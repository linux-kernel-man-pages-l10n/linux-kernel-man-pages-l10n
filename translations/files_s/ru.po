# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Alexander Golubev <fatzer2@gmail.com>, 2018
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2011,2014-2016
# Hotellook, 2014
# Nikita <zxcvbnm3230@mail.ru>, 2014
# Spiros Georgaras <sng@hellug.gr>, 2016
# Vladislav <ivladislavefimov@gmail.com>, 2015
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019
# Yuri Kozlov <yuray@komyakino.ru>, 2013
# Иван Павлов <pavia00@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:26+0300\n"
"PO-Revision-Date: 2019-08-26 06:21+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/kruvalig/man-pages/language/"
"ru/)\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"

#. type: TH
#: man-pages/man4/smartpqi.4:8
#, no-wrap
msgid "SMARTPQI"
msgstr "SMARTPQI"

#. type: TH
#: man-pages/man4/smartpqi.4:8
#, no-wrap
msgid "2017-10-19"
msgstr "2017-10-19"

#. type: TH
#: man-pages/man4/smartpqi.4:8
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/smartpqi.4:8
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/smartpqi.4:9
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/smartpqi.4:11
msgid "smartpqi - Microsemi Smart Family SCSI driver"
msgstr "smartpqi - драйвер Microsemi Smart Family SCSI"

#. type: SH
#: man-pages/man4/smartpqi.4:11
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man4/smartpqi.4:17
msgid ""
"[B<disable_device_id_wildcards=>{B<0>|B<1>}] [B<disable_heartbeat=>{B<0>|"
"B<1>}] [B<disable_ctrl_shutdown=>{B<0>|B<1>}] [B<lockup_action=>{B<none>|"
"B<reboot>|B<panic>}]"
msgstr ""
"[B<disable_device_id_wildcards=>{B<0>|B<1>}] [B<disable_heartbeat=>{B<0>|"
"B<1>}] [B<disable_ctrl_shutdown=>{B<0>|B<1>}] [B<lockup_action=>{B<none>|"
"B<reboot>|B<panic>}]"

#. type: SH
#: man-pages/man4/smartpqi.4:18
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/smartpqi.4:21
msgid "B<smartpqi> is a SCSI driver for Microsemi Smart Family controllers."
msgstr ""
"B<smartpqi> — это драйвер SCSI для контроллеров Microsemi Smart Family."

#. type: SS
#: man-pages/man4/smartpqi.4:21
#, no-wrap
msgid "Supported \\f[BI]ioctl\\fB\\/() operations"
msgstr "Поддерживаемые операции \\f[BI]ioctl\\fB\\/()"

#. type: Plain text
#: man-pages/man4/smartpqi.4:36
msgid ""
"For compatibility with applications written for the B<cciss>(4)  and "
"B<hpsa>(4)  drivers, many, but not all of the B<ioctl>(2)  operations "
"supported by the B<hpsa> driver are also supported by the B<smartpqi> "
"driver.  The data structures used by these operations are described in the "
"Linux kernel source file I<include/linux/cciss_ioctl.h>."
msgstr ""
"Для совместимости с приложениями, написанными для драйверов B<cciss>(4) и "
"B<hpsa>(4), многие операции B<ioctl>(2), поддерживаемые в драйвере B<hpsa>, "
"также поддерживаются драйвером B<smartpqi>(4) (но не все). Структуры данных, "
"используемые в операциях, описаны в файле исходного кода ядра Linux "
"I<include/linux/cciss_ioctl.h>."

#. type: TP
#: man-pages/man4/smartpqi.4:36
#, no-wrap
msgid "B<CCISS_DEREGDISK>, B<CCISS_REGNEWDISK>, B<CCISS_REGNEWD>"
msgstr "B<CCISS_DEREGDISK>, B<CCISS_REGNEWDISK>, B<CCISS_REGNEWD>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:46
msgid ""
"These operations all do exactly the same thing, which is to cause the driver "
"to re-scan for new devices.  This does exactly the same thing as writing to "
"the B<smartpqi>-specific host I<rescan> attribute."
msgstr ""
"Это операции выполняют ту же работу — заставляют драйвер искать новые "
"устройства. Это тоже самое, как если выполнить запись в атрибут I<rescan> "
"конкретного узла B<smartpqi>."

#. type: TP
#: man-pages/man4/smartpqi.4:46
#, no-wrap
msgid "B<CCISS_GETPCIINFO>"
msgstr "B<CCISS_GETPCIINFO>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:50
msgid ""
"This operation Returns the PCI domain, bus, device and function and \"board "
"ID\" (PCI subsystem ID)."
msgstr ""
"Возвращает домен PCI, шину, устройство, функцию и «board ID» (ID подсистемы "
"PCI)."

#. type: TP
#: man-pages/man4/smartpqi.4:50
#, no-wrap
msgid "B<CCISS_GETDRIVVER>"
msgstr "B<CCISS_GETDRIVVER>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:53
msgid "This operation returns the driver version in four bytes, encoded as:"
msgstr "Возвращает версию драйвера в виде четырёх байт в формате:"

#. type: Plain text
#: man-pages/man4/smartpqi.4:58
#, no-wrap
msgid ""
"(major_version E<lt>E<lt> 28) | (minor_version E<lt>E<lt> 24) |\n"
"        (release E<lt>E<lt> 16) | revision\n"
msgstr ""
"(основная_версия E<lt>E<lt> 28) | (дополнительная_версия E<lt>E<lt> 24) |\n"
"        (выпуск E<lt>E<lt> 16) | редакция\n"

#. type: TP
#: man-pages/man4/smartpqi.4:60
#, no-wrap
msgid "B<CCISS_PASSTHRU>"
msgstr "B<CCISS_PASSTHRU>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:63
msgid "Allows BMIC and CISS commands to be passed through to the controller."
msgstr "Позволить передачу команд BMIC и CISS напрямую в контроллер."

#. type: SS
#: man-pages/man4/smartpqi.4:63
#, no-wrap
msgid "Boot options"
msgstr "Параметры загрузки"

#. type: TP
#: man-pages/man4/smartpqi.4:64
#, no-wrap
msgid "B<disable_device_id_wildcards=>{B<0>|B<1>}"
msgstr "B<disable_device_id_wildcards=>{B<0>|B<1>}"

#. type: Plain text
#: man-pages/man4/smartpqi.4:68
msgid "Disables support for device ID wildcards.  The default value is 0."
msgstr ""
"Отключить поддержку, совпадающих с шаблоном идентификаторов устройств. "
"Значение по умолчанию равно 0."

#. type: TP
#: man-pages/man4/smartpqi.4:68
#, no-wrap
msgid "B<disable_heartbeat=>{B<0>|B<1>}"
msgstr "B<disable_heartbeat=>{B<0>|B<1>}"

#. type: Plain text
#: man-pages/man4/smartpqi.4:73
msgid ""
"Disables support for the controller's heartbeat check.  This parameter is "
"used for debugging purposes.  The default value is 0, leaving the "
"controller's heartbeat check active."
msgstr ""
"Отключить поддержку сторожевой проверки (heartbeat check). Этот параметр "
"используется для отладки. Значение по умолчанию равно 0, что оставляет "
"активной поддержку сторожевой проверки."

#. type: TP
#: man-pages/man4/smartpqi.4:73
#, no-wrap
msgid "B<disable_ctrl_shutdown=>{B<0>|B<1>}"
msgstr "B<disable_ctrl_shutdown=>{B<0>|B<1>}"

#. type: Plain text
#: man-pages/man4/smartpqi.4:78
msgid ""
"Disables support for shutting down the controller in the event of a "
"controller lockup.  The default value is 0."
msgstr ""
"Отключить поддержку по выключению контроллера в ответ на события его "
"блокировки. Значение по умолчанию равно 0."

#. type: TP
#: man-pages/man4/smartpqi.4:78
#, no-wrap
msgid "B<lockup_action=>{B<none>|B<reboot>|B<panic>}"
msgstr "B<lockup_action=>{B<none>|B<reboot>|B<panic>}"

#. type: Plain text
#: man-pages/man4/smartpqi.4:84
msgid ""
"Specifies the action the driver takes when a controller lockup is detected.  "
"The default action is B<none>."
msgstr ""
"Задаёт действие, которое выполняет драйвер, когда обнаруживается блокировка "
"контроллера. Действие по умолчанию равно B<none>."

#. type: tbl table
#: man-pages/man4/smartpqi.4:88
#, no-wrap
msgid "parameter"
msgstr "параметр"

#. type: tbl table
#: man-pages/man4/smartpqi.4:88
#, no-wrap
msgid "action"
msgstr "действие"

#. type: tbl table
#: man-pages/man4/smartpqi.4:89
#, no-wrap
msgid "B<none>"
msgstr "B<none>"

#. type: tbl table
#: man-pages/man4/smartpqi.4:89
#, no-wrap
msgid "take controller offline only"
msgstr "отключить только контроллер (offline)"

#. type: tbl table
#: man-pages/man4/smartpqi.4:90
#, no-wrap
msgid "B<reboot>"
msgstr "B<reboot>"

#. type: tbl table
#: man-pages/man4/smartpqi.4:90
#, no-wrap
msgid "reboot the system"
msgstr "перезагрузить систему"

#. type: tbl table
#: man-pages/man4/smartpqi.4:91
#, no-wrap
msgid "B<panic>"
msgstr "B<panic>"

#. type: tbl table
#: man-pages/man4/smartpqi.4:91
#, no-wrap
msgid "panic the system"
msgstr "вызвать панику системы"

#. type: SH
#: man-pages/man4/smartpqi.4:93
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: SS
#: man-pages/man4/smartpqi.4:94
#, no-wrap
msgid "Device nodes"
msgstr "Узлы устройства"

#. type: Plain text
#: man-pages/man4/smartpqi.4:107
msgid ""
"Logical drives are accessed via the SCSI disk driver (I<sd>), tape drives "
"via the SCSI tape driver (I<st>), and the RAID controller via the SCSI "
"generic driver (I<sg>), with device nodes named I</dev/sd>*, I</dev/st>*, "
"and I</dev/sg>*, respectively."
msgstr ""
"Логические диски доступны через драйвер дисков SCSI (I<sd>), ленточные "
"устройства — через драйвер лент SCSI (I<st>), а контроллеры RAID — через "
"общий драйвер SCSI (I<sg>); имена узлов устройств называются I</dev/sd>*, I</"
"dev/st>* и I</dev/sg>*, соответственно."

#. type: SS
#: man-pages/man4/smartpqi.4:107
#, no-wrap
msgid "SmartPQI-specific host attribute files in \\f[BI]/sys\\fB"
msgstr "Файлы в \\f[BI]/sys\\fB, относящиеся к атрибутам узла SmartPQI"

#. type: TP
#: man-pages/man4/smartpqi.4:108
#, no-wrap
msgid "I</sys/class/scsi_host/host>*I</rescan>"
msgstr "I</sys/class/scsi_host/host>*I</rescan>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:121
msgid ""
"The host I<rescan> attribute is a write-only attribute.  Writing to this "
"attribute will cause the driver to scan for new, changed, or removed devices "
"(e.g., hot-plugged tape drives, or newly configured or deleted logical "
"drives) and notify the SCSI mid-layer of any changes detected.  Usually this "
"action is triggered automatically by configuration changes, so the user "
"should not normally have to write to this file.  Doing so may be useful when "
"hot-plugging devices such as tape drives or entire storage boxes containing "
"pre-configured logical drives."
msgstr ""
"Атрибут I<rescan> узла только для записи. Факт записи заставляет драйвер "
"выполнить сканирование на предмет появления новых, изменившихся или "
"удалённых устройств (например, подключаемых на ходу ленточных накопителей "
"или только что настроенных или удалённых логических дисков и т. д.) и "
"уведомить прослойку (midlayer) SCSI об обнаруженных изменениях. Обычно, "
"пересканирование выполняется автоматически при изменении состава "
"оборудования, поэтому, обычно, пользователь не должен выполнять запись в "
"этот файл. Такое действие может быть полезным при подключении на ходу "
"устройств, таких как ленточные накопители или хранилища с уже настроенными "
"логическими дисками."

#. type: TP
#: man-pages/man4/smartpqi.4:121
#, no-wrap
msgid "I</sys/class/scsi_host/host>*I</version>"
msgstr "I</sys/class/scsi_host/host>*I</version>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:128
msgid ""
"The host I<version> attribute is a read-only attribute.  This attribute "
"contains the driver version and the controller firmware version."
msgstr ""
"Атрибут узла I<version> доступен только для чтения. Он содержит версию "
"драйвера и микропрограммы контроллера."

#. type: Plain text
#: man-pages/man4/smartpqi.4:130 man-pages/man4/smartpqi.4:170
#: man-pages/man4/smartpqi.4:186 man-pages/man4/smartpqi.4:208
msgid "For example:"
msgstr "Пример:"

#. type: Plain text
#: man-pages/man4/smartpqi.4:137
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_host/host1/version>\n"
"driver: 1.1.2-126\n"
"firmware: 1.29-112\n"
msgstr ""
"$ B<cat /sys/class/scsi_host/host1/version>\n"
"driver: 1.1.2-126\n"
"firmware: 1.29-112\n"

#. type: TP
#: man-pages/man4/smartpqi.4:139
#, no-wrap
msgid "I</sys/class/scsi_host/host>*I</lockup_action>"
msgstr "I</sys/class/scsi_host/host>*I</lockup_action>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:152
msgid ""
"The host I<lockup_action> attribute is a read/write attribute.  This "
"attribute will cause the driver to perform a specific action in the unlikely "
"event that a controller lockup has been detected.  See B<OPTIONS> above for "
"an explanation of the I<lockup_action> values."
msgstr ""
"Атрибут узла I<lockup_action> доступен на чтение/запись. Он заставляет "
"драйвер выполнять определённое действие при маловероятном событии — "
"обнаружении блокировки контроллера. Смотрите в разделе B<ПАРАМЕТРЫ> описание "
"значений I<lockup_action>."

#. type: SS
#: man-pages/man4/smartpqi.4:152
#, no-wrap
msgid "SmartPQI-specific disk attribute files in \\f[BI]/sys\\fB"
msgstr "Файлы в \\f[BI]/sys\\fB, относящиеся к атрибутам диска SmartPQI"

#. type: Plain text
#: man-pages/man4/smartpqi.4:162
msgid ""
"In the file specifications below, I<c> stands for the number of the "
"appropriate SCSI controller, I<b> is the bus number, I<t> the target number, "
"and I<l> is the logical unit number (LUN)."
msgstr ""
"В определениях файла ниже символ I<c> означает номер соответствующего "
"контроллера SCSI, I<b> — номер шины, I<t> — номер цели, I<l> — номер "
"логического элемента (LUN)."

#. type: TP
#: man-pages/man4/smartpqi.4:162
#, no-wrap
msgid "I</sys/class/scsi_disk/>cI<:>bI<:>tI<:>lI</device/raid_level>"
msgstr "I</sys/class/scsi_disk/>cI<:>bI<:>tI<:>lI</device/raid_level>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:168
msgid ""
"The I<raid_level> attribute is read-only.  This attribute contains the RAID "
"level of each logical drive."
msgstr ""
"Атрибут I<raid_level> доступен только для чтения. В данном атрибуте хранится "
"уровень RAID каждого логического диска."

#. type: Plain text
#: man-pages/man4/smartpqi.4:176
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_disk/4:0:0:0/device/raid_level>\n"
"RAID 0\n"
msgstr ""
"$ B<cat /sys/class/scsi_disk/4:0:0:0/device/raid_level>\n"
"RAID 0\n"

#. type: TP
#: man-pages/man4/smartpqi.4:178
#, no-wrap
msgid "I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/sas_address>"
msgstr "I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/sas_address>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:184
msgid ""
"The I<sas_address> attribute is read-only.  This attribute contains the "
"unique identifier of the disk."
msgstr ""
"Атрибут I<sas_address> доступен только для чтения. В данном атрибуте "
"хранится уникальный идентификатор диска."

#. type: Plain text
#: man-pages/man4/smartpqi.4:192
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_disk/1:0:3:0/device/sas_address>\n"
"0x5001173d028543a2\n"
msgstr ""
"$ B<cat /sys/class/scsi_disk/1:0:3:0/device/sas_address>\n"
"0x5001173d028543a2\n"

#. type: TP
#: man-pages/man4/smartpqi.4:194
#, no-wrap
msgid "I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/ssd_smart_path_enabled>"
msgstr "I</sys/class/scsi_disk/c>:I<b>:I<t>:I<l/device/ssd_smart_path_enabled>"

#. type: Plain text
#: man-pages/man4/smartpqi.4:206
msgid ""
"The I<ssd_smart_path_enabled> attribute is read-only.  This attribute is for "
"ioaccel-enabled volumes.  (Ioaccel is an alternative driver submission path "
"that allows the driver to send I/O requests directly to backend SCSI "
"devices, bypassing the controller firmware.  This results in an increase in "
"performance.  This method is used for HBA disks and for logical volumes "
"comprised of SSDs.)  Contains 1 if ioaccel is enabled for the volume and 0 "
"otherwise."
msgstr ""
"Атрибут I<ssd_smart_path_enabled> доступен только для чтения. Он имеется у "
"томов с включённым ioaccel (ioaccel — альтернативный путь доступа для "
"драйвера, который позволяет драйверу посылать запросы ввода-вывода напрямую "
"устройству SCSI минуя микропрограмму контроллера. Это увеличивает "
"производительность. Данный метод используется для дисков HBA и логических "
"томов на SSD). Содержит 1, если ioaccel включён для тома и 0 в противном "
"случае."

#. type: Plain text
#: man-pages/man4/smartpqi.4:214
#, no-wrap
msgid ""
"$ B<cat /sys/class/scsi_disk/1:0:3:0/device/ssd_smart_path_enabled>\n"
"0\n"
msgstr ""
"$ B<cat /sys/class/scsi_disk/1:0:3:0/device/ssd_smart_path_enabled>\n"
"0\n"

#. type: SH
#: man-pages/man4/smartpqi.4:216
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man4/smartpqi.4:220
msgid "The B<smarpqi> driver was added in Linux 4.9."
msgstr "Драйвер B<smarpqi>()  впервые появился в Linux версии 4.9."

#. type: SH
#: man-pages/man4/smartpqi.4:220
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: SS
#: man-pages/man4/smartpqi.4:221
#, no-wrap
msgid "Configuration"
msgstr "Настройка"

#. type: Plain text
#: man-pages/man4/smartpqi.4:227
msgid ""
"To configure a Microsemi Smart Family controller, refer to the User Guide "
"for the controller, which can be found by searching for the specific "
"controller at E<.UR https://storage.microsemi.com/> E<.UE .>"
msgstr ""
"Описание настройки контроллера Microsemi Smart Family смотрите в руководстве "
"пользователя на контроллер, которое можно найти поискав нужный контроллер на "
"странице E<.UR https://storage.microsemi.com/> E<.UE .>"

#. type: SH
#: man-pages/man4/smartpqi.4:227
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/smartpqi.4:232
msgid "B<cciss>(4), B<hpsa>(4), B<sd>(4), B<st>(4)"
msgstr "B<cciss>(4), B<hpsa>(4), B<sd>(4), B<st>(4)"

#. type: Plain text
#: man-pages/man4/smartpqi.4:234
msgid ""
"I<Documentation/ABI/testing/sysfs-bus-pci-devices-cciss> in the Linux kernel "
"source tree."
msgstr ""
"Файл I<Documentation/ABI/testing/sysfs-bus-pci-devices-cciss> в дереве "
"исходного кода ядра Linux."

#. type: TH
#: man-pages/man4/sk98lin.4:27
#, no-wrap
msgid "SK98LIN"
msgstr "SK98LIN"

#. type: TH
#: man-pages/man4/sk98lin.4:27
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man4/sk98lin.4:30
msgid "sk98lin - Marvell/SysKonnect Gigabit Ethernet driver v6.21"
msgstr "sk98lin - драйвер Marvell/SysKonnect Gigabit Ethernet, версия 6.21"

#. type: Plain text
#: man-pages/man4/sk98lin.4:62
msgid ""
"B<insmod sk98lin.o> [B<Speed_A=>I<i,j,...>] [B<Speed_B=>I<i,j,...>] "
"[B<AutoNeg_A=>I<i,j,...>] [B<AutoNeg_B=>I<i,j,...>] [B<DupCap_A=>I<i,j,...>] "
"[B<DupCap_B=>I<i,j,...>] [B<FlowCtrl_A=>I<i,j,...>] [B<FlowCtrl_B=>I<i,j,..."
">] [B<Role_A=>I<i,j,...>] [B<Role_B=>I<i,j,...>] [B<ConType=>I<i,j,...>] "
"[B<Moderation=>I<i,j,...>] [B<IntsPerSec=>I<i,j,...>] [B<PrefPort=>I<i,j,..."
">] [B<RlmtMode=>I<i,j,...>]"
msgstr ""
"B<insmod sk98lin.o> [B<Speed_A=>I<i,j,...>] [B<Speed_B=>I<i,j,...>] "
"[B<AutoNeg_A=>I<i,j,...>] [B<AutoNeg_B=>I<i,j,...>] [B<DupCap_A=>I<i,j,...>] "
"[B<DupCap_B=>I<i,j,...>] [B<FlowCtrl_A=>I<i,j,...>] [B<FlowCtrl_B=>I<i,j,..."
">] [B<Role_A=>I<i,j,...>] [B<Role_B=>I<i,j,...>] [B<ConType=>I<i,j,...>] "
"[B<Moderation=>I<i,j,...>] [B<IntsPerSec=>I<i,j,...>] [B<PrefPort=>I<i,j,..."
">] [B<RlmtMode=>I<i,j,...>]"

#. type: Plain text
#: man-pages/man4/sk98lin.4:67
msgid ""
"B<Note>: This obsolete driver was removed from the kernel in version 2.6.26."
msgstr ""
"B<Замечание>: Данный устаревший драйвер был удалён из ядра версии 2.6.26."

#. type: Plain text
#: man-pages/man4/sk98lin.4:74
msgid ""
"B<sk98lin> is the Gigabit Ethernet driver for Marvell and SysKonnect network "
"adapter cards.  It supports SysKonnect SK-98xx/SK-95xx compliant Gigabit "
"Ethernet Adapter and any Yukon compliant chipset."
msgstr ""
"B<sk98lin> — это драйвер Gigabit Ethernet для сетевых адаптеров Marvell и "
"SysKonnect. Он поддерживает SysKonnect SK-98xx/SK-95xx-совместимые адаптеры "
"Gigabit Ethernet и любые карты с Yukon-совместимым чипсетом."

#. type: Plain text
#: man-pages/man4/sk98lin.4:81
msgid ""
"When loading the driver using insmod, parameters for the network adapter "
"cards might be stated as a sequence of comma separated commands.  If for "
"instance two network adapters are installed and AutoNegotiation on Port A of "
"the first adapter should be ON, but on the Port A of the second adapter "
"switched OFF, one must enter:"
msgstr ""
"При загрузке драйвера с помощью insmod, параметры сетевого адаптера можно "
"указать в командной строке через запятую. Если, например, установлено два "
"сетевых адаптера и AutoNegotiation на порту A первого адаптера нужно "
"включить, а на порту A второго адаптера — выключить, то введите следующее:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:83
#, no-wrap
msgid "   insmod sk98lin.o AutoNeg_A=On,Off\n"
msgstr "   insmod sk98lin.o AutoNeg_A=On,Off\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:98
msgid ""
"After B<sk98lin> is bound to one or more adapter cards and the I</proc> "
"filesystem is mounted on your system, a dedicated statistics file will be "
"created in the folder I</proc/net/sk98lin> for all ports of the installed "
"network adapter cards.  Those files are named I<eth[x]>, where I<x> is the "
"number of the interface that has been assigned to a dedicated port by the "
"system."
msgstr ""
"После того как B<sk98lin> подхватит один или более адаптер и будет "
"смонтирована файловая система I</proc>, будут созданы отдельные файлы "
"статистики в каталоге I</proc/net/sk98lin> для каждого  порта установленных "
"сетевых адаптеров. Эти файлы будут называться I<eth[x]>, где I<x> — номер "
"интерфейса, который был назначен каждому порту в системе."

#. type: Plain text
#: man-pages/man4/sk98lin.4:108
msgid ""
"If loading is finished, any desired IP address can be assigned to the "
"respective I<eth[x]> interface using the B<ifconfig>(8)  command.  This "
"causes the adapter to connect to the Ethernet and to display a status "
"message on the console saying \"ethx: network connection up using port y\" "
"followed by the configured or detected connection parameters."
msgstr ""
"После завершения загрузки каждому I<eth[x]> может быть назначен желаемый IP-"
"адрес с помощью команды B<ifconfig>(8). Это заставит адаптер подключиться к "
"Ethernet и вывести сообщение на консоль: \"ethx: network connection up using "
"port y\" с настроенными или определёнными параметрами подключения."

#. type: Plain text
#: man-pages/man4/sk98lin.4:124
msgid ""
"The B<sk98lin> also supports large frames (also called jumbo frames).  Using "
"jumbo frames can improve throughput tremendously when transferring large "
"amounts of data.  To enable large frames, the MTU (maximum transfer unit) "
"size for an interface is to be set to a high value.  The default MTU size is "
"1500 and can be changed up to 9000 (bytes).  Setting the MTU size can be "
"done when assigning the IP address to the interface or later by using the "
"B<ifconfig>(8)  command with the mtu parameter.  If for instance eth0 needs "
"an IP address and a large frame MTU size, the following two commands might "
"be used:"
msgstr ""
"Драйвер B<sk98lin> также поддерживает большие фреймы (также называемые jumbo "
"фреймами). С помощью jumbo-фреймов можно очень сильно увеличить пропускную "
"способность при передаче больших объёмов данных. Чтобы включить большие "
"фреймы, нужно на интерфейсе установить большое значение MTU (максимальная "
"единица передачи). Значение MTU по умолчанию равно 1500 и может быть "
"увеличено до 9000 (байт). Установку размера MTU можно выполнить при "
"назначении IP-адреса интерфейсу или позднее с помощью команды B<ifconfig>(8) "
"с параметром mtu. Если, например, eth0 нужно назначить IP-адрес и большой "
"размер фрейма MTU, то это можно сделать с помощью следующих двух команд:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:127
#, no-wrap
msgid ""
"    ifconfig eth0 10.1.1.1\n"
"    ifconfig eth0 mtu 9000\n"
msgstr ""
"    ifconfig eth0 10.1.1.1\n"
"    ifconfig eth0 mtu 9000\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:129
msgid "Those two commands might even be combined into one:"
msgstr "Эти две команды можно объединить в одну:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:131
#, no-wrap
msgid "    ifconfig eth0 10.1.1.1 mtu 9000\n"
msgstr "    ifconfig eth0 10.1.1.1 mtu 9000\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:144
msgid ""
"Note that large frames can be used only if permitted by your network "
"infrastructure.  This means, that any switch being used in your Ethernet "
"must also support large frames.  Quite some switches support large frames, "
"but need to be configured to do so.  Most of the times, their default "
"setting is to support only standard frames with an MTU size of 1500 "
"(bytes).  In addition to the switches inside the network, all network "
"adapters that are to be used must also be enabled regarding jumbo frames.  "
"If an adapter is not set to receive large frames, it will simply drop them."
msgstr ""
"Заметим, что большие фреймы можно использовать только, если эта позволяет "
"ваша сетевая инфраструктура. Это означает, что все коммутаторы сети "
"Ethernet  также должны поддерживать большие фреймы. Довольно много "
"коммутаторов поддерживают большие фреймы, но для этого их нужно настроить. В "
"большинстве случаев, в настройках по умолчанию используются только "
"стандартные фреймы с размером MTU равным 1500 (байт). Помимо коммутатором "
"сети, все используемые сетевые адаптеры также должны принимать jumbo-фреймы. "
"Если адаптер не настроен для приёма больших фреймов, то он их просто "
"отбрасывает."

#. type: Plain text
#: man-pages/man4/sk98lin.4:148
msgid ""
"Switching back to the standard Ethernet frame size can be done by using the "
"B<ifconfig>(8)  command again:"
msgstr ""
"Для переключения обратно к стандартному размеру фрейма Ethernet можно "
"использовать такую команду B<ifconfig>(8):"

#. type: Plain text
#: man-pages/man4/sk98lin.4:150
#, no-wrap
msgid "    ifconfig eth0 mtu 1500\n"
msgstr "    ifconfig eth0 mtu 1500\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:156
msgid ""
"The Marvell/SysKonnect Gigabit Ethernet driver for Linux is able to support "
"VLAN and Link Aggregation according to IEEE standards 802.1, 802.1q, and "
"802.3ad.  Those features are available only after installation of open "
"source modules which can be found on the Internet:"
msgstr ""
"Драйвер Marvell/SysKonnect Gigabit Ethernet для Linux поддерживает VLAN и "
"объединение каналов в соответствии со стандартами IEEE 802.1, 802.1q и "
"802.3ad. Эти свойства доступны только после установки открытых модулей, "
"которые можно найти в Интернет:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:161
msgid ""
"I<VLAN>: E<.UR http://www.candelatech.com\\:/~greear\\:/vlan.html> E<.UE>"
msgstr ""
"I<VLAN>: E<.UR http://www.candelatech.com\\:/~greear\\:/vlan.html> E<.UE>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:167
msgid "I<Link> I<Aggregation>: E<.UR http://www.st.rim.or.jp\\:/~yumo> E<.UE>"
msgstr "I<Link> I<Aggregation>: E<.UR http://www.st.rim.or.jp\\:/~yumo> E<.UE>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:171
msgid ""
"Note that Marvell/SysKonnect does not offer any support for these open "
"source modules and does not take the responsibility for any kind of failures "
"or problems arising when using these modules."
msgstr ""
"Заметим, что Marvell/SysKonnect не предлагает поддержку этих открытых "
"модулей и не несёт ответственности при отказах и проблемах, связанных с "
"использованием этих модулей."

#. type: SS
#: man-pages/man4/sk98lin.4:171
#, no-wrap
msgid "Parameters"
msgstr "Параметры"

#. type: TP
#: man-pages/man4/sk98lin.4:172
#, no-wrap
msgid "B<Speed_A=>I<i,j,...>"
msgstr "B<Speed_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:189
msgid ""
"This parameter is used to set the speed capabilities of port A of an adapter "
"card.  It is valid only for Yukon copper adapters.  Possible values are: "
"I<10>, I<100>, I<1000>, or I<Auto>; I<Auto> is the default.  Usually, the "
"speed is negotiated between the two ports during link establishment.  If "
"this fails, a port can be forced to a specific setting with this parameter."
msgstr ""
"Этот параметр используется для задания скорости порта A. Работает только для "
"адаптеров Yukon с медным интерфейсом. Возможные значения: I<10>, I<100>, "
"I<1000> или I<Auto>; по умолчанию задано I<Auto>. Обычно, скорость "
"согласуется между двумя портами во время установки связи. Если процедура "
"завершается неудачно, то порт можно принудительно перевести на нужную "
"скорость с помощью этого параметра."

#. type: TP
#: man-pages/man4/sk98lin.4:189
#, no-wrap
msgid "B<Speed_B=>I<i,j,...>"
msgstr "B<Speed_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:206
msgid ""
"This parameter is used to set the speed capabilities of port B of an adapter "
"card.  It is valid only for Yukon copper adapters.  Possible values are: "
"I<10>, I<100>, I<1000>, or I<Auto>; I<Auto> is the default.  Usually, the "
"speed is negotiated between the two ports during link establishment.  If "
"this fails, a port can be forced to a specific setting with this parameter."
msgstr ""
"Этот параметр используется для задания скорости порта B. Работает только для "
"адаптеров Yukon с медным интерфейсом. Возможные значения: I<10>, I<100>, "
"I<1000> или I<Auto>; по умолчанию задано I<Auto>. Обычно, скорость "
"согласуется между двумя портами во время установки связи. Если процедура "
"завершается неудачно, то порт можно принудительно перевести на нужную "
"скорость с помощью этого параметра."

#. type: TP
#: man-pages/man4/sk98lin.4:206
#, no-wrap
msgid "B<AutoNeg_A=>I<i,j,...>"
msgstr "B<AutoNeg_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:220
msgid ""
"Enables or disables the use of autonegotiation of port A of an adapter "
"card.  Possible values are: I<On>, I<Off>, or I<Sense>; I<On> is the "
"default.  The I<Sense> mode automatically detects whether the link partner "
"supports auto-negotiation or not."
msgstr ""
"Включение или выключение автосогласования на порту A. Возможные значения: "
"I<On>, I<Off> или I<Sense>; по умолчанию задано I<On>. В режиме I<Sense> "
"выполняется автоматическое обнаружение поддержки автосогласования у партнёра "
"по связи."

#. type: TP
#: man-pages/man4/sk98lin.4:220
#, no-wrap
msgid "B<AutoNeg_B=>I<i,j,...>"
msgstr "B<AutoNeg_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:234
msgid ""
"Enables or disables the use of autonegotiation of port B of an adapter "
"card.  Possible values are: I<On>, I<Off>, or I<Sense>; I<On> is the "
"default.  The I<Sense> mode automatically detects whether the link partner "
"supports auto-negotiation or not."
msgstr ""
"Включение или выключение автосогласования на порту B. Возможные значения: "
"I<On>, I<Off> или I<Sense>; по умолчанию задано I<On>. В режиме I<Sense> "
"выполняется автоматическое обнаружение поддержки автосогласования у партнёра "
"по связи."

#. type: TP
#: man-pages/man4/sk98lin.4:234
#, no-wrap
msgid "B<DupCap_A=>I<i,j,...>"
msgstr "B<DupCap_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:264
msgid ""
"This parameter indicates the duplex mode to be used for port A of an adapter "
"card.  Possible values are: I<Half>, I<Full>, or I<Both>; I<Both> is the "
"default.  This parameter is relevant only if AutoNeg_A of port A is not set "
"to I<Sense>.  If AutoNeg_A is set to I<On>, all three values of DupCap_A "
"( I<Half>, I<Full> or I<Both>)  might be stated.  If AutoNeg_A is set to "
"I<Off>, only DupCap_A values I<Full> and I<Half> are allowed.  This DupCap_A "
"parameter is useful if your link partner does not support all possible "
"duplex combinations."
msgstr ""
"Этот параметр используется для задания режима дуплекса на порту A. Возможные "
"значения: I<Half>, I<Full> или I<Both>; по умолчанию задано I<Both>. Этот "
"параметр учитывается только, если AutoNeg_A для порта A не установлено в "
"I<Sense>. Если значение AutoNeg_A равно I<On>, то может быть указано любое "
"из трёх значений DupCap_A ( I<Half>, I<Full> или I<Both>). Если AutoNeg_A "
"равно I<Off>, то значениями DupCap_A могут быть только I<Full> и I<Half>. "
"Параметр DupCap_A полезен, если партнёр по связи не поддерживает все "
"возможные комбинации дуплекса."

#. type: TP
#: man-pages/man4/sk98lin.4:264
#, no-wrap
msgid "B<DupCap_B=>I<i,j,...>"
msgstr "B<DupCap_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:294
msgid ""
"This parameter indicates the duplex mode to be used for port B of an adapter "
"card.  Possible values are: I<Half>, I<Full>, or I<Both>; I<Both> is the "
"default.  This parameter is relevant only if AutoNeg_B of port B is not set "
"to I<Sense>.  If AutoNeg_B is set to I<On>, all three values of DupCap_B "
"( I<Half>, I<Full> or I<Both>)  might be stated.  If AutoNeg_B is set to "
"I<Off>, only DupCap_B values I<Full> and I<Half> are allowed.  This DupCap_B "
"parameter is useful if your link partner does not support all possible "
"duplex combinations."
msgstr ""
"Этот параметр используется для задания режима дуплекса на порту B. Возможные "
"значения: I<Half>, I<Full> или I<Both>; по умолчанию задано I<Both>. Этот "
"параметр учитывается только, если AutoNeg_B для порта B не установлено в "
"I<Sense>. Если значение AutoNeg_B равно I<On>, то может быть указано любое "
"из трёх значений  DupCap_B ( I<Half>, I<Full> или I<Both>). Если AutoNeg_B "
"равно I<Off>, то значениями DupCap_B могут быть только I<Full> и I<Half>. "
"Параметр DupCap_B полезен, если партнёр по связи не поддерживает все "
"возможные комбинации дуплекса."

#. type: TP
#: man-pages/man4/sk98lin.4:294
#, no-wrap
msgid "B<FlowCtrl_A=>I<i,j,...>"
msgstr "B<FlowCtrl_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:307 man-pages/man4/sk98lin.4:339
msgid ""
"This parameter can be used to set the flow control capabilities the port "
"reports during auto-negotiation.  Possible values are: I<Sym>, I<SymOrRem>, "
"I<LocSend>, or I<None>; I<SymOrRem> is the default.  The different modes "
"have the following meaning:"
msgstr ""
"Этот параметр используется для задания свойств управления потоком, которые "
"анонсируются портом при автосогласовании. Возможные значения: I<Sym>, "
"I<SymOrRem>, I<LocSend> или I<None>; по умолчанию задано I<SymOrRem>. "
"Назначение режимов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:311 man-pages/man4/sk98lin.4:343
#, no-wrap
msgid ""
"I<Sym>\n"
"= Symmetric\n"
" both link partners are allowed to send PAUSE frames\n"
msgstr ""
"I<Sym>\n"
"= Symmetric\n"
" Оба партнёра по связи позволяют посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:315 man-pages/man4/sk98lin.4:347
#, no-wrap
msgid ""
"I<SymOrRem>\n"
"= SymmetricOrRemote\n"
" both or only remote partner are allowed to send PAUSE frames\n"
msgstr ""
"I<SymOrRem>\n"
"= SymmetricOrRemote\n"
" Оба или только один партнёр по связи позволяет посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:319 man-pages/man4/sk98lin.4:351
#, no-wrap
msgid ""
"I<LocSend>\n"
"= LocalSend\n"
" only local link partner is allowed to send PAUSE frames\n"
msgstr ""
"I<LocSend>\n"
"= LocalSend\n"
" Только локальная связь партнёра позволяет посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:323 man-pages/man4/sk98lin.4:355
#, no-wrap
msgid ""
"I<None>\n"
"= None\n"
" no link partner is allowed to send PAUSE frames\n"
msgstr ""
"I<None>\n"
"= None\n"
"  Партнёры по связи не позволяют посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:326
msgid "Note that this parameter is ignored if AutoNeg_A is set to I<Off>."
msgstr ""
"Заметим, что этот параметр игнорируется, если значение AutoNeg_A равно "
"I<Off>."

#. type: TP
#: man-pages/man4/sk98lin.4:326
#, no-wrap
msgid "B<FlowCtrl_B=>I<i,j,...>"
msgstr "B<FlowCtrl_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:359
msgid "Note that this parameter is ignored if AutoNeg_B is set to I<Off>."
msgstr ""
"Заметим, что этот параметр игнорируется, если значение AutoNeg_B равно "
"I<Off>."

#. type: TP
#: man-pages/man4/sk98lin.4:359
#, no-wrap
msgid "B<Role_A=>I<i,j,...>"
msgstr "B<Role_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:375
msgid ""
"This parameter is valid only for 1000Base-T adapter cards.  For two 1000Base-"
"T ports to communicate, one must take the role of the master (providing "
"timing information), while the other must be the slave.  Possible values "
"are: I<Auto>, I<Master>, or I<Slave>; I<Auto> is the default.  Usually, the "
"role of a port is negotiated between two ports during link establishment, "
"but if that fails the port A of an adapter card can be forced to a specific "
"setting with this parameter."
msgstr ""
"Этот параметр доступен только для адаптеров 1000Base-T. При организации "
"связи между двумя портами 1000Base-T один должен играть роль основного "
"(предоставлять синхронизацию), другой — подчинённого. Возможные значения: "
"I<Auto>, I<Master> или I<Slave>; по умолчанию задано I<Auto>. Обычно, роль "
"порта согласуется во время установления связи, но если этого достичь не "
"удалось, с помощью этого параметра порту A можно принудительно назначить "
"нужное значение."

#. type: TP
#: man-pages/man4/sk98lin.4:375
#, no-wrap
msgid "B<Role_B=>I<i,j,...>"
msgstr "B<Role_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:392
msgid ""
"This parameter is valid only for 1000Base-T adapter cards.  For two 1000Base-"
"T ports to communicate, one must take the role of the master (providing "
"timing information), while the other must be the slave.  Possible values "
"are: I<Auto>, I<Master>, or I<Slave>; I<Auto> is the default.  Usually, the "
"role of a port is negotiated between two ports during link establishment, "
"but if that fails the port B of an adapter card can be forced to a specific "
"setting with this parameter."
msgstr ""
"Этот параметр доступен только для адаптеров 1000Base-T. При организации "
"связи между двумя портами 1000Base-T один должен играть роль основного "
"(предоставлять синхронизацию), другой — подчинённого. Возможные значения: "
"I<Auto>, I<Master> или I<Slave>; по умолчанию задано I<Auto>. Обычно, роль "
"порта согласуется во время установления связи, но если этого достичь не "
"удалось, с помощью этого параметра порту B можно принудительно назначить "
"нужное значение."

#. type: TP
#: man-pages/man4/sk98lin.4:392
#, no-wrap
msgid "B<ConType=>I<i,j,...>"
msgstr "B<ConType=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:400
msgid ""
"This parameter is a combination of all five per-port parameters within one "
"single parameter.  This simplifies the configuration of both ports of an "
"adapter card.  The different values of this variable reflect the most "
"meaningful combinations of port parameters.  Possible values and their "
"corresponding combination of per-port parameters:"
msgstr ""
"Этот параметр представляет собой комбинацию всех пяти параметров порта. Он "
"упрощает настройку обоих портов адаптера. Различные значения этой переменной "
"отражают большую часть важных комбинаций параметров порта. Возможные "
"значения и их соответствующие комбинации параметров портов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:409
#, no-wrap
msgid ""
"ConType | DupCap   AutoNeg   FlowCtrl   Role   Speed\n"
"--------+-------------------------------------------\n"
"I<Auto>    |  Both      On      SymOrRem   Auto   Auto\n"
"I<100FD>   |  Full      Off       None     Auto   100\n"
"I<100HD>   |  Half      Off       None     Auto   100\n"
"I<10FD>    |  Full      Off       None     Auto   10\n"
"I<10HD>    |  Half      Off       None     Auto   10\n"
msgstr ""
"ConType | DupCap   AutoNeg   FlowCtrl   Role   Speed\n"
"--------+-------------------------------------------\n"
"I<Auto>    |  Both      On      SymOrRem   Auto   Auto\n"
"I<100FD>   |  Full      Off       None     Auto   100\n"
"I<100HD>   |  Half      Off       None     Auto   100\n"
"I<10FD>    |  Full      Off       None     Auto   10\n"
"I<10HD>    |  Half      Off       None     Auto   10\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:419
msgid ""
"Stating any other port parameter together with this I<ConType> parameter "
"will result in a merged configuration of those settings.  This is due to the "
"fact, that the per-port parameters (e.g., I<Speed_A>)  have a higher "
"priority than the combined variable I<ConType>."
msgstr ""
"Задание любого другого параметра порта вместе с I<ConType> приводит к "
"объединению обеих настроек. Одиночные параметры порта (например, I<Speed_A>) "
"имеют больший приоритет чем значение переменной I<ConType>."

#. type: TP
#: man-pages/man4/sk98lin.4:419
#, no-wrap
msgid "B<Moderation=>I<i,j,...>"
msgstr "B<Moderation=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:436
msgid ""
"Interrupt moderation is employed to limit the maximum number of interrupts "
"the driver has to serve.  That is, one or more interrupts (which indicate "
"any transmit or receive packet to be processed) are queued until the driver "
"processes them.  When queued interrupts are to be served, is determined by "
"the I<IntsPerSec> parameter, which is explained later below.  Possible "
"moderation modes are: I<None>, I<Static>, or I<Dynamic>; I<None> is the "
"default.  The different modes have the following meaning:"
msgstr ""
"Регулирование прерываний используется для ограничения максимального "
"количества прерываний, которое может обработать драйвер. То есть одно и "
"более прерываний (которые означают обработку передачи или приёма пакета) "
"ставится в очередь для ожидания обработки драйвером. Параметр I<IntsPerSec> "
"определяет когда обслуживается очередь (см. далее). Возможные режимы "
"регулирования: I<None>, I<Static> или I<Dynamic>; по умолчанию задано "
"I<None>. Назначение режимов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:441
msgid ""
"I<None> No interrupt moderation is applied on the adapter card.  Therefore, "
"each transmit or receive interrupt is served immediately as soon as it "
"appears on the interrupt line of the adapter card."
msgstr ""
"I<None> Не выполнять регулирование прерываний для адаптера. Следовательно, "
"каждое прерывания по передаче или приёму будет обработано немедленно, сразу "
"после появления на линии прерывания адаптера."

#. type: Plain text
#: man-pages/man4/sk98lin.4:455
msgid ""
"I<Static> Interrupt moderation is applied on the adapter card.  All transmit "
"and receive interrupts are queued until a complete moderation interval "
"ends.  If such a moderation interval ends, all queued interrupts are "
"processed in one big bunch without any delay.  The term I<Static> reflects "
"the fact, that interrupt moderation is always enabled, regardless how much "
"network load is currently passing via a particular interface.  In addition, "
"the duration of the moderation interval has a fixed length that never "
"changes while the driver is operational."
msgstr ""
"I<Static> Выполнять регулирование прерываний для адаптера. Все прерывания по "
"передаче и приёму ставятся в очередь в ожидании завершения интервала "
"регулирования. После окончания интервала все прерывания в очереди "
"обрабатываются одним большим заданием без задержки. Термин I<Static> "
"отражает тот факт, что регулирование прерываний всегда включено, независимо "
"от сетевой загрузки на определённом интерфейсе в данный момент. Кроме того, "
"длительность интервала регулирования прерываний  имеет постоянную величину, "
"которая при работающем драйвере никогда не меняется."

#. type: Plain text
#: man-pages/man4/sk98lin.4:465
msgid ""
"I<Dynamic> Interrupt moderation might be applied on the adapter card, "
"depending on the load of the system.  If the driver detects that the system "
"load is too high, the driver tries to shield the system against too much "
"network load by enabling interrupt moderation.  If\\(emat a later time"
"\\(emthe CPU utilization decreases again (or if the network load is "
"negligible), the interrupt moderation will automatically be disabled."
msgstr ""
"I<Dynamic> Регулирование прерываний может применяться к адаптеру в "
"зависимости от загрузки системы. Если драйвер обнаруживает, что система "
"очень загружена, то он попытается оградить систему от излишней сетевой "
"нагрузки, включив регулирование прерываний. Если позднее нагрузка на ЦП "
"снизится (или если сетевая загрузка станет очень маленькой), то "
"регулирование прерываний будет автоматически выключено."

#. type: Plain text
#: man-pages/man4/sk98lin.4:471
msgid ""
"Interrupt moderation should be used when the driver has to handle one or "
"more interfaces with a high network load, which\\(emas a consequence"
"\\(emleads also to a high CPU utilization.  When moderation is applied in "
"such high network load situations, CPU load might be reduced by 20\\(en30% "
"on slow computers."
msgstr ""
"Регулирование прерываний должно использоваться, когда драйвер обрабатывает "
"много трафика на одном или более интерфейсах, который, как следствие, также "
"приводит большой нагрузке на ЦП. Применение регулирования при большой "
"сетевой нагрузке на медленных компьютерах может понизить загрузку ЦП на "
"20\\(en30%."

#. type: Plain text
#: man-pages/man4/sk98lin.4:475
msgid ""
"Note that the drawback of using interrupt moderation is an increase of the "
"round-trip-time (RTT), due to the queuing and serving of interrupts at "
"dedicated moderation times."
msgstr ""
"Заметим, что отрицательной стороной регулирования прерываний является "
"увеличение времени на передачу и подтверждение (round-trip-time, RTT), так "
"как постановка в очередь и обслуживание прерываний происходит только через "
"определённые интервалы."

#. type: TP
#: man-pages/man4/sk98lin.4:475
#, no-wrap
msgid "B<IntsPerSec=>I<i,j,...>"
msgstr "B<IntsPerSec=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:485
msgid ""
"This parameter determines the length of any interrupt moderation interval.  "
"Assuming that static interrupt moderation is to be used, an I<IntsPerSec> "
"parameter value of 2000 will lead to an interrupt moderation interval of 500 "
"microseconds.  Possible values for this parameter are in the range of "
"30...40000 (interrupts per second).  The default value is 2000."
msgstr ""
"Этот параметр определяет длительность любого интервала регулирования "
"прерываний. Предполагая, что используется регулирование прерываний, при "
"значении параметра I<IntsPerSec> равном 2000, получается интервал "
"регулирования прерываний в 500 микросекунд. Возможные значения этого "
"параметра находятся в диапазоне 30...40000 (прерываний в секунду). Значение "
"по умолчанию равно 2000."

#. type: Plain text
#: man-pages/man4/sk98lin.4:489
msgid ""
"This parameter is used only if either static or dynamic interrupt moderation "
"is enabled on a network adapter card.  This parameter is ignored if no "
"moderation is applied."
msgstr ""
"Этот параметр используется только, если для сетевого адаптера включено "
"статическое или динамическое регулирование прерываний. Если регулирование не "
"применяется, то параметр игнорируется."

#. type: Plain text
#: man-pages/man4/sk98lin.4:496
msgid ""
"Note that the duration of the moderation interval is to be chosen with "
"care.  At first glance, selecting a very long duration (e.g., only 100 "
"interrupts per second) seems to be meaningful, but the increase of packet-"
"processing delay is tremendous.  On the other hand, selecting a very short "
"moderation time might compensate the use of any moderation being applied."
msgstr ""
"Заметим, что длительность интервала регулирования прерываний нужно выбирать "
"с осторожностью. На первый взгляд, выбор очень большой длительности "
"(например, только 100 прерываний в секунду) кажется осмысленным, но это "
"колоссально увеличит задержку в обработке. С другой стороны, выбор очень "
"короткого интервала регулирования мог бы компенсировать использование любого "
"применяемого регулирования."

#. type: TP
#: man-pages/man4/sk98lin.4:496
#, no-wrap
msgid "B<PrefPort=>I<i,j,...>"
msgstr "B<PrefPort=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:508
msgid ""
"This parameter is used to force the preferred port to A or B (on dual-port "
"network adapters).  The preferred port is the one that is used if both ports "
"A and B are detected as fully functional.  Possible values are: I<A> or "
"I<B>; I<A> is the default."
msgstr ""
"Этот параметр используется для принудительного задания предпочтительного "
"порта: A или B (на двухпортовых адаптерах). Предпочтительный порт будет "
"использован когда оба порта, A и B, считаются полностью взаимозаменяемыми. "
"Возможные значения: I<A> или I<B>; по умолчанию задано I<A>."

#. type: TP
#: man-pages/man4/sk98lin.4:508
#, no-wrap
msgid "B<RlmtMode=>I<i,j,...>"
msgstr "B<RlmtMode=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:524
msgid ""
"RLMT monitors the status of the port.  If the link of the active port fails, "
"RLMT switches immediately to the standby link.  The virtual link is "
"maintained as long as at least one \"physical\" link is up.  This parameters "
"states how RLMT should monitor both ports.  Possible values are: "
"I<CheckLinkState>, I<CheckLocalPort>, I<CheckSeg>, or I<DualNet>; "
"I<CheckLinkState> is the default.  The different modes have the following "
"meaning:"
msgstr ""
"RLMT-слежение за состоянием порта. Если связь на активном порту пропадает, "
"то RLMT сразу переключает работу на резервную связь. Виртуальная связь "
"поддерживается так долго, пока есть не менее одной работающей «физической» "
"связи. Этот параметр определяет как RLMT должен отслеживать состояние "
"портов. Возможные значения: I<CheckLinkState>, I<CheckLocalPort>, "
"I<CheckSeg> или I<DualNet>; по умолчанию задано I<CheckLinkState>. "
"Назначение режимов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:529
msgid ""
"I<CheckLinkState> Check link state only: RLMT uses the link state reported "
"by the adapter hardware for each individual port to determine whether a port "
"can be used for all network traffic or not."
msgstr ""
"I<CheckLinkState> Проверять только состояние связи: RLMT использует "
"состояние связи, сообщаемое аппаратурой адаптера для каждого порта, для "
"определения, можно ли использовать порт для передачи данных в сеть или нет."

#. type: Plain text
#: man-pages/man4/sk98lin.4:536
msgid ""
"I<CheckLocalPort> In this mode, RLMT monitors the network path between the "
"two ports of an adapter by regularly exchanging packets between them.  This "
"mode requires a network configuration in which the two ports are able to "
"\"see\" each other (i.e., there must not be any router between the ports)."
msgstr ""
"I<CheckLocalPort> В этом режиме RLMT отслеживает сетевой путь между двумя "
"портами адаптера, периодически пересылая пакеты между ними. Для работы этого "
"режима требуется настройка сети, при которой два порта смогли бы \"видеть\" "
"друг друга (то есть, между ними не должно быть маршрутизатора)."

#. type: Plain text
#: man-pages/man4/sk98lin.4:544
msgid ""
"I<CheckSeg> Check local port and segmentation: This mode supports the same "
"functions as the CheckLocalPort mode and additionally checks network "
"segmentation between the ports.  Therefore, this mode is to be used only if "
"Gigabit Ethernet switches are installed on the network that have been "
"configured to use the Spanning Tree protocol."
msgstr ""
"I<CheckSeg> Проверять локальный порт и сегментирование: Этот режим "
"поддерживает те же функции что и CheckLocalPort и вдобавок проверяет "
"сегментирование сети между портами. Поэтому этот режим может использоваться "
"только, если в сети установлены коммутаторы Gigabit Ethernet, на которых  "
"настроен протокол Spanning Tree."

#. type: Plain text
#: man-pages/man4/sk98lin.4:554
msgid ""
"I<DualNet> In this mode, ports A and B are used as separate devices.  If you "
"have a dual port adapter, port A will be configured as I<eth[x]> and port B "
"as I<eth[x+1]>.  Both ports can be used independently with distinct IP "
"addresses.  The preferred port setting is not used.  RLMT is turned off."
msgstr ""
"I<DualNet> В этом режиме порты A и B используются как раздельные устройства. "
"Если у вас адаптер с двумя портами, то порт A будет настроен как I<eth[x]>, "
"а порт B как I<eth[x+1]>. Оба порта можно использовать независимо с "
"различающимися IP-адресами. Настройка выбора предпочтительного порта не "
"используется. RLMT выключено."

#. type: Plain text
#: man-pages/man4/sk98lin.4:563
msgid ""
"Note that RLMT modes I<CheckLocalPort> and I<CheckLinkState> are designed to "
"operate in configurations where a network path between the ports on one "
"adapter exists.  Moreover, they are not designed to work where adapters are "
"connected back-to-back."
msgstr ""
"Заметим, что RLMT-режимы I<CheckLocalPort> и I<CheckLinkState> предназначены "
"для работы в условиях, где сетевой путь между портами существует на одном "
"адаптере. Более того, они не работают, если адаптеры соединены друг с другом."

#. type: TP
#: man-pages/man4/sk98lin.4:564
#, no-wrap
msgid "I</proc/net/sk98lin/eth[x]>"
msgstr "I</proc/net/sk98lin/eth[x]>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:569
msgid ""
"The statistics file of a particular interface of an adapter card.  It "
"contains generic information about the adapter card plus a detailed summary "
"of all transmit and receive counters."
msgstr ""
"Файлы статистики для определённого интерфейса адаптера. Содержит общую "
"информацию о карте адаптера и подробную сводку по всем счётчикам передачи и "
"приёма."

#. type: TP
#: man-pages/man4/sk98lin.4:569
#, no-wrap
msgid "I</usr/src/linux/Documentation/networking/sk98lin.txt>"
msgstr "I</usr/src/linux/Documentation/networking/sk98lin.txt>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:579
msgid ""
"This is the I<README> file of the I<sk98lin> driver.  It contains a detailed "
"installation HOWTO and describes all parameters of the driver.  It denotes "
"also common problems and provides the solution to them."
msgstr ""
"Это файл I<README> от драйвера I<sk98lin>. В нём содержится подробная "
"инструкция по установке и описание всех параметров драйвера. Также отмечены "
"общие проблемы и их решения."

#. type: SH
#: man-pages/man4/sk98lin.4:579
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  .SH AUTHORS
#.  Ralph Roesler \(em rroesler@syskonnect.de
#.  .br
#.  Mirko Lindner \(em mlindner@syskonnect.de
#. type: Plain text
#: man-pages/man4/sk98lin.4:585
msgid "Report any bugs to linux@syskonnect.de"
msgstr "О дефектах сообщайте по адресу: linux@syskonnect.de"

#. type: Plain text
#: man-pages/man4/sk98lin.4:588
msgid "B<ifconfig>(8), B<insmod>(8), B<modprobe>(8)"
msgstr "B<ifconfig>(8), B<insmod>(8), B<modprobe>(8)"

#. type: TH
#: man-pages/man4/st.4:25
#, no-wrap
msgid "ST"
msgstr "ST"

#. type: TH
#: man-pages/man4/st.4:25
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: man-pages/man4/st.4:28
msgid "st - SCSI tape device"
msgstr "st - ленточный накопитель SCSI"

#. type: Plain text
#: man-pages/man4/st.4:31
#, no-wrap
msgid "B<#include E<lt>sys/mtio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mtio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man4/st.4:36
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, int >I<request>B< [, (void *)>I<arg3>B<]);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCTOP, (struct mtop *)>I<mt_cmd>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCGET, (struct mtget *)>I<mt_status>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCPOS, (struct mtpos *)>I<mt_pos>B<);>\n"
msgstr ""
"B<int ioctl(int >I<fd>B<, int >I<request>B< [, (void *)>I<arg3>B<]);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCTOP, (struct mtop *)>I<mt_cmd>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCGET, (struct mtget *)>I<mt_status>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCPOS, (struct mtpos *)>I<mt_pos>B<);>\n"

#. type: Plain text
#: man-pages/man4/st.4:46
msgid ""
"The B<st> driver provides the interface to a variety of SCSI tape devices.  "
"Currently, the driver takes control of all detected devices of type "
"\\(lqsequential-access\\(rq.  The B<st> driver uses major device number 9."
msgstr ""
"Драйвер B<st> предоставляет интерфейс к различным ленточным накопителям "
"SCSI. В настоящее время драйвер позволяет управлять любыми устройствами "
"\"последовательного доступа\". Драйвер B<st> использует для устройств "
"старший номер 9."

#. type: Plain text
#: man-pages/man4/st.4:66
msgid ""
"Each device uses eight minor device numbers.  The lowermost five bits in the "
"minor numbers are assigned sequentially in the order of detection.  In the "
"2.6 kernel, the bits above the eight lowermost bits are concatenated to the "
"five lowermost bits to form the tape number.  The minor numbers can be "
"grouped into two sets of four numbers: the principal (auto-rewind) minor "
"device numbers, I<n>, and the \\(lqno-rewind\\(rq device numbers, (I<n> + "
"128).  Devices opened using the principal device number will be sent a "
"B<REWIND> command when they are closed.  Devices opened using the \\(lqno-"
"rewind\\(rq device number will not.  (Note that using an auto-rewind device "
"for positioning the tape with, for instance, mt does not lead to the desired "
"result: the tape is rewound after the mt command and the next command starts "
"from the beginning of the tape)."
msgstr ""
"Для каждого устройства есть восемь младших номеров. Первые пять битов в "
"младших номерах определяют последовательность обнаружения. В ядрах 2.6 "
"первые восемь битов объединяются с первыми пятью битами для создания номера "
"ленты. Младшие номера могут быть сгруппированы в два набора из четырех "
"чисел: основные младшие номера для устройств (I<n>) с автоперемоткой и "
"номера устройств без автоперемотки (I<n> + 128). При открытии устройства с "
"основным младшим номером, будет послана команда B<REWIND>. При открытии с "
"использованием устройства без автоперемотки этого произведено не будет. "
"(Заметим, что использование устройства с автоперемоткой для установки ленты "
"в определённое положение, например, mt, не даст желаемого результата: лента "
"перемотается после команды mt, и следующая команда будет выполняться с "
"начала ленты)."

#. type: Plain text
#: man-pages/man4/st.4:80
msgid ""
"Within each group, four minor numbers are available to define devices with "
"different characteristics (block size, compression, density, etc.)  When the "
"system starts up, only the first device is available.  The other three are "
"activated when the default characteristics are defined (see below).  (By "
"changing compile-time constants, it is possible to change the balance "
"between the maximum number of tape drives and the number of minor numbers "
"for each drive.  The default allocation allows control of 32 tape drives.  "
"For instance, it is possible to control up to 64 tape drives with two minor "
"numbers for different options.)"
msgstr ""
"В каждой группе четыре младших номера доступны для определения устройств с "
"особыми характеристиками (такими как: размер блока, сжатие, плотность и "
"другое). Когда система запускается, доступно только первое устройство. "
"Другие три приводятся в действие, когда определены некоторые их "
"характеристики (смотрите ниже). Путем изменения константы при компиляции "
"возможно изменение баланса между максимальным числом ленточных накопителей и "
"числом из младших номеров каждого накопителя. Начальное значение позволяет "
"контролировать 32 ленточных устройства. Например, возможно контролировать до "
"64-х ленточных устройств с двумя младшими номерами для различных параметров."

#. type: Plain text
#: man-pages/man4/st.4:82
msgid "Devices are typically created by:"
msgstr "Устройства обычно создаются так:"

#. type: Plain text
#: man-pages/man4/st.4:93
#, no-wrap
msgid ""
"mknod -m 666 /dev/st0 c 9 0\n"
"mknod -m 666 /dev/st0l c 9 32\n"
"mknod -m 666 /dev/st0m c 9 64\n"
"mknod -m 666 /dev/st0a c 9 96\n"
"mknod -m 666 /dev/nst0 c 9 128\n"
"mknod -m 666 /dev/nst0l c 9 160\n"
"mknod -m 666 /dev/nst0m c 9 192\n"
"mknod -m 666 /dev/nst0a c 9 224\n"
msgstr ""
"mknod -m 666 /dev/st0 c 9 0\n"
"mknod -m 666 /dev/st0l c 9 32\n"
"mknod -m 666 /dev/st0m c 9 64\n"
"mknod -m 666 /dev/st0a c 9 96\n"
"mknod -m 666 /dev/nst0 c 9 128\n"
"mknod -m 666 /dev/nst0l c 9 160\n"
"mknod -m 666 /dev/nst0m c 9 192\n"
"mknod -m 666 /dev/nst0a c 9 224\n"

#. type: Plain text
#: man-pages/man4/st.4:97
msgid "There is no corresponding block device."
msgstr "Соответствующее блочное устройство отсутствует."

#. type: Plain text
#: man-pages/man4/st.4:112
msgid ""
"The driver uses an internal buffer that has to be large enough to hold at "
"least one tape block.  In kernels before 2.1.121, the buffer is allocated as "
"one contiguous block.  This limits the block size to the largest contiguous "
"block of memory the kernel allocator can provide.  The limit is currently "
"128\\ kB for 32-bit architectures and 256\\ kB for 64-bit architectures.  In "
"newer kernels the driver allocates the buffer in several parts if "
"necessary.  By default, the maximum number of parts is 16.  This means that "
"the maximum block size is very large (2\\ MB if allocation of 16 blocks of "
"128\\ kB succeeds)."
msgstr ""
"Драйвер использует внутренний буфер, которого достаточно для сохранения, как "
"минимум, одного блока ленты. В ядре до версии 2.1.121 буфер выделялся как "
"один непрерывный блок. Это ограничивало размер блока самым большим "
"непрерывным участком памяти, которое может выделить ядро. Ограничение в "
"настоящее время составляет: 128\\ Кбайт для 32-битной и 256\\ Кбайт для 64-"
"битной архитектуры. В новейших ядрах драйвер располагает буфер в нескольких "
"частях, если это необходимо. По умолчанию максимальное число частей \\(em "
"16. Таким способом можно сделать максимальный размер блока очень большим "
"(2\\ МБ, если выделяется 16 блоков по 128\\ Кбайт)."

#. type: Plain text
#: man-pages/man4/st.4:121
msgid ""
"The driver's internal buffer size is determined by a compile-time constant "
"which can be overridden with a kernel startup option.  In addition to this, "
"the driver tries to allocate a larger temporary buffer at run time if "
"necessary.  However, run-time allocation of large contiguous blocks of "
"memory may fail and it is advisable not to rely too much on dynamic buffer "
"allocation with kernels older than 2.1.121 (this applies also to demand-"
"loading the driver with kerneld or kmod)."
msgstr ""
"Размер внутреннего буфера драйвера определяется константой при сборке; эта "
"константа может быть изменена при загрузке ядра. Вдобавок к этому, драйвер "
"пытается разместить больший временный буфер во время запуска, если это "
"необходимо. Тем не менее, размещение во время запуска больших блоков памяти "
"может завершиться неудачно, и лучше не полагаться на динамическое размещение "
"буфера в ядре до версии 2.1.121 (это применяется также при загрузке драйвера "
"по требованию с помощью kerneld или kmod)."

#. type: Plain text
#: man-pages/man4/st.4:134
msgid ""
"The driver does not specifically support any tape drive brand or model.  "
"After system start-up the tape device options are defined by the drive "
"firmware.  For example, if the drive firmware selects fixed-block mode, the "
"tape device uses fixed-block mode.  The options can be changed with explicit "
"B<ioctl>(2)  calls and remain in effect when the device is closed and "
"reopened.  Setting the options affects both the auto-rewind and the "
"nonrewind device."
msgstr ""
"В драйвере нет специальной поддержки для устройств определённых "
"производителей или моделей. После старта системы параметры ленточного "
"устройства определяются микропрограммой устройства. Для примера, если "
"микропрограмма выбирает режим с блоками одинакового размера, то ленточное "
"устройство использует этот режим. Параметры могут быть изменены вызовами "
"B<ioctl>(2) и действуют до тех пор, пока устройство не закрыто и потом не "
"открыто вновь. Установка параметров влияет на оба устройства (с "
"автоперемоткой и без автоперемотки)."

#. type: Plain text
#: man-pages/man4/st.4:143
msgid ""
"Different options can be specified for the different devices within the "
"subgroup of four.  The options take effect when the device is opened.  For "
"example, the system administrator can define one device that writes in fixed-"
"block mode with a certain block size, and one which writes in variable-block "
"mode (if the drive supports both modes)."
msgstr ""
"Внутри подгруппы четырёх устройств для каждого могут быть заданы особые "
"параметры. Параметры начинают работать, когда устройство открывается. Для "
"примера, системный администратор может определить одно устройство, которое "
"записывает данные в режиме блоков одинакового размера с задаваемым размером "
"и другое, которое записывает данные в режиме блоков с разным размером (если "
"накопитель поддерживает оба режима)."

#. type: Plain text
#: man-pages/man4/st.4:166
msgid ""
"The driver supports B<tape partitions> if they are supported by the drive.  "
"(Note that the tape partitions have nothing to do with disk partitions.  A "
"partitioned tape can be seen as several logical tapes within one medium.)  "
"Partition support has to be enabled with an B<ioctl>(2).  The tape location "
"is preserved within each partition across partition changes.  The partition "
"used for subsequent tape operations is selected with an B<ioctl>(2).  The "
"partition switch is executed together with the next tape operation in order "
"to avoid unnecessary tape movement.  The maximum number of partitions on a "
"tape is defined by a compile-time constant (originally four).  The driver "
"contains an B<ioctl>(2)  that can format a tape with either one or two "
"partitions."
msgstr ""
"Драйвер поддерживает B<ленточные разделы>, но только если их поддерживает "
"само устройство. Заметим, что ленточные разделы не имеют ничего общего с "
"разделами диска. Размеченная лента одного носителя может выглядеть как "
"несколько логических лент. Поддержка разделов включается с помощью "
"B<ioctl>(2). Местоположение ленты зафиксировано внутри каждого раздела. При "
"последующих ленточных операциях используется нужный раздел, выбранный с "
"помощью B<ioctl>(2). Переключение раздела выполняется вместе со следующей "
"операцией с лентой во избежании ненужной перемотки. Максимальное число "
"разделов на ленте определяется константой при компиляции (изначально оно "
"равно четырём). Драйвер содержит вызов B<ioctl>(2), который позволяет "
"форматировать ленту с одним или двумя разделами."

#. type: Plain text
#: man-pages/man4/st.4:171
msgid ""
"Device I</dev/tape> is usually created as a hard or soft link to the default "
"tape device on the system."
msgstr ""
"Обычно, в системе создаётся устройство I</dev/tape> в виде жёсткой или "
"символьной ссылки на ленточное устройство по умолчанию."

#. type: Plain text
#: man-pages/man4/st.4:175
msgid ""
"Starting from kernel 2.6.2, the driver exports in the sysfs directory I</sys/"
"class/scsi_tape> the attached devices and some parameters assigned to the "
"devices."
msgstr ""
"Начиная с ядра 2.6.2, драйвер экспортирует в каталог sysfs в файл I</sys/"
"class/scsi_tape> подключённые устройства и некоторые их параметры."

#. type: SS
#: man-pages/man4/st.4:175
#, no-wrap
msgid "Data transfer"
msgstr "Передача данных"

#. type: Plain text
#: man-pages/man4/st.4:188
msgid ""
"The driver supports operation in both fixed-block mode and variable-block "
"mode (if supported by the drive).  In fixed-block mode the drive writes "
"blocks of the specified size and the block size is not dependent on the byte "
"counts of the write system calls.  In variable-block mode one tape block is "
"written for each write call and the byte count determines the size of the "
"corresponding tape block.  Note that the blocks on the tape don't contain "
"any information about the writing mode: when reading, the only important "
"thing is to use commands that accept the block sizes on the tape."
msgstr ""
"Драйвер поддерживает операции в обоих режимах: с постоянным и переменным "
"размером блоков (только если оба режима поддерживает само устройство). В "
"режиме с постоянным размером блока устройство выполняет запись блоками "
"заданного размера, и размер блока не зависит от количества байтов, которые "
"записываются системными вызовами. В режиме с переменным размером блока один "
"блок ленты записывается при каждом вызове записи, и размер соответствующего "
"блока ленты определяется в соответствии с количеством записываемых байт. "
"Заметим, что блоки ленты не содержат информации о режиме записи: при чтении "
"единственно важной вещью является использование нужных команд, которые "
"принимают размеры блоков ленты."

#. type: Plain text
#: man-pages/man4/st.4:196
msgid ""
"In variable-block mode the read byte count does not have to match the tape "
"block size exactly.  If the byte count is larger than the next block on "
"tape, the driver returns the data and the function returns the actual block "
"size.  If the block size is larger than the byte count, an error is returned."
msgstr ""
"В режиме с переменным размером блока при чтении количество байтов не "
"совпадает точно с размером блока ленты. Если количество байтов больше, чем в "
"следующем блоке ленты, драйвер возвращает данные, а функция возвращает "
"реальный размер блока. Если размер блока больше, чем количество байтов, то "
"возвращается ошибка."

#. type: Plain text
#: man-pages/man4/st.4:205
msgid ""
"In fixed-block mode the read byte counts can be arbitrary if buffering is "
"enabled, or a multiple of the tape block size if buffering is disabled.  "
"Kernels before 2.1.121 allow writes with arbitrary byte count if buffering "
"is enabled.  In all other cases (kernel before 2.1.121 with buffering "
"disabled or newer kernel) the write byte count must be a multiple of the "
"tape block size."
msgstr ""
"При чтении в режиме с постоянным размером блока количества байтов может быть "
"произвольным, если включена буферизация, или пропорциональным размеру блока "
"ленты, если буферизация выключена. Ядра версий до 2.1.121, позволяли "
"записывать произвольное количество байтов, если включена буферизация. Во "
"всех других случаях (ядра до 2.1.121 с выключенной буферизацией и новые "
"ядра) количество байтов должно быть пропорциональным размеру блока ленты."

#. type: Plain text
#: man-pages/man4/st.4:214
msgid ""
"In the 2.6 kernel, the driver tries to use direct transfers between the user "
"buffer and the device.  If this is not possible, the driver's internal "
"buffer is used.  The reasons for not using direct transfers include improper "
"alignment of the user buffer (default is 512 bytes but this can be changed "
"by the HBA driver), one or more pages of the user buffer not reachable by "
"the SCSI adapter, and so on."
msgstr ""
"В ядрах 2.6 драйвер пытается использовать прямую пересылку между "
"пользовательским буфером и устройством. Если это невозможно, то используется "
"внутренний буфер драйвера. Причинами отказа от использования прямой "
"пересылки может быть включение неправильного выравнивания пользовательского "
"буфера (по умолчанию 512 байт, но может быть изменено драйвером HBA), одна "
"или более страниц пользовательского буфера недостижима из адаптера SCSI и т. "
"п."

#. type: Plain text
#: man-pages/man4/st.4:217
msgid ""
"A filemark is automatically written to tape if the last tape operation "
"before close was a write."
msgstr ""
"Маркер файла автоматически записывается на ленту, если последней операцией "
"до закрытия была запись."

#. type: Plain text
#: man-pages/man4/st.4:229
msgid ""
"When a filemark is encountered while reading, the following happens.  If "
"there are data remaining in the buffer when the filemark is found, the "
"buffered data is returned.  The next read returns zero bytes.  The following "
"read returns data from the next file.  The end of recorded data is signaled "
"by returning zero bytes for two consecutive read calls.  The third read "
"returns an error."
msgstr ""
"Когда при чтении обнаруживается маркер файла, происходит следующее. Если при "
"обнаружении маркера есть данные в буфере, то возвращаются данные буфера. "
"Следующее чтение вернёт ноль байтов. Затем вернёт данные из следующего "
"файла. О конце записанных данных будет сообщено возвращением нуля байтов в "
"двух операциях чтения подряд. И, наконец, третье чтение вернёт ошибку."

#. type: SS
#: man-pages/man4/st.4:229
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#. type: Plain text
#: man-pages/man4/st.4:240
msgid ""
"The driver supports three B<ioctl>(2)  requests.  Requests not recognized by "
"the B<st> driver are passed to the B<SCSI> driver.  The definitions below "
"are from I</usr/include/linux/mtio.h>:"
msgstr ""
"Драйвер поддерживает три запроса B<ioctl>(2). Запросы, не опознанные "
"драйвером B<st>, пропускаются в драйвер B<SCSI>. Определения, приведённые "
"далее, взяты из I</usr/include/linux/mtio.h>:"

#. type: SS
#: man-pages/man4/st.4:240
#, no-wrap
msgid "MTIOCTOP \\(em perform a tape operation"
msgstr "MTIOCTOP \\(em выполнение операций с лентой"

#. type: Plain text
#: man-pages/man4/st.4:248
msgid ""
"This request takes an argument of type I<(struct mtop\\ *)>.  Not all drives "
"support all operations.  The driver returns an B<EIO> error if the drive "
"rejects an operation."
msgstr ""
"Для этого запроса требуется аргумент с типом I<(struct mtop\\ *)>. Не все "
"устройства поддерживает все операции. Драйвер возвращает ошибку B<EIO>, если "
"устройство не выполнило операцию."

#. type: Plain text
#: man-pages/man4/st.4:256
#, no-wrap
msgid ""
"/* Structure for MTIOCTOP - mag tape op command: */\n"
"struct mtop {\n"
"    short   mt_op;       /* operations defined below */\n"
"    int     mt_count;    /* how many of them */\n"
"};\n"
msgstr ""
"/* Структура для MTIOCTOP - операция с маг. лентой */\n"
"struct mtop {\n"
"    short   mt_op;       /* операции перечислены далее */\n"
"    int     mt_count;    /* их количество */\n"
"};\n"

#. type: Plain text
#: man-pages/man4/st.4:260
msgid "Magnetic Tape operations for normal tape use:"
msgstr "Операции с магнитной лентой для обычного использования:"

#. type: TP
#: man-pages/man4/st.4:260
#, no-wrap
msgid "B<MTBSF>"
msgstr "B<MTBSF>"

#. type: Plain text
#: man-pages/man4/st.4:265
msgid "Backward space over I<mt_count> filemarks."
msgstr "Перемотка ленты на I<mt_count> файловых маркеров назад."

#. type: TP
#: man-pages/man4/st.4:265
#, no-wrap
msgid "B<MTBSFM>"
msgstr "B<MTBSFM>"

#. type: Plain text
#: man-pages/man4/st.4:271
msgid ""
"Backward space over I<mt_count> filemarks.  Reposition the tape to the EOT "
"side of the last filemark."
msgstr ""
"Перемотка ленты на I<mt_count> файловых маркеров назад. Перемотка ленты на "
"сторону EOT последнего маркера файла."

#. type: TP
#: man-pages/man4/st.4:271
#, no-wrap
msgid "B<MTBSR>"
msgstr "B<MTBSR>"

#. type: Plain text
#: man-pages/man4/st.4:276
msgid "Backward space over I<mt_count> records (tape blocks)."
msgstr "Перемотка ленты на I<mt_count> записей назад (блоков ленты)."

#. type: TP
#: man-pages/man4/st.4:276
#, no-wrap
msgid "B<MTBSS>"
msgstr "B<MTBSS>"

#. type: Plain text
#: man-pages/man4/st.4:281
msgid "Backward space over I<mt_count> setmarks."
msgstr "Перемотка ленты на I<mt_count> сборочных маркеров (setmarks) назад."

#. type: TP
#: man-pages/man4/st.4:281
#, no-wrap
msgid "B<MTCOMPRESSION>"
msgstr "B<MTCOMPRESSION>"

#. type: Plain text
#: man-pages/man4/st.4:289
msgid ""
"Enable compression of tape data within the drive if I<mt_count> is nonzero "
"and disable compression if I<mt_count> is zero.  This command uses the MODE "
"page 15 supported by most DATs."
msgstr ""
"Включение режима сжатия данных на ленте устройства, если I<mt_count> не "
"равно 0, и отключение сжатия, если I<mt_count> равно 0. Эта команда "
"использует MODE page 15, поддерживаемую многими DAT-устройствами."

#. type: TP
#: man-pages/man4/st.4:289
#, no-wrap
msgid "B<MTEOM>"
msgstr "B<MTEOM>"

#. type: Plain text
#: man-pages/man4/st.4:292
msgid "Go to the end of the recorded media (for appending files)."
msgstr "Переход в конец записанных на носителе данных (для добавления файлов)."

#. type: TP
#: man-pages/man4/st.4:292
#, no-wrap
msgid "B<MTERASE>"
msgstr "B<MTERASE>"

#. type: Plain text
#: man-pages/man4/st.4:298
msgid ""
"Erase tape.  With 2.6 kernel, short erase (mark tape empty) is performed if "
"the argument is zero.  Otherwise, long erase (erase all) is done."
msgstr ""
"Стирание ленты. В ядре 2.6 выполняется быстрое стирание (удаление маркера "
"ленты), если аргумент равен 0. В противном случае выполняется полное "
"стирание."

#. type: TP
#: man-pages/man4/st.4:298
#, no-wrap
msgid "B<MTFSF>"
msgstr "B<MTFSF>"

#. type: Plain text
#: man-pages/man4/st.4:303
msgid "Forward space over I<mt_count> filemarks."
msgstr "Перемотка ленты на I<mt_count> файловых маркеров вперёд."

#. type: TP
#: man-pages/man4/st.4:303
#, no-wrap
msgid "B<MTFSFM>"
msgstr "B<MTFSFM>"

#. type: Plain text
#: man-pages/man4/st.4:309
msgid ""
"Forward space over I<mt_count> filemarks.  Reposition the tape to the BOT "
"side of the last filemark."
msgstr ""
"Перемотка ленты на I<mt_count> файловых маркеров вперёд. Перемотка ленты на "
"сторону BOT последнего маркера файла."

#. type: TP
#: man-pages/man4/st.4:309
#, no-wrap
msgid "B<MTFSR>"
msgstr "B<MTFSR>"

#. type: Plain text
#: man-pages/man4/st.4:314
msgid "Forward space over I<mt_count> records (tape blocks)."
msgstr "Перемотка ленты на I<mt_count> записей вперёд (блоков ленты)."

#. type: TP
#: man-pages/man4/st.4:314
#, no-wrap
msgid "B<MTFSS>"
msgstr "B<MTFSS>"

#. type: Plain text
#: man-pages/man4/st.4:319
msgid "Forward space over I<mt_count> setmarks."
msgstr "Перемотка ленты на I<mt_count> сборочных маркеров вперёд."

#. type: TP
#: man-pages/man4/st.4:319
#, no-wrap
msgid "B<MTLOAD>"
msgstr "B<MTLOAD>"

#. type: Plain text
#: man-pages/man4/st.4:330
msgid ""
"Execute the SCSI load command.  A special case is available for some HP "
"autoloaders.  If I<mt_count> is the constant B<MT_ST_HPLOADER_OFFSET> plus a "
"number, the number is sent to the drive to control the autoloader."
msgstr ""
"Выполнение SCSI-команды загрузки. Для некоторых автозагрузчиков HP "
"выполняется особое действие. Если I<mt_count> равно константе "
"B<MT_ST_HPLOADER_OFFSET> плюс  некоторое число, то это значение передаётся "
"устройству для управления автозагрузчиком."

#. type: TP
#: man-pages/man4/st.4:330
#, no-wrap
msgid "B<MTLOCK>"
msgstr "B<MTLOCK>"

#. type: Plain text
#: man-pages/man4/st.4:333
msgid "Lock the tape drive door."
msgstr "Блокирование дверцы ленточного устройства."

#. type: TP
#: man-pages/man4/st.4:333
#, no-wrap
msgid "B<MTMKPART>"
msgstr "B<MTMKPART>"

#.  commit 8038e6456a3e6f5c4759e0d73c4f9165b90c93e7
#. type: Plain text
#: man-pages/man4/st.4:354
msgid ""
"Format the tape into one or two partitions.  If I<mt_count> is positive, it "
"gives the size of partition 1 and partition 0 contains the rest of the "
"tape.  If I<mt_count> is zero, the tape is formatted into one partition.  "
"From kernel version 4.6, a negative I<mt_count> specifies the size of "
"partition 0 and the rest of the tape contains partition 1.  The physical "
"ordering of partitions depends on the drive.  This command is not allowed "
"for a drive unless the partition support is enabled for the drive (see "
"B<MT_ST_CAN_PARTITIONS> below)."
msgstr ""
"Форматирование ленты на один или два раздела. Если I<mt_count> положительно, "
"то оно определяет размер раздела 1, а раздел 0 займёт остаток ленты. Если "
"I<mt_count> равно 0, то лента форматируется с одним разделом. Для ядра "
"версии 4.6: отрицательное значение I<mt_count> задаёт размер раздела 0, а "
"раздел 1 займёт остаток ленты. Физический порядок разделов зависит от "
"устройства. Эта команда запрещена для устройств, не поддерживающих разделы "
"(смотрите B<MT_ST_CAN_PARTITIONS> далее)."

#. type: TP
#: man-pages/man4/st.4:354
#, no-wrap
msgid "B<MTNOP>"
msgstr "B<MTNOP>"

#. type: Plain text
#: man-pages/man4/st.4:359
msgid ""
"No op\\(emflushes the driver's buffer as a side effect.  Should be used "
"before reading status with B<MTIOCGET>."
msgstr ""
"Нет операции, как побочный эффект — сброс буфера устройства. Операция должна "
"выполняться до чтения состояния с помощью B<MTIOCGET>."

#. type: TP
#: man-pages/man4/st.4:359
#, no-wrap
msgid "B<MTOFFL>"
msgstr "B<MTOFFL>"

#. type: Plain text
#: man-pages/man4/st.4:362
msgid "Rewind and put the drive off line."
msgstr "Перемотка ленты и отключение устройства."

#. type: TP
#: man-pages/man4/st.4:362
#, no-wrap
msgid "B<MTRESET>"
msgstr "B<MTRESET>"

#. type: Plain text
#: man-pages/man4/st.4:365
msgid "Reset drive."
msgstr "Возврат устройства в исходное состояние."

#. type: TP
#: man-pages/man4/st.4:365
#, no-wrap
msgid "B<MTRETEN>"
msgstr "B<MTRETEN>"

#. type: Plain text
#: man-pages/man4/st.4:368
msgid "Re-tension tape."
msgstr "Подтягивание ленты."

#. type: TP
#: man-pages/man4/st.4:368
#, no-wrap
msgid "B<MTREW>"
msgstr "B<MTREW>"

#. type: Plain text
#: man-pages/man4/st.4:371
msgid "Rewind."
msgstr "Перемотка ленты назад."

#. type: TP
#: man-pages/man4/st.4:371
#, no-wrap
msgid "B<MTSEEK>"
msgstr "B<MTSEEK>"

#. type: Plain text
#: man-pages/man4/st.4:383
msgid ""
"Seek to the tape block number specified in I<mt_count>.  This operation "
"requires either a SCSI-2 drive that supports the B<LOCATE> command (device-"
"specific address)  or a Tandberg-compatible SCSI-1 drive (Tandberg, Archive "
"Viper, Wangtek, ...).  The block number should be one that was previously "
"returned by B<MTIOCPOS> if device-specific addresses are used."
msgstr ""
"Переход к блоку ленты с номером I<mt_count>. Эта операция требует устройства "
"SCSI-2, поддерживающего команду B<LOCATE> (адрес, определяемый "
"устройством),  или Tandberg-совместимого устройства SCSI-1 (Tandberg, "
"Archive Viper, Wangtek, ... ). Номер блока должен быть равен значению, "
"которое было получено ранее с помощью B<MTIOCPOS>, если используется адрес, "
"определяемый устройством."

#. type: TP
#: man-pages/man4/st.4:383
#, no-wrap
msgid "B<MTSETBLK>"
msgstr "B<MTSETBLK>"

#. type: Plain text
#: man-pages/man4/st.4:388
msgid ""
"Set the drive's block length to the value specified in I<mt_count>.  A block "
"length of zero sets the drive to variable block size mode."
msgstr ""
"Задание размера блока устройства равному I<mt_count>. Нулевое значение "
"включает режим с переменным размером блоков."

#. type: TP
#: man-pages/man4/st.4:388
#, no-wrap
msgid "B<MTSETDENSITY>"
msgstr "B<MTSETDENSITY>"

#. type: Plain text
#: man-pages/man4/st.4:394
msgid ""
"Set the tape density to the code in I<mt_count>.  The density codes "
"supported by a drive can be found from the drive documentation."
msgstr ""
"Задание плотности данных на ленте равной I<mt_count>. Коды плотности данных, "
"поддерживаемые устройством, можно найти в документации к устройству."

#. type: TP
#: man-pages/man4/st.4:394
#, no-wrap
msgid "B<MTSETPART>"
msgstr "B<MTSETPART>"

#. type: Plain text
#: man-pages/man4/st.4:403
msgid ""
"The active partition is switched to I<mt_count>.  The partitions are "
"numbered from zero.  This command is not allowed for a drive unless the "
"partition support is enabled for the drive (see B<MT_ST_CAN_PARTITIONS> "
"below)."
msgstr ""
"Переключение активного раздела на номер I<mt_count>. Разделы нумеруются "
"начиная с нуля. Эта команда только для устройств с включённой поддержкой "
"разделов (см. B<MT_ST_CAN_PARTITIONS> далее)."

#. type: TP
#: man-pages/man4/st.4:403
#, no-wrap
msgid "B<MTUNLOAD>"
msgstr "B<MTUNLOAD>"

#. type: Plain text
#: man-pages/man4/st.4:406
msgid "Execute the SCSI unload command (does not eject the tape)."
msgstr "Выполнение SCSI-команды выгрузки (но лента не выталкивается)."

#. type: TP
#: man-pages/man4/st.4:406
#, no-wrap
msgid "B<MTUNLOCK>"
msgstr "B<MTUNLOCK>"

#. type: Plain text
#: man-pages/man4/st.4:409
msgid "Unlock the tape drive door."
msgstr "Разблокирование дверцы ленточного устройства."

#. type: TP
#: man-pages/man4/st.4:409
#, no-wrap
msgid "B<MTWEOF>"
msgstr "B<MTWEOF>"

#. type: Plain text
#: man-pages/man4/st.4:414
msgid "Write I<mt_count> filemarks."
msgstr "Запись I<mt_count> маркеров файлов."

#. type: TP
#: man-pages/man4/st.4:414
#, no-wrap
msgid "B<MTWSM>"
msgstr "B<MTWSM>"

#. type: Plain text
#: man-pages/man4/st.4:419
msgid "Write I<mt_count> setmarks."
msgstr "Запись I<mt_count> сборочных маркеров."

#. type: Plain text
#: man-pages/man4/st.4:421
msgid ""
"Magnetic Tape operations for setting of device options (by the superuser):"
msgstr ""
"Операции с магнитной лентой по установке параметров устройства (для "
"суперпользователя):"

#. type: TP
#: man-pages/man4/st.4:421
#, no-wrap
msgid "B<MTSETDRVBUFFER>"
msgstr "B<MTSETDRVBUFFER>"

#. type: Plain text
#: man-pages/man4/st.4:430
msgid ""
"Set various drive and driver options according to bits encoded in "
"I<mt_count>.  These consist of the drive's buffering mode, a set of Boolean "
"driver options, the buffer write threshold, defaults for the block size and "
"density, and timeouts (only in kernels 2.1 and later).  A single operation "
"can affect only one item in the list above (the Booleans counted as one "
"item.)"
msgstr ""
"Установка различных параметров устройства и драйвера согласно битам "
"I<mt_count>. Задаётся режим буферизации устройства, набор логических "
"параметров драйвера, порог буфера записи, значения по умолчанию для размера "
"блока, плотности и время ожидания (только для ядра версии 2.1 или более "
"поздних). Одна операция может присваивать значение только одного пункта из "
"списка выше (логические параметры считаются за одну)."

#. type: Plain text
#: man-pages/man4/st.4:434
msgid ""
"A value having zeros in the high-order 4 bits will be used to set the "
"drive's buffering mode.  The buffering modes are:"
msgstr ""
"Нулевое значение старших 4-х битов будет использовано для установки режима "
"буферизации устройства. Режимы буферизации:"

#. type: IP
#: man-pages/man4/st.4:435
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: man-pages/man4/st.4:440
msgid ""
"The drive will not report B<GOOD> status on write commands until the data "
"blocks are actually written to the medium."
msgstr ""
"Устройство не сообщит, что запись прошла успешно (B<GOOD>) до тех пор, пока "
"блоки данных фактически не будут записаны на носитель."

#. type: IP
#: man-pages/man4/st.4:440
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: man-pages/man4/st.4:445
msgid ""
"The drive may report B<GOOD> status on write commands as soon as all the "
"data has been transferred to the drive's internal buffer."
msgstr ""
"Устройство может сообщить, что запись прошла успешно после того, как все "
"данные будут перемещены во внутренний буфер устройства."

#. type: IP
#: man-pages/man4/st.4:445
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: man-pages/man4/st.4:452
msgid ""
"The drive may report B<GOOD> status on write commands as soon as (a) all the "
"data has been transferred to the drive's internal buffer, and (b) all "
"buffered data from different initiators has been successfully written to the "
"medium."
msgstr ""
"Устройство может сообщить, что запись прошла успешно после того, как: (а) "
"все данные будут перемещены во внутренний буфер устройства и (б) все "
"буферизованные данные из различных источников были успешно записаны на "
"носитель."

#. type: Plain text
#: man-pages/man4/st.4:463
msgid ""
"To control the write threshold the value in I<mt_count> must include the "
"constant B<MT_ST_WRITE_THRESHOLD> bitwise ORed with a block count in the low "
"28 bits.  The block count refers to 1024-byte blocks, not the physical block "
"size on the tape.  The threshold cannot exceed the driver's internal buffer "
"size (see DESCRIPTION, above)."
msgstr ""
"Для контроля записи пороговое значение I<mt_count> должно включать в себя "
"константу B<MT_ST_WRITE_THRESHOLD> побитно сложенную (OR) с счётчиком  "
"блоков в первых 28-и битах. Счётчик блоков содержит количество блоков по "
"1024 байта, а не физических блоков на ленте. Пороговое значение не может "
"превышать размер внутреннего буфера устройства. (см. ОПИСАНИЕ выше)."

#. type: Plain text
#: man-pages/man4/st.4:484
msgid ""
"To set and clear the Boolean options the value in I<mt_count> must include "
"one of the constants B<MT_ST_BOOLEANS>, B<MT_ST_SETBOOLEANS>, "
"B<MT_ST_CLEARBOOLEANS>, or B<MT_ST_DEFBOOLEANS> bitwise ORed with whatever "
"combination of the following options is desired.  Using B<MT_ST_BOOLEANS> "
"the options can be set to the values defined in the corresponding bits.  "
"With B<MT_ST_SETBOOLEANS> the options can be selectively set and with "
"B<MT_ST_DEFBOOLEANS> selectively cleared."
msgstr ""
"Для установки и очистки логических параметров значение I<mt_count> должно "
"включать в себя одну из констант: B<MT_ST_BOOLEANS>, B<MT_ST_SETBOOLEANS>, "
"B<MT_ST_CLEARBOOLEANS>, B<MT_ST_DEFBOOLEANS>  или любую их побитно сложенную "
"комбинацию. Используя параметры B<MT_ST_BOOLEANS> можно задать значения "
"соответствующими битами. С помощью параметров B<MT_ST_SETBOOLEANS> можно "
"выборочно установить, а с помощью B<MT_ST_DEFBOOLEANS> \\(em выборочно "
"сбросить некоторые биты."

#. type: Plain text
#: man-pages/man4/st.4:492
msgid ""
"The default options for a tape device are set with B<MT_ST_DEFBOOLEANS>.  A "
"nonactive tape device (e.g., device with minor 32 or 160) is activated when "
"the default options for it are defined the first time.  An activated device "
"inherits from the device activated at start-up the options not set "
"explicitly."
msgstr ""
"Параметры по умолчанию для ленточного устройства устанавливаются с помощью "
"B<MT_ST_DEFBOOLEANS>. Неактивное ленточное устройство (например, устройство "
"с младшим номером 32 или 160) активируется когда для него назначаются "
"параметры по умолчанию в первый раз. Активированное устройство наследует "
"параметры, которые не заданы явно, от устройства, активированного при "
"загрузке ОС."

#. type: Plain text
#: man-pages/man4/st.4:494
msgid "The Boolean options are:"
msgstr "Логические параметры:"

#. type: TP
#: man-pages/man4/st.4:495
#, no-wrap
msgid "B<MT_ST_BUFFER_WRITES> (Default: true)"
msgstr "B<MT_ST_BUFFER_WRITES> (по умолчанию true)"

#. type: Plain text
#: man-pages/man4/st.4:501
msgid ""
"Buffer all write operations in fixed-block mode.  If this option is false "
"and the drive uses a fixed block size, then all write operations must be for "
"a multiple of the block size.  This option must be set false to write "
"reliable multivolume archives."
msgstr ""
"Выполнять буферизацию чтения и опережающее чтение в режиме с постоянным "
"размером блока. Если значение параметра равно false и устройство использует "
"режим с постоянным размером блока, то во всех операциях чтения должны "
"использоваться блоки кратной длины. Для надёжной записи многотомных архивов "
"значение этого параметра должно быть равно false."

#. type: TP
#: man-pages/man4/st.4:501
#, no-wrap
msgid "B<MT_ST_ASYNC_WRITES> (Default: true)"
msgstr "B<MT_ST_ASYNC_WRITES> (по умолчанию true)"

#. type: Plain text
#: man-pages/man4/st.4:511
msgid ""
"When this option is true, write operations return immediately without "
"waiting for the data to be transferred to the drive if the data fits into "
"the driver's buffer.  The write threshold determines how full the buffer "
"must be before a new SCSI write command is issued.  Any errors reported by "
"the drive will be held until the next operation.  This option must be set "
"false to write reliable multivolume archives."
msgstr ""
"Когда значение этого параметра равно true, то операции записи сразу "
"завершаются, не дожидаясь пока данные переместятся в устройство, если данные "
"помещаются в буфер драйвера. Порог записи определяет, насколько должен быть "
"заполнен буфер до ввода новых SCSI-команд. Любые ошибки, возвращённые "
"устройством, хранятся до следующей операции. Для надёжной записи многотомных "
"архивов значение этого параметра должно быть равно false."

#. type: TP
#: man-pages/man4/st.4:511
#, no-wrap
msgid "B<MT_ST_READ_AHEAD> (Default: true)"
msgstr "B<MT_ST_READ_AHEAD> (по умолчанию true)"

#. type: Plain text
#: man-pages/man4/st.4:517
msgid ""
"This option causes the driver to provide read buffering and read-ahead in "
"fixed-block mode.  If this option is false and the drive uses a fixed block "
"size, then all read operations must be for a multiple of the block size."
msgstr ""
"Этот параметр указывает драйверу выполнять буферизацию чтения и опережающее "
"чтение в режиме с постоянным размером блока. Если значение параметра равно "
"false и устройство использует режим с постоянным размером блока, то во всех "
"операциях чтения должны использоваться блоки кратной длины."

#. type: TP
#: man-pages/man4/st.4:517
#, no-wrap
msgid "B<MT_ST_TWO_FM> (Default: false)"
msgstr "B<MT_ST_TWO_FM> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:523
msgid ""
"This option modifies the driver behavior when a file is closed.  The normal "
"action is to write a single filemark.  If the option is true, the driver "
"will write two filemarks and backspace over the second one."
msgstr ""
"Этот параметр изменяет поведение драйвера после закрытия файла. По умолчанию "
"драйвер записывает один маркер файла. Если значение параметра равно true, то "
"драйвер запишет два маркера файла и вернётся на место второго."

#. type: Plain text
#: man-pages/man4/st.4:532
msgid ""
"Note: This option should not be set true for QIC tape drives since they are "
"unable to overwrite a filemark.  These drives detect the end of recorded "
"data by testing for blank tape rather than two consecutive filemarks.  Most "
"other current drives also detect the end of recorded data and using two "
"filemarks is usually necessary only when interchanging tapes with some other "
"systems."
msgstr ""
"Замечание: этому параметру не может быть присвоено значение true для "
"ленточных устройств QIC, так как  они не могут перезаписать маркер файла. "
"Они находят конец записанных данных ища пустое место на ленте, а не два "
"последовательных маркера файла. Многие современные устройства также находят "
"конец записанных данных, и использование двух меток файла обычно необходимо "
"только при одновременном использовании лент в нескольких разных системах."

#. type: TP
#: man-pages/man4/st.4:532
#, no-wrap
msgid "B<MT_ST_DEBUGGING> (Default: false)"
msgstr "B<MT_ST_DEBUGGING> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:538
msgid ""
"This option turns on various debugging messages from the driver (effective "
"only if the driver was compiled with B<DEBUG> defined nonzero)."
msgstr ""
"Этот параметр включает вывод отладочных сообщений драйвера (работает только "
"в том случае, если драйвер был собран с ненулевым значением B<DEBUG>)."

#. type: TP
#: man-pages/man4/st.4:538
#, no-wrap
msgid "B<MT_ST_FAST_EOM> (Default: false)"
msgstr "B<MT_ST_FAST_EOM> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:552
msgid ""
"This option causes the B<MTEOM> operation to be sent directly to the drive, "
"potentially speeding up the operation but causing the driver to lose track "
"of the current file number normally returned by the B<MTIOCGET> request.  If "
"B<MT_ST_FAST_EOM> is false, the driver will respond to an B<MTEOM> request "
"by forward spacing over files."
msgstr ""
"Этот параметр заставляет посылать операцию B<MTEOM> непосредственно "
"устройству, потенциально увеличивая скорость операций, но возникает "
"опасность потерять дорожку текущего файла, номер которой обычно возвращается "
"по запросу B<MTIOCGET>. Если значение параметра B<MT_ST_FAST_EOM> равно "
"false, то драйвер отвечает на запрос B<MTEOM>, перематывая ленту к концу "
"записанных файлов."

#. type: TP
#: man-pages/man4/st.4:552
#, no-wrap
msgid "B<MT_ST_AUTO_LOCK> (Default: false)"
msgstr "B<MT_ST_AUTO_LOCK> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:556
msgid ""
"When this option is true, the drive door is locked when the device is opened "
"and unlocked when it is closed."
msgstr ""
"Когда этому параметру присвоено значение true, дверца блокируется, если "
"устройство открыто, и дверца разблокируется, когда устройство закрыто."

#. type: TP
#: man-pages/man4/st.4:556
#, no-wrap
msgid "B<MT_ST_DEF_WRITES> (Default: false)"
msgstr "B<MT_ST_DEF_WRITES> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:573
msgid ""
"The tape options (block size, mode, compression, etc.) may change when "
"changing from one device linked to a drive to another device linked to the "
"same drive depending on how the devices are defined.  This option defines "
"when the changes are enforced by the driver using SCSI-commands and when the "
"drives auto-detection capabilities are relied upon.  If this option is "
"false, the driver sends the SCSI-commands immediately when the device is "
"changed.  If the option is true, the SCSI-commands are not sent until a "
"write is requested.  In this case, the drive firmware is allowed to detect "
"the tape structure when reading and the SCSI-commands are used only to make "
"sure that a tape is written according to the correct specification."
msgstr ""
"Параметры ленты (размер блока, режим, сжатие и т.д.) могут изменяться, когда "
"выполняется переход от одного устройства к другому устройству, которое "
"связано с тем же устройством, в зависимости от того, как определяются "
"устройства. Этот параметр определяет, будут ли применяться изменения через "
"драйвер при помощи команд SCSI, или устройство само определит возможности, "
"которые будут использоваться. Если значение параметра равно false, то "
"драйвер будет посылать команды SCSI сразу после смены устройства. Если "
"значение параметра равно true, команды SCSI не отправляются до запроса "
"записи. В этом случае микропрограмма устройства позволяет выполнить "
"обнаружение структуры ленты во время чтения, а команды SCSI используются "
"только для проверки правильности записи на ленту в соответствии со "
"спецификацией."

#. type: TP
#: man-pages/man4/st.4:573
#, no-wrap
msgid "B<MT_ST_CAN_BSR> (Default: false)"
msgstr "B<MT_ST_CAN_BSR> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:586
msgid ""
"When read-ahead is used, the tape must sometimes be spaced backward to the "
"correct position when the device is closed and the SCSI command to space "
"backward over records is used for this purpose.  Some older drives can't "
"process this command reliably and this option can be used to instruct the "
"driver not to use the command.  The end result is that, with read-ahead and "
"fixed-block mode, the tape may not be correctly positioned within a file "
"when the device is closed.  With 2.6 kernel, the default is true for drives "
"supporting SCSI-3."
msgstr ""
"Если используется упреждающее чтение, лента должна быть иногда перемотана "
"назад для правильного её размещения при закрытом устройстве. Для перемотки "
"ленты назад используется команда SCSI. Некоторые старые устройства не могут "
"правильно обрабатывать эту команду, и этот параметр может использоваться для "
"того, чтобы указать драйверу не применять данную команду. В конечном итоге, "
"с упреждающим чтением и в режиме с постоянным размером блока может быть "
"неверно определено местоположение файла при закрытом устройстве. В ядре 2.6 "
"значение параметра равно true для устройств с поддержкой SCSI-3."

#. type: TP
#: man-pages/man4/st.4:586
#, no-wrap
msgid "B<MT_ST_NO_BLKLIMS> (Default: false)"
msgstr "B<MT_ST_NO_BLKLIMS> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:595
msgid ""
"Some drives don't accept the B<READ BLOCK LIMITS> SCSI command.  If this is "
"used, the driver does not use the command.  The drawback is that the driver "
"can't check before sending commands if the selected block size is acceptable "
"to the drive."
msgstr ""
"Некоторые устройства не понимают SCSI-команду B<READ BLOCK LIMITS>. Если "
"параметр установлен, то драйвер не исполняет эту команду. Недостатком этого "
"является невозможность проверки драйвером до отправки команд, поддерживается "
"ли устройством выбранный размер блока."

#. type: TP
#: man-pages/man4/st.4:595
#, no-wrap
msgid "B<MT_ST_CAN_PARTITIONS> (Default: false)"
msgstr "B<MT_ST_CAN_PARTITIONS> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:600
msgid ""
"This option enables support for several partitions within a tape.  The "
"option applies to all devices linked to a drive."
msgstr ""
"Этот параметр даёт возможность поддерживать несколько разделов на ленте. Он "
"применяется ко всем файлам устройств, связанным с устройством."

#. type: TP
#: man-pages/man4/st.4:600
#, no-wrap
msgid "B<MT_ST_SCSI2LOGICAL> (Default: false)"
msgstr "B<MT_ST_SCSI2LOGICAL> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:615
msgid ""
"This option instructs the driver to use the logical block addresses defined "
"in the SCSI-2 standard when performing the seek and tell operations (both "
"with B<MTSEEK> and B<MTIOCPOS> commands and when changing tape partition).  "
"Otherwise, the device-specific addresses are used.  It is highly advisable "
"to set this option if the drive supports the logical addresses because they "
"count also filemarks.  There are some drives that support only the logical "
"block addresses."
msgstr ""
"Этот параметр заставляет драйвер использовать адресацию логических блоков, "
"определённую в стандарте SCSI-2 для выполнения операций поиска и пересчёта "
"(с командами B<MTSEEK> и B<MTIOCPOS> и в том случае, когда изменяются "
"разделы ленты). Желательно установить этот параметр, если устройство "
"поддерживает логические адреса, потому что они рассчитывают также и маркеры "
"файлов. Некоторые устройства поддерживают только адресацию логических блоков."

#. type: TP
#: man-pages/man4/st.4:615
#, no-wrap
msgid "B<MT_ST_SYSV> (Default: false)"
msgstr "B<MT_ST_SYSV> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:626
msgid ""
"When this option is enabled, the tape devices use the SystemV semantics.  "
"Otherwise, the BSD semantics are used.  The most important difference "
"between the semantics is what happens when a device used for reading is "
"closed: in System V semantics the tape is spaced forward past the next "
"filemark if this has not happened while using the device.  In BSD semantics "
"the tape position is not changed."
msgstr ""
"Когда этот параметр установлен, ленточные устройства используют семантику "
"SystemV. В других случаях используется семантика BSD. Основное  различие "
"между ними (когда устройство, используемое для чтения, закрыто) состоит в "
"следующем: по семантике SYSV лента перематывается вперед за следующий маркер "
"файла, если этого не произошло во время использования устройства. В "
"семантике BSD позиция на ленте не меняется."

#. type: TP
#: man-pages/man4/st.4:626
#, no-wrap
msgid "B<MT_NO_WAIT> (Default: false)"
msgstr "B<MT_NO_WAIT> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:630
msgid ""
"Enables immediate mode (i.e., don't wait for the command to finish) for some "
"commands (e.g., rewind)."
msgstr ""
"Включает режим без задержки (т.е., не ждать завершения работы команды) для "
"некоторых команд (например, rewind)."

#. type: Plain text
#: man-pages/man4/st.4:632
msgid "An example:"
msgstr "Пример:"

#. type: Plain text
#: man-pages/man4/st.4:640
#, no-wrap
msgid ""
"struct mtop mt_cmd;\n"
"mt_cmd.mt_op = MTSETDRVBUFFER;\n"
"mt_cmd.mt_count = MT_ST_BOOLEANS |\n"
"        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;\n"
"ioctl(fd, MTIOCTOP, mt_cmd);\n"
msgstr ""
"struct mtop mt_cmd;\n"
"mt_cmd.mt_op = MTSETDRVBUFFER;\n"
"mt_cmd.mt_count = MT_ST_BOOLEANS |\n"
"        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;\n"
"ioctl(fd, MTIOCTOP, mt_cmd);\n"

#. type: Plain text
#: man-pages/man4/st.4:650
msgid ""
"The default block size for a device can be set with B<MT_ST_DEF_BLKSIZE> and "
"the default density code can be set with B<MT_ST_DEFDENSITY>.  The values "
"for the parameters are or'ed with the operation code."
msgstr ""
"Размер блока по умолчанию для устройства может быть установлен с помощью "
"B<MT_ST_DEF_BLKSIZE>, а плотность данных по умолчанию может быть установлена "
"с помощью B<MT_ST_DEFDENSITY>. Значения параметров логически складываются с "
"кодом операции."

#. type: Plain text
#: man-pages/man4/st.4:667
msgid ""
"With kernels 2.1.x and later, the timeout values can be set with the "
"subcommand B<MT_ST_SET_TIMEOUT> ORed with the timeout in seconds.  The long "
"timeout (used for rewinds and other commands that may take a long time) can "
"be set with B<MT_ST_SET_LONG_TIMEOUT>.  The kernel defaults are very long to "
"make sure that a successful command is not timed out with any drive.  "
"Because of this, the driver may seem stuck even if it is only waiting for "
"the timeout.  These commands can be used to set more practical values for a "
"specific drive.  The timeouts set for one device apply for all devices "
"linked to the same drive."
msgstr ""
"В ядре версии 2.1.x и более поздних время ожидания может быть установлено "
"подкомандой B<MT_ST_SET_TIMEOUT> логически сложенной со значением ожидания. "
"Долгое время ожидания (используется при перемотке и выполнении других "
"команд, занимающих длительное время) может быть установлено с помощью "
"B<MT_ST_SET_LONG_TIMEOUT>. Значения, используемые в ядре по умолчанию, "
"слишком велики, для уверенности в том, время ожидания не истечёт. Из-за "
"этого драйвер может надолго застрять в ожидании. Эти команды могут быть "
"использованы для установки оптимальных для значений различных устройств. "
"Установка времени ожидания для одного устройства применяется для всех файлов "
"устройств, связанных с этим устройством."

#. type: Plain text
#: man-pages/man4/st.4:688
msgid ""
"Starting from kernels 2.4.19 and 2.5.43, the driver supports a status bit "
"which indicates whether the drive requests cleaning.  The method used by the "
"drive to return cleaning information is set using the B<MT_ST_SEL_CLN> "
"subcommand.  If the value is zero, the cleaning bit is always zero.  If the "
"value is one, the TapeAlert data defined in the SCSI-3 standard is used (not "
"yet implemented).  Values 2\\(en17 are reserved.  If the lowest eight bits "
"are E<gt>= 18, bits from the extended sense data are used.  The bits "
"9\\(en16 specify a mask to select the bits to look at and the bits 17\\(en23 "
"specify the bit pattern to look for.  If the bit pattern is zero, one or "
"more bits under the mask indicate the cleaning request.  If the pattern is "
"nonzero, the pattern must match the masked sense data byte."
msgstr ""
"Начиная с ядер 2.4.19 и 2.5.43, в драйвере появился бит состояния, который "
"показывает, была ли запрошена очистка у устройства. Метод, используемый "
"устройством для возврата информации об очистке, задаётся с помощью "
"подкоманды B<MT_ST_SEL_CLN>. Если значение равно 0, то бит очистки всегда "
"ноль. Если значение равно 1, то используются данные TapeAlert, определённые "
"в стандарте SCSI-3 (пока не реализовано). Значения 2\\(en17 зарезервированы. "
"Если самые младшие восемь бит E<gt>= 18, то используются биты из расширенных "
"данных уточнённого состояния (extended sense data). Биты 9\\(en16 задают "
"маску для выбора бит, которые должны просматриваться, а биты 17\\(en23 "
"задают битовый шаблон поиска. Если битовый шаблон равен 0, то один или более "
"бит в маске указывают на запрос очистки. Если шаблон не равен нулю, то "
"шаблон должен совпадать с байтом уточнённого состояния согласно маске."

#. type: SS
#: man-pages/man4/st.4:688
#, no-wrap
msgid "MTIOCGET \\(em get status"
msgstr "MTIOCGET \\(em получение состояния ленты"

#. type: Plain text
#: man-pages/man4/st.4:692
msgid "This request takes an argument of type I<(struct mtget\\ *)>."
msgstr "Для этого запроса требуется аргумент с типом I<(struct mtget\\ *)>."

#. type: Plain text
#: man-pages/man4/st.4:707
#, no-wrap
msgid ""
"/* structure for MTIOCGET - mag tape get status command */\n"
"struct mtget {\n"
"    long     mt_type;\n"
"    long     mt_resid;\n"
"    /* the following registers are device dependent */\n"
"    long     mt_dsreg;\n"
"    long     mt_gstat;\n"
"    long     mt_erreg;\n"
"    /* The next two fields are not always used */\n"
"    daddr_t  mt_fileno;\n"
"    daddr_t  mt_blkno;\n"
"};\n"
msgstr ""
"/* структура для MTIOCGET - команда получения состояния ленты */\n"
"struct mtget {\n"
"    long     mt_type;\n"
"    long     mt_resid;\n"
"    /* следующие регистры зависят от устройства */\n"
"    long     mt_dsreg;\n"
"    long     mt_gstat;\n"
"    long     mt_erreg;\n"
"    /* следующие два поля используются не всегда */\n"
"    daddr_t  mt_fileno;\n"
"    daddr_t  mt_blkno;\n"
"};\n"

#. type: IP
#: man-pages/man4/st.4:709
#, no-wrap
msgid "I<mt_type>"
msgstr "I<mt_type>"

#. type: Plain text
#: man-pages/man4/st.4:718
msgid ""
"The header file defines many values for I<mt_type>, but the current driver "
"reports only the generic types B<MT_ISSCSI1> (Generic SCSI-1 tape)  and "
"B<MT_ISSCSI2> (Generic SCSI-2 tape)."
msgstr ""
"В заголовочном файле определено множество значений I<mt_type>, но текущий "
"драйвер сообщает только об общих типах B<MT_ISSCSI1> (лента общего типа "
"SCSI-1) и B<MT_ISSCSI2> (лента общего типа SCSI-2)."

#. type: IP
#: man-pages/man4/st.4:718
#, no-wrap
msgid "I<mt_resid>"
msgstr "I<mt_resid>"

#. type: Plain text
#: man-pages/man4/st.4:720
msgid "contains the current tape partition number."
msgstr "Содержит номер текущего раздела ленты."

#. type: IP
#: man-pages/man4/st.4:720
#, no-wrap
msgid "I<mt_dsreg>"
msgstr "I<mt_dsreg>"

#. type: Plain text
#: man-pages/man4/st.4:729
msgid ""
"reports the drive's current settings for block size (in the low 24 bits) and "
"density (in the high 8 bits).  These fields are defined by "
"B<MT_ST_BLKSIZE_SHIFT>, B<MT_ST_BLKSIZE_MASK>, B<MT_ST_DENSITY_SHIFT>, and "
"B<MT_ST_DENSITY_MASK>."
msgstr ""
"Содержит текущие настройки размера блока устройства (в младших 24-х битах) и "
"плотность (в старших 8-х битах). Эти поля определяются с помощью "
"B<MT_ST_BLKSIZE_SHIFT>, B<MT_ST_BLKSIZE_MASK>, B<MT_ST_DENSITY_SHIFT> и "
"B<MT_ST_DENSITY_MASK>."

#. type: IP
#: man-pages/man4/st.4:729
#, no-wrap
msgid "I<mt_gstat>"
msgstr "I<mt_gstat>"

#. type: Plain text
#: man-pages/man4/st.4:732
msgid ""
"reports generic (device independent) status information.  The header file "
"defines macros for testing these status bits:"
msgstr ""
"Содержит общую (независимую от устройства) информацию о состоянии. В "
"заголовочном файле определены макросы для тестирования бит:"

#. type: Plain text
#: man-pages/man4/st.4:739
msgid ""
"B<GMT_EOF>(I<x>): The tape is positioned just after a filemark (always false "
"after an B<MTSEEK> operation)."
msgstr ""
"B<GMT_EOF>(I<x>): Текущая позиция сразу после маркера файла (всегда false "
"после выполнения операции B<MTSEEK>)."

#. type: Plain text
#: man-pages/man4/st.4:745
msgid ""
"B<GMT_BOT>(I<x>): The tape is positioned at the beginning of the first file "
"(always false after an B<MTSEEK> operation)."
msgstr ""
"B<GMT_BOT>(I<x>): Текущая позиция на начале первого файла (всегда false "
"после операции B<MTSEEK>)."

#. type: Plain text
#: man-pages/man4/st.4:748
msgid ""
"B<GMT_EOT>(I<x>): A tape operation has reached the physical End Of Tape."
msgstr "B<GMT_EOT>(I<x>): Текущая позиция у физического конца ленты."

#. type: Plain text
#: man-pages/man4/st.4:754
msgid ""
"B<GMT_SM>(I<x>): The tape is currently positioned at a setmark (always false "
"after an B<MTSEEK> operation)."
msgstr ""
"B<GMT_SM>(I<x>): Текущая позиция на сборочном маркере (всегда false после "
"выполнения операции B<MTSEEK>)."

#. type: Plain text
#: man-pages/man4/st.4:757
msgid "B<GMT_EOD>(I<x>): The tape is positioned at the end of recorded data."
msgstr "B<GMT_EOD>(I<x>): Текущая позиция в конце записанных данных."

#. type: Plain text
#: man-pages/man4/st.4:762
msgid ""
"B<GMT_WR_PROT>(I<x>): The drive is write-protected.  For some drives this "
"can also mean that the drive does not support writing on the current medium "
"type."
msgstr ""
"B<GMT_WR_PROT>(I<x>): Устройство защищено от записи. Для некоторых устройств "
"это может означать, что они не поддерживают запись на установленный носитель "
"(неподдерживаемый тип)."

#. type: Plain text
#: man-pages/man4/st.4:767
msgid ""
"B<GMT_ONLINE>(I<x>): The last B<open>(2)  found the drive with a tape in "
"place and ready for operation."
msgstr ""
"B<GMT_ONLINE>(I<x>): Последний вызов B<open>(2) привёл к тому, что лента в "
"нужном месте и устройство готово к работе."

#. type: Plain text
#: man-pages/man4/st.4:771
msgid ""
"B<GMT_D_6250>(I<x>), B<GMT_D_1600>(I<x>), B<GMT_D_800>(I<x>): This "
"\\(lqgeneric\\(rq status information reports the current density setting for "
"9-track \\(12\" tape drives only."
msgstr ""
"B<GMT_D_6250>(I<x>), B<GMT_D_1600>(I<x>), B<GMT_D_800>(I<x>): \"Общая\" "
"информация о текущей плотности только для 9-дорожечных \\(12\" устройств."

#. type: Plain text
#: man-pages/man4/st.4:774
msgid "B<GMT_DR_OPEN>(I<x>): The drive does not have a tape in place."
msgstr "B<GMT_DR_OPEN>(I<x>): Нет ленты в устройстве."

#. type: Plain text
#: man-pages/man4/st.4:782
msgid ""
"B<GMT_IM_REP_EN>(I<x>): Immediate report mode.  This bit is set if there are "
"no guarantees that the data has been physically written to the tape when the "
"write call returns.  It is set zero only when the driver does not buffer "
"data and the drive is set not to buffer data."
msgstr ""
"B<GMT_IM_REP_EN>(I<x>): Сообщает о режиме. Этот бит устанавливается, если "
"нет гарантии, что данные были правильно физически записаны на ленту после "
"возврата из функции записи. Этот бит приобретает нулевое значение, когда "
"драйвер не записывает данные в буфер и устройство не настроено на "
"буферизацию данных."

#. type: Plain text
#: man-pages/man4/st.4:786
msgid ""
"B<GMT_CLN>(I<x>): The drive has requested cleaning.  Implemented in kernels "
"since 2.4.19 and 2.5.43."
msgstr ""
"B<GMT_CLN>(I<x>): У устройства запросили очистку. Реализовано в ядрах, "
"начиная с 2.4.19 и 2.5.43."

#. type: IP
#: man-pages/man4/st.4:787
#, no-wrap
msgid "I<mt_erreg>"
msgstr "I<mt_erreg>"

#. type: Plain text
#: man-pages/man4/st.4:797
msgid ""
"The only field defined in I<mt_erreg> is the recovered error count in the "
"low 16 bits (as defined by B<MT_ST_SOFTERR_SHIFT> and "
"B<MT_ST_SOFTERR_MASK>.  Due to inconsistencies in the way drives report "
"recovered errors, this count is often not maintained (most drives do not by "
"default report soft errors but this can be changed with a SCSI MODE SELECT "
"command)."
msgstr ""
"Содержит счётчик (младшие 16 бит) исправленных ошибок, определяемых с "
"помощью B<MT_ST_SOFTERR_SHIFT> и B<MT_ST_SOFTERR_MASK>. Из-за "
"противоречивости способов сообщения об исправленных ошибках устройствами, "
"часто этот счётчик не ведётся (большинство устройств по умолчанию не "
"сообщают об исправленных ошибках, это можно изменить с помощью SCSI-команды "
"MODE SELECT)."

#. type: IP
#: man-pages/man4/st.4:797
#, no-wrap
msgid "I<mt_fileno>"
msgstr "I<mt_fileno>"

#. type: Plain text
#: man-pages/man4/st.4:803
msgid ""
"reports the current file number (zero-based).  This value is set to -1 when "
"the file number is unknown (e.g., after B<MTBSS> or B<MTSEEK>)."
msgstr ""
"Содержит текущий номер файла (отсчёт ведётся с 0). Если номер файла "
"неизвестен, то значение равно -1 (например, после B<MTBSS> или B<MTSEEK>)."

#. type: IP
#: man-pages/man4/st.4:803
#, no-wrap
msgid "I<mt_blkno>"
msgstr "I<mt_blkno>"

#. type: Plain text
#: man-pages/man4/st.4:810
msgid ""
"reports the block number (zero-based) within the current file.  This value "
"is set to -1 when the block number is unknown (e.g., after B<MTBSF>, "
"B<MTBSS>, or B<MTSEEK>)."
msgstr ""
"Содержит номер блока (отсчёт ведётся с 0) в пределах текущего файла. Если "
"номер блока неизвестен, то значение равно -1 (например, после B<MTBSF>, "
"B<MTBSS> или B<MTSEEK>)."

#. type: SS
#: man-pages/man4/st.4:810
#, no-wrap
msgid "MTIOCPOS \\(em get tape position"
msgstr "MTIOCPOS \\(em получение текущей позиции ленты"

#. type: Plain text
#: man-pages/man4/st.4:824
msgid ""
"This request takes an argument of type I<(struct mtpos\\ *)> and reports the "
"drive's notion of the current tape block number, which is not the same as "
"I<mt_blkno> returned by B<MTIOCGET>.  This drive must be a SCSI-2 drive that "
"supports the B<READ POSITION> command (device-specific address)  or a "
"Tandberg-compatible SCSI-1 drive (Tandberg, Archive Viper, Wangtek, ... )."
msgstr ""
"Для этого запроса требуется аргумент с типом I<(struct mtpos\\ *)>. Он "
"возвращает текущий номер блока ленты, который необязательно совпадает со "
"значением I<mt_blkno>, возвращаемым B<MTIOCGET>. Устройство должен быть "
"SCSI-2, чтобы поддерживать команду B<READ POSITION> (адрес, определяемый "
"устройством), или Tandberg-совместимым устройством SCSI-1 (Tandberg, Archive "
"Viper, Wangtek, …)."

#. type: Plain text
#: man-pages/man4/st.4:831
#, no-wrap
msgid ""
"/* structure for MTIOCPOS - mag tape get position command */\n"
"struct mtpos {\n"
"    long mt_blkno;    /* current block number */\n"
"};\n"
msgstr ""
"/* структура для MTIOCPOS - команда получения позиции на ленте */\n"
"struct mtpos {\n"
"    long mt_blkno;    /* текущий номер блока */\n"
"};\n"

#. type: SH
#: man-pages/man4/st.4:833
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: TP
#: man-pages/man4/st.4:835
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man4/st.4:840
msgid ""
"An attempt was made to write or erase a write-protected tape.  (This error "
"is not detected during B<open>(2).)"
msgstr ""
"Попытка записать или стереть ленту, защищённую от записи. (Эта ошибка не "
"возникает при B<open>(2).)"

#. type: TP
#: man-pages/man4/st.4:840
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man4/st.4:844
msgid ""
"The device is already in use or the driver was unable to allocate a buffer."
msgstr "Устройство уже используется, или драйвер не способен выделить буфер."

#. type: TP
#: man-pages/man4/st.4:844
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man4/st.4:848
msgid ""
"The command parameters point to memory not belonging to the calling process."
msgstr ""
"Параметры команды указывают на память, не принадлежащую вызывающему процессу."

#. type: TP
#: man-pages/man4/st.4:848
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man4/st.4:853
msgid ""
"An B<ioctl>(2)  had an invalid argument, or a requested block size was "
"invalid."
msgstr ""
"Вызову B<ioctl>(2) был передан неверный аргумент, или запрошен неправильный "
"размер блока."

#. type: TP
#: man-pages/man4/st.4:853
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man4/st.4:856
msgid "The requested operation could not be completed."
msgstr "Запрошенные операции не могут быть завершены."

#. type: TP
#: man-pages/man4/st.4:856
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: man-pages/man4/st.4:864
msgid ""
"The byte count in B<read>(2)  is smaller than the next physical block on the "
"tape.  (Before 2.2.18 and 2.4.0 the extra bytes have been silently ignored.)"
msgstr ""
"Счётчик байт в B<read>(2) меньше чем следующий физический блок ленты (до "
"версии 2.2.18 и 2.4.0 лишние байты просто игнорировались)."

#. type: TP
#: man-pages/man4/st.4:864
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man4/st.4:868
msgid ""
"A write operation could not be completed because the tape reached end-of-"
"medium."
msgstr "Операция записи не может завершиться, потому что лента закончилась."

#. type: TP
#: man-pages/man4/st.4:868
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man4/st.4:872
msgid "Unknown B<ioctl>(2)."
msgstr "Неизвестный вызов B<ioctl>(2)."

#. type: TP
#: man-pages/man4/st.4:872
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man4/st.4:875
msgid "During opening, the tape device does not exist."
msgstr "Во время открытия обнаружено, что ленточного устройства не существует."

#. type: TP
#: man-pages/man4/st.4:875
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: man-pages/man4/st.4:879
msgid ""
"An attempt was made to read or write a variable-length block that is larger "
"than the driver's internal buffer."
msgstr ""
"Попытка чтения или записи блоков переменной длины, больших, чем внутренний "
"буфер драйвера."

#. type: TP
#: man-pages/man4/st.4:879
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man4/st.4:886
msgid ""
"Open is attempted with B<O_WRONLY> or B<O_RDWR> when the tape in the drive "
"is write-protected."
msgstr ""
"Попытка открытия с параметром B<O_WRONLY> или B<O_RDWR>, но лента в "
"устройстве защищена от записи."

#. type: TP
#: man-pages/man4/st.4:887
#, no-wrap
msgid "I</dev/st*>"
msgstr "I</dev/st*>"

#. type: Plain text
#: man-pages/man4/st.4:890
msgid "the auto-rewind SCSI tape devices"
msgstr "ленточные устройства SCSI с автоперемоткой"

#. type: TP
#: man-pages/man4/st.4:890
#, no-wrap
msgid "I</dev/nst*>"
msgstr "I</dev/nst*>"

#.  .SH AUTHOR
#.  The driver has been written by Kai M\(:akisara (Kai.Makisara@metla.fi)
#.  starting from a driver written by Dwayne Forsyth.
#.  Several other
#.  people have also contributed to the driver.
#. type: Plain text
#: man-pages/man4/st.4:898
msgid "the nonrewind SCSI tape devices"
msgstr "ленточные устройства SCSI без автоперемотки"

#. type: IP
#: man-pages/man4/st.4:899
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man4/st.4:919
msgid ""
"When exchanging data between systems, both systems have to agree on the "
"physical tape block size.  The parameters of a drive after startup are often "
"not the ones most operating systems use with these devices.  Most systems "
"use drives in variable-block mode if the drive supports that mode.  This "
"applies to most modern drives, including DATs, 8mm helical scan drives, "
"DLTs, etc.  It may be advisable to use these drives in variable-block mode "
"also in Linux (i.e., use B<MTSETBLK> or B<MTSETDEFBLK> at system startup to "
"set the mode), at least when exchanging data with a foreign system.  The "
"drawback of this is that a fairly large tape block size has to be used to "
"get acceptable data transfer rates on the SCSI bus."
msgstr ""
"При обмене данными между системами в них должен быть согласован физический "
"размер блока ленты. Параметры устройства после загрузки часто не являются "
"теми, которые использует большинство операционных систем, работающих с этими "
"устройствами. Большинство систем используют устройства в режиме с переменным "
"размером блока, если этот режим поддерживается устройством. Это применимо к "
"большинству современных  устройств, включая DAT, DLT и т.д. Возможно, "
"целесообразно использовать эти устройства в режиме с переменным размером "
"блока также и в Linux (т.е., используйте B<MTSETBLK> или B<MTSETDEFBLK> при "
"запуске системы для установки необходимого режима), по крайней мере при "
"обмене данными с другими системами. Недостатком этого является довольно "
"большой размер блока ленты, который нужно использовать для работы на "
"приемлемой скорости при передаче данных по шине SCSI."

#. type: IP
#: man-pages/man4/st.4:919
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man4/st.4:926
msgid ""
"Many programs (e.g., B<tar>(1))  allow the user to specify the blocking "
"factor on the command line.  Note that this determines the physical block "
"size on tape only in variable-block mode."
msgstr ""
"Многие программы (например, B<tar>(1)) позволяют пользователю задать  размер "
"блока в командной строке. Заметим, что это помогает определить размер "
"физического блока на ленте, но только в режиме с переменным размером блока."

#. type: IP
#: man-pages/man4/st.4:926
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man4/st.4:933
msgid ""
"In order to use SCSI tape drives, the basic SCSI driver, a SCSI-adapter "
"driver and the SCSI tape driver must be either configured into the kernel or "
"loaded as modules.  If the SCSI-tape driver is not present, the drive is "
"recognized but the tape support described in this page is not available."
msgstr ""
"Для использования ленточных устройств SCSI, базовый драйвер SCSI, драйвер "
"SCSI-адаптера и драйвер ленты SCSI должны быть включены в ядро или "
"загружаться как модули. Если драйвер SCSI-ленты отсутствует, то устройство "
"считается распознанным, но поддержка работы с лентой, описанная здесь, будет "
"недоступна."

#. type: IP
#: man-pages/man4/st.4:933
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man4/st.4:938
msgid ""
"The driver writes error messages to the console/log.  The SENSE codes "
"written into some messages are automatically translated to text if verbose "
"SCSI messages are enabled in kernel configuration."
msgstr ""
"Драйвер записывает сообщения об ошибках в консоль/журнал. Коды SENSE, "
"содержащиеся в некоторых сообщениях, автоматически транслируются в текст, "
"если в ядре включён параметр подробного вывода сообщений SCSI."

#. type: IP
#: man-pages/man4/st.4:938
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: man-pages/man4/st.4:951
msgid ""
"The driver's internal buffering allows good throughput in fixed-block mode "
"also with small B<read>(2)  and B<write>(2)  byte counts.  With direct "
"transfers this is not possible and may cause a surprise when moving to the "
"2.6 kernel.  The solution is to tell the software to use larger transfers "
"(often telling it to use larger blocks).  If this is not possible, direct "
"transfers can be disabled."
msgstr ""
"Использование внутреннего буфера драйвера позволяет достичь хорошей "
"пропускной способности в режиме с постоянным размером блока даже с маленьким "
"числом байт в B<read>(2) и B<write>(2). Прямой обмен для этого невозможен и "
"может привести к неожиданностям при переходе на ядро 2.6. В качестве решения "
"предлагается указать ПО использовать больший обмен передачи (часто, указав "
"использовать больший размер блоков). Если это невозможно, то прямой обмен "
"может быть выключен."

#. type: Plain text
#: man-pages/man4/st.4:953
msgid "B<mt>(1)"
msgstr "B<mt>(1)"

#. type: Plain text
#: man-pages/man4/st.4:960
msgid ""
"The file I<drivers/scsi/README.st> or I<Documentation/scsi/st.txt> (kernel "
"E<gt>= 2.6) in the Linux kernel source tree contains the most recent "
"information about the driver and its configuration possibilities"
msgstr ""
"Файл I<drivers/scsi/README.st> или I<Documentation/scsi/st.txt> (ядро E<gt>= "
"2.6) из дерева исходного кода ядра Linux содержит самую последнюю информацию "
"о драйвере и его возможностях настройки"

#. type: TH
#: man-pages/man4/sd.4:26
#, no-wrap
msgid "SD"
msgstr "SD"

#. type: Plain text
#: man-pages/man4/sd.4:29
msgid "sd - driver for SCSI disk drives"
msgstr "sd - драйвер для дисковых накопителей SCSI"

#. type: Plain text
#: man-pages/man4/sd.4:33
#, no-wrap
msgid ""
"B<#include E<lt>linux/hdreg.hE<gt>        >/* for HDIO_GETGEO */\n"
"B<#include E<lt>linux/fs.hE<gt>           >/* for BLKGETSIZE and BLKRRPART */\n"
msgstr ""
"B<#include E<lt>linux/hdreg.hE<gt>        >/* для HDIO_GETGEO */\n"
"B<#include E<lt>linux/fs.hE<gt>           >/* для BLKGETSIZE и BLKRRPART */\n"

#. type: SH
#: man-pages/man4/sd.4:34
#, no-wrap
msgid "CONFIGURATION"
msgstr "НАСТРОЙКА"

#. type: Plain text
#: man-pages/man4/sd.4:45
msgid ""
"The block device name has the following form: B<sd>I<lp,> where I<l> is a "
"letter denoting the physical drive, and I<p> is a number denoting the "
"partition on that physical drive.  Often, the partition number, I<p>, will "
"be left off when the device corresponds to the whole drive."
msgstr ""
"Эти блочные устройства именуются согласно следующему формату: B<sd>I<lp,> "
"где I<l> \\(em буква, обозначающая физический накопитель, а I<p> \\(em номер "
"раздела на этом физическом накопителе. Часто номер раздела I<p> бывает "
"пропущен, тогда устройство соответствует полностью всему накопителю."

#. type: Plain text
#: man-pages/man4/sd.4:54
msgid ""
"SCSI disks have a major device number of 8, and a minor device number of the "
"form (16 * I<drive_number>) + I<partition_number>, where I<drive_number> is "
"the number of the physical drive in order of detection, and "
"I<partition_number> is as follows:"
msgstr ""
"Файлам устройств дисков SCSI присвоен старший номер 8, а младшие номера "
"устройств рассчитываются как (16 * I<номер_накопителя>) + I<номер_раздела>, "
"где I<номер_накопителя> \\(em это номер физического накопителя в порядке "
"обнаружения, а I<номер_раздела>:"

#. type: IP
#: man-pages/man4/sd.4:54
#, no-wrap
msgid "+3"
msgstr "+3"

#. type: Plain text
#: man-pages/man4/sd.4:56
msgid "partition 0 is the whole drive"
msgstr "раздел 0 \\(em накопитель полностью"

#. type: Plain text
#: man-pages/man4/sd.4:58
msgid "partitions 1\\(en4 are the DOS \"primary\" partitions"
msgstr "разделы 1\\(en4 —«первичные» разделы DOS"

#. type: Plain text
#: man-pages/man4/sd.4:60
msgid "partitions 5\\(en8 are the DOS \"extended\" (or \"logical\") partitions"
msgstr "разделы 5\\(en8 — «расширенные» (или «логические») разделы DOS"

#. type: Plain text
#: man-pages/man4/sd.4:68
msgid ""
"For example, I</dev/sda> will have major 8, minor 0, and will refer to all "
"of the first SCSI drive in the system; and I</dev/sdb3> will have major 8, "
"minor 19, and will refer to the third DOS \"primary\" partition on the "
"second SCSI drive in the system."
msgstr ""
"Например, устройство I</dev/sda> будет иметь старший номер 8, младший 0 и "
"указывать на первый накопитель SCSI в системе; устройство I</dev/sdb3> будет "
"иметь старший номер 8, младший 19 и указывать на третий \"первичный\" раздел "
"DOS на втором накопителе SCSI."

#. type: Plain text
#: man-pages/man4/sd.4:71
msgid ""
"At this time, only block devices are provided.  Raw devices have not yet "
"been implemented."
msgstr ""
"В настоящий момент поддерживаются только блочные устройства. Устройства для "
"прямого доступа (raw) пока не реализованы."

#. type: Plain text
#: man-pages/man4/sd.4:75
msgid "The following I<ioctl>s are provided:"
msgstr "Доступны следующие вызовы I<ioctl>:"

#. type: TP
#: man-pages/man4/sd.4:75
#, no-wrap
msgid "B<HDIO_GETGEO>"
msgstr "B<HDIO_GETGEO>"

#. type: Plain text
#: man-pages/man4/sd.4:78
msgid "Returns the BIOS disk parameters in the following structure:"
msgstr "Возвращает параметры диска из BIOS в виде следующей структуры:"

#. type: Plain text
#: man-pages/man4/sd.4:87
#, no-wrap
msgid ""
"struct hd_geometry {\n"
"    unsigned char  heads;\n"
"    unsigned char  sectors;\n"
"    unsigned short cylinders;\n"
"    unsigned long  start;\n"
"};\n"
msgstr ""
"struct hd_geometry {\n"
"    unsigned char  heads;\n"
"    unsigned char  sectors;\n"
"    unsigned short cylinders;\n"
"    unsigned long  start;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/sd.4:93
msgid "A pointer to this structure is passed as the B<ioctl>(2)  parameter."
msgstr "Указатель на эту структуру передаётся ioctl(2) в виде параметра."

#. type: Plain text
#: man-pages/man4/sd.4:108
msgid ""
"The information returned in the parameter is the disk geometry of the drive "
"I<as understood by DOS!> This geometry is I<not> the physical geometry of "
"the drive.  It is used when constructing the drive's partition table, "
"however, and is needed for convenient operation of B<fdisk>(1), "
"B<efdisk>(1), and B<lilo>(1).  If the geometry information is not available, "
"zero will be returned for all of the parameters."
msgstr ""
"Информация, возвращаемая в параметре, представляет собой геометрию дискового "
"накопителя I<как это понимается в DOS!> Эта геометрия I<не> является "
"физической геометрией накопителя. Однако, она используется при составлении "
"таблицы разделов накопителя, и требуется для удобства при работе с "
"B<fdisk>(1), B<efdisk>(1) и B<lilo>(1). Если информация о геометрии диска "
"недоступна, все поля структуры равны нулю."

#. type: TP
#: man-pages/man4/sd.4:108
#, no-wrap
msgid "B<BLKGETSIZE>"
msgstr "B<BLKGETSIZE>"

#. type: Plain text
#: man-pages/man4/sd.4:115
msgid ""
"Returns the device size in sectors.  The B<ioctl>(2)  parameter should be a "
"pointer to a I<long>."
msgstr ""
"Возвращает размер устройства в секторах. Параметр B<ioctl>(2) должен быть "
"указателем на I<long>."

#. type: TP
#: man-pages/man4/sd.4:115
#, no-wrap
msgid "B<BLKRRPART>"
msgstr "B<BLKRRPART>"

#. type: Plain text
#: man-pages/man4/sd.4:119
msgid ""
"Forces a reread of the SCSI disk partition tables.  No parameter is needed."
msgstr ""
"Заставляет перечитать таблицы разделов на диске SCSI. Используется без "
"параметра."

#. type: Plain text
#: man-pages/man4/sd.4:129
msgid ""
"The SCSI B<ioctl>(2)  operations are also supported.  If the B<ioctl>(2)  "
"parameter is required, and it is NULL, then B<ioctl>(2)  fails with the "
"error B<EINVAL>."
msgstr ""
"Также поддерживаются операции SCSI через B<ioctl>(2). Если B<ioctl>(2) "
"требуется параметр и он равен NULL, то B<ioctl>(2) завершается ошибкой "
"B<EINVAL>."

#. type: TP
#: man-pages/man4/sd.4:130
#, no-wrap
msgid "I</dev/sd[a-h]>"
msgstr "I</dev/sd[a-h]>"

#. type: Plain text
#: man-pages/man4/sd.4:133
msgid "the whole device"
msgstr "устройство целиком"

#. type: TP
#: man-pages/man4/sd.4:133
#, no-wrap
msgid "I</dev/sd[a-h][0-8]>"
msgstr "I</dev/sd[a-h][0-8]>"

#. type: Plain text
#: man-pages/man4/sd.4:135
msgid "individual block partitions"
msgstr "отдельные блочные разделы"

#. type: TH
#: man-pages/man8/sln.8:25
#, no-wrap
msgid "SLN"
msgstr "SLN"

#. type: TH
#: man-pages/man8/sln.8:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man8/sln.8:28
msgid "sln - create symbolic links"
msgstr "sln - создаёт символьные ссылки"

#. type: Plain text
#: man-pages/man8/sln.8:30
msgid "B<sln>I< source dest>"
msgstr "B<sln>I< source dest>"

#. type: Plain text
#: man-pages/man8/sln.8:32
msgid "B<sln>I< filelist>"
msgstr "B<sln>I< filelist>"

#. type: Plain text
#: man-pages/man8/sln.8:42
msgid ""
"The B<sln> program creates symbolic links.  Unlike the B<ln>(1)  program, it "
"is statically linked.  This means that if for some reason the dynamic linker "
"is not working, B<sln> can be used to make symbolic links to dynamic "
"libraries."
msgstr ""
"Программа B<sln> создаёт символьные ссылки. В отличие от программы B<ln>(1) "
"она собрана статически. Это означает, что если по какой-то причине "
"динамический компоновщик не работает, B<sln> можно использовать для создания "
"символьных ссылок на динамические библиотеки."

#. type: Plain text
#: man-pages/man8/sln.8:48
msgid ""
"The command line has two forms.  In the first form, it creates I<dest> as a "
"new symbolic link to I<source>."
msgstr ""
"Из командной строки есть два способа вызова. С помощью первого создаётся "
"I<dest> как символьная ссылка на I<source>."

#. type: Plain text
#: man-pages/man8/sln.8:56
msgid ""
"In the second form, I<filelist> is a list of space-separated pathname pairs, "
"and the effect is as if B<sln> was executed once for each line of the file, "
"with the two pathnames as the arguments."
msgstr ""
"Во втором I<filelist> — список пар путей через пробел; работает так, как "
"если бы B<sln> вызывался несколько раз с двумя путями в качестве аргументов."

#. type: Plain text
#: man-pages/man8/sln.8:60
msgid "The B<sln> program supports no command-line options."
msgstr "У программы B<sln> нет параметров командной строки."

#. type: Plain text
#: man-pages/man8/sln.8:63
msgid "B<ln>(1), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ln>(1), B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: man-pages/man1/sprof.1:25
#, no-wrap
msgid "SPROF"
msgstr "SPROF"

#. type: TH
#: man-pages/man1/sprof.1:25
#, no-wrap
msgid "Linux User Manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man1/sprof.1:28
msgid "sprof - read and display shared object profiling data"
msgstr "sprof - читает и показывает общие объекты данных профилирования"

#. type: Plain text
#: man-pages/man1/sprof.1:32
#, no-wrap
msgid "B<sprof> [I<option>]... I<shared-object-path> [I<profile-data-path>]\n"
msgstr "B<sprof> [I<параметр>]… I<shared-object-path> [I<profile-data-path>]\n"

#. type: Plain text
#: man-pages/man1/sprof.1:46
msgid ""
"The B<sprof> command displays a profiling summary for the shared object "
"(shared library) specified as its first command-line argument.  The "
"profiling summary is created using previously generated profiling data in "
"the (optional) second command-line argument.  If the profiling data pathname "
"is omitted, then B<sprof> will attempt to deduce it using the soname of the "
"shared object, looking for a file with the name I<E<lt>sonameE<gt>.profile> "
"in the current directory."
msgstr ""
"Команда B<sprof> выводит краткий отчёт по профилированию для общего объекта "
"(общей библиотеки), заданного в первом аргументе командной строки. Краткий "
"отчёт по профилированию создан с помощью ранее сгенерированных данных "
"профилирования во втором (необязательном) аргументе командной строки. Если "
"путь данных профилирования отсутствует, то B<sprof> попытается вычислить его "
"используя soname общего объекта и поищет файл с именем I<E<lt>sonameE<gt>."
"profile> в текущем каталоге."

#. type: SH
#: man-pages/man1/sprof.1:46
#, no-wrap
msgid "OPTIONS"
msgstr "ПАРАМЕТРЫ"

#. type: Plain text
#: man-pages/man1/sprof.1:49
msgid ""
"The following command-line options specify the profile output to be produced:"
msgstr ""
"Следующие параметры командной строки определяют выводимые данные "
"профилирования:"

#. type: TP
#: man-pages/man1/sprof.1:49
#, no-wrap
msgid "B<-c>, B<--call-pairs>"
msgstr "B<-c>, B<--call-pairs>"

#. type: Plain text
#: man-pages/man1/sprof.1:54
msgid ""
"Print a list of pairs of call paths for the interfaces exported by the "
"shared object, along with the number of times each path is used."
msgstr ""
"Вывести список пар путей вызова для интерфейсов, экспортируемых общим "
"объектом, а также сколько раз использовался каждый путь."

#. type: TP
#: man-pages/man1/sprof.1:54
#, no-wrap
msgid "B<-p>, B<--flat-profile>"
msgstr "B<-p>, B<--flat-profile>"

#. type: Plain text
#: man-pages/man1/sprof.1:58
msgid ""
"Generate a flat profile of all of the functions in the monitored object, "
"with counts and ticks."
msgstr ""
"Сгенерировать плоский профиль всех функций в отслеживаемом объекте, а также "
"количество вызовов и время работы."

#. type: TP
#: man-pages/man1/sprof.1:58
#, no-wrap
msgid "B<-q>, B<--graph>"
msgstr "B<-q>, B<--graph>"

#. type: Plain text
#: man-pages/man1/sprof.1:61
msgid "Generate a call graph."
msgstr "Сгенерировать граф вызовов."

#. type: Plain text
#: man-pages/man1/sprof.1:64
msgid ""
"If none of the above options is specified, then the default behavior is to "
"display a flat profile and a call graph."
msgstr ""
"Если ни один из этих параметров не указан, то действием по умолчанию "
"является вывод плоского профиля и графа вызовов."

#. type: Plain text
#: man-pages/man1/sprof.1:66
msgid "The following additional command-line options are available:"
msgstr "Доступны следующие дополнительные параметры командной строки:"

#. type: TP
#: man-pages/man1/sprof.1:66
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr "B<-?>, B<--help>"

#. type: Plain text
#: man-pages/man1/sprof.1:69
msgid "Display a summary of command-line options and arguments and exit."
msgstr ""
"Показать справку по параметрам командной строки и аргументам и завершить "
"работу."

#. type: TP
#: man-pages/man1/sprof.1:69
#, no-wrap
msgid "B<--usage>"
msgstr "B<--usage>"

#. type: Plain text
#: man-pages/man1/sprof.1:72
msgid "Display a short usage message and exit."
msgstr "Показать короткое сообщение об использовании и завершить работу."

#. type: TP
#: man-pages/man1/sprof.1:72
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr "B<-V>, B<--version>"

#. type: Plain text
#: man-pages/man1/sprof.1:75
msgid "Display the program version and exit."
msgstr "Вывести версию программы и выйти."

#. type: SH
#: man-pages/man1/sprof.1:75
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man1/sprof.1:79
msgid "The B<sprof> command is a GNU extension, not present in POSIX.1."
msgstr "Команда B<sprof> является расширением GNU и отсутствует в POSIX.1."

#. type: SH
#: man-pages/man1/sprof.1:79
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man1/sprof.1:85
msgid ""
"The following example demonstrates the use of B<sprof>.  The example "
"consists of a main program that calls two functions in a shared object.  "
"First, the code of the main program:"
msgstr ""
"В следующем примере показано использование B<sprof>. Пример состоит из "
"основной программы, которая вызывает две функции из общего объекта. Вот код "
"основной программы:"

#. type: Plain text
#: man-pages/man1/sprof.1:90
#, no-wrap
msgid ""
"$ B<cat prog.c>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"$ B<cat prog.c>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:93
#, no-wrap
msgid ""
"void x1(void);\n"
"void x2(void);\n"
msgstr ""
"void x1(void);\n"
"void x2(void);\n"

#. type: Plain text
#: man-pages/man1/sprof.1:101
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    x1();\n"
"    x2();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    x1();\n"
"    x2();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man1/sprof.1:110
msgid ""
"The functions I<x1>()  and I<x2>()  are defined in the following source file "
"that is used to construct the shared object:"
msgstr ""
"Функции I<x1>() и I<x2>() определены в следующем файле исходного кода, "
"который используется для сборки общего объекта:"

#. type: Plain text
#: man-pages/man1/sprof.1:115
#, no-wrap
msgid ""
"$ B<cat libdemo.c>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"$ B<cat libdemo.c>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:120
#, no-wrap
msgid ""
"void\n"
"consumeCpu1(int lim)\n"
"{\n"
"    int j;\n"
msgstr ""
"void\n"
"consumeCpu1(int lim)\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man1/sprof.1:124 man-pages/man1/sprof.1:141
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"
msgstr ""
"    for (j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"

#. type: Plain text
#: man-pages/man1/sprof.1:128
#, no-wrap
msgid ""
"void\n"
"x1(void) {\n"
"    int j;\n"
msgstr ""
"void\n"
"x1(void) {\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man1/sprof.1:132
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 100; j++)\n"
"\tconsumeCpu1(200000);\n"
"}\n"
msgstr ""
"    for (j = 0; j E<lt> 100; j++)\n"
"\tconsumeCpu1(200000);\n"
"}\n"

#. type: Plain text
#: man-pages/man1/sprof.1:137
#, no-wrap
msgid ""
"void\n"
"consumeCpu2(int lim)\n"
"{\n"
"    int j;\n"
msgstr ""
"void\n"
"consumeCpu2(int lim)\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man1/sprof.1:146
#, no-wrap
msgid ""
"void\n"
"x2(void)\n"
"{\n"
"    int j;\n"
msgstr ""
"void\n"
"x2(void)\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man1/sprof.1:150
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 1000; j++)\n"
"\tconsumeCpu2(10000);\n"
"}\n"
msgstr ""
"    for (j = 0; j E<lt> 1000; j++)\n"
"\tconsumeCpu2(10000);\n"
"}\n"

#. type: Plain text
#: man-pages/man1/sprof.1:157
msgid ""
"Now we construct the shared object with the real name I<libdemo.so.1.0.1>, "
"and the soname I<libdemo.so.1>:"
msgstr ""
"Соберём общий объект с реальным именем I<libdemo.so.1.0.1> и soname "
"I<libdemo.so.1>:"

#. type: Plain text
#: man-pages/man1/sprof.1:162
#, no-wrap
msgid ""
"$ B<cc -g -fPIC -shared -Wl,-soname,libdemo.so.1 \\e>\n"
"        B<-o libdemo.so.1.0.1 libdemo.c>\n"
msgstr ""
"$ B<cc -g -fPIC -shared -Wl,-soname,libdemo.so.1 \\e>\n"
"        B<-o libdemo.so.1.0.1 libdemo.c>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:167
msgid ""
"Then we construct symbolic links for the library soname and the library "
"linker name:"
msgstr ""
"Создадим символьные ссылки на soname библиотеки и имя библиотеки для "
"компоновщика:"

#. type: Plain text
#: man-pages/man1/sprof.1:172
#, no-wrap
msgid ""
"$ B<ln -sf libdemo.so.1.0.1 libdemo.so.1>\n"
"$ B<ln -sf libdemo.so.1 libdemo.so>\n"
msgstr ""
"$ B<ln -sf libdemo.so.1.0.1 libdemo.so.1>\n"
"$ B<ln -sf libdemo.so.1 libdemo.so>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:177
msgid ""
"Next, we compile the main program, linking it against the shared object, and "
"then list the dynamic dependencies of the program:"
msgstr ""
"Скомпилируем основную программу, скомпонуем её с общим объектом и выведем "
"список динамических зависимостей программы:"

#. type: Plain text
#: man-pages/man1/sprof.1:186
#, no-wrap
msgid ""
"$ B<cc -g -o prog prog.c -L. -ldemo>\n"
"$ B<ldd prog>\n"
"\tlinux-vdso.so.1 =E<gt>  (0x00007fff86d66000)\n"
"\tlibdemo.so.1 =E<gt> not found\n"
"\tlibc.so.6 =E<gt> /lib64/libc.so.6 (0x00007fd4dc138000)\n"
"\t/lib64/ld-linux-x86-64.so.2 (0x00007fd4dc51f000)\n"
msgstr ""
"$ B<cc -g -o prog prog.c -L. -ldemo>\n"
"$ B<ldd prog>\n"
"\tlinux-vdso.so.1 =E<gt>  (0x00007fff86d66000)\n"
"\tlibdemo.so.1 =E<gt> not found\n"
"\tlibc.so.6 =E<gt> /lib64/libc.so.6 (0x00007fd4dc138000)\n"
"\t/lib64/ld-linux-x86-64.so.2 (0x00007fd4dc51f000)\n"

#. type: Plain text
#: man-pages/man1/sprof.1:193
msgid ""
"In order to get profiling information for the shared object, we define the "
"environment variable B<LD_PROFILE> with the soname of the library:"
msgstr ""
"Чтобы получить информацию о профилировании общего объекта мы определим "
"переменную окружения B<LD_PROFILE> с soname библиотеки:"

#. type: Plain text
#: man-pages/man1/sprof.1:197
#, no-wrap
msgid "$ B<export LD_PROFILE=libdemo.so.1>\n"
msgstr "$ B<export LD_PROFILE=libdemo.so.1>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:204
msgid ""
"We then define the environment variable B<LD_PROFILE_OUTPUT> with the "
"pathname of the directory where profile output should be written, and create "
"that directory if it does not exist already:"
msgstr ""
"Затем определим переменную окружения B<LD_PROFILE_OUTPUT> с именем каталога "
"куда нужно сохранить результат профилирования и создадим этот каталог, если "
"его ещё нет:"

#. type: Plain text
#: man-pages/man1/sprof.1:209
#, no-wrap
msgid ""
"$ B<export LD_PROFILE_OUTPUT=$(pwd)/prof_data>\n"
"$ B<mkdir -p $LD_PROFILE_OUTPUT>\n"
msgstr ""
"$ B<export LD_PROFILE_OUTPUT=$(pwd)/prof_data>\n"
"$ B<mkdir -p $LD_PROFILE_OUTPUT>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:217
msgid ""
"B<LD_PROFILE> causes profiling output to be I<appended> to the output file "
"if it already exists, so we ensure that there is no preexisting profiling "
"data:"
msgstr ""
"Переменная B<LD_PROFILE> приводит к I<добавлению> результата профилирования "
"в выходной файл, если он уже существует, поэтому убедимся, что не существует "
"каких-либо результатов профилирования:"

#. type: Plain text
#: man-pages/man1/sprof.1:221
#, no-wrap
msgid "$ B<rm -f $LD_PROFILE_OUTPUT/$LD_PROFILE.profile>\n"
msgstr "$ B<rm -f $LD_PROFILE_OUTPUT/$LD_PROFILE.profile>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:227
msgid ""
"We then run the program to produce the profiling output, which is written to "
"a file in the directory specified in B<LD_PROFILE_OUTPUT>:"
msgstr ""
"Затем запустим программу для получения результата профилирования, которые "
"записывается в файл в каталоге, указанном в B<LD_PROFILE_OUTPUT>:"

#. type: Plain text
#: man-pages/man1/sprof.1:233
#, no-wrap
msgid ""
"$ B<LD_LIBRARY_PATH=. ./prog>\n"
"$ B<ls prof_data>\n"
"libdemo.so.1.profile\n"
msgstr ""
"$ B<LD_LIBRARY_PATH=. ./prog>\n"
"$ B<ls prof_data>\n"
"libdemo.so.1.profile\n"

#. type: Plain text
#: man-pages/man1/sprof.1:239
msgid ""
"We then use the B<sprof -p> option to generate a flat profile with counts "
"and ticks:"
msgstr ""
"Используем параметр B<sprof -p> для генерации плоского профиля с счётчиками "
"и временем:"

#. type: Plain text
#: man-pages/man1/sprof.1:244
#, no-wrap
msgid ""
"$ B<sprof -p libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"Flat profile:\n"
msgstr ""
"$ B<sprof -p libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"Плоский профиль:\n"

#. type: Plain text
#: man-pages/man1/sprof.1:252
#, no-wrap
msgid ""
"Each sample counts as 0.01 seconds.\n"
"  %   cumulative   self              self     total\n"
" time   seconds   seconds    calls  us/call  us/call  name\n"
" 60.00      0.06     0.06      100   600.00           consumeCpu1\n"
" 40.00      0.10     0.04     1000    40.00           consumeCpu2\n"
"  0.00      0.10     0.00        1     0.00           x1\n"
"  0.00      0.10     0.00        1     0.00           x2\n"
msgstr ""
"Each sample counts as 0.01 seconds.\n"
"  %   cumulative   self              self     total\n"
" time   seconds   seconds    calls  us/call  us/call  name\n"
" 60.00      0.06     0.06      100   600.00           consumeCpu1\n"
" 40.00      0.10     0.04     1000    40.00           consumeCpu2\n"
"  0.00      0.10     0.00        1     0.00           x1\n"
"  0.00      0.10     0.00        1     0.00           x2\n"

#. type: Plain text
#: man-pages/man1/sprof.1:258
msgid "The B<sprof -q> option generates a call graph:"
msgstr "Параметр B<sprof -q> генерирует граф вызовов:"

#. type: Plain text
#: man-pages/man1/sprof.1:262
#, no-wrap
msgid "$ B<sprof -q libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
msgstr "$ B<sprof -q libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"

#. type: Plain text
#: man-pages/man1/sprof.1:264
#, no-wrap
msgid "index % time    self  children    called     name\n"
msgstr "index % time    self  children    called     name\n"

#. type: Plain text
#: man-pages/man1/sprof.1:279
#, no-wrap
msgid ""
"                0.00    0.00      100/100         x1 [1]\n"
"[0]    100.0    0.00    0.00      100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[1]      0.0    0.00    0.00        1         x1 [1]\n"
"                0.00    0.00      100/100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00     1000/1000        x2 [3]\n"
"[2]      0.0    0.00    0.00     1000         consumeCpu2 [2]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[3]      0.0    0.00    0.00        1         x2 [3]\n"
"                0.00    0.00     1000/1000        consumeCpu2 [2]\n"
"-----------------------------------------------\n"
msgstr ""
"                0.00    0.00      100/100         x1 [1]\n"
"[0]    100.0    0.00    0.00      100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[1]      0.0    0.00    0.00        1         x1 [1]\n"
"                0.00    0.00      100/100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00     1000/1000        x2 [3]\n"
"[2]      0.0    0.00    0.00     1000         consumeCpu2 [2]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[3]      0.0    0.00    0.00        1         x2 [3]\n"
"                0.00    0.00     1000/1000        consumeCpu2 [2]\n"
"-----------------------------------------------\n"

#. type: Plain text
#: man-pages/man1/sprof.1:285
msgid ""
"Above and below, the \"E<lt>UNKNOWNE<gt>\" strings represent identifiers "
"that are outside of the profiled object (in this example, these are "
"instances of I<main()>)."
msgstr ""
"Выше и ниже строки «E<lt>UNKNOWNE<gt>» представляют идентификаторы, которые "
"находятся вне объекта профилирования (в этом примере они являются "
"экземплярами I<main()>)."

#. type: Plain text
#: man-pages/man1/sprof.1:289
msgid ""
"The B<sprof -c> option generates a list of call pairs and the number of "
"their occurrences:"
msgstr ""
"Параметр B<sprof -c> генерирует список пар вызовов и количество их появления:"

#. type: Plain text
#: man-pages/man1/sprof.1:297
#, no-wrap
msgid ""
"$ B<sprof -c libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"E<lt>UNKNOWNE<gt>                  x1                                 1\n"
"x1                         consumeCpu1                      100\n"
"E<lt>UNKNOWNE<gt>                  x2                                 1\n"
"x2                         consumeCpu2                     1000\n"
msgstr ""
"$ B<sprof -c libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"E<lt>UNKNOWNE<gt>                  x1                                 1\n"
"x1                         consumeCpu1                      100\n"
"E<lt>UNKNOWNE<gt>                  x2                                 1\n"
"x2                         consumeCpu2                     1000\n"

#. type: Plain text
#: man-pages/man1/sprof.1:302
msgid "B<gprof>(1), B<ldd>(1), B<ld.so>(8)"
msgstr "B<gprof>(1), B<ldd>(1), B<ld.so>(8)"

#. type: TH
#: man-pages/man7/sock_diag.7:24
#, no-wrap
msgid "SOCK_DIAG"
msgstr "SOCK_DIAG"

#. type: Plain text
#: man-pages/man7/sock_diag.7:27
msgid "sock_diag - obtaining information about sockets"
msgstr "sock_diag - возвращает информацию о сокетах"

#. type: Plain text
#: man-pages/man7/sock_diag.7:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/sock_diag.hE<gt>>\n"
"B<#include E<lt>linux/unix_diag.hE<gt>> /* for UNIX domain sockets */\n"
"B<#include E<lt>linux/inet_diag.hE<gt>> /* for IPv4 and IPv6 sockets */\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/sock_diag.hE<gt>>\n"
"B<#include E<lt>linux/unix_diag.hE<gt>> /* для доменных сокетов UNIX */\n"
"B<#include E<lt>linux/inet_diag.hE<gt>> /* для сокетов IPv4 и IPv6 */\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:35
#, no-wrap
msgid "B<diag_socket = socket(AF_NETLINK, >I<socket_type>B<, NETLINK_SOCK_DIAG);>\n"
msgstr "B<diag_socket = socket(AF_NETLINK, >I<socket_type>B<, NETLINK_SOCK_DIAG);>\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:41
msgid ""
"The sock_diag netlink subsystem provides a mechanism for obtaining "
"information about sockets of various address families from the kernel.  This "
"subsystem can be used to obtain information about individual sockets or "
"request a list of sockets."
msgstr ""
"Подсистема sock_diag netlink предоставляет механизм получения информации о "
"сокетах различных семейств адресов из ядра. Данная подсистема может "
"использоваться для получения информации об отдельных сокетах или запрашивать "
"список сокетов."

#. type: Plain text
#: man-pages/man7/sock_diag.7:45
msgid ""
"In the request, the caller can specify additional information it would like "
"to obtain about the socket, for example, memory information or information "
"specific to the address family."
msgstr ""
"В запросе вызывающий может указать дополнительную информацию, которую "
"хочется узнать о сокетах, например, информацию о памяти  или характерную "
"семейству адресов."

#. type: Plain text
#: man-pages/man7/sock_diag.7:50
msgid ""
"When requesting a list of sockets, the caller can specify filters that would "
"be applied by the kernel to select a subset of sockets to report.  For now, "
"there is only the ability to filter sockets by state (connected, listening, "
"and so on.)"
msgstr ""
"Когда запрашивается список сокетов вызывающий может задать фильтры, которые "
"будут применены ядром для выбора возвращаемого набора сокетов. В настоящее "
"время, фильтровать сокеты можно только по состоянию (соединён, слушает и т. "
"д.)."

#. type: Plain text
#: man-pages/man7/sock_diag.7:62
msgid ""
"Note that sock_diag reports only those sockets that have a name; that is, "
"either sockets bound explicitly with B<bind>(2)  or sockets that were "
"automatically bound to an address (e.g., by B<connect>(2)).  This is the "
"same set of sockets that is available via I</proc/net/unix>, I</proc/net/"
"tcp>, I</proc/net/udp>, and so on."
msgstr ""
"Заметим, что sock_diag возвращает только сокеты  с именем; то есть, явно "
"привязанные сокеты с помощью B<bind>(2) или автоматически привязанные к "
"адресу сокеты (например, с помощью B<connect>(2)). Данный набор сокетов "
"совпадает со списком в I</proc/net/unix>, I</proc/net/tcp>, I</proc/net/udp> "
"и т. п."

#. type: SS
#: man-pages/man7/sock_diag.7:62
#, no-wrap
msgid "Request"
msgstr "Запрос"

#. type: Plain text
#: man-pages/man7/sock_diag.7:73
msgid ""
"The request starts with a I<struct nlmsghdr> header described in "
"B<netlink>(7)  with I<nlmsg_type> field set to B<SOCK_DIAG_BY_FAMILY>.  It "
"is followed by a header specific to the address family that starts with a "
"common part shared by all address families:"
msgstr ""
"Запрос начинается с заголовка I<struct nlmsghdr>, описанного в "
"B<netlink>(7), в котором поле I<nlmsg_type> равно B<SOCK_DIAG_BY_FAMILY>. За "
"ним следует заголовок, соответствующий семейству адресов, начинающийся с "
"общей части, используемой для всех семейств адресов:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:80
#, no-wrap
msgid ""
"struct sock_diag_req {\n"
"    __u8 sdiag_family;\n"
"    __u8 sdiag_protocol;\n"
"};\n"
msgstr ""
"struct sock_diag_req {\n"
"    __u8 sdiag_family;\n"
"    __u8 sdiag_protocol;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:84 man-pages/man7/sock_diag.7:146
#: man-pages/man7/sock_diag.7:206 man-pages/man7/sock_diag.7:249
#: man-pages/man7/sock_diag.7:310 man-pages/man7/sock_diag.7:425
#: man-pages/man7/sock_diag.7:519
msgid "The fields of this structure are as follows:"
msgstr "Поля этой структуры имеют следующее назначение:"

#. type: TP
#: man-pages/man7/sock_diag.7:84 man-pages/man7/sock_diag.7:146
#: man-pages/man7/sock_diag.7:375
#, no-wrap
msgid "I<sdiag_family>"
msgstr "I<sdiag_family>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:90
msgid ""
"An address family.  It should be set to the appropriate B<AF_*> constant."
msgstr ""
"Семейство адресов. Должна быть указана соответствующая константа B<AF_*>."

#. type: TP
#: man-pages/man7/sock_diag.7:90 man-pages/man7/sock_diag.7:152
#: man-pages/man7/sock_diag.7:382
#, no-wrap
msgid "I<sdiag_protocol>"
msgstr "I<sdiag_protocol>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:101
msgid ""
"Depends on I<sdiag_family>.  It should be set to the appropriate "
"B<IPPROTO_*> constant for B<AF_INET> and B<AF_INET6>, and to 0 otherwise."
msgstr ""
"Зависит от I<sdiag_family>. Должна быть указана соответствующая константа "
"B<IPPROTO_*> при B<AF_INET> и B<AF_INET6>, и 0 в остальных случаях."

#. type: Plain text
#: man-pages/man7/sock_diag.7:111
msgid ""
"If the I<nlmsg_flags> field of the I<struct nlmsghdr> header has the "
"B<NLM_F_DUMP> flag set, it means that a list of sockets is being requested; "
"otherwise it is a query about an individual socket."
msgstr ""
"Если в поле I<nlmsg_flags> заголовка I<struct nlmsghdr> установлен флаг "
"B<NLM_F_DUMP>, то это означает, что запрашивается список сокетов; в "
"противном случае запрашивается информация об конкретном сокете."

#. type: SS
#: man-pages/man7/sock_diag.7:111
#, no-wrap
msgid "Response"
msgstr "Ответ"

#. type: Plain text
#: man-pages/man7/sock_diag.7:120
msgid ""
"The response starts with a I<struct nlmsghdr> header and is followed by an "
"array of objects specific to the address family.  The array is to be "
"accessed with the standard B<NLMSG_*> macros from the B<netlink>(3)  API."
msgstr ""
"Ответ начинается с заголовка I<struct nlmsghdr>, за которым следует массив "
"объектов, соответствующих семейству адресов. Массив доступен через "
"стандартные макросы из B<NLMSG_*> программного интерфейса B<netlink>(3)."

#. type: Plain text
#: man-pages/man7/sock_diag.7:128
msgid ""
"Each object is the NLA (netlink attributes) list that is to be accessed with "
"the B<RTA_*> macros from B<rtnetlink>(3)  API."
msgstr ""
"Каждый объект представляет собой список NLA (атрибутов netlink), которые "
"доступны через макросы B<RTA_*> программного интерфейса B<rtnetlink>(3)."

#. type: SS
#: man-pages/man7/sock_diag.7:128
#, no-wrap
msgid "UNIX domain sockets"
msgstr "Доменные сокеты UNIX"

#. type: Plain text
#: man-pages/man7/sock_diag.7:130
msgid ""
"For UNIX domain sockets the request is represented in the following "
"structure:"
msgstr "Запрос доменных сокетов UNIX описывается в следующей структуре:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:142
#, no-wrap
msgid ""
"struct unix_diag_req {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u16   pad;\n"
"    __u32   udiag_states;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_show;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"
msgstr ""
"struct unix_diag_req {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u16   pad;\n"
"    __u32   udiag_states;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_show;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:150
msgid "The address family; it should be set to B<AF_UNIX>."
msgstr "Семейство адресов; должно быть равно B<AF_UNIX>."

#. type: TP
#: man-pages/man7/sock_diag.7:153 man-pages/man7/sock_diag.7:327
#: man-pages/man7/sock_diag.7:454
#, no-wrap
msgid "I<pad>"
msgstr "I<pad>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:157
msgid "These fields should be set to 0."
msgstr "Эти поля должны быть равны 0."

#. type: TP
#: man-pages/man7/sock_diag.7:157
#, no-wrap
msgid "I<udiag_states>"
msgstr "I<udiag_states>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:163
msgid ""
"This is a bit mask that defines a filter of sockets states.  Only those "
"sockets whose states are in this mask will be reported.  Ignored when "
"querying for an individual socket.  Supported values are:"
msgstr ""
"Битовая маска, описывающая фильтр состояний сокетов. Будут возвращены только "
"сокеты с состояниями из этой маски. Игнорируется, если запрашивается "
"конкретный сокет. Поддерживаемые значения:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:167
msgid "1 E<lt>E<lt> B<TCP_ESTABLISHED>"
msgstr "1 E<lt>E<lt> B<TCP_ESTABLISHED>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:170
msgid "1 E<lt>E<lt> B<TCP_LISTEN>"
msgstr "1 E<lt>E<lt> B<TCP_LISTEN>"

#. type: TP
#: man-pages/man7/sock_diag.7:171 man-pages/man7/sock_diag.7:330
#, no-wrap
msgid "I<udiag_ino>"
msgstr "I<udiag_ino>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:175
msgid ""
"This is an inode number when querying for an individual socket.  Ignored "
"when querying for a list of sockets."
msgstr ""
"Номер иноды при запросе конкретного сокета. Игнорируется, если запрашивается "
"список сокетов."

#. type: TP
#: man-pages/man7/sock_diag.7:175
#, no-wrap
msgid "I<udiag_show>"
msgstr "I<udiag_show>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:180
msgid ""
"This is a set of flags defining what kind of information to report.  Each "
"requested kind of information is reported back as a netlink attribute as "
"described below:"
msgstr ""
"Набор флагов, определяющий тип возвращаемой информации. Каждый запрашиваемый "
"тип информации возвращается в виде атрибута netlink, описанного ниже:"

#. type: TP
#: man-pages/man7/sock_diag.7:181
#, no-wrap
msgid "B<UDIAG_SHOW_NAME>"
msgstr "B<UDIAG_SHOW_NAME>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:189
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_NAME>.  The "
"payload associated with this attribute is the pathname to which the socket "
"was bound (a sequence of bytes up to B<UNIX_PATH_MAX> length)."
msgstr ""
"Атрибут, возвращаемый в ответе на этот запрос — B<UNIX_DIAG_NAME>. Полезные "
"данные, связанные с этим атрибутом — путь, с которым был связан сокет "
"(последовательность байт длиной до B<UNIX_PATH_MAX>)."

#. type: TP
#: man-pages/man7/sock_diag.7:189
#, no-wrap
msgid "B<UDIAG_SHOW_VFS>"
msgstr "B<UDIAG_SHOW_VFS>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:195
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_VFS>.  The "
"payload associated with this attribute is represented in the following "
"structure:"
msgstr ""
"Атрибут, возвращаемый в ответе на этот запрос — B<UNIX_DIAG_VFS>. Полезные "
"данные, связанные с этим атрибутом представляются следующей структурой:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:202
#, no-wrap
msgid ""
"struct unix_diag_vfs {\n"
"    __u32 udiag_vfs_dev;\n"
"    __u32 udiag_vfs_ino;\n"
"};\n"
msgstr ""
"struct unix_diag_vfs {\n"
"    __u32 udiag_vfs_dev;\n"
"    __u32 udiag_vfs_ino;\n"
"};\n"

#. type: TP
#: man-pages/man7/sock_diag.7:207
#, no-wrap
msgid "I<udiag_vfs_dev>"
msgstr "I<udiag_vfs_dev>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:210
msgid "The device number of the corresponding on-disk socket inode."
msgstr "Номер устройства, соответствующего иноде сокета на диске."

#. type: TP
#: man-pages/man7/sock_diag.7:210
#, no-wrap
msgid "I<udiag_vfs_ino>"
msgstr "I<udiag_vfs_ino>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:213
msgid "The inode number of the corresponding on-disk socket inode."
msgstr "Номер иноды, соответствующей иноде сокета на диске."

#. type: TP
#: man-pages/man7/sock_diag.7:214
#, no-wrap
msgid "B<UDIAG_SHOW_PEER>"
msgstr "B<UDIAG_SHOW_PEER>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:221
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_PEER>.  The "
"payload associated with this attribute is a __u32 value which is the peer's "
"inode number.  This attribute is reported for connected sockets only."
msgstr ""
"Атрибут, возвращаемый в ответе на этот запрос — B<UNIX_DIAG_PEER>. Полезные "
"данные, связанные с этим атрибутом — значение __u32, представляющее номер "
"иноды ответной стороны. Данный атрибут возвращается только для соединённых "
"сокетов."

#. type: TP
#: man-pages/man7/sock_diag.7:221
#, no-wrap
msgid "B<UDIAG_SHOW_ICONS>"
msgstr "B<UDIAG_SHOW_ICONS>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:232
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_ICONS>.  The "
"payload associated with this attribute is an array of __u32 values which are "
"inode numbers of sockets that has passed the B<connect>(2)  call, but hasn't "
"been processed with B<accept>(2)  yet.  This attribute is reported for "
"listening sockets only."
msgstr ""
"Атрибут, возвращаемый в ответе на этот запрос — B<UNIX_DIAG_ICONS>. Полезные "
"данные, связанные с этим атрибутом — значения __u32, представляющие номера "
"инод сокетов, которые переданы вызову B<connect>(2), но ещё не были "
"обработаны B<accept>(2). Данный атрибут возвращается, если запрашивается "
"список сокетов."

#. type: TP
#: man-pages/man7/sock_diag.7:232
#, no-wrap
msgid "B<UDIAG_SHOW_RQLEN>"
msgstr "B<UDIAG_SHOW_RQLEN>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:238
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_RQLEN>.  The "
"payload associated with this attribute is represented in the following "
"structure:"
msgstr ""
"Атрибут, возвращаемый в ответе на этот запрос — B<UNIX_DIAG_RQLEN>. Полезные "
"данные, связанные с этим атрибутом представляются следующей структурой:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:245
#, no-wrap
msgid ""
"struct unix_diag_rqlen {\n"
"    __u32 udiag_rqueue;\n"
"    __u32 udiag_wqueue;\n"
"};\n"
msgstr ""
"struct unix_diag_rqlen {\n"
"    __u32 udiag_rqueue;\n"
"    __u32 udiag_wqueue;\n"
"};\n"

#. type: TP
#: man-pages/man7/sock_diag.7:250
#, no-wrap
msgid "I<udiag_rqueue>"
msgstr "I<udiag_rqueue>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:257
msgid ""
"For listening sockets: the number of pending connections.  The length of the "
"array associated with the B<UNIX_DIAG_ICONS> response attribute is equal to "
"this value."
msgstr ""
"Для слушающих сокетов: количество ожидающих подключений. Этому значению "
"равна длина массива, связанного с атрибутом ответа B<UNIX_DIAG_ICONS>."

#. type: Plain text
#: man-pages/man7/sock_diag.7:260
msgid "For established sockets: the amount of data in incoming queue."
msgstr ""
"Для сокетов с установленным соединением: количество данных во входящей "
"очереди."

#. type: TP
#: man-pages/man7/sock_diag.7:260
#, no-wrap
msgid "I<udiag_wqueue>"
msgstr "I<udiag_wqueue>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:265
msgid ""
"For listening sockets: the backlog length which equals to the value passed "
"as the second argument to B<listen>(2)."
msgstr ""
"Для слушающих сокетов: длина недодела (backlog), равная значению, "
"переданному во втором аргументе B<listen>(2)."

#. type: Plain text
#: man-pages/man7/sock_diag.7:268
msgid "For established sockets: the amount of memory available for sending."
msgstr ""
"Для сокетов с установленным соединением: количество памяти, доступной при "
"отправке."

#. type: TP
#: man-pages/man7/sock_diag.7:269
#, no-wrap
msgid "B<UDIAG_SHOW_MEMINFO>"
msgstr "B<UDIAG_SHOW_MEMINFO>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:275
msgid ""
"The attribute reported in answer to this request is B<UNIX_DIAG_MEMINFO>.  "
"The payload associated with this attribute is an array of __u32 values "
"described below in the subsection \"Socket memory information\"."
msgstr ""
"Атрибут, возвращаемый в ответе на этот запрос — B<UNIX_DIAG_MEMINFO>. "
"Полезные данные, связанные с этим атрибутом представляют собой массив "
"значений с типом __u32,описанный далее в подразделе «Информация о памяти "
"сокетов»."

#. type: Plain text
#: man-pages/man7/sock_diag.7:277
msgid ""
"The following attributes are reported back without any specific request:"
msgstr "Следующие атрибуты возвращаются для любого запроса:"

#. type: TP
#: man-pages/man7/sock_diag.7:277
#, no-wrap
msgid "B<UNIX_DIAG_SHUTDOWN>"
msgstr "B<UNIX_DIAG_SHUTDOWN>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:283
msgid ""
"The payload associated with this attribute is __u8 value which represents "
"bits of B<shutdown>(2)  state."
msgstr ""
"Полезные данные, связанные с этим атрибутом, имеют тип __u8 и представляют "
"биты состояния из B<shutdown>(2)."

#. type: TP
#: man-pages/man7/sock_diag.7:284 man-pages/man7/sock_diag.7:333
#, no-wrap
msgid "I<udiag_cookie>"
msgstr "I<udiag_cookie>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:291
msgid ""
"This is an array of opaque identifiers that could be used along with "
"I<udiag_ino> to specify an individual socket.  It is ignored when querying "
"for a list of sockets, as well as when all its elements are set to -1."
msgstr ""
"Массив скрытых идентификаторов, которые можно использовать вместе с "
"I<udiag_ino> для указания определённого сокета. Игнорируется при запросе "
"списка сокетов, а также когда все его элементы равны -1."

#. type: Plain text
#: man-pages/man7/sock_diag.7:293
msgid ""
"The response to a query for UNIX domain sockets is represented as an array of"
msgstr "Ответ на запрос о доменных сокетах UNIX представляется в виде массива"

#. type: Plain text
#: man-pages/man7/sock_diag.7:304
#, no-wrap
msgid ""
"struct unix_diag_msg {\n"
"    __u8    udiag_family;\n"
"    __u8    udiag_type;\n"
"    __u8    udiag_state;\n"
"    __u8    pad;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"
msgstr ""
"struct unix_diag_msg {\n"
"    __u8    udiag_family;\n"
"    __u8    udiag_type;\n"
"    __u8    udiag_state;\n"
"    __u8    pad;\n"
"    __u32   udiag_ino;\n"
"    __u32   udiag_cookie[2];\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:308 man-pages/man7/sock_diag.7:517
msgid "followed by netlink attributes."
msgstr "и следует за атрибутами netlink."

#. type: TP
#: man-pages/man7/sock_diag.7:310
#, no-wrap
msgid "I<udiag_family>"
msgstr "I<udiag_family>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:314
msgid "This field has the same meaning as in I<struct unix_diag_req>."
msgstr "Данное поле имеет то же значение что в I<struct unix_diag_req>."

#. type: TP
#: man-pages/man7/sock_diag.7:314
#, no-wrap
msgid "I<udiag_type>"
msgstr "I<udiag_type>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:321
msgid ""
"This is set to one of B<SOCK_PACKET>, B<SOCK_STREAM>, or B<SOCK_SEQPACKET>."
msgstr "Может быть B<SOCK_PACKET>, B<SOCK_STREAM> или B<SOCK_SEQPACKET>."

#. type: TP
#: man-pages/man7/sock_diag.7:321
#, no-wrap
msgid "I<udiag_state>"
msgstr "I<udiag_state>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:327
msgid "This is set to one of B<TCP_LISTEN> or B<TCP_ESTABLISHED>."
msgstr "Может быть B<TCP_LISTEN> или B<TCP_ESTABLISHED>."

#. type: Plain text
#: man-pages/man7/sock_diag.7:330
msgid "This field is set to 0."
msgstr "Это поле равно 0."

#. type: Plain text
#: man-pages/man7/sock_diag.7:333 man-pages/man7/sock_diag.7:588
msgid "This is the socket inode number."
msgstr "Номер иноды сокета."

#. type: Plain text
#: man-pages/man7/sock_diag.7:338
msgid ""
"This is an array of opaque identifiers that could be used in subsequent "
"queries."
msgstr ""
"Массив скрытых идентификаторов, которые можно использовать в последующих "
"запросах."

#. type: SS
#: man-pages/man7/sock_diag.7:338
#, no-wrap
msgid "IPv4 and IPv6 sockets"
msgstr "Сокеты IPv4 и IPv6"

#. type: Plain text
#: man-pages/man7/sock_diag.7:341
msgid ""
"For IPv4 and IPv6 sockets, the request is represented in the following "
"structure:"
msgstr "Запрос сокетов IPv4 и IPv6 описывается в следующей структуре:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:352
#, no-wrap
msgid ""
"struct inet_diag_req_v2 {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u8    idiag_ext;\n"
"    __u8    pad;\n"
"    __u32   idiag_states;\n"
"    struct inet_diag_sockid id;\n"
"};\n"
msgstr ""
"struct inet_diag_req_v2 {\n"
"    __u8    sdiag_family;\n"
"    __u8    sdiag_protocol;\n"
"    __u8    idiag_ext;\n"
"    __u8    pad;\n"
"    __u32   idiag_states;\n"
"    struct inet_diag_sockid id;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:358
msgid "where I<struct inet_diag_sockid> is defined as follows:"
msgstr "где I<struct inet_diag_sockid> определена как:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:369
#, no-wrap
msgid ""
"struct inet_diag_sockid {\n"
"    __be16  idiag_sport;\n"
"    __be16  idiag_dport;\n"
"    __be32  idiag_src[4];\n"
"    __be32  idiag_dst[4];\n"
"    __u32   idiag_if;\n"
"    __u32   idiag_cookie[2];\n"
"};\n"
msgstr ""
"struct inet_diag_sockid {\n"
"    __be16  idiag_sport;\n"
"    __be16  idiag_dport;\n"
"    __be32  idiag_src[4];\n"
"    __be32  idiag_dst[4];\n"
"    __u32   idiag_if;\n"
"    __u32   idiag_cookie[2];\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:375
msgid "The fields of I<struct inet_diag_req_v2> are as follows:"
msgstr "Поля I<struct inet_diag_req_v2>:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:382
msgid ""
"This should be set to either B<AF_INET> or B<AF_INET6> for IPv4 or IPv6 "
"sockets respectively."
msgstr ""
"Должно быть равно B<AF_INET> или B<AF_INET6> для сокетов IPv4 или IPv6, "
"соответственно."

#. type: Plain text
#: man-pages/man7/sock_diag.7:389
msgid ""
"This should be set to one of B<IPPROTO_TCP>, B<IPPROTO_UDP>, or "
"B<IPPROTO_UDPLITE>."
msgstr ""
"Должно быть равно B<IPPROTO_TCP>, B<IPPROTO_UDP> или B<IPPROTO_UDPLITE>."

#. type: TP
#: man-pages/man7/sock_diag.7:389
#, no-wrap
msgid "I<idiag_ext>"
msgstr "I<idiag_ext>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:394
msgid ""
"This is a set of flags defining what kind of extended information to "
"report.  Each requested kind of information is reported back as a netlink "
"attribute as described below:"
msgstr ""
"Набор флагов, определяющий тип возвращаемой расширенной информации. Каждый "
"запрашиваемый тип информации возвращается в виде атрибута netlink, "
"описанного ниже:"

#. type: TP
#: man-pages/man7/sock_diag.7:395
#, no-wrap
msgid "B<INET_DIAG_TOS>"
msgstr "B<INET_DIAG_TOS>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:399
msgid ""
"The payload associated with this attribute is a __u8 value which is the TOS "
"of the socket."
msgstr ""
"Полезные данные, связанные с этим атрибутом, имеют тип __u8 и представляют "
"TOS сокета."

#. type: TP
#: man-pages/man7/sock_diag.7:399
#, no-wrap
msgid "B<INET_DIAG_TCLASS>"
msgstr "B<INET_DIAG_TCLASS>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:408
msgid ""
"The payload associated with this attribute is a __u8 value which is the "
"TClass of the socket.  IPv6 sockets only.  For LISTEN and CLOSE sockets, "
"this is followed by B<INET_DIAG_SKV6ONLY> attribute with associated __u8 "
"payload value meaning whether the socket is IPv6-only or not."
msgstr ""
"Полезные данные, связанные с этим атрибутом, имеют тип __u8 и представляют "
"TClass сокета. Только для сокетов IPv6. Для сокетов LISTEN и CLOSE эти "
"данные следуют за атрибутом B<INET_DIAG_SKV6ONLY> с значением полезных "
"данных (тип __u8), описывающим является ли сокет только IPv6 или нет."

#. type: TP
#: man-pages/man7/sock_diag.7:408
#, no-wrap
msgid "B<INET_DIAG_MEMINFO>"
msgstr "B<INET_DIAG_MEMINFO>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:412
msgid ""
"The payload associated with this attribute is represented in the following "
"structure:"
msgstr ""
"Полезные данные, связанные с этим атрибутом представляются следующей "
"структурой:"

#. type: Plain text
#: man-pages/man7/sock_diag.7:421
#, no-wrap
msgid ""
"struct inet_diag_meminfo {\n"
"    __u32 idiag_rmem;\n"
"    __u32 idiag_wmem;\n"
"    __u32 idiag_fmem;\n"
"    __u32 idiag_tmem;\n"
"};\n"
msgstr ""
"struct inet_diag_meminfo {\n"
"    __u32 idiag_rmem;\n"
"    __u32 idiag_wmem;\n"
"    __u32 idiag_fmem;\n"
"    __u32 idiag_tmem;\n"
"};\n"

#. type: TP
#: man-pages/man7/sock_diag.7:426
#, no-wrap
msgid "I<idiag_rmem>"
msgstr "I<idiag_rmem>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:429
msgid "The amount of data in the receive queue."
msgstr "Количество данных в приёмной очереди."

#. type: TP
#: man-pages/man7/sock_diag.7:429
#, no-wrap
msgid "I<idiag_wmem>"
msgstr "I<idiag_wmem>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:432
msgid "The amount of data that is queued by TCP but not yet sent."
msgstr "Количество данных, помещённых в очередь TCP и ещё не отправленных."

#. type: TP
#: man-pages/man7/sock_diag.7:432
#, no-wrap
msgid "I<idiag_fmem>"
msgstr "I<idiag_fmem>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:435 man-pages/man7/sock_diag.7:611
msgid "The amount of memory scheduled for future use (TCP only)."
msgstr ""
"Объём памяти, запланированной для использования в будущем (только TCP)."

#. type: TP
#: man-pages/man7/sock_diag.7:435
#, no-wrap
msgid "I<idiag_tmem>"
msgstr "I<idiag_tmem>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:438 man-pages/man7/sock_diag.7:604
msgid "The amount of data in send queue."
msgstr "Количество данных в очереди отправки."

#. type: TP
#: man-pages/man7/sock_diag.7:439
#, no-wrap
msgid "B<INET_DIAG_SKMEMINFO>"
msgstr "B<INET_DIAG_SKMEMINFO>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:443
msgid ""
"The payload associated with this attribute is an array of __u32 values "
"described below in the subsection \"Socket memory information\"."
msgstr ""
"Полезные данные, связанные с этим атрибутом представляют собой массив "
"значений с типом __u32,описанный далее в подразделе «Информация о памяти "
"сокетов»."

#. type: TP
#: man-pages/man7/sock_diag.7:443
#, no-wrap
msgid "B<INET_DIAG_INFO>"
msgstr "B<INET_DIAG_INFO>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:448
msgid ""
"The payload associated with this attribute is specific to the address "
"family.  For TCP sockets, it is an object of type I<struct tcp_info>."
msgstr ""
"Полезные данные, связанные с этим атрибутом, относятся к определённому "
"семейству адресов. Для сокетов TCP объект имеет тип I<struct tcp_info>."

#. type: TP
#: man-pages/man7/sock_diag.7:448
#, no-wrap
msgid "B<INET_DIAG_CONG>"
msgstr "B<INET_DIAG_CONG>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:453
msgid ""
"The payload associated with this attribute is a string that describes the "
"congestion control algorithm used.  For TCP sockets only."
msgstr ""
"Полезные данные, связанные с этим атрибутом, представляют собой строку, "
"описывающую используемый алгоритм контроля перегрузки. Только для сокетов "
"TCP."

#. type: Plain text
#: man-pages/man7/sock_diag.7:457
msgid "This should be set to 0."
msgstr "Должно равняться 0."

#. type: TP
#: man-pages/man7/sock_diag.7:457
#, no-wrap
msgid "I<idiag_states>"
msgstr "I<idiag_states>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:462
msgid ""
"This is a bit mask that defines a filter of socket states.  Only those "
"sockets whose states are in this mask will be reported.  Ignored when "
"querying for an individual socket."
msgstr ""
"Битовая маска, описывающая фильтр состояний сокета. Будут возвращены только "
"сокеты с состояниями из этой маски. Игнорируется, если запрашивается "
"конкретный сокет."

#. type: TP
#: man-pages/man7/sock_diag.7:462
#, no-wrap
msgid "I<id>"
msgstr "I<id>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:469
msgid ""
"This is a socket ID object that is used in dump requests, in queries about "
"individual sockets, and is reported back in each response.  Unlike UNIX "
"domain sockets, IPv4 and IPv6 sockets are identified using addresses and "
"ports.  All values are in network byte order."
msgstr ""
"Идентификатор объекта сокета, использующийся при запросах дампа, в опросах "
"отдельных сокетов и возвращается в каждом ответе. В отличие от доменных "
"сокетов UNIX, сокеты IPv4 и IPv6 опознаются по адресам и портам. Все "
"значения указываются в сетевом порядке байт."

#. type: Plain text
#: man-pages/man7/sock_diag.7:473
msgid "The fields of I<struct inet_diag_sockid> are as follows:"
msgstr "Поля I<struct inet_diag_sockid>:"

#. type: TP
#: man-pages/man7/sock_diag.7:473
#, no-wrap
msgid "I<idiag_sport>"
msgstr "I<idiag_sport>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:476
msgid "The source port."
msgstr "Порт отправителя."

#. type: TP
#: man-pages/man7/sock_diag.7:476
#, no-wrap
msgid "I<idiag_dport>"
msgstr "I<idiag_dport>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:479
msgid "The destination port."
msgstr "Порт получателя."

#. type: TP
#: man-pages/man7/sock_diag.7:479
#, no-wrap
msgid "I<idiag_src>"
msgstr "I<idiag_src>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:482
msgid "The source address."
msgstr "Адрес отправителя."

#. type: TP
#: man-pages/man7/sock_diag.7:482
#, no-wrap
msgid "I<idiag_dst>"
msgstr "I<idiag_dst>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:485
msgid "The destination address."
msgstr "Адрес получателя."

#. type: TP
#: man-pages/man7/sock_diag.7:485
#, no-wrap
msgid "I<idiag_if>"
msgstr "I<idiag_if>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:488
msgid "The interface number the socket is bound to."
msgstr "Интерфейсный номер к которому привязан сокет."

#. type: TP
#: man-pages/man7/sock_diag.7:488
#, no-wrap
msgid "I<idiag_cookie>"
msgstr "I<idiag_cookie>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:494
msgid ""
"This is an array of opaque identifiers that could be used along with other "
"fields of this structure to specify an individual socket.  It is ignored "
"when querying for a list of sockets, as well as when all its elements are "
"set to -1."
msgstr ""
"Массив скрытых идентификаторов, которые можно использовать вместе с другими "
"полями этой структуры для указания определённого сокета. Игнорируется при "
"запросе списка сокетов, а также когда все его элементы равны -1."

#. type: Plain text
#: man-pages/man7/sock_diag.7:496
msgid ""
"The response to a query for IPv4 or IPv6 sockets is represented as an array "
"of"
msgstr "Ответ на запрос о сокетах IPv4 или IPv6 представляется в виде массива"

#. type: Plain text
#: man-pages/man7/sock_diag.7:504
#, no-wrap
msgid ""
"struct inet_diag_msg {\n"
"    __u8    idiag_family;\n"
"    __u8    idiag_state;\n"
"    __u8    idiag_timer;\n"
"    __u8    idiag_retrans;\n"
msgstr ""
"struct inet_diag_msg {\n"
"    __u8    idiag_family;\n"
"    __u8    idiag_state;\n"
"    __u8    idiag_timer;\n"
"    __u8    idiag_retrans;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:506
#, no-wrap
msgid "    struct inet_diag_sockid id;\n"
msgstr "    struct inet_diag_sockid id;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:513
#, no-wrap
msgid ""
"    __u32   idiag_expires;\n"
"    __u32   idiag_rqueue;\n"
"    __u32   idiag_wqueue;\n"
"    __u32   idiag_uid;\n"
"    __u32   idiag_inode;\n"
"};\n"
msgstr ""
"    __u32   idiag_expires;\n"
"    __u32   idiag_rqueue;\n"
"    __u32   idiag_wqueue;\n"
"    __u32   idiag_uid;\n"
"    __u32   idiag_inode;\n"
"};\n"

#. type: TP
#: man-pages/man7/sock_diag.7:519
#, no-wrap
msgid "I<idiag_family>"
msgstr "I<idiag_family>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:523
msgid "This is the same field as in I<struct inet_diag_req_v2>."
msgstr "Это тоже поле что и в I<struct inet_diag_req_v2>."

#. type: TP
#: man-pages/man7/sock_diag.7:523
#, no-wrap
msgid "I<idiag_state>"
msgstr "I<idiag_state>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:527
msgid "This denotes socket state as in I<struct inet_diag_req_v2>."
msgstr "Обозначает состояние сокета как в I<struct inet_diag_req_v2>."

#. type: TP
#: man-pages/man7/sock_diag.7:527
#, no-wrap
msgid "I<idiag_timer>"
msgstr "I<idiag_timer>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:532
msgid ""
"For TCP sockets, this field describes the type of timer that is currently "
"active for the socket.  It is set to one of the following constants:"
msgstr ""
"Для сокетов TCP это поле описывает тип активного в данный момент таймера "
"сокета. Задаётся одной из следующих констант:"

#. type: TP
#: man-pages/man7/sock_diag.7:535
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:538
msgid "no timer is active"
msgstr "таймер не активен"

#. type: TP
#: man-pages/man7/sock_diag.7:538
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:541
msgid "a retransmit timer"
msgstr "таймер повторной передачи"

#. type: TP
#: man-pages/man7/sock_diag.7:541
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:544
msgid "a keep-alive timer"
msgstr "таймер поддержания соединения"

#. type: TP
#: man-pages/man7/sock_diag.7:544
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:547
msgid "a TIME_WAIT timer"
msgstr "таймер TIME_WAIT"

#. type: TP
#: man-pages/man7/sock_diag.7:547
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:550
msgid "a zero window probe timer"
msgstr "таймер проверки нулевым окном"

#. type: Plain text
#: man-pages/man7/sock_diag.7:554
msgid "For non-TCP sockets, this field is set to 0."
msgstr "Для сокетов не TCP, значение этого поля равно 0."

#. type: TP
#: man-pages/man7/sock_diag.7:554
#, no-wrap
msgid "I<idiag_retrans>"
msgstr "I<idiag_retrans>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:562
msgid ""
"For I<idiag_timer> values 1, 2, and 4, this field contains the number of "
"retransmits.  For other I<idiag_timer> values, this field is set to 0."
msgstr ""
"Если I<idiag_timer> содержит 1, 2 и 4, то это поле содержит количество "
"повторных передач. При других значениях I<idiag_timer> это поле равно 0."

#. type: TP
#: man-pages/man7/sock_diag.7:562
#, no-wrap
msgid "I<idiag_expires>"
msgstr "I<idiag_expires>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:567
msgid ""
"For TCP sockets that have an active timer, this field describes its "
"expiration time in milliseconds.  For other sockets, this field is set to 0."
msgstr ""
"Для сокетов TCP, имеющих активный таймер, это поле описывает его время "
"окончания в миллисекундах. Для других сокетов значение этого поля равно 0."

#. type: TP
#: man-pages/man7/sock_diag.7:567
#, no-wrap
msgid "I<idiag_rqueue>"
msgstr "I<idiag_rqueue>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:571
msgid "For listening sockets: the number of pending connections."
msgstr "Для слушающих сокетов: количество ожидающих подключений."

#. type: Plain text
#: man-pages/man7/sock_diag.7:574
msgid "For other sockets: the amount of data in the incoming queue."
msgstr "Для других сокетов: количество данных во входящей очереди."

#. type: TP
#: man-pages/man7/sock_diag.7:574
#, no-wrap
msgid "I<idiag_wqueue>"
msgstr "I<idiag_wqueue>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:578
msgid "For listening sockets: the backlog length."
msgstr "Для слушающих сокетов: длина недодела (backlog)."

#. type: Plain text
#: man-pages/man7/sock_diag.7:581
msgid "For other sockets: the amount of memory available for sending."
msgstr "Для других сокетов: количество памяти, доступной при отправке."

#. type: TP
#: man-pages/man7/sock_diag.7:581
#, no-wrap
msgid "I<idiag_uid>"
msgstr "I<idiag_uid>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:584
msgid "This is the socket owner UID."
msgstr "Идентификатор пользователя, владеющего сокетом."

#. type: TP
#: man-pages/man7/sock_diag.7:584
#, no-wrap
msgid "I<idiag_inode>"
msgstr "I<idiag_inode>"

#. type: SS
#: man-pages/man7/sock_diag.7:588
#, no-wrap
msgid "Socket memory information"
msgstr "Информация о памяти сокетов"

#. type: Plain text
#: man-pages/man7/sock_diag.7:594
msgid ""
"The payload associated with B<UNIX_DIAG_MEMINFO> and B<INET_DIAG_SKMEMINFO> "
"netlink attributes is an array of the following __u32 values:"
msgstr ""
"Полезные данные, связанные с атрибутами netlink B<UNIX_DIAG_MEMINFO> и "
"B<INET_DIAG_SKMEMINFO>, представляют собой массив следующих значений с типом "
"__u32:"

#. type: TP
#: man-pages/man7/sock_diag.7:594
#, no-wrap
msgid "B<SK_MEMINFO_RMEM_ALLOC>"
msgstr "B<SK_MEMINFO_RMEM_ALLOC>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:597
msgid "The amount of data in receive queue."
msgstr "Количество данных в приёмной очереди."

#. type: TP
#: man-pages/man7/sock_diag.7:597
#, no-wrap
msgid "B<SK_MEMINFO_RCVBUF>"
msgstr "B<SK_MEMINFO_RCVBUF>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:601
msgid "The receive socket buffer as set by B<SO_RCVBUF>."
msgstr "Приёмный буфер сокета, заданный B<SO_RCVBUF>."

#. type: TP
#: man-pages/man7/sock_diag.7:601
#, no-wrap
msgid "B<SK_MEMINFO_WMEM_ALLOC>"
msgstr "B<SK_MEMINFO_WMEM_ALLOC>"

#. type: TP
#: man-pages/man7/sock_diag.7:604
#, no-wrap
msgid "B<SK_MEMINFO_SNDBUF>"
msgstr "B<SK_MEMINFO_SNDBUF>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:608
msgid "The send socket buffer as set by B<SO_SNDBUF>."
msgstr "Буфер отправки сокета, заданный B<SO_SNDBUF>."

#. type: TP
#: man-pages/man7/sock_diag.7:608
#, no-wrap
msgid "B<SK_MEMINFO_FWD_ALLOC>"
msgstr "B<SK_MEMINFO_FWD_ALLOC>"

#. type: TP
#: man-pages/man7/sock_diag.7:611
#, no-wrap
msgid "B<SK_MEMINFO_WMEM_QUEUED>"
msgstr "B<SK_MEMINFO_WMEM_QUEUED>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:614
msgid "The amount of data queued by TCP, but not yet sent."
msgstr "Количество данных, помещённых в очередь TCP, но ещё не отправленных."

#. type: TP
#: man-pages/man7/sock_diag.7:614
#, no-wrap
msgid "B<SK_MEMINFO_OPTMEM>"
msgstr "B<SK_MEMINFO_OPTMEM>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:618
msgid ""
"The amount of memory allocated for the socket's service needs (e.g., socket "
"filter)."
msgstr ""
"Объем памяти, выделенный для служебных нужд сокета (например, для сокетного "
"фильтра)."

#. type: TP
#: man-pages/man7/sock_diag.7:618
#, no-wrap
msgid "B<SK_MEMINFO_BACKLOG>"
msgstr "B<SK_MEMINFO_BACKLOG>"

#. type: Plain text
#: man-pages/man7/sock_diag.7:621
msgid "The amount of packets in the backlog (not yet processed)."
msgstr "Количество пакетов в памяти недодела (не обработанных)."

#. type: Plain text
#: man-pages/man7/sock_diag.7:633
msgid ""
"B<NETLINK_INET_DIAG> was introduced in Linux 2.6.14 and supported B<AF_INET> "
"and B<AF_INET6> sockets only.  In Linux 3.3, it was renamed to "
"B<NETLINK_SOCK_DIAG> and extended to support B<AF_UNIX> sockets."
msgstr ""
"Программный интерфейс B<NETLINK_INET_DIAG> появился в Linux 2.6.14 и "
"поддерживал только сокеты B<AF_INET> и B<AF_INET6>. В Linux 3.3 он был "
"переименован в B<NETLINK_SOCK_DIAG> и появилась поддержка сокетов B<AF_UNIX>."

#. type: Plain text
#: man-pages/man7/sock_diag.7:638
msgid ""
"B<UNIX_DIAG_MEMINFO> and B<INET_DIAG_SKMEMINFO> were introduced in Linux 3.6."
msgstr ""
"Программный интерфейс B<UNIX_DIAG_MEMINFO> и B<INET_DIAG_SKMEMINFO> появился "
"в Linux 3.6."

#. type: Plain text
#: man-pages/man7/sock_diag.7:640
msgid "The NETLINK_SOCK_DIAG API is Linux-specific."
msgstr "Программный интерфейс NETLINK_SOCK_DIAG есть только в Linux."

#. type: Plain text
#: man-pages/man7/sock_diag.7:643
msgid ""
"The following example program prints inode number, peer's inode number, and "
"name of all UNIX domain sockets in the current namespace."
msgstr ""
"Следующий пример программы печатает номер иноды, номер иноды противоположной "
"стороны и имена всех доменных сокетов UNIX в текущем пространстве имён."

#. type: Plain text
#: man-pages/man7/sock_diag.7:655
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>linux/netlink.hE<gt>\n"
"#include E<lt>linux/rtnetlink.hE<gt>\n"
"#include E<lt>linux/sock_diag.hE<gt>\n"
"#include E<lt>linux/unix_diag.hE<gt>\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>linux/netlink.hE<gt>\n"
"#include E<lt>linux/rtnetlink.hE<gt>\n"
"#include E<lt>linux/sock_diag.hE<gt>\n"
"#include E<lt>linux/unix_diag.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:688
#, no-wrap
msgid ""
"static int\n"
"send_query(int fd)\n"
"{\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct\n"
"    {\n"
"        struct nlmsghdr nlh;\n"
"        struct unix_diag_req udr;\n"
"    } req = {\n"
"        .nlh = {\n"
"            .nlmsg_len = sizeof(req),\n"
"            .nlmsg_type = SOCK_DIAG_BY_FAMILY,\n"
"            .nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP\n"
"        },\n"
"        .udr = {\n"
"            .sdiag_family = AF_UNIX,\n"
"            .udiag_states = -1,\n"
"            .udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER\n"
"        }\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = &req,\n"
"        .iov_len = sizeof(req)\n"
"    };\n"
"    struct msghdr msg = {\n"
"        .msg_name = (void *) &nladdr,\n"
"        .msg_namelen = sizeof(nladdr),\n"
"        .msg_iov = &iov,\n"
"        .msg_iovlen = 1\n"
"    };\n"
msgstr ""
"static int\n"
"send_query(int fd)\n"
"{\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct\n"
"    {\n"
"        struct nlmsghdr nlh;\n"
"        struct unix_diag_req udr;\n"
"    } req = {\n"
"        .nlh = {\n"
"            .nlmsg_len = sizeof(req),\n"
"            .nlmsg_type = SOCK_DIAG_BY_FAMILY,\n"
"            .nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP\n"
"        },\n"
"        .udr = {\n"
"            .sdiag_family = AF_UNIX,\n"
"            .udiag_states = -1,\n"
"            .udiag_show = UDIAG_SHOW_NAME | UDIAG_SHOW_PEER\n"
"        }\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = &req,\n"
"        .iov_len = sizeof(req)\n"
"    };\n"
"    struct msghdr msg = {\n"
"        .msg_name = (void *) &nladdr,\n"
"        .msg_namelen = sizeof(nladdr),\n"
"        .msg_iov = &iov,\n"
"        .msg_iovlen = 1\n"
"    };\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:693
#, no-wrap
msgid ""
"    for (;;) {\n"
"        if (sendmsg(fd, &msg, 0) E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
msgstr ""
"    for (;;) {\n"
"        if (sendmsg(fd, &msg, 0) E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:697
#, no-wrap
msgid ""
"            perror(\"sendmsg\");\n"
"            return -1;\n"
"        }\n"
msgstr ""
"            perror(\"sendmsg\");\n"
"            return -1;\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:701
#, no-wrap
msgid ""
"        return 0;\n"
"    }\n"
"}\n"
msgstr ""
"        return 0;\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:713
#, no-wrap
msgid ""
"static int\n"
"print_diag(const struct unix_diag_msg *diag, unsigned int len)\n"
"{\n"
"    if (len E<lt> NLMSG_LENGTH(sizeof(*diag))) {\n"
"        fputs(\"short response\\en\", stderr);\n"
"        return -1;\n"
"    }\n"
"    if (diag-E<gt>udiag_family != AF_UNIX) {\n"
"        fprintf(stderr, \"unexpected family %u\\en\", diag-E<gt>udiag_family);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"static int\n"
"print_diag(const struct unix_diag_msg *diag, unsigned int len)\n"
"{\n"
"    if (len E<lt> NLMSG_LENGTH(sizeof(*diag))) {\n"
"        fputs(\"короткий ответ\\en\", stderr);\n"
"        return -1;\n"
"    }\n"
"    if (diag-E<gt>udiag_family != AF_UNIX) {\n"
"        fprintf(stderr, \"неожиданное семейство %u\\en\", diag-E<gt>udiag_family);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:719
#, no-wrap
msgid ""
"    struct rtattr *attr;\n"
"    unsigned int rta_len = len - NLMSG_LENGTH(sizeof(*diag));\n"
"    unsigned int peer = 0;\n"
"    size_t path_len = 0;\n"
"    char path[sizeof(((struct sockaddr_un *) 0)-E<gt>sun_path) + 1];\n"
msgstr ""
"    struct rtattr *attr;\n"
"    unsigned int rta_len = len - NLMSG_LENGTH(sizeof(*diag));\n"
"    unsigned int peer = 0;\n"
"    size_t path_len = 0;\n"
"    char path[sizeof(((struct sockaddr_un *) 0)-E<gt>sun_path) + 1];\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:732
#, no-wrap
msgid ""
"    for (attr = (struct rtattr *) (diag + 1);\n"
"             RTA_OK(attr, rta_len); attr = RTA_NEXT(attr, rta_len)) {\n"
"        switch (attr-E<gt>rta_type) {\n"
"        case UNIX_DIAG_NAME:\n"
"            if (!path_len) {\n"
"                path_len = RTA_PAYLOAD(attr);\n"
"                if (path_len E<gt> sizeof(path) - 1)\n"
"                    path_len = sizeof(path) - 1;\n"
"                memcpy(path, RTA_DATA(attr), path_len);\n"
"                path[path_len] = '\\e0';\n"
"            }\n"
"            break;\n"
msgstr ""
"    for (attr = (struct rtattr *) (diag + 1);\n"
"             RTA_OK(attr, rta_len); attr = RTA_NEXT(attr, rta_len)) {\n"
"        switch (attr-E<gt>rta_type) {\n"
"        case UNIX_DIAG_NAME:\n"
"            if (!path_len) {\n"
"                path_len = RTA_PAYLOAD(attr);\n"
"                if (path_len E<gt> sizeof(path) - 1)\n"
"                    path_len = sizeof(path) - 1;\n"
"                memcpy(path, RTA_DATA(attr), path_len);\n"
"                path[path_len] = '\\e0';\n"
"            }\n"
"            break;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:739
#, no-wrap
msgid ""
"        case UNIX_DIAG_PEER:\n"
"            if (RTA_PAYLOAD(attr) E<gt>= sizeof(peer))\n"
"                peer = *(unsigned int *) RTA_DATA(attr);\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"        case UNIX_DIAG_PEER:\n"
"            if (RTA_PAYLOAD(attr) E<gt>= sizeof(peer))\n"
"                peer = *(unsigned int *) RTA_DATA(attr);\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:741
#, no-wrap
msgid "    printf(\"inode=%u\", diag-E<gt>udiag_ino);\n"
msgstr "    printf(\"инода=%u\", diag-E<gt>udiag_ino);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:744
#, no-wrap
msgid ""
"    if (peer)\n"
"        printf(\", peer=%u\", peer);\n"
msgstr ""
"    if (peer)\n"
"        printf(\", другая сторона=%u\", peer);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:748
#, no-wrap
msgid ""
"    if (path_len)\n"
"        printf(\", name=%s%s\", *path ? \"\" : \"@\",\n"
"                *path ? path : path + 1);\n"
msgstr ""
"    if (path_len)\n"
"        printf(\", имя=%s%s\", *path ? \"\" : \"@\",\n"
"                *path ? path : path + 1);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:752
#, no-wrap
msgid ""
"    putchar('\\en');\n"
"    return 0;\n"
"}\n"
msgstr ""
"    putchar('\\en');\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:765
#, no-wrap
msgid ""
"static int\n"
"receive_responses(int fd)\n"
"{\n"
"    long buf[8192 / sizeof(long)];\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = buf,\n"
"        .iov_len = sizeof(buf)\n"
"    };\n"
"    int flags = 0;\n"
msgstr ""
"static int\n"
"receive_responses(int fd)\n"
"{\n"
"    long buf[8192 / sizeof(long)];\n"
"    struct sockaddr_nl nladdr = {\n"
"        .nl_family = AF_NETLINK\n"
"    };\n"
"    struct iovec iov = {\n"
"        .iov_base = buf,\n"
"        .iov_len = sizeof(buf)\n"
"    };\n"
"    int flags = 0;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:773
#, no-wrap
msgid ""
"    for (;;) {\n"
"        struct msghdr msg = {\n"
"            .msg_name = (void *) &nladdr,\n"
"            .msg_namelen = sizeof(nladdr),\n"
"            .msg_iov = &iov,\n"
"            .msg_iovlen = 1\n"
"        };\n"
msgstr ""
"    for (;;) {\n"
"        struct msghdr msg = {\n"
"            .msg_name = (void *) &nladdr,\n"
"            .msg_namelen = sizeof(nladdr),\n"
"            .msg_iov = &iov,\n"
"            .msg_iovlen = 1\n"
"        };\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:775
#, no-wrap
msgid "        ssize_t ret = recvmsg(fd, &msg, flags);\n"
msgstr "        ssize_t ret = recvmsg(fd, &msg, flags);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:779
#, no-wrap
msgid ""
"        if (ret E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
msgstr ""
"        if (ret E<lt> 0) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:785
#, no-wrap
msgid ""
"            perror(\"recvmsg\");\n"
"            return -1;\n"
"        }\n"
"        if (ret == 0)\n"
"            return 0;\n"
msgstr ""
"            perror(\"recvmsg\");\n"
"            return -1;\n"
"        }\n"
"        if (ret == 0)\n"
"            return 0;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:787
#, no-wrap
msgid "        const struct nlmsghdr *h = (struct nlmsghdr *) buf;\n"
msgstr "        const struct nlmsghdr *h = (struct nlmsghdr *) buf;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:792
#, no-wrap
msgid ""
"        if (!NLMSG_OK(h, ret)) {\n"
"            fputs(\"!NLMSG_OK\\en\", stderr);\n"
"            return -1;\n"
"        }\n"
msgstr ""
"        if (!NLMSG_OK(h, ret)) {\n"
"            fputs(\"!NLMSG_OK\\en\", stderr);\n"
"            return -1;\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:796
#, no-wrap
msgid ""
"        for (; NLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) {\n"
"            if (h-E<gt>nlmsg_type == NLMSG_DONE)\n"
"                return 0;\n"
msgstr ""
"        for (; NLMSG_OK(h, ret); h = NLMSG_NEXT(h, ret)) {\n"
"            if (h-E<gt>nlmsg_type == NLMSG_DONE)\n"
"                return 0;\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:799
#, no-wrap
msgid ""
"            if (h-E<gt>nlmsg_type == NLMSG_ERROR) {\n"
"                const struct nlmsgerr *err = NLMSG_DATA(h);\n"
msgstr ""
"            if (h-E<gt>nlmsg_type == NLMSG_ERROR) {\n"
"                const struct nlmsgerr *err = NLMSG_DATA(h);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:806
#, no-wrap
msgid ""
"                if (h-E<gt>nlmsg_len E<lt> NLMSG_LENGTH(sizeof(*err))) {\n"
"                    fputs(\"NLMSG_ERROR\\en\", stderr);\n"
"                } else {\n"
"                    errno = -err-E<gt>error;\n"
"                    perror(\"NLMSG_ERROR\");\n"
"                }\n"
msgstr ""
"                if (h-E<gt>nlmsg_len E<lt> NLMSG_LENGTH(sizeof(*err))) {\n"
"                    fputs(\"NLMSG_ERROR\\en\", stderr);\n"
"                } else {\n"
"                    errno = -err-E<gt>error;\n"
"                    perror(\"NLMSG_ERROR\");\n"
"                }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:809
#, no-wrap
msgid ""
"                return -1;\n"
"            }\n"
msgstr ""
"                return -1;\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:815
#, no-wrap
msgid ""
"            if (h-E<gt>nlmsg_type != SOCK_DIAG_BY_FAMILY) {\n"
"                fprintf(stderr, \"unexpected nlmsg_type %u\\en\",\n"
"                        (unsigned) h-E<gt>nlmsg_type);\n"
"                return -1;\n"
"            }\n"
msgstr ""
"            if (h-E<gt>nlmsg_type != SOCK_DIAG_BY_FAMILY) {\n"
"                fprintf(stderr, \"неожиданный nlmsg_type %u\\en\",\n"
"                        (unsigned) h-E<gt>nlmsg_type);\n"
"                return -1;\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:821
#, no-wrap
msgid ""
"            if (print_diag(NLMSG_DATA(h), h-E<gt>nlmsg_len))\n"
"                return -1;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            if (print_diag(NLMSG_DATA(h), h-E<gt>nlmsg_len))\n"
"                return -1;\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:826
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_SOCK_DIAG);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:831
#, no-wrap
msgid ""
"    if (fd E<lt> 0) {\n"
"        perror(\"socket\");\n"
"        return 1;\n"
"    }\n"
msgstr ""
"    if (fd E<lt> 0) {\n"
"        perror(\"socket\");\n"
"        return 1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:833
#, no-wrap
msgid "    int ret = send_query(fd) || receive_responses(fd);\n"
msgstr "    int ret = send_query(fd) || receive_responses(fd);\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:837
#, no-wrap
msgid ""
"    close(fd);\n"
"    return ret;\n"
"}\n"
msgstr ""
"    close(fd);\n"
"    return ret;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/sock_diag.7:842
msgid "B<netlink>(3), B<rtnetlink>(3), B<netlink>(7), B<tcp>(7)"
msgstr "B<netlink>(3), B<rtnetlink>(3), B<netlink>(7), B<tcp>(7)"

#. type: TH
#: man-pages/man7/signal.7:46
#, no-wrap
msgid "SIGNAL"
msgstr "SIGNAL"

#. type: TH
#: man-pages/man7/signal.7:46
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:49
msgid "signal - overview of signals"
msgstr "signal - обзор сигналов"

#. type: Plain text
#: man-pages/man7/signal.7:52
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard signals"
"\") and POSIX real-time signals."
msgstr ""
"В Linux поддерживаются надёжные (reliable) сигналы POSIX (далее, "
"«стандартные сигналы») и сигналы реального времени POSIX."

#. type: SS
#: man-pages/man7/signal.7:52
#, no-wrap
msgid "Signal dispositions"
msgstr "Обработчики сигнала"

#. type: Plain text
#: man-pages/man7/signal.7:57
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""
"Каждый сигнал имеет текущий I<обработчик>, который определяет, что будет "
"делать процесс при поступлении сигнала."

#. type: Plain text
#: man-pages/man7/signal.7:60
msgid ""
"The entries in the \"Action\" column of the table below specify the default "
"disposition for each signal, as follows:"
msgstr ""
"В таблице далее есть столбец «Действие», в котором указан обработчик по "
"умолчанию для каждого сигнала:"

#. type: tbl table
#: man-pages/man7/signal.7:60 man-pages/man7/signal.7:235
#: man-pages/man7/signal.7:240 man-pages/man7/signal.7:242
#: man-pages/man7/signal.7:246 man-pages/man7/signal.7:247
#: man-pages/man7/signal.7:249 man-pages/man7/signal.7:250
#: man-pages/man7/signal.7:251 man-pages/man7/signal.7:253
#: man-pages/man7/signal.7:255 man-pages/man7/signal.7:256
#: man-pages/man7/signal.7:259 man-pages/man7/signal.7:264
#: man-pages/man7/signal.7:270 man-pages/man7/signal.7:271
#: man-pages/man7/signal.7:272
#, no-wrap
msgid "Term"
msgstr "Term"

#. type: Plain text
#: man-pages/man7/signal.7:62
msgid "Default action is to terminate the process."
msgstr "Действие по умолчанию — завершение процесса."

#. type: tbl table
#: man-pages/man7/signal.7:62 man-pages/man7/signal.7:237
#: man-pages/man7/signal.7:238 man-pages/man7/signal.7:269
#: man-pages/man7/signal.7:277
#, no-wrap
msgid "Ign"
msgstr "Ign"

#. type: Plain text
#: man-pages/man7/signal.7:64
msgid "Default action is to ignore the signal."
msgstr "Действие по умолчанию — игнорирование сигнала."

#. type: tbl table
#: man-pages/man7/signal.7:64 man-pages/man7/signal.7:234
#: man-pages/man7/signal.7:236 man-pages/man7/signal.7:241
#: man-pages/man7/signal.7:244 man-pages/man7/signal.7:248
#: man-pages/man7/signal.7:257 man-pages/man7/signal.7:258
#: man-pages/man7/signal.7:262 man-pages/man7/signal.7:265
#: man-pages/man7/signal.7:268 man-pages/man7/signal.7:273
#: man-pages/man7/signal.7:275
#, no-wrap
msgid "Core"
msgstr "Core"

#. type: Plain text
#: man-pages/man7/signal.7:67
msgid ""
"Default action is to terminate the process and dump core (see B<core>(5))."
msgstr ""
"Действие по умолчанию — завершение процесса и вывод дампа в файл (смотрите "
"B<core>(5))."

#. type: tbl table
#: man-pages/man7/signal.7:67 man-pages/man7/signal.7:260
#: man-pages/man7/signal.7:261 man-pages/man7/signal.7:266
#: man-pages/man7/signal.7:267
#, no-wrap
msgid "Stop"
msgstr "Stop"

#. type: Plain text
#: man-pages/man7/signal.7:69
msgid "Default action is to stop the process."
msgstr "Действие по умолчанию — остановка процесса."

#. type: tbl table
#: man-pages/man7/signal.7:69 man-pages/man7/signal.7:239
#, no-wrap
msgid "Cont"
msgstr "Cont"

#. type: Plain text
#: man-pages/man7/signal.7:71
msgid "Default action is to continue the process if it is currently stopped."
msgstr ""
"Действие по умолчанию — продолжение работы процесса, если он в данный момент "
"остановлен."

#. type: Plain text
#: man-pages/man7/signal.7:87
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered."
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:94
msgid ""
"By default, a signal handler is invoked on the normal process stack.  It is "
"possible to arrange that the signal handler uses an alternate stack; see "
"B<sigaltstack>(2)  for a discussion of how to do this and when it might be "
"useful."
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:98
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""
"Реакция на сигналы является атрибутом процесса: в многонитевом приложении "
"реакция на определённый сигнал одинакова для всех нитей."

#. type: Plain text
#: man-pages/man7/signal.7:106
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""
"Потомок, созданный с помощью B<fork>(2), наследует реакцию на сигналы от "
"своего родителя. При B<execve>(2) реакция на сигналы устанавливается в "
"значение по умолчанию; реакция на игнорируемые сигналы не изменяется."

#. type: SS
#: man-pages/man7/signal.7:106
#, no-wrap
msgid "Sending a signal"
msgstr "Отправка сигнала"

#. type: Plain text
#: man-pages/man7/signal.7:109
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""
"Для отправки сигнала можно использовать следующие системные вызовы и "
"библиотечные функции:"

#. type: TP
#: man-pages/man7/signal.7:109
#, no-wrap
msgid "B<raise>(3)"
msgstr "B<raise>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:112
msgid "Sends a signal to the calling thread."
msgstr "Посылает сигнал вызвавшей нити."

#. type: TP
#: man-pages/man7/signal.7:112
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:117
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""
"Посылает сигнал указанному процессу, всем членам указанной группы процессов "
"или всем процессам в системе."

#. type: TP
#: man-pages/man7/signal.7:117
#, no-wrap
msgid "B<killpg>(3)"
msgstr "B<killpg>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:120
msgid "Sends a signal to all of the members of a specified process group."
msgstr "Посылает сигнал всем членам указанной группы процессов."

#. type: TP
#: man-pages/man7/signal.7:120
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr "B<pthread_kill>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:124
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the caller."
msgstr ""
"Посылает сигнал указанной нити POSIX в том же процессе, что и вызывающий."

#. type: TP
#: man-pages/man7/signal.7:124
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:129
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""
"Посылает сигнал указанной нити в указанном процессе (данный системный вызов "
"используется в реализации B<pthread_kill>(3))."

#. type: TP
#: man-pages/man7/signal.7:129
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr "B<sigqueue>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:132
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr ""
"Посылает сигнал реального времени указанному процессу с сопроводительными "
"данными."

#. type: SS
#: man-pages/man7/signal.7:132
#, no-wrap
msgid "Waiting for a signal to be caught"
msgstr "Ожидание сигнала для обработки"

#. type: Plain text
#: man-pages/man7/signal.7:136
msgid ""
"The following system calls suspend execution of the calling thread until a "
"signal is caught (or an unhandled signal terminates the process):"
msgstr ""
"Следующие системные вызовы приостанавливают выполнение вызывающей нити до "
"тех пор, пока не будет пойман сигнал (или необработанный сигнал не завершит "
"процесс):"

#. type: TP
#: man-pages/man7/signal.7:136
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:139
msgid "Suspends execution until any signal is caught."
msgstr ""
"Приостанавливает выполнение до тех пор, пока не будет пойман любой сигнал."

#. type: tbl table
#: man-pages/man7/signal.7:139 man-pages/man7/signal.7:521
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:143
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""
"Временно изменяет маску сигналов (смотрите далее) и приостанавливает "
"выполнение до получения одного из незамаскированных сигналов."

#. type: SS
#: man-pages/man7/signal.7:143
#, no-wrap
msgid "Synchronously accepting a signal"
msgstr "Синхронный приём сигнала"

#. type: Plain text
#: man-pages/man7/signal.7:150
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""
"В отличие от асинхронного получения сигнала через обработчик, возможно "
"синхронно получить сигнал, то есть блокировать выполнение до поступления "
"сигнала в некоторой точке, в которой ядро вернёт информацию о сигнале "
"вызывающему. Для этого существует два пути:"

#. type: IP
#: man-pages/man7/signal.7:150 man-pages/man7/signal.7:158
#: man-pages/man7/signal.7:387 man-pages/man7/signal.7:395
#: man-pages/man7/signal.7:528 man-pages/man7/signal.7:530
#: man-pages/man7/signal.7:550 man-pages/man7/signal.7:566
#: man-pages/man7/signal.7:570 man-pages/man7/signal.7:577
#: man-pages/man7/signal.7:595 man-pages/man7/signal.7:605
#: man-pages/man7/signal.7:612 man-pages/man7/signal.7:619
#: man-pages/man7/signal.7:621 man-pages/man7/signal.7:625
#: man-pages/man7/signal.7:628 man-pages/man7/signal.7:637
#: man-pages/man7/signal.7:656 man-pages/man7/signal.7:670
#: man-pages/man7/signal.7:681 man-pages/man7/signal.7:688
#: man-pages/man7/signal.7:697 man-pages/man7/signal.7:705
#: man-pages/man7/signal.7:711 man-pages/man7/signal.7:729
#: man-pages/man7/signal.7:743 man-pages/man7/signal.7:757
#: man-pages/man7/signal.7:760 man-pages/man7/signal.7:763
#: man-pages/man7/signal.7:766 man-pages/man7/signal.7:773
#: man-pages/man7/signal.7:779 man-pages/man7/signal.7:783
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/signal.7:158
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""
"С помощью B<sigwaitinfo>(2), B<sigtimedwait>(2) и B<sigwait>(3). Они "
"приостанавливают выполнение до поступления одного из заданного набора "
"сигналов. Каждый из этих вызовов возвращает информацию о полученном сигнале."

#. type: Plain text
#: man-pages/man7/signal.7:171
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each "
"B<read>(2)  from this file descriptor blocks until one of the signals in the "
"set specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""
"С помощью B<signalfd>(2). Данный вызов возвращает файловый дескриптор, "
"который можно использовать для чтения информации о сигналах, доставляемых "
"вызывающему. Каждое выполнение B<read>(2) с этим файловым дескриптором "
"блокируется до тех пор, пока один из сигналов набора, указанного в вызове "
"B<signalfd>(2), не будет послан вызывающему. В возвращаемом B<read>(2) "
"буфере содержится структура, описывающая сигнал."

#. type: SS
#: man-pages/man7/signal.7:171
#, no-wrap
msgid "Signal mask and pending signals"
msgstr "Сигнальная маска и ожидающие сигналы"

#. type: Plain text
#: man-pages/man7/signal.7:178
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""
"Сигнал может быть I<заблокирован>. Это означает, что он не будет доставлен "
"до тех пор, пока не будет разблокирован. В промежуток времени от генерации "
"сигнала и до его доставки о сигнале говорят как об I<ожидающем>."

#. type: Plain text
#: man-pages/man7/signal.7:187
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""
"В каждой нити процесса имеется независимая I<сигнальная маска>, определяющая "
"набор сигналов, которые нить, в данный момент, блокирует. Нить может "
"управлять сигнальной маской с помощью B<pthread_sigmask>(3). В обычном "
"однонитевом приложении для работы с сигнальной маской можно использовать "
"вызов B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:193
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""
"Потомок, создаваемый с помощью B<fork>(2), наследует копию родительской "
"маски сигналов; маска сигналов сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:210
msgid ""
"A signal may be generated (and thus pending)  for a process as a whole (e."
"g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
"signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
"executing a specific machine-language instruction are thread directed, as "
"are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
"process-directed signal may be delivered to any one of the threads that does "
"not currently have the signal blocked.  If more than one of the threads has "
"the signal unblocked, then the kernel chooses an arbitrary thread to which "
"to deliver the signal."
msgstr ""
"Сигнал может быть сгенерирован (а значит и стать ожидающим) как для всего "
"процесса (например, при отправке с помощью B<kill>(2)) так и для отдельной "
"нити (например, некоторые сигналы, такие как B<SIGSEGV> и B<SIGFPE>, "
"сгенерированные в следствии выполнения определённой инструкции на машинном "
"языке в самой нити, или сигналы, направленные определённой нити с помощью "
"B<pthread_kill>(3)). Направленный процессу сигнал может быть доставлен в "
"любую из нитей, у которых сигнал не заблокирован. Если имеется несколько "
"таких нитей, то ядро выбирает произвольную нить, которой и доставит сигнал."

#. type: Plain text
#: man-pages/man7/signal.7:217
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""
"Нить может получить набор сигналов, которые находятся в состоянии ожидания с "
"помощью вызова B<sigpending>(2). Этот набор будет состоять из объединения "
"набора ожидающих сигналов, направленных процессу, и набора ожидающих "
"сигналов для вызвавшей нити."

#. type: Plain text
#: man-pages/man7/signal.7:223
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""
"Потомок, созданный с помощью B<fork>(2), первоначально имеет пустой набор "
"ожидающих сигналов; набор ожидающих сигналов сохраняется при вызове "
"B<execve>(2)."

#. type: SS
#: man-pages/man7/signal.7:223
#, no-wrap
msgid "Standard signals"
msgstr "Стандартные сигналы"

#. type: Plain text
#: man-pages/man7/signal.7:229
msgid ""
"Linux supports the standard signals listed below.  The second column of the "
"table indicates which standard (if any)  specified the signal: \"P1990\" "
"indicates that the signal is described in the original POSIX.1-1990 "
"standard; \"P2001\" indicates that the signal was added in SUSv2 and "
"POSIX.1-2001."
msgstr ""
"Linux поддерживает стандартные сигналы, перечисленные далее. Во второй "
"колонке таблицы указан стандарт (если есть), которым введён сигнал, "
"например, «P1990» — сигнал описан в первоначальной версии стандарта "
"POSIX.1-1990; «P2001» — сигнал добавлен в SUSv2 и POSIX.1-2001."

#. type: tbl table
#: man-pages/man7/signal.7:233 man-pages/man7/signal.7:344
#, no-wrap
msgid "Signal"
msgstr "Сигнал"

#. type: tbl table
#: man-pages/man7/signal.7:233
#, no-wrap
msgid "Standard"
msgstr "Стандарт"

#. type: tbl table
#: man-pages/man7/signal.7:233
#, no-wrap
msgid "Action"
msgstr "Действие"

#. type: tbl table
#: man-pages/man7/signal.7:233
#, no-wrap
msgid "Comment"
msgstr "Комментарий"

#. type: tbl table
#: man-pages/man7/signal.7:234 man-pages/man7/signal.7:351
#, no-wrap
msgid "SIGABRT"
msgstr "SIGABRT"

#. type: tbl table
#: man-pages/man7/signal.7:234 man-pages/man7/signal.7:235
#: man-pages/man7/signal.7:237 man-pages/man7/signal.7:239
#: man-pages/man7/signal.7:241 man-pages/man7/signal.7:242
#: man-pages/man7/signal.7:244 man-pages/man7/signal.7:246
#: man-pages/man7/signal.7:249 man-pages/man7/signal.7:251
#: man-pages/man7/signal.7:257 man-pages/man7/signal.7:258
#: man-pages/man7/signal.7:260 man-pages/man7/signal.7:261
#: man-pages/man7/signal.7:264 man-pages/man7/signal.7:266
#: man-pages/man7/signal.7:267 man-pages/man7/signal.7:270
#: man-pages/man7/signal.7:271
#, no-wrap
msgid "P1990"
msgstr "P1990"

#. type: tbl table
#: man-pages/man7/signal.7:234
#, no-wrap
msgid "Abort signal from B<abort>(3)"
msgstr "Сигнал аварии (abort), посланный B<abort>(3)"

#. type: tbl table
#: man-pages/man7/signal.7:235 man-pages/man7/signal.7:361
#, no-wrap
msgid "SIGALRM"
msgstr "SIGALRM"

#. type: tbl table
#: man-pages/man7/signal.7:235
#, no-wrap
msgid "Timer signal from B<alarm>(2)"
msgstr "Сигнал таймера, посланный B<alarm>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:236 man-pages/man7/signal.7:353
#, no-wrap
msgid "SIGBUS"
msgstr "SIGBUS"

#. type: tbl table
#: man-pages/man7/signal.7:236 man-pages/man7/signal.7:253
#: man-pages/man7/signal.7:255 man-pages/man7/signal.7:262
#: man-pages/man7/signal.7:265 man-pages/man7/signal.7:269
#: man-pages/man7/signal.7:272 man-pages/man7/signal.7:273
#: man-pages/man7/signal.7:275
#, no-wrap
msgid "P2001"
msgstr "P2001"

#. type: tbl table
#: man-pages/man7/signal.7:236
#, no-wrap
msgid "Bus error (bad memory access)"
msgstr "Ошибка шины (некорректный адрес доступа)"

#. type: tbl table
#: man-pages/man7/signal.7:237 man-pages/man7/signal.7:364
#, no-wrap
msgid "SIGCHLD"
msgstr "SIGCHLD"

#. type: tbl table
#: man-pages/man7/signal.7:237
#, no-wrap
msgid "Child stopped or terminated"
msgstr "Потомок остановлен или завершился"

#. type: tbl table
#: man-pages/man7/signal.7:238 man-pages/man7/signal.7:365
#, no-wrap
msgid "SIGCLD"
msgstr "SIGCLD"

#. type: tbl table
#: man-pages/man7/signal.7:238 man-pages/man7/signal.7:240
#: man-pages/man7/signal.7:245 man-pages/man7/signal.7:247
#: man-pages/man7/signal.7:248 man-pages/man7/signal.7:250
#: man-pages/man7/signal.7:256 man-pages/man7/signal.7:259
#: man-pages/man7/signal.7:268 man-pages/man7/signal.7:277
#: man-pages/man7/signal.7:354 man-pages/man7/signal.7:363
#: man-pages/man7/signal.7:365 man-pages/man7/signal.7:380
#: man-pages/man7/signal.7:381 man-pages/man7/signal.7:383
#, no-wrap
msgid "-"
msgstr "-"

#. type: tbl table
#: man-pages/man7/signal.7:238
#, no-wrap
msgid "A synonym for B<SIGCHLD>"
msgstr "Синоним B<SIGCHLD>"

#. type: tbl table
#: man-pages/man7/signal.7:239 man-pages/man7/signal.7:366
#, no-wrap
msgid "SIGCONT"
msgstr "SIGCONT"

#. type: tbl table
#: man-pages/man7/signal.7:239
#, no-wrap
msgid "Continue if stopped"
msgstr "Продолжить, если остановлен"

#. type: tbl table
#: man-pages/man7/signal.7:240 man-pages/man7/signal.7:354
#, no-wrap
msgid "SIGEMT"
msgstr "SIGEMT"

#. type: tbl table
#: man-pages/man7/signal.7:240
#, no-wrap
msgid "Emulator trap"
msgstr "Ловушка эмулятора"

#. type: tbl table
#: man-pages/man7/signal.7:241 man-pages/man7/signal.7:355
#, no-wrap
msgid "SIGFPE"
msgstr "SIGFPE"

#. type: tbl table
#: man-pages/man7/signal.7:241
#, no-wrap
msgid "Floating-point exception"
msgstr "Ошибка операций с плавающей запятой"

#. type: tbl table
#: man-pages/man7/signal.7:242 man-pages/man7/signal.7:346
#, no-wrap
msgid "SIGHUP"
msgstr "SIGHUP"

#. type: tbl table
#: man-pages/man7/signal.7:242
#, no-wrap
msgid "Hangup detected on controlling terminal"
msgstr "Обнаружен обрыв связи с управляющим"

#. type: tbl table
#: man-pages/man7/signal.7:243
#, no-wrap
msgid "or death of controlling process"
msgstr "терминалом, либо завершение управляющего терминалом процесса"

#. type: tbl table
#: man-pages/man7/signal.7:244 man-pages/man7/signal.7:349
#, no-wrap
msgid "SIGILL"
msgstr "SIGILL"

#. type: tbl table
#: man-pages/man7/signal.7:244
#, no-wrap
msgid "Illegal Instruction"
msgstr "Недопустимая инструкция"

#. type: tbl table
#: man-pages/man7/signal.7:245 man-pages/man7/signal.7:380
#, no-wrap
msgid "SIGINFO"
msgstr "SIGINFO"

#. type: tbl table
#: man-pages/man7/signal.7:245
#, no-wrap
msgid "A synonym for B<SIGPWR>"
msgstr "Синоним B<SIGPWR>"

#. type: tbl table
#: man-pages/man7/signal.7:246 man-pages/man7/signal.7:347
#, no-wrap
msgid "SIGINT"
msgstr "SIGINT"

#. type: tbl table
#: man-pages/man7/signal.7:246
#, no-wrap
msgid "Interrupt from keyboard"
msgstr "Прерывание с клавиатуры"

#. type: tbl table
#: man-pages/man7/signal.7:247 man-pages/man7/signal.7:377
#, no-wrap
msgid "SIGIO"
msgstr "SIGIO"

#. type: tbl table
#: man-pages/man7/signal.7:247
#, no-wrap
msgid "I/O now possible (4.2BSD)"
msgstr "Теперь возможен ввод/вывод (4.2BSD)"

#. type: tbl table
#: man-pages/man7/signal.7:248 man-pages/man7/signal.7:352
#, no-wrap
msgid "SIGIOT"
msgstr "SIGIOT"

#. type: tbl table
#: man-pages/man7/signal.7:248
#, no-wrap
msgid "IOT trap. A synonym for B<SIGABRT>"
msgstr "Ловушка IOT. Синоним B<SIGABRT>"

#. type: tbl table
#: man-pages/man7/signal.7:249 man-pages/man7/signal.7:356
#, no-wrap
msgid "SIGKILL"
msgstr "SIGKILL"

#. type: tbl table
#: man-pages/man7/signal.7:249
#, no-wrap
msgid "Kill signal"
msgstr "Kill-сигнал"

#. type: tbl table
#: man-pages/man7/signal.7:250 man-pages/man7/signal.7:381
#, no-wrap
msgid "SIGLOST"
msgstr "SIGLOST"

#. type: tbl table
#: man-pages/man7/signal.7:250
#, no-wrap
msgid "File lock lost (unused)"
msgstr "Утрачена блокировка файла (не используется)"

#. type: tbl table
#: man-pages/man7/signal.7:251 man-pages/man7/signal.7:360
#, no-wrap
msgid "SIGPIPE"
msgstr "SIGPIPE"

#. type: tbl table
#: man-pages/man7/signal.7:251
#, no-wrap
msgid "Broken pipe: write to pipe with no"
msgstr "Обрыв канала: запись в канал без"

#. type: tbl table
#: man-pages/man7/signal.7:252
#, no-wrap
msgid "readers; see B<pipe>(7)"
msgstr "читателей; смотрите B<pipe>(7)"

#. type: tbl table
#: man-pages/man7/signal.7:253 man-pages/man7/signal.7:378
#, no-wrap
msgid "SIGPOLL"
msgstr "SIGPOLL"

#. type: tbl table
#: man-pages/man7/signal.7:253
#, no-wrap
msgid "Pollable event (Sys V)."
msgstr "Опрашиваемое событие (Sys V)"

#. type: tbl table
#: man-pages/man7/signal.7:254
#, no-wrap
msgid "Synonym for B<SIGIO>"
msgstr "Синоним B<SIGIO>"

#. type: tbl table
#: man-pages/man7/signal.7:255 man-pages/man7/signal.7:375
#, no-wrap
msgid "SIGPROF"
msgstr "SIGPROF"

#. type: tbl table
#: man-pages/man7/signal.7:255
#, no-wrap
msgid "Profiling timer expired"
msgstr "Время профилирования истекло"

#. type: tbl table
#: man-pages/man7/signal.7:256 man-pages/man7/signal.7:379
#, no-wrap
msgid "SIGPWR"
msgstr "SIGPWR"

#. type: tbl table
#: man-pages/man7/signal.7:256
#, no-wrap
msgid "Power failure (System V)"
msgstr "Отказ питания (System V)"

#. type: tbl table
#: man-pages/man7/signal.7:257 man-pages/man7/signal.7:348
#, no-wrap
msgid "SIGQUIT"
msgstr "SIGQUIT"

#. type: tbl table
#: man-pages/man7/signal.7:257
#, no-wrap
msgid "Quit from keyboard"
msgstr "Выход с клавиатуры"

#. type: tbl table
#: man-pages/man7/signal.7:258 man-pages/man7/signal.7:358
#, no-wrap
msgid "SIGSEGV"
msgstr "SIGSEGV"

#. type: tbl table
#: man-pages/man7/signal.7:258
#, no-wrap
msgid "Invalid memory reference"
msgstr "Некорректная ссылка в память"

#. type: tbl table
#: man-pages/man7/signal.7:259 man-pages/man7/signal.7:363
#, no-wrap
msgid "SIGSTKFLT"
msgstr "SIGSTKFLT"

#. type: tbl table
#: man-pages/man7/signal.7:259
#, no-wrap
msgid "Stack fault on coprocessor (unused)"
msgstr "Ошибка стека на сопроцессоре (не используется)"

#. type: tbl table
#: man-pages/man7/signal.7:260 man-pages/man7/signal.7:367
#, no-wrap
msgid "SIGSTOP"
msgstr "SIGSTOP"

#. type: tbl table
#: man-pages/man7/signal.7:260
#, no-wrap
msgid "Stop process"
msgstr "Остановить процесс"

#. type: tbl table
#: man-pages/man7/signal.7:261 man-pages/man7/signal.7:368
#, no-wrap
msgid "SIGTSTP"
msgstr "SIGTSTP"

#. type: tbl table
#: man-pages/man7/signal.7:261
#, no-wrap
msgid "Stop typed at terminal"
msgstr "Останов введён с терминала"

#. type: tbl table
#: man-pages/man7/signal.7:262 man-pages/man7/signal.7:382
#, no-wrap
msgid "SIGSYS"
msgstr "SIGSYS"

#. type: tbl table
#: man-pages/man7/signal.7:262
#, no-wrap
msgid "Bad system call (SVr4);"
msgstr "Неправильный системный вызов (SVr4);"

#. type: tbl table
#: man-pages/man7/signal.7:263
#, no-wrap
msgid "see also B<seccomp>(2)"
msgstr "смотрите также B<seccomp>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:264 man-pages/man7/signal.7:362
#, no-wrap
msgid "SIGTERM"
msgstr "SIGTERM"

#. type: tbl table
#: man-pages/man7/signal.7:264
#, no-wrap
msgid "Termination signal"
msgstr "Сигнал завершения"

#. type: tbl table
#: man-pages/man7/signal.7:265 man-pages/man7/signal.7:350
#, no-wrap
msgid "SIGTRAP"
msgstr "SIGTRAP"

#. type: tbl table
#: man-pages/man7/signal.7:265
#, no-wrap
msgid "Trace/breakpoint trap"
msgstr "Прерывание из-за трассировки/останова"

#. type: tbl table
#: man-pages/man7/signal.7:266 man-pages/man7/signal.7:369
#, no-wrap
msgid "SIGTTIN"
msgstr "SIGTTIN"

#. type: tbl table
#: man-pages/man7/signal.7:266
#, no-wrap
msgid "Terminal input for background process"
msgstr "Ввод с терминала для фонового процесса"

#. type: tbl table
#: man-pages/man7/signal.7:267 man-pages/man7/signal.7:370
#, no-wrap
msgid "SIGTTOU"
msgstr "SIGTTOU"

#. type: tbl table
#: man-pages/man7/signal.7:267
#, no-wrap
msgid "Terminal output for background process"
msgstr "Вывод с терминала для фонового процесса"

#. type: tbl table
#: man-pages/man7/signal.7:268 man-pages/man7/signal.7:383
#, no-wrap
msgid "SIGUNUSED"
msgstr "SIGUNUSED"

#. type: tbl table
#: man-pages/man7/signal.7:268
#, no-wrap
msgid "Synonymous with B<SIGSYS>"
msgstr "Синоним B<SIGSYS>"

#. type: tbl table
#: man-pages/man7/signal.7:269 man-pages/man7/signal.7:371
#, no-wrap
msgid "SIGURG"
msgstr "SIGURG"

#. type: tbl table
#: man-pages/man7/signal.7:269
#, no-wrap
msgid "Urgent condition on socket (4.2BSD)"
msgstr "Требующее внимание условие сокета (4.2BSD)"

#. type: tbl table
#: man-pages/man7/signal.7:270 man-pages/man7/signal.7:357
#, no-wrap
msgid "SIGUSR1"
msgstr "SIGUSR1"

#. type: tbl table
#: man-pages/man7/signal.7:270
#, no-wrap
msgid "User-defined signal 1"
msgstr "Определяемый пользователем сигнал 1"

#. type: tbl table
#: man-pages/man7/signal.7:271 man-pages/man7/signal.7:359
#, no-wrap
msgid "SIGUSR2"
msgstr "SIGUSR2"

#. type: tbl table
#: man-pages/man7/signal.7:271
#, no-wrap
msgid "User-defined signal 2"
msgstr "Определяемый пользователем сигнал 2"

#. type: tbl table
#: man-pages/man7/signal.7:272 man-pages/man7/signal.7:374
#, no-wrap
msgid "SIGVTALRM"
msgstr "SIGVTALRM"

#. type: tbl table
#: man-pages/man7/signal.7:272
#, no-wrap
msgid "Virtual alarm clock (4.2BSD)"
msgstr "Виртуальный будильник (4.2BSD)"

#. type: tbl table
#: man-pages/man7/signal.7:273 man-pages/man7/signal.7:372
#, no-wrap
msgid "SIGXCPU"
msgstr "SIGXCPU"

#. type: tbl table
#: man-pages/man7/signal.7:273
#, no-wrap
msgid "CPU time limit exceeded (4.2BSD);"
msgstr "Превышен предел процессорного времени (4.2BSD);"

#. type: tbl table
#: man-pages/man7/signal.7:274 man-pages/man7/signal.7:276
#, no-wrap
msgid "see B<setrlimit>(2)"
msgstr "смотрите B<setrlimit>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:275 man-pages/man7/signal.7:373
#, no-wrap
msgid "SIGXFSZ"
msgstr "SIGXFSZ"

#. type: tbl table
#: man-pages/man7/signal.7:275
#, no-wrap
msgid "File size limit exceeded (4.2BSD);"
msgstr "Превышен предел размера файла (4.2BSD);"

#. type: tbl table
#: man-pages/man7/signal.7:277 man-pages/man7/signal.7:376
#, no-wrap
msgid "SIGWINCH"
msgstr "SIGWINCH"

#. type: tbl table
#: man-pages/man7/signal.7:277
#, no-wrap
msgid "Window resize signal (4.3BSD, Sun)"
msgstr "Сигнал изменения размера окна (4.3BSD, Sun)"

#. type: Plain text
#: man-pages/man7/signal.7:285
msgid ""
"The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr ""
"Сигналы B<SIGKILL> и B<SIGSTOP> нельзя поймать, заблокировать или "
"проигнорировать."

#. type: Plain text
#: man-pages/man7/signal.7:296
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""
"В Linux до версии 2.2 включительно поведением по умолчанию для сигналов "
"B<SIGSYS>, B<SIGXCPU>, B<SIGXFSZ> и B<SIGBUS> (на всех архитектурах кроме "
"SPARC и MIPS) было завершение процесса без создания дампа (в некоторых "
"системах UNIX действием по умолчанию для B<SIGXCPU> и B<SIGXFSZ> является "
"завершение процесса без создания дампа). Linux версии 2.4 соответствует "
"требованиям POSIX.1-2001 для этих сигналов и завершает процесс с созданием "
"дампа."

#. type: Plain text
#: man-pages/man7/signal.7:303
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""
"Сигнал B<SIGEMT> не определён в POSIX.1-2001, но, тем не менее, появляется "
"почти во всех системах UNIX, где действием по умолчанию для него является "
"завершение процесса с созданием дампа."

#. type: Plain text
#: man-pages/man7/signal.7:307
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""
"Сигнал B<SIGPWR> (не определён в POSIX.1-2001) по умолчанию, обычно, "
"игнорируется (в других системах UNIX)."

#. type: Plain text
#: man-pages/man7/signal.7:312
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""
"Для сигнала B<SIGIO> (не определён в POSIX.1-2001) в других системах UNIX "
"действием по умолчанию является игнорирование."

#. type: SS
#: man-pages/man7/signal.7:312
#, no-wrap
msgid "Queueing and delivery semantics for standard signals"
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:315
msgid ""
"If multiple standard signals are pending for a process, the order in which "
"the signals are delivered is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:330
msgid ""
"Standard signals do not queue.  If multiple instances of a standard signal "
"are generated while that signal is blocked, then only one instance of the "
"signal is marked as pending (and the signal will be delivered just once when "
"it is unblocked).  In the case where a standard signal is already pending, "
"the I<siginfo_t> structure (see B<sigaction>(2))  associated with that "
"signal is not overwritten on arrival of subsequent instances of the same "
"signal.  Thus, the process will receive the information associated with the "
"first instance of the signal."
msgstr ""

#. type: SS
#: man-pages/man7/signal.7:330
#, no-wrap
msgid "Signal numbering for standard signals"
msgstr "Нумерация стандартных сигналов"

#. type: Plain text
#: man-pages/man7/signal.7:339
msgid ""
"The numeric value for each signal is given in the table below.  As shown in "
"the table, many signals have different numeric values on different "
"architectures.  The first numeric value in each table row shows the signal "
"number on x86, ARM, and most other architectures; the second value is for "
"Alpha and SPARC; the third is for MIPS; and the last is for PARISC.  A dash "
"(-) denotes that a signal is absent on the corresponding architecture."
msgstr ""
"Числовое значение каждого сигнала показано в таблице ниже. У многих сигналов "
"номера различаются на разных архитектурах. Первое числовое значение в каждой "
"строке таблицы описывает номер сигнала на x86, ARM и большинстве других "
"архитектур; второе значение для Alpha и SPARC, третье для MIPS, последнее "
"для PARISC. Символ минус (-) означает, что сигнал отсутствует в "
"соответствующей архитектуре."

#. type: tbl table
#: man-pages/man7/signal.7:344
#, no-wrap
msgid "x86/ARM"
msgstr "x86/ARM"

#. type: tbl table
#: man-pages/man7/signal.7:344
#, no-wrap
msgid "Alpha/"
msgstr "Alpha/"

#. type: tbl table
#: man-pages/man7/signal.7:344
#, no-wrap
msgid "MIPS"
msgstr "MIPS"

#. type: tbl table
#: man-pages/man7/signal.7:344
#, no-wrap
msgid "PARISC"
msgstr "PARISC"

#. type: tbl table
#: man-pages/man7/signal.7:344
#, no-wrap
msgid "Notes"
msgstr "Примечания"

#. type: tbl table
#: man-pages/man7/signal.7:345
#, no-wrap
msgid "most others"
msgstr "большинство других"

#. type: tbl table
#: man-pages/man7/signal.7:345
#, no-wrap
msgid "SPARC"
msgstr "SPARC"

#. type: tbl table
#: man-pages/man7/signal.7:346
#, no-wrap
msgid "\\01"
msgstr "\\01"

#. type: tbl table
#: man-pages/man7/signal.7:347
#, no-wrap
msgid "\\02"
msgstr "\\02"

#. type: tbl table
#: man-pages/man7/signal.7:348
#, no-wrap
msgid "\\03"
msgstr "\\03"

#. type: tbl table
#: man-pages/man7/signal.7:349
#, no-wrap
msgid "\\04"
msgstr "\\04"

#. type: tbl table
#: man-pages/man7/signal.7:350
#, no-wrap
msgid "\\05"
msgstr "\\05"

#. type: tbl table
#: man-pages/man7/signal.7:351 man-pages/man7/signal.7:352
#, no-wrap
msgid "\\06"
msgstr "\\06"

#. type: tbl table
#: man-pages/man7/signal.7:353 man-pages/man7/signal.7:354
#: man-pages/man7/signal.7:363
#, no-wrap
msgid "\\07"
msgstr "\\07"

#. type: tbl table
#: man-pages/man7/signal.7:353 man-pages/man7/signal.7:357
#, no-wrap
msgid "10"
msgstr "10"

#. type: tbl table
#: man-pages/man7/signal.7:355
#, no-wrap
msgid "\\08"
msgstr "\\08"

#. type: tbl table
#: man-pages/man7/signal.7:356
#, no-wrap
msgid "\\09"
msgstr "\\09"

#. type: tbl table
#: man-pages/man7/signal.7:357 man-pages/man7/signal.7:372
#: man-pages/man7/signal.7:373 man-pages/man7/signal.7:379
#, no-wrap
msgid "30"
msgstr "30"

#. type: tbl table
#: man-pages/man7/signal.7:357 man-pages/man7/signal.7:363
#: man-pages/man7/signal.7:371
#, no-wrap
msgid "16"
msgstr "16"

#. type: tbl table
#: man-pages/man7/signal.7:358
#, no-wrap
msgid "11"
msgstr "11"

#. type: tbl table
#: man-pages/man7/signal.7:359 man-pages/man7/signal.7:372
#: man-pages/man7/signal.7:382
#, no-wrap
msgid "12"
msgstr "12"

#. type: tbl table
#: man-pages/man7/signal.7:359 man-pages/man7/signal.7:373
#: man-pages/man7/signal.7:382 man-pages/man7/signal.7:383
#, no-wrap
msgid "31"
msgstr "31"

#. type: tbl table
#: man-pages/man7/signal.7:359 man-pages/man7/signal.7:364
#: man-pages/man7/signal.7:367
#, no-wrap
msgid "17"
msgstr "17"

#. type: tbl table
#: man-pages/man7/signal.7:360
#, no-wrap
msgid "13"
msgstr "13"

#. type: tbl table
#: man-pages/man7/signal.7:361
#, no-wrap
msgid "14"
msgstr "14"

#. type: tbl table
#: man-pages/man7/signal.7:362
#, no-wrap
msgid "15"
msgstr "15"

#. type: tbl table
#: man-pages/man7/signal.7:364 man-pages/man7/signal.7:368
#: man-pages/man7/signal.7:374 man-pages/man7/signal.7:376
#, no-wrap
msgid "20"
msgstr "20"

#. type: tbl table
#: man-pages/man7/signal.7:364 man-pages/man7/signal.7:365
#: man-pages/man7/signal.7:366 man-pages/man7/signal.7:368
#, no-wrap
msgid "18"
msgstr "18"

#. type: tbl table
#: man-pages/man7/signal.7:366 man-pages/man7/signal.7:367
#: man-pages/man7/signal.7:379
#, no-wrap
msgid "19"
msgstr "19"

#. type: tbl table
#: man-pages/man7/signal.7:366 man-pages/man7/signal.7:368
#: man-pages/man7/signal.7:373
#, no-wrap
msgid "25"
msgstr "25"

#. type: tbl table
#: man-pages/man7/signal.7:366 man-pages/man7/signal.7:369
#: man-pages/man7/signal.7:374
#, no-wrap
msgid "26"
msgstr "26"

#. type: tbl table
#: man-pages/man7/signal.7:367 man-pages/man7/signal.7:371
#: man-pages/man7/signal.7:376 man-pages/man7/signal.7:377
#, no-wrap
msgid "23"
msgstr "23"

#. type: tbl table
#: man-pages/man7/signal.7:367 man-pages/man7/signal.7:368
#: man-pages/man7/signal.7:372
#, no-wrap
msgid "24"
msgstr "24"

#. type: tbl table
#: man-pages/man7/signal.7:369 man-pages/man7/signal.7:371
#: man-pages/man7/signal.7:375
#, no-wrap
msgid "21"
msgstr "21"

#. type: tbl table
#: man-pages/man7/signal.7:369 man-pages/man7/signal.7:370
#: man-pages/man7/signal.7:375
#, no-wrap
msgid "27"
msgstr "27"

#. type: tbl table
#: man-pages/man7/signal.7:370 man-pages/man7/signal.7:377
#, no-wrap
msgid "22"
msgstr "22"

#. type: tbl table
#: man-pages/man7/signal.7:370 man-pages/man7/signal.7:374
#: man-pages/man7/signal.7:376
#, no-wrap
msgid "28"
msgstr "28"

#. type: tbl table
#: man-pages/man7/signal.7:371 man-pages/man7/signal.7:375
#: man-pages/man7/signal.7:377
#, no-wrap
msgid "29"
msgstr "29"

#. type: tbl table
#: man-pages/man7/signal.7:378
#, no-wrap
msgid "Same as SIGIO"
msgstr "Тот же, что SIGIO"

#. type: tbl table
#: man-pages/man7/signal.7:379 man-pages/man7/signal.7:380
#, no-wrap
msgid "29/-"
msgstr "29/-"

#. type: tbl table
#: man-pages/man7/signal.7:381
#, no-wrap
msgid "-/29"
msgstr "-/29"

#. type: Plain text
#: man-pages/man7/signal.7:387
msgid "Note the following:"
msgstr "Также заметим следующее:"

#. type: Plain text
#: man-pages/man7/signal.7:395
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS>.  Since glibc 2.26, "
"B<SIGUNUSED> is no longer defined on any architecture."
msgstr ""
"Если определён сигнал B<SIGUNUSED>, то он является синонимом B<SIGSYS>. "
"Начиная с glibc 2.26, определение B<SIGUNUSED> удалено из всех архитектур."

#. type: Plain text
#: man-pages/man7/signal.7:402
msgid ""
"Signal 29 is B<SIGINFO>/B<SIGPWR> (synonyms for the same value) on Alpha but "
"B<SIGLOST> on SPARC."
msgstr ""
"Сигнал с номером 29 на Alpha соответствует B<SIGINFO>/B<SIGPWR> (одинаковый "
"номер), а на SPARC соответствует B<SIGLOST>."

#. type: SS
#: man-pages/man7/signal.7:402
#, no-wrap
msgid "Real-time signals"
msgstr "Сигналы реального времени"

#. type: Plain text
#: man-pages/man7/signal.7:413
msgid ""
"Starting with version 2.2, Linux supports real-time signals as originally "
"defined in the POSIX.1b real-time extensions (and now included in "
"POSIX.1-2001).  The range of supported real-time signals is defined by the "
"macros B<SIGRTMIN> and B<SIGRTMAX>.  POSIX.1-2001 requires that an "
"implementation support at least B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""
"Начиная с версии 2.2, Linux поддерживает сигналы реального времени согласно "
"первоначальному описанию расширений реального времени в POSIX.1b (теперь "
"включено в POSIX.1-2001). Диапазон поддерживаемых сигналов реального времени "
"определяется макросами B<SIGRTMIN> и B<SIGRTMAX>. Согласно POSIX.1-2001 "
"требуется, чтобы реализация поддерживала не менее B<_POSIX_RTSIG_MAX> (8) "
"сигналов реального времени."

#. type: Plain text
#: man-pages/man7/signal.7:435
msgid ""
"The Linux kernel supports a range of 33 different real-time signals, "
"numbered 32 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""
"Ядро Linux поддерживает 33 таких сигнала, начиная с номера 32 до номера 64. "
"Однако внутри реализации нитей POSIX в glibc используется два (для NPTL) или "
"три (для LinuxThreads) сигнала реального времени (смотрите B<pthreads>(7)), "
"а значение B<SIGRTMIN> корректируется должным образом (до 34 или 35). Так "
"как диапазон доступных сигналов реального времени различается в зависимости "
"от реализации нитей в glibc (и это может происходить во время выполнения при "
"смене ядра и glibc), и, более того, диапазон сигналов реального времени "
"различен в разных системах UNIX, то программы I<никогда не должны задавать "
"сигналы реального времени по номерам>, а вместо этого всегда должны "
"записывать их в виде B<SIGRTMIN>+n и выполнять проверку (во время "
"выполнения), что B<SIGRTMIN>+n не превышает B<SIGRTMAX>."

#. type: Plain text
#: man-pages/man7/signal.7:439
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined purposes."
msgstr ""
"В отличие от стандартных сигналов, сигналы реального времени не имеют "
"предопределенного назначения: весь набор сигналов реального времени "
"приложения могут использовать так, как им нужно."

#. type: Plain text
#: man-pages/man7/signal.7:442
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""
"Действием по умолчанию для необработанных сигналов реального времени "
"является завершение процесса (terminate)."

#. type: Plain text
#: man-pages/man7/signal.7:444
msgid "Real-time signals are distinguished by the following:"
msgstr "Сигналы реального времени отличаются от обычных в следующем:"

#. type: Plain text
#: man-pages/man7/signal.7:448
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""
"В очередь можно добавлять несколько экземпляров одного сигнала реального "
"времени. В случае со стандартными сигналами, если доставляется несколько "
"экземпляров сигнала, в то время как этот тип сигнала в данный момент "
"заблокирован, то только один экземпляр будет добавлен в очередь."

#. type: Plain text
#: man-pages/man7/signal.7:468
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2), then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""
"Если сигнал отправляется с помощью B<sigqueue>(3), то с сигналом может быть "
"отправлено некоторое значение (целочисленное, либо указатель). Если "
"принимающий процесс устанавливает обработчик для сигнала, используя флаг "
"B<SA_SIGINFO> и вызов B<sigaction>(2), то он может получить это значение "
"через поле I<si_value> структуры I<siginfo_t>, переданной обработчику в виде "
"второго аргумента. Кроме этого, поля I<si_pid> и I<si_uid> данной структуры "
"можно использовать для получения идентификатора процесса и реального "
"идентификатора пользователя, отправившего сигнал."

#. type: Plain text
#: man-pages/man7/signal.7:477
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""
"Сигналы реального времени доставляются точно в порядке поступления. "
"Несколько сигналов одного типа доставляются в порядке, определяемых их "
"отправлением. Если процессу отправлено несколько разных сигналов реального "
"времени, то порядок их доставки начинается с сигнала с наименьшим номером "
"(то есть сигналы с наименьшим номером имеют наивысший приоритет). Порядок же "
"для стандартных сигналов в такой ситуации не определён."

#. type: Plain text
#: man-pages/man7/signal.7:482
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""
"Если процессу передан и стандартный сигнал, и сигнал реального времени, то в "
"POSIX однозначно не определено, какой из них будет доставлен первым. В "
"Linux, как и во многих других реализациях в таких случаях, отдан приоритет "
"стандартным сигналам."

#. type: Plain text
#: man-pages/man7/signal.7:505
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, I</proc/"
"sys/kernel/rtsig-nr>, can be used to find out how many real-time signals are "
"currently queued.  In Linux 2.6.8, these I</proc> interfaces were replaced "
"by the B<RLIMIT_SIGPENDING> resource limit, which specifies a per-user limit "
"for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""
"В соответствии с POSIX, реализация должна позволять ставить в очередь "
"процесса, как минимум, B<_POSIX_SIGQUEUE_MAX> (32) сигнала реального "
"времени. Однако в Linux это делается по-другому. В ядрах до версии 2.6.7 "
"включительно, Linux накладывает общесистемный лимит на количество сигналов "
"режима реального времени в очереди для всех процессов. Этот лимит может быть "
"получен и изменён (если есть права) через файл I</proc/sys/kernel/rtsig-"
"max>. Текущее количество сигналов режима реального времени в очереди можно "
"получить из файла I</proc/sys/kernel/rtsig-nr>. В Linux 2.6.8 данные "
"интерфейсы I</proc> были заменены на ограничение ресурса "
"B<RLIMIT_SIGPENDING>, которое устанавливает ограничение на очередь сигналов "
"на каждого пользователя отдельно; дополнительную информацию можно найти в "
"B<setrlimit>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:513
msgid ""
"The addition of real-time signals required the widening of the signal set "
"structure (I<sigset_t>)  from 32 to 64 bits.  Consequently, various system "
"calls were superseded by new system calls that supported the larger signal "
"sets.  The old and new system calls are as follows:"
msgstr ""
"Для дополнительных сигналов реального времени требуется расширение структуры "
"набора сигналов (I<sigset_t>) с 32 до 64 бит. В связи с этим, различные "
"системные вызовы заменены на новые системные вызов, поддерживающие набор "
"сигналов большего размера. Вот соответствие старых и новых системных вызовов:"

#. type: tbl table
#: man-pages/man7/signal.7:516
#, no-wrap
msgid "Linux 2.0 and earlier"
msgstr "Linux версии 2.0 и более ранние"

#. type: tbl table
#: man-pages/man7/signal.7:516
#, no-wrap
msgid "Linux 2.2 and later"
msgstr "Linux версии 2.2 и новее"

#. type: tbl table
#: man-pages/man7/signal.7:517
#, no-wrap
msgid "B<sigaction>(2)"
msgstr "B<sigaction>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:517
#, no-wrap
msgid "B<rt_sigaction>(2)"
msgstr "B<rt_sigaction>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:518
#, no-wrap
msgid "B<sigpending>(2)"
msgstr "B<sigpending>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:518
#, no-wrap
msgid "B<rt_sigpending>(2)"
msgstr "B<rt_sigpending>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:519
#, no-wrap
msgid "B<sigprocmask>(2)"
msgstr "B<sigprocmask>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:519
#, no-wrap
msgid "B<rt_sigprocmask>(2)"
msgstr "B<rt_sigprocmask>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:520
#, no-wrap
msgid "B<sigreturn>(2)"
msgstr "B<sigreturn>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:520
#, no-wrap
msgid "B<rt_sigreturn>(2)"
msgstr "B<rt_sigreturn>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:521
#, no-wrap
msgid "B<rt_sigsuspend>(2)"
msgstr "B<rt_sigsuspend>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:522
#, no-wrap
msgid "B<sigtimedwait>(2)"
msgstr "B<sigtimedwait>(2)"

#. type: tbl table
#: man-pages/man7/signal.7:522
#, no-wrap
msgid "B<rt_sigtimedwait>(2)"
msgstr "B<rt_sigtimedwait>(2)"

#. type: SS
#: man-pages/man7/signal.7:525
#, no-wrap
msgid "Interruption of system calls and library functions by signal handlers"
msgstr "Прерывание системных вызовов и библиотечных функций обработчиками сигналов"

#. type: Plain text
#: man-pages/man7/signal.7:528
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""
"Если обработчик сигнала вызван во время заблокированного системного вызова "
"или библиотечной функции, то может произойти следующее:"

#. type: Plain text
#: man-pages/man7/signal.7:530
msgid ""
"the call is automatically restarted after the signal handler returns; or"
msgstr ""
"вызов автоматически перезапускается после возврата из обработчика сигнала; "
"или"

#. type: Plain text
#: man-pages/man7/signal.7:533
msgid "the call fails with the error B<EINTR>."
msgstr "вызов завершается с ошибкой B<EINTR>."

#. type: Plain text
#: man-pages/man7/signal.7:541
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""
"Выбираемое поведение зависит от интерфейса и от того, был ли обработчик "
"сигнала установлен с флагом B<SA_RESTART> (смотрите B<sigaction>(2)). Но в "
"различных системах UNIX есть другие различия; далее описаны подробности для "
"Linux."

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
#: man-pages/man7/signal.7:550
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call is automatically restarted after the signal "
"handler returns if the B<SA_RESTART> flag was used; otherwise the call fails "
"with the error B<EINTR>:"
msgstr ""
"Если заблокированный вызов к одному из следующих интерфейсов прерван "
"обработчиком сигнала, то вызов автоматически перезапускается после "
"завершения обработчика сигнала, если задействован флаг B<SA_RESTART>; иначе "
"вызов завершается ошибкой B<EINTR>:"

#. type: Plain text
#: man-pages/man7/signal.7:566
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  If an I/O "
"call on a slow device has already transferred some data by the time it is "
"interrupted by a signal handler, then the call will return a success status "
"(normally, the number of bytes transferred).  Note that a (local) disk is "
"not a slow device according to this definition; I/O operations on disk "
"devices are not interrupted by signals."
msgstr ""
"Вызовы B<read>(2), B<readv>(2), B<write>(2), B<writev>(2) и B<ioctl>(2) для "
"«медленных» устройств. «Медленным» называют устройство, которое может "
"навсегда заблокировать ввод-вывод, например, терминал, канал или сокет. Если "
"вызов ввода-вывода для медленного устройства уже передал немного данных на "
"момент прерывания обработчиком сигнала, то вызов вернёт состояние успешного "
"выполнения (обычно, количество переданных байт). Заметим, что диск "
"(локальный) не подходит под определение медленного устройства; операции "
"ввода-вывода с дисками не прерываются сигналами."

#. type: Plain text
#: man-pages/man7/signal.7:570
msgid ""
"B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""
"Вызов B<open>(2), если он может выполнить блокировку (например, при открытии "
"FIFO; смотрите B<fifo>(7))."

#. type: Plain text
#: man-pages/man7/signal.7:577
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr ""
"Вызовы B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2) и B<waitpid>(2)."

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#.  FIXME What about sendmmsg()?
#. type: Plain text
#: man-pages/man7/signal.7:595
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), "
"unless a timeout has been set on the socket (see below)."
msgstr ""
"Интерфейсы сокетов: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2) и B<sendmsg>(2), "
"если для сокета не указано время ожидания (смотрите далее)."

#. type: Plain text
#: man-pages/man7/signal.7:605
msgid ""
"File locking interfaces: B<flock>(2)  and the B<F_SETLKW> and "
"B<F_OFD_SETLKW> operations of B<fcntl>(2)"
msgstr ""
"Интерфейсы файловой блокировки: B<flock>(2) и операции B<F_SETLKW> и "
"B<F_OFD_SETLKW> у B<fcntl>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:612
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""
"Интерфейсы очереди сообщений POSIX: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3) и B<mq_timedsend>(3)."

#.  commit 72c1bbf308c75a136803d2d76d0e18258be14c7a
#. type: Plain text
#: man-pages/man7/signal.7:619
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""
"Вызов B<futex>(2) с B<FUTEX_WAIT> (начиная с Linux 2.6.22; до этой версии "
"вызов завершался с ошибкой B<EINTR>)."

#. type: Plain text
#: man-pages/man7/signal.7:621
msgid "B<getrandom>(2)."
msgstr "B<getrandom>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:625
msgid "B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3), and related APIs."
msgstr ""
"B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3) связанный с этим "
"программный интерфейс."

#. type: Plain text
#: man-pages/man7/signal.7:628
msgid "B<futex>(2)  B<FUTEX_WAIT_BITSET>."
msgstr "B<futex>(2)  B<FUTEX_WAIT_BITSET>."

#.  as a consequence of the 2.6.22 changes in the futex() implementation
#. type: Plain text
#: man-pages/man7/signal.7:637
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""
"Интерфейсы семафоров POSIX: B<sem_wait>(3) и B<sem_timedwait>(3) (начиная с "
"Linux 2.6.22; до этой версии вызовы завершались с ошибкой B<EINTR>)."

#.  commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
#. type: Plain text
#: man-pages/man7/signal.7:646
msgid ""
"B<read>(2)  from an B<inotify>(7)  file descriptor (since Linux 3.8; "
"beforehand, always failed with B<EINTR>)."
msgstr ""
"Вызов B<read>(2) из файлового дескриптора B<inotify>(7) (начиная с Linux "
"3.8; прежде всегда завершался с ошибкой B<EINTR>)."

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
#: man-pages/man7/signal.7:656
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""
"Следующие интерфейсы никогда не перезапускаются после прерывания "
"обработчиком сигнала независимо от наличия B<SA_RESTART>; они всегда "
"завершаются с ошибкой B<EINTR>, если прерываются обработчиком сигнала:"

#. type: Plain text
#: man-pages/man7/signal.7:670 man-pages/man7/signal.7:743
msgid ""
"\"Input\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<accept>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2)  (also with a non-NULL I<timeout> argument), "
"and B<recvmsg>(2)."
msgstr ""
"«Входные» интерфейсы сокетов, если установлен таймаут (B<SO_RCVTIMEO>) на "
"сокете с помощью B<setsockopt>(2): B<accept>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2) (также с аргументом I<timeout>, не равным NULL) и "
"B<recvmsg>(2)."

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: man-pages/man7/signal.7:681
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2)."
msgstr ""
"«Выходные» интерфейсы сокетов, если установлен таймаут (B<SO_RCVTIMEO>) на "
"сокете с помощью B<setsockopt>(2): B<connect>(2), B<send>(2), B<sendto>(2) и "
"B<sendmsg>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:688
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""
"Интерфейсы, используемые для ожидания сигналов: B<pause>(2), "
"B<sigsuspend>(2), B<sigtimedwait>(2) и B<sigwaitinfo>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:697
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"Интерфейсы комбинирования (multiplexing) файловых дескрипторов: "
"B<epoll_wait>(2), B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2) и "
"B<pselect>(2)."

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
#: man-pages/man7/signal.7:705
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""
"IPC-интерфейсы System V: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2) и "
"B<semtimedop>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:711
msgid ""
"Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr "Интерфейсы сна: B<clock_nanosleep>(2), B<nanosleep>(2) и B<usleep>(3)."

#. type: Plain text
#: man-pages/man7/signal.7:713
msgid "B<io_getevents>(2)."
msgstr "B<io_getevents>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:718
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""
"Функция B<sleep>(3) также никогда не перезапускается, если прервана "
"обработчиком сигнала, но сообщает об успешном выполнении: возвращает "
"количество оставшиеся для сна секунд."

#. type: SS
#: man-pages/man7/signal.7:718
#, no-wrap
msgid "Interruption of system calls and library functions by stop signals"
msgstr "Прерывание системных вызовов и библиотечных функций сигналами останова"

#. type: Plain text
#: man-pages/man7/signal.7:727
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""
"В Linux, даже в отсутствии обработчиков сигнала, некоторые блокирующие "
"интерфейсы могут завершаться с ошибкой B<EINTR>, если процесс "
"останавливается одним из сигналов останова и затем возобновляет работу при "
"получении сигнала B<SIGCONT>. Такое поведение не предусмотрено POSIX.1 и в "
"других системах отсутствует."

#. type: Plain text
#: man-pages/man7/signal.7:729
msgid "The Linux interfaces that display this behavior are:"
msgstr "Интерфейсы Linux, к которым это относится:"

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: man-pages/man7/signal.7:757
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2), if a send timeout (B<SO_SNDTIMEO>)  has "
"been set."
msgstr ""
"«Выходные» интерфейсы сокетов, если установлен таймаут (B<SO_RCVTIMEO>) на "
"сокете с помощью B<setsockopt>(2): B<connect>(2), B<send>(2), B<sendto>(2) и "
"B<sendmsg>(2), если установлен таймаут отправления (B<SO_SNDTIMEO>)."

#. type: Plain text
#: man-pages/man7/signal.7:760
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr "B<epoll_wait>(2), B<epoll_pwait>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:763
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr "B<semop>(2), B<semtimedop>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:766
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr "B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#.  commit 1ca39ab9d21ac93f94b9e3eb364ea9a5cf2aba06
#. type: Plain text
#: man-pages/man7/signal.7:773
msgid ""
"Linux 3.7 and earlier: B<read>(2)  from an B<inotify>(7)  file descriptor"
msgstr "Linux 3.7 и старее: B<read>(2) из файлового дескриптора B<inotify>(7)"

#. type: Plain text
#: man-pages/man7/signal.7:779
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""
"Linux версии 2.6.21 и более ранних: B<futex>(2) с B<FUTEX_WAIT>, "
"B<sem_timedwait>(3), B<sem_wait>(3)."

#. type: Plain text
#: man-pages/man7/signal.7:783
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr "Linux версии 2.6.8 и более ранних: B<msgrcv>(2), B<msgsnd>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:786
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr "Linux версии 2.4 и более ранних: B<nanosleep>(2)."

#.  It must be a *very* long time since this was true:
#.  .SH BUGS
#.  .B SIGIO
#.  and
#.  .B SIGLOST
#.  have the same value.
#.  The latter is commented out in the kernel source, but
#.  the build process of some software still thinks that
#.  signal 29 is
#.  .BR SIGLOST .
#. type: Plain text
#: man-pages/man7/signal.7:798
msgid "POSIX.1, except as noted."
msgstr "POSIX.1, кроме описанных исключений."

#. type: Plain text
#: man-pages/man7/signal.7:801
msgid ""
"For a discussion of async-signal-safe functions, see B<signal-safety>(7)."
msgstr ""
"Описание безопасных асинхронных функций при работе с сигналами смотрите в "
"B<signal-safety>(7)."

#. type: Plain text
#: man-pages/man7/signal.7:824
msgid ""
"The I</proc/[pid]/task/[tid]/status> file contains various fields that show "
"the signals that a thread is blocking (I<SigBlk>), catching (I<SigCgt>), or "
"ignoring (I<SigIgn>).  (The set of signals that are caught or ignored will "
"be the same across all threads in a process.)  Other fields show the set of "
"pending signals that are directed to the thread (I<SigPnd>)  as well as the "
"set of pending signals that are directed to the process as a whole "
"(I<ShdPnd>).  The corresponding fields in I</proc/[pid]/status> show the "
"information for the main thread.  See B<proc>(5)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:860
msgid ""
"B<kill>(1), B<clone>(2), B<getrlimit>(2), B<kill>(2), B<restart_syscall>(2), "
"B<rt_sigqueueinfo>(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), "
"B<sigaction>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), "
"B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), B<killpg>(3), "
"B<longjmp>(3), B<pthread_sigqueue>(3), B<raise>(3), B<sigqueue>(3), "
"B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), "
"B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), B<pthreads>(7), "
"B<sigevent>(7)"
msgstr ""
"B<kill>(1), B<clone>(2), B<getrlimit>(2), B<kill>(2), B<restart_syscall>(2), "
"B<rt_sigqueueinfo>(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), "
"B<sigaction>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), "
"B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), B<killpg>(3), "
"B<longjmp>(3), B<pthread_sigqueue>(3), B<raise>(3), B<sigqueue>(3), "
"B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), "
"B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), B<pthreads>(7), "
"B<sigevent>(7)"

#. type: TH
#: man-pages/man7/sysvipc.7:40
#, no-wrap
msgid "SVIPC"
msgstr "SVIPC"

#. type: TH
#: man-pages/man7/sysvipc.7:40
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: man-pages/man7/sysvipc.7:43
msgid "sysvipc - System V interprocess communication mechanisms"
msgstr ""

#. type: Plain text
#: man-pages/man7/sysvipc.7:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/msg.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/msg.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/sysvipc.7:56
msgid ""
"This manual page refers to the Linux implementation of the System V "
"interprocess communication (IPC) mechanisms: message queues, semaphore sets, "
"and shared memory segments.  In the following, the word I<resource> means an "
"instantiation of one among such mechanisms."
msgstr ""
"Данная справочная страница описывает реализацию механизмов межпроцессного "
"взаимодействия (IPC) System V в Linux: очереди сообщений, наборы семафоров и "
"сегменты разделяемой памяти.  В дальнейшем под словом  I<ресурс> будет "
"подразумеваться экземпляр одного из этих механизмов."

#. type: SS
#: man-pages/man7/sysvipc.7:56
#, no-wrap
msgid "Resource access permissions"
msgstr "Права доступа к ресурсу"

#. type: Plain text
#: man-pages/man7/sysvipc.7:64
msgid ""
"For each resource, the system uses a common structure of type I<struct "
"ipc_perm> to store information needed in determining permissions to perform "
"an IPC operation.  The I<ipc_perm> structure includes the following members:"
msgstr ""
"Для каждого ресурса система использует общую структуру типа I<struct "
"ipc_perm>, хранящую необходимую информацию о правах для проведения IPC-"
"операции. Структура I<ipc_perm> включает следующие поля:"

#. type: Plain text
#: man-pages/man7/sysvipc.7:74
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    uid_t          cuid;   /* creator user ID */\n"
"    gid_t          cgid;   /* creator group ID */\n"
"    uid_t          uid;    /* owner user ID */\n"
"    gid_t          gid;    /* owner group ID */\n"
"    unsigned short mode;   /* r/w permissions */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    uid_t          cuid;   /* ID пользователя создателя */\n"
"    gid_t          cgid;   /* ID группы создателя */\n"
"    uid_t          uid;    /* ID пользователя владельца */\n"
"    gid_t          gid;    /* ID группы владельца */\n"
"    unsigned short mode;   /* права для чтения-записи */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sysvipc.7:84
msgid ""
"The I<mode> member of the I<ipc_perm> structure defines, with its lower 9 "
"bits, the access permissions to the resource for a process executing an IPC "
"system call.  The permissions are interpreted as follows:"
msgstr ""
"Поле I<mode> из структуры I<ipc_perm> определяет в нижних 9 битах права "
"доступа к ресурсу для вызвавшего системный вызов IPC процесса. Права "
"определены следующим образом:"

#. type: Plain text
#: man-pages/man7/sysvipc.7:92
#, no-wrap
msgid ""
"    0400    Read by user.\n"
"    0200    Write by user.\n"
"    0040    Read by group.\n"
"    0020    Write by group.\n"
"    0004    Read by others.\n"
"    0002    Write by others.\n"
msgstr ""
"    0400    Чтение пользователем\n"
"    0200    Запись пользователем\n"
"    0040    Чтение группой\n"
"    0020    Запись группой\n"
"    0004    Чтение остальными\n"
"    0002    Запись остальными\n"

#. type: Plain text
#: man-pages/man7/sysvipc.7:100
msgid ""
"Bits 0100, 0010, and 0001 (the execute bits) are unused by the system.  "
"Furthermore, \"write\" effectively means \"alter\" for a semaphore set."
msgstr ""
"Биты 0100, 0010 и 0001 (биты запуска) системой не используется. Кроме того, "
"«запись» для набора семафоров на самом деле означает «изменение»."

#. type: Plain text
#: man-pages/man7/sysvipc.7:103
msgid ""
"The same system header file also defines the following symbolic constants:"
msgstr ""
"Тот же системный заголовочный файл определяет следующие символические "
"константы:"

#. type: TP
#: man-pages/man7/sysvipc.7:103
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr "B<IPC_CREAT>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:106
msgid "Create entry if key doesn't exist."
msgstr "Создать запись, если ключ не существует."

#. type: TP
#: man-pages/man7/sysvipc.7:106
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr "B<IPC_EXCL>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:109
msgid "Fail if key exists."
msgstr "Завершиться ошибкой, если ключ существует."

#. type: TP
#: man-pages/man7/sysvipc.7:109
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr "B<IPC_NOWAIT>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:112
msgid "Error if request must wait."
msgstr "Ошибка, если запрос должен ждать."

#. type: TP
#: man-pages/man7/sysvipc.7:112
#, no-wrap
msgid "B<IPC_PRIVATE>"
msgstr "B<IPC_PRIVATE>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:115
msgid "Private key."
msgstr "Частный ключ."

#. type: TP
#: man-pages/man7/sysvipc.7:115
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:118
msgid "Remove resource."
msgstr "Удалить ресурс."

#. type: TP
#: man-pages/man7/sysvipc.7:118
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:121
msgid "Set resource options."
msgstr "Установить параметры ресурса."

#. type: TP
#: man-pages/man7/sysvipc.7:121
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:124
msgid "Get resource options."
msgstr "Получить параметры ресурса."

#. type: Plain text
#: man-pages/man7/sysvipc.7:133
msgid ""
"Note that B<IPC_PRIVATE> is a I<key_t> type, while all the other symbolic "
"constants are flag fields and can be OR'ed into an I<int> type variable."
msgstr ""
"Заметьте, что B<IPC_PRIVATE> является типом I<key_t>, когда как остальные "
"символические константы являются флагами и могут быть объединены с помощью "
"логического ИЛИ в переменную типа I<int>."

#. type: SS
#: man-pages/man7/sysvipc.7:133
#, no-wrap
msgid "Message queues"
msgstr "Очереди сообщений"

#. type: Plain text
#: man-pages/man7/sysvipc.7:141
msgid ""
"A message queue is uniquely identified by a positive integer (its I<msqid>)  "
"and has an associated data structure of type I<struct msqid_ds>, defined in "
"I<E<lt>sys/msg.hE<gt>>, containing the following members:"
msgstr ""
"Очередь сообщений уникально идентифицируется положительным целым (I<msqid>) "
"и имеет связанную структуру данных I<struct msqid_ds>, определенную в "
"I<E<lt>sys/msg.hE<gt>> и содержащую следующие поля:"

#. type: Plain text
#: man-pages/man7/sysvipc.7:154
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;\n"
"    msgqnum_t       msg_qnum;    /* no of messages on queue */\n"
"    msglen_t        msg_qbytes;  /* bytes max on a queue */\n"
"    pid_t           msg_lspid;   /* PID of last msgsnd(2) call */\n"
"    pid_t           msg_lrpid;   /* PID of last msgrcv(2) call */\n"
"    time_t          msg_stime;   /* last msgsnd(2) time */\n"
"    time_t          msg_rtime;   /* last msgrcv(2) time */\n"
"    time_t          msg_ctime;   /* last change time */\n"
"};\n"
msgstr ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;\n"
"    msgqnum_t       msg_qnum;    /* в очереди не сообщений */\n"
"    msglen_t        msg_qbytes;  /* макс. байт в очереди */\n"
"    pid_t           msg_lspid;   /* PID последнего вызова  msgsnd(2) */\n"
"    pid_t           msg_lrpid;   /* PID последнего вызова msgrcv(2) */\n"
"    time_t          msg_stime;   /* время последнего msgsnd(2) */\n"
"    time_t          msg_rtime;   /* время последнего  msgrcv(2) */\n"
"    time_t          msg_ctime;   /* последнее время изменения */\n"
"};\n"

#. type: TP
#: man-pages/man7/sysvipc.7:156
#, no-wrap
msgid "I<msg_perm>"
msgstr "I<msg_perm>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:161
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the message "
"queue."
msgstr "Структура I<ipc_perm>, определяющая права доступа к очереди сообщений."

#. type: TP
#: man-pages/man7/sysvipc.7:161
#, no-wrap
msgid "I<msg_qnum>"
msgstr "I<msg_qnum>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:164
msgid "Number of messages currently on the message queue."
msgstr "Число сообщений, находящихся в данный момент в очереди сообщений."

#. type: TP
#: man-pages/man7/sysvipc.7:164
#, no-wrap
msgid "I<msg_qbytes>"
msgstr "I<msg_qbytes>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:168
msgid "Maximum number of bytes of message text allowed on the message queue."
msgstr ""
"Максимальная длина сообщения в байтах, разрешенная в очереди сообщений."

#. type: TP
#: man-pages/man7/sysvipc.7:168
#, no-wrap
msgid "I<msg_lspid>"
msgstr "I<msg_lspid>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:173
msgid "ID of the process that performed the last B<msgsnd>(2)  system call."
msgstr "ID процесса, выполнившего последний системный вызов B<msgsnd>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:173
#, no-wrap
msgid "I<msg_lrpid>"
msgstr "I<msg_lrpid>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:178
msgid "ID of the process that performed the last B<msgrcv>(2)  system call."
msgstr "ID процесса, выполнившего последний системный вызов B<msgrcv>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:178
#, no-wrap
msgid "I<msg_stime>"
msgstr "I<msg_stime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:183
msgid "Time of the last B<msgsnd>(2)  system call."
msgstr "Время последнего вызова B<msgsnd>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:183
#, no-wrap
msgid "I<msg_rtime>"
msgstr "I<msg_rtime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:188
msgid "Time of the last B<msgrcv>(2)  system call."
msgstr "Время последнего вызова B<msgrcv>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:188
#, no-wrap
msgid "I<msg_ctime>"
msgstr "I<msg_ctime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:194
msgid ""
"Time of the last system call that changed a member of the I<msqid_ds> "
"structure."
msgstr ""
"Время последнего системного вызова, изменившего поля структуры I<msgid_ds>."

#. type: SS
#: man-pages/man7/sysvipc.7:194
#, no-wrap
msgid "Semaphore sets"
msgstr "Наборы семафоров"

#. type: Plain text
#: man-pages/man7/sysvipc.7:202
msgid ""
"A semaphore set is uniquely identified by a positive integer (its I<semid>)  "
"and has an associated data structure of type I<struct semid_ds>, defined in "
"I<E<lt>sys/sem.hE<gt>>, containing the following members:"
msgstr ""
"Набор семафора уникально идентифицируется положительным целым (I<semid>) и "
"имеет связанную структуру типа I<struct semid_ds>, определенную в I<E<lt>sys/"
"sem.hE<gt>> и содержащую следующие поля:"

#. type: Plain text
#: man-pages/man7/sysvipc.7:211
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;\n"
"    time_t          sem_otime;   /* last operation time */\n"
"    time_t          sem_ctime;   /* last change time */\n"
"    unsigned long   sem_nsems;   /* count of sems in set */\n"
"};\n"
msgstr ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;\n"
"    time_t          sem_otime;   /* время последней операции */\n"
"    time_t          sem_ctime;   /* время последнего изменения */\n"
"    unsigned long   sem_nsems;   /* число семафоров в наборе */\n"
"};\n"

#. type: TP
#: man-pages/man7/sysvipc.7:213
#, no-wrap
msgid "I<sem_perm>"
msgstr "I<sem_perm>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:218
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the semaphore "
"set."
msgstr "Структура I<ipc_perm>, определяющая права доступа к набору семафоров."

#. type: TP
#: man-pages/man7/sysvipc.7:218
#, no-wrap
msgid "I<sem_otime>"
msgstr "I<sem_otime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:223
msgid "Time of last B<semop>(2)  system call."
msgstr "Время последнего системного вызова B<semop>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:223
#, no-wrap
msgid "I<sem_ctime>"
msgstr "I<sem_ctime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:229
msgid ""
"Time of last B<semctl>(2)  system call that changed a member of the above "
"structure or of one semaphore belonging to the set."
msgstr ""
"Время последнего системного вызова B<semctl>(2), который изменил поле "
"указанной структуры или один из семафоров, принадлежащих набору."

#. type: TP
#: man-pages/man7/sysvipc.7:229
#, no-wrap
msgid "I<sem_nsems>"
msgstr "I<sem_nsems>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:237
msgid ""
"Number of semaphores in the set.  Each semaphore of the set is referenced by "
"a nonnegative integer ranging from B<0> to I<sem_nsems-1>."
msgstr ""
"Число семафоров в наборе. Каждый семафор описывается неотрицательным целым "
"числом от  B<0> до I<sem_nsems-1>."

#. type: Plain text
#: man-pages/man7/sysvipc.7:241
msgid ""
"A semaphore is a data structure of type I<struct sem> containing the "
"following members:"
msgstr ""
"Семафор является структурой данных типа I<struct sem>, содержащие следующие "
"поля:"

#.     unsigned short semncnt; /* nr awaiting semval to increase */
#.     unsigned short semzcnt; /* nr awaiting semval = 0 */
#. type: Plain text
#: man-pages/man7/sysvipc.7:250
#, no-wrap
msgid ""
"struct sem {\n"
"    int semval;  /* semaphore value */\n"
"    int sempid;  /* PID of process that last modified */\n"
"};\n"
msgstr ""
"struct sem {\n"
"    int semval;  /* значение семафора */\n"
"    int sempid;  /* PID последнего изменившего процесса */\n"
"};\n"

#. type: TP
#: man-pages/man7/sysvipc.7:252
#, no-wrap
msgid "I<semval>"
msgstr "I<semval>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:255
msgid "Semaphore value: a nonnegative integer."
msgstr "Значение семафора, неотрицательное целое."

#. type: TP
#: man-pages/man7/sysvipc.7:255
#, no-wrap
msgid "I<sempid>"
msgstr "I<sempid>"

#. .TP
#. .I semncnt
#. Number of processes suspended awaiting for
#. .I semval
#. to increase.
#. .TP
#. .I semznt
#. Number of processes suspended awaiting for
#. .I semval
#. to become zero.
#. type: Plain text
#: man-pages/man7/sysvipc.7:269
msgid "PID of the last process that modified the value of this semaphore."
msgstr "PID последнего процесса, изменившего значение данного семафора."

#. type: SS
#: man-pages/man7/sysvipc.7:269
#, no-wrap
msgid "Shared memory segments"
msgstr "Сегменты общей памяти"

#. type: Plain text
#: man-pages/man7/sysvipc.7:277
msgid ""
"A shared memory segment is uniquely identified by a positive integer (its "
"I<shmid>)  and has an associated data structure of type I<struct shmid_ds>, "
"defined in I<E<lt>sys/shm.hE<gt>>, containing the following members:"
msgstr ""
"Сегмент общей памяти уникально идентифицируется положительным целым "
"(I<shmid>) и имеет связанную структуру данных  I<struct shmid_ds>, "
"определённую в I<E<lt>sys/shm.hE<gt>> и содержащую следующие поля:"

#. type: Plain text
#: man-pages/man7/sysvipc.7:290
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;\n"
"    size_t          shm_segsz;   /* size of segment */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID, last operation */\n"
"    shmatt_t        shm_nattch;  /* no. of current attaches */\n"
"    time_t          shm_atime;   /* time of last attach */\n"
"    time_t          shm_dtime;   /* time of last detach */\n"
"    time_t          shm_ctime;   /* time of last change */\n"
"};\n"
msgstr ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;\n"
"    size_t          shm_segsz;   /* размер сегмента */\n"
"    pid_t           shm_cpid;    /* PID создателя */\n"
"    pid_t           shm_lpid;    /* PID последней операции */\n"
"    shmatt_t        shm_nattch;  /* число текущих подключений */\n"
"    time_t          shm_atime;   /* время последнего подключения */\n"
"    time_t          shm_dtime;   /* время последнего отключения */\n"
"    time_t          shm_ctime;   /* время последнего изменения */\n"
"};\n"

#. type: TP
#: man-pages/man7/sysvipc.7:292
#, no-wrap
msgid "I<shm_perm>"
msgstr "I<shm_perm>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:297
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the shared "
"memory segment."
msgstr ""
"Структура I<ipc_perm>, описывающая права доступа к сегменту общей памяти."

#. type: TP
#: man-pages/man7/sysvipc.7:297
#, no-wrap
msgid "I<shm_segsz>"
msgstr "I<shm_segsz>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:300
msgid "Size in bytes of the shared memory segment."
msgstr "Размер в байтах сегмента общей памяти."

#. type: TP
#: man-pages/man7/sysvipc.7:300
#, no-wrap
msgid "I<shm_cpid>"
msgstr "I<shm_cpid>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:303
msgid "ID of the process that created the shared memory segment."
msgstr "ID процесса, создавшего сегмент общей памяти."

#. type: TP
#: man-pages/man7/sysvipc.7:303
#, no-wrap
msgid "I<shm_lpid>"
msgstr "I<shm_lpid>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:310
msgid ""
"ID of the last process that executed a B<shmat>(2)  or B<shmdt>(2)  system "
"call."
msgstr ""
"ID последнего процесса, выполнившего системный вызов B<shmat>(2) или "
"B<shmdt>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:310
#, no-wrap
msgid "I<shm_nattch>"
msgstr "I<shm_nattch>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:313
msgid "Number of current alive attaches for this shared memory segment."
msgstr "Количество текущих подключений для данного сегмента общей памяти."

#. type: TP
#: man-pages/man7/sysvipc.7:313
#, no-wrap
msgid "I<shm_atime>"
msgstr "I<shm_atime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:318
msgid "Time of the last B<shmat>(2)  system call."
msgstr "Время последнего системного вызова B<shmat>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:318
#, no-wrap
msgid "I<shm_dtime>"
msgstr "I<shm_dtime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:323
msgid "Time of the last B<shmdt>(2)  system call."
msgstr "Время последнего системного вызова B<shmdt>(2)."

#. type: TP
#: man-pages/man7/sysvipc.7:323
#, no-wrap
msgid "I<shm_ctime>"
msgstr "I<shm_ctime>"

#. type: Plain text
#: man-pages/man7/sysvipc.7:329
msgid "Time of the last B<shmctl>(2)  system call that changed I<shmid_ds>."
msgstr ""
"Время последнего системного вызова B<shmctl>(2), изменившего I<shmid_ds>."

#. type: SS
#: man-pages/man7/sysvipc.7:329
#, no-wrap
msgid "IPC namespaces"
msgstr "Пространства имён IPC"

#. type: Plain text
#: man-pages/man7/sysvipc.7:333
msgid ""
"For a discussion of the interaction of System V IPC objects and IPC "
"namespaces, see B<namespaces>(7)."
msgstr ""
"Обсуждение связи объектов System V IPC с пространствами IPC смотрите в "
"B<namespaces>(7)."

#. type: Plain text
#: man-pages/man7/sysvipc.7:351
msgid ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<lsipc>(1), B<ipc>(2), B<msgctl>(2), "
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), "
"B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), "
"B<ftok>(3), B<namespaces>(7)"
msgstr ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<lsipc>(1), B<ipc>(2), B<msgctl>(2), "
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), "
"B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), "
"B<ftok>(3), B<namespaces>(7)"

#. type: TH
#: man-pages/man7/sigevent.7:26
#, no-wrap
msgid "SIGEVENT"
msgstr "SIGEVENT"

#. type: TH
#: man-pages/man7/sigevent.7:26
#, no-wrap
msgid "2017-07-13"
msgstr "2017-07-13"

#. type: Plain text
#: man-pages/man7/sigevent.7:29
msgid "sigevent - structure for notification from asynchronous routines"
msgstr "sigevent - структура для уведомления из асинхронных процедур"

#. type: Plain text
#: man-pages/man7/sigevent.7:32
#, no-wrap
msgid "#include E<lt>signal.hE<gt>\n"
msgstr "#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/sigevent.7:37
#, no-wrap
msgid ""
"union sigval {          /* Data passed with notification */\n"
"    int     sival_int;         /* Integer value */\n"
"    void   *sival_ptr;         /* Pointer value */\n"
"};\n"
msgstr ""
"union sigval {          /* Данные, передаваемые с уведомлением */\n"
"    int     sival_int;         /* целое */\n"
"    void   *sival_ptr;         /* указатель */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sigevent.7:52
#, no-wrap
msgid ""
"struct sigevent {\n"
"    int          sigev_notify; /* Notification method */\n"
"    int          sigev_signo;  /* Notification signal */\n"
"    union sigval sigev_value;  /* Data passed with\n"
"                                  notification */\n"
"    void       (*sigev_notify_function) (union sigval);\n"
"                     /* Function used for thread\n"
"                        notification (SIGEV_THREAD) */\n"
"    void        *sigev_notify_attributes;\n"
"                     /* Attributes for notification thread\n"
"                        (SIGEV_THREAD) */\n"
"    pid_t        sigev_notify_thread_id;\n"
"                     /* ID of thread to signal (SIGEV_THREAD_ID) */\n"
"};\n"
msgstr ""
"struct sigevent {\n"
"    int          sigev_notify; /* метод уведомления */\n"
"    int          sigev_signo;  /* сигнал уведомления */\n"
"    union sigval sigev_value;  /* данные, передаваемые\n"
"                                  с уведомлением */\n"
"    void       (*sigev_notify_function) (union sigval);\n"
"                     /* функция, используемая для нити\n"
"                        notification (SIGEV_THREAD) */\n"
"    void        *sigev_notify_attributes;\n"
"                     /* атрибуты для уведомления нити\n"
"                        (SIGEV_THREAD) */\n"
"    pid_t        sigev_notify_thread_id;\n"
"                     /* ID нити для уведомления (SIGEV_THREAD_ID) */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/sigevent.7:61
msgid ""
"The I<sigevent> structure is used by various APIs to describe the way a "
"process is to be notified about an event (e.g., completion of an "
"asynchronous request, expiration of a timer, or the arrival of a message)."
msgstr ""
"Структура I<sigevent> используется в различных программных интерфейсах для "
"описания способа, которым нужно уведомлять процесс о событии (например, "
"окончание асинхронного запроса, истечение таймера или поступление сообщения)."

#. type: Plain text
#: man-pages/man7/sigevent.7:69
msgid ""
"The definition shown in the SYNOPSIS is approximate: some of the fields in "
"the I<sigevent> structure may be defined as part of a union.  Programs "
"should employ only those fields relevant to the value specified in "
"I<sigev_notify>."
msgstr ""
"Определение, приведённое в ОБЗОРЕ, приблизительно: некоторые поля в "
"структуре I<sigevent> могут быть определены как часть объединения. Программы "
"должны использовать только те поля, которые применимы к значению, заданном в "
"I<sigev_notify>."

#. type: Plain text
#: man-pages/man7/sigevent.7:74
msgid ""
"The I<sigev_notify> field specifies how notification is to be performed.  "
"This field can have one of the following values:"
msgstr ""
"В поле I<sigev_notify> задаётся как выполняется уведомление. Значением поля "
"может быть:"

#. type: TP
#: man-pages/man7/sigevent.7:74
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: man-pages/man7/sigevent.7:77
msgid "A \"null\" notification: don't do anything when the event occurs."
msgstr "«Пустое» уведомление: ничего не делать при возникновении события."

#. type: TP
#: man-pages/man7/sigevent.7:77
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#. type: Plain text
#: man-pages/man7/sigevent.7:81
msgid "Notify the process by sending the signal specified in I<sigev_signo>."
msgstr "Уведомить процесс, отправив сигнал, указанный в I<sigev_signo>."

#. type: Plain text
#: man-pages/man7/sigevent.7:88
msgid ""
"If the signal is caught with a signal handler that was registered using the "
"B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are set in "
"the I<siginfo_t> structure that is passed as the second argument of the "
"handler:"
msgstr ""
"Если сигнал пойман обработчиком сигнала, который зарегистрирован с помощью "
"B<sigaction>(2) с флагом B<SA_SIGINFO>, то следующим полям назначаются "
"значения в структуре I<siginfo_t>, передаваемой во втором аргументе "
"обработчика:"

#. type: TP
#: man-pages/man7/sigevent.7:89
#, no-wrap
msgid "I<si_code>"
msgstr "I<si_code>"

#. type: Plain text
#: man-pages/man7/sigevent.7:93
msgid ""
"This field is set to a value that depends on the API delivering the "
"notification."
msgstr ""
"В этом поле задаётся значение, которое зависит от программного интерфейса, "
"доставляющего уведомление."

#. type: TP
#: man-pages/man7/sigevent.7:93
#, no-wrap
msgid "I<si_signo>"
msgstr "I<si_signo>"

#. type: Plain text
#: man-pages/man7/sigevent.7:97
msgid ""
"This field is set to the signal number (i.e., the same value as in "
"I<sigev_signo>)."
msgstr ""
"В этом поле указывается номер сигнала (т. е., тоже значение, что и в "
"I<sigev_signo>)."

#. type: TP
#: man-pages/man7/sigevent.7:97
#, no-wrap
msgid "I<si_value>"
msgstr "I<si_value>"

#. type: Plain text
#: man-pages/man7/sigevent.7:101
msgid "This field is set to the value specified in I<sigev_value>."
msgstr "В этом поле содержится значение, указанное в I<sigev_value>."

#. type: Plain text
#: man-pages/man7/sigevent.7:106
msgid ""
"Depending on the API, other fields may also be set in the I<siginfo_t> "
"structure."
msgstr ""
"В зависимости от программного интерфейса остальным полям в структуре "
"I<siginfo_t> также могут быть присвоены значения."

#. type: Plain text
#: man-pages/man7/sigevent.7:109
msgid ""
"The same information is also available if the signal is accepted using "
"B<sigwaitinfo>(2)."
msgstr ""
"Эта информация также доступна, если сигнал принимается с помощью "
"B<sigwaitinfo>(2)."

#. type: TP
#: man-pages/man7/sigevent.7:109
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: man-pages/man7/sigevent.7:126
msgid ""
"Notify the process by invoking I<sigev_notify_function> \"as if\" it were "
"the start function of a new thread.  (Among the implementation possibilities "
"here are that each timer notification could result in the creation of a new "
"thread, or that a single thread is created to receive all notifications.)  "
"The function is invoked with I<sigev_value> as its sole argument.  If "
"I<sigev_notify_attributes> is not NULL, it should point to a "
"I<pthread_attr_t> structure that defines attributes for the new thread (see "
"B<pthread_attr_init>(3))."
msgstr ""
"Уведомить процесс с помощью вызова I<sigev_notify_function> «как если бы» "
"это была бы начальная функция новой нити (среди возможностей реализации "
"здесь может быть: каждое уведомление таймера приводит к созданию новой нити, "
"или создаётся нить для получения всех уведомлений). Функция вызывается с "
"единственным аргументом I<sigev_value>. Если I<sigev_notify_attributes> не "
"равно NULL, то значение должно указывать на структуру I<pthread_attr_t>, в "
"которой определены атрибуты новой нити (смотрите B<pthread_attr_init>(3))."

#. type: TP
#: man-pages/man7/sigevent.7:126
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr "B<SIGEV_THREAD_ID> (есть только в Linux)"

#.  | SIGEV_SIGNAL vs not?
#. type: Plain text
#: man-pages/man7/sigevent.7:131
msgid "Currently used only by POSIX timers; see B<timer_create>(2)."
msgstr ""
"В настоящее время используется только таймерами POSIX; смотрите "
"B<timer_create>(2)."

#. type: Plain text
#: man-pages/man7/sigevent.7:140
msgid ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"
msgstr ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"

#. type: TH
#: man-pages/man7/standards.7:24
#, no-wrap
msgid "STANDARDS"
msgstr "STANDARDS"

#. type: TH
#: man-pages/man7/standards.7:24
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: man-pages/man7/standards.7:27
msgid "standards - C and UNIX Standards"
msgstr "standards - стандарты Си и UNIX"

#. type: Plain text
#: man-pages/man7/standards.7:31
msgid ""
"The CONFORMING TO section that appears in many manual pages identifies "
"various standards to which the documented interface conforms.  The following "
"list briefly describes these standards."
msgstr ""
"В разделе СООТВЕТСТВИЕ СТАНДАРТАМ, который имеется во многих справочных "
"страницах, перечисляются различные стандарты, которым соответствует "
"описываемый интерфейс. В следующем списке кратко описаны эти стандарты."

#. type: TP
#: man-pages/man7/standards.7:31
#, no-wrap
msgid "B<V7>"
msgstr "B<V7>"

#. type: Plain text
#: man-pages/man7/standards.7:37
msgid ""
"Version 7 (also known as Seventh Edition) UNIX, released by AT&T/Bell Labs "
"in 1979.  After this point, UNIX systems diverged into two main dialects: "
"BSD and System V."
msgstr ""
"Version 7 (также известная как седьмая редакция) UNIX, выпущена AT&T/Bell "
"Labs в 1979 году. После этого системы UNIX разделились на два основных "
"диалекта: BSD и System V."

#. type: TP
#: man-pages/man7/standards.7:37
#, no-wrap
msgid "B<4.2BSD>"
msgstr "B<4.2BSD>"

#. type: Plain text
#: man-pages/man7/standards.7:46
msgid ""
"This is an implementation standard defined by the 4.2 release of the "
"I<Berkeley Software Distribution>, released by the University of California "
"at Berkeley.  This was the first Berkeley release that contained a TCP/IP "
"stack and the sockets API.  4.2BSD was released in 1983."
msgstr ""
"Так называется реализация стандарта, определённого выпуском 4.2 I<Berkeley "
"Software Distribution>, выпущенном Калифорнийским университетом в Беркли. "
"Это первый выпуск Berkeley со стеком TCP/IP и программным интерфейсом "
"сокетов. 4.2BSD выпущена 1983 году."

#. type: Plain text
#: man-pages/man7/standards.7:55
msgid ""
"Earlier major BSD releases included I<3BSD> (1980), I<4BSD> (1980), and "
"I<4.1BSD> (1981)."
msgstr ""
"Предыдущие основные версии BSD: I<3BSD> (1980 год), I<4BSD> (1980 год) и "
"I<4.1BSD> (1981 год)."

#. type: TP
#: man-pages/man7/standards.7:55
#, no-wrap
msgid "B<4.3BSD>"
msgstr "B<4.3BSD>"

#. type: Plain text
#: man-pages/man7/standards.7:58
msgid "The successor to 4.2BSD, released in 1986."
msgstr "Преемник 4.2BSD, выпущен в 1986 году."

#. type: TP
#: man-pages/man7/standards.7:58
#, no-wrap
msgid "B<4.4BSD>"
msgstr "B<4.4BSD>"

#. type: Plain text
#: man-pages/man7/standards.7:62
msgid ""
"The successor to 4.3BSD, released in 1993.  This was the last major Berkeley "
"release."
msgstr ""
"Преемник 4.3BSD, выпущен в 1993 году. Это был последний крупный выпуск от "
"Университета Беркли."

#. type: TP
#: man-pages/man7/standards.7:62
#, no-wrap
msgid "B<System V>"
msgstr "B<System V>"

#. type: Plain text
#: man-pages/man7/standards.7:69
msgid ""
"This is an implementation standard defined by AT&T's milestone 1983 release "
"of its commercial System V (five) release.  The previous major AT&T release "
"was I<System III>, released in 1981."
msgstr ""
"Так называется реализация стандарта, определённого выпуском AT&T в 1983 году "
"своего коммерческого выпуска System V (пять). Предыдущий основной выпуск "
"AT&T называется I<System III> и выпущен в 1981 году."

#. type: TP
#: man-pages/man7/standards.7:69
#, no-wrap
msgid "B<System V release 2 (SVr2)>"
msgstr "B<System V release 2 (SVr2)>"

#. type: Plain text
#: man-pages/man7/standards.7:76
msgid ""
"This was the next System V release, made in 1985.  The SVr2 was formally "
"described in the I<System V Interface Definition version 1> (I<SVID 1>)  "
"published in 1985."
msgstr ""
"Это следующий выпуск System V, выпущенный в 1985 году. SVr2 формально описан "
"в I<System V Interface Definition version 1> (I<SVID 1>), опубликованном в "
"1985 году."

#. type: TP
#: man-pages/man7/standards.7:76
#, no-wrap
msgid "B<System V release 3 (SVr3)>"
msgstr "B<System V release 3 (SVr3)>"

#. type: Plain text
#: man-pages/man7/standards.7:82
msgid ""
"This was the successor to SVr2, released in 1986.  This release was formally "
"described in the I<System V Interface Definition version 2> (I<SVID 2>)."
msgstr ""
"Это следующий выпуск SVr2, выпущен в 1986 году. Данный выпуск формально "
"описан в I<System V Interface Definition version 2> (I<SVID 2>)."

#. type: TP
#: man-pages/man7/standards.7:82
#, no-wrap
msgid "B<System V release 4 (SVr4)>"
msgstr "B<System V release 4 (SVr4)>"

#. type: Plain text
#: man-pages/man7/standards.7:92
msgid ""
"This was the successor to SVr3, released in 1989.  This version of System V "
"is described in the \"Programmer's Reference Manual: Operating System API "
"(Intel processors)\" (Prentice-Hall 1992, ISBN 0-13-951294-2)  This release "
"was formally described in the I<System V Interface Definition version 3> "
"(I<SVID 3>), and is considered the definitive System V release."
msgstr ""
"Это следующий выпуск SVr3, выпущен в 1989 году. Эта версия System V описана "
"в «Programmer's Reference Manual: Operating System API (Intel "
"processors)» (Prentice-Hall 1992, ISBN 0-13-951294-2). Данный выпуск "
"формально описан в I<System V Interface Definition version 3> (I<SVID 3>) и "
"считается определяющим выпуском System V."

#. type: TP
#: man-pages/man7/standards.7:92
#, no-wrap
msgid "B<SVID 4>"
msgstr "B<SVID 4>"

#. type: Plain text
#: man-pages/man7/standards.7:98
msgid ""
"System V Interface Definition version 4, issued in 1995.  Available online "
"at E<.UR http://www.sco.com\\:/developers\\:/devspecs/> E<.UE .>"
msgstr ""
"Определение интерфейса System V, версия 4, выпущено в 1995 году. Доступно по "
"адресу E<.UR http://www.sco.com\\:/developers\\:/devspecs/> E<.UE .>"

#. type: TP
#: man-pages/man7/standards.7:98
#, no-wrap
msgid "B<C89>"
msgstr "B<C89>"

#. type: Plain text
#: man-pages/man7/standards.7:112
msgid ""
"This was the first C language standard, ratified by ANSI (American National "
"Standards Institute) in 1989 (I<X3.159-1989>).  Sometimes this is known as "
"I<ANSI C>, but since C99 is also an ANSI standard, this term is ambiguous.  "
"This standard was also ratified by ISO (International Standards "
"Organization) in 1990 (I<ISO/IEC 9899:1990>), and is thus occasionally "
"referred to as I<ISO C90>."
msgstr ""
"Это первая версия стандарта языка Си, одобрена ANSI (Американский "
"национальный институт стандартов) в 1989 году (I<X3.159-1989>). Иногда её "
"называют I<ANSI C>, но так как C99 также является стандартом ANSI, этот "
"термин противоречив. Данный стандарт также одобрен ISO (Международная "
"организация по стандартизации) в 1990 году (I<ISO/IEC 9899:1990>) и поэтому "
"изредка называется I<ISO C90>."

#. type: TP
#: man-pages/man7/standards.7:112
#, no-wrap
msgid "B<C99>"
msgstr "B<C99>"

#. type: Plain text
#: man-pages/man7/standards.7:119
msgid ""
"This revision of the C language standard was ratified by ISO in 1999 (I<ISO/"
"IEC 9899:1999>).  Available online at E<.UR http://www.open-std.org\\:/"
"jtc1\\:/sc22\\:/wg14\\:/www\\:/standards> E<.UE .>"
msgstr ""
"Данная редакция стандарта языка Си была одобрена ISO в 1999 году (I<ISO/IEC "
"9899:1999>). Доступна по адресу E<.UR http://www.open-std.org\\:/jtc1\\:/"
"sc22\\:/wg14\\:/www\\:/standards> E<.UE .>"

#. type: TP
#: man-pages/man7/standards.7:119
#, no-wrap
msgid "B<C11>"
msgstr "B<C11>"

#. type: Plain text
#: man-pages/man7/standards.7:123
msgid ""
"This revision of the C language standard was ratified by ISO in 2011 (I<ISO/"
"IEC 9899:2011>)."
msgstr ""
"Данная редакция стандарта языка Си была одобрена ISO в 2011 году (I<ISO/IEC "
"9899:2011>)."

#. type: TP
#: man-pages/man7/standards.7:123
#, no-wrap
msgid "B<POSIX.1-1990>"
msgstr "B<POSIX.1-1990>"

#. type: Plain text
#: man-pages/man7/standards.7:129
msgid ""
"\"Portable Operating System Interface for Computing Environments\".  IEEE "
"1003.1-1990 part 1, ratified by ISO in 1990 (I<ISO/IEC 9945-1:1990>).  The "
"term \"POSIX\" was coined by Richard Stallman."
msgstr ""
"«Переносимый интерфейс операционных систем для вычислительных сред». IEEE "
"1003.1-1990 часть 1 одобрена ISO в 1990 году (I<ISO/IEC 9945-1:1990>). "
"Термин «POSIX» был предложен Ричардом Столлманом."

#. type: TP
#: man-pages/man7/standards.7:129
#, no-wrap
msgid "B<POSIX.2>"
msgstr "B<POSIX.2>"

#. type: Plain text
#: man-pages/man7/standards.7:134
msgid ""
"IEEE Std 1003.2-1992, describing commands and utilities, ratified by ISO in "
"1993 (I<ISO/IEC 9945-2:1993>)."
msgstr ""
"IEEE Std 1003.2-1992 описывает команды и утилиты, одобрен ISO в 1993 году "
"(I<ISO/IEC 9945-2:1993>)."

#. type: TP
#: man-pages/man7/standards.7:134
#, no-wrap
msgid "B<POSIX.1b> (formerly known as I<POSIX.4>)"
msgstr "B<POSIX.1b> (ранее известен как I<POSIX.4>)"

#. type: Plain text
#: man-pages/man7/standards.7:140
msgid ""
"IEEE Std 1003.1b-1993, describing real-time facilities for portable "
"operating systems, ratified by ISO in 1996 (I<ISO/IEC 9945-1:1996>)."
msgstr ""
"IEEE Std 1003.1b-1993 описывает средства реального времени в переносимых "
"операционных системах, одобрен ISO в 1996 году (I<ISO/IEC 9945-1:1996>)."

#. type: TP
#: man-pages/man7/standards.7:140
#, no-wrap
msgid "B<POSIX.1c>"
msgstr "B<POSIX.1c>"

#. type: Plain text
#: man-pages/man7/standards.7:143
msgid "IEEE Std 1003.1c-1995, which describes the POSIX threads interfaces."
msgstr "IEEE Std 1003.1c-1995 описывает интерфейс нитей POSIX."

#. type: TP
#: man-pages/man7/standards.7:143
#, no-wrap
msgid "B<POSIX.1d>"
msgstr "B<POSIX.1d>"

#. type: Plain text
#: man-pages/man7/standards.7:146
msgid "IEEE Std 1003.1c-1999, which describes additional real-time extensions."
msgstr ""
"IEEE Std 1003.1c-1999 описывает дополнительные расширения реального времени."

#. type: TP
#: man-pages/man7/standards.7:146
#, no-wrap
msgid "B<POSIX.1g>"
msgstr "B<POSIX.1g>"

#. type: Plain text
#: man-pages/man7/standards.7:149
msgid ""
"IEEE Std 1003.1g-2000, which describes networking APIs (including sockets)."
msgstr ""
"IEEE Std 1003.1g-2000 описывает сетевые программные интерфейсы (включая "
"сокеты)."

#. type: TP
#: man-pages/man7/standards.7:149
#, no-wrap
msgid "B<POSIX.1j>"
msgstr "B<POSIX.1j>"

#. type: Plain text
#: man-pages/man7/standards.7:152
msgid "IEEE Std 1003.1j-2000, which describes advanced real-time extensions."
msgstr "IEEE Std 1003.1j-2000 описывает развитые расширения реального времени."

#. type: TP
#: man-pages/man7/standards.7:152
#, no-wrap
msgid "B<POSIX.1-1996>"
msgstr "B<POSIX.1-1996>"

#. type: Plain text
#: man-pages/man7/standards.7:155
msgid "A 1996 revision of POSIX.1 which incorporated POSIX.1b and POSIX.1c."
msgstr "Ревизия POSIX.1 1996 года с включёнными POSIX.1b и POSIX.1c."

#. type: TP
#: man-pages/man7/standards.7:155
#, no-wrap
msgid "B<XPG3>"
msgstr "B<XPG3>"

#. type: Plain text
#: man-pages/man7/standards.7:162
msgid ""
"Released in 1989, this was the first significant release of the I<X/Open "
"Portability Guide>, produced by the X/Open Company, a multivendor "
"consortium.  This multivolume guide was based on the POSIX standards."
msgstr ""
"Выпущен в 1989 году, первый существенный выпуск I<X/Open Portability Guide>, "
"разработанный X/Open Company — консорциумом производителей. Данное "
"многотомное руководство основано на стандартах POSIX."

#. type: TP
#: man-pages/man7/standards.7:162
#, no-wrap
msgid "B<XPG4>"
msgstr "B<XPG4>"

#. type: Plain text
#: man-pages/man7/standards.7:165
msgid "A revision of the X/Open Portability Guide, released in 1992."
msgstr "Ревизия X/Open Portability Guide, выпущенная в 1992 году."

#. type: TP
#: man-pages/man7/standards.7:165
#, no-wrap
msgid "B<XPG4v2>"
msgstr "B<XPG4v2>"

#. type: Plain text
#: man-pages/man7/standards.7:172
msgid ""
"A 1994 revision of XPG4.  This is also referred to as I<Spec 1170>, where "
"1170 referred to the number of interfaces defined by this standard."
msgstr ""
"Ревизия XPG4, выпущенная в 1994 году. Также называется I<Spec 1170>, где "
"1170 — количество интерфейсов, определённых в этом стандарте."

#. type: TP
#: man-pages/man7/standards.7:172
#, no-wrap
msgid "B<SUS (SUSv1)>"
msgstr "B<SUS (SUSv1)>"

#. type: Plain text
#: man-pages/man7/standards.7:180
msgid ""
"Single UNIX Specification.  This was a repackaging of XPG4v2 and other X/"
"Open standards (X/Open Curses Issue 4 version 2, X/Open Networking Service "
"(XNS) Issue 4).  Systems conforming to this standard can be branded I<UNIX "
"95>."
msgstr ""
"Single UNIX Specification. Перепакованный вариант XPG4v2 и других стандартов "
"X/Open (X/Open Curses Issue 4 version 2, X/Open Networking Service (XNS) "
"Issue 4). Системы, удовлетворяющие этому стандарту, могут маркироваться как "
"I<UNIX 95>."

#. type: TP
#: man-pages/man7/standards.7:180
#, no-wrap
msgid "B<SUSv2>"
msgstr "B<SUSv2>"

#. type: Plain text
#: man-pages/man7/standards.7:191
msgid ""
"Single UNIX Specification version 2.  Sometimes also referred to as "
"I<XPG5>.  This standard appeared in 1997.  Systems conforming to this "
"standard can be branded I<UNIX 98>.  See also E<.UR http://www.UNIX-systems."
"org\\:/version2/> E<.UE .)>"
msgstr ""
"Single UNIX Specification, версия 2. Иногда называется I<XPG5>. Данный "
"стандарт появился в 1997 году. Системы, удовлетворяющие этому стандарту, "
"могут маркироваться как I<UNIX 98>. Смотрите также E<.UR http://www.UNIX-"
"systems.org\\:/version2/> E<.UE .)>"

#. type: TP
#: man-pages/man7/standards.7:191
#, no-wrap
msgid "B<POSIX.1-2001, SUSv3>"
msgstr "B<POSIX.1-2001, SUSv3>"

#. type: Plain text
#: man-pages/man7/standards.7:203
msgid ""
"This was a 2001 revision and consolidation of the POSIX.1, POSIX.2, and SUS "
"standards into a single document, conducted under the auspices of the Austin "
"Group E<.UR http://www.opengroup.org\\:/austin/> E<.UE .> The standard is "
"available online at E<.UR http://www.unix-systems.org\\:/version3/> E<.UE ,> "
"and the interfaces that it describes are also available in the Linux manual "
"pages package under sections 1p and 3p (e.g., \"man 3p open\")."
msgstr ""
"Это выпуск 2001 года и объединение стандартов POSIX.1, POSIX.2 и SUS в один "
"документ, проводимый под покровительством Austin Group E<.UR http://www."
"opengroup.org\\:/austin/> E<.UE .> Стандарт доступен в сети по адресу E<.UR "
"http://www.unix-systems.org\\:/version3/> E<.UE ,>а интерфейсы, которые он "
"описывает, также доступны в пакете справочных страниц Linux в разделах 1p и "
"3p (например, «man 3p open»)."

#. type: Plain text
#: man-pages/man7/standards.7:216
msgid ""
"The standard defines two levels of conformance: I<POSIX conformance>, which "
"is a baseline set of interfaces required of a conforming system; and I<XSI "
"Conformance>, which additionally mandates a set of interfaces (the \"XSI "
"extension\") which are only optional for POSIX conformance.  XSI-conformant "
"systems can be branded I<UNIX 03>.  (XSI conformance constitutes the "
"I<Single UNIX Specification version 3> (I<SUSv3>).)"
msgstr ""
"В стандарте определено два уровня соответствия: I<POSIX conformance> — "
"базовый набор интерфейсов, требуемых в системе для соответствия и I<XSI "
"Conformance> — дополнительный набор интерфейсов («расширение XSI»), которые "
"не являются обязательными для соответствия POSIX. Системы, удовлетворяющие "
"XSI, могут маркироваться как I<UNIX 03>. (соответствием XSI определяется "
"I<Single UNIX Specification version 3> (I<SUSv3>))."

#. type: Plain text
#: man-pages/man7/standards.7:218
msgid "The POSIX.1-2001 document is broken into four parts:"
msgstr "Документ POSIX.1-2001 разделён на четыре части:"

#. type: Plain text
#: man-pages/man7/standards.7:221
msgid "B<XBD>: Definitions, terms and concepts, header file specifications."
msgstr ""
"B<XBD>: Определения, обозначения и положения, описание заголовочных файлов."

#. type: Plain text
#: man-pages/man7/standards.7:225
msgid ""
"B<XSH>: Specifications of functions (i.e., system calls and library "
"functions in actual implementations)."
msgstr ""
"B<XSH>: Описание функций (т. е., реальные реализации системных вызовов и "
"библиотечных функций)."

#. type: Plain text
#: man-pages/man7/standards.7:229
msgid ""
"B<XCU>: Specifications of commands and utilities (i.e., the area formerly "
"described by POSIX.2)."
msgstr ""
"B<XCU>: Описания команд и утилит (т. е., то, что описывалось ранее в "
"POSIX.2)."

#. type: Plain text
#: man-pages/man7/standards.7:232
msgid "B<XRAT>: Informative text on the other parts of the standard."
msgstr "B<XRAT>: Справочные данные на другие части стандарта."

#. type: Plain text
#: man-pages/man7/standards.7:236
msgid ""
"POSIX.1-2001 is aligned with C99, so that all of the library functions "
"standardized in C99 are also standardized in POSIX.1-2001."
msgstr ""
"POSIX.1-2001 выверен с C99, поэтому все библиотечные функции, "
"стандартизованные в C99, также стандартизованы в POSIX.1-2001."

#. type: Plain text
#: man-pages/man7/standards.7:243
msgid ""
"Two Technical Corrigenda (minor fixes and improvements)  of the original "
"2001 standard have occurred: TC1 in 2003 (also known as I<POSIX.1-2003>), "
"and TC2 in 2004 (also known as I<POSIX.1-2004>)."
msgstr ""
"Было проведено две технические поправки (небольшие исправления и улучшения) "
"оригинального стандарта 2001 года: TC1 в 2003 году (известна как "
"I<POSIX.1-2003>) и TC2 в 2004 году (известна как I<POSIX.1-2004>)."

#. type: TP
#: man-pages/man7/standards.7:243
#, no-wrap
msgid "B<POSIX.1-2008, SUSv4>"
msgstr "B<POSIX.1-2008, SUSv4>"

#. type: Plain text
#: man-pages/man7/standards.7:247
msgid ""
"Work on the next revision of POSIX.1/SUS was completed and ratified in 2008."
msgstr "Следующий выпуск POSIX.1/SUS, утверждён в 2008 году."

#. type: Plain text
#: man-pages/man7/standards.7:256
msgid ""
"The changes in this revision are not as large as those that occurred for "
"POSIX.1-2001/SUSv3, but a number of new interfaces are added and various "
"details of existing specifications are modified.  Many of the interfaces "
"that were optional in POSIX.1-2001 become mandatory in the 2008 revision of "
"the standard.  A few interfaces that are present in POSIX.1-2001 are marked "
"as obsolete in POSIX.1-2008, or removed from the standard altogether."
msgstr ""
"Изменения в этом выпуске не столь велики как в POSIX.1-2001/SUSv3, но "
"добавлено несколько новых интерфейсов и внесены изменения в описание "
"существующих. Многие необязательные в POSIX.1-2001 интерфейсы стали "
"обязательными в выпуске стандарта 2008 года. Некоторые интерфейсы из "
"POSIX.1-2001 помечены как устаревшие в POSIX.1-2008, или удалены вообще."

#. type: Plain text
#: man-pages/man7/standards.7:264
msgid ""
"The revised standard is broken into the same four parts as POSIX.1-2001, and "
"again there are two levels of conformance: the baseline I<POSIX "
"Conformance>, and I<XSI Conformance>, which mandates an additional set of "
"interfaces beyond those in the base specification."
msgstr ""
"Выпуск стандарта делится на те же части что и POSIX.1-2001 и также "
"существует два уровня соответствия: основной I<POSIX Conformance> и I<XSI "
"Conformance>, который описывает дополнительный набор интерфейсов вне "
"основного."

#. type: Plain text
#: man-pages/man7/standards.7:268
msgid ""
"In general, where the CONFORMING TO section of a manual page lists "
"POSIX.1-2001, it can be assumed that the interface also conforms to "
"POSIX.1-2008, unless otherwise noted."
msgstr ""
"В общем, если в разделе справочных страниц «СООТВЕТСТВИЕ СТАНДАРТАМ» указан "
"POSIX.1-2001, то можно считать, что интерфейс также соответствует "
"POSIX.1-2008, если не указано обратного."

#. type: Plain text
#: man-pages/man7/standards.7:273
msgid ""
"Technical Corrigendum 1 (minor fixes and improvements)  of this standard was "
"released in 2013 (also known as I<POSIX.1-2013>)."
msgstr ""
"Техническая поправка 1 (небольшие исправления и улучшения) данного стандарта "
"была выпущена в 2013 году (также известна как I<POSIX.1-2013>)."

#. type: Plain text
#: man-pages/man7/standards.7:277
msgid ""
"Technical Corrigendum 2 of this standard was released in 2016 (also known as "
"I<POSIX.1-2016>)."
msgstr ""
"Техническая поправка 2 данного стандарта вошла в выпуск 2016 года (также "
"известна как I<POSIX.1-2016>)."

#. type: Plain text
#: man-pages/man7/standards.7:281
msgid ""
"Further information can be found on the Austin Group web site, E<.UR http://"
"www.opengroup.org\\:/austin/> E<.UE .>"
msgstr ""
"Дополнительную информацию можно найти на веб-сайте Austin Group по адресу: "
"E<.UR http://www.opengroup.org\\:/austin/> E<.UE .>"

#. type: Plain text
#: man-pages/man7/standards.7:289
msgid ""
"B<getconf>(1), B<confstr>(3), B<pathconf>(3), B<sysconf>(3), "
"B<attributes>(7), B<feature_test_macros>(7), B<libc>(7), B<posixoptions>(7)"
msgstr ""
"B<getconf>(1), B<confstr>(3), B<pathconf>(3), B<sysconf>(3), "
"B<attributes>(7), B<feature_test_macros>(7), B<libc>(7), B<posixoptions>(7)"

#. type: TH
#: man-pages/man7/suffixes.7:39
#, no-wrap
msgid "SUFFIXES"
msgstr "SUFFIXES"

#. type: Plain text
#: man-pages/man7/suffixes.7:42
msgid "suffixes - list of file suffixes"
msgstr "suffixes - список суффиксов имён файлов"

#. type: Plain text
#: man-pages/man7/suffixes.7:50
msgid ""
"It is customary to indicate the contents of a file with the file suffix, "
"which consists of a period, followed by one or more letters.  Many standard "
"utilities, such as compilers, use this to recognize the type of file they "
"are dealing with.  The B<make>(1)  utility is driven by rules based on file "
"suffix."
msgstr ""
"Обычно, чтобы указать на содержимое файла, в конец имени добавляют суффикс, "
"который состоит из точки и одной или нескольких букв. Многие стандартные "
"утилиты, такие как компиляторы, используют это, чтобы распознать тип файла, "
"который им передан. Утилита B<make>(1) работает по правилам на основе "
"суффиксов файлов."

#. type: Plain text
#: man-pages/man7/suffixes.7:53
msgid ""
"Following is a list of suffixes which are likely to be found on a Linux "
"system."
msgstr ""
"Ниже представлен список суффиксов, которые, вероятно, можно найти в системе "
"Linux."

#. type: tbl table
#: man-pages/man7/suffixes.7:58
#, no-wrap
msgid "Suffix"
msgstr "Суффикс"

#. type: tbl table
#: man-pages/man7/suffixes.7:58
#, no-wrap
msgid "File type"
msgstr "Тип файла"

#. type: tbl table
#: man-pages/man7/suffixes.7:59
#, no-wrap
msgid " ,v"
msgstr " ,v"

#. type: tbl table
#: man-pages/man7/suffixes.7:59
#, no-wrap
msgid "files for RCS (Revision Control System)"
msgstr "файлы RCS (Revision Control System)"

#. type: tbl table
#: man-pages/man7/suffixes.7:60
#, no-wrap
msgid " -"
msgstr " -"

#. type: tbl table
#: man-pages/man7/suffixes.7:60 man-pages/man7/suffixes.7:88
#, no-wrap
msgid "backup file"
msgstr "резервная копия файла"

#. type: tbl table
#: man-pages/man7/suffixes.7:61
#, no-wrap
msgid " .C"
msgstr " .C"

#. type: tbl table
#: man-pages/man7/suffixes.7:61
#, no-wrap
msgid "C++ source code, equivalent to I<.cc>"
msgstr "исходный код C++, эквивалент I<.cc>"

#. type: tbl table
#: man-pages/man7/suffixes.7:62
#, no-wrap
msgid " .F"
msgstr " .F"

#. type: tbl table
#: man-pages/man7/suffixes.7:62
#, no-wrap
msgid "Fortran source with B<cpp>(1) directives"
msgstr "исходный код Fortran с директивами B<cpp>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:63
#, no-wrap
msgid "or file compressed using freeze"
msgstr "или файл, сжатый с помощью freeze"

#. type: tbl table
#: man-pages/man7/suffixes.7:64
#, no-wrap
msgid " .S"
msgstr " .S"

#. type: tbl table
#: man-pages/man7/suffixes.7:64
#, no-wrap
msgid "assembler source with B<cpp>(1) directives"
msgstr "исходный код ассемблера с директивами B<cpp>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:65
#, no-wrap
msgid " .Y"
msgstr " .Y"

#. type: tbl table
#: man-pages/man7/suffixes.7:65
#, no-wrap
msgid "file compressed using yabba"
msgstr "файл, сжатый с помощью yabba"

#. type: tbl table
#: man-pages/man7/suffixes.7:66
#, no-wrap
msgid " .Z"
msgstr " .Z"

#. type: tbl table
#: man-pages/man7/suffixes.7:66
#, no-wrap
msgid "file compressed using B<compress>(1)"
msgstr "файл, сжатый с помощью B<compress>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:67
#, no-wrap
msgid " .[0-\\9]+gf"
msgstr " .[0-\\9]+gf"

#. type: tbl table
#: man-pages/man7/suffixes.7:67
#, no-wrap
msgid "TeX generic font files"
msgstr "файлы обычных шрифтов TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:68
#, no-wrap
msgid " .[0-9]+pk"
msgstr " .[0-9]+pk"

#. type: tbl table
#: man-pages/man7/suffixes.7:68
#, no-wrap
msgid "TeX packed font files"
msgstr "файлы упакованных шрифтов TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:69
#, no-wrap
msgid " .[1-9]"
msgstr " .[1-9]"

#. type: tbl table
#: man-pages/man7/suffixes.7:69
#, no-wrap
msgid "manual page for the corresponding section"
msgstr "справочная страница из соответствующего раздела"

#. type: tbl table
#: man-pages/man7/suffixes.7:70
#, no-wrap
msgid " .[1-9][a-z]"
msgstr " .[1-9][a-z]"

#. type: tbl table
#: man-pages/man7/suffixes.7:70
#, no-wrap
msgid "manual page for section plus subsection"
msgstr "справочная страница из раздела плюс подраздел"

#. type: tbl table
#: man-pages/man7/suffixes.7:71
#, no-wrap
msgid " .a"
msgstr " .a"

#. type: tbl table
#: man-pages/man7/suffixes.7:71
#, no-wrap
msgid "static object code library"
msgstr "библиотека статического объектного кода"

#. type: tbl table
#: man-pages/man7/suffixes.7:72
#, no-wrap
msgid " .ad"
msgstr " .ad"

#. type: tbl table
#: man-pages/man7/suffixes.7:72
#, no-wrap
msgid "X application default resource file"
msgstr "файл ресурсов по умолчанию приложения для X"

#. type: tbl table
#: man-pages/man7/suffixes.7:73
#, no-wrap
msgid " .ada"
msgstr " .ada"

#. type: tbl table
#: man-pages/man7/suffixes.7:73
#, no-wrap
msgid "Ada source (may be body, spec, or combination)"
msgstr "исходный код на языке Ада (тело, спецификация или оба сразу)"

#. type: tbl table
#: man-pages/man7/suffixes.7:74
#, no-wrap
msgid " .adb"
msgstr " .adb"

#. type: tbl table
#: man-pages/man7/suffixes.7:74
#, no-wrap
msgid "Ada body source"
msgstr "исходный код тела на языке Ада"

#. type: tbl table
#: man-pages/man7/suffixes.7:75
#, no-wrap
msgid " .ads"
msgstr " .ads"

#. type: tbl table
#: man-pages/man7/suffixes.7:75
#, no-wrap
msgid "Ada spec source"
msgstr "исходный код спецификации на языке Ада"

#. type: tbl table
#: man-pages/man7/suffixes.7:76
#, no-wrap
msgid " .afm"
msgstr " .afm"

#. type: tbl table
#: man-pages/man7/suffixes.7:76
#, no-wrap
msgid "PostScript font metrics"
msgstr "метрика шрифта PostScript"

#. type: tbl table
#: man-pages/man7/suffixes.7:77
#, no-wrap
msgid " .al"
msgstr " .al"

#. type: tbl table
#: man-pages/man7/suffixes.7:77
#, no-wrap
msgid "Perl autoload file"
msgstr "автозагружаемый файл Perl"

#. type: tbl table
#: man-pages/man7/suffixes.7:78
#, no-wrap
msgid " .am"
msgstr " .am"

#. type: tbl table
#: man-pages/man7/suffixes.7:78
#, no-wrap
msgid "B<automake>(1) input file"
msgstr "входной файл для B<automake>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:79
#, no-wrap
msgid " .arc"
msgstr " .arc"

#. type: tbl table
#: man-pages/man7/suffixes.7:79
#, no-wrap
msgid "B<arc>(1) archive"
msgstr "архив B<arc>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:80
#, no-wrap
msgid " .arj"
msgstr " .arj"

#. type: tbl table
#: man-pages/man7/suffixes.7:80
#, no-wrap
msgid "B<arj>(1) archive"
msgstr "архив B<arj>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:81
#, no-wrap
msgid " .asc"
msgstr " .asc"

#. type: tbl table
#: man-pages/man7/suffixes.7:81
#, no-wrap
msgid "PGP ASCII-armored data"
msgstr "данные в кодировке ASCII, защищённые PGP"

#. type: tbl table
#: man-pages/man7/suffixes.7:82
#, no-wrap
msgid " .asm"
msgstr " .asm"

#. type: tbl table
#: man-pages/man7/suffixes.7:82
#, no-wrap
msgid "(GNU) assembler source file"
msgstr "файл исходного кода на ассемблере (GNU)"

#. type: tbl table
#: man-pages/man7/suffixes.7:83
#, no-wrap
msgid " .au"
msgstr " .au"

#. type: tbl table
#: man-pages/man7/suffixes.7:83
#, no-wrap
msgid "Audio sound file"
msgstr "Звуковой файл"

#. type: tbl table
#: man-pages/man7/suffixes.7:84
#, no-wrap
msgid " .aux"
msgstr " .aux"

#. type: tbl table
#: man-pages/man7/suffixes.7:84
#, no-wrap
msgid "LaTeX auxiliary file"
msgstr "вспомогательный файл LaTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:85
#, no-wrap
msgid " .avi"
msgstr " .avi"

#. type: tbl table
#: man-pages/man7/suffixes.7:85
#, no-wrap
msgid "(msvideo) movie"
msgstr "видео (msvideo)"

#. type: tbl table
#: man-pages/man7/suffixes.7:86
#, no-wrap
msgid " .awk"
msgstr " .awk"

#. type: tbl table
#: man-pages/man7/suffixes.7:86
#, no-wrap
msgid "AWK language program"
msgstr "программа на языке AWK"

#. type: tbl table
#: man-pages/man7/suffixes.7:87
#, no-wrap
msgid " .b"
msgstr " .b"

#. type: tbl table
#: man-pages/man7/suffixes.7:87
#, no-wrap
msgid "LILO boot loader image"
msgstr "образ системного загрузчика LILO"

#. type: tbl table
#: man-pages/man7/suffixes.7:88
#, no-wrap
msgid " .bak"
msgstr " .bak"

#. type: tbl table
#: man-pages/man7/suffixes.7:89
#, no-wrap
msgid " .bash"
msgstr " .bash"

#. type: tbl table
#: man-pages/man7/suffixes.7:89
#, no-wrap
msgid "B<bash>(1) shell script"
msgstr "сценарий оболочки B<bash>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:90
#, no-wrap
msgid " .bb"
msgstr " .bb"

#. type: tbl table
#: man-pages/man7/suffixes.7:90
#, no-wrap
msgid "basic block list data produced by"
msgstr "данные простого блочного листинга, созданные"

#. type: tbl table
#: man-pages/man7/suffixes.7:91 man-pages/man7/suffixes.7:93
#, no-wrap
msgid "gcc -ftest-coverage"
msgstr "gcc -ftest-coverage"

#. type: tbl table
#: man-pages/man7/suffixes.7:92
#, no-wrap
msgid " .bbg"
msgstr " .bbg"

#. type: tbl table
#: man-pages/man7/suffixes.7:92
#, no-wrap
msgid "basic block graph data produced by"
msgstr "данные простого блочного графа, созданные"

#. type: tbl table
#: man-pages/man7/suffixes.7:94
#, no-wrap
msgid " .bbl"
msgstr " .bbl"

#. type: tbl table
#: man-pages/man7/suffixes.7:94
#, no-wrap
msgid "BibTeX output"
msgstr "вывод BibTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:95
#, no-wrap
msgid " .bdf"
msgstr " .bdf"

#. type: tbl table
#: man-pages/man7/suffixes.7:95
#, no-wrap
msgid "X font file"
msgstr "файл шрифта X"

#. type: tbl table
#: man-pages/man7/suffixes.7:96
#, no-wrap
msgid " .bib"
msgstr " .bib"

#. type: tbl table
#: man-pages/man7/suffixes.7:96
#, no-wrap
msgid "TeX bibliographic database, BibTeX input"
msgstr "библиографическая база данных TeX, входные данные BibTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:97
#, no-wrap
msgid " .bm"
msgstr " .bm"

#. type: tbl table
#: man-pages/man7/suffixes.7:97 man-pages/man7/suffixes.7:148
#: man-pages/man7/suffixes.7:151 man-pages/man7/suffixes.7:214
#, no-wrap
msgid "bitmap source"
msgstr "исходный текст для растровых изображений"

#. type: tbl table
#: man-pages/man7/suffixes.7:98
#, no-wrap
msgid " .bmp"
msgstr " .bmp"

#. type: tbl table
#: man-pages/man7/suffixes.7:98
#, no-wrap
msgid "bitmap"
msgstr "bitmap"

#. type: tbl table
#: man-pages/man7/suffixes.7:99
#, no-wrap
msgid " .bz2"
msgstr " .bz2"

#. type: tbl table
#: man-pages/man7/suffixes.7:99
#, no-wrap
msgid "file compressed using B<bzip2>(1)"
msgstr "файл, сжатый с помощью B<bzip2>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:100
#, no-wrap
msgid " .c"
msgstr " .c"

#. type: tbl table
#: man-pages/man7/suffixes.7:100
#, no-wrap
msgid "C source"
msgstr "исходный код на языке Си"

#. type: tbl table
#: man-pages/man7/suffixes.7:101
#, no-wrap
msgid " .cat"
msgstr " .cat"

#. type: tbl table
#: man-pages/man7/suffixes.7:101
#, no-wrap
msgid "message catalog files"
msgstr "файлы каталога сообщений"

#. type: tbl table
#: man-pages/man7/suffixes.7:102
#, no-wrap
msgid " .cc"
msgstr " .cc"

#. type: tbl table
#: man-pages/man7/suffixes.7:102
#, no-wrap
msgid "C++ source"
msgstr "исходный код на языке Си++"

#. type: tbl table
#: man-pages/man7/suffixes.7:103
#, no-wrap
msgid " .cf"
msgstr " .cf"

#. type: tbl table
#: man-pages/man7/suffixes.7:103 man-pages/man7/suffixes.7:104
#: man-pages/man7/suffixes.7:108 man-pages/man7/suffixes.7:109
#, no-wrap
msgid "configuration file"
msgstr "файл с настройками"

#. type: tbl table
#: man-pages/man7/suffixes.7:104
#, no-wrap
msgid " .cfg"
msgstr " .cfg"

#. type: tbl table
#: man-pages/man7/suffixes.7:105
#, no-wrap
msgid " .cgi"
msgstr " .cgi"

#. type: tbl table
#: man-pages/man7/suffixes.7:105
#, no-wrap
msgid "WWW content generating script or program"
msgstr "сценарий или программа, генерирующая информацию для WWW"

#. type: tbl table
#: man-pages/man7/suffixes.7:106
#, no-wrap
msgid " .cls"
msgstr " .cls"

#. type: tbl table
#: man-pages/man7/suffixes.7:106
#, no-wrap
msgid "LaTeX Class definition"
msgstr "определение класса LaTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:107
#, no-wrap
msgid " .class"
msgstr " .class"

#. type: tbl table
#: man-pages/man7/suffixes.7:107
#, no-wrap
msgid "Java compiled byte-code"
msgstr "скомпилированный байт-код Java"

#. type: tbl table
#: man-pages/man7/suffixes.7:108
#, no-wrap
msgid " .conf"
msgstr " .conf"

#. type: tbl table
#: man-pages/man7/suffixes.7:109
#, no-wrap
msgid " .config"
msgstr " .config"

#. type: tbl table
#: man-pages/man7/suffixes.7:110
#, no-wrap
msgid " .cpp"
msgstr " .cpp"

#. type: tbl table
#: man-pages/man7/suffixes.7:110 man-pages/man7/suffixes.7:112
#, no-wrap
msgid "equivalent to I<.cc>"
msgstr "эквивалентно I<.cc>"

#. type: tbl table
#: man-pages/man7/suffixes.7:111
#, no-wrap
msgid " .csh"
msgstr " .csh"

#. type: tbl table
#: man-pages/man7/suffixes.7:111
#, no-wrap
msgid "B<csh>(1) shell script"
msgstr "сценарий оболочки B<csh>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:112
#, no-wrap
msgid " .cxx"
msgstr " .cxx"

#. type: tbl table
#: man-pages/man7/suffixes.7:113
#, no-wrap
msgid " .dat"
msgstr " .dat"

#. type: tbl table
#: man-pages/man7/suffixes.7:113
#, no-wrap
msgid "data file"
msgstr "файл данных"

#. type: tbl table
#: man-pages/man7/suffixes.7:114
#, no-wrap
msgid " .deb"
msgstr " .deb"

#. type: tbl table
#: man-pages/man7/suffixes.7:114
#, no-wrap
msgid "Debian software package"
msgstr "пакет ПО Debian"

#. type: tbl table
#: man-pages/man7/suffixes.7:115 man-pages/man7/suffixes.7:116
#, no-wrap
msgid " .def"
msgstr " .def"

#. type: tbl table
#: man-pages/man7/suffixes.7:115
#, no-wrap
msgid "Modula-2 source for definition modules"
msgstr "исходный код Modula-2 для определения модулей"

#. type: tbl table
#: man-pages/man7/suffixes.7:116
#, no-wrap
msgid "other definition files"
msgstr "файлы других определений"

#. type: tbl table
#: man-pages/man7/suffixes.7:117
#, no-wrap
msgid " .desc"
msgstr " .desc"

#. type: tbl table
#: man-pages/man7/suffixes.7:117
#, no-wrap
msgid "initial part of mail message unpacked with"
msgstr "начальная часть почтового сообщения, распакованного"

#. type: tbl table
#: man-pages/man7/suffixes.7:118
#, no-wrap
msgid "B<munpack>(1)"
msgstr "B<munpack>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:119
#, no-wrap
msgid " .diff"
msgstr " .diff"

#. type: tbl table
#: man-pages/man7/suffixes.7:119
#, no-wrap
msgid "file differences (B<diff>(1) command output)"
msgstr "файл различий (результат команды B<diff>(1))"

#. type: tbl table
#: man-pages/man7/suffixes.7:120
#, no-wrap
msgid " .dir"
msgstr " .dir"

#. type: tbl table
#: man-pages/man7/suffixes.7:120
#, no-wrap
msgid "dbm data base directory file"
msgstr "каталожный файл базы данных dbm"

#. type: tbl table
#: man-pages/man7/suffixes.7:121
#, no-wrap
msgid " .doc"
msgstr " .doc"

#. type: tbl table
#: man-pages/man7/suffixes.7:121
#, no-wrap
msgid "documentation file"
msgstr "файл документации"

#. type: tbl table
#: man-pages/man7/suffixes.7:122
#, no-wrap
msgid " .dsc"
msgstr " .dsc"

#. type: tbl table
#: man-pages/man7/suffixes.7:122
#, no-wrap
msgid "Debian Source Control (source package)"
msgstr "Debian Source Control (пакет с исходным кодом)"

#. type: tbl table
#: man-pages/man7/suffixes.7:123
#, no-wrap
msgid " .dtx"
msgstr " .dtx"

#. type: tbl table
#: man-pages/man7/suffixes.7:123
#, no-wrap
msgid "LaTeX package source file"
msgstr "исходный файл пакета LaTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:124
#, no-wrap
msgid " .dvi"
msgstr " .dvi"

#. type: tbl table
#: man-pages/man7/suffixes.7:124
#, no-wrap
msgid "TeX's device independent output"
msgstr "вывод TeX для независимого устройства"

#. type: tbl table
#: man-pages/man7/suffixes.7:125
#, no-wrap
msgid " .el"
msgstr " .el"

#. type: tbl table
#: man-pages/man7/suffixes.7:125
#, no-wrap
msgid "Emacs-Lisp source"
msgstr "исходный код на языке Emacs-Lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:126
#, no-wrap
msgid " .elc"
msgstr " .elc"

#. type: tbl table
#: man-pages/man7/suffixes.7:126
#, no-wrap
msgid "compiled Emacs-Lisp source"
msgstr "скомпилированный код на языке Emacs-Lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:127
#, no-wrap
msgid " .eps"
msgstr " .eps"

#. type: tbl table
#: man-pages/man7/suffixes.7:127
#, no-wrap
msgid "encapsulated PostScript"
msgstr "инкапсулированный PostScript"

#. type: tbl table
#: man-pages/man7/suffixes.7:128
#, no-wrap
msgid " .exp"
msgstr " .exp"

#. type: tbl table
#: man-pages/man7/suffixes.7:128
#, no-wrap
msgid "Expect source code"
msgstr "исходный код на языке Expect"

#. type: tbl table
#: man-pages/man7/suffixes.7:129
#, no-wrap
msgid " .f"
msgstr " .f"

#. type: tbl table
#: man-pages/man7/suffixes.7:129
#, no-wrap
msgid "Fortran source"
msgstr "исходный код на языке Фортран"

#. type: tbl table
#: man-pages/man7/suffixes.7:130
#, no-wrap
msgid " .f77"
msgstr " .f77"

#. type: tbl table
#: man-pages/man7/suffixes.7:130
#, no-wrap
msgid "Fortran 77 source"
msgstr "исходный код на языке Фортран77"

#. type: tbl table
#: man-pages/man7/suffixes.7:131
#, no-wrap
msgid " .f90"
msgstr " .f90"

#. type: tbl table
#: man-pages/man7/suffixes.7:131
#, no-wrap
msgid "Fortran 90 source"
msgstr "исходный код на языке Фортран90"

#. type: tbl table
#: man-pages/man7/suffixes.7:132
#, no-wrap
msgid " .fas"
msgstr " .fas"

#. type: tbl table
#: man-pages/man7/suffixes.7:132
#, no-wrap
msgid "precompiled Common-Lisp"
msgstr "прекомпилированный Common-Lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:133
#, no-wrap
msgid " .fi"
msgstr " .fi"

#. type: tbl table
#: man-pages/man7/suffixes.7:133
#, no-wrap
msgid "Fortran include files"
msgstr "включаемые файлы на языке Фортран"

#. type: tbl table
#: man-pages/man7/suffixes.7:134
#, no-wrap
msgid " .fig"
msgstr " .fig"

#. type: tbl table
#: man-pages/man7/suffixes.7:134
#, no-wrap
msgid "FIG image file (used by B<xfig>(1))"
msgstr "файл изображения FIG (используется B<xfig>(1))"

#. type: tbl table
#: man-pages/man7/suffixes.7:135
#, no-wrap
msgid " .fmt"
msgstr " .fmt"

#. type: tbl table
#: man-pages/man7/suffixes.7:135
#, no-wrap
msgid "TeX format file"
msgstr "форматный файл TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:136
#, no-wrap
msgid " .gif"
msgstr " .gif"

#. type: tbl table
#: man-pages/man7/suffixes.7:136
#, no-wrap
msgid "Compuserve Graphics Image File format"
msgstr "файл в формате Compuserve Graphics Image File"

#. type: tbl table
#: man-pages/man7/suffixes.7:137
#, no-wrap
msgid " .gmo"
msgstr " .gmo"

#. type: tbl table
#: man-pages/man7/suffixes.7:137
#, no-wrap
msgid "GNU format message catalog"
msgstr "каталог сообщений в формате GNU"

#. type: tbl table
#: man-pages/man7/suffixes.7:138
#, no-wrap
msgid " .gsf"
msgstr " .gsf"

#. type: tbl table
#: man-pages/man7/suffixes.7:138
#, no-wrap
msgid "Ghostscript fonts"
msgstr "шрифты Ghostscript"

#. type: tbl table
#: man-pages/man7/suffixes.7:139
#, no-wrap
msgid " .gz"
msgstr " .gz"

#. type: tbl table
#: man-pages/man7/suffixes.7:139
#, no-wrap
msgid "file compressed using B<gzip>(1)"
msgstr "файл, сжатый с помощью B<gzip>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:140
#, no-wrap
msgid " .h"
msgstr " .h"

#. type: tbl table
#: man-pages/man7/suffixes.7:140
#, no-wrap
msgid "C or C++ header files"
msgstr "заголовочные файлы C или C++"

#. type: tbl table
#: man-pages/man7/suffixes.7:141
#, no-wrap
msgid " .help"
msgstr " .help"

#. type: tbl table
#: man-pages/man7/suffixes.7:141
#, no-wrap
msgid "help file"
msgstr "файл справки"

#. type: tbl table
#: man-pages/man7/suffixes.7:142
#, no-wrap
msgid " .hf"
msgstr " .hf"

#. type: tbl table
#: man-pages/man7/suffixes.7:142 man-pages/man7/suffixes.7:143
#, no-wrap
msgid "equivalent to I<.help>"
msgstr "эквивалентно I<.help>"

#. type: tbl table
#: man-pages/man7/suffixes.7:143
#, no-wrap
msgid " .hlp"
msgstr " .hlp"

#. type: tbl table
#: man-pages/man7/suffixes.7:144
#, no-wrap
msgid " .htm"
msgstr " .htm"

#. type: tbl table
#: man-pages/man7/suffixes.7:144
#, no-wrap
msgid "poor man's I<.html>"
msgstr "сокращение I<.html>"

#. type: tbl table
#: man-pages/man7/suffixes.7:145
#, no-wrap
msgid " .html"
msgstr " .html"

#. type: tbl table
#: man-pages/man7/suffixes.7:145
#, no-wrap
msgid "HTML document used with the World Wide Web"
msgstr "документ HTML, используемый в World Wide Web"

#. type: tbl table
#: man-pages/man7/suffixes.7:146
#, no-wrap
msgid " .hqx"
msgstr " .hqx"

#. type: tbl table
#: man-pages/man7/suffixes.7:146
#, no-wrap
msgid "7-bit encoded Macintosh file"
msgstr "файл Macintosh в 7-битной кодировке"

#. type: tbl table
#: man-pages/man7/suffixes.7:147
#, no-wrap
msgid " .i"
msgstr " .i"

#. type: tbl table
#: man-pages/man7/suffixes.7:147
#, no-wrap
msgid "C source after preprocessing"
msgstr "файл исходного кода на C после предварительной обработки"

#. type: tbl table
#: man-pages/man7/suffixes.7:148
#, no-wrap
msgid " .icon"
msgstr " .icon"

#. type: tbl table
#: man-pages/man7/suffixes.7:149
#, no-wrap
msgid " .idx"
msgstr " .idx"

#. type: tbl table
#: man-pages/man7/suffixes.7:149
#, no-wrap
msgid "reference or datum-index file for hypertext"
msgstr "файл ссылок или список данных для гипертекста"

#. type: tbl table
#: man-pages/man7/suffixes.7:150
#, no-wrap
msgid "or database system"
msgstr "или системы базы данных"

#. type: tbl table
#: man-pages/man7/suffixes.7:151
#, no-wrap
msgid " .image"
msgstr " .image"

#. type: tbl table
#: man-pages/man7/suffixes.7:152
#, no-wrap
msgid " .in"
msgstr " .in"

#. type: tbl table
#: man-pages/man7/suffixes.7:152
#, no-wrap
msgid "configuration template, especially for GNU Autoconf"
msgstr "шаблон конфигурации, в частности для GNU Autoconf"

#. type: tbl table
#: man-pages/man7/suffixes.7:153
#, no-wrap
msgid " .info"
msgstr " .info"

#. type: tbl table
#: man-pages/man7/suffixes.7:153
#, no-wrap
msgid "files for the Emacs info browser"
msgstr "файлы для навигатора по информации Emacs"

#. type: tbl table
#: man-pages/man7/suffixes.7:154
#, no-wrap
msgid " .info-[0-9]+"
msgstr " .info-[0-9]+"

#. type: tbl table
#: man-pages/man7/suffixes.7:154
#, no-wrap
msgid "split info files"
msgstr "раздельные файлы info"

#. type: tbl table
#: man-pages/man7/suffixes.7:155
#, no-wrap
msgid " .ins"
msgstr " .ins"

#. type: tbl table
#: man-pages/man7/suffixes.7:155
#, no-wrap
msgid "LaTeX package install file for docstrip"
msgstr "файл установочного пакета LaTeX для docstrip"

#. type: tbl table
#: man-pages/man7/suffixes.7:156
#, no-wrap
msgid " .itcl"
msgstr " .itcl"

#. type: tbl table
#: man-pages/man7/suffixes.7:156
#, no-wrap
msgid "itcl source code;"
msgstr "файл исходного кода для itcl;"

#. type: tbl table
#: man-pages/man7/suffixes.7:157
#, no-wrap
msgid "itcl ([incr Tcl]) is an OO extension of tcl"
msgstr "itcl ([incr Tcl]) — объектно-ориентированное расширение tcl"

#. type: tbl table
#: man-pages/man7/suffixes.7:158
#, no-wrap
msgid " .java"
msgstr " .java"

#. type: tbl table
#: man-pages/man7/suffixes.7:158
#, no-wrap
msgid "a Java source file"
msgstr "файл исходного кода на языке Java"

#. type: tbl table
#: man-pages/man7/suffixes.7:159
#, no-wrap
msgid " .jpeg"
msgstr " .jpeg"

#. type: tbl table
#: man-pages/man7/suffixes.7:159
#, no-wrap
msgid "Joint Photographic Experts Group format"
msgstr "формат Joint Photographic Experts Group"

#. type: tbl table
#: man-pages/man7/suffixes.7:160
#, no-wrap
msgid " .jpg"
msgstr " .jpg"

#. type: tbl table
#: man-pages/man7/suffixes.7:160
#, no-wrap
msgid "poor man's I<.jpeg>"
msgstr "сокращение I<.jpeg>"

#. type: tbl table
#: man-pages/man7/suffixes.7:161
#, no-wrap
msgid " .kmap"
msgstr " .kmap"

#. type: tbl table
#: man-pages/man7/suffixes.7:161
#, no-wrap
msgid "B<lyx>(1) keymap"
msgstr "клавиатурная раскладка B<lyx>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:162
#, no-wrap
msgid " .l"
msgstr " .l"

#. type: tbl table
#: man-pages/man7/suffixes.7:162
#, no-wrap
msgid "equivalent to I<.lex> or I<.lisp>"
msgstr "эквивалентно файлам I<.lex> или I<.lisp>"

#. type: tbl table
#: man-pages/man7/suffixes.7:163
#, no-wrap
msgid " .lex"
msgstr " .lex"

#. type: tbl table
#: man-pages/man7/suffixes.7:163
#, no-wrap
msgid "B<lex>(1) or B<flex>(1) files"
msgstr "B<lex>(1) или B<flex>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:164
#, no-wrap
msgid " .lha"
msgstr " .lha"

#. type: tbl table
#: man-pages/man7/suffixes.7:164 man-pages/man7/suffixes.7:171
#, no-wrap
msgid "lharc archive"
msgstr "архив lharc"

#. type: tbl table
#: man-pages/man7/suffixes.7:165
#, no-wrap
msgid " .lib"
msgstr " .lib"

#. type: tbl table
#: man-pages/man7/suffixes.7:165
#, no-wrap
msgid "Common-Lisp library"
msgstr "библиотека Common-Lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:166
#, no-wrap
msgid " .lisp"
msgstr " .lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:166
#, no-wrap
msgid "Lisp source"
msgstr "исходный код на языке Lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:167
#, no-wrap
msgid " .ln"
msgstr " .ln"

#. type: tbl table
#: man-pages/man7/suffixes.7:167
#, no-wrap
msgid "files for use with B<lint>(1)"
msgstr "файлы для B<lint>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:168
#, no-wrap
msgid " .log"
msgstr " .log"

#. type: tbl table
#: man-pages/man7/suffixes.7:168
#, no-wrap
msgid "log file, in particular produced by TeX"
msgstr "файл журнала, в частности, создаваемый TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:169
#, no-wrap
msgid " .lsm"
msgstr " .lsm"

#. type: tbl table
#: man-pages/man7/suffixes.7:169
#, no-wrap
msgid "Linux Software Map entry"
msgstr "запись для Linux Software Map"

#. type: tbl table
#: man-pages/man7/suffixes.7:170
#, no-wrap
msgid " .lsp"
msgstr " .lsp"

#. type: tbl table
#: man-pages/man7/suffixes.7:170
#, no-wrap
msgid "Common-Lisp source"
msgstr "исходный код на языке Common-Lisp"

#. type: tbl table
#: man-pages/man7/suffixes.7:171
#, no-wrap
msgid " .lzh"
msgstr " .lzh"

#. type: tbl table
#: man-pages/man7/suffixes.7:172
#, no-wrap
msgid " .m"
msgstr " .m"

#. type: tbl table
#: man-pages/man7/suffixes.7:172
#, no-wrap
msgid "Objective-C source code"
msgstr "исходный код на языке Objective-C"

#. type: tbl table
#: man-pages/man7/suffixes.7:173
#, no-wrap
msgid " .m4"
msgstr " .m4"

#. type: tbl table
#: man-pages/man7/suffixes.7:173
#, no-wrap
msgid "B<m4>(1) source"
msgstr "исходный код на языке B<m4>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:174
#, no-wrap
msgid " .mac"
msgstr " .mac"

#. type: tbl table
#: man-pages/man7/suffixes.7:174
#, no-wrap
msgid "macro files for various programs"
msgstr "файлы макросов для различных программ"

#. type: tbl table
#: man-pages/man7/suffixes.7:175
#, no-wrap
msgid " .man"
msgstr " .man"

#. type: tbl table
#: man-pages/man7/suffixes.7:175
#, no-wrap
msgid "manual page (usually source rather than formatted)"
msgstr "справочная страница (обычно, исходный текст, а не отформатированная)"

#. type: tbl table
#: man-pages/man7/suffixes.7:176
#, no-wrap
msgid " .map"
msgstr " .map"

#. type: tbl table
#: man-pages/man7/suffixes.7:176
#, no-wrap
msgid "map files for various programs"
msgstr "файлы карт для различных программ"

#. type: tbl table
#: man-pages/man7/suffixes.7:177
#, no-wrap
msgid " .me"
msgstr " .me"

#. type: tbl table
#: man-pages/man7/suffixes.7:177
#, no-wrap
msgid "Nroff source using the me macro package"
msgstr "исходный код для nroff, в котором используется пакет макросов me"

#. type: tbl table
#: man-pages/man7/suffixes.7:178
#, no-wrap
msgid " .mf"
msgstr " .mf"

#. type: tbl table
#: man-pages/man7/suffixes.7:178
#, no-wrap
msgid "Metafont (font generator for TeX) source"
msgstr "исходный код для metafont (генератор шрифтов для TeX)"

#. type: tbl table
#: man-pages/man7/suffixes.7:179
#, no-wrap
msgid " .mgp"
msgstr " .mgp"

#. type: tbl table
#: man-pages/man7/suffixes.7:179
#, no-wrap
msgid "MagicPoint file"
msgstr "файл MagicPoint"

#. type: tbl table
#: man-pages/man7/suffixes.7:180
#, no-wrap
msgid " .mm"
msgstr " .mm"

#. type: tbl table
#: man-pages/man7/suffixes.7:180
#, no-wrap
msgid "sources for B<groff>(1) in mm - format"
msgstr "исходный код для B<groff>(1) в формате mm"

#. type: tbl table
#: man-pages/man7/suffixes.7:181
#, no-wrap
msgid " .mo"
msgstr " .mo"

#. type: tbl table
#: man-pages/man7/suffixes.7:181
#, no-wrap
msgid "Message catalog binary file"
msgstr "двоичный файл каталога сообщений"

#. type: tbl table
#: man-pages/man7/suffixes.7:182
#, no-wrap
msgid " .mod"
msgstr " .mod"

#. type: tbl table
#: man-pages/man7/suffixes.7:182
#, no-wrap
msgid "Modula-2 source for implementation modules"
msgstr "исходный код на языке Modula-2 для реализации модулей"

#. type: tbl table
#: man-pages/man7/suffixes.7:183
#, no-wrap
msgid " .mov"
msgstr " .mov"

#. type: tbl table
#: man-pages/man7/suffixes.7:183
#, no-wrap
msgid "(quicktime) movie"
msgstr "видео (quicktime)"

#. type: tbl table
#: man-pages/man7/suffixes.7:184
#, no-wrap
msgid " .mp"
msgstr " .mp"

#. type: tbl table
#: man-pages/man7/suffixes.7:184
#, no-wrap
msgid "Metapost source"
msgstr "исходный код для Metapost"

#. type: tbl table
#: man-pages/man7/suffixes.7:185
#, no-wrap
msgid " .mp2"
msgstr " .mp2"

#. type: tbl table
#: man-pages/man7/suffixes.7:185
#, no-wrap
msgid "MPEG Layer 2 (audio) file"
msgstr "файл MPEG Layer 2 (аудио)"

#. type: tbl table
#: man-pages/man7/suffixes.7:186
#, no-wrap
msgid " .mp3"
msgstr " .mp3"

#. type: tbl table
#: man-pages/man7/suffixes.7:186
#, no-wrap
msgid "MPEG Layer 3 (audio) file"
msgstr "файл MPEG Layer 3 (аудио)"

#. type: tbl table
#: man-pages/man7/suffixes.7:187
#, no-wrap
msgid " .mpeg"
msgstr " .mpeg"

#. type: tbl table
#: man-pages/man7/suffixes.7:187
#, no-wrap
msgid "movie file"
msgstr "видео файл"

#. type: tbl table
#: man-pages/man7/suffixes.7:188
#, no-wrap
msgid " .o"
msgstr " .o"

#. type: tbl table
#: man-pages/man7/suffixes.7:188
#, no-wrap
msgid "object file"
msgstr "объектный файл"

#. type: tbl table
#: man-pages/man7/suffixes.7:189
#, no-wrap
msgid " .old"
msgstr " .old"

#. type: tbl table
#: man-pages/man7/suffixes.7:189
#, no-wrap
msgid "old or backup file"
msgstr "старый файл или резервная копия"

#. type: tbl table
#: man-pages/man7/suffixes.7:190
#, no-wrap
msgid " .orig"
msgstr " .orig"

#. type: tbl table
#: man-pages/man7/suffixes.7:190
#, no-wrap
msgid "backup (original) version of a file, from B<patch>(1)"
msgstr "резервная версия файла (до изменений), созданная B<patch>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:191
#, no-wrap
msgid " .out"
msgstr " .out"

#. type: tbl table
#: man-pages/man7/suffixes.7:191
#, no-wrap
msgid "output file, often executable program (a.out)"
msgstr "файл результата, часто исполняемая программа (a.out)"

#. type: tbl table
#: man-pages/man7/suffixes.7:192
#, no-wrap
msgid " .p"
msgstr " .p"

#. type: tbl table
#: man-pages/man7/suffixes.7:192
#, no-wrap
msgid "Pascal source"
msgstr "файл исходного кода на языке Pascal"

#. type: tbl table
#: man-pages/man7/suffixes.7:193
#, no-wrap
msgid " .pag"
msgstr " .pag"

#. type: tbl table
#: man-pages/man7/suffixes.7:193
#, no-wrap
msgid "dbm data base data file"
msgstr "файл базы данный dbm"

#. type: tbl table
#: man-pages/man7/suffixes.7:194
#, no-wrap
msgid " .patch"
msgstr " .patch"

#. type: tbl table
#: man-pages/man7/suffixes.7:194
#, no-wrap
msgid "file differences for B<patch>(1)"
msgstr "файл различий для B<patch>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:195
#, no-wrap
msgid " .pbm"
msgstr " .pbm"

#. type: tbl table
#: man-pages/man7/suffixes.7:195
#, no-wrap
msgid "portable bitmap format"
msgstr "переносимый формат растровой графики"

#. type: tbl table
#: man-pages/man7/suffixes.7:196
#, no-wrap
msgid " .pcf"
msgstr " .pcf"

#. type: tbl table
#: man-pages/man7/suffixes.7:196
#, no-wrap
msgid "X11 font files"
msgstr "файлы шрифтов X11"

#. type: tbl table
#: man-pages/man7/suffixes.7:197
#, no-wrap
msgid " .pdf"
msgstr " .pdf"

#. type: tbl table
#: man-pages/man7/suffixes.7:197
#, no-wrap
msgid "Adobe Portable Data Format"
msgstr "переносимый формат данных Adobe"

#. type: tbl table
#: man-pages/man7/suffixes.7:198
#, no-wrap
msgid "(use Acrobat/B<acroread> or B<xpdf>)"
msgstr "(используется в Acrobat/B<acroread> или B<xpdf>)"

#. type: tbl table
#: man-pages/man7/suffixes.7:199
#, no-wrap
msgid " .perl"
msgstr " .perl"

#. type: tbl table
#: man-pages/man7/suffixes.7:199
#, no-wrap
msgid "Perl source (see .ph, .pl and .pm)"
msgstr "исходный код на языке Perl (смотрите .ph, .pl и .pm)"

#. type: tbl table
#: man-pages/man7/suffixes.7:200
#, no-wrap
msgid " .pfa"
msgstr " .pfa"

#. type: tbl table
#: man-pages/man7/suffixes.7:200
#, no-wrap
msgid "PostScript font definition files, ASCII format"
msgstr "файлы описания шрифтов PostScript в формате ASCII"

#. type: tbl table
#: man-pages/man7/suffixes.7:201
#, no-wrap
msgid " .pfb"
msgstr " .pfb"

#. type: tbl table
#: man-pages/man7/suffixes.7:201
#, no-wrap
msgid "PostScript font definition files, binary format"
msgstr "файлы описания шрифтов PostScript в двоичном формате"

#. type: tbl table
#: man-pages/man7/suffixes.7:202
#, no-wrap
msgid " .pgm"
msgstr " .pgm"

#. type: tbl table
#: man-pages/man7/suffixes.7:202
#, no-wrap
msgid "portable greymap format"
msgstr "переносимый формат полутонов"

#. type: tbl table
#: man-pages/man7/suffixes.7:203
#, no-wrap
msgid " .pgp"
msgstr " .pgp"

#. type: tbl table
#: man-pages/man7/suffixes.7:203
#, no-wrap
msgid "PGP binary data"
msgstr "двоичные данные PGP"

#. type: tbl table
#: man-pages/man7/suffixes.7:204
#, no-wrap
msgid " .ph"
msgstr " .ph"

#. type: tbl table
#: man-pages/man7/suffixes.7:204
#, no-wrap
msgid "Perl header file"
msgstr "файл заголовка Perl"

#. type: tbl table
#: man-pages/man7/suffixes.7:205
#, no-wrap
msgid " .php"
msgstr " .php"

#. type: tbl table
#: man-pages/man7/suffixes.7:205
#, no-wrap
msgid "PHP program file"
msgstr "файл программы на языке PHP"

#. type: tbl table
#: man-pages/man7/suffixes.7:206
#, no-wrap
msgid " .php3"
msgstr " .php3"

#. type: tbl table
#: man-pages/man7/suffixes.7:206
#, no-wrap
msgid "PHP3 program file"
msgstr "файл программы на языке PHP3"

#. type: tbl table
#: man-pages/man7/suffixes.7:207
#, no-wrap
msgid " .pid"
msgstr " .pid"

#. type: tbl table
#: man-pages/man7/suffixes.7:207
#, no-wrap
msgid "File to store daemon PID (e.g., crond.pid)"
msgstr "файл для хранения PID службы (например, crond.pid)"

#. type: tbl table
#: man-pages/man7/suffixes.7:208
#, no-wrap
msgid " .pl"
msgstr " .pl"

#. type: tbl table
#: man-pages/man7/suffixes.7:208
#, no-wrap
msgid "TeX property list file or Perl library file"
msgstr "файл списка свойств TeX или библиотечный файл Perl"

#. type: tbl table
#: man-pages/man7/suffixes.7:209
#, no-wrap
msgid " .pm"
msgstr " .pm"

#. type: tbl table
#: man-pages/man7/suffixes.7:209
#, no-wrap
msgid "Perl module"
msgstr "модуль Perl"

#. type: tbl table
#: man-pages/man7/suffixes.7:210
#, no-wrap
msgid " .png"
msgstr " .png"

#. type: tbl table
#: man-pages/man7/suffixes.7:210
#, no-wrap
msgid "Portable Network Graphics file"
msgstr "файл в формате Portable Network Graphics"

#. type: tbl table
#: man-pages/man7/suffixes.7:211
#, no-wrap
msgid " .po"
msgstr " .po"

#. type: tbl table
#: man-pages/man7/suffixes.7:211
#, no-wrap
msgid "Message catalog source"
msgstr "исходный файл каталога сообщений"

#. type: tbl table
#: man-pages/man7/suffixes.7:212
#, no-wrap
msgid " .pod"
msgstr " .pod"

#. type: tbl table
#: man-pages/man7/suffixes.7:212
#, no-wrap
msgid "B<perldoc>(1) file"
msgstr "файл для B<perldoc>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:213
#, no-wrap
msgid " .ppm"
msgstr " .ppm"

#. type: tbl table
#: man-pages/man7/suffixes.7:213
#, no-wrap
msgid "portable pixmap format"
msgstr "переносимый формат pixmap"

#. type: tbl table
#: man-pages/man7/suffixes.7:214
#, no-wrap
msgid " .pr"
msgstr " .pr"

#. type: tbl table
#: man-pages/man7/suffixes.7:215
#, no-wrap
msgid " .ps"
msgstr " .ps"

#. type: tbl table
#: man-pages/man7/suffixes.7:215
#, no-wrap
msgid "PostScript file"
msgstr "файл PostScript"

#. type: tbl table
#: man-pages/man7/suffixes.7:216
#, no-wrap
msgid " .py"
msgstr " .py"

#. type: tbl table
#: man-pages/man7/suffixes.7:216
#, no-wrap
msgid "Python source"
msgstr "файл исходного кода на языке Python"

#. type: tbl table
#: man-pages/man7/suffixes.7:217
#, no-wrap
msgid " .pyc"
msgstr " .pyc"

#. type: tbl table
#: man-pages/man7/suffixes.7:217
#, no-wrap
msgid "compiled python"
msgstr "скомпилированный python"

#. type: tbl table
#: man-pages/man7/suffixes.7:218
#, no-wrap
msgid " .qt"
msgstr " .qt"

#. type: tbl table
#: man-pages/man7/suffixes.7:218
#, no-wrap
msgid "quicktime movie"
msgstr "видео quicktime"

#. type: tbl table
#: man-pages/man7/suffixes.7:219
#, no-wrap
msgid " .r"
msgstr " .r"

#. type: tbl table
#: man-pages/man7/suffixes.7:219
#, no-wrap
msgid "RATFOR source (obsolete)"
msgstr "исходный код для RATFOR (устарел)"

#. type: tbl table
#: man-pages/man7/suffixes.7:220
#, no-wrap
msgid " .rej"
msgstr " .rej"

#. type: tbl table
#: man-pages/man7/suffixes.7:220
#, no-wrap
msgid "patches that B<patch>(1) couldn't apply"
msgstr "заплаты, которые B<patch>(1) не удалось наложить"

#. type: tbl table
#: man-pages/man7/suffixes.7:221
#, no-wrap
msgid " .rpm"
msgstr " .rpm"

#. type: tbl table
#: man-pages/man7/suffixes.7:221
#, no-wrap
msgid "RPM software package"
msgstr "ПО в пакете RPM"

#. type: tbl table
#: man-pages/man7/suffixes.7:222
#, no-wrap
msgid " .rtf"
msgstr " .rtf"

#. type: tbl table
#: man-pages/man7/suffixes.7:222
#, no-wrap
msgid "Rich Text Format file"
msgstr "файл в формате Rich Text Format"

#. type: tbl table
#: man-pages/man7/suffixes.7:223
#, no-wrap
msgid " .rules"
msgstr " .rules"

#. type: tbl table
#: man-pages/man7/suffixes.7:223
#, no-wrap
msgid "rules for something"
msgstr "правила чего-нибудь"

#. type: tbl table
#: man-pages/man7/suffixes.7:224
#, no-wrap
msgid " .s"
msgstr " .s"

#. type: tbl table
#: man-pages/man7/suffixes.7:224
#, no-wrap
msgid "assembler source"
msgstr "исходный код на ассемблере"

#. type: tbl table
#: man-pages/man7/suffixes.7:225
#, no-wrap
msgid " .sa"
msgstr " .sa"

#. type: tbl table
#: man-pages/man7/suffixes.7:225
#, no-wrap
msgid "stub libraries for a.out shared libraries"
msgstr "библиотеки-заглушки для общих библиотек a.out"

#. type: tbl table
#: man-pages/man7/suffixes.7:226
#, no-wrap
msgid " .sc"
msgstr " .sc"

#. type: tbl table
#: man-pages/man7/suffixes.7:226
#, no-wrap
msgid "B<sc>(1) spreadsheet commands"
msgstr "электронная таблица с командами B<sc>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:227
#, no-wrap
msgid " .scm"
msgstr " .scm"

#. type: tbl table
#: man-pages/man7/suffixes.7:227
#, no-wrap
msgid "Scheme source code"
msgstr "исходный код на языке Scheme"

#. type: tbl table
#: man-pages/man7/suffixes.7:228
#, no-wrap
msgid " .sed"
msgstr " .sed"

#. type: tbl table
#: man-pages/man7/suffixes.7:228
#, no-wrap
msgid "sed source file"
msgstr "файл исходного кода для sed"

#. type: tbl table
#: man-pages/man7/suffixes.7:229
#, no-wrap
msgid " .sgml"
msgstr " .sgml"

#. type: tbl table
#: man-pages/man7/suffixes.7:229
#, no-wrap
msgid "SGML source file"
msgstr "файл исходного кода на языке SGML"

#. type: tbl table
#: man-pages/man7/suffixes.7:230
#, no-wrap
msgid " .sh"
msgstr " .sh"

#. type: tbl table
#: man-pages/man7/suffixes.7:230
#, no-wrap
msgid "B<sh>(1) scripts"
msgstr "сценарии B<sh>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:231
#, no-wrap
msgid " .shar"
msgstr " .shar"

#. type: tbl table
#: man-pages/man7/suffixes.7:231
#, no-wrap
msgid "archive created by the B<shar>(1) utility"
msgstr "архив, созданный утилитой B<shar>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:232
#, no-wrap
msgid " .so"
msgstr " .so"

#. type: tbl table
#: man-pages/man7/suffixes.7:232
#, no-wrap
msgid "Shared library or dynamically loadable object"
msgstr "общая библиотека или динамически загружаемый объект"

#. type: tbl table
#: man-pages/man7/suffixes.7:233
#, no-wrap
msgid " .sql"
msgstr " .sql"

#. type: tbl table
#: man-pages/man7/suffixes.7:233
#, no-wrap
msgid "SQL source"
msgstr "исходный код на языке SQL"

#. type: tbl table
#: man-pages/man7/suffixes.7:234
#, no-wrap
msgid " .sqml"
msgstr " .sqml"

#. type: tbl table
#: man-pages/man7/suffixes.7:234
#, no-wrap
msgid "SQML schema or query program"
msgstr "схема SQML или программа-запрос"

#. type: tbl table
#: man-pages/man7/suffixes.7:235
#, no-wrap
msgid " .sty"
msgstr " .sty"

#. type: tbl table
#: man-pages/man7/suffixes.7:235
#, no-wrap
msgid "LaTeX style files"
msgstr "файлы стилей LaTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:236
#, no-wrap
msgid " .sym"
msgstr " .sym"

#. type: tbl table
#: man-pages/man7/suffixes.7:236
#, no-wrap
msgid "Modula-2 compiled definition modules"
msgstr "скомпилированные модули определений Modula-2"

#. type: tbl table
#: man-pages/man7/suffixes.7:237
#, no-wrap
msgid " .tar"
msgstr " .tar"

#. type: tbl table
#: man-pages/man7/suffixes.7:237
#, no-wrap
msgid "archive created by the B<tar>(1) utility"
msgstr "архив, созданный утилитой B<tar>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:238
#, no-wrap
msgid " .tar.Z"
msgstr " .tar.Z"

#. type: tbl table
#: man-pages/man7/suffixes.7:238 man-pages/man7/suffixes.7:241
#, no-wrap
msgid "tar(1) archive compressed with B<compress>(1)"
msgstr "архив tar(1), сжатый с помощью B<compress>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:239
#, no-wrap
msgid " .tar.bz2"
msgstr " .tar.bz2"

#. type: tbl table
#: man-pages/man7/suffixes.7:239
#, no-wrap
msgid "tar(1) archive compressed with B<bzip2>(1)"
msgstr "архив tar(1), сжатый с помощью B<bzip2>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:240
#, no-wrap
msgid " .tar.gz"
msgstr " .tar.gz"

#. type: tbl table
#: man-pages/man7/suffixes.7:240
#, no-wrap
msgid "tar(1) archive compressed with B<gzip>(1)"
msgstr "архив tar(1), сжатый с помощью B<gzip>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:241
#, no-wrap
msgid " .taz"
msgstr " .taz"

#. type: tbl table
#: man-pages/man7/suffixes.7:242
#, no-wrap
msgid " .tcl"
msgstr " .tcl"

#. type: tbl table
#: man-pages/man7/suffixes.7:242
#, no-wrap
msgid "tcl source code"
msgstr "исходный код на языке tcl"

#. type: tbl table
#: man-pages/man7/suffixes.7:243
#, no-wrap
msgid " .tex"
msgstr " .tex"

#. type: tbl table
#: man-pages/man7/suffixes.7:243
#, no-wrap
msgid "TeX or LaTeX source"
msgstr "исходный код на языке TeX или LaTeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:244
#, no-wrap
msgid " .texi"
msgstr " .texi"

#. type: tbl table
#: man-pages/man7/suffixes.7:244
#, no-wrap
msgid "equivalent to I<.texinfo>"
msgstr "эквивалентно I<.texinfo>"

#. type: tbl table
#: man-pages/man7/suffixes.7:245
#, no-wrap
msgid " .texinfo"
msgstr " .texinfo"

#. type: tbl table
#: man-pages/man7/suffixes.7:245
#, no-wrap
msgid "Texinfo documentation source"
msgstr "исходный код документации в формате Texinfo"

#. type: tbl table
#: man-pages/man7/suffixes.7:246
#, no-wrap
msgid " .text"
msgstr " .text"

#. type: tbl table
#: man-pages/man7/suffixes.7:246
#, no-wrap
msgid "text file"
msgstr "текстовый файл"

#. type: tbl table
#: man-pages/man7/suffixes.7:247
#, no-wrap
msgid " .tfm"
msgstr " .tfm"

#. type: tbl table
#: man-pages/man7/suffixes.7:247
#, no-wrap
msgid "TeX font metric file"
msgstr "файл метрики шрифта TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:248
#, no-wrap
msgid " .tgz"
msgstr " .tgz"

#. type: tbl table
#: man-pages/man7/suffixes.7:248
#, no-wrap
msgid "tar archive compressed with B<gzip>(1)"
msgstr "архив tar, сжатый с помощью B<gzip>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:249
#, no-wrap
msgid " .tif"
msgstr " .tif"

#. type: tbl table
#: man-pages/man7/suffixes.7:249
#, no-wrap
msgid "poor man's I<.tiff>"
msgstr "сокращение I<.tiff>"

#. type: tbl table
#: man-pages/man7/suffixes.7:250
#, no-wrap
msgid " .tiff"
msgstr " .tiff"

#. type: tbl table
#: man-pages/man7/suffixes.7:250
#, no-wrap
msgid "Tagged Image File Format"
msgstr "размеченный формат файлов изображений (TIFF)"

#. type: tbl table
#: man-pages/man7/suffixes.7:251
#, no-wrap
msgid " .tk"
msgstr " .tk"

#. type: tbl table
#: man-pages/man7/suffixes.7:251
#, no-wrap
msgid "tcl/tk script"
msgstr "сценарий на tcl/tk"

#. type: tbl table
#: man-pages/man7/suffixes.7:252
#, no-wrap
msgid " .tmp"
msgstr " .tmp"

#. type: tbl table
#: man-pages/man7/suffixes.7:252
#, no-wrap
msgid "temporary file"
msgstr "временный файл"

#. type: tbl table
#: man-pages/man7/suffixes.7:253
#, no-wrap
msgid " .tmpl"
msgstr " .tmpl"

#. type: tbl table
#: man-pages/man7/suffixes.7:253
#, no-wrap
msgid "template files"
msgstr "файлы шаблонов"

#. type: tbl table
#: man-pages/man7/suffixes.7:254
#, no-wrap
msgid " .txt"
msgstr " .txt"

#. type: tbl table
#: man-pages/man7/suffixes.7:254
#, no-wrap
msgid "equivalent to I<.text>"
msgstr "эквивалентно I<.text>"

#. type: tbl table
#: man-pages/man7/suffixes.7:255
#, no-wrap
msgid " .uu"
msgstr " .uu"

#. type: tbl table
#: man-pages/man7/suffixes.7:255
#, no-wrap
msgid "equivalent to I<.uue>"
msgstr "эквивалентно I<.uue>"

#. type: tbl table
#: man-pages/man7/suffixes.7:256
#, no-wrap
msgid " .uue"
msgstr " .uue"

#. type: tbl table
#: man-pages/man7/suffixes.7:256
#, no-wrap
msgid "binary file encoded with B<uuencode>(1)"
msgstr "двоичный файл, закодированный с помощью B<uuencode>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:257
#, no-wrap
msgid " .vf"
msgstr " .vf"

#. type: tbl table
#: man-pages/man7/suffixes.7:257
#, no-wrap
msgid "TeX virtual font file"
msgstr "файл виртуального шрифта TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:258
#, no-wrap
msgid " .vpl"
msgstr " .vpl"

#. type: tbl table
#: man-pages/man7/suffixes.7:258
#, no-wrap
msgid "TeX virtual property list file"
msgstr "файл виртуального списка свойств TeX"

#. type: tbl table
#: man-pages/man7/suffixes.7:259
#, no-wrap
msgid " .w"
msgstr " .w"

#. type: tbl table
#: man-pages/man7/suffixes.7:259
#, no-wrap
msgid "Silvio Levi's CWEB"
msgstr "CWEB Сильвио Леви"

#. type: tbl table
#: man-pages/man7/suffixes.7:260
#, no-wrap
msgid " .wav"
msgstr " .wav"

#. type: tbl table
#: man-pages/man7/suffixes.7:260
#, no-wrap
msgid "wave sound file"
msgstr "звуковой файл"

#. type: tbl table
#: man-pages/man7/suffixes.7:261
#, no-wrap
msgid " .web"
msgstr " .web"

#. type: tbl table
#: man-pages/man7/suffixes.7:261
#, no-wrap
msgid "Donald Knuth's WEB"
msgstr "WEB Дональда Кнута"

#. type: tbl table
#: man-pages/man7/suffixes.7:262
#, no-wrap
msgid " .wml"
msgstr " .wml"

#. type: tbl table
#: man-pages/man7/suffixes.7:262
#, no-wrap
msgid "Source file for Web Meta Language"
msgstr "исходный файл для Web Meta Language"

#. type: tbl table
#: man-pages/man7/suffixes.7:263
#, no-wrap
msgid " .xbm"
msgstr " .xbm"

#. type: tbl table
#: man-pages/man7/suffixes.7:263
#, no-wrap
msgid "X11 bitmap source"
msgstr "исходный текст для растровых изображений X11"

#. type: tbl table
#: man-pages/man7/suffixes.7:264
#, no-wrap
msgid " .xcf"
msgstr " .xcf"

#. type: tbl table
#: man-pages/man7/suffixes.7:264
#, no-wrap
msgid "GIMP graphic"
msgstr "графика GIMP"

#. type: tbl table
#: man-pages/man7/suffixes.7:265
#, no-wrap
msgid " .xml"
msgstr " .xml"

#. type: tbl table
#: man-pages/man7/suffixes.7:265
#, no-wrap
msgid "eXtended Markup Language file"
msgstr "файл на языке eXtended Markup Language"

#. type: tbl table
#: man-pages/man7/suffixes.7:266
#, no-wrap
msgid " .xpm"
msgstr " .xpm"

#. type: tbl table
#: man-pages/man7/suffixes.7:266
#, no-wrap
msgid "X11 pixmap source"
msgstr "исходный код изображений X11"

#. type: tbl table
#: man-pages/man7/suffixes.7:267
#, no-wrap
msgid " .xs"
msgstr " .xs"

#. type: tbl table
#: man-pages/man7/suffixes.7:267
#, no-wrap
msgid "Perl xsub file produced by h2xs"
msgstr "файл Perl xsub, создаваемый h2xs"

#. type: tbl table
#: man-pages/man7/suffixes.7:268
#, no-wrap
msgid " .xsl"
msgstr " .xsl"

#. type: tbl table
#: man-pages/man7/suffixes.7:268
#, no-wrap
msgid "XSL stylesheet"
msgstr "таблица стилей XSL"

#. type: tbl table
#: man-pages/man7/suffixes.7:269
#, no-wrap
msgid " .y"
msgstr " .y"

#. type: tbl table
#: man-pages/man7/suffixes.7:269
#, no-wrap
msgid "B<yacc>(1) or B<bison>(1) (parser generator) files"
msgstr "файлы для B<yacc>(1) или B<bison>(1) (генератор разборщика)"

#. type: tbl table
#: man-pages/man7/suffixes.7:270
#, no-wrap
msgid " .z"
msgstr " .z"

#. type: tbl table
#: man-pages/man7/suffixes.7:270
#, no-wrap
msgid "File compressed using B<pack>(1) (or an old B<gzip>(1))"
msgstr "файл, сжатый с помощью B<pack>(1) (или старой версией B<gzip>(1))"

#. type: tbl table
#: man-pages/man7/suffixes.7:271
#, no-wrap
msgid " .zip"
msgstr " .zip"

#. type: tbl table
#: man-pages/man7/suffixes.7:271
#, no-wrap
msgid "B<zip>(1) archive"
msgstr "архив B<zip>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:272
#, no-wrap
msgid " .zoo"
msgstr " .zoo"

#. type: tbl table
#: man-pages/man7/suffixes.7:272
#, no-wrap
msgid "B<zoo>(1) archive"
msgstr "архив B<zoo>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:273
#, no-wrap
msgid " ~"
msgstr " ~"

#. type: tbl table
#: man-pages/man7/suffixes.7:273
#, no-wrap
msgid "Emacs or B<patch>(1) backup file"
msgstr "резервная копия файла Emacs или B<patch>(1)"

#. type: tbl table
#: man-pages/man7/suffixes.7:274
#, no-wrap
msgid " rc"
msgstr " rc"

#. type: tbl table
#: man-pages/man7/suffixes.7:274
#, no-wrap
msgid "startup (`run control') file, e.g., I<.newsrc>"
msgstr "файл запуска («run control»), например I<.newsrc>"

#. type: Plain text
#: man-pages/man7/suffixes.7:278
msgid "General UNIX conventions."
msgstr "Условные обозначения UNIX."

#. type: Plain text
#: man-pages/man7/suffixes.7:280
msgid "This list is not exhaustive."
msgstr "Этот список далеко не полон."

#. type: Plain text
#: man-pages/man7/suffixes.7:282
msgid "B<file>(1), B<make>(1)"
msgstr "B<file>(1), B<make>(1)"

#. type: TH
#: man-pages/man7/signal-safety.7:25
#, no-wrap
msgid "SIGNAL-SAFETY"
msgstr "SIGNAL-SAFETY"

#. type: TH
#: man-pages/man7/signal-safety.7:25
#, no-wrap
msgid "2017-03-13"
msgstr "2017-03-13"

#. type: Plain text
#: man-pages/man7/signal-safety.7:28
msgid "signal-safety - async-signal-safe functions"
msgstr "signal-safety - функции async-signal-safe"

#. type: Plain text
#: man-pages/man7/signal-safety.7:37
msgid ""
"An I<async-signal-safe> function is one that can be safely called from "
"within a signal handler.  Many functions are I<not> async-signal-safe.  In "
"particular, nonreentrant functions are generally unsafe to call from a "
"signal handler."
msgstr ""
"Функцией I<async-signal-safe> называется функция, которую безопасно вызывать "
"внутри обработчика сигналов. Многие функции I<не> являются async-signal-"
"safe. В частности, нереентерабельные функции, обычно, небезопасно вызывать в "
"обработчиках сигналов."

#. type: Plain text
#: man-pages/man7/signal-safety.7:43
msgid ""
"The kinds of issues that render a function unsafe can be quickly understood "
"when one considers the implementation of the I<stdio> library, all of whose "
"functions are not async-signal-safe."
msgstr ""
"Виды проблем, которые делают функцию небезопасной, можно быстро понять на "
"примере реализации библиотеки I<stdio>, все функции которой являются не "
"async-signal-safe."

#. type: Plain text
#: man-pages/man7/signal-safety.7:60
msgid ""
"When performing buffered I/O on a file, the I<stdio> functions must maintain "
"a statically allocated data buffer along with associated counters and "
"indexes (or pointers)  that record the amount of data and the current "
"position in the buffer.  Suppose that the main program is in the middle of a "
"call to a I<stdio> function such as B<printf>(3)  where the buffer and "
"associated variables have been partially updated.  If, at that moment, the "
"program is interrupted by a signal handler that also calls B<printf>(3), "
"then the second call to B<printf>(3)  will operate on inconsistent data, "
"with unpredictable results."
msgstr ""
"При выполнении буферизируемого ввода-вывода в файл функции I<stdio> должны "
"вести статически выделенный буфер и связанные с ним счётчики и индексы (или "
"указатели), содержащие количество данных и текущее положение в буфере. "
"Предположим, что основная программа находится в середине вызова функции "
"I<stdio>, например B<printf>(3), которая обновляет часть буфера и связанных "
"переменных. Если в этот момент программа прервётся обработчиком сигнала, "
"который также вызывает B<printf>(3), то второй вызов B<printf>(3) будет "
"работать с не целостными данными и результат будет непредсказуем."

#. type: Plain text
#: man-pages/man7/signal-safety.7:62
msgid ""
"To avoid problems with unsafe functions, there are two possible choices:"
msgstr ""
"Чтобы не возникало проблем с небезопасными функциями есть два варианта:"

#. type: Plain text
#: man-pages/man7/signal-safety.7:68
msgid ""
"Ensure that (a) the signal handler calls only async-signal-safe functions, "
"and (b) the signal handler itself is reentrant with respect to global "
"variables in the main program."
msgstr ""
"Следить, чтобы (а) обработчик сигнала вызывал только функции async-signal-"
"safe, и (б) сам обработчик сигнала был реентерабельным по отношению к "
"глобальным переменным основной программы."

#. type: Plain text
#: man-pages/man7/signal-safety.7:72
msgid ""
"Block signal delivery in the main program when calling functions that are "
"unsafe or operating on global data that is also accessed by the signal "
"handler."
msgstr ""
"Блокировать доставку сигнала в основной программе при вызове небезопасных "
"функций или при работе с глобальными данными, доступными из обработчика "
"сигнала."

#. type: Plain text
#: man-pages/man7/signal-safety.7:75
msgid ""
"Generally, the second choice is difficult in programs of any complexity, so "
"the first choice is taken."
msgstr ""
"Обычно, второй вариант труден для программ любой сложности, поэтому "
"используется первый вариант."

#. type: Plain text
#: man-pages/man7/signal-safety.7:84
msgid ""
"POSIX.1 specifies a set of functions that an implementation must make async-"
"signal-safe.  (An implementation may provide safe implementations of "
"additional functions, but this is not required by the standard and other "
"implementations may not provide the same guarantees.)  In general, a "
"function is async-signal-safe either because it is reentrant or because it "
"is atomic with respect to signals (i.e., its execution can't be interrupted "
"by a signal handler)."
msgstr ""
"В POSIX.1 определён набор функций, реализация которых должна быть async-"
"signal-safe (реализация может предоставлять безопасную реализацию и других "
"функций, но это не требуется стандартом и другие реализации могут не "
"предоставлять те же гарантии) Обычно, функция является async-signal-safe или "
"потому что она реентерабельная, или из-за её атомарности по отношению к "
"сигналам (т. е., её выполнение не может быть прервано обработчиком сигнала)."

#. type: Plain text
#: man-pages/man7/signal-safety.7:90
msgid ""
"The set of functions required to be async-signal-safe by POSIX.1 is shown in "
"the following table.  The functions not otherwise noted were required to be "
"async-signal-safe in POSIX.1-2001; the table details changes in the "
"subsequent standards."
msgstr ""
"Набор функций async-signal-safe по POSIX.1 показан в таблице далее. Функции, "
"если не указано обратное, являются async-signal-safe и по POSIX.1-2001; в "
"таблице отмечены изменения в последующих стандартах."

#. type: tbl table
#: man-pages/man7/signal-safety.7:94
#, no-wrap
msgid "Function"
msgstr "функция"

#. type: tbl table
#: man-pages/man7/signal-safety.7:95
#, no-wrap
msgid "B<abort>(3)"
msgstr "B<abort>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:95
#, no-wrap
msgid "Added in POSIX.1-2003"
msgstr "Добавлена в POSIX.1-2003"

#. type: tbl table
#: man-pages/man7/signal-safety.7:96
#, no-wrap
msgid "B<accept>(2)"
msgstr "B<accept>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:97
#, no-wrap
msgid "B<access>(2)"
msgstr "B<access>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:98
#, no-wrap
msgid "B<aio_error>(3)"
msgstr "B<aio_error>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:99
#, no-wrap
msgid "B<aio_return>(3)"
msgstr "B<aio_return>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:100
#, no-wrap
msgid "B<aio_suspend>(3)"
msgstr "B<aio_suspend>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:100 man-pages/man7/signal-safety.7:117
#: man-pages/man7/signal-safety.7:132
#, no-wrap
msgid "See notes below"
msgstr "смотрите замечания далее"

#. type: tbl table
#: man-pages/man7/signal-safety.7:101
#, no-wrap
msgid "B<alarm>(2)"
msgstr "B<alarm>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:102
#, no-wrap
msgid "B<bind>(2)"
msgstr "B<bind>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:103
#, no-wrap
msgid "B<cfgetispeed>(3)"
msgstr "B<cfgetispeed>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:104
#, no-wrap
msgid "B<cfgetospeed>(3)"
msgstr "B<cfgetospeed>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:105
#, no-wrap
msgid "B<cfsetispeed>(3)"
msgstr "B<cfsetispeed>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:106
#, no-wrap
msgid "B<cfsetospeed>(3)"
msgstr "B<cfsetospeed>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:107
#, no-wrap
msgid "B<chdir>(2)"
msgstr "B<chdir>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:108
#, no-wrap
msgid "B<chmod>(2)"
msgstr "B<chmod>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:109
#, no-wrap
msgid "B<chown>(2)"
msgstr "B<chown>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:110
#, no-wrap
msgid "B<clock_gettime>(2)"
msgstr "B<clock_gettime>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:111
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:112
#, no-wrap
msgid "B<connect>(2)"
msgstr "B<connect>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:113
#, no-wrap
msgid "B<creat>(2)"
msgstr "B<creat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:114
#, no-wrap
msgid "B<dup>(2)"
msgstr "B<dup>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:115
#, no-wrap
msgid "B<dup2>(2)"
msgstr "B<dup2>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:116
#, no-wrap
msgid "B<execl>(3)"
msgstr "B<execl>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:116
#, no-wrap
msgid "Added in POSIX.1-2008; see notes below"
msgstr "Добавлена в POSIX.1-2008; смотрите замечания ниже"

#. type: tbl table
#: man-pages/man7/signal-safety.7:117
#, no-wrap
msgid "B<execle>(3)"
msgstr "B<execle>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:118
#, no-wrap
msgid "B<execv>(3)"
msgstr "B<execv>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:118 man-pages/man7/signal-safety.7:122
#: man-pages/man7/signal-safety.7:125 man-pages/man7/signal-safety.7:127
#: man-pages/man7/signal-safety.7:130 man-pages/man7/signal-safety.7:134
#: man-pages/man7/signal-safety.7:137 man-pages/man7/signal-safety.7:153
#: man-pages/man7/signal-safety.7:165 man-pages/man7/signal-safety.7:167
#: man-pages/man7/signal-safety.7:168 man-pages/man7/signal-safety.7:169
#: man-pages/man7/signal-safety.7:173 man-pages/man7/signal-safety.7:185
#: man-pages/man7/signal-safety.7:190 man-pages/man7/signal-safety.7:240
#: man-pages/man7/signal-safety.7:257 man-pages/man7/signal-safety.7:259
#: man-pages/man7/signal-safety.7:260
#, no-wrap
msgid "Added in POSIX.1-2008"
msgstr "Добавлена в POSIX.1-2008"

#. type: tbl table
#: man-pages/man7/signal-safety.7:119
#, no-wrap
msgid "B<execve>(2)"
msgstr "B<execve>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:120
#, no-wrap
msgid "B<_exit>(2)"
msgstr "B<_exit>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:121
#, no-wrap
msgid "B<_Exit>(2)"
msgstr "B<_Exit>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:122
#, no-wrap
msgid "B<faccessat>(2)"
msgstr "B<faccessat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:123
#, no-wrap
msgid "B<fchdir>(2)"
msgstr "B<fchdir>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:123 man-pages/man7/signal-safety.7:179
#: man-pages/man7/signal-safety.7:180 man-pages/man7/signal-safety.7:181
#, no-wrap
msgid "Added in POSIX.1-2013"
msgstr "Добавлена в POSIX.1-2013"

#. type: tbl table
#: man-pages/man7/signal-safety.7:124
#, no-wrap
msgid "B<fchmod>(2)"
msgstr "B<fchmod>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:125
#, no-wrap
msgid "B<fchmodat>(2)"
msgstr "B<fchmodat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:126
#, no-wrap
msgid "B<fchown>(2)"
msgstr "B<fchown>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:127
#, no-wrap
msgid "B<fchownat>(2)"
msgstr "B<fchownat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:128
#, no-wrap
msgid "B<fcntl>(2)"
msgstr "B<fcntl>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:129
#, no-wrap
msgid "B<fdatasync>(2)"
msgstr "B<fdatasync>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:130
#, no-wrap
msgid "B<fexecve>(3)"
msgstr "B<fexecve>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:131
#, no-wrap
msgid "B<ffs>(3)"
msgstr "B<ffs>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:131 man-pages/man7/signal-safety.7:149
#: man-pages/man7/signal-safety.7:150 man-pages/man7/signal-safety.7:158
#: man-pages/man7/signal-safety.7:159 man-pages/man7/signal-safety.7:160
#: man-pages/man7/signal-safety.7:161 man-pages/man7/signal-safety.7:162
#: man-pages/man7/signal-safety.7:163 man-pages/man7/signal-safety.7:170
#: man-pages/man7/signal-safety.7:171 man-pages/man7/signal-safety.7:222
#: man-pages/man7/signal-safety.7:223 man-pages/man7/signal-safety.7:224
#: man-pages/man7/signal-safety.7:225 man-pages/man7/signal-safety.7:226
#: man-pages/man7/signal-safety.7:227 man-pages/man7/signal-safety.7:228
#: man-pages/man7/signal-safety.7:229 man-pages/man7/signal-safety.7:230
#: man-pages/man7/signal-safety.7:231 man-pages/man7/signal-safety.7:232
#: man-pages/man7/signal-safety.7:233 man-pages/man7/signal-safety.7:234
#: man-pages/man7/signal-safety.7:235 man-pages/man7/signal-safety.7:236
#: man-pages/man7/signal-safety.7:237 man-pages/man7/signal-safety.7:238
#: man-pages/man7/signal-safety.7:263 man-pages/man7/signal-safety.7:264
#: man-pages/man7/signal-safety.7:265 man-pages/man7/signal-safety.7:266
#: man-pages/man7/signal-safety.7:267 man-pages/man7/signal-safety.7:268
#: man-pages/man7/signal-safety.7:269 man-pages/man7/signal-safety.7:270
#: man-pages/man7/signal-safety.7:271 man-pages/man7/signal-safety.7:272
#: man-pages/man7/signal-safety.7:273 man-pages/man7/signal-safety.7:274
#: man-pages/man7/signal-safety.7:275 man-pages/man7/signal-safety.7:276
#: man-pages/man7/signal-safety.7:277 man-pages/man7/signal-safety.7:278
#: man-pages/man7/signal-safety.7:279 man-pages/man7/signal-safety.7:280
#: man-pages/man7/signal-safety.7:281 man-pages/man7/signal-safety.7:282
#: man-pages/man7/signal-safety.7:283 man-pages/man7/signal-safety.7:284
#, no-wrap
msgid "Added in POSIX.1-2016"
msgstr "Добавлена в POSIX.1-2016"

#. type: tbl table
#: man-pages/man7/signal-safety.7:132
#, no-wrap
msgid "B<fork>(2)"
msgstr "B<fork>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:133
#, no-wrap
msgid "B<fstat>(2)"
msgstr "B<fstat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:134
#, no-wrap
msgid "B<fstatat>(2)"
msgstr "B<fstatat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:135
#, no-wrap
msgid "B<fsync>(2)"
msgstr "B<fsync>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:136
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr "B<ftruncate>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:137
#, no-wrap
msgid "B<futimens>(3)"
msgstr "B<futimens>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:138
#, no-wrap
msgid "B<getegid>(2)"
msgstr "B<getegid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:139
#, no-wrap
msgid "B<geteuid>(2)"
msgstr "B<geteuid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:140
#, no-wrap
msgid "B<getgid>(2)"
msgstr "B<getgid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:141
#, no-wrap
msgid "B<getgroups>(2)"
msgstr "B<getgroups>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:142
#, no-wrap
msgid "B<getpeername>(2)"
msgstr "B<getpeername>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:143
#, no-wrap
msgid "B<getpgrp>(2)"
msgstr "B<getpgrp>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:144
#, no-wrap
msgid "B<getpid>(2)"
msgstr "B<getpid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:145
#, no-wrap
msgid "B<getppid>(2)"
msgstr "B<getppid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:146
#, no-wrap
msgid "B<getsockname>(2)"
msgstr "B<getsockname>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:147
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr "B<getsockopt>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:148
#, no-wrap
msgid "B<getuid>(2)"
msgstr "B<getuid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:149
#, no-wrap
msgid "B<htonl>(3)"
msgstr "B<htonl>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:150
#, no-wrap
msgid "B<htons>(3)"
msgstr "B<htons>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:152
#, no-wrap
msgid "B<link>(2)"
msgstr "B<link>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:153
#, no-wrap
msgid "B<linkat>(2)"
msgstr "B<linkat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:154
#, no-wrap
msgid "B<listen>(2)"
msgstr "B<listen>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:155
#, no-wrap
msgid "B<longjmp>(3)"
msgstr "B<longjmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:155 man-pages/man7/signal-safety.7:209
#, no-wrap
msgid "Added in POSIX.1-2016; see notes below"
msgstr "Добавлена в POSIX.1-2016; смотрите замечания ниже"

#. type: tbl table
#: man-pages/man7/signal-safety.7:156
#, no-wrap
msgid "B<lseek>(2)"
msgstr "B<lseek>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:157
#, no-wrap
msgid "B<lstat>(2)"
msgstr "B<lstat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:158
#, no-wrap
msgid "B<memccpy>(3)"
msgstr "B<memccpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:159
#, no-wrap
msgid "B<memchr>(3)"
msgstr "B<memchr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:160
#, no-wrap
msgid "B<memcmp>(3)"
msgstr "B<memcmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:161
#, no-wrap
msgid "B<memcpy>(3)"
msgstr "B<memcpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:162
#, no-wrap
msgid "B<memmove>(3)"
msgstr "B<memmove>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:163
#, no-wrap
msgid "B<memset>(3)"
msgstr "B<memset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:164
#, no-wrap
msgid "B<mkdir>(2)"
msgstr "B<mkdir>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:165
#, no-wrap
msgid "B<mkdirat>(2)"
msgstr "B<mkdirat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:166
#, no-wrap
msgid "B<mkfifo>(3)"
msgstr "B<mkfifo>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:167
#, no-wrap
msgid "B<mkfifoat>(3)"
msgstr "B<mkfifoat>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:168
#, no-wrap
msgid "B<mknod>(2)"
msgstr "B<mknod>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:169
#, no-wrap
msgid "B<mknodat>(2)"
msgstr "B<mknodat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:170
#, no-wrap
msgid "B<ntohl>(3)"
msgstr "B<ntohl>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:171
#, no-wrap
msgid "B<ntohs>(3)"
msgstr "B<ntohs>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:172
#, no-wrap
msgid "B<open>(2)"
msgstr "B<open>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:173
#, no-wrap
msgid "B<openat>(2)"
msgstr "B<openat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:175
#, no-wrap
msgid "B<pipe>(2)"
msgstr "B<pipe>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:176
#, no-wrap
msgid "B<poll>(2)"
msgstr "B<poll>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:177
#, no-wrap
msgid "B<posix_trace_event>(3)"
msgstr "B<posix_trace_event>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:178
#, no-wrap
msgid "B<pselect>(2)"
msgstr "B<pselect>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:180
#, no-wrap
msgid "B<pthread_self>(3)"
msgstr "B<pthread_self>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:181
#, no-wrap
msgid "B<pthread_sigmask>(3)"
msgstr "B<pthread_sigmask>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:183
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:184
#, no-wrap
msgid "B<readlink>(2)"
msgstr "B<readlink>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:185
#, no-wrap
msgid "B<readlinkat>(2)"
msgstr "B<readlinkat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:186
#, no-wrap
msgid "B<recv>(2)"
msgstr "B<recv>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:187
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr "B<recvfrom>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:188
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr "B<recvmsg>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:189
#, no-wrap
msgid "B<rename>(2)"
msgstr "B<rename>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:190
#, no-wrap
msgid "B<renameat>(2)"
msgstr "B<renameat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:191
#, no-wrap
msgid "B<rmdir>(2)"
msgstr "B<rmdir>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:192
#, no-wrap
msgid "B<select>(2)"
msgstr "B<select>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:193
#, no-wrap
msgid "B<sem_post>(3)"
msgstr "B<sem_post>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:194
#, no-wrap
msgid "B<send>(2)"
msgstr "B<send>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:195
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr "B<sendmsg>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:196
#, no-wrap
msgid "B<sendto>(2)"
msgstr "B<sendto>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:197
#, no-wrap
msgid "B<setgid>(2)"
msgstr "B<setgid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:198
#, no-wrap
msgid "B<setpgid>(2)"
msgstr "B<setpgid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:199
#, no-wrap
msgid "B<setsid>(2)"
msgstr "B<setsid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:200
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr "B<setsockopt>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:201
#, no-wrap
msgid "B<setuid>(2)"
msgstr "B<setuid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:202
#, no-wrap
msgid "B<shutdown>(2)"
msgstr "B<shutdown>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:204
#, no-wrap
msgid "B<sigaddset>(3)"
msgstr "B<sigaddset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:205
#, no-wrap
msgid "B<sigdelset>(3)"
msgstr "B<sigdelset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:206
#, no-wrap
msgid "B<sigemptyset>(3)"
msgstr "B<sigemptyset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:207
#, no-wrap
msgid "B<sigfillset>(3)"
msgstr "B<sigfillset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:208
#, no-wrap
msgid "B<sigismember>(3)"
msgstr "B<sigismember>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:209
#, no-wrap
msgid "B<siglongjmp>(3)"
msgstr "B<siglongjmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:210
#, no-wrap
msgid "B<signal>(2)"
msgstr "B<signal>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:211
#, no-wrap
msgid "B<sigpause>(3)"
msgstr "B<sigpause>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:214
#, no-wrap
msgid "B<sigqueue>(2)"
msgstr "B<sigqueue>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:215
#, no-wrap
msgid "B<sigset>(3)"
msgstr "B<sigset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:217
#, no-wrap
msgid "B<sleep>(3)"
msgstr "B<sleep>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:218
#, no-wrap
msgid "B<sockatmark>(3)"
msgstr "B<sockatmark>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:218
#, no-wrap
msgid "Added in POSIX.1-2004"
msgstr "Добавлена в POSIX.1-2004"

#. type: tbl table
#: man-pages/man7/signal-safety.7:219
#, no-wrap
msgid "B<socket>(2)"
msgstr "B<socket>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:220
#, no-wrap
msgid "B<socketpair>(2)"
msgstr "B<socketpair>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:221
#, no-wrap
msgid "B<stat>(2)"
msgstr "B<stat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:222
#, no-wrap
msgid "B<stpcpy>(3)"
msgstr "B<stpcpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:223
#, no-wrap
msgid "B<stpncpy>(3)"
msgstr "B<stpncpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:224
#, no-wrap
msgid "B<strcat>(3)"
msgstr "B<strcat>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:225
#, no-wrap
msgid "B<strchr>(3)"
msgstr "B<strchr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:226
#, no-wrap
msgid "B<strcmp>(3)"
msgstr "B<strcmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:227
#, no-wrap
msgid "B<strcpy>(3)"
msgstr "B<strcpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:228
#, no-wrap
msgid "B<strcspn>(3)"
msgstr "B<strcspn>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:229
#, no-wrap
msgid "B<strlen>(3)"
msgstr "B<strlen>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:230
#, no-wrap
msgid "B<strncat>(3)"
msgstr "B<strncat>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:231
#, no-wrap
msgid "B<strncmp>(3)"
msgstr "B<strncmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:232
#, no-wrap
msgid "B<strncpy>(3)"
msgstr "B<strncpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:233
#, no-wrap
msgid "B<strnlen>(3)"
msgstr "B<strnlen>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:234
#, no-wrap
msgid "B<strpbrk>(3)"
msgstr "B<strpbrk>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:235
#, no-wrap
msgid "B<strrchr>(3)"
msgstr "B<strrchr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:236
#, no-wrap
msgid "B<strspn>(3)"
msgstr "B<strspn>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:237
#, no-wrap
msgid "B<strstr>(3)"
msgstr "B<strstr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:238
#, no-wrap
msgid "B<strtok_r>(3)"
msgstr "B<strtok_r>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:239
#, no-wrap
msgid "B<symlink>(2)"
msgstr "B<symlink>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:240
#, no-wrap
msgid "B<symlinkat>(2)"
msgstr "B<symlinkat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:241
#, no-wrap
msgid "B<tcdrain>(3)"
msgstr "B<tcdrain>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:242
#, no-wrap
msgid "B<tcflow>(3)"
msgstr "B<tcflow>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:243
#, no-wrap
msgid "B<tcflush>(3)"
msgstr "B<tcflush>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:244
#, no-wrap
msgid "B<tcgetattr>(3)"
msgstr "B<tcgetattr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:245
#, no-wrap
msgid "B<tcgetpgrp>(3)"
msgstr "B<tcgetpgrp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:246
#, no-wrap
msgid "B<tcsendbreak>(3)"
msgstr "B<tcsendbreak>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:247
#, no-wrap
msgid "B<tcsetattr>(3)"
msgstr "B<tcsetattr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:248
#, no-wrap
msgid "B<tcsetpgrp>(3)"
msgstr "B<tcsetpgrp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:249
#, no-wrap
msgid "B<time>(2)"
msgstr "B<time>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:250
#, no-wrap
msgid "B<timer_getoverrun>(2)"
msgstr "B<timer_getoverrun>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:251
#, no-wrap
msgid "B<timer_gettime>(2)"
msgstr "B<timer_gettime>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:252
#, no-wrap
msgid "B<timer_settime>(2)"
msgstr "B<timer_settime>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:253
#, no-wrap
msgid "B<times>(2)"
msgstr "B<times>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:254
#, no-wrap
msgid "B<umask>(2)"
msgstr "B<umask>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:255
#, no-wrap
msgid "B<uname>(2)"
msgstr "B<uname>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:256
#, no-wrap
msgid "B<unlink>(2)"
msgstr "B<unlink>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:257
#, no-wrap
msgid "B<unlinkat>(2)"
msgstr "B<unlinkat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:258
#, no-wrap
msgid "B<utime>(2)"
msgstr "B<utime>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:259
#, no-wrap
msgid "B<utimensat>(2)"
msgstr "B<utimensat>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:260
#, no-wrap
msgid "B<utimes>(2)"
msgstr "B<utimes>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:261
#, no-wrap
msgid "B<wait>(2)"
msgstr "B<wait>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:262
#, no-wrap
msgid "B<waitpid>(2)"
msgstr "B<waitpid>(2)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:263
#, no-wrap
msgid "B<wcpcpy>(3)"
msgstr "B<wcpcpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:264
#, no-wrap
msgid "B<wcpncpy>(3)"
msgstr "B<wcpncpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:265
#, no-wrap
msgid "B<wcscat>(3)"
msgstr "B<wcscat>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:266
#, no-wrap
msgid "B<wcschr>(3)"
msgstr "B<wcschr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:267
#, no-wrap
msgid "B<wcscmp>(3)"
msgstr "B<wcscmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:268
#, no-wrap
msgid "B<wcscpy>(3)"
msgstr "B<wcscpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:269
#, no-wrap
msgid "B<wcscspn>(3)"
msgstr "B<wcscspn>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:270
#, no-wrap
msgid "B<wcslen>(3)"
msgstr "B<wcslen>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:271
#, no-wrap
msgid "B<wcsncat>(3)"
msgstr "B<wcsncat>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:272
#, no-wrap
msgid "B<wcsncmp>(3)"
msgstr "B<wcsncmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:273
#, no-wrap
msgid "B<wcsncpy>(3)"
msgstr "B<wcsncpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:274
#, no-wrap
msgid "B<wcsnlen>(3)"
msgstr "B<wcsnlen>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:275
#, no-wrap
msgid "B<wcspbrk>(3)"
msgstr "B<wcspbrk>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:276
#, no-wrap
msgid "B<wcsrchr>(3)"
msgstr "B<wcsrchr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:277
#, no-wrap
msgid "B<wcsspn>(3)"
msgstr "B<wcsspn>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:278
#, no-wrap
msgid "B<wcsstr>(3)"
msgstr "B<wcsstr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:279
#, no-wrap
msgid "B<wcstok>(3)"
msgstr "B<wcstok>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:280
#, no-wrap
msgid "B<wmemchr>(3)"
msgstr "B<wmemchr>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:281
#, no-wrap
msgid "B<wmemcmp>(3)"
msgstr "B<wmemcmp>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:282
#, no-wrap
msgid "B<wmemcpy>(3)"
msgstr "B<wmemcpy>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:283
#, no-wrap
msgid "B<wmemmove>(3)"
msgstr "B<wmemmove>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:284
#, no-wrap
msgid "B<wmemset>(3)"
msgstr "B<wmemset>(3)"

#. type: tbl table
#: man-pages/man7/signal-safety.7:285
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: man-pages/man7/signal-safety.7:289
msgid "Notes:"
msgstr "Замечания:"

#. type: Plain text
#: man-pages/man7/signal-safety.7:296
msgid ""
"POSIX.1-2001 and POSIX.1-2004 required the functions B<fpathconf>(3), "
"B<pathconf>(3), and B<sysconf>(3)  to be async-signal-safe, but this "
"requirement was removed in POSIX.1-2008."
msgstr ""
"В POSIX.1-2001 и POSIX.1-2004 требуется, чтобы функции B<fpathconf>(3), "
"B<pathconf>(3) и B<sysconf>(3) были async-signal-safe, но это требование "
"удалено в POSIX.1-2008."

#. type: Plain text
#: man-pages/man7/signal-safety.7:304
msgid ""
"If a signal handler interrupts the execution of an unsafe function, and the "
"handler terminates via a call to B<longjmp>(3)  or B<siglongjmp>(3)  and the "
"program subsequently calls an unsafe function, then the behavior of the "
"program is undefined."
msgstr ""
"Если обработчик сигнала прерывает выполнение небезопасной функции и "
"обработчик завершается вызовом B<longjmp>(3) или B<siglongjmp>(3) и далее "
"программа вызывает небезопасную функцию, то поведение программы "
"непредсказуемо."

#.  http://www.opengroup.org/austin/aardvark/latest/xshbug3.txt
#. type: Plain text
#: man-pages/man7/signal-safety.7:317
msgid ""
"POSIX.1-2003 clarified that if an application calls B<fork>(2)  from a "
"signal handler and any of the fork handlers registered by "
"B<pthread_atfork>(3)  calls a function that is not async-signal-safe, the "
"behavior is undefined.  A future revision of the standard is likely to "
"remove B<fork>(2)  from the list of async-signal-safe functions."
msgstr ""
"В POSIX.1-2003 уточнено, что если приложение вызывает B<fork>(2) из "
"обработчика сигнала и и зарегистрированный обработчик fork (с помощью "
"B<pthread_atfork>(3)) вызывает не async-signal-safe функцию, то поведение "
"непредсказуемо. Вероятно, в будущих версиях стандарта вызов B<fork>(2) будет "
"удалён из списка функций async-signal-safe."

#. type: SS
#: man-pages/man7/signal-safety.7:317
#, no-wrap
msgid "Deviations in the GNU C library"
msgstr "Отклонения в библиотеке GNU C"

#. type: Plain text
#: man-pages/man7/signal-safety.7:320
msgid ""
"The following known deviations from the standard occur in the GNU C library:"
msgstr "В библиотеке GNU C есть следующие известные отклонения от стандарта:"

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=19534
#. type: Plain text
#: man-pages/man7/signal-safety.7:330
msgid ""
"Before glibc 2.24, B<execl>(3)  and B<execle>(3)  employed B<realloc>(3)  "
"internally and were consequently not async-signal-safe.  This was fixed in "
"glibc 2.24."
msgstr ""
"До glibc 2.24 внутри B<execl>(3) и B<execle>(3) использовалась B<realloc>(3) "
"и поэтому они были не безопасны для асинхронных сигналов. Это было "
"исправлено в glibc 2.24."

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=13172
#. type: Plain text
#: man-pages/man7/signal-safety.7:337
msgid ""
"The glibc implementation of B<aio_suspend>(3)  is not async-signal-safe "
"because it uses B<pthread_mutex_lock>(3)  internally."
msgstr ""
"Реализация B<aio_suspend>(3) в glibc не является безопасной для асинхронных "
"сигналов, так как в ней используется B<pthread_mutex_lock>(3)."

#. type: Plain text
#: man-pages/man7/signal-safety.7:340
msgid "B<sigaction>(2), B<signal>(7), B<standards>(7)"
msgstr "B<sigaction>(2), B<signal>(7), B<standards>(7)"

#. type: TH
#: man-pages/man7/symlink.7:37
#, no-wrap
msgid "SYMLINK"
msgstr "SYMLINK"

#. type: TH
#: man-pages/man7/symlink.7:37
#, no-wrap
msgid "2016-10-08"
msgstr "2016-10-08"

#. type: Plain text
#: man-pages/man7/symlink.7:40
msgid "symlink - symbolic link handling"
msgstr "symlink - работа с символьными ссылками"

#. type: Plain text
#: man-pages/man7/symlink.7:44
msgid ""
"Symbolic links are files that act as pointers to other files.  To understand "
"their behavior, you must first understand how hard links work."
msgstr ""
"Символьные ссылки — это файлы, которые служат указателями на другие файлы. "
"Чтобы понять их работу, сперва вы должны понять как работают жёсткие ссылки."

#. type: Plain text
#: man-pages/man7/symlink.7:60
msgid ""
"A hard link to a file is indistinguishable from the original file because it "
"is a reference to the object underlying the original filename.  (To be "
"precise: each of the hard links to a file is a reference to the same I<inode "
"number>, where an inode number is an index into the inode table, which "
"contains metadata about all files on a filesystem.  See B<stat>(2).)  "
"Changes to a file are independent of the name used to reference the file.  "
"Hard links may not refer to directories (to prevent the possibility of loops "
"within the filesystem tree, which would confuse many programs)  and may not "
"refer to files on different filesystems (because inode numbers are not "
"unique across filesystems)."
msgstr ""
"Жёсткая ссылка на файл не отличима от оригинального файла, так как это "
"ссылка на объект, на который указывает оригинальное имя файла (более точно: "
"каждая из жёстких ссылок на файл — это ссылка на один I<номер inode>, где "
"номер inode — индекс в таблице inode, в которой содержатся метаданные о всех "
"файлах файловой системы; смотрите B<stat>(2)). Изменения файла не зависят от "
"используемого при этом имени файла. Жёсткие ссылки не могут указывать на "
"каталоги (чтобы не возникало петель в дереве файловой системы, что могло бы "
"привести к неправильной работе многих программ) и на файлы из разных "
"файловых систем (так как номера inode не уникальны в файловых системах)."

#. type: Plain text
#: man-pages/man7/symlink.7:69
msgid ""
"A symbolic link is a special type of file whose contents are a string that "
"is the pathname of another file, the file to which the link refers.  (The "
"contents of a symbolic link can be read using B<readlink>(2).)  In other "
"words, a symbolic link is a pointer to another name, and not to an "
"underlying object.  For this reason, symbolic links may refer to directories "
"and may cross filesystem boundaries."
msgstr ""
"Символьная ссылка — это специальный тип файла, чьё содержимое представляет "
"собой строку, содержащую имя другого файла — файла, на который указывает "
"ссылка (содержимое символьной ссылки можно прочитать с помощью "
"B<readlink>(2)). Другими словами, символьная ссылка — это указатель на "
"другое имя, а не на сам объект. В следствии этого, символьные ссылки могут "
"указывать на каталоги и могут указывать на файлы в разных файловых системах."

#. type: Plain text
#: man-pages/man7/symlink.7:75
msgid ""
"There is no requirement that the pathname referred to by a symbolic link "
"should exist.  A symbolic link that refers to a pathname that does not exist "
"is said to be a I<dangling link>."
msgstr ""
"Объект с именем, на которое ссылается символьная ссылка, может не "
"существовать. Символьную ссылку, указывающую на не существующее имя, "
"называют I<оборванной ссылкой (dangling link)>."

#. type: Plain text
#: man-pages/man7/symlink.7:87
msgid ""
"Because a symbolic link and its referenced object coexist in the filesystem "
"name space, confusion can arise in distinguishing between the link itself "
"and the referenced object.  On historical systems, commands and system calls "
"adopted their own link-following conventions in a somewhat ad-hoc fashion.  "
"Rules for a more uniform approach, as they are implemented on Linux and "
"other systems, are outlined here.  It is important that site-local "
"applications also conform to these rules, so that the user interface can be "
"as consistent as possible."
msgstr ""
"Поскольку символьная ссылка и объект, на который она ссылается, сосуществуют "
"в пространство имён файловой системы, можно запутаться при различении самой "
"ссылки и объекта, на который она ссылается. Старые системы, команды и "
"системные вызовы имели собственные соглашения о ссылках, специально для "
"этого созданные. Здесь в общих чертах описаны правила, которые одинаково "
"реализованы в Linux и других системах. Важно, чтобы локальное приложение "
"также соответствовало этим правилам, и пользовательский интерфейс был "
"максимально одинаков."

#. type: SS
#: man-pages/man7/symlink.7:87
#, no-wrap
msgid "Symbolic link ownership, permissions, and timestamps"
msgstr "Владельцы, права и отметки времени символьных ссылок"

#. type: Plain text
#: man-pages/man7/symlink.7:95
msgid ""
"The owner and group of an existing symbolic link can be changed using "
"B<lchown>(2).  The only time that the ownership of a symbolic link matters "
"is when the link is being removed or renamed in a directory that has the "
"sticky bit set (see B<stat>(2))."
msgstr ""
"Владельца и группу существующей символьной ссылки можно изменить с помощью "
"B<lchown>(2). Владельцы символьной ссылки учитываются только, когда "
"символьная ссылка удаляется или переименовывается в каталоге, на котором "
"установлен бит закрепления (sticky bit) (смотрите B<stat>(2))."

#. type: Plain text
#: man-pages/man7/symlink.7:101
msgid ""
"The last access and last modification timestamps of a symbolic link can be "
"changed using B<utimensat>(2)  or B<lutimes>(3)."
msgstr ""
"Время последнего обращения и изменения символьной ссылки можно изменять с "
"помощью B<utimensat>(2) или B<lutimes>(3)."

#.  Linux does not currently implement an lchmod(2).
#.  The
#.  4.4BSD
#.  system differs from historical
#.  4BSD
#.  systems in that the system call
#.  .BR chown (2)
#.  has been changed to follow symbolic links.
#.  The
#.  .BR lchown (2)
#.  system call was added later when the limitations of the new
#.  .BR chown (2)
#.  became apparent.
#. type: Plain text
#: man-pages/man7/symlink.7:125
msgid ""
"On Linux, the permissions of a symbolic link are not used in any operations; "
"the permissions are always 0777 (read, write, and execute for all user "
"categories), and can't be changed.  (Note that there are some \"magic\" "
"symbolic links in the I</proc> directory tree\\(emfor example, the I</proc/"
"[pid]/fd/*> files\\(emthat have different permissions.)"
msgstr ""
"В Linux права на символьную ссылку при операциях не учитываются; права "
"всегда имеют значение 0777 (чтение, запись и исполнение для всех категорий "
"пользователей) и это нельзя изменить (заметим, что есть несколько "
"«магических» символьных ссылок в дереве каталогов I</proc> — например, файлы "
"I</proc/[pid]/fd/*> — с другим набором прав)."

#. type: SS
#: man-pages/man7/symlink.7:125
#, no-wrap
msgid "Obtaining a file descriptor that refers to a symbolic link"
msgstr "Получение файлового дескриптора, который указывает на символьную ссылку"

#. type: Plain text
#: man-pages/man7/symlink.7:143
msgid ""
"Using the combination of the B<O_PATH> and B<O_NOFOLLOW> flags to "
"B<open>(2)  yields a file descriptor that can be passed as the I<dirfd> "
"argument in system calls such as B<fstatat>(2), B<fchownat>(2), "
"B<fchmodat>(2), B<linkat>(2), and B<readlinkat>(2), in order to operate on "
"the symbolic link itself (rather than the file to which it refers)."
msgstr ""
"Для работы с самой символьной ссылкой (а не файлом, на который она "
"указывает) нужно указать комбинацию флагов B<O_PATH> и B<O_NOFOLLOW> вызов "
"B<open>(2) вернёт файловый дескриптор, который можно передавать в аргументе "
"I<dirfd> в такие системные вызовы как B<fstatat>(2), B<fchownat>(2), "
"B<fchmodat>(2), B<linkat>(2) и B<readlinkat>(2)."

#. type: Plain text
#: man-pages/man7/symlink.7:159
msgid ""
"By default (i.e., if the B<AT_SYMLINK_FOLLOW> flag is not specified), if "
"B<name_to_handle_at>(2)  is applied to a symbolic link, it yields a handle "
"for the symbolic link (rather than the file to which it refers).  One can "
"then obtain a file descriptor for the symbolic link (rather than the file to "
"which it refers)  by specifying the B<O_PATH> flag in a subsequent call to "
"B<open_by_handle_at>(2).  Again, that file descriptor can be used in the "
"aforementioned system calls to operate on the symbolic link itself."
msgstr ""
"По умолчанию (т. е., если не указан флаг B<AT_SYMLINK_FOLLOW>), если "
"B<name_to_handle_at>(2) вызывается для символьной ссылки, то он возвращает "
"описатель символьной ссылки (а не файла, на который она указывает). Затем с "
"его помощью можно получить файловый дескриптор символьной ссылки (а не "
"файла, на который она указывает), указав флаг B<O_PATH> в последующем вызове "
"B<open_by_handle_at>(2). Данный файловый дескриптор можно использовать в "
"вышеупомянутых системных вызовах для работы с самой символьной ссылкой."

#. type: SS
#: man-pages/man7/symlink.7:159
#, no-wrap
msgid "Handling of symbolic links by system calls and commands"
msgstr "Трактовка символьных ссылок в системных вызовах и командах"

#. type: Plain text
#: man-pages/man7/symlink.7:174
msgid ""
"Symbolic links are handled either by operating on the link itself, or by "
"operating on the object referred to by the link.  In the latter case, an "
"application or system call is said to I<follow> the link.  Symbolic links "
"may refer to other symbolic links, in which case the links are dereferenced "
"until an object that is not a symbolic link is found, a symbolic link that "
"refers to a file which does not exist is found, or a loop is detected.  "
"(Loop detection is done by placing an upper limit on the number of links "
"that may be followed, and an error results if this limit is exceeded.)"
msgstr ""
"При работе с символьными ссылками можно воздействовать на сами символьные "
"ссылки или на объекты, на которые они указывают. В последнем случае про "
"приложение или системный вызов говорят, что он I<переходит (follow)> по "
"ссылке. Символьные ссылки могут указывать на другие символьные ссылки; в "
"этом случае ссылки разыменовываются до нахождения объекта, который не "
"является символьной ссылкой, символьной ссылки, которая указывает на "
"несуществующий файл, или до обнаружения зацикливания (обнаружение "
"зацикливания выполняется заданием максимального количества переходов по "
"ссылкам, при превышении которого возвращается ошибка)."

#. type: Plain text
#: man-pages/man7/symlink.7:177
msgid ""
"There are three separate areas that need to be discussed.  They are as "
"follows:"
msgstr "Есть три области, которые требуют обсуждения:"

#. type: Plain text
#: man-pages/man7/symlink.7:179
msgid "Symbolic links used as filename arguments for system calls."
msgstr ""
"Использование символьных ссылок в виде имён файлов в аргументах системных "
"вызовов."

#. type: Plain text
#: man-pages/man7/symlink.7:182
msgid ""
"Symbolic links specified as command-line arguments to utilities that are not "
"traversing a file tree."
msgstr ""
"Символьные ссылки, указываемые в аргументах командной строки утилит, которые "
"не выполняют обход дерева файлов."

#. type: Plain text
#: man-pages/man7/symlink.7:186
msgid ""
"Symbolic links encountered by utilities that are traversing a file tree "
"(either specified on the command line or encountered as part of the file "
"hierarchy walk)."
msgstr ""
"Символьные ссылки, встреченные утилитами при обходе дерева файлов "
"(задаваемые в командной строке или встреченные как часть файла при обходе "
"иерархии)."

#. type: SS
#: man-pages/man7/symlink.7:186
#, no-wrap
msgid "System calls"
msgstr "Системные вызовы"

#. type: Plain text
#: man-pages/man7/symlink.7:189
msgid ""
"The first area is symbolic links used as filename arguments for system calls."
msgstr ""
"Рассмотрим использование символьных ссылок в виде имён файлов в аргументах "
"системных вызовов."

#. type: Plain text
#: man-pages/man7/symlink.7:199
msgid ""
"Except as noted below, all system calls follow symbolic links.  For example, "
"if there were a symbolic link I<slink> which pointed to a file named "
"I<afile>, the system call I<open(\"slink\" ...\\&)> would return a file "
"descriptor referring to the file I<afile>."
msgstr ""
"За исключениями, описанными ниже, все системные вызовы переходят по "
"символьным ссылкам. Например, если есть символьная ссылка I<slink>, которая "
"указывает на файл с именем I<afile>, то системный вызов I<open(\"slink\" ..."
"\\&)> вернёт файловый дескриптор, ссылающийся на файл I<afile>."

#. type: Plain text
#: man-pages/man7/symlink.7:214
msgid ""
"Various system calls do not follow links, and operate on the symbolic link "
"itself.  They are: B<lchown>(2), B<lgetxattr>(2), B<llistxattr>(2), "
"B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), B<readlink>(2), "
"B<rename>(2), B<rmdir>(2), and B<unlink>(2)."
msgstr ""
"Некоторые системные вызовы не переходят по ссылкам, а работают с самими "
"ссылками: B<lchown>(2), B<lgetxattr>(2), B<llistxattr>(2), "
"B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), B<readlink>(2), "
"B<rename>(2), B<rmdir>(2) и B<unlink>(2)."

#.  Maybe one day: .BR fchownat (2)
#. type: Plain text
#: man-pages/man7/symlink.7:238
msgid ""
"Certain other system calls optionally follow symbolic links.  They are: "
"B<faccessat>(2), B<fchownat>(2), B<fstatat>(2), B<linkat>(2), "
"B<name_to_handle_at>(2), B<open>(2), B<openat>(2), B<open_by_handle_at>(2), "
"and B<utimensat>(2); see their manual pages for details.  Because "
"B<remove>(3)  is an alias for B<unlink>(2), that library function also does "
"not follow symbolic links.  When B<rmdir>(2)  is applied to a symbolic link, "
"it fails with the error B<ENOTDIR>."
msgstr ""
"Другие системные вызовы могут переходить по ссылкам: B<faccessat>(2), "
"B<fchownat>(2), B<fstatat>(2), B<linkat>(2), B<name_to_handle_at>(2), "
"B<open>(2), B<openat>(2), B<open_by_handle_at>(2) и B<utimensat>(2); "
"подробности смотрите в их справочных страницах. Так как B<remove>(3) "
"является псевдонимом B<unlink>(2), библиотечная функция также не переходит "
"по символьным ссылкам. При указании символьной ссылки B<rmdir>(2) вызов "
"завершается с ошибкой B<ENOTDIR>."

#. type: Plain text
#: man-pages/man7/symlink.7:252
msgid ""
"B<link>(2)  warrants special discussion.  POSIX.1-2001 specifies that "
"B<link>(2)  should dereference I<oldpath> if it is a symbolic link.  "
"However, Linux does not do this.  (By default, Solaris is the same, but the "
"POSIX.1-2001 specified behavior can be obtained with suitable compiler "
"options.)  POSIX.1-2008 changed the specification to allow either behavior "
"in an implementation."
msgstr ""
"Вызов B<link>(2) заслуживает отдельного описания. В POSIX.1-2001 говорится, "
"что B<link>(2) должен разыменовывать I<oldpath>, если это символьная ссылка. "
"Однако в Linux этого не делается (по умолчанию Solaris делается тоже самое, "
"но в POSIX.1-2001 определяется как такое поведение можно получить с помощью "
"специальных параметров компилятора). В POSIX.1-2008 изменено описание, "
"которое позволяет реализовывать любое из этих вариантов поведения."

#. type: SS
#: man-pages/man7/symlink.7:252
#, no-wrap
msgid "Commands not traversing a file tree"
msgstr "Команды, не выполняющие обход дерева файлов"

#. type: Plain text
#: man-pages/man7/symlink.7:255
msgid ""
"The second area is symbolic links, specified as command-line filename "
"arguments, to commands which are not traversing a file tree."
msgstr ""
"Рассмотрим случай с символьными ссылками, указываемыми в аргументах "
"командной строки утилит, которые не выполняют обход дерева файлов."

#. type: Plain text
#: man-pages/man7/symlink.7:266
msgid ""
"Except as noted below, commands follow symbolic links named as command-line "
"arguments.  For example, if there were a symbolic link I<slink> which "
"pointed to a file named I<afile>, the command I<cat slink> would display the "
"contents of the file I<afile>."
msgstr ""
"За исключением, описанным далее, команды переходят по ссылкам, указанным в "
"аргументах командной строки. Например, если I<slink> — символьная ссылка, "
"которая указывает на файл с именем I<afile>, то команда I<cat slink> выведет "
"содержимое файла I<afile>."

#. type: Plain text
#: man-pages/man7/symlink.7:274
msgid ""
"It is important to realize that this rule includes commands which may "
"optionally traverse file trees; for example, the command I<chown file> is "
"included in this rule, while the command I<chown\\ -R file>, which performs "
"a tree traversal, is not.  (The latter is described in the third area, "
"below.)"
msgstr ""
"Важно понимать, что это правило учитывается командами, которые не "
"обязательно выполняют обход дерева файлов; например, команда I<chown file> "
"следует этому правилу, а команда I<chown\\ -R file>, выполняющая обход "
"дерева, нет (последняя описана далее)."

#. type: Plain text
#: man-pages/man7/symlink.7:292
msgid ""
"If it is explicitly intended that the command operate on the symbolic link "
"instead of following the symbolic link\\(emfor example, it is desired that "
"I<chown slink> change the ownership of the file that I<slink> is, whether it "
"is a symbolic link or not\\(emthe I<-h> option should be used.  In the above "
"example, I<chown root slink> would change the ownership of the file referred "
"to by I<slink>, while I<chown\\ -h root slink> would change the ownership of "
"I<slink> itself."
msgstr ""
"Если команде явно указано воздействовать на символьную ссылку, а не "
"переходить по символьной ссылке, например, требуется, чтобы I<chown slink> "
"изменила права на файл I<slink>, независимо от того, является ли он "
"символьной ссылкой или нет, то нужно использовать параметр I<-h>. В примере "
"выше I<chown root slink> изменяет права на файл, на который указывает "
"I<slink>, а I<chown\\ -h root slink> изменяет права на саму ссылку I<slink>."

#. type: Plain text
#: man-pages/man7/symlink.7:294
msgid "There are some exceptions to this rule:"
msgstr "Есть несколько исключений из этого правила:"

#. type: Plain text
#: man-pages/man7/symlink.7:304
msgid ""
"The B<mv>(1)  and B<rm>(1)  commands do not follow symbolic links named as "
"arguments, but respectively attempt to rename and delete them.  (Note, if "
"the symbolic link references a file via a relative path, moving it to "
"another directory may very well cause it to stop working, since the path may "
"no longer be correct.)"
msgstr ""
"Команды B<mv>(1) и B<rm>(1) не переходят по символьным ссылкам, указанным в "
"аргументах, а пытаются переименовать и удалить их (заметим, если символьная "
"ссылка указывает на файл через относительный путь, то перемещение файла в "
"другой каталог с большой вероятностью вызовет проблемы, так как путь может "
"оказаться неправильным)."

#. type: Plain text
#: man-pages/man7/symlink.7:334
msgid ""
"The B<ls>(1)  command is also an exception to this rule.  For compatibility "
"with historic systems (when B<ls>(1)  is not doing a tree walk\\(emthat is, "
"I<-R> option is not specified), the B<ls>(1)  command follows symbolic links "
"named as arguments if the I<-H> or I<-L> option is specified, or if the I<-"
"F>, I<-d>, or I<-l> options are not specified.  (The B<ls>(1)  command is "
"the only command where the I<-H> and I<-L> options affect its behavior even "
"though it is not doing a walk of a file tree.)"
msgstr ""
"Команда B<ls>(1) также является исключением из этого правила. Для "
"совместимости со старыми системами (когда B<ls>(1) не делает обход дерева, "
"то есть не указан параметр I<-R>), команда B<ls>(1) переходит по символьным "
"ссылкам, указанным в аргументах, если задан параметр I<-H> или I<-L>, или "
"если не указан параметр I<-F>, I<-d> или I<-l>  (команда B<ls>(1) — "
"единственная команда, у которой параметры I<-H> и I<-L> влияют на поведение "
"даже когда не выполняется обход дерева файлов)."

#. The 4.4BSD system differs from historical 4BSD systems in that the
#. .BR chown (1)
#. and
#. .BR chgrp (1)
#. commands follow symbolic links specified on the command line.
#. type: Plain text
#: man-pages/man7/symlink.7:352
msgid ""
"The B<file>(1)  command is also an exception to this rule.  The B<file>(1)  "
"command does not follow symbolic links named as argument by default.  The "
"B<file>(1)  command does follow symbolic links named as argument if the I<-"
"L> option is specified."
msgstr ""
"Команда B<file>(1) также является исключением из этого правила. По умолчанию "
"B<file>(1) не переходит по символьной ссылке, указанной в аргументе. Команда "
"B<file>(1) переходит по символьной ссылке, указанной в аргументе, если "
"указан параметр I<-L>."

#. type: SS
#: man-pages/man7/symlink.7:352
#, no-wrap
msgid "Commands traversing a file tree"
msgstr "Команды, выполняющие обход дерева файлов"

#. type: Plain text
#: man-pages/man7/symlink.7:365
msgid ""
"The following commands either optionally or always traverse file trees: "
"B<chgrp>(1), B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), "
"B<ls>(1), B<pax>(1), B<rm>(1), and B<tar>(1)."
msgstr ""
"Следующие команды могут или всегда обходят дерево файлов: B<chgrp>(1), "
"B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), B<ls>(1), "
"B<pax>(1), B<rm>(1) и B<tar>(1)."

#. type: Plain text
#: man-pages/man7/symlink.7:369
msgid ""
"It is important to realize that the following rules apply equally to "
"symbolic links encountered during the file tree traversal and symbolic links "
"listed as command-line arguments."
msgstr ""
"Важно понимать, что следующие правила применяются как к символьным ссылкам, "
"обнаруженным при обходе дерева файлов, так и к символьным ссылкам, указанным "
"в аргументах командной строки."

#. type: Plain text
#: man-pages/man7/symlink.7:374
msgid ""
"The I<first rule> applies to symbolic links that reference files other than "
"directories.  Operations that apply to symbolic links are performed on the "
"links themselves, but otherwise the links are ignored."
msgstr ""
"I<Первое правило> применяется к символьным ссылкам, которые указывают на "
"файлы, а не на каталоги. Операции, которые применимы к символьным ссылкам, "
"выполняются с самими ссылками, но другие ссылки игнорируется."

#. type: Plain text
#: man-pages/man7/symlink.7:386
msgid ""
"The command I<rm\\ -r slink directory> will remove I<slink>, as well as any "
"symbolic links encountered in the tree traversal of I<directory>, because "
"symbolic links may be removed.  In no case will B<rm>(1)  affect the file "
"referred to by I<slink>."
msgstr ""
"Команда I<rm\\ -r slink каталог> удалит I<slink>, а также все символьные "
"ссылки, обнаруженные при обходе I<каталога>, так как символьные ссылки могут "
"быть удалены. Команда B<rm>(1) никогда не удаляет файл, на который указывает "
"I<slink>."

#. type: Plain text
#: man-pages/man7/symlink.7:391
msgid ""
"The I<second rule> applies to symbolic links that refer to directories.  "
"Symbolic links that refer to directories are never followed by default.  "
"This is often referred to as a \"physical\" walk, as opposed to a \"logical"
"\" walk (where symbolic links that refer to directories are followed)."
msgstr ""
"I<Второе правило> применяется к символьным ссылкам, которые указывают на "
"каталоги. По умолчанию такие символьные ссылки никогда не разыменовываются. "
"Часто об этом говорят как о «физическом» обходе, в противовес «логическому» "
"обходу (когда выполняется переход по символьным ссылкам, указывающем на "
"каталог)."

#. type: Plain text
#: man-pages/man7/symlink.7:394
msgid ""
"Certain conventions are (should be) followed as consistently as possible by "
"commands that perform file tree walks:"
msgstr ""
"При обходе дерева файлов командами соблюдаются (должны) определённые "
"соглашения, если это возможно:"

#. type: Plain text
#: man-pages/man7/symlink.7:407
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, regardless of the type of file they reference, by specifying the I<-H> "
"(for \"half-logical\") flag.  This flag is intended to make the command-line "
"name space look like the logical name space.  (Note, for commands that do "
"not always do file tree traversals, the I<-H> flag will be ignored if the I<-"
"R> flag is not also specified.)"
msgstr ""
"Команду можно заставить перейти по любой символьной ссылке, указанной в "
"командной строке, независимо от типа файла, на который она ссылаются, указав "
"параметр I<-H> (от «half-logical»). Этот параметр заставляет пространство "
"имён командной строки выглядеть как логическое пространство имён (заметим, "
"что команды, которые не всегда делают обход дерева файлов, будут "
"игнорировать флаг I<-H>, если также не указан флаг I<-R>)."

#. type: Plain text
#: man-pages/man7/symlink.7:423
msgid ""
"For example, the command I<chown\\ -HR user slink> will traverse the file "
"hierarchy rooted in the file pointed to by I<slink>.  Note, the I<-H> is not "
"the same as the previously discussed I<-h> flag.  The I<-H> flag causes "
"symbolic links specified on the command line to be dereferenced for the "
"purposes of both the action to be performed and the tree walk, and it is as "
"if the user had specified the name of the file to which the symbolic link "
"pointed."
msgstr ""
"Например, команда I<chown\\ -HR user slink> выполнит обход файловой иерархии "
"с корнем как у файла, указанном I<slink>. Заметим, что здесь I<-H> делает не "
"тоже самое, что и флаг I<-h>, описанный ранее. При флаге I<-H> символьные "
"ссылки, указанные в командной строке, будут разыменовываться и при обходе "
"файлового дерева и как если бы пользователь указал имя файла, на которое "
"указывает символьная ссылка."

#. type: Plain text
#: man-pages/man7/symlink.7:437
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, as well as any symbolic links encountered during the traversal, "
"regardless of the type of file they reference, by specifying the I<-L> (for "
"\"logical\") flag.  This flag is intended to make the entire name space look "
"like the logical name space.  (Note, for commands that do not always do file "
"tree traversals, the I<-L> flag will be ignored if the I<-R> flag is not "
"also specified.)"
msgstr ""
"Команду можно заставить перейти по любой символьной ссылке, указанной в "
"командной строке, а также по всем символьным ссылкам, встреченным при "
"обходе, независимо от типа файла, на который она ссылается, указав параметр "
"I<-H> (от «half-logical»). Этот параметр заставляет всё пространство имён "
"выглядеть как логическое пространство имён (заметим, что команды, которые не "
"всегда делают обход дерева файлов, будут игнорировать флаг I<-L>, если также "
"не указан флаг I<-R>)."

#. type: Plain text
#: man-pages/man7/symlink.7:452
msgid ""
"For example, the command I<chown\\ -LR user slink> will change the owner of "
"the file referred to by I<slink>.  If I<slink> refers to a directory, "
"B<chown> will traverse the file hierarchy rooted in the directory that it "
"references.  In addition, if any symbolic links are encountered in any file "
"tree that B<chown> traverses, they will be treated in the same fashion as "
"I<slink>."
msgstr ""
"Например, команда I<chown\\ -LR user slink> изменит владельца файла, на "
"который указывает I<slink>. Если I<slink> указывает на каталог, то B<chown> "
"обойдёт дерево файлов с корнем в этом каталоге. Также, если символьные "
"ссылки встречаются в любом файловом дереве, которое обходит B<chown>, то с "
"ними  будет сделано тоже что и с I<slink>."

#. type: Plain text
#: man-pages/man7/symlink.7:459
msgid ""
"A command can be made to provide the default behavior by specifying the I<-"
"P> (for \"physical\") flag.  This flag is intended to make the entire name "
"space look like the physical name space."
msgstr ""
"Команду можно заставить следовать поведению по умолчанию, указав флаг I<-P> "
"(от «physical»). Этот флаг предназначен для работы со всем пространством "
"имён как с физическим пространством имён."

#. type: Plain text
#: man-pages/man7/symlink.7:477
msgid ""
"For commands that do not by default do file tree traversals, the I<-H>, I<-"
"L>, and I<-P> flags are ignored if the I<-R> flag is not also specified.  In "
"addition, you may specify the I<-H>, I<-L>, and I<-P> options more than "
"once; the last one specified determines the command's behavior.  This is "
"intended to permit you to alias commands to behave one way or the other, and "
"then override that behavior on the command line."
msgstr ""
"Команды, которые по умолчанию не выполняют обход дерева файлов, игнорируют "
"флаги I<-H>, I<-L> и I<-P>, если не указан флаг I<-R>. Также вы можете "
"указать параметры I<-H>, I<-L> и I<-P> более одного раза; последний "
"указанный параметр определяет поведение команды. Это позволяет создавать "
"псевдонимы команд с некоторым поведением, а затем переопределять это "
"поведение в командной строке."

#. type: Plain text
#: man-pages/man7/symlink.7:483
msgid "The B<ls>(1)  and B<rm>(1)  commands have exceptions to these rules:"
msgstr "У команд B<ls>(1) и B<rm>(1) есть исключения из этих правил:"

#. type: Plain text
#: man-pages/man7/symlink.7:496
msgid ""
"The B<rm>(1)  command operates on the symbolic link, and not the file it "
"references, and therefore never follows a symbolic link.  The B<rm>(1)  "
"command does not support the I<-H>, I<-L>, or I<-P> options."
msgstr ""
"Команда B<rm>(1) работает с символьными ссылками, а не с файлами, на который "
"они ссылаются, и поэтому никогда не переходит по символьной ссылке. Команда "
"B<rm>(1) не поддерживает параметры I<-H>, I<-L> и I<-P>."

#. type: Plain text
#: man-pages/man7/symlink.7:516
msgid ""
"To maintain compatibility with historic systems, the B<ls>(1)  command acts "
"a little differently.  If you do not specify the I<-F>, I<-d> or I<-l> "
"options, B<ls>(1)  will follow symbolic links specified on the command "
"line.  If the I<-L> flag is specified, B<ls>(1)  follows all symbolic links, "
"regardless of their type, whether specified on the command line or "
"encountered in the tree walk."
msgstr ""
"Для совместимости со старыми системами работа команды B<ls>(1) чуть "
"отличается. Если не указан параметр I<-F>, I<-d> или I<-l>, то B<ls>(1) "
"переходит по символьной ссылке, указанной в командной строке. Если указан "
"флаг I<-L>, то B<ls>(1) переходит по всем символьным ссылкам независимо от "
"их типа и где они встретились — в командной строке или при обходе дерева."

#. type: Plain text
#: man-pages/man7/symlink.7:534
msgid ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), "
"B<namei>(1), B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), "
"B<readlink>(2), B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), "
"B<lutimes>(3), B<path_resolution>(7)"
msgstr ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), "
"B<namei>(1), B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), "
"B<readlink>(2), B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), "
"B<lutimes>(3), B<path_resolution>(7)"

#. type: TH
#: man-pages/man7/spufs.7:27
#, no-wrap
msgid "SPUFS"
msgstr "SPUFS"

#. type: Plain text
#: man-pages/man7/spufs.7:30
msgid "spufs - SPU filesystem"
msgstr "spufs - файловая система SPU"

#. type: Plain text
#: man-pages/man7/spufs.7:34
msgid ""
"The SPU filesystem is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic Processor Units "
"(SPUs)."
msgstr ""
"Файловая система SPU используется на машинах PowerPC, на которых реализована "
"Cell Broadband Engine Architecture для доступа к cинергичным процессорным "
"блокам (Synergistic Processor Unit, SPU)."

#. type: Plain text
#: man-pages/man7/spufs.7:43
msgid ""
"The filesystem provides a name space similar to POSIX shared memory or "
"message queues.  Users that have write permissions on the filesystem can use "
"B<spu_create>(2)  to establish SPU contexts under the B<spufs> root "
"directory."
msgstr ""
"Файловая система предоставляет пространство имён похожее на общую память "
"POSIX или очереди сообщений. Пользователи, имеющие права на запись в "
"файловую систему, могут использовать вызов B<spu_create>(2) для организации "
"контекстов SPU в корневом каталоге B<spufs>."

#. type: Plain text
#: man-pages/man7/spufs.7:50
msgid ""
"Every SPU context is represented by a directory containing a predefined set "
"of files.  These files can be used for manipulating the state of the logical "
"SPU.  Users can change permissions on the files, but can't add or remove "
"files."
msgstr ""
"Каждый контекст SPU представлен каталогом с постоянным набором файлов. Эти "
"файлы можно использовать для управления состоянием логического SPU. "
"Пользователи могут изменять права на файлы, но не могут добавлять или "
"удалять файлы."

#. type: SS
#: man-pages/man7/spufs.7:50
#, no-wrap
msgid "Mount options"
msgstr "Параметры монтирования"

#. type: TP
#: man-pages/man7/spufs.7:51
#, no-wrap
msgid "B<uid=E<lt>uidE<gt>>"
msgstr "B<uid=E<lt>uidE<gt>>"

#. type: Plain text
#: man-pages/man7/spufs.7:54
msgid "Set the user owning the mount point; the default is 0 (root)."
msgstr ""
"Назначает пользователя-владельца точки монтирования; по умолчанию 0 (root)."

#. type: TP
#: man-pages/man7/spufs.7:54
#, no-wrap
msgid "B<gid=E<lt>gidE<gt>>"
msgstr "B<gid=E<lt>gidE<gt>>"

#. type: Plain text
#: man-pages/man7/spufs.7:57
msgid "Set the group owning the mount point; the default is 0 (root)."
msgstr "Назначает группу-владельца точки монтирования; по умолчанию 0 (root)."

#. type: TP
#: man-pages/man7/spufs.7:57
#, no-wrap
msgid "B<mode=E<lt>modeE<gt>>"
msgstr "B<mode=E<lt>праваE<gt>>"

#. type: Plain text
#: man-pages/man7/spufs.7:63
msgid ""
"Set the mode of the top-level directory in B<spufs>, as an octal mode "
"string.  The default is 0775."
msgstr ""
"Назначает права на каталог верхнего уровня в B<spufs>, задаётся как строка-"
"число прав в восьмеричной системе счисления. По умолчанию 0775."

#. type: SS
#: man-pages/man7/spufs.7:63
#, no-wrap
msgid "Files"
msgstr "Файлы"

#. type: Plain text
#: man-pages/man7/spufs.7:75
msgid ""
"The files in B<spufs> mostly follow the standard behavior for regular system "
"calls like B<read>(2)  or B<write>(2), but often support only a subset of "
"the operations supported on regular filesystems.  This list details the "
"supported operations and the deviations from the standard behavior described "
"in the respective man pages."
msgstr ""
"При вызовах B<read>(2)  или B<write>(2) файлы в B<spufs>, в основном, ведут "
"себя как обычно, но часто поддерживают только ограниченный набор операций. В "
"данном списке перечислены поддерживаемые операции, а отклонения от "
"стандартного поведения описаны в соответствующих справочных страницах."

#. type: Plain text
#: man-pages/man7/spufs.7:97
msgid ""
"All files that support the B<read>(2)  operation also support B<readv>(2)  "
"and all files that support the B<write>(2)  operation also support "
"B<writev>(2).  All files support the B<access>(2)  and B<stat>(2)  family of "
"operations, but for the latter call, the only fields of the returned I<stat> "
"structure that contain reliable information are I<st_mode>, I<st_nlink>, "
"I<st_uid>, and I<st_gid>."
msgstr ""
"Все файлы, поддерживающие операцию B<read>(2), также поддерживают "
"B<readv>(2), а все файлы, поддерживающие операцию B<write>(2), также "
"поддерживают B<writev>(2). Все файлы поддерживают семейство операций "
"B<access>(2) и B<stat>(2), но у последней операции в возвращаемой структуре "
"I<stat> достоверную информацию содержат только поля I<st_mode>, I<st_nlink>, "
"I<st_uid> и I<st_gid>."

#. type: Plain text
#: man-pages/man7/spufs.7:106
msgid ""
"All files support the B<chmod>(2)/B<fchmod>(2)  and B<chown>(2)/"
"B<fchown>(2)  operations, but will not be able to grant permissions that "
"contradict the possible operations (e.g., read access on the I<wbox> file)."
msgstr ""
"Все файлы поддерживают операции B<chmod>(2)/B<fchmod>(2) и B<chown>(2)/"
"B<fchown>(2), но они не могут предоставить права, которые противоречат "
"возможным операциям (например, возможность чтения файла I<wbox>)."

#. type: Plain text
#: man-pages/man7/spufs.7:108
msgid "The current set of files is:"
msgstr "Текущий список файлов:"

#. type: TP
#: man-pages/man7/spufs.7:108
#, no-wrap
msgid "I</capabilities>"
msgstr "I</capabilities>"

#. type: Plain text
#: man-pages/man7/spufs.7:113
msgid ""
"Contains a comma-delimited string representing the capabilities of this SPU "
"context.  Possible capabilities are:"
msgstr ""
"Содержит строку мандатов (перечисляемых через запятую) этого контекста SPU. "
"Возможные мандаты:"

#. type: TP
#: man-pages/man7/spufs.7:114
#, no-wrap
msgid "B<sched>"
msgstr "B<sched>"

#. type: Plain text
#: man-pages/man7/spufs.7:117
msgid "This context may be scheduled."
msgstr "Данный контекст может быть запланирован."

#. type: TP
#: man-pages/man7/spufs.7:117
#, no-wrap
msgid "B<step>"
msgstr "B<step>"

#. type: Plain text
#: man-pages/man7/spufs.7:120
msgid "This context can be run in single-step mode, for debugging."
msgstr "Данный контекст может выполняться в пошаговом режиме, для отладки."

#. type: Plain text
#: man-pages/man7/spufs.7:122
msgid "New capabilities flags may be added in the future."
msgstr "В будущем могут быть добавлены новые флаги мандатов."

#. type: TP
#: man-pages/man7/spufs.7:123
#, no-wrap
msgid "I</mem>"
msgstr "I</mem>"

#. type: Plain text
#: man-pages/man7/spufs.7:132
msgid ""
"the contents of the local storage memory of the SPU.  This can be accessed "
"like a regular shared memory file and contains both code and data in the "
"address space of the SPU.  The possible operations on an open I<mem> file "
"are:"
msgstr ""
"Содержимое хранилища локальной памяти SPU. Оно может быть доступно как "
"обычный файл общей памяти и содержит код и данные в адресном пространстве "
"SPU. Возможные операции после открытия файла I<mem>:"

#. type: TP
#: man-pages/man7/spufs.7:133
#, no-wrap
msgid "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"
msgstr "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"

#. type: Plain text
#: man-pages/man7/spufs.7:144
msgid ""
"These operate as usual, with the exception that B<lseek>(2), B<write>(2), "
"and B<pwrite>(2)  are not supported beyond the end of the file.  The file "
"size is the size of the local storage of the SPU, which is normally 256 "
"kilobytes."
msgstr ""
"Эти операции работают как обычно, за исключением того, что B<lseek>(2), "
"B<write>(2) и B<pwrite>(2) не поддерживают доступ за конец файла. Размер "
"файла — это размер локального хранилища SPU, обычно 256 килобайт."

#. type: TP
#: man-pages/man7/spufs.7:144 man-pages/man7/spufs.7:706
#: man-pages/man7/spufs.7:725
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: Plain text
#: man-pages/man7/spufs.7:153
msgid ""
"Mapping I<mem> into the process address space provides access to the SPU "
"local storage within the process address space.  Only B<MAP_SHARED> mappings "
"are allowed."
msgstr ""
"Отображает I<mem> в адресное пространство процесса, предоставляя доступ к "
"локальному хранилищу SPU внутри адресного пространства процесса. Разрешено "
"только отображение B<MAP_SHARED>."

#. type: TP
#: man-pages/man7/spufs.7:154
#, no-wrap
msgid "I</regs>"
msgstr "I</regs>"

#. type: Plain text
#: man-pages/man7/spufs.7:161
msgid ""
"Contains the saved general-purpose registers of the SPU context.  This file "
"contains the 128-bit values of each register, from register 0 to register "
"127, in order.  This allows the general-purpose registers to be inspected "
"for debugging."
msgstr ""
"Содержит сохранённые регистры общего назначения контекста SPU. Этот файл "
"содержит 128-битное значение каждого регистра, начиная с регистра 0 и кончая "
"127, в этом порядке. Это позволяет просматривать регистры общего назначения "
"при отладке."

#. type: Plain text
#: man-pages/man7/spufs.7:165
msgid ""
"Reading to or writing from this file requires that the context is scheduled "
"out, so use of this file is not recommended in normal program operation."
msgstr ""
"Для чтения или записи в этот файл требуется, чтобы контекст был "
"запланирован, поэтому использовать этот файл не рекомендуется при нормальной "
"работе программы."

#. type: Plain text
#: man-pages/man7/spufs.7:171
msgid ""
"The I<regs> file is not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""
"Файл I<regs> отсутствует в контекстах, которые были созданы с флагом "
"B<SPU_CREATE_NOSCHED>."

#. type: TP
#: man-pages/man7/spufs.7:171
#, no-wrap
msgid "I</mbox>"
msgstr "I</mbox>"

#. type: Plain text
#: man-pages/man7/spufs.7:181
msgid ""
"The first SPU-to-CPU communication mailbox.  This file is read-only and can "
"be read in units of 4 bytes.  The file can be used only in nonblocking mode "
"- even B<poll>(2)  cannot be used to block on this file.  The only possible "
"operation on an open I<mbox> file is:"
msgstr ""
"Первый буфер обмена (communication mailbox) SPU-в-CPU. Этот файл доступен "
"только для чтения и может быть прочитан по 4 байта за раз. Его можно "
"использовать только в неблокирующем режиме — для блокировки нельзя даже "
"использовать B<poll>(2). Единственно возможная операция над открытым файлом "
"I<mbox>:"

#. type: Plain text
#: man-pages/man7/spufs.7:200
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox (i.e., the SPU "
"has not sent a mailbox message), the return value is set to -1 and I<errno> "
"is set to B<EAGAIN>.  When data has been read successfully, four bytes are "
"placed in the data buffer and the value four is returned."
msgstr ""
"Если I<count> меньше четырёх, то B<read>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. Если данные в буфере отсутствуют (т. е., SPU не "
"отправлял сообщений), то возвращается значение -1, а I<errno> присваивается "
"значение B<EAGAIN>. При успешном чтении данных четыре байта помещаются в "
"буфер данных и возвращается значение 4."

#. type: TP
#: man-pages/man7/spufs.7:201
#, no-wrap
msgid "I</ibox>"
msgstr "I</ibox>"

#. type: Plain text
#: man-pages/man7/spufs.7:217
msgid ""
"The second SPU-to-CPU communication mailbox.  This file is similar to the "
"first mailbox file, but can be read in blocking I/O mode, thus calling "
"B<read>(2)  on an open I<ibox> file will block until the SPU has written "
"data to its interrupt mailbox channel (unless the file has been opened with "
"B<O_NONBLOCK>, see below).  Also, B<poll>(2)  and similar system calls can "
"be used to monitor for the presence of mailbox data."
msgstr ""
"Второй буфер обмена SPU-в-CPU. Этот файл подобен первому буферу обмена, но "
"может открываться в блокирующем режиме ввода-вывода, то есть вызов "
"B<read>(2) с открытым файлом I<ibox> заблокирует выполнение до тех пор, пока "
"SPU не запишет данные в свой канал прерываний буфера (если файл не открыт с "
"флагом B<O_NONBLOCK>, смотрите далее). Также можно использовать B<poll>(2) и "
"подобные системные вызовы для отслеживания наличия данных в буфере."

#. type: Plain text
#: man-pages/man7/spufs.7:221
msgid "The possible operations on an open I<ibox> file are:"
msgstr "Возможные операции над открытым файлом I<ibox>:"

#. type: Plain text
#: man-pages/man7/spufs.7:239
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""
"Если I<count> меньше четырёх, то B<read>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. Если данные в буфере отсутствуют и файловый "
"дескриптор открыт с флагом B<O_NONBLOCK>, то возвращается значение -1, а "
"I<errno> присваивается значение B<EAGAIN>."

#. type: Plain text
#: man-pages/man7/spufs.7:247
msgid ""
"If there is no data available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU writes "
"to its interrupt mailbox channel.  When data has been read successfully, "
"four bytes are placed in the data buffer and the value four is returned."
msgstr ""
"Если в буфере данных нет и файловый дескриптор был открыт без B<O_NONBLOCK>, "
"то вызов блокируется до тех пор, пока SPU не запишет в свой канал прерываний "
"буфера. При успешном чтении данных четыре байта помещаются в буфер данных и "
"возвращается значение 4."

#. type: Plain text
#: man-pages/man7/spufs.7:254
msgid ""
"Poll on the I<ibox> file returns I<(POLLIN | POLLRDNORM)> whenever data is "
"available for reading."
msgstr ""
"Опрос файла I<ibox> показывает I<(POLLIN | POLLRDNORM)> есть ли данные для "
"чтения."

#. type: TP
#: man-pages/man7/spufs.7:255
#, no-wrap
msgid "I</wbox>"
msgstr "I</wbox>"

#. type: Plain text
#: man-pages/man7/spufs.7:267
msgid ""
"The CPU-to-SPU communication mailbox.  It is write-only and can be written "
"in units of four bytes.  If the mailbox is full, B<write>(2)  will block, "
"and B<poll>(2)  can be used to block until the mailbox is available for "
"writing again.  The possible operations on an open I<wbox> file are:"
msgstr ""
"Буфер обмена CPU-в-SPU. Доступен только для записи, которую можно "
"производить по четыре байта за раз. Если буфер полон, то B<write>(2) "
"блокируется; для слежения за возможностью записи можно использовать вызов "
"B<poll>(2). Возможные операции с открытым файлом I<wbox>:"

#. type: Plain text
#: man-pages/man7/spufs.7:286
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no space available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""
"Если I<count> меньше четырёх, то B<write>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. Если в буфере нет места и файловый дескриптор "
"открыт с флагом B<O_NONBLOCK>, то возвращается значение -1, а I<errno> "
"присваивается значение B<EAGAIN>."

#. type: Plain text
#: man-pages/man7/spufs.7:295
msgid ""
"If there is no space available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU reads "
"from its PPE (PowerPC Processing Element)  mailbox channel.  When data has "
"been written successfully, the system call returns four as its function "
"result."
msgstr ""
"Если в буфере нет места и файловый дескриптор был открыт без флага "
"B<O_NONBLOCK>, то вызов заблокирует выполнение до тех пор, пока SPU не "
"выполнит чтение из своего буферного канала PPE (PowerPC Processing Element). "
"После успешного чтения данных, системный вызов вернёт значение 4 как "
"результат функции."

#. type: Plain text
#: man-pages/man7/spufs.7:302
msgid ""
"A poll on the I<wbox> file returns I<(POLLOUT | POLLWRNORM)> whenever space "
"is available for writing."
msgstr ""
"Опрос файла I<wbox> показывает I<(POLLOUT | POLLWRNORM)> есть ли свободное "
"место для записи."

#. type: TP
#: man-pages/man7/spufs.7:303
#, no-wrap
msgid "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"
msgstr "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"

#. type: Plain text
#: man-pages/man7/spufs.7:316
msgid ""
"These are read-only files that contain the length of the current queue of "
"each mailbox\\(emthat is, how many words can be read from I<mbox> or I<ibox> "
"or how many words can be written to I<wbox> without blocking.  The files can "
"be read only in four-byte units and return a big-endian binary integer "
"number.  The only possible operation on an open I<*box_stat> file is:"
msgstr ""
"Эти файлы доступны только для чтения и содержат размер текущей очереди "
"каждого буфера — то есть сколько слов можно прочитать из I<mbox> или "
"I<ibox>, или сколько слов можно записать в I<wbox> без блокировки. Файлы "
"можно читать только по четыре байта за раз и возвращается целое двоичное "
"число с прямым порядком байт. С открытыми файлами I<*box_stat> возможна "
"только операция:"

#. type: Plain text
#: man-pages/man7/spufs.7:337
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer.  "
"This value is the number of elements that can be read from (for I<mbox_stat> "
"and I<ibox_stat>)  or written to (for I<wbox_stat>)  the respective mailbox "
"without blocking or returning an B<EAGAIN> error."
msgstr ""
"Если I<count> меньше четырёх, то B<read>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. В противном случае четырёхбайтное значение "
"помещается в буфер данных. Это значение — количество элементов, которые "
"можно прочитать (для I<mbox_stat> и I<ibox_stat>) или записать (для "
"I<wbox_stat>) из соответствующего буфера без блокировки, иначе возвращается "
"ошибка B<EAGAIN>."

#. type: TP
#: man-pages/man7/spufs.7:338
#, no-wrap
msgid "I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, I</event_status>, I</srr0>, I</lslr>"
msgstr "I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, I</event_status>, I</srr0>, I</lslr>"

#. type: Plain text
#: man-pages/man7/spufs.7:350
msgid ""
"Internal registers of the SPU.  These files contain an ASCII string "
"representing the hex value of the specified register.  Reads and writes on "
"these files (except for I<npc>, see below) require that the SPU context be "
"scheduled out, so frequent access to these files is not recommended for "
"normal program operation."
msgstr ""
"Внутренние регистры SPU. В этих файлах содержатся строки ASCII, "
"представляющие значение регистра в виде шестнадцатеричного числа. Для чтения "
"и записи в эти файлы (кроме I<npc>, смотрите далее) требуется, чтобы "
"выполнялся контекст SPU, поэтому частый доступ к этим файлам не "
"рекомендуется при обычной работе программы."

#. type: Plain text
#: man-pages/man7/spufs.7:352
msgid "The contents of these files are:"
msgstr "Содержимое этих файлов:"

#. type: TP
#: man-pages/man7/spufs.7:353
#, no-wrap
msgid "I<npc>"
msgstr "I<npc>"

#. type: Plain text
#: man-pages/man7/spufs.7:356
msgid "Next Program Counter - valid only when the SPU is in a stopped state."
msgstr ""
"Счётчик следующей команды — доступен только когда SPU в остановленном "
"состоянии."

#. type: TP
#: man-pages/man7/spufs.7:356
#, no-wrap
msgid "I<decr>"
msgstr "I<decr>"

#. type: Plain text
#: man-pages/man7/spufs.7:359
msgid "SPU Decrementer"
msgstr "Декрементный счётчик SPU"

#. type: TP
#: man-pages/man7/spufs.7:359
#, no-wrap
msgid "I<decr_status>"
msgstr "I<decr_status>"

#. type: Plain text
#: man-pages/man7/spufs.7:362
msgid "Decrementer Status"
msgstr "Состояние декрементного счётчика"

#. type: TP
#: man-pages/man7/spufs.7:362
#, no-wrap
msgid "I<spu_tag_mask>"
msgstr "I<spu_tag_mask>"

#. type: Plain text
#: man-pages/man7/spufs.7:365
msgid "MFC tag mask for SPU DMA"
msgstr "Маска тега MFC для SPU DMA"

#. type: TP
#: man-pages/man7/spufs.7:365
#, no-wrap
msgid "I<event_mask>"
msgstr "I<event_mask>"

#. type: Plain text
#: man-pages/man7/spufs.7:368
msgid "Event mask for SPU interrupts"
msgstr "Маска событий прерываний SPU"

#. type: TP
#: man-pages/man7/spufs.7:368
#, no-wrap
msgid "I<event_status>"
msgstr "I<event_status>"

#. type: Plain text
#: man-pages/man7/spufs.7:371
msgid "Number of SPU events pending (read-only)"
msgstr "Количество ожидающих событий SPU (только для чтения)"

#. type: TP
#: man-pages/man7/spufs.7:371
#, no-wrap
msgid "I<srr0>"
msgstr "I<srr0>"

#. type: Plain text
#: man-pages/man7/spufs.7:374
msgid "Interrupt Return address register"
msgstr "Регистр адреса возврата из прерывания"

#. type: TP
#: man-pages/man7/spufs.7:374
#, no-wrap
msgid "I<lslr>"
msgstr "I<lslr>"

#. type: Plain text
#: man-pages/man7/spufs.7:377
msgid "Local Store Limit Register"
msgstr "Ограничительный регистр локального хранилища"

#. type: Plain text
#: man-pages/man7/spufs.7:380
msgid "The possible operations on these files are:"
msgstr "Возможные операции над этими файлами:"

#. type: Plain text
#: man-pages/man7/spufs.7:388
msgid ""
"Reads the current register value.  If the register value is larger than the "
"buffer passed to the B<read>(2)  system call, subsequent reads will continue "
"reading from the same buffer, until the end of the buffer is reached."
msgstr ""
"Читает текущее значение регистра. Если значение не вмещается в буфер, "
"переданный в системный вызов B<read>(2), то последующие чтения продолжат "
"чтение из этого же буфера пока не будет достигнут его конец."

#. type: Plain text
#: man-pages/man7/spufs.7:392
msgid ""
"When a complete string has been read, all subsequent read operations will "
"return zero bytes and a new file descriptor needs to be opened to read a new "
"value."
msgstr ""
"После прочтения всей строки, все последующие операции чтения будут "
"возвращать ноль байт и для чтения нового значения нужно открыть новый "
"файловый дескриптор."

#. type: Plain text
#: man-pages/man7/spufs.7:402 man-pages/man7/spufs.7:537
msgid ""
"A B<write>(2)  operation on the file sets the register to the value given in "
"the string.  The string is parsed from the beginning until the first "
"nonnumeric character or the end of the buffer.  Subsequent writes to the "
"same file descriptor overwrite the previous setting."
msgstr ""
"Операция B<write>(2) над файлом устанавливает в регистр значение, "
"передаваемое в строке. Строка анализируется от начала до первого не "
"числового символа или до конца буфера. Последующие операции записи в тот же "
"файловый дескриптор перезаписывают предыдущее значение."

#. type: Plain text
#: man-pages/man7/spufs.7:409
msgid ""
"Except for the I<npc> file, these files are not present on contexts that "
"have been created with the B<SPU_CREATE_NOSCHED> flag."
msgstr ""
"За исключением файла I<npc>, эти файлы отсутствуют в контекстах, которые "
"были созданы с флагом B<SPU_CREATE_NOSCHED>."

#. type: TP
#: man-pages/man7/spufs.7:410
#, no-wrap
msgid "I</fpcr>"
msgstr "I</fpcr>"

#. type: Plain text
#: man-pages/man7/spufs.7:417
msgid ""
"This file provides access to the Floating Point Status and Control Register "
"(fcpr) as a binary, four-byte file.  The operations on the I<fpcr> file are:"
msgstr ""
"Данный файл предоставляет доступ к регистру управления и состояния операций "
"с плавающей запятой (fcpr). Это четырёхбайтный файл с двоичным значением "
"регистра. Операции с I<fpcr>:"

#. type: Plain text
#: man-pages/man7/spufs.7:432
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the I<fpcr> register."
msgstr ""
"Если I<count> меньше четырёх, то B<read>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. В противном случае четырёхбайтное значение "
"помещается в буфер данных; это текущее значение регистра I<fpcr>."

#. type: Plain text
#: man-pages/man7/spufs.7:446
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the I<fpcr> register."
msgstr ""
"Если I<count> меньше четырёх, то B<write>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. В противном случае четырёхбайтное значение "
"копируется из буфера данных, обновляя значение регистра I<fpcr>."

#. type: TP
#: man-pages/man7/spufs.7:447
#, no-wrap
msgid "I</signal1>, I</signal2>"
msgstr "I</signal1>, I</signal2>"

#. type: Plain text
#: man-pages/man7/spufs.7:462
msgid ""
"The files provide access to the two signal notification channels of an SPU.  "
"These are read-write files that operate on four-byte words.  Writing to one "
"of these files triggers an interrupt on the SPU.  The value written to the "
"signal files can be read from the SPU through a channel read or from host "
"user space through the file.  After the value has been read by the SPU, it "
"is reset to zero.  The possible operations on an open I<signal1> or "
"I<signal2> file are:"
msgstr ""
"Эти файлы предоставляют доступ к двум сигнальным каналам уведомления SPU. "
"Они доступны на чтение-запись четырёхбайтными словами. Запись в один из "
"файлов возбуждает прерывание на SPU. Значение, записанное в сигнальные "
"файлы, можно прочитать из SPU через канал чтения или из пользовательского "
"пространства узла через файл. После чтения SPU этого значения, оно "
"сбрасывается в ноль. Возможные операции с открытым файлом I<signal1> или "
"I<signal2>:"

#. type: Plain text
#: man-pages/man7/spufs.7:476
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the specified signal notification register."
msgstr ""
"Если I<count> меньше четырёх, то B<read>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. В противном случае четырёхбайтное значение "
"помещается в буфер данных; это текущее значение указанного сигнального "
"регистра уведомления."

#. type: Plain text
#: man-pages/man7/spufs.7:497
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the specified signal notification register.  The "
"signal notification register will either be replaced with the input data or "
"will be updated to the bitwise OR operation of the old value and the input "
"data, depending on the contents of the I<signal1_type> or I<signal2_type> "
"files respectively."
msgstr ""
"Если I<count> меньше четырёх, то B<write>(2) возвращает -1 и присваивает "
"I<errno> значение B<EINVAL>. В противном случае четырёхбайтное значение "
"копируется из буфера данных, обновляя значение указанного сигнального "
"регистра уведомления. Данные в сигнальном регистре уведомления или будут "
"перезаписаны входными данными или обновлены с помощью побитной операции ИЛИ, "
"в зависимости от содержимого файла I<signal1_type> или I<signal2_type>, "
"соответственно."

#. type: TP
#: man-pages/man7/spufs.7:498
#, no-wrap
msgid "I</signal1_type>, I</signal2_type>"
msgstr "I</signal1_type>, I</signal2_type>"

#. type: Plain text
#: man-pages/man7/spufs.7:516
msgid ""
"These two files change the behavior of the I<signal1> and I<signal2> "
"notification files.  They contain a numeric ASCII string which is read as "
"either \"1\" or \"0\".  In mode 0 (overwrite), the hardware replaces the "
"contents of the signal channel with the data that is written to it.  In mode "
"1 (logical OR), the hardware accumulates the bits that are subsequently "
"written to it.  The possible operations on an open I<signal1_type> or "
"I<signal2_type> file are:"
msgstr ""
"Эти файлы изменяют поведение файлов уведомлений I<signal1> и I<signal2>. В "
"них содержится число в виде строки ASCII, которое читается как «1» или «0».  "
"В режиме 0 (перезапись)  аппаратное обеспечение заменяет содержимое "
"сигнального канала данными, которые в него записываются. В режиме 1 "
"(логическое ИЛИ) аппаратное обеспечение складывает биты, которые в него "
"последовательно поступают. Возможные операции с  открытым файлом "
"I<signal1_type> или I<signal2_type>:"

#. type: Plain text
#: man-pages/man7/spufs.7:527
msgid ""
"When the count supplied to the B<read>(2)  call is shorter than the required "
"length for the digit (plus a newline character), subsequent reads from the "
"same file descriptor will complete the string.  When a complete string has "
"been read, all subsequent read operations will return zero bytes and a new "
"file descriptor needs to be opened to read the value again."
msgstr ""
"Если счётчик, переданный в вызов B<read>(2), короче требуемой длины для "
"цифры (плюс символ новой строки), последующие чтения из того же файлового "
"дескриптора дополнят строку. После чтения всей строки все последующие "
"операции чтения будут возвращать ноль байт, а для повторного чтения значения "
"нужно открыть новый файловый дескриптор."

#. type: TP
#: man-pages/man7/spufs.7:538
#, no-wrap
msgid "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"
msgstr "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"

#. type: Plain text
#: man-pages/man7/spufs.7:557
msgid ""
"Read-only files that contain the saved state of the SPU mailboxes and DMA "
"queues.  This allows the SPU status to be inspected, mainly for debugging.  "
"The I<mbox_info> and I<ibox_info> files each contain the four-byte mailbox "
"message that has been written by the SPU.  If no message has been written to "
"these mailboxes, then contents of these files is undefined.  The "
"I<mbox_stat>, I<ibox_stat> and I<wbox_stat> files contain the available "
"message count."
msgstr ""
"Эти файлы, доступные только для чтения, содержат сохранённое состояние "
"буферов обмена SPU и очередей DMA. Это позволяет просматривать состояние "
"SPU, полезно при отладке. Файлы I<mbox_info> и I<ibox_info> содержат "
"четырёхбайтное сообщение, которое было записано SPU. Если сообщения не было "
"записано в эти буферы обмена, то содержимое этих файлов не определено. Файлы "
"I<mbox_stat>, I<ibox_stat> и I<wbox_stat> содержат счётчик доступных "
"сообщений."

#. type: Plain text
#: man-pages/man7/spufs.7:566
msgid ""
"The I<wbox_info> file contains an array of four-byte mailbox messages, which "
"have been sent to the SPU.  With current CBEA machines, the array is four "
"items in length, so up to 4 * 4 = 16 bytes can be read from this file.  If "
"any mailbox queue entry is empty, then the bytes read at the corresponding "
"location are undefined."
msgstr ""
"Файл I<wbox_info> содержит массив четырёхбайтных сообщений, которые "
"посылались в SPU. В существующих машинах CBEA размер массива равен четырём "
"элементам, поэтому 4 * 4 = 16 байт можно прочитать из этого файла. Если "
"какой-то элемент очереди пуст, то содержимое прочитанных байтов из этого "
"положения не определено."

#. type: Plain text
#: man-pages/man7/spufs.7:571
msgid ""
"The I<dma_info> file contains the contents of the SPU MFC DMA queue, "
"represented as the following structure:"
msgstr ""
"Файл I<dma_info> содержит данные очереди SPU MFC DMA, которые представлены "
"следующей структурой:"

#. type: Plain text
#: man-pages/man7/spufs.7:582
#, no-wrap
msgid ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"
msgstr ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:590
msgid ""
"The last member of this data structure is the actual DMA queue, containing "
"16 entries.  The I<mfc_cq_sr> structure is defined as:"
msgstr ""
"Последний элемент структуры — действующая очередь DMA, содержащая 16 "
"элементов. Структура I<mfc_cq_sr> определена следующим образом:"

#. type: Plain text
#: man-pages/man7/spufs.7:599
#, no-wrap
msgid ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"
msgstr ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:607
msgid ""
"The I<proxydma_info> file contains similar information, but describes the "
"proxy DMA queue (i.e., DMAs initiated by entities outside the SPU) instead.  "
"The file is in the following format:"
msgstr ""
"В файле I<proxydma_info> содержится подобная информация, но она описывает "
"очередь прокси-DMA (т. е., DMA, инициируемые элементами вне SPU). Файл имеет "
"следующий формат:"

#. type: Plain text
#: man-pages/man7/spufs.7:616
#, no-wrap
msgid ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"
msgstr ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:622
msgid ""
"Accessing these files requires that the SPU context is scheduled out - "
"frequent use can be inefficient.  These files should not be used for normal "
"program operation."
msgstr ""
"Для доступа к этим файлам требуется, чтобы выполнялся контекст SPU, частое "
"использование может быть неэффективным. Эти файлы не должны использоваться в "
"обычной работе."

#. type: Plain text
#: man-pages/man7/spufs.7:626
msgid ""
"These files are not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""
"Эти файлы отсутствуют в контекстах, которые были созданы с флагом "
"B<SPU_CREATE_NOSCHED>."

#. type: TP
#: man-pages/man7/spufs.7:626
#, no-wrap
msgid "I</cntl>"
msgstr "I</cntl>"

#. type: Plain text
#: man-pages/man7/spufs.7:631
msgid ""
"This file provides access to the SPU Run Control and SPU status registers, "
"as an ASCII string.  The following operations are supported:"
msgstr ""
"Данный файл предоставляет доступ к регистрам управления работой SPU (Run "
"Control) и состояния SPU, содержит строки ASCII. Поддерживаются следующие "
"операции:"

#. type: Plain text
#: man-pages/man7/spufs.7:638
msgid ""
"Reads from the I<cntl> file will return an ASCII string with the hex value "
"of the SPU Status register."
msgstr ""
"При попытке чтения файла I<cntl> возвращается строка ASCII, представляющая "
"содержимое регистра состояния SPU в виде шестнадцатеричного значения."

#. type: Plain text
#: man-pages/man7/spufs.7:643
msgid ""
"Writes to the I<cntl> file will set the context's SPU Run Control register."
msgstr ""
"Запись в файл I<cntl> изменяет значение контекстного регистра управления "
"работой SPU."

#. type: TP
#: man-pages/man7/spufs.7:644
#, no-wrap
msgid "I</mfc>"
msgstr "I</mfc>"

#. type: Plain text
#: man-pages/man7/spufs.7:651
msgid ""
"Provides access to the Memory Flow Controller of the SPU.  Reading from the "
"file returns the contents of the SPU's MFC Tag Status register, and writing "
"to the file initiates a DMA from the MFC.  The following operations are "
"supported:"
msgstr ""
"Предоставляет доступ к Memory Flow Controller, находящийся в SPU. При чтении "
"из файла возвращается содержимое регистра SPU MFC Tag Status, а при записи в "
"файл запускается DMA из MFC. Поддерживаются следующие операции:"

#. type: Plain text
#: man-pages/man7/spufs.7:656
msgid ""
"Writes to this file need to be in the format of a MFC DMA command, defined "
"as follows:"
msgstr "Для записи в файл данные должны быть в формате команды MFC DMA:"

#. type: Plain text
#: man-pages/man7/spufs.7:668
#, no-wrap
msgid ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"
msgstr ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* зарезервировано */\n"
"    uint32_t lsa;    /* адрес локального хранилища */\n"
"    uint64_t ea;     /* эффективный адрес */\n"
"    uint16_t size;   /* размер передачи */\n"
"    uint16_t tag;    /* тег команды */\n"
"    uint16_t class;  /* ID класса */\n"
"    uint16_t cmd;    /* opcode команды */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:676
msgid ""
"Writes are required to be exactly I<sizeof(struct mfc_dma_command)> bytes in "
"size.  The command will be sent to the SPU's MFC proxy queue, and the tag "
"stored in the kernel (see below)."
msgstr ""
"Данные записи должны иметь размер ровно I<sizeof(struct mfc_dma_command)> "
"байт. Команда будет послана в очередь прокси MFC SPU, а тег сохранён в ядре "
"(смотрите далее)."

#. type: Plain text
#: man-pages/man7/spufs.7:685
msgid ""
"Reads the contents of the tag status register.  If the file is opened in "
"blocking mode (i.e., without B<O_NONBLOCK>), then the read will block until "
"a DMA tag (as performed by a previous write) is complete.  In nonblocking "
"mode, the MFC tag status register will be returned without waiting."
msgstr ""
"Читает содержимое регистра состояния тега. Если файл открыт в блокирующем "
"режиме (т. е., без B<O_NONBLOCK>), то чтение заблокирует выполнение до тех "
"пор, пока не выполнится тег DMA (который задан предыдущей записью). В "
"неблокирующем режиме сразу же возвращается регистр состояния тега MFC."

#. type: Plain text
#: man-pages/man7/spufs.7:698
msgid ""
"Calling B<poll>(2)  on the I<mfc> file will block until a new DMA can be "
"started (by checking for B<POLLOUT>)  or until a previously started DMA (by "
"checking for B<POLLIN>)  has been completed."
msgstr ""
"Вызов B<poll>(2) с файлом I<mfc> заблокирует выполнение до тех пор, пока не "
"будет запущен новый DMA (проверяется по B<POLLOUT>) или пока не будет "
"завершён уже выполняющийся DMA (проверяется по B<POLLIN>)."

#. type: Plain text
#: man-pages/man7/spufs.7:704
msgid ""
"I</mss> Provides access to the MFC MultiSource Synchronization (MSS) "
"facility.  By B<mmap>(2)-ing this file, processes can access the MSS area of "
"the SPU."
msgstr ""
"I</mss> Предоставляет доступ к свойству MFC MultiSource Synchronization "
"(MSS). При выполнении B<mmap>(2) процесс может получить доступ к области MSS "
"из SPU."

#. type: Plain text
#: man-pages/man7/spufs.7:706 man-pages/man7/spufs.7:724
msgid "The following operations are supported:"
msgstr "Поддерживаются следующие операции:"

#. type: Plain text
#: man-pages/man7/spufs.7:715
msgid ""
"Mapping B<mss> into the process address space gives access to the SPU MSS "
"area within the process address space.  Only B<MAP_SHARED> mappings are "
"allowed."
msgstr ""
"Отображает I<mss> в адресное пространство процесса, предоставляя доступ к "
"области MSS SPU внутри адресного пространства процесса. Разрешено только "
"отображение B<MAP_SHARED>."

#. type: TP
#: man-pages/man7/spufs.7:716
#, no-wrap
msgid "I</psmap>"
msgstr "I</psmap>"

#. type: Plain text
#: man-pages/man7/spufs.7:722
msgid ""
"Provides access to the whole problem-state mapping of the SPU.  Applications "
"can use this area to interface to the SPU, rather than writing to individual "
"register files in B<spufs>."
msgstr ""
"Предоставляет доступ к полному отображению проблемного состояния (problem-"
"state mapping) SPU. В приложениях эту область можно использовать для обмена "
"с SPU вместо записи в отдельные регистровые файлы B<spufs>."

#. type: Plain text
#: man-pages/man7/spufs.7:733
msgid ""
"Mapping B<psmap> gives a process a direct map of the SPU problem state "
"area.  Only B<MAP_SHARED> mappings are supported."
msgstr ""
"Отображение B<psmap> предоставляет процессу прямое отображение к области "
"проблемного состояния SPU. Поддерживаются только отображения B<MAP_SHARED>."

#. type: TP
#: man-pages/man7/spufs.7:734
#, no-wrap
msgid "I</phys-id>"
msgstr "I</phys-id>"

#. type: Plain text
#: man-pages/man7/spufs.7:740
msgid ""
"Read-only file containing the physical SPU number that the SPU context is "
"running on.  When the context is not running, this file contains the string "
"\"-1\"."
msgstr ""
"Доступный только для чтения файл содержит номер физического SPU, на котором "
"выполняется контекст SPU. Когда контекст не выполняется этот файл содержит "
"строку «-1»."

#. type: Plain text
#: man-pages/man7/spufs.7:742
msgid "The physical SPU number is given by an ASCII hex string."
msgstr ""
"Номер физического SPU описывается строкой ASCII числом в шестнадцатеричной "
"системе счисления."

#. type: TP
#: man-pages/man7/spufs.7:742
#, no-wrap
msgid "I</object-id>"
msgstr "I</object-id>"

#. type: Plain text
#: man-pages/man7/spufs.7:748
msgid ""
"Allows applications to store (or retrieve) a single 64-bit ID into the "
"context.  This ID is later used by profiling tools to uniquely identify the "
"context."
msgstr ""
"Позволяет приложениям хранить (или получать) одиночный 64-битный ID в "
"контекст. Позднее данный ID используется инструментами профилирования как "
"уникальный идентификатор контекста."

#. type: Plain text
#: man-pages/man7/spufs.7:754
msgid ""
"By writing an ASCII hex value into this file, applications can set the "
"object ID of the SPU context.  Any previous value of the object ID is "
"overwritten."
msgstr ""
"Записью строки ASCII с шестнадцатеричным числом приложение может назначать "
"ID объекта контекста SPU. Любое предыдущее значение объекта ID "
"перезаписывается."

#. type: Plain text
#: man-pages/man7/spufs.7:758
msgid ""
"Reading this file gives an ASCII hex string representing the object ID for "
"this SPU context."
msgstr ""
"При чтении из файла возвращается строка ASCII с шестнадцатеричным числом, "
"представляющим ID объекта этого контекста SPU."

#. type: TP
#: man-pages/man7/spufs.7:760
#, no-wrap
msgid "I</etc/fstab>  entry"
msgstr "запись в I</etc/fstab>"

#.  .SH AUTHORS
#.  Arnd Bergmann <arndb@de.ibm.com>, Mark Nutter <mnutter@us.ibm.com>,
#.  Ulrich Weigand <Ulrich.Weigand@de.ibm.com>, Jeremy Kerr <jk@ozlabs.org>
#. type: Plain text
#: man-pages/man7/spufs.7:766
msgid "none \t/spu \tspufs \tgid=spu \t0\t0"
msgstr "none \t/spu \tspufs \tgid=spu \t0\t0"

#. type: Plain text
#: man-pages/man7/spufs.7:771
msgid "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"

#. type: Plain text
#: man-pages/man7/spufs.7:772
msgid "I<The Cell Broadband Engine Architecture (CBEA) specification>"
msgstr "I<The Cell Broadband Engine Architecture (CBEA) specification>"

#. type: TH
#: man-pages/man7/sched.7:32
#, no-wrap
msgid "SCHED"
msgstr "SCHED"

#. type: Plain text
#: man-pages/man7/sched.7:35
msgid "sched - overview of CPU scheduling"
msgstr "sched - обзор планирования работы ЦП"

#. type: Plain text
#: man-pages/man7/sched.7:40
msgid ""
"Since Linux 2.6.23, the default scheduler is CFS, the \"Completely Fair "
"Scheduler\".  The CFS scheduler replaced the earlier \"O(1)\" scheduler."
msgstr ""
"Начиная с Linux 2.6.23 планировщиком по умолчанию является CFS — «полностью "
"честный планировщик» (Completely Fair Scheduler). Планировщик CFS заменил "
"использовавшийся ранее «O(1)»."

#. type: SS
#: man-pages/man7/sched.7:40
#, no-wrap
msgid "API summary"
msgstr "Краткие сведения о программном интерфейсе"

#. type: Plain text
#: man-pages/man7/sched.7:44
msgid ""
"Linux provides the following system calls for controlling the CPU scheduling "
"behavior, policy, and priority of processes (or, more precisely, threads)."
msgstr ""
"Для управления планированием, алгоритмом и приоритетом процессов (более "
"точно, нитей) на ЦП в Linux имеются следующие системные вызовы:"

#. type: TP
#: man-pages/man7/sched.7:44
#, no-wrap
msgid "B<nice>(2)"
msgstr "B<nice>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:48
msgid ""
"Set a new nice value for the calling thread, and return the new nice value."
msgstr ""
"Назначает новое значение уступчивости вызвавшей нити и возвращает новое "
"значение уступчивости."

#. type: TP
#: man-pages/man7/sched.7:48
#, no-wrap
msgid "B<getpriority>(2)"
msgstr "B<getpriority>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:52
msgid ""
"Return the nice value of a thread, a process group, or the set of threads "
"owned by a specified user."
msgstr ""
"Возвращает значение уступчивости нити, группы процессов или набора нитей, "
"принадлежащих указанному пользователю."

#. type: TP
#: man-pages/man7/sched.7:52
#, no-wrap
msgid "B<setpriority>(2)"
msgstr "B<setpriority>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:56
msgid ""
"Set the nice value of a thread, a process group, or the set of threads owned "
"by a specified user."
msgstr ""
"Изменяет значение уступчивости нити, группы процессов или набора нитей, "
"принадлежащих указанному пользователю."

#. type: TP
#: man-pages/man7/sched.7:56
#, no-wrap
msgid "B<sched_setscheduler>(2)"
msgstr "B<sched_setscheduler>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:59
msgid "Set the scheduling policy and parameters of a specified thread."
msgstr "Назначает алгоритм планирования и параметры заданной нити."

#. type: TP
#: man-pages/man7/sched.7:59
#, no-wrap
msgid "B<sched_getscheduler>(2)"
msgstr "B<sched_getscheduler>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:62
msgid "Return the scheduling policy of a specified thread."
msgstr "Возвращает алгоритм планирования и параметры заданной нити."

#. type: TP
#: man-pages/man7/sched.7:62
#, no-wrap
msgid "B<sched_setparam>(2)"
msgstr "B<sched_setparam>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:65
msgid "Set the scheduling parameters of a specified thread."
msgstr "Назначает параметры планирования заданной нити."

#. type: TP
#: man-pages/man7/sched.7:65
#, no-wrap
msgid "B<sched_getparam>(2)"
msgstr "B<sched_getparam>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:68
msgid "Fetch the scheduling parameters of a specified thread."
msgstr "Возвращает параметры планирования заданной нити."

#. type: TP
#: man-pages/man7/sched.7:68
#, no-wrap
msgid "B<sched_get_priority_max>(2)"
msgstr "B<sched_get_priority_max>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:71
msgid "Return the maximum priority available in a specified scheduling policy."
msgstr ""
"Возвращает максимальный приоритет, доступный заданному алгоритму "
"планирования."

#. type: TP
#: man-pages/man7/sched.7:71
#, no-wrap
msgid "B<sched_get_priority_min>(2)"
msgstr "B<sched_get_priority_min>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:74
msgid "Return the minimum priority available in a specified scheduling policy."
msgstr ""
"Возвращает минимальный приоритет, доступный заданному алгоритму планирования."

#. type: TP
#: man-pages/man7/sched.7:74
#, no-wrap
msgid "B<sched_rr_get_interval>(2)"
msgstr "B<sched_rr_get_interval>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:78
msgid ""
"Fetch the quantum used for threads that are scheduled under the \"round-robin"
"\" scheduling policy."
msgstr ""
"Возвращает квант, используемый нитями, которые запланированы "
"«циклическим» (round-robin) алгоритмом планирования."

#. type: TP
#: man-pages/man7/sched.7:78
#, no-wrap
msgid "B<sched_yield>(2)"
msgstr "B<sched_yield>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:82
msgid ""
"Cause the caller to relinquish the CPU, so that some other thread be "
"executed."
msgstr "Заставляет вызывающего освободить ЦП для выполнения других нитей."

#. type: TP
#: man-pages/man7/sched.7:82
#, no-wrap
msgid "B<sched_setaffinity>(2)"
msgstr "B<sched_setaffinity>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:86
msgid "(Linux-specific)  Set the CPU affinity of a specified thread."
msgstr "(только в Linux) Назначить увязываемый ЦП указанной нити."

#. type: TP
#: man-pages/man7/sched.7:86
#, no-wrap
msgid "B<sched_getaffinity>(2)"
msgstr "B<sched_getaffinity>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:90
msgid "(Linux-specific)  Get the CPU affinity of a specified thread."
msgstr "(только в Linux) Возвращает увязываемый ЦП указанной нити."

#. type: TP
#: man-pages/man7/sched.7:90
#, no-wrap
msgid "B<sched_setattr>(2)"
msgstr "B<sched_setattr>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:97
msgid ""
"Set the scheduling policy and parameters of a specified thread.  This (Linux-"
"specific) system call provides a superset of the functionality of "
"B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""
"Назначает алгоритм планирования и параметры заданной нити. Данный системный "
"вызов (есть только в Linux) предоставляет охватывающий набор возможностей "
"B<sched_setscheduler>(2) и B<sched_setparam>(2)."

#. type: TP
#: man-pages/man7/sched.7:97
#, no-wrap
msgid "B<sched_getattr>(2)"
msgstr "B<sched_getattr>(2)"

#. type: Plain text
#: man-pages/man7/sched.7:105
msgid ""
"Fetch the scheduling policy and parameters of a specified thread.  This "
"(Linux-specific) system call provides a superset of the functionality of "
"B<sched_getscheduler>(2)  and B<sched_getparam>(2)."
msgstr ""
"Возвращает алгоритм планирования и параметры заданной нити. Данный системный "
"вызов (есть только в Linux) предоставляет охватывающий набор возможностей "
"B<sched_setscheduler>(2) и B<sched_setparam>(2)."

#. type: SS
#: man-pages/man7/sched.7:105
#, no-wrap
msgid "Scheduling policies"
msgstr "Алгоритмы планирования"

#. type: Plain text
#: man-pages/man7/sched.7:113
msgid ""
"The scheduler is the kernel component that decides which runnable thread "
"will be executed by the CPU next.  Each thread has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>.  The "
"scheduler makes its decisions based on knowledge of the scheduling policy "
"and static priority of all threads on the system."
msgstr ""
"Планировщик — это часть ядра, которая решает какая запущенная нить будет "
"выполняться процессором следующей. Каждой нити назначается алгоритм "
"планирования и I<статический> приоритет планирования, I<sched_priority>. "
"Планировщик принимает решение на основе данных об алгоритме планирования и "
"статическом приоритете всех нитей системы."

#. type: Plain text
#: man-pages/man7/sched.7:118
msgid ""
"For threads scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""
"Для нитей, которые планируются одним из обычных алгоритмом планирования "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), значение I<sched_priority> "
"при принятии решения не используется (должен быть указан 0)."

#. type: Plain text
#: man-pages/man7/sched.7:132
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time threads always have higher "
"priority than normal threads.)  Note well: POSIX.1 requires an "
"implementation to support only a minimum 32 distinct priority levels for the "
"real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr ""
"Для процессов, которые планируются одним из алгоритмов реального времени "
"(B<SCHED_FIFO>, B<SCHED_RR>), значение приоритета I<sched_priority> лежит в "
"диапазоне от 1 (низкий) до 99 (высокий) Как и числовые значения, нити "
"реального времени всегда имеют более высокий приоритет чем обычные нити. Но "
"заметим: согласно POSIX.1 от реализации для алгоритмов реального времени "
"требуется поддержка только 32 различных уровней приоритета, и в некоторых "
"системах обеспечивается только этот минимум. В переносимых программах нужно "
"использовать вызовы B<sched_get_priority_min>(2) и "
"B<sched_get_priority_max>(2) для для определения диапазона приоритетов, "
"поддерживаемых определённым алгоритмом."

#. type: Plain text
#: man-pages/man7/sched.7:138
msgid ""
"Conceptually, the scheduler maintains a list of runnable threads for each "
"possible I<sched_priority> value.  In order to determine which thread runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the thread at the head of this list."
msgstr ""
"По существу, планировщик хранит в памяти списки всех работающих нитей для "
"каждого возможного значения I<sched_priority>. Чтобы определить какую нить "
"выполнять следующей, планировщик ищет непустой список с самым высоким "
"статическим приоритетом и выбирает нить из начала списка."

#. type: Plain text
#: man-pages/man7/sched.7:142
msgid ""
"A thread's scheduling policy determines where it will be inserted into the "
"list of threads with equal static priority and how it will move inside this "
"list."
msgstr ""
"Алгоритм планирования определяет, в какое место списка будет добавлена нить "
"с тем же статическим приоритетом и как она будет перемещаться внутри этого "
"списка."

#. type: Plain text
#: man-pages/man7/sched.7:150
msgid ""
"All scheduling is preemptive: if a thread with a higher static priority "
"becomes ready to run, the currently running thread will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy determines the ordering only within the list of runnable threads with "
"equal static priority."
msgstr ""
"Всё планирование основано на вытеснении: если нить с высшим статическим "
"приоритетом готова к выполнению, текущая выполняющаяся нить будет вытеснена "
"и возвращена в список ожидания согласно своему уровню статического "
"приоритета. Алгоритм выполнения определяет порядок только внутри списка "
"готовых к выполнению нитей с одинаковым статическим приоритетом."

#. type: SS
#: man-pages/man7/sched.7:150
#, no-wrap
msgid "SCHED_FIFO: First in-first out scheduling"
msgstr "SCHED_FIFO: планировщик «первым вошёл — первым вышел»"

#. type: Plain text
#: man-pages/man7/sched.7:159
msgid ""
"B<SCHED_FIFO> can be used only with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> threads becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> thread.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For threads scheduled under the B<SCHED_FIFO> policy, "
"the following rules apply:"
msgstr ""
"Алгоритм B<SCHED_FIFO> можно использовать только со значениями статического "
"приоритета большими нуля. Это означает, что если нить с B<SCHED_FIFO> готова "
"к работе, то она сразу запустится, а все обычные нити с B<SCHED_OTHER>, "
"B<SCHED_BATCH> или B<SCHED_IDLE> будут приостановлены. B<SCHED_FIFO> — это "
"простой алгоритм планирования без квантования времени. Нити, работающие "
"согласно алгоритму B<SCHED_FIFO>, подчиняются следующим правилам:"

#. type: IP
#: man-pages/man7/sched.7:159
#, no-wrap
msgid "1)"
msgstr "1)"

#. type: Plain text
#: man-pages/man7/sched.7:164
msgid ""
"A running B<SCHED_FIFO> thread that has been preempted by another thread of "
"higher priority will stay at the head of the list for its priority and will "
"resume execution as soon as all threads of higher priority are blocked again."
msgstr ""
"Нить, выполняемая с алгоритмом B<SCHED_FIFO> и вытесненная другой нитью с "
"большим приоритетом, останется в начале списка нитей с приоритетом как у "
"неё, и её исполнение будет продолжено сразу после того, как закончатся нити "
"с большими приоритетами."

#. type: IP
#: man-pages/man7/sched.7:164
#, no-wrap
msgid "2)"
msgstr "2)"

#. type: Plain text
#: man-pages/man7/sched.7:167
msgid ""
"When a blocked B<SCHED_FIFO> thread becomes runnable, it will be inserted at "
"the end of the list for its priority."
msgstr ""
"Когда заблокированная нить с алгоритмом B<SCHED_FIFO> готова к работе, она "
"помещается в конец списка нитей с приоритетом как у неё."

#. type: IP
#: man-pages/man7/sched.7:167
#, no-wrap
msgid "3)"
msgstr "3)"

#. type: Plain text
#: man-pages/man7/sched.7:181
msgid ""
"If a call to B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<sched_setattr>(2), B<pthread_setschedparam>(3), or "
"B<pthread_setschedprio>(3)  changes the priority of the running or runnable "
"B<SCHED_FIFO> thread identified by I<pid> the effect on the thread's "
"position in the list depends on the direction of the change to threads "
"priority:"
msgstr ""
"Если вызовом B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<sched_setattr>(2), B<pthread_setschedparam>(3) или "
"B<pthread_setschedprio>(3) изменяется приоритет выполняющейся или готовой к "
"выполнению нити B<SCHED_FIFO>, задаваемой I<pid>, то  результат положения "
"нити в списке зависит от направления изменения приоритета нити:"

#. type: IP
#: man-pages/man7/sched.7:182 man-pages/man7/sched.7:187
#: man-pages/man7/sched.7:190
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man7/sched.7:187
msgid ""
"If the thread's priority is raised, it is placed at the end of the list for "
"its new priority.  As a consequence, it may preempt a currently running "
"thread with the same priority."
msgstr ""
"Если приоритет нити повышается, то она помещается в конец списка со своим "
"новым приоритетом. В результате, может быть вытеснена выполняемая в этот "
"момент нить с таким же приоритетом."

#. type: Plain text
#: man-pages/man7/sched.7:190
msgid ""
"If the thread's priority is unchanged, its position in the run list is "
"unchanged."
msgstr ""
"Если приоритет нити не изменяется, то её положение в списке выполнения не "
"изменяется."

#. type: Plain text
#: man-pages/man7/sched.7:193
msgid ""
"If the thread's priority is lowered, it is placed at the front of the list "
"for its new priority."
msgstr ""
"Если приоритет нити понижается, то она помещается в начало списка со своим "
"новым приоритетом."

#.  In 2.2.x and 2.4.x, the thread is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
#. type: Plain text
#: man-pages/man7/sched.7:202
msgid ""
"According to POSIX.1-2008, changes to a thread's priority (or policy) using "
"any mechanism other than B<pthread_setschedprio>(3)  should result in the "
"thread being placed at the end of the list for its priority."
msgstr ""
"Согласно POSIX.1-2008 изменение приоритета нити (или алгоритма) с помощью "
"какого-либо механизма отличного от B<pthread_setschedprio>(3), должно "
"приводить к размещению нити в конец списка с её приоритетом."

#. type: IP
#: man-pages/man7/sched.7:202
#, no-wrap
msgid "4)"
msgstr "4)"

#. type: Plain text
#: man-pages/man7/sched.7:206
msgid "A thread calling B<sched_yield>(2)  will be put at the end of the list."
msgstr "Нить, вызывающая B<sched_yield>(2), будет помещена в конец списка."

#. type: Plain text
#: man-pages/man7/sched.7:210
msgid ""
"No other events will move a thread scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable threads with equal static priority."
msgstr ""
"Других событий для перемещения нити с алгоритмом B<SCHED_FIFO> в списке "
"ожидания запускаемых нитей с одинаковым статическим приоритетом не "
"существует."

#. type: Plain text
#: man-pages/man7/sched.7:215
msgid ""
"A B<SCHED_FIFO> thread runs until either it is blocked by an I/O request, it "
"is preempted by a higher priority thread, or it calls B<sched_yield>(2)."
msgstr ""
"Нить с алгоритмом B<SCHED_FIFO> выполняется до тех пор, пока не будет "
"заблокирована запросом ввода/вывода, вытеснена нитью с большим приоритетом "
"или пока не вызовет B<sched_yield>(2)."

#. type: SS
#: man-pages/man7/sched.7:215
#, no-wrap
msgid "SCHED_RR: Round-robin scheduling"
msgstr "SCHED_RR: планирование выполнения по циклу"

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: man-pages/man7/sched.7:234
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each thread "
"is allowed to run only for a maximum time quantum.  If a B<SCHED_RR> thread "
"has been running for a time period equal to or longer than the time quantum, "
"it will be put at the end of the list for its priority.  A B<SCHED_RR> "
"thread that has been preempted by a higher priority thread and subsequently "
"resumes execution as a running thread will complete the unexpired portion of "
"its round-robin time quantum.  The length of the time quantum can be "
"retrieved using B<sched_rr_get_interval>(2)."
msgstr ""
"B<SCHED_RR> — это просто улучшение B<SCHED_FIFO>. Всё, относящееся к "
"B<SCHED_FIFO>, справедливо и для B<SCHED_RR> за исключением того, что каждой "
"нити разрешено работать непрерывно не дольше максимального кванта времени. "
"Если нить с алгоритмом B<SCHED_RR> работала столько же или дольше, чем "
"квант, то она помещается в конец списка с тем же приоритетом. Нить с "
"алгоритмом B<SCHED_RR>, вытесненная нитью с большим приоритетом, возобновляя "
"работу, использует остаток своего кванта из старого цикла. Длину этого "
"кванта можно узнать, вызвав B<sched_rr_get_interval>(2)."

#. type: SS
#: man-pages/man7/sched.7:234
#, no-wrap
msgid "SCHED_DEADLINE: Sporadic task model deadline scheduling"
msgstr "SCHED_DEADLINE: Модель планирования случайной задачи с предельным сроком"

#. type: Plain text
#: man-pages/man7/sched.7:246
msgid ""
"Since version 3.14, Linux provides a deadline scheduling policy "
"(B<SCHED_DEADLINE>).  This policy is currently implemented using GEDF "
"(Global Earliest Deadline First)  in conjunction with CBS (Constant "
"Bandwidth Server).  To set and fetch this policy and associated attributes, "
"one must use the Linux-specific B<sched_setattr>(2)  and "
"B<sched_getattr>(2)  system calls."
msgstr ""
"Начиная с версии 3.14, в Linux появился алгоритм планирования с предельным "
"сроком (B<SCHED_DEADLINE>). Сейчас этот алгоритм реализован с помощью GEDF "
"(Global Earliest Deadline First) в совокупности с CBS (Constant Bandwidth "
"Server). Для назначения и выборки данного алгоритма и его атрибутов, нужно "
"использовать системные вызовы (есть только в Linux) B<sched_setattr>(2) и "
"B<sched_getattr>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:264
msgid ""
"A sporadic task is one that has a sequence of jobs, where each job is "
"activated at most once per period.  Each job also has a I<relative "
"deadline>, before which it should finish execution, and a I<computation "
"time>, which is the CPU time necessary for executing the job.  The moment "
"when a task wakes up because a new job has to be executed is called the "
"I<arrival time> (also referred to as the request time or release time).  The "
"I<start time> is the time at which a task starts its execution.  The "
"I<absolute deadline> is thus obtained by adding the relative deadline to the "
"arrival time."
msgstr ""
"Случайная задача — одна из последовательности заданий (jobs), где каждое "
"задание активизируется не более чем один раз за промежуток времени. Также у "
"каждого задания есть I<относительный крайний срок>, до которого оно должно "
"завершить выполнение и I<время вычисления> — время ЦП, необходимое для "
"выполнения задания. Момент, когда задача пробуждается из-за выполнения "
"нового задания, называется I<временем принятия (arrival time)> (его ещё "
"называют временем запроса (request time) или временем выпуска (release "
"time). I<Время начала> — это время когда задача начинает выполнение. "
"I<Абсолютный предельный срок> получается сложением относительного "
"предельного срока с временем принятия."

#. type: Plain text
#: man-pages/man7/sched.7:266
msgid "The following diagram clarifies these terms:"
msgstr "Эти определения показаны в следующей диаграмме:"

#. type: Plain text
#: man-pages/man7/sched.7:277
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>- comp. time -E<gt>|\n"
"     |E<lt>------- relative deadline ------E<gt>|\n"
"     |E<lt>-------------- period -------------------E<gt>|\n"
msgstr ""
"принятие/пробуждение                    абсолютный предельный срок\n"
"     |    время начала                  |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>- comp. time -E<gt>|\n"
"     |E<lt>------- относительный предельный срок ------E<gt>|\n"
"     |E<lt>-------------- промежуток времени -------------------E<gt>|\n"

#. type: Plain text
#: man-pages/man7/sched.7:296
msgid ""
"When setting a B<SCHED_DEADLINE> policy for a thread using "
"B<sched_setattr>(2), one can specify three parameters: I<Runtime>, "
"I<Deadline>, and I<Period>.  These parameters do not necessarily correspond "
"to the aforementioned terms: usual practice is to set Runtime to something "
"bigger than the average computation time (or worst-case execution time for "
"hard real-time tasks), Deadline to the relative deadline, and Period to the "
"period of the task.  Thus, for B<SCHED_DEADLINE> scheduling, we have:"
msgstr ""
"При назначении нити алгоритма B<SCHED_DEADLINE> с помощью "
"B<sched_setattr>(2) можно указать три параметра: I<Runtime>, I<Deadline> и "
"I<Period>. Эти параметры не обязательно соответствуют вышеупомянутым "
"терминам: на практике, Runtime задаётся чуть больше чем среднее время "
"вычисления (или время вычисления в самом плохом варианте для задач жёсткого "
"реального времени), Deadline равен относительному предельному сроку, а "
"Period равен промежутку времени. Таким образом, при планировании "
"B<SCHED_DEADLINE> мы имеем:"

#. type: Plain text
#: man-pages/man7/sched.7:307
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>-- Runtime -------E<gt>|\n"
"     |E<lt>----------- Deadline -----------E<gt>|\n"
"     |E<lt>-------------- Period -------------------E<gt>|\n"
msgstr ""
"принятие/пробуждение                    абсолютный предельный срок\n"
"     |    время начала                  |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>-- Runtime -------E<gt>|\n"
"     |E<lt>----------- Deadline -----------E<gt>|\n"
"     |E<lt>-------------- Period -------------------E<gt>|\n"

#.  FIXME It looks as though specifying sched_period as 0 means
#.  "make sched_period the same as sched_deadline".
#.  This needs to be documented.
#. type: Plain text
#: man-pages/man7/sched.7:327
msgid ""
"The three deadline-scheduling parameters correspond to the I<sched_runtime>, "
"I<sched_deadline>, and I<sched_period> fields of the I<sched_attr> "
"structure; see B<sched_setattr>(2).  These fields express values in "
"nanoseconds.  If I<sched_period> is specified as 0, then it is made the same "
"as I<sched_deadline>."
msgstr ""
"Три параметра алгоритма с крайним сроком соответствуют полям  "
"I<sched_runtime>, I<sched_deadline> и I<sched_period> структуры "
"I<sched_attr>; смотрите B<sched_setattr>(2). Значения этих полей задаются в "
"наносекундах. Если I<sched_period> равно 0, то его значение равно "
"I<sched_deadline>."

#. type: Plain text
#: man-pages/man7/sched.7:329
msgid "The kernel requires that:"
msgstr "Для ядра требуется соблюдение условия:"

#. type: Plain text
#: man-pages/man7/sched.7:331
#, no-wrap
msgid "    sched_runtime E<lt>= sched_deadline E<lt>= sched_period\n"
msgstr "    sched_runtime E<lt>= sched_deadline E<lt>= sched_period\n"

#.  See __checkparam_dl in kernel/sched/core.c
#. type: Plain text
#: man-pages/man7/sched.7:341
msgid ""
"In addition, under the current implementation, all of the parameter values "
"must be at least 1024 (i.e., just over one microsecond, which is the "
"resolution of the implementation), and less than 2^63.  If any of these "
"checks fails, B<sched_setattr>(2)  fails with the error B<EINVAL>."
msgstr ""
"Также, в текущей реализации, значения всех параметров должны быть не менее "
"1024 (т. е., чуть более одной микросекунды, ограничено в реализации) и "
"меньше 2^63. При нарушении ограничений B<sched_setattr>(2) завершается с "
"ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man7/sched.7:344
msgid ""
"The CBS guarantees non-interference between tasks, by throttling threads "
"that attempt to over-run their specified Runtime."
msgstr ""
"CBS гарантирует отсутствие влияния задача друг на друга, регулируя "
"(throttling) нити, которые пытаются превысить заданное им время выполнения "
"(Runtime)."

#. type: Plain text
#: man-pages/man7/sched.7:357
msgid ""
"To ensure deadline scheduling guarantees, the kernel must prevent situations "
"where the set of B<SCHED_DEADLINE> threads is not feasible (schedulable) "
"within the given constraints.  The kernel thus performs an admittance test "
"when setting or changing B<SCHED_DEADLINE> policy and attributes.  This "
"admission test calculates whether the change is feasible; if it is not, "
"B<sched_setattr>(2)  fails with the error B<EBUSY>."
msgstr ""
"Чтобы гарантировать выполнение алгоритма планирования крайнего срока, ядро "
"должно предотвращать ситуации, где установка B<SCHED_DEADLINE> нитям не "
"выполнима (не может быть запланирована) для указанных ограничений. Для этого "
"ядро выполняет тест допустимости при назначении или изменении алгоритма "
"B<SCHED_DEADLINE> и атрибутов. В данном тесте вычисляется, выполнимы ли "
"изменения; если нет, то B<sched_setattr>(2) завершается с ошибкой B<EBUSY>."

#. type: Plain text
#: man-pages/man7/sched.7:363
msgid ""
"For example, it is required (but not necessarily sufficient) for the total "
"utilization to be less than or equal to the total number of CPUs available, "
"where, since each thread can maximally run for Runtime per Period, that "
"thread's utilization is its Runtime divided by its Period."
msgstr ""
"Например, для этого требуется (но не обязательно достаточно), чтобы общая "
"загруженность была меньше или равной общему количеству доступных ЦП, так как "
"каждая нить максимально может работать весь промежуток времени, то есть "
"загруженность нити равна её Runtime, поделённый на Period."

#. type: Plain text
#: man-pages/man7/sched.7:374
msgid ""
"In order to fulfill the guarantees that are made when a thread is admitted "
"to the B<SCHED_DEADLINE> policy, B<SCHED_DEADLINE> threads are the highest "
"priority (user controllable) threads in the system; if any B<SCHED_DEADLINE> "
"thread is runnable, it will preempt any thread scheduled under one of the "
"other policies."
msgstr ""
"Чтобы удовлетворить гарантиям, которые даются, когда нити назначен алгоритм "
"B<SCHED_DEADLINE>, нити с B<SCHED_DEADLINE> имеют наивысший приоритет "
"(управляется пользователем) по сравнению с другими нитями в системе; если "
"нить с B<SCHED_DEADLINE> запускается, то она вытеснит любую нить, "
"запланированную любым другим алгоритмом."

#. type: Plain text
#: man-pages/man7/sched.7:382
msgid ""
"A call to B<fork>(2)  by a thread scheduled under the B<SCHED_DEADLINE> "
"policy fails with the error B<EAGAIN>, unless the thread has its reset-on-"
"fork flag set (see below)."
msgstr ""
"Вызов B<fork>(2) в нити, запланированной B<SCHED_DEADLINE> завершается "
"ошибкой B<EAGAIN>, если у нити не установлен флаг reset-on-fork (смотрите "
"далее)."

#.  FIXME Calling sched_getparam() on a SCHED_DEADLINE thread
#.  fails with EINVAL, but sched_getscheduler() succeeds.
#.  Is that intended? (Why?)
#. type: Plain text
#: man-pages/man7/sched.7:393
msgid ""
"A B<SCHED_DEADLINE> thread that calls B<sched_yield>(2)  will yield the "
"current job and wait for a new period to begin."
msgstr ""
"Нить с B<SCHED_DEADLINE>, вызывающая B<sched_yield>(2) приостановит текущее "
"задание и будет ждать начала нового промежутка времени."

#. type: SS
#: man-pages/man7/sched.7:393
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr "SCHED_OTHER: планирование с разделение времени (по умолчанию в Linux)"

#. type: Plain text
#: man-pages/man7/sched.7:401
msgid ""
"B<SCHED_OTHER> can be used at only static priority 0 (i.e., threads under "
"real-time policies always have priority over B<SCHED_OTHER> processes).  "
"B<SCHED_OTHER> is the standard Linux time-sharing scheduler that is intended "
"for all threads that do not require the special real-time mechanisms."
msgstr ""
"B<SCHED_OTHER> можно использовать только с статическим приоритетом 0 (то "
"есть, нити, работающие по алгоритму реального времени, всегда имеют "
"приоритет над процессами с B<SCHED_OTHER>). B<SCHED_OTHER> — это стандартный "
"планировщик Linux с разделением времени, предназначенный для всех нитей, не "
"требующих специальных механизмов реального времени."

#. type: Plain text
#: man-pages/man7/sched.7:409
msgid ""
"The thread to run is chosen from the static priority 0 list based on a "
"I<dynamic> priority that is determined only inside this list.  The dynamic "
"priority is based on the nice value (see below)  and is increased for each "
"time quantum the thread is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> threads."
msgstr ""
"Для выполнения выбирается нить из списка со статическим приоритетом 0 на "
"основе I<динамического> приоритета, существующего только внутри этого "
"списка. Динамический приоритет основан на значении уступчивости (смотрите "
"ниже) и увеличивается с каждым квантом времени, при котором нить была готова "
"к работе, но ей было отказано в этом планировщиком. Таким образом время "
"равномерно распределяется между всеми нитями с алгоритмом B<SCHED_OTHER>."

#. type: Plain text
#: man-pages/man7/sched.7:415
msgid ""
"In the Linux kernel source code, the B<SCHED_OTHER> policy is actually named "
"B<SCHED_NORMAL>."
msgstr ""
"В дереве исходного кода ядра Linux алгоритм B<SCHED_OTHER> на самом деле "
"называется B<SCHED_NORMAL>."

#. type: SS
#: man-pages/man7/sched.7:415
#, no-wrap
msgid "The nice value"
msgstr "Значение уступчивости"

#. type: Plain text
#: man-pages/man7/sched.7:429
msgid ""
"The nice value is an attribute that can be used to influence the CPU "
"scheduler to favor or disfavor a process in scheduling decisions.  It "
"affects the scheduling of B<SCHED_OTHER> and B<SCHED_BATCH> (see below) "
"processes.  The nice value can be modified using B<nice>(2), "
"B<setpriority>(2), or B<sched_setattr>(2)."
msgstr ""
"Значение уступчивости — это атрибут, который можно использовать для влияния "
"на планировщик ЦП с целью сделать процесс более популярным (или наоборот) "
"при принятии решений о планировании выполнения. Он учитывается при "
"планировании процессов с B<SCHED_OTHER> и B<SCHED_BATCH> (смотрите ниже). "
"Значение уступчивости можно изменять с помощью B<nice>(2), B<setpriority>(2) "
"или B<sched_setattr>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:434
msgid ""
"According to POSIX.1, the nice value is a per-process attribute; that is, "
"the threads in a process should share a nice value.  However, on Linux, the "
"nice value is a per-thread attribute: different threads in the same process "
"may have different nice values."
msgstr ""
"Согласно POSIX.1, значение уступчивости является атрибутом процесса; то есть "
"нити процесса должны иметь одинаковое значение уступчивости. Однако в Linux "
"значение уступчивости является атрибутом нити: разные нити одного процесса "
"могут иметь разные значения уступчивости."

#.  Linux before 1.3.36 had \-infinity..15.
#.  Since kernel 1.3.43, Linux has the range \-20..19.
#. type: Plain text
#: man-pages/man7/sched.7:442
msgid ""
"The range of the nice value varies across UNIX systems.  On modern Linux, "
"the range is -20 (high priority) to +19 (low priority).  On some other "
"systems, the range is -20..20.  Very early Linux kernels (Before Linux 2.0) "
"had the range -infinity..15."
msgstr ""
"Диапазон значений уступчивости различается в разных системах UNIX. В "
"современном Linux диапазон: -20 (высокий приоритет) по +19 (низкий "
"приоритет). В других системах диапазон равен -20..20. В самых первых версиях "
"ядра Linux (до Linux 2.0) диапазон равнялся -бесконечность..15."

#. type: Plain text
#: man-pages/man7/sched.7:447
msgid ""
"The degree to which the nice value affects the relative scheduling of "
"B<SCHED_OTHER> processes likewise varies across UNIX systems and across "
"Linux kernel versions."
msgstr ""
"Степень влияния значения уступчивости на процессы с подобным B<SCHED_OTHER> "
"в разных системах UNIX различна и не одинакова даже между версиями ядра "
"Linux."

#. type: Plain text
#: man-pages/man7/sched.7:459
msgid ""
"With the advent of the CFS scheduler in kernel 2.6.23, Linux adopted an "
"algorithm that causes relative differences in nice values to have a much "
"stronger effect.  In the current implementation, each unit of difference in "
"the nice values of two processes results in a factor of 1.25 in the degree "
"to which the scheduler favors the higher priority process.  This causes very "
"low nice values (+19) to truly provide little CPU to a process whenever "
"there is any other higher priority load on the system, and makes high nice "
"values (-20) deliver most of the CPU to applications that require it (e.g., "
"some audio applications)."
msgstr ""
"С появлением планировщика CFS в ядре 2.6.23, в Linux стал применяться "
"алгоритм, учитывающий относительную разницу значений уступчивости более "
"полно. В текущей реализации каждое различие на единицу между значениями "
"уступчивости двух процессов приводит к умножению приоритета на 1.25, с "
"которым планировщик отдаёт предпочтение процессу с более высоким "
"приоритетом. Это приводит к тому, что самые низкие значения уступчивости "
"(+19) действительно получают очень мало времени ЦП независимо от того, есть "
"ли высокая загрузка системы, и по высоким значениям уступчивости (-20) "
"даётся больше времени на ЦП приложениям, которым это нужно (например, "
"некоторым аудиоприложениям)."

#. type: Plain text
#: man-pages/man7/sched.7:466
msgid ""
"On Linux, the B<RLIMIT_NICE> resource limit can be used to define a limit to "
"which an unprivileged process's nice value can be raised; see "
"B<setrlimit>(2)  for details."
msgstr ""
"Для задания ограничения, до которого можно повышать значение уступчивости "
"непривилегированному процессу, в используется Linux ограничение ресурса "
"B<RLIMIT_NICE>; смотрите B<setrlimit>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:470
msgid ""
"For further details on the nice value, see the subsections on the autogroup "
"feature and group scheduling, below."
msgstr ""
"Дополнительную информацию о значении уступчивости смотрите подразделы "
"свойств автогруппировки и группового планирования ниже."

#. type: SS
#: man-pages/man7/sched.7:470
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr "SCHED_BATCH: планирование для пакетных процессов"

#. type: Plain text
#: man-pages/man7/sched.7:482
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can be used only at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the thread "
"according to its dynamic priority (based on the nice value).  The difference "
"is that this policy will cause the scheduler to always assume that the "
"thread is CPU-intensive.  Consequently, the scheduler will apply a small "
"scheduling penalty with respect to wakeup behavior, so that this thread is "
"mildly disfavored in scheduling decisions."
msgstr ""
"(начиная с Linux 2.6.16) B<SCHED_BATCH> можно использовать только с "
"статическим приоритетом равным нулю. Этот алгоритм похож на B<SCHED_OTHER> в "
"том, что он планирует выполнение нити на основе её динамического приоритета "
"(на основе значения nice). Различие в том, что в этом алгоритме планировщик "
"всегда предполагает, что нить, в основном, использует ЦП. Следовательно, "
"планировщик немного понизит вероятность её следующего пробуждения для того, "
"чтобы эта нить уступила другим при планировании."

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#.  commit b0a9499c3dd50d333e2aedb7e894873c58da3785
#. type: Plain text
#: man-pages/man7/sched.7:492
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""
"Этот алгоритм полезен при нагрузках не интерактивными задачами, но когда "
"нежелательно понижать их значение nice и для задач, которым требуется "
"предсказуемый алгоритм планирования без интерактивности, который приводит к "
"дополнительным вытеснениям (между задачами нагрузки)."

#. type: SS
#: man-pages/man7/sched.7:492
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr "SCHED_IDLE: планирование заданий с очень низким приоритетом"

#. type: Plain text
#: man-pages/man7/sched.7:496
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can be used only at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""
"(начиная с Linux 2.6.23)  B<SCHED_IDLE> можно использовать только с "
"статическим приоритетом равным нулю; значение nice не учитывает в этом "
"алгоритме."

#. type: Plain text
#: man-pages/man7/sched.7:504
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""
"Данный алгоритм предназначен для выполнения заданий с чрезвычайно низким "
"приоритетом (даже ниже чем значение nice +19 в алгоритме B<SCHED_OTHER> или "
"B<SCHED_BATCH>)."

#. type: SS
#: man-pages/man7/sched.7:504
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr "Сброс алгоритма планирования у дочерних процессов"

#. type: Plain text
#: man-pages/man7/sched.7:510
msgid ""
"Each thread has a reset-on-fork scheduling flag.  When this flag is set, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  The reset-on-fork flag can be set by either:"
msgstr ""
"В каждой нити есть флаг планирования reset-on-fork. Когда этот флаг "
"установлен, потомки, создаваемые B<fork>(2), не наследуют привилегированные "
"алгоритмы планирования. Флаг reset-on-fork может быть задан так:"

#. type: Plain text
#: man-pages/man7/sched.7:519
msgid ""
"ORing the B<SCHED_RESET_ON_FORK> flag into the I<policy> argument when "
"calling B<sched_setscheduler>(2)  (since Linux 2.6.32); or"
msgstr ""
"Логическим сложением флага B<SCHED_RESET_ON_FORK> с аргументом I<policy> при "
"вызове B<sched_setscheduler>(2) (начиная с Linux 2.6.32); или"

#. type: Plain text
#: man-pages/man7/sched.7:526
msgid ""
"specifying the B<SCHED_FLAG_RESET_ON_FORK> flag in I<attr.sched_flags> when "
"calling B<sched_setattr>(2)."
msgstr ""
"заданием флага B<SCHED_FLAG_RESET_ON_FORK> в I<attr.sched_flags> при вызове "
"B<sched_setattr>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:532
msgid ""
"Note that the constants used with these two APIs have different names.  The "
"state of the reset-on-fork flag can analogously be retrieved using "
"B<sched_getscheduler>(2)  and B<sched_getattr>(2)."
msgstr ""
"Заметим, что константы, используемые в этих двух вызовам имеют разные имена. "
"Состояние флага reset-on-fork может быть получено аналогичным образом с "
"помощью B<sched_getscheduler>(2) и B<sched_getattr>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:539
msgid ""
"The reset-on-fork feature is intended for media-playback applications, and "
"can be used to prevent applications evading the B<RLIMIT_RTTIME> resource "
"limit (see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""
"Возможность reset-on-fork предназначена для приложений, проигрывающих медиа-"
"файлы, и может использоваться для обхождения ограничения ресурса "
"B<RLIMIT_RTTIME> (см. B<getrlimit>(2)), посредством создания нескольких "
"дочерних процессов."

#. type: Plain text
#: man-pages/man7/sched.7:542
msgid ""
"More precisely, if the reset-on-fork flag is set, the following rules apply "
"for subsequently created children:"
msgstr ""
"Точнее говоря, если указан флаг reset-on-fork, то к новым потомкам "
"применяются следующие правила:"

#. type: Plain text
#: man-pages/man7/sched.7:550
msgid ""
"If the calling thread has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""
"Если вызывающая нить имеет алгоритм планирования B<SCHED_FIFO> или "
"B<SCHED_RR>, то у потомков алгоритм сбрасывается в B<SCHED_OTHER>."

#. type: Plain text
#: man-pages/man7/sched.7:553
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""
"Если у вызывающего процесса значение nice отрицательно, то у потомков "
"значение nice сбрасывается в ноль."

#. type: Plain text
#: man-pages/man7/sched.7:561
msgid ""
"After the reset-on-fork flag has been enabled, it can be reset only if the "
"thread has the B<CAP_SYS_NICE> capability.  This flag is disabled in child "
"processes created by B<fork>(2)."
msgstr ""
"После установки флага reset-on-fork его можно сбросить только, если нить "
"имеет мандат B<CAP_SYS_NICE>. Этот флаг выключается у потомков, созданных "
"через B<fork>(2)."

#. type: SS
#: man-pages/man7/sched.7:561
#, no-wrap
msgid "Privileges and resource limits"
msgstr "Привилегии и ограничения по ресурсам"

#. type: Plain text
#: man-pages/man7/sched.7:573
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  threads "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged thread can make is to set the "
"B<SCHED_OTHER> policy, and this can be done only if the effective user ID of "
"the caller matches the real or effective user ID of the target thread (i.e., "
"the thread specified by I<pid>)  whose policy is being changed."
msgstr ""
"В ядрах Linux до версии 2.6.12, только привилегированные нити "
"(B<CAP_SYS_NICE>) могли устанавливать ненулевое значение статического "
"приоритета (т.е. алгоритм планирования реального времени). "
"Непривилегированные нити могли только установить алгоритм B<SCHED_OTHER>, и "
"это могло быть сделано только, если эффективный пользовательский "
"идентификатор вызывающего совпадал с реальным или эффективным "
"пользовательским идентификатором задаваемого нити (т.е., нити, указываемой в "
"I<pid>)."

#. type: Plain text
#: man-pages/man7/sched.7:579
msgid ""
"A thread must be privileged (B<CAP_SYS_NICE>)  in order to set or modify a "
"B<SCHED_DEADLINE> policy."
msgstr ""
"Для задания или изменения B<SCHED_DEADLINE> нить должна быть "
"привилегированной (B<CAP_SYS_NICE>)."

#. type: Plain text
#: man-pages/man7/sched.7:589
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged thread's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""
"Начиная с Linux 2.6.12, ограничитель ресурса B<RLIMIT_RTPRIO> определяет "
"максимум статического приоритета непривилегированной нити для алгоритмов "
"B<SCHED_RR> и B<SCHED_FIFO>. Правила для изменения алгоритма планирования и "
"приоритета:"

#. type: Plain text
#: man-pages/man7/sched.7:597
msgid ""
"If an unprivileged thread has a nonzero B<RLIMIT_RTPRIO> soft limit, then it "
"can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""
"Если непривилегированная нить имеет ненулевое значение мягкого ограничения "
"B<RLIMIT_RTPRIO>, то она может изменять свой алгоритм планирования и "
"приоритет, но при этом значение приоритета не может быть больше чем "
"максимальное значение её текущего приоритета и его мягкого ограничения "
"B<RLIMIT_RTPRIO>."

#. type: Plain text
#: man-pages/man7/sched.7:602
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""
"Если мягкое ограничение B<RLIMIT_RTPRIO> равно 0, то разрешается только "
"снижать приоритет или переключиться на алгоритм выполнения не реального "
"времени."

#. type: Plain text
#: man-pages/man7/sched.7:607
msgid ""
"Subject to the same rules, another unprivileged thread can also make these "
"changes, as long as the effective user ID of the thread making the change "
"matches the real or effective user ID of the target thread."
msgstr ""
"Согласно тем же самым правилам другая непривилегированная нить может также "
"сделать эти изменения, пока эффективный идентификатор пользователя нити, "
"производящей изменение, совпадает с реальным или эффективным идентификатором "
"пользователя изменяемой нити."

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: man-pages/man7/sched.7:626
msgid ""
"Special rules apply for the B<SCHED_IDLE> policy.  In Linux kernels before "
"2.6.39, an unprivileged thread operating under this policy cannot change its "
"policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In "
"Linux kernels since 2.6.39, an unprivileged thread can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_OTHER> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""
"Для политики B<SCHED_IDLE> применяются специальные правила. В ядрах Linux до "
"версии 2.6.39, сменить политику работы непривилегированной нити нельзя, "
"независимо от значения её ограничителя ресурсов B<RLIMIT_RTPRIO>. В ядрах "
"Linux начиная с версии 2.6.39, непривилегированная нить может переключиться "
"на политику B<SCHED_BATCH> или B<SCHED_OTHER>, если её значение уступчивости "
"находится в диапазоне, разрешённом ей ограничителем ресурсов B<RLIMIT_NICE> "
"(см. B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man7/sched.7:637
msgid ""
"Privileged (B<CAP_SYS_NICE>)  threads ignore the B<RLIMIT_RTPRIO> limit; as "
"with older kernels, they can make arbitrary changes to scheduling policy and "
"priority.  See B<getrlimit>(2)  for further information on B<RLIMIT_RTPRIO>."
msgstr ""
"Для привилегированных (B<CAP_SYS_NICE>) нитей ограничение B<RLIMIT_RTPRIO> "
"игнорируется; как в старых ядрах, они могут произвольно менять алгоритм "
"планирования и приоритет. Подробней смотрите в B<getrlimit>(2) про "
"B<RLIMIT_RTPRIO>."

#. type: SS
#: man-pages/man7/sched.7:637
#, no-wrap
msgid "Limiting the CPU usage of real-time and deadline processes"
msgstr "Ограничение использование ЦП процессами реального времени и процессами с крайним сроком"

#. type: Plain text
#: man-pages/man7/sched.7:650
msgid ""
"A nonblocking infinite loop in a thread scheduled under the B<SCHED_FIFO>, "
"B<SCHED_RR>, or B<SCHED_DEADLINE> policy can potentially block all other "
"threads from accessing the CPU forever.  Prior to Linux 2.6.25, the only way "
"of preventing a runaway real-time process from freezing the system was to "
"run (at the console)  a shell scheduled under a higher static priority than "
"the tested application.  This allows an emergency kill of tested real-time "
"applications that do not block or terminate as expected."
msgstr ""
"Неблокирующий бесконечный цикл в нити, запланированной алгоритмами "
"B<SCHED_FIFO>, B<SCHED_RR> или B<SCHED_DEADLINE> потенциально может привести "
"к вечному блокированию остальных нитей. До Linux 2.6.25 был только один "
"способ предотвращения заморозки системы бесконтрольными процессами реального "
"времени — запуск (с консоли) оболочки с наивысшим статическим приоритетом, "
"большим чем тестируемое приложение. Это позволяло экстренно прибить "
"тестируемое приложение реального времени, которое не блокируется или "
"завершается как положено."

#. type: Plain text
#: man-pages/man7/sched.7:660
msgid ""
"Since Linux 2.6.25, there are other techniques for dealing with runaway real-"
"time and deadline processes.  One of these is to use the B<RLIMIT_RTTIME> "
"resource limit to set a ceiling on the CPU time that a real-time process may "
"consume.  See B<getrlimit>(2)  for details."
msgstr ""
"Начиная с Linux 2.6.25, есть другие способы работы с процессами реального "
"времени и процессами с крайним сроком. Один из них — использовать "
"ограничитель ресурса B<RLIMIT_RTTIME>, задав потолок времени ЦП, которое "
"процесс реального времени может задействовать. Подробней смотрите в "
"B<getrlimit>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:668
msgid ""
"Since version 2.6.25, Linux also provides two I</proc> files that can be "
"used to reserve a certain amount of CPU time to be used by non-real-time "
"processes.  Reserving CPU time in this fashion allows some CPU time to be "
"allocated to (say) a root shell that can be used to kill a runaway process.  "
"Both of these files specify time values in microseconds:"
msgstr ""
"Начиная с версии 2.6.25, в Linux также предоставляется два файла в I</proc>, "
"которые можно использовать для резервирования определённого количества "
"времени ЦП, используемое процессами нереального времени. Резервирование "
"некоторого количества ЦП подобным образом позволяет оставить время на том же "
"ЦП (скажем) оболочке root, через которую можно завершить неконтролируемый "
"процесс. В этих файлах значение времени указывается в микросекундах:"

#. type: TP
#: man-pages/man7/sched.7:668
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_period_us>"
msgstr "I</proc/sys/kernel/sched_rt_period_us>"

#. type: Plain text
#: man-pages/man7/sched.7:676
msgid ""
"This file specifies a scheduling period that is equivalent to 100% CPU "
"bandwidth.  The value in this file can range from 1 to B<INT_MAX>, giving an "
"operating range of 1 microsecond to around 35 minutes.  The default value in "
"this file is 1,000,000 (1 second)."
msgstr ""
"В данном файле задаётся планируемый промежуток времени, который равен 100% "
"полосы ЦП. Значение в этом файле может лежать в диапазоне от 1 до "
"B<INT_MAX>, что даёт рабочий диапазон от 1 микросекунды до, приблизительно, "
"35 минут. Значение в файле по умолчанию равно 1000000 (1 секунда)."

#. type: TP
#: man-pages/man7/sched.7:676
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_runtime_us>"
msgstr "I</proc/sys/kernel/sched_rt_runtime_us>"

#. type: Plain text
#: man-pages/man7/sched.7:689
msgid ""
"The value in this file specifies how much of the \"period\" time can be used "
"by all real-time and deadline scheduled processes on the system.  The value "
"in this file can range from -1 to B<INT_MAX>-1.  Specifying -1 makes the run "
"time the same as the period; that is, no CPU time is set aside for non-real-"
"time processes (which was the Linux behavior before kernel 2.6.25).  The "
"default value in this file is 950,000 (0.95 seconds), meaning that 5% of the "
"CPU time is reserved for processes that don't run under a real-time or "
"deadline scheduling policy."
msgstr ""
"Значением в этом файле определяется насколько большой промежуток времени "
"может использоваться всеми процессами реального времени и процессами с "
"крайним сроком в системе. Диапазон значений: от -1 до B<INT_MAX>-1. Значение "
"-1 означает, что время выполнения равно промежутку времени; то есть нет "
"времени ЦП для приложений нереального времени (что соответствует поведению "
"Linux до версии ядра 2.6.25). Значение по умолчанию равно 950000 (0.95 "
"секунды), означающее, что 5% времени ЦП зарезервировано для процессов, "
"планирование которых выполняется не по алгоритму реального времени или "
"алгоритму с крайним сроком."

#. type: SS
#: man-pages/man7/sched.7:690
#, no-wrap
msgid "Response time"
msgstr "Время ответа"

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: man-pages/man7/sched.7:698
msgid ""
"A blocked high priority thread waiting for I/O has a certain response time "
"before it is scheduled again.  The device driver writer can greatly reduce "
"this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""
"Блокированная нить с высоким приоритетом, ожидающая ввода/вывода, "
"освобождает достаточно много процессорного времени до того, как снова начнёт "
"работать. Авторы драйверов устройств могут более эффективно использовать это "
"время, если воспользуются «медленным» обработчиком прерываний."

#. type: SS
#: man-pages/man7/sched.7:698
#, no-wrap
msgid "Miscellaneous"
msgstr "Разное"

#. type: Plain text
#: man-pages/man7/sched.7:703
msgid ""
"Child processes inherit the scheduling policy and parameters across a "
"B<fork>(2).  The scheduling policy and parameters are preserved across "
"B<execve>(2)."
msgstr ""
"Дочерние процессы наследуют алгоритм планирования и его параметры после "
"B<fork>(2). Алгоритм планирования и параметры сохраняются при вызове "
"B<execve>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:710
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""
"Обычно, процессам реального времени необходимо блокировать память для того, "
"чтобы избежать задержек при страничном обмене. Это можно сделать при помощи "
"вызова B<mlock>(2) или B<mlockall>(2)."

#. type: SS
#: man-pages/man7/sched.7:710
#, no-wrap
msgid "The autogroup feature"
msgstr "Свойство автогруппировки"

#.  commit 5091faa449ee0b7d73bc296a93bca9540fc51d0a
#. type: Plain text
#: man-pages/man7/sched.7:720
msgid ""
"Since Linux 2.6.38, the kernel provides a feature known as autogrouping to "
"improve interactive desktop performance in the face of multiprocess, CPU-"
"intensive workloads such as building the Linux kernel with large numbers of "
"parallel build processes (i.e., the B<make>(1)  B<-j> flag)."
msgstr ""
"Начиная с Linux 2.6.38 в ядре появилось свойство, называемое "
"автогруппировкой; оно улучшает интерактивность рабочего окружения несмотря "
"на многопроцессную интенсивную нагрузку ЦП, такую как сборка ядра Linux "
"большим количеством параллельно собирающих процессов (т. е., командой "
"B<make>(1) с флагом B<-j>)."

#. type: Plain text
#: man-pages/man7/sched.7:730
msgid ""
"This feature operates in conjunction with the CFS scheduler and requires a "
"kernel that is configured with B<CONFIG_SCHED_AUTOGROUP>.  On a running "
"system, this feature is enabled or disabled via the file I</proc/sys/kernel/"
"sched_autogroup_enabled>; a value of 0 disables the feature, while a value "
"of 1 enables it.  The default value in this file is 1, unless the kernel was "
"booted with the I<noautogroup> parameter."
msgstr ""
"Данное свойств работает совместно с планировщиком CFS, и ядро должно быть "
"собрано с параметром B<CONFIG_SCHED_AUTOGROUP>. В работающей системе "
"свойство можно включать и выключать через файл I</proc/sys/kernel/"
"sched_autogroup_enabled>; значение 0 выключает свойство, а 1 — включает. "
"Значение по умолчанию равно 1, если ядро не загружалось с параметром "
"I<noautogroup>."

#. type: Plain text
#: man-pages/man7/sched.7:740
msgid ""
"A new autogroup is created when a new session is created via B<setsid>(2); "
"this happens, for example, when a new terminal window is started.  A new "
"process created by B<fork>(2)  inherits its parent's autogroup membership.  "
"Thus, all of the processes in a session are members of the same autogroup.  "
"An autogroup is automatically destroyed when the last process in the group "
"terminates."
msgstr ""
"Новая автогруппа создаётся при создании нового сеанса с помощью "
"B<setsid>(2); например, это происходит при запуске нового окна терминала. "
"Новый процесс, созданный B<fork>(2), наследует членство в автогруппе "
"родителя. Таким образом, все процессы в сеансе являются членами одной "
"автогруппы. Автогруппа автоматически уничтожается при завершении последнего "
"процесса в группе."

#. type: Plain text
#: man-pages/man7/sched.7:747
msgid ""
"When autogrouping is enabled, all of the members of an autogroup are placed "
"in the same kernel scheduler \"task group\".  The CFS scheduler employs an "
"algorithm that equalizes the distribution of CPU cycles across task groups.  "
"The benefits of this for interactive desktop performance can be described "
"via the following example."
msgstr ""
"При включенной автогруппировке все члены автогруппы помещаются в в одну "
"«группу задач» планировщика ядра. Планировщик CFS использует алгоритм, "
"который уравнивает раздачу циклов ЦП между задачами группы. Преимущество "
"такого подхода заключается в улучшении интерактивности рабочего стола, "
"которую можно описать следующим примером."

#.  Mike Galbraith, 25 Nov 2016:
#.      I'd say something more wishy-washy here, like cycles are
#.      distributed fairly across groups and leave it at that, as your
#.      detailed example is incorrect due to SMP fairness (which I don't
#.      like much because [very unlikely] worst case scenario
#.      renders a box sized group incapable of utilizing more that
#.      a single CPU total).  For example, if a group of NR_CPUS
#.      size competes with a singleton, load balancing will try to give
#.      the singleton a full CPU of its very own.  If groups intersect for
#.      whatever reason on say my quad lappy, distribution is 80/20 in
#.      favor of the singleton.
#. type: Plain text
#: man-pages/man7/sched.7:778
msgid ""
"Suppose that there are two autogroups competing for the same CPU (i.e., "
"presume either a single CPU system or the use of B<taskset>(1)  to confine "
"all the processes to the same CPU on an SMP system).  The first group "
"contains ten CPU-bound processes from a kernel build started with I<make\\ -"
"j10>.  The other contains a single CPU-bound process: a video player.  The "
"effect of autogrouping is that the two groups will each receive half of the "
"CPU cycles.  That is, the video player will receive 50% of the CPU cycles, "
"rather than just 9% of the cycles, which would likely lead to degraded video "
"playback.  The situation on an SMP system is more complex, but the general "
"effect is the same: the scheduler distributes CPU cycles across task groups "
"such that an autogroup that contains a large number of CPU-bound processes "
"does not end up hogging CPU cycles at the expense of the other jobs on the "
"system."
msgstr ""
"Предположим, что есть две автогруппы, выполняющиеся на одном ЦП (т. е., "
"используется система с одним ЦП или с помощью B<taskset>(1) все процессы "
"вытеснены на один ЦП в многопроцессорной системе). Первая группа содержит 10 "
"привязанных к ЦП процессов, запущенных для сборки ядра I<make\\ -j10>. "
"Вторая группа содержит один привязанный к ЦП процесс: видеопроигрыватель. Из-"
"за автогруппировки в том, что каждая из групп получит половину циклов ЦП. То "
"есть, видеопроигрыватель получит 50% циклов ЦП, а не 9% циклов, что, "
"вероятно, привело бы к ухудшению воспроизведения. Ситуация в "
"многопроцессорных системах несколько сложнее, но результат тот же самый: "
"планировщик распределит циклы ЦП между группами задач и автогруппа с большим "
"количеством привязанных к ЦП процессов не истратит все циклы ЦП с ущербом "
"других задач, выполняемых системой."

#. type: Plain text
#: man-pages/man7/sched.7:781
msgid ""
"A process's autogroup (task group) membership can be viewed via the file I</"
"proc/[pid]/autogroup>:"
msgstr ""
"Членство автогруппы процесса (группу задач) можно увидеть через файл I</proc/"
"[pid]/autogroup>:"

#. type: Plain text
#: man-pages/man7/sched.7:786
#, no-wrap
msgid ""
"$ B<cat /proc/1/autogroup>\n"
"/autogroup-1 nice 0\n"
msgstr ""
"$ B<cat /proc/1/autogroup>\n"
"/autogroup-1 nice 0\n"

#.  FIXME .
#.  Because of a bug introduced in Linux 4.7
#.  (commit 2159197d66770ec01f75c93fb11dc66df81fd45b made changes
#.  that exposed the fact that autogroup didn't call scale_load()),
#.  it happened that *all* values in this range caused a task group
#.  to be further disfavored by the scheduler, with \-20 resulting
#.  in the scheduler mildly disfavoring the task group and +19 greatly
#.  disfavoring it.
#.  A patch was posted on 23 Nov 2016
#.  ("sched/autogroup: Fix 64bit kernel nice adjustment";
#.  check later to see in which kernel version it lands.
#. type: Plain text
#: man-pages/man7/sched.7:810
msgid ""
"This file can also be used to modify the CPU bandwidth allocated to an "
"autogroup.  This is done by writing a number in the \"nice\" range to the "
"file to set the autogroup's nice value.  The allowed range is from +19 (low "
"priority) to -20 (high priority).  (Writing values outside of this range "
"causes B<write>(2)  to fail with the error B<EINVAL>.)"
msgstr ""
"Также этот файл можно использовать для изменения полосы пропускания ЦП, "
"выделенной автогруппе. Для этого в файл записывается диапазон "
"«уступчивости», задающий значение уступчивости автогруппы. Допускаемый "
"диапазон: от +19 (низкий приоритет) до -20 (высокий приоритет) (запись через "
"B<write>(2) значений вне это диапазона приводит к ошибке B<EINVAL>)."

#. type: Plain text
#: man-pages/man7/sched.7:819
msgid ""
"The autogroup nice setting has the same meaning as the process nice value, "
"but applies to distribution of CPU cycles to the autogroup as a whole, based "
"on the relative nice values of other autogroups.  For a process inside an "
"autogroup, the CPU cycles that it receives will be a product of the "
"autogroup's nice value (compared to other autogroups)  and the process's "
"nice value (compared to other processes in the same autogroup."
msgstr ""
"Значение уступчивости автогруппы означает тоже самое что и значение "
"уступчивости процесса, но распространяется на циклы ЦП автогруппы в целом, "
"основываясь на относительных значениях уступчивости других автогрупп. Для "
"процесса внутри автогруппы количество циклов ЦП, которые он получит, равно "
"произведению значения уступчивости автогруппы (по сравнению с другими "
"автогруппами) и значению уступчивости процесса (по сравнению с другими "
"процессам в той же автогруппе)."

#. type: Plain text
#: man-pages/man7/sched.7:824
msgid ""
"The use of the B<cgroups>(7)  CPU controller to place processes in cgroups "
"other than the root CPU cgroup overrides the effect of autogrouping."
msgstr ""
"Использование контроллера ЦП B<cgroups>(7) для размещения процессов в cgroup "
"не равную корневой cgroup ЦП, отменяет эффект автогруппировки."

#. type: Plain text
#: man-pages/man7/sched.7:835
msgid ""
"The autogroup feature groups only processes scheduled under non-real-time "
"policies (B<SCHED_OTHER>, B<SCHED_BATCH>, and B<SCHED_IDLE>).  It does not "
"group processes scheduled under real-time and deadline policies.  Those "
"processes are scheduled according to the rules described earlier."
msgstr ""
"Свойство автогруппировки группирует только процессы, планируемые алгоритмами "
"не реального времени (B<SCHED_OTHER>, B<SCHED_BATCH> и B<SCHED_IDLE>). Оно "
"не группирует процессы, планируемые алгоритмами реального времени и с "
"предельным сроком (deadline). Такие процессы планируются согласно правилам, "
"описанным ранее."

#. type: SS
#: man-pages/man7/sched.7:835
#, no-wrap
msgid "The nice value and group scheduling"
msgstr "Значение уступчивости и групповое планирование"

#. type: Plain text
#: man-pages/man7/sched.7:845
msgid ""
"When scheduling non-real-time processes (i.e., those scheduled under the "
"B<SCHED_OTHER>, B<SCHED_BATCH>, and B<SCHED_IDLE> policies), the CFS "
"scheduler employs a technique known as \"group scheduling\", if the kernel "
"was configured with the B<CONFIG_FAIR_GROUP_SCHED> option (which is typical)."
msgstr ""
"При планировании процессов не реального времени (т. е., планируемых по "
"алгоритмам B<SCHED_OTHER>, B<SCHED_BATCH> и B<SCHED_IDLE>), планировщик CFS "
"использует технику называемую «групповое планирование», если ядро было "
"собрано с параметром B<CONFIG_FAIR_GROUP_SCHED> (обычно так и есть)."

#. type: Plain text
#: man-pages/man7/sched.7:851
msgid ""
"Under group scheduling, threads are scheduled in \"task groups\".  Task "
"groups have a hierarchical relationship, rooted under the initial task group "
"on the system, known as the \"root task group\".  Task groups are formed in "
"the following circumstances:"
msgstr ""
"При групповом планировании нити планируются по «группам задач». Группы задач "
"имеют иерархические связи, берущие начало от начальной группы задач системы, "
"называемой «корневая группа задач». Группы задач формируются согласно "
"следующему:"

#. type: Plain text
#: man-pages/man7/sched.7:855
msgid ""
"All of the threads in a CPU cgroup form a task group.  The parent of this "
"task group is the task group of the corresponding parent cgroup."
msgstr ""
"Все нити в cgroup ЦП образуют группу задач. Родитель этой группы задач "
"является группой задач соответствующей родительской cgroup."

#. type: Plain text
#: man-pages/man7/sched.7:863
msgid ""
"If autogrouping is enabled, then all of the threads that are (implicitly) "
"placed in an autogroup (i.e., the same session, as created by B<setsid>(2))  "
"form a task group.  Each new autogroup is thus a separate task group.  The "
"root task group is the parent of all such autogroups."
msgstr ""
"Если автогруппировка разрешена, то все нити, помещённые (неявно) в "
"автогруппу (т. е., одного сеанса, созданного B<setsid>(2)), образуют группу "
"задач. Таким образом, каждая новая автогруппа является отдельной группой "
"задач. Корневая группа задач является родителем всех этих автогрупп."

#. type: Plain text
#: man-pages/man7/sched.7:867
msgid ""
"If autogrouping is enabled, then the root task group consists of all "
"processes in the root CPU cgroup that were not otherwise implicitly placed "
"into a new autogroup."
msgstr ""
"Если автогруппировка разрешена, то корневая группа задач состоит из всех "
"процессов в корневой cgroup ЦП, которые не были неявно помещены в новую "
"автогруппу."

#. type: Plain text
#: man-pages/man7/sched.7:870
msgid ""
"If autogrouping is disabled, then the root task group consists of all "
"processes in the root CPU cgroup."
msgstr ""
"Если автогруппировка запрещена, то корневая группа задач состоит из всех "
"процессов в корневой cgroup ЦП."

#. type: Plain text
#: man-pages/man7/sched.7:875
msgid ""
"If group scheduling was disabled (i.e., the kernel was configured without "
"B<CONFIG_FAIR_GROUP_SCHED>), then all of the processes on the system are "
"notionally placed in a single task group."
msgstr ""
"Если групповое планирование было запрещено (т. е., ядро собрано без "
"параметра B<CONFIG_FAIR_GROUP_SCHED>), то все процессы системы условно "
"помещаются в одну группу задач."

#. type: Plain text
#: man-pages/man7/sched.7:889
msgid ""
"Under group scheduling, a thread's nice value has an effect for scheduling "
"decisions I<only relative to other threads in the same task group>.  This "
"has some surprising consequences in terms of the traditional semantics of "
"the nice value on UNIX systems.  In particular, if autogrouping is enabled "
"(which is the default in various distributions), then employing "
"B<setpriority>(2)  or B<nice>(1)  on a process has an effect only for "
"scheduling relative to other processes executed in the same session "
"(typically: the same terminal window)."
msgstr ""
"При групповом планировании значение уступчивости нити влияет на решение о "
"планировании I<только относительно других нитей в той же группе задач>. Это "
"слегка удивляет с точки зрения обычной семантики значения уступчивости в "
"системах UNIX. В частности, если автогруппировка разрешена (по умолчанию во "
"многих дистрибутивах), то применение к процессу  B<setpriority>(2) или "
"B<nice>(1) подействует только на планирование относительно других процессов, "
"выполняющихся в том же сеансе (обычно, в том же окне терминала)."

#.  More succinctly: the nice(1) command is in many cases a no-op since
#.  Linux 2.6.38.
#. type: Plain text
#: man-pages/man7/sched.7:905
msgid ""
"Conversely, for two processes that are (for example)  the sole CPU-bound "
"processes in different sessions (e.g., different terminal windows, each of "
"whose jobs are tied to different autogroups), I<modifying the nice value of "
"the process in one of the sessions> I<has no effect> in terms of the "
"scheduler's decisions relative to the process in the other session.  A "
"possibly useful workaround here is to use a command such as the following to "
"modify the autogroup nice value for I<all> of the processes in a terminal "
"session:"
msgstr ""
"И наоборот, для двух процессов, которые (например) являются единственными "
"привязанными к ЦП процессами в в разных сеансах (например, различные окна "
"терминалов, в каждом задачи составляют разные автогруппы), I<изменение "
"значения уступчивости процесса в одном из сеансов> I<не повлияет> на "
"принятие решения планировщиком относительно процесса в другом сеансе. "
"Возможно, здесь полезным обходным решением будет использовать команду, "
"изменяющую значение уступчивости автогруппы I<всех> процессов в сеансе "
"терминала:"

#. type: Plain text
#: man-pages/man7/sched.7:909
#, no-wrap
msgid "$ B<echo 10 E<gt> /proc/self/autogroup>\n"
msgstr "$ B<echo 10 E<gt> /proc/self/autogroup>\n"

#. type: SS
#: man-pages/man7/sched.7:911
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr "Возможности выполнения в реальном времени из оригинальной версии Linux"

#.  FIXME . Probably this text will need some minor tweaking
#.  ask Carsten Emde about this.
#. type: Plain text
#: man-pages/man7/sched.7:923
msgid ""
"Since kernel version 2.6.18, Linux is gradually becoming equipped with real-"
"time capabilities, most of which are derived from the former I<realtime-"
"preempt> patch set.  Until the patches have been completely merged into the "
"mainline kernel, they must be installed to achieve the best real-time "
"performance.  These patches are named:"
msgstr ""
"Начиная с версии ядра 2.6.18, Linux постепенно обрастает возможностями "
"выполнения в реальном времени, большая часть которых взята из раннего набора "
"заплат I<realtime-preempt>. Пока заплатки не были полностью включены в "
"основное ядро, их нужно было устанавливать отдельно. Файлы заплаток "
"называются:"

#. type: Plain text
#: man-pages/man7/sched.7:927
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr "patch-I<версия_ядра>-rtI<версия_заплатки>\n"

#. type: Plain text
#: man-pages/man7/sched.7:933
msgid ""
"and can be downloaded from E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/"
"kernel\\:/projects\\:/rt/> E<.UE .>"
msgstr ""
"и могут быть скачаны с E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/kernel"
"\\:/projects\\:/rt/> E<.UE .>"

#. type: Plain text
#: man-pages/man7/sched.7:942
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""
"Без заплаток и до их полного включения в оригинальное ядро, через параметры "
"ядра предлагается только три класса вытеснения: B<CONFIG_PREEMPT_NONE>, "
"B<CONFIG_PREEMPT_VOLUNTARY> и B<CONFIG_PREEMPT_DESKTOP>, которые, "
"соответственно, не сокращают, частично сокращают и значительно сокращают "
"задержку планирования при наихудшем случае."

#. type: Plain text
#: man-pages/man7/sched.7:951
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular real-"
"time operating system.  The FIFO and RR scheduling policies are then used to "
"run a thread with true real-time priority and a minimum worst-case "
"scheduling latency."
msgstr ""
"С заплатками и после их полного включения в оригинальное ядро, в параметрах "
"ядра появится новый пункт B<CONFIG_PREEMPT_RT>. Если он будет выбран, то "
"Linux преобразуется в обычную операционную систему реального времени. После "
"этого для выполнения нити с настоящим приоритетом реального времени и "
"минимальной задержкой планирования в наихудшем случае используются алгоритмы "
"планирования FIFO и RR."

#. type: Plain text
#: man-pages/man7/sched.7:956
msgid ""
"The B<cgroups>(7)  CPU controller can be used to limit the CPU consumption "
"of groups of processes."
msgstr ""
"Для ограничения групп процессов потребления ЦП можно использовать контроллер "
"ЦП B<cgroups>(7)."

#. type: Plain text
#: man-pages/man7/sched.7:966
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""
"Изначально стандартный Linux представлял собой операционную систему общего "
"назначения для выполнения как фоновых процессов, так и интерактивных "
"приложений, а также нетребовательных приложений реального времени "
"(приложений, которым желательно, чтобы задержки и интервалы времени "
"выдерживались). Хотя ядро Linux 2.6 позволяет вытеснение и новый планировщик "
"O(1) обеспечивает необходимое постоянство планирования и предсказуемое "
"независимое количество активных задач, настоящая работа в реальном времени "
"стала доступна начиная с версии ядра 2.6.17."

#. type: Plain text
#: man-pages/man7/sched.7:998
msgid ""
"B<chcpu>(1), B<chrt>(1), B<lscpu>(1), B<ps>(1), B<taskset>(1), B<top>(1), "
"B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), "
"B<pthread_getaffinity_np>(3), B<pthread_setaffinity_np>(3), "
"B<sched_getcpu>(3), B<capabilities>(7), B<cpuset>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:1002
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O.\\& Gallmeister, "
"O'Reilly & Associates, Inc., ISBN 1-56592-074-0."
msgstr ""
"I<Programming for the real world - POSIX.4> by Bill O.\\& Gallmeister, "
"O'Reilly & Associates, Inc., ISBN 1-56592-074-0."

#. type: Plain text
#: man-pages/man7/sched.7:1008
msgid ""
"The Linux kernel source files I<Documentation/scheduler/sched-deadline.txt>, "
"I<Documentation/scheduler/sched-rt-group.txt>, I<Documentation/scheduler/"
"sched-design-CFS.txt>, and I<Documentation/scheduler/sched-nice-design.txt>"
msgstr ""
"Исходные файлы ядра Linux I<Documentation/scheduler/sched-deadline.txt>, "
"I<Documentation/scheduler/sched-rt-group.txt>, I<Documentation/scheduler/"
"sched-design-CFS.txt> и I<Documentation/scheduler/sched-nice-design.txt>"

#. type: TH
#: man-pages/man7/socket.7:64
#, no-wrap
msgid "SOCKET"
msgstr "SOCKET"

#. type: Plain text
#: man-pages/man7/socket.7:67
msgid "socket - Linux socket interface"
msgstr "socket - интерфейс сокетов Linux"

#. type: Plain text
#: man-pages/man7/socket.7:69
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/socket.7:71
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"

#. type: Plain text
#: man-pages/man7/socket.7:90
msgid ""
"This manual page describes the Linux networking socket layer user "
"interface.  The BSD compatible sockets are the uniform interface between the "
"user process and the network protocol stacks in the kernel.  The protocol "
"modules are grouped into I<protocol families> such as B<AF_INET>, B<AF_IPX>, "
"and B<AF_PACKET>, and I<socket types> such as B<SOCK_STREAM> or "
"B<SOCK_DGRAM>.  See B<socket>(2)  for more information on families and types."
msgstr ""
"В этой справочной странице описывается пользовательский интерфейс уровня "
"сетевых сокетов Linux. Совместимый с сокетами BSD, он предоставляет "
"унифицированный интерфейс между пользовательскими процессами и стеком "
"сетевых протоколов в ядре. Модули протоколов группируются по I<семействам "
"протоколов>, такими, как B<AF_INET>, B<AF_IPX> и B<AF_PACKET>, и I<типам "
"сокетов>, такими, как B<SOCK_STREAM> или B<SOCK_DGRAM>. Более подробная "
"информация о семействах и типах приведена в B<socket>(2)."

#. type: SS
#: man-pages/man7/socket.7:90
#, no-wrap
msgid "Socket-layer functions"
msgstr "Функции уровня сокетов"

#. type: Plain text
#: man-pages/man7/socket.7:94
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr ""
"Эти функции используются пользовательскими процессами для отправки или "
"приёма пакетов и выполнения других операций над сокетами. Более подробная "
"информация приведена в соответствующих справочных страницах."

#. type: Plain text
#: man-pages/man7/socket.7:110
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote "
"socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets "
"(implemented only for a few local families like B<AF_UNIX>)"
msgstr ""
"Вызов B<socket>(2) создаёт сокет, B<connect>(2) соединяет сокет с удалённым "
"сокетным адресом, B<bind>(2) привязывает сокет к локальному адресу, "
"B<listen>(2) сообщает сокету, что должны приниматься новые соединения, а "
"B<accept>(2) используется для получения нового сокета для нового входящего "
"соединения. Вызов B<socketpair>(2) возвращает два соединённых анонимных "
"сокета (реализовано только для некоторых локальных семейств, например "
"B<AF_UNIX>)."

#. type: Plain text
#: man-pages/man7/socket.7:132
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), "
"B<writev>(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to "
"read and write data."
msgstr ""
"Вызовы B<send>(2), B<sendto>(2) и B<sendmsg>(2) отправляют данные в сокет, а "
"B<recv>(2), B<recvfrom>(2) и B<recvmsg>(2) принимают данные из сокета. "
"Вызовы B<poll>(2) и B<select>(2) ожидают поступления данных или готовятся к "
"передаче данных. Кроме того, для чтения и записи данных могут использоваться "
"стандартные операции ввода-вывода: B<write>(2), B<writev>(2), "
"B<sendfile>(2), B<read>(2) и B<readv>(2)."

#. type: Plain text
#: man-pages/man7/socket.7:143
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr ""
"Вызов B<getsockname>(2) возвращает адрес локального сокета, а "
"B<getpeername>(2) возвращает адрес удалённого сокета. Вызовы "
"B<getsockopt>(2) и B<setsockopt>(2) используются для установки или "
"считывания параметров протокола или уровня сокетов. Вызов B<ioctl>(2) может "
"быть использован для установки или чтения некоторых других параметров."

#. type: Plain text
#: man-pages/man7/socket.7:148
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr ""
"Вызов B<close>(2) используется для закрытия сокета. Вызов B<shutdown>(2) "
"закрывает части полнодуплексного сокетного соединения."

#. type: Plain text
#: man-pages/man7/socket.7:154
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is "
"not supported on sockets."
msgstr ""
"Перемещение (seeking), или вызовы B<pread>(2) и B<pwrite>(2) с ненулевой "
"позицией, для сокетов не поддерживается."

#. type: Plain text
#: man-pages/man7/socket.7:171
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK> "
"flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr ""
"Для сокетов возможно создание неблокирующего ввода/вывода путём установки в "
"файловый дескриптор сокета флага B<O_NONBLOCK> с помощью вызова B<fcntl>(2). "
"При этом все блокировавшие раньше операции, будут возвращать B<EAGAIN> "
"(операция должна быть повторена позднее); B<connect>(2) возвратит ошибку "
"B<EINPROGRESS>. Пользователь может подождать наступления различных событий "
"через B<poll>(2) или B<select>(2)."

#. type: tbl table
#: man-pages/man7/socket.7:175
#, no-wrap
msgid "I/O events"
msgstr "События ввода-вывода"

#. type: tbl table
#: man-pages/man7/socket.7:176
#, no-wrap
msgid "Event"
msgstr "Событие"

#. type: tbl table
#: man-pages/man7/socket.7:176
#, no-wrap
msgid "Poll flag"
msgstr "Флаг poll"

#. type: tbl table
#: man-pages/man7/socket.7:176
#, no-wrap
msgid "Occurrence"
msgstr "Когда происходит"

#. type: tbl table
#: man-pages/man7/socket.7:177 man-pages/man7/socket.7:180
#: man-pages/man7/socket.7:184 man-pages/man7/socket.7:187
#, no-wrap
msgid "Read"
msgstr "Чтение"

#. type: tbl table
#: man-pages/man7/socket.7:177 man-pages/man7/socket.7:180
#, no-wrap
msgid "POLLIN"
msgstr "POLLIN"

#. type: tbl table
#: man-pages/man7/socket.7:179
#, no-wrap
msgid "New data arrived."
msgstr "Поступили новые данные."

#. type: tbl table
#: man-pages/man7/socket.7:183
#, no-wrap
msgid ""
"A connection setup has been completed\n"
"(for connection-oriented sockets)"
msgstr ""
"Установка соединения выполнена\n"
"(для сокетов с установлением соединения)"

#. type: tbl table
#: man-pages/man7/socket.7:184 man-pages/man7/socket.7:187
#: man-pages/man7/socket.7:206
#, no-wrap
msgid "POLLHUP"
msgstr "POLLHUP"

#. type: tbl table
#: man-pages/man7/socket.7:186
#, no-wrap
msgid "A disconnection request has been initiated by the other end."
msgstr "Другая сторона инициировала запрос на разъединение."

#. type: tbl table
#: man-pages/man7/socket.7:192
#, no-wrap
msgid ""
"A connection is broken (only for connection-oriented protocols).\n"
"When the socket is written\n"
"B<SIGPIPE>\n"
"is also sent."
msgstr ""
"Соединение разорвано (только для протоколов с установлением соединения).\n"
"Если производится запись в сокет, то также посылается\n"
"сигнал B<SIGPIPE>."

#. type: tbl table
#: man-pages/man7/socket.7:193
#, no-wrap
msgid "Write"
msgstr "Запись"

#. type: tbl table
#: man-pages/man7/socket.7:193 man-pages/man7/socket.7:200
#, no-wrap
msgid "POLLOUT"
msgstr "POLLOUT"

#. type: tbl table
#: man-pages/man7/socket.7:195
#, no-wrap
msgid "Socket has enough send buffer space for writing new data."
msgstr "Сокет имеет достаточно места в буфере отправки для записи в него новых данных."

#. type: tbl table
#: man-pages/man7/socket.7:196 man-pages/man7/socket.7:205
#: man-pages/man7/socket.7:206
#, no-wrap
msgid "Read/Write"
msgstr "Чтение/Запись"

#. type: tbl table
#: man-pages/man7/socket.7:198
#, no-wrap
msgid "POLLIN |\n"
msgstr "POLLIN |\n"

#. type: tbl table
#: man-pages/man7/socket.7:198
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man7/socket.7:204
#, no-wrap
msgid ""
"An outgoing\n"
"B<connect>(2)\n"
"finished."
msgstr ""
"Исходящий\n"
"B<connect>(2)\n"
"завершён."

#. type: tbl table
#: man-pages/man7/socket.7:205
#, no-wrap
msgid "POLLERR"
msgstr "POLLERR"

#. type: tbl table
#: man-pages/man7/socket.7:205
#, no-wrap
msgid "An asynchronous error occurred."
msgstr "Произошла асинхронная ошибка."

#. type: tbl table
#: man-pages/man7/socket.7:206
#, no-wrap
msgid "The other end has shut down one direction."
msgstr "Другая сторона закрыла (shut down) одно направление."

#. type: tbl table
#: man-pages/man7/socket.7:207
#, no-wrap
msgid "Exception"
msgstr "Исключение"

#. type: tbl table
#: man-pages/man7/socket.7:207
#, no-wrap
msgid "POLLPRI"
msgstr "POLLPRI"

#. type: tbl table
#: man-pages/man7/socket.7:211
#, no-wrap
msgid ""
"Urgent data arrived.\n"
"B<SIGURG>\n"
"is sent then."
msgstr ""
"Пришли неотложные данные.\n"
"После посылается\n"
"сигнал B<SIGURG>."

#. type: Plain text
#: man-pages/man7/socket.7:239
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC> "
"flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr ""
"Альтернативе B<poll>(2) и B<select>(2) в ядре существует возможность "
"информировать приложение о событиях с помощью сигнала B<SIGIO>. Для этого "
"необходимо установить с помощью B<fcntl>(2) в файловом дескрипторе сокета "
"флаг B<O_ASYNC>, а также назначить с помощью B<sigaction>(2) корректный "
"обработчик сигнала B<SIGIO>. Смотрите ниже раздел I<Сигналы>."

#. type: SS
#: man-pages/man7/socket.7:239
#, no-wrap
msgid "Socket address structures"
msgstr "Структуры адреса сокета"

#. type: Plain text
#: man-pages/man7/socket.7:255
msgid ""
"Each socket domain has its own format for socket addresses, with a domain-"
"specific address structure.  Each of these structures begins with an integer "
"\"family\" field (typed as I<sa_family_t>)  that indicates the type of the "
"address structure.  This allows the various system calls (e.g., "
"B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), "
"B<getpeername>(2)), which are generic to all socket domains, to determine "
"the domain of a particular socket address."
msgstr ""
"Каждый сокетный домен имеет свой формат сокетных адресов, выраженный в "
"отдельной адресной структуре. Каждая из этих структур начинается с "
"целочисленного поля «семейства» (с типом I<sa_family_t>), в котором "
"указывается тип адресной структуры. Это позволяет различным системным "
"вызовам (например, B<connect>(2), B<bind>(2), B<accept>(2), "
"B<getsockname>(2), B<getpeername>(2)), которые являются общими для всех "
"сокетов, определить домен конкретного сокетного адреса."

#. type: Plain text
#: man-pages/man7/socket.7:265
msgid ""
"To allow any type of socket address to be passed to interfaces in the "
"sockets API, the type I<struct sockaddr> is defined.  The purpose of this "
"type is purely to allow casting of domain-specific socket address types to a "
"\"generic\" type, so as to avoid compiler warnings about type mismatches in "
"calls to the sockets API."
msgstr ""
"Для передачи сокетного адреса любого типа через программный интерфейс "
"сокетов служит тип I<struct sockaddr>. Целью данного типа является "
"приведение типов сокетных адресов определённого домена к «общему» типу, что "
"позволяет избежать предупреждений компилятора о несовпадении типов в вызовах "
"API сокетов."

#. type: Plain text
#: man-pages/man7/socket.7:275
msgid ""
"In addition, the sockets API provides the data type I<struct "
"sockaddr_storage>.  This type is suitable to accommodate all supported "
"domain-specific socket address structures; it is large enough and is aligned "
"properly.  (In particular, it is large enough to hold IPv6 socket "
"addresses.)  The structure includes the following field, which can be used "
"to identify the type of socket address actually stored in the structure:"
msgstr ""
"Также, программный интерфейс сокетов предоставляет тип данных I<struct "
"sockaddr_storage>. Данный тип удобен для размещения всех поддерживаемых "
"структур сокетных адресов определённого домена; он достаточно большой и "
"имеет корректное выравнивание (в частности, он позволяет хранить сокетные "
"адреса IPv6). Для определения типа сокетного адреса, который хранится в "
"структуре, служит следующее поле:"

#. type: Plain text
#: man-pages/man7/socket.7:279
#, no-wrap
msgid "    sa_family_t ss_family;\n"
msgstr "    sa_family_t ss_family;\n"

#. type: Plain text
#: man-pages/man7/socket.7:287
msgid ""
"The I<sockaddr_storage> structure is useful in programs that must handle "
"socket addresses in a generic way (e.g., programs that must deal with both "
"IPv4 and IPv6 socket addresses)."
msgstr ""
"Структура I<sockaddr_storage> полезна для программ, которые должны работать "
"с сокетными адресами единообразно (например, в программах, использующих "
"одновременно сокетные адреса IPv4 и IPv6)."

#. type: SS
#: man-pages/man7/socket.7:287
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокетов"

#.  FIXME .
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: man-pages/man7/socket.7:305
msgid ""
"The socket options listed below can be set by using B<setsockopt>(2)  and "
"read with B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for "
"all sockets.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""
"Следующие параметры сокета могут быть установлены с помощью B<setsockopt>(2) "
"или прочитаны с помощью B<getsockopt>(2) с уровнем сокета, равным "
"B<SOL_SOCKET> для всех сокетов:"

#. type: TP
#: man-pages/man7/socket.7:305
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr "B<SO_ACCEPTCONN>"

#. type: Plain text
#: man-pages/man7/socket.7:313
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr ""
"Определить, был или не был данный сокет помечен для прослушивания и приёма "
"соединений с помощью B<listen>(2). Возвращаемое значение 0 обозначает, что "
"это не прослушивающий сокет. Значение 1 обозначает, что это прослушивающий "
"сокет. Данный параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:313
#, no-wrap
msgid "B<SO_ATTACH_FILTER> (since Linux 2.2), B<SO_ATTACH_BPF> (since Linux 3.19)"
msgstr "B<SO_ATTACH_FILTER> (начиная с Linux 2.2), B<SO_ATTACH_BPF> (начиная с Linux 3.19)"

#. type: Plain text
#: man-pages/man7/socket.7:326
msgid ""
"Attach a classic BPF (B<SO_ATTACH_FILTER>)  or an extended BPF "
"(B<SO_ATTACH_BPF>)  program to the socket for use as a filter of incoming "
"packets.  A packet will be dropped if the filter program returns zero.  If "
"the filter program returns a nonzero value which is less than the packet's "
"data length, the packet will be truncated to the length returned.  If the "
"value returned by the filter is greater than or equal to the packet's data "
"length, the packet is allowed to proceed unmodified."
msgstr ""
"Присоединить классическую (B<SO_ATTACH_FILTER>) или расширенную "
"(B<SO_ATTACH_BPF>) программу BPF к сокету, которая будет использоваться как "
"фильтр входящих пакетов. Пакет будет отброшен, если фильтрующая программа "
"возвращает ноль. Если фильтрующая программа возвращает ненулевое значение, "
"меньше длины данных пакета, то пакет будет обрезан до возвращаемой длины. "
"Если возвращаемое фильтром значение больше или равно длине данных пакета, то "
"пакет разрешён к обработке без изменений."

#. type: Plain text
#: man-pages/man7/socket.7:333
msgid ""
"The argument for B<SO_ATTACH_FILTER> is a I<sock_fprog> structure, defined "
"in I<E<lt>linux/filter.hE<gt>>:"
msgstr ""
"Для B<SO_ATTACH_FILTER> аргументом является структура I<sock_fprog>, "
"определяемая в I<E<lt>linux/filter.hE<gt>>:"

#. type: Plain text
#: man-pages/man7/socket.7:340
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;\n"
"    struct sock_filter *filter;\n"
"};\n"
msgstr ""
"struct sock_fprog {\n"
"    unsigned short      len;\n"
"    struct sock_filter *filter;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/socket.7:349
msgid ""
"The argument for B<SO_ATTACH_BPF> is a file descriptor returned by the "
"B<bpf>(2)  system call and must refer to a program of type "
"B<BPF_PROG_TYPE_SOCKET_FILTER>."
msgstr ""
"Для B<SO_ATTACH_BPF> аргументом является файловый дескриптор, возвращаемый "
"системным вызовом B<bpf>(2), он должен указывать на программу с типом "
"B<BPF_PROG_TYPE_SOCKET_FILTER>."

#. type: Plain text
#: man-pages/man7/socket.7:355
msgid ""
"These options may be set multiple times for a given socket, each time "
"replacing the previous filter program.  The classic and extended versions "
"may be called on the same socket, but the previous filter will always be "
"replaced such that a socket never has more than one filter defined."
msgstr ""
"Эти параметры могут быть назначены заданному сокету несколько раз, если "
"перед этим заменять фильтрующую программу. Для одного сокета могут "
"вызываться классическая и расширенная версии, но предыдущий фильтр всегда "
"будет заменён, так как для сокета допускается определять не более одного "
"фильтра."

#. type: Plain text
#: man-pages/man7/socket.7:358
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>"
msgstr ""
"Классический и расширенный BPF описаны в файле исходного кода ядра "
"I<Documentation/networking/filter.txt>."

#. type: TP
#: man-pages/man7/socket.7:358
#, no-wrap
msgid "B<SO_ATTACH_REUSEPORT_CBPF>, B<SO_ATTACH_REUSEPORT_EBPF>"
msgstr "B<SO_ATTACH_REUSEPORT_CBPF>, B<SO_ATTACH_REUSEPORT_EBPF>"

#. type: Plain text
#: man-pages/man7/socket.7:370
msgid ""
"For use with the B<SO_REUSEPORT> option, these options allow the user to set "
"a classic BPF (B<SO_ATTACH_REUSEPORT_CBPF>)  or an extended BPF "
"(B<SO_ATTACH_REUSEPORT_EBPF>)  program which defines how packets are "
"assigned to the sockets in the reuseport group (that is, all sockets which "
"have B<SO_REUSEPORT> set and are using the same local address to receive "
"packets)."
msgstr ""
"При использовании вместе с B<SO_REUSEPORT> эти параметры позволяют "
"пользователю задавать классическую (B<SO_ATTACH_REUSEPORT_CBPF>) или "
"расширенную (B<SO_ATTACH_REUSEPORT_EBPF>) программу BPF, которая определяет "
"как пакеты назначаются сокетам в группе reuseport (то есть всем сокетам, у "
"которых установлен B<SO_REUSEPORT>, и использующим один локальный адрес для "
"приёма пакетов)."

#. type: Plain text
#: man-pages/man7/socket.7:378
msgid ""
"The BPF program must return an index between 0 and N-1 representing the "
"socket which should receive the packet (where N is the number of sockets in "
"the group).  If the BPF program returns an invalid index, socket selection "
"will fall back to the plain B<SO_REUSEPORT> mechanism."
msgstr ""
"Программа BPF должна возвращать индекс от 0 до N-1, представляющий сокет, "
"который должен получить пакет (где N — количество сокетов в группе). Если "
"программа BPF возвращает некорректный индекс, то выбор сокета будет выполнен "
"с помощью простого механизма B<SO_REUSEPORT>."

#. type: Plain text
#: man-pages/man7/socket.7:390
msgid ""
"Sockets are numbered in the order in which they are added to the group (that "
"is, the order of B<bind>(2)  calls for UDP sockets or the order of "
"B<listen>(2)  calls for TCP sockets).  New sockets added to a reuseport "
"group will inherit the BPF program.  When a socket is removed from a "
"reuseport group (via B<close>(2)), the last socket in the group will be "
"moved into the closed socket's position."
msgstr ""
"Сокеты нумеруются в порядке их добавления в группу (то есть, в порядке "
"вызовов B<bind>(2) для сокетов UDP и в порядке вызовов B<listen>(2) для "
"сокетов TCP). Новые сокеты, добавляемые в группу reuseport, будут "
"наследовать программу BPF. Когда сокет удаляется из группы reuseport (с "
"помощью B<close>(2)), последний сокет в группе будет перемещён в позицию "
"закрытого сокета."

#. type: Plain text
#: man-pages/man7/socket.7:393
msgid ""
"These options may be set repeatedly at any time on any socket in the group "
"to replace the current BPF program used by all sockets in the group."
msgstr ""
"Эти параметры могут быть повторно назначены в любое время любому сокету в "
"группе для замены текущей программы BPF, используемой всеми сокетами в "
"группе."

#. type: Plain text
#: man-pages/man7/socket.7:401
msgid ""
"B<SO_ATTACH_REUSEPORT_CBPF> takes the same argument type as "
"B<SO_ATTACH_FILTER> and B<SO_ATTACH_REUSEPORT_EBPF> takes the same argument "
"type as B<SO_ATTACH_BPF>."
msgstr ""
"Для B<SO_ATTACH_REUSEPORT_CBPF> учитывается тот же тип аргумента как у "
"B<SO_ATTACH_FILTER>, а для B<SO_ATTACH_REUSEPORT_EBPF> учитывается тот же "
"тип аргумента как у B<SO_ATTACH_BPF>."

#. type: Plain text
#: man-pages/man7/socket.7:404
msgid ""
"UDP support for this feature is available since Linux 4.5; TCP support is "
"available since Linux 4.6."
msgstr ""
"Поддержка этого свойства для UDP доступна начиная с Linux 4.5; Поддержка "
"этого свойства для TCP доступна начиная с Linux 4.6."

#. type: TP
#: man-pages/man7/socket.7:404
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr "B<SO_BINDTODEVICE>"

#. type: Plain text
#: man-pages/man7/socket.7:423
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in "
"the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this works only for some socket types, particularly B<AF_INET> "
"sockets.  It is not supported for packet sockets (use normal B<bind>(2)  "
"there)."
msgstr ""
"Привязать сокет к определённому устройству, например, к «eth0», в "
"соответствии с переданным именем интерфейса. Если имя является пустой "
"строкой или длина параметра равна нулю, то привязка сокета к устройству "
"будет удалена. В качестве параметра передаётся оканчивающаяся null строка "
"переменной длины с именем интерфейса, максимальная длина которого не "
"превышает B<IFNAMSIZ>. Если сокет привязан к интерфейсу, то сокетом "
"обрабатываются только пакеты этого интерфейса. Заметим, что это работает "
"только для некоторых типов сокетов, в частности, для сокетов B<AF_INET>. Это "
"не поддерживается для сокетов пакетной передачи (для них используйте обычный "
"B<bind>(2))."

#. type: Plain text
#: man-pages/man7/socket.7:437
msgid ""
"Before Linux 3.8, this socket option could be set, but could not retrieved "
"with B<getsockopt>(2).  Since Linux 3.8, it is readable.  The I<optlen> "
"argument should contain the buffer size available to receive the device name "
"and is recommended to be B<IFNAMSIZ> bytes.  The real device name length is "
"reported back in the I<optlen> argument."
msgstr ""
"До Linux 3.8, данный параметр сокета можно было устанавливать, но нельзя "
"прочитать с помощью B<getsockopt>(2). Начиная с Linux 3.8 он доступен для "
"чтения. Аргумент I<optlen> должен содержать размер буфера, способного "
"разместить имя устройства; рекомендуемое значение — B<IFNAMSIZ> байт. "
"Реальная длина имени устройства возвращается обратно через аргумент "
"I<optlen>."

#. type: TP
#: man-pages/man7/socket.7:437
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr "B<SO_BROADCAST>"

#. type: Plain text
#: man-pages/man7/socket.7:443
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on stream-"
"oriented sockets."
msgstr ""
"Задать или считать флаг широковещания. Если он установлен, то через "
"датаграммные сокеты разрешено отправлять пакеты на широковещательный адрес. "
"Этот параметр не действует на потоковые сокеты."

#. type: TP
#: man-pages/man7/socket.7:443
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr "B<SO_BSDCOMPAT>"

#. type: Plain text
#: man-pages/man7/socket.7:455
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled, ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random "
"header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr ""
"Разрешить совместимость по ошибкам с BSD. Используется модулем протокола UDP "
"в Linux версии 2.0 и 2.2. Если включено, то полученные UDP-сокетом ошибки "
"ICMP не будут передаваться пользовательской программе. В последний версиях "
"ядер поддержка этого параметра удалена: в Linux 2.4 он игнорируется, а в "
"Linux 2.6 при использовании в программе для него генерируется предупреждение "
"ядра (printk()). В Linux 2.0 также включён параметр совместимости по ошибкам "
"с BSD и для неструктурированных сокетов (произвольное изменение заголовка, "
"пропуск флага широковещательной передачи), но в Linux 2.2 это было удалено."

#. type: TP
#: man-pages/man7/socket.7:455
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr "B<SO_DEBUG>"

#. type: Plain text
#: man-pages/man7/socket.7:461
msgid ""
"Enable socket debugging.  Allowed only for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr ""
"Включить отладку сокета. Разрешено только процессам с мандатом "
"B<CAP_NET_ADMIN> или имеющим нулевой идентификатор эффективного пользователя."

#. type: TP
#: man-pages/man7/socket.7:461
#, no-wrap
msgid "B<SO_DETACH_FILTER> (since Linux 2.2), B<SO_DETACH_BPF> (since Linux 3.19)"
msgstr "B<SO_DETACH_FILTER> (начиная с Linux 2.2), B<SO_DETACH_BPF> (начиная с Linux 3.19)"

#. type: Plain text
#: man-pages/man7/socket.7:470
msgid ""
"These two options, which are synonyms, may be used to remove the classic or "
"extended BPF program attached to a socket with either B<SO_ATTACH_FILTER> or "
"B<SO_ATTACH_BPF>.  The option value is ignored."
msgstr ""
"Эти два параметра, синонимы, можно использовать для удаления классической "
"или расширенной программы BPF, присоединённой к сокету с помощью "
"B<SO_ATTACH_FILTER> или B<SO_ATTACH_BPF>. Значение параметра игнорируется."

#. type: TP
#: man-pages/man7/socket.7:470
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr "B<SO_DOMAIN> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man7/socket.7:478
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr ""
"Получить доменный сокет в виде целого числа; пример возвращаемого значения: "
"B<AF_INET6>. Подробней смотрите в B<socket>(2). Этот параметр сокета "
"доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:478
#, no-wrap
msgid "B<SO_ERROR>"
msgstr "B<SO_ERROR>"

#. type: Plain text
#: man-pages/man7/socket.7:483
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr ""
"Получить и очистить ожидающую обработки ошибку сокета. Этот параметр сокета "
"доступен только для чтения. Ожидает целое число."

#. type: TP
#: man-pages/man7/socket.7:483
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr "B<SO_DONTROUTE>"

#. type: Plain text
#: man-pages/man7/socket.7:492
msgid ""
"Don't send via a gateway, send only to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr ""
"Не выполнять отправку через шлюз, посылать только на машины, соединенные "
"напрямую. Тот же эффект может быть достигнут путём установки для сокета "
"флага B<MSG_DONTROUTE> во время вызова B<send>(2). В качестве параметра "
"ожидается целочисленный логический флаг."

#. type: TP
#: man-pages/man7/socket.7:492
#, no-wrap
msgid "B<SO_INCOMING_CPU> (gettable since Linux 3.19, settable since Linux 4.4)"
msgstr "B<SO_INCOMING_CPU> (чтение, начиная с Linux 3.19; запись, начиная с Linux 4.4)"

#.  getsockopt 2c8c56e15df3d4c2af3d656e44feb18789f75837
#.  setsockopt 70da268b569d32a9fddeea85dc18043de9d89f89
#. type: Plain text
#: man-pages/man7/socket.7:498
msgid "Sets or gets the CPU affinity of a socket.  Expects an integer flag."
msgstr ""
"Изменяет или возвращает привязку сокета к ЦП. В качестве параметра ожидается "
"целочисленный логический флаг."

#. type: Plain text
#: man-pages/man7/socket.7:503
#, no-wrap
msgid ""
"int cpu = 1;\n"
"setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu, sizeof(cpu));\n"
msgstr ""
"int cpu = 1;\n"
"setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, &cpu, sizeof(cpu));\n"

#.  From an email conversation with Eric Dumazet:
#.  >> Note that setting the option is not supported if SO_REUSEPORT is used.
#.  >
#.  > Please define "not supported". Does this yield an API diagnostic?
#.  > If so, what is it?
#.  >
#.  >> Socket will be selected from an array, either by a hash or BPF program
#.  >> that has no access to this information.
#.  >
#.  > Sorry -- I'm lost here. How does this comment relate to the proposed
#.  > man page text above?
#.  Simply that :
#.  If an application uses both SO_INCOMING_CPU and SO_REUSEPORT, then
#.  SO_REUSEPORT logic, selecting the socket to receive the packet, ignores
#.  SO_INCOMING_CPU setting.
#. type: Plain text
#: man-pages/man7/socket.7:531
msgid ""
"Because all of the packets for a single stream (i.e., all packets for the "
"same 4-tuple)  arrive on the single RX queue that is associated with a "
"particular CPU, the typical use case is to employ one listening process per "
"RX queue, with the incoming flow being handled by a listener on the same CPU "
"that is handling the RX queue.  This provides optimal NUMA behavior and "
"keeps CPU caches hot."
msgstr ""
"Так как все пакеты одного потока (т. е., все пакеты одной связки 4-х "
"значений (4-tuple)) поступают в одно очередь RX, которая связана с "
"определённым ЦП, обычно, это используется для привязки слушающего процесса к "
"очереди RX, чтобы входящий поток, обрабатываемый слушающим, был на том же "
"ЦП, который обслуживает очередь RX. Это предоставляет оптимальное поведение "
"NUMA и поддерживает кэши ЦП в актуальном состоянии."

#. type: TP
#: man-pages/man7/socket.7:531
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr "B<SO_KEEPALIVE>"

#. type: Plain text
#: man-pages/man7/socket.7:535
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr ""
"Включить отправку «поддерживающих» (keep-alive) сообщений для сокетов, "
"ориентированных на соединение. Ожидается целочисленный логический флаг."

#. type: TP
#: man-pages/man7/socket.7:535
#, no-wrap
msgid "B<SO_LINGER>"
msgstr "B<SO_LINGER>"

#. type: Plain text
#: man-pages/man7/socket.7:543
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> structure."
msgstr ""
"Задать или считать параметр B<SO_LINGER>. Аргументом является структура "
"I<linger>."

#. type: Plain text
#: man-pages/man7/socket.7:550
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr ""
"struct linger {\n"
"    int l_onoff;    /* задержка активна */\n"
"    int l_linger;   /* величина задержки в секундах */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/socket.7:564
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr ""
"Если этот параметр установлен, то B<close>(2) или B<shutdown>(2) не вернут "
"управление до тех пор, пока не будут отправлены все сообщения в очереди "
"сокета или до истечения времени задержки (linger). В противном случае вызовы "
"вернут управление немедленно и закрытие будет произведено в фоновом режиме. "
"Если сокет закрывается как часть вызова B<exit>(2), то задержка всегда "
"происходит в фоновом режиме."

#. type: TP
#: man-pages/man7/socket.7:564
#, no-wrap
msgid "B<SO_LOCK_FILTER>"
msgstr "B<SO_LOCK_FILTER>"

#.  commit d59577b6ffd313d0ab3be39cb1ab47e29bdc9182
#. type: Plain text
#: man-pages/man7/socket.7:575
msgid ""
"When set, this option will prevent changing the filters associated with the "
"socket.  These filters include any set using the socket options "
"B<SO_ATTACH_FILTER>, B<SO_ATTACH_BPF>, B<SO_ATTACH_REUSEPORT_CBPF>, and "
"B<SO_ATTACH_REUSEPORT_EBPF>."
msgstr ""
"Если указан, то это запрещает изменять фильтры, связанные с сокетом. К "
"фильтрам относятся любые, добавленные с помощью параметров сокета "
"B<SO_ATTACH_FILTER> B<SO_ATTACH_BPF> B<SO_ATTACH_REUSEPORT_CBPF> и "
"B<SO_ATTACH_REUSEPORT_EBPF>."

#. type: Plain text
#: man-pages/man7/socket.7:584
msgid ""
"The typical use case is for a privileged process to set up a raw socket (an "
"operation that requires the B<CAP_NET_RAW> capability), apply a restrictive "
"filter, set the B<SO_LOCK_FILTER> option, and then either drop its "
"privileges or pass the socket file descriptor to an unprivileged process via "
"a UNIX domain socket."
msgstr ""
"Обычно, он используется так: настраивается неструктурированный сокет "
"привилегированного процесса (операция требует мандата B<CAP_NET_RAW>), "
"применяется ограничивающий фильтр, назначается параметр B<SO_LOCK_FILTER>, а "
"затем сбрасываются привилегии или файловый дескриптор сокета передаётся "
"непривилегированного процессу через доменный сокет UNIX."

#. type: Plain text
#: man-pages/man7/socket.7:592
msgid ""
"Once the B<SO_LOCK_FILTER> option has been enabled, attempts to change or "
"remove the filter attached to a socket, or to disable the B<SO_LOCK_FILTER> "
"option will fail with the error B<EPERM>."
msgstr ""
"После установки параметра B<SO_LOCK_FILTER>, все попытки изменить, удалить "
"присоединённый к сокету фильтр или отключить с помощью параметра "
"B<SO_LOCK_FILTER>, будут завершаться с ошибкой B<EPERM>."

#. type: TP
#: man-pages/man7/socket.7:592
#, no-wrap
msgid "B<SO_MARK> (since Linux 2.6.25)"
msgstr "B<SO_MARK> (начиная с Linux 2.6.25)"

#.  commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
#.  and    914a9ab386a288d0f22252fc268ecbc048cdcbd5
#. type: Plain text
#: man-pages/man7/socket.7:603
msgid ""
"Set the mark for each packet sent through this socket (similar to the "
"netfilter MARK target but socket-based).  Changing the mark can be used for "
"mark-based routing without netfilter or for packet filtering.  Setting this "
"option requires the B<CAP_NET_ADMIN> capability."
msgstr ""
"Устанавливать метку на каждый пакет, отправленный через сокет (похоже на "
"цель netfilter MARK, но для сокетов). Изменение метки можно использовать для "
"маршрутизации на основе меток не задействуя netfilter или для фильтрации "
"пакетов. Для установки этого параметра требуется мандат B<CAP_NET_ADMIN>."

#. type: TP
#: man-pages/man7/socket.7:603
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr "B<SO_OOBINLINE>"

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#.      The kernel has support for the SO_NO_CHECK socket
#.      option (boolean: 0 == default, calculate checksum on xmit,
#.      1 == do not calculate checksum on xmit).
#.  Additional note from Andi Kleen on SO_NO_CHECK (2010-08-30)
#.      On Linux UDP checksums are essentially free and there's no reason
#.      to turn them off and it would disable another safety line.
#.      That is why I didn't document the option.
#. type: Plain text
#: man-pages/man7/socket.7:619
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise, out-of-band data is passed only when the "
"B<MSG_OOB> flag is set during receiving."
msgstr ""
"Если включён этот параметр, то внепоточные данные помещаются непосредственно "
"во входной поток данных. В противном случае внепоточные данные передаются "
"только, если во время приёма установлен флаг B<MSG_OOB>."

#. type: TP
#: man-pages/man7/socket.7:619
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#. type: Plain text
#: man-pages/man7/socket.7:626
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr ""
"Включить или выключить приём управляющего сообщения B<SCM_CREDENTIALS>. "
"Подробней смотрите в B<unix>(7)."

#. type: TP
#: man-pages/man7/socket.7:626
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr "B<SO_PASSSEC>"

#. type: Plain text
#: man-pages/man7/socket.7:633
msgid ""
"Enable or disable the receiving of the B<SCM_SECURITY> control message.  For "
"more information see B<unix>(7)."
msgstr ""
"Включить или выключить приём управляющего сообщения B<SCM_SECURITY>. "
"Подробней смотрите в B<unix>(7)."

#. type: TP
#: man-pages/man7/socket.7:633
#, no-wrap
msgid "B<SO_PEEK_OFF> (since Linux 3.4)"
msgstr "B<SO_PEEK_OFF> (начиная с Linux 3.4)"

#.  commit ef64a54f6e558155b4f149bb10666b9e914b6c54
#. type: Plain text
#: man-pages/man7/socket.7:643
msgid ""
"This option, which is currently supported only for B<unix>(7)  sockets, sets "
"the value of the \"peek offset\" for the B<recv>(2)  system call when used "
"with B<MSG_PEEK> flag."
msgstr ""
"Этот параметр, который пока поддерживается только для сокетов B<unix>(7), "
"устанавливает значение «смещения выборки» (peek offset) для системного "
"вызова B<recv(2)>, когда он используется с флагом B<MSG_PEEK>."

#. type: Plain text
#: man-pages/man7/socket.7:651
msgid ""
"When this option is set to a negative value (it is set to -1 for all new "
"sockets), traditional behavior is provided: B<recv>(2)  with the B<MSG_PEEK> "
"flag will peek data from the front of the queue."
msgstr ""
"Если этому параметру присваивается отрицательное значение (равен -1 для всех "
"новых сокетов), то действует обычное правило: B<recv(2)> с флагом "
"B<MSG_PEEK> выбирает данные из начала (front) очереди."

#. type: Plain text
#: man-pages/man7/socket.7:658
msgid ""
"When the option is set to a value greater than or equal to zero, then the "
"next peek at data queued in the socket will occur at the byte offset "
"specified by the option value.  At the same time, the \"peek offset\" will "
"be incremented by the number of bytes that were peeked from the queue, so "
"that a subsequent peek will return the next data in the queue."
msgstr ""
"Если этому параметру присваивается положительное значение или ноль, то "
"следующая выборка данных из очереди сокета произойдёт по байтовому смещению, "
"определяемому значением этого параметра. В то же время, «смещение выборки» "
"будет увеличено на количество байт, выбранных из очереди, то есть "
"последовательные операции выборки возвращают следующие данные из очереди."

#. type: Plain text
#: man-pages/man7/socket.7:670
msgid ""
"If data is removed from the front of the queue via a call to B<recv>(2)  (or "
"similar) without the B<MSG_PEEK> flag, the \"peek offset\" will be decreased "
"by the number of bytes removed.  In other words, receiving data without the "
"B<MSG_PEEK> flag will cause the \"peek offset\" to be adjusted to maintain "
"the correct relative position in the queued data, so that a subsequent peek "
"will retrieve the data that would have been retrieved had the data not been "
"removed."
msgstr ""
"Если данные удалены из начала очереди с помощью вызова B<recv>(2) (или "
"подобного) без флага B<MSG_PEEK>, то «смещение выборки» будет уменьшено на "
"количество удалённых байт. Другими словами, приём данных без флага "
"B<MSG_PEEK> корректирует «смещение выборки»  относительно поддерживаемого "
"относительного положения данных в очереди, и последующая выборка возвратит "
"данные, которые были бы получены, если бы данные не удалялись."

#. type: Plain text
#: man-pages/man7/socket.7:675
msgid ""
"For datagram sockets, if the \"peek offset\" points to the middle of a "
"packet, the data returned will be marked with the B<MSG_TRUNC> flag."
msgstr ""
"Для датаграммных сокетов, если «смещение выборки» указывает в середину "
"пакета, то возвращаемые данные маркируются флагом B<MSG_TRUNC>."

#. type: Plain text
#: man-pages/man7/socket.7:679
msgid ""
"The following example serves to illustrate the use of B<SO_PEEK_OFF>.  "
"Suppose a stream socket has the following queued input data:"
msgstr ""
"В следующем примере показано использование B<SO_PEEK_OFF>. Предположим, в "
"очереди потокового сокета есть входные данные:"

#. type: Plain text
#: man-pages/man7/socket.7:681
#, no-wrap
msgid "    aabbccddeeff\n"
msgstr "    aabbccddeeff\n"

#. type: Plain text
#: man-pages/man7/socket.7:685
msgid ""
"The following sequence of B<recv>(2)  calls would have the effect noted in "
"the comments:"
msgstr ""
"Следующая последовательность вызовов B<recv>(2) выполнила бы то, что описано "
"в комментариях:"

#. type: Plain text
#: man-pages/man7/socket.7:690
#, no-wrap
msgid ""
"int ov = 4;                  // Set peek offset to 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"
msgstr ""
"int ov = 4;        // установка смещения выборки равной 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"

#. type: Plain text
#: man-pages/man7/socket.7:695
#, no-wrap
msgid ""
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"cc\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"dd\"; offset set to 8\n"
"recv(fd, buf, 2, 0);         // Reads \"aa\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"ee\"; offset set to 8\n"
msgstr ""
"recv(fd, buf, 2, MSG_PEEK);  // выборка «cc»; смещение 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // выборка «dd»; смещение 8\n"
"recv(fd, buf, 2, 0);         // выборка «aa»; смещение 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // выборка «ee»; смещение 8\n"

#. type: TP
#: man-pages/man7/socket.7:697
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr "B<SO_PEERCRED>"

#. type: Plain text
#: man-pages/man7/socket.7:702
msgid ""
"Return the credentials of the peer process connected to this socket.  For "
"further details, see B<unix>(7)."
msgstr ""
"Возвращает учётные данные (credentials) ответного процесса, подключённого к "
"сокету. Дополнительную информацию смотрите в B<unix>(7)."

#. type: TP
#: man-pages/man7/socket.7:702
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr "B<SO_PRIORITY>"

#.  For
#.  .BR ip (7),
#.  this also sets the IP type-of-service (TOS) field for outgoing packets.
#. type: Plain text
#: man-pages/man7/socket.7:715
msgid ""
"Set the protocol-defined priority for all packets to be sent on this "
"socket.  Linux uses this value to order the networking queues: packets with "
"a higher priority may be processed first depending on the selected device "
"queueing discipline.  Setting a priority outside the range 0 to 6 requires "
"the B<CAP_NET_ADMIN> capability."
msgstr ""
"Установить определяемый протоколом приоритет для всех пакетов, отправляемых "
"из этого сокета. Linux использует это значение для управления сетевыми "
"очередями: пакеты с более высоким приоритетом могут быть обработаны раньше "
"(в зависимости от выбранного для устройства способа постановки в очередь). "
"Установка значения приоритета не из диапазона 0 до 6 требует мандата "
"B<CAP_NET_ADMIN>."

#. type: TP
#: man-pages/man7/socket.7:715
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr "B<SO_PROTOCOL> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man7/socket.7:723
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr ""
"Получить протокол сокета в виде целого числа; пример возвращаемого значения: "
"B<IPPROTO_SCTP>. Подробней смотрите в B<socket>(2). Этот параметр сокета "
"доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:723
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr "B<SO_RCVBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  The following thread on LMKL is quite informative:
#.  getsockopt/setsockopt with SO_RCVBUF and SO_SNDBUF "non-standard" behavior
#.  17 July 2012
#.  http://thread.gmane.org/gmane.linux.kernel/1328935
#. type: Plain text
#: man-pages/man7/socket.7:742
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and "
"the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr ""
"Задать или получить максимальный размер буфера приёма сокета (в байтах). "
"Ядро удваивает это значение (для пространства под учёт ресурсов (bookkeeping "
"overhead)) при установке этого параметра с помощью B<setsockopt>(2), и это "
"удвоенное значение возвращается B<getsockopt>(2). Значение по умолчанию "
"устанавливается через файл I</proc/sys/net/core/rmem_default>, а "
"максимальное возможное значение устанавливается через файл I</proc/sys/net/"
"core/rmem_max>. Минимальное (удвоенное) значение для этого параметра равно "
"256."

#. type: TP
#: man-pages/man7/socket.7:742
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_RCVBUFFORCE> (начиная с Linux 2.6.14)"

#. type: Plain text
#: man-pages/man7/socket.7:751
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr ""
"С помощью этого параметра сокета привилегированный (B<CAP_NET_ADMIN>) "
"процесс может выполнить ту же работу, что и с помощью B<SO_RCVBUF>, но "
"возможно превысить ограничение I<rmem_max>."

#. type: TP
#: man-pages/man7/socket.7:751
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr "B<SO_RCVLOWAT> и B<SO_SNDLOWAT>"

#. type: Plain text
#: man-pages/man7/socket.7:767
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4."
msgstr ""

#.  commit c7004482e8dcb7c3c72666395cfa98a216a4fb70
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=111049368106984&w=2
#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#. type: Plain text
#: man-pages/man7/socket.7:784
msgid ""
"Before Linux 2.6.28 B<select>(2), B<poll>(2), and B<epoll>(7)  did not "
"respect the B<SO_RCVLOWAT> setting on Linux, and indicated a socket as "
"readable when even a single byte of data was available.  A subsequent read "
"from the socket would then block until B<SO_RCVLOWAT> bytes are available."
msgstr ""

#. type: TP
#: man-pages/man7/socket.7:784
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr "B<SO_RCVTIMEO> и B<SO_SNDTIMEO>"

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: man-pages/man7/socket.7:819
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of "
"that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached, then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK>, or B<EINPROGRESS> (for "
"B<connect>(2))  just as if the socket was specified to be nonblocking.  If "
"the timeout is set to zero (the default), then the operation will never "
"timeout.  Timeouts only have effect for system calls that perform socket I/O "
"(e.g., B<read>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); timeouts have "
"no effect for B<select>(2), B<poll>(2), B<epoll_wait>(2), and so on."
msgstr ""
"Задать время ожидания (при отправке или приёме) до генерации сообщения об "
"ошибке. Аргументом является структура I<struct timeval>. Если вводящая или "
"выводящая функция блокируется на этот период времени, и данные был "
"отправлены или получены, то возвращаемое значение этой функции будет равно "
"количеству переданных данных; если данные не проходили и время ожидания "
"истекло, то возвращается -1 и I<errno> устанавливается в B<EAGAIN>, "
"B<EWOULDBLOCK> или B<EINPROGRESS> (для B<connect>(2)) — также как, если был "
"сокет был заблокирован. Если время ожидания установлено в 0 (по умолчанию), "
"то операция не будет ждать. Время ожидания учитывается только в системных "
"вызовах, которые выполняют ввод-вывод из сокета (например, B<read>(2), "
"B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); время ожидания не учитывается в "
"B<select>(2), B<poll>(2), B<epoll_wait>(2) и подобных."

#. type: TP
#: man-pages/man7/socket.7:819
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr "B<SO_REUSEADDR>"

#. 	commit c617f398edd4db2b8567a28e899a88f8f574798d
#. 	https://lwn.net/Articles/542629/
#. type: Plain text
#: man-pages/man7/socket.7:836
msgid ""
"Indicates that the rules used in validating addresses supplied in a "
"B<bind>(2)  call should allow reuse of local addresses.  For B<AF_INET> "
"sockets this means that a socket may bind, except when there is an active "
"listening socket bound to the address.  When the listening socket is bound "
"to B<INADDR_ANY> with a specific port then it is not possible to bind to "
"this port for any local address.  Argument is an integer boolean flag."
msgstr ""
"Указать, что правила проверки адресов, передаваемых с помощью вызова "
"B<bind>(2), должны позволять повторное использование локальных адресов. В "
"случае с сокетами B<AF_INET> это означает, что сокет может быть привязан "
"(bind), за исключением случаев, когда активному слушающему сокету присвоен "
"адрес. Если слушающий сокет привязан к B<INADDR_ANY> с определённым портом, "
"то к этому порту невозможно будет привязать любой локальный адрес. "
"Аргументом является целочисленный логический флаг."

#. type: TP
#: man-pages/man7/socket.7:836
#, no-wrap
msgid "B<SO_REUSEPORT> (since Linux 3.9)"
msgstr "B<SO_REUSEPORT> (начиная с Linux 3.9)"

#. type: Plain text
#: man-pages/man7/socket.7:851
msgid ""
"Permits multiple B<AF_INET> or B<AF_INET6> sockets to be bound to an "
"identical socket address.  This option must be set on each socket (including "
"the first socket)  prior to calling B<bind>(2)  on the socket.  To prevent "
"port hijacking, all of the processes binding to the same address must have "
"the same effective UID.  This option can be employed with both TCP and UDP "
"sockets."
msgstr ""
"Разрешить многократную привязку сокета B<AF_INET> или B<AF_INET6> к "
"одинаковому адресу сокета. Данный параметр должен быть указан на каждом "
"сокете (включая первый сокет) до вызова B<bind>(2). Чтобы предотвратить "
"захват порта  все привязки процессов к одному адресу должны иметь один "
"эффективный UID. Данный параметр можно применять к сокетам TCP и UDP."

#. type: Plain text
#: man-pages/man7/socket.7:863
msgid ""
"For TCP sockets, this option allows B<accept>(2)  load distribution in a "
"multi-threaded server to be improved by using a distinct listener socket for "
"each thread.  This provides improved load distribution as compared to "
"traditional techniques such using a single B<accept>(2)ing thread that "
"distributes connections, or having multiple threads that compete to "
"B<accept>(2)  from the same socket."
msgstr ""
"Для сокетов TCP данный параметр позволяет B<accept>(2) распределить нагрузку "
"в многонитевом сервере, назначая разные слушатели сокета в каждой нити. Это "
"улучшает распределение нагрузки по сравнении с обычными методами, например с "
"одной принимающей нитью B<accept>(2), которая распределяет соединения, или с "
"несколькими нитями, которые конкурируют за B<accept>(2) единого сокета."

#. type: Plain text
#: man-pages/man7/socket.7:869
msgid ""
"For UDP sockets, the use of this option can provide better distribution of "
"incoming datagrams to multiple processes (or threads) as compared to the "
"traditional technique of having multiple processes compete to receive "
"datagrams on the same socket."
msgstr ""
"Для сокетов UDP использование данного параметра может улучшить распределение "
"входящих датаграмм по нескольким процессам (или нитям) по сравнении с "
"обычным методом с несколькими процессами, которые конкурируют при приёме "
"датаграмм из единого сокета."

#. type: TP
#: man-pages/man7/socket.7:869
#, no-wrap
msgid "B<SO_RXQ_OVFL> (since Linux 2.6.33)"
msgstr "B<SO_RXQ_OVFL> (начиная с Linux 2.6.33)"

#.  commit 3b885787ea4112eaa80945999ea0901bf742707f
#. type: Plain text
#: man-pages/man7/socket.7:875
msgid ""
"Indicates that an unsigned 32-bit value ancillary message (cmsg)  should be "
"attached to received skbs indicating the number of packets dropped by the "
"socket since its creation."
msgstr ""
"Указывает, что к принятым skbs должно быть прикреплено вспомогательное "
"сообщение (cmsg) с беззнаковым 32-битным значением, которое обозначает "
"количество пакетов, отброшенных сокетом с момента его создания."

#. type: TP
#: man-pages/man7/socket.7:875
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr "B<SO_SNDBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  See also the comment to SO_RCVBUF (17 Jul 2012 LKML mail)
#. type: Plain text
#: man-pages/man7/socket.7:891
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> "
"file.  The minimum (doubled) value for this option is 2048."
msgstr ""
"Задать или считать максимальный размер буфера отправки сокета (в байтах). "
"Ядро удваивает это значение (для пространства под учёт ресурсов (bookkeeping "
"overhead)) при установке этого параметра с помощью B<setsockopt>(2), и это "
"удвоенное значение возвращается B<getsockopt>(2). Значение по умолчанию "
"устанавливается через файл I</proc/sys/net/core/wmem_default>, а "
"максимальное возможное значение устанавливается через файл I</proc/sys/net/"
"core/wmem_max>. Минимальное (удвоенное) значение для этого параметра равно "
"2048."

#. type: TP
#: man-pages/man7/socket.7:891
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_SNDBUFFORCE> (начиная Linux 2.6.14)"

#. type: Plain text
#: man-pages/man7/socket.7:900
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr ""
"С помощью этого параметра сокета привилегированный (B<CAP_NET_ADMIN>) "
"процесс может выполнить ту же работу, что и с помощью B<SO_SNDBUF>, но "
"возможно превысить ограничение I<wmem_max>."

#. type: TP
#: man-pages/man7/socket.7:900
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr "B<SO_TIMESTAMP>"

#. type: Plain text
#: man-pages/man7/socket.7:916
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The "
"timestamp control message is sent with level B<SOL_SOCKET> and the "
"I<cmsg_data> field is a I<struct timeval> indicating the reception time of "
"the last packet passed to the user in this call.  See B<cmsg>(3)  for "
"details on control messages."
msgstr ""
"Включить или выключить приём управляющего сообщения B<SO_TIMESTAMP>. "
"Управляющее сообщение метки времени посылается с уровнем B<SOL_SOCKET>, а "
"поле I<cmsg_data> выражено структурой I<struct timeval>, обозначающей время "
"приёма последнего пакета, переданного пользователю в этом вызове. Подробней "
"об управляющих сообщениях смотрите в B<cmsg>(3)."

#. type: TP
#: man-pages/man7/socket.7:916
#, no-wrap
msgid "B<SO_TYPE>"
msgstr "B<SO_TYPE>"

#. type: Plain text
#: man-pages/man7/socket.7:921
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr ""
"Получить тип сокета в виде целого числа (например, B<SOCK_STREAM>). Этот "
"параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:921
#, no-wrap
msgid "B<SO_BUSY_POLL> (since Linux 3.11)"
msgstr "B<SO_BUSY_POLL> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man7/socket.7:930
msgid ""
"Sets the approximate time in microseconds to busy poll on a blocking receive "
"when there is no data.  Increasing this value requires B<CAP_NET_ADMIN>.  "
"The default for this option is controlled by the I</proc/sys/net/core/"
"busy_read> file."
msgstr ""
"Задаёт приблизительный интервал в микросекундах для задержки опроса при "
"блокирующем приёме при отсутствии данных. Увеличение этого значения требует "
"мандата B<CAP_NET_ADMIN>. Значение по умолчанию данного параметра "
"управляется через файл I</proc/sys/net/core/busy_read>."

#. type: Plain text
#: man-pages/man7/socket.7:940
msgid ""
"The value in the I</proc/sys/net/core/busy_poll> file determines how long "
"B<select>(2)  and B<poll>(2)  will busy poll when they operate on sockets "
"with B<SO_BUSY_POLL> set and no events to report are found."
msgstr ""
"Значение в файле I</proc/sys/net/core/busy_poll> определяет как долго "
"B<select>(2) и B<poll>(2) задержат опрос, если они работают с сокетами с "
"установленным B<SO_BUSY_POLL> и отсутствуют события для извещения."

#. type: Plain text
#: man-pages/man7/socket.7:944
msgid ""
"In both cases, busy polling will only be done when the socket last received "
"data from a network device that supports this option."
msgstr ""
"В обоих случаях опрос с задержкой (busy polling) будет завершён только, "
"когда сокет примет все данные из сетевого устройства, которое поддерживает "
"этот параметр."

#. type: Plain text
#: man-pages/man7/socket.7:948
msgid ""
"While busy polling may improve latency of some applications, care must be "
"taken when using it since this will increase both CPU utilization and power "
"usage."
msgstr ""
"Хотя опрос с задержкой может уменьшить время ожидания в некоторых "
"приложениях, этим нужно пользоваться с осторожностью, так как его "
"использование увеличит нагрузку на ЦП и энергопотребление."

#. type: SS
#: man-pages/man7/socket.7:948
#, no-wrap
msgid "Signals"
msgstr "Сигналы"

#. type: Plain text
#: man-pages/man7/socket.7:959
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr ""
"При записи в сокет, ориентированный на соединение, который был выключен "
"(shutdown) локальной или удалённой стороной, записывающему процессу "
"посылается сигнал B<SIGPIPE> и возвращается B<EPIPE>. Сигнал не посылается, "
"если вызов записи был сделан с флагом B<MSG_NOSIGNAL>."

#. type: Plain text
#: man-pages/man7/socket.7:984
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> "
"B<ioctl>(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to "
"use B<poll>(2)  or B<select>(2)  in the signal handler to find out which "
"socket the event occurred on.  An alternative (in Linux 2.2) is to set a "
"real-time signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real "
"time signal will be called with the file descriptor in the I<si_fd> field of "
"its I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr ""
"Если был произведён вызов B<fcntl>(2) с B<FIOSETOWN> или B<ioctl>(2) с "
"B<SIOCSPGRP>, то при появлении событий ввода/вывода посылается сигнал "
"B<SIGIO>. Для определения сокета, в котором произошло событие, в обработчике "
"можно воспользоваться вызовом B<poll>(2) или B<select>(2). Альтернативным "
"способом (в Linux 2.2) является установка сигнала реального времени с "
"помощью вызова B<fcntl>(2) с B<F_SETSIG>; будет вызван обработчик сигнала "
"реального времени и в его структуре I<siginfo_t> поле I<si_fd> будет "
"содержать значение файлового дескриптора. Дополнительная информация "
"приведена в B<fcntl>(2)."

#.  .SS Ancillary messages
#. type: Plain text
#: man-pages/man7/socket.7:992
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared "
"when the process reacts to the signal.  If this happens, the process should "
"wait again because Linux will resend the signal later."
msgstr ""
"В некоторых случаях (например, при наличии доступа нескольких процессов к "
"одному сокету) условие, вызвавшее B<SIGIO>, может исчезнуть на момент "
"обработки процессом сигнала. Если это происходит, то процесс должен "
"подождать сигнала ещё какое-то время, так как Linux снова пошлёт его позже."

#. type: SS
#: man-pages/man7/socket.7:992
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#. type: Plain text
#: man-pages/man7/socket.7:996
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr ""
"Основные сетевые параметры сокета доступны через файлы в каталоге I</proc/"
"sys/net/core/>."

#. type: TP
#: man-pages/man7/socket.7:996
#, no-wrap
msgid "I<rmem_default>"
msgstr "I<rmem_default>"

#. type: Plain text
#: man-pages/man7/socket.7:999
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr "устанавливаемый по умолчанию размер буфера приёма сокета (в байтах)"

#. type: TP
#: man-pages/man7/socket.7:999
#, no-wrap
msgid "I<rmem_max>"
msgstr "I<rmem_max>"

#. type: Plain text
#: man-pages/man7/socket.7:1005
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr ""
"максимальный размер буфера приёма сокета (в байтах), который может "
"установить пользователь с помощью параметра сокета B<SO_RCVBUF>"

#. type: TP
#: man-pages/man7/socket.7:1005
#, no-wrap
msgid "I<wmem_default>"
msgstr "I<wmem_default>"

#. type: Plain text
#: man-pages/man7/socket.7:1008
msgid "contains the default setting in bytes of the socket send buffer."
msgstr "устанавливаемый по умолчанию размер буфера отправки сокета (в байтах)"

#. type: TP
#: man-pages/man7/socket.7:1008
#, no-wrap
msgid "I<wmem_max>"
msgstr "I<wmem_max>"

#. type: Plain text
#: man-pages/man7/socket.7:1014
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr ""
"максимальный размер буфера отправки сокета (в байтах), который может "
"установить пользователь с помощью параметра сокета B<SO_SNDBUF>"

#. type: TP
#: man-pages/man7/socket.7:1014
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr "I<message_cost> и I<message_burst>"

#. type: Plain text
#: man-pages/man7/socket.7:1018
msgid ""
"configure the token bucket filter used to load limit warning messages caused "
"by external network events."
msgstr ""
"фильтр корзины токенов, используемый для ограничения нагрузки сети "
"предупреждающими сообщениями, вызванными внешними сетевыми событиями"

#. type: TP
#: man-pages/man7/socket.7:1018
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr "I<netdev_max_backlog>"

#. type: Plain text
#: man-pages/man7/socket.7:1021
msgid "Maximum number of packets in the global input queue."
msgstr "максимальное количество пакетов в глобальной входящей очереди"

#. type: TP
#: man-pages/man7/socket.7:1021
#, no-wrap
msgid "I<optmem_max>"
msgstr "I<optmem_max>"

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: man-pages/man7/socket.7:1026
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr ""
"максимальная длина вспомогательных данных и управляющих данных пользователя, "
"таких, как iovec (для каждого сокета)"

#. type: Plain text
#: man-pages/man7/socket.7:1029
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr "Следующие операции доступны через B<ioctl>(2):"

#. type: Plain text
#: man-pages/man7/socket.7:1033
#, no-wrap
msgid "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"
msgstr "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"

#. type: TP
#: man-pages/man7/socket.7:1035
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr "B<SIOCGSTAMP>"

#. type: Plain text
#: man-pages/man7/socket.7:1059
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>.  "
"This ioctl should be used only if the socket option B<SO_TIMESTAMP> is not "
"set on the socket.  Otherwise, it returns the timestamp of the last packet "
"that was received while B<SO_TIMESTAMP> was not set, or it fails if no such "
"packet has been received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set "
"to B<ENOENT>)."
msgstr ""
"Возвращает структуру I<struct timeval> с меткой времени принятого последнего "
"пакета, переданного пользователю. Это полезно для точного вычисления "
"времени. Описание I<struct timeval> приведено в B<setitimer>(2). Данный "
"ioctl нужно использовать только, если для сокета не задан параметр "
"B<SO_TIMESTAMP>. В противном случае возвращается метка времени последнего "
"пакета, который был получен в то время, когда не был установлен "
"B<SO_TIMESTAMP>, или возвращается ошибка, если такой пакет вообще никогда не "
"принимался (т.е. B<ioctl>(2) возвращает -1 и устанавливает I<errno> равной "
"B<ENOENT>)."

#. type: TP
#: man-pages/man7/socket.7:1059
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr "B<SIOCSPGRP>"

#. type: Plain text
#: man-pages/man7/socket.7:1072
msgid ""
"Set the process or process group that is to receive B<SIGIO> or B<SIGURG> "
"signals when I/O becomes possible or urgent data is available.  The argument "
"is a pointer to a I<pid_t>.  For further details, see the description of "
"B<F_SETOWN> in B<fcntl>(2)."
msgstr ""
"Назначает процесс или группу процессов, которым будут посылаться сигналы "
"B<SIGIO> или B<SIGURG> при появлении возможности ввода-вывода или при "
"появлении срочных данных. Аргумент является указателем на I<pid_t>. "
"Дополнительная информация приведена в описании на B<F_SETOWN> в B<fcntl>(2)."

#. type: TP
#: man-pages/man7/socket.7:1072
#, no-wrap
msgid "B<FIOASYNC>"
msgstr "B<FIOASYNC>"

#. type: Plain text
#: man-pages/man7/socket.7:1082
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the "
"socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal "
"set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr ""
"Изменяет флаг B<O_ASYNC> для включения или отключения асинхронного режима "
"ввода/вывода сокета. В асинхронном режиме при появлении событий ввода/вывода "
"посылается сигнал B<SIGIO> или сигнал, установленный с помощью B<F_SETSIG>."

#. type: Plain text
#: man-pages/man7/socket.7:1090
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the "
"use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr ""
"Аргументом является целочисленный логический флаг. Данная операция "
"аналогична вызову B<fcntl>(2) с установленным флагом B<O_ASYNC>."

#. type: TP
#: man-pages/man7/socket.7:1090
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr "B<SIOCGPGRP>"

#. type: Plain text
#: man-pages/man7/socket.7:1099
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG> "
"signals, or 0 when none is set."
msgstr ""
"Возвращает процесс или группу процессов, получающих сигналы B<SIGIO> или "
"B<SIGURG>. Если такой процесс не задан, то возвращается нулевое значение."

#. type: Plain text
#: man-pages/man7/socket.7:1103
msgid "Valid B<fcntl>(2)  operations:"
msgstr "Возможные операции B<fcntl>(2):"

#. type: TP
#: man-pages/man7/socket.7:1103
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr "B<FIOGETOWN>"

#. type: Plain text
#: man-pages/man7/socket.7:1108
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr "То же, что и вызов B<ioctl>(2) B<SIOCGPGRP>."

#. type: TP
#: man-pages/man7/socket.7:1108
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr "B<FIOSETOWN>"

#. type: Plain text
#: man-pages/man7/socket.7:1113
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr "То же, что и вызов B<ioctl>(2) B<SIOCSPGRP>."

#. type: Plain text
#: man-pages/man7/socket.7:1127
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in "
"Linux 2.2.  The I</proc> interfaces were introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr ""
"Параметр B<SO_BINDTODEVICE> появился в Linux 2.0.30. Параметр B<SO_PASSCRED> "
"появился в Linux 2.2. Интерфейсы I</proc> появились в Linux 2.2. Параметры "
"B<SO_RCVTIMEO> и B<SO_SNDTIMEO> начали поддерживаться в Linux 2.3.41. До "
"этого, времена ожидания были жёстко прописаны в настройках протокола и "
"недоступны для чтения или записи."

#. type: Plain text
#: man-pages/man7/socket.7:1132
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr ""
"В Linux предполагается, что половина буфера приёма/передачи используется для "
"размещения внутренних структур ядра; поэтому соответствующие файлы I</proc> "
"в два раза больше, чем кажутся."

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/socket.7:1147
msgid ""
"Linux will allow port reuse only with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from "
"some implementations (e.g., FreeBSD)  where only the later program needs to "
"set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr ""
"В Linux разрешено повторное использование порта с параметром B<SO_REUSEADDR> "
"только, когда этот параметр установлен и в программе, уже выполнившей "
"B<bind>(2) и в программе, которая хочет использовать порт. Такое поведение "
"отличается от некоторых реализаций (например, FreeBSD), в которых только "
"последняя программа должна устанавливать параметр B<SO_REUSEADDR>. Обычно, "
"это отличие незаметно, так как, например, в серверных программах всегда "
"устанавливают этот параметр."

#. type: Plain text
#: man-pages/man7/socket.7:1163
msgid ""
"B<wireshark>(1), B<bpf>(2), B<connect>(2), B<getsockopt>(2), "
"B<setsockopt>(2), B<socket>(2), B<pcap>(3), B<address_families>(7), "
"B<capabilities>(7), B<ddp>(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7), B<tcpdump>(8)"
msgstr ""
"B<wireshark>(1), B<bpf>(2), B<connect>(2), B<getsockopt>(2), "
"B<setsockopt>(2), B<socket>(2), B<pcap>(3), B<address_families>(7), "
"B<capabilities>(7), B<ddp>(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7), B<tcpdump>(8)"

#. type: TH
#: man-pages/man7/session-keyring.7:12
#, no-wrap
msgid "SESSION-KEYRING"
msgstr "SESSION-KEYRING"

#. type: Plain text
#: man-pages/man7/session-keyring.7:15
msgid "session-keyring - session shared process keyring"
msgstr "session-keyring - общая сеансовая связка ключей процесса"

#. type: Plain text
#: man-pages/man7/session-keyring.7:25
msgid ""
"The session keyring is a keyring used to anchor keys on behalf of a "
"process.  It is typically created by B<pam_keyinit>(8)  when a user logs in "
"and a link will be added that refers to the B<user-keyring>(7).  Optionally, "
"PAM may revoke the session keyring on logout.  (In typical configurations, "
"PAM does do this revocation.)  The session keyring has the name "
"(description)  I<_ses>."
msgstr ""
"Связка ключей сеанса — это связка ключей для привязки ключей от имени "
"процесса. Обычно, она создаётся B<pam_keyinit>(8) при входе пользователя в "
"систему и добавляется связь, на которую указывает B<user-keyring>(7). Также, "
"PAM может отозвать связку ключей сеанса при выходе пользователя (обычно, PAM "
"так и делает). Связка ключей сеанса имеет имя (описание) I<_ses>."

#. type: Plain text
#: man-pages/man7/session-keyring.7:30
msgid ""
"A special serial number value, B<KEY_SPEC_SESSION_KEYRING>, is defined that "
"can be used in lieu of the actual serial number of the calling process's "
"session keyring."
msgstr ""
"Существует специальный серийный номер, B<KEY_SPEC_SESSION_KEYRING>, который "
"можно указывать вместо реального серийного номера связки ключей сеанса "
"вызывающего процесса."

#. type: Plain text
#: man-pages/man7/session-keyring.7:35
msgid ""
"From the B<keyctl>(1)  utility, 'B<@s>' can be used instead of a numeric key "
"ID in much the same way."
msgstr ""
"В утилите B<keyctl>(1) подобным образом можно использовать «B<@s>» вместо "
"числового идентификатора ключа."

#. type: Plain text
#: man-pages/man7/session-keyring.7:47
msgid ""
"A process's session keyring is inherited across B<clone>(2), B<fork>(2), and "
"B<vfork>(2).  The session keyring is preserved across B<execve>(2), even "
"when the executable is set-user-ID or set-group-ID or has capabilities.  The "
"session keyring is destroyed when the last process that refers to it exits."
msgstr ""
"Связка ключей сеанса процесса наследуется при вызове B<clone>(2), B<fork>(2) "
"и B<vfork>(2). Связка ключей сеанса сохраняется при вызове B<execve>(2), "
"даже когда исполняемый файл содержит биты set-user-ID и set-group-ID или "
"имеет другие мандаты. Связка ключей сеанса уничтожается когда завершается "
"последний ссылающийся на неё процесс."

#. type: Plain text
#: man-pages/man7/session-keyring.7:56
msgid ""
"If a process doesn't have a session keyring when it is accessed, then, under "
"certain circumstances, the B<user-session-keyring>(7)  will be attached as "
"the session keyring and under others a new session keyring will be created.  "
"(See B<user-session-keyring>(7)  for further details.)"
msgstr ""
"Если процесс при обращении не имеет связки ключей сеанса, то в одних "
"случаях, в качестве связке ключей сеанса будет присоединена B<user-session-"
"keyring>(7), а в других будет создана новая связка ключей сеанса "
"(подробности смотрите в B<user-session-keyring>(7))."

#. type: SS
#: man-pages/man7/session-keyring.7:56
#, no-wrap
msgid "Special operations"
msgstr "Специальные операции"

#. type: Plain text
#: man-pages/man7/session-keyring.7:61
msgid ""
"The I<keyutils> library provides the following special operations for "
"manipulating session keyrings:"
msgstr ""
"Библиотека I<keyutils> предоставляет следующие операции для работы со "
"связками ключей сеанса:"

#. type: TP
#: man-pages/man7/session-keyring.7:61
#, no-wrap
msgid "B<keyctl_join_session_keyring>(3)"
msgstr "B<keyctl_join_session_keyring>(3)"

#. type: Plain text
#: man-pages/man7/session-keyring.7:73
msgid ""
"This operation allows the caller to change the session keyring that it "
"subscribes to.  The caller can join an existing keyring with a specified "
"name (description), create a new keyring with a given name, or ask the "
"kernel to create a new \"anonymous\" session keyring with the name \"_ses"
"\".  (This function is an interface to the B<keyctl>(2)  "
"B<KEYCTL_JOIN_SESSION_KEYRING> operation.)"
msgstr ""
"Данная операция позволяет вызывающему изменить связку ключей сеанса, на "
"которую он подписан. Вызывающий может присоединить существующую связку "
"ключей с заданным именем (описанием), создать новую связку ключей с заданным "
"именем или попросить ядро создать новую «анонимную» связку ключей сеанса с "
"именем «_ses» (данная функция является интерфейсом к B<keyctl>(2) с "
"операцией B<KEYCTL_JOIN_SESSION_KEYRING>)."

#. type: TP
#: man-pages/man7/session-keyring.7:73
#, no-wrap
msgid "B<keyctl_session_to_parent>(3)"
msgstr "B<keyctl_session_to_parent>(3)"

#. type: Plain text
#: man-pages/man7/session-keyring.7:83
msgid ""
"This operation allows the caller to make the parent process's session "
"keyring to the same as its own.  For this to succeed, the parent process "
"must have identical security attributes and must be single threaded.  (This "
"function is an interface to the B<keyctl>(2)  B<KEYCTL_SESSION_TO_PARENT> "
"operation.)"
msgstr ""
"Данная операция позволяет вызывающему сделать связку ключей сеанса родителя "
"своей собственной. Для успешного выполнения родительский процесс должен "
"иметь такие же атрибуты безопасности и состоять из одной нити (данная "
"операция является интерфейсом к B<keyctl>(2) с операцией "
"B<KEYCTL_SESSION_TO_PARENT>)."

#. type: Plain text
#: man-pages/man7/session-keyring.7:87
msgid "These operations are also exposed through the B<keyctl>(1)  utility as:"
msgstr "Эти операции также доступны через утилиту B<keyctl>(1)"

#. type: Plain text
#: man-pages/man7/session-keyring.7:93
#, no-wrap
msgid ""
"keyctl session\n"
"keyctl session - [E<lt>progE<gt> E<lt>arg1E<gt> E<lt>arg2E<gt> ...]\n"
"keyctl session E<lt>nameE<gt> [E<lt>progE<gt> E<lt>arg1E<gt> E<lt>arg2E<gt> ...]\n"
msgstr ""
"keyctl session\n"
"keyctl session - [E<lt>прогE<gt> E<lt>арг1E<gt> E<lt>арг2E<gt> …]\n"
"keyctl session E<lt>имяE<gt> [E<lt>прогE<gt> E<lt>арг1E<gt> E<lt>арг2E<gt> …]\n"

#. type: Plain text
#: man-pages/man7/session-keyring.7:97
msgid "and:"
msgstr "и"

#. type: Plain text
#: man-pages/man7/session-keyring.7:101
#, no-wrap
msgid "keyctl new_session\n"
msgstr "keyctl new_session\n"

#. type: Plain text
#: man-pages/man7/session-keyring.7:116
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyctl_join_session_keyring>(3), "
"B<keyctl_session_to_parent>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"
msgstr ""
"B<keyctl>(1), B<keyctl>(3), B<keyctl_join_session_keyring>(3), "
"B<keyctl_session_to_parent>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"

#. type: TH
#: man-pages/man7/shm_overview.7:27
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr "SHM_OVERVIEW"

#. type: TH
#: man-pages/man7/shm_overview.7:27
#, no-wrap
msgid "2016-12-12"
msgstr "2016-12-12"

#. type: Plain text
#: man-pages/man7/shm_overview.7:30
msgid "shm_overview - overview of POSIX shared memory"
msgstr "shm_overview - обзор общей памяти POSIX"

#. type: Plain text
#: man-pages/man7/shm_overview.7:33
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""
"API общей памяти POSIX позволяет процессам обмениваться информацией через "
"общую область памяти."

#. type: Plain text
#: man-pages/man7/shm_overview.7:35
msgid "The interfaces employed in the API are:"
msgstr "Доступные интерфейсы:"

#. type: TP
#: man-pages/man7/shm_overview.7:35
#, no-wrap
msgid "B<shm_open>(3)"
msgstr "B<shm_open>(3)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:42
msgid ""
"Create and open a new object, or open an existing object.  This is analogous "
"to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""
"Создаёт и открывает новый объект, или открывает существующий объект. Аналог "
"B<open>(2). Вызов возвращает файловый дескриптор, которые используется "
"другими интерфейсами, описанными далее."

#. type: Plain text
#: man-pages/man7/shm_overview.7:46
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr ""
"Назначает размер общего объекта памяти (размер создаваемого объекта общей "
"памяти равен нулю)."

#. type: Plain text
#: man-pages/man7/shm_overview.7:50
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""
"Отображает объект общей памяти в виртуальное адресное пространство "
"вызвавшего процесса."

#. type: TP
#: man-pages/man7/shm_overview.7:50
#, no-wrap
msgid "B<munmap>(2)"
msgstr "B<munmap>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:54
msgid ""
"Unmap the shared memory object from the virtual address space of the calling "
"process."
msgstr ""
"Удаляет отображение объекта общей памяти из виртуального адресного "
"пространства вызвавшего процесса."

#. type: TP
#: man-pages/man7/shm_overview.7:54
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr "B<shm_unlink>(3)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:57
msgid "Remove a shared memory object name."
msgstr "Удаляет объект общей памяти с заданным именем."

#. type: Plain text
#: man-pages/man7/shm_overview.7:62
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""
"Закрывает файловый дескриптор (выделенный  B<shm_open>(3)), когда он больше "
"не требуется."

#. type: Plain text
#: man-pages/man7/shm_overview.7:76
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""
"Возвращает структуру I<stat>, в которой описан объект общей памяти. "
"Информация, возвращаемой этим вызовом: размер объекта (I<st_size>), права "
"(I<st_mode>), владелец (I<st_uid>) и группа (I<st_gid>)."

#. type: Plain text
#: man-pages/man7/shm_overview.7:79
msgid "To change the ownership of a shared memory object."
msgstr "Изменяет владельца объекта общей памяти."

#. type: Plain text
#: man-pages/man7/shm_overview.7:82
msgid "To change the permissions of a shared memory object."
msgstr "Изменяет права на объект общей памяти."

#. type: SS
#: man-pages/man7/shm_overview.7:82
#, no-wrap
msgid "Versions"
msgstr "Версии"

#. type: Plain text
#: man-pages/man7/shm_overview.7:84
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr "Общая память POSIX стала доступна начиная с Linux 2.4 и glibc 2.2."

#. type: SS
#: man-pages/man7/shm_overview.7:84
#, no-wrap
msgid "Persistence"
msgstr "Устойчивость"

#. type: Plain text
#: man-pages/man7/shm_overview.7:89
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""
"Объекты общей памяти POSIX являются устойчивыми на уровне ядра. Объект будет "
"существовать до самого отключения системы или до тех пор, пока все процессы "
"не разорвут связь с объектом, после чего он может быть удален с помощью "
"B<shm_unlink>(3)."

#. type: SS
#: man-pages/man7/shm_overview.7:89
#, no-wrap
msgid "Linking"
msgstr "Компоновка"

#. type: Plain text
#: man-pages/man7/shm_overview.7:94
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""
"Программы, в которых используется программный интерфейс общей памяти POSIX, "
"для компоновки с библиотекой реального времени I<librt> должны "
"компилироваться с помощью I<cc -lrt>."

#. type: SS
#: man-pages/man7/shm_overview.7:94
#, no-wrap
msgid "Accessing shared memory objects via the filesystem"
msgstr "Доступ к объектам общей памяти через файловую систему"

#. type: Plain text
#: man-pages/man7/shm_overview.7:101
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>(5))  virtual "
"filesystem, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual filesystem."
msgstr ""
"В Linux объекты общей памяти создаются в виртуальной файловой системе "
"(I<tmpfs>(5)), которая обычно монтируется в каталог I</dev/shm>. Начиная с "
"ядра версии 2.6.19, в Linux поддерживается использование списков контроля "
"доступа (ACL) для управления доступа к объектам в виртуальной файловой "
"системе."

#. type: Plain text
#: man-pages/man7/shm_overview.7:104
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""
"Обычно процессы должны синхронизировать свой доступ к объекту общей памяти, "
"например, с использованием семафоров POSIX."

#. type: Plain text
#: man-pages/man7/shm_overview.7:112
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""
"Общая память System V (B<shmget>(2), B<shmop>(2) и так далее) является "
"старым API. POSIX предоставляет более простой и лучше спроектированный "
"интерфейс. С другой стороны, общая память POSIX в какой-то мере менее "
"распространена (особенно на старых системах), чем System V."

#. type: Plain text
#: man-pages/man7/shm_overview.7:124
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man7/sem_overview.7:26
#, no-wrap
msgid "SEM_OVERVIEW"
msgstr "SEM_OVERVIEW"

#. type: TH
#: man-pages/man7/sem_overview.7:26
#, no-wrap
msgid "2017-05-03"
msgstr "2017-05-03"

#. type: Plain text
#: man-pages/man7/sem_overview.7:29
msgid "sem_overview - overview of POSIX semaphores"
msgstr "sem_overview - обзор семафоров POSIX"

#. type: Plain text
#: man-pages/man7/sem_overview.7:31
msgid ""
"POSIX semaphores allow processes and threads to synchronize their actions."
msgstr ""
"Семафоры POSIX позволяют процессам и нитям синхронизировать свою работу."

#. type: Plain text
#: man-pages/man7/sem_overview.7:41
msgid ""
"A semaphore is an integer whose value is never allowed to fall below zero.  "
"Two operations can be performed on semaphores: increment the semaphore value "
"by one (B<sem_post>(3)); and decrement the semaphore value by one "
"(B<sem_wait>(3)).  If the value of a semaphore is currently zero, then a "
"B<sem_wait>(3)  operation will block until the value becomes greater than "
"zero."
msgstr ""
"Семафор представляет собой целое число, значение которого никогда не будет "
"меньше нуля. Над семафорами выполняются две операции: увеличение значения "
"семафора на единицу (B<sem_post>(3)) и уменьшение значения семафора на "
"единицу (B<sem_wait>(3)). Если значение семафора равно нулю, то операция "
"B<sem_wait>(3) блокирует работу до тех пор, пока значение не станет больше "
"нуля."

#. type: Plain text
#: man-pages/man7/sem_overview.7:44
msgid ""
"POSIX semaphores come in two forms: named semaphores and unnamed semaphores."
msgstr ""
"Есть два вида семафоров POSIX: именованные семафоры и безымянные семафоры."

#. type: TP
#: man-pages/man7/sem_overview.7:44
#, no-wrap
msgid "B<Named semaphores>"
msgstr "B<Именованные семафоры>"

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory tree must exist under /dev/shm, and
#.  the fist subdirectory component must exist as the name
#.  sem.name, and all of the subdirectory components must allow the
#.  required permissions if a user wants to create a semaphore
#.  object in a subdirectory.
#. type: Plain text
#: man-pages/man7/sem_overview.7:64
msgid ""
"A named semaphore is identified by a name of the form I</somename>; that is, "
"a null-terminated string of up to B<NAME_MAX>I<-4> (i.e., 251) characters "
"consisting of an initial slash, followed by one or more characters, none of "
"which are slashes.  Two processes can operate on the same named semaphore by "
"passing the same name to B<sem_open>(3)."
msgstr ""
"Именованные семафоры отличают по именам вида I</имя> — строка (с null в "
"конце) до B<NAME_MAX>I<-4> (т. е., 251) символов, состоящая из начальной "
"косой черты и одного или нескольких символов (символ косой черты не "
"допускается). Два процесса могут работать с одним семафором указав его имя в "
"B<sem_open>(3)."

#. type: Plain text
#: man-pages/man7/sem_overview.7:79
msgid ""
"The B<sem_open>(3)  function creates a new named semaphore or opens an "
"existing named semaphore.  After the semaphore has been opened, it can be "
"operated on using B<sem_post>(3)  and B<sem_wait>(3).  When a process has "
"finished using the semaphore, it can use B<sem_close>(3)  to close the "
"semaphore.  When all processes have finished using the semaphore, it can be "
"removed from the system using B<sem_unlink>(3)."
msgstr ""
"Функция B<sem_open>(3) создаёт новый именованный семафор или открывает "
"существующий. После открытия семафора с ним можно работать посредством "
"B<sem_post>(3) и B<sem_wait>(3). Когда процесс закончил использовать "
"семафор, его можно закрыть с помощью B<sem_close>(3). Когда все процессы "
"закончили использовать семафор, его можно удалить из системы с помощью "
"B<sem_unlink>(3)."

#. type: TP
#: man-pages/man7/sem_overview.7:79
#, no-wrap
msgid "B<Unnamed semaphores (memory-based semaphores)>"
msgstr "B<Безымянные семафоры (семафоры в памяти)>"

#. type: Plain text
#: man-pages/man7/sem_overview.7:94
msgid ""
"An unnamed semaphore does not have a name.  Instead the semaphore is placed "
"in a region of memory that is shared between multiple threads (a I<thread-"
"shared semaphore>)  or processes (a I<process-shared semaphore>).  A thread-"
"shared semaphore is placed in an area of memory shared between the threads "
"of a process, for example, a global variable.  A process-shared semaphore "
"must be placed in a shared memory region (e.g., a System V shared memory "
"segment created using B<shmget>(2), or a POSIX shared memory object built "
"created using B<shm_open>(3))."
msgstr ""
"Безымянные семафоры не имеют имени. Семафор размещается в области памяти, "
"которая доступна нескольким нитям (I<общий семафор для нитей)> или процессам "
"(I<общий семафор для процессов>). Общий семафор для нитей размещается в "
"области памяти, которая доступна из нитей процесса, например в глобальной "
"переменной. Общий семафор для процессов должен размещаться в области общей "
"памяти (например, в сегменте общей памяти System V, созданной с помощью "
"B<shmget>(2), или в объекте общей памяти POSIX, созданном с помощью "
"B<shm_open>(3))."

#. type: Plain text
#: man-pages/man7/sem_overview.7:105
msgid ""
"Before being used, an unnamed semaphore must be initialized using "
"B<sem_init>(3).  It can then be operated on using B<sem_post>(3)  and "
"B<sem_wait>(3).  When the semaphore is no longer required, and before the "
"memory in which it is located is deallocated, the semaphore should be "
"destroyed using B<sem_destroy>(3)."
msgstr ""
"Перед началом использования безымянный семафор должны быть "
"проинициализирован с помощью B<sem_init>(3). После этого с ним можно "
"работать через B<sem_post>(3) и B<sem_wait>(3). Если семафор больше не "
"нужен, то семафор нужно уничтожить с помощью B<sem_destroy>(3) (но до "
"освобождения выделенной для него памяти)."

#. type: Plain text
#: man-pages/man7/sem_overview.7:108
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX semaphores."
msgstr ""
"Далее в разделе описываются особенности реализации семафоров POSIX в Linux."

#. type: Plain text
#: man-pages/man7/sem_overview.7:114
msgid ""
"Prior to kernel 2.6, Linux supported only unnamed, thread-shared "
"semaphores.  On a system with Linux 2.6 and a glibc that provides the NPTL "
"threading implementation, a complete implementation of POSIX semaphores is "
"provided."
msgstr ""
"До ядра версии 2.6, в Linux поддерживались только безымянные общие семафоры "
"для нитей. В системах с Linux 2.6 и glibc, предоставляющей реализацию нитей "
"NPTL, имеется полная реализация семафоров POSIX."

#. type: Plain text
#: man-pages/man7/sem_overview.7:119
msgid ""
"POSIX named semaphores have kernel persistence: if not removed by "
"B<sem_unlink>(3), a semaphore will exist until the system is shut down."
msgstr ""
"Именованные семафоры POSIX располагаются в ядре. Пока семафор не удалён с "
"помощью B<sem_unlink>(3), он остаётся в системе до её выключения."

#. type: Plain text
#: man-pages/man7/sem_overview.7:124
msgid ""
"Programs using the POSIX semaphores API must be compiled with I<cc -pthread> "
"to link against the real-time library, I<librt>."
msgstr ""
"Программы, в которых используется программный интерфейс семафоров POSIX, для "
"компоновки с библиотекой реального времени I<librt> должны компилироваться с "
"помощью I<cc -pthread>."

#. type: SS
#: man-pages/man7/sem_overview.7:124
#, no-wrap
msgid "Accessing named semaphores via the filesystem"
msgstr "Доступ к именованным семафорам через файловую систему"

#. type: Plain text
#: man-pages/man7/sem_overview.7:135
msgid ""
"On Linux, named semaphores are created in a virtual filesystem, normally "
"mounted under I</dev/shm>, with names of the form B<sem.>I<somename>.  (This "
"is the reason that semaphore names are limited to B<NAME_MAX>I<-4> rather "
"than B<NAME_MAX> characters.)"
msgstr ""
"В Linux, именованные семафоры создаются в виртуальной файловой системе, "
"обычно монтируемой в I</dev/shm>, с именами вида B<sem.>I<имя> (по этой "
"причине длина имени семафора ограничена B<NAME_MAX>I<-4>, а не B<NAME_MAX> "
"символами)."

#. type: Plain text
#: man-pages/man7/sem_overview.7:138
msgid ""
"Since Linux 2.6.19, ACLs can be placed on files under this directory, to "
"control object permissions on a per-user and per-group basis."
msgstr ""
"Начиная с Linux 2.6.19, для управления доступом к объектам конкретным "
"пользователям или группам на файлы в этом каталоге могут быть применены ACL."

#. type: Plain text
#: man-pages/man7/sem_overview.7:147
msgid ""
"System V semaphores (B<semget>(2), B<semop>(2), etc.) are an older semaphore "
"API.  POSIX semaphores provide a simpler, and better designed interface than "
"System V semaphores; on the other hand POSIX semaphores are less widely "
"available (especially on older systems) than System V semaphores."
msgstr ""
"Семафоры System V (B<semget>(2), B<semop>(2) и т. п.) — это старый "
"программный интерфейс семафоров. Семафоры POSIX предоставляют более простой "
"и продуманный интерфейс чем семафоры System V; с другой стороны, семафоры "
"POSIX не так широко распространены (особенно в старых системах), по "
"сравнению с семафорами System V."

#. type: Plain text
#: man-pages/man7/sem_overview.7:150
msgid ""
"An example of the use of various POSIX semaphore functions is shown in "
"B<sem_wait>(3)."
msgstr "Пример использования функций семафоров POSIX показан в B<sem_wait>(3)."

#. type: Plain text
#: man-pages/man7/sem_overview.7:160
msgid ""
"B<sem_close>(3), B<sem_destroy>(3), B<sem_getvalue>(3), B<sem_init>(3), "
"B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), B<sem_wait>(3), "
"B<pthreads>(7), B<shm_overview>(7)"
msgstr ""
"B<sem_close>(3), B<sem_destroy>(3), B<sem_getvalue>(3), B<sem_init>(3), "
"B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), B<sem_wait>(3), "
"B<pthreads>(7), B<shm_overview>(7)"

#. type: TH
#: man-pages/man2/set_thread_area.2:9
#, no-wrap
msgid "SET_THREAD_AREA"
msgstr "SET_THREAD_AREA"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:12
msgid ""
"get_thread_area, set_thread_area - manipulate thread-local storage "
"information"
msgstr ""
"get_thread_area, set_thread_area - управляют информацией области локального "
"хранилища нити"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:15
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:18
#, no-wrap
msgid ""
"B<#if defined __i386__ || defined __x86_64__>\n"
"B<# include E<lt>asm/ldt.hE<gt>>\n"
msgstr ""
"B<#if defined __i386__ || defined __x86_64__>\n"
"B<# include E<lt>asm/ldt.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:21
#, no-wrap
msgid ""
"B<int get_thread_area(struct user_desc *>I<u_info>B<);>\n"
"B<int set_thread_area(struct user_desc *>I<u_info>B<);>\n"
msgstr ""
"B<int get_thread_area(struct user_desc *>I<u_info>B<);>\n"
"B<int set_thread_area(struct user_desc *>I<u_info>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:23
#, no-wrap
msgid "B<#elif defined __m68k__>\n"
msgstr "B<#elif defined __m68k__>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:26
#, no-wrap
msgid ""
"B<int get_thread_area(void);>\n"
"B<int set_thread_area(unsigned long >I<tp>B<);>\n"
msgstr ""
"B<int get_thread_area(void);>\n"
"B<int set_thread_area(unsigned long >I<tp>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:28
#, no-wrap
msgid "B<#elif defined __mips__>\n"
msgstr "B<#elif defined __mips__>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:30
#, no-wrap
msgid "B<int set_thread_area(unsigned long >I<addr>B<);>\n"
msgstr "B<int set_thread_area(unsigned long >I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:32
#, no-wrap
msgid "B<#endif>\n"
msgstr "B<#endif>\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:36
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточных функций для этих системных вызовов; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:44
msgid ""
"These calls provide architecture-specific support for a thread-local storage "
"implementation.  At the moment, B<set_thread_area>()  is available on m68k, "
"MIPS, and x86 (both 32-bit and 64-bit variants); B<get_thread_area>()  is "
"available on m68k and x86."
msgstr ""
"Эти вызовы предоставляют зависимую от архитектуры реализацию поддержки "
"информации области локального хранилища нити. В настоящее время вызов "
"B<set_thread_area>() доступен для m68k, MIPS и x86 (32-битный и 64-битный "
"вариант); B<get_thread_area>() доступен для m68k и x86."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:57
msgid ""
"On m68k and MIPS, B<set_thread_area>()  allows storing an arbitrary pointer "
"(provided in the B<tp> argument on m68k and in the B<addr> argument on "
"MIPS)  in the kernel data structure associated with the calling thread; this "
"pointer can later be retrieved using B<get_thread_area>()  (see also NOTES "
"for information regarding obtaining the thread pointer on MIPS)."
msgstr ""
"Для m68k и MIPS, B<set_thread_area>() позволяет сохранить произвольный "
"указатель (указанный в аргументе B<tp> на m68k и в аргументе B<addr> на "
"MIPS) структуре данных ядра, связанной с вызывающей нитью; этот указатель "
"позднее может быть получен с помощью B<get_thread_area>() (информацию о "
"получении указателя нити на MIPS также смотрите ЗАМЕЧАНИЯ)."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:62
msgid ""
"On x86, Linux dedicates three global descriptor table (GDT) entries for "
"thread-local storage.  For more information about the GDT, see the Intel "
"Software Developer's Manual or the AMD Architecture Programming Manual."
msgstr ""
"На x86 в Linux под локальное хранилище нити отдано три элемента глобальной "
"таблицы дескрипторов (GDT). Подробней о GDT читайте в Intel Software "
"Developer's Manual или AMD Architecture Programming Manual."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:65
msgid ""
"Both of these system calls take an argument that is a pointer to a structure "
"of the following type:"
msgstr "Этим системным вызовам передаётся указатель на структуру вида:"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:82
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"#ifdef __x86_64__\n"
"    unsigned int  lm:1;\n"
"#endif\n"
"};\n"
msgstr ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"#ifdef __x86_64__\n"
"    unsigned int  lm:1;\n"
"#endif\n"
"};\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:90
msgid ""
"B<get_thread_area>()  reads the GDT entry indicated by I<u_info-"
"E<gt>entry_number> and fills in the rest of the fields in I<u_info>."
msgstr ""
"Вызов B<get_thread_area>() читает элемент GDT, указанный в I<u_info-"
"E<gt>entry_number> и заполняет оставшиеся поля в I<u_info>."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:93
msgid "B<set_thread_area>()  sets a TLS entry in the GDT."
msgstr "Вызов B<set_thread_area>() изменяет элемент TLS в GDT."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:104
msgid ""
"The TLS array entry set by B<set_thread_area>()  corresponds to the value of "
"I<u_info-E<gt>entry_number> passed in by the user.  If this value is in "
"bounds, B<set_thread_area>()  writes the TLS descriptor pointed to by "
"I<u_info> into the thread's TLS array."
msgstr ""
"Элемент массива TLS, устанавливаемый B<set_thread_area>(), соответствует "
"значению  I<u_info-E<gt>entry_number>, которое передал пользователь. Если "
"это значение находится в допустимых пределах, то B<set_thread_area>() "
"записывает дескриптор TLS, на который указывает I<u_info>, в массив TLS нити."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:115
msgid ""
"When B<set_thread_area>()  is passed an I<entry_number> of -1, it searches "
"for a free TLS entry.  If B<set_thread_area>()  finds a free TLS entry, the "
"value of I<u_info-E<gt>entry_number> is set upon return to show which entry "
"was changed."
msgstr ""
"Когда B<set_thread_area>() передаётся I<entry_number> со значением -1, то "
"ищется свободный элемент TLS. Если B<set_thread_area>() находит свободный "
"элемент TLS, то значение I<u_info-E<gt>entry_number> устанавливается после "
"возврата для показа того, какой же элемент был изменён."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:127
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  If an "
"\"empty\" descriptor is passed to B<set_thread_area>(), the corresponding "
"TLS entry will be cleared.  See BUGS for additional details."
msgstr ""
"Структура I<user_desc> считается «пустой», если I<read_exec_only> и "
"I<seg_not_present> равны 1, а все остальные поля равны 0. Если «пустой» "
"дескриптор передаётся в B<set_thread_area>(), то соответствующий элемент TLS "
"будет очищен. Дополнительную информацию смотрите в разделе ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:132
msgid ""
"Since Linux 3.19, B<set_thread_area>()  cannot be used to write non-present "
"segments, 16-bit segments, or code segments, although clearing a segment is "
"still acceptable."
msgstr ""
"Начиная с Linux 3.19, B<set_thread_area>() нельзя использовать для записи "
"отсутствующих сегментов, 16-битных сегментов или сегментов кода, но "
"допускается очистка таких сегментов."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:137
msgid ""
"On x86, these system calls return 0 on success, and -1 on failure, with "
"I<errno> set appropriately."
msgstr ""
"На x86 данные системные вызовы возвращают 0 при успешном выполнении и 1 при "
"ошибке, записывая в I<errno> соответствующее значение."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:146
msgid ""
"On MIPS and m68k, B<set_thread_area>()  always returns 0.  On m68k, "
"B<get_thread_area>()  returns the thread area pointer value (previously set "
"via B<set_thread_area>())."
msgstr ""
"На MIPS и m68k вызов B<set_thread_area>() всегда возвращает 0. На m68k вызов "
"B<get_thread_area>() возвращает значение указателя области нити "
"(установленный ране с помощью B<set_thread_area>())."

#. type: SH
#: man-pages/man2/set_thread_area.2:146
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:150
msgid "I<u_info> is an invalid pointer."
msgstr "I<u_info> является некорректным указателем."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:153
msgid "I<u_info-E<gt>entry_number> is out of bounds."
msgstr "I<u_info-E<gt>entry_number> вне допустимых границ."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:159
msgid ""
"B<get_thread_area>()  or B<set_thread_area>()  was invoked as a 64-bit "
"system call."
msgstr ""
"Вызов B<get_thread_area>() или B<set_thread_area>() был вызван как 64-битный "
"системный вызов."

#. type: TP
#: man-pages/man2/set_thread_area.2:159
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:163
msgid "(B<set_thread_area>())  A free TLS entry could not be located."
msgstr "(B<set_thread_area>()) Невозможно найти свободный элемент TLS."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:168
msgid ""
"B<set_thread_area>()  first appeared in Linux 2.5.29.  B<get_thread_area>()  "
"first appeared in Linux 2.5.32."
msgstr ""
"Вызов B<set_thread_area>() появился в версии 2.5.29. Вызов "
"B<get_thread_area>() появился в Linux 2.5.32."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:174
msgid ""
"B<set_thread_area>()  and B<get_thread_area>()  are Linux-specific and "
"should not be used in programs that are intended to be portable."
msgstr ""
"Вызовы B<set_thread_area>() и B<get_thread_area>() есть только в Linux, и "
"они не должны использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:179
msgid ""
"Glibc does not provide wrappers for these system calls, since they are "
"generally intended for use only by threading libraries.  In the unlikely "
"event that you want to call them directly, use B<syscall>(2)."
msgstr ""
"В glibc нет обёрточных функций для этих системных вызовов, так как они "
"предназначены только для использования в библиотеках нитей. Если вам всё-"
"таки нужно их вызвать, используйте B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:190
msgid ""
"B<arch_prctl>(2)  can interfere with B<set_thread_area>()  on x86.  See "
"B<arch_prctl>(2)  for more details.  This is not normally a problem, as "
"B<arch_prctl>(2)  is normally used only by 64-bit programs."
msgstr ""
"На x86 вызов B<arch_prctl>(2) может влиять на B<set_thread_area>(). "
"Подробней смотрите в B<arch_prctl>(2). Обычно это не вызывает проблем, так "
"как B<arch_prctl>(2) обычно используется только в 64-битных программах."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:193
msgid ""
"On MIPS, the current value of the thread area pointer can be obtained using "
"the instruction:"
msgstr ""
"На MIPS текущее значение указателя области нити можно получить с помощью "
"инструкции:"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:197
#, no-wrap
msgid "rdhwr dest, $29\n"
msgstr "rdhwr dest, $29\n"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:201
msgid "This instruction traps and is handled by kernel."
msgstr "Эта инструкция ловится и обрабатывается ядром."

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: man-pages/man2/set_thread_area.2:223
msgid ""
"On 64-bit kernels before Linux 3.19, one of the padding bits in "
"I<user_desc>, if set, would prevent the descriptor from being considered "
"empty (see B<modify_ldt>(2)).  As a result, the only reliable way to clear a "
"TLS entry is to use B<memset>(3)  to zero the entire I<user_desc> structure, "
"including padding bits, and then to set the I<read_exec_only> and "
"I<seg_not_present> bits.  On Linux 3.19, a I<user_desc> consisting entirely "
"of zeros except for I<entry_number> will also be interpreted as a request to "
"clear a TLS entry, but this behaved differently on older kernels."
msgstr ""
"В 64-битных ядрах до Linux 3.19, если был установлен один из битов "
"заполнения в I<user_desc>, то это приводило к тому, что дескриптор не "
"считался пустым (смотрите B<modify_ldt>(2)). В результате, единственным "
"надёжным способом очистить элемент TLS было задействование B<memset>(3) для "
"обнуления всей структуры I<user_desc>, включая биты заполнения, и затем "
"установка битов I<read_exec_only> и I<seg_not_present>. В Linux 3.19, "
"структура I<user_desc>, полностью состоящая из нулей кроме I<entry_number>, "
"также будет считаться запросом на очистку элемента TLS, что отличается от "
"работы старых ядер."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:226
msgid ""
"Prior to Linux 3.19, the DS and ES segment registers must not reference TLS "
"entries."
msgstr ""
"До Linux 3.19, сегментные регистры DS и ES не должны ссылаться на элементы "
"TLS."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:230
msgid ""
"B<arch_prctl>(2), B<modify_ldt>(2), B<ptrace>(2)  (B<PTRACE_GET_THREAD_AREA> "
"and B<PTRACE_SET_THREAD_AREA>)"
msgstr ""
"B<arch_prctl>(2), B<modify_ldt>(2), B<ptrace>(2)  (B<PTRACE_GET_THREAD_AREA> "
"and B<PTRACE_SET_THREAD_AREA>)"

#. type: TH
#: man-pages/man2/shutdown.2:40
#, no-wrap
msgid "SHUTDOWN"
msgstr "SHUTDOWN"

#. type: TH
#: man-pages/man2/shutdown.2:40
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man2/shutdown.2:43
msgid "shutdown - shut down part of a full-duplex connection"
msgstr "shutdown - закрывает часть полнодуплексного соединения"

#. type: Plain text
#: man-pages/man2/shutdown.2:47
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"

#. type: Plain text
#: man-pages/man2/shutdown.2:69
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>, "
"further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr ""
"Вызов B<shutdown>() приводит к закрытию всего полнодуплексного соединения "
"или его части в сокете, связанном с I<sockfd>. Если значение I<how> равно "
"B<SHUT_RD>, то дальнейший приём данных будет запрещён. Если значение I<how> "
"равно B<SHUT_WR>, то дальнейшая передача данных будет запрещена. Если "
"значение I<how> равно B<SHUT_RDWR>, то дальнейший приём и передача данных "
"будут запрещены."

#. type: Plain text
#: man-pages/man2/shutdown.2:74
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/shutdown.2:75
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/shutdown.2:79
msgid "I<sockfd> is not a valid file descriptor."
msgstr "Значение I<sockfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/shutdown.2:84
msgid "An invalid value was specified in I<how> (but see BUGS)."
msgstr "Указано неверное значение в I<how> (но смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man2/shutdown.2:84
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man2/shutdown.2:87
msgid "The specified socket is not connected."
msgstr "Указанный сокет не подключён."

#. type: TP
#: man-pages/man2/shutdown.2:87
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/shutdown.2:92
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr "Файловый дескриптор I<sockfd> указывает не на каталог."

#. type: Plain text
#: man-pages/man2/shutdown.2:96
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<shutdown>()  first appeared in 4.2BSD)."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD, (B<shutdown>() впервые появился в "
"4.2BSD)."

#. type: Plain text
#: man-pages/man2/shutdown.2:105
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr ""
"Константы B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> имеют значения 0, 1, 2, "
"соответственно, и определены в I<E<lt>sys/socket.hE<gt>> начиная с "
"glibc-2.1.91."

#.  https://bugzilla.kernel.org/show_bug.cgi?id=47111
#.  commit fc61b928dc4d72176cf4bd4d30bf1d22e599aefc
#.  and for DECnet sockets in commit 46b66d7077b89fb4917ceef19b3f7dd86055c94a
#. type: Plain text
#: man-pages/man2/shutdown.2:116
msgid ""
"Checks for the validity of I<how> are done in domain-specific code, and "
"before Linux 3.7 not all domains performed these checks.  Most notably, UNIX "
"domain sockets simply ignored invalid values.  This problem was fixed for "
"UNIX domain sockets in Linux 3.7."
msgstr ""
"Проверки применимости I<how> выполняются в коде, относящемся к домену, и до "
"Linux 3.7 проверки были не во всех доменах. В первую очередь, это были "
"доменные сокеты UNIX, которые просто игнорировали некорректные значения. "
"Данная проблема была устранена для доменных сокетов UNIX в Linux 3.7."

#. type: Plain text
#: man-pages/man2/shutdown.2:120
msgid "B<close>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr "B<close>(2), B<connect>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: man-pages/man2/shmctl.2:46
#, no-wrap
msgid "SHMCTL"
msgstr "SHMCTL"

#. type: Plain text
#: man-pages/man2/shmctl.2:49
msgid "shmctl - System V shared memory control"
msgstr "shmctl - управление общей памятью System V"

#. type: Plain text
#: man-pages/man2/shmctl.2:52
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr "B<#include E<lt>sys/ipc.hE<gt>>"

#. type: Plain text
#: man-pages/man2/shmctl.2:54
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr "B<#include E<lt>sys/shm.hE<gt>>"

#. type: Plain text
#: man-pages/man2/shmctl.2:56
msgid ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/shmctl.2:63
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the System"
"\\ V shared memory segment whose identifier is given in I<shmid>."
msgstr ""
"Вызов B<shmctl>() выполняет управляющую операцию, указанную в I<cmd>, над "
"общим сегментом памяти System\\ V, чей идентификатор задан в I<shmid>."

#. type: Plain text
#: man-pages/man2/shmctl.2:68
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""
"В аргументе I<buf> содержится указатель на структуру I<shmid_ds>, "
"определённую в I<E<lt>sys/shm.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/shmctl.2:82
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Last change time */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* владелец и права */\n"
"    size_t          shm_segsz;   /* размер сегмента (байты) */\n"
"    time_t          shm_atime;   /* время последнего подключения */\n"
"    time_t          shm_dtime;   /* время последнего отключения */\n"
"    time_t          shm_ctime;   /* время последнего изменения */\n"
"    pid_t           shm_cpid;    /* PID создателя */\n"
"    pid_t           shm_lpid;    /* PID последнего выполнявшего \n"
"                                    shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* текущее количество подключений */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: man-pages/man2/shmctl.2:90
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""
"Структура I<ipc_perm> определена следующим образом (значения полей "
"устанавливаются с помощью B<IPC_SET>):"

#. type: Plain text
#: man-pages/man2/shmctl.2:103
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key;    /* ключ, передаваемый в shmget(2) */\n"
"    uid_t          B<uid>;      /* эффективный UID владельца */\n"
"    gid_t          B<gid>;      /* эффективный GID владельца */\n"
"    uid_t          cuid;     /* эффективный UID создателя */\n"
"    gid_t          cgid;     /* эффективный GID создателя */\n"
"    unsigned short B<mode>;     /* B<права> + флаги SHM_DEST и\n"
"                                SHM_LOCKED */\n"
"    unsigned short __seq;    /* порядковый номер */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/shmctl.2:109
msgid "Valid values for I<cmd> are:"
msgstr "Возможные значения I<cmd>:"

#. type: Plain text
#: man-pages/man2/shmctl.2:118
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""
"Копирует информацию из структуры данных ядра, связанной с I<shmid>, в "
"структуру I<shsid_ds>, расположенную по адресу I<buf>. Вызывающий должен "
"иметь права на чтение общего сегмента памяти."

#. type: Plain text
#: man-pages/man2/shmctl.2:136
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member.  The following fields can be "
"changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant 9 bits "
"of) I<shm_perm.mode>.  The effective UID of the calling process must match "
"the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the shared "
"memory segment, or the caller must be privileged."
msgstr ""
"Записывает значения некоторых полей структуры I<shmid_ds>, указанной в "
"I<buf>, в структуру данных ядра, связанную с общим сегментом памяти, "
"обновляя при этом поле I<shm_ctime>. Могут измениться следующие поля: "
"I<shm_perm.uid>, I<shm_perm.gid> и I<shm_perm.mode> (младшие 9 битов). "
"Эффективный UID вызывающего процесса должен совпадать с UID владельца "
"(I<shm_perm.uid>) или создателя (I<shm_perm.cuid>) общего сегмента памяти, "
"или вызывающий должен иметь привилегии."

#. type: Plain text
#: man-pages/man2/shmctl.2:149
msgid ""
"Mark the segment to be destroyed.  The segment will actually be destroyed "
"only after the last process detaches it (i.e., when the I<shm_nattch> member "
"of the associated structure I<shmid_ds> is zero).  The caller must be the "
"owner or creator of the segment, or be privileged.  The I<buf> argument is "
"ignored."
msgstr ""
"Помечает сегмент как удалённый. Сегмент будет удалён только после того как "
"от него отключится последний процесс (т.е. когда поле I<shm_nattch> из "
"связанной структуры I<shmid_ds> станет равно нулю). Вызывающий должен быть "
"владельцем, создателем или иметь соответствующие привилегии. Аргумент I<buf> "
"игнорируется."

#. type: Plain text
#: man-pages/man2/shmctl.2:157
msgid ""
"If a segment has been marked for destruction, then the (nonstandard)  "
"B<SHM_DEST> flag of the I<shm_perm.mode> field in the associated data "
"structure retrieved by B<IPC_STAT> will be set."
msgstr ""
"Если сегмент помечен на удаление, то в поле I<shm_perm.mode> устанавливается "
"(нестандартный) флаг B<SHM_DEST> в связанной структуре данных, которая "
"возвращается при операции B<IPC_STAT>."

#. type: Plain text
#: man-pages/man2/shmctl.2:160
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""
"Вызывающий I<должен> удостовериться, что сегмент в конечном итоге удалён; "
"иначе ошибочные страницы останутся в памяти или в пространстве подкачки."

#. type: Plain text
#: man-pages/man2/shmctl.2:165
msgid ""
"See also the description of I</proc/sys/kernel/shm_rmid_forced> in "
"B<proc>(5)."
msgstr ""
"Смотрите также описание I</proc/sys/kernel/shm_rmid_forced> в B<proc>(5)."

#. type: TP
#: man-pages/man2/shmctl.2:165
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:178
msgid ""
"Return information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"Возвращает параметры и информацию о системных максимальных значениях общей "
"памяти в структуре, указанной в I<buf>. Данная структура имеет тип "
"I<shminfo> (то есть, требуется приведение типов) и определена в I<E<lt>sys/"
"shm.hE<gt>>, если определён макрос тестирования свойств B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/shmctl.2:192
#, no-wrap
msgid ""
"struct shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""
"struct shminfo {\n"
"    unsigned long shmmax; /* максимальный размер\n"
"                             сегмента */\n"
"    unsigned long shmmin; /* минимальный размер сегмента;\n"
"                             всегда 1 */\n"
"    unsigned long shmmni; /* максимальное количество\n"
"                             сегментов */\n"
"    unsigned long shmseg; /* максимальное количество\n"
"                             сегментов, к которому может\n"
"                             подключиться; процесс\n"
"                             не используется в ядре */\n"
"    unsigned long shmall; /* макс. количество страниц\n"
"                             общей памяти в системе */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/shmctl.2:205
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""
"Значения I<shmmni>, I<shmmax> и I<shmall> можно изменить с помощью файлов в "
"I</proc> с теми же именами; подробней см. B<proc>(5)."

#. type: TP
#: man-pages/man2/shmctl.2:205
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr "B<SHM_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:216
msgid ""
"Return a I<shm_info> structure whose fields contain information about system "
"resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"Возвращает структуру I<shm_info>, чьи поля содержат информацию о системных "
"ресурсах, использованных общей памятью. Эта структура определена в "
"I<E<lt>sys/shm.hE<gt>>, если определён макрос тестирования свойств "
"B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/shmctl.2:233
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""
"struct shm_info {\n"
"    int           used_ids; /* количество используемых в\n"
"                               данный момент сегментов */\n"
"    unsigned long shm_tot;  /* общее количество общих\n"
"                               страниц памяти */\n"
"    unsigned long shm_rss;  /* количество общих страниц, \n"
"                               находящихся в памяти */\n"
"    unsigned long shm_swp;  /* количество страниц памяти в \n"
"                               пространстве подкачки */\n"
"    unsigned long swap_attempts; /* не используется,\n"
"                                    начиная с Linux 2.4 */\n"
"    unsigned long swap_successes; /* не используется,\n"
"                                     начиная с Linux 2.4 */\n"
"};\n"

#. type: TP
#: man-pages/man2/shmctl.2:235
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr "B<SHM_STAT> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:246
msgid ""
"Return a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""
"Возвращает структуру I<shmid_ds> как в операции B<IPC_STAT>. Однако аргумент "
"I<shmid> является не идентификатором сегмента, а индексом во внутреннем "
"массиве ядра, в котором содержится информации о всех общих сегментов памяти "
"в системе."

#. type: TP
#: man-pages/man2/shmctl.2:246
#, no-wrap
msgid "B<SHM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr "B<SHM_STAT_ANY> (есть только в Linux, начиная с Linux 4.17)"

#. type: Plain text
#: man-pages/man2/shmctl.2:259
msgid ""
"Return a I<shmid_ds> structure as for B<SHM_STAT>.  However, I<shm_perm."
"mode> is not checked for read access for I<shmid>, meaning that any user can "
"employ this operation (just as any user may read I</proc/sysvipc/shm> to "
"obtain the same information)."
msgstr ""
"Возвращает структуру I<shmid_ds> как для B<SHM_STAT>. Однако I<shm_perm."
"mode> не проверяется на доступность чтения для I<shmid>, что означает, что "
"эту операцию может выполнять пользователь (как и любой пользователь, который "
"может прочитать эту же информацию из I</proc/sysvipc/shm>)."

#. type: Plain text
#: man-pages/man2/shmctl.2:262
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""
"Вызывающий может запретить или разрешить размещение общего сегмента памяти в "
"пространство подкачки с помощью следующих значений I<cmd>:"

#. type: TP
#: man-pages/man2/shmctl.2:262
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr "B<SHM_LOCK> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:274
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""
"Запрещает подкачку общего сегмента памяти. После включения блокировки "
"вызывающий должен считать сбойными все страницы, наличие которых требуется. "
"Если сегмент заблокирован, то в поле I<shm_perm.mode> устанавливается "
"(нестандартный) флаг B<SHM_LOCKED> в связанной структуре, которая "
"возвращается при операции B<IPC_STAT>."

#. type: TP
#: man-pages/man2/shmctl.2:274
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr "B<SHM_UNLOCK> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:277
msgid "Unlock the segment, allowing it to be swapped out."
msgstr "Разблокирует сегмент, разрешая выполнение подкачки."

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: man-pages/man2/shmctl.2:295
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""
"В ядрах до версии 2.6.10 только привилегированный процесс мог использовать "
"B<SHM_LOCK> и B<SHM_UNLOCK>. Начиная с ядра версии 2.6.10 "
"непривилегированный процесс может использовать эти операции, если его "
"эффективный UID совпадает с UID владельца или создателя сегмента и (для "
"B<SHM_LOCK>) количество блокируемой памяти находится в пределах ресурса "
"B<RLIMIT_MEMLOCK> (см. B<setrlimit>(2))."

#. type: Plain text
#: man-pages/man2/shmctl.2:315
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> or B<SHM_STAT_ANY> operations to obtain information "
"about all shared memory segments on the system.)  A successful B<SHM_STAT> "
"operation returns the identifier of the shared memory segment whose index "
"was given in I<shmid>.  Other operations return 0 on success."
msgstr ""
"При успешном выполнении операции B<IPC_INFO> или B<SHM_INFO> возвращается "
"индекс самого последнего использованного элемента внутреннего массива ядра, "
"в котором записывается информация о всех общих сегментах памяти (эта "
"информация может быть использована в повторяющихся операциях B<SHM_STAT> или "
"B<SHM_STAT_ANY> для получения информации о всех общих сегментах памяти "
"системы). При успешном выполнении операции B<SHM_STAT> возвращается "
"идентификатор общего сегмента памяти, чей индекс был указан в I<shmid>. При "
"успешном выполнении других операций возвращается 0."

#. type: Plain text
#: man-pages/man2/shmctl.2:319
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"В случае ошибки возвращается -1 и значение I<errno> устанавливается "
"соответствующим образом."

#. type: Plain text
#: man-pages/man2/shmctl.2:328
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability in the user namespace that governs its IPC "
"namespace."
msgstr ""
"Указана операция B<IPC_STAT> или B<SHM_STAT>, но в I<shm_perm.mode> не "
"установлено право на чтение I<shmid>, и вызывающий процесс не имеет мандата "
"B<CAP_IPC_OWNER> в пространстве имён пользователя, который управляет его "
"пространством имён IPC."

#. type: Plain text
#: man-pages/man2/shmctl.2:339
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""
"Значение аргумента I<cmd> равно B<IPC_SET> или B<IPC_STAT>, но адрес, "
"указанный в I<buf>, недоступен."

#. type: TP
#: man-pages/man2/shmctl.2:339
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: man-pages/man2/shmctl.2:342
msgid "I<shmid> points to a removed identifier."
msgstr "Значение I<shmid> указывает на удалённый идентификатор."

#. type: Plain text
#: man-pages/man2/shmctl.2:353
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> or B<SHM_STAT_ANY> operation, the index value specified in "
"I<shmid> referred to an array slot that is currently unused."
msgstr ""
"Значение I<shmid> содержит недопустимый идентификатор, или I<cmd> содержит "
"недопустимую команду. Или (для B<SHM_STAT> или B<SHM_STAT_ANY>) индекс "
"I<shmid> ссылается на элемент массива, который в данный момент не "
"используется."

#. type: Plain text
#: man-pages/man2/shmctl.2:364
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the to-"
"be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""
"(в ядрах, начиная с 2.6.9) Указана операция B<SHM_LOCK> и размер "
"блокируемого сегмента таков, что общее количество байт, блокируемое общими "
"сегментами памяти, превысило бы ограничение, установленное для "
"действительного идентификатора пользователя вызывающего процесса. Этот лимит "
"определён мягким ограничителем ресурса B<RLIMIT_MEMLOCK> (см. "
"B<setrlimit>(2))."

#. type: Plain text
#: man-pages/man2/shmctl.2:369
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""
"Попытка выполнить B<IPC_STAT>, но значения GID или UID слишком велики для "
"помещения в структуру, на которую указывает I<buf>."

#. type: TP
#: man-pages/man2/shmctl.2:369
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/shmctl.2:381
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""
"Попытка выполнить B<IPC_SET> или B<IPC_RMID>, но эффективный "
"пользовательский идентификатор вызывающего процесса не равен идентификатору "
"создателя (I<shm_perm.cuid>) или владельца (I<shm_perm.uid>) и процесс не "
"привилегированный (Linux: не имеет мандата B<CAP_SYS_ADMIN>)."

#. type: Plain text
#: man-pages/man2/shmctl.2:393
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""
"Или (в ядрах до 2.6.9) процесс не имеет привилегий (Linux: не имеет мандата "
"B<CAP_IPC_LOCK>) для выполнения B<SHM_LOCK> или B<SHM_UNLOCK>. Начиная с "
"Linux 2.6.9 эта ошибка также возникает, если значение B<RLIMIT_MEMLOCK> "
"равно 0 и вызывающий не имеет привилегий."

#.  SVr4 documents additional error conditions EINVAL,
#.  ENOENT, ENOSPC, ENOMEM, EEXIST.  Neither SVr4 nor SVID documents
#.  an EIDRM error condition.
#. type: Plain text
#: man-pages/man2/shmctl.2:398
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: man-pages/man2/shmctl.2:411
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""
"Включение файлов I<E<lt>sys/types.hE<gt>> и I<E<lt>sys/ipc.hE<gt>> не "
"требуется в Linux или любых версий POSIX. Однако, некоторые старые "
"реализации требуют включения данных заголовочных файлов, и это также "
"требуется по SVID. В приложениях, которые нужно перенести на такие старые "
"системы, может потребоваться включить данных заголовочные файлы."

#. type: Plain text
#: man-pages/man2/shmctl.2:423
msgid ""
"The B<IPC_INFO>, B<SHM_STAT> and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future, these may modified or moved to a I</proc> filesystem interface."
msgstr ""
"Операции B<IPC_INFO>, B<SHM_STAT> и B<SHM_INFO> используются программой "
"B<ipcs>(1) для получения информации о выделенных ресурсах. В будущем для "
"этого может быть задействован интерфейс файловой системы I</proc>."

#. type: Plain text
#: man-pages/man2/shmctl.2:431
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""
"Linux разрешает процессу подключаться (B<shmat>(2)) к общему сегменту "
"память, который уже помечен как удалённый с помощью I<shmctl(IPC_RMID)>. Это "
"свойство недоступно в других реализациях UNIX; в переносимых приложениях "
"лучше не использовать это свойство."

#. type: Plain text
#: man-pages/man2/shmctl.2:444
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"В Linux 2.2 различные поля I<struct shmid_ds> имели тип I<short>. В Linux "
"2.4 тип был изменён на I<long>. Для задействования преимуществ этого "
"изменения необходима перекомпиляция программы с glibc-2.1.91 или более "
"поздней версией (ядро различает старые и новые вызовы по флагу B<IPC_64> в "
"аргументе I<cmd>)."

#. type: Plain text
#: man-pages/man2/shmctl.2:450
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_setscheduler.2:26
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr "SCHED_SETSCHEDULER"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:30
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling policy/"
"parameters"
msgstr ""
"sched_setscheduler, sched_getscheduler - устанавливает или получает алгоритм "
"планирования (и его параметры)"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:33
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr "B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:36
#, no-wrap
msgid ""
"B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
"B<                       const struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
"B<                       const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:38
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:47
msgid ""
"The B<sched_setscheduler>()  system call sets both the scheduling policy and "
"parameters for the thread whose ID is specified in I<pid>.  If I<pid> equals "
"zero, the scheduling policy and parameters of the calling thread will be set."
msgstr ""
"Вызов B<sched_setscheduler>() задаёт алгоритм и параметры планирования "
"выполнения нити с идентификатором I<pid>. Если I<pid> равен нулю, то будет "
"изменён алгоритм и параметры планирования вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:51
msgid ""
"The scheduling parameters are specified in the I<param> argument, which is a "
"pointer to a structure of the following form:"
msgstr ""
"Параметры планирования указываются в аргументе I<param>, который является "
"указателем на следующую структуру:"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:59
#, no-wrap
msgid ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"
msgstr ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:67
msgid ""
"In the current implementation, the structure contains only one field, "
"I<sched_priority>.  The interpretation of I<param> depends on the selected "
"policy."
msgstr ""
"В текущей реализации структура содержит только одно поле — "
"I<sched_priority>. Интерпретация I<param> зависит от выбранного алгоритма."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:71
msgid ""
"Currently, Linux supports the following \"normal\" (i.e., non-real-time) "
"scheduling policies as values that may be specified in I<policy>:"
msgstr ""
"В настоящее время в Linux поддерживаются следующие «обычные» (т. е. не "
"реального времени) алгоритмы планирования, которые можно указать в I<policy>:"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:71
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr "B<SCHED_OTHER>"

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:76
msgid "the standard round-robin time-sharing policy;"
msgstr "алгоритм циклического обслуживания с разделением времени;"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:76
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr "B<SCHED_BATCH>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:79
msgid "for \"batch\" style execution of processes; and"
msgstr "«пакетный» стиль выполнения процессов;"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:79
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr "B<SCHED_IDLE>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:84
msgid "for running I<very> low priority background jobs."
msgstr "для выполнения фоновых заданий с I<очень> низким приоритетом."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:88
msgid "For each of the above policies, I<param-E<gt>sched_priority> must be 0."
msgstr ""
"Для каждого алгоритма, перечисленного выше, значение I<param-"
"E<gt>sched_priority> должно быть равно 0."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:97
msgid ""
"Various \"real-time\" policies are also supported, for special time-critical "
"applications that need precise control over the way in which runnable "
"threads are selected for execution.  For the rules governing when a process "
"may use these policies, see B<sched>(7).  The real-time policies that may be "
"specified in I<policy> are:"
msgstr ""
"Также поддерживаются различные алгоритмы «реального времени», для "
"специальных, критичных ко времени приложений, которым требуется точное "
"управление методом выбора приложением исполняемых нитей. Правила управления, "
"когда процесс может использовать эти алгоритмы, смотрите в B<sched>(7). "
"Алгоритмы реального времени, которые могут быть указаны в I<policy>:"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:97
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr "B<SCHED_FIFO>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:100
msgid "a first-in, first-out policy; and"
msgstr "алгоритм «первым вошёл — первым вышел»;"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:100
#, no-wrap
msgid "B<SCHED_RR>"
msgstr "B<SCHED_RR>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:103
msgid "a round-robin policy."
msgstr "алгоритм циклического обслуживания."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:114
msgid ""
"For each of the above policies, I<param-E<gt>sched_priority> specifies a "
"scheduling priority for the thread.  This is a number in the range returned "
"by calling B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2)  "
"with the specified I<policy>.  On Linux, these system calls return, "
"respectively, 1 and 99."
msgstr ""
"Для каждого перечисленного выше алгоритма в I<param-E<gt>sched_priority> "
"задаётся приоритет планирования для нити. Это число в диапазоне, "
"возвращаемом вызовами B<sched_get_priority_min>(2) и "
"B<sched_get_priority_max>(2) с указанным I<policy>. В Linux эти системные "
"вызовы возвращают 1 и 99, соответственно."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:127
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""
"Начиная с Linux 2.6.32, флаг B<SCHED_RESET_ON_FORK> может быть добавлен (OR) "
"в I<policy> при вызове B<sched_setscheduler>(). В результате включения этого "
"флага потомок, созданный B<fork>(2), не наследует алгоритмы "
"привилегированные алгоритмы планирования. Подробней смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:133
msgid ""
"B<sched_getscheduler>()  returns the current scheduling policy of the thread "
"identified by I<pid>.  If I<pid> equals zero, the policy of the calling "
"thread will be retrieved."
msgstr ""
"Вызов B<sched_getscheduler>() возвращает текущий алгоритм планирования нити "
"с идентификатором I<pid>. Если значение I<pid> равно нулю, то будет выдан "
"алгоритм вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:143
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the thread (a nonnegative "
"integer).  On error, both calls return -1, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sched_setscheduler>()  возвращается ноль. При "
"успешном выполнении B<sched_getscheduler>()  возвращается алгоритм нити "
"(неотрицательное целое). При ошибках оба вызова возвращают -1, а переменной "
"I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:151
msgid "Invalid arguments: I<pid> is negative or I<param> is NULL."
msgstr ""
"Некорректные аргументы: значение I<pid> отрицательно или I<param> равно NULL."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:156
msgid ""
"(B<sched_setscheduler>())  I<policy> is not one of the recognized policies."
msgstr ""
"(B<sched_setscheduler>()) Значение I<policy> не равно одному из известных "
"значений алгоритмов."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:162
msgid ""
"(B<sched_setscheduler>())  I<param> does not make sense for the specified "
"I<policy>."
msgstr ""
"(B<sched_setscheduler>()) Значение I<param> не имеет смысла для заданного "
"I<policy>."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:165
msgid "The calling thread does not have appropriate privileges."
msgstr "Вызывающая нить не имеет достаточно привилегий."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:168
msgid "The thread whose ID is I<pid> could not be found."
msgstr "Нить с идентификатором I<pid> не найдена."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008 (but see BUGS below).  The B<SCHED_BATCH> and "
"B<SCHED_IDLE> policies are Linux-specific."
msgstr ""
"POSIX.1-2001, POSIX.1-2008 (но смотрите ДЕФЕКТЫ далее). Алгоритмы "
"B<SCHED_BATCH> и B<SCHED_IDLE> есть только в Linux."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:180
msgid ""
"Further details of the semantics of all of the above \"normal\" and \"real-"
"time\" scheduling policies can be found in the B<sched>(7)  manual page.  "
"That page also describes an additional policy, B<SCHED_DEADLINE>, which is "
"settable only via B<sched_setattr>(2)."
msgstr ""
"Подробное описание семантики всех алгоритмов планирования («обычных» и "
"«реального времени») можно найти в справочной странице B<sched>(7). В этой "
"странице также описывается дополнительный алгоритм, B<SCHED_DEADLINE>, "
"который доступен только через вызов B<sched_setattr>(2)."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:188
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"В системах POSIX, в которых доступны B<sched_setscheduler>() и "
"B<sched_getscheduler>(), в I<E<lt>unistd.hE<gt>> определён макрос "
"B<_POSIX_PRIORITY_SCHEDULING>."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:196
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged thread requires "
"in order to call B<sched_setscheduler>(), and details vary across systems.  "
"For example, the Solaris 7 manual page says that the real or effective user "
"ID of the caller must match the real user ID or the save set-user-ID of the "
"target."
msgstr ""
"В POSIX.1 не описаны права, которые требуются привилегированной нити для "
"вызова B<sched_setscheduler>(), и в разных системах используются разные "
"права. Например, в справочной странице Solaris 7 сказано, что реальный и "
"эффективный пользовательский идентификатор вызывающего должен совпадать с "
"реальным пользовательским идентификатором или сохранённым set-user-ID "
"изменяемой нити."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:217
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the "
"argument I<pid>.  Specifying I<pid> as 0 will operate on the attributes of "
"the calling thread, and passing the value returned from a call to "
"B<getpid>(2)  will operate on the attributes of the main thread of the "
"thread group.  (If you are using the POSIX threads API, then use "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3), instead of the B<sched_*>(2)  system calls.)"
msgstr ""
"Алгоритм планирования и параметры, фактически, являются атрибутами нить в "
"Linux. Значение, возвращаемое из вызова B<gettid>(2), можно передавать в "
"аргументе I<pid>. При указании в I<pid> значения 0 операции будут "
"выполняться на атрибутах вызывающей нити, а при передаче значения, "
"полученном из вызова B<getpid>(2), операции будут выполнятся на атрибутах "
"главной нити группы нитей (если вы используете интерфейс нитей POSIX, то "
"используйте B<pthread_setschedparam>(3), B<pthread_getschedparam>(3) и "
"B<pthread_setschedprio>(3) вместо системных вызовов B<sched_*>(2))."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:225
msgid ""
"POSIX.1 says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""
"В POSIX.1 указано, что при успешном выполнении B<sched_setscheduler>() "
"должно возвращаться предыдущее значение алгоритма планирования. В Linux "
"вызов B<sched_setscheduler>() не выполняет это требование, так как при "
"успешном выполнении всегда возвращает 0."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:244
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), "
"B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), "
"B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/semget.2:36
#, no-wrap
msgid "SEMGET"
msgstr "SEMGET"

#. type: Plain text
#: man-pages/man2/semget.2:39
msgid "semget - get a System V semaphore set identifier"
msgstr "semget - считывает идентификатор набора семафоров System V"

#. type: Plain text
#: man-pages/man2/semget.2:44
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/semget.2:49
msgid ""
"B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"
msgstr ""
"B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"

#. type: Plain text
#: man-pages/man2/semget.2:63
msgid ""
"The B<semget>()  system call returns the System\\ V semaphore set identifier "
"associated with the argument I<key>.  It may be used either to obtain the "
"identifier of a previously created semaphore set (when I<semflg> is zero and "
"I<key> does not have the value B<IPC_PRIVATE>), or to create a new set."
msgstr ""
"Системный вызов B<semget>() возвращает идентификатор набора семафоров System"
"\\ V, связанный со значением аргумента I<key>. Его можно использовать для "
"получения идентификатора уже созданного набора семафоров (если I<semflg> "
"равно нулю и значение I<key> не равно B<IPC_PRIVATE>) или для создания "
"нового."

#. type: Plain text
#: man-pages/man2/semget.2:76
msgid ""
"A new set of I<nsems> semaphores is created if I<key> has the value "
"B<IPC_PRIVATE> or if no existing semaphore set is associated with I<key> and "
"B<IPC_CREAT> is specified in I<semflg>."
msgstr ""
"Новый набор семафоров I<nsems> создаётся, если значение I<key> равно "
"B<IPC_PRIVATE> или с ключом I<key> не связано ни одного существующего набора "
"семафоров, а в I<semflg> задано B<IPC_CREAT>."

#. type: Plain text
#: man-pages/man2/semget.2:95
msgid ""
"If I<semflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a semaphore set "
"already exists for I<key>, then B<semget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""
"Если в I<semflg> одновременно указаны B<IPC_CREAT> и B<IPC_EXCL> и набор "
"семафоров для I<key> уже существует, то B<semget>() завершается с ошибкой и "
"I<errno> присваивается значение B<EEXIST> (такой же результат как с "
"B<O_CREAT | O_EXCL> у B<open>(2))."

#. type: Plain text
#: man-pages/man2/semget.2:108
msgid ""
"Upon creation, the least significant 9 bits of the argument I<semflg> define "
"the permissions (for owner, group and others)  for the semaphore set.  These "
"bits have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2)  (though the execute permissions are not meaningful for "
"semaphores, and write permissions mean permission to alter semaphore values)."
msgstr ""
"При создании в 9 начальных битах аргумента I<semflg> указываются права "
"(владелец, группа и др.) на набор семафоров. Формат значения битов совпадает "
"с аргументом I<mode> вызова B<open>(2) (но права на выполнение для семафоров "
"ничего не означают, а права на запись означают право изменять значения "
"семафоров)."

#. type: Plain text
#: man-pages/man2/semget.2:116
msgid ""
"When creating a new semaphore set, B<semget>()  initializes the set's "
"associated data structure, I<semid_ds> (see B<semctl>(2)), as follows:"
msgstr ""
"При создании нового набора семафоров B<semget>() инициализирует связанную с "
"семафором структуру данных I<semid_ds> (см. B<semctl>(2)) следующим образом: "

#. type: Plain text
#: man-pages/man2/semget.2:121
msgid ""
"I<sem_perm.cuid> and I<sem_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"Полям I<sem_perm.cuid> и I<sem_perm.uid> присваиваются значения эффективного "
"идентификатора пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/semget.2:126
msgid ""
"I<sem_perm.cgid> and I<sem_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"Полям I<sem_perm.cgid> и I<sem_perm.gid> присваиваются значения эффективного "
"идентификатора группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/semget.2:131
msgid ""
"The least significant 9 bits of I<sem_perm.mode> are set to the least "
"significant 9 bits of I<semflg>."
msgstr ""
"Младшим 9 битам I<sem_perm.mode> присваивается значение младших 9 бит "
"I<semflg>."

#. type: Plain text
#: man-pages/man2/semget.2:135
msgid "I<sem_nsems> is set to the value of I<nsems>."
msgstr "Полю I<sem_nsems> присваивается значение I<nsems>."

#. type: Plain text
#: man-pages/man2/semget.2:138
msgid "I<sem_otime> is set to 0."
msgstr "Полю I<sem_otime> присваивается значение 0."

#. type: Plain text
#: man-pages/man2/semget.2:141
msgid "I<sem_ctime> is set to the current time."
msgstr "Полю I<sem_ctime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/semget.2:152
msgid ""
"The argument I<nsems> can be 0 (a don't care)  when a semaphore set is not "
"being created.  Otherwise, I<nsems> must be greater than 0 and less than or "
"equal to the maximum number of semaphores per semaphore set (B<SEMMSL>)."
msgstr ""
"Если набор семафоров не создаётся, то аргумент I<nsems> может быть равен 0 "
"(не учитывать). Иначе аргумент I<nsems> должен быть больше 0 и меньше или "
"равен максимальному количеству семафоров в наборе (B<SEMMSL>)."

#.  and a check is made to see if it is marked for destruction.
#. type: Plain text
#: man-pages/man2/semget.2:156
msgid "If the semaphore set already exists, the permissions are verified."
msgstr "Если набор семафоров уже существует, то проверяются права доступа."

#. type: Plain text
#: man-pages/man2/semget.2:162
msgid ""
"If successful, the return value will be the semaphore set identifier (a "
"nonnegative integer), otherwise, -1 is returned, with I<errno> indicating "
"the error."
msgstr ""
"При успешном выполнении возвращается идентификатор набора семафоров "
"(неотрицательное целое), иначе возвращается -1, а переменной I<errno> "
"присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/semget.2:166
msgid "On failure, I<errno> will be set to one of the following:"
msgstr "При ошибке I<errno> присваиваются следующие значения:"

#. type: Plain text
#: man-pages/man2/semget.2:174
msgid ""
"A semaphore set exists for I<key>, but the calling process does not have "
"permission to access the set, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"Набор семафоров для ключа I<key> существует, но вызывающий процесс не имеет "
"прав доступа к нему и не имеет мандата B<CAP_IPC_OWNER> в пространстве имён "
"пользователя, который управляет его пространством имён IPC."

#. type: TP
#: man-pages/man2/semget.2:174
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#.  .TP
#.  .B EIDRM
#.  The semaphore set is marked to be deleted.
#. type: Plain text
#: man-pages/man2/semget.2:186
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<semflg>, but a semaphore "
"set already exists for I<key>."
msgstr ""
"В I<semflg> указаны B<IPC_CREAT> и B<IPC_EXCL>, но набор семафоров уже "
"существует для I<key>."

#. type: Plain text
#: man-pages/man2/semget.2:192
msgid ""
"I<nsems> is less than 0 or greater than the limit on the number of "
"semaphores per semaphore set (B<SEMMSL>)."
msgstr ""
"Значение I<nsems> меньше 0 или больше максимально возможного для набора "
"количества семафоров (B<SEMMSL>)."

#. type: Plain text
#: man-pages/man2/semget.2:199
msgid ""
"A semaphore set corresponding to I<key> already exists, but I<nsems> is "
"larger than the number of semaphores in that set."
msgstr ""
"Набор семафоров, соответствующий I<key>, уже существует, но I<nsems> больше, "
"чем количество семафоров в этом наборе."

#. type: TP
#: man-pages/man2/semget.2:199
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/semget.2:207
msgid ""
"No semaphore set exists for I<key> and I<semflg> did not specify "
"B<IPC_CREAT>."
msgstr ""
"Для ключа I<key> не существует набора семафоров и в I<semflg> нет флага "
"B<IPC_CREAT>."

#. type: Plain text
#: man-pages/man2/semget.2:211
msgid ""
"A semaphore set has to be created but the system does not have enough memory "
"for the new data structure."
msgstr ""
"Набор семафоров должен быть создан, но в системе не хватает памяти для "
"хранения новой структуры данных."

#. type: Plain text
#: man-pages/man2/semget.2:219
msgid ""
"A semaphore set has to be created but the system limit for the maximum "
"number of semaphore sets (B<SEMMNI>), or the system wide maximum number of "
"semaphores (B<SEMMNS>), would be exceeded."
msgstr ""
"Набор семафоров должен быть создан, но при этом будет превышен системный "
"лимит на количество наборов семафоров (B<SEMMNI>) или системный лимит на "
"количество семафоров (B<SEMMNS>)."

#.  SVr4 documents additional error conditions EFBIG, E2BIG, EAGAIN,
#.  ERANGE, EFAULT.
#. type: Plain text
#: man-pages/man2/semget.2:223
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/semget.2:247
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<semflg> and creates a new semaphore set (on success)."
msgstr ""
"Значение B<IPC_PRIVATE> не поле флага, а тип I<key_t>. Если I<key> равно "
"этому специальному значению, то системный вызов игнорирует всё кроме 9-ти "
"младших битов I<semflg> и создаёт новый набор семафоров (при успешном "
"выполнении)."

#. type: SS
#: man-pages/man2/semget.2:247
#, no-wrap
msgid "Semaphore initialization"
msgstr "Инициализация семафоров"

#.  In truth, every one of the many implementations that I've tested sets
#.  the values to zero, but I suppose there is/was some obscure
#.  implementation out there that does not.
#. type: Plain text
#: man-pages/man2/semget.2:259
msgid ""
"The values of the semaphores in a newly created set are indeterminate.  "
"(POSIX.1-2001 and POSIX.1-2008 are explicit on this point, although "
"POSIX.1-2008 notes that a future version of the standard may require an "
"implementation to initialize the semaphores to 0.)  Although Linux, like "
"many other implementations, initializes the semaphore values to 0, a "
"portable application cannot rely on this: it should explicitly initialize "
"the semaphores to the desired values."
msgstr ""
"Значения только что созданных семафоров не определены (в POSIX.1-2001 и "
"POSIX.1-2008 это указано явно, хотя в POSIX.1-2008 сказано, что в будущих "
"версиях стандарта от реализации может потребоваться инициализировать "
"семафоры 0). Хотя Linux, подобно многим другим реализациям, инициализирует "
"семафоры значением 0, переносимое приложение не может полагаться на это: оно "
"должно явно инициализировать семафоры нужным значением."

#. type: Plain text
#: man-pages/man2/semget.2:274
msgid ""
"Initialization can be done using B<semctl>(2)  B<SETVAL> or B<SETALL> "
"operation.  Where multiple peers do not know who will be the first to "
"initialize the set, checking for a nonzero I<sem_otime> in the associated "
"data structure retrieved by a B<semctl>(2)  B<IPC_STAT> operation can be "
"used to avoid races."
msgstr ""
"Инициализацию можно выполнять с помощью B<semctl>(2) с операцией B<SETVAL> "
"или B<SETALL>. При наличии нескольких абонентов неизвестно, кто первый "
"выполнит инициализацию, и чтобы избежать состязательности нужно проверять "
"I<sem_otime> на ненулевое значение в связанной структуре данных, получаемой "
"с помощью B<semctl>(2) и операции B<IPC_STAT>."

#. type: SS
#: man-pages/man2/semget.2:274
#, no-wrap
msgid "Semaphore limits"
msgstr "Ограничения семафоров"

#. type: Plain text
#: man-pages/man2/semget.2:278
msgid ""
"The following limits on semaphore set resources affect the B<semget>()  call:"
msgstr ""
"Ниже приведены ограничения на ресурсы набора семафоров, оказывающие влияние "
"на вызов B<semget>():"

#. type: TP
#: man-pages/man2/semget.2:278
#, no-wrap
msgid "B<SEMMNI>"
msgstr "B<SEMMNI>"

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/semget.2:289
msgid ""
"System-wide limit on the number of semaphore sets.  On Linux systems before "
"version 3.19, the default value for this limit was 128.  Since Linux 3.19, "
"the default value is 32,000.  On Linux, this limit can be read and modified "
"via the fourth field of I</proc/sys/kernel/sem>."
msgstr ""
"Ограничение на максимальное количество наборов семафоров. В системах Linux "
"до версии 3.19, значением по умолчанию этого ограничения было 128. Начиная с "
"Linux 3.19, значение по умолчанию равно 32000. В Linux это ограничение можно "
"получать и изменять через четвёртое поле I</proc/sys/kernel/sem>)."

#. type: TP
#: man-pages/man2/semget.2:289
#, no-wrap
msgid "B<SEMMSL>"
msgstr "B<SEMMSL>"

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#. type: Plain text
#: man-pages/man2/semget.2:299
msgid ""
"Maximum number of semaphores per semaphore ID.  On Linux systems before "
"version 3.19, the default value for this limit was 250.  Since Linux 3.19, "
"the default value is 32,000.  On Linux, this limit can be read and modified "
"via the first field of I</proc/sys/kernel/sem>."
msgstr ""
"Максимальное количество семафоров на один ID семафора. В системах Linux до "
"версии 3.19, значением по умолчанию этого ограничения было 250. Начиная с "
"Linux 3.19, значение по умолчанию равно 32000. В Linux это ограничение можно "
"получать и изменять через первое поле I</proc/sys/kernel/sem>)."

#. type: TP
#: man-pages/man2/semget.2:299
#, no-wrap
msgid "B<SEMMNS>"
msgstr "B<SEMMNS>"

#. type: Plain text
#: man-pages/man2/semget.2:309
msgid ""
"System-wide limit on the number of semaphores: policy dependent (on Linux, "
"this limit can be read and modified via the second field of I</proc/sys/"
"kernel/sem>).  Note that the number of semaphores system-wide is also "
"limited by the product of B<SEMMSL> and B<SEMMNI>."
msgstr ""
"Ограничение на максимальное количество семафоров в системе: зависит от "
"политики (в Linux это ограничение можно получать и изменять через второе "
"поле I</proc/sys/kernel/sem>). Заметим, что количество семафоров в системе "
"также ограничено произведением B<SEMMSL> и B<SEMMNI>."

#. type: Plain text
#: man-pages/man2/semget.2:315
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""
"Имя B<IPC_PRIVATE>, возможно, было выбрано неудачно, B<IPC_NEW> отражает "
"смысл действия более ясно."

#. type: Plain text
#: man-pages/man2/semget.2:321
msgid ""
"B<semctl>(2), B<semop>(2), B<ftok>(3), B<capabilities>(7), "
"B<sem_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr "SENDMMSG"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr "sendmmsg - отправляет несколько сообщений в сокет"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<);>\n"
msgstr ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<);>\n"

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: man-pages/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""
"Системный вызов B<sendmmsg>() является расширенной версией B<sendmsg>(2), "
"позволяя вызывающему передавать несколько сообщений из сокета, используя "
"только один системный вызов (в некоторых приложениях это позволяет получить "
"выигрыш в производительности)."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""
"Аргумент I<sockfd> представляет собой файловый дескриптор сокета для "
"отправки данных."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""
"Аргумент I<msgvec> является указателем на массив структур I<mmsghdr>. Размер "
"этого массива указывается в I<vlen>."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""
"Структура I<mmsghdr> определена в I<E<lt>sys/socket.hE<gt>> следующим "
"образом:"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* заголовок сообщения */\n"
"    unsigned int  msg_len;  /* кол-во переданных байт */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from "
"a single B<sendmsg>(2)  call)."
msgstr ""
"Поле I<msg_hdr> представляет собой структуру I<msghdr>, которая описана в "
"B<sendmsg>(2). Поле I<msg_len> используется для возврата количества байт, "
"посланных из сообщения в I<msg_hdr> (т. е., такое же значение, что и "
"возвращаемое значение одиночного вызова B<sendmsg>(2))."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""
"Аргумент I<flags> содержит объединённые с помощью OR флаги. Флаги те же, что "
"и у B<sendmsg>(2)."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""
"Блокирование вызова B<sendmmsg>() происходит до тех пор, пока не будет "
"отправлено I<vlen> сообщений. Неблокирующий вызов посылает столько сообщений "
"сколько возможно (максимальное количество указано в I<vlen>) и сразу "
"завершает работу."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""
"При возврате из B<sendmmsg>(), поля I<msg_len> последующих элементов "
"I<msgvec> обновляются и содержат количество байт, переданных из "
"соответствующего I<msg_hdr>. Возвращаемое вызовом значение равно количеству "
"элементов I<msgvec>, которые были обновлены."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""
"При успешном выполнении B<sendmmsg>() возвращает количество сообщений, "
"посланных из I<msgvec>; если это значение меньше чем I<vlen>, то вызывающий "
"может повторить вызов B<sendmmsg>() для отправки оставшихся сообщений."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"В случае ошибки возвращается -1, а I<errno> устанавливается в значение "
"ошибки."

#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#.      This matches the behavior of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: man-pages/man2/sendmmsg.2:146
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent.  See also BUGS."
msgstr ""
"Возникают те же ошибки что и для B<sendmsg>(2). Ошибка возвращается только, "
"если ни одной дейтаграммы не послано. Смотрите также ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:151
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""
"Системный вызов B<sendmmsg>() был добавлен в ядро Linux версии 3.0. "
"Поддержка в glibc появилась в версии 2.14."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:154
msgid "B<sendmmsg>()  is Linux-specific."
msgstr "Вызов B<sendmmsg>() есть только в Linux."

#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: man-pages/man2/sendmmsg.2:169
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr "Значение, указанное в I<vlen>, ограничено B<UIO_MAXIOV> (1024)."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:177
msgid ""
"If an error occurs after at least one message has been sent, the call "
"succeeds, and returns the number of messages sent.  The error code is lost.  "
"The caller can retry the transmission, starting at the first failed message, "
"but there is no guarantee that, if an error is returned, it will be the same "
"as the one that was lost on the previous call."
msgstr ""
"Если после отправки хотя бы одного сообщения произошла ошибка, то вызов "
"завершается успешно и возвращается количество отправленных сообщений. Код "
"ошибки теряется. Вызывающий может повторить передачу, начиная с первого "
"ошибочного сообщения, но нет гарантии, что возвращаемый код ошибки будет "
"совпадать с потерянным в предыдущем вызове."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:186
msgid ""
"The example below uses B<sendmmsg>()  to send I<onetwo> and I<three> in two "
"distinct UDP datagrams using one system call.  The contents of the first "
"datagram originates from a pair of buffers."
msgstr ""
"В примере далее B<sendmmsg>() используется для отправки I<onetwo> и I<three> "
"в двух разных дейтаграммах UDP за один системный вызов. Содержимое первой "
"дейтаграммы составляется из пары буферов."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:195
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:204
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:210
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:218
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:224
#, no-wrap
msgid ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"
msgstr ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:228
#, no-wrap
msgid ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"
msgstr ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:232
#, no-wrap
msgid ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"
msgstr ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:235
#, no-wrap
msgid ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"
msgstr ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:241
#, no-wrap
msgid ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"
msgstr ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d сообщений послано\\en\", retval);\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:244
#, no-wrap
msgid ""
"    exit(0);\n"
"}\n"
msgstr ""
"    exit(0);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:249
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: man-pages/man2/setpgid.2:48
#, no-wrap
msgid "SETPGID"
msgstr "SETPGID"

#. type: Plain text
#: man-pages/man2/setpgid.2:51
msgid "setpgid, getpgid, setpgrp, getpgrp - set/get process group"
msgstr ""
"setpgid, getpgid, setpgrp, getpgrp - устанавливает/получает группу процессов"

#. type: Plain text
#: man-pages/man2/setpgid.2:53
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/setpgid.2:55
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/setpgid.2:57
msgid "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"
msgstr "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"

#. type: Plain text
#: man-pages/man2/setpgid.2:59
msgid "B<pid_t getpgid(pid_t >I<pid>B<);>"
msgstr "B<pid_t getpgid(pid_t >I<pid>B<);>"

#. type: Plain text
#: man-pages/man2/setpgid.2:61
msgid "B<pid_t getpgrp(void);> /* POSIX.1 version */"
msgstr "B<pid_t getpgrp(void);> /* по версии POSIX.1 */"

#. type: Plain text
#: man-pages/man2/setpgid.2:64
msgid ""
"B<pid_t getpgrp(pid_t >I<pid>B<);\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ > /* BSD "
"version */"
msgstr "B<pid_t getpgrp(pid_t >I<pid>B<);> /* по версии BSD */"

#. type: Plain text
#: man-pages/man2/setpgid.2:66
msgid "B<int setpgrp(void);> /* System V version */"
msgstr "B<int setpgrp(void);> /* по версии System V */"

#. type: Plain text
#: man-pages/man2/setpgid.2:69
msgid "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);\\ > /* BSD version */"
msgstr "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);> /* по версии BSD */"

#. type: Plain text
#: man-pages/man2/setpgid.2:73
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/setpgid.2:77
msgid "B<getpgid>():"
msgstr "B<getpgid>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/setpgid.2:80
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man2/setpgid.2:82
#, no-wrap
msgid "    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr "    || /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:85
msgid "B<setpgrp>() (POSIX.1):"
msgstr "B<setpgrp>() (POSIX.1):"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/setpgid.2:90
#, no-wrap
msgid ""
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"        || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:94
msgid "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"
msgstr "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"

#. type: Plain text
#: man-pages/man2/setpgid.2:99
#, no-wrap
msgid ""
"    [These are available only before glibc 2.19]\n"
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"            _GNU_SOURCE || _SVID_SOURCE)\n"
msgstr ""
"    [Доступно только в версиях glibc до 2.19]\n"
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"            _GNU_SOURCE || _SVID_SOURCE)\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:110
msgid ""
"All of these interfaces are available on Linux, and are used for getting and "
"setting the process group ID (PGID) of a process.  The preferred, POSIX.1-"
"specified ways of doing this are: B<getpgrp>(void), for retrieving the "
"calling process's PGID; and B<setpgid>(), for setting a process's PGID."
msgstr ""
"Все перечисленные интерфейсы доступны в Linux и используются для получения и "
"установки идентификатора группы процессов (PGID). Предпочтительней "
"использовать версию POSIX.1: B<getpgrp>(void) — для получения PGID "
"вызывающего процесса; B<setpgid>() — для установки PGID вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:135
msgid ""
"B<setpgid>()  sets the PGID of the process specified by I<pid> to I<pgid>.  "
"If I<pid> is zero, then the process ID of the calling process is used.  If "
"I<pgid> is zero, then the PGID of the process specified by I<pid> is made "
"the same as its process ID.  If B<setpgid>()  is used to move a process from "
"one process group to another (as is done by some shells when creating "
"pipelines), both process groups must be part of the same session (see "
"B<setsid>(2)  and B<credentials>(7)).  In this case, the I<pgid> specifies "
"an existing process group to be joined and the session ID of that group must "
"match the session ID of the joining process."
msgstr ""
"Вызов B<setpgid>() устанавливает PGID у процесса с идентификатором I<pid> "
"равным I<pgid>. Если значение I<pid> равно 0, то используется идентификатор "
"вызывающего процесса. Если значение I<pgid> равно 0, то PGID процесса, "
"указанного в I<pid>, становится равным его идентификатору процесса. Если "
"B<setpgid>() используется для перевода процесса из одной группы в другую "
"(это делают некоторые оболочки командной строки для объединения каналов "
"процессов), то обе группы процессов должны быть частью одного сеанса (см. "
"B<setsid>(2) и B<credentials>(7)). В этом случае в I<pgid> указывается "
"существующая группа процессов, в которую нужно выполнить перевод и "
"идентификатор сеанса этой группы должен совпадать с идентификатором сеанса "
"переводимого процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:140
msgid ""
"The POSIX.1 version of B<getpgrp>(), which takes no arguments, returns the "
"PGID of the calling process."
msgstr ""
"В версии POSIX.1 вызов B<getpgrp>() без аргументов возвращает PGID "
"вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:151
msgid ""
"B<getpgid>()  returns the PGID of the process specified by I<pid>.  If "
"I<pid> is zero, the process ID of the calling process is used.  (Retrieving "
"the PGID of a process other than the caller is rarely necessary, and the "
"POSIX.1 B<getpgrp>()  is preferred for that task.)"
msgstr ""
"Вызов B<getpgid>() возвращает PGID процесса с заданным I<pid>. Если значение "
"I<pid> равно нулю, то используется идентификатор вызывающего процесса "
"(получение PGID процесса, отличного от вызывающего, требуется редко, а для "
"этой задачи хорошо подходит POSIX.1 B<getpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:156
msgid ""
"The System\\ V-style B<setpgrp>(), which takes no arguments, is equivalent "
"to I<setpgid(0,\\ 0)>."
msgstr ""
"В версии System\\ V вызов B<setpgrp>() без аргументов эквивалентен "
"I<setpgid(0,\\ 0)>."

#. type: Plain text
#: man-pages/man2/setpgid.2:164
msgid ""
"The BSD-specific B<setpgrp>()  call, which takes arguments I<pid> and "
"I<pgid>, is a wrapper function that calls"
msgstr ""
"В версии BSD вызов B<setpgrp>() с аргументами I<pid> и I<pgid> является "
"обёрточной функцией, которая вызывает"

#. type: Plain text
#: man-pages/man2/setpgid.2:166
#, no-wrap
msgid "    setpgid(pid, pgid)\n"
msgstr "    setpgid(pid, pgid)\n"

#.  The true BSD setpgrp() system call differs in allowing the PGID
#.  to be set to arbitrary values, rather than being restricted to
#.  PGIDs in the same session.
#. type: Plain text
#: man-pages/man2/setpgid.2:177
msgid ""
"Since glibc 2.19, the BSD-specific B<setpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with the "
"B<setpgid>()  call shown above."
msgstr ""
"Начиная с glibc 2.19, BSD-функция B<setpgrp>() была удалена из I<E<lt>unistd."
"hE<gt>>; вызовы должны быть заменены на вызов B<setpgid>(), как показано "
"выше."

#. type: Plain text
#: man-pages/man2/setpgid.2:183
msgid ""
"The BSD-specific B<getpgrp>()  call, which takes a single I<pid> argument, "
"is a wrapper function that calls"
msgstr ""
"В версии BSD вызов B<getpgrp>() с аргументом I<pid> является обёрточной "
"функцией, которая вызывает"

#. type: Plain text
#: man-pages/man2/setpgid.2:185
#, no-wrap
msgid "    getpgid(pid)\n"
msgstr "    getpgid(pid)\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:196
msgid ""
"Since glibc 2.19, the BSD-specific B<getpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with calls to the "
"POSIX.1 B<getpgrp>()  which takes no arguments (if the intent is to obtain "
"the caller's PGID), or with the B<getpgid>()  call shown above."
msgstr ""
"Начиная с glibc 2.19, BSD-функция B<getpgrp>() была удалена из I<E<lt>unistd."
"hE<gt>>; вызовы должны быть заменены на вызов POSIX.1 B<getpgrp>(), который "
"не имеет аргументов (если нужно получить PGID вызывающего), или на вызов "
"B<getpgid>(), как показано выше."

#. type: Plain text
#: man-pages/man2/setpgid.2:205
msgid ""
"On success, B<setpgid>()  and B<setpgrp>()  return zero.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<setpgid>()  and B<setpgrp>() возвращают 0. В "
"случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее "
"значение."

#. type: Plain text
#: man-pages/man2/setpgid.2:209
msgid "The POSIX.1 B<getpgrp>()  always returns the PGID of the caller."
msgstr ""
"Вызов B<getpgrp>() (POSIX.1) всегда возвращает PGID вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:217
msgid ""
"B<getpgid>(), and the BSD-specific B<getpgrp>()  return a process group on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"Вызовы B<getpgid>() и B<getpgrp>() (BSD) при успешном выполнении возвращают "
"группу процессов. При ошибке возвращается -1, а значение I<errno> "
"устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/setpgid.2:226
msgid ""
"An attempt was made to change the process group ID of one of the children of "
"the calling process and the child had already performed an B<execve>(2)  "
"(B<setpgid>(), B<setpgrp>())."
msgstr ""
"Попытка изменить идентификатор группы процессов у одного из потомков "
"вызывающего процесса, но потомок уже вызвал B<execve>(2) (B<setpgid>(), "
"B<setpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:232
msgid "I<pgid> is less than 0 (B<setpgid>(), B<setpgrp>())."
msgstr "Значение I<pgid> меньше 0 (B<setpgid>(), B<setpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:241
msgid ""
"An attempt was made to move a process into a process group in a different "
"session, or to change the process group ID of one of the children of the "
"calling process and the child was in a different session, or to change the "
"process group ID of a session leader (B<setpgid>(), B<setpgrp>())."
msgstr ""
"Попытка переместить процесс в группу процессов из другого сеанса или "
"изменить идентификатор группы процессов у одного из потомков вызывающего "
"процесса, но потомок находится в другом сеансе или изменить идентификатор "
"группы процессов лидера сеанса (B<setpgid>(), B<setpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:251
msgid ""
"For B<getpgid>(): I<pid> does not match any process.  For B<setpgid>(): "
"I<pid> is not the calling process and not a child of the calling process."
msgstr ""
"Для B<getpgid>(): нет процесса с указанным I<pid>. Для B<setpgid>(): "
"значение I<pid> не равно идентификатору вызывающего процесса или "
"идентификатору потомка вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:257
msgid ""
"B<setpgid>()  and the version of B<getpgrp>()  with no arguments conform to "
"POSIX.1-2001."
msgstr ""
"Вызов B<setpgid>() и версия B<getpgrp>() без аргументов соответствуют "
"POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/setpgid.2:266
msgid ""
"POSIX.1-2001 also specifies B<getpgid>()  and the version of B<setpgrp>()  "
"that takes no arguments.  (POSIX.1-2008 marks this B<setpgrp>()  "
"specification as obsolete.)"
msgstr ""
"В POSIX.1-2001 также определён вызов B<getpgid>() и его версия B<setpgrp>(), "
"у которых нет аргументов (в POSIX.1-2008 определение B<setpgrp>() помечено "
"как устаревшее)."

#. type: Plain text
#: man-pages/man2/setpgid.2:273
msgid ""
"The version of B<getpgrp>()  with one argument and the version of "
"B<setpgrp>()  that takes two arguments derive from 4.2BSD, and are not "
"specified by POSIX.1."
msgstr ""
"Версия B<getpgrp>() с одним аргументом и версия B<setpgrp>() с двумя "
"аргументами появились из 4.2BSD и отсутствуют в POSIX.1."

#. type: Plain text
#: man-pages/man2/setpgid.2:279
msgid ""
"A child created via B<fork>(2)  inherits its parent's process group ID.  The "
"PGID is preserved across an B<execve>(2)."
msgstr ""
"Потомок, создаваемый с помощью B<fork>(2), наследует идентификатор группы "
"процессов своего родителя. Значение PGID сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setpgid.2:284
msgid ""
"Each process group is a member of a session and each process is a member of "
"the session of which its process group is a member.  (See B<credentials>(7).)"
msgstr ""
"Каждая группа процессов является членом сеанса и каждый процесс является "
"членом сеанса, в который входит его группа процессов (смотрите "
"B<credentials>(7))."

#. type: Plain text
#: man-pages/man2/setpgid.2:311
msgid ""
"A session can have a controlling terminal.  At any time, one (and only one) "
"of the process groups in the session can be the foreground process group for "
"the terminal; the remaining process groups are in the background.  If a "
"signal is generated from the terminal (e.g., typing the interrupt key to "
"generate B<SIGINT>), that signal is sent to the foreground process group.  "
"(See B<termios>(3)  for a description of the characters that generate "
"signals.)  Only the foreground process group may B<read>(2)  from the "
"terminal; if a background process group tries to B<read>(2)  from the "
"terminal, then the group is sent a B<SIGTTIN> signal, which suspends it.  "
"The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  functions are used to get/set the "
"foreground process group of the controlling terminal."
msgstr ""
"Сеанс может иметь управляющий терминал. В любой момент одна (и только одна) "
"группа процессов в сеансе может являться приоритетной группой процессов "
"(foreground process group) терминала; оставшиеся группы процессов "
"выполняются в фоновом режиме. Если от терминала приходит сигнал (например, "
"нажата клавиша прерывания и сгенерирован B<SIGINT>), то сигнал посылается в "
"приоритетную группу процессов (смотрите в B<termios>(3) описание символов, "
"для которых генерируются сигналы). Только приоритетная группа процессов "
"может выполнять вызов B<read>(2) для терминала; если группа процессов в "
"фоновом режиме пытается выполнить B<read>(2) для терминала, то группе "
"посылается сигнал B<SIGTTIN>, который приостанавливает её выполнение. "
"Функции B<tcgetpgrp>(3) и B<tcsetpgrp>(3) используются для получения/"
"установки приоритетной группы процессов у управляющего терминала."

#. type: Plain text
#: man-pages/man2/setpgid.2:319
msgid ""
"The B<setpgid>()  and B<getpgrp>()  calls are used by programs such as "
"B<bash>(1)  to create process groups in order to implement shell job control."
msgstr ""
"Вызовы B<setpgid>() и B<getpgrp>() используются программами, например "
"B<bash>(1), для создания группы процессов с целью реализации управления "
"заданиями оболочки командной строки."

#.  exit.3 refers to the following text:
#. type: Plain text
#: man-pages/man2/setpgid.2:333
msgid ""
"If the termination of a process causes a process group to become orphaned, "
"and if any member of the newly orphaned process group is stopped, then a "
"B<SIGHUP> signal followed by a B<SIGCONT> signal will be sent to each "
"process in the newly orphaned process group.  An orphaned process group is "
"one in which the parent of every member of process group is either itself "
"also a member of the process group or is a member of a process group in a "
"different session (see also B<credentials>(7))."
msgstr ""
"Если завершение процесса лишает группу процессов главы и если любой из такой "
"группы процессов остановлен, то каждому процессу в группе посылается сигнал "
"B<SIGHUP> с последующим B<SIGCONT>. Осиротевшей считается группа процессов, "
"у которой родитель каждого члена группы процессов сам является членом группы "
"процессов или членом группы процессов другого сеанса (см. также "
"B<credentials>(7))."

#. type: Plain text
#: man-pages/man2/setpgid.2:339
msgid ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"
msgstr ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"

#. type: TH
#: man-pages/man2/sigpending.2:29
#, no-wrap
msgid "SIGPENDING"
msgstr "SIGPENDING"

#. type: Plain text
#: man-pages/man2/sigpending.2:32
msgid "sigpending, rt_sigpending - examine pending signals"
msgstr "sigpending, rt_sigpending - проверка ожидающих сигналов"

#. type: Plain text
#: man-pages/man2/sigpending.2:34
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr "B<#include E<lt>signal.hE<gt>>"

#. type: Plain text
#: man-pages/man2/sigpending.2:36
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr "B<int sigpending(sigset_t *>I<set>B<);>"

#. type: Plain text
#: man-pages/man2/sigpending.2:45
msgid "B<sigpending>(): _POSIX_C_SOURCE"
msgstr "B<sigpending>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man2/sigpending.2:53
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to "
"the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr ""
"Вызов B<sigpending>() возвращает набор сигналов, которые ожидают доставки в "
"вызвавшую нить (т.е., сигналы, возникшие пока были заблокированы). Маска "
"ожидающих сигналов возвращается в I<set>."

#. type: Plain text
#: man-pages/man2/sigpending.2:59
msgid ""
"B<sigpending>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"При успешном выполнении функция B<sigpending>() возвращает 0 и -1 при "
"ошибке. В случае ошибки в I<errno> указывается номер ошибки."

#. type: Plain text
#: man-pages/man2/sigpending.2:64
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr ""
"Аргумент I<set> указывает на память в недопустимой части адресуемого "
"пространства."

#. type: Plain text
#: man-pages/man2/sigpending.2:66
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/sigpending.2:70
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr ""
"Подробная информация о работе с наборами сигналов есть на странице "
"B<sigsetops>(3)."

#. type: Plain text
#: man-pages/man2/sigpending.2:74
msgid ""
"If a signal is both blocked and has a disposition of \"ignored\", it is "
"I<not> added to the mask of pending signals when generated."
msgstr ""
"Если сигнал заблокирован и имеет обработчик «игнорировать», то он I<не> "
"добавляется в маску ожидающих сигналов при генерации."

#. type: Plain text
#: man-pages/man2/sigpending.2:79
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr ""
"Набор сигналов, ожидающих обработки в нити, представляет собой объединение "
"набора сигналов, ожидающих обработки в этой нити и набора сигналов, "
"ожидающих обработки всем процессом (см. B<signal>(7))."

#. type: SS
#: man-pages/man2/sigpending.2:86
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#.  This argument is currently required to be less than or equal to
#.  .IR sizeof(sigset_t)
#.  (or the error
#.  .B EINVAL
#.  results).
#. type: Plain text
#: man-pages/man2/sigpending.2:113
msgid ""
"The original Linux system call was named B<sigpending>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> argument supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigpending>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  The glibc B<sigpending>()  wrapper function hides "
"these details from us, transparently calling B<rt_sigpending>()  when the "
"kernel provides it."
msgstr ""
"Первоначально, системный вызов Linux назывался B<sigpending>(). Однако, с "
"добавлением сигналов реального времени в Linux 2.2, 32-битный аргумент "
"I<sigset_t> неизменяемого размера, поддерживаемый этим системным вызовом, не "
"мог больше использоваться. В результате был добавлен новый системный вызов "
"B<rt_sigpending>() с увеличенным типом I<sigset_t>. У нового системного "
"вызова появился второй аргумент, I<size_t sigsetsize>, в котором указывается "
"размер (в байтах) набора сигналов I<set>. Обёрточная функция glibc "
"B<sigpending>() скрывает это и вызывает B<rt_sigpending>(), если он есть в "
"ядре."

#. type: Plain text
#: man-pages/man2/sigpending.2:119
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr ""
"В версиях glibc до 2.2.1 включительно, был дефект в обёрточной функции к "
"B<sigpending>(), из-за которого возвращалась некорректная информация об "
"ожидающих сигналах реального времени."

#. type: Plain text
#: man-pages/man2/sigpending.2:126
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/socketcall.2:25
#, no-wrap
msgid "SOCKETCALL"
msgstr "SOCKETCALL"

#. type: Plain text
#: man-pages/man2/socketcall.2:28
msgid "socketcall - socket system calls"
msgstr "socketcall - системные вызовы сокетов"

#. type: Plain text
#: man-pages/man2/socketcall.2:30
msgid "B<#include E<lt>linux/net.hE<gt>>"
msgstr "B<#include E<lt>linux/net.hE<gt>>"

#. type: Plain text
#: man-pages/man2/socketcall.2:32
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"

#. type: Plain text
#: man-pages/man2/socketcall.2:40
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""
"B<socketcall>() \\(em это общая точка входа в ядро всех системных вызовов "
"сокетов. В аргументе I<call> задаётся функция сокета, которая будет вызвана. "
"Аргумент I<args> указывает на блок параметров функции, которые передаются "
"соответствующему вызову."

#. type: Plain text
#: man-pages/man2/socketcall.2:44
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""
"Пользовательские программы должны оперировать обычными функциями, имеющими "
"стандартные имена. О существовании B<socketcall>() необходимо знать лишь "
"создателям стандартных библиотек и ядра."

#. type: tbl table
#: man-pages/man2/socketcall.2:48
#, no-wrap
msgid "I<call>"
msgstr "I<Вызов>"

#. type: tbl table
#: man-pages/man2/socketcall.2:48
#, no-wrap
msgid "Man page"
msgstr "Справочная страница"

#. type: tbl table
#: man-pages/man2/socketcall.2:51
#, no-wrap
msgid "B<SYS_SOCKET>"
msgstr "B<SYS_SOCKET>"

#. type: tbl table
#: man-pages/man2/socketcall.2:56
#, no-wrap
msgid "B<SYS_BIND>"
msgstr "B<SYS_BIND>"

#. type: tbl table
#: man-pages/man2/socketcall.2:61
#, no-wrap
msgid "B<SYS_CONNECT>"
msgstr "B<SYS_CONNECT>"

#. type: tbl table
#: man-pages/man2/socketcall.2:66
#, no-wrap
msgid "B<SYS_LISTEN>"
msgstr "B<SYS_LISTEN>"

#. type: tbl table
#: man-pages/man2/socketcall.2:71
#, no-wrap
msgid "B<SYS_ACCEPT>"
msgstr "B<SYS_ACCEPT>"

#. type: tbl table
#: man-pages/man2/socketcall.2:76
#, no-wrap
msgid "B<SYS_GETSOCKNAME>"
msgstr "B<SYS_GETSOCKNAME>"

#. type: tbl table
#: man-pages/man2/socketcall.2:81
#, no-wrap
msgid "B<SYS_GETPEERNAME>"
msgstr "B<SYS_GETPEERNAME>"

#. type: tbl table
#: man-pages/man2/socketcall.2:86
#, no-wrap
msgid "B<SYS_SOCKETPAIR>"
msgstr "B<SYS_SOCKETPAIR>"

#. type: tbl table
#: man-pages/man2/socketcall.2:91
#, no-wrap
msgid "B<SYS_SEND>"
msgstr "B<SYS_SEND>"

#. type: tbl table
#: man-pages/man2/socketcall.2:96
#, no-wrap
msgid "B<SYS_RECV>"
msgstr "B<SYS_RECV>"

#. type: tbl table
#: man-pages/man2/socketcall.2:101
#, no-wrap
msgid "B<SYS_SENDTO>"
msgstr "B<SYS_SENDTO>"

#. type: tbl table
#: man-pages/man2/socketcall.2:106
#, no-wrap
msgid "B<SYS_RECVFROM>"
msgstr "B<SYS_RECVFROM>"

#. type: tbl table
#: man-pages/man2/socketcall.2:111
#, no-wrap
msgid "B<SYS_SHUTDOWN>"
msgstr "B<SYS_SHUTDOWN>"

#. type: tbl table
#: man-pages/man2/socketcall.2:116
#, no-wrap
msgid "B<SYS_SETSOCKOPT>"
msgstr "B<SYS_SETSOCKOPT>"

#. type: tbl table
#: man-pages/man2/socketcall.2:121
#, no-wrap
msgid "B<SYS_GETSOCKOPT>"
msgstr "B<SYS_GETSOCKOPT>"

#. type: tbl table
#: man-pages/man2/socketcall.2:126
#, no-wrap
msgid "B<SYS_SENDMSG>"
msgstr "B<SYS_SENDMSG>"

#. type: tbl table
#: man-pages/man2/socketcall.2:131
#, no-wrap
msgid "B<SYS_RECVMSG>"
msgstr "B<SYS_RECVMSG>"

#. type: tbl table
#: man-pages/man2/socketcall.2:136
#, no-wrap
msgid "B<SYS_ACCEPT4>"
msgstr "B<SYS_ACCEPT4>"

#. type: tbl table
#: man-pages/man2/socketcall.2:138
#, no-wrap
msgid "B<accept4>(2)"
msgstr "B<accept4>(2)"

#. type: tbl table
#: man-pages/man2/socketcall.2:141
#, no-wrap
msgid "B<SYS_RECVMMSG>"
msgstr "B<SYS_RECVMMSG>"

#. type: tbl table
#: man-pages/man2/socketcall.2:143
#, no-wrap
msgid "B<recvmmsg>(2)"
msgstr "B<recvmmsg>(2)"

#. type: tbl table
#: man-pages/man2/socketcall.2:146
#, no-wrap
msgid "B<SYS_SENDMMSG>"
msgstr "B<SYS_SENDMMSG>"

#. type: tbl table
#: man-pages/man2/socketcall.2:148
#, no-wrap
msgid "B<sendmmsg>(2)"
msgstr "B<sendmmsg>(2)"

#. type: Plain text
#: man-pages/man2/socketcall.2:153
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""
"Эта функция есть только в Linux, и она не должна использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man2/socketcall.2:161
msgid ""
"On a some architectures\\(emfor example, x86-64 and ARM\\(emthere is no "
"B<socketcall>()  system call; instead B<socket>(2), B<accept>(2), "
"B<bind>(2), and so on really are implemented as separate system calls."
msgstr ""
"На некоторых архитектурах, например x86-64 и ARM, нет системного вызова "
"B<socketcall>(); вместо него реализованы системные вызовы B<socket>(2), "
"B<accept>(2), B<bind>(2) и т.д."

#.  commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb
#. type: Plain text
#: man-pages/man2/socketcall.2:174
msgid ""
"On x86-32, B<socketcall>()  was historically the only entry point for the "
"sockets API.  However, starting in Linux 4.3, direct system calls are "
"provided on x86-32 for the sockets API.  This facilitates the creation of "
"B<seccomp>(2)  filters that filter sockets system calls (for new user-space "
"binaries that are compiled to use the new entry points)  and also provides a "
"(very) small performance improvement."
msgstr ""
"Для архитектуры x86-32, B<socketcall>() исторически имел только одну точку "
"входа в программном интерфейсе сокетов. Однако начиная с Linux 4.3, для "
"x86-32 появились прямые системные вызовы в программном интерфейсе сокетов. "
"for the sockets API. Это упрощает создание фильтров B<seccomp>(2), которые "
"отбирают системные вызовы сокетов (для новых пользовательских исполняемых "
"файлов, которые компилируются с использованием новых точек входа), а также "
"улучшают (совсем немного) производительность."

#. type: Plain text
#: man-pages/man2/socketcall.2:191
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"

#. type: TH
#: man-pages/man2/shmop.2:41
#, no-wrap
msgid "SHMOP"
msgstr "SHMOP"

#. type: Plain text
#: man-pages/man2/shmop.2:44
msgid "shmat, shmdt - System V shared memory operations"
msgstr "shmat, shmdt - операции с общей памятью System V"

#. type: Plain text
#: man-pages/man2/shmop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/shmop.2:50
#, no-wrap
msgid "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"
msgstr "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"

#. type: Plain text
#: man-pages/man2/shmop.2:52
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr "B<int shmdt(const void *>I<shmaddr>B<);>\n"

#. type: SS
#: man-pages/man2/shmop.2:54
#, no-wrap
msgid "shmat()"
msgstr "shmat()"

#. type: Plain text
#: man-pages/man2/shmop.2:62
msgid ""
"B<shmat>()  attaches the System\\ V shared memory segment identified by "
"I<shmid> to the address space of the calling process.  The attaching address "
"is specified by I<shmaddr> with one of the following criteria:"
msgstr ""
"Вызов B<shmat>() подключает сегмент общей памяти System\\ V с "
"идентификатором I<shmid> к адресному пространству вызывающего процесса. "
"Адрес подключения, указанный в I<shmaddr>, учитывается следующим образом:"

#. type: Plain text
#: man-pages/man2/shmop.2:68
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) page-aligned "
"address to attach the segment."
msgstr ""
"Если значение I<shmaddr> равно NULL, то система выбирает подходящий "
"(неиспользуемый) выровненный по странице адрес для подключения сегмента."

#. type: Plain text
#: man-pages/man2/shmop.2:80
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>."
msgstr ""
"Если значение I<shmaddr> не равно NULL, а в I<shmflg> указан флаг "
"B<SHM_RND>, то подключение производится по адресу I<shmaddr>, округлённому "
"до ближайшего значения кратного B<SHMLBA>."

#. type: Plain text
#: man-pages/man2/shmop.2:84
msgid ""
"Otherwise, I<shmaddr> must be a page-aligned address at which the attach "
"occurs."
msgstr ""
"В противном случае I<shmaddr> должно быть выровнено по адресу страницы, к "
"которому производится подключение."

#. type: Plain text
#: man-pages/man2/shmop.2:90
msgid ""
"In addition to B<SHM_RND>, the following flags may be specified in the "
"I<shmflg> bit-mask argument:"
msgstr ""
"В дополнении к B<SHM_RND>, в аргументе битовой маски I<shmflg> могут быть "
"указаны следующие флаги:"

#. type: TP
#: man-pages/man2/shmop.2:90
#, no-wrap
msgid "B<SHM_EXEC> (Linux-specific; since Linux 2.6.9)"
msgstr "B<SHM_EXEC> (есть только в Linux; начиная с Linux 2.6.9)"

#. type: Plain text
#: man-pages/man2/shmop.2:94
msgid ""
"Allow the contents of the segment to be executed.  The caller must have "
"execute permission on the segment."
msgstr ""
"Разрешить выполнение содержимого сегмента. Вызывающий должен иметь права на "
"выполнение сегмента."

#. type: TP
#: man-pages/man2/shmop.2:94
#, no-wrap
msgid "B<SHM_RDONLY>"
msgstr "B<SHM_RDONLY>"

#. type: Plain text
#: man-pages/man2/shmop.2:102
msgid ""
"Attach the segment for read-only access.  The process must have read "
"permission for the segment.  If this flag is not specified, the segment is "
"attached for read and write access, and the process must have read and write "
"permission for the segment.  There is no notion of a write-only shared "
"memory segment."
msgstr ""
"Разрешить доступ к сегменту только для чтения. Процесс должен иметь права на "
"чтение сегмента. Если этот флаг не указан, то сегмент подключается с правом "
"чтения и записи, и процесс должен иметь права на чтение и запись сегмента. "
"Об общих сегментах памяти, доступных только на запись, ничего не упоминается."

#. type: TP
#: man-pages/man2/shmop.2:102
#, no-wrap
msgid "B<SHM_REMAP> (Linux-specific)"
msgstr "B<SHM_REMAP> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmop.2:115
msgid ""
"This flag specifies that the mapping of the segment should replace any "
"existing mapping in the range starting at I<shmaddr> and continuing for the "
"size of the segment.  (Normally, an B<EINVAL> error would result if a "
"mapping already exists in this address range.)  In this case, I<shmaddr> "
"must not be NULL."
msgstr ""
"Этот флаг указывает, что отображение сегмента должно замещать любые "
"существующие отображения в диапазоне, начиная с I<shmaddr> и до размера "
"сегмента (обычно выдается ошибка B<EINVAL>, если в этом диапазоне адресов "
"уже есть отображение). В этом случае значение I<shmaddr> не должно быть "
"равно NULL."

#. type: Plain text
#: man-pages/man2/shmop.2:122
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""
"Значение B<brk>(2) вызывающего процесса от подключения не изменяется. При "
"завершении работы процесса сегмент будет автоматически отсоединён. Один и "
"тот же сегмент может быть подключён в адресное пространство процесса "
"несколько раз, как только для чтения, так и для чтения-записи."

#. type: Plain text
#: man-pages/man2/shmop.2:130
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""
"При успешном выполнении системный вызов B<shmat>() обновляет поля структуры "
"I<shmid_ds> (см. B<shmctl>(2)), связанной с общим сегментом памяти, "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/shmop.2:133
msgid "I<shm_atime> is set to the current time."
msgstr "Полю I<shm_atime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/shmop.2:136 man-pages/man2/shmop.2:163
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr ""
"Значение I<shm_lpid> устанавливается равным идентификатору вызывающего "
"процесса."

#. type: Plain text
#: man-pages/man2/shmop.2:140
msgid "I<shm_nattch> is incremented by one."
msgstr "Значение I<shm_nattch> увеличивается на 1."

#. type: SS
#: man-pages/man2/shmop.2:140
#, no-wrap
msgid "shmdt()"
msgstr "shmdt()"

#. type: Plain text
#: man-pages/man2/shmop.2:151
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""
"Вызов B<shmdt>() отключает сегмент общей памяти, находящийся по адресу "
"I<shmaddr>, от адресного пространства вызывающего процесса. Отключаемый "
"сегмент должен быть подключён по адресу I<shmaddr> с помощью вызова "
"B<shmat>()."

#. type: Plain text
#: man-pages/man2/shmop.2:157
msgid ""
"On a successful B<shmdt>()  call, the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""
"При успешном выполнении вызов B<shmdt>() обновляет поля структуры "
"I<shmid_ds>, связанной с общим сегментом памяти, следующим образом:"

#. type: Plain text
#: man-pages/man2/shmop.2:160
msgid "I<shm_dtime> is set to the current time."
msgstr "Полю I<shm_dtime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/shmop.2:168
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""
"Значение I<shm_nattch> уменьшается на 1. Если оно становится равным 0 и "
"сегмент помечен для удаления, то сегмент удаляется."

#. type: Plain text
#: man-pages/man2/shmop.2:176
msgid ""
"On success, B<shmat>()  returns the address of the attached shared memory "
"segment; on error, I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""
"При успешном выполнении B<shmat>() возвращается адрес подключённого общего "
"сегмента памяти; при ошибке возвращается I<(void\\ *)\\ -1>, а в I<errno> "
"содержится код ошибки."

#. type: Plain text
#: man-pages/man2/shmop.2:182
msgid ""
"On success, B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<shmdt>() возвращается 0; при ошибке возвращается "
"-1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/shmop.2:188
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""
"Значения I<errno>, устанавливаемые при возникновении ошибок в B<shmat>():"

#. type: Plain text
#: man-pages/man2/shmop.2:194
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability in the user "
"namespace that governs its IPC namespace."
msgstr ""
"Вызывающий процесс не имеет прав для подключения заданного типа и не имеет "
"мандата B<CAP_IPC_OWNER> в пространстве имён пользователя, который управляет "
"его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/shmop.2:211
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""
"Неправильное значение I<shmid>, не выровненное (по границе страницы и не "
"указан B<SHM_RND>) или неправильное значение I<shmaddr>, или невозможно "
"подключить сегмент по адресу I<shmaddr>, или был указан B<SHM_REMAP>, но "
"I<shmaddr> равно NULL."

#. type: Plain text
#: man-pages/man2/shmop.2:214
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr "Невозможно выделить память для дескриптора или страничных таблиц."

#. type: Plain text
#: man-pages/man2/shmop.2:220
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr ""
"Значения I<errno>, устанавливаемые при возникновении ошибок в B<shmdt>():"

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: man-pages/man2/shmop.2:228
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""
"По адресу I<shmaddr> подключённый общий сегмент памяти отсутствует; или "
"значение I<shmaddr> не выровнено по границе страницы."

#. type: Plain text
#: man-pages/man2/shmop.2:243
msgid ""
"In SVID 3 (or perhaps earlier), the type of the I<shmaddr> argument was "
"changed from I<char\\ *> into I<const void\\ *>, and the returned type of "
"B<shmat>()  from I<char\\ *> into I<void\\ *>."
msgstr ""
"В SVID 3 (возможно, чуть раньше) тип аргумента I<shmaddr> изменён с I<char\\ "
"*> на I<const void\\ *>, а тип возвращаемого значения B<shmat>() с I<char\\ "
"*> на I<void\\ *>."

#. type: Plain text
#: man-pages/man2/shmop.2:248
msgid ""
"After a B<fork>(2), the child inherits the attached shared memory segments."
msgstr ""
"При вызове B<fork>(2) потомки наследуют подключённые общие сегменты памяти."

#. type: Plain text
#: man-pages/man2/shmop.2:252
msgid ""
"After an B<execve>(2), all attached shared memory segments are detached from "
"the process."
msgstr ""
"При вызове B<execve>(2) все подключённые общие сегменты памяти отключаются."

#. type: Plain text
#: man-pages/man2/shmop.2:256
msgid ""
"Upon B<_exit>(2), all attached shared memory segments are detached from the "
"process."
msgstr ""
"При вызове B<_exit>(2) все подключённые общие сегменты памяти отключаются."

#. type: Plain text
#: man-pages/man2/shmop.2:268
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""
"Для улучшения переносимости программ при подключении общего сегмента памяти "
"рекомендуется использовать B<shmat>() с аргументом I<shmaddr>, установленным "
"в NULL. Необходимо учитывать, что сегмент памяти, подключаемый таким "
"способом, в разных процессах может подключаться по разным адресам. Поэтому "
"все указатели в области общей памяти должны быть не абсолютными, а "
"относительными (как правило относительно адреса начала сегмента)."

#. type: Plain text
#: man-pages/man2/shmop.2:273
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1 does not specify this "
"behavior and many other implementations do not support it."
msgstr ""
"В Linux сегмент общей памяти можно подключить даже, если он помечен для "
"удаление. Однако в POSIX.1 об этом ничего не сказано, и многие другие "
"реализации это не поддерживают."

#. type: Plain text
#: man-pages/man2/shmop.2:276
msgid "The following system parameter affects B<shmat>():"
msgstr "На работу B<shmat>() влияют следующие системные параметры:"

#. type: TP
#: man-pages/man2/shmop.2:276
#, no-wrap
msgid "B<SHMLBA>"
msgstr "B<SHMLBA>"

#. type: Plain text
#: man-pages/man2/shmop.2:291
msgid ""
"Segment low boundary address multiple.  When explicitly specifying an attach "
"address in a call to B<shmat>(), the caller should ensure that the address "
"is a multiple of this value.  This is necessary on some architectures, in "
"order either to ensure good CPU cache performance or to ensure that "
"different attaches of the same segment have consistent views within the CPU "
"cache.  B<SHMLBA> is normally some multiple of the system page size.  (On "
"many Linux architectures, B<SHMLBA> is the same as the system page size.)"
msgstr ""
"Кратность адреса нижней границы сегмента. При явном указании в вызове "
"B<shmat>() подключаемого адреса вызывающий должен убедиться, что адрес "
"кратен этому значению. Это необходимо у некоторых архитектур, чтобы точно "
"получить хорошую производительность от кэша ЦП или чтобы различные "
"подключения одного сегмента имели целостный вид внутри кэша ЦП. Параметр "
"B<SHMLBA>, обычно, кратен нескольким размерам системной страницы (у многих "
"архитектур Linux B<SHMLBA> совпадает с размером системной страницы)."

#. type: Plain text
#: man-pages/man2/shmop.2:295
msgid ""
"The implementation places no intrinsic per-process limit on the number of "
"shared memory segments (B<SHMSEG>)."
msgstr ""
"Реализацией не ограничивается количество общих сегментов общей памяти на "
"процесс (B<SHMSEG>)."

#. type: Plain text
#: man-pages/man2/shmop.2:302
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr "SYNC_FILE_RANGE"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr "sync_file_range - синхронизирует сегмент файла на диске"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""
"Вызов B<sync_file_range>() позволяет точно контролировать синхронизацию "
"открытого файла, задаваемого файловым дескриптором I<fd>, с диском."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""
"В I<offset> задаётся начальный байт диапазона файла, который нужно "
"синхронизировать. В I<nbytes> указывается длина синхронизируемого диапазона "
"(в байтах); если I<nbytes> равно нулю, то синхронизируются все байты, "
"начиная с I<offset> и до конца файла. Синхронизация выполняется в единицах "
"размера системной страницы: значение I<offset> округляется к меньшей границе "
"страницы; I<(offset+nbytes-1)> округляется к большей границе страницы."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr "В битовую маску аргумент I<flags> можно включать следующие значения:"

#. type: TP
#: man-pages/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""
"Перед выполнением записи ждать, пока будут перезаписаны все страницы в "
"указанном диапазоне, которые уже были отправлены в драйвер устройства."

#. type: TP
#: man-pages/man2/sync_file_range.2:70 man-pages/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr "B<SYNC_FILE_RANGE_WRITE>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""
"Начать перезапись всех изменённых страниц в указанном диапазоне, которые к "
"настоящему моменту не были перезаписаны. Заметим, что это может привести к "
"блокировке, если вы пытаетесь записать больше размера очереди запросов."

#. type: TP
#: man-pages/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:80
msgid ""
"Wait upon write-out of all pages in the range after performing any write."
msgstr ""
"После выполнения записи ждать, пока не перезапишутся все страницы в "
"диапазоне."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr "Указание 0 в I<flags> допустимо; никаких действий выполнено не будет."

#. type: SS
#: man-pages/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr "Предупреждение"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On filesystems using copy-on-write semantics (e.g., "
"I<btrfs>)  an overwrite of existing allocated blocks is impossible.  When "
"writing into preallocated space, many filesystems also require calls into "
"the block allocator, which this system call does not sync out to disk.  This "
"system call does not flush disk write caches and thus does not provide any "
"data integrity on systems with volatile disk write caches."
msgstr ""
"Данный системный вызов очень опасен и не должен использоваться в переносимых "
"программах. Ни одна из этих операций перезаписи не касается метаданных "
"файла. Поэтому, если приложение строго не выполняет перезаписи уже "
"выделенных дисковых блоков, то нет никаких гарантий, что данные будут будьте "
"доступны после катастрофического отказа. Не существует пользовательского "
"интерфейса, который позволял бы узнать, действительно ли выполнилась "
"перезапись. В файловых системах, использующих семантику копирования при "
"записи (например, I<btrfs>) перезапись существующих выделенных блоков "
"невозможна. Когда запись выполняется в уже выделенное пространство, многие "
"файловые системы также вызывают выделитель блоков, которые данный системный "
"вызов не синхронизирует с диском. Данный системный вызов не выполняет сброс "
"дисковых кэшей для записи и поэтому не предоставляет какой-либо целостности "
"данных в системах с изменчивыми дисковыми кэшами на запись."

#. type: SS
#: man-pages/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr "Некоторые подробности"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""
"При B<SYNC_FILE_RANGE_WAIT_BEFORE> и B<SYNC_FILE_RANGE_WAIT_AFTER> будут "
"обнаруживаться все ошибки ввода-вывода или условия B<ENOSPC>, и они будут "
"возвращены вызвавшему."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr "Полезные комбинации битов в I<flags>:"

#. type: TP
#: man-pages/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""
"Гарантировать, что все изменённые страницы в указанном диапазоне при вызове "
"B<sync_file_range>() помещаются для записи. Это начало операции по целостной "
"записи данных."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""
"Начать запись всех изменённых страниц указанного диапазона, которые ещё не "
"были размещены для записи. Это анонимная операция сброса данных на диск. Она "
"не подходит для операций целостности данных."

#. type: TP
#: man-pages/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE> (или B<SYNC_FILE_RANGE_WAIT_AFTER>)"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""
"Ждать завершения записи всех страниц указанного диапазона. Можно "
"использовать после операции B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE>, дождаться завершения этой операции и получить её "
"результат."

#. type: TP
#: man-pages/man2/sync_file_range.2:134
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""
"Это операция по целостной записи данных, которая позволит быть уверенным, "
"что все изменённые на момент вызова B<sync_file_range>() страницы указанного "
"диапазона записаны на диск."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<sync_file_range>() возвращает 0. При ошибке "
"возвращается -1, и I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:160
msgid ""
"I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""
"В I<flags> указан некорректный бит; или некорректное значение в I<offset> "
"или I<nbytes>."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:163
msgid "I/O error."
msgstr "Ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr "Недостаточно места на диске."

#. type: TP
#: man-pages/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:174
msgid ""
"I<fd> refers to something other than a regular file, a block device, or a "
"directory."
msgstr ""
"Значение I<fd> ссылается не на обычный файл, блочное устройство, или каталог."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:177
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr "Вызов B<sync_file_range>() появился в Linux в ядре версии 2.6.17."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:180
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""
"Данный системный вызов есть только в Linux, и не должен использоваться в "
"переносимых приложениях."

#. type: SS
#: man-pages/man2/sync_file_range.2:181
#, no-wrap
msgid "sync_file_range2()"
msgstr "sync_file_range2()"

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: man-pages/man2/sync_file_range.2:198
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  shown in the SYNOPSIS would force a register to be "
"wasted as padding between the I<fd> and I<offset> arguments.  (See "
"B<syscall>(2)  for details.)  Therefore, these architectures define a "
"different system call that orders the arguments suitably:"
msgstr ""
"Для некоторых архитектур (например, PowerPC, ARM) требуется, чтобы 64-битные "
"аргументы были выровнены в нужных парах регистров. На таких архитектурах для "
"объявления вызова B<sync_file_range>(), показанного в СИНТАКСИСЕ, для "
"заполнения между аргументами I<fd> и I<offset> расходовался бы ещё один "
"регистр впустую (подробности смотрите в B<syscall>(2)). Поэтому в этих "
"архитектурах определён другой системный вызов с подходящим порядком "
"аргументов:"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:203
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:208
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr "Поведение данного системного вызова такое же как B<sync_file_range>()."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:219
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""
"Системный вызов с таких объявлением впервые появился для архитектуры ARM в "
"Linux 2.6.20 под именем B<arm_sync_file_range>(). В Linux 2.6.22 он был "
"переименован, так как аналогичный системный вызов был добавлен для PowerPC. "
"Для архитектур, поддерживаемых glibc, glibc прозрачно обёртывает "
"B<sync_file_range2>() именем B<sync_file_range>()."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:223
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"

#. type: TH
#: man-pages/man2/sigwaitinfo.2:25
#, no-wrap
msgid "SIGWAITINFO"
msgstr "SIGWAITINFO"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:29
msgid ""
"sigwaitinfo, sigtimedwait, rt_sigtimedwait - synchronously wait for queued "
"signals"
msgstr ""
"sigwaitinfo, sigtimedwait, rt_sigtimedwait - синхронное ожидание запрошенных "
"сигналов"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:32
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:34
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:37
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:47
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""
"B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:57
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is pending (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately.)"
msgstr ""
"B<sigwaitinfo>() приостанавливает исполнение вызывающий нити до тех пор, "
"пока не будет ожидаться один из сигналов из набора I<set> (если один из "
"сигналов в I<set> уже ожидает обработки вызывающей нитью, то "
"B<sigwaitinfo>() завершит работу немедленно с возвратом информации об этом "
"сигнале)."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:69
msgid ""
"B<sigwaitinfo>()  removes the signal from the set of pending signals and "
"returns the signal number as its function result.  If the I<info> argument "
"is not NULL, then the buffer that it points to is used to return a structure "
"of type I<siginfo_t> (see B<sigaction>(2))  containing information about the "
"signal."
msgstr ""
"B<sigwaitinfo>() удаляет сигнал из списка сигналов ожидающих обработки и "
"возвращает номер сигнала как результат работы функции. Если аргумент I<info> "
"не равен NULL, то в буфер, на который он указывает, записывается структура "
"типа I<siginfo_t> (см. B<sigaction>(2)), содержащая информацию о сигнале."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:77
msgid ""
"If multiple signals in I<set> are pending for the caller, the signal that is "
"retrieved by B<sigwaitinfo>()  is determined according to the usual ordering "
"rules; see B<signal>(7)  for further details."
msgstr ""
"Если в I<set> ожидают обработки несколько сигналов, то сигнал, который "
"получит B<sigwaitinfo>(), определяется согласно обычным правилам "
"очерёдности; подробней смотрите в B<signal>(7)."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:89
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which specifies the "
"interval for which the thread is suspended waiting for a signal.  (This "
"interval will be rounded up to the system clock granularity, and kernel "
"scheduling delays mean that the interval may overrun by a small amount.)  "
"This argument is of the following type:"
msgstr ""
"Системный вызов B<sigtimedwait>() работает аналогично B<sigwaitinfo>(), за "
"исключением того, что он имеет дополнительный аргумент I<timeout>, задающий "
"интервал,  на который приостанавливается процесс в ожидании сигнала. Данное "
"значение интервала будет округлено до точности системных часов, а из-за "
"задержки при планировании в ядре блокирующий интервал будет немного больше. "
"Этот аргумент имеет следующий тип:"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:96
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* секунды */\n"
"    long    tv_nsec;        /* наносекунды */\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:106
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr ""
"Если оба поля структуры равны 0, то исполняется опрос: B<sigtimedwait>() "
"немедленно завершает работу, либо с информацией о сигнале, предназначенном "
"вызывающему, либо с ошибкой, если ни один из сигналов в наборе I<set> не "
"ожидает обработки."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:115
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr ""
"При нормальном завершении работы B<sigwaitinfo>() и B<sigtimedwait>() "
"возвращают номер сигнала (т.е. значение больше нуля). При ошибках оба вызова "
"возвращают -1 и переменная I<errno> устанавливается соответственно ошибке."

#. type: TP
#: man-pages/man2/sigwaitinfo.2:116
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:124
msgid ""
"No signal in I<set> was became pending within the I<timeout> period "
"specified to B<sigtimedwait>()."
msgstr ""
"Ни одного сигнала в указанном наборе I<set> не появилось для обработки за "
"время I<timeout>, указанном для B<sigtimedwait>()."

#. type: TP
#: man-pages/man2/sigwaitinfo.2:124
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:130
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr ""
"Ожидание было прервано обработчиком сигнала; см. B<signal>(7). (Этот "
"обработчик был для другого сигнала, не из набора I<set>.)"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:134
msgid "I<timeout> was invalid."
msgstr "Значение I<timeout> некорректно. "

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:154
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they become pending between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for "
"these signals.  In a multithreaded program, the signal should be blocked in "
"all threads, in order to prevent the signal being treated according to its "
"default disposition in a thread other than the one calling B<sigwaitinfo>()  "
"or B<sigtimedwait>())."
msgstr ""
"При обычном использовании вызывающая программа блокирует сигналы в наборе "
"I<set> через предыдущий вызов B<sigprocmask>(2) (для того, чтобы не "
"сработали обработчики по умолчанию этих сигналов, если они появятся для "
"обработки между последующими вызовами B<sigwaitinfo>() или "
"B<sigtimedwait>()) и не устанавливает обработчики для этих сигналов. В "
"многонитевых программах сигнал должен быть заблокирован во всех нитях, чтобы "
"предотвратить возврат сигнала нити, отличной от той, которая вызвала "
"B<sigwaitinfo>() или B<sigtimedwait>())."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:159
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr ""
"Набор сигналов, ожидающих обработки в заданной нити, представляет собой "
"объединение набора сигналов, ожидающих обработки именно в этой нити и набора "
"сигналов, ожидающих обработки всем процессом (см. B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:165
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr "Попытки ожидания B<SIGKILL> и B<SIGSTOP> просто игнорируются."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:174
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it becomes pending for the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr ""
"Если несколько нитей процесса заблокированы в ожидании одного сигнала(ов) в "
"B<sigwaitinfo>() или B<sigtimedwait>(), то только одна нить действительно "
"получит сигнал, если он станет доступен для ожидания всему процессу; какая "
"именно нить примет сигнал неизвестно."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:186
msgid ""
"B<sigwaitinfo>()  or B<sigtimedwait>(), can't be used to receive signals "
"that are synchronously generated, such as the B<SIGSEGV> signal that results "
"from accessing an invalid memory address or the B<SIGFPE> signal that "
"results from an arithmetic error.  Such signals can be caught only via "
"signal handler."
msgstr ""
"Вызовы B<sigwaitinfo>() и B<sigtimedwait>() нельзя использовать для приёма "
"сигналов, генерируемых синхронно, например сигнала B<SIGSEGV> при доступе по "
"неправильному адресу памяти, или сигнала B<SIGFPE> при математических "
"ошибках. Такие сигналы можно поймать только через обработчик сигнала."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:196
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the "
"same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done "
"on Linux."
msgstr ""
"POSIX оставляет неопределённое значение NULL в аргументе I<timeout> для "
"B<sigtimedwait>(), допуская возможность того, что он имеет такое же "
"значение, как и у вызова B<sigwaitinfo>(), и в самом деле это именно так в "
"Linux."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:201
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr ""
"В Linux, B<sigwaitinfo>() реализована в виде библиотечной функции, "
"использующей B<sigtimedwait>()."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:211
msgid ""
"The glibc wrapper functions for B<sigwaitinfo>()  and B<sigtimedwait>()  "
"silently ignore attempts to wait for the two real-time signals that are used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""
"Обёрточные функции glibc для B<sigwaitinfo>() и B<sigtimedwait>() просто "
"игнорируют попытки ожидания двух сигналов реального времени, которые "
"используются внутри реализации NPTL. Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:238
msgid ""
"The original Linux system call was named B<sigtimedwait>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigtimedwait>(), was added "
"to support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  This argument is currently required to have the value "
"I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigtimedwait>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigtimedwait>()  when the kernel provides it."
msgstr ""
"Первоначально, системный вызов Linux назывался B<sigtimedwait>(). Однако, с "
"добавлением сигналов реального времени в Linux 2.2, 32-битный аргумент "
"I<sigset_t> неизменяемого размера, поддерживаемый этим системным вызовом, не "
"мог больше использоваться. В результате был добавлен новый системный вызов "
"B<rt_sigtimedwait>() с увеличенным типом I<sigset_t>. У нового системного "
"вызова появился четвёртый аргумент, I<size_t sigsetsize>, в котором "
"указывается размер (в байтах) набора сигналов I<set>. В настоящее время "
"значение этого аргумента должно быть равно I<sizeof(sigset_t)> (иначе "
"возникает ошибка B<EINVAL>). Обёрточная функция glibc B<sigtimedwait>() "
"скрывает это и вызывает B<rt_sigtimedwait>(), если он есть в ядре."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:249
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"

#. type: TH
#: man-pages/man2/syscall.2:42
#, no-wrap
msgid "SYSCALL"
msgstr "SYSCALL"

#. type: Plain text
#: man-pages/man2/syscall.2:45
msgid "syscall - indirect system call"
msgstr "syscall - непрямой системный вызов"

#. type: Plain text
#: man-pages/man2/syscall.2:50
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* For SYS_xxx definitions */\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* для определений SYS_xxx */\n"

#. type: Plain text
#: man-pages/man2/syscall.2:52
#, no-wrap
msgid "B<long syscall(long >I<number>B<, ...);>\n"
msgstr "B<long syscall(long >I<number>B<, ...);>\n"

#. type: Plain text
#: man-pages/man2/syscall.2:64
msgid ""
"B<syscall>()  is a small library function that invokes the system call whose "
"assembly language interface has the specified I<number> with the specified "
"arguments.  Employing B<syscall>()  is useful, for example, when invoking a "
"system call that has no wrapper function in the C library."
msgstr ""
"B<syscall>() — это маленькая библиотечная функция, которая делает системный "
"вызов, чей интерфейс ассемблерного языка  указывается в I<number>, с "
"дополнительными аргументами. Выполнение B<syscall>() нужно, например, для "
"запуска системного вызова, у которого нет обёрточной функции в библиотеке C."

#. type: Plain text
#: man-pages/man2/syscall.2:71
msgid ""
"B<syscall>()  saves CPU registers before making the system call, restores "
"the registers upon return from the system call, and stores any error code "
"returned by the system call in B<errno>(3)  if an error occurs."
msgstr ""
"При вызове B<syscall>() сохраняет регистры ЦП до выполнения системного "
"вызова, восстанавливает регистры при возврате из системного вызова и если "
"возникла ошибка, то сохраняет любой код, полученный от системного вызова, в "
"B<errno>(3)."

#. type: Plain text
#: man-pages/man2/syscall.2:74
msgid ""
"Symbolic constants for system call numbers can be found in the header file "
"I<E<lt>sys/syscall.hE<gt>>."
msgstr ""
"Символьные константы для системных вызовов можно найти в заголовочном файле "
"I<E<lt>sys/syscall.hE<gt>>."

#. type: Plain text
#: man-pages/man2/syscall.2:80
msgid ""
"The return value is defined by the system call being invoked.  In general, a "
"0 return value indicates success.  A -1 return value indicates an error, and "
"an error code is stored in I<errno>."
msgstr ""
"Возвращаемое значение определяется вызываемым системным вызовом. При "
"успешном выполнении обычно возвращается 0. При ошибке возвращается -1, при "
"этом код ошибки сохраняется в I<errno>."

#. type: Plain text
#: man-pages/man2/syscall.2:84
msgid "B<syscall>()  first appeared in 4BSD."
msgstr "Вызов B<syscall>() впервые появился в 4BSD."

#. type: SS
#: man-pages/man2/syscall.2:84
#, no-wrap
msgid "Architecture-specific requirements"
msgstr "Требования, зависящие от архитектуры"

#. type: Plain text
#: man-pages/man2/syscall.2:95
msgid ""
"Each architecture ABI has its own requirements on how system call arguments "
"are passed to the kernel.  For system calls that have a glibc wrapper (e.g., "
"most system calls), glibc handles the details of copying arguments to the "
"right registers in a manner suitable for the architecture.  However, when "
"using B<syscall>()  to make a system call, the caller might need to handle "
"architecture-dependent details; this requirement is most commonly "
"encountered on certain 32-bit architectures."
msgstr ""
"Каждый ABI архитектуры имеет свои собственные требования по передаче "
"аргументов системного вызова в ядро. Для системных вызовов, имеющих обёртку "
"в glibc (большинство системных вызовов), копирование аргументов в правильные "
"регистры с учётом архитектуры выполняется в самой glibc. Однако при "
"выполнении системного вызова через B<syscall>(), вызывающий сам должен "
"учитывать особенности архитектуры; чаще всего это относится к 32-битным "
"архитектурам."

#. type: Plain text
#: man-pages/man2/syscall.2:107
msgid ""
"For example, on the ARM architecture Embedded ABI (EABI), a 64-bit value (e."
"g., I<long long>)  must be aligned to an even register pair.  Thus, using "
"B<syscall>()  instead of the wrapper provided by glibc, the B<readahead>()  "
"system call would be invoked as follows on the ARM architecture with the "
"EABI in little endian mode:"
msgstr ""
"Например, на архитектуре ARM Embedded ABI (EABI) 64-битное значение (I<long "
"long>) должно быть выровнено по чётной паре регистров. То есть, при "
"использовании B<syscall>() вместо обёрточной функции glibc системный вызов "
"B<readahead>() на ARM вызывался бы с учётом EABI (режим с обратным порядком "
"байт) следующим образом:"

#. type: Plain text
#: man-pages/man2/syscall.2:114
#, no-wrap
msgid ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        count);\n"
msgstr ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        count);\n"

#. type: Plain text
#: man-pages/man2/syscall.2:130
msgid ""
"Since the offset argument is 64 bits, and the first argument (I<fd>)  is "
"passed in I<r0>, the caller must manually split and align the 64-bit value "
"so that it is passed in the I<r2>/I<r3> register pair.  That means inserting "
"a dummy value into I<r1> (the second argument of 0).  Care also must be "
"taken so that the split follows endian conventions (according to the C ABI "
"for the platform)."
msgstr ""
"Так как смещение аргумента 64 бита, и первый аргумент (I<fd>) передаётся в "
"регистре I<r0>, вызывающий должен разделить и выровнять 64-битное значение "
"так, чтобы оно передавалось в паре регистров I<r2>/I<r3>. Это выполняется "
"вставкой пустого значения в I<r1> (второго аргумент 0). Также нужно не "
"забывать о преобразовании порядка байт (в соответствии с C ABI платформы)."

#.  Mike Frysinger: this issue ends up forcing MIPS
#.  O32 to take 7 arguments to syscall()
#. type: Plain text
#: man-pages/man2/syscall.2:135
msgid ""
"Similar issues can occur on MIPS with the O32 ABI, on PowerPC and parisc "
"with the 32-bit ABI, and on Xtensa."
msgstr ""
"Подобные сложности можно видеть на MIPS с O32 ABI, на PowerPC и parisc с 32-"
"битным ABI и на Xtensa."

#.  See arch/parisc/kernel/sys_parisc.c.
#. type: Plain text
#: man-pages/man2/syscall.2:139
msgid ""
"Note that while the parisc C ABI also uses aligned register pairs, it uses a "
"shim layer to hide the issue from user space."
msgstr ""
"Заметим, что хотя в parisc C ABI также используется выравнивание пары "
"регистров, в нём используется слой shim, который прячет проблему от "
"пространства пользователя."

#. type: Plain text
#: man-pages/man2/syscall.2:150
msgid ""
"The affected system calls are B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), and B<truncate64>(2)."
msgstr ""
"Это относится к системным вызовам B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2) и B<truncate64>(2)."

#.  You need to look up the syscalls directly in the kernel source to see if
#.  they should be in this list.  For example, look at fs/read_write.c and
#.  the function signatures that do:
#.  ..., unsigned long, pos_l, unsigned long, pos_h, ...
#.  If they use off_t, then they most likely do not belong in this list.
#. type: Plain text
#: man-pages/man2/syscall.2:165
msgid ""
"This does not affect syscalls that manually split and assemble 64-bit values "
"such as B<_llseek>(2), B<preadv>(2), B<preadv2>(2), B<pwritev>(2), and "
"B<pwritev2>(2).  Welcome to the wonderful world of historical baggage."
msgstr ""
"Это не влияет на syscall-ы, который самостоятельно разделяют и собирают 64-"
"битные значения, например B<_llseek>(2), B<preadv>(2), B<preadv2>(2), "
"B<pwritev>(2) и B<pwritev2>(2). Добро пожаловать в чудесную страну "
"исторического наследия."

#. type: SS
#: man-pages/man2/syscall.2:165
#, no-wrap
msgid "Architecture calling conventions"
msgstr "Архитектурные соглашения по вызовам"

#. type: Plain text
#: man-pages/man2/syscall.2:169
msgid ""
"Every architecture has its own way of invoking and passing arguments to the "
"kernel.  The details for various architectures are listed in the two tables "
"below."
msgstr ""
"В каждой архитектуре есть собственный способ передачи аргументов вызову "
"ядра. Особенности различных архитектур перечислены в двух таблицах ниже."

#. type: Plain text
#: man-pages/man2/syscall.2:177
msgid ""
"The first table lists the instruction used to transition to kernel mode "
"(which might not be the fastest or best way to transition to the kernel, so "
"you might have to refer to B<vdso>(7)), the register used to indicate the "
"system call number, the register(s) used to return the system call result, "
"and the register used to signal an error."
msgstr ""
"Поля первой таблицы: инструкция для перехода в режим ядра (может быть не "
"быстрым или лучшим способом перехода в ядро, лучше использовать B<vdso>(7)), "
"регистр для указания номера системного вызова, регистр(ы) возврата "
"результата работы системного вызова и регистр сигнализации ошибки."

#. type: Plain text
#: man-pages/man2/syscall.2:180 man-pages/man2/syscall.2:306
msgid "CW<\\}>"
msgstr "CW<\\}>"

#. type: tbl table
#: man-pages/man2/syscall.2:182 man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<Arch/ABI>"
msgstr "CW<Арх/ABI>"

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "CW<Instruction>"
msgstr "CW<Инструкция>"

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "CW<System>"
msgstr "CW<Система>"

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "CW<Ret>"
msgstr "CW<Ret>"

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "CW<Error>"
msgstr "CW<Ошибка>"

#. type: tbl table
#: man-pages/man2/syscall.2:182 man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<Notes>"
msgstr "CW<замечания>"

#. type: tbl table
#: man-pages/man2/syscall.2:183
#, no-wrap
msgid "CW<call #>"
msgstr "CW<call #>"

#. type: tbl table
#: man-pages/man2/syscall.2:183
#, no-wrap
msgid "CW<val>"
msgstr "CW<знач>"

#. type: tbl table
#: man-pages/man2/syscall.2:183
#, no-wrap
msgid "CW<val2>"
msgstr "CW<знач2>"

#. type: tbl table
#: man-pages/man2/syscall.2:184 man-pages/man2/syscall.2:309
#, no-wrap
msgid "CW<_>"
msgstr "CW<_>"

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:310
#, no-wrap
msgid "CW<alpha>"
msgstr "CW<alpha>"

#. type: tbl table
#: man-pages/man2/syscall.2:185
#, no-wrap
msgid "CW<callsys>"
msgstr "CW<callsys>"

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:195
#, no-wrap
msgid "CW<v0>"
msgstr "CW<v0>"

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:310
#: man-pages/man2/syscall.2:312 man-pages/man2/syscall.2:321
#: man-pages/man2/syscall.2:325 man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<a4>"
msgstr "CW<a4>"

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:195
#: man-pages/man2/syscall.2:310 man-pages/man2/syscall.2:312
#: man-pages/man2/syscall.2:320 man-pages/man2/syscall.2:321
#: man-pages/man2/syscall.2:325 man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<a3>"
msgstr "CW<a3>"

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:192
#: man-pages/man2/syscall.2:195 man-pages/man2/syscall.2:203
#: man-pages/man2/syscall.2:204
#, no-wrap
msgid "CW<1, 6>"
msgstr "CW<1, 6>"

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:311
#, no-wrap
msgid "CW<arc>"
msgstr "CW<arc>"

#. type: tbl table
#: man-pages/man2/syscall.2:186
#, no-wrap
msgid "CW<trap0>"
msgstr "CW<trap0>"

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:192
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:322
#: man-pages/man2/syscall.2:324 man-pages/man2/syscall.2:332
#: man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<r8>"
msgstr "CW<r8>"

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:188
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:202
#: man-pages/man2/syscall.2:311 man-pages/man2/syscall.2:313
#: man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r0>"
msgstr "CW<r0>"

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:187
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:189
#: man-pages/man2/syscall.2:190 man-pages/man2/syscall.2:191
#: man-pages/man2/syscall.2:193 man-pages/man2/syscall.2:194
#: man-pages/man2/syscall.2:196 man-pages/man2/syscall.2:197
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:199
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:205
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:207
#: man-pages/man2/syscall.2:208 man-pages/man2/syscall.2:310
#: man-pages/man2/syscall.2:311 man-pages/man2/syscall.2:314
#: man-pages/man2/syscall.2:315 man-pages/man2/syscall.2:316
#: man-pages/man2/syscall.2:317 man-pages/man2/syscall.2:318
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:320
#: man-pages/man2/syscall.2:321 man-pages/man2/syscall.2:322
#: man-pages/man2/syscall.2:323 man-pages/man2/syscall.2:325
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#: man-pages/man2/syscall.2:331 man-pages/man2/syscall.2:332
#: man-pages/man2/syscall.2:333 man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<->"
msgstr "CW<->"

#. type: tbl table
#: man-pages/man2/syscall.2:187 man-pages/man2/syscall.2:312
#, no-wrap
msgid "CW<arm/OABI>"
msgstr "CW<arm/OABI>"

#. type: tbl table
#: man-pages/man2/syscall.2:187
#, no-wrap
msgid "CW<swi NR>"
msgstr "CW<swi NR>"

#. type: tbl table
#: man-pages/man2/syscall.2:187 man-pages/man2/syscall.2:199
#: man-pages/man2/syscall.2:310 man-pages/man2/syscall.2:312
#: man-pages/man2/syscall.2:320 man-pages/man2/syscall.2:321
#: man-pages/man2/syscall.2:325
#, no-wrap
msgid "CW<a1>"
msgstr "CW<a1>"

#. type: tbl table
#: man-pages/man2/syscall.2:187
#, no-wrap
msgid "CW<2>"
msgstr "CW<2>"

#. type: tbl table
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:313
#, no-wrap
msgid "CW<arm/EABI>"
msgstr "CW<arm/EABI>"

#. type: tbl table
#: man-pages/man2/syscall.2:188
#, no-wrap
msgid "CW<swi 0x0>"
msgstr "CW<swi 0x0>"

#. type: tbl table
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:196
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:322
#: man-pages/man2/syscall.2:324 man-pages/man2/syscall.2:326
#: man-pages/man2/syscall.2:327 man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r7>"
msgstr "CW<r7>"

#. type: tbl table
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:200
#: man-pages/man2/syscall.2:201 man-pages/man2/syscall.2:202
#: man-pages/man2/syscall.2:311 man-pages/man2/syscall.2:313
#: man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r1>"
msgstr "CW<r1>"

#. type: tbl table
#: man-pages/man2/syscall.2:189 man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<arm64>"
msgstr "CW<arm64>"

#. type: tbl table
#: man-pages/man2/syscall.2:189
#, no-wrap
msgid "CW<svc #0>"
msgstr "CW<svc #0>"

#. type: tbl table
#: man-pages/man2/syscall.2:189
#, no-wrap
msgid "CW<x8>"
msgstr "CW<x8>"

#. type: tbl table
#: man-pages/man2/syscall.2:189 man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<x0>"
msgstr "CW<x0>"

#. type: tbl table
#: man-pages/man2/syscall.2:189 man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<x1>"
msgstr "CW<x1>"

#. type: tbl table
#: man-pages/man2/syscall.2:190 man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<blackfin>"
msgstr "CW<blackfin>"

#. type: tbl table
#: man-pages/man2/syscall.2:190
#, no-wrap
msgid "CW<excpt 0x0>"
msgstr "CW<excpt 0x0>"

#. type: tbl table
#: man-pages/man2/syscall.2:190
#, no-wrap
msgid "CW<P0>"
msgstr "CW<P0>"

#. type: tbl table
#: man-pages/man2/syscall.2:190 man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<R0>"
msgstr "CW<R0>"

#. type: tbl table
#: man-pages/man2/syscall.2:191 man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<i386>"
msgstr "CW<i386>"

#. type: tbl table
#: man-pages/man2/syscall.2:191
#, no-wrap
msgid "CW<int $0x80>"
msgstr "CW<int $0x80>"

#. type: tbl table
#: man-pages/man2/syscall.2:191
#, no-wrap
msgid "CW<eax>"
msgstr "CW<eax>"

#. type: tbl table
#: man-pages/man2/syscall.2:191 man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<edx>"
msgstr "CW<edx>"

#. type: tbl table
#: man-pages/man2/syscall.2:192 man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<ia64>"
msgstr "CW<ia64>"

#. type: tbl table
#: man-pages/man2/syscall.2:192
#, no-wrap
msgid "CW<break 0x100000>"
msgstr "CW<break 0x100000>"

#. type: tbl table
#: man-pages/man2/syscall.2:192
#, no-wrap
msgid "CW<r15>"
msgstr "CW<r15>"

#. type: tbl table
#: man-pages/man2/syscall.2:192 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:322 man-pages/man2/syscall.2:324
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<r9>"
msgstr "CW<r9>"

#. type: tbl table
#: man-pages/man2/syscall.2:192 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<r10>"
msgstr "CW<r10>"

#. type: tbl table
#: man-pages/man2/syscall.2:193 man-pages/man2/syscall.2:318
#, no-wrap
msgid "CW<m68k>"
msgstr "CW<m68k>"

#. type: tbl table
#: man-pages/man2/syscall.2:193
#, no-wrap
msgid "CW<trap #0>"
msgstr "CW<trap #0>"

#. type: tbl table
#: man-pages/man2/syscall.2:193
#, no-wrap
msgid "CW<d0>"
msgstr "CW<d0>"

#. type: tbl table
#: man-pages/man2/syscall.2:194 man-pages/man2/syscall.2:319
#, no-wrap
msgid "CW<microblaze>"
msgstr "CW<microblaze>"

#. type: tbl table
#: man-pages/man2/syscall.2:194
#, no-wrap
msgid "CW<brki r14,8>"
msgstr "CW<brki r14,8>"

#. type: tbl table
#: man-pages/man2/syscall.2:194
#, no-wrap
msgid "CW<r12>"
msgstr "CW<r12>"

#. type: tbl table
#: man-pages/man2/syscall.2:194 man-pages/man2/syscall.2:198
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:311
#: man-pages/man2/syscall.2:313 man-pages/man2/syscall.2:324
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#, no-wrap
msgid "CW<r3>"
msgstr "CW<r3>"

#. type: tbl table
#: man-pages/man2/syscall.2:195
#, no-wrap
msgid "CW<mips>"
msgstr "CW<mips>"

#. type: tbl table
#: man-pages/man2/syscall.2:195 man-pages/man2/syscall.2:206
#: man-pages/man2/syscall.2:207 man-pages/man2/syscall.2:208
#, no-wrap
msgid "CW<syscall>"
msgstr "CW<syscall>"

#. type: tbl table
#: man-pages/man2/syscall.2:195 man-pages/man2/syscall.2:312
#, no-wrap
msgid "CW<v1>"
msgstr "CW<v1>"

#. type: tbl table
#: man-pages/man2/syscall.2:196 man-pages/man2/syscall.2:322
#, no-wrap
msgid "CW<nios2>"
msgstr "CW<nios2>"

#. type: tbl table
#: man-pages/man2/syscall.2:196
#, no-wrap
msgid "CW<trap>"
msgstr "CW<trap>"

#. type: tbl table
#: man-pages/man2/syscall.2:196 man-pages/man2/syscall.2:200
#: man-pages/man2/syscall.2:201 man-pages/man2/syscall.2:311
#: man-pages/man2/syscall.2:313 man-pages/man2/syscall.2:326
#: man-pages/man2/syscall.2:327 man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r2>"
msgstr "CW<r2>"

#. type: tbl table
#: man-pages/man2/syscall.2:197 man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<parisc>"
msgstr "CW<parisc>"

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "CW<ble 0x100(%sr2, %r0)>"
msgstr "CW<ble 0x100(%sr2, %r0)>"

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "CW<r20>"
msgstr "CW<r20>"

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "CW<r28>"
msgstr "CW<r28>"

#. type: tbl table
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:324
#, no-wrap
msgid "CW<powerpc>"
msgstr "CW<powerpc>"

#. type: tbl table
#: man-pages/man2/syscall.2:198
#, no-wrap
msgid "CW<sc>"
msgstr "CW<sc>"

#. type: tbl table
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:205
#: man-pages/man2/syscall.2:320
#, no-wrap
msgid "CW<1>"
msgstr "CW<1>"

#. type: tbl table
#: man-pages/man2/syscall.2:199 man-pages/man2/syscall.2:325
#, no-wrap
msgid "CW<riscv>"
msgstr "CW<riscv>"

#. type: tbl table
#: man-pages/man2/syscall.2:199
#, no-wrap
msgid "CW<scall>"
msgstr "CW<scall>"

#. type: tbl table
#: man-pages/man2/syscall.2:199
#, no-wrap
msgid "CW<a7>"
msgstr "CW<a7>"

#. type: tbl table
#: man-pages/man2/syscall.2:199 man-pages/man2/syscall.2:310
#: man-pages/man2/syscall.2:318 man-pages/man2/syscall.2:320
#: man-pages/man2/syscall.2:321 man-pages/man2/syscall.2:325
#, no-wrap
msgid "CW<a0>"
msgstr "CW<a0>"

#. type: tbl table
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:326
#, no-wrap
msgid "CW<s390>"
msgstr "CW<s390>"

#. type: tbl table
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:201
#, no-wrap
msgid "CW<svc 0>"
msgstr "CW<svc 0>"

#. type: tbl table
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:201
#, no-wrap
msgid "CW<3>"
msgstr "CW<3>"

#. type: tbl table
#: man-pages/man2/syscall.2:201 man-pages/man2/syscall.2:327
#, no-wrap
msgid "CW<s390x>"
msgstr "CW<s390x>"

#. type: tbl table
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<superh>"
msgstr "CW<superh>"

#. type: tbl table
#: man-pages/man2/syscall.2:202
#, no-wrap
msgid "CW<trap #0x17>"
msgstr "CW<trap #0x17>"

#. type: tbl table
#: man-pages/man2/syscall.2:202
#, no-wrap
msgid "CW<4, 6>"
msgstr "CW<4, 6>"

#. type: tbl table
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:329
#, no-wrap
msgid "CW<sparc/32>"
msgstr "CW<sparc/32>"

#. type: tbl table
#: man-pages/man2/syscall.2:203
#, no-wrap
msgid "CW<t 0x10>"
msgstr "CW<t 0x10>"

#. type: tbl table
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:204
#, no-wrap
msgid "CW<g1>"
msgstr "CW<g1>"

#. type: tbl table
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:204
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<o0>"
msgstr "CW<o0>"

#. type: tbl table
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:204
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<o1>"
msgstr "CW<o1>"

#. type: tbl table
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:204
#, no-wrap
msgid "CW<psr/csr>"
msgstr "CW<psr/csr>"

#. type: tbl table
#: man-pages/man2/syscall.2:204 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<sparc/64>"
msgstr "CW<sparc/64>"

#. type: tbl table
#: man-pages/man2/syscall.2:204
#, no-wrap
msgid "CW<t 0x6d>"
msgstr "CW<t 0x6d>"

#. type: tbl table
#: man-pages/man2/syscall.2:205 man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<tile>"
msgstr "CW<tile>"

#. type: tbl table
#: man-pages/man2/syscall.2:205
#, no-wrap
msgid "CW<swint1>"
msgstr "CW<swint1>"

#. type: tbl table
#: man-pages/man2/syscall.2:205
#, no-wrap
msgid "CW<R10>"
msgstr "CW<R10>"

#. type: tbl table
#: man-pages/man2/syscall.2:205 man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<R00>"
msgstr "CW<R00>"

#. type: tbl table
#: man-pages/man2/syscall.2:205 man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<R01>"
msgstr "CW<R01>"

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:332
#, no-wrap
msgid "CW<x86-64>"
msgstr "CW<x86-64>"

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:207
#, no-wrap
msgid "CW<rax>"
msgstr "CW<rax>"

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:207
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<rdx>"
msgstr "CW<rdx>"

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:207
#, no-wrap
msgid "CW<5>"
msgstr "CW<5>"

#. type: tbl table
#: man-pages/man2/syscall.2:207 man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<x32>"
msgstr "CW<x32>"

#. type: tbl table
#: man-pages/man2/syscall.2:208 man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<xtensa>"
msgstr "CW<xtensa>"

#. type: tbl table
#: man-pages/man2/syscall.2:208 man-pages/man2/syscall.2:310
#: man-pages/man2/syscall.2:312 man-pages/man2/syscall.2:320
#: man-pages/man2/syscall.2:321 man-pages/man2/syscall.2:325
#, no-wrap
msgid "CW<a2>"
msgstr "CW<a2>"

#. type: IP
#: man-pages/man2/syscall.2:212 man-pages/man2/syscall.2:338
#, no-wrap
msgid "[1]"
msgstr "[1]"

#. type: Plain text
#: man-pages/man2/syscall.2:223
msgid ""
"On a few architectures, a register is used as a boolean (0 indicating no "
"error, and -1 indicating an error) to signal that the system call failed.  "
"The actual error value is still contained in the return register.  On sparc, "
"the carry bit (I<csr>)  in the processor status register (I<psr>)  is used "
"instead of a full register."
msgstr ""
"На некоторых архитектурах для показа отказа системного вызова используется "
"регистр с простым логическим значением (0 — нет ошибки, -1 — ошибка). "
"Настоящее значение ошибки всё равно содержится в регистре возврата. На "
"sparc, вместо полного регистра используется бит переноса (I<csr>) в регистре "
"состояния процессора (I<psr>)."

#. type: IP
#: man-pages/man2/syscall.2:223
#, no-wrap
msgid "[2]"
msgstr "[2]"

#. type: Plain text
#: man-pages/man2/syscall.2:226
msgid "I<NR> is the system call number."
msgstr "I<NR> — номер системного вызова."

#. type: IP
#: man-pages/man2/syscall.2:226
#, no-wrap
msgid "[3]"
msgstr "[3]"

#. type: Plain text
#: man-pages/man2/syscall.2:232
msgid ""
"For s390 and s390x, I<NR> (the system call number) may be passed directly "
"with I<svc\\ NR> if it is less than 256."
msgstr ""
"Для s390 и s390x I<NR> (номер системного вызова) может передаваться напрямую "
"с помощью I<svc\\ NR>, если он меньше 256."

#. type: IP
#: man-pages/man2/syscall.2:232
#, no-wrap
msgid "[4]"
msgstr "[4]"

#. type: Plain text
#: man-pages/man2/syscall.2:242
msgid ""
"On SuperH, the trap number controls the maximum number of arguments passed.  "
"A I<trap\\ #0x10> can be used with only 0-argument system calls, a I<trap\\ "
"#0x11> can be used with 0- or 1-argument system calls, and so on up to "
"I<trap #0x17> for 7-argument system calls."
msgstr ""
"На SuperH, номер ловушки (trap number) контролирует максимальное количество "
"передаваемых аргументов.I<trap\\ #0x10> можно использовать только с "
"системными вызовами без аргументов, I<trap\\ #0x11> можно использовать "
"только с системными вызовами без или с одним аргументом и так далее до "
"I<trap #0x17> (7 аргументов в системном вызове)."

#. type: IP
#: man-pages/man2/syscall.2:242
#, no-wrap
msgid "[5]"
msgstr "[5]"

#. type: Plain text
#: man-pages/man2/syscall.2:245
msgid ""
"The x32 ABI shares syscall table with x86-64 ABI, but there are some nuances:"
msgstr ""
"Для x32 ABI используется общая с x86-64 ABI таблица syscall, но есть "
"несколько отличий:"

#. type: Plain text
#: man-pages/man2/syscall.2:253
msgid ""
"In order to indicate that a system call is called under the x32 ABI, an "
"additional bit, B<__X32_SYSCALL_BIT>, is bitwise-ORed with the system call "
"number.  The ABI used by a process affects some process behaviors, including "
"signal handling or system call restarting."
msgstr ""
"Чтобы показать, что системный вызов запрошен из x32 ABI, "
"введёндополнительный бит I<__X32_SYSCALL_BIT>, который побитно складывается "
"с номером системного вызова. ABI, используемый процессом, частично влияет на "
"поведение процесса, включая обработку сигналов или перезапуск или системного "
"вызова."

#. type: Plain text
#: man-pages/man2/syscall.2:281
msgid ""
"Since x32 has different sizes for I<long> and pointer types, layouts of some "
"(but not all; I<struct timeval> or I<struct rlimit> are 64-bit, for example) "
"structures are different.  In order to handle this, additional system calls "
"are added to the system call table, starting from number 512 (without the "
"B<__X32_SYSCALL_BIT>).  For example, B<__NR_readv> is defined as 19 for the "
"x86-64 ABI and as I<__X32_SYSCALL_BIT> | B<515> for the x32 ABI.  Most of "
"these additional system calls are actually identical to the system calls "
"used for providing i386 compat.  There are some notable exceptions, however, "
"such as B<preadv2>(2), which uses I<struct iovec> entities with 4-byte "
"pointers and sizes (\"compat_iovec\" in kernel terms), but passes an 8-byte "
"I<pos> argument in a single register and not two, as is done in every other "
"ABI."
msgstr ""
"Так как на x32 размеры типа I<long> и указателя различаются, то различны "
"раскладки некоторых (но не всех; например, I<struct timeval> или I<struct "
"rlimit> 64-битные) структур. Для их обработки в таблицу системных вызовов "
"добавлены дополнительные системные вызовы; они начинаются с номера 512 (без "
"B<__X32_SYSCALL_BIT>). Например, B<__NR_readv> определён как 19 в x86-64 ABI "
"и как I<__X32_SYSCALL_BIT> | B<515> в x32 ABI. Большинство этих "
"дополнительных системных вызовов на самом деле одинаковы с системными "
"вызовами, используемыми для предоставления совместимости с i386. Однако есть "
"исключения, например, B<preadv2>(2), который использует элементы I<struct "
"iovec> с 4-байтовыми указателями и размерами (в терминах ядра — "
"«compat_iovec»), но передаёт 8-байтовый аргумент I<pos> в одном регистре, а "
"не в двух, как это делается в других ABI."

#. type: IP
#: man-pages/man2/syscall.2:282
#, no-wrap
msgid "[6]"
msgstr "[6]"

#. type: Plain text
#: man-pages/man2/syscall.2:297
msgid ""
"Some architectures (namely, Alpha, IA-64, MIPS, SuperH, sparc/32, and "
"sparc/64)  use an additional register (\"Retval2\" in the above table)  to "
"pass back a second return value from the B<pipe>(2)  system call; Alpha uses "
"this technique in the architecture-specific B<getxpid>(2), B<getxuid>(2), "
"and B<getxgid>(2)  system calls as well.  Other architectures do not use the "
"second return value register in the system call interface, even if it is "
"defined in the System V ABI."
msgstr ""
"Некоторые архитектуры (Alpha, IA-64, MIPS, SuperH, sparc/32 sparc/64) "
"используют дополнительный регистр (\"Retval2\" в таблице выше) для обратной "
"передачи второго возвращаемого значения из системного вызова B<pipe>(2); в "
"Alpha это также используется в зависимых от архитектуры системных вызовах "
"B<getxpid>(2), B<getxuid>(2) и B<getxgid>(2). На других архитектурах в "
"интерфейсе системных вызовов второй регистр для возвращаемого значения не "
"используется, даже если он определён в System V ABI."

#. type: Plain text
#: man-pages/man2/syscall.2:301 man-pages/man2/syscall.2:345
msgid "\\}"
msgstr "\\}"

#. type: Plain text
#: man-pages/man2/syscall.2:303
msgid ""
"The second table shows the registers used to pass the system call arguments."
msgstr ""
"Во второй таблице показаны регистры, которые используются для передачи "
"аргументов в системный вызов."

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg1>"
msgstr "CW<арг1>"

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg2>"
msgstr "CW<арг2>"

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg3>"
msgstr "CW<арг3>"

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg4>"
msgstr "CW<арг4>"

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg5>"
msgstr "CW<арг5>"

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg6>"
msgstr "CW<арг6>"

#. type: tbl table
#: man-pages/man2/syscall.2:308
#, no-wrap
msgid "CW<arg7>"
msgstr "CW<арг7>"

#. type: tbl table
#: man-pages/man2/syscall.2:310 man-pages/man2/syscall.2:321
#: man-pages/man2/syscall.2:325 man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<a5>"
msgstr "CW<a5>"

#. type: tbl table
#: man-pages/man2/syscall.2:311 man-pages/man2/syscall.2:313
#: man-pages/man2/syscall.2:322 man-pages/man2/syscall.2:324
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r4>"
msgstr "CW<r4>"

#. type: tbl table
#: man-pages/man2/syscall.2:311 man-pages/man2/syscall.2:313
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:322
#: man-pages/man2/syscall.2:324 man-pages/man2/syscall.2:326
#: man-pages/man2/syscall.2:327 man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r5>"
msgstr "CW<r5>"

#. type: tbl table
#: man-pages/man2/syscall.2:312
#, no-wrap
msgid "CW<v2>"
msgstr "CW<v2>"

#. type: tbl table
#: man-pages/man2/syscall.2:312
#, no-wrap
msgid "CW<v3>"
msgstr "CW<v3>"

#. type: tbl table
#: man-pages/man2/syscall.2:313 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:322 man-pages/man2/syscall.2:324
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:328
#, no-wrap
msgid "CW<r6>"
msgstr "CW<r6>"

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<x2>"
msgstr "CW<x2>"

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<x3>"
msgstr "CW<x3>"

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<x4>"
msgstr "CW<x4>"

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "CW<x5>"
msgstr "CW<x5>"

#. type: tbl table
#: man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<R1>"
msgstr "CW<R1>"

#. type: tbl table
#: man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<R2>"
msgstr "CW<R2>"

#. type: tbl table
#: man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<R3>"
msgstr "CW<R3>"

#. type: tbl table
#: man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<R4>"
msgstr "CW<R4>"

#. type: tbl table
#: man-pages/man2/syscall.2:315
#, no-wrap
msgid "CW<R5>"
msgstr "CW<R5>"

#. type: tbl table
#: man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<ebx>"
msgstr "CW<ebx>"

#. type: tbl table
#: man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<ecx>"
msgstr "CW<ecx>"

#. type: tbl table
#: man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<esi>"
msgstr "CW<esi>"

#. type: tbl table
#: man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<edi>"
msgstr "CW<edi>"

#. type: tbl table
#: man-pages/man2/syscall.2:316
#, no-wrap
msgid "CW<ebp>"
msgstr "CW<ebp>"

#. type: tbl table
#: man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<out0>"
msgstr "CW<out0>"

#. type: tbl table
#: man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<out1>"
msgstr "CW<out1>"

#. type: tbl table
#: man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<out2>"
msgstr "CW<out2>"

#. type: tbl table
#: man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<out3>"
msgstr "CW<out3>"

#. type: tbl table
#: man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<out4>"
msgstr "CW<out4>"

#. type: tbl table
#: man-pages/man2/syscall.2:317
#, no-wrap
msgid "CW<out5>"
msgstr "CW<out5>"

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "CW<d1>"
msgstr "CW<d1>"

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "CW<d2>"
msgstr "CW<d2>"

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "CW<d3>"
msgstr "CW<d3>"

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "CW<d4>"
msgstr "CW<d4>"

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "CW<d5>"
msgstr "CW<d5>"

#. type: tbl table
#: man-pages/man2/syscall.2:320
#, no-wrap
msgid "CW<mips/o32>"
msgstr "CW<mips/o32>"

#. type: tbl table
#: man-pages/man2/syscall.2:321
#, no-wrap
msgid "CW<mips/n32,64>"
msgstr "CW<mips/n32,64>"

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<r26>"
msgstr "CW<r26>"

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<r25>"
msgstr "CW<r25>"

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<r24>"
msgstr "CW<r24>"

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<r23>"
msgstr "CW<r23>"

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<r22>"
msgstr "CW<r22>"

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "CW<r21>"
msgstr "CW<r21>"

#. type: tbl table
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<o2>"
msgstr "CW<o2>"

#. type: tbl table
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<o3>"
msgstr "CW<o3>"

#. type: tbl table
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<o4>"
msgstr "CW<o4>"

#. type: tbl table
#: man-pages/man2/syscall.2:329 man-pages/man2/syscall.2:330
#, no-wrap
msgid "CW<o5>"
msgstr "CW<o5>"

#. type: tbl table
#: man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<R02>"
msgstr "CW<R02>"

#. type: tbl table
#: man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<R03>"
msgstr "CW<R03>"

#. type: tbl table
#: man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<R04>"
msgstr "CW<R04>"

#. type: tbl table
#: man-pages/man2/syscall.2:331
#, no-wrap
msgid "CW<R05>"
msgstr "CW<R05>"

#. type: tbl table
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<rdi>"
msgstr "CW<rdi>"

#. type: tbl table
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:333
#, no-wrap
msgid "CW<rsi>"
msgstr "CW<rsi>"

#. type: tbl table
#: man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<a6>"
msgstr "CW<a6>"

#. type: tbl table
#: man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<a8>"
msgstr "CW<a8>"

#. type: tbl table
#: man-pages/man2/syscall.2:334
#, no-wrap
msgid "CW<a9>"
msgstr "CW<a9>"

#. type: Plain text
#: man-pages/man2/syscall.2:341
msgid ""
"The mips/o32 system call convention passes arguments 5 through 8 on the user "
"stack."
msgstr ""
"По соглашению в mips/o32 аргументы системных вызовов с 5 по 8 передаются "
"через пользовательский стек."

#. type: Plain text
#: man-pages/man2/syscall.2:348
msgid ""
"Note that these tables don't cover the entire calling convention\\(emsome "
"architectures may indiscriminately clobber other registers not listed here."
msgstr ""
"Заметим, что эти таблицы не описывают полное соглашение о вызове — некоторые "
"архитектуры могут затирать другие регистры и это здесь не описано."

#. type: Plain text
#: man-pages/man2/syscall.2:355
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/syscall.2:360
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"

#. type: Plain text
#: man-pages/man2/syscall.2:364
#, no-wrap
msgid ""
"    tid = syscall(SYS_gettid);\n"
"    syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"
msgstr ""
"    tid = syscall(SYS_gettid);\n"
"    syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/syscall.2:370
msgid "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<errno>(3), B<vdso>(7)"
msgstr "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<errno>(3), B<vdso>(7)"

#. type: TH
#: man-pages/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr "SCHED_SETAFFINITY"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity "
"mask"
msgstr ""
"sched_setaffinity, sched_getaffinity - устанавливает и получает процессорную "
"маску увязывания для нити"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:63
msgid ""
"A thread's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular thread (i.e., setting the affinity mask of that thread "
"to specify a single CPU, and setting the affinity mask of all other threads "
"to exclude that CPU), it is possible to ensure maximum execution speed for "
"that thread.  Restricting a thread to run on a single CPU also avoids the "
"performance cost caused by the cache invalidation that occurs when a thread "
"ceases to execute on one CPU and then recommences execution on a different "
"CPU."
msgstr ""
"Процессорной маской увязывания нити задаётся набор процессоров, на которых "
"разрешено выполняться нити. В многопроцессорных системах задание "
"процессорной маски увязывания можно использовать для получения большей "
"производительности. Например, выделение специального процессора определённой "
"нити (т.е., задание в процессорной маске увязывания для нити одного ЦП и "
"исключение этого ЦП из процессорных масок увязывания для остальных нитей) "
"обеспечивает максимальную скорость выполнения этой нити. Ограничение для "
"нити одним ЦП также исключает сокращение производительности в следствие "
"недостоверности данных кэша, которая возникает, когда нить прекращает "
"выполнение на одном ЦП и затем продолжает выполнение на другом."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU set"
"\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""
"Маска увязывания ЦП представляется в виде структуры I<cpu_set_t>, «набором "
"процессоров», на которую указывает I<mask>. В B<CPU_SET>(3) описаны макросы "
"для изменения набора ЦП."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the thread whose ID is "
"I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling thread is used.  The argument I<cpusetsize> is the length (in bytes) "
"of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""
"Вызов B<sched_setaffinity>() устанавливает маску увязывания ЦП I<mask> для "
"нити, чей ID указан в I<pid>. Если значение I<pid> равно нулю, то "
"используется вызывающая нить. В аргументе I<cpusetsize> задаётся количество "
"данных (в байтах), на которые указывает I<mask>. Обычно его значение "
"указывается как I<sizeof(cpu_set_t)>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:92
msgid ""
"If the thread specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that thread is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""
"Если нить, указанная в I<pid>, в данный момент не выполняется на одном из "
"ЦП, заданном в I<mask>, то эта нить переносится на один из процессоров, "
"назначаемых I<mask>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the thread whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling thread is returned."
msgstr ""
"Вызов B<sched_getaffinity>() записывает в структуру I<cpu_set_t>, на которую "
"указывает I<mask>, значение маски увязывания ЦП для нити, чей ID указан в "
"I<pid>. В аргументе I<cpusetsize> задаётся размер I<mask> (в байтах). Если "
"значение I<pid> равно нулю, то возвращается маска вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:116
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sched_setaffinity>() и B<sched_getaffinity>() "
"возвращают 0. В случае ошибки возвращается -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:120
msgid "A supplied memory address was invalid."
msgstr "Указан некорректный адрес памяти."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:130
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the thread according to any "
"restrictions that may be imposed by I<cpuset> cgroups or the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""
"В маске увязывания ЦП I<mask> указаны процессоры, которых физически нет в "
"системе, и которые разрешены нити согласно любым ограничениям, которые могут "
"налагаться I<cpuset> cgroups или механизмом «cpuset», описанном в "
"B<cpuset>(7)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:137
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""
"(B<sched_getaffinity>() и, в ядрах до 2.6.9, B<sched_setaffinity>()) "
"Значение I<cpusetsize> меньше размера маски увязывания, используемой в ядре."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:148
msgid ""
"(B<sched_setaffinity>())  The calling thread does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the thread identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability in the user namespace of the thread I<pid>."
msgstr ""
"(B<sched_setaffinity>()) Вызывающая нить не имеет достаточно прав. "
"Вызывающему требуется иметь эффективный пользовательский ID равный реальному "
"пользовательскому ID или эффективному пользовательскому ID нити, указанной в "
"I<pid>, или он должен обладать мандатом B<CAP_SYS_NICE> в пространстве имён "
"пользователя нити I<pid>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:162
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""
"Системные вызовы увязывания ЦП появились в ядре Linux версии 2.5.8. "
"Обёрточные функции появились в glibc 2.3. Первоначально, в интерфейсе glibc "
"присутствовал аргумент I<cpusetsize>, имевший тип I<unsigned int>. В glibc "
"2.3.3 аргумент I<cpusetsize> был удалён, но появился вновь в glibc 2.3.4 с "
"типом I<size_t>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:164
msgid "These system calls are Linux-specific."
msgstr "Данные системные вызовы есть только в Linux."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:177
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the thread "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the thread runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the thread will run are silently imposed by "
"the kernel."
msgstr ""
"После вызова B<sched_setaffinity>() набор процессоров, на которых "
"действительно будет выполняться нить, вычисляется пересечением набора из "
"аргумента I<mask> и набором процессоров, присутствующих в системе. В "
"дальнейшем, система может ограничить набор процессоров нити, если "
"задействован механизм «cpuset», описанный в B<cpuset>(7). Эти ограничения на "
"действительный набор процессоров, используемых для нити, без уведомления "
"налагаются ядром."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:189
msgid ""
"There are various ways of determining the number of CPUs available on the "
"system, including: inspecting the contents of I</proc/cpuinfo>; using "
"B<sysconf>(3)  to obtain the values of the B<_SC_NPROCESSORS_CONF> and "
"B<_SC_NPROCESSORS_ONLN> parameters; and inspecting the list of CPU "
"directories under I</sys/devices/system/cpu/>."
msgstr ""
"Есть несколько способов определения количества процессоров в системе: по "
"содержимому I</proc/cpuinfo>; с помощью B<sysconf>(3) получить значение "
"параметров B<_SC_NPROCESSORS_CONF> и B<_SC_NPROCESSORS_ONLN>; посчитать "
"количество подкаталогов cpu в I</sys/devices/system/cpu/>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:192
msgid "B<sched>(7)  has a description of the Linux scheduling scheme."
msgstr "В B<sched>(7) приведено описание схемы планирования Linux."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:209
msgid ""
"The affinity mask is a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""
"Маска увязывания является атрибутом нити, которая может изменяться "
"независимо для каждой нити в группе нитей. В аргументе I<pid> можно "
"передавать значение, возвращаемое вызовом B<gettid>(2). При значении I<pid> "
"равным 0 будет установлен атрибут вызывающей нити, а при передаче значения, "
"возвращаемого вызовом B<getpid>(2), устанавливается атрибут главной нити "
"группы нитей (при работе с программным интерфейсом POSIX используйте функцию "
"B<pthread_setaffinity_np>(3) вместо B<sched_setaffinity>()). "

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:227
msgid ""
"The I<isolcpus> boot option can be used to isolate one or more CPUs at boot "
"time, so that no processes are scheduled onto those CPUs.  Following the use "
"of this boot option, the only way to schedule processes onto the isolated "
"CPUs is via B<sched_setaffinity>()  or the B<cpuset>(7)  mechanism.  For "
"further information, see the kernel source file I<Documentation/admin-guide/"
"kernel-parameters.txt>.  As noted in that file, I<isolcpus> is the preferred "
"mechanism of isolating CPUs (versus the alternative of manually setting the "
"CPU affinity of all processes on the system)."
msgstr ""
"Параметр начальной загрузки I<isolcpus> можно использовать для изоляции "
"одного и более ЦП во время загрузки, и ни один процесс не будет запланирован "
"к выполнению на этих ЦП. После использования этого параметра единственный "
"способ запланировать процессы на изолированных ЦП — использовать "
"B<sched_setaffinity>()  или механизм B<cpuset>(7). Подробности смотрите в "
"файле исходного кода ядра I<Documentation/admin-guide/kernel-parameters."
"txt>. Согласно тексту файла, I<isolcpus> является предпочтительным "
"механизмом изоляции ЦП (по сравнению с ручным увязыванием ЦП всех процессов "
"в системе)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:233
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""
"Потомок, создаваемый с помощью B<fork>(2), наследует маску увязывания ЦП. "
"Маска увязывания сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:241
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:253
msgid ""
"On success, the raw B<sched_getaffinity>()  system call returns the number "
"of bytes placed copied into the I<mask> buffer; this will be the minimum of "
"I<cpusetsize> and the size (in bytes) of the I<cpumask_t> data type that is "
"used internally by the kernel to represent the CPU set bit mask."
msgstr ""

#. type: SS
#: man-pages/man2/sched_setaffinity.2:253
#, no-wrap
msgid "Handling systems with large CPU affinity masks"
msgstr "Работа систем с масками увязывания ЦП большого размера"

#.  FIXME . See https://sourceware.org/bugzilla/show_bug.cgi?id=15630
#.  and https://sourceware.org/ml/libc-alpha/2013-07/msg00288.html
#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:265
msgid ""
"The underlying system calls (which represent CPU masks as bit masks of type "
"I<unsigned long\\ *>)  impose no restriction on the size of the CPU mask.  "
"However, the I<cpu_set_t> data type used by glibc has a fixed size of 128 "
"bytes, meaning that the maximum CPU number that can be represented is 1023.  "
"If the kernel CPU affinity mask is larger than 1024, then calls of the form:"
msgstr ""
"Лежащие в основе системные вызовы (которые представляют маски ЦП в виде "
"маски битов с типом I<unsigned long\\ *>) не накладывают ограничений на "
"размер маски ЦП. Однако, тип данных I<cpu_set_t>, используемый в glibc, "
"имеет постоянный размер 128 байт, то есть максимальный номер представляемых "
"ЦП равен 1023. Если ядерная маска увязывания ЦП больше 1024, то вызовы вида:"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:267
#, no-wrap
msgid "    sched_getaffinity(pid, sizeof(cpu_set_t), &mask);\n"
msgstr "    sched_getaffinity(pid, sizeof(cpu_set_t), &mask);\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:277
msgid ""
"fail with the error B<EINVAL>, the error produced by the underlying system "
"call for the case where the I<mask> size specified in I<cpusetsize> is "
"smaller than the size of the affinity mask used by the kernel.  (Depending "
"on the system CPU topology, the kernel affinity mask can be substantially "
"larger than the number of active CPUs in the system.)"
msgstr ""
"завершается ошибкой B<EINVAL>; ошибка выдаётся подлежащим системным вызовом "
"в случае, когда размер I<mask>, указанный в I<cpusetsize>, меньше чем размер "
"маски увязывания используемой ядром (в зависимости от топологии ЦП системы, "
"ядерная маска увязывания может быть значительно больше, чем количество "
"активных ЦП в системе)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:288
msgid ""
"When working on systems with large kernel CPU affinity masks, one must "
"dynamically allocate the I<mask> argument (see B<CPU_ALLOC>(3)).  Currently, "
"the only way to do this is by probing for the size of the required mask "
"using B<sched_getaffinity>()  calls with increasing mask sizes (until the "
"call does not fail with the error B<EINVAL>)."
msgstr ""
"При работе в системах с ядерными масками увязывания ЦП большого размера, "
"место под аргумент I<mask> должно выделяться динамически (смотрите "
"B<CPU_ALLOC>(3)). В настоящее время единственный способ сделать это — "
"определить размер требуемой маски с помощью вызовов B<sched_getaffinity>() с "
"увеличиваемым размером маски (пока вызов не перестанет выдавать ошибку "
"B<EINVAL>)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:303
msgid ""
"Be aware that B<CPU_ALLOC>(3)  may allocate a slightly larger CPU set than "
"requested (because CPU sets are implemented as bit masks allocated in units "
"of I<sizeof(long)>).  Consequently, B<sched_getaffinity>()  can set bits "
"beyond the requested allocation size, because the kernel sees a few "
"additional bits.  Therefore, the caller should iterate over the bits in the "
"returned set, counting those which are set, and stop upon reaching the value "
"returned by B<CPU_COUNT>(3)  (rather than iterating over the number of bits "
"requested to be allocated)."
msgstr ""
"Учтите, что B<CPU_ALLOC>(3) может выделить несколько больший набор ЦП, чем "
"запрашивается (так как наборы ЦП реализованы как битовые маски, выделяемые в "
"объёмах I<sizeof(long)>). Следовательно, B<sched_getaffinity>() может задать "
"биты за границами запрашиваемого выделяемого размера, так как ядро видит "
"несколько дополнительных бит. Поэтому вызывающий должен пройтись по всем "
"возвращённым битам, считая установленные и остановиться при достижении "
"значения, полученного от B<CPU_COUNT>(3) (а не останавливаться на количестве "
"запрошенных к выделению бит)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:312
msgid ""
"The program below creates a child process.  The parent and child then each "
"assign themselves to a specified CPU and execute identical loops that "
"consume some CPU time.  Before terminating, the parent waits for the child "
"to complete.  The program takes three command-line arguments: the CPU number "
"for the parent, the CPU number for the child, and the number of loop "
"iterations that both processes should perform."
msgstr ""
"Программа, представленная ниже, создаёт дочерний процесс. Затем родитель и "
"потомок назначают выполнение себя на указанных ЦП и выполняют одинаковые "
"циклы, которые выполняются на ЦП какое-то время. Перед завершением, родитель "
"ждёт завершения потомка. Программа имеет три аргумента командной строки: "
"номер ЦП для родителя, номер ЦП для потомка и количество итераций цикла, "
"который будут выполнять оба процесса."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:316
msgid ""
"As the sample runs below demonstrate, the amount of real and CPU time "
"consumed when running the program will depend on intra-core caching effects "
"and whether the processes are using the same CPU."
msgstr ""
"В примере работы, показанном ниже, количество реального времени и времени "
"использованного ЦП при работе программы, будет зависеть он меж ядерного "
"кэширования и будут ли процессы использовать одинаковый ЦП."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:321
msgid ""
"We first employ B<lscpu>(1)  to determine that this (x86)  system has two "
"cores, each with two CPUs:"
msgstr ""
"Сначала запустим B<lscpu>(1) для определения, что эта система (x86) имеет по "
"два потока выполнения в двух ЦП:"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:328
#, no-wrap
msgid ""
"$ B<lscpu | egrep -i 'core.*:|socket'>\n"
"Thread(s) per core:    2\n"
"Core(s) per socket:    2\n"
"Socket(s):             1\n"
msgstr ""
"$ B<lscpu | egrep -i 'core.*:|socket'>\n"
"Thread(s) per core:    2\n"
"Core(s) per socket:    2\n"
"Socket(s):             1\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:335
msgid ""
"We then time the operation of the example program for three cases: both "
"processes running on the same CPU; both processes running on different CPUs "
"on the same core; and both processes running on different CPUs on different "
"cores."
msgstr ""
"Затем запустим подсчёт времени выполнения программы для трёх случаев: оба "
"процесс выполняются на одном ЦП; оба процесса выполняются на разных ЦП "
"одного ядра; оба процесса выполняются на разных ЦП разных ядер."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:350
#, no-wrap
msgid ""
"$ B<time -p ./a.out 0 0 100000000>\n"
"real 14.75\n"
"user 3.02\n"
"sys 11.73\n"
"$ B<time -p ./a.out 0 1 100000000>\n"
"real 11.52\n"
"user 3.98\n"
"sys 19.06\n"
"$ B<time -p ./a.out 0 3 100000000>\n"
"real 7.89\n"
"user 3.29\n"
"sys 12.07\n"
msgstr ""
"$ B<time -p ./a.out 0 0 100000000>\n"
"real 14.75\n"
"user 3.02\n"
"sys 11.73\n"
"$ B<time -p ./a.out 0 1 100000000>\n"
"real 11.52\n"
"user 3.98\n"
"sys 19.06\n"
"$ B<time -p ./a.out 0 3 100000000>\n"
"real 7.89\n"
"user 3.29\n"
"sys 12.07\n"

#. type: SS
#: man-pages/man2/sched_setaffinity.2:352
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:361
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:364
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:371
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t set;\n"
"    int parentCPU, childCPU;\n"
"    int nloops, j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t set;\n"
"    int parentCPU, childCPU;\n"
"    int nloops, j;\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:377
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s parent-cpu child-cpu num-loops\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Использование: %s parent-cpu child-cpu num-loops\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:381
#, no-wrap
msgid ""
"    parentCPU = atoi(argv[1]);\n"
"    childCPU = atoi(argv[2]);\n"
"    nloops = atoi(argv[3]);\n"
msgstr ""
"    parentCPU = atoi(argv[1]);\n"
"    childCPU = atoi(argv[2]);\n"
"    nloops = atoi(argv[3]);\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:383
#, no-wrap
msgid "    CPU_ZERO(&set);\n"
msgstr "    CPU_ZERO(&set);\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:387
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:            /* Error */\n"
"        errExit(\"fork\");\n"
msgstr ""
"    switch (fork()) {\n"
"    case -1:            /* Ошибка */\n"
"        errExit(\"fork\");\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:390
#, no-wrap
msgid ""
"    case 0:             /* Child */\n"
"        CPU_SET(childCPU, &set);\n"
msgstr ""
"    case 0:             /* потомок */\n"
"        CPU_SET(childCPU, &set);\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:393
#: man-pages/man2/sched_setaffinity.2:404
#, no-wrap
msgid ""
"        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)\n"
"            errExit(\"sched_setaffinity\");\n"
msgstr ""
"        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)\n"
"            errExit(\"sched_setaffinity\");\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:396
#: man-pages/man2/sched_setaffinity.2:407
#, no-wrap
msgid ""
"        for (j = 0; j E<lt> nloops; j++)\n"
"            getppid();\n"
msgstr ""
"        for (j = 0; j E<lt> nloops; j++)\n"
"            getppid();\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:398
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr "        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:401
#, no-wrap
msgid ""
"    default:            /* Parent */\n"
"        CPU_SET(parentCPU, &set);\n"
msgstr ""
"    default:            /* родитель */\n"
"        CPU_SET(parentCPU, &set);\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:412
#, no-wrap
msgid ""
"        wait(NULL);     /* Wait for child to terminate */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"        wait(NULL);     /* ждём завершения потомка */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:436
msgid ""
"B<lscpu>(1), B<nproc>(1), B<taskset>(1), B<clone>(2), B<getcpu>(2), "
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getscheduler>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), "
"B<get_nprocs>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7), B<numactl>(8)"
msgstr ""
"B<lscpu>(1), B<nproc>(1), B<taskset>(1), B<clone>(2), B<getcpu>(2), "
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getscheduler>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), "
"B<get_nprocs>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7), B<numactl>(8)"

#. type: TH
#: man-pages/man2/sgetmask.2:26
#, no-wrap
msgid "SGETMASK"
msgstr "SGETMASK"

#. type: Plain text
#: man-pages/man2/sgetmask.2:29
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr "sgetmask, ssetmask - работа с маской сигналов (устарел)"

#. type: Plain text
#: man-pages/man2/sgetmask.2:31
msgid "B<long sgetmask(void);>"
msgstr "B<long sgetmask(void);>"

#. type: Plain text
#: man-pages/man2/sgetmask.2:33
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr "B<long ssetmask(long >I<newmask>B<);>"

#. type: Plain text
#: man-pages/man2/sgetmask.2:42
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)  "
"instead."
msgstr ""
"Данные системные вызовы устарели. Используйте вместо них B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:45
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr "Вызов B<sgetmask>() возвращает маску сигналов вызывающего процесса."

#. type: Plain text
#: man-pages/man2/sgetmask.2:50
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr ""
"Вызов B<ssetmask>() устанавливает маску сигналов вызывающего процесса равной "
"значению, указанному в I<newmask>. Возвращается предыдущее значение маски "
"сигналов."

#. type: Plain text
#: man-pages/man2/sgetmask.2:59
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr ""
"Маски сигналов обрабатываются этими системными вызовами как простые битовые "
"маски (в отличие от I<sigset_t>, который используется в B<sigprocmask>(2)); "
"для создания и проверки масок используйте B<sigmask>(3)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:64
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr ""
"Вызов B<sgetmask>() всегда выполняется успешно и возвращает маску сигналов. "
"Вызов B<ssetmask>() всегда выполняется успешно и возвращает предыдущее "
"значение маски сигналов."

#. type: Plain text
#: man-pages/man2/sgetmask.2:66
msgid "These system calls always succeed."
msgstr "Данные системные вызовы всегда выполняются без ошибок."

#.  f6187769dae48234f3877df3c4d99294cc2254fa
#. type: Plain text
#: man-pages/man2/sgetmask.2:73
msgid ""
"Since Linux 3.16, support for these system calls is optional, depending on "
"whether the kernel was built with the B<CONFIG_SGETMASK_SYSCALL> option."
msgstr ""
"Начиная с Linux 3.16 поддержка данных системных вызовов необязательна, она "
"зависит от того, собрано ли ядро с параметром B<CONFIG_SGETMASK_SYSCALL>."

#. type: Plain text
#: man-pages/man2/sgetmask.2:79
msgid ""
"Glibc does not provide wrappers for these obsolete system calls; in the "
"unlikely event that you want to call them, use B<syscall>(2)."
msgstr ""
"В glibc нет обёрток для этих устаревших системных вызовов; вызывайте их "
"через B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:82
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., real-"
"time signals)."
msgstr ""
"Данные системные вызовы ничего не знают о номерах сигналов больше 31 (т.е. "
"сигналах реального времени)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:84
msgid "These system calls do not exist on x86-64."
msgstr "Данные системные вызовы не существуют на x86-64."

#. type: Plain text
#: man-pages/man2/sgetmask.2:89
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr "Они не могут заблокировать B<SIGSTOP> или B<SIGKILL>."

#. type: Plain text
#: man-pages/man2/sgetmask.2:91
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr "B<sigprocmask>(2), B<signal>(7)"

#. type: TH
#: man-pages/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr "SHMGET"

#. type: Plain text
#: man-pages/man2/shmget.2:41
msgid "shmget - allocates a System V shared memory segment"
msgstr "shmget - выделяет общий сегмент памяти System V"

#. type: Plain text
#: man-pages/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"

#. type: Plain text
#: man-pages/man2/shmget.2:62
msgid ""
"B<shmget>()  returns the identifier of the System\\ V shared memory segment "
"associated with the value of the argument I<key>.  It may be used either to "
"obtain the identifier of a previously created shared memory segment (when "
"I<shmflg> is zero and I<key> does not have the value B<IPC_PRIVATE>), or to "
"create a new set."
msgstr ""
"Вызов B<shmget>() возвращает идентификатор общего сегмента памяти System\\ "
"V, соответствующего значению аргумента I<key>. Его можно использовать для "
"получения идентификатора ранее созданного общего сегмента памяти (когда "
"I<shmflg> равно нулю и I<key> не содержит значения B<IPC_PRIVATE>) или для "
"создания нового."

#. type: Plain text
#: man-pages/man2/shmget.2:81
msgid ""
"A new shared memory segment, with size equal to the value of I<size> rounded "
"up to a multiple of B<PAGE_SIZE>, is created if I<key> has the value "
"B<IPC_PRIVATE> or I<key> isn't B<IPC_PRIVATE>, no shared memory segment "
"corresponding to I<key> exists, and B<IPC_CREAT> is specified in I<shmflg>."
msgstr ""
"Новый общий сегмент памяти размером I<size>, округлённым до значения, "
"кратного B<PAGE_SIZE> создаётся, если значение I<key> равно B<IPC_PRIVATE> "
"или, если I<key> не равно B<IPC_PRIVATE>, но не существует общего сегмента "
"памяти, который бы соответствовал значению I<key> и в I<shmflg> есть флаг "
"B<IPC_CREAT>."

#. type: Plain text
#: man-pages/man2/shmget.2:100
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""
"Если в I<shmflg> одновременно указаны B<IPC_CREAT> и B<IPC_EXCL> и для "
"значения I<key> уже существует общий сегмент памяти, то вызов B<shmget>() "
"завершается с ошибкой и I<errno> присваивается B<EEXIST> (такой же результат "
"как с B<O_CREAT | O_EXCL> у B<open>(2))."

#. type: Plain text
#: man-pages/man2/shmget.2:104
msgid "The value I<shmflg> is composed of:"
msgstr "Значение I<shmflg> составляется из следующих флагов:"

#. type: Plain text
#: man-pages/man2/shmget.2:111
msgid ""
"Create a new segment.  If this flag is not used, then B<shmget>()  will find "
"the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""
"Служит для создания нового сегмента. Если этого флага нет, то вызов "
"B<shmget>() будет искать сегмент, соответствующий I<key>, и затем проверит, "
"имеет ли пользователь права на доступ к сегменту."

#. type: Plain text
#: man-pages/man2/shmget.2:117
msgid ""
"This flag is used with B<IPC_CREAT> to ensure that this call creates the "
"segment.  If the segment already exists, the call fails."
msgstr ""
"Этот флаг используется совместно с B<IPC_CREAT> для того, чтобы этот вызов "
"создал сегмент. Если сегмент уже существует, то вызов завершается с ошибкой."

#. type: TP
#: man-pages/man2/shmget.2:117
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr "B<SHM_HUGETLB> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man2/shmget.2:123
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information."
msgstr ""
"Выделять сегмент используя «огромные страницы». Дополнительную информацию "
"смотрите в файле исходного кода ядра Linux I<Documentation/admin-guide/mm/"
"hugetlbpage.rst>."

#. type: TP
#: man-pages/man2/shmget.2:123
#, no-wrap
msgid "B<SHM_HUGE_2MB>, B<SHM_HUGE_1GB> (since Linux 3.8)"
msgstr "B<SHM_HUGE_2MB>, B<SHM_HUGE_1GB> (начиная с Linux 3.8)"

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: man-pages/man2/shmget.2:130
msgid ""
"Used in conjunction with B<SHM_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""
"Используется вместе с B<SHM_HUGETLB> для выбора других размеров страниц "
"hugetlb (2\\ МБ и 1\\ МБ, соответственно) в системах, которые поддерживают "
"несколько размеров страниц hugetlb."

#. type: Plain text
#: man-pages/man2/shmget.2:135
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<SHM_HUGE_SHIFT>.  Thus, the above two constants are defined as:"
msgstr ""
"Вообще, желаемые размер огромной страницы можно настроить закодировав "
"логарифмом по основанию 2 желаемый размер страницы в шести битах смещения "
"B<SHM_HUGE_SHIFT>. Таким образом, приведённые выше константы определяются "
"так:"

#. type: Plain text
#: man-pages/man2/shmget.2:140
#, no-wrap
msgid ""
"#define SHM_HUGE_2MB    (21 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
"#define SHM_HUGE_1GB    (30 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
msgstr ""
"#define SHM_HUGE_2MB    (21 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
"#define SHM_HUGE_1GB    (30 E<lt>E<lt> SHM_HUGE_SHIFT)\n"

#. type: Plain text
#: man-pages/man2/shmget.2:146
msgid ""
"For some additional details, see the discussion of the similarly named "
"constants in B<mmap>(2)."
msgstr ""
"Дополнительную информацию о схожих по имени константах смотрите в B<mmap>(2)."

#. type: TP
#: man-pages/man2/shmget.2:146
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr "B<SHM_NORESERVE> (начиная с Linux 2.6.15)"

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: man-pages/man2/shmget.2:165
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5)."
msgstr ""
"Этот флаг нужен для того же, что и флаг B<MAP_NORESERVE> у B<mmap>(2). Он "
"указывает не резервировать место в пространстве подкачки для этого сегмента. "
"Операцией резервирования места в пространстве подкачки гарантируется, что "
"сегмент можно изменить. Если место не резервировать, то при записи можно "
"получить сигнал B<SIGSEGV>, если кончится физическая память. Смотрите также "
"обсуждение файла I</proc/sys/vm/overcommit_memory> в B<proc>(5)."

#. type: Plain text
#: man-pages/man2/shmget.2:175
msgid ""
"In addition to the above flags, the least significant 9 bits of I<shmflg> "
"specify the permissions granted to the owner, group, and others.  These bits "
"have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2).  Presently, execute permissions are not used by the system."
msgstr ""
"В дополнении к перечисленным выше флагам в младших 9 битах I<shmflg> "
"задаются права для владельца, группы и всех остальных. Формат значения битов "
"совпадает с аргументом I<mode> вызова B<open>(2). В данный момент бит "
"выполнения системой не используются."

#. type: Plain text
#: man-pages/man2/shmget.2:183
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr ""
"Если создаётся новый общий сегмент памяти, то его содержимое "
"инициализируется нулями, а соответствующая ему структура данных I<shmid_ds> "
"(см. B<shmctl>(2)) следующим образом:"

#. type: Plain text
#: man-pages/man2/shmget.2:188
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"Полям I<shm_perm.cuid> и I<shm_perm.uid> присваиваются значения эффективного "
"идентификатора пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/shmget.2:193
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"Полям I<shm_perm.cgid> и I<shm_perm.gid> присваиваются значения эффективного "
"идентификатора группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/shmget.2:198
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""
"Младшим 9 битам I<shm_perm.mode> присваивается значение младших 9 бит "
"I<shmflg>."

#. type: Plain text
#: man-pages/man2/shmget.2:202
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr "Полю I<shm_segsz> присваивается значение I<size>."

#. type: Plain text
#: man-pages/man2/shmget.2:209
msgid ""
"I<shm_lpid>, I<shm_nattch>, I<shm_atime>, and I<shm_dtime> are set to 0."
msgstr ""
"Полям I<shm_lpid>, I<shm_nattch>, I<shm_atime> и I<shm_dtime> присваивается "
"значение 0."

#. type: Plain text
#: man-pages/man2/shmget.2:212
msgid "I<shm_ctime> is set to the current time."
msgstr "Полю I<shm_ctime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/shmget.2:215
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""
"Если общий сегмент памяти уже существует, то проверяются права доступа к "
"нему и не помечен ли он для удаления."

#. type: Plain text
#: man-pages/man2/shmget.2:220
msgid ""
"On success, a valid shared memory identifier is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении возвращается корректный идентификатор общей памяти. "
"При ошибке возвращается -1, а в I<errno> записывается причина ошибки."

#. type: Plain text
#: man-pages/man2/shmget.2:224
msgid "On failure, I<errno> is set to one of the following:"
msgstr ""
"В случае возникновения ошибки I<errno> может принимать следующие значения:"

#. type: Plain text
#: man-pages/man2/shmget.2:230
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""
"Пользователь не имеет прав доступа к общему сегменту памяти и не имеет "
"мандата B<CAP_IPC_OWNER> в пространстве имён пользователя, который управляет "
"его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/shmget.2:239
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<shmflg>, but a shared "
"memory segment already exists for I<key>."
msgstr ""
"В I<shmflg> указаны B<IPC_CREAT> и B<IPC_EXCL>, но общий сегмент памяти уже "
"существует для I<key>."

#. type: Plain text
#: man-pages/man2/shmget.2:247
msgid ""
"A new segment was to be created and I<size> is less than B<SHMMIN> or "
"greater than B<SHMMAX>."
msgstr ""
"Был создан новый сегмент и I<size> меньше B<SHMMIN> или больше B<SHMMAX>."

#. type: Plain text
#: man-pages/man2/shmget.2:253
msgid ""
"A segment for the given I<key> exists, but I<size> is greater than the size "
"of that segment."
msgstr ""
"Сегмент для заданного I<key> существует, но I<size> больше размера этого "
"сегмента."

#. type: TP
#: man-pages/man2/shmget.2:253
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#. type: Plain text
#: man-pages/man2/shmget.2:257
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: Plain text
#: man-pages/man2/shmget.2:262
msgid ""
"No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr "Не существует сегмента для ключа I<key> и флаг B<IPC_CREAT> не указан."

#. type: Plain text
#: man-pages/man2/shmget.2:265
msgid "No memory could be allocated for segment overhead."
msgstr "Не хватает памяти для выделения под перерасход сегмента."

#. type: Plain text
#: man-pages/man2/shmget.2:273
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the system-"
"wide limit on shared memory (B<SHMALL>)."
msgstr ""
"Все возможные идентификаторы сегментов уже распределены (B<SHMMNI>) или "
"размер выделяемого сегмента превысит системные лимиты по общей памяти "
"(B<SHMALL>)."

#. type: Plain text
#: man-pages/man2/shmget.2:280
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""
"Указан флаг B<SHM_HUGETLB>, но у вызывающего нет прав (нет мандата "
"B<CAP_IPC_LOCK>)."

#. type: Plain text
#: man-pages/man2/shmget.2:288
msgid "B<SHM_HUGETLB> and B<SHM_NORESERVE> are Linux extensions."
msgstr "B<SHM_HUGETLB> и B<SHM_NORESERVE> являются расширениями Linux."

#. type: Plain text
#: man-pages/man2/shmget.2:312
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment."
msgstr ""
"B<IPC_PRIVATE> — не поле флага, а тип I<key_t>. Если I<key> равно этому "
"специальному значению, то системный вызов игнорирует всё кроме 9-ти младших "
"битов I<shmflg> и создаёт новый общий сегмент памяти."

#. type: SS
#: man-pages/man2/shmget.2:312
#, no-wrap
msgid "Shared memory limits"
msgstr "Ограничения общей памяти"

#. type: Plain text
#: man-pages/man2/shmget.2:316
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr ""
"Ниже приведены ограничения ресурсов на общий сегмент памяти, влияющие на "
"вызов B<shmget>():"

#. type: TP
#: man-pages/man2/shmget.2:316
#, no-wrap
msgid "B<SHMALL>"
msgstr "B<SHMALL>"

#. type: Plain text
#: man-pages/man2/shmget.2:320
msgid ""
"System-wide limit on the total amount of shared memory, measured in units of "
"the system page size."
msgstr ""
"Системный лимит на полный объём общей памяти, измеряется в единицах, равных "
"размеру системной страницы."

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: man-pages/man2/shmget.2:326
msgid ""
"On Linux, this limit can be read and modified via I</proc/sys/kernel/"
"shmall>.  Since Linux 3.16, the default value for this limit is:"
msgstr ""
"В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/"
"shmmni>. Начиная с 3.16, значение по умолчанию равно:"

#. type: Plain text
#: man-pages/man2/shmget.2:328 man-pages/man2/shmget.2:363
#, no-wrap
msgid "    ULONG_MAX - 2^24\n"
msgstr "    ULONG_MAX - 2^24\n"

#. type: Plain text
#: man-pages/man2/shmget.2:339
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  This value, rather "
"than B<ULONG_MAX>, was chosen as the default to prevent some cases where "
"historical applications simply raised the existing limit without first "
"checking its current value.  Such applications would cause the value to "
"overflow if the limit was set at B<ULONG_MAX>."
msgstr ""
"Эффект этого значения (которое подходит и для 32-разрядной, и для 64-"
"разрядной системы) — не задать ограничение на выделения. Это значение, в "
"отличии от  B<ULONG_MAX>, было выбрано в качестве значения по умолчанию, "
"чтобы предотвратить некоторые случаи, когда старые приложения просто "
"увеличивают существующий предел без начальной проверки его текущего "
"значения. Такие приложения переполнили бы значение, если предел был равен "
"B<ULONG_MAX>."

#. type: Plain text
#: man-pages/man2/shmget.2:342
msgid "From Linux 2.4 up to Linux 3.15, the default value for this limit was:"
msgstr ""
"В Linux 2.4 по Linux 3.15 значение по умолчанию этого ограничения было:"

#. type: Plain text
#: man-pages/man2/shmget.2:344
#, no-wrap
msgid "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"
msgstr "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"

#. type: Plain text
#: man-pages/man2/shmget.2:352
msgid ""
"If B<SHMMAX> and B<SHMMNI> were not modified, then multiplying the result of "
"this formula by the page size (to get a value in bytes) yielded a value of "
"8\\ GB as the limit on the total memory used by all shared memory segments."
msgstr ""
"Если B<SHMMAX> и B<SHMMNI> не изменены, то умножение результата этой формулы "
"на размер страницы (для получения значения в байтах) даёт значение 8\\ ГБ — "
"ограничение на общее количество памяти, используемой во всех общих сегментах "
"памяти."

#. type: TP
#: man-pages/man2/shmget.2:352
#, no-wrap
msgid "B<SHMMAX>"
msgstr "B<SHMMAX>"

#. type: Plain text
#: man-pages/man2/shmget.2:355
msgid "Maximum size in bytes for a shared memory segment."
msgstr "Максимальный размер общего сегмента памяти в байтах."

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: man-pages/man2/shmget.2:361
msgid ""
"On Linux, this limit can be read and modified via I</proc/sys/kernel/"
"shmmax>.  Since Linux 3.16, the default value for this limit is:"
msgstr ""
"В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/"
"shmmax>. Начиная с 3.16, значение по умолчанию равно:"

#. type: Plain text
#: man-pages/man2/shmget.2:372
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  See the description of "
"B<SHMALL> for a discussion of why this default value (rather than "
"B<ULONG_MAX>)  is used."
msgstr ""
"Эффект этого значения (которое подходит и для 32-разрядной, и для 64-"
"разрядной системы) — не задать ограничение на выделения. Смотрите описание "
"B<SHMALL> о том, почему используется именно такое значение по умолчанию (а "
"не B<ULONG_MAX>)."

#. type: Plain text
#: man-pages/man2/shmget.2:375
msgid ""
"From Linux 2.2 up to Linux 3.15, the default value of this limit was "
"0x2000000 (32\\ MB)."
msgstr ""
"В Linux 2.2 по Linux 3.15 значение по умолчанию этого ограничения равно "
"0x2000000 (32\\ МБ)."

#. type: Plain text
#: man-pages/man2/shmget.2:381
msgid ""
"Because it is not possible to map just part of a shared memory segment, the "
"amount of virtual memory places another limit on the maximum size of a "
"usable segment: for example, on i386 the largest segments that can be mapped "
"have a size of around 2.8\\ GB, and on x86-64 the limit is around 127 TB."
msgstr ""
"Так как невозможно отобразить только часть общего сегмента памяти, размер "
"виртуальной памяти отличается от ограничения на максимальный размер "
"подходящего сегмента: например, на i386 самые большие сегменты, которые "
"можно отображать, имеют размер около 2.8\\ ГБ, а на x86-64 — около 127\\ ТБ."

#. type: TP
#: man-pages/man2/shmget.2:381
#, no-wrap
msgid "B<SHMMIN>"
msgstr "B<SHMMIN>"

#. type: Plain text
#: man-pages/man2/shmget.2:387
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""
"Минимальный размер общего сегмента памяти в байтах в системе: зависит от "
"реализации (в настоящий момент равно 1 байту, хотя на самом деле минимальный "
"выделяемый размер равен B<PAGE_SIZE>)."

#. type: TP
#: man-pages/man2/shmget.2:387
#, no-wrap
msgid "B<SHMMNI>"
msgstr "B<SHMMNI>"

#. type: Plain text
#: man-pages/man2/shmget.2:392
msgid ""
"System-wide limit on the number of shared memory segments.  In Linux 2.2, "
"the default value for this limit was 128; since Linux 2.4, the default value "
"is 4096."
msgstr ""
"Системный лимит на общее количество общих сегментов памяти. Начиная с Linux "
"2.2, значение по умолчанию равно 128; начиная с Linux 2.4, значение по "
"умолчанию равно 4096."

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/shmget.2:398
msgid ""
"On Linux, this limit can be read and modified via I</proc/sys/kernel/shmmni>."
msgstr ""
"В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/"
"shmmni>."

#. type: Plain text
#: man-pages/man2/shmget.2:402
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""
"Реализацией не ограничивается максимальное количество общих сегментов памяти "
"на процесс (B<SHMSEG>)."

#. type: SS
#: man-pages/man2/shmget.2:402
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#. type: Plain text
#: man-pages/man2/shmget.2:408
msgid ""
"Until version 2.3.30, Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""
"В Linux до версии 2.3.30 вызов B<shmget>() возвращал значение B<EIDRM>, если "
"общий сегмент памяти был запланирован к удалению."

#. type: Plain text
#: man-pages/man2/shmget.2:422
msgid ""
"B<memfd_create>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), "
"B<capabilities>(7), B<shm_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setresuid.2:27
#, no-wrap
msgid "SETRESUID"
msgstr "SETRESUID"

#. type: Plain text
#: man-pages/man2/setresuid.2:30
msgid "setresuid, setresgid - set real, effective and saved user or group ID"
msgstr ""
"setresuid, setresgid - устанавливает  реальный, эффективный и сохранённый "
"пользовательский идентификатор или идентификатор группы"

#. type: Plain text
#: man-pages/man2/setresuid.2:32
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man2/setresuid.2:36
msgid "B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"
msgstr ""
"B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"

#. type: Plain text
#: man-pages/man2/setresuid.2:38
msgid "B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"
msgstr ""
"B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"

#. type: Plain text
#: man-pages/man2/setresuid.2:42
msgid ""
"B<setresuid>()  sets the real user ID, the effective user ID, and the saved "
"set-user-ID of the calling process."
msgstr ""
"Вызов B<setresuid>() устанавливает реальный идентификатор пользователя, "
"эффективный идентификатор пользователя и сохранённый идентификатор "
"пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setresuid.2:47
msgid ""
"An unprivileged process may change its real UID, effective UID, and saved "
"set-user-ID, each to one of: the current real UID, the current effective UID "
"or the current saved set-user-ID."
msgstr ""
"Непривилегированный процесс может изменять реальный UID, эффективный UID и "
"сохранённый set-user-ID на соответственно текущий реальный UID, текущий  UID "
"и текущий сохранённый set-user-ID."

#. type: Plain text
#: man-pages/man2/setresuid.2:51
msgid ""
"A privileged process (on Linux, one having the B<CAP_SETUID> capability)  "
"may set its real UID, effective UID, and saved set-user-ID to arbitrary "
"values."
msgstr ""
"Привилегированный процесс (в Linux: имеющие мандат B<CAP_SETUID>) могут "
"устанавливать произвольные значения для реального, эффективного UID и "
"сохранённого set-user-UID ."

#. type: Plain text
#: man-pages/man2/setresuid.2:53
msgid ""
"If one of the arguments equals -1, the corresponding value is not changed."
msgstr ""
"Если один из параметров равен -1, то соответствующее ему значение не "
"изменяется."

#. type: Plain text
#: man-pages/man2/setresuid.2:57
msgid ""
"Regardless of what changes are made to the real UID, effective UID, and "
"saved set-user-ID, the filesystem UID is always set to the same value as the "
"(possibly new) effective UID."
msgstr ""
"Независимо от того, как изменились реальный UID, эффективный UID и "
"сохранённый UID идентификатор в файловой системе всегда устанавливается "
"равным значению (возможно новому) эффективного UID."

#. type: Plain text
#: man-pages/man2/setresuid.2:64
msgid ""
"Completely analogously, B<setresgid>()  sets the real GID, effective GID, "
"and saved set-group-ID of the calling process (and always modifies the "
"filesystem GID to be the same as the effective GID), with the same "
"restrictions for unprivileged processes."
msgstr ""
"Аналогично, B<setresgid>() устанавливает реальный GID, эффективный GID, и "
"сохранённый GID вызывающего процесса (и всегда изменяет GID в файловой "
"системе на значение эффективного GID) с теми же ограничениями для "
"непривилегированных процессов."

#. type: Plain text
#: man-pages/man2/setresuid.2:76
msgid ""
"I<Note>: there are cases where B<setresuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setresuid>()."
msgstr ""
"I<Замечание>: есть случаи, когда B<setresuid>() может завершиться с ошибкой "
"даже когда UID вызывающего равен 0; это серьёзная ошибка безопасности — не "
"проверять возвращаемое значение B<setresuid>()."

#. type: Plain text
#: man-pages/man2/setresuid.2:84
msgid ""
"The call would change the caller's real UID (i.e., I<ruid> does not match "
"the caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""
"Вызов изменил бы настоящего реальный UID вызывающего (т. е. I<ruid> не "
"совпадает с реальным UID вызывающего), но возникла временная ошибка при "
"выделении памяти под необходимые структуры ядра."

#. type: Plain text
#: man-pages/man2/setresuid.2:99
msgid ""
"I<ruid> does not match the caller's real UID and this call would bring the "
"number of processes belonging to the real user ID I<ruid> over the caller's "
"B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case no longer "
"occurs (but robust applications should check for this error); see the "
"description of B<EAGAIN> in B<execve>(2)."
msgstr ""
"Значение I<ruid> не совпадает с реальным UID вызывающего и этот вызов создал "
"был превышение количества процессов, принадлежащих пользователю с реальным "
"ID I<ruid> сверх ограничителя ресурсы B<RLIMIT_NPROC> вызывающего. Начиная с "
"Linux 3.1 эта ошибка больше не возникает (но корректное приложение должно "
"проверять эту ошибку); смотрите описание B<EAGAIN> в B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setresuid.2:103
msgid ""
"One or more of the target user or group IDs is not valid in this user "
"namespace."
msgstr ""
"Один или более целевых идентификаторов пользователя или группы некорректны в "
"этом пользовательском пространстве имён."

#. type: Plain text
#: man-pages/man2/setresuid.2:116
msgid ""
"The calling process is not privileged (did not have the necessary capability "
"in its user namespace)  and tried to change the IDs to values that are not "
"permitted.  For B<setresuid>(), the necessary capability is B<CAP_SETUID>; "
"for B<setresgid>(), it is B<CAP_SETGID>."
msgstr ""
"Вызывающий процесс не является привилегированным (не имеет необходимого "
"мандата в своём пространстве имён пользователя) и пытается изменить значения "
"идентификаторов, что запрещено. Для B<setresuid>() необходим мандат "
"B<CAP_SETUID>; для B<setresgid>() — B<CAP_SETGID>."

#. type: Plain text
#: man-pages/man2/setresuid.2:118
msgid "These calls are available under Linux since Linux 2.1.44."
msgstr "Данные вызовы доступны в Linux начиная с версии 2.1.44."

#. type: Plain text
#: man-pages/man2/setresuid.2:121
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr "Это нестандартные вызовы; также они есть в HP-UX и некоторых BSD."

#. type: Plain text
#: man-pages/man2/setresuid.2:125
msgid ""
"Under HP-UX and FreeBSD, the prototype is found in I<E<lt>unistd.hE<gt>>.  "
"Under Linux, the prototype is provided by glibc since version 2.3.2."
msgstr ""
"В HP-UX и FreeBSD прототип находится в I<E<lt>unistd.hE<gt>>. В Linux "
"прототип задан в glibc, начиная с версии 2.3.2."

#. type: Plain text
#: man-pages/man2/setresuid.2:142
msgid ""
"The original Linux B<setresuid>()  and B<setresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setresuid32>()  and B<setresgid32>(), supporting 32-bit IDs.  The glibc "
"B<setresuid>()  and B<setresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""
"Первоначальные версии системных вызовов B<setresuid>() и B<setresgid>() в "
"Linux поддерживали только 16-битные идентификаторы пользователей и групп. "
"Позднее в Linux 2.4 были добавлены вызовы B<setresuid32>() и "
"B<setresgid32>(), поддерживающие 32-битные идентификаторы. В glibc "
"обёрточные функции B<setresuid>() и B<setresgid>() работают одинаково вне "
"зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/setresuid.2:158
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setresuid>()  and B<setresgid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""
"На уровне ядра ID пользователя и группы являются атрибутами нити. Однако в "
"POSIX требуется, чтобы все нити в процессе имели одинаковые права. В "
"реализации нитей NPTL требования POSIX реализованы через обёрточные функции "
"для различных системных вызовов, которые изменяют UID и GID процесса. В этих "
"функциях (включая и  B<setresuid>() and B<setresgid>()) используется "
"алгоритмы на основе сигналов, которые следят за тем, что когда у одной нити "
"изменяются права, эти изменения выполняются и для остальных нитей процесса. "
"Подробное описание смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/setresuid.2:167
msgid ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), "
"B<user_namespaces>(7)"
msgstr ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), "
"B<user_namespaces>(7)"

#. type: TH
#: man-pages/man2/sigprocmask.2:29
#, no-wrap
msgid "SIGPROCMASK"
msgstr "SIGPROCMASK"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:32
msgid "sigprocmask, rt_sigprocmask - examine and change blocked signals"
msgstr "sigprocmask, rt_sigprocmask - проверка и изменение блокировки сигналов"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:38
#, no-wrap
msgid ""
"/* Prototype for the glibc wrapper function */\n"
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"
msgstr ""
"/* Прототип обёрточной функции glibc */\n"
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:42
#, no-wrap
msgid ""
"/* Prototype for the underlying system call */\n"
"B<int rt_sigprocmask(int >I<how>B<, const kernel_sigset_t *>I<set>B<,>\n"
"B<                   kernel_sigset_t *>I<oldset>B<, size_t >I<sigsetsize>B<);>\n"
msgstr ""
"/* Прототип используемого системного вызова */\n"
"B<int rt_sigprocmask(int >I<how>B<, const kernel_sigset_t *>I<set>B<,>\n"
"B<                   kernel_sigset_t *>I<oldset>B<, size_t >I<sigsetsize>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:46
#, no-wrap
msgid ""
"/* Prototype for the legacy system call (deprecated) */\n"
"B<int sigprocmask(int >I<how>B<, const old_kernel_sigset_t *>I<set>B<,>\n"
"B<                old_kernel_sigset_t *>I<oldset>B<);>\n"
msgstr ""
"/* Прототип устаревшего системного вызова */\n"
"B<int sigprocmask(int >I<how>B<, const old_kernel_sigset_t *>I<set>B<,>\n"
"B<                old_kernel_sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:56
msgid "B<sigprocmask>(): _POSIX_C_SOURCE"
msgstr "B<sigprocmask>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:65
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr ""
"Вызов B<sigprocmask>() используется для выборки и/или изменения маски "
"сигналов вызывающей нити. Маска сигналов представляет собой набор сигналов, "
"чья доставка в настоящее время заблокирована вызывающим (подробнее об этом "
"смотрите также в B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:69
msgid ""
"The behavior of the call is dependent on the value of I<how>, as follows."
msgstr "Работа вызова зависит от значения I<how>:"

#. type: TP
#: man-pages/man2/sigprocmask.2:69
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr "B<SIG_BLOCK>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:74
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr ""
"Набор блокируемых сигналов — объединение текущего набора и аргумента I<set>."

#. type: TP
#: man-pages/man2/sigprocmask.2:74
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr "B<SIG_UNBLOCK>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:80
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr ""
"Сигналы в I<set> удаляются из списка блокируемых сигналов. Допускается "
"разблокировать незаблокированные сигналы."

#. type: TP
#: man-pages/man2/sigprocmask.2:80
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr "B<SIG_SETMASK>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:84
msgid "The set of blocked signals is set to the argument I<set>."
msgstr "Набор блокируемых сигналов приравнивается к аргументу I<set>."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:89
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in "
"I<oldset>."
msgstr ""
"Если значение I<oldset> не равно NULL, то предыдущее значение маски сигналов "
"записывается в I<oldset>."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:98
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr ""
"Если значение I<set> равно NULL, то маска сигналов не изменяется (т.е., "
"значение I<how> игнорируется), но текущее значение маски сигналов всё же "
"возвращается в I<oldset> (если его значение не равно NULL)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:103
msgid ""
"A set of functions for modifying and inspecting variables of type "
"I<sigset_t> (\"signal sets\") is described in B<sigsetops>(3)."
msgstr ""
"Функции для изменения и получения переменных с типом  I<sigset_t> («наборы "
"сигналов») описаны в B<sigsetops>(3)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:108
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr ""
"Использование B<sigprocmask>() в многонитевых процессах не определено; "
"смотрите B<pthread_sigmask>(3)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:114
msgid ""
"B<sigprocmask>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"При успешном выполнении функция B<sigprocmask>() возвращает 0 и -1 при "
"ошибке. В случае ошибки в I<errno> указывается номер ошибки."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:122
msgid ""
"The I<set> or I<oldset> argument points outside the process's allocated "
"address space."
msgstr ""
"Аргумент I<set> или I<oldset> указывает за пределы выделенного адресного "
"пространства процесса."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:128
msgid ""
"Either the value specified in I<how> was invalid or the kernel does not "
"support the size passed in I<sigsetsize.>"
msgstr ""
"Значение I<how> некорректно или ядро не поддерживает размер, переданный в "
"I<sigsetsize>."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:134
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are "
"silently ignored."
msgstr ""
"Невозможно заблокировать B<SIGKILL> или B<SIGSTOP>. Попытка выполнить это "
"просто игнорируется."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:136
msgid "Each of the threads in a process has its own signal mask."
msgstr "Каждая нить процесса имеют свою маску сигналов."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:156
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr ""
"Если генерируется сигнал B<SIGBUS>, B<SIGFPE>, B<SIGILL> или B<SIGSEGV>, а "
"он заблокирован, то результат не определён, если сигнал был сгенерирован не "
"из B<kill>(3), B<sigqueue>(3) или B<raise>(3)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:167
msgid ""
"Note that it is permissible (although not very useful) to specify both "
"I<set> and I<oldset> as NULL."
msgstr ""
"Заметим, что разрешается (хотя не очень полезно) передавать в I<set> и "
"I<oldset> значение NULL."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:178
msgid ""
"The kernel's definition of I<sigset_t> differs in size from that used by the "
"C library.  In this manual page, the former is referred to as "
"I<kernel_sigset_t> (it is nevertheless named I<sigset_t> in the kernel "
"sources)."
msgstr ""
"Определение ядра I<sigset_t> отличается по размеру от используемого в "
"библиотеке C. В данной справочной странице оно упоминается как "
"I<kernel_sigset_t> (хотя в исходном коде ядра оно называется I<sigset_t>)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:186
msgid ""
"The glibc wrapper function for B<sigprocmask>()  silently ignores attempts "
"to block the two real-time signals that are used internally by the NPTL "
"threading implementation.  See B<nptl>(7)  for details."
msgstr ""
"Обёрточная функция glibc для B<sigprocmask>() просто игнорирует попытки "
"блокирования двух сигналов реального времени, которые используются внутри "
"реализации NPTL. Подробности смотрите в B<nptl>(7)."

#.  sizeof(kernel_sigset_t) == _NSIG / 8,
#.  which equals to 8 on most architectures, but e.g. on MIPS it's 16.
#. type: Plain text
#: man-pages/man2/sigprocmask.2:215
msgid ""
"The original Linux system call was named B<sigprocmask>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> (referred to as I<old_kernel_sigset_t> in this manual page)  "
"type supported by that system call was no longer fit for purpose.  "
"Consequently, a new system call, B<rt_sigprocmask>(), was added to support "
"an enlarged I<sigset_t> type (referred to as I<kernel_sigset_t> in this "
"manual page).  The new system call takes a fourth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the signal sets in I<set> "
"and I<oldset>.  This argument is currently required to have a fixed "
"architecture specific value (equal to I<sizeof(kernel_sigset_t)>)."
msgstr ""
"Изначально, системный вызов Linux назывался B<sigprocmask>(). Однако из-за "
"добавления сигналов реального времени в Linux 2.2, 32-битный тип I<sigset_t> "
"(который называется I<old_kernel_sigset_t> в этой справочной странице) "
"постоянного размера, поддерживаемый этим системным вызовом, перестал "
"подходить для этой цели. В связи с этим был добавлен новый системный вызов "
"B<rt_sigprocmask>(), поддерживающий увеличенный тип I<sigset_t> (который "
"называется I<kernel_sigset_t> в этой справочной странице). У нового "
"системного вызова есть четвёртый аргумент, I<size_t sigsetsize>, которым "
"задаётся размер набора сигналов (в байтах) в I<set> и I<oldset>. В настоящее "
"время этот аргумент должен задаваться постоянным определяемым архитектурой "
"значением (равен I<sizeof(kernel_sigset_t)>)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:222
msgid ""
"The glibc B<sigprocmask>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigprocmask>()  when the kernel provides it."
msgstr ""
"Обёрточная функция glibc B<sigprocmask>() скрывает эти детали от нас, "
"вызывая B<rt_sigprocmask>(), если это необходимо ядру."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:232
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"

#. type: TH
#: man-pages/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr "SETXATTR"

#. type: Plain text
#: man-pages/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr ""
"setxattr, lsetxattr, fsetxattr - устанавливает расширенное значение атрибутов"

#. type: Plain text
#: man-pages/man2/setxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/setxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""
"Расширенные атрибуты представляют собой пару I<имя>:I<значение> и "
"связываются с записями inode (файлы, каталоги, символьные ссылки и т.п.). "
"Они являются расширениями к обычным атрибутам, связанным со всеми записями "
"inode в системе (например, данные B<stat>(2)). Полное описание модели "
"расширенных атрибутов можно найти в B<xattr>(7)."

#. type: Plain text
#: man-pages/man2/setxattr.2:67
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"I<size> argument specifies the size (in bytes) of I<value>; a zero-length "
"value is permitted."
msgstr ""
"Вызов B<setxattr>() устанавливает значение I<value> расширенного атрибута с "
"именем, заданным в I<name> и связанного с заданным I<path> в файловой "
"системе. В аргументе I<size> задаётся размер (в байтах) I<value>; "
"допускается нулевой размер."

#. type: Plain text
#: man-pages/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr ""
"Вызов B<lsetxattr>() идентичен B<setxattr>(), за исключением случая работы с "
"символьными ссылками; он устанавливает расширенный атрибут на ссылке, а не "
"на том файле, на который она указывает."

#. type: Plain text
#: man-pages/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in "
"place of I<path>."
msgstr ""
"Вызов B<fsetxattr>() идентичен B<setxattr>(), отличием является то, что "
"расширенный атрибут устанавливается на открытом файле, на который указывает "
"I<fd> (возвращаемом B<open>(2)), а не на указанном в I<path>."

#. type: Plain text
#: man-pages/man2/setxattr.2:93
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr ""
"Имя расширенного атрибута представляет собой строку, заканчивающуюся null. "
"Имя I<name> включает префикс пространства имён; их может быть несколько, "
"разрозненные пространства ассоциируются с разными inode. Значением I<value> "
"расширенного атрибута является произвольный кусок текстовых или двоичных "
"данных определённой длины."

#. type: Plain text
#: man-pages/man2/setxattr.2:102
msgid ""
"By default (i.e., I<flags> is zero), the extended attribute will be created "
"if it does not exist, or the value will be replaced if the attribute already "
"exists.  To modify these semantics, one of the following values can be "
"specified in I<flags>:"
msgstr ""
"По умолчанию (т. е., значение I<flags> равно), если расширенный атрибут "
"отсутствует, то он создаётся, а если он существует, то заменяется его "
"значение. Для изменения такой работы, в I<flags> можно указать одно из "
"следующих значений:"

#. type: TP
#: man-pages/man2/setxattr.2:102
#, no-wrap
msgid "B<XATTR_CREATE>"
msgstr "B<XATTR_CREATE>"

#. type: Plain text
#: man-pages/man2/setxattr.2:105
msgid ""
"Perform a pure create, which fails if the named attribute exists already."
msgstr ""
"Выполнять только создание, если атрибут с таким именем существует — "
"возвращать ошибку."

#. type: TP
#: man-pages/man2/setxattr.2:105
#, no-wrap
msgid "B<XATTR_REPLACE>"
msgstr "B<XATTR_REPLACE>"

#. type: Plain text
#: man-pages/man2/setxattr.2:109
msgid ""
"Perform a pure replace operation, which fails if the named attribute does "
"not already exist."
msgstr ""
"Выполнять только замену, если атрибут с таким именем не существует — "
"возвращать ошибку."

#. type: Plain text
#: man-pages/man2/setxattr.2:114
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, "
"а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/setxattr.2:115
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/setxattr.2:119
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr ""
"Предел по дисковой квоте; не хватает пространства для сохранения "
"расширенного атрибута."

#. type: Plain text
#: man-pages/man2/setxattr.2:123
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr "Указан B<XATTR_CREATE>, но атрибут уже существует."

#. type: TP
#: man-pages/man2/setxattr.2:123
#, no-wrap
msgid "B<ENODATA>"
msgstr "B<ENODATA>"

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/setxattr.2:132
msgid "B<XATTR_REPLACE> was specified, and the attribute does not exist."
msgstr "Указан B<XATTR_REPLACE>, но атрибут не существует."

#. type: Plain text
#: man-pages/man2/setxattr.2:135
msgid "There is insufficient space remaining to store the extended attribute."
msgstr "Не хватает пространства для сохранения расширенного атрибута."

#. type: TP
#: man-pages/man2/setxattr.2:135 man-pages/man2/setxattr.2:140
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man2/setxattr.2:140
msgid "The namespace prefix of I<name> is not valid."
msgstr "Неверный префикс пространства имён I<name>."

#. type: Plain text
#: man-pages/man2/setxattr.2:143
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled,"
msgstr ""
"Расширенные атрибуты не поддерживаются файловой системой или отключены."

#. type: Plain text
#: man-pages/man2/setxattr.2:148
msgid "The file is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""
"Файл помечен как неизменяемый (immutable) или только для добавления "
"(смотрите B<ioctl_iflags>(2))."

#. type: Plain text
#: man-pages/man2/setxattr.2:152
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "Также могут возникать ошибки, описанные в B<stat>(2)."

#. type: TP
#: man-pages/man2/setxattr.2:152
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man2/setxattr.2:159
msgid "The size of I<name> or I<value> exceeds a filesystem-specific limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:162
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""
"Данные системные вызовы доступны в Linux начиная с ядра версии 2.4; "
"поддержка в glibc появилась в версии 2.3."

#. type: Plain text
#: man-pages/man2/setxattr.2:179
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: man-pages/man2/setgid.2:30
#, no-wrap
msgid "SETGID"
msgstr "SETGID"

#. type: Plain text
#: man-pages/man2/setgid.2:33
msgid "setgid - set group identity"
msgstr "setgid - устанавливает идентификатор группы процесса"

#. type: Plain text
#: man-pages/man2/setgid.2:39
msgid "B<int setgid(gid_t >I<gid>B<);>"
msgstr "B<int setgid(gid_t >I<gid>B<);>"

#. type: Plain text
#: man-pages/man2/setgid.2:46
msgid ""
"B<setgid>()  sets the effective group ID of the calling process.  If the "
"calling process is privileged (more precisely: has the B<CAP_SETGID> "
"capability in its user namespace), the real GID and saved set-group-ID are "
"also set."
msgstr ""
"Вызов B<setgid>() устанавливает эффективный идентификатор группы вызвавшего "
"процесса. Если вызывающий процесс имеет права (точнее, мандат B<CAP_SETGID> "
"в своём пространстве имён пользователя), то также устанавливаются "
"действительный и сохраненный идентификаторы группы."

#. type: Plain text
#: man-pages/man2/setgid.2:56
msgid ""
"Under Linux, B<setgid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-group-ID program that is not "
"set-user-ID-root to drop all of its group privileges, do some un-privileged "
"work, and then reengage the original effective group ID in a secure manner."
msgstr ""
"В Linux B<setgid>() реализован так же, как в версии POSIX где есть "
"возможность B<_POSIX_SAVED_IDS>. Это позволяет set-group-ID-программам (не "
"являющимся программами суперпользователя) сбросить привилегии группы, "
"проделать непривилегированную работу и безопасно вернуть исходный "
"эффективный идентификатор группы."

#. type: Plain text
#: man-pages/man2/setgid.2:67
msgid "The group ID specified in I<gid> is not valid in this user namespace."
msgstr ""
"Идентификатор группы, заданный в I<gid>, некорректен в этом пользовательском "
"пространстве имён."

#. type: Plain text
#: man-pages/man2/setgid.2:74
msgid ""
"The calling process is not privileged (does not have the B<CAP_SETGID> "
"capability in its user namespace), and I<gid> does not match the real group "
"ID or saved set-group-ID of the calling process."
msgstr ""
"У вызвавшего процесса нет прав (не имеет мандата B<CAP_SETGID> в его "
"пользовательском пространстве имён) и I<gid> не совпадает с эффективным "
"идентификатором группы или сохраненным set-group-ID идентификатором группы "
"вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setgid.2:87
msgid ""
"The original Linux B<setgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setgid32>()  supporting 32-bit IDs.  "
"The glibc B<setgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"Первоначальная версия системного вызова B<setgid>() в Linux поддерживала "
"только 16-битные идентификаторы групп. Позднее в Linux 2.4 был добавлен "
"вызов B<setgid32>(), поддерживающий 32-битные идентификаторы. В glibc "
"обёрточная функция B<gsetgid>() работает одинаково вне зависимости от версий "
"ядра."

#. type: Plain text
#: man-pages/man2/setgid.2:101
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""
"На уровне ядра ID пользователя и группы являются атрибутами нити. Однако в "
"POSIX требуется, чтобы все нити в процессе имели одинаковые права. В "
"реализации нитей NPTL требования POSIX реализованы через обёрточные функции "
"для различных системных вызовов, которые изменяют UID и GID процесса. В этих "
"функциях (включая и для B<setgid>()) используется алгоритмы на основе "
"сигналов, которые следят за тем, что когда у одной нити изменяются права, "
"эти изменения выполняются и для остальных нитей процесса. Подробное описание "
"смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/setgid.2:107
msgid ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: man-pages/man2/sysctl.2:30
#, no-wrap
msgid "SYSCTL"
msgstr "SYSCTL"

#. type: Plain text
#: man-pages/man2/sysctl.2:33
msgid "sysctl - read/write system parameters"
msgstr "sysctl - читает/записывает параметры системы"

#. type: Plain text
#: man-pages/man2/sysctl.2:37
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>linux/sysctl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>linux/sysctl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:39
#, no-wrap
msgid "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"
msgstr "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:43
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/sysctl.2:46
msgid "B<Do not use this system call!> See NOTES."
msgstr "B<Не используйте этот системный вызов!> Смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/sysctl.2:53
msgid ""
"The B<_sysctl>()  call reads and/or writes kernel parameters.  For example, "
"the hostname, or the maximum number of open files.  The argument has the form"
msgstr ""
"Системный вызов B<_sysctl> считывает и/или изменяет параметры ядра. К ним "
"относятся, например, имя машины или максимальное количество открытых файлов. "
"Параметр имеет следующую структуру:"

#. type: Plain text
#: man-pages/man2/sysctl.2:65
#, no-wrap
msgid ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"
msgstr ""
"struct __sysctl_args {\n"
"    int    *name;    /* целочисленный вектор, описывающий\n"
"                        переменную */\n"
"    int     nlen;    /* длина этого вектора */\n"
"    void   *oldval;  /* 0 или адрес старого значения */\n"
"    size_t *oldlenp; /* размер старого значения, заменяется\n"
"                        реальным размером старого значения */\n"
"    void   *newval;  /* 0 или адрес нового значения */\n"
"    size_t  newlen;  /* размер нового значения */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:73
msgid ""
"This call does a search in a tree structure, possibly resembling a directory "
"tree under I</proc/sys>, and if the requested item is found calls some "
"appropriate routine to read or modify the value."
msgstr ""
"Этот вызов производит поиск в древовидной структуре, возможно, похожей на "
"структуру каталогов I</proc/sys>, и, если запрашиваемый элемент найден, "
"вызывает соответствующую процедуру, читающую или изменяющую значение."

#. type: Plain text
#: man-pages/man2/sysctl.2:80
msgid ""
"Upon successful completion, B<_sysctl>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<_sysctl>() возвращает 0. При ошибке возвращается "
"-1, а переменной I<errno> присваивается номер ошибки."

#. type: TP
#: man-pages/man2/sysctl.2:81
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr "B<EACCES>, B<EPERM>"

#. type: Plain text
#: man-pages/man2/sysctl.2:89
msgid ""
"No search permission for one of the encountered \"directories\", or no read "
"permission where I<oldval> was nonzero, or no write permission where "
"I<newval> was nonzero."
msgstr ""
"Нет прав на поиск в одном из встретившихся «каталогов» или нет прав на "
"чтение, если I<oldval> не равно нулю; или нет прав на запись, если I<newval> "
"не равно нулю."

#. type: Plain text
#: man-pages/man2/sysctl.2:95
msgid ""
"The invocation asked for the previous value by setting I<oldval> non-NULL, "
"but allowed zero room in I<oldlenp>."
msgstr ""
"Был сделан запрос предыдущего значения путём установки не-NULL значения "
"I<oldval>, но размер места под него в I<oldlenp> равен нулю."

#. type: TP
#: man-pages/man2/sysctl.2:95
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/sysctl.2:99
msgid "I<name> was not found."
msgstr "I<name> не найден."

#. type: Plain text
#: man-pages/man2/sysctl.2:113
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable.  A B<sysctl>()  call has been present in Linux since version "
"1.3.57.  It originated in 4.4BSD.  Only Linux has the I</proc/sys> mirror, "
"and the object naming schemes differ between Linux and 4.4BSD, but the "
"declaration of the B<sysctl>()  function is the same in both."
msgstr ""
"Этот вызов есть только в Linux и не должен использоваться в переносимых "
"программах. Вызов B<sysctl>() впервые появился в Linux 1.3.57. Впервые он "
"появился в 4.4BSD. Только в Linux существует зеркало I</proc/sys>, и схемы "
"именования объектов в Linux и 4.4BSD различаются, но объявление функции "
"B<sysctl>() одинаково в обеих системах."

#.  See http://lwn.net/Articles/247243/
#.  Though comments in suggest that it is needed by old glibc binaries,
#.  so maybe it's not going away.
#. type: Plain text
#: man-pages/man2/sysctl.2:130
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Or rather...  I<don't> call it: use of this system call has "
"long been discouraged, and it is so unloved that B<it is likely to disappear "
"in a future kernel version>.  Since Linux 2.6.24, uses of this system call "
"result in warnings in the kernel log.  Remove it from your programs now; use "
"the I</proc/sys> interface instead."
msgstr ""
"В glibc отсутствует обёрточная функция для этого системного вызова; "
"вызывайте его через B<syscall>(2).  Или лучше I<совсем> не используйте: "
"использование данного системного вызова уже давно не рекомендуется и он так "
"всем не нравится, что, B<вероятно, исчезнет в новой версии ядра>. Начиная с "
"Linux 2.6.24, при использовании данного системного вызова записывается "
"предупреждение в журнал ядра. Удалите вызов из своих программ прямо сейчас; "
"вместо него используйте интерфейс I</proc/sys>."

#. type: Plain text
#: man-pages/man2/sysctl.2:134
msgid ""
"This system call is available only if the kernel was configured with the "
"B<CONFIG_SYSCTL_SYSCALL> option."
msgstr ""
"Данный системный вызов доступен только, если ядро было собрано с параметром "
"B<CONFIG_SYSCTL_SYSCALL>."

#. type: Plain text
#: man-pages/man2/sysctl.2:137
msgid ""
"The object names vary between kernel versions, making this system call "
"worthless for applications."
msgstr ""
"Названия объектов различаются в разных версиях ядра, что делает данный вызов "
"в приложениях бесполезным."

#. type: Plain text
#: man-pages/man2/sysctl.2:139
msgid "Not all available objects are properly documented."
msgstr "Не все существующие объекты описаны соответствующим образом."

#. type: Plain text
#: man-pages/man2/sysctl.2:142
msgid ""
"It is not yet possible to change operating system by writing to I</proc/sys/"
"kernel/ostype>."
msgstr ""
"В настоящее время невозможно изменить тип операционной системы путём записи "
"в файл I</proc/sys/kernel/ostype>."

#. type: Plain text
#: man-pages/man2/sysctl.2:151
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:153
#, no-wrap
msgid "int _sysctl(struct __sysctl_args *args );\n"
msgstr "int _sysctl(struct __sysctl_args *args );\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:155
#, no-wrap
msgid "#define OSNAMESZ 100\n"
msgstr "#define OSNAMESZ 100\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:163
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:169
#, no-wrap
msgid ""
"    memset(&args, 0, sizeof(struct __sysctl_args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"
msgstr ""
"    memset(&args, 0, sizeof(struct __sysctl_args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:171
#, no-wrap
msgid "    osnamelth = sizeof(osname);\n"
msgstr "    osnamelth = sizeof(osname);\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:179
#, no-wrap
msgid ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"Эта машина работает в %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:181
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: man-pages/man2/sysinfo.2:35
#, no-wrap
msgid "SYSINFO"
msgstr "SYSINFO"

#. type: Plain text
#: man-pages/man2/sysinfo.2:38
msgid "sysinfo - return system information"
msgstr "sysinfo - возвращает информацию о системе"

#. type: Plain text
#: man-pages/man2/sysinfo.2:40
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>"

#. type: Plain text
#: man-pages/man2/sysinfo.2:42
msgid "B<int sysinfo(struct sysinfo *>I<info>B<);>"
msgstr "B<int sysinfo(struct sysinfo *>I<info>B<);>"

#. type: Plain text
#: man-pages/man2/sysinfo.2:46
msgid ""
"B<sysinfo>()  returns certain statistics on memory and swap usage, as well "
"as the load average."
msgstr ""
"Вызов B<sysinfo>() возвращает некоторую статистику использования памяти и "
"области подкачки, а также среднюю загруженность."

#. type: Plain text
#: man-pages/man2/sysinfo.2:50
msgid ""
"Until Linux 2.3.16, B<sysinfo>()  returned information in the following "
"structure:"
msgstr "До Linux 2.3.16 вызов B<sysinfo>() возвращал следующую структуру:"

#. type: Plain text
#: man-pages/man2/sysinfo.2:65
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"
msgstr ""
"struct sysinfo {\n"
"    long uptime;             /* Количество секунд, прошедшее\n"
"                                с загрузки системы */\n"
"    unsigned long loads[3];  /* средняя 1, 5 и 15-минутная загруженность\n"
"                                системы */\n"
"    unsigned long totalram;  /* Общий объём доступной оперативной памяти */\n"
"    unsigned long freeram;   /* Объём свободной памяти */\n"
"    unsigned long sharedram; /* Объём общей памяти */\n"
"    unsigned long bufferram; /* Объём памяти, использованной под буферы */\n"
"    unsigned long totalswap; /* Общий объём области подкачки */\n"
"    unsigned long freeswap;  /* Объём свободного пространства в области\n"
"                                подкачки */\n"
"    unsigned short procs;    /* Текущее количество процессов */\n"
"    char _f[22];             /* Дополнение структуры до 64 байтов */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/sysinfo.2:70
msgid ""
"In the above structure, the sizes of the memory and swap fields are given in "
"bytes."
msgstr ""
"В приведённой выше структуре размеры полей памяти и подкачки приводятся в "
"байтах."

#. type: Plain text
#: man-pages/man2/sysinfo.2:73
msgid ""
"Since Linux 2.3.23 (i386) and Linux 2.3.48 (all architectures) the structure "
"is:"
msgstr ""
"Начиная с Linux 2.3.23 (i386) и Linux 2.3.48 (остальные архитектуры), "
"структура следующая:"

#. type: Plain text
#: man-pages/man2/sysinfo.2:92
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)];\n"
"                             /* Padding to 64 bytes */\n"
"};\n"
msgstr ""
"struct sysinfo {\n"
"    long uptime;             /* Количество секунд, прошедшее с загрузки\n"
"                                системы */\n"
"    unsigned long loads[3];  /* средняя 1,  и 15-минутная загруженность\n"
"                                системы */\n"
"    unsigned long totalram;  /* Общий объём доступной оперативной памяти */\n"
"    unsigned long freeram;   /* Объём свободной памяти */\n"
"    unsigned long sharedram; /* Объём общей памяти */\n"
"    unsigned long bufferram; /* Объём памяти, использованной под буферы */\n"
"    unsigned long totalswap; /* Общий объём области подкачки */\n"
"    unsigned long freeswap;  /* Объём свободного пространства в области\n"
"                                подкачки */\n"
"    unsigned short procs;    /* Текущее количество процессов */\n"
"    unsigned long totalhigh; /* Общий объём дальней (high) памяти */\n"
"    unsigned long freehigh;  /* Объём свободной дальней памяти */\n"
"    unsigned int mem_unit;   /* Размер элемента памяти в байтах */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)];\n"
"                             /* Дополнение до 64 байт */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/sysinfo.2:99
msgid ""
"In the above structure, sizes of the memory and swap fields are given as "
"multiples of I<mem_unit> bytes."
msgstr ""
"В приведённой выше структуре размеры полей памяти и подкачки приводятся "
"умноженными на I<mem_unit> байт."

#. type: Plain text
#: man-pages/man2/sysinfo.2:106
msgid ""
"On success, B<sysinfo>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<sysinfo>() возвращается ноль. При ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/sysinfo.2:111
msgid "I<info> is not a valid address."
msgstr "Аргумент I<info> не содержит допустимого адреса."

#. type: Plain text
#: man-pages/man2/sysinfo.2:114
msgid "B<sysinfo>()  first appeared in Linux 0.98.pl6."
msgstr "Вызов B<sysinfo>() впервые появился в Linux 0.98.pl6."

#. type: Plain text
#: man-pages/man2/sysinfo.2:117
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"Данная функция есть только в Linux и не должна использоваться в программах, "
"которые задуманы как переносимые."

#. type: Plain text
#: man-pages/man2/sysinfo.2:122
msgid ""
"All of the information provided by this system call is also available via I</"
"proc/meminfo> and I</proc/loadavg>."
msgstr ""
"Вся информация, предоставляемая этим системным вызовом также доступна через "
"I</proc/meminfo> и I</proc/loadavg>."

#. type: TH
#: man-pages/man2/setfsuid.2:32
#, no-wrap
msgid "SETFSUID"
msgstr "SETFSUID"

#. type: TH
#: man-pages/man2/setfsuid.2:32
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:35
msgid "setfsuid - set user identity used for filesystem checks"
msgstr ""
"setfsuid - устанавливает идентификатор пользователя для доступа к файловой "
"системе"

#. type: Plain text
#: man-pages/man2/setfsuid.2:37
msgid "B<#include E<lt>sys/fsuid.hE<gt>>"
msgstr "B<#include E<lt>sys/fsuid.hE<gt>>"

#. type: Plain text
#: man-pages/man2/setfsuid.2:39
msgid "B<int setfsuid(uid_t >I<fsuid>B<);>"
msgstr "B<int setfsuid(uid_t >I<fsuid>B<);>"

#. type: Plain text
#: man-pages/man2/setfsuid.2:46
msgid ""
"On Linux, a process has both a filesystem user ID and an effective user ID.  "
"The (Linux-specific) filesystem user ID is used for permissions checking "
"when accessing filesystem objects, while the effective user ID is used for "
"various other kinds of permissions checks (see B<credentials>(7))."
msgstr ""
"В Linux у процесса есть идентификатор пользователя файловой системы и "
"эффективный (effective) идентификатор пользователя. Идентификатор "
"пользователя файловой системы (есть только в Linux) используется при "
"проверки прав доступа к объектам файловой системы, а эффективный "
"идентификатор пользователя используется для проверки прав доступа к другим "
"различным объектам (смотрите B<credentials>(7))."

#. type: Plain text
#: man-pages/man2/setfsuid.2:57
msgid ""
"Normally, the value of the process's filesystem user ID is the same as the "
"value of its effective user ID.  This is so, because whenever a process's "
"effective user ID is changed, the kernel also changes the filesystem user ID "
"to be the same as the new value of the effective user ID.  A process can "
"cause the value of its filesystem user ID to diverge from its effective user "
"ID by using B<setfsuid>()  to change its filesystem user ID to the value "
"given in I<fsuid>."
msgstr ""
"Обычно, значение идентификатора пользователя файловой системы процесса "
"совпадает со значением эффективного идентификатора пользователя. Более того, "
"при изменении идентификатора эффективного идентификатора пользователя ядро "
"также изменяет и идентификатор пользователя файловой системы на новое "
"значение идентификатора эффективного идентификатора пользователя.Процесс "
"может изменить значение своего идентификатора пользователя файловой системы "
"на отличное от эффективного идентификатора пользователя с помощью "
"B<setfsuid>() указав его в параметре I<fsuid>."

#. type: Plain text
#: man-pages/man2/setfsuid.2:68
msgid ""
"Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are (were) usually used "
"only by programs such as the Linux NFS server that need to change what user "
"and group ID is used for file access without a corresponding change in the "
"real and effective user and group IDs.  A change in the normal user IDs for "
"a program such as the NFS server is (was) a security hole that can expose it "
"to unwanted signals.  (However, this issue is historical; see below.)"
msgstr ""
"Вызовы B<setfsuid>() и B<setfsgid>(2) в явном виде, обычно (теперь), "
"используются только в программах Linux типа NFS-сервера, которым требуется "
"изменить идентификатор пользователя и группы для доступа к файлам без "
"изменения действительного и эффективного идентификаторов пользователя и "
"группы. Изменение обычного идентификатора пользователя для программы типа "
"NFS-сервера — это нарушение безопасности (раньше), приводящее к возможному "
"получению нежелательных сигналов от других групп (однако это было в прошлом, "
"читайте далее)."

#. type: Plain text
#: man-pages/man2/setfsuid.2:74
msgid ""
"B<setfsuid>()  will succeed only if the caller is the superuser or if "
"I<fsuid> matches either the caller's real user ID, effective user ID, saved "
"set-user-ID, or current filesystem user ID."
msgstr ""
"Вызов B<setfsuid>() выполняется корректно, только если он был вызван "
"суперпользователем или, если I<fsuid> совпадает с действительным, "
"эффективным и сохранённым идентификатором пользователя или равен текущему "
"значению идентификатора пользователя файловой системы вызывающего."

#. type: Plain text
#: man-pages/man2/setfsuid.2:77
msgid ""
"On both success and failure, this call returns the previous filesystem user "
"ID of the caller."
msgstr ""
"При успешном выполнении или при ошибке данный вызов возвращает предыдущий "
"идентификатор пользователя файловой системы вызвавшего."

#.  This system call is present since Linux 1.1.44
#.  and in libc since libc 4.7.6.
#. type: Plain text
#: man-pages/man2/setfsuid.2:81
msgid "This system call is present in Linux since version 1.2."
msgstr "Данный системный вызов доступен в Linux начиная с версии 1.2."

#. type: Plain text
#: man-pages/man2/setfsuid.2:85
msgid ""
"B<setfsuid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"Вызов B<setfsuid>() есть только в Linux и не должен использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man2/setfsuid.2:104
msgid ""
"At the time when this system call was introduced, one process could send a "
"signal to another process with the same effective user ID.  This meant that "
"if a privileged process changed its effective user ID for the purpose of "
"file permission checking, then it could become vulnerable to receiving "
"signals sent by another (unprivileged) process with the same user ID.  The "
"filesystem user ID attribute was thus added to allow a process to change its "
"user ID for the purposes of file permission checking without at the same "
"time becoming vulnerable to receiving unwanted signals.  Since Linux 2.0, "
"signal permission handling is different (see B<kill>(2)), with the result "
"that a process can change its effective user ID without being vulnerable to "
"receiving signals from unwanted processes.  Thus, B<setfsuid>()  is nowadays "
"unneeded and should be avoided in new applications (likewise for "
"B<setfsgid>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:114
msgid ""
"The original Linux B<setfsuid>()  system call supported only 16-bit user "
"IDs.  Subsequently, Linux 2.4 added B<setfsuid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsuid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"Первоначальная версия системного вызова B<setfsuid>() в Linux поддерживала "
"только 16-битные идентификаторы пользователя. Позднее в Linux 2.4 был "
"добавлен вызов B<setfsuid32>(), поддерживающий 32-битные идентификаторы. В "
"glibc обёрточная функция B<setfsuid>() работает одинаково вне зависимости от "
"версий ядра."

#. type: Plain text
#: man-pages/man2/setfsuid.2:123
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit user IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""
"В glibc 2.15 и старее, если обёрточная функция этого системного вызова "
"определяет, что аргумент невозможно передать ядру без обрезания целого (так "
"как ядро старое и не поддерживает 32-битные ID пользователя), то она "
"возвращает -1 и присваивает I<errno> значение B<EINVAL> не пытаясь выполнить "
"системный вызов."

#. type: Plain text
#: man-pages/man2/setfsuid.2:140
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsuid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsuid>()  changed the filesystem user "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETUID> capability)."
msgstr ""
"Вызывающему не возвращается никаких ошибок, и факт того, что успешном или не "
"успешном выполнении возвращается одинаковое значение, делает невозможным "
"напрямую определить как завершился вызов. Вместо этого, вызывающий должен "
"получить значение из ещё одного вызова — I<setfsuid(-1)> (который всегда "
"завершается с ошибкой), чтобы определить, изменил ли предыдущий вызов "
"B<setfsuid>() идентификатор пользователя файловой системы. По крайней мере, "
"должно быть получено значение B<EPERM>, если вызов завершится с ошибкой (так "
"как у вызывающего нет мандата B<CAP_SETUID>)."

#. type: Plain text
#: man-pages/man2/setfsuid.2:144
msgid "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/setuid.2:31
#, no-wrap
msgid "SETUID"
msgstr "SETUID"

#. type: Plain text
#: man-pages/man2/setuid.2:34
msgid "setuid - set user identity"
msgstr "setuid - устанавливает идентификатор пользователя"

#. type: Plain text
#: man-pages/man2/setuid.2:40
msgid "B<int setuid(uid_t >I<uid>B<);>"
msgstr "B<int setuid(uid_t >I<uid>B<);>"

#. type: Plain text
#: man-pages/man2/setuid.2:48
msgid ""
"B<setuid>()  sets the effective user ID of the calling process.  If the "
"calling process is privileged (more precisely: if the process has the "
"B<CAP_SETUID> capability in its user namespace), the real UID and saved set-"
"user-ID are also set."
msgstr ""
"Вызов B<setuid>() устанавливает эффективный идентификатор пользователя "
"вызвавшего процесса. Если вызывающий процесс имеет права (мандат "
"B<CAP_SETUID> в своём пространстве имён пользователя), то также "
"устанавливаются действительный и сохраненный идентификаторы пользователя."

#. type: Plain text
#: man-pages/man2/setuid.2:57
msgid ""
"Under Linux, B<setuid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-user-ID (other than root) "
"program to drop all of its user privileges, do some un-privileged work, and "
"then reengage the original effective user ID in a secure manner."
msgstr ""
"В Linux B<setuid>() реализован как и в стандарте POSIX с возможностью "
"B<_POSIX_SAVED_IDS>. Это позволяет setuid-программам (не setuid-root) "
"сбрасывать все привилегии, делать непривилегированную работу, а затем "
"безопасным путём возвращать себе исходный эффективный идентификатор "
"пользователя."

#. type: Plain text
#: man-pages/man2/setuid.2:66
msgid ""
"If the user is root or the program is set-user-ID-root, special care must be "
"taken: B<setuid>()  checks the effective user ID of the caller and if it is "
"the superuser, all process-related user ID's are set to I<uid>.  After this "
"has occurred, it is impossible for the program to regain root privileges."
msgstr ""
"Если пользователь root или программа установлена как setuid root, при работе "
"требуется особая осторожность: функция B<setuid>() проверяет эффективный "
"идентификатор вызвавшего пользователя и, если это суперпользователь, то все "
"устанавливаемые значения идентификаторов равны I<uid>. После этого программа "
"уже никаким образом не сможет вернуть права пользователя root."

#. type: Plain text
#: man-pages/man2/setuid.2:73
msgid ""
"Thus, a set-user-ID-root program wishing to temporarily drop root "
"privileges, assume the identity of an unprivileged user, and then regain "
"root privileges afterward cannot use B<setuid>().  You can accomplish this "
"with B<seteuid>(2)."
msgstr ""
"Таким образом, программа, принадлежащая root и с установленным битом setuid, "
"собирающаяся временно сбросить права root и поработать с правами "
"непривилегированного пользователя, а затем восстановить права root, не "
"сможет использовать B<setuid>(). Требуемого результата можно достичь с "
"помощью вызова B<seteuid>(2)."

#. type: Plain text
#: man-pages/man2/setuid.2:85
msgid ""
"I<Note>: there are cases where B<setuid>()  can fail even when the caller is "
"UID 0; it is a grave security error to omit checking for a failure return "
"from B<setuid>()."
msgstr ""
"I<Замечание>: есть случаи, когда B<setuid>() может завершиться с ошибкой "
"даже когда UID вызывающего равен 0; это серьёзная ошибка безопасности — не "
"проверять возвращаемое значение B<setuid>()."

#. type: Plain text
#: man-pages/man2/setuid.2:93
msgid ""
"The call would change the caller's real UID (i.e., I<uid> does not match the "
"caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""
"Вызов изменил бы настоящего реальный UID вызывающего (т. е. I<uid> не "
"совпадает с реальным UID вызывающего), но возникла временная ошибка при "
"выделении памяти под необходимые структуры ядра."

#. type: Plain text
#: man-pages/man2/setuid.2:108
msgid ""
"I<uid> does not match the real user ID of the caller and this call would "
"bring the number of processes belonging to the real user ID I<uid> over the "
"caller's B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case "
"no longer occurs (but robust applications should check for this error); see "
"the description of B<EAGAIN> in B<execve>(2)."
msgstr ""
"Значение I<uid> не совпадает с реальным UID вызывающего и этот вызов создал "
"был превышение количества процессов, принадлежащих пользователю с реальным "
"ID I<ruid> сверх ограничителя ресурсы B<RLIMIT_NPROC> вызывающего. Начиная с "
"Linux 3.1 эта ошибка больше не возникает (но корректное приложение должно "
"проверять эту ошибку); смотрите описание B<EAGAIN> в B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setuid.2:113
msgid "The user ID specified in I<uid> is not valid in this user namespace."
msgstr ""
"Идентификатор пользователя, заданный в I<uid>, некорректен в этом "
"пользовательском пространстве имён."

#. type: Plain text
#: man-pages/man2/setuid.2:120
msgid ""
"The user is not privileged (Linux: does not have the B<CAP_SETUID> "
"capability in its user namespace) and I<uid> does not match the real UID or "
"saved set-user-ID of the calling process."
msgstr ""
"Пользователь не является суперпользователем (Linux: нет мандата "
"B<CAP_SETUID> в пользовательском пространстве имён), а I<uid> не совпадает с "
"действительным или сохранённым идентификатором пользователя вызывающего "
"процесса."

#.  SVr4 documents an additional EINVAL error condition.
#. type: Plain text
#: man-pages/man2/setuid.2:125
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  Not quite compatible with the 4.4BSD "
"call, which sets all of the real, saved, and effective user IDs."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, SVr4. Этот системный вызов не полностью "
"совместим с 4.4BSD, который устанавливает действительный, эффективный и "
"сохранённый идентификаторы пользователя."

#. type: Plain text
#: man-pages/man2/setuid.2:133
msgid ""
"Linux has the concept of the filesystem user ID, normally equal to the "
"effective user ID.  The B<setuid>()  call also sets the filesystem user ID "
"of the calling process.  See B<setfsuid>(2)."
msgstr ""
"Linux поддерживает идентификатор пользователя файловой системы, обычно "
"совпадающий с эффективным идентификатором. Системный вызов B<setuid>() также "
"устанавливает идентификатор пользователя файловой системы вызывающего "
"процесса. См. B<setfsuid>(2)."

#. type: Plain text
#: man-pages/man2/setuid.2:138
msgid ""
"If I<uid> is different from the old effective UID, the process will be "
"forbidden from leaving core dumps."
msgstr ""
"Если I<uid> отличается от старого эффективного идентификатора, то процессу "
"нельзя будет создавать core-файлы."

#. type: Plain text
#: man-pages/man2/setuid.2:149
msgid ""
"The original Linux B<setuid>()  system call supported only 16-bit user IDs.  "
"Subsequently, Linux 2.4 added B<setuid32>()  supporting 32-bit IDs.  The "
"glibc B<setuid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr ""
"Первоначальная версия системного вызова B<setuid>() в Linux поддерживала "
"только 16-битные идентификаторы пользователя. Позднее в Linux 2.4 был "
"добавлен вызов B<setuid32>(), поддерживающий 32-битные идентификаторы. В "
"glibc обёрточная функция B<setuid>() работает одинаково вне зависимости от "
"версий ядра."

#. type: Plain text
#: man-pages/man2/setuid.2:163
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setuid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""
"На уровне ядра ID пользователя и группы являются атрибутами нити. Однако в "
"POSIX требуется, чтобы все нити в процессе имели одинаковые права. В "
"реализации нитей NPTL требования POSIX реализованы через обёрточные функции "
"для различных системных вызовов, которые изменяют UID и GID процесса. В этих "
"функциях (включая и B<setuid>()) используется алгоритмы на основе сигналов, "
"которые следят за тем, что когда у одной нити изменяются права, эти "
"изменения выполняются и для остальных нитей процесса. Подробное описание "
"смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/setuid.2:170
msgid ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: man-pages/man2/semctl.2:42
#, no-wrap
msgid "SEMCTL"
msgstr "SEMCTL"

#. type: Plain text
#: man-pages/man2/semctl.2:45
msgid "semctl - System V semaphore control operations"
msgstr "semctl - операции управления семафорами System V"

#. type: Plain text
#: man-pages/man2/semctl.2:52
#, no-wrap
msgid "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"
msgstr "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"

#. type: Plain text
#: man-pages/man2/semctl.2:63
msgid ""
"B<semctl>()  performs the control operation specified by I<cmd> on the System"
"\\ V semaphore set identified by I<semid>, or on the I<semnum>-th semaphore "
"of that set.  (The semaphores in a set are numbered starting at 0.)"
msgstr ""
"Вызов semctl выполняет операцию, определённую в I<cmd>, над набором "
"семафоров System\\ V, указанном в I<semid>, или над семафором с номером "
"I<semnum> из этого набора (семафоры нумеруются, начиная с 0)."

#. type: Plain text
#: man-pages/man2/semctl.2:69
msgid ""
"This function has three or four arguments, depending on I<cmd>.  When there "
"are four, the fourth has the type I<union semun>.  The I<calling program> "
"must define this union as follows:"
msgstr ""
"Данный вызов имеет три или четыре аргумента, в зависимости от значения "
"I<cmd>. Если аргументов четыре, то четвертый аргумент arg имеет тип I<union "
"semun>. В I<вызывающей программе> это объединение должно быть определено "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/semctl.2:79
#, no-wrap
msgid ""
"union semun {\n"
"    int              val;    /* Value for SETVAL */\n"
"    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n"
"    unsigned short  *array;  /* Array for GETALL, SETALL */\n"
"    struct seminfo  *__buf;  /* Buffer for IPC_INFO\n"
"                                (Linux-specific) */\n"
"};\n"
msgstr ""
"union semun {\n"
"    int              val;    /* значение для SETVAL */\n"
"    struct semid_ds *buf;    /* буфер для IPC_STAT, IPC_SET */\n"
"    unsigned short  *array;  /* массив для GETALL, SETALL */\n"
"    struct seminfo  *__buf;  /* буфер для IPC_INFO\n"
"                                (есть только в Linux) */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:85
msgid ""
"The I<semid_ds> data structure is defined in I<E<lt>sys/sem.hE<gt>> as "
"follows:"
msgstr ""
"Структура данных I<semid_ds> определена в I<E<lt>sys/sem.hE<gt>> следующим "
"образом:"

#. type: Plain text
#: man-pages/man2/semctl.2:94
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;  /* Ownership and permissions */\n"
"    time_t          sem_otime; /* Last semop time */\n"
"    time_t          sem_ctime; /* Last change time */\n"
"    unsigned long   sem_nsems; /* No. of semaphores in set */\n"
"};\n"
msgstr ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;  /* владелец и права */\n"
"    time_t          sem_otime; /* время последней операции semop */\n"
"    time_t          sem_ctime; /* время последнего изменения */\n"
"    unsigned long  sem_nsems; /* кол-во семафоров в наборе */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:114
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key; /* Key supplied to semget(2) */\n"
"    uid_t          B<uid>;   /* Effective UID of owner */\n"
"    gid_t          B<gid>;   /* Effective GID of owner */\n"
"    uid_t          cuid;  /* Effective UID of creator */\n"
"    gid_t          cgid;  /* Effective GID of creator */\n"
"    unsigned short B<mode>;  /* Permissions */\n"
"    unsigned short __seq; /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key; /* ключ, передаваемый в semget(2) */\n"
"    uid_t          B<uid>;   /* эффективный UID владельца */\n"
"    gid_t          B<gid>;   /* эффективный GID владельца */\n"
"    uid_t          cuid;  /* эффективный UID создателя */\n"
"    gid_t          cgid;  /* эффективный GID создателя */\n"
"    unsigned short B<mode>;  /* права */\n"
"    unsigned short __seq; /* порядковый номер */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:132
msgid ""
"Copy information from the kernel data structure associated with I<semid> "
"into the I<semid_ds> structure pointed to by I<arg.buf>.  The argument "
"I<semnum> is ignored.  The calling process must have read permission on the "
"semaphore set."
msgstr ""
"Копирует информацию из структуры данных ядра, связанной с I<semid>, в "
"структуру I<semid_ds>, расположенную по адресу I<arg.buf>. Аргумент "
"I<semnum> игнорируется. Вызывающий процесс должен иметь права на чтение "
"набора семафоров."

#. type: Plain text
#: man-pages/man2/semctl.2:155
msgid ""
"Write the values of some members of the I<semid_ds> structure pointed to by "
"I<arg.buf> to the kernel data structure associated with this semaphore set, "
"updating also its I<sem_ctime> member.  The following members of the "
"structure are updated: I<sem_perm.uid>, I<sem_perm.gid>, and (the least "
"significant 9 bits of)  I<sem_perm.mode>.  The effective UID of the calling "
"process must match the owner (I<sem_perm.uid>)  or creator (I<sem_perm."
"cuid>)  of the semaphore set, or the caller must be privileged.  The "
"argument I<semnum> is ignored."
msgstr ""
"Записывает значения некоторых полей структуры I<semid_ds>, на которую "
"указывает I<arg.buf>, в структуру данных ядра, связанную с этим набором "
"семафоров, также обновляя при этом поле I<sem_ctime>. Обновляются следующие "
"поля структуры: I<sem_perm.uid>, I<sem_perm.gid> и (младшие 9 значащих "
"битов) I<sem_perm.mode>. Эффективный UID вызывающего процесса должен "
"совпадать с идентификатором владельца (I<sem_perm.uid>) или создателя "
"(I<sem_perm.cuid>) набора семафоров, или вызывающий должен иметь расширенные "
"права. Аргумент I<semnum> игнорируется."

#. type: Plain text
#: man-pages/man2/semctl.2:170
msgid ""
"Immediately remove the semaphore set, awakening all processes blocked in "
"B<semop>(2)  calls on the set (with an error return and I<errno> set to "
"B<EIDRM>).  The effective user ID of the calling process must match the "
"creator or owner of the semaphore set, or the caller must be privileged.  "
"The argument I<semnum> is ignored."
msgstr ""
"Немедленно удаляет набор семафоров, пробуждая все процессы, заблокированные "
"в вызове B<semop>(2) (при этом возвращается сообщение об ошибке, а I<errno> "
"присваивается значение B<EIDRM>). Эффективный идентификатор пользователя "
"вызывающего процесса должен совпадать с идентификатором создателя или "
"владельца набора семафоров, или вызывающий должен иметь расширенные права. "
"Аргумент I<semnum> игнорируется."

#. type: Plain text
#: man-pages/man2/semctl.2:182
msgid ""
"Return information about system-wide semaphore limits and parameters in the "
"structure pointed to by I<arg.__buf>.  This structure is of type I<seminfo>, "
"defined in I<E<lt>sys/sem.hE<gt>> if the B<_GNU_SOURCE> feature test macro "
"is defined:"
msgstr ""
"Возвращает параметры и информацию о системных ограничениях семафоров в "
"структуре, указанной в I<arg.__buf>. Данная структура имеет тип I<seminfo>, "
"который определён в I<E<lt>sys/sem.hE<gt>>, если определён макрос "
"тестирования свойств B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/semctl.2:204
#, no-wrap
msgid ""
"struct  seminfo {\n"
"    int semmap;  /* Number of entries in semaphore\n"
"                    map; unused within kernel */\n"
"    int semmni;  /* Maximum number of semaphore sets */\n"
"    int semmns;  /* Maximum number of semaphores in all\n"
"                    semaphore sets */\n"
"    int semmnu;  /* System-wide maximum number of undo\n"
"                    structures; unused within kernel */\n"
"    int semmsl;  /* Maximum number of semaphores in a\n"
"                    set */\n"
"    int semopm;  /* Maximum number of operations for\n"
"                    semop(2) */\n"
"    int semume;  /* Maximum number of undo entries per\n"
"                    process; unused within kernel */\n"
"    int semusz;  /* Size of struct sem_undo */\n"
"    int semvmx;  /* Maximum semaphore value */\n"
"    int semaem;  /* Max. value that can be recorded for\n"
"                    semaphore adjustment (SEM_UNDO) */\n"
"};\n"
msgstr ""
"struct  seminfo {\n"
"    int semmap;  /* количество записей в карте\n"
"                    семафоров; не используется в ядре */\n"
"    int semmni;  /* максимальное количество наборов\n"
"                    семафоров */\n"
"    int semmns;  /* максимальное количество семафоров во\n"
"                     всех наборах семафоров */\n"
"    int semmnu;  /* максимальное количество структур undo\n"
"                    в системе; не используется в ядре */\n"
"    int semmsl;  /* максимальное количество семафоров в\n"
"                    наборе */\n"
"    int semopm;  /* максимальное количество операция для\n"
"                    semop(2) */\n"
"    int semume;  /* максимальное количество записей undo на\n"
"                    процесс; не используется в ядре */\n"
"    int semusz;  /* размер struct sem_undo */\n"
"    int semvmx;  /* максимальное значение семафора */\n"
"    int semaem;  /* максимальное значение, которое может\n"
"                    быть записано для регулирования\n"
"                    семафора (SEM_UNDO) */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:218
msgid ""
"The I<semmsl>, I<semmns>, I<semopm>, and I<semmni> settings can be changed "
"via I</proc/sys/kernel/sem>; see B<proc>(5)  for details."
msgstr ""
"Значения I<semmsl>, I<semmns>, I<semopm> и I<semmni> можно изменить через I</"
"proc/sys/kernel/sem>; подробности в B<proc>(5)."

#. type: TP
#: man-pages/man2/semctl.2:218
#, no-wrap
msgid "B<SEM_INFO> (Linux-specific)"
msgstr "B<SEM_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/semctl.2:232
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by semaphores: the I<semusz> field returns "
"the number of semaphore sets that currently exist on the system; and the "
"I<semaem> field returns the total number of semaphores in all semaphore sets "
"on the system."
msgstr ""
"Возвращает структуру I<seminfo>, содержащую такую же информацию что и для "
"B<IPC_INFO>, за исключением того, что следующие поля содержат информацию о "
"системных ресурсах, потребляемых семафорами: в поле I<semusz> возвращается "
"количество наборов семафоров, существующих в системе; в поле I<semaem> "
"возвращается общее количество семафоров во всех наборах семафоров в системе."

#. type: TP
#: man-pages/man2/semctl.2:232
#, no-wrap
msgid "B<SEM_STAT> (Linux-specific)"
msgstr "B<SEM_STAT> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/semctl.2:243
msgid ""
"Return a I<semid_ds> structure as for B<IPC_STAT>.  However, the I<semid> "
"argument is not a semaphore identifier, but instead an index into the "
"kernel's internal array that maintains information about all semaphore sets "
"on the system."
msgstr ""
"Возвращает структуру I<semid_ds> как для B<IPC_STAT>. Однако аргумент "
"I<semid> содержит не идентификатор семафора, а индекс во внутреннем массиве "
"ядра, который хранит информацию о всех наборах семафоров в системе."

#. type: TP
#: man-pages/man2/semctl.2:243
#, no-wrap
msgid "B<SEM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr "B<SEM_STAT_ANY> (есть только в Linux-specific, начиная с Linux 4.17)"

#. type: Plain text
#: man-pages/man2/semctl.2:256
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<SEM_STAT>.  However, I<sem_perm.mode> is not checked for read access for "
"I<semid> meaning that any user can employ this operation (just as any user "
"may read I</proc/sysvipc/sem> to obtain the same information)."
msgstr ""
"Возвращает структуру I<seminfo>, содержащую информацию как у B<SEM_STAT>. "
"Однако I<sem_perm.mode> не проверяется на доступность чтения для I<semid>, "
"что означает, что эту операцию может выполнять пользователь (как и любой "
"пользователь, который может прочитать эту же информацию из I</proc/sysvipc/"
"sem>)."

#. type: TP
#: man-pages/man2/semctl.2:256
#, no-wrap
msgid "B<GETALL>"
msgstr "B<GETALL>"

#. type: Plain text
#: man-pages/man2/semctl.2:267
msgid ""
"Return B<semval> (i.e., the current value)  for all semaphores of the set "
"into I<arg.array>.  The argument I<semnum> is ignored.  The calling process "
"must have read permission on the semaphore set."
msgstr ""
"Возвращает значение B<semval> (т.е. текущее значение) всех семафоров в "
"наборе в I<arg.array>. Аргумент I<semnum> игнорируется. Вызывающему процессу "
"нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:267 man-pages/man2/semctl.2:362
#, no-wrap
msgid "B<GETNCNT>"
msgstr "B<GETNCNT>"

#. type: Plain text
#: man-pages/man2/semctl.2:280
msgid ""
"Return the value of B<semncnt> for the I<semnum>-th semaphore of the set (i."
"e., the number of processes waiting for an increase of B<semval> for the "
"I<semnum>-th semaphore of the set).  The calling process must have read "
"permission on the semaphore set."
msgstr ""
"Возвращает значение B<semncnt> для I<semnum>-того семафора (т.е., число "
"процессов, ожидающих увеличения значения B<semval> в I<semnum>-ом семафоре "
"набора). Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:280 man-pages/man2/semctl.2:366
#, no-wrap
msgid "B<GETPID>"
msgstr "B<GETPID>"

#. type: Plain text
#: man-pages/man2/semctl.2:290
msgid ""
"Return the value of B<sempid> for the I<semnum>-th semaphore of the set.  "
"This is the PID of the process that last performed an operation on that "
"semaphore (but see NOTES).  The calling process must have read permission on "
"the semaphore set."
msgstr ""
"Возвращает значение B<sempid> для I<semnum>-того семафора набора. Это PID "
"процесса, который последним выполнял операцию с этим семафором (но смотрите "
"ЗАМЕЧАНИЯ). Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:290 man-pages/man2/semctl.2:370
#, no-wrap
msgid "B<GETVAL>"
msgstr "B<GETVAL>"

#. type: Plain text
#: man-pages/man2/semctl.2:298
msgid ""
"Return the value of B<semval> for the I<semnum>-th semaphore of the set.  "
"The calling process must have read permission on the semaphore set."
msgstr ""
"Возвращает значение B<semval> для I<semnum>-того семафора набора. "
"Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:298 man-pages/man2/semctl.2:374
#, no-wrap
msgid "B<GETZCNT>"
msgstr "B<GETZCNT>"

#. type: Plain text
#: man-pages/man2/semctl.2:311
msgid ""
"Return the value of B<semzcnt> for the I<semnum>-th semaphore of the set (i."
"e., the number of processes waiting for B<semval> of the I<semnum>-th "
"semaphore of the set to become 0).  The calling process must have read "
"permission on the semaphore set."
msgstr ""
"Возвращает значение B<semzcnt> для I<semnum>-того семафора (т.е., количество "
"процессов, ожидающих, когда значение B<semval> I<semnum>-того семафора "
"набора станет равным 0). Вызывающему процессу нужны права на чтение набора "
"семафоров."

#. type: TP
#: man-pages/man2/semctl.2:311
#, no-wrap
msgid "B<SETALL>"
msgstr "B<SETALL>"

#. type: Plain text
#: man-pages/man2/semctl.2:333
msgid ""
"Set B<semval> for all semaphores of the set using I<arg.array>, updating "
"also the I<sem_ctime> member of the I<semid_ds> structure associated with "
"the set.  Undo entries (see B<semop>(2))  are cleared for altered semaphores "
"in all processes.  If the changes to semaphore values would permit blocked "
"B<semop>(2)  calls in other processes to proceed, then those processes are "
"woken up.  The argument I<semnum> is ignored.  The calling process must have "
"alter (write) permission on the semaphore set."
msgstr ""
"Устанавливает значение B<semval> всех семафоров набора, используя I<arg."
"array> и изменяя также поле I<sem_ctime> структуры I<semid_ds>, связанной с "
"набором. Записи undo (см. B<semop>(2)) очищаются для изменённых семафоров во "
"всех процессах. Если изменения значений семафоров приводят к отмене "
"блокировки в вызове B<semop>(2) других процессов, то эти процессы "
"пробуждаются. Аргумент I<semnum> игнорируется. Вызывающему процессу нужны "
"права на запись в набор семафоров."

#. type: TP
#: man-pages/man2/semctl.2:333
#, no-wrap
msgid "B<SETVAL>"
msgstr "B<SETVAL>"

#. type: Plain text
#: man-pages/man2/semctl.2:351
msgid ""
"Set the value of B<semval> to I<arg.val> for the I<semnum>-th semaphore of "
"the set, updating also the I<sem_ctime> member of the I<semid_ds> structure "
"associated with the set.  Undo entries are cleared for altered semaphores in "
"all processes.  If the changes to semaphore values would permit blocked "
"B<semop>(2)  calls in other processes to proceed, then those processes are "
"woken up.  The calling process must have alter permission on the semaphore "
"set."
msgstr ""
"Устанавливает значение B<semval> равным I<arg.val> для I<semnum>-го семафора "
"набора, изменяя также поле I<sem_ctime> в структуре I<semid_ds>, связанной с "
"этим набором. Записи undo очищаются для изменённых семафоров во всех "
"процессах. Если изменения значений семафоров приводят к отмене блокировки в "
"вызове B<semop>(2) других процессов, то эти процессы пробуждаются. Аргумент "
"I<semnum> игнорируется. Вызывающему процессу нужны права на запись в набор "
"семафоров."

#. type: Plain text
#: man-pages/man2/semctl.2:358
msgid "On failure, B<semctl>()  returns -1 with I<errno> indicating the error."
msgstr ""
"При ошибке B<semctl>() возвращает -1, а переменной I<errno> присваивается "
"номер ошибки."

#. type: Plain text
#: man-pages/man2/semctl.2:362
msgid ""
"Otherwise, the system call returns a nonnegative value depending on I<cmd> "
"as follows:"
msgstr ""
"При успешном выполнении системный вызов возвращает положительное значение, "
"зависящее от I<cmd>:"

#. type: Plain text
#: man-pages/man2/semctl.2:366
msgid "the value of B<semncnt>."
msgstr "значение B<semncnt>."

#. type: Plain text
#: man-pages/man2/semctl.2:370
msgid "the value of B<sempid>."
msgstr "значение B<sempid>."

#. type: Plain text
#: man-pages/man2/semctl.2:374
msgid "the value of B<semval>."
msgstr "значение B<semval>."

#. type: Plain text
#: man-pages/man2/semctl.2:378
msgid "the value of B<semzcnt>."
msgstr "значение B<semzcnt>."

#. type: TP
#: man-pages/man2/semctl.2:378
#, no-wrap
msgid "B<IPC_INFO>"
msgstr "B<IPC_INFO>"

#. type: Plain text
#: man-pages/man2/semctl.2:388
msgid ""
"the index of the highest used entry in the kernel's internal array recording "
"information about all semaphore sets.  (This information can be used with "
"repeated B<SEM_STAT> or B<SEM_STAT_ANY> operations to obtain information "
"about all semaphore sets on the system.)"
msgstr ""
"самое большое значение индекса, использованного в записи внутреннего массива "
"ядра, содержащего информацию о всех наборах семафоров (эта информация может "
"использоваться в повторяющихся операциях B<SEM_STAT> или B<SEM_STAT_ANY> для "
"получения информации о всех наборах семафоров в системе)."

#. type: TP
#: man-pages/man2/semctl.2:388
#, no-wrap
msgid "B<SEM_INFO>"
msgstr "B<SEM_INFO>"

#. type: Plain text
#: man-pages/man2/semctl.2:392
msgid "as for B<IPC_INFO>."
msgstr "как для B<IPC_INFO>."

#. type: TP
#: man-pages/man2/semctl.2:392
#, no-wrap
msgid "B<SEM_STAT>"
msgstr "B<SEM_STAT>"

#. type: Plain text
#: man-pages/man2/semctl.2:396
msgid "the identifier of the semaphore set whose index was given in I<semid>."
msgstr "идентификатор набора семафоров, индекс которого указан в I<semid>."

#. type: TP
#: man-pages/man2/semctl.2:396
#, no-wrap
msgid "B<SEM_STAT_ANY>"
msgstr "B<SEM_STAT_ANY>"

#. type: Plain text
#: man-pages/man2/semctl.2:400
msgid "as for B<SEM_STAT>."
msgstr "как у B<SEM_STAT>."

#. type: Plain text
#: man-pages/man2/semctl.2:404
msgid "All other I<cmd> values return 0 on success."
msgstr "Для всех остальных значений I<cmd> возвращается 0."

#. type: Plain text
#: man-pages/man2/semctl.2:428
msgid ""
"The argument I<cmd> has one of the values B<GETALL>, B<GETPID>, B<GETVAL>, "
"B<GETNCNT>, B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SEM_STAT_ANY>, "
"B<SETALL>, or B<SETVAL> and the calling process does not have the required "
"permissions on the semaphore set and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"Аргумент I<cmd> равен B<GETALL>, B<GETPID>, B<GETVAL>, B<GETNCNT>, "
"B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SEM_STAT_ANY>, B<SETALL> или "
"B<SETVAL> и вызывающий процесс не имеет требуемых прав на набор семафоров и "
"не имеет мандата B<CAP_IPC_OWNER> в пользовательском пространстве имён, "
"которое управляет своим пространством имён IPC."

#. type: Plain text
#: man-pages/man2/semctl.2:435
msgid "The address pointed to by I<arg.buf> or I<arg.array> isn't accessible."
msgstr "Адрес, указанный в I<arg.buf> или I<arg.array>, недоступен."

#. type: Plain text
#: man-pages/man2/semctl.2:438
msgid "The semaphore set was removed."
msgstr "Набор семафоров был удалён."

#. type: Plain text
#: man-pages/man2/semctl.2:449
msgid ""
"Invalid value for I<cmd> or I<semid>.  Or: for a B<SEM_STAT> operation, the "
"index value specified in I<semid> referred to an array slot that is "
"currently unused."
msgstr ""
"Неверное значение I<cmd> или I<semid>. Или: при операции B<SEM_STAT> "
"значение индекса, указанное в I<semid>, ссылается на место в массиве, "
"которое в данные момент не используется."

#. type: Plain text
#: man-pages/man2/semctl.2:467
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID> but the "
"effective user ID of the calling process is not the creator (as found in "
"I<sem_perm.cuid>)  or the owner (as found in I<sem_perm.uid>)  of the "
"semaphore set, and the process does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""
"Аргумент I<cmd> имеет значение B<IPC_SET> или B<IPC_RMID>, но эффективный "
"идентификатор пользователя вызывающего процесса не совпадает с ID создателя "
"(указанного в I<sem_perm.cuid>) или с ID владельца (указанного в I<sem_perm."
"uid>) набора семафоров, и процесс не имеет мандата B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/semctl.2:480
msgid ""
"The argument I<cmd> has the value B<SETALL> or B<SETVAL> and the value to "
"which B<semval> is to be set (for some semaphore of the set) is less than 0 "
"or greater than the implementation limit B<SEMVMX>."
msgstr ""
"Аргумент I<cmd> имеет значение B<SETALL> или B<SETVAL> и значение, "
"присваиваемое B<semval> (для какого-то семафора в наборе), меньше нуля или "
"больше, чем ограничение реализации B<SEMVMX>."

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/semctl.2:495
msgid ""
"POSIX.1 specifies the I<sem_nsems> field of the I<semid_ds> structure as "
"having the type I<unsigned\\ short>, and the field is so defined on most "
"other systems.  It was also so defined on Linux 2.2 and earlier, but, since "
"Linux 2.4, the field has the type I<unsigned\\ long>."
msgstr ""
"В POSIX.1 указано, что поле I<sem_nsems> структуры I<semid_ds> имеет тип "
"I<unsigned\\ short>, и это так на в большинстве других систем. Это было и в "
"Linux 2.2 и более ранних версиях, но начиная с Linux 2.4 это поле имеет тип "
"I<unsigned\\ long>."

#. type: Plain text
#: man-pages/man2/semctl.2:520
msgid ""
"The B<IPC_INFO>, B<SEM_STAT> and B<SEM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""
"Операции B<IPC_INFO>, B<SEM_STAT> и B<SEM_INFO> используются программой "
"B<ipcs>(1) для получения информации о выделенных ресурсах. В будущем для "
"этого может быть задействован интерфейс файловой системы I</proc>."

#. type: Plain text
#: man-pages/man2/semctl.2:533
msgid ""
"Various fields in a I<struct semid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"В Linux 2.2 различные поля I<struct semid_ds> имели тип I<short>. В Linux "
"2.4 тип был изменён на I<long>. Для задействования преимуществ этого "
"изменения необходима перекомпиляция программы с glibc-2.1.91 или более "
"поздней версией (ядро различает старые и новые вызовы по флагу B<IPC_64> в "
"аргументе I<cmd>)."

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/semctl.2:543
msgid ""
"In some earlier versions of glibc, the I<semun> union was defined in "
"I<E<lt>sys/sem.hE<gt>>, but POSIX.1 requires that the caller define this "
"union.  On versions of glibc where this union is I<not> defined, the macro "
"B<_SEM_SEMUN_UNDEFINED> is defined in I<E<lt>sys/sem.hE<gt>>."
msgstr ""
"В некоторых ранних версиях glibc объединение I<semun> определялось в "
"I<E<lt>sys/sem.hE<gt>>, но в POSIX.1 требовалось, чтобы это объединение "
"определял вызывающий. В версиях glibc, в которых это объединение I<не> "
"определено, в I<E<lt>sys/sem.hE<gt>> определён макрос "
"B<_SEM_SEMUN_UNDEFINED>."

#. type: Plain text
#: man-pages/man2/semctl.2:547
msgid ""
"The following system limit on semaphore sets affects a B<semctl>()  call:"
msgstr ""
"На работу наборов семафоров и вызова B<semctl>() влияет системное "
"ограничение:"

#. type: TP
#: man-pages/man2/semctl.2:547
#, no-wrap
msgid "B<SEMVMX>"
msgstr "B<SEMVMX>"

#. type: Plain text
#: man-pages/man2/semctl.2:552
msgid "Maximum value for B<semval>: implementation dependent (32767)."
msgstr "Максимальное значение B<semval>: зависит от реализации (32767)."

#. type: Plain text
#: man-pages/man2/semctl.2:557
msgid ""
"For greater portability, it is best to always call B<semctl>()  with four "
"arguments."
msgstr ""
"Для лучшей переносимости программ желательно всегда вызывать B<semctl>() c "
"четырьмя аргументам."

#. type: SS
#: man-pages/man2/semctl.2:557
#, no-wrap
msgid "The sempid value"
msgstr "Значение sempid"

#. type: Plain text
#: man-pages/man2/semctl.2:566
msgid ""
"POSIX.1 defines I<sempid> as the \"process ID of [the] last operation\" on a "
"semaphore, and explicitly notes that this value is set by a successful "
"B<semop>(2)  call, with the implication that no other interface affects the "
"I<sempid> value."
msgstr ""
"В POSIX.1 значение I<sempid> определено как «ID процесса последней операции» "
"над семафором, и явно отмечено, что это значение устанавливается успешным "
"вызовом B<semop>(2), подразумевая, что больше никто не изменяет I<sempid>."

#.  At least OpenSolaris (and, one supposes, older Solaris) and Darwin
#. type: Plain text
#: man-pages/man2/semctl.2:584
msgid ""
"While some implementations conform to the behavior specified in POSIX.1, "
"others do not.  (The fault here probably lies with POSIX.1 inasmuch as it "
"likely failed to capture the full range of existing implementation "
"behaviors.)  Various other implementations also update I<sempid> for the "
"other operations that update the value of a semaphore: the B<SETVAL> and "
"B<SETALL> operations, as well as the semaphore adjustments performed on "
"process termination as a consequence of the use of the B<SEM_UNDO> flag (see "
"B<semop>(2))."
msgstr ""
"Одни реализации следуют требованиям, указанным в POSIX.1, а другие нет (вина "
"здесь, вероятно, лежит на POSIX.1, так как ему не удастся охватить поведение "
"всех существующих реализаций). Также, разные реализации обновляют I<sempid> "
"другими операциями, обновляющими значение семафора: B<SETVAL> и B<SETALL>, а "
"также изменение семафора, выполняемое при завершении процесса как следствие "
"использования флага B<SEM_UNDO> (смотрите B<semop>(2))."

#.  commit a5f4db877177d2a3d7ae62a7bac3a5a27e083d7f
#. type: Plain text
#: man-pages/man2/semctl.2:599
msgid ""
"Linux also updates I<sempid> for B<SETVAL> operations and semaphore "
"adjustments.  However, somewhat inconsistently, up to and including 4.5, "
"Linux did not update I<sempid> for B<SETALL> operations.  This was rectified "
"in Linux 4.6."
msgstr ""
"Linux также обновляет I<sempid> при операциях B<SETVAL> и регулировки "
"семафора. Однако, непоследовательно, ранние версии Linux по 4.5 включительно "
"не обновляли I<sempid> при операциях B<SETALL>. Это было исправлено в Linux "
"4.6."

#. type: Plain text
#: man-pages/man2/semctl.2:605
msgid ""
"B<ipc>(2), B<semget>(2), B<semop>(2), B<capabilities>(7), "
"B<sem_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/seteuid.2:29
#, no-wrap
msgid "SETEUID"
msgstr "SETEUID"

#. type: Plain text
#: man-pages/man2/seteuid.2:32
msgid "seteuid, setegid - set effective user or group ID"
msgstr ""
"seteuid, setegid - устанавливает эффективный идентификатор пользователя или "
"группы"

#. type: Plain text
#: man-pages/man2/seteuid.2:38
msgid "B<int seteuid(uid_t >I<euid>B<);>"
msgstr "B<int seteuid(uid_t >I<euid>B<);>"

#. type: Plain text
#: man-pages/man2/seteuid.2:40
msgid "B<int setegid(gid_t >I<egid>B<);>"
msgstr "B<int setegid(gid_t >I<egid>B<);>"

#. type: Plain text
#: man-pages/man2/seteuid.2:49
msgid "B<seteuid>(), B<setegid>():"
msgstr "B<seteuid>(), B<setegid>():"

#. type: Plain text
#: man-pages/man2/seteuid.2:52
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/seteuid.2:59
msgid ""
"B<seteuid>()  sets the effective user ID of the calling process.  "
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID or the saved set-user-ID."
msgstr ""
"Вызов B<seteuid>() устанавливает эффективный идентификатор пользователя "
"вызывающего процесса. Непривилегированные процессы могут менять эффективный "
"идентификатор пользователя только на действительный, эффективный или "
"сохранённый идентификатор пользователя."

#.  When
#.  .I euid
#.  equals \-1, nothing is changed.
#.  (This is an artifact of the implementation in glibc of seteuid()
#.  using setresuid(2).)
#. type: Plain text
#: man-pages/man2/seteuid.2:68
msgid ""
"Precisely the same holds for B<setegid>()  with \"group\" instead of \"user"
"\"."
msgstr ""
"Тоже самое справедливо при работе B<setegid>() с «групповым» "
"идентификатором, а не «пользовательским»."

#. type: Plain text
#: man-pages/man2/seteuid.2:80
msgid ""
"I<Note>: there are cases where B<seteuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<seteuid>()."
msgstr ""
"I<Замечание>: есть случаи, когда B<seteuid>() может завершиться с ошибкой "
"даже когда UID вызывающего равен 0; это серьёзная ошибка безопасности — не "
"проверять возвращаемое значение B<seteuid>()."

#. type: Plain text
#: man-pages/man2/seteuid.2:84
msgid "The target user or group ID is not valid in this user namespace."
msgstr ""
"Целевой идентификатор пользователя или группы некорректен в этом "
"пользовательском пространстве имён."

#. type: Plain text
#: man-pages/man2/seteuid.2:94
msgid ""
"In the case of B<seteuid>(): the calling process is not privileged (does not "
"have the B<CAP_SETUID> capability in its user namespace) and I<euid> does "
"not match the current real user ID, current effective user ID, or current "
"saved set-user-ID."
msgstr ""
"Для B<seteuid>(): вызывающий процесс не имеет прав (не имеет мандата "
"B<CAP_SETUID> в своём пространстве имён пользователя) и I<euid> не совпадает "
"с текущим действительным, эффективным или сохранённым идентификатором "
"пользователя."

#. type: Plain text
#: man-pages/man2/seteuid.2:103
msgid ""
"In the case of B<setegid>(): the calling process is not privileged (does not "
"have the B<CAP_SETGID> capability in its user namespace) and I<egid> does "
"not match the current real group ID, current effective group ID, or current "
"saved set-group-ID."
msgstr ""
"Для B<setegid>(): вызывающий процесс не имеет прав (не имеет мандата "
"B<CAP_SETGID> в своём пространстве имён пользователя) и I<egid> не совпадает "
"с текущим действительным, эффективным или сохранённым идентификатором группы."

#. type: Plain text
#: man-pages/man2/seteuid.2:105
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: man-pages/man2/seteuid.2:111
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38).  On an arbitrary system "
"one should check B<_POSIX_SAVED_IDS>."
msgstr ""
"Установка эффективного идентификатора пользователя (группы) в сохранённый "
"идентификатор пользователя (группы) возможна с версии Linux 1.1.37 (1.1.38). "
"В других системах надо проверять B<_POSIX_SAVED_IDS>."

#. type: Plain text
#: man-pages/man2/seteuid.2:127
msgid ""
"Under glibc 2.0, B<seteuid(>I<euid>B<)> is equivalent to B<setreuid(-1,>I< "
"euid>B<)> and hence may change the saved set-user-ID.  Under glibc 2.1 and "
"later, it is equivalent to B<setresuid(-1,>I< euid>B<, -1)> and hence does "
"not change the saved set-user-ID.  Analogous remarks hold for B<setegid>(), "
"with the difference that the change in implementation from B<setregid(-1,>I< "
"egid>B<)> to B<setresgid(-1,>I< egid>B<, -1)> occurred in glibc 2.2 or 2.3 "
"(depending on the hardware architecture)."
msgstr ""
"В glibc 2.0 вызов B<seteuid(>I<euid>B<)>эквивалентен B<setreuid(-1,>I< "
"euid>B<)>, и поэтому может изменить сохранённый идентификатор пользователя. "
"В glibc 2.1 и новее он эквивалентен B<setresuid(-1,>I< euid>B<, -1)> и "
"поэтому не изменяет сохранённый идентификатор пользователя. Аналогичные "
"замечания относятся и к B<setegid>(), с той разницей, что изменение в "
"реализации из B<setregid(-1,>I< egid>B<)> в B<setresgid(-1,>I< egid>B<, -1)> "
"произошло в glibc 2.2 или 2.3 (зависит от аппаратной архитектуры)."

#. type: Plain text
#: man-pages/man2/seteuid.2:136
msgid ""
"According to POSIX.1, B<seteuid>()  (B<setegid>())  need not permit I<euid> "
"(I<egid>)  to be the same value as the current effective user (group) ID, "
"and some implementations do not permit this."
msgstr ""
"Согласно POSIX.1, B<seteuid>() (B<setegid>()) необходимо запрещать I<euid> "
"(I<egid>) равный текущему эффективному идентификатору пользователя (группе), "
"и некоторые реализации не позволяют этого."

#. type: Plain text
#: man-pages/man2/seteuid.2:145
msgid ""
"On Linux, B<seteuid>()  and B<setegid>()  are implemented as library "
"functions that call, respectively, B<setreuid>(2)  and B<setregid>(2)."
msgstr ""
"В Linux, B<seteuid>() и B<setegid>() реализованы в виде библиотечных "
"функций, которые вызывают B<setreuid>(2) и B<setregid>(2), соответственно."

#. type: Plain text
#: man-pages/man2/seteuid.2:152
msgid ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"

#. type: Plain text
#: man-pages/man2/socket.2:46
msgid "socket - create an endpoint for communication"
msgstr "socket - создаёт конечную точку соединения"

#. type: Plain text
#: man-pages/man2/socket.2:48
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr "B<#include E<lt>sys/types.hE<gt>> /* смотрите ЗАМЕЧАНИЯ */"

#. type: Plain text
#: man-pages/man2/socket.2:52
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"

#. type: Plain text
#: man-pages/man2/socket.2:58
msgid ""
"B<socket>()  creates an endpoint for communication and returns a file "
"descriptor that refers to that endpoint.  The file descriptor returned by a "
"successful call will be the lowest-numbered file descriptor not currently "
"open for the process."
msgstr ""
"Системный вызов B<socket>() создаёт конечную точку соединения и возвращает "
"файловый дескриптор, указывающий на эту точку. Возвращаемый при успешном "
"выполнении файловый дескриптор будет иметь самый маленький номер, который не "
"используется процессом."

#. type: Plain text
#: man-pages/man2/socket.2:66
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The formats currently understood by "
"the Linux kernel include:"
msgstr ""
"Параметр I<domain> задает домен соединения: выбирает семейство протоколов, "
"которое будет использоваться для соединения. Семейства описаны в I<E<lt>sys/"
"socket.hE<gt>>. В настоящее время ядром Linux распознаются следующие форматы:"

#. type: tbl table
#: man-pages/man2/socket.2:69
#, no-wrap
msgid "Name"
msgstr "Имя"

#. type: tbl table
#: man-pages/man2/socket.2:69
#, no-wrap
msgid "Purpose"
msgstr "Цель"

#. type: tbl table
#: man-pages/man2/socket.2:72
#, no-wrap
msgid "B<AF_UNIX>"
msgstr "B<AF_UNIX>"

#. type: tbl table
#: man-pages/man2/socket.2:74
#, no-wrap
msgid "Local communication"
msgstr "Локальное соединение"

#. type: tbl table
#: man-pages/man2/socket.2:76
#, no-wrap
msgid "B<unix>(7)"
msgstr "B<unix>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:79
#, no-wrap
msgid "B<AF_LOCAL>"
msgstr "B<AF_LOCAL>"

#. type: tbl table
#: man-pages/man2/socket.2:82
#, no-wrap
msgid ""
"Synonym for\n"
"B<AF_UNIX>"
msgstr ""
"Синоним\n"
"B<AF_UNIX>"

#. type: tbl table
#: man-pages/man2/socket.2:86
#, no-wrap
msgid "B<AF_INET>"
msgstr "B<AF_INET>"

#. type: tbl table
#: man-pages/man2/socket.2:86
#, no-wrap
msgid "IPv4 Internet protocols"
msgstr "Протоколы Интернет IPv4"

#. type: tbl table
#: man-pages/man2/socket.2:88
#, no-wrap
msgid "B<ip>(7)"
msgstr "B<ip>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:91
#, no-wrap
msgid "B<AF_AX25>"
msgstr "B<AF_AX25>"

#. type: tbl table
#: man-pages/man2/socket.2:93
#, no-wrap
msgid "Amateur radio AX.25 protocol"
msgstr "Протокол любительского радио AX.25"

#.  Part of ax25-tools
#. type: tbl table
#: man-pages/man2/socket.2:96
#, no-wrap
msgid "B<ax25>(4)"
msgstr "B<ax25>(4)"

#. type: tbl table
#: man-pages/man2/socket.2:99
#, no-wrap
msgid "B<AF_IPX>"
msgstr "B<AF_IPX>"

#. type: tbl table
#: man-pages/man2/socket.2:99
#, no-wrap
msgid "IPX - Novell protocols"
msgstr "Протоколы Novell IPX"

#. type: tbl table
#: man-pages/man2/socket.2:102
#, no-wrap
msgid "B<AF_APPLETALK>"
msgstr "B<AF_APPLETALK>"

#. type: tbl table
#: man-pages/man2/socket.2:102
#, no-wrap
msgid "AppleTalk"
msgstr "AppleTalk"

#. type: tbl table
#: man-pages/man2/socket.2:104
#, no-wrap
msgid "B<ddp>(7)"
msgstr "B<ddp>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:107
#, no-wrap
msgid "B<AF_X25>"
msgstr "B<AF_X25>"

#. type: tbl table
#: man-pages/man2/socket.2:107
#, no-wrap
msgid "ITU-T X.25 / ISO-8208 protocol"
msgstr "Протокол ITU-T X.25/ISO-8208"

#. type: tbl table
#: man-pages/man2/socket.2:109
#, no-wrap
msgid "B<x25>(7)"
msgstr "B<x25>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:112
#, no-wrap
msgid "B<AF_INET6>"
msgstr "B<AF_INET6>"

#. type: tbl table
#: man-pages/man2/socket.2:112
#, no-wrap
msgid "IPv6 Internet protocols"
msgstr "Протоколы Интернет IPv6"

#. type: tbl table
#: man-pages/man2/socket.2:114
#, no-wrap
msgid "B<ipv6>(7)"
msgstr "B<ipv6>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:117
#, no-wrap
msgid "B<AF_DECnet>"
msgstr "B<AF_DECnet>"

#. type: tbl table
#: man-pages/man2/socket.2:119
#, no-wrap
msgid "DECet protocol sockets"
msgstr "Протокольные сокеты DECet"

#. type: tbl table
#: man-pages/man2/socket.2:122
#, no-wrap
msgid "B<AF_KEY>"
msgstr "B<AF_KEY>"

#. type: tbl table
#: man-pages/man2/socket.2:124
#, no-wrap
msgid "Key management protocol, originally developed for usage with IPsec"
msgstr "Протокол управления ключами, изначально разрабатывавшийся для использования с IPsec"

#. type: tbl table
#: man-pages/man2/socket.2:127
#, no-wrap
msgid "B<AF_NETLINK>"
msgstr "B<AF_NETLINK>"

#. type: tbl table
#: man-pages/man2/socket.2:129
#, no-wrap
msgid "Kernel user interface device"
msgstr "Устройство для взаимодействия с ядром"

#. type: tbl table
#: man-pages/man2/socket.2:131
#, no-wrap
msgid "B<netlink>(7)"
msgstr "B<netlink>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:134
#, no-wrap
msgid "B<AF_PACKET>"
msgstr "B<AF_PACKET>"

#. type: tbl table
#: man-pages/man2/socket.2:136
#, no-wrap
msgid "Low-level packet interface"
msgstr "Низкоуровневый пакетный интерфейс"

#. type: tbl table
#: man-pages/man2/socket.2:138
#, no-wrap
msgid "B<packet>(7)"
msgstr "B<packet>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:141
#, no-wrap
msgid "B<AF_RDS>"
msgstr "B<AF_RDS>"

#.  commit: 639b321b4d8f4e412bfbb2a4a19bfebc1e68ace4
#. type: tbl table
#: man-pages/man2/socket.2:144
#, no-wrap
msgid "Reliable Datagram Sockets (RDS) protocol"
msgstr "Протокол надёжных датаграмный сокетов (RDS)"

#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds.7
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds-rdma.7
#. type: tbl table
#: man-pages/man2/socket.2:148
#, no-wrap
msgid "B<rds>(7)\n"
msgstr " "

#. type: tbl table
#: man-pages/man2/socket.2:150
#, no-wrap
msgid "B<rds-rdma>(7)"
msgstr "B<rds-rdma>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:153
#, no-wrap
msgid "B<AF_PPPOX>"
msgstr "B<AF_PPPOX>"

#. type: tbl table
#: man-pages/man2/socket.2:156
#, no-wrap
msgid ""
"Generic PPP transport layer, for setting up up L2 tunnels\n"
"(L2TP and PPPoE)"
msgstr ""
"Транспортный слой PPP общего назначения для поднятия\n"
"туннелей L2 (L2TP и PPPoE)"

#. type: tbl table
#: man-pages/man2/socket.2:159
#, no-wrap
msgid "B<AF_LLC>"
msgstr "B<AF_LLC>"

#.  linux-history commit: 34beb106cde7da233d4df35dd3d6cf4fee937caa
#. type: tbl table
#: man-pages/man2/socket.2:162
#, no-wrap
msgid "Logical link control (IEEE 802.2 LLC) protocol"
msgstr "Протокол управления логической связью (IEEE 802.2 LLC)"

#. type: tbl table
#: man-pages/man2/socket.2:165
#, no-wrap
msgid "B<AF_IB>"
msgstr "B<AF_IB>"

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: man-pages/man2/socket.2:168
#, no-wrap
msgid "InfiniBand native addressing"
msgstr "Собственная адресация InfiniBand"

#. type: tbl table
#: man-pages/man2/socket.2:171
#, no-wrap
msgid "B<AF_MPLS>"
msgstr "B<AF_MPLS>"

#.  commits: 0189197f441602acdca3f97750d392a895b778fd
#. type: tbl table
#: man-pages/man2/socket.2:174
#, no-wrap
msgid "Multiprotocol Label Switching"
msgstr "Многопротокольная коммутация по меткам"

#. type: tbl table
#: man-pages/man2/socket.2:177
#, no-wrap
msgid "B<AF_CAN>"
msgstr "B<AF_CAN>"

#.  commits: 8dbde28d9711475a..5423dd67bd0108a1
#. type: tbl table
#: man-pages/man2/socket.2:180
#, no-wrap
msgid "Controller Area Network automotive bus protocol"
msgstr "Протокол шины сети транспортных контроллеров"

#. type: tbl table
#: man-pages/man2/socket.2:183
#, no-wrap
msgid "B<AF_TIPC>"
msgstr "B<AF_TIPC>"

#.  commits: b97bf3fd8f6a16966d4f18983b2c40993ff937d4
#. type: tbl table
#: man-pages/man2/socket.2:186
#, no-wrap
msgid "TIPC, \"cluster domain sockets\" protocol"
msgstr "Протокол «кластерных доменных сокетов» TIPC"

#. type: tbl table
#: man-pages/man2/socket.2:189
#, no-wrap
msgid "B<AF_BLUETOOTH>"
msgstr "B<AF_BLUETOOTH>"

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: man-pages/man2/socket.2:192
#, no-wrap
msgid "Bluetooth low-level socket protocol"
msgstr "Сокетный протокол Bluetooth низкого уровня"

#. type: tbl table
#: man-pages/man2/socket.2:195
#, no-wrap
msgid "B<AF_ALG>"
msgstr "B<AF_ALG>"

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: man-pages/man2/socket.2:198
#, no-wrap
msgid "Interface to kernel crypto API"
msgstr "Интерфейс к ядерному крипто-API"

#. type: tbl table
#: man-pages/man2/socket.2:201
#, no-wrap
msgid "B<AF_VSOCK>"
msgstr "B<AF_VSOCK>"

#.  commit: d021c344051af91f42c5ba9fdedc176740cbd238
#. type: tbl table
#: man-pages/man2/socket.2:205
#, no-wrap
msgid ""
"VSOCK (originally \"VMWare VSockets\") protocol\n"
"for hypervisor-guest communication"
msgstr ""
"Протокол VSOCK (изначально «VMWare VSockets»)\n"
"для связей гипервизор-гость"

#. type: tbl table
#: man-pages/man2/socket.2:207
#, no-wrap
msgid "B<vsock>(7)"
msgstr "B<vsock>(7)"

#. type: tbl table
#: man-pages/man2/socket.2:210
#, no-wrap
msgid "B<AF_KCM>"
msgstr "B<AF_KCM>"

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: man-pages/man2/socket.2:213
#, no-wrap
msgid "KCM (kernel connection multiplexor) interface"
msgstr "Интерфейс KCM (мультиплексор соединений ядра)"

#. type: tbl table
#: man-pages/man2/socket.2:216
#, no-wrap
msgid "B<AF_XDP>"
msgstr "B<AF_XDP>"

#.  commit: c0c77d8fb787cfe0c3fca689c2a30d1dad4eaba7
#. type: tbl table
#: man-pages/man2/socket.2:219
#, no-wrap
msgid "XDP (express data path) interface"
msgstr "Интерфейс XDP (express data path)"

#. type: Plain text
#: man-pages/man2/socket.2:225
msgid ""
"Further details of the above address families, as well as information on "
"several other address families, can be found in B<address_families>(7)."
msgstr ""
"Подробнее об адресных семействах, приведённых выше, а также информацию о "
"других адресных семействах можно найти в B<address_families>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:231
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""
"Сокет имеет тип I<type>, задающий семантику соединения. В настоящее время "
"определены следующие типы:"

#. type: TP
#: man-pages/man2/socket.2:231
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr "B<SOCK_STREAM>"

#. type: Plain text
#: man-pages/man2/socket.2:235
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""
"Обеспечивает создание двусторонних, надёжных потоков байтов на основе "
"установления соединения. Может также поддерживаться механизм внепоточных "
"данных."

#. type: TP
#: man-pages/man2/socket.2:235
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr "B<SOCK_DGRAM>"

#. type: Plain text
#: man-pages/man2/socket.2:239
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr ""
"Поддерживает дейтаграммы (ненадежные сообщения с ограниченной длиной без "
"установки соединения)."

#. type: TP
#: man-pages/man2/socket.2:239
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr "B<SOCK_SEQPACKET>"

#. type: Plain text
#: man-pages/man2/socket.2:244
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""
"Обеспечивает работу последовательного двустороннего канала для передачи "
"дейтаграмм на основе соединений; дейтаграммы имеют постоянный размер; от "
"получателя требуется за один раз прочитать целый пакет."

#. type: TP
#: man-pages/man2/socket.2:244
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr "B<SOCK_RAW>"

#. type: Plain text
#: man-pages/man2/socket.2:247
msgid "Provides raw network protocol access."
msgstr "Обеспечивает прямой доступ к сетевому протоколу."

#. type: TP
#: man-pages/man2/socket.2:247
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr "B<SOCK_RDM>"

#. type: Plain text
#: man-pages/man2/socket.2:250
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr ""
"Обеспечивает надежную доставку дейтаграмм без гарантии, что они будут "
"расположены по порядку."

#. type: TP
#: man-pages/man2/socket.2:250
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr "B<SOCK_PACKET>"

#. type: Plain text
#: man-pages/man2/socket.2:255
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""
"Устарел и не должен использоваться в новых программах; см. B<packet>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:257
msgid "Some socket types may not be implemented by all protocol families."
msgstr ""
"Некоторые типы сокетов могут быть не реализованы во всех семействах "
"протоколов."

#. type: Plain text
#: man-pages/man2/socket.2:265
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""
"Начиная с Linux 2.6.27, аргумент I<type> предназначается для двух вещей: "
"кроме определения типа сокета, для изменения поведения B<socket>() он может "
"содержать побитно сложенные любые следующие значения:"

#. type: TP
#: man-pages/man2/socket.2:265
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr "B<SOCK_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/socket.2:275
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"Устанавливает флаг состояния файла B<O_NONBLOCK> для нового открытого "
"файлового описания (смотрите B<open>(2)), на которое ссылается новый "
"файловый дескриптор. Использование данного флага делает ненужными "
"дополнительные вызовы B<fcntl>(2) для достижения того же результата."

#. type: TP
#: man-pages/man2/socket.2:275
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr "B<SOCK_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/socket.2:285
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для нового открытого "
"файлового дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для "
"того, чтобы узнать как это может пригодиться."

#. type: Plain text
#: man-pages/man2/socket.2:301
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""
"В I<protocol> задаётся определённый протокол, используемый с сокетом. "
"Обычно, только единственный протокол существует для поддержи определённого "
"типа сокета с заданным семейством протоколов, в этом случае в I<protocol> "
"можно указать 0. Однако, может существовать несколько протоколов, тогда "
"нужно указать один из них. Номер используемого протокола зависит от \"домена "
"соединения'', по которому устанавливается соединение; см. B<protocols>(5). "
"Смотрите B<getprotoent>(3), где описано, как соотносить имена протоколов с "
"их номерами."

#. type: Plain text
#: man-pages/man2/socket.2:331
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams.  They do not "
"preserve record boundaries.  A stream socket must be in a I<connected> state "
"before any data may be sent or received on it.  A connection to another "
"socket is created with a B<connect>(2)  call.  Once connected, data may be "
"transferred using B<read>(2)  and B<write>(2)  calls or some variant of the "
"B<send>(2)  and B<recv>(2)  calls.  When a session has been completed a "
"B<close>(2)  may be performed.  Out-of-band data may also be transmitted as "
"described in B<send>(2)  and received as described in B<recv>(2)."
msgstr ""
"Сокеты типа B<SOCK_STREAM> являются соединениями полнодуплексных байтовых "
"потоков. Они не сохраняют границы записей. Потоковый сокет должен быть в "
"состоянии I<соединения> перед тем, как из него можно будет отсылать данные "
"или принимать их. Соединение с другим сокетом создается с помощью системного "
"вызова B<connect>(2). После соединения данные можно передавать с помощью "
"системных вызовов B<read>(2) и B<write>(2) или одного из вариантов системных "
"вызовов B<send>(2) и B<recv>(2). Когда сеанс закончен, выполняется команда "
"B<close>(2). Внепоточные данные могут передаваться, как описано в "
"B<send>(2), и приниматься, как описано в B<recv>(2)."

#. type: Plain text
#: man-pages/man2/socket.2:357
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""
"Протоколы связи, которые реализуют B<SOCK_STREAM>, следят, чтобы данные не "
"были потеряны или дублированы. Если часть данных, для которых имеется место "
"в буфере протокола, не может быть передана за определённое время, соединение "
"считается разорванным. Когда в сокете включен флаг B<SO_KEEPALIVE>, протокол "
"каким-либо способом проверяет, не отключена ли ещё другая сторона. Если "
"процесс посылает или принимает данные, пользуясь «разорванным» потоком, ему "
"выдаётся сигнал B<SIGPIPE>; это приводит к тому, что процессы, не "
"обрабатывающие этот сигнал, завершаются. Сокеты B<SOCK_SEQPACKET> используют "
"те же самые системные вызовы, что и сокеты B<SOCK_STREAM>. Единственное "
"отличие в том, что вызовы B<read>(2) возвращают только запрошенное "
"количество данных, а остальные данные пришедшего пакета будут отброшены. "
"Границы сообщений во входящих дейтаграммах сохраняются."

#. type: Plain text
#: man-pages/man2/socket.2:367
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""
"Сокеты B<SOCK_DGRAM> и B<SOCK_RAW> позволяют посылать дейтаграммы "
"принимающей стороне, заданной при вызове B<sendto>(2). Дейтаграммы обычно "
"принимаются с помощью вызова B<recvfrom>(2), который возвращает следующую "
"дейтаграмму с соответствующим обратным адресом."

#. type: Plain text
#: man-pages/man2/socket.2:374
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""
"Тип B<SOCK_PACKET> считается устаревшим типом сокета; он позволяет получать "
"необработанные пакеты прямо от драйвера устройства. Используйте вместо него "
"B<packet>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:397
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""
"Системный вызов B<fcntl>(2) с аргументом B<F_SETOWN> может использоваться "
"для задания группы процессов, которая будет получать сигнал B<SIGURG>, когда "
"прибывают внепоточные данные, или сигнал B<SIGPIPE>, когда соединение типа "
"B<SOCK_STREAM> неожиданно обрывается. Этот вызов также можно использовать, "
"чтобы задать процесс или группу процессов, которые получают асинхронные "
"уведомления о событиях ввода-вывода с помощью B<SIGIO>. Использование "
"B<F_SETOWN>  эквивалентно использованию вызова B<ioctl>(2) с аргументом "
"B<FIOSETOWN> или B<SIOCSPGRP>."

#. type: Plain text
#: man-pages/man2/socket.2:407
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using an ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr ""
"Когда сеть сообщает модулю протокола об ошибке (например, в случае IP, "
"используя ICMP-сообщение), то для сокета устанавливается флаг ожидающей "
"ошибки. Следующая операция этого сокета вернёт код ожидающей ошибки. "
"Некоторые протоколы позволяют организовывать очередь ошибок в сокете для "
"получения подробной информацию об ошибке; смотрите B<IP_RECVERR> в B<ip>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:417
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options."
msgstr ""
"Операции сокетов контролируются их параметрами I<options>. Эти параметры "
"описаны в I<E<lt>sys/socket.hE<gt>>. Вызовы B<setsockopt>(2) и "
"B<getsockopt>(2) используются, чтобы установить и получить необходимые "
"параметры."

#. type: Plain text
#: man-pages/man2/socket.2:422
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"В случае успешного выполнения возвращается дескриптор, ссылающийся на сокет. "
"В случае ошибки возвращается -1, а значение I<errno> устанавливается "
"соответствующим образом."

#. type: Plain text
#: man-pages/man2/socket.2:427
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr "Нет прав на создание сокета указанного типа и/или протокола."

#. type: TP
#: man-pages/man2/socket.2:427
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: man-pages/man2/socket.2:430
msgid "The implementation does not support the specified address family."
msgstr "Реализация не поддерживает указанное семейства адресов."

#. type: Plain text
#: man-pages/man2/socket.2:433
msgid "Unknown protocol, or protocol family not available."
msgstr "Неизвестный протокол или недоступное семейство протоколов."

#.  Since Linux 2.6.27
#. type: Plain text
#: man-pages/man2/socket.2:438
msgid "Invalid flags in I<type>."
msgstr "Неверные флаги в I<type>."

#. type: TP
#: man-pages/man2/socket.2:438
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/socket.2:441
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""
"Было достигнуто ограничение по количеству открытых файловых дескрипторов на "
"процесс."

#. type: TP
#: man-pages/man2/socket.2:444
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr "B<ENOBUFS> или B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/socket.2:449
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""
"Недостаточно памяти для создания сокета. Сокет не может быть создан, пока не "
"будет освобождено достаточное количество ресурсов."

#. type: TP
#: man-pages/man2/socket.2:449
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: man-pages/man2/socket.2:453
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr "Тип протокола или указанный протокол не поддерживаются в этом домене."

#. type: Plain text
#: man-pages/man2/socket.2:455
msgid "Other errors may be generated by the underlying protocol modules."
msgstr ""
"Другие ошибки могут быть созданы модулями протоколов более низкого уровня."

#. type: Plain text
#: man-pages/man2/socket.2:457
msgid "POSIX.1-2001, POSIX.1-2008, 4.4BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.4BSD."

#. type: Plain text
#: man-pages/man2/socket.2:463
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr "Флаги B<SOCK_NONBLOCK> и B<SOCK_CLOEXEC> есть только в Linux."

#. type: Plain text
#: man-pages/man2/socket.2:469
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants)."
msgstr ""
"Вызов B<socket>() появился в 4.2BSD. Обычно он переносим в/из не-BSD систем "
"на уровне сокетов BSD (включая варианты System\\ V)."

#. type: Plain text
#: man-pages/man2/socket.2:475
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this "
"header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""
"В POSIX.1 не требуется включение I<E<lt>sys/types.hE<gt>>, и этот "
"заголовочный файл не требуется в Linux. Однако, для некоторых старых "
"реализаций (BSD) требует данный файл, и в переносимых приложениях для "
"предосторожности, вероятно, лучше его указать."

#. type: Plain text
#: man-pages/man2/socket.2:488
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<AF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""
"Для семейств протоколов в 4.x BSD используются константы B<PF_UNIX>, "
"B<PF_INET>, B<PF_INET> и т. д., тогда как B<AF_UNIX>, B<AF_INET> и т. п. "
"используется для указания семейства адресов. Однако, в справочной странице "
"BSD сказано: «Обычно, семейство протоколов совпадает с семейством адресов» и "
"во всех последующих стандартах используется AF_*."

#. type: Plain text
#: man-pages/man2/socket.2:493
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr "Пример использования B<socket>() показан в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man2/socket.2:518
msgid ""
"B<accept>(2), B<bind>(2), B<close>(2), B<connect>(2), B<fcntl>(2), "
"B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), "
"B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), "
"B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), "
"B<address_families>(7), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<close>(2), B<connect>(2), B<fcntl>(2), "
"B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), "
"B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), "
"B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), "
"B<address_families>(7), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7)"

#. type: Plain text
#: man-pages/man2/socket.2:523
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"

#. type: TH
#: man-pages/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr "SCHED_YIELD"

#. type: Plain text
#: man-pages/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr "sched_yield - освободить процессор"

#. type: Plain text
#: man-pages/man2/sched_yield.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr "B<#include E<lt>sched.hE<gt>>"

#. type: Plain text
#: man-pages/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr "B<int sched_yield(void);>"

#. type: Plain text
#: man-pages/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""
"Вызов B<sched_yield>() заставляет вызывающую нить освободить процессор. Нить "
"перемещается в конец очереди согласно её статическому приоритету, и "
"управление передаётся другой нити."

#. type: Plain text
#: man-pages/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sched_yield>() возвращается 0. При ошибке "
"возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr "В Linux-реализации B<sched_yield>() всегда завершается успешно."

#. type: Plain text
#: man-pages/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""
"Если вызывающая нить единственная в списке с самым высоким приоритетом, то "
"она продолжит выполняться после вызова B<sched_yield>()."

#. type: Plain text
#: man-pages/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"В системах POSIX, в которых доступен вызов B<sched_yield>(), определён "
"B<_POSIX_PRIORITY_SCHEDULING> в I<E<lt>unistd.hE<gt>>."

#. type: Plain text
#: man-pages/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources (e."
"g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr ""
"Оперативные вызовы B<sched_yield>() могут улучшить производительность, давая "
"другим нитям или процессам шанс поработать, когда (сильно) оспариваемые "
"ресурсы (например, мьютексы) освобождаются вызывающим. Избегайте частых или "
"нецелесообразных вызовов B<sched_yield>() (например, когда ресурсы, "
"необходимые других планируемым нитям, по-прежнему удерживаются вызывающим), "
"так как это приводит к чрезмерному переключению контекстов, что ухудшит "
"производительность системы."

#. type: Plain text
#: man-pages/man2/sched_yield.2:90
msgid ""
"B<sched_yield>()  is intended for use with real-time scheduling policies (i."
"e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<sched_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""
"Функция B<sched_yield>() предназначена для использования с алгоритмами "
"планирования реального времени (т. е., B<SCHED_FIFO> или B<SCHED_RR>). "
"Использование B<sched_yield>() с недерминированными алгоритмами "
"планирования, такими как B<SCHED_OTHER>, не определено и указывает на, "
"вероятно, неправильно разработанное приложение."

#. type: Plain text
#: man-pages/man2/sched_yield.2:91
msgid "B<sched>(7)"
msgstr "B<sched>(7)"

#. type: TH
#: man-pages/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr "SCHED_RR_GET_INTERVAL"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:32
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr ""
"sched_rr_get_interval - определяет временной интервал SCHED_RR для заданного "
"процесса"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:36
msgid ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"
msgstr ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""
"Вызов B<sched_rr_get_interval>() записывает циклический квант времени "
"процесса I<pid> в структуру I<timespec>, на которую указывает I<tp>. "
"Указанный процесс должен запускаться с политикой выполнения B<SCHED_RR>."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr "Структура I<timespec> описана следующим образом:"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;        /* секунды */\n"
"    long   tv_nsec;       /* наносекунды */\n"
"};\n"

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""
"Если значение I<pid> равно нулю, то в I<*tp> записывается квант времени "
"вызывающего процесса."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sched_rr_get_interval>() возвращается 0. При "
"ошибке возвращается -1, а значение I<errno> устанавливается соответствующим "
"образом."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr "Проблема с копированием информации в пространство пользователя."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr "Неверное значение pid."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr "Системный вызов ещё не реализован (только в старых ядрах)."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr "Не удалось найти процесс с идентификатором, указанном в I<pid>."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"В системах POSIX, в которых доступен вызов B<sched_rr_get_interval>(), "
"определён B<_POSIX_PRIORITY_SCHEDULING> в I<E<lt>unistd.hE<gt>>."

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the round-"
"robin time quantum.  Older Linux kernels provide a (nonportable) method of "
"doing this.  The quantum can be controlled by adjusting the process's nice "
"value (see B<setpriority>(2)).  Assigning a negative (i.e., high) nice value "
"results in a longer quantum; assigning a positive (i.e., low) nice value "
"results in a shorter quantum.  The default quantum is 0.1 seconds; the "
"degree to which changing the nice value affects the quantum has varied "
"somewhat across kernel versions.  This method of adjusting the quantum was "
"removed starting with Linux 2.6.24."
msgstr ""
"В POSIX не определён какой-либо механизм для контроля размера циклического "
"кванта времени. В старых ядрах Linux для этого создан (непереносимый) метод. "
"Квант можно контролировать подгоняя значение любезности процесса (см. "
"B<setpriority>(2)). Назначение отрицательного (т.е., высокого) значения "
"любезности приведёт к более длинному кванту; назначение положительного (т."
"е., низкого) значения любезности приведёт к сокращению кванта. Квант по "
"умолчанию равен 0.1 секунды; степень, с которой значение любезности влияет "
"на квант, различается в разных версиях ядра. Данный метод подгонки кванта "
"был удалён начиная с Linux 2.6.24."

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr ""
"В Linux 3.9 добавлен новый механизм регулировки (и просмотра) кванта "
"B<SCHED_RR>: файл I</proc/sys/kernel/sched_rr_timeslice_ms> отражает квант "
"как значение в миллисекундах, по умолчанию равное 100. Запись 0 в этот файл "
"сбрасывает квант в значение по умолчанию."

#. type: TH
#: man-pages/man2/setsid.2:31
#, no-wrap
msgid "SETSID"
msgstr "SETSID"

#. type: Plain text
#: man-pages/man2/setsid.2:34
msgid "setsid - creates a session and sets the process group ID"
msgstr "setsid - создает сеанс и устанавливает идентификатор группы процесса"

#. type: Plain text
#: man-pages/man2/setsid.2:41
msgid "B<pid_t setsid(void);>"
msgstr "B<pid_t setsid(void);>"

#. type: Plain text
#: man-pages/man2/setsid.2:52
msgid ""
"B<setsid>()  creates a new session if the calling process is not a process "
"group leader.  The calling process is the leader of the new session (i.e., "
"its session ID is made the same as its process ID).  The calling process "
"also becomes the process group leader of a new process group in the session "
"(i.e., its process group ID is made the same as its process ID)."
msgstr ""
"Вызов B<setsid>() создаёт новый сеанс, если вызывающий процесс не является "
"лидером группы процессов. Вызывающий процесс становится лидером нового "
"сеанса (то есть, его ID сеанса становится равным ID самого процесса). "
"Вызывающий процесс также становится лидером группы процессов новой группы "
"процессов в сеансе (то есть, его ID группы процессов становится равным ID "
"самого процесса)."

#. type: Plain text
#: man-pages/man2/setsid.2:55
msgid ""
"The calling process will be the only process in the new process group and in "
"the new session."
msgstr ""
"Вызывающий процесс будет единственным в новой группе процессов и новом "
"сеансе."

#. type: Plain text
#: man-pages/man2/setsid.2:59
msgid ""
"Initially, the new session has no controlling terminal.  For details of how "
"a session acquires a controlling terminal, see B<credentials>(7)."
msgstr ""
"Изначально, новый сеанс не имеет управляющего терминала. О том, как сеанс "
"получает управляющий терминал, смотрите в B<credentials>(7)."

#. type: Plain text
#: man-pages/man2/setsid.2:66
msgid ""
"On success, the (new) session ID of the calling process is returned.  On "
"error, I<(pid_t)\\ -1> is returned, and I<errno> is set to indicate the "
"error."
msgstr ""
"При успешном выполнении возвращается идентификатор (нового) сеанса "
"вызывающего процесса. В случае ошибки возвращается I<(pid_t)\\ -1>, а "
"I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/setsid.2:73
msgid ""
"The process group ID of any process equals the PID of the calling process.  "
"Thus, in particular, B<setsid>()  fails if the calling process is already a "
"process group leader."
msgstr ""
"Идентификатор группы процессов любого процесса равен PID вызывающего "
"процесса. В этом случае, в частности, B<setsid>() завершается неудачно, если "
"вызывающий процесс уже является лидером группы процессов."

#. type: Plain text
#: man-pages/man2/setsid.2:81
msgid ""
"A child created via B<fork>(2)  inherits its parent's session ID.  The "
"session ID is preserved across an B<execve>(2)."
msgstr ""
"Потомок, создаваемый с помощью B<fork>(2), наследует ID сеанса своего "
"родителя. Идентификатор сеанса сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setsid.2:98
msgid ""
"A process group leader is a process whose process group ID equals its PID.  "
"Disallowing a process group leader from calling B<setsid>()  prevents the "
"possibility that a process group leader places itself in a new session while "
"other processes in the process group remain in the original session; such a "
"scenario would break the strict two-level hierarchy of sessions and process "
"groups.  In order to be sure that B<setsid>()  will succeed, call "
"B<fork>(2)  and have the parent B<_exit>(2), while the child (which by "
"definition can't be a process group leader) calls B<setsid>()."
msgstr ""
"Лидер группы процессов — это процесс, идентификатор группы процессов "
"которого равен идентификатору самого процесса (PID). Отказ лидера группы "
"процессов выполнять B<setsid>() предотвращает возможность того, что сам "
"лидер группы процессов переместится в новый сеанс, в то время как другие "
"процессы в группе останутся в первоначальном сеансе; это поломало бы жёсткую "
"двухуровневую иерархию сценариев и групп процессов. Для того, чтобы "
"B<setsid>() выполнился успешно, вызовите B<fork>(2) и в родителе "
"B<_exit>(2), а затем в дочернем процессе (который по определению не может "
"быть лидером группы процессов) вызовите B<setsid>()."

#. type: Plain text
#: man-pages/man2/setsid.2:105
msgid ""
"If a session has a controlling terminal, and the B<CLOCAL> flag for that "
"terminal is not set, and a terminal hangup occurs, then the session leader "
"is sent a B<SIGHUP> signal."
msgstr ""
"Если сеанс имеет управляющий терминал, у которого не установлен флаг "
"B<CLOCAL> и возникает зависание (hangup) терминала, то лидеру сеанса "
"посылается B<SIGHUP>."

#. type: Plain text
#: man-pages/man2/setsid.2:110
msgid ""
"If a process that is a session leader terminates, then a B<SIGHUP> signal is "
"sent to each process in the foreground process group of the controlling "
"terminal."
msgstr ""
"Если завершается процесс, который является лидером сеанса, то сигнал "
"B<SIGHUP> посылается каждому процессу в приоритетной (foreground) группе "
"процессов управляющего терминала."

#. type: Plain text
#: man-pages/man2/setsid.2:117
msgid ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7), B<sched>(7)"
msgstr ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/setreuid.2:46
#, no-wrap
msgid "SETREUID"
msgstr "SETREUID"

#. type: Plain text
#: man-pages/man2/setreuid.2:49
msgid "setreuid, setregid - set real and/or effective user or group ID"
msgstr ""
"setreuid, setregid - устанавливает действительный и/или эффективный "
"идентификатор пользователя или группы"

#. type: Plain text
#: man-pages/man2/setreuid.2:55
msgid "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"
msgstr "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"

#. type: Plain text
#: man-pages/man2/setreuid.2:57
msgid "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"
msgstr "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"

#. type: Plain text
#: man-pages/man2/setreuid.2:65
msgid "B<setreuid>(), B<setregid>():"
msgstr "B<setreuid>(), B<setregid>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/setreuid.2:71
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/setreuid.2:76
msgid "B<setreuid>()  sets real and effective user IDs of the calling process."
msgstr ""
"Вызов B<setreuid>() устанавливает действительный и эффективный идентификатор "
"пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setreuid.2:79
msgid ""
"Supplying a value of -1 for either the real or effective user ID forces the "
"system to leave that ID unchanged."
msgstr ""
"Если указываемое значение действительного или эффективного идентификатора "
"пользователя равно -1, то система не изменяет его."

#. type: Plain text
#: man-pages/man2/setreuid.2:82
msgid ""
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID, or the saved set-user-ID."
msgstr ""
"Непривилегированные процессы могут изменять эффективный идентификатор "
"пользователя на действующий, эффективный или сохранённый идентификатор "
"пользователя."

#. type: Plain text
#: man-pages/man2/setreuid.2:85
msgid ""
"Unprivileged users may only set the real user ID to the real user ID or the "
"effective user ID."
msgstr ""
"Непривилегированные пользователи могут изменять действительный идентификатор "
"пользователя на эффективный или действительный идентификатор пользователя."

#. type: Plain text
#: man-pages/man2/setreuid.2:91
msgid ""
"If the real user ID is set (i.e., I<ruid> is not -1) or the effective user "
"ID is set to a value not equal to the previous real user ID, the saved set-"
"user-ID will be set to the new effective user ID."
msgstr ""
"Если установлен действительный идентификатор пользователя (т. е., значение "
"I<ruid> не равно -1) или установлено значение эффективного идентификатора "
"пользователя в отличное от предыдущего значения действительного "
"идентификатора пользователя, то значение сохранённого идентификатора "
"пользователя будет установлено в новое значение эффективного идентификатора "
"пользователя."

#. type: Plain text
#: man-pages/man2/setreuid.2:96
msgid ""
"Completely analogously, B<setregid>()  sets real and effective group ID's of "
"the calling process, and all of the above holds with \"group\" instead of "
"\"user\"."
msgstr ""
"Аналогично B<setregid>() меняет действующий и эффективный идентификаторы "
"группы вызывающего процесса, и всё описанное выше для пользователя "
"справедливо и для группы."

#. type: Plain text
#: man-pages/man2/setreuid.2:108
msgid ""
"I<Note>: there are cases where B<setreuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setreuid>()."
msgstr ""
"I<Замечание>: есть случаи, когда B<setreuid>() может завершиться с ошибкой "
"даже когда UID вызывающего равен 0; это серьёзная ошибка безопасности — не "
"проверять возвращаемое значение B<setreuid>()."

#. type: Plain text
#: man-pages/man2/setreuid.2:151
msgid ""
"The calling process is not privileged (on Linux, does not have the necessary "
"capability in its user namespace: B<CAP_SETUID> in the case of "
"B<setreuid>(), or B<CAP_SETGID> in the case of B<setregid>())  and a change "
"other than (i)  swapping the effective user (group) ID with the real user "
"(group) ID, or (ii) setting one to the value of the other or (iii) setting "
"the effective user (group) ID to the value of the saved set-user-ID (saved "
"set-group-ID) was specified."
msgstr ""
"Вызывающий процесс не имеет прав (Linux: не имеет необходимого мандата в "
"своём пространстве имён пользователя: B<CAP_SETUID> при вызове B<setreuid>() "
"или мандата B<CAP_SETGID> при вызове B<setregid>()), а требуемые изменения "
"не относятся к следующим: 1) взаимозамене эффективного идентификатора на "
"действительный идентификатор пользователя (группы); 2) установке значения "
"одного идентификатора в значение другого; 3) замене эффективного "
"идентификатора пользователя (группы) на сохранённый идентификатор "
"пользователя (группы)."

#. type: Plain text
#: man-pages/man2/setreuid.2:157
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.3BSD (B<setreuid>()  and B<setregid>()  first "
"appeared in 4.2BSD)."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, 4.3BSD (B<setreuid>() и B<setregid>() впервые "
"появились в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/setreuid.2:161
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38)."
msgstr ""
"Установка эффективного идентификатора пользователя (группы) в значение "
"сохранённого идентификатора возможна с версии Linux 1.1.37 (1.1.38)."

#. type: Plain text
#: man-pages/man2/setreuid.2:178
msgid ""
"POSIX.1 does not specify all of the UID changes that Linux permits for an "
"unprivileged process.  For B<setreuid>(), the effective user ID can be made "
"the same as the real user ID or the saved set-user-ID, and it is unspecified "
"whether unprivileged processes may set the real user ID to the real user ID, "
"the effective user ID, or the saved set-user-ID.  For B<setregid>(), the "
"real group ID can be changed to the value of the saved set-group-ID, and the "
"effective group ID can be changed to the value of the real group ID or the "
"saved set-group-ID.  The precise details of what ID changes are permitted "
"vary across implementations."
msgstr ""
"В POSIX.1 не определены все варианты изменения идентификаторов, разрешённые "
"в Linux непривилегированным процессам. Вызов B<setreuid>() может изменить "
"значение эффективного пользовательского идентификатора на действительный или "
"сохранённый пользовательский идентификатор и не определено, может ли "
"непривилегированный процесс установить действительный пользовательский "
"идентификатор равным действительному, эффективному или сохранённому "
"пользовательскому идентификатору. Вызов B<setregid>() может изменить "
"действительный идентификатор группы на значение сохранённого идентификатора "
"группы, а эффективный идентификатор группы — на значение действительного или "
"сохранённого идентификатора группы. Действующие правила о разрешённых "
"изменениях идентификаторов отличаются в разных реализациях."

#. type: Plain text
#: man-pages/man2/setreuid.2:181
msgid ""
"POSIX.1 makes no specification about the effect of these calls on the saved "
"set-user-ID and saved set-group-ID."
msgstr ""
"В POSIX.1 ничего не сказано о работе этих вызовов над сохранённым "
"идентификатором пользователя и группы."

#. type: Plain text
#: man-pages/man2/setreuid.2:198
msgid ""
"The original Linux B<setreuid>()  and B<setregid>()  system calls supported "
"only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setreuid32>()  and B<setregid32>(), supporting 32-bit IDs.  The glibc "
"B<setreuid>()  and B<setregid>()  wrapper functions transparently deal with "
"the variations across kernel versions."
msgstr ""
"Первоначальные версии системных вызовов B<setreuid>() и B<setregid>() в "
"Linux поддерживали только 16-битные идентификаторы пользователей и групп. "
"Позднее в Linux 2.4 были добавлены вызовы B<setreuid32>() и B<setregid32>(), "
"поддерживающие 32-битные идентификаторы. В glibc обёрточные функции "
"B<setreuid>() и B<setregid>() работают одинаково вне зависимости от версий "
"ядра."

#. type: Plain text
#: man-pages/man2/setreuid.2:214
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setreuid>()  and B<setregid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""
"На уровне ядра ID пользователя и группы являются атрибутами нити. Однако в "
"POSIX требуется, чтобы все нити в процессе имели одинаковые права. В "
"реализации нитей NPTL требования POSIX реализованы через обёрточные функции "
"для различных системных вызовов, которые изменяют UID и GID процесса. В этих "
"функциях (включая B<setreuid>() и B<setregid>()) используется алгоритмы на "
"основе сигналов, которые следят за тем, что когда у одной нити изменяются "
"права, эти изменения выполняются и для остальных нитей процесса. Подробное "
"описание смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/setreuid.2:223
msgid ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"

#. type: TH
#: man-pages/man2/swapon.2:42
#, no-wrap
msgid "SWAPON"
msgstr "SWAPON"

#. type: Plain text
#: man-pages/man2/swapon.2:45
msgid "swapon, swapoff - start/stop swapping to file/device"
msgstr ""
"swapon, swapoff - запускает/останавливает подкачку данных в файл/устройство"

#. type: Plain text
#: man-pages/man2/swapon.2:49
msgid "B<#include E<lt>sys/swap.hE<gt>>"
msgstr "B<#include E<lt>sys/swap.hE<gt>>"

#. type: Plain text
#: man-pages/man2/swapon.2:51
msgid "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"
msgstr "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"

#. type: Plain text
#: man-pages/man2/swapon.2:53
msgid "B<int swapoff(const char *>I<path>B<);>"
msgstr "B<int swapoff(const char *>I<path>B<);>"

#. type: Plain text
#: man-pages/man2/swapon.2:60
msgid ""
"B<swapon>()  sets the swap area to the file or block device specified by "
"I<path>.  B<swapoff>()  stops swapping to the file or block device specified "
"by I<path>."
msgstr ""
"B<swapon>() включает использование файла или блочного устройства, указанного "
"в I<path>, в качестве подкачки данных. B<swapoff>() выключает использование "
"файла или блочного устройства, указанного в I<path>, в качестве подкачки "
"данных."

#. type: Plain text
#: man-pages/man2/swapon.2:70
msgid ""
"If the B<SWAP_FLAG_PREFER> flag is specified in the B<swapon>()  "
"I<swapflags> argument, the new swap area will have a higher priority than "
"default.  The priority is encoded within I<swapflags> as:"
msgstr ""
"Если при вызове B<swapon>() в аргументе I<swapflags> установлен флаг "
"B<SWAP_FLAG_PREFER>, то новое пространство подкачки будет иметь больший "
"приоритет, чем используемый по умолчанию. Приоритет задаётся в I<swapflags> "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/swapon.2:74
#, no-wrap
msgid "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>\n"
msgstr "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>\n"

#. type: Plain text
#: man-pages/man2/swapon.2:87
msgid ""
"If the B<SWAP_FLAG_DISCARD> flag is specified in the B<swapon>()  "
"I<swapflags> argument, freed swap pages will be discarded before they are "
"reused, if the swap device supports the discard or trim operation.  (This "
"may improve performance on some Solid State Devices, but often it does "
"not.)  See also NOTES."
msgstr ""
"Если в аргументе I<swapflags> вызова B<swapon>() указан флаг "
"B<SWAP_FLAG_DISCARD>, то освобождаемые страницы подкачки будут исключены "
"(discard) до того как они задействуются повторно (если устройство подкачки "
"поддерживает операцию исключения или обрезки). Это может улучшить "
"производительность на некоторых твердотельных накопителях, но, чаще всего, "
"нет. Также смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/swapon.2:91
msgid ""
"These functions may be used only by a privileged process (one having the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""
"Эти функции могут использоваться только привилегированным процессом (имеющим "
"мандат B<CAP_SYS_ADMIN>)."

#. type: SS
#: man-pages/man2/swapon.2:91
#, no-wrap
msgid "Priority"
msgstr "Приоритет"

#. type: Plain text
#: man-pages/man2/swapon.2:96
msgid ""
"Each swap area has a priority, either high or low.  The default priority is "
"low.  Within the low-priority areas, newer areas are even lower priority "
"than older areas."
msgstr ""
"Каждое пространство подкачки имеет приоритет, высокий или низкий. По "
"умолчанию задается низкий приоритет. Внутри пространств с низким "
"приоритетом, новые пространства имеют ещё меньший приоритет, чем старые."

#. type: Plain text
#: man-pages/man2/swapon.2:102
msgid ""
"All priorities set with I<swapflags> are high-priority, higher than "
"default.  They may have any nonnegative value chosen by the caller.  Higher "
"numbers mean higher priority."
msgstr ""
"Все приоритеты, установленные с помощью I<swapflags>, выше используемого по "
"умолчанию. Приоритет может быть любым неотрицательным числом (определяется "
"вызывающим). Большее значение соответствует большему приоритету."

#. type: Plain text
#: man-pages/man2/swapon.2:110
msgid ""
"Swap pages are allocated from areas in priority order, highest priority "
"first.  For areas with different priorities, a higher-priority area is "
"exhausted before using a lower-priority area.  If two or more areas have the "
"same priority, and it is the highest priority available, pages are allocated "
"on a round-robin basis between them."
msgstr ""
"Страницы подкачки располагаются в пространствах согласно убыванию их "
"приоритета. Если приоритеты различаются, то сначала полностью заполняются "
"пространства с большим приоритетом. Если два пространства имеют одинаковый "
"приоритет, и это наибольший приоритет из свободных, страницы распределяются "
"между ними по \"карусельному\" принципу."

#. type: Plain text
#: man-pages/man2/swapon.2:113
msgid ""
"As of Linux 1.3.6, the kernel usually follows these rules, but there are "
"exceptions."
msgstr ""
"В Linux 1.3.6 работа ядра обычно следует этим правилам, но существуют "
"исключения."

#. type: Plain text
#: man-pages/man2/swapon.2:126
msgid ""
"(for B<swapon>())  The specified I<path> is already being used as a swap "
"area."
msgstr ""
"(для B<swapon>()) Указанный I<path> уже используется в качестве пространства "
"подкачки."

#. type: Plain text
#: man-pages/man2/swapon.2:131
msgid ""
"The file I<path> exists, but refers neither to a regular file nor to a block "
"device;"
msgstr ""
"Файл I<path> существует, но не ссылается на обычный файл или блочное "
"устройство;"

#. type: Plain text
#: man-pages/man2/swapon.2:137
msgid ""
"(B<swapon>())  The indicated path does not contain a valid swap signature or "
"resides on an in-memory filesystem such as B<tmpfs>(5)."
msgstr ""
"(B<swapon>()) Указанный путь не содержит правильной сигнатуры подкачки или "
"располагается в файловой системе, работающей в памяти, например, B<tmpfs>(5)."

#. type: TP
#: man-pages/man2/swapon.2:137
#, no-wrap
msgid "B<EINVAL> (since Linux 3.4)"
msgstr "B<EINVAL> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/swapon.2:142
msgid "(B<swapon>())  An invalid flag value was specified in I<flags>."
msgstr "(B<swapon>()) В I<flags> указано неверное значение флага."

#. type: Plain text
#: man-pages/man2/swapon.2:147
msgid "(B<swapoff>())  I<path> is not currently a swap area."
msgstr ""
"(B<swapoff>()) В настоящее время I<path> не является областью подкачки."

#. type: Plain text
#: man-pages/man2/swapon.2:155
msgid "The file I<path> does not exist."
msgstr "Файл I<path> не существует."

#. type: Plain text
#: man-pages/man2/swapon.2:158
msgid "The system has insufficient memory to start swapping."
msgstr "Не хватает памяти ядра для запуска процесса подкачки."

#. type: Plain text
#: man-pages/man2/swapon.2:165
msgid ""
"The caller does not have the B<CAP_SYS_ADMIN> capability.  Alternatively, "
"the maximum number of swap files are already in use; see NOTES below."
msgstr ""
"Вызывающий не имеет мандата B<CAP_SYS_ADMIN>. Или превышен лимит количества "
"используемых пространств подкачки; см. ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man2/swapon.2:171
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable.  The second I<swapflags> argument was introduced in "
"Linux 1.3.2."
msgstr ""
"Эти функции предназначены только для работы в Linux и не должны "
"использоваться в переносимых программах. Второй параметр I<swapflags> "
"впервые появился в Linux 1.3.2."

#. type: Plain text
#: man-pages/man2/swapon.2:174
msgid "The partition or path must be prepared with B<mkswap>(8)."
msgstr ""
"Раздел или путь должны быть подготовлены к подкачке при помощи B<mkswap>(8)."

#. type: Plain text
#: man-pages/man2/swapon.2:194
msgid ""
"There is an upper limit on the number of swap files that may be used, "
"defined by the kernel constant B<MAX_SWAPFILES>.  Before kernel 2.4.10, "
"B<MAX_SWAPFILES> has the value 8; since kernel 2.4.10, it has the value 32.  "
"Since kernel 2.6.18, the limit is decreased by 2 (thus: 30)  if the kernel "
"is built with the B<CONFIG_MIGRATION> option (which reserves two swap table "
"entries for the page migration features of B<mbind>(2)  and "
"B<migrate_pages>(2)).  Since kernel 2.6.32, the limit is further decreased "
"by 1 if the kernel is built with the B<CONFIG_MEMORY_FAILURE> option."
msgstr ""
"Есть верхний предел на количество используемых файлов подкачки, он "
"определяется константой ядра B<MAX_SWAPFILES>. До ядра версии 2.4.10 "
"значение B<MAX_SWAPFILES> было равно 8; начиная с ядра 2.4.10, значение "
"стало 32.  Начиная с ядра 2.6.18, предел уменьшается на 2 (то есть стало "
"30), если ядро собирается с параметром B<CONFIG_MIGRATION> (который "
"резервирует 2 элемента таблицы подкачки для возможности переноса страниц "
"B<mbind>(2) и B<migrate_pages>(2)). Начиная с ядра 2.6.32, предел ещё "
"сокращается на 1, если ядро собирается с параметром B<CONFIG_MEMORY_FAILURE>."

#.  To be precise: 2.6.35.5
#. type: Plain text
#: man-pages/man2/swapon.2:205
msgid ""
"Discard of swap pages was introduced in kernel 2.6.29, then made conditional "
"on the B<SWAP_FLAG_DISCARD> flag in kernel 2.6.36, which still discards the "
"entire swap area when B<swapon>()  is called, even if that flag bit is not "
"set."
msgstr ""
"Исключение (discard) страниц подкачки появилось в ядре версии 2.6.29, флаг "
"условия B<SWAP_FLAG_DISCARD> появился в ядре версии 2.6.36, но пока при "
"вызове B<swapon>() исключается вся область подкачки, даже если этот флаг не "
"задан."

#. type: Plain text
#: man-pages/man2/swapon.2:208
msgid "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"
msgstr "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"

#. type: TH
#: man-pages/man2/setup.2:34
#, no-wrap
msgid "SETUP"
msgstr "SETUP"

#. type: TH
#: man-pages/man2/setup.2:34
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: man-pages/man2/setup.2:37
msgid "setup - setup devices and filesystems, mount root filesystem"
msgstr ""
"setup - настраивает устройства и файловые системы, монтирует корневую "
"файловую систему"

#. type: Plain text
#: man-pages/man2/setup.2:41
msgid "B<int setup(void);>"
msgstr "B<int setup(void);>"

#. type: Plain text
#: man-pages/man2/setup.2:47
msgid ""
"B<setup>()  is called once from within I<linux/init/main.c>.  It calls "
"initialization functions for devices and filesystems configured into the "
"kernel and then mounts the root filesystem."
msgstr ""
"B<setup>() вызывается один раз из I<linux/init/main.c>. Она вызывает функции "
"инициализации устройств и файловых систем, встроенных в ядро, и затем "
"монтирует корневую файловую систему."

#. type: Plain text
#: man-pages/man2/setup.2:53
msgid ""
"No user process may call B<setup>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""
"Ни один из пользовательских процессов не может вызвать B<setup>(). Любой "
"пользовательский процесс даже с правами суперпользователя будет получать "
"сообщение об ошибке с кодом B<EPERM>."

#. type: Plain text
#: man-pages/man2/setup.2:56
msgid "B<setup>()  always returns -1 for a user process."
msgstr ""
"Вызов B<setup>() всегда возвращает пользовательскому процессу значение -1."

#. type: Plain text
#: man-pages/man2/setup.2:60
msgid "Always, for a user process."
msgstr "Всегда для пользовательского процесса."

#. type: Plain text
#: man-pages/man2/setup.2:62
msgid "Since Linux 2.1.121, no such function exists anymore."
msgstr "Начиная с Linux 2.1.121, эта функция не существует."

#. type: Plain text
#: man-pages/man2/setup.2:65
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable, or indeed in any programs at all."
msgstr ""
"Эта функция применяется только в Linux и поэтому не должна использоваться в "
"программах, предназначенных для переноса на другую платформу, и вообще не "
"должна вызываться из пользовательских программ."

#. type: Plain text
#: man-pages/man2/setup.2:71
msgid ""
"The calling sequence varied: at some times B<setup>()  has had a single "
"argument I<void\\ *BIOS> and at other times a single argument I<int magic>."
msgstr ""
"Вызывающая последовательность менялась: в некоторых версиях у B<setup>() был "
"один аргумент I<void\\ *BIOS>, а в некоторых — I<int magic>."

#. type: TH
#: man-pages/man2/sigaction.2:49
#, no-wrap
msgid "SIGACTION"
msgstr "SIGACTION"

#. type: Plain text
#: man-pages/man2/sigaction.2:52
msgid "sigaction, rt_sigaction - examine and change a signal action"
msgstr "sigaction, rt_sigaction - получает и изменяет обработчик сигнала"

#. type: Plain text
#: man-pages/man2/sigaction.2:58
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:68
msgid "B<sigaction>(): _POSIX_C_SOURCE"
msgstr "B<sigaction>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man2/sigaction.2:71
msgid "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"
msgstr "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"

#. type: Plain text
#: man-pages/man2/sigaction.2:80
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview "
"of signals.)"
msgstr ""
"Системный вызов B<sigaction>() используется для изменения выполняемого "
"процессом действия при получении определённого сигнала (список сигналов "
"смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigaction.2:86
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL> "
"and B<SIGSTOP>."
msgstr ""
"В I<signum> указывается сигнал; может принимать значение любого корректного "
"сигнала за исключением B<SIGKILL> и B<SIGSTOP>."

#. type: Plain text
#: man-pages/man2/sigaction.2:97
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from "
"I<act>.  If I<oldact> is non-NULL, the previous action is saved in I<oldact>."
msgstr ""
"Если значение I<act> не равно NULL, то устанавливается новое действие для "
"сигнала I<signum> из I<act>. Если значение I<oldact> не равно NULL, то "
"предыдущее действие записывается в I<oldact>."

#. type: Plain text
#: man-pages/man2/sigaction.2:101
msgid "The I<sigaction> structure is defined as something like:"
msgstr "Структура I<sigaction> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/sigaction.2:111
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t sa_mask;\n"
"    int      sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:118
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr ""
"Для некоторых архитектур используется union: не выполняйте назначение "
"одновременно I<sa_handler> и I<sa_sigaction>."

#. type: Plain text
#: man-pages/man2/sigaction.2:127
msgid ""
"The I<sa_restorer> field is not intended for application use.  (POSIX does "
"not specify a I<sa_restorer> field.)  Some further details of the purpose of "
"this field can be found in B<sigreturn>(2)."
msgstr ""
"Поле I<sa_restorer> не предназначено для использования в приложении (в POSIX "
"I<sa_restorer> не определёно). Предназначение этого поля немного описано в "
"B<sigreturn>(2)."

#. type: Plain text
#: man-pages/man2/sigaction.2:137
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and may "
"be B<SIG_DFL> for the default action, B<SIG_IGN> to ignore this signal, or a "
"pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr ""
"I<sa_handler> указывает действие, которое должно быть связано с I<signum>; "
"может принимать значение B<SIG_DFL> в качестве действия по умолчанию, "
"B<SIG_IGN>, чтобы игнорировать этот сигнал, или принимать указатель на "
"функцию управления сигналом. Данная функция получает номер сигнала в "
"качестве своего единственного аргумента."

#. type: Plain text
#: man-pages/man2/sigaction.2:149
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives three arguments, as described below."
msgstr ""
"Если в I<sa_flags> указан B<SA_SIGINFO>, то I<sa_sigaction> (вместо "
"I<sa_handler>) задаёт функцию обработки сигнала I<signum>. Эта функция имеет "
"три параметра, которые описаны ниже."

#. type: Plain text
#: man-pages/man2/sigaction.2:159
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is used."
msgstr ""
"В I<sa_mask> задаётся маска сигналов, которые должны блокироваться (т.е. "
"добавляется к маске сигналов нити, в которой вызывается обработчик сигнала) "
"при выполнении обработчика сигнала. Также будет блокироваться и сигнал, "
"вызвавший запуск обработчика, если только не был использован флаг "
"B<SA_NODEFER>."

#. type: Plain text
#: man-pages/man2/sigaction.2:163
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr ""
"В I<flag> указывается набор флагов, которые изменяют поведение сигнала. Он "
"формируется побитовым ИЛИ из следующих флагов:"

#. type: TP
#: man-pages/man2/sigaction.2:164
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr "B<SA_NOCLDSTOP>"

#. type: Plain text
#: man-pages/man2/sigaction.2:181
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes "
"stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, or "
"B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is meaningful only when establishing a handler for B<SIGCHLD>."
msgstr ""
"Если значение I<signum> равно B<SIGCHLD>, то уведомление об остановке "
"дочернего процесса (т.е., в тех случаях, когда дочерний процесс получает "
"сигнал B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN> или B<SIGTTOU>) или возобновлении "
"работы (т.е., когда дочерний процесс получает B<SIGCONT>) не будет получено "
"(см. B<wait>(2)). Этот флаг имеет значение только когда установлен "
"обработчик B<SIGCHLD>."

#. type: TP
#: man-pages/man2/sigaction.2:181
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr "B<SA_NOCLDWAIT> (начиная с Linux 2.6)"

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: man-pages/man2/sigaction.2:195
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they "
"terminate.  See also B<waitpid>(2).  This flag is meaningful only when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr ""
"Если значение I<signum> равно B<SIGCHLD>, то дочерние процессы не будут "
"переводиться в состояние зомби при завершении. Смотрите также B<waitpid>(2). "
"Этот флаг имеет значение только когда установлен обработчик B<SIGCHLD> или "
"когда обработчик сигнала установлен в B<SIG_DFL>."

#. type: Plain text
#: man-pages/man2/sigaction.2:207
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is "
"generated in this case; on some other implementations, it is not."
msgstr ""
"Если флаг B<SA_NOCLDWAIT> не задан при установке обработчика B<SIGCHLD>, то "
"по POSIX.1 остаётся неопределённым, будет ли генерироваться сигнал "
"B<SIGCHLD> при завершении дочернего процесса. В Linux сигнал B<SIGCHLD> в "
"этом случае генерируется; в некоторых других реализациях это не делается."

#. type: TP
#: man-pages/man2/sigaction.2:207
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr "B<SA_NODEFER>"

#. type: Plain text
#: man-pages/man2/sigaction.2:214
msgid ""
"Do not prevent the signal from being received from within its own signal "
"handler.  This flag is meaningful only when establishing a signal handler.  "
"B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr ""
"Не препятствовать получению сигнала при его обработке обработчиком сигнала. "
"Этот флаг имеет значение только когда установлен обработчик. Флаг "
"B<SA_NOMASK> является устаревшим синонимом данного флага."

#. type: TP
#: man-pages/man2/sigaction.2:214
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr "B<SA_ONSTACK>"

#. type: Plain text
#: man-pages/man2/sigaction.2:220
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is meaningful only when establishing a signal "
"handler."
msgstr ""
"Вызывать обработчик сигнала в дополнительном стеке сигналов, предоставленном "
"B<sigaltstack>(2). Если дополнительный стек недоступен, то будет использован "
"стек по умолчанию. Этот флаг имеет значение только когда установлен "
"обработчик."

#. type: TP
#: man-pages/man2/sigaction.2:220
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr "B<SA_RESETHAND>"

#. type: Plain text
#: man-pages/man2/sigaction.2:226
msgid ""
"Restore the signal action to the default upon entry to the signal handler.  "
"This flag is meaningful only when establishing a signal handler.  "
"B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr ""
"Восстановить поведение сигнала в значение по умолчанию после входа в "
"обработчик сигнала. Этот флаг имеет значение только когда установлен "
"обработчик. Флаг B<SA_ONESHOT> является устаревшим синонимом данного флага."

#. type: TP
#: man-pages/man2/sigaction.2:226
#, no-wrap
msgid "B<SA_RESTART>"
msgstr "B<SA_RESTART>"

#. type: Plain text
#: man-pages/man2/sigaction.2:234
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is meaningful only when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system "
"call restarting."
msgstr ""
"Обеспечивать поведение совместимое с семантикой сигналов BSD, позволяя "
"некоторым системным вызовам перезапускаться в то время, как идет обработка "
"сигналов. Этот флаг имеет значение только когда установлен обработчик. О "
"перезапуске системных вызовов смотрите в B<signal>(7)."

#. type: TP
#: man-pages/man2/sigaction.2:234
#, no-wrap
msgid "B<SA_RESTORER>"
msgstr "B<SA_RESTORER>"

#. type: Plain text
#: man-pages/man2/sigaction.2:243
msgid ""
"I<Not intended for application use>.  This flag is used by C libraries to "
"indicate that the I<sa_restorer> field contains the address of a \"signal "
"trampoline\".  See B<sigreturn>(2)  for more details."
msgstr ""
"I<Не предназначен для приложений>. Данный флаг используется в библиотеках C "
"для указания на то, что поле I<sa_restorer> содержит адрес «прыжковым "
"мостиком в сигнал\" (signal trampoline). Подробней смотрите в "
"B<sigreturn>(2)."

#. type: TP
#: man-pages/man2/sigaction.2:243
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr "B<SA_SIGINFO> (начиная с Linux 2.2)"

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: man-pages/man2/sigaction.2:254
msgid ""
"The signal handler takes three arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is "
"meaningful only when establishing a signal handler."
msgstr ""
"Обработчик сигнала требует трёх аргументов, а не одного. В этом случае надо "
"использовать параметр I<sa_sigaction> вместо I<sa_handler>. Этот флаг имеет "
"значение только когда установлен обработчик."

#. type: SS
#: man-pages/man2/sigaction.2:255
#, no-wrap
msgid "The siginfo_t argument to a SA_SIGINFO handler"
msgstr "Аргумент siginfo_t обработчика SA_SIGINFO."

#. type: Plain text
#: man-pages/man2/sigaction.2:264
msgid ""
"When the B<SA_SIGINFO> flag is specified in I<act.sa_flags>, the signal "
"handler address is passed via the I<act.sa_sigaction> field.  This handler "
"takes three arguments, as follows:"
msgstr ""
"Если в I<act.sa_flags> указан флаг B<SA_SIGINFO>, то адрес обработчика "
"сигнала передаётся в поле I<act.sa_sigaction>. Этот обработчик имеет три "
"аргумента:"

#. type: Plain text
#: man-pages/man2/sigaction.2:272
#, no-wrap
msgid ""
"void\n"
"handler(int sig, siginfo_t *info, void *ucontext)\n"
"{\n"
"    ...\n"
"}\n"
msgstr ""
"void\n"
"handler(int sig, siginfo_t *info, void *ucontext)\n"
"{\n"
"    ...\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:276
msgid "These three arguments are as follows"
msgstr "Три параметра:"

#. type: TP
#: man-pages/man2/sigaction.2:276
#, no-wrap
msgid "I<sig>"
msgstr "I<sig>"

#. type: Plain text
#: man-pages/man2/sigaction.2:279
msgid "The number of the signal that caused invocation of the handler."
msgstr "Номер сигнала, который привёл к вызову обработчика."

#. type: TP
#: man-pages/man2/sigaction.2:279
#, no-wrap
msgid "I<info>"
msgstr "I<info>"

#. type: Plain text
#: man-pages/man2/sigaction.2:285
msgid ""
"A pointer to a I<siginfo_t>, which is a structure containing further "
"information about the signal, as described below."
msgstr ""
"Указатель на I<siginfo_t> — структуру, содержащую дополнительную информацию "
"о сигнале, описана далее."

#. type: TP
#: man-pages/man2/sigaction.2:285
#, no-wrap
msgid "I<ucontext>"
msgstr "I<ucontext>"

#. type: Plain text
#: man-pages/man2/sigaction.2:299
msgid ""
"This is a pointer to a I<ucontext_t> structure, cast to I<void\\ *>.  The "
"structure pointed to by this field contains signal context information that "
"was saved on the user-space stack by the kernel; for details, see "
"B<sigreturn>(2).  Further information about the I<ucontext_t> structure can "
"be found in B<getcontext>(3).  Commonly, the handler function doesn't make "
"any use of the third argument."
msgstr ""
"Указатель на структуру I<ucontext_t>, приведённую к I<void \"\\ *>. Эта "
"структура содержит информацию о контексте сигнала, которая была сохранена "
"ядром в стеке пользовательского пространства; подробности описаны в "
"B<sigreturn>(2). Подробней о структуре I<ucontext_t> смотрите в "
"B<getcontext>(3). Вообще, функция-обработчик не использует третий аргумент."

#. type: Plain text
#: man-pages/man2/sigaction.2:303
msgid "The I<siginfo_t> data type is a structure with the following fields:"
msgstr ""
"Тип данных I<siginfo_t> представляется структурой со следующими полями:"

#.  FIXME
#.  The siginfo_t 'si_trapno' field seems to be used
#.  only on SPARC and Alpha; this page could use
#.  a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: man-pages/man2/sigaction.2:348
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;     /* Signal number */\n"
"    int      si_errno;     /* An errno value */\n"
"    int      si_code;      /* Signal code */\n"
"    int      si_trapno;    /* Trap number that caused\n"
"                              hardware-generated signal\n"
"                              (unused on most architectures) */\n"
"    pid_t    si_pid;       /* Sending process ID */\n"
"    uid_t    si_uid;       /* Real user ID of sending process */\n"
"    int      si_status;    /* Exit value or signal */\n"
"    clock_t  si_utime;     /* User time consumed */\n"
"    clock_t  si_stime;     /* System time consumed */\n"
"    sigval_t si_value;     /* Signal value */\n"
"    int      si_int;       /* POSIX.1b signal */\n"
"    void    *si_ptr;       /* POSIX.1b signal */\n"
"    int      si_overrun;   /* Timer overrun count;\n"
"                              POSIX.1b timers */\n"
"    int      si_timerid;   /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;      /* Memory location which caused fault */\n"
"    long     si_band;      /* Band event (was I<int> in\n"
"                              glibc 2.3.2 and earlier) */\n"
"    int      si_fd;        /* File descriptor */\n"
"    short    si_addr_lsb;  /* Least significant bit of address\n"
"                              (since Linux 2.6.32) */\n"
"    void    *si_lower;     /* Lower bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    void    *si_upper;     /* Upper bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    int      si_pkey;      /* Protection key on PTE that caused\n"
"                              fault (since Linux 4.6) */\n"
"    void    *si_call_addr; /* Address of system call instruction\n"
"                              (since Linux 3.5) */\n"
"    int      si_syscall;   /* Number of attempted system call\n"
"                              (since Linux 3.5) */\n"
"    unsigned int si_arch;  /* Architecture of attempted system call\n"
"                              (since Linux 3.5) */\n"
"}\n"
msgstr ""
"siginfo_t {\n"
"    int      si_signo;     /* Номер сигнала */\n"
"    int      si_errno;     /* Значение errno */\n"
"    int      si_code;      /* Код сигнала */\n"
"    int      si_trapno;    /* Номер ловушки, которую вызвал\n"
"                              аппаратный сигнал\n"
"                              (не используется на большинстве\n"
"                              архитектур) */\n"
"    pid_t    si_pid;       /* ID процесса, пославшего сигнал */\n"
"    uid_t    si_uid;       /* ID реального пользователя процесса,\n"
"                              пославшего сигнал */\n"
"    int      si_status;    /* Выходное значение или номер сигнала */\n"
"    clock_t  si_utime;     /* Использованное пользовательское время */\n"
"    clock_t  si_stime;     /* Использованное системное время */\n"
"    sigval_t si_value;     /* Значение сигнала */\n"
"    int      si_int;       /* Сигнал POSIX.1b */\n"
"    void    *si_ptr;       /* Сигнал POSIX.1b */\n"
"    int      si_overrun;   /* Счётчик переполнения таймера;\n"
"                              таймеры POSIX.1b */\n"
"    int      si_timerid;   /* ID таймера; таймеры POSIX.1b */\n"
"    void    *si_addr;      /* Адрес памяти, приводящий к ошибке */\n"
"    long     si_band;      /* Внутреннее событие (был I<int> в\n"
"                              glibc 2.3.2 и более ранних) */\n"
"    int      si_fd;        /* Файловый дескриптор */\n"
"    short    si_addr_lsb;  /* Наименее значимый бит адреса\n"
"                              (начиная с Linux 2.6.32) */\n"
"    void    *si_lower;     /* Нижняя граница при нарушении адреса\n"
"                              (начиная с Linux 3.19) */\n"
"    void    *si_upper;     /* Верхняя граница при нарушении адреса\n"
"                              (начиная с Linux 3.19) */\n"
"    int      si_pkey;      /* Ключа защиты в PTE, который привёл\n"
"                              к ошибке (начиная с Linux 4.6) */\n"
"    void    *si_call_addr; /* Адрес инструкции системного вызова\n"
"                              (начиная с Linux 3.5) */\n"
"    int      si_syscall;   /* Количество попыток системного вызова\n"
"                              (начиная с Linux 3.5) */\n"
"    unsigned int si_arch;  /* Архитектура пытавшегося системного вызова\n"
"                              (начиная с Linux 3.5) */\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:357
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a "
"union, so that one should read only the fields that are meaningful for the "
"given signal:"
msgstr ""
"Поля I<si_signo>, I<si_errno> и I<si_code> определены для всех сигналов. "
"(I<si_errno> обычно не используется в Linux.) Оставшаяся часть структуры "
"может представлять собой объединение, поэтому нужно читать только те поля, "
"которые имеют смысл для заданного сигнала:"

#. type: Plain text
#: man-pages/man2/sigaction.2:372
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int> "
"and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr ""
"Для сигналов, посылаемых B<kill>(3) и B<sigqueue>(3), заполняются I<si_pid> "
"и I<si_uid>. Также для сигналов, посылаемых B<sigqueue>(3), заполняются "
"I<si_int> и I<si_ptr> значениями, задаваемыми отправителем сигнала; "
"подробней смотрите B<sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/sigaction.2:388
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel "
"to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to "
"B<timer_getoverrun>(2).  These fields are nonstandard Linux extensions."
msgstr ""
"Для сигналов, посылаемых таймерами POSIX.1b (начиная с Linux 2.6), "
"заполняются I<si_overrun> и I<si_timerid>. Поле I<si_timerid> является "
"внутренним идентификатором, который используется ядром для различения "
"таймеров; это не идентификатор таймера, возвращаемого B<timer_create>(2). "
"Поле I<si_overrun> отражает счётчик превышения таймера; эту же информацию "
"можно получить с помощью вызова B<timer_getoverrun>(2). Эти поля являются "
"нестандартным расширением Linux."

#. type: Plain text
#: man-pages/man2/sigaction.2:403
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr ""
"Для сигналов, посылаемых уведомлением очереди сообщений (см. описание "
"B<SIGEV_SIGNAL> в B<mq_notify>(3)), заполняются I<si_int>/I<si_ptr>  "
"значением I<sigev_value>, предоставляемым B<mq_notify>(3); I<si_pid> \\(em "
"значением идентификатора процесса, отправившего сообщение; I<si_uid> \\(em "
"значением реального идентификатора пользователя, отправившего сообщение."

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: man-pages/man2/sigaction.2:450
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>, and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time "
"used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<times>(2)).  In kernels "
"up to 2.6, and since 2.6.27, these fields report CPU time in units of "
"I<sysconf(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that "
"these fields reported time in units of the (configurable) system jiffy (see "
"B<time>(7))."
msgstr ""
"Для B<SIGCHLD> заполняются I<si_pid>, I<si_uid>, I<si_status>, I<si_utime> и "
"I<si_stime>, предоставляющие информацию о потомке. В поле I<si_pid> "
"указывается идентификатор процесса потомка; в I<si_uid> — реальный "
"пользовательский идентификатор потомка. В поле I<si_status> содержится код "
"завершения потомка (если I<si_code> равно B<CLD_EXITED>) или номер сигнала, "
"который вызвал изменение состояния процесса. Поля I<si_utime> и I<si_stime> "
"содержат системное и пользовательское время ЦП, затраченное процессом-"
"потомком; эти поля не содержат время, использованное на ожидание потомков (в "
"отличие от B<getrusage>(2) и B<times>(2)). В ядрах до версии 2.6 и начиная с "
"2.6.27 эти поля содержат время ЦП в единицах I<sysconf(_SC_CLK_TCK)>. В "
"ядрах 2.6 до 2.6.27 ошибочно считалось, что эти поля содержат время в "
"единицах (настраиваемых) системных мигов (jiffy) (смотрите B<time>(7))."

#. type: Plain text
#: man-pages/man2/sigaction.2:464
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> field."
msgstr ""
"При B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS> и B<SIGTRAP> заполняется "
"I<si_addr> адресом ошибки. На некоторых архитектурах для эти сигналов также "
"заполняется поле I<si_trapno>."

#. type: Plain text
#: man-pages/man2/sigaction.2:498
msgid ""
"Some suberrors of B<SIGBUS>, in particular B<BUS_MCEERR_AO> and "
"B<BUS_MCEERR_AR>, also fill in I<si_addr_lsb>.  This field indicates the "
"least significant bit of the reported address and therefore the extent of "
"the corruption.  For example, if a full page was corrupted, I<si_addr_lsb> "
"contains I<log2(sysconf(_SC_PAGESIZE))>.  When B<SIGTRAP> is delivered in "
"response to a B<ptrace>(2)  event (PTRACE_EVENT_foo), I<si_addr> is not "
"populated, but I<si_pid> and I<si_uid> are populated with the respective "
"process ID and user ID responsible for delivering the trap.  In the case of "
"B<seccomp>(2), the tracee will be shown as delivering the event.  "
"B<BUS_MCEERR_*> and I<si_addr_lsb> are Linux-specific extensions."
msgstr ""
"Некоторые отдельные варианты B<SIGBUS>, в частности B<BUS_MCEERR_AO> и "
"B<BUS_MCEERR_AR>, также заполняют I<si_addr_lsb>. Это поле указывает на "
"наименее значимый бит сообщаемого адреса и поэтому показывает размер "
"повреждения. Например, если была повреждена страница целиком, то "
"I<si_addr_lsb> содержит I<log2(sysconf(_SC_PAGESIZE))>. Когда доставляется "
"B<SIGTRAP> в ответ на событие B<ptrace>(2) (PTRACE_EVENT_foo), то I<si_addr> "
"не заполняется, но заполняются I<si_pid> и I<si_uid> соответствующими ID "
"процесса и пользователя, ответственного за получение трапа. В случае "
"B<seccomp>(2), трассируемый будет показан как получающий событие. "
"B<BUS_MCERR_*> и I<si_addr_lsb> являются расширениями Linux."

#. type: Plain text
#: man-pages/man2/sigaction.2:507
msgid ""
"The B<SEGV_BNDERR> suberror of B<SIGSEGV> populates I<si_lower> and "
"I<si_upper>."
msgstr ""
"Для отдельного варианта B<SEGV_BNDERR> из B<SIGSEGV> заполняются I<si_lower> "
"и I<si_upper>."

#. type: Plain text
#: man-pages/man2/sigaction.2:514
msgid "The B<SEGV_PKUERR> suberror of B<SIGSEGV> populates I<si_pkey>."
msgstr ""
"Для отдельного варианта B<SEGV_PKUERR> из B<SIGSEGV> заполняется I<si_pkey>."

#. type: Plain text
#: man-pages/man2/sigaction.2:532
msgid ""
"B<SIGIO>/B<SIGPOLL> (the two names are synonyms on Linux)  fills in "
"I<si_band> and I<si_fd>.  The I<si_band> event is a bit mask containing the "
"same values as are filled in the I<revents> field by B<poll>(2).  The "
"I<si_fd> field indicates the file descriptor for which the I/O event "
"occurred; for further details, see the description of B<F_SETSIG> in "
"B<fcntl>(2)."
msgstr ""
"Для B<SIGIO>/B<SIGPOLL> (синонимы в Linux) заполняются I<si_band> и "
"I<si_fd>. Событие I<si_band> представляет собой битовую маску, содержащую те "
"же значения, которые заполняются в поле I<revents> вызовом B<poll>(2). Поле "
"I<si_fd> содержит файловый дескриптор, для которого произошло событие ввода-"
"вывода; дополнительную информацию смотрите в описании B<F_SETSIG> на "
"странице B<fcntl>(2)."

#.  commit a0727e8ce513fe6890416da960181ceb10fbfae6
#. type: Plain text
#: man-pages/man2/sigaction.2:546
msgid ""
"B<SIGSYS>, generated (since Linux 3.5)  when a seccomp filter returns "
"B<SECCOMP_RET_TRAP>, fills in I<si_call_addr>, I<si_syscall>, I<si_arch>, "
"I<si_errno>, and other fields as described in B<seccomp>(2)."
msgstr ""
"Для B<SIGSYS>, генерируемого (начиная с Linux 3.5), когда фильтр seccomp "
"возвращает B<SECCOMP_RET_TRAP>, заполняются I<si_call_addr>, I<si_syscall>, "
"I<si_arch>, I<si_errno> и другие поля, как описывается в B<seccomp>(2)."

#. type: SS
#: man-pages/man2/sigaction.2:546
#, no-wrap
msgid "The si_code field"
msgstr "Поле si_code"

#. type: Plain text
#: man-pages/man2/sigaction.2:563
msgid ""
"The I<si_code> field inside the I<siginfo_t> argument that is passed to a "
"B<SA_SIGINFO> signal handler is a value (not a bit mask)  indicating why "
"this signal was sent.  For a B<ptrace>(2)  event, I<si_code> will contain "
"B<SIGTRAP> and have the ptrace event in the high byte:"
msgstr ""
"В поле I<si_code> аргумента I<siginfo_t>, передаваемого обработчику сигналов "
"B<SA_SIGINFO> содержится значение (не маска битов), определяющее причину "
"отправки сигнала. При событии B<ptrace>(2) в I<si_code> будет содержаться "
"B<SIGTRAP> и событие ptrace в старшем байте:"

#. type: Plain text
#: man-pages/man2/sigaction.2:567
#, no-wrap
msgid "(SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr "(SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:581
msgid ""
"For a non-B<ptrace>(2)  event, the values that can appear in I<si_code> are "
"described in the remainder of this section.  Since glibc 2.20, the "
"definitions of most of these symbols are obtained from I<E<lt>signal.hE<gt>> "
"by defining feature test macros (before including I<any> header file) as "
"follows:"
msgstr ""
"Не события не B<ptrace>(2) значения, которые могут появиться в I<si_code>, "
"описаны в конце этого раздела. Начиная с glibc 2.20, определения большинства "
"этих символов доступны из I<E<lt>signal.hE<gt>> при определении макросов "
"тестирования свойств (до включения I<какого-либо> заголовочного файла) "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/sigaction.2:584
msgid "B<_XOPEN_SOURCE> with the value 500 or greater;"
msgstr "B<_XOPEN_SOURCE> со значением 500 или больше;"

#. type: Plain text
#: man-pages/man2/sigaction.2:589
msgid "B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>; or"
msgstr "B<_XOPEN_SOURCE> и B<_XOPEN_SOURCE_EXTENDED>; или"

#. type: Plain text
#: man-pages/man2/sigaction.2:592
msgid "B<_POSIX_C_SOURCE> with the value 200809L or greater."
msgstr "B<_POSIX_C_SOURCE> со значением 200809L или больше."

#. type: Plain text
#: man-pages/man2/sigaction.2:597
msgid ""
"For the B<TRAP_*> constants, the symbol definitions are provided only in the "
"first two cases.  Before glibc 2.20, no feature test macros were required to "
"obtain these symbols."
msgstr ""
"Определения символов констант B<TRAP_*>  предоставляются только в первых "
"двух случаях. До glibc 2.20 для получения этих символов макросы тестирования "
"свойств были не нужны."

#. type: Plain text
#: man-pages/man2/sigaction.2:602
msgid ""
"For a regular signal, the following list shows the values which can be "
"placed in I<si_code> for any signal, along with the reason that the signal "
"was generated."
msgstr ""
"Для обычного сигнала в следующей таблице приведены значения, которые могут "
"быть в I<si_code> для любого сигнала, и причина возникновения сигнала:"

#. type: TP
#: man-pages/man2/sigaction.2:603
#, no-wrap
msgid "B<SI_USER>"
msgstr "B<SI_USER>"

#. type: Plain text
#: man-pages/man2/sigaction.2:606
msgid "B<kill>(2)."
msgstr "B<kill>(2)."

#. type: TP
#: man-pages/man2/sigaction.2:606
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr "B<SI_KERNEL>"

#. type: Plain text
#: man-pages/man2/sigaction.2:609
msgid "Sent by the kernel."
msgstr "посылается ядром"

#. type: TP
#: man-pages/man2/sigaction.2:609
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr "B<SI_QUEUE>"

#. type: Plain text
#: man-pages/man2/sigaction.2:612
msgid "B<sigqueue>(3)."
msgstr "B<sigqueue>(3)."

#. type: TP
#: man-pages/man2/sigaction.2:612
#, no-wrap
msgid "B<SI_TIMER>"
msgstr "B<SI_TIMER>"

#. type: Plain text
#: man-pages/man2/sigaction.2:615
msgid "POSIX timer expired."
msgstr "таймер POSIX истёк."

#. type: TP
#: man-pages/man2/sigaction.2:615
#, no-wrap
msgid "B<SI_MESGQ> (since Linux 2.6.6)"
msgstr "B<SI_MESGQ> (начиная с Linux 2.6.6)"

#. type: Plain text
#: man-pages/man2/sigaction.2:619
msgid "POSIX message queue state changed; see B<mq_notify>(3)."
msgstr "изменилось состояние очереди сообщений POSIX; см. B<mq_notify>(3)."

#. type: TP
#: man-pages/man2/sigaction.2:619
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr "B<SI_ASYNCIO>"

#. type: Plain text
#: man-pages/man2/sigaction.2:622
msgid "AIO completed."
msgstr "AIO завершён."

#. type: TP
#: man-pages/man2/sigaction.2:622
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr "B<SI_SIGIO>"

#. type: Plain text
#: man-pages/man2/sigaction.2:631
msgid ""
"Queued B<SIGIO> (only in kernels up to Linux 2.2; from Linux 2.4 onward "
"B<SIGIO>/B<SIGPOLL> fills in I<si_code> as described below)."
msgstr ""
"Queued B<SIGIO> (только в ядрах до Linux 2.2; начиная с Linux 2.4 B<SIGIO>/"
"B<SIGPOLL> заполняют I<si_code> как описано выше)."

#. type: TP
#: man-pages/man2/sigaction.2:631
#, no-wrap
msgid "B<SI_TKILL> (since Linux 2.4.19)"
msgstr "B<SI_TKILL> (начиная с Linux 2.4.19)"

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: man-pages/man2/sigaction.2:639
msgid "B<tkill>(2)  or B<tgkill>(2)."
msgstr "B<tkill>(2)  или B<tgkill>(2)."

#. type: Plain text
#: man-pages/man2/sigaction.2:646
msgid ""
"The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGILL>:"

#. type: TP
#: man-pages/man2/sigaction.2:647
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr "B<ILL_ILLOPC>"

#. type: Plain text
#: man-pages/man2/sigaction.2:650
msgid "Illegal opcode."
msgstr "Некорректный код инструкции."

#. type: TP
#: man-pages/man2/sigaction.2:650
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr "B<ILL_ILLOPN>"

#. type: Plain text
#: man-pages/man2/sigaction.2:653
msgid "Illegal operand."
msgstr "Некорректный операнд."

#. type: TP
#: man-pages/man2/sigaction.2:653
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr "B<ILL_ILLADR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:656
msgid "Illegal addressing mode."
msgstr "Некорректный режим адресации."

#. type: TP
#: man-pages/man2/sigaction.2:656
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr "B<ILL_ILLTRP>"

#. type: Plain text
#: man-pages/man2/sigaction.2:659
msgid "Illegal trap."
msgstr "Некорректная ловушка."

#. type: TP
#: man-pages/man2/sigaction.2:659
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr "B<ILL_PRVOPC>"

#. type: Plain text
#: man-pages/man2/sigaction.2:662
msgid "Privileged opcode."
msgstr "Привилегированный код инструкции."

#. type: TP
#: man-pages/man2/sigaction.2:662
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr "B<ILL_PRVREG>"

#. type: Plain text
#: man-pages/man2/sigaction.2:665
msgid "Privileged register."
msgstr "Привилегированный регистр."

#. type: TP
#: man-pages/man2/sigaction.2:665
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr "B<ILL_COPROC>"

#. type: Plain text
#: man-pages/man2/sigaction.2:668
msgid "Coprocessor error."
msgstr "Ошибка сопроцессора."

#. type: TP
#: man-pages/man2/sigaction.2:668
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr "B<ILL_BADSTK>"

#. type: Plain text
#: man-pages/man2/sigaction.2:671
msgid "Internal stack error."
msgstr "Внутренняя ошибка стека."

#. type: Plain text
#: man-pages/man2/sigaction.2:678
msgid ""
"The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGFPE>:"

#. type: TP
#: man-pages/man2/sigaction.2:679
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr "B<FPE_INTDIV>"

#. type: Plain text
#: man-pages/man2/sigaction.2:682
msgid "Integer divide by zero."
msgstr "Деление на ноль при работе с целыми числами."

#. type: TP
#: man-pages/man2/sigaction.2:682
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr "B<FPE_INTOVF>"

#. type: Plain text
#: man-pages/man2/sigaction.2:685
msgid "Integer overflow."
msgstr "Переполнение при работе с целыми числами."

#. type: TP
#: man-pages/man2/sigaction.2:685
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr "B<FPE_FLTDIV>"

#. type: Plain text
#: man-pages/man2/sigaction.2:688
msgid "Floating-point divide by zero."
msgstr "Деление на ноль при работе с числами с плавающей запятой."

#. type: TP
#: man-pages/man2/sigaction.2:688
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr "B<FPE_FLTOVF>"

#. type: Plain text
#: man-pages/man2/sigaction.2:691
msgid "Floating-point overflow."
msgstr "Переполнение при работе с числами с плавающей запятой."

#. type: TP
#: man-pages/man2/sigaction.2:691
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr "B<FPE_FLTUND>"

#. type: Plain text
#: man-pages/man2/sigaction.2:694
msgid "Floating-point underflow."
msgstr "Нехватка значения при работе с числами с плавающей запятой."

#. type: TP
#: man-pages/man2/sigaction.2:694
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr "B<FPE_FLTRES>"

#. type: Plain text
#: man-pages/man2/sigaction.2:697
msgid "Floating-point inexact result."
msgstr "Неточный результат при работе с числами с плавающей запятой."

#. type: TP
#: man-pages/man2/sigaction.2:697
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr "B<FPE_FLTINV>"

#. type: Plain text
#: man-pages/man2/sigaction.2:700
msgid "Floating-point invalid operation."
msgstr "Неправильная операция при работе с числами с плавающей запятой."

#. type: TP
#: man-pages/man2/sigaction.2:700
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr "B<FPE_FLTSUB>"

#. type: Plain text
#: man-pages/man2/sigaction.2:703
msgid "Subscript out of range."
msgstr ""
"Индекс вне разрешенных пределов при работе с числами с плавающей запятой."

#. type: Plain text
#: man-pages/man2/sigaction.2:710
msgid ""
"The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGSEGV>:"

#. type: TP
#: man-pages/man2/sigaction.2:711
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr "B<SEGV_MAPERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:714
msgid "Address not mapped to object."
msgstr "Адрес не соответствует объекту."

#. type: TP
#: man-pages/man2/sigaction.2:714
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr "B<SEGV_ACCERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:717
msgid "Invalid permissions for mapped object."
msgstr "Некорректные права на отображённый объект."

#. type: TP
#: man-pages/man2/sigaction.2:717
#, no-wrap
msgid "B<SEGV_BNDERR> (since Linux 3.19)"
msgstr "B<SEGV_BNDERR> (начиная с Linux 3.19)"

#.  commit ee1b58d36aa1b5a79eaba11f5c3633c88231da83
#. type: Plain text
#: man-pages/man2/sigaction.2:721
msgid "Failed address bound checks."
msgstr "Ошибка проверки границ адреса."

#. type: TP
#: man-pages/man2/sigaction.2:721
#, no-wrap
msgid "B<SEGV_PKUERR> (since Linux 4.6)"
msgstr "B<SEGV_PKUERR> (начиная с Linux 4.6)"

#.  commit cd0ea35ff5511cde299a61c21a95889b4a71464e
#. type: Plain text
#: man-pages/man2/sigaction.2:729
msgid ""
"Access was denied by memory protection keys.  See B<pkeys>(7).  The "
"protection key which applied to this access is available via I<si_pkey>."
msgstr ""
"Доступ запрещён битами защиты памяти. Смотрите B<pkeys>(7). Ключ защиты, "
"применяемый при таком доступе, доступен в I<si_pkey>."

#. type: Plain text
#: man-pages/man2/sigaction.2:736
msgid ""
"The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGBUS>:"

#. type: TP
#: man-pages/man2/sigaction.2:737
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr "B<BUS_ADRALN>"

#. type: Plain text
#: man-pages/man2/sigaction.2:740
msgid "Invalid address alignment."
msgstr "Некорректное выравнивание адреса."

#. type: TP
#: man-pages/man2/sigaction.2:740
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr "B<BUS_ADRERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:743
msgid "Nonexistent physical address."
msgstr "Несуществующий физический адрес."

#. type: TP
#: man-pages/man2/sigaction.2:743
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr "B<BUS_OBJERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:746
msgid "Object-specific hardware error."
msgstr "Аппаратная ошибка, специфичная для объекта."

#. type: TP
#: man-pages/man2/sigaction.2:746
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AR> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/sigaction.2:749
msgid "Hardware memory error consumed on a machine check; action required."
msgstr ""
"машинной проверкой устранена аппаратная ошибка памяти; требуется действие"

#. type: TP
#: man-pages/man2/sigaction.2:749
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AO> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/sigaction.2:752
msgid ""
"Hardware memory error detected in process but not consumed; action optional."
msgstr ""
"в процессе обнаружена аппаратная ошибка памяти, но не устранена; действие не "
"обязательно"

#. type: Plain text
#: man-pages/man2/sigaction.2:759
msgid ""
"The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGTRAP>:"

#. type: TP
#: man-pages/man2/sigaction.2:760
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr "B<TRAP_BRKPT>"

#. type: Plain text
#: man-pages/man2/sigaction.2:763
msgid "Process breakpoint."
msgstr "Точка останова процесса."

#. type: TP
#: man-pages/man2/sigaction.2:763
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr "B<TRAP_TRACE>"

#. type: Plain text
#: man-pages/man2/sigaction.2:766
msgid "Process trace trap."
msgstr "Ловушка отладки процесса."

#. type: TP
#: man-pages/man2/sigaction.2:766
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4, IA64 only))"
msgstr "B<TRAP_BRANCH> (начиная с Linux 2.4, только для IA64))"

#. type: Plain text
#: man-pages/man2/sigaction.2:769
msgid "Process taken branch trap."
msgstr "Процесс пойман в ветвь ловушки."

#. type: TP
#: man-pages/man2/sigaction.2:769
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4, IA64 only))"
msgstr "B<TRAP_HWBKPT> (начиная с Linux 2.4, только для IA64))"

#. type: Plain text
#: man-pages/man2/sigaction.2:772
msgid "Hardware breakpoint/watchpoint."
msgstr "Аппаратная точка прерывания/слежения."

#. type: Plain text
#: man-pages/man2/sigaction.2:779
msgid ""
"The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGCHLD>:"

#. type: TP
#: man-pages/man2/sigaction.2:780
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr "B<CLD_EXITED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:783
msgid "Child has exited."
msgstr "Дочерний процесс завершил работу."

#. type: TP
#: man-pages/man2/sigaction.2:783
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr "B<CLD_KILLED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:786
msgid "Child was killed."
msgstr "Работа дочернего процесса была прервана."

#. type: TP
#: man-pages/man2/sigaction.2:786
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr "B<CLD_DUMPED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:789
msgid "Child terminated abnormally."
msgstr "Дочерний процесс завершился некорректно."

#. type: TP
#: man-pages/man2/sigaction.2:789
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr "B<CLD_TRAPPED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:792
msgid "Traced child has trapped."
msgstr "Сработала ловушка в отлаживаемом дочернем процессе."

#. type: TP
#: man-pages/man2/sigaction.2:792
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr "B<CLD_STOPPED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:795
msgid "Child has stopped."
msgstr "Дочерний процесс остановлен."

#. type: TP
#: man-pages/man2/sigaction.2:795
#, no-wrap
msgid "B<CLD_CONTINUED> (since Linux 2.6.9)"
msgstr "B<CLD_CONTINUED> (начиная с Linux 2.6.9)"

#. type: Plain text
#: man-pages/man2/sigaction.2:798
msgid "Stopped child has continued."
msgstr "Остановленный дочерний процесс продолжил работу."

#. type: Plain text
#: man-pages/man2/sigaction.2:805
msgid ""
"The following values can be placed in I<si_code> for a B<SIGIO>/B<SIGPOLL> "
"signal:"
msgstr ""
"Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGIO>/"
"B<SIGPOLL>:"

#. type: TP
#: man-pages/man2/sigaction.2:806
#, no-wrap
msgid "B<POLL_IN>"
msgstr "B<POLL_IN>"

#. type: Plain text
#: man-pages/man2/sigaction.2:809
msgid "Data input available."
msgstr "Есть входные данные."

#. type: TP
#: man-pages/man2/sigaction.2:809
#, no-wrap
msgid "B<POLL_OUT>"
msgstr "B<POLL_OUT>"

#. type: Plain text
#: man-pages/man2/sigaction.2:812
msgid "Output buffers available."
msgstr "Освободились выходные буферы."

#. type: TP
#: man-pages/man2/sigaction.2:812
#, no-wrap
msgid "B<POLL_MSG>"
msgstr "B<POLL_MSG>"

#. type: Plain text
#: man-pages/man2/sigaction.2:815
msgid "Input message available."
msgstr "Есть входное сообщение."

#. type: TP
#: man-pages/man2/sigaction.2:815
#, no-wrap
msgid "B<POLL_ERR>"
msgstr "B<POLL_ERR>"

#. type: TP
#: man-pages/man2/sigaction.2:818
#, no-wrap
msgid "B<POLL_PRI>"
msgstr "B<POLL_PRI>"

#. type: Plain text
#: man-pages/man2/sigaction.2:821
msgid "High priority input available."
msgstr "Есть входные данные высокого приоритета."

#. type: TP
#: man-pages/man2/sigaction.2:821
#, no-wrap
msgid "B<POLL_HUP>"
msgstr "B<POLL_HUP>"

#. type: Plain text
#: man-pages/man2/sigaction.2:824
msgid "Device disconnected."
msgstr "Устройство отключено."

#. type: Plain text
#: man-pages/man2/sigaction.2:831
msgid "The following value can be placed in I<si_code> for a B<SIGSYS> signal:"
msgstr ""
"Следующее значение может присутствовать в I<si_code> для сигнала B<SIGSYS>:"

#. type: TP
#: man-pages/man2/sigaction.2:832
#, no-wrap
msgid "B<SYS_SECCOMP> (since Linux 3.5)"
msgstr "B<SYS_SECCOMP> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/sigaction.2:837
msgid "Triggered by a B<seccomp>(2)  filter rule."
msgstr "Возникает по правилу фильтрации B<seccomp>(2)."

#. type: Plain text
#: man-pages/man2/sigaction.2:843
msgid ""
"B<sigaction>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"При успешном выполнении B<sigaction>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/sigaction.2:848
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr ""
"I<act> или I<oldact> указывают на память, которая не является частью "
"адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/sigaction.2:855
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr ""
"Указан некорректный сигнал. Также ошибка будет сгенерирована, если "
"произведена попытка изменить действие для сигналов B<SIGKILL> или "
"B<SIGSTOP>, которые не могут быть перехвачены или игнорированы."

#. type: Plain text
#: man-pages/man2/sigaction.2:884
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result.  "
"On some architectures it will generate a B<SIGFPE> signal.  (Also dividing "
"the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr ""
"В соответствии с POSIX поведение процесса после игнорирования сигнала "
"B<SIGFPE>, B<SIGILL> или B<SIGSEGV> не определено, если эти сигналы не были "
"посланы при помощи функций B<kill>(2) или B<raise>(3). Деление целого числа "
"на ноль имеет непредсказуемый результат. В некоторых архитектурах это "
"приводит к появлению сигнала B<SIGFPE>. (Также, деление самого большого по "
"модулю отрицательного числа на -1 тоже может приводить к B<SIGFPE>.) "
"Игнорирование этого сигнала может привести к появлению бесконечного цикла."

#. type: Plain text
#: man-pages/man2/sigaction.2:901
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 and later allow this possibility, so that ignoring B<SIGCHLD> "
"can be used to prevent the creation of zombies (see B<wait>(2)).  "
"Nevertheless, the historical BSD and System\\ V behaviors for ignoring "
"B<SIGCHLD> differ, so that the only completely portable method of ensuring "
"that terminated children do not become zombies is to catch the B<SIGCHLD> "
"signal and perform a B<wait>(2)  or similar."
msgstr ""
"POSIX.1-1990 запрещает установку действия для сигнала B<SIGCHLD> в "
"B<SIG_IGN>. В POSIX.1-2001 и новых версиях стандарта допускается такая "
"возможность, поэтому игнорирование B<SIGCHLD> можно использовать для "
"недопущения создания зомби (смотрите B<wait>(2)). Тем не менее, поведение "
"BSD и System\\ V по игнорированию B<SIGCHLD> различается, поэтому есть "
"только один переносимый способ убедиться, что завершившийся потомок не стал "
"зомби — поймать сигнал B<SIGCHLD> и выполнить B<wait>(2) или подобный вызов."

#. type: Plain text
#: man-pages/man2/sigaction.2:917
msgid ""
"POSIX.1-1990 specified only B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDSTOP>, B<SA_NOCLDWAIT>, B<SA_NODEFER>, B<SA_ONSTACK>, "
"B<SA_RESETHAND>, B<SA_RESTART>, and B<SA_SIGINFO>.  Use of these latter "
"values in I<sa_flags> may be less portable in applications intended for "
"older UNIX implementations."
msgstr ""
"В POSIX.1-1990 указан только B<SA_NOCLDSTOP>. В POSIX.1-2001 добавлены "
"B<SA_NOCLDSTOP>, B<SA_NOCLDWAIT>, B<SA_NODEFER>, B<SA_ONSTACK>, "
"B<SA_RESETHAND>, B<SA_RESTART> и B<SA_SIGINFO>. Использование в приложениях "
"последних значений в I<sa_flags> может оказаться сложнее перенести на старые "
"реализации UNIX."

#. type: Plain text
#: man-pages/man2/sigaction.2:921
msgid ""
"The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr "Флаг B<SA_RESETHAND> совместим с одноимённым флагом из SVr4."

#. type: Plain text
#: man-pages/man2/sigaction.2:931
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and newer.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr ""
"Флаг B<SA_NODEFER> совместим с одноименным флагом SVr4 в ядре версии 1.3.9 и "
"более поздних. В старых выпусках ядра Linux позволяли принимать и "
"обрабатывать любые сигналы, а не только те, обработка которых уже задана (на "
"деле это приводит к игнорированию установок I<sa_mask>)."

#. type: Plain text
#: man-pages/man2/sigaction.2:937
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal "
"is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr ""
"Для получения адреса текущего обработчика сигнала можно использовать вызов "
"B<sigaction>(), указав NULL в качестве значения второго аргумента. Этот "
"вызов можно также использовать для проверки доступности этого типа сигнала в "
"конкретной системе, вызвав его с вторым и третьим аргументами, равными NULL."

#. type: Plain text
#: man-pages/man2/sigaction.2:943
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr ""
"Невозможно заблокировать сигналы B<SIGKILL> или B<SIGSTOP> (указав их в "
"I<sa_mask>). Попытки это сделать будут просто игнорироваться."

#. type: Plain text
#: man-pages/man2/sigaction.2:953
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called inside from inside a signal handler."
msgstr ""
"Список функций безопасных асинхронных сигналов, которые можно не опасаясь "
"вызывать из обработчика сигналов, смотрите в B<signal-safety>(7)."

#. type: Plain text
#: man-pages/man2/sigaction.2:963
msgid ""
"The glibc wrapper function for B<sigaction>()  gives an error (B<EINVAL>)  "
"on attempts to change the disposition of the two real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""
"Обёрточная функция glibc для B<sigaction>() выдаёт ошибку (B<EINVAL>) при "
"попытках изменить обработчики двух сигналов реального времени, которые "
"используются внутри реализации NPTL. Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/sigaction.2:976
msgid ""
"On architectures where the signal trampoline resides in the C library, the "
"glibc wrapper function for B<sigaction>()  places the address of the "
"trampoline code in the I<act.sa_restorer> field and sets the B<SA_RESTORER> "
"flag in the I<act.sa_flags> field.  See B<sigreturn>(2)."
msgstr ""
"На архитектурах, где переход от сигнала (signal trampoline) располагается в "
"библиотеке C, обёрточная функция glibc для B<sigaction>() помещает адрес "
"кода перехода в поле I<act.sa_restorer> и изменяет флаг B<SA_RESTORER> в "
"поле I<act.sa_flags>. Смотрите B<sigreturn>(2)."

#. type: Plain text
#: man-pages/man2/sigaction.2:1005
msgid ""
"The original Linux system call was named B<sigaction>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigaction>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal sets in I<act.sa_mask> and I<oldact.sa_mask>.  This argument is "
"currently required to have the value I<sizeof(sigset_t)> (or the error "
"B<EINVAL> results).  The glibc B<sigaction>()  wrapper function hides these "
"details from us, transparently calling B<rt_sigaction>()  when the kernel "
"provides it."
msgstr ""
"Первоначально, системный вызов Linux назывался B<sigaction>(). Однако, с "
"добавлением сигналов реального времени в Linux 2.2, 32-битный аргумент "
"I<sigset_t> неизменяемого размера, поддерживаемый этим системным вызовом, не "
"мог больше использоваться. В результате был добавлен новый системный вызов "
"B<rt_sigaction>() с увеличенным типом I<sigset_t>. У нового системного "
"вызова появился четвёртый аргумент, I<size_t sigsetsize>, в котором "
"указывается размер (в байтах) наборов сигналов I<act.sa_mask> и I<oldact."
"sa_mask>. В настоящее время значение этого аргумента должно быть равно "
"I<sizeof(sigset_t)> (иначе возникает ошибка B<EINVAL>). Обёрточная функция "
"glibc B<sigaction>() скрывает это и вызывает B<rt_sigaction>(), если он есть "
"в ядре."

#. type: SS
#: man-pages/man2/sigaction.2:1005
#, no-wrap
msgid "Undocumented"
msgstr "Недокументированное"

#. type: Plain text
#: man-pages/man2/sigaction.2:1022
msgid ""
"Before the introduction of B<SA_SIGINFO>, it was also possible to get some "
"additional information about the signal.  This was done by providing an "
"I<sa_handler> signal handler with a second argument of type I<struct "
"sigcontext>, which is the same structure as the one that is passed in the "
"I<uc_mcontext> field of the I<ucontext> structure that is passed (via a "
"pointer) in the third argument of the I<sa_sigaction> handler.  See the "
"relevant Linux kernel sources for details.  This use is obsolete now."
msgstr ""
"До появления B<SA_SIGINFO> также было возможно получить дополнительную "
"информацию о сигнале. Для этого в обработчике сигнала I<sa_handler> "
"заполняется второй параметр типа I<struct sigcontext>, который повторяет "
"структуру, передаваемую в поле I<uc_mcontext> структуры I<ucontext>, которая "
"передаётся (через указатель) в третьем аргументе обработчика "
"I<sa_sigaction>. Смотрите соответствующий исходный код ядра Linux. В "
"настоящее время этот механизм устарел."

#. type: Plain text
#: man-pages/man2/sigaction.2:1031
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr ""
"В ядрах по версию 2.6.13 включительно, указание B<SA_NODEFER> в I<sa_flags> "
"предотвращает доставку сигнала  не только из маскируемого при выполнении "
"обработчика, но также сигналов, указанных в I<sa_mask>. Этот дефект "
"исправлен в ядре 2.6.14."

#. type: Plain text
#: man-pages/man2/sigaction.2:1034
msgid "See B<mprotect>(2)."
msgstr "Смотрите в B<mprotect>(2)."

#. type: Plain text
#: man-pages/man2/sigaction.2:1055
msgid ""
"B<kill>(1), B<kill>(2), B<pause>(2), B<restart_syscall>(2), B<seccomp>(2)  "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), B<wait>(2), "
"B<killpg>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), "
"B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"
msgstr ""
"B<kill>(1), B<kill>(2), B<pause>(2), B<restart_syscall>(2), B<seccomp>(2)  "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigreturn>(2), B<sigsuspend>(2), B<wait>(2), "
"B<killpg>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), "
"B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"

#. type: TH
#: man-pages/man2/syscalls.2:31
#, no-wrap
msgid "SYSCALLS"
msgstr "SYSCALLS"

#. type: Plain text
#: man-pages/man2/syscalls.2:34
msgid "syscalls - Linux system calls"
msgstr "syscalls - системные вызовы Linux"

#. type: Plain text
#: man-pages/man2/syscalls.2:36
msgid "Linux system calls."
msgstr "Системные вызовы Linux."

#. type: Plain text
#: man-pages/man2/syscalls.2:39
msgid ""
"The system call is the fundamental interface between an application and the "
"Linux kernel."
msgstr ""
"Системный вызов \\(em это основной интерфейс между приложением и ядром Linux."

#. type: SS
#: man-pages/man2/syscalls.2:39
#, no-wrap
msgid "System calls and library wrapper functions"
msgstr "Системные вызовы и обёрточные библиотечные функции"

#. type: Plain text
#: man-pages/man2/syscalls.2:49
msgid ""
"System calls are generally not invoked directly, but rather via wrapper "
"functions in glibc (or perhaps some other library).  For details of direct "
"invocation of a system call, see B<intro>(2).  Often, but not always, the "
"name of the wrapper function is the same as the name of the system call that "
"it invokes.  For example, glibc contains a function B<chdir>()  which "
"invokes the underlying \"chdir\" system call."
msgstr ""
"Обычно, системные вызовы не вызываются напрямую, это делается через "
"обёрточную функцию из glibc (или другой библиотеки). Подробней о "
"непосредственном вызове системного вызова, смотрите B<intro>(2). Часто, но "
"не всегда, имя обёрточной функции совпадает с именем системного вызова, "
"который она вызывает. Например, в glibc есть функция B<chdir>(), которая "
"вызывает делающий всё работу системный вызов «chdir»."

#. type: Plain text
#: man-pages/man2/syscalls.2:69
msgid ""
"Often the glibc wrapper function is quite thin, doing little work other than "
"copying arguments to the right registers before invoking the system call, "
"and then setting I<errno> appropriately after the system call has returned.  "
"(These are the same steps that are performed by B<syscall>(2), which can be "
"used to invoke system calls for which no wrapper function is provided.)  "
"Note: system calls indicate a failure by returning a negative error number "
"to the caller on architectures without a separate error register/flag, as "
"noted in B<syscall>(2); when this happens, the wrapper function negates the "
"returned error number (to make it positive), copies it to I<errno>, and "
"returns -1 to the caller of the wrapper."
msgstr ""
"Часто, обёрточная функция glibc очень маленькая, она просто копирует "
"аргументы в нужные регистры перед запуском системного вызова, а затем "
"присваивает переменной I<errno> значение, которое было возвращено системным "
"вызовом. (Эти те же шаги выполняет B<syscall>(2), её можно использовать для "
"осуществления системных вызовов, для которых нет обёрточных функций.) "
"Замечание: системные вызовы указывают, что произошла ошибка возвращая "
"отрицательное целое число вызывающей стороне (если в архитектуре нет "
"отдельного регистра/флага ошибки, смотрите B<syscall>(2)); когда это "
"происходит, обёрточная функция меняет знак у возвращённого значения (на "
"положительный), копирует его в I<errno> и возвращает -1 вызвавшей обёртку "
"функции."

#. type: Plain text
#: man-pages/man2/syscalls.2:81
msgid ""
"Sometimes, however, the wrapper function does some extra work before "
"invoking the system call.  For example, nowadays there are (for reasons "
"described below) two related system calls, B<truncate>(2)  and "
"B<truncate64>(2), and the glibc B<truncate>()  wrapper function checks which "
"of those system calls are provided by the kernel and determines which should "
"be employed."
msgstr ""
"Иногда, однако, обёрточная функция производит дополнительную работу до "
"осуществления системного вызова. Например, в настоящее время существует (по "
"причинам, описанным далее) два похожих системных вызова \\(em B<truncate>(2) "
"и B<truncate64>(2); обёрточная функция glibc B<truncate>() проверяет какой "
"из системных вызовов предоставляет ядро и решает какой нужно задействовать."

#. type: SS
#: man-pages/man2/syscalls.2:81
#, no-wrap
msgid "System call list"
msgstr "Список системных вызовов"

#. type: Plain text
#: man-pages/man2/syscalls.2:89
msgid ""
"Below is a list of the Linux system calls.  In the list, the I<Kernel> "
"column indicates the kernel version for those system calls that were new in "
"Linux 2.2, or have appeared since that kernel version.  Note the following "
"points:"
msgstr ""
"Далее приведён список список системных вызовов Linux. В колонке I<Ядро> "
"указана версия ядра для системных вызовов, которые появились в Linux 2.2, и "
"с какой именно версии. Также заметим следующее:"

#. type: Plain text
#: man-pages/man2/syscalls.2:92
msgid ""
"Where no kernel version is indicated, the system call appeared in kernel 1.0 "
"or earlier."
msgstr ""
"Если версия ядра не указана, то системный вызов появился в ядре 1.0 или "
"более раннем."

#. type: Plain text
#: man-pages/man2/syscalls.2:98
msgid ""
"Where a system call is marked \"1.2\" this means the system call probably "
"appeared in a 1.1.x kernel version, and first appeared in a stable kernel "
"with 1.2.  (Development of the 1.2 kernel was initiated from a branch of "
"kernel 1.0.6 via the 1.1.x unstable kernel series.)"
msgstr ""
"Системные вызовы, помеченные \"1.2\", скорее всего появились в в версиях "
"ядра 1.1.x, и впервые появились в стабильном ядре 1.2. (Разработка ядра 1.2 "
"началась с ответвления от ядра 1.0.6 и прошла несколько выпусков ядер 1.1.x.)"

#.  Was kernel 2.0 started from a branch of 1.2.10?
#.  At least from the timestamps of the tarballs of
#.  of 1.2.10 and 1.3.0, that's how it looks, but in
#.  fact the diff doesn't seem very clear, the
#.  1.3.0 .tar.bz is much bigger (2.0 MB) than the
#.  1.2.10 .tar.bz2 (1.8 MB), and AEB points out the
#.  timestamps of some files in 1.3.0 seem to be older
#.  than those in 1.2.10.  All of this suggests
#.  that there might not have been a clean branch point.
#. type: Plain text
#: man-pages/man2/syscalls.2:114
msgid ""
"Where a system call is marked \"2.0\" this means the system call probably "
"appeared in a 1.3.x kernel version, and first appeared in a stable kernel "
"with 2.0.  (Development of the 2.0 kernel was initiated from a branch of "
"kernel 1.2.x, somewhere around 1.2.10, via the 1.3.x unstable kernel series.)"
msgstr ""
"Системные вызовы, помеченные \"1.2\", скорее всего появились в в версиях "
"ядра 1.3.x, и впервые появились в стабильном ядре 2.0. (Разработка ядра 2.0 "
"началась с ответвления от ядра 1.2.x, начиная, приблизительно, с 1.2.10, и "
"прошла несколько выпусков ядер 1.3.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:120
msgid ""
"Where a system call is marked \"2.2\" this means the system call probably "
"appeared in a 2.1.x kernel version, and first appeared in a stable kernel "
"with 2.2.0.  (Development of the 2.2 kernel was initiated from a branch of "
"kernel 2.0.21 via the 2.1.x unstable kernel series.)"
msgstr ""
"Системные вызовы, помеченные \"2.2\", скорее всего появились в в версиях "
"ядра 2.1.x, и впервые появились в стабильном ядре 2.2.0. (Разработка ядра "
"2.2 началась с ответвления от ядра 2.0.21, и прошла несколько выпусков ядер "
"2.1.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:126
msgid ""
"Where a system call is marked \"2.4\" this means the system call probably "
"appeared in a 2.3.x kernel version, and first appeared in a stable kernel "
"with 2.4.0.  (Development of the 2.4 kernel was initiated from a branch of "
"kernel 2.2.8 via the 2.3.x unstable kernel series.)"
msgstr ""
"Системные вызовы, помеченные \"2.4\", скорее всего появились в в версиях "
"ядра 2.3.x, и впервые появились в стабильном ядре 2.4.0. (Разработка ядра "
"2.4 началась с ответвления от ядра 2.2.8, и прошла несколько выпусков ядер "
"2.3.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:132
msgid ""
"Where a system call is marked \"2.6\" this means the system call probably "
"appeared in a 2.5.x kernel version, and first appeared in a stable kernel "
"with 2.6.0.  (Development of kernel 2.6 was initiated from a branch of "
"kernel 2.4.15 via the 2.5.x unstable kernel series.)"
msgstr ""
"Системные вызовы, помеченные \"2.6\", скорее всего появились в в версиях "
"ядра 2.5.x, и впервые появились в стабильном ядре 2.6.0. (Разработка ядра "
"2.6 началась с ответвления от ядра 2.4.15, и прошла несколько выпусков ядер "
"2.5.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:140
msgid ""
"Starting with kernel 2.6.0, the development model changed, and new system "
"calls may appear in each 2.6.x release.  In this case, the exact version "
"number where the system call appeared is shown.  This convention continues "
"with the 3.x kernel series, which followed on from kernel 2.6.39, and the 4."
"x kernel series, which followed on from kernel 3.19."
msgstr ""
"Начиная с ядра 2.6.0 порядок разработки был изменён, и новые системные "
"вызовы могут появляться в каждом выпуске 2.6.x. В этом случае для системного "
"вызова указан точный номер версии. 2.6.39. Это соглашение продолжает "
"действовать и в ядрах серии 3.x, которая началась с ядра 2.6.39, и в ядрах "
"серии 4.х, которая началась с ядра 3.19."

#. type: Plain text
#: man-pages/man2/syscalls.2:148
msgid ""
"In some cases, a system call was added to a stable kernel series after it "
"branched from the previous stable kernel series, and then backported into "
"the earlier stable kernel series.  For example some system calls that "
"appeared in 2.6.x were also backported into a 2.4.x release after 2.4.15.  "
"When this is so, the version where the system call appeared in both of the "
"major kernel series is listed."
msgstr ""
"Иногда системный вызов, добавленный в текущую на тот момент стабильную ветвь "
"ядра, переносился в предыдущие стабильные ветви ядра. Например, некоторые "
"системные вызовы, которые появились в в 2.6.x были перенесены и в выпуски "
"2.4.x, начиная с 2.4.15. Если это производилось, будут показаны основные "
"версии обеих ветвей ядра."

#.  Looking at scripts/checksyscalls.sh in the kernel source is
#.  instructive about x86 specifics.
#. type: Plain text
#: man-pages/man2/syscalls.2:155
msgid ""
"The list of system calls that are available as at kernel 4.19 (or in a few "
"cases only on older kernels) is as follows:"
msgstr ""
"Список системных вызовов, доступных в ядре версии 4.19 (или, в некоторых "
"случаях, только в более старых ядрах):"

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<System call>"
msgstr "B<System call>"

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<Kernel>"
msgstr "B<Kernel>"

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<Notes>"
msgstr "B<Notes>"

#. type: tbl table
#: man-pages/man2/syscalls.2:162
#, no-wrap
msgid "B<_llseek>(2)"
msgstr "B<_llseek>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:162 man-pages/man2/syscalls.2:183
#: man-pages/man2/syscalls.2:201 man-pages/man2/syscalls.2:524
#: man-pages/man2/syscalls.2:664 man-pages/man2/syscalls.2:666
#: man-pages/man2/syscalls.2:763
#, no-wrap
msgid "1.2"
msgstr "1.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:163
#, no-wrap
msgid "B<_newselect>(2)"
msgstr "B<_newselect>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:163 man-pages/man2/syscalls.2:164
#: man-pages/man2/syscalls.2:165 man-pages/man2/syscalls.2:193
#: man-pages/man2/syscalls.2:240 man-pages/man2/syscalls.2:262
#: man-pages/man2/syscalls.2:288 man-pages/man2/syscalls.2:292
#: man-pages/man2/syscalls.2:319 man-pages/man2/syscalls.2:330
#: man-pages/man2/syscalls.2:345 man-pages/man2/syscalls.2:351
#: man-pages/man2/syscalls.2:352 man-pages/man2/syscalls.2:365
#: man-pages/man2/syscalls.2:366 man-pages/man2/syscalls.2:367
#: man-pages/man2/syscalls.2:374 man-pages/man2/syscalls.2:375
#: man-pages/man2/syscalls.2:376 man-pages/man2/syscalls.2:414
#: man-pages/man2/syscalls.2:456 man-pages/man2/syscalls.2:458
#: man-pages/man2/syscalls.2:472 man-pages/man2/syscalls.2:473
#: man-pages/man2/syscalls.2:474 man-pages/man2/syscalls.2:475
#: man-pages/man2/syscalls.2:476 man-pages/man2/syscalls.2:477
#: man-pages/man2/syscalls.2:480 man-pages/man2/syscalls.2:481
#: man-pages/man2/syscalls.2:484 man-pages/man2/syscalls.2:489
#: man-pages/man2/syscalls.2:580 man-pages/man2/syscalls.2:582
#: man-pages/man2/syscalls.2:583 man-pages/man2/syscalls.2:584
#: man-pages/man2/syscalls.2:616 man-pages/man2/syscalls.2:617
#: man-pages/man2/syscalls.2:620 man-pages/man2/syscalls.2:621
#: man-pages/man2/syscalls.2:622 man-pages/man2/syscalls.2:630
#: man-pages/man2/syscalls.2:631 man-pages/man2/syscalls.2:632
#: man-pages/man2/syscalls.2:635 man-pages/man2/syscalls.2:636
#: man-pages/man2/syscalls.2:637 man-pages/man2/syscalls.2:639
#: man-pages/man2/syscalls.2:643 man-pages/man2/syscalls.2:644
#: man-pages/man2/syscalls.2:673 man-pages/man2/syscalls.2:678
#: man-pages/man2/syscalls.2:694 man-pages/man2/syscalls.2:701
#: man-pages/man2/syscalls.2:702 man-pages/man2/syscalls.2:703
#: man-pages/man2/syscalls.2:704 man-pages/man2/syscalls.2:705
#: man-pages/man2/syscalls.2:715 man-pages/man2/syscalls.2:718
#: man-pages/man2/syscalls.2:822
#, no-wrap
msgid "2.0"
msgstr "2.0"

#. type: tbl table
#: man-pages/man2/syscalls.2:164
#, no-wrap
msgid "B<_sysctl>(2)"
msgstr "B<_sysctl>(2)"

#.  Implements BSD socket calls
#. type: tbl table
#: man-pages/man2/syscalls.2:165 man-pages/man2/syscalls.2:193
#: man-pages/man2/syscalls.2:240 man-pages/man2/syscalls.2:351
#: man-pages/man2/syscalls.2:366 man-pages/man2/syscalls.2:367
#: man-pages/man2/syscalls.2:414 man-pages/man2/syscalls.2:582
#: man-pages/man2/syscalls.2:583 man-pages/man2/syscalls.2:584
#: man-pages/man2/syscalls.2:639 man-pages/man2/syscalls.2:643
#: man-pages/man2/syscalls.2:644 man-pages/man2/syscalls.2:694
#: man-pages/man2/syscalls.2:705 man-pages/man2/syscalls.2:715
#: man-pages/man2/syscalls.2:718
#, no-wrap
msgid "See notes on B<socketcall>(2)"
msgstr "смотрите замечания по B<socketcall>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:166
#, no-wrap
msgid "2.6.28"
msgstr "2.6.28"

#. type: tbl table
#: man-pages/man2/syscalls.2:167 man-pages/man2/syscalls.2:168
#: man-pages/man2/syscalls.2:170 man-pages/man2/syscalls.2:171
#: man-pages/man2/syscalls.2:195 man-pages/man2/syscalls.2:204
#: man-pages/man2/syscalls.2:205 man-pages/man2/syscalls.2:212
#: man-pages/man2/syscalls.2:219 man-pages/man2/syscalls.2:220
#: man-pages/man2/syscalls.2:242 man-pages/man2/syscalls.2:243
#: man-pages/man2/syscalls.2:244 man-pages/man2/syscalls.2:252
#: man-pages/man2/syscalls.2:253 man-pages/man2/syscalls.2:267
#: man-pages/man2/syscalls.2:269 man-pages/man2/syscalls.2:280
#: man-pages/man2/syscalls.2:281 man-pages/man2/syscalls.2:283
#: man-pages/man2/syscalls.2:286 man-pages/man2/syscalls.2:293
#: man-pages/man2/syscalls.2:297 man-pages/man2/syscalls.2:300
#: man-pages/man2/syscalls.2:302 man-pages/man2/syscalls.2:303
#: man-pages/man2/syscalls.2:307 man-pages/man2/syscalls.2:336
#: man-pages/man2/syscalls.2:338 man-pages/man2/syscalls.2:340
#: man-pages/man2/syscalls.2:342 man-pages/man2/syscalls.2:350
#: man-pages/man2/syscalls.2:353 man-pages/man2/syscalls.2:354
#: man-pages/man2/syscalls.2:355 man-pages/man2/syscalls.2:356
#: man-pages/man2/syscalls.2:357 man-pages/man2/syscalls.2:363
#: man-pages/man2/syscalls.2:364 man-pages/man2/syscalls.2:369
#: man-pages/man2/syscalls.2:370 man-pages/man2/syscalls.2:377
#: man-pages/man2/syscalls.2:388 man-pages/man2/syscalls.2:389
#: man-pages/man2/syscalls.2:390 man-pages/man2/syscalls.2:393
#: man-pages/man2/syscalls.2:404 man-pages/man2/syscalls.2:405
#: man-pages/man2/syscalls.2:412 man-pages/man2/syscalls.2:419
#: man-pages/man2/syscalls.2:421 man-pages/man2/syscalls.2:452
#: man-pages/man2/syscalls.2:454 man-pages/man2/syscalls.2:459
#: man-pages/man2/syscalls.2:461 man-pages/man2/syscalls.2:462
#: man-pages/man2/syscalls.2:464 man-pages/man2/syscalls.2:482
#: man-pages/man2/syscalls.2:488 man-pages/man2/syscalls.2:497
#: man-pages/man2/syscalls.2:498 man-pages/man2/syscalls.2:499
#: man-pages/man2/syscalls.2:500 man-pages/man2/syscalls.2:506
#: man-pages/man2/syscalls.2:507 man-pages/man2/syscalls.2:512
#: man-pages/man2/syscalls.2:528 man-pages/man2/syscalls.2:558
#: man-pages/man2/syscalls.2:573 man-pages/man2/syscalls.2:574
#: man-pages/man2/syscalls.2:576 man-pages/man2/syscalls.2:578
#: man-pages/man2/syscalls.2:581 man-pages/man2/syscalls.2:588
#: man-pages/man2/syscalls.2:595 man-pages/man2/syscalls.2:634
#: man-pages/man2/syscalls.2:663 man-pages/man2/syscalls.2:668
#: man-pages/man2/syscalls.2:670 man-pages/man2/syscalls.2:674
#: man-pages/man2/syscalls.2:675 man-pages/man2/syscalls.2:677
#: man-pages/man2/syscalls.2:683 man-pages/man2/syscalls.2:684
#: man-pages/man2/syscalls.2:690 man-pages/man2/syscalls.2:692
#: man-pages/man2/syscalls.2:693 man-pages/man2/syscalls.2:695
#: man-pages/man2/syscalls.2:696 man-pages/man2/syscalls.2:698
#: man-pages/man2/syscalls.2:700 man-pages/man2/syscalls.2:706
#: man-pages/man2/syscalls.2:708 man-pages/man2/syscalls.2:711
#: man-pages/man2/syscalls.2:712 man-pages/man2/syscalls.2:713
#: man-pages/man2/syscalls.2:714 man-pages/man2/syscalls.2:716
#: man-pages/man2/syscalls.2:734 man-pages/man2/syscalls.2:735
#: man-pages/man2/syscalls.2:737 man-pages/man2/syscalls.2:740
#: man-pages/man2/syscalls.2:746 man-pages/man2/syscalls.2:747
#: man-pages/man2/syscalls.2:748 man-pages/man2/syscalls.2:750
#: man-pages/man2/syscalls.2:758 man-pages/man2/syscalls.2:764
#: man-pages/man2/syscalls.2:765 man-pages/man2/syscalls.2:770
#: man-pages/man2/syscalls.2:785 man-pages/man2/syscalls.2:787
#: man-pages/man2/syscalls.2:790 man-pages/man2/syscalls.2:791
#: man-pages/man2/syscalls.2:795 man-pages/man2/syscalls.2:796
#: man-pages/man2/syscalls.2:799 man-pages/man2/syscalls.2:800
#: man-pages/man2/syscalls.2:804 man-pages/man2/syscalls.2:811
#: man-pages/man2/syscalls.2:812 man-pages/man2/syscalls.2:818
#: man-pages/man2/syscalls.2:820 man-pages/man2/syscalls.2:821
#, no-wrap
msgid "1.0"
msgstr "1.0"

#. type: tbl table
#: man-pages/man2/syscalls.2:168
#, no-wrap
msgid "B<acct>(2)"
msgstr "B<acct>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:169
#, no-wrap
msgid "B<add_key>(2)"
msgstr "B<add_key>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:169 man-pages/man2/syscalls.2:403
#: man-pages/man2/syscalls.2:591 man-pages/man2/syscalls.2:819
#, no-wrap
msgid "2.6.10"
msgstr "2.6.10"

#. type: tbl table
#: man-pages/man2/syscalls.2:170
#, no-wrap
msgid "B<adjtimex>(2)"
msgstr "B<adjtimex>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:172
#, no-wrap
msgid "B<alloc_hugepages>(2)"
msgstr "B<alloc_hugepages>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:172 man-pages/man2/syscalls.2:294
#, no-wrap
msgid "2.5.36"
msgstr "2.5.36"

#. type: tbl table
#: man-pages/man2/syscalls.2:172 man-pages/man2/syscalls.2:294
#, no-wrap
msgid "Removed in 2.5.44"
msgstr "удалён из Linux 2.5.44"

#.  4adeefe161a74369e44cc8e663f240ece0470dc3
#. type: tbl table
#: man-pages/man2/syscalls.2:174
#, no-wrap
msgid "B<arc_gettls>(2)"
msgstr "B<arc_gettls>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:174 man-pages/man2/syscalls.2:175
#: man-pages/man2/syscalls.2:428 man-pages/man2/syscalls.2:433
#: man-pages/man2/syscalls.2:438 man-pages/man2/syscalls.2:443
#, no-wrap
msgid "3.9"
msgstr "3.9"

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: man-pages/man2/syscalls.2:174 man-pages/man2/syscalls.2:175
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "ARC only"
msgstr "только на ARC"

#. type: tbl table
#: man-pages/man2/syscalls.2:175
#, no-wrap
msgid "B<arc_settls>(2)"
msgstr "B<arc_settls>(2)"

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "B<arc_usr_cmpxchg>(2)"
msgstr "B<arc_usr_cmpxchg>(2)"

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "4.9"
msgstr "4.9"

#.  x86: 79170fda313ed5be2394f87aa2a00d597f8ed4a1
#. type: tbl table
#: man-pages/man2/syscalls.2:179
#, no-wrap
msgid "B<arch_prctl>(2)"
msgstr "B<arch_prctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:179 man-pages/man2/syscalls.2:214
#: man-pages/man2/syscalls.2:215 man-pages/man2/syscalls.2:216
#: man-pages/man2/syscalls.2:217 man-pages/man2/syscalls.2:255
#: man-pages/man2/syscalls.2:257 man-pages/man2/syscalls.2:259
#: man-pages/man2/syscalls.2:270 man-pages/man2/syscalls.2:272
#: man-pages/man2/syscalls.2:274 man-pages/man2/syscalls.2:301
#: man-pages/man2/syscalls.2:305 man-pages/man2/syscalls.2:310
#: man-pages/man2/syscalls.2:382 man-pages/man2/syscalls.2:383
#: man-pages/man2/syscalls.2:384 man-pages/man2/syscalls.2:386
#: man-pages/man2/syscalls.2:387 man-pages/man2/syscalls.2:417
#: man-pages/man2/syscalls.2:586 man-pages/man2/syscalls.2:592
#: man-pages/man2/syscalls.2:611 man-pages/man2/syscalls.2:618
#: man-pages/man2/syscalls.2:623 man-pages/man2/syscalls.2:628
#: man-pages/man2/syscalls.2:647 man-pages/man2/syscalls.2:648
#: man-pages/man2/syscalls.2:738 man-pages/man2/syscalls.2:769
#: man-pages/man2/syscalls.2:771 man-pages/man2/syscalls.2:772
#: man-pages/man2/syscalls.2:773 man-pages/man2/syscalls.2:774
#: man-pages/man2/syscalls.2:775
#, no-wrap
msgid "2.6"
msgstr "2.6"

#.  x86: 79170fda313ed5be2394f87aa2a00d597f8ed4a1
#. type: tbl table
#: man-pages/man2/syscalls.2:179
#, no-wrap
msgid "x86_64, x86 since 4.12"
msgstr "x86_64, x86 начиная с 4.12"

#.  9674cdc74d63f346870943ef966a034f8c71ee57
#. type: tbl table
#: man-pages/man2/syscalls.2:181
#, no-wrap
msgid "B<atomic_barrier>(2)"
msgstr "B<atomic_barrier>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:181 man-pages/man2/syscalls.2:182
#, no-wrap
msgid "2.6.34"
msgstr "2.6.34"

#. type: tbl table
#: man-pages/man2/syscalls.2:181 man-pages/man2/syscalls.2:182
#, no-wrap
msgid "m68k only"
msgstr "только на m68k"

#. type: tbl table
#: man-pages/man2/syscalls.2:182
#, no-wrap
msgid "B<atomic_cmpxchg_32>(2)"
msgstr "B<atomic_cmpxchg_32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:183
#, no-wrap
msgid "B<bdflush>(2)"
msgstr "B<bdflush>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:185
#, no-wrap
msgid "Deprecated (does nothing)\n"
msgstr "устарел (ничего не делает)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:187
#, no-wrap
msgid "since 2.6"
msgstr "начиная с 2.6"

#. type: tbl table
#: man-pages/man2/syscalls.2:188
#, no-wrap
msgid "B<bfin_spinlock>(2)"
msgstr "B<bfin_spinlock>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:188 man-pages/man2/syscalls.2:247
#: man-pages/man2/syscalls.2:260 man-pages/man2/syscalls.2:709
#: man-pages/man2/syscalls.2:724 man-pages/man2/syscalls.2:729
#: man-pages/man2/syscalls.2:752 man-pages/man2/syscalls.2:805
#, no-wrap
msgid "2.6.22"
msgstr "2.6.22"

#. type: tbl table
#: man-pages/man2/syscalls.2:190 man-pages/man2/syscalls.2:249
#, no-wrap
msgid "Blackfin only (port removed\n"
msgstr "только на Blackfin (перенос удалён\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:192 man-pages/man2/syscalls.2:239
#: man-pages/man2/syscalls.2:251 man-pages/man2/syscalls.2:432
#: man-pages/man2/syscalls.2:437 man-pages/man2/syscalls.2:442
#: man-pages/man2/syscalls.2:447 man-pages/man2/syscalls.2:545
#: man-pages/man2/syscalls.2:728 man-pages/man2/syscalls.2:733
#, no-wrap
msgid "in Linux 4.17)"
msgstr "в Linux 4.17)"

#. type: tbl table
#: man-pages/man2/syscalls.2:194
#, no-wrap
msgid "B<bpf>(2)"
msgstr "B<bpf>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:194
#, no-wrap
msgid "3.18"
msgstr "3.18"

#. type: tbl table
#: man-pages/man2/syscalls.2:195
#, no-wrap
msgid "B<brk>(2)"
msgstr "B<brk>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:196
#, no-wrap
msgid "B<breakpoint>(2)"
msgstr "B<breakpoint>(2)"

#.  FIXME . document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: man-pages/man2/syscalls.2:196 man-pages/man2/syscalls.2:202
#: man-pages/man2/syscalls.2:203 man-pages/man2/syscalls.2:206
#: man-pages/man2/syscalls.2:318 man-pages/man2/syscalls.2:322
#: man-pages/man2/syscalls.2:359 man-pages/man2/syscalls.2:361
#: man-pages/man2/syscalls.2:425 man-pages/man2/syscalls.2:487
#: man-pages/man2/syscalls.2:525 man-pages/man2/syscalls.2:536
#: man-pages/man2/syscalls.2:572 man-pages/man2/syscalls.2:597
#: man-pages/man2/syscalls.2:598 man-pages/man2/syscalls.2:599
#: man-pages/man2/syscalls.2:600 man-pages/man2/syscalls.2:601
#: man-pages/man2/syscalls.2:602 man-pages/man2/syscalls.2:603
#: man-pages/man2/syscalls.2:640 man-pages/man2/syscalls.2:686
#: man-pages/man2/syscalls.2:688 man-pages/man2/syscalls.2:707
#: man-pages/man2/syscalls.2:793 man-pages/man2/syscalls.2:806
#: man-pages/man2/syscalls.2:807 man-pages/man2/syscalls.2:810
#, no-wrap
msgid "2.2"
msgstr "2.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:198
#, no-wrap
msgid "ARM OABI only, defined with\n"
msgstr "только в ARM OABI, определён с\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:200 man-pages/man2/syscalls.2:316
#, no-wrap
msgid "B<__ARM_NR> prefix"
msgstr "префиксом B<__ARM_NR>"

#. type: tbl table
#: man-pages/man2/syscalls.2:201
#, no-wrap
msgid "B<cacheflush>(2)"
msgstr "B<cacheflush>(2)"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:201 man-pages/man2/syscalls.2:352
#: man-pages/man2/syscalls.2:513 man-pages/man2/syscalls.2:515
#: man-pages/man2/syscalls.2:517
#, no-wrap
msgid "Not on x86"
msgstr "не для x86"

#. type: tbl table
#: man-pages/man2/syscalls.2:202
#, no-wrap
msgid "B<capget>(2)"
msgstr "B<capget>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:203
#, no-wrap
msgid "B<capset>(2)"
msgstr "B<capset>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:208 man-pages/man2/syscalls.2:407
#, no-wrap
msgid "See B<chown>(2) for\n"
msgstr "смотрите в B<chown>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:210 man-pages/man2/syscalls.2:409
#, no-wrap
msgid "version details"
msgstr "подробности о версии"

#. type: tbl table
#: man-pages/man2/syscalls.2:211
#, no-wrap
msgid "B<chown32>(2)"
msgstr "B<chown32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:211 man-pages/man2/syscalls.2:218
#: man-pages/man2/syscalls.2:284 man-pages/man2/syscalls.2:287
#: man-pages/man2/syscalls.2:298 man-pages/man2/syscalls.2:304
#: man-pages/man2/syscalls.2:320 man-pages/man2/syscalls.2:337
#: man-pages/man2/syscalls.2:339 man-pages/man2/syscalls.2:341
#: man-pages/man2/syscalls.2:343 man-pages/man2/syscalls.2:360
#: man-pages/man2/syscalls.2:362 man-pages/man2/syscalls.2:371
#: man-pages/man2/syscalls.2:410 man-pages/man2/syscalls.2:422
#: man-pages/man2/syscalls.2:423 man-pages/man2/syscalls.2:451
#: man-pages/man2/syscalls.2:460 man-pages/man2/syscalls.2:490
#: man-pages/man2/syscalls.2:527 man-pages/man2/syscalls.2:530
#: man-pages/man2/syscalls.2:665 man-pages/man2/syscalls.2:667
#: man-pages/man2/syscalls.2:669 man-pages/man2/syscalls.2:671
#: man-pages/man2/syscalls.2:685 man-pages/man2/syscalls.2:687
#: man-pages/man2/syscalls.2:689 man-pages/man2/syscalls.2:691
#: man-pages/man2/syscalls.2:697 man-pages/man2/syscalls.2:736
#: man-pages/man2/syscalls.2:788 man-pages/man2/syscalls.2:789
#, no-wrap
msgid "2.4"
msgstr "2.4"

#. type: tbl table
#: man-pages/man2/syscalls.2:212
#, no-wrap
msgid "B<chroot>(2)"
msgstr "B<chroot>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:213
#, no-wrap
msgid "B<clock_adjtime>(2)"
msgstr "B<clock_adjtime>(2)"

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: man-pages/man2/syscalls.2:213 man-pages/man2/syscalls.2:483
#: man-pages/man2/syscalls.2:508 man-pages/man2/syscalls.2:756
#, no-wrap
msgid "2.6.39"
msgstr "2.6.39"

#. type: tbl table
#: man-pages/man2/syscalls.2:214
#, no-wrap
msgid "B<clock_getres>(2)"
msgstr "B<clock_getres>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:216
#, no-wrap
msgid "B<clock_nanosleep>(2)"
msgstr "B<clock_nanosleep>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:217
#, no-wrap
msgid "B<clock_settime>(2)"
msgstr "B<clock_settime>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:218
#, no-wrap
msgid "B<clone2>(2)"
msgstr "B<clone2>(2)"

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: man-pages/man2/syscalls.2:218 man-pages/man2/syscalls.2:527
#, no-wrap
msgid "IA-64 only"
msgstr "только на IA-64"

#. type: tbl table
#: man-pages/man2/syscalls.2:219
#, no-wrap
msgid "B<clone>(2)"
msgstr "B<clone>(2)"

#.  .\" dcef1f634657dabe7905af3ccda12cf7f0b6fcc1
#.  .\" cc20d42986d5807cbe4f5c7c8e3dab2e59ea0db3
#.  .\" db695c0509d6ec9046ee5e4c520a19fa17d9fce2
#.  \fBcmpxchg\fP(2)	2.6.12	T{
#.  ARM, syscall constant never was
#.  .br
#.  exposed to userspace, in-kernel
#.  .br
#.  definition had \fB__ARM_NR\fP prefix,
#.  .br
#.  removed in 4.4
#.  T}
#.  867e359b97c970a60626d5d76bbe2a8fadbf38fb
#.  bb9d812643d8a121df7d614a2b9c60193a92deb0
#. type: tbl table
#: man-pages/man2/syscalls.2:235
#, no-wrap
msgid "B<cmpxchg_badaddr>(2)"
msgstr "B<cmpxchg_badaddr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:235 man-pages/man2/syscalls.2:553
#, no-wrap
msgid "2.6.36"
msgstr "2.6.36"

#. type: tbl table
#: man-pages/man2/syscalls.2:237
#, no-wrap
msgid "Tile only (port removed\n"
msgstr "только на Tile (перенос удалён\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:241
#, no-wrap
msgid "B<copy_file_range>(2)"
msgstr "B<copy_file_range>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:241
#, no-wrap
msgid "4.5"
msgstr "4.5"

#. type: tbl table
#: man-pages/man2/syscalls.2:243
#, no-wrap
msgid "B<create_module>(2)"
msgstr "B<create_module>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:243 man-pages/man2/syscalls.2:307
#: man-pages/man2/syscalls.2:572
#, no-wrap
msgid "Removed in 2.6"
msgstr "удалён из Linux 2.6"

#. type: tbl table
#: man-pages/man2/syscalls.2:244
#, no-wrap
msgid "B<delete_module>(2)"
msgstr "B<delete_module>(2)"

#.  1394f03221790a988afc3e4b3cb79f2e477246a9
#.  4ba66a9760722ccbb691b8f7116cad2f791cca7b
#. type: tbl table
#: man-pages/man2/syscalls.2:247
#, no-wrap
msgid "B<dma_memcpy>(2)"
msgstr "B<dma_memcpy>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:254
#, no-wrap
msgid "B<dup3>(2)"
msgstr "B<dup3>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:254 man-pages/man2/syscalls.2:256
#: man-pages/man2/syscalls.2:261 man-pages/man2/syscalls.2:380
#: man-pages/man2/syscalls.2:529 man-pages/man2/syscalls.2:710
#, no-wrap
msgid "2.6.27"
msgstr "2.6.27"

#. type: tbl table
#: man-pages/man2/syscalls.2:255
#, no-wrap
msgid "B<epoll_create>(2)"
msgstr "B<epoll_create>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:256
#, no-wrap
msgid "B<epoll_create1>(2)"
msgstr "B<epoll_create1>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:257
#, no-wrap
msgid "B<epoll_ctl>(2)"
msgstr "B<epoll_ctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:258
#, no-wrap
msgid "B<epoll_pwait>(2)"
msgstr "B<epoll_pwait>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:258 man-pages/man2/syscalls.2:317
#, no-wrap
msgid "2.6.19"
msgstr "2.6.19"

#. type: tbl table
#: man-pages/man2/syscalls.2:259
#, no-wrap
msgid "B<epoll_wait>(2)"
msgstr "B<epoll_wait>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:260
#, no-wrap
msgid "B<eventfd>(2)"
msgstr "B<eventfd>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:261
#, no-wrap
msgid "B<eventfd2>(2)"
msgstr "B<eventfd2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:262
#, no-wrap
msgid "B<execv>(2)"
msgstr "B<execv>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:264
#, no-wrap
msgid "SPARC/SPARC64 only, for\n"
msgstr "только на SPARC/SPARC64, для\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:266
#, no-wrap
msgid "compatibility with SunOS"
msgstr "совместимости с SunOS"

#. type: tbl table
#: man-pages/man2/syscalls.2:268
#, no-wrap
msgid "B<execveat>(2)"
msgstr "B<execveat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:268 man-pages/man2/syscalls.2:607
#: man-pages/man2/syscalls.2:608
#, no-wrap
msgid "3.19"
msgstr "3.19"

#. type: tbl table
#: man-pages/man2/syscalls.2:269
#, no-wrap
msgid "B<exit>(2)"
msgstr "B<exit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:270
#, no-wrap
msgid "B<exit_group>(2)"
msgstr "B<exit_group>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:271 man-pages/man2/syscalls.2:282
#: man-pages/man2/syscalls.2:285 man-pages/man2/syscalls.2:299
#: man-pages/man2/syscalls.2:306 man-pages/man2/syscalls.2:413
#: man-pages/man2/syscalls.2:450 man-pages/man2/syscalls.2:453
#: man-pages/man2/syscalls.2:455 man-pages/man2/syscalls.2:486
#: man-pages/man2/syscalls.2:509 man-pages/man2/syscalls.2:535
#: man-pages/man2/syscalls.2:556 man-pages/man2/syscalls.2:579
#: man-pages/man2/syscalls.2:589 man-pages/man2/syscalls.2:722
#: man-pages/man2/syscalls.2:723 man-pages/man2/syscalls.2:749
#: man-pages/man2/syscalls.2:797 man-pages/man2/syscalls.2:798
#, no-wrap
msgid "2.6.16"
msgstr "2.6.16"

#. type: tbl table
#: man-pages/man2/syscalls.2:272
#, no-wrap
msgid "B<fadvise64>(2)"
msgstr "B<fadvise64>(2)"

#.  Implements \fBposix_fadvise\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:274
#, no-wrap
msgid "B<fadvise64_64>(2)"
msgstr "B<fadvise64_64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:275
#, no-wrap
msgid "B<fallocate>(2)"
msgstr "B<fallocate>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:275
#, no-wrap
msgid "2.6.23"
msgstr "2.6.23"

#. type: tbl table
#: man-pages/man2/syscalls.2:276
#, no-wrap
msgid "B<fanotify_init>(2)"
msgstr "B<fanotify_init>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:276 man-pages/man2/syscalls.2:277
#, no-wrap
msgid "2.6.37"
msgstr "2.6.37"

#. type: tbl table
#: man-pages/man2/syscalls.2:277
#, no-wrap
msgid "B<fanotify_mark>(2)"
msgstr "B<fanotify_mark>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:284
#, no-wrap
msgid "B<fchown32>(2)"
msgstr "B<fchown32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:287
#, no-wrap
msgid "B<fcntl64>(2)"
msgstr "B<fcntl64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:289
#, no-wrap
msgid "B<fgetxattr>(2)"
msgstr "B<fgetxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:289 man-pages/man2/syscalls.2:291
#: man-pages/man2/syscalls.2:295 man-pages/man2/syscalls.2:296
#: man-pages/man2/syscalls.2:373 man-pages/man2/syscalls.2:411
#: man-pages/man2/syscalls.2:415 man-pages/man2/syscalls.2:416
#: man-pages/man2/syscalls.2:418 man-pages/man2/syscalls.2:420
#: man-pages/man2/syscalls.2:587 man-pages/man2/syscalls.2:699
#, no-wrap
msgid "2.6; 2.4.18"
msgstr "2.6; 2.4.18"

#. type: tbl table
#: man-pages/man2/syscalls.2:290
#, no-wrap
msgid "B<finit_module>(2)"
msgstr "B<finit_module>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:290
#, no-wrap
msgid "3.8"
msgstr "3.8"

#. type: tbl table
#: man-pages/man2/syscalls.2:291
#, no-wrap
msgid "B<flistxattr>(2)"
msgstr "B<flistxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:292
#, no-wrap
msgid "B<flock>(2)"
msgstr "B<flock>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:294
#, no-wrap
msgid "B<free_hugepages>(2)"
msgstr "B<free_hugepages>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:295
#, no-wrap
msgid "B<fremovexattr>(2)"
msgstr "B<fremovexattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:296
#, no-wrap
msgid "B<fsetxattr>(2)"
msgstr "B<fsetxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:298
#, no-wrap
msgid "B<fstat64>(2)"
msgstr "B<fstat64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:299
#, no-wrap
msgid "B<fstatat64>(2)"
msgstr "B<fstatat64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:300
#, no-wrap
msgid "B<fstatfs>(2)"
msgstr "B<fstatfs>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:301
#, no-wrap
msgid "B<fstatfs64>(2)"
msgstr "B<fstatfs64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:304
#, no-wrap
msgid "B<ftruncate64>(2)"
msgstr "B<ftruncate64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:305
#, no-wrap
msgid "B<futex>(2)"
msgstr "B<futex>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:306
#, no-wrap
msgid "B<futimesat>(2)"
msgstr "B<futimesat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:307
#, no-wrap
msgid "B<get_kernel_syms>(2)"
msgstr "B<get_kernel_syms>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:308
#, no-wrap
msgid "B<get_mempolicy>(2)"
msgstr "B<get_mempolicy>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:308 man-pages/man2/syscalls.2:424
#: man-pages/man2/syscalls.2:465 man-pages/man2/syscalls.2:467
#: man-pages/man2/syscalls.2:468 man-pages/man2/syscalls.2:469
#: man-pages/man2/syscalls.2:470 man-pages/man2/syscalls.2:471
#: man-pages/man2/syscalls.2:645
#, no-wrap
msgid "2.6.6"
msgstr "2.6.6"

#. type: tbl table
#: man-pages/man2/syscalls.2:309
#, no-wrap
msgid "B<get_robust_list>(2)"
msgstr "B<get_robust_list>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:309 man-pages/man2/syscalls.2:646
#: man-pages/man2/syscalls.2:721 man-pages/man2/syscalls.2:751
#: man-pages/man2/syscalls.2:768 man-pages/man2/syscalls.2:817
#, no-wrap
msgid "2.6.17"
msgstr "2.6.17"

#. type: tbl table
#: man-pages/man2/syscalls.2:310
#, no-wrap
msgid "B<get_thread_area>(2)"
msgstr "B<get_thread_area>(2)"

#.  8fcd6c45f5a65621ec809b7866a3623e9a01d4ed
#. type: tbl table
#: man-pages/man2/syscalls.2:312
#, no-wrap
msgid "B<get_tls>(2)"
msgstr "B<get_tls>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:312 man-pages/man2/syscalls.2:594
#: man-pages/man2/syscalls.2:609
#, no-wrap
msgid "4.15"
msgstr "4.15"

#. type: tbl table
#: man-pages/man2/syscalls.2:314
#, no-wrap
msgid "ARM OABI only, has\n"
msgstr "только в ARM OABI, есть\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:317
#, no-wrap
msgid "B<getcpu>(2)"
msgstr "B<getcpu>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:318
#, no-wrap
msgid "B<getcwd>(2)"
msgstr "B<getcwd>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:319
#, no-wrap
msgid "B<getdents>(2)"
msgstr "B<getdents>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:320
#, no-wrap
msgid "B<getdents64>(2)"
msgstr "B<getdents64>(2)"

#.  parisc: 863722e856e64dae0e252b6bb546737c6c5626ce
#. type: tbl table
#: man-pages/man2/syscalls.2:322
#, no-wrap
msgid "B<getdomainname>(2)"
msgstr "B<getdomainname>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:324
#, no-wrap
msgid "SPARC, SPARC64; available\n"
msgstr "SPARC, SPARC64; доступен\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:326
#, no-wrap
msgid "as B<osf_getdomainname>(2)\n"
msgstr "как B<osf_getdomainname>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:328
#, no-wrap
msgid "on Alpha since Linux 2.0"
msgstr "на Alpha начиная с Linux 2.0"

#.  ec98c6b9b47df6df1c1fa6cf3d427414f8c2cf16
#. type: tbl table
#: man-pages/man2/syscalls.2:330
#, no-wrap
msgid "B<getdtablesize>(2)"
msgstr "B<getdtablesize>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:332
#, no-wrap
msgid "SPARC (removed in 2.6.26),\n"
msgstr "SPARC (удалён в 2.6.26),\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:335
#, no-wrap
msgid ""
"available since Linux 2.0 on Alpha as\n"
"B<osf_getdtablesize>(2)"
msgstr ""
"доступен начиная с Linux 2.0 на Alpha как\n"
"B<osf_getdtablesize>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:337
#, no-wrap
msgid "B<getegid32>(2)"
msgstr "B<getegid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:339
#, no-wrap
msgid "B<geteuid32>(2)"
msgstr "B<geteuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:341
#, no-wrap
msgid "B<getgid32>(2)"
msgstr "B<getgid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:343
#, no-wrap
msgid "B<getgroups32>(2)"
msgstr "B<getgroups32>(2)"

#.  SPARC removal: ec98c6b9b47df6df1c1fa6cf3d427414f8c2cf16
#. type: tbl table
#: man-pages/man2/syscalls.2:345
#, no-wrap
msgid "B<gethostname>(2)"
msgstr "B<gethostname>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:347
#, no-wrap
msgid "Alpha, was available on\n"
msgstr "Alpha, был доступен на\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:349
#, no-wrap
msgid "SPARC up to Linux 2.6.26"
msgstr "SPARC до Linux 2.6.26"

#. type: tbl table
#: man-pages/man2/syscalls.2:350
#, no-wrap
msgid "B<getitimer>(2)"
msgstr "B<getitimer>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:352
#, no-wrap
msgid "B<getpagesize>(2)"
msgstr "B<getpagesize>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:353
#, no-wrap
msgid "B<getpgid>(2)"
msgstr "B<getpgid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:358
#, no-wrap
msgid "B<getrandom>(2)"
msgstr "B<getrandom>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:358 man-pages/man2/syscalls.2:399
#: man-pages/man2/syscalls.2:448 man-pages/man2/syscalls.2:449
#: man-pages/man2/syscalls.2:633
#, no-wrap
msgid "3.17"
msgstr "3.17"

#. type: tbl table
#: man-pages/man2/syscalls.2:359
#, no-wrap
msgid "B<getresgid>(2)"
msgstr "B<getresgid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:360
#, no-wrap
msgid "B<getresgid32>(2)"
msgstr "B<getresgid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:361
#, no-wrap
msgid "B<getresuid>(2)"
msgstr "B<getresuid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:362
#, no-wrap
msgid "B<getresuid32>(2)"
msgstr "B<getresuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:363
#, no-wrap
msgid "B<getrlimit>(2)"
msgstr "B<getrlimit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:364
#, no-wrap
msgid "B<getrusage>(2)"
msgstr "B<getrusage>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:365
#, no-wrap
msgid "B<getsid>(2)"
msgstr "B<getsid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:368
#, no-wrap
msgid "B<gettid>(2)"
msgstr "B<gettid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:368
#, no-wrap
msgid "2.4.11"
msgstr "2.4.11"

#. type: tbl table
#: man-pages/man2/syscalls.2:369
#, no-wrap
msgid "B<gettimeofday>(2)"
msgstr "B<gettimeofday>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:371
#, no-wrap
msgid "B<getuid32>(2)"
msgstr "B<getuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:372
#, no-wrap
msgid "B<getunwind>(2)"
msgstr "B<getunwind>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:372
#, no-wrap
msgid "2.4.8"
msgstr "2.4.8"

#. type: tbl table
#: man-pages/man2/syscalls.2:372
#, no-wrap
msgid "IA-64 only; deprecated"
msgstr "только IA-64; устарел"

#. type: tbl table
#: man-pages/man2/syscalls.2:373
#, no-wrap
msgid "B<getxattr>(2)"
msgstr "B<getxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:374
#, no-wrap
msgid "B<getxgid>(2)"
msgstr "B<getxgid>(2)"

#.  arch/alpha/include/asm/core_lca.h
#. type: tbl table
#: man-pages/man2/syscalls.2:374 man-pages/man2/syscalls.2:375
#: man-pages/man2/syscalls.2:376 man-pages/man2/syscalls.2:489
#: man-pages/man2/syscalls.2:673
#, no-wrap
msgid "Alpha only; see NOTES"
msgstr "только на Alpha; смотрите ЗАМЕЧАНИЯ"

#. type: tbl table
#: man-pages/man2/syscalls.2:375
#, no-wrap
msgid "B<getxpid>(2)"
msgstr "B<getxpid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:376
#, no-wrap
msgid "B<getxuid>(2)"
msgstr "B<getxuid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:377
#, no-wrap
msgid "B<init_module>(2)"
msgstr "B<init_module>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:378
#, no-wrap
msgid "B<inotify_add_watch>(2)"
msgstr "B<inotify_add_watch>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:378 man-pages/man2/syscalls.2:379
#: man-pages/man2/syscalls.2:381 man-pages/man2/syscalls.2:391
#: man-pages/man2/syscalls.2:392 man-pages/man2/syscalls.2:400
#: man-pages/man2/syscalls.2:720 man-pages/man2/syscalls.2:824
#, no-wrap
msgid "2.6.13"
msgstr "2.6.13"

#. type: tbl table
#: man-pages/man2/syscalls.2:379
#, no-wrap
msgid "B<inotify_init>(2)"
msgstr "B<inotify_init>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:380
#, no-wrap
msgid "B<inotify_init1>(2)"
msgstr "B<inotify_init1>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:381
#, no-wrap
msgid "B<inotify_rm_watch>(2)"
msgstr "B<inotify_rm_watch>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:382
#, no-wrap
msgid "B<io_cancel>(2)"
msgstr "B<io_cancel>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:383
#, no-wrap
msgid "B<io_destroy>(2)"
msgstr "B<io_destroy>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:384
#, no-wrap
msgid "B<io_getevents>(2)"
msgstr "B<io_getevents>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:385
#, no-wrap
msgid "B<io_pgetevents>(2)"
msgstr "B<io_pgetevents>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:385 man-pages/man2/syscalls.2:596
#, no-wrap
msgid "4.18"
msgstr "4.18"

#. type: tbl table
#: man-pages/man2/syscalls.2:386
#, no-wrap
msgid "B<io_setup>(2)"
msgstr "B<io_setup>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:387
#, no-wrap
msgid "B<io_submit>(2)"
msgstr "B<io_submit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:388
#, no-wrap
msgid "B<ioctl>(2)"
msgstr "B<ioctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:389
#, no-wrap
msgid "B<ioperm>(2)"
msgstr "B<ioperm>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:390
#, no-wrap
msgid "B<iopl>(2)"
msgstr "B<iopl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:391
#, no-wrap
msgid "B<ioprio_get>(2)"
msgstr "B<ioprio_get>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:392
#, no-wrap
msgid "B<ioprio_set>(2)"
msgstr "B<ioprio_set>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:393
#, no-wrap
msgid "B<ipc>(2)"
msgstr "B<ipc>(2)"

#.  Implements System V IPC calls
#. type: tbl table
#: man-pages/man2/syscalls.2:395
#, no-wrap
msgid "B<kcmp>(2)"
msgstr "B<kcmp>(2)"

#.  Implements System V IPC calls
#. type: tbl table
#: man-pages/man2/syscalls.2:395
#, no-wrap
msgid "3.5"
msgstr "3.5"

#. type: tbl table
#: man-pages/man2/syscalls.2:396
#, no-wrap
msgid "B<kern_features>(2)"
msgstr "B<kern_features>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:396 man-pages/man2/syscalls.2:606
#, no-wrap
msgid "3.7"
msgstr "3.7"

#. type: tbl table
#: man-pages/man2/syscalls.2:396 man-pages/man2/syscalls.2:425
#: man-pages/man2/syscalls.2:807
#, no-wrap
msgid "SPARC64 only"
msgstr "только на SPARC64"

#.  FIXME . document kern_features():
#.  commit 517ffce4e1a03aea979fe3a18a3dd1761a24fafb
#. type: tbl table
#: man-pages/man2/syscalls.2:399
#, no-wrap
msgid "B<kexec_file_load>(2)"
msgstr "B<kexec_file_load>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:400
#, no-wrap
msgid "B<kexec_load>(2)"
msgstr "B<kexec_load>(2)"

#.  The entry in the syscall table was reserved starting in 2.6.7
#.  Was named sys_kexec_load() from 2.6.7 to 2.6.16
#. type: tbl table
#: man-pages/man2/syscalls.2:403
#, no-wrap
msgid "B<keyctl>(2)"
msgstr "B<keyctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:405
#, no-wrap
msgid "B<lchown>(2)"
msgstr "B<lchown>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:410
#, no-wrap
msgid "B<lchown32>(2)"
msgstr "B<lchown32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:411
#, no-wrap
msgid "B<lgetxattr>(2)"
msgstr "B<lgetxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:415
#, no-wrap
msgid "B<listxattr>(2)"
msgstr "B<listxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:416
#, no-wrap
msgid "B<llistxattr>(2)"
msgstr "B<llistxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:417
#, no-wrap
msgid "B<lookup_dcookie>(2)"
msgstr "B<lookup_dcookie>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:418
#, no-wrap
msgid "B<lremovexattr>(2)"
msgstr "B<lremovexattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:420
#, no-wrap
msgid "B<lsetxattr>(2)"
msgstr "B<lsetxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:422
#, no-wrap
msgid "B<lstat64>(2)"
msgstr "B<lstat64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:423
#, no-wrap
msgid "B<madvise>(2)"
msgstr "B<madvise>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:424
#, no-wrap
msgid "B<mbind>(2)"
msgstr "B<mbind>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:425
#, no-wrap
msgid "B<memory_ordering>(2)"
msgstr "B<memory_ordering>(2)"

#.  26025bbfbba33a9425be1b89eccb4664ea4c17b6
#.  bb6fb6dfcc17cddac11ac295861f7608194447a7
#. type: tbl table
#: man-pages/man2/syscalls.2:428
#, no-wrap
msgid "B<metag_get_tls>(2)"
msgstr "B<metag_get_tls>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:430 man-pages/man2/syscalls.2:435
#: man-pages/man2/syscalls.2:440 man-pages/man2/syscalls.2:445
#, no-wrap
msgid "Metag only (port removed\n"
msgstr "только на Metag (перенос удалён\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:433
#, no-wrap
msgid "B<metag_set_fpu_flags>(2)"
msgstr "B<metag_set_fpu_flags>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:438
#, no-wrap
msgid "B<metag_set_tls>(2)"
msgstr "B<metag_set_tls>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:443
#, no-wrap
msgid "B<metag_setglobalbit>(2)"
msgstr "B<metag_setglobalbit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:448
#, no-wrap
msgid "B<membarrier>(2)"
msgstr "B<membarrier>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:449
#, no-wrap
msgid "B<memfd_create>(2)"
msgstr "B<memfd_create>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:450
#, no-wrap
msgid "B<migrate_pages>(2)"
msgstr "B<migrate_pages>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:451
#, no-wrap
msgid "B<mincore>(2)"
msgstr "B<mincore>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:456
#, no-wrap
msgid "B<mlock>(2)"
msgstr "B<mlock>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:457
#, no-wrap
msgid "B<mlock2>(2)"
msgstr "B<mlock2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:457
#, no-wrap
msgid "4.4"
msgstr "4.4"

#. type: tbl table
#: man-pages/man2/syscalls.2:458
#, no-wrap
msgid "B<mlockall>(2)"
msgstr "B<mlockall>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:460
#, no-wrap
msgid "B<mmap2>(2)"
msgstr "B<mmap2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:461
#, no-wrap
msgid "B<modify_ldt>(2)"
msgstr "B<modify_ldt>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:462
#, no-wrap
msgid "B<mount>(2)"
msgstr "B<mount>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:463
#, no-wrap
msgid "B<move_pages>(2)"
msgstr "B<move_pages>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:463
#, no-wrap
msgid "2.6.18"
msgstr "2.6.18"

#. type: tbl table
#: man-pages/man2/syscalls.2:464
#, no-wrap
msgid "B<mprotect>(2)"
msgstr "B<mprotect>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:465
#, no-wrap
msgid "B<mq_getsetattr>(2)"
msgstr "B<mq_getsetattr>(2)"

#.  Implements \fBmq_getattr\fP(3) and \fBmq_setattr\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:467
#, no-wrap
msgid "B<mq_notify>(2)"
msgstr "B<mq_notify>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:468
#, no-wrap
msgid "B<mq_open>(2)"
msgstr "B<mq_open>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:469
#, no-wrap
msgid "B<mq_timedreceive>(2)"
msgstr "B<mq_timedreceive>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:470
#, no-wrap
msgid "B<mq_timedsend>(2)"
msgstr "B<mq_timedsend>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:471
#, no-wrap
msgid "B<mq_unlink>(2)"
msgstr "B<mq_unlink>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:472
#, no-wrap
msgid "B<mremap>(2)"
msgstr "B<mremap>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:473
#, no-wrap
msgid "B<msgctl>(2)"
msgstr "B<msgctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:473 man-pages/man2/syscalls.2:474
#: man-pages/man2/syscalls.2:475 man-pages/man2/syscalls.2:476
#: man-pages/man2/syscalls.2:635 man-pages/man2/syscalls.2:636
#: man-pages/man2/syscalls.2:637 man-pages/man2/syscalls.2:701
#: man-pages/man2/syscalls.2:702 man-pages/man2/syscalls.2:703
#: man-pages/man2/syscalls.2:704
#, no-wrap
msgid "See notes on B<ipc>(2)"
msgstr "смотрите замечания по B<ipc>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:474
#, no-wrap
msgid "B<msgget>(2)"
msgstr "B<msgget>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:475
#, no-wrap
msgid "B<msgrcv>(2)"
msgstr "B<msgrcv>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:476
#, no-wrap
msgid "B<msgsnd>(2)"
msgstr "B<msgsnd>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:477
#, no-wrap
msgid "B<msync>(2)"
msgstr "B<msync>(2)"

#.  \fBmultiplexer\fP(2)	??	__NR_multiplexer reserved on
#. 		PowerPC, but unimplemented?
#. type: tbl table
#: man-pages/man2/syscalls.2:480
#, no-wrap
msgid "B<munlock>(2)"
msgstr "B<munlock>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:481
#, no-wrap
msgid "B<munlockall>(2)"
msgstr "B<munlockall>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:483
#, no-wrap
msgid "B<name_to_handle_at>(2)"
msgstr "B<name_to_handle_at>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:484
#, no-wrap
msgid "B<nanosleep>(2)"
msgstr "B<nanosleep>(2)"

#.  5590ff0d5528b60153c0b4e7b771472b5a95e297
#. type: tbl table
#: man-pages/man2/syscalls.2:486
#, no-wrap
msgid "B<newfstatat>(2)"
msgstr "B<newfstatat>(2)"

#.  5590ff0d5528b60153c0b4e7b771472b5a95e297
#. type: tbl table
#: man-pages/man2/syscalls.2:486
#, no-wrap
msgid "See B<stat>(2)"
msgstr "смотрите B<stat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:487
#, no-wrap
msgid "B<nfsservctl>(2)"
msgstr "B<nfsservctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:487
#, no-wrap
msgid "Removed in 3.1"
msgstr "удалён из Linux 3.1"

#. type: tbl table
#: man-pages/man2/syscalls.2:489
#, no-wrap
msgid "B<old_adjtimex>(2)"
msgstr "B<old_adjtimex>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:490
#, no-wrap
msgid "B<old_getrlimit>(2)"
msgstr "B<old_getrlimit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:492
#, no-wrap
msgid "Old variant of B<getrlimit>(2)\n"
msgstr "старый вариант B<getrlimit>(2),\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:494
#, no-wrap
msgid "that used a different value\n"
msgstr "использующий другое значение\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:496
#, no-wrap
msgid "for B<RLIM_INFINITY>"
msgstr "для B<RLIM_INFINITY>"

#. type: tbl table
#: man-pages/man2/syscalls.2:497
#, no-wrap
msgid "B<oldfstat>(2)"
msgstr "B<oldfstat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:498
#, no-wrap
msgid "B<oldlstat>(2)"
msgstr "B<oldlstat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:499
#, no-wrap
msgid "B<oldolduname>(2)"
msgstr "B<oldolduname>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:500
#, no-wrap
msgid "B<oldstat>(2)"
msgstr "B<oldstat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:501
#, no-wrap
msgid "B<oldumount>(2)"
msgstr "B<oldumount>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:501
#, no-wrap
msgid "2.4.116"
msgstr "2.4.116"

#. type: tbl table
#: man-pages/man2/syscalls.2:503
#, no-wrap
msgid "Name of the old B<umount>(2)\n"
msgstr "название старого B<umount>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:505
#, no-wrap
msgid "syscall on Alpha"
msgstr "syscall на Alpha"

#. type: tbl table
#: man-pages/man2/syscalls.2:506
#, no-wrap
msgid "B<olduname>(2)"
msgstr "B<olduname>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:508
#, no-wrap
msgid "B<open_by_handle_at>(2)"
msgstr "B<open_by_handle_at>(2)"

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: man-pages/man2/syscalls.2:511
#, no-wrap
msgid "B<or1k_atomic>(2)"
msgstr "B<or1k_atomic>(2)"

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: man-pages/man2/syscalls.2:511
#, no-wrap
msgid "3.1"
msgstr "3.1"

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: man-pages/man2/syscalls.2:511
#, no-wrap
msgid "OpenRISC 1000 only"
msgstr "только на OpenRISC 1000"

#. type: tbl table
#: man-pages/man2/syscalls.2:513
#, no-wrap
msgid "B<pciconfig_iobase>(2)"
msgstr "B<pciconfig_iobase>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:513
#, no-wrap
msgid "2.2.15; 2.4"
msgstr "2.2.15; 2.4"

#.  Alpha, PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:515
#, no-wrap
msgid "B<pciconfig_read>(2)"
msgstr "B<pciconfig_read>(2)"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:515 man-pages/man2/syscalls.2:517
#, no-wrap
msgid "2.0.26; 2.2"
msgstr "2.0.26; 2.2"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:517
#, no-wrap
msgid "B<pciconfig_write>(2)"
msgstr "B<pciconfig_write>(2)"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:519
#, no-wrap
msgid "B<perf_event_open>(2)"
msgstr "B<perf_event_open>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:519 man-pages/man2/syscalls.2:604
#, no-wrap
msgid "2.6.31"
msgstr "2.6.31"

#. type: tbl table
#: man-pages/man2/syscalls.2:521
#, no-wrap
msgid "Was perf_counter_open() in\n"
msgstr "был perf_counter_open() в\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:523
#, no-wrap
msgid "2.6.31; renamed in 2.6.32"
msgstr "2.6.31; переименован в 2.6.32"

#. type: tbl table
#: man-pages/man2/syscalls.2:524
#, no-wrap
msgid "B<personality>(2)"
msgstr "B<personality>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:525
#, no-wrap
msgid "B<perfctr>(2)"
msgstr "B<perfctr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:525
#, no-wrap
msgid "SPARC only; removed in 2.6.34"
msgstr "только на SPARC; удалён в 2.6.34"

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: man-pages/man2/syscalls.2:527
#, no-wrap
msgid "B<perfmonctl>(2)"
msgstr "B<perfmonctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:529
#, no-wrap
msgid "B<pipe2>(2)"
msgstr "B<pipe2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:530
#, no-wrap
msgid "B<pivot_root>(2)"
msgstr "B<pivot_root>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:531
#, no-wrap
msgid "B<pkey_alloc>(2)"
msgstr "B<pkey_alloc>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:531 man-pages/man2/syscalls.2:532
#: man-pages/man2/syscalls.2:533
#, no-wrap
msgid "4.8"
msgstr "4.8"

#. type: tbl table
#: man-pages/man2/syscalls.2:532
#, no-wrap
msgid "B<pkey_free>(2)"
msgstr "B<pkey_free>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:533
#, no-wrap
msgid "B<pkey_mprotect>(2)"
msgstr "B<pkey_mprotect>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:534
#, no-wrap
msgid "2.0.36; 2.2"
msgstr "2.0.36; 2.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:535
#, no-wrap
msgid "B<ppoll>(2)"
msgstr "B<ppoll>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:536
#, no-wrap
msgid "B<prctl>(2)"
msgstr "B<prctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:537
#, no-wrap
msgid "B<pread>(2)"
msgstr "B<pread>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:539
#, no-wrap
msgid "Used for B<pread64>(2) on AVR32\n"
msgstr "используется для B<pread64>(2) на AVR32\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:541
#, no-wrap
msgid "(port removed in Linux 4.12)\n"
msgstr "(перенос удалён в Linux 4.12)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:543
#, no-wrap
msgid "and Blackfin (port removed\n"
msgstr "и Blackfin (перенос удалён\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:546
#, no-wrap
msgid "B<pread64>(2)"
msgstr "B<pread64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:548
#, no-wrap
msgid "Added as \"pread\" in 2.2;\n"
msgstr "добавлен под именем «pread» в 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:550
#, no-wrap
msgid "renamed \"pread64\" in 2.6"
msgstr "переименован в «pread64» в 2.6"

#. type: tbl table
#: man-pages/man2/syscalls.2:551
#, no-wrap
msgid "B<preadv>(2)"
msgstr "B<preadv>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:551 man-pages/man2/syscalls.2:570
#, no-wrap
msgid "2.6.30"
msgstr "2.6.30"

#. type: tbl table
#: man-pages/man2/syscalls.2:552
#, no-wrap
msgid "B<preadv2>(2)"
msgstr "B<preadv2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:552 man-pages/man2/syscalls.2:571
#, no-wrap
msgid "4.6"
msgstr "4.6"

#. type: tbl table
#: man-pages/man2/syscalls.2:553
#, no-wrap
msgid "B<prlimit64>(2)"
msgstr "B<prlimit64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:554
#, no-wrap
msgid "B<process_vm_readv>(2)"
msgstr "B<process_vm_readv>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:554 man-pages/man2/syscalls.2:555
#, no-wrap
msgid "3.2"
msgstr "3.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:555
#, no-wrap
msgid "B<process_vm_writev>(2)"
msgstr "B<process_vm_writev>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:556
#, no-wrap
msgid "B<pselect6>(2)"
msgstr "B<pselect6>(2)"

#.  Implements \fBpselect\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:558
#, no-wrap
msgid "B<ptrace>(2)"
msgstr "B<ptrace>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:559
#, no-wrap
msgid "B<pwrite>(2)"
msgstr "B<pwrite>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:564
#, no-wrap
msgid ""
"Used for B<pwrite64>(2) on AVR32\n"
"(port removed in Linux 4.12)\n"
"and Blackfin (port removed\n"
"in Linux 4.17)"
msgstr ""
"используется для B<pwrite64>(2) на AVR32\n"
"(перенос удалён в Linux 4.12)\n"
"и Blackfin (перенос удалён\n"
"в Linux 4.17)"

#. type: tbl table
#: man-pages/man2/syscalls.2:565
#, no-wrap
msgid "B<pwrite64>(2)"
msgstr "B<pwrite64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:567
#, no-wrap
msgid "Added as \"pwrite\" in 2.2;\n"
msgstr "добавлен под именем «pwrite» в 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:569
#, no-wrap
msgid "renamed \"pwrite64\" in 2.6"
msgstr "переименован в «pwrite64» в 2.6"

#. type: tbl table
#: man-pages/man2/syscalls.2:570
#, no-wrap
msgid "B<pwritev>(2)"
msgstr "B<pwritev>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:571
#, no-wrap
msgid "B<pwritev2>(2)"
msgstr "B<pwritev2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:572
#, no-wrap
msgid "B<query_module>(2)"
msgstr "B<query_module>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:573
#, no-wrap
msgid "B<quotactl>(2)"
msgstr "B<quotactl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:575
#, no-wrap
msgid "B<readahead>(2)"
msgstr "B<readahead>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:575
#, no-wrap
msgid "2.4.13"
msgstr "2.4.13"

#. type: tbl table
#: man-pages/man2/syscalls.2:576
#, no-wrap
msgid "B<readdir>(2)"
msgstr "B<readdir>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:580
#, no-wrap
msgid "B<readv>(2)"
msgstr "B<readv>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:581
#, no-wrap
msgid "B<reboot>(2)"
msgstr "B<reboot>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:585
#, no-wrap
msgid "2.6.33"
msgstr "2.6.33"

#. type: tbl table
#: man-pages/man2/syscalls.2:586
#, no-wrap
msgid "B<remap_file_pages>(2)"
msgstr "B<remap_file_pages>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:586
#, no-wrap
msgid "Deprecated since 3.16"
msgstr "устарел начиная с 3.16"

#. type: tbl table
#: man-pages/man2/syscalls.2:587
#, no-wrap
msgid "B<removexattr>(2)"
msgstr "B<removexattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:590
#, no-wrap
msgid "B<renameat2>(2)"
msgstr "B<renameat2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:590
#, no-wrap
msgid "3.15"
msgstr "3.15"

#. type: tbl table
#: man-pages/man2/syscalls.2:591
#, no-wrap
msgid "B<request_key>(2)"
msgstr "B<request_key>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:592
#, no-wrap
msgid "B<restart_syscall>(2)"
msgstr "B<restart_syscall>(2)"

#.  921ebd8f2c081b3cf6c3b29ef4103eef3ff26054
#. type: tbl table
#: man-pages/man2/syscalls.2:594
#, no-wrap
msgid "B<riscv_flush_icache>(2)"
msgstr "B<riscv_flush_icache>(2)"

#.  921ebd8f2c081b3cf6c3b29ef4103eef3ff26054
#. type: tbl table
#: man-pages/man2/syscalls.2:594
#, no-wrap
msgid "RISC-V only"
msgstr "только на RISC-V"

#. type: tbl table
#: man-pages/man2/syscalls.2:596
#, no-wrap
msgid "B<rseq>(2)"
msgstr "B<rseq>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:600
#, no-wrap
msgid "B<rt_sigqueueinfo>(2)"
msgstr "B<rt_sigqueueinfo>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:604
#, no-wrap
msgid "B<rt_tgsigqueueinfo>(2)"
msgstr "B<rt_tgsigqueueinfo>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:605
#, no-wrap
msgid "B<rtas>(2)"
msgstr "B<rtas>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:605
#, no-wrap
msgid "2.6.2"
msgstr "2.6.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:605 man-pages/man2/syscalls.2:722
#: man-pages/man2/syscalls.2:723 man-pages/man2/syscalls.2:741
#: man-pages/man2/syscalls.2:742
#, no-wrap
msgid "PowerPC/PowerPC64 only"
msgstr "только на PowerPC/PowerPC64"

#. type: tbl table
#: man-pages/man2/syscalls.2:606
#, no-wrap
msgid "B<s390_runtime_instr>(2)"
msgstr "B<s390_runtime_instr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:606 man-pages/man2/syscalls.2:607
#: man-pages/man2/syscalls.2:608 man-pages/man2/syscalls.2:609
#: man-pages/man2/syscalls.2:610
#, no-wrap
msgid "s390 only"
msgstr "только для s390"

#. type: tbl table
#: man-pages/man2/syscalls.2:607
#, no-wrap
msgid "B<s390_pci_mmio_read>(2)"
msgstr "B<s390_pci_mmio_read>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:608
#, no-wrap
msgid "B<s390_pci_mmio_write>(2)"
msgstr "B<s390_pci_mmio_write>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:609
#, no-wrap
msgid "B<s390_sthyi>(2)"
msgstr "B<s390_sthyi>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:610
#, no-wrap
msgid "B<s390_guarded_storage>(2)"
msgstr "B<s390_guarded_storage>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:610
#, no-wrap
msgid "4.12"
msgstr "4.12"

#. type: tbl table
#: man-pages/man2/syscalls.2:611
#, no-wrap
msgid "B<sched_get_affinity>(2)"
msgstr "B<sched_get_affinity>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:613
#, no-wrap
msgid "Name of B<sched_getaffinity>(2)\n"
msgstr "название B<sched_getaffinity>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:615 man-pages/man2/syscalls.2:627
#, no-wrap
msgid "on SPARC and SPARC64"
msgstr "на SPARC и SPARC64"

#. type: tbl table
#: man-pages/man2/syscalls.2:619 man-pages/man2/syscalls.2:629
#, no-wrap
msgid "3.14"
msgstr "3.14"

#. type: tbl table
#: man-pages/man2/syscalls.2:623
#, no-wrap
msgid "B<sched_set_affinity>(2)"
msgstr "B<sched_set_affinity>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:625
#, no-wrap
msgid "Name of B<sched_setaffinity>(2)\n"
msgstr "название B<sched_setaffinity>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:633
#, no-wrap
msgid "B<seccomp>(2)"
msgstr "B<seccomp>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:635
#, no-wrap
msgid "B<semctl>(2)"
msgstr "B<semctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:636
#, no-wrap
msgid "B<semget>(2)"
msgstr "B<semget>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:637
#, no-wrap
msgid "B<semop>(2)"
msgstr "B<semop>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:638
#, no-wrap
msgid "B<semtimedop>(2)"
msgstr "B<semtimedop>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:638 man-pages/man2/syscalls.2:786
#, no-wrap
msgid "2.6; 2.4.22"
msgstr "2.6; 2.4.22"

#. type: tbl table
#: man-pages/man2/syscalls.2:640
#, no-wrap
msgid "B<sendfile>(2)"
msgstr "B<sendfile>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:641
#, no-wrap
msgid "B<sendfile64>(2)"
msgstr "B<sendfile64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:641
#, no-wrap
msgid "2.6; 2.4.19"
msgstr "2.6; 2.4.19"

#. type: tbl table
#: man-pages/man2/syscalls.2:642 man-pages/man2/syscalls.2:676
#, no-wrap
msgid "3.0"
msgstr "3.0"

#. type: tbl table
#: man-pages/man2/syscalls.2:645
#, no-wrap
msgid "B<set_mempolicy>(2)"
msgstr "B<set_mempolicy>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:646
#, no-wrap
msgid "B<set_robust_list>(2)"
msgstr "B<set_robust_list>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:647
#, no-wrap
msgid "B<set_thread_area>(2)"
msgstr "B<set_thread_area>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:648
#, no-wrap
msgid "B<set_tid_address>(2)"
msgstr "B<set_tid_address>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:649
#, no-wrap
msgid "B<set_tls>(2)"
msgstr "B<set_tls>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:649 man-pages/man2/syscalls.2:757
#, no-wrap
msgid "2.6.11"
msgstr "2.6.11"

#. type: tbl table
#: man-pages/man2/syscalls.2:651
#, no-wrap
msgid "ARM OABI/EABI only (constant\n"
msgstr "только в ARM OABI/EABI (константа\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:653
#, no-wrap
msgid "has B<__ARM_NR> prefix)"
msgstr "с префиксом B<__ARM_NR>)"

#.  \fBsetaltroot\fP(2)	2.6.10	T{
#.  Removed in 2.6.11, exposed one
#.  of implementation details of
#.  \fBpersonality\fP(2) (creating an
#.  alternative root, precursor of
#.  mount namespaces) to user space.
#.  T}
#.  See http://lkml.org/lkml/2005/8/1/83
#.  "[PATCH] remove sys_set_zone_reclaim()"
#. type: tbl table
#: man-pages/man2/syscalls.2:663
#, no-wrap
msgid "B<setdomainname>(2)"
msgstr "B<setdomainname>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:664
#, no-wrap
msgid "B<setfsgid>(2)"
msgstr "B<setfsgid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:665
#, no-wrap
msgid "B<setfsgid32>(2)"
msgstr "B<setfsgid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:666
#, no-wrap
msgid "B<setfsuid>(2)"
msgstr "B<setfsuid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:667
#, no-wrap
msgid "B<setfsuid32>(2)"
msgstr "B<setfsuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:669
#, no-wrap
msgid "B<setgid32>(2)"
msgstr "B<setgid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:670
#, no-wrap
msgid "B<setgroups>(2)"
msgstr "B<setgroups>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:671
#, no-wrap
msgid "B<setgroups32>(2)"
msgstr "B<setgroups32>(2)"

#.  arch/alpha/include/asm/core_lca.h
#. type: tbl table
#: man-pages/man2/syscalls.2:673
#, no-wrap
msgid "B<sethae>(2)"
msgstr "B<sethae>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:674
#, no-wrap
msgid "B<sethostname>(2)"
msgstr "B<sethostname>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:675
#, no-wrap
msgid "B<setitimer>(2)"
msgstr "B<setitimer>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:676
#, no-wrap
msgid "B<setns>(2)"
msgstr "B<setns>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:678
#, no-wrap
msgid "B<setpgrp>(2)"
msgstr "B<setpgrp>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:680
#, no-wrap
msgid "Alternative name for\n"
msgstr "дополнительное имя для\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:682
#, no-wrap
msgid "B<setpgid>(2) on Alpha"
msgstr "B<setpgid>(2) на Alpha"

#. type: tbl table
#: man-pages/man2/syscalls.2:684
#, no-wrap
msgid "B<setregid>(2)"
msgstr "B<setregid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:685
#, no-wrap
msgid "B<setregid32>(2)"
msgstr "B<setregid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:686
#, no-wrap
msgid "B<setresgid>(2)"
msgstr "B<setresgid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:687
#, no-wrap
msgid "B<setresgid32>(2)"
msgstr "B<setresgid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:688
#, no-wrap
msgid "B<setresuid>(2)"
msgstr "B<setresuid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:689
#, no-wrap
msgid "B<setresuid32>(2)"
msgstr "B<setresuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:690
#, no-wrap
msgid "B<setreuid>(2)"
msgstr "B<setreuid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:691
#, no-wrap
msgid "B<setreuid32>(2)"
msgstr "B<setreuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:692
#, no-wrap
msgid "B<setrlimit>(2)"
msgstr "B<setrlimit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:695
#, no-wrap
msgid "B<settimeofday>(2)"
msgstr "B<settimeofday>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:697
#, no-wrap
msgid "B<setuid32>(2)"
msgstr "B<setuid32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:698
#, no-wrap
msgid "B<setup>(2)"
msgstr "B<setup>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:698
#, no-wrap
msgid "Removed in 2.2"
msgstr "удалён в 2.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:699
#, no-wrap
msgid "B<setxattr>(2)"
msgstr "B<setxattr>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:700
#, no-wrap
msgid "B<sgetmask>(2)"
msgstr "B<sgetmask>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:701
#, no-wrap
msgid "B<shmat>(2)"
msgstr "B<shmat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:702
#, no-wrap
msgid "B<shmctl>(2)"
msgstr "B<shmctl>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:703
#, no-wrap
msgid "B<shmdt>(2)"
msgstr "B<shmdt>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:704
#, no-wrap
msgid "B<shmget>(2)"
msgstr "B<shmget>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:707
#, no-wrap
msgid "B<sigaltstack>(2)"
msgstr "B<sigaltstack>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:709
#, no-wrap
msgid "B<signalfd>(2)"
msgstr "B<signalfd>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:710
#, no-wrap
msgid "B<signalfd4>(2)"
msgstr "B<signalfd4>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:716
#, no-wrap
msgid "B<socketcall>(2)"
msgstr "B<socketcall>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:720
#, no-wrap
msgid "B<spill>(2)"
msgstr "B<spill>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:720 man-pages/man2/syscalls.2:824
#, no-wrap
msgid "Xtensa only"
msgstr "только на Xtensa"

#. type: tbl table
#: man-pages/man2/syscalls.2:721
#, no-wrap
msgid "B<splice>(2)"
msgstr "B<splice>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:722
#, no-wrap
msgid "B<spu_create>(2)"
msgstr "B<spu_create>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:723
#, no-wrap
msgid "B<spu_run>(2)"
msgstr "B<spu_run>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:724
#, no-wrap
msgid "B<sram_alloc>(2)"
msgstr "B<sram_alloc>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:726 man-pages/man2/syscalls.2:731
#, no-wrap
msgid "Blackfin (port removed\n"
msgstr "Blackfin (перенос удалён\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:729
#, no-wrap
msgid "B<sram_free>(2)"
msgstr "B<sram_free>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:734
#, no-wrap
msgid "B<ssetmask>(2)"
msgstr "B<ssetmask>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:736
#, no-wrap
msgid "B<stat64>(2)"
msgstr "B<stat64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:737
#, no-wrap
msgid "B<statfs>(2)"
msgstr "B<statfs>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:738
#, no-wrap
msgid "B<statfs64>(2)"
msgstr "B<statfs64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:739
#, no-wrap
msgid "B<statx>(2)"
msgstr "B<statx>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:739
#, no-wrap
msgid "4.11"
msgstr "4.11"

#. type: tbl table
#: man-pages/man2/syscalls.2:740
#, no-wrap
msgid "B<stime>(2)"
msgstr "B<stime>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:741
#, no-wrap
msgid "B<subpage_prot>(2)"
msgstr "B<subpage_prot>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:741 man-pages/man2/syscalls.2:782
#: man-pages/man2/syscalls.2:783 man-pages/man2/syscalls.2:784
#, no-wrap
msgid "2.6.25"
msgstr "2.6.25"

#. type: tbl table
#: man-pages/man2/syscalls.2:742 man-pages/man2/syscalls.2:745
#, no-wrap
msgid "B<swapcontext>(2)"
msgstr "B<swapcontext>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:742 man-pages/man2/syscalls.2:745
#, no-wrap
msgid "2.6.3"
msgstr "2.6.3"

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: man-pages/man2/syscalls.2:744
#, no-wrap
msgid "B<switch_endian>(2)"
msgstr "B<switch_endian>(2)"

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: man-pages/man2/syscalls.2:744
#, no-wrap
msgid "4.1"
msgstr "4.1"

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: man-pages/man2/syscalls.2:744
#, no-wrap
msgid "PowerPC64 only"
msgstr "только для PowerPC64"

#. type: tbl table
#: man-pages/man2/syscalls.2:745 man-pages/man2/syscalls.2:757
#, no-wrap
msgid "PowerPC only"
msgstr "только для PowerPC "

#. type: tbl table
#: man-pages/man2/syscalls.2:746
#, no-wrap
msgid "B<swapoff>(2)"
msgstr "B<swapoff>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:747
#, no-wrap
msgid "B<swapon>(2)"
msgstr "B<swapon>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:750
#, no-wrap
msgid "B<sync>(2)"
msgstr "B<sync>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:751
#, no-wrap
msgid "B<sync_file_range>(2)"
msgstr "B<sync_file_range>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:752
#, no-wrap
msgid "B<sync_file_range2>(2)"
msgstr "B<sync_file_range2>(2)"

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: man-pages/man2/syscalls.2:756
#, no-wrap
msgid "B<syncfs>(2)"
msgstr "B<syncfs>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:757
#, no-wrap
msgid "B<sys_debug_setcontext>(2)"
msgstr "B<sys_debug_setcontext>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:758
#, no-wrap
msgid "B<syscall>(2)"
msgstr "B<syscall>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:760
#, no-wrap
msgid "Still available on ARM OABI\n"
msgstr "ещё доступен в ARM OABI\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:762
#, no-wrap
msgid "and MIPS O32 ABI"
msgstr "и MIPS O32 ABI"

#. type: tbl table
#: man-pages/man2/syscalls.2:763
#, no-wrap
msgid "B<sysfs>(2)"
msgstr "B<sysfs>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:764
#, no-wrap
msgid "B<sysinfo>(2)"
msgstr "B<sysinfo>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:765
#, no-wrap
msgid "B<syslog>(2)"
msgstr "B<syslog>(2)"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:767
#, no-wrap
msgid "B<sysmips>(2)"
msgstr "B<sysmips>(2)"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:767
#, no-wrap
msgid "2.6.0"
msgstr "2.6.0"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:767
#, no-wrap
msgid "MIPS only"
msgstr "только на MIPS"

#. type: tbl table
#: man-pages/man2/syscalls.2:768
#, no-wrap
msgid "B<tee>(2)"
msgstr "B<tee>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:771
#, no-wrap
msgid "B<timer_create>(2)"
msgstr "B<timer_create>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:772
#, no-wrap
msgid "B<timer_delete>(2)"
msgstr "B<timer_delete>(2)"

#.  .\" b215e283992899650c4271e7385c79e26fb9a88e
#.  .\" 4d672e7ac79b5ec5cdc90e450823441e20464691
#.  \fBtimerfd\fP(2)	2.6.22	T{
#.  Old timerfd interface,
#.  removed in 2.6.25
#.  T}
#. type: tbl table
#: man-pages/man2/syscalls.2:782
#, no-wrap
msgid "B<timerfd_create>(2)"
msgstr "B<timerfd_create>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:783
#, no-wrap
msgid "B<timerfd_gettime>(2)"
msgstr "B<timerfd_gettime>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:784
#, no-wrap
msgid "B<timerfd_settime>(2)"
msgstr "B<timerfd_settime>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:786
#, no-wrap
msgid "B<tkill>(2)"
msgstr "B<tkill>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:787
#, no-wrap
msgid "B<truncate>(2)"
msgstr "B<truncate>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:788
#, no-wrap
msgid "B<truncate64>(2)"
msgstr "B<truncate64>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:789
#, no-wrap
msgid "B<ugetrlimit>(2)"
msgstr "B<ugetrlimit>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:791
#, no-wrap
msgid "B<umount>(2)"
msgstr "B<umount>(2)"

#.  sys_oldumount() -- __NR_umount
#. type: tbl table
#: man-pages/man2/syscalls.2:793
#, no-wrap
msgid "B<umount2>(2)"
msgstr "B<umount2>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:798
#, no-wrap
msgid "B<unshare>(2)"
msgstr "B<unshare>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:799
#, no-wrap
msgid "B<uselib>(2)"
msgstr "B<uselib>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:800
#, no-wrap
msgid "B<ustat>(2)"
msgstr "B<ustat>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:801
#, no-wrap
msgid "B<userfaultfd>(2)"
msgstr "B<userfaultfd>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:801
#, no-wrap
msgid "4.3"
msgstr "4.3"

#. type: tbl table
#: man-pages/man2/syscalls.2:802
#, no-wrap
msgid "B<usr26>(2)"
msgstr "B<usr26>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:802 man-pages/man2/syscalls.2:803
#, no-wrap
msgid "2.4.8.1"
msgstr "2.4.8.1"

#. type: tbl table
#: man-pages/man2/syscalls.2:802 man-pages/man2/syscalls.2:803
#, no-wrap
msgid "ARM OABI only"
msgstr "только в ARM OABI"

#. type: tbl table
#: man-pages/man2/syscalls.2:803
#, no-wrap
msgid "B<usr32>(2)"
msgstr "B<usr32>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:807
#, no-wrap
msgid "B<utrap_install>(2)"
msgstr "B<utrap_install>(2)"

#.  FIXME . document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: man-pages/man2/syscalls.2:810
#, no-wrap
msgid "B<vfork>(2)"
msgstr "B<vfork>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:811
#, no-wrap
msgid "B<vhangup>(2)"
msgstr "B<vhangup>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:812
#, no-wrap
msgid "B<vm86old>(2)"
msgstr "B<vm86old>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:815
#, no-wrap
msgid ""
"Was \"vm86\"; renamed in\n"
"2.0.28/2.2"
msgstr ""
"ранее «vm86»; переименован в\n"
"2.0.28/2.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:816
#, no-wrap
msgid "B<vm86>(2)"
msgstr "B<vm86>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:816
#, no-wrap
msgid "2.0.28; 2.2"
msgstr "2.0.28; 2.2"

#. type: tbl table
#: man-pages/man2/syscalls.2:817
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr "B<vmsplice>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:818
#, no-wrap
msgid "B<wait4>(2)"
msgstr "B<wait4>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:819
#, no-wrap
msgid "B<waitid>(2)"
msgstr "B<waitid>(2)"

#. type: tbl table
#: man-pages/man2/syscalls.2:822
#, no-wrap
msgid "B<writev>(2)"
msgstr "B<writev>(2)"

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:824
#, no-wrap
msgid "B<xtensa>(2)"
msgstr "B<xtensa>(2)"

#. type: Plain text
#: man-pages/man2/syscalls.2:833
msgid ""
"On many platforms, including x86-32, socket calls are all multiplexed (via "
"glibc wrapper functions) through B<socketcall>(2)  and similarly System\\ V "
"IPC calls are multiplexed through B<ipc>(2)."
msgstr ""
"Для многих платформ, включая x86-32, все сокетные вызовы мультиплексируются "
"(с помощью обёрточных функций glibc) через B<socketcall>(2), а подобные IPC "
"вызовы System\\ V мультиплексируются через B<ipc>(2)."

#.  __NR_afs_syscall is 53 on Linux 2.6.22/i386
#.  __NR_break is 17 on Linux 2.6.22/i386
#.  __NR_ftime is 35 on Linux 2.6.22/i386
#.  __NR_getpmsg is 188 on Linux 2.6.22/i386
#.  __NR_gtty is 32 on Linux 2.6.22/i386
#.  __NR_idle is 112 on Linux 2.6.22/i386
#.  __NR_lock is 53 on Linux 2.6.22/i386
#.  __NR_madvise1 is 219 on Linux 2.6.22/i386
#.  __NR_mpx is 66 on Linux 2.6.22/i386
#.  Slot has been reused
#.  __NR_prof is 44 on Linux 2.6.22/i386
#.  __NR_profil is 98 on Linux 2.6.22/i386
#.  __NR_putpmsg is 189 on Linux 2.6.22/i386
#.  __NR_security is 223 on Linux 2.4/i386
#.  __NR_security is 223 on Linux 2.4/i386; absent on 2.6/i386, present
#.  on a couple of 2.6 architectures
#.  __NR_stty is 31 on Linux 2.6.22/i386
#.  The security call is for future use.
#.  __NR_tuxcall is 184 on x86_64, also on PPC and alpha
#.  __NR_ulimit is 58 on Linux 2.6.22/i386
#.  __NR_vserver is 273 on Linux 2.6.22/i386
#. type: Plain text
#: man-pages/man2/syscalls.2:878
msgid ""
"Although slots are reserved for them in the system call table, the following "
"system calls are not implemented in the standard kernel: B<afs_syscall>(2), "
"B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2), B<idle>(2), B<lock>(2), "
"B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2), B<profil>(2), "
"B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2), B<ulimit>(2), and "
"B<vserver>(2)  (see also B<unimplemented>(2)).  However, B<ftime>(3), "
"B<profil>(3), and B<ulimit>(3)  exist as library routines.  The slot for "
"B<phys>(2)  is in use since kernel 2.1.116 for B<umount>(2); B<phys>(2)  "
"will never be implemented.  The B<getpmsg>(2)  and B<putpmsg>(2)  calls are "
"for kernels patched to support STREAMS, and may never be in the standard "
"kernel."
msgstr ""
"Хотя для них и зарезервированы места в таблице системных вызовов, следующие "
"системные вызовы не реализованы в стандартном ядре: B<afs_syscall>(2), "
"B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2), B<idle>(2), B<lock>(2), "
"B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2), B<profil>(2), "
"B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2), B<ulimit>(2) и "
"B<vserver>(2) (см. также B<unimplemented>(2)). Однако B<ftime>(3), "
"B<profil>(3) и B<ulimit>(3) есть среди библиотечных функций. Место для "
"B<phys>(2) занято начиная с ядра 2.1.116 под B<umount>(2); B<phys>(2) "
"никогда не будет реализован. Вызовы B<getpmsg>(2) и B<putpmsg>(2) есть в "
"ядрах с заплатами, обеспечивающими поддержку STREAMS, и могут никогда не "
"появиться в стандартном ядре."

#. type: Plain text
#: man-pages/man2/syscalls.2:883
msgid ""
"There was briefly B<set_zone_reclaim>(2), added in Linux 2.6.13, and removed "
"in 2.6.16; this system call was never available to user space."
msgstr ""
"На короткое время появлялся B<set_zone_reclaim>(2), добавленный в Linux "
"2.6.13 и удалённый в 2.6.16; данный системный вызов никогда не был доступен "
"из пользовательского пространства."

#. type: Plain text
#: man-pages/man2/syscalls.2:898
msgid ""
"Roughly speaking, the code belonging to the system call with number __NR_xxx "
"defined in I</usr/include/asm/unistd.h> can be found in the Linux kernel "
"source in the routine I<sys_xxx>().  There are many exceptions, however, "
"mostly because older system calls were superseded by newer ones, and this "
"has been treated somewhat unsystematically.  On platforms with proprietary "
"operating-system emulation, such as sparc, sparc64, and alpha, there are "
"many additional system calls; mips64 also contains a full set of 32-bit "
"system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:917
msgid ""
"Over time, changes to the interfaces of some system calls have been "
"necessary.  One reason for such changes was the need to increase the size of "
"structures or scalar values passed to the system call.  Because of these "
"changes, certain architectures (notably, longstanding 32-bit architectures "
"such as i386)  now have various groups of related system calls (e.g., "
"B<truncate>(2)  and B<truncate64>(2))  which perform similar tasks, but "
"which vary in details such as the size of their arguments.  (As noted "
"earlier, applications are generally unaware of this: the glibc wrapper "
"functions do some work to ensure that the right system call is invoked, and "
"that ABI compatibility is preserved for old binaries.)  Examples of systems "
"calls that exist in multiple versions are the following:"
msgstr ""
"С течением времени при необходимости происходили изменения в интерфейсе "
"некоторых системных вызовов. Одной из причин таких изменений была "
"необходимость увеличения размера структур или скалярных значений "
"передаваемых системному вызову. Из-за этих изменений на некоторых "
"архитектурах (а именно на старых 32-битных i386) появились различные группы "
"похожих системных вызовов (например, B<truncate>(2) и B<truncate64>(2)), "
"которые выполняют одинаковые задачи, но отличаются размером своих "
"аргументов. (Как уже отмечалось, на приложения это не влияет: обёрточные "
"функции glibc выполняют некоторые действия по запуску правильного системного "
"вызова, и это обеспечивает совместимость по ABI для старых двоичных файлов.) "
"Примеры системных вызовов, у которых есть несколько версий:"

#.  e.g., on 2.6.22/i386: __NR_oldstat 18, __NR_stat 106, __NR_stat64 195
#.  The stat system calls deal with three different data structures,
#.  defined in include/asm-i386/stat.h: __old_kernel_stat, stat, stat64
#. type: Plain text
#: man-pages/man2/syscalls.2:938
msgid ""
"By now there are three different versions of B<stat>(2): I<sys_stat>()  "
"(slot I<__NR_oldstat>), I<sys_newstat>()  (slot I<__NR_stat>), and "
"I<sys_stat64>()  (slot I<__NR_stat64>), with the last being the most "
"current.  A similar story applies for B<lstat>(2)  and B<fstat>(2)."
msgstr ""
"В настоящее время есть три различные версии B<stat>(2): I<sys_stat>() (место "
"I<__NR_oldstat>), I<sys_newstat>() (место I<__NR_stat>) и I<sys_stat64>() "
"(место I<__NR_stat64>), последняя используется в в данный момент. Похожая "
"ситуация с B<lstat>(2) и B<fstat>(2)."

#. type: Plain text
#: man-pages/man2/syscalls.2:949
msgid ""
"Similarly, the defines I<__NR_oldolduname>, I<__NR_olduname>, and "
"I<__NR_uname> refer to the routines I<sys_olduname>(), I<sys_uname>()  and "
"I<sys_newuname>()."
msgstr ""
"Похожим образом определены I<__NR_oldolduname>, I<__NR_olduname> и "
"I<__NR_uname> для вызовов I<sys_olduname>(), I<sys_uname>() и "
"I<sys_newuname>()."

#. type: Plain text
#: man-pages/man2/syscalls.2:956
msgid ""
"In Linux 2.0, a new version of B<vm86>(2)  appeared, with the old and the "
"new kernel routines being named I<sys_vm86old>()  and I<sys_vm86>()."
msgstr ""
"В Linux 2.0 появилась новая версия B<vm86>(2), новая и старая версии ядерных "
"процедур называются I<sys_vm86old>() и I<sys_vm86>()."

#. type: Plain text
#: man-pages/man2/syscalls.2:967
msgid ""
"In Linux 2.4, a new version of B<getrlimit>(2)  appeared, with the old and "
"the new kernel routines being named I<sys_old_getrlimit>()  (slot "
"I<__NR_getrlimit>)  and I<sys_getrlimit>()  (slot I<__NR_ugetrlimit>)."
msgstr ""
"В Linux 2.4 появилась новая версия B<getrlimit>(2) новая и старая версии "
"ядерных процедур называются I<sys_old_getrlimit>() (место I<__NR_getrlimit>) "
"и I<sys_getrlimit>() (место I<__NR_ugetrlimit>)."

#.  64-bit off_t changes: ftruncate64, *stat64,
#.  fcntl64 (because of the flock structure), getdents64, *statfs64
#. type: Plain text
#: man-pages/man2/syscalls.2:979
msgid ""
"Linux 2.4 increased the size of user and group IDs from 16 to 32 bits.  To "
"support this change, a range of system calls were added (e.g., "
"B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)), "
"superseding earlier calls of the same name without the \"32\" suffix."
msgstr ""
"В Linux 2.4 увеличено размер поля ID пользователей и групп с 16 до 32 бит. "
"Для поддержки этого изменения добавлено несколько системных вызовов "
"(например, B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), "
"B<setresuid32>(2)), упраздняющих ранние вызовы с теми же именами, но без "
"суффикса \"32\"."

#. type: Plain text
#: man-pages/man2/syscalls.2:996
msgid ""
"Linux 2.4 added support for applications on 32-bit architectures to access "
"large files (i.e., files for which the sizes and file offsets can't be "
"represented in 32 bits.)  To support this change, replacements were required "
"for system calls that deal with file offsets and sizes.  Thus the following "
"system calls were added: B<fcntl64>(2), B<getdents64>(2), B<stat64>(2), "
"B<statfs64>(2), B<truncate64>(2), and their analogs that work with file "
"descriptors or symbolic links.  These system calls supersede the older "
"system calls which, except in the case of the \"stat\" calls, have the same "
"name without the \"64\" suffix."
msgstr ""
"В Linux 2.4 добавлена поддержка доступа к большим файлам (у которых размеры "
"и смещения не умещаются в 32 бита) в приложениях на 32-битных архитектурах. "
"Для этого потребовалось внести изменения в системные вызовы, работающие с "
"размерами и смещениями по файлам. Были добавлены следующие системные вызовы: "
"B<fcntl64>(2), B<getdents64>(2), B<stat64>(2), B<statfs64>(2), "
"B<truncate64>(2) и их аналоги, которые обрабатывают файловые дескрипторы или "
"символьные ссылки. Эти системные вызовы упраздняют старые системные вызовы, "
"которые, за исключением вызовов «stat», называются также, но не имеют "
"суффикса «64»."

#. type: Plain text
#: man-pages/man2/syscalls.2:1002
msgid ""
"On newer platforms that only have 64-bit file access and 32-bit UIDs/GIDs (e."
"g., alpha, ia64, s390x, x86-64), there is just a single version of the UID/"
"GID and file access system calls.  On platforms (typically, 32-bit "
"platforms) where the *64 and *32 calls exist, the other versions are "
"obsolete."
msgstr ""
"На новых платформах, имеющих только 64-битный доступ к файлам и 32-битные "
"UID/GID (например, alpha, ia64, s390x, x86-64), есть только одна версия "
"системных вызовов для UID/GID и файлового доступа. На платформах (обычно это "
"32-битные платформы) где имеются *64 и *32 вызовы, другие версии устарели."

#. type: Plain text
#: man-pages/man2/syscalls.2:1010
msgid ""
"The I<rt_sig*> calls were added in kernel 2.2 to support the addition of "
"real-time signals (see B<signal>(7)).  These system calls supersede the "
"older system calls of the same name without the \"rt_\" prefix."
msgstr ""
"Вызовы I<rt_sig*> добавлены в ядро 2.2 для поддержки дополнительных сигналов "
"реального времени (см. B<signal>(7)). Эти системные вызовы упраздняют старые "
"системные вызовы с теми же именами, но без префикса \"rt_\"."

#.  (used by libc 6)
#.  .PP
#.  Two system call numbers,
#.  .IR __NR__llseek
#.  and
#.  .IR __NR__sysctl
#.  have an additional underscore absent in
#.  .IR sys_llseek ()
#.  and
#.  .IR sys_sysctl ().
#.  In kernel 2.1.81,
#.  .BR lchown (2)
#.  and
#.  .BR chown (2)
#.  were swapped; that is,
#.  .BR lchown (2)
#.  was added with the semantics that were then current for
#.  .BR chown (2),
#.  and the semantics of the latter call were changed to what
#.  they are today.
#. type: Plain text
#: man-pages/man2/syscalls.2:1064
msgid ""
"The B<select>(2)  and B<mmap>(2)  system calls use five or more arguments, "
"which caused problems in the way argument passing on the i386 used to be set "
"up.  Thus, while other architectures have I<sys_select>()  and "
"I<sys_mmap>()  corresponding to I<__NR_select> and I<__NR_mmap>, on i386 one "
"finds I<old_select>()  and I<old_mmap>()  (routines that use a pointer to an "
"argument block) instead.  These days passing five arguments is not a problem "
"any more, and there is a I<__NR__newselect> that corresponds directly to "
"I<sys_select>()  and similarly I<__NR_mmap2>.  s390x is the only 64-bit "
"architecture that has I<old_mmap>()."
msgstr ""
"В системных вызовах B<select>(2) и B<mmap>(2) используется пять или более "
"аргументов, что вызывало проблемы определения способа передачи аргументов на "
"i386(). В следствии этого, тогда как на других архитектурах вызовы "
"I<sys_select>() и I<sys_mmap>() соответствуют I<__NR_select> и I<__NR_mmap>, "
"на i386 они соответствуют I<old_select>() и I<old_mmap>() (процедуры, "
"использующие указатель на блок аргументов). В настоящее время больше нет "
"проблемы с передачей более пяти аргументов и есть I<__NR__newselect>, "
"который соответствует именно I<sys_select>() и тоже самое с I<__NR_mmap2>. "
"На s390x только 64-битная архитектура имеет I<old_mmap>."

#. type: SS
#: man-pages/man2/syscalls.2:1064
#, no-wrap
msgid "Architecture-specific details: Alpha"
msgstr "Специфика некоторых архитектур: Alpha"

#. type: Plain text
#: man-pages/man2/syscalls.2:1071
msgid ""
"B<getxgid>(2)  returns a pair of GID and effective GID via registers B<r0> "
"and B<r20>; it is provided instead of B<getgid>(2) and B<getegid>(2)."
msgstr ""
"Вызов B<getxgid>(2) возвращает пару GID и эффективный GID через регистры "
"B<r0> и B<r20>; он предоставляется как замена B<getgid>(2) и B<getegid>(2)."

#. type: Plain text
#: man-pages/man2/syscalls.2:1076
msgid ""
"B<getxpid>(2)  returns a pair of PID and parent PID via registers B<r0> and "
"B<r20>; it is provided instead of B<getpid>(2) and B<getppid>(2)."
msgstr ""
"Вызов B<getxpid>(2) возвращает пару PID и эффективный PID через регистры "
"B<r0> и B<r20>; он предоставляется как замена B<getpid>(2) и B<getppid>(2)."

#. type: Plain text
#: man-pages/man2/syscalls.2:1080
msgid ""
"B<old_adjtimex>(2)  is a variant of B<adjtimex>(2) that uses I<struct "
"timeval32>, for compatibility with OSF/1."
msgstr ""
"Вызов B<old_adjtimex>(2) является вариантом B<adjtimex>(2), в котором "
"используется I<struct timeval32> (для совместимости с OSF/1)."

#. type: Plain text
#: man-pages/man2/syscalls.2:1085
msgid ""
"B<getxuid>(2)  returns a pair of GID and effective GID via registers B<r0> "
"and B<r20>; it is provided instead of B<getuid>(2) and B<geteuid>(2)."
msgstr ""
"Вызов B<getxuid>(2) возвращает пару GID и эффективный GID через регистры "
"B<r0> и B<r20>; он предоставляется как замена B<getuid>(2) и B<geteuid>(2)."

#. type: Plain text
#: man-pages/man2/syscalls.2:1089
msgid ""
"B<sethae>(2)  is used for configuring the Host Address Extension register on "
"low-cost Alphas in order to access address space beyond first 27 bits."
msgstr ""
"Вызов B<sethae>(2) используется для настройки регистра Host Address "
"Extension в бюджетных Alpha, чтобы получить доступ к адресному пространству "
"за границу первых 27 бит."

#. type: Plain text
#: man-pages/man2/syscalls.2:1095
msgid ""
"B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<errno>(3), B<libc>(7), "
"B<vdso>(7)"
msgstr ""
"B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<errno>(3), B<libc>(7), "
"B<vdso>(7)"

#. type: TH
#: man-pages/man2/send.2:40
#, no-wrap
msgid "SEND"
msgstr "SEND"

#. type: Plain text
#: man-pages/man2/send.2:43
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr "send, sendto, sendmsg - отправляет сообщения в сокет"

#. type: Plain text
#: man-pages/man2/send.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/send.2:50
#, no-wrap
msgid "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/send.2:54
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/send.2:57
#, no-wrap
msgid "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/send.2:65
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""
"Системные вызовы B<send>(), B<sendto>() и B<sendmsg>() используются для "
"пересылки сообщений в другой сокет."

#. type: Plain text
#: man-pages/man2/send.2:84
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""
"Вызов B<send>() можно использовать, только если сокет находится в состоянии "
"I<соединения> (то есть известен получатель). Вызов B<send>() отличается от "
"B<write>(2) только наличием аргумента I<flags>. Если значение I<flags> равно "
"нулю, то вызов B<send>() эквивалентен B<write>(2). Также, вызов"

#. type: Plain text
#: man-pages/man2/send.2:86
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr "    send(sockfd, buf, len, flags);\n"

#. type: Plain text
#: man-pages/man2/send.2:88
msgid "is equivalent to"
msgstr "эквивалентен"

#. type: Plain text
#: man-pages/man2/send.2:90
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr "    sendto(sockfd, buf, len, flags, NULL, 0);\n"

#. type: Plain text
#: man-pages/man2/send.2:94
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""
"Аргумент I<sockfd> представляет файловый дескриптор сокета отправления."

#. type: Plain text
#: man-pages/man2/send.2:122
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""
"Если B<sendto>() используется с сокетом в режиме с установлением соединения "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>), то аргументы I<dest_addr> и I<addrlen> "
"игнорируются (и может быть возвращена ошибка B<EISCONN>, если их значения не "
"равны NULL и 0) и возвращается ошибка B<ENOTCONN>, если соединение через "
"сокет не установлено. Иначе в I<dest_addr> задаётся адрес назначения и его "
"размер в I<addrlen>. Для B<sendmsg>() адрес назначения указывается в I<msg."
"msg_name>, а его размер в I<msg.msg_namelen>."

#. type: Plain text
#: man-pages/man2/send.2:138
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""
"У B<send>() и B<sendto>() сообщение находится в I<buf>, а его длина в "
"I<len>. У B<sendmsg>() сообщение указывается в элементах массива I<msg."
"msg_iov>. Вызов B<sendmsg>() также позволяет отправлять вспомогательные "
"данные (так называемую управляющую информацию)."

#. type: Plain text
#: man-pages/man2/send.2:143
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""
"Если сообщение слишком длинно для передачи за раз через используемый "
"нижележащий протокол, то возвращается ошибка B<EMSGSIZE> и сообщение не "
"передаётся."

#. type: Plain text
#: man-pages/man2/send.2:147
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""
"Неудачная отправка с помощью B<send>() никак не отмечается. При обнаружении "
"локальных ошибок возвращается значение -1."

#. type: Plain text
#: man-pages/man2/send.2:160
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""
"Когда сообщение не помещается в буфер отправки сокета, выполнение "
"блокируется в B<send>(), если сокет не находится в неблокирующем режиме. "
"Если сокет находится в неблокирующем режиме, то  возвращается ошибка "
"B<EAGAIN> или B<EWOULDBLOCK>. Для выяснения, возможна ли отправка данных, "
"можно использовать вызов B<select>(2)."

#. type: SS
#: man-pages/man2/send.2:160
#, no-wrap
msgid "The flags argument"
msgstr "Аргумент флагов"

#.  FIXME . ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: man-pages/man2/send.2:166
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""
"Аргумент I<flags> является битовой маской и может содержать следующие флаги:"

#. type: TP
#: man-pages/man2/send.2:166
#, no-wrap
msgid "B<MSG_CONFIRM> (since Linux 2.3.15)"
msgstr "B<MSG_CONFIRM> (начиная с Linux 2.3.15)"

#. type: Plain text
#: man-pages/man2/send.2:180
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently implemented only for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""
"Сообщить уровню связи, что процесс пересылки произошел: вы получили успешный "
"ответ с другой стороны. Если уровень связи не получит его, то он будет "
"регулярно перепроверять наличие ответной стороны (например посредством "
"однонаправленной передачи ARP). Это работает только с сокетами B<SOCK_DGRAM> "
"и B<SOCK_RAW> и в настоящее время реализовано только для IPv4 и IPv6. В "
"B<arp>(7) представлена более подробная информация."

#. type: TP
#: man-pages/man2/send.2:180
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr "B<MSG_DONTROUTE>"

#. type: Plain text
#: man-pages/man2/send.2:188
msgid ""
"Don't use a gateway to send out the packet, send to hosts only on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is defined only for protocol families that route; packet "
"sockets don't."
msgstr ""
"Не использовать маршрутизацию для отправки пакета, а посылать его только на "
"узлы локальной сети. Обычно это используется в диагностических программах и "
"программах маршрутизации. Этот флаг определён только для маршрутизируемых "
"семейств протоколов; пакетные сокеты не используют маршрутизацию."

#. type: TP
#: man-pages/man2/send.2:188
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr "B<MSG_DONTWAIT> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/send.2:209
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned.  This provides similar behavior to setting the "
"B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> operation), but differs "
"in that B<MSG_DONTWAIT> is a per-call option, whereas B<O_NONBLOCK> is a "
"setting on the open file description (see B<open>(2)), which will affect all "
"threads in the calling process and as well as other processes that hold file "
"descriptors referring to the same open file description."
msgstr ""
"Включить неблокирующий режим. Если операция могла бы привести к блокировке, "
"возвращается B<EAGAIN> или B<EWOULDBLOCK>. Такое поведение подобно заданию "
"флага B<O_NONBLOCK> (в B<fcntl>(2) операцией B<F_SETFL>), но отличие в том, "
"что B<MSG_DONTWAIT> указывается в вызове, а B<O_NONBLOCK> задаётся в "
"описании открытого файла (смотрите B<open>(2)), что влияет на все нити "
"вызывающего процесса, а также на другие процессы, у которых есть файловые "
"дескрипторы, ссылающиеся на это описание открытого файла."

#. type: TP
#: man-pages/man2/send.2:209
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr "B<MSG_EOR> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/send.2:213
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""
"Завершить запись (record) (если поддерживается, например в сокетах типа "
"B<SOCK_SEQPACKET>)."

#. type: TP
#: man-pages/man2/send.2:213
#, no-wrap
msgid "B<MSG_MORE> (since Linux 2.4.4)"
msgstr "B<MSG_MORE> (начиная с Linux 2.4.4)"

#. type: Plain text
#: man-pages/man2/send.2:222
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""
"Вызывающий имеет дополнительные данные для отправки. Этот флаг используется "
"с сокетами TCP для получения такого же эффекта как с параметром сокета "
"B<TCP_CORK> (см. B<tcp>(7)), с той разницей, что этот флаг можно "
"устанавливать при каждом вызове."

#. type: Plain text
#: man-pages/man2/send.2:231
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is transmitted only when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""
"Начиная с Linux 2.6 этот флаг также поддерживается для сокетов UDP и "
"информирует ядро, о том что нужно упаковать все отправляемые данные вызовов "
"с этим флагом в одну дейтаграмму, которая передаётся только когда "
"выполняется вызов без указания этого флага (смотрите также описание "
"параметра сокета B<UDP_CORK> в B<udp>(7))."

#. type: TP
#: man-pages/man2/send.2:231
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr "B<MSG_NOSIGNAL> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/send.2:249
msgid ""
"Don't generate a B<SIGPIPE> signal if the peer on a stream-oriented socket "
"has closed the connection.  The B<EPIPE> error is still returned.  This "
"provides similar behavior to using B<sigaction>(2)  to ignore B<SIGPIPE>, "
"but, whereas B<MSG_NOSIGNAL> is a per-call feature, ignoring B<SIGPIPE> sets "
"a process attribute that affects all threads in the process."
msgstr ""
"Не генерировать сигнал B<SIGPIPE>, если сторона потокоориентированного "
"сокета закрыла соединение. Ошибка B<EPIPE> по прежнему возвращается. Это "
"создаёт поведение как при использовании B<sigaction>(2) для игнорирования "
"B<SIGPIPE>, но B<MSG_NOSIGNAL> является свойством вызова, а установка "
"B<SIGPIPE> в атрибутах процесса влияет на все нити процесса."

#. type: TP
#: man-pages/man2/send.2:249
#, no-wrap
msgid "B<MSG_OOB>"
msgstr "B<MSG_OOB>"

#. type: Plain text
#: man-pages/man2/send.2:258
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""
"Послать I<внепоточные данные>, если сокет это поддерживает (как, например, "
"сокеты типа B<SOCK_STREAM>); протокол более низкого уровня также должен "
"поддерживать I<внепоточные данные>. "

#. type: SS
#: man-pages/man2/send.2:258
#, no-wrap
msgid "sendmsg()"
msgstr "sendmsg()"

#. type: Plain text
#: man-pages/man2/send.2:264
msgid ""
"The definition of the I<msghdr> structure employed by B<sendmsg>()  is as "
"follows:"
msgstr "Определение структуры I<msghdr>, используемой B<sendmsg>():"

#. type: Plain text
#: man-pages/man2/send.2:276
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags (unused) */\n"
"};\n"
msgstr ""
"struct msghdr {\n"
"    void         *msg_name;       /* необязательный адрес */\n"
"    socklen_t     msg_namelen;    /* размер адреса */\n"
"    struct iovec *msg_iov;        /* массив приёма/передачи */\n"
"    size_t        msg_iovlen;     /* # количество элементов в msg_iov */\n"
"    void         *msg_control;    /* вспомогательные данные,\n"
"                                     смотрите ниже */\n"
"    size_t        msg_controllen; /* размер буфера вспомогательных\n"
"                                     данных */\n"
"    int           msg_flags;      /* флаги (не используется) */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/send.2:288
msgid ""
"The I<msg_name> field is used on an unconnected socket to specify the target "
"address for a datagram.  It points to a buffer containing the address; the "
"I<msg_namelen> field should be set to the size of the address.  For a "
"connected socket, these fields should be specified as NULL and 0, "
"respectively."
msgstr ""
"Поле I<msg_name> используется на неподключённом сокете для указания адреса "
"назначения дейтаграммы. Оно указывает на буфер с адресом; в поле "
"I<msg_namelen> должен быть указан размер адреса. Для подключённого сокета "
"значения этих полей должны быть равны NULL и 0, соответственно."

#. type: Plain text
#: man-pages/man2/send.2:295
msgid ""
"The I<msg_iov> and I<msg_iovlen> fields specify scatter-gather locations, as "
"for B<writev>(2)."
msgstr ""
"В полях I<msg_iov> и I<msg_iovlen> задаются места приёма/передачи, как для "
"B<writev>(2)."

#. type: Plain text
#: man-pages/man2/send.2:306
msgid ""
"You may send control information using the I<msg_control> and "
"I<msg_controllen> members.  The maximum control buffer length the kernel can "
"process is limited per socket by the value in I</proc/sys/net/core/"
"optmem_max>; see B<socket>(7)."
msgstr ""
"Управляющую информацию можно посылать через поля I<msg_control> и "
"I<msg_controllen>. Максимальная длина управляющего буфера, которую "
"поддерживает ядро, ограничена значением I</proc/sys/net/core/optmem_max>; "
"см. B<socket>(7)."

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#. type: Plain text
#: man-pages/man2/send.2:313
msgid "The I<msg_flags> field is ignored."
msgstr "Поле I<msg_flags> игнорируется."

#. type: Plain text
#: man-pages/man2/send.2:318
msgid ""
"On success, these calls return the number of bytes sent.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении эти вызовы возвращают количество отправленных байт. "
"В случае ошибки возвращается -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/send.2:323
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""
"Здесь представлено несколько стандартных ошибок, возвращаемых с уровня "
"сокетов. Могут также появиться другие ошибки, возвращаемые из "
"соответствующих модулей протоколов; их описание находится в соответствующих "
"справочных страницах."

#. type: Plain text
#: man-pages/man2/send.2:331
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr ""
"(для доменных сокетов UNIX, которые идентифицируются по имени пути) Нет прав "
"на запись в файл сокета назначения или в одном из каталогов пути запрещён "
"поиск (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/send.2:334
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""
"(для сокетов UDP) Попытка отправки по сетевому/широковещательному адресу, "
"как будто это был однозначный (unicast) адрес."

#. type: TP
#: man-pages/man2/send.2:334
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> или B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/send.2:342
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""
"Сокет помечен как неблокирующий, но запрошенная операция привела бы к "
"блокировке. POSIX.1-2001 допускает в этих случаях возврат ошибки и не "
"требует, чтобы эти константы имели одинаковое значение, поэтому переносимое "
"приложение должно проверять обе возможности."

#. type: Plain text
#: man-pages/man2/send.2:355
msgid ""
"(Internet domain datagram sockets)  The socket referred to by I<sockfd> had "
"not previously been bound to an address and, upon attempting to bind it to "
"an ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of I</proc/sys/net/ipv4/"
"ip_local_port_range> in B<ip>(7)."
msgstr ""
"(доменные датаграммные сокеты Интернета) Сокет, указанный I<sockfd>, ранее "
"не был привязан к адресу и при попытке привязать его к эфемеридному порту, "
"было определено, что все номера в диапазоне эфемеридных портов уже "
"используются. Смотрите обсуждение I</proc/sys/net/ipv4/ip_local_port_range> "
"в B<ip>(7)."

#. type: TP
#: man-pages/man2/send.2:355
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: man-pages/man2/send.2:358
msgid "Another Fast Open is in progress."
msgstr "Сейчас выполняется другая операция Fast Open."

#. type: Plain text
#: man-pages/man2/send.2:362
msgid "I<sockfd> is not a valid open file descriptor."
msgstr ""
"Значение I<sockfd> не является правильным открытым файловым дескриптором."

#. type: TP
#: man-pages/man2/send.2:362
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: man-pages/man2/send.2:365
msgid "Connection reset by peer."
msgstr "Соединение сброшено другой стороной."

#. type: TP
#: man-pages/man2/send.2:365
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: man-pages/man2/send.2:368
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""
"Сокет в режиме без установления соединения и адрес второй стороны не задан."

#. type: Plain text
#: man-pages/man2/send.2:371
msgid "An invalid user space address was specified for an argument."
msgstr ""
"В аргументе указано неверное значение адреса пользовательского пространства."

#. type: Plain text
#: man-pages/man2/send.2:375
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr "Получен сигнал до начала передачи данных; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/send.2:378
msgid "Invalid argument passed."
msgstr "Передан неверный аргумент."

#. type: TP
#: man-pages/man2/send.2:378
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: man-pages/man2/send.2:384
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""
"Сокет в режиме с установлением соединения уже выполнил подключение, но "
"указан получатель (теперь или возвращается эта ошибка, или игнорируется "
"указание получателя)."

#. type: TP
#: man-pages/man2/send.2:384
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: man-pages/man2/send.2:390
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""
"Для типа сокета требуется, чтобы сообщение было отослано за время одной "
"операции (атомарно), а размер сообщения не позволяет этого."

#. type: TP
#: man-pages/man2/send.2:390
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: man-pages/man2/send.2:398
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""
"Исходящая очередь сетевого интерфейса заполнена. Обычно это означает, что "
"интерфейс прекратил отправку, но это может быть также вызвано временной "
"перегрузкой сети. Обычно, в Linux этого не происходит. Пакеты просто "
"отбрасываются, когда очередь устройства переполняется."

#. type: Plain text
#: man-pages/man2/send.2:401
msgid "No memory available."
msgstr "Больше нет доступной памяти."

#. type: Plain text
#: man-pages/man2/send.2:404
msgid "The socket is not connected, and no target has been given."
msgstr "Сокет не подключён и назначение не задано."

#. type: TP
#: man-pages/man2/send.2:409
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/send.2:414
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""
"Один из битов в аргументе I<flags> не может устанавливаться для этого типа "
"сокета."

#. type: TP
#: man-pages/man2/send.2:414
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: man-pages/man2/send.2:423
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case, the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""
"Локальный сокет, ориентированный на соединение, был закрыт. В этом случае "
"процесс также получит сигнал B<SIGPIPE>, если не установлен флаг "
"B<MSG_NOSIGNAL>."

#. type: Plain text
#: man-pages/man2/send.2:426
msgid "4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD."
msgstr "4.4BSD, SVr4, POSIX.1-2001. Эти интерфейсы впервые появились в 4.2BSD."

#. type: Plain text
#: man-pages/man2/send.2:437
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""
"В POSIX.1-2001 описаны только флаги B<MSG_OOB> и B<MSG_EOR>. В POSIX.1-2008 "
"добавлено описание B<MSG_NOSIGNAL>. Флаг B<MSG_CONFIRM> является "
"нестандартным расширением Linux."

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/send.2:451
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr ""
"В соответствие с POSIX.1-2001 поле I<msg_controllen> структуры I<msghdr> "
"должно иметь тип I<socklen_t>, но в настоящее время в glibc оно имеет тип "
"I<size_t>."

#. type: Plain text
#: man-pages/man2/send.2:456
msgid ""
"See B<sendmmsg>(2)  for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""
"В B<sendmmsg>(2) можно найти информацию о специальном системном вызове "
"Linux, который можно использовать для передачи нескольких дейтаграмм за один "
"вызов."

#. type: Plain text
#: man-pages/man2/send.2:461
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr "Linux может вернуть B<EPIPE> вместо B<ENOTCONN>."

#. type: Plain text
#: man-pages/man2/send.2:466
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr "Пример использования B<sendto>() показан в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man2/send.2:482
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/sendfile.2:19
#, no-wrap
msgid "SENDFILE"
msgstr "SENDFILE"

#. type: Plain text
#: man-pages/man2/sendfile.2:22
msgid "sendfile - transfer data between file descriptors"
msgstr "sendfile - производит обмен данными между дескрипторами файлов"

#. type: Plain text
#: man-pages/man2/sendfile.2:24
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr "B<#include E<lt>sys/sendfile.hE<gt>>"

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" #.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: man-pages/man2/sendfile.2:47
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"

#. type: Plain text
#: man-pages/man2/sendfile.2:57
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""
"Вызов B<sendfile>() копирует данные из одного файлового дескриптора в "
"другой. Так как копирование производится в ядре, использование B<sendfile>() "
"более эффективно чем комбинация B<read>(2) и B<write>(2), в которой "
"требуется скопировать данные в и из пользовательского пространства."

#. type: Plain text
#: man-pages/man2/sendfile.2:62
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""
"В I<in_fd> должен указываться файловый дескриптор, открытый для чтения, а в "
"I<out_fd> должен указываться файловый дескриптор, открытый для записи."

#. type: Plain text
#: man-pages/man2/sendfile.2:83
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the file offset of I<in_fd>; otherwise the "
"file offset is adjusted to reflect the number of bytes read from I<in_fd>."
msgstr ""
"Если значение I<offset> не равно NULL, то оно указывает на переменную, "
"содержащую файловое смещение с которого B<sendfile>() начнёт чтение данных "
"из I<in_fd>. При завершении B<sendfile>() значение этой переменной будет "
"содержать смещение следующего байта после последнего прочитанного. Если "
"значение I<offset> не равно NULL, то B<sendfile>() не изменяет файловое "
"смещение I<in_fd>; иначе файловое смещение изменяется для отражения "
"количества прочитанных из I<in_fd> байт."

#. type: Plain text
#: man-pages/man2/sendfile.2:90
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"file offset, and the file offset will be updated by the call."
msgstr ""
"Если значение I<offset> равно NULL, то данные будут прочитаны из I<in_fd> "
"начиная с файлового смещения, и по окончании работы вызова файловое смещение "
"будет обновлено."

#. type: Plain text
#: man-pages/man2/sendfile.2:93
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr ""
"В I<count> содержится количество байт, копируемых между файловыми "
"дескрипторами."

#. type: Plain text
#: man-pages/man2/sendfile.2:100
msgid ""
"The I<in_fd> argument must correspond to a file which supports B<mmap>(2)-"
"like operations (i.e., it cannot be a socket)."
msgstr ""
"Значение I<in_fd> должно описывать файл, который поддерживает операции типа "
"B<mmap>(2) (т.е., не сокет)."

#. type: Plain text
#: man-pages/man2/sendfile.2:108
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then "
"B<sendfile>()  changes the file offset appropriately."
msgstr ""
"В ядрах Linux до версии 2.6.33, значение I<out_fd> должно указывать на "
"сокет. Начиная с Linux 2.6.33 можно указывать любой файл. Если это обычный "
"файл, то B<sendfile>() изменит файловое смещение соответствующим образом."

#. type: Plain text
#: man-pages/man2/sendfile.2:117
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  Note that a successful call to B<sendfile>()  may write fewer "
"bytes than requested; the caller should be prepared to retry the call if "
"there were unsent bytes.  See also NOTES."
msgstr ""
"Если пересылка прошла успешно, то возвращается количество записанных в "
"I<out_fd> байт. Заметим, что при успешном выполнении вызов B<sendfile>() "
"может записать меньше байт, чем запрашивалось; вызывающий должен быть готов "
"повторить вызов, если останутся не отправленные байты. Также смотрите "
"ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/sendfile.2:127
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""
"Был выбран неблокирующий ввод-вывод с помощью B<O_NONBLOCK>, но запись "
"привела бы блокировке."

#. type: Plain text
#: man-pages/man2/sendfile.2:131
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""
"Входной файл не открыт для чтения или выходной файл не открыт для записи."

#. type: Plain text
#: man-pages/man2/sendfile.2:134
msgid "Bad address."
msgstr "Неправильный адрес."

#. type: Plain text
#: man-pages/man2/sendfile.2:143
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>, or I<count> is negative."
msgstr ""
"Неправильный или заблокированный дескриптор, или для I<in_fd> недоступна "
"операция типа B<mmap>(2) или значение I<count> отрицательно."

#. type: Plain text
#: man-pages/man2/sendfile.2:151
msgid ""
"I<out_fd> has the B<O_APPEND> flag set.  This is not currently supported by "
"B<sendfile>()."
msgstr ""
"У I<out_fd> установлен флаг B<O_APPEND>. Пока это не поддерживается в "
"B<sendfile>()."

#. type: Plain text
#: man-pages/man2/sendfile.2:155
msgid "Unspecified error while reading from I<in_fd>."
msgstr "Неизвестная ошибка при чтении I<in_fd>."

#. type: Plain text
#: man-pages/man2/sendfile.2:159
msgid "Insufficient memory to read from I<in_fd>."
msgstr "Не хватает памяти для чтения I<in_fd>."

#. type: Plain text
#: man-pages/man2/sendfile.2:164
msgid ""
"I<count> is too large, the operation would result in exceeding the maximum "
"size of either the input file or the output file."
msgstr ""
"Значение I<count> слишком велико, операция вернула бы результат, превышающий "
"максимальный размер входного или выходного файла."

#. type: Plain text
#: man-pages/man2/sendfile.2:169
msgid "I<offset> is not NULL but the input file is not B<seek>(2)-able."
msgstr ""
"Значение I<offset> не равно NULL, но для входного файла не работает "
"B<seek>(2)."

#. type: Plain text
#: man-pages/man2/sendfile.2:175
msgid ""
"B<sendfile>()  first appeared in Linux 2.2.  The include file I<E<lt>sys/"
"sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""
"Вызов B<sendfile>() впервые появился в Linux 2.2. Файл заголовков I<E<lt>sys/"
"sendfile.hE<gt>> появился в glibc 2.1."

#. type: Plain text
#: man-pages/man2/sendfile.2:177
msgid "Not specified in POSIX.1-2001, nor in other standards."
msgstr "Отсутствует в POSIX.1-2001 и других стандартах."

#. type: Plain text
#: man-pages/man2/sendfile.2:182
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""
"В других системах UNIX вызов B<sendfile>() реализован с другими семантиками "
"и прототипами. Не должен использоваться в переносимых программах."

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: man-pages/man2/sendfile.2:188
msgid ""
"B<sendfile>()  will transfer at most 0x7ffff000 (2,147,479,552) bytes, "
"returning the number of bytes actually transferred.  (This is true on both "
"32-bit and 64-bit systems.)"
msgstr ""
"Вызов B<sendfile>() передаст не больше 0x7ffff000 (2 147 479 552) байт, "
"возвращая число байт, переданных на самом деле (это утверждение справедливо "
"как к 32-битным, так и к 64-битным системам)."

#. type: Plain text
#: man-pages/man2/sendfile.2:198
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""
"Если вы планируете использовать B<sendfile>() для отправки файлов через "
"сокет TCP и вам нужно послать некоторые заголовочные данные перед содержимым "
"файла, то обратите внимание на параметр B<TCP_CORK>, описанный в B<tcp>(7), "
"он поможет минимизировать количество пакетов и оптимизировать "
"производительность."

#. type: Plain text
#: man-pages/man2/sendfile.2:204
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file; this "
"possibility went away in the Linux 2.6.x kernel series, but was restored in "
"Linux 2.6.33."
msgstr ""
"В Linux 2.4 и более ранних, значение I<out_fd> может также указывать на "
"обычный файл; эта возможность была удалена в ядрах Linux 2.6.x, но "
"возвращена в 2.6.33."

#. type: Plain text
#: man-pages/man2/sendfile.2:216
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""
"Первоначальная версия Linux B<sendfile>() не была приспособлена для работы с "
"большими файловыми смещениями. В последствии в Linux 2.4 был добавлен вызов "
"B<sendfile64>() с более широким диапазоном значений аргумента I<offset>. В "
"glibc B<sendfile>() представляет собой обёрточную функцию, которая делает "
"незаметным разницу между версиями ядер."

#. type: Plain text
#: man-pages/man2/sendfile.2:225
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""
"Приложение может попытаться воспользоваться B<read>(2)/B<write>(2), если "
"вызов B<sendfile>() завершится с ошибкой B<EINVAL> или B<ENOSYS>."

#. type: Plain text
#: man-pages/man2/sendfile.2:234
msgid ""
"If I<out_fd> refers to a socket or pipe with zero-copy support, callers must "
"ensure the transferred portions of the file referred to by I<in_fd> remain "
"unmodified until the reader on the other end of I<out_fd> has consumed the "
"transferred data."
msgstr ""
"Если I<out_fd> ссылается на сокет или канал с поддержкой нулевого "
"копирования, то вызывающие должны гарантировать, что переданные части файла, "
"указываемого I<in_fd>, останутся неизменёнными до тех пор, пока читающий на "
"другом конце I<out_fd> не закончит обрабатывать переданные данные."

#. type: Plain text
#: man-pages/man2/sendfile.2:239
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary file descriptors provided one (or both) of them is a pipe."
msgstr ""
"Специальный вызов Linux B<splice>(2) поддерживает пересылку данных между "
"произвольными файловыми дескрипторами, представляющими сокеты (один или оба)."

#. type: Plain text
#: man-pages/man2/sendfile.2:244
msgid ""
"B<copy_file_range>(2), B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr ""
"B<copy_file_range>(2), B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"

#. type: TH
#: man-pages/man2/s390_pci_mmio_write.2:25
#, no-wrap
msgid "S390_PCI_MMIO_WRITE"
msgstr "S390_PCI_MMIO_WRITE"

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:29
msgid ""
"s390_pci_mmio_write, s390_pci_mmio_read - transfer data to/from PCI MMIO "
"memory page"
msgstr ""
"s390_pci_mmio_write, s390_pci_mmio_read - обмен данными со страницей памяти "
"PCI MMIO"

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:32
#, no-wrap
msgid "B<#include E<lt>asm/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>asm/unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:37
#, no-wrap
msgid ""
"B<int s390_pci_mmio_write(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
"B<int s390_pci_mmio_read(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<int s390_pci_mmio_write(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
"B<int s390_pci_mmio_read(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:56
msgid ""
"The B<s390_pci_mmio_write>()  system call writes I<length> bytes of data "
"from the user-space buffer I<user_buffer> to the PCI MMIO memory location "
"specified by I<mmio_addr>.  The B<s390_pci_mmio_read>()  system call reads "
"I<length> bytes of data from the PCI MMIO memory location specified by "
"I<mmio_addr> to the user-space buffer I<user_buffer>."
msgstr ""
"Системный вызов B<s390_pci_mmio_write>() записывает I<length> байт данных из "
"буфера I<user_buffer> пользовательского пространства в память PCI MMIO по "
"адресу, указанному в I<mmio_addr>. Системный вызов B<s390_pci_mmio_read>() "
"читает I<length> байт данных начиная с адреса I<mmio_addr> в памяти PCI MMIO "
"и записывает их в буфер пользовательского пространства I<user_buffer>."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:67
msgid ""
"These system calls must be used instead of the simple assignment or data-"
"transfer operations that are used to access the PCI MMIO memory areas mapped "
"to user space on the Linux System z platform.  The address specified by "
"I<mmio_addr> must belong to a PCI MMIO memory page mapping in the caller's "
"address space, and the data being written or read must not cross a page "
"boundary.  The I<length> value cannot be greater than the system page size."
msgstr ""
"Данные системные вызовы должны использоваться вместо простых операций "
"назначения данных, используемых для доступа к областям памяти PCI MMIO, "
"отображенным в пользовательское пространство на платформе Linux System z. "
"Адрес, указываемый в I<mmio_addr>, должен принадлежать отображению страницы "
"памяти PCI MMIO в адресном пространстве вызывающего, а записываемые или "
"читаемые данные не должны пересекать границу страницы. Значение I<length> не "
"может быть больше размера системной страницы."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:76
msgid ""
"On success, B<s390_pci_mmio_write>()  and B<s390_pci_mmio_read>()  return "
"0.  On error, -1 is returned and I<errno> is set to one of the error codes "
"listed below."
msgstr ""
"При успешном выполнении B<s390_pci_mmio_write>() и B<s390_pci_mmio_read>() "
"возвращают 0. При ошибке возвращается -1, а в I<errno> содержится один из "
"кодов ошибки, перечисленных далее."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:82
msgid "The address in I<mmio_addr> is invalid."
msgstr "Некорректный адрес в I<mmio_addr>."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:86
msgid ""
"I<user_buffer> does not point to a valid location in the caller's address "
"space."
msgstr ""
"Адрес I<user_buffer> не ссылается на корректную точку в адресном "
"пространстве вызывающего."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:91
msgid "Invalid I<length> argument."
msgstr "Некорректное значение аргумента I<length>."

#. type: TP
#: man-pages/man2/s390_pci_mmio_write.2:91
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:94
msgid "PCI support is not enabled."
msgstr "Поддержка PCI выключена."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:97
msgid "Insufficient memory."
msgstr "Недостаточно памяти."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:99
msgid "These system calls are available since Linux 3.19."
msgstr "Данные системные вызовы появились в Linux 3.19."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:102
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The required PCI support is available beginning with System z EC12."
msgstr ""
"Данный системный вызов есть только в Linux и доступен только на архитектуре "
"s390. Требуемая поддержка PCI доступна начиная с System z EC12."

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:106
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to "
"call it."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/symlink.2:36
msgid "symlink, symlinkat - make a new name for a file"
msgstr "symlink, symlinkat - создаёт новое имя для файла"

#. type: Plain text
#: man-pages/man2/symlink.2:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:41
#, no-wrap
msgid "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"
msgstr "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант of AT_* */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:47
#, no-wrap
msgid "B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char *>I<linkpath>B<);>\n"
msgstr "B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char *>I<linkpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:56
msgid "B<symlink>():"
msgstr "B<symlink>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/symlink.2:60
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/symlink.2:63
msgid "B<symlinkat>():"
msgstr "B<symlinkat>():"

#. type: TP
#: man-pages/man2/symlink.2:66
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/symlink.2:69
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/symlink.2:69
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/symlink.2:72
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/symlink.2:81
msgid ""
"B<symlink>()  creates a symbolic link named I<linkpath> which contains the "
"string I<target>."
msgstr ""
"Вызов B<symlink>() создаёт символьную ссылку с именем I<linkpath>, которая "
"содержит строку I<target>."

#. type: Plain text
#: man-pages/man2/symlink.2:85
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr ""
"Символьные ссылки интерпретируются «на лету», как будто бы содержимое ссылки "
"было подставлено вместо пути, по которому идёт поиск файла или каталога."

#. type: Plain text
#: man-pages/man2/symlink.2:90
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link "
"resides."
msgstr ""
"Символьные ссылки могут содержать компоненты пути I<..>, которые (если "
"используются в начале ссылки) ссылаются на родительский каталог того "
"каталога, в котором находится ссылка."

#. type: Plain text
#: man-pages/man2/symlink.2:94
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or "
"to a nonexistent one; the latter case is known as a dangling link."
msgstr ""
"Символьная ссылка (также известная как «мягкая ссылка») может указывать как "
"на существующий, так и на несуществующий файлы; в последнем случае такая "
"ссылка называется повисшей (dangling)."

#. type: Plain text
#: man-pages/man2/symlink.2:101
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link "
"is requested and the link is in a directory with the sticky bit "
"(B<S_ISVTX>)  set."
msgstr ""
"Права доступа символьной ссылки не имеют значения; принадлежность "
"определённому владельцу игнорируется при переходе по ссылке, но проверяется "
"при удалении или переименовании ссылки, а также ссылки в каталог с "
"установленным закрепляющим (sticky) битом (B<S_ISVTX>)."

#. type: Plain text
#: man-pages/man2/symlink.2:107
msgid "If I<linkpath> exists, it will I<not> be overwritten."
msgstr "Если I<linkpath> существует, то он I<не> будет перезаписан."

#. type: SS
#: man-pages/man2/symlink.2:107
#, no-wrap
msgid "symlinkat()"
msgstr "symlinkat()"

#. type: Plain text
#: man-pages/man2/symlink.2:113
msgid ""
"The B<symlinkat>()  system call operates in exactly the same way as "
"B<symlink>(), except for the differences described here."
msgstr ""
"Системный вызов B<symlinkat>() работает также как системный вызов "
"B<symlink>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/symlink.2:123
msgid ""
"If the pathname given in I<linkpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<newdirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<symlink>()  for a relative pathname)."
msgstr ""
"Если в I<linkpath> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<newdirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<symlink>())."

#. type: Plain text
#: man-pages/man2/symlink.2:135
msgid ""
"If I<linkpath> is relative and I<newdirfd> is the special value B<AT_FDCWD>, "
"then I<linkpath> is interpreted relative to the current working directory of "
"the calling process (like B<symlink>())."
msgstr ""
"Если в I<linkpath> задан относительный путь и значение I<newdirfd> равно "
"B<AT_FDCWD>, то I<linkpath> рассматривается относительно текущего рабочего "
"каталога вызывающего процесса (как B<symlink>())."

#. type: Plain text
#: man-pages/man2/symlink.2:141
msgid "If I<linkpath> is absolute, then I<newdirfd> is ignored."
msgstr "Если в I<linkpath> задан абсолютный путь, то I<newdirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/symlink.2:156
msgid ""
"Write access to the directory containing I<linkpath> is denied, or one of "
"the directories in the path prefix of I<linkpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""
"Нет прав на запись в каталог, содержащийся в I<linkpath>, или в одном из "
"каталогов в I<linkpath> не разрешён поиск (смотрите также "
"B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/symlink.2:161
msgid ""
"The user's quota of resources on the filesystem has been exhausted.  The "
"resources could be inodes or disk blocks, depending on the filesystem "
"implementation."
msgstr ""
"Исчерпана пользовательская квота на ресурсы файловой системы. Ресурсами "
"могут быть иноды или дисковые блоки, в зависимости от реализации файловой "
"системы."

#. type: Plain text
#: man-pages/man2/symlink.2:165
msgid "I<linkpath> already exists."
msgstr "I<linkpath> уже существует."

#. type: Plain text
#: man-pages/man2/symlink.2:168
msgid "I<target> or I<linkpath> points outside your accessible address space."
msgstr ""
"Значение I<target> или I<linkpath> указывают за пределы доступного адресного "
"пространства."

#. type: Plain text
#: man-pages/man2/symlink.2:171
msgid "An I/O error occurred."
msgstr "Произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/symlink.2:171
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/symlink.2:175
msgid "Too many symbolic links were encountered in resolving I<linkpath>."
msgstr ""
"Во время определения I<linkpath> встретилось слишком много символьных ссылок."

#. type: TP
#: man-pages/man2/symlink.2:175
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/symlink.2:178
msgid "I<target> or I<linkpath> was too long."
msgstr "Слишком длинное значение аргумента I<target> или I<linkpath>."

#. type: Plain text
#: man-pages/man2/symlink.2:187
msgid ""
"A directory component in I<linkpath> does not exist or is a dangling "
"symbolic link, or I<target> or I<linkpath> is an empty string."
msgstr ""
"Компонент пути I<linkpath> не существует или является повисшей символьной "
"ссылкой или значение I<target> или I<linkpath> равно пустой строке."

#. type: Plain text
#: man-pages/man2/symlink.2:190
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: Plain text
#: man-pages/man2/symlink.2:194
msgid "The device containing the file has no room for the new directory entry."
msgstr ""
"На устройстве, содержащем файл, нет места для создания нового элемента "
"каталога."

#. type: Plain text
#: man-pages/man2/symlink.2:199
msgid ""
"A component used as a directory in I<linkpath> is not, in fact, a directory."
msgstr ""
"Компонент пути, использованный как каталог в I<linkpath>, в действительности "
"таковым не является."

#. type: Plain text
#: man-pages/man2/symlink.2:204
msgid ""
"The filesystem containing I<linkpath> does not support the creation of "
"symbolic links."
msgstr ""
"Файловая система, содержащая I<linkpath>, не поддерживает создание "
"символьных ссылок."

#. type: Plain text
#: man-pages/man2/symlink.2:208
msgid "I<linkpath> is on a read-only filesystem."
msgstr ""
"I<linkpath> расположен в файловой системе, доступной только для чтения."

#. type: Plain text
#: man-pages/man2/symlink.2:211
msgid "The following additional errors can occur for B<symlinkat>():"
msgstr "В B<symlinkat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/symlink.2:215
msgid "I<newdirfd> is not a valid file descriptor."
msgstr "Значение I<newdirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/symlink.2:221
msgid ""
"I<linkpath> is a relative pathname and I<newdirfd> refers to a directory "
"that has been deleted."
msgstr ""
"Значение I<linkpath> является относительным путём и I<newdirfd> ссылается на "
"каталог, который был удалён."

#. type: Plain text
#: man-pages/man2/symlink.2:227
msgid ""
"I<linkpath> is relative and I<newdirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<linkpath> содержит относительный путь и I<newdirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/symlink.2:231
msgid ""
"B<symlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Системный вызов B<symlinkat>() был добавлен в ядро Linux версии 2.6.16; "
"поддержка в glibc доступна с версии 2.4."

#.  SVr4 documents additional error codes EDQUOT and ENOSYS.
#.  See
#.  .BR open (2)
#.  re multiple files with the same name, and NFS.
#. type: Plain text
#: man-pages/man2/symlink.2:238
msgid "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/symlink.2:241
msgid "B<symlinkat>(): POSIX.1-2008."
msgstr "B<symlinkat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/symlink.2:245
msgid "No checking of I<target> is done."
msgstr "Не выполняется проверка I<target>."

#. type: Plain text
#: man-pages/man2/symlink.2:250
msgid ""
"Deleting the name referred to by a symbolic link will actually delete the "
"file (unless it also has other hard links).  If this behavior is not "
"desired, use B<link>(2)."
msgstr ""
"При удаление имени, на который ссылается символьная ссылка, произойдёт "
"удаление файла (если только у него нет других жёстких ссылок). Если такое "
"поведение нежелательно, используйте B<link>(2)."

#. type: SS
#: man-pages/man2/symlink.2:250
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#. type: Plain text
#: man-pages/man2/symlink.2:263
msgid ""
"On older kernels where B<symlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<symlink>().  When I<linkpath> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<newdirfd> argument."
msgstr ""
"В старых ядрах, где B<symlinkat>() отсутствует, обёрточная функция glibc "
"использует B<symlink>(). Если I<linkpath> является относительным путём, то "
"glibc собирает путь относительно символической ссылки в I</proc/self/fd>, "
"которая соответствует аргументу I<newdirfd>."

#. type: Plain text
#: man-pages/man2/symlink.2:274
msgid ""
"B<ln>(1), B<namei>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), "
"B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""
"B<ln>(1), B<namei>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), "
"B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"

#. type: TH
#: man-pages/man2/socketpair.2:42
#, no-wrap
msgid "SOCKETPAIR"
msgstr "SOCKETPAIR"

#. type: Plain text
#: man-pages/man2/socketpair.2:45
msgid "socketpair - create a pair of connected sockets"
msgstr "socketpair - создает пару присоединённых сокетов"

#. type: Plain text
#: man-pages/man2/socketpair.2:52
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"

#. type: Plain text
#: man-pages/man2/socketpair.2:63
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr ""
"Вызов B<socketpair>() создает пару неименованых присоединённых сокетов в "
"заданном домене  I<domain> заданного типа I<type>, используя (при "
"необходимости) заданный протокол I<protocol>. Подробнее об этих аргументах "
"можно узнать в B<socket>(2)."

#. type: Plain text
#: man-pages/man2/socketpair.2:69
msgid ""
"The file descriptors used in referencing the new sockets are returned in "
"I<sv>[0] and I<sv>[1].  The two sockets are indistinguishable."
msgstr ""
"Файловые дескрипторы, используемые как ссылки на новые сокеты, возвращаются "
"в I<sv>[0] и I<sv>[1]. Никаких различий между этими двумя сокетами нет."

#. type: Plain text
#: man-pages/man2/socketpair.2:76
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<sv> is left unchanged"
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, "
"I<errno> устанавливается в соответствующее значение, а I<sv> не изменяется."

#.  http://austingroupbugs.net/view.php?id=483
#. type: Plain text
#: man-pages/man2/socketpair.2:84
msgid ""
"On Linux (and other systems), B<socketpair>()  does not modify I<sv> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2016."
msgstr ""
"В Linux (и других системах) B<socketpair>() не изменяет I<sv> при ошибке. "
"Требование стандартизации этого поведения было добавлено в POSIX.1-2016."

#. type: Plain text
#: man-pages/man2/socketpair.2:88
msgid "The specified address family is not supported on this machine."
msgstr "Заданное семейство адресов не поддерживается в этой машине. "

#. type: Plain text
#: man-pages/man2/socketpair.2:93
msgid ""
"The address I<sv> does not specify a valid part of the process address space."
msgstr "Адрес I<sv> не ссылается на адресное пространство процесса. "

#. type: Plain text
#: man-pages/man2/socketpair.2:102
msgid "The specified protocol does not support creation of socket pairs."
msgstr "Заданный протокол не поддерживает создание пар сокетов. "

#. type: Plain text
#: man-pages/man2/socketpair.2:105
msgid "The specified protocol is not supported on this machine."
msgstr "Заданный протокол не поддерживается на этой машине."

#. type: Plain text
#: man-pages/man2/socketpair.2:112
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD.  B<socketpair>()  first appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System\\ V variants)."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD. Вызов B<socketpair>() впервые появился в "
"4.2BSD. Обычно он переносим в/из не-BSD систем на уровне сокетов BSD "
"(включая варианты System\\ V)."

#.  commit: 70b03759e9ecfae400605fa34f3d7154cccbbba3
#. type: Plain text
#: man-pages/man2/socketpair.2:121
msgid ""
"On Linux, the only supported domains for this call are B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>)  and B<AF_TIPC> (since Linux 4.12)."
msgstr ""
"В Linux единственными поддерживаемыми доменами для этого вызова являются "
"B<AF_UNIX> (или его синоним B<AF_LOCAL>) и B<AF_TIPC> (начиная с Linux 4.12)."

#. type: Plain text
#: man-pages/man2/socketpair.2:132
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags in the I<type> argument, as described in B<socket>(2)."
msgstr ""
"Начиная с Linux 2.6.27, в аргументе I<type> вызова B<socketpair>() "
"поддерживаются флаги B<SOCK_NONBLOCK> и B<SOCK_CLOEXEC>, описанные в "
"B<socket>(2)."

#. type: Plain text
#: man-pages/man2/socketpair.2:144
msgid ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/set_tid_address.2:25
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr "SET_TID_ADDRESS"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:28
msgid "set_tid_address - set pointer to thread ID"
msgstr "set_tid_address - устанавливает указатель идентификатора нити"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:33
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr "B<long set_tid_address(int *>I<tidptr>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:43
msgid ""
"For each thread, the kernel maintains two attributes (addresses) called "
"I<set_child_tid> and I<clear_child_tid>.  These two attributes contain the "
"value NULL by default."
msgstr ""
"В ядре для каждой нити хранится два атрибута (адреса): I<set_child_tid> и "
"I<clear_child_tid>. Их значение по умолчанию равно NULL."

#. type: TP
#: man-pages/man2/set_tid_address.2:43
#, no-wrap
msgid "I<set_child_tid>"
msgstr "I<set_child_tid>"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:54
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to the value passed in the I<ctid> argument of "
"that system call."
msgstr ""
"Если нить запущена с помощью B<clone>(2) с флагом B<CLONE_CHILD_SETTID>, то "
"значение I<set_child_tid> устанавливается равным аргументу системного вызова "
"I<ctid>."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:59
msgid ""
"When I<set_child_tid> is set, the very first thing the new thread does is to "
"write its thread ID at this address."
msgstr ""
"Если I<set_child_tid> присвоено значение, то самое первое действие, которое "
"выполняется для новой нити, это запись ID нити по этому адресу."

#. type: TP
#: man-pages/man2/set_tid_address.2:59
#, no-wrap
msgid "I<clear_child_tid>"
msgstr "I<clear_child_tid>"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:70
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to the value passed in the I<ctid> argument "
"of that system call."
msgstr ""
"Если нить запущена с помощью B<clone>(2) с флагом B<CLONE_CHILD_CLEARTID>, "
"то значение I<clear_child_tid> устанавливается равным аргументу системного "
"вызова I<ctid>."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:77
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling thread to I<tidptr>."
msgstr ""
"Системный вызов B<set_tid_address>() устанавливает у вызывающей нити "
"значение I<clear_child_tid> равным I<tidptr>."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:85
msgid ""
"When a thread whose I<clear_child_tid> is not NULL terminates, then, if the "
"thread is sharing memory with other threads, then 0 is written at the "
"address specified in I<clear_child_tid> and the kernel performs the "
"following operation:"
msgstr ""
"Если нить, чьё значение I<clear_child_tid> не равно NULL, завершается и если "
"нить использовала общую память с другими нитями, то по адресу, указанному в "
"I<clear_child_tid>, записывается 0 и ядро выполняет следующую операцию:"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:87
#, no-wrap
msgid "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
msgstr "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:91
msgid ""
"The effect of this operation is to wake a single thread that is performing a "
"futex wait on the memory location.  Errors from the futex wake operation are "
"ignored."
msgstr ""
"Действие этой операции в том, что она пробуждает единственную нить, "
"выполнявшую ожидание futex на расположение памяти. Ошибки операции "
"пробуждения futex игнорируются."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:94
msgid "B<set_tid_address>()  always returns the caller's thread ID."
msgstr "Вызов B<set_tid_address>() всегда возвращает ID вызывающей нити."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:97
msgid "B<set_tid_address>()  always succeeds."
msgstr "Вызов B<set_tid_address>() всегда завершается без ошибок."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:100
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""
"Данный вызов появился в Linux 2.5.48. Представленное здесь описание "
"соответствует вызову, начиная с Linux 2.5.49."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:102
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:105
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:108
msgid "B<clone>(2), B<futex>(2), B<gettid>(2)"
msgstr "B<clone>(2), B<futex>(2), B<gettid>(2)"

#. type: TH
#: man-pages/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr "SCHED_GET_PRIORITY_MAX"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:32
msgid ""
"sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""
"sched_get_priority_max, sched_get_priority_min - возвращают статический "
"диапазон приоритетов"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_max(int >I<policy>B<);>"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_min(int >I<policy>B<);>"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:59
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, "
"B<SCHED_BATCH>, B<SCHED_IDLE>, and B<SCHED_DEADLINE>.  Further details about "
"these policies can be found in B<sched>(7)."
msgstr ""
"Вызов B<sched_get_priority_max>() возвращает максимальное значение "
"приоритета, которое может использоваться с алгоритмом планирования, "
"указанного в I<policy>. Вызов B<sched_get_priority_min>() возвращает "
"минимальное значение приоритета, которое может использоваться с алгоритмом "
"планирования, указанного в I<policy>. Поддерживаемые значения для I<policy>: "
"B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, B<SCHED_BATCH>, B<SCHED_IDLE> и "
"B<SCHED_DEADLINE>. Подробней об этих политиках смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:68
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""
"Процессы с большим числовым значением приоритета планируются к выполнению "
"раньше процессов с меньшим числовым значением приоритета. То есть значение, "
"возвращаемое B<sched_get_priority_max>(), будет больше значения, "
"возвращаемого B<sched_get_priority_min>()."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:76
msgid ""
"Linux allows the static priority range 1 to 99 for the B<SCHED_FIFO> and "
"B<SCHED_RR> policies, and the priority 0 for the remaining policies.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""
"В Linux допускаются статические приоритеты в диапазоне от 1 до 99 для "
"политик B<SCHED_FIFO> и B<SCHED_RR> и приоритет 0 для для остальных политик. "
"Диапазоны планируемых приоритетов для различных политик назначить нельзя."

#.  POSIX.1-2001, POSIX.1-2008 (XBD 2.8.4)
#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:89
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min> POSIX.1 requires a spread of at least 32 between "
"the maximum and the minimum values for B<SCHED_FIFO> and B<SCHED_RR>."
msgstr ""
"В разных системах POSIX диапазон планируемых приоритетов может различаться, "
"то есть переносимое приложение должно использовать диапазон виртуальных "
"приоритетов и отображать его в интервал, получаемый с помощью "
"B<sched_get_priority_max>() и B<sched_get_priority_min>(). Согласно POSIX.1 "
"между максимальным и минимальным значениями для B<SCHED_FIFO> и B<SCHED_RR> "
"требуется диапазон из не менее 32 значений."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:98
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"В системах POSIX, имеющих B<sched_get_priority_max>() и "
"B<sched_get_priority_min>(), определено значение для "
"B<_POSIX_PRIORITY_SCHEDULING> в I<E<lt>unistd.hE<gt>>."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:108
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sched_get_priority_max>() и "
"B<sched_get_priority_min>() возвращают максимальное/минимальное значение "
"приоритета для указанной политики планирования. В случае ошибки возвращается "
"-1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:114
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr ""
"Аргумент I<policy> не содержит допустимого значения политики планирования."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:125
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"
msgstr ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"

#. type: TH
#: man-pages/man2/setfsgid.2:32
#, no-wrap
msgid "SETFSGID"
msgstr "SETFSGID"

#. type: Plain text
#: man-pages/man2/setfsgid.2:35
msgid "setfsgid - set group identity used for filesystem checks"
msgstr ""
"setfsgid - устанавливает идентификатор группы для доступа к файловой системе"

#. type: Plain text
#: man-pages/man2/setfsgid.2:39
msgid "B<int setfsgid(uid_t >I<fsgid>B<);>"
msgstr "B<int setfsgid(uid_t >I<fsgid>B<);>"

#. type: Plain text
#: man-pages/man2/setfsgid.2:46
msgid ""
"On Linux, a process has both a filesystem group ID and an effective group "
"ID.  The (Linux-specific) filesystem group ID is used for permissions "
"checking when accessing filesystem objects, while the effective group ID is "
"used for some other kinds of permissions checks (see B<credentials>(7))."
msgstr ""
"В Linux у процесса есть идентификатор группы файловой системы и эффективный "
"(effective) идентификатор группы. Идентификатор группы файловой системы "
"(есть только в Linux) используется при проверки прав доступа к объектам "
"файловой системы, а эффективный идентификатор группы используется для "
"проверки прав доступа к другим различным объектам (смотрите "
"B<credentials>(7))."

#. type: Plain text
#: man-pages/man2/setfsgid.2:57
msgid ""
"Normally, the value of the process's filesystem group ID is the same as the "
"value of its effective group ID.  This is so, because whenever a process's "
"effective group ID is changed, the kernel also changes the filesystem group "
"ID to be the same as the new value of the effective group ID.  A process can "
"cause the value of its filesystem group ID to diverge from its effective "
"group ID by using B<setfsgid>()  to change its filesystem group ID to the "
"value given in I<fsgid>."
msgstr ""
"Обычно, значение идентификатора группы файловой системы процесса совпадает "
"со значением эффективного идентификатора группы. Более того, при изменении "
"идентификатора эффективного идентификатора группы ядро также изменяет и "
"идентификатор группы файловой системы на новое значение идентификатора "
"эффективного идентификатора группы.Процесс может изменить значение своего "
"идентификатора группы файловой системы на отличное от эффективного "
"идентификатора группы с помощью B<setfsgid>() указав его в параметре "
"I<fsgid>."

#. type: Plain text
#: man-pages/man2/setfsgid.2:63
msgid ""
"B<setfsgid>()  will succeed only if the caller is the superuser or if "
"I<fsgid> matches either the caller's real group ID, effective group ID, "
"saved set-group-ID, or current the filesystem user ID."
msgstr ""
"Вызов B<setfsgid>() выполняется корректно, только если он был вызван "
"суперпользователем или, если I<fsgid> совпадает с идентификатором "
"действительной, эффективной и сохранённой группы или равен текущему значению "
"идентификатора пользователя файловой системы вызывающего."

#. type: Plain text
#: man-pages/man2/setfsgid.2:66
msgid ""
"On both success and failure, this call returns the previous filesystem group "
"ID of the caller."
msgstr ""
"При успешном выполнении или при ошибке данный вызов возвращает предыдущий "
"идентификатор группы файловой системы вызвавшего."

#. type: Plain text
#: man-pages/man2/setfsgid.2:74
msgid ""
"B<setfsgid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"Вызов B<setfsgid>() есть только в Linux и не должен использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man2/setfsgid.2:86
msgid ""
"The filesystem group ID concept and the B<setfsgid>()  system call were "
"invented for historical reasons that are no longer applicable on modern "
"Linux kernels.  See B<setfsuid>(2)  for a discussion of why the use of both "
"B<setfsuid>(2)  and B<setfsgid>()  is nowadays unneeded."
msgstr ""
"Понятие идентификатора группы файловой системы и системный вызов "
"B<setfsgid>() были изобретены по историческим причинам, которые больше не "
"применимы к современным ядрам Linux. Смотрите в описании B<setfsuid>(2) "
"почему в использовании B<setfsuid>(2) и B<setfsgid>() теперь нет "
"необходимости."

#. type: Plain text
#: man-pages/man2/setfsgid.2:96
msgid ""
"The original Linux B<setfsgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setfsgid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"Первоначальная версия системного вызова Linux B<setfsgid>() поддерживала "
"только 16-битные идентификаторы групп. Позднее в Linux 2.4 был добавлен "
"B<setfsgid32>(), поддерживающий 32-битные идентификаторы. Обёрточная функция "
"glibc B<setfsgid>() скрывает это различие в версиях ядер."

#. type: Plain text
#: man-pages/man2/setfsgid.2:105
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit group IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""
"В glibc 2.15 и старее, если обёрточная функция этого системного вызова "
"определяет, что аргумент невозможно передать ядру без обрезания целого (так "
"как ядро старое и не поддерживает 32-битные ID группы), то она возвращает -1 "
"и присваивает I<errno> значение B<EINVAL> не пытаясь выполнить системный "
"вызов."

#. type: Plain text
#: man-pages/man2/setfsgid.2:122
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsgid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsgid>()  changed the filesystem group "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETGID> capability)."
msgstr ""
"Вызывающему не возвращается никаких ошибок, и факт того, что успешном или не "
"успешном выполнении возвращается одинаковое значение, делает невозможным "
"напрямую определить как завершился вызов. Вместо этого, вызывающий должен "
"получить значение из ещё одного вызова — I<setfsgid(-1)> (который всегда "
"завершается с ошибкой), чтобы определить, изменил ли предыдущий вызов "
"B<setfsgid>() идентификатор группы файловой системы. По крайней мере, должно "
"быть получено значение B<EPERM>, если вызов завершится с ошибкой (так как у "
"вызывающего нет мандата B<CAP_SETGID>)."

#. type: Plain text
#: man-pages/man2/setfsgid.2:126
msgid "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/stat.2:40
#, no-wrap
msgid "STAT"
msgstr "STAT"

#. type: Plain text
#: man-pages/man2/stat.2:43
msgid "stat, fstat, lstat, fstatat - get file status"
msgstr "stat, fstat, lstat, fstatat - считывает состояние файла"

#. type: Plain text
#: man-pages/man2/stat.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/stat.2:52
#, no-wrap
msgid ""
"B<int stat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
"B<int fstat(int >I<fd>B<, struct stat *>I<statbuf>B<);>\n"
"B<int lstat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
msgstr ""
"B<int stat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
"B<int fstat(int >I<fd>B<, struct stat *>I<statbuf>B<);>\n"
"B<int lstat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"

#. type: Plain text
#: man-pages/man2/stat.2:55
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант AT_* */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/stat.2:59
#, no-wrap
msgid ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat *>I<statbuf>B<,>\n"
"B<            int >I<flags>B<);>\n"
msgstr ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat *>I<statbuf>B<,>\n"
"B<            int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/stat.2:68
msgid "B<lstat>():"
msgstr "B<lstat>():"

#. type: Plain text
#: man-pages/man2/stat.2:70
msgid "/* glibc 2.19 and earlier */ _BSD_SOURCE"
msgstr "/* glibc 2.19 и старее */ _BSD_SOURCE"

#. type: Plain text
#: man-pages/man2/stat.2:72
#, no-wrap
msgid "    || /* Since glibc 2.20 */ _DEFAULT_SOURCE\n"
msgstr "    || /* начиная с glibc 2.20 */ _DEFAULT_SOURCE\n"

#.    _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/stat.2:75
#, no-wrap
msgid "    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr "    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"

#. type: Plain text
#: man-pages/man2/stat.2:77
#, no-wrap
msgid "    || /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr "    || /* начиная с glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"

#. type: Plain text
#: man-pages/man2/stat.2:80
msgid "B<fstatat>():"
msgstr "B<fstatat>():"

#. type: Plain text
#: man-pages/man2/stat.2:104
msgid ""
"These functions return information about a file, in the buffer pointed to by "
"I<statbuf>.  No permissions are required on the file itself, but\\(emin the "
"case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
"permission is required on all of the directories in I<pathname> that lead to "
"the file."
msgstr ""
"Данные системные вызовы возвращают информацию о файле в буфер, на который "
"указывает I<statbuf>. Для этого не требуется иметь права доступа к самому "
"файлу, но — в случае B<stat>(), B<fstatat>() и B<lstat>() — потребуются "
"права выполнения (поиска) на все каталоги, указанные в полном имени файла "
"I<pathname>."

#. type: Plain text
#: man-pages/man2/stat.2:113
msgid ""
"B<stat>()  and B<fstatat>()  retrieve information about the file pointed to "
"by I<pathname>; the differences for B<fstatat>()  are described below."
msgstr ""
"Вызовы B<stat>() и B<fstatat>() возвращают информацию о файле, указанном в "
"I<pathname>; различия с B<fstatat>() описаны далее."

#. type: Plain text
#: man-pages/man2/stat.2:121
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
"symbolic link, then it returns information about the link itself, not the "
"file that it refers to."
msgstr ""
"Вызов B<lstat>() идентичен B<stat>(), но в случае, если I<pathname> является "
"символьной ссылкой, то возвращается информация о самой ссылке, а не о файле, "
"на который она указывает."

#. type: Plain text
#: man-pages/man2/stat.2:129
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file about which "
"information is to be retrieved is specified by the file descriptor I<fd>."
msgstr ""
"Вызов B<fstat>() идентичен B<stat>(), но опрашиваемый файл задаётся в виде "
"файлового дескриптора I<fd>."

#. type: SS
#: man-pages/man2/stat.2:129
#, no-wrap
msgid "The stat structure"
msgstr "Структура stat"

#. type: Plain text
#: man-pages/man2/stat.2:133
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr ""
"Все эти системные вызовы возвращают структуру I<stat>, которая содержит "
"следующие поля:"

#. type: Plain text
#: man-pages/man2/stat.2:147
#, no-wrap
msgid ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID of device containing file */\n"
"    ino_t     st_ino;         /* Inode number */\n"
"    mode_t    st_mode;        /* File type and mode */\n"
"    nlink_t   st_nlink;       /* Number of hard links */\n"
"    uid_t     st_uid;         /* User ID of owner */\n"
"    gid_t     st_gid;         /* Group ID of owner */\n"
"    dev_t     st_rdev;        /* Device ID (if special file) */\n"
"    off_t     st_size;        /* Total size, in bytes */\n"
"    blksize_t st_blksize;     /* Block size for filesystem I/O */\n"
"    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */\n"
msgstr ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID устройства с файлом */\n"
"    ino_t     st_ino;         /* номер иноды */\n"
"    mode_t    st_mode;        /* тип файла и режим доступа */\n"
"    nlink_t   st_nlink;       /* количество жёстких ссылок */\n"
"    uid_t     st_uid;         /* идентификатор пользователя-владельца */\n"
"    gid_t     st_gid;         /* идентификатор группы-владельца */\n"
"    dev_t     st_rdev;        /* идентификатор устройства\n"
"                                 (для специального файла) */\n"
"    off_t     st_size;        /* общий размер в байтах */\n"
"    blksize_t st_blksize;     /* размер блока ввода-вывода файловой системы */\n"
"    blkcnt_t  st_blocks;      /* количество выделенных 512Б блоков */\n"

#. type: Plain text
#: man-pages/man2/stat.2:151
#, no-wrap
msgid ""
"    /* Since Linux 2.6, the kernel supports nanosecond\n"
"       precision for the following timestamp fields.\n"
"       For the details before Linux 2.6, see NOTES. */\n"
msgstr ""
"    /* Начиная с Linux 2.6, ядро поддерживает точность до\n"
"       наносекунд в следующих полям меток времени.\n"
"       Подробней о версиях до Linux 2.6, смотрите ЗАМЕЧАНИЯ. */\n"

#. type: Plain text
#: man-pages/man2/stat.2:155
#, no-wrap
msgid ""
"    struct timespec st_atim;  /* Time of last access */\n"
"    struct timespec st_mtim;  /* Time of last modification */\n"
"    struct timespec st_ctim;  /* Time of last status change */\n"
msgstr ""
"    struct timespec st_atim;  /* время последнего доступа */\n"
"    struct timespec st_mtim;  /* время последнего изменения */\n"
"    struct timespec st_ctim;  /* время последней смены состояния */\n"

#. type: Plain text
#: man-pages/man2/stat.2:160
#, no-wrap
msgid ""
"#define st_atime st_atim.tv_sec      /* Backward compatibility */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"
msgstr ""
"#define st_atime st_atim.tv_sec      /* для обратной совместимости */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"

#. type: Plain text
#: man-pages/man2/stat.2:173
msgid ""
"I<Note>: the order of fields in the I<stat> structure varies somewhat across "
"architectures.  In addition, the definition above does not show the padding "
"bytes that may be present between some fields on various architectures.  "
"Consult the glibc and kernel source code if you need to know the details."
msgstr ""
"I<Замечание>: порядок полей структуры I<stat> для разных архитектур "
"отличается. Также, в определении выше не показаны дополняющие байты, которые "
"для различных архитектур могут присутствовать между некоторыми полями Если "
"необходимы подробности, то посмотрите исходный код glibc и ядра."

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: man-pages/man2/stat.2:198
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<stat> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<st_mode> or "
"I<st_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<st_mode> together with the "
"new I<st_uid>, or the old I<st_uid> together with the new I<st_mode>."
msgstr ""
"I<Замечание>: Для простоты и производительности различные поля структуры "
"I<stat> могут содержать информацию о состоянии из разных моментов работы "
"системного вызова. Например, если I<st_mode> или I<st_uid> изменились другим "
"процессом с помощью вызова B<chmod>(2) или B<chown>(2), то B<stat>() может "
"вернуть старое значение I<st_mode> вместе с новым I<st_uid>, или старое "
"значение I<st_uid> вместе с новым I<st_mode>."

#. type: Plain text
#: man-pages/man2/stat.2:202
msgid "The fields in the I<stat> structure are as follows:"
msgstr "Поля структуры I<stat>:"

#. type: TP
#: man-pages/man2/stat.2:202
#, no-wrap
msgid "I<st_dev>"
msgstr "I<st_dev>"

#. type: Plain text
#: man-pages/man2/stat.2:210
msgid ""
"This field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr ""
"Устройство, на котором расположен файл (для разбора идентификатора этого "
"поля могут пригодиться макросы B<major>(3) и B<minor>(3))."

#. type: TP
#: man-pages/man2/stat.2:210
#, no-wrap
msgid "I<st_ino>"
msgstr "I<st_ino>"

#. type: Plain text
#: man-pages/man2/stat.2:213
msgid "This field contains the file's inode number."
msgstr "Номер иноды файла."

#. type: TP
#: man-pages/man2/stat.2:213
#, no-wrap
msgid "I<st_mode>"
msgstr "I<st_mode>"

#. type: Plain text
#: man-pages/man2/stat.2:219
msgid ""
"This field contains the file type and mode.  See B<inode>(7)  for further "
"information."
msgstr ""
"Тип файла и режим доступа. Дополнительную информацию смотрите в B<inode>(7)."

#. type: TP
#: man-pages/man2/stat.2:219
#, no-wrap
msgid "I<st_nlink>"
msgstr "I<st_nlink>"

#. type: Plain text
#: man-pages/man2/stat.2:222
msgid "This field contains the number of hard links to the file."
msgstr "Количество жёстких ссылок на файл."

#. type: TP
#: man-pages/man2/stat.2:222
#, no-wrap
msgid "I<st_uid>"
msgstr "I<st_uid>"

#. type: Plain text
#: man-pages/man2/stat.2:225
msgid "This field contains the user ID of the owner of the file."
msgstr "Пользовательский идентификатор владельца файла."

#. type: TP
#: man-pages/man2/stat.2:225
#, no-wrap
msgid "I<st_gid>"
msgstr "I<st_gid>"

#. type: Plain text
#: man-pages/man2/stat.2:228
msgid "This field contains the ID of the group owner of the file."
msgstr "Групповой идентификатор владельца файла."

#. type: TP
#: man-pages/man2/stat.2:228
#, no-wrap
msgid "I<st_rdev>"
msgstr "I<st_rdev>"

#. type: Plain text
#: man-pages/man2/stat.2:231
msgid "This field describes the device that this file (inode) represents."
msgstr "Устройство, который этот файл (инода) представляет."

#. type: TP
#: man-pages/man2/stat.2:231
#, no-wrap
msgid "I<st_size>"
msgstr "I<st_size>"

#. type: Plain text
#: man-pages/man2/stat.2:237
msgid ""
"This field gives the size of the file (if it is a regular file or a symbolic "
"link) in bytes.  The size of a symbolic link is the length of the pathname "
"it contains, without a terminating null byte."
msgstr ""
"Размер файла (если он обычный или является символьной ссылкой) в байтах. "
"Размер символьной ссылки равен длине пути файла, на который она ссылается, "
"без конечного нулевого байта."

#. type: TP
#: man-pages/man2/stat.2:237
#, no-wrap
msgid "I<st_blksize>"
msgstr "I<st_blksize>"

#. type: Plain text
#: man-pages/man2/stat.2:240
msgid ""
"This field gives the \"preferred\" block size for efficient filesystem I/O."
msgstr ""
"«Предпочтительный» размер блока для эффективного ввода/вывода в файловой "
"системе."

#. type: TP
#: man-pages/man2/stat.2:240
#, no-wrap
msgid "I<st_blocks>"
msgstr "I<st_blocks>"

#. type: Plain text
#: man-pages/man2/stat.2:247
msgid ""
"This field indicates the number of blocks allocated to the file, in 512-byte "
"units.  (This may be smaller than I<st_size>/512 when the file has holes.)"
msgstr ""
"Количество блоков (по 512 байт), выделенных для файла (может быть меньше, "
"чем I<st_size>/512, когда в файле есть пропуски (holes))."

#. type: TP
#: man-pages/man2/stat.2:247
#, no-wrap
msgid "I<st_atime>"
msgstr "I<st_atime>"

#. type: Plain text
#: man-pages/man2/stat.2:250
msgid "This is the file's last access timestamp."
msgstr "Метка времени последнего доступа к файлу."

#. type: TP
#: man-pages/man2/stat.2:250
#, no-wrap
msgid "I<st_mtime>"
msgstr "I<st_mtime>"

#. type: Plain text
#: man-pages/man2/stat.2:253
msgid "This is the file's last modification timestamp."
msgstr "Метка времени последнего изменения файла."

#. type: TP
#: man-pages/man2/stat.2:253
#, no-wrap
msgid "I<st_ctime>"
msgstr "I<st_ctime>"

#. type: Plain text
#: man-pages/man2/stat.2:256
msgid "This is the file's last status change timestamp."
msgstr "Метка времени последнего изменения состояния файла."

#. type: Plain text
#: man-pages/man2/stat.2:260
msgid "For further information on the above fields, see B<inode>(7)."
msgstr "Дополнительную информацию об этих полях смотрите в B<inode>(7)."

#. type: SS
#: man-pages/man2/stat.2:260
#, no-wrap
msgid "fstatat()"
msgstr "fstatat()"

#. type: Plain text
#: man-pages/man2/stat.2:269
msgid ""
"The B<fstatat>()  system call is a more general interface for accessing file "
"information which can still provide exactly the behavior of each of "
"B<stat>(), B<lstat>(), and B<fstat>()."
msgstr ""
"Системный вызов B<fstatat>() представляет собой обобщённый интерфейс доступа "
"к файловой информации, и может выполнить работу за B<stat>(), B<lstat>() и "
"B<fstat>()."

#. type: Plain text
#: man-pages/man2/stat.2:281
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<stat>()  and B<lstat>()  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<stat>() и B<lstat>())."

#. type: Plain text
#: man-pages/man2/stat.2:295
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<stat>()  and B<lstat>())."
msgstr ""
"Если в I<pathname> задан относительный путь и значение I<dirfd> равно "
"B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего рабочего "
"каталога вызывающего процесса (как B<stat>() и B<lstat>())."

#. type: Plain text
#: man-pages/man2/stat.2:301
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/stat.2:304
msgid ""
"I<flags> can either be 0, or include one or more of the following flags ORed:"
msgstr ""
"Значение I<flags> может быть 0, или включать один или более следующих флагов:"

#. type: TP
#: man-pages/man2/stat.2:304
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr "B<AT_EMPTY_PATH> (начиная с Linux 2.6.39)"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/stat.2:331
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory, and the behavior of B<fstatat>()  is similar to that of "
"B<fstat>().  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
"working directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
"obtain its definition."
msgstr ""
"Если значение I<pathname> равно пустой строке, то выполнять действие над "
"файлом, на который указывает I<dirfd> (который может быть получен с помощью "
"B<open>(2) с флагом B<O_PATH>). В этом случае I<dirfd> может указывать на "
"файл любого типа, а не только на каталог и поведение B<fstatat>() подобно "
"B<fstat>(). Если I<dirfd> равно B<AT_FDCWD>, то вызов выполняет действие над "
"текущим рабочим каталогом. Этот флаг есть только в Linux; для получения его "
"определения определите B<_GNU_SOURCE>."

#. type: TP
#: man-pages/man2/stat.2:331
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT> (since Linux 2.6.38)"
msgstr "B<AT_NO_AUTOMOUNT> (начиная с Linux 2.6.38)"

#.  commit 42f46148217865a545e129612075f3d828a2c4e4
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/stat.2:358
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand "
"directory such as used for automounter indirect maps.  This flag can be used "
"in tools that scan directories to prevent mass-automounting of a directory "
"of automount points.  The B<AT_NO_AUTOMOUNT> flag has no effect if the mount "
"point has already been mounted over.  This flag is Linux-specific; define "
"B<_GNU_SOURCE> to obtain its definition.  Both B<stat>()  and B<lstat>()  "
"act as though B<AT_NO_AUTOMOUNT> was set."
msgstr ""
"Не выполнять автоматическое монтирование конечного компонента («basename») "
"I<pathname>, если этот каталог является точкой автоматического монтирования. "
"Это позволяет вызывающему получить атрибуты точки автоматического "
"монтирования (а не расположения, где её предполагалось смонтировать). "
"Начиная с  Linux 4.14, также не создаётся несуществующее имя в каталоге по "
"требованию, например в неявных картах автоматического монтировщика. Этот "
"флаг можно использовать в инструментах, сканирующих каталоги, для "
"предотвращения массового автоматического монтирования каталогов в их точки "
"автоматического монтирования. Флаг B<AT_NO_AUTOMOUNT> не учитывается, если к "
"точке уже была выполнено монтирование. Этот флаг есть только Linux; для его "
"получения нужно задать B<_GNU_SOURCE>. Вызовы B<stat>() и B<lstat>() "
"работают, как если бы был установлен флаг B<AT_NO_AUTOMOUNT>."

#. type: TP
#: man-pages/man2/stat.2:358
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: man-pages/man2/stat.2:369
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>().  (By default, "
"B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgstr ""
"Если значение I<pathname> является символьной ссылкой, не разыменовывать её, "
"а вернуть информацию о самой ссылке, как это делается в B<lstat>(). (По "
"умолчанию, B<fstatat>() разыменовывает символьные ссылки как и B<stat>().)"

#. type: Plain text
#: man-pages/man2/stat.2:374
msgid "See B<openat>(2)  for an explanation of the need for B<fstatat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<fstatat>()."

#. type: Plain text
#: man-pages/man2/stat.2:387
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<pathname>.  (See also B<path_resolution>(7).)"
msgstr ""
"Запрещён поиск в одном из каталогов пути I<pathname> (смотрите также "
"B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/stat.2:391
msgid "I<fd> is not a valid open file descriptor."
msgstr "Значение I<fd> не является правильным открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man2/stat.2:397
msgid "Too many symbolic links encountered while traversing the path."
msgstr "Во время определения пути встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/stat.2:401
msgid "I<pathname> is too long."
msgstr "Слишком длинное значение аргумента I<pathname>."

#. type: Plain text
#: man-pages/man2/stat.2:406
msgid ""
"A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr ""
"Компонент пути I<pathname> не существует или является повисшей символьной "
"ссылкой."

#. type: Plain text
#: man-pages/man2/stat.2:413
msgid ""
"I<pathname> is an empty string and B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""
"Значение I<pathname> равно пустой строке и в I<flags> не указано значение "
"B<AT_EMPTY_PATH>."

#. type: Plain text
#: man-pages/man2/stat.2:416
msgid "Out of memory (i.e., kernel memory)."
msgstr "Не хватает памяти (например, памяти ядра)."

#. type: Plain text
#: man-pages/man2/stat.2:421
msgid "A component of the path prefix of I<pathname> is not a directory."
msgstr "Компонент в префиксе пути I<pathname> не является каталогом."

#. type: Plain text
#: man-pages/man2/stat.2:440
msgid ""
"I<pathname> or I<fd> refers to a file whose size, inode number, or number of "
"blocks cannot be represented in, respectively, the types I<off_t>, I<ino_t>, "
"or I<blkcnt_t>.  This error can occur when, for example, an application "
"compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> calls "
"B<stat>()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr ""
"Значение I<pathname> или I<fd> ссылаются на файл, чей размер, номер inode "
"или количество блоков не может быть представлено с помощью типов I<off_t>, "
"I<ino_t> или I<blkcnt_t>, соответственно. Эта ошибка может возникнуть, если, "
"например, приложение собрано на 32-битной платформе без флага I<-"
"D_FILE_OFFSET_BITS=64> при вызове B<stat>() для файла, чей размер превышает "
"I<(1E<lt>E<lt>31)-1> байт."

#. type: Plain text
#: man-pages/man2/stat.2:443
msgid "The following additional errors can occur for B<fstatat>():"
msgstr "В B<fstatat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/stat.2:447
msgid "I<dirfd> is not a valid file descriptor."
msgstr "Значение I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/stat.2:451
msgid "Invalid flag specified in I<flags>."
msgstr "Указано неверное значение в I<flags>."

#. type: Plain text
#: man-pages/man2/stat.2:457
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/stat.2:461
msgid ""
"B<fstatat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"Вызов B<fstatat>() был добавлен в ядро Linux версии 2.6.16; поддержка в "
"glibc доступна с версии 2.4."

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: man-pages/man2/stat.2:474
msgid ""
"B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."
msgstr ""
"B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."

#. type: Plain text
#: man-pages/man2/stat.2:477
msgid "B<fstatat>(): POSIX.1-2008."
msgstr "B<fstatat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/stat.2:491
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file type of the I<st_mode> "
"field of the I<stat> structure.  POSIX.1-2008 tightens the specification, "
"requiring B<lstat>()  to return valid information in all fields except the "
"mode bits in I<st_mode>."
msgstr ""
"Согласно POSIX.1-2001, B<lstat>() для символьной ссылки требует вернуть "
"корректную информацию только в поле I<st_size> и в типе файла в поле "
"I<st_mode> структуры I<stat>. В POSIX.1-2008 более жёсткая спецификация, "
"требующая, чтобы B<lstat>() возвращал корректную информацию во всех полях "
"кроме битов режима в I<st_mode>."

#. type: Plain text
#: man-pages/man2/stat.2:500
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)"
msgstr ""
"Использование полей I<st_blocks> и I<st_blksize> может усложнить перенос на "
"другие платформы. (Эти поля появились из BSD. Их смысл различается в разных "
"системах и, вероятно, даже в одной системе при использовании NFS)."

#. type: SS
#: man-pages/man2/stat.2:501
#, no-wrap
msgid "Timestamp fields"
msgstr "Поля с отметками времени"

#. type: Plain text
#: man-pages/man2/stat.2:512
msgid ""
"Older kernels and older standards did not support nanosecond timestamp "
"fields.  Instead, there were three timestamp fields\\(emI<st_atime>, "
"I<st_mtime>, and I<st_ctime>\\(emtyped as I<time_t> that recorded timestamps "
"with one-second precision."
msgstr ""
"В старых ядрах и стандартах нет поддержки полей времени в наносекундах. "
"Вместо них есть три поря времени — I<st_atime>, I<st_mtime> и I<st_ctime> — "
"с типом I<time_t>, который имеет секундную точность."

#. type: Plain text
#: man-pages/man2/stat.2:537
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  The nanosecond components of each "
"timestamp are available via names of the form I<st_atim.tv_nsec>, if "
"suitable feature test macros are defined.  Nanosecond timestamps were "
"standardized in POSIX.1-2008, and, starting with version 2.12, glibc exposes "
"the nanosecond component names if B<_POSIX_C_SOURCE> is defined with the "
"value 200809L or greater, or B<_XOPEN_SOURCE> is defined with the value 700 "
"or greater.  Up to and including glibc 2.19, the definitions of the "
"nanoseconds components are also defined if B<_BSD_SOURCE> or B<_SVID_SOURCE> "
"is defined.  If none of the aforementioned macros are defined, then the "
"nanosecond values are exposed with names of the form I<st_atimensec>."
msgstr ""
"Начиная с ядра 2.5.48, в структуре I<stat> поддерживается наносекундная "
"точность для всех трёх полей времени. Наносекундные компоненты каждой метки "
"времени доступны под именами вида I<st_atim.tv_nsec>, если определён "
"подходящий макрос тестирования свойств. Наносекундные метки времени "
"стандартизованы в POSIX.1-2008, и, начиная с версии 2.12, в glibc также есть "
"поддержка имён наносекундных компонент, если определён B<_POSIX_C_SOURCE> со "
"значением 200809L или более, или B<_XOPEN_SOURCE> со значением 700 или "
"более. До glibc 2.19 включительно определения наносекундных компонент также "
"доступны, если определён B<_BSD_SOURCE> или B<_SVID_SOURCE>. Если ни один из "
"вышеупомянутых макросов не определён, то наносекундные значения доступны под "
"именами вида I<st_atimensec>."

#.  See include/asm-i386/stat.h in the Linux 2.4 source code for the
#.  various versions of the structure definitions
#. type: Plain text
#: man-pages/man2/stat.2:562
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (slot "
"I<__NR_stat64>)  on 32-bit platforms such as i386.  The first two versions "
"were already present in Linux 1.0 (albeit with different names); the last "
"was added in Linux 2.4.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr ""
"В течении долгого времени увеличение размера структуры I<stat> привело к "
"появлению трёх новых версий B<stat>(): I<sys_stat>() (слот I<__NR_oldstat>), "
"I<sys_newstat>() (слот I<__NR_stat>) и I<sys_stat64()> (слот I<__NR_stat64>) "
"на 32-битных платформах, например, i386. Первые две версии уже существовали "
"в Linux 1.0 (но под другими именами); последняя была добавлена в Linux 2.4. "
"Подобное замечание применимо к B<fstat>() и B<lstat>()."

#. type: Plain text
#: man-pages/man2/stat.2:566
msgid ""
"The kernel-internal versions of the I<stat> structure dealt with by the "
"different versions are, respectively:"
msgstr "Внутренние ядерные структуры I<stat> в разных версиях:"

#. type: TP
#: man-pages/man2/stat.2:566
#, no-wrap
msgid "I<__old_kernel_stat>"
msgstr "I<__old_kernel_stat>"

#. type: Plain text
#: man-pages/man2/stat.2:569
msgid "The original structure, with rather narrow fields, and no padding."
msgstr ""
"Самая первая версия структуры со слегка узкими полями и без заполнителей."

#. type: TP
#: man-pages/man2/stat.2:569
#, no-wrap
msgid "I<stat>"
msgstr "I<stat>"

#. type: Plain text
#: man-pages/man2/stat.2:575
msgid ""
"Larger I<st_ino> field and padding added to various parts of the structure "
"to allow for future expansion."
msgstr ""
"Увеличенное поле I<st_ino> и добавлены заполнители в различные части "
"структуры для расширения в дальнейшем."

#. type: TP
#: man-pages/man2/stat.2:575
#, no-wrap
msgid "I<stat64>"
msgstr "I<stat64>"

#. type: Plain text
#: man-pages/man2/stat.2:589
msgid ""
"Even larger I<st_ino> field, larger I<st_uid> and I<st_gid> fields to "
"accommodate the Linux-2.4 expansion of UIDs and GIDs to 32 bits, and various "
"other enlarged fields and further padding in the structure.  (Various "
"padding bytes were eventually consumed in Linux 2.6, with the advent of 32-"
"bit device IDs and nanosecond components for the timestamp fields.)"
msgstr ""
"Ещё раз увеличенное поле I<st_ino>, увеличены поля I<st_uid> и I<st_gid> для "
"работы с увеличенными в Linux-2.4 UID и GID до 32 бит, увеличены другие "
"поля, дальнейшее добавление заполнителей в структуру (различные байты "
"заполнения в дальнейшем были задействованы в Linux 2.6 с появлением 32-"
"битных ID устройств и наносекундной части в полях временных отметок)."

#.  A note from Andries Brouwer, July 2007
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: man-pages/man2/stat.2:623
msgid ""
"The glibc B<stat>()  wrapper function hides these details from applications, "
"invoking the most recent version of the system call provided by the kernel, "
"and repacking the returned information if required for old binaries."
msgstr ""
"Обёрточная функция glibc B<stat>() прячет эти подробности от приложений, "
"вызывая самую новую версию системного вызова, предоставляемого ядром, и "
"перепаковывая возвращаемую информацию, если это нужно для старых программ."

#. type: Plain text
#: man-pages/man2/stat.2:629
msgid ""
"On modern 64-bit systems, life is simpler: there is a single B<stat>()  "
"system call and the kernel deals with a I<stat> structure that contains "
"fields of a sufficient size."
msgstr ""
"В современных 64-битных системах жизнь упростилась: единственный системный "
"вызов B<stat>() и ядро работает со структурой I<stat>, в которой поля "
"достаточного размера."

#.  strace(1) shows the name "newfstatat" on x86-64
#. type: Plain text
#: man-pages/man2/stat.2:637
msgid ""
"The underlying system call employed by the glibc B<fstatat>()  wrapper "
"function is actually called B<fstatat64>()  or, on some architectures, "
"B<newfstatat>()."
msgstr ""
"Нижележащий системный вызов, используемый обёрточной функцией B<fstatat>() в "
"glibc, на самом деле называется B<fstatat64>() или, на некоторых "
"архитектурах, B<newfstatat>()."

#. type: Plain text
#: man-pages/man2/stat.2:643
msgid ""
"The following program calls B<lstat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr ""
"Следующая программа вызывает B<lstat>() и показывает некоторые поля из "
"полученной структуры I<stat>."

#. type: Plain text
#: man-pages/man2/stat.2:651
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/stat.2:656
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"

#. type: Plain text
#: man-pages/man2/stat.2:661
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>путьE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/stat.2:666
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/stat.2:669
#, no-wrap
msgid ""
"    printf(\"ID of containing device:  [%lx,%lx]\\en\",\n"
"\t    (long) major(sb.st_dev), (long) minor(sb.st_dev));\n"
msgstr ""
"    printf(\"ID содержащего устройства:  [%lx,%lx]\\en\",\n"
"\t    (long) major(sb.st_dev), (long) minor(sb.st_dev));\n"

#. type: Plain text
#: man-pages/man2/stat.2:671
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr "    printf(\"Тип файла:                \");\n"

#. type: Plain text
#: man-pages/man2/stat.2:682
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"блочное устройство\\en\");     break;\n"
"    case S_IFCHR:  printf(\"символьное устройство\\en\");  break;\n"
"    case S_IFDIR:  printf(\"каталог\\en\");                break;\n"
"    case S_IFIFO:  printf(\"FIFO/канал\\en\");             break;\n"
"    case S_IFLNK:  printf(\"символьная ссылка\\en\");      break;\n"
"    case S_IFREG:  printf(\"обычный файл\\en\");           break;\n"
"    case S_IFSOCK: printf(\"сокет\\en\");                  break;\n"
"    default:       printf(\"неизвестно?\\en\");            break;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/stat.2:684
#, no-wrap
msgid "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"
msgstr "    printf(\"номер inode:              %ld\\en\", (long) sb.st_ino);\n"

#. type: Plain text
#: man-pages/man2/stat.2:687
#, no-wrap
msgid ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"
msgstr ""
"    printf(\"Режим доступа:            %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"

#. type: Plain text
#: man-pages/man2/stat.2:691
#, no-wrap
msgid ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"
msgstr ""
"    printf(\"Кол-во ссылок:            %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Владелец:                 UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"

#. type: Plain text
#: man-pages/man2/stat.2:698
#, no-wrap
msgid ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"
msgstr ""
"    printf(\"Предпоч. размер бл. в/в:  %ld байт\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"Размер файла:             %lld байт\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Выделено блоков:          %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"

#. type: Plain text
#: man-pages/man2/stat.2:702
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr ""
"    printf(\"Посл. изм. состояния:     %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Посл. доступ к файлу:     %s\", ctime(&sb.st_atime));\n"
"    printf(\"Посл. изм. файла:         %s\", ctime(&sb.st_mtime));\n"

#. type: Plain text
#: man-pages/man2/stat.2:705
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/stat.2:717
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<statx>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<statx>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"

#. type: TH
#: man-pages/man2/s390_sthyi.2:25
#, no-wrap
msgid "S390_STHYI"
msgstr "S390_STHYI"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:28
msgid "s390_sthyi - emulate STHYI instruction"
msgstr "s390_sthyi - эмулирует инструкцию STHYI"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:34
#, no-wrap
msgid ""
"B<int s390_sthyi(unsigned long >I<function_code>B<, void *>I<resp_buffer>B<,>\n"
"B<               uint64_t *>I<return_code>B<, unsigned long >I<flags>B<);>\n"
msgstr ""
"B<int s390_sthyi(unsigned long >I<function_code>B<, void *>I<resp_buffer>B<,>\n"
"B<               uint64_t *>I<return_code>B<, unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:43
msgid ""
"The B<s390_sthyi>()  system call emulates the STHYI (Store Hypervisor "
"Information) instruction.  It provides hardware resource information for the "
"machine and its virtualization levels.  This includes CPU type and capacity, "
"as well as the machine model and other metrics."
msgstr ""
"Системный вызов B<s390_sthyi>() эмулирует инструкцию STHYI (Store Hypervisor "
"Information). Он предоставляет информацию о ресурсах машины и её уровни "
"виртуализации. В частности, возвращается тип ЦП и ёмкость, а также модель "
"машины и другие свойства."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:48
msgid ""
"The I<function_code> argument indicates which function to perform.  The "
"following code(s) are supported:"
msgstr ""
"В аргументе I<function_code> указывается какую функцию нужно выполнить. "
"Поддерживаются следующие коды:"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:52
msgid ""
"Return CP (Central Processor) and IFL (Integrated Facility for Linux)  "
"capacity information."
msgstr ""
"Вернуть информацию о CP (Central Processor) и ёмкости IFL (Integrated "
"Facility for Linux)."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:62
msgid ""
"The I<resp_buffer> argument specifies the address of a response buffer.  "
"When the I<function_code> is 0, the buffer must be one page (4K) in size.  "
"If the system call returns 0, the response buffer will be filled with CPU "
"capacity information.  Otherwise, the response buffer's content is unchanged."
msgstr ""
"В аргументе I<resp_buffer> указывается адрес буфера результата. При "
"I<function_code> равном 0, размер буфера должен быть равен странице (4K). "
"Если системный вызов вернул 0, то буфер результата будет заполнен "
"информацией о ёмкости ЦП. В противном случае содержимое буфера результата не "
"меняется."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:67
msgid ""
"The I<return_code> argument stores the return code of the STHYI instruction, "
"using one of the following values:"
msgstr ""
"В аргументе I<return_code> хранится код возврата инструкции STHYI; возможно "
"одно из следующих значений:"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:70
msgid "Success."
msgstr "Успешно."

#. type: TP
#: man-pages/man2/s390_sthyi.2:70
#, no-wrap
msgid "4"
msgstr "4"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:73
msgid "Unsupported function code."
msgstr "Неподдерживаемый код функции."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:80
msgid ""
"For further details about I<return_code>, I<function_code>, and "
"I<resp_buffer>, see the reference given in NOTES."
msgstr ""
"Дополнительную информацию о I<return_code>, I<function_code> и "
"I<resp_buffer> смотрите по ссылкам, приведённым в ЗАМЕЧАНИЯХ."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:85
msgid ""
"The I<flags> argument is provided to allow for future extensions and "
"currently must be set to 0."
msgstr ""
"Аргумент I<flags> предназначен для будущих расширений, а пока его значение "
"должно быть равно 0."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:96
msgid ""
"On success (that is: emulation succeeded), the return value of "
"B<s390_sthyi>()  matches the condition code of the STHYI instructions, which "
"is a value in the range [0..3].  A return value of 0 indicates that CPU "
"capacity information is stored in I<*resp_buffer>.  A return value of 3 "
"indicates \"unsupported function code\" and the content of I<*resp_buffer> "
"is unchanged.  The return values 1 and 2 are reserved."
msgstr ""
"При успешном выполнении (т. е. эмуляция прошла успешно), возвращаемое "
"B<s390_sthyi>() значение совпадает с кодом условия инструкций STHYI — "
"значением в диапазоне [0..3]. Возвращаемое значение 0 означает, что "
"информация о ёмкости ЦП сохранена в I<*resp_buffer>. Возвращаемое значение 3 "
"указывает на «неподдерживаемый код функции» и содержимое I<*resp_buffer> не "
"изменяется. Значения 1 и 2 зарезервированы."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:108
msgid ""
"The value specified in I<resp_buffer> or I<return_code> is not a valid "
"address."
msgstr ""
"Значение, указанное в I<resp_buffer> или I<return_code>, содержит "
"некорректный адрес."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:113
msgid "The value specified in I<flags> is nonzero."
msgstr "Значение, указанное в I<flags>, не равно нулю."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:116
msgid "Allocating memory for handling the CPU capacity information failed."
msgstr "Не удалось выделить память для обработки информации о ёмкости ЦП."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:121
msgid "The value specified in I<function_code> is not valid."
msgstr "Некорректное значение в I<function_code>."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:123
msgid "This system call is available since Linux 4.15."
msgstr "Данный системный вызов появился в Linux 4.15."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:125
msgid ""
"This Linux-specific system call is available only on the s390 architecture."
msgstr ""
"Данный системный вызов есть только в Linux и доступен только на архитектуре "
"s390."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:134
msgid ""
"For details of the STHYI instruction, see E<.UR https://www.ibm.com\\:/"
"support\\:/knowledgecenter\\:/SSB27U_6.3.0\\:/com.ibm.zvm.v630.hcpb4\\:/"
"hcpb4sth.htm> the documentation page E<.UE .>"
msgstr ""
"Описание инструкции STHYI смотрите на E<.UR https://www.ibm.com\\:/support"
"\\:/knowledgecenter\\:/SSB27U_6.3.0\\:/com.ibm.zvm.v630.hcpb4\\:/hcpb4sth."
"htm> странице документации E<.UE .>"

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:138
msgid ""
"When the system call interface is used, the response buffer doesn't have to "
"fulfill alignment requirements described in the STHYI instruction definition."
msgstr ""
"При использовании интерфейса системного вызова буфер результата не имеет "
"требований по выравниванию, описанных в инструкции STHYI."

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:141
msgid ""
"The kernel caches the response (for up to one second, as of Linux 4.16).  "
"Subsequent system call invocations may return the cached response."
msgstr ""
"Ядро кэширует результат (в Linux 4.16 каждую секунду). Последующие запуски "
"системного вызова могут вернуть кэшированный ответ."

#. type: TH
#: man-pages/man2/sigsuspend.2:29
#, no-wrap
msgid "SIGSUSPEND"
msgstr "SIGSUSPEND"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:32
msgid "sigsuspend, rt_sigsuspend - wait for a signal"
msgstr "sigsuspend, rt_sigsuspend - ожидание сигнала"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:36
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr "B<int sigsuspend(const sigset_t *>I<mask>B<);>"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:45
msgid "B<sigsuspend>(): _POSIX_C_SOURCE"
msgstr "B<sigsuspend>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:53
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling thread "
"with the mask given by I<mask> and then suspends the thread until delivery "
"of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr ""
"Вызов B<sigsuspend>() временно заменяет маску сигналов вызывающей нити "
"маской, указанной в I<mask>, и затем приостанавливает нить до тех пор, пока "
"не поступит сигнал, для которого запустится обработчик сигнала или это "
"приведёт к завершению процесса."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:62
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not "
"return.  If the signal is caught, then B<sigsuspend>()  returns after the "
"signal handler returns, and the signal mask is restored to the state before "
"the call to B<sigsuspend>()."
msgstr ""
"Если по сигналу процесс завершается, то вызов B<sigsuspend>() не возвращает "
"управление обратно в программу. Если сигнал пойман, то возврат из "
"B<sigsuspend>() произойдёт после завершения выполнения обработчика, и маска "
"сигналов восстановится в значение, которое было до вызова B<sigsuspend>()."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:70
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the thread's signal mask."
msgstr ""
"Сигналы B<SIGKILL> и B<SIGSTOP> невозможно заблокировать; указание этих этих "
"сигналов в I<mask> не влияет на маску сигналов нити."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:76
msgid ""
"B<sigsuspend>()  always returns -1, with I<errno> set to indicate the error "
"(normally, B<EINTR>)."
msgstr ""
"Вызов B<sigsuspend>() всегда возвращает -1; I<errno> присваивается номер "
"ошибки (обычно B<EINTR>)."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:81
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr ""
"Аргумент I<mask> указывает на память в недопустимой части адресного "
"пространства процесса."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:85
msgid "The call was interrupted by a signal; B<signal>(7)."
msgstr "Вызов был прерван по сигналу; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:105
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in "
"order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr ""
"Обычно, B<sigsuspend>() используется вместе с B<sigprocmask>(2), чтобы "
"предотвратить доставку сигнала при выполнении критического участка кода. "
"Сначала вызывающий блокирует сигналы с помощью B<sigprocmask>(2). Когда "
"критический участок выполнен, вызывающий начинает ждать сигналов с помощью "
"вызова B<sigsuspend>(), указав маску, значение которой было возвращено "
"вызовом B<sigprocmask>(2) (в аргументе I<oldset>)."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:137
msgid ""
"The original Linux system call was named B<sigsuspend>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigsuspend>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<mask>.  This argument is currently required to have the "
"value I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigsuspend>()  wrapper function hides these details from us, transparently "
"calling B<rt_sigsuspend>()  when the kernel provides it."
msgstr ""
"Первоначально, системный вызов Linux назывался B<sigsuspend>(). Однако, с "
"добавлением сигналов реального времени в Linux 2.2, 32-битный аргумент "
"I<sigset_t> неизменяемого размера, поддерживаемый этим системным вызовом, не "
"мог больше использоваться. В результате был добавлен новый системный вызов "
"B<rt_sigsuspend>() с увеличенным типом I<sigset_t>. У нового системного "
"вызова появился второй аргумент, I<size_t sigsetsize>, в котором указывается "
"размер (в байтах) набора сигналов I<mask>. В настоящее время значение этого "
"аргумента должно быть равно I<sizeof(sigset_t)> (иначе возникает ошибка "
"B<EINVAL>). Обёрточная функция glibc B<sigsuspend>() скрывает это и вызывает "
"B<rt_sigsuspend>(), если он есть в ядре."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:146
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr "SETNS"

#. type: Plain text
#: man-pages/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr "setns - повторно связывает нить с пространством имён"

#. type: Plain text
#: man-pages/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"

#. type: Plain text
#: man-pages/man2/setns.2:21
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""
"Указанный файловый дескриптор, ссылающийся на пространство имён, повторно "
"связывается (reassociate) в вызвавшей нити с этим пространством имён."

#. type: Plain text
#: man-pages/man2/setns.2:34
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<namespaces>(7)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""
"Аргумент I<fd> представляет собой файловый дескриптор, ссылающийся на одно "
"из элементов пространств имён в каталоге I</proc/[pid]/ns/>; подробней о I</"
"proc/[pid]/ns/> смотрите в B<namespaces>(7). Вызывающая нить будет повторно "
"связана с соответствующим пространством имён с учётом всех ограничений, "
"устанавливаемых аргументом I<nstype>."

#. type: Plain text
#: man-pages/man2/setns.2:40
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""
"В аргументе I<nstype> указывается тип пространства имён, с которым "
"вызывающая нить может быть повторно связана. Данный аргумент может иметь "
"одно из следующих значений:"

#. type: Plain text
#: man-pages/man2/setns.2:43
msgid "Allow any type of namespace to be joined."
msgstr "Разрешить подключиться к пространству имён любого типа."

#. type: TP
#: man-pages/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr "B<CLONE_NEWCGROUP> (начиная с Linux 4.6)"

#. type: Plain text
#: man-pages/man2/setns.2:47
msgid "I<fd> must refer to a cgroup namespace."
msgstr "Значение I<fd> должно указывать на пространство имён cgroup."

#. type: TP
#: man-pages/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 3.0)"
msgstr "B<CLONE_NEWIPC> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/setns.2:51
msgid "I<fd> must refer to an IPC namespace."
msgstr "Значение I<fd> должно указывать на пространство имён IPC."

#. type: TP
#: man-pages/man2/setns.2:51
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 3.0)"
msgstr "B<CLONE_NEWNET> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/setns.2:55
msgid "I<fd> must refer to a network namespace."
msgstr "Значение I<fd> должно указывать на пространство имён network."

#. type: TP
#: man-pages/man2/setns.2:55
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 3.8)"
msgstr "B<CLONE_NEWNS> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/setns.2:59
msgid "I<fd> must refer to a mount namespace."
msgstr "Значение I<fd> должно указывать на пространство имён mount."

#. type: TP
#: man-pages/man2/setns.2:59
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 3.8)"
msgstr "B<CLONE_NEWPID> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/setns.2:63
msgid "I<fd> must refer to a descendant PID namespace."
msgstr "Значение I<fd> должно указывать на пространство имён PID потомков."

#. type: TP
#: man-pages/man2/setns.2:63
#, no-wrap
msgid "B<CLONE_NEWUSER> (since Linux 3.8)"
msgstr "B<CLONE_NEWUSER> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/setns.2:67
msgid "I<fd> must refer to a user namespace."
msgstr "Значение I<fd> должно указывать на пространство имён user."

#. type: TP
#: man-pages/man2/setns.2:67
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 3.0)"
msgstr "B<CLONE_NEWUTS> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/setns.2:71
msgid "I<fd> must refer to a UTS namespace."
msgstr "Значение I<fd> должно указывать на пространство имён UTS."

#. type: Plain text
#: man-pages/man2/setns.2:87
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""
"Установка I<nstype> в 0 имеет смысл только, если вызывающий знает (или ему "
"не важно) на какой тип пространства имён ссылается I<fd>. Назначение "
"ненулевого значения в I<nstype> полезно, если вызывающий не знает на какой "
"тип пространства имён ссылается I<fd>. и хочет быть уверенным, что "
"пространство имён именно нужного типа (вызывающий может не знать тип "
"пространства имён на который указывает I<fd>, если файловый дескриптор был "
"открыт другим процессом и, например, передан вызывающему через доменный "
"сокет UNIX)."

#. type: SS
#: man-pages/man2/setns.2:87
#, no-wrap
msgid "Details for specific namespace types"
msgstr "Информация по определённым типам пространств имён"

#. type: Plain text
#: man-pages/man2/setns.2:90
msgid ""
"Note the following details and restrictions when reassociating with specific "
"namespace types:"
msgstr ""
"Некоторые примечания и ограничения при пересопряжении с некоторыми типами "
"пространств имён:"

#. type: TP
#: man-pages/man2/setns.2:90
#, no-wrap
msgid "User namespaces"
msgstr "Пользовательские пространства имён"

#.  See kernel/user_namespace.c:userns_install() [3.8 source]
#. type: Plain text
#: man-pages/man2/setns.2:101
msgid ""
"A process reassociating itself with a user namespace must have the "
"B<CAP_SYS_ADMIN> capability in the target user namespace.  (This necessarily "
"implies that it is only possible to join a descendant user namespace.)  Upon "
"successfully joining a user namespace, a process is granted all capabilities "
"in that namespace, regardless of its user and group IDs."
msgstr ""
"Для пересопряжения процесса с пространством имён пользователя он должен "
"иметь мандат B<CAP_SYS_ADMIN> в назначаемом пространстве имён пользователя "
"(эта необходимость подразумевает, что возможно присоединение только "
"дочернего  пространства имён пользователя). При успешном присоединении к  "
"пространству имён пользователя процесс получает все мандаты в этом "
"пространстве имён, независимо от своего ID пользователя и группы."

#. type: Plain text
#: man-pages/man2/setns.2:104
msgid "A multithreaded process may not change user namespace with B<setns>()."
msgstr ""
"Многонитевой процесс не может изменить пространство имён пользователя с "
"помощью B<setns>()."

#. type: Plain text
#: man-pages/man2/setns.2:111
msgid ""
"It is not permitted to use B<setns>()  to reenter the caller's current user "
"namespace.  This prevents a caller that has dropped capabilities from "
"regaining those capabilities via a call to B<setns>()."
msgstr ""
"Запрещается использовать B<setns>() для повторного вхождения вызывающего в "
"текущее пространство имён пользователя. Это не позволяет вызывающему, "
"оставшемуся без мандатов, повторно получить их через вызов B<setns>()."

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: man-pages/man2/setns.2:121
msgid ""
"For security reasons, a process can't join a new user namespace if it is "
"sharing filesystem-related attributes (the attributes whose sharing is "
"controlled by the B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""
"По причинам, связанным с безопасностью, процесс не может войти в новое "
"пользовательское пространство имён, если он сообща владеет атрибутами "
"файловых систем (атрибуты, чьё наследование управляется флагом B<CLONE_FS> в "
"B<clone>(2)) с другим процессом."

#. type: Plain text
#: man-pages/man2/setns.2:124
msgid "For further details on user namespaces, see B<user_namespaces>(7)."
msgstr ""
"Дополнительную информацию о пользовательских пространствах имён смотрите в "
"B<user_namespaces>(7)."

#. type: TP
#: man-pages/man2/setns.2:124
#, no-wrap
msgid "Mount namespaces"
msgstr "Пространства имён монтирования"

#. type: Plain text
#: man-pages/man2/setns.2:133
msgid ""
"Changing the mount namespace requires that the caller possess both "
"B<CAP_SYS_CHROOT> and B<CAP_SYS_ADMIN> capabilities in its own user "
"namespace and B<CAP_SYS_ADMIN> in the user namespace that owns the target "
"mount namespace."
msgstr ""
"Для смены пространства имён монтирования требуется, чтобы вызывающий процесс "
"имел мандаты B<CAP_SYS_CHROOT> и B<CAP_SYS_ADMIN> в своём пространстве имён "
"пользователя и мандат B<CAP_SYS_ADMIN> в пользовательском пространстве имён, "
"которое принадлежит целевому пространству имён монтирования."

#.  Above check is in fs/namespace.c:mntns_install() [3.8 source]
#. type: Plain text
#: man-pages/man2/setns.2:137
msgid ""
"A process may not be reassociated with a new mount namespace if it is "
"multithreaded."
msgstr ""
"Процесс не может пересопрягаться с новым пространством имён монтирования, "
"если он является многонитевым."

#. type: Plain text
#: man-pages/man2/setns.2:141
msgid ""
"See B<user_namespaces>(7)  for details on the interaction of user namespaces "
"and mount namespaces."
msgstr ""
"Подробную информацию взаимодействии пользовательского пространствах имён и "
"пространства имён монтирования смотрите в B<user_namespaces>(7)."

#. type: TP
#: man-pages/man2/setns.2:141
#, no-wrap
msgid "PID namespaces"
msgstr "Пространства имён PID"

#. type: Plain text
#: man-pages/man2/setns.2:148
msgid ""
"In order to reassociate itself with a new PID namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target PID namespace."
msgstr ""
"Чтобы пересопрячь новое пространство имён PID c самим собой, вызывающий "
"должен иметь мандат B<CAP_SYS_ADMIN> в своём пространстве имён пользователя "
"и пространстве имён пользователя целевого пространства имён PID."

#. type: Plain text
#: man-pages/man2/setns.2:157
msgid ""
"If I<fd> refers to a PID namespace, the semantics are somewhat different "
"from other namespace types: reassociating the calling thread with a PID "
"namespace changes only the PID namespace that subsequently created child "
"processes of the caller will be placed in; it does not change the PID "
"namespace of the caller itself."
msgstr ""
"Если I<fd> ссылается на пространство имён PID, то семантика слегла "
"отличается от других типов пространств имён: пересопряжение вызывающей нити "
"с пространством имён PID изменяет только пространство имён PID, в которое "
"будут помещены все создаваемые далее потомки вызывающего; пространство имён "
"PID самого вызывающего не изменяется."

#. type: Plain text
#: man-pages/man2/setns.2:163
msgid ""
"Reassociating with a PID namespace is allowed only if the PID namespace "
"specified by I<fd> is a descendant (child, grandchild, etc.)  of the PID "
"namespace of the caller."
msgstr ""
"Пересопряжение (reassociating) с пространством имён PID разрешено только, "
"если пространство имён PID, указанное в I<fd>, является потомком (дочерним, "
"внучатым и т. д.) пространства имён PID вызывающего."

#. type: Plain text
#: man-pages/man2/setns.2:166
msgid "For further details on PID namespaces, see B<pid_namespaces>(7)."
msgstr ""
"Дополнительную информацию о пространствах имён PID смотрите в "
"B<pid_namespaces>(7)."

#. type: TP
#: man-pages/man2/setns.2:166
#, no-wrap
msgid "Cgroup namespaces"
msgstr "Пространства имён cgroup"

#. type: Plain text
#: man-pages/man2/setns.2:173
msgid ""
"In order to reassociate itself with a new cgroup namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target cgroup namespace."
msgstr ""
"Чтобы пересопрячь новое пространство имён cgroup c самим собой, вызывающий "
"должен иметь мандат B<CAP_SYS_ADMIN> в своём пространстве имён пользователя "
"и пространстве имён пользователя целевого пространства имён cgroup."

#. type: Plain text
#: man-pages/man2/setns.2:178
msgid ""
"Using B<setns>()  to change the caller's cgroup namespace does not change "
"the caller's cgroup memberships."
msgstr ""
"Использование B<setns>()  для изменения пространства имён cgroup вызывающего "
"не изменяет членство cgroup вызывающего."

#. type: TP
#: man-pages/man2/setns.2:178
#, no-wrap
msgid "Network, IPC, and UTS namespaces"
msgstr "Пространства имён IPC, UTS и сетевое"

#. type: Plain text
#: man-pages/man2/setns.2:185
msgid ""
"In order to reassociate itself with a new network, IPC, or UTS namespace, "
"the caller must have the B<CAP_SYS_ADMIN> capability both in its own user "
"namespace and in the user namespace that owns the target namespace."
msgstr ""
"Чтобы пересопрячь новое пространство имён IPC, UTS или сетевое c самим "
"собой, вызывающий должен иметь мандат B<CAP_SYS_ADMIN> в своём пространстве "
"имён пользователя и пространстве имён пользователя целевого пространства "
"имён PID."

#. type: Plain text
#: man-pages/man2/setns.2:192
msgid ""
"On success, B<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""
"При успешном выполнении B<setns>() возвращает 0. При ошибке возвращается -1, "
"и I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/setns.2:202
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>."
msgstr ""
"Значение I<fd> ссылается на пространство имён, чей тип не соответствует с "
"указанным в I<nstype>."

#. type: Plain text
#: man-pages/man2/setns.2:206
msgid ""
"There is problem with reassociating the thread with the specified namespace."
msgstr ""
"Эти проблемы возникают при повторном связывании нити с указанным "
"пространством имён."

#. type: Plain text
#: man-pages/man2/setns.2:211
msgid ""
"The caller tried to join an ancestor (parent, grandparent, and so on)  PID "
"namespace."
msgstr ""
"Вызывающий пытается объединиться с пространством имён PID предка (родителя, "
"родителя родителя и т. д.)."

#. type: Plain text
#: man-pages/man2/setns.2:215
msgid ""
"The caller attempted to join the user namespace in which it is already a "
"member."
msgstr ""
"Вызывающий пытается объединиться с пространством имён пользователя, в "
"которое он уже входит."

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: man-pages/man2/setns.2:222
msgid ""
"The caller shares filesystem (B<CLONE_FS>)  state (in particular, the root "
"directory)  with other processes and tried to join a new user namespace."
msgstr ""
"Вызывающий сообща владеет состоянием файловой системы (B<CLONE_FS>) (в "
"частности, корневой каталог) с другим процессом и пытается объединить новое "
"пользовательское пространство имён."

#.  See kernel/user_namespace.c::userns_install() [kernel 3.15 sources]
#. type: Plain text
#: man-pages/man2/setns.2:226
msgid "The caller is multithreaded and tried to join a new user namespace."
msgstr ""
"Вызывающий состоит из нескольких нитей и пытается объединить новое "
"пользовательское пространство имён."

#. type: Plain text
#: man-pages/man2/setns.2:229
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr ""
"Невозможно выделить достаточно памяти для изменения указанного пространства "
"имён."

#. type: Plain text
#: man-pages/man2/setns.2:233
msgid ""
"The calling thread did not have the required capability for this operation."
msgstr "Вызывающая нить не имеет требуемого мандата для этой операции."

#. type: Plain text
#: man-pages/man2/setns.2:238
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""
"Системный вызов B<setns>() впервые появился в ядре Linux версии 3.0; "
"поддержка в glibc добавлена в версии 2.14."

#. type: Plain text
#: man-pages/man2/setns.2:242
msgid "The B<setns>()  system call is Linux-specific."
msgstr "Системный вызов B<setns>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/setns.2:248
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""
"Не все атрибуты, которыми можно владеть сообща при создании новой нити с "
"помощью using B<clone>(2), можно изменить с помощью B<setns>()."

#. type: Plain text
#: man-pages/man2/setns.2:257
msgid ""
"The program below takes two or more arguments.  The first argument specifies "
"the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(), "
"and executes the specified command inside that namespace."
msgstr ""
"Программа, представленная ниже, ожидает два и более аргументов. В первом "
"аргумент указывается путь к файлу пространства имён в существующем каталоге "
"I</proc/[pid]/ns/>. В остальных аргументах указывается команда и её "
"параметры. Программа открывает файл пространства имён, объединяет это "
"пространство имён с помощью B<setns>() и выполняет указанную команду внутри "
"этого пространства имён."

#. type: Plain text
#: man-pages/man2/setns.2:267
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""
"В следующем сеансе оболочки показано использование этой программы "
"(скомпилирована под именем I<ns_exec>) вместе с примером для B<CLONE_NEWUTS> "
"из справочной страницы B<clone>(2) (скомпилирована под именем I<newuts>)."

#. type: Plain text
#: man-pages/man2/setns.2:275
msgid ""
"We begin by executing the example program in B<clone>(2)  in the "
"background.  That program creates a child in a separate UTS namespace.  The "
"child changes the hostname in its namespace, and then both processes display "
"the hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""
"Сначала мы запускаем программу из B<clone>(2) в фоновом режиме. Эта "
"программа создаёт потомка в отдельном пространстве имён UTS. Потомок "
"изменяет имя узла в своём пространстве имён, а затем оба процесса отображают "
"имена узлов в своих пространствах имён UTS для того, чтобы мы увидели, что "
"они разные."

#. type: Plain text
#: man-pages/man2/setns.2:287
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""
"$ B<su>                   # Требуются права для выполнения\n"
"                          # операций с пространством имён\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # проверяем имя узла в оболочке\n"
"antero\n"

#. type: Plain text
#: man-pages/man2/setns.2:294
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""
"Затем мы запускаем программу, показанную ниже, используя ту же оболочку. "
"Внутри этой оболочки мы проверяем, что имя узла — одно из изменённых "
"потомком, созданным первой программой:"

#. type: Plain text
#: man-pages/man2/setns.2:300
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # выполняется в оболочке, запущенной ns_exec\n"
"bizarro\n"

#. type: Plain text
#: man-pages/man2/setns.2:310
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/setns.2:318
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"

#. type: Plain text
#: man-pages/man2/setns.2:323
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE команда аргументы…\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/setns.2:327
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY); /* Get file descriptor for namespace */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY);  /* получаем файловый дескриптор для пространства\n"
"                                      имён */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"

#. type: Plain text
#: man-pages/man2/setns.2:330
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)       /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""
"    if (setns(fd, 0) == -1)        /* объединяемся с этим пространством имён */\n"
"        errExit(\"setns\");\n"

#. type: Plain text
#: man-pages/man2/setns.2:334
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);    /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    execvp(argv[2], &argv[2]);     /* выполняем команду в пространстве имён */\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: man-pages/man2/setns.2:342
msgid ""
"B<nsenter>(1), B<clone>(2), B<fork>(2), B<unshare>(2), B<vfork>(2), "
"B<namespaces>(7), B<unix>(7)"
msgstr ""
"B<nsenter>(1), B<clone>(2), B<fork>(2), B<unshare>(2), B<vfork>(2), "
"B<namespaces>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/stime.2:30
#, no-wrap
msgid "STIME"
msgstr "STIME"

#. type: Plain text
#: man-pages/man2/stime.2:33
msgid "stime - set time"
msgstr "stime - устанавливает системное время"

#. type: Plain text
#: man-pages/man2/stime.2:35
msgid "B<#include E<lt>time.hE<gt>>"
msgstr "B<#include E<lt>time.hE<gt>>"

#. type: Plain text
#: man-pages/man2/stime.2:37
msgid "B<int stime(const time_t *>I<t>B<);>"
msgstr "B<int stime(const time_t *>I<t>B<);>"

#. type: Plain text
#: man-pages/man2/stime.2:48
#, no-wrap
msgid ""
"B<stime>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""
"B<stime>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 и старее:\n"
"        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man2/stime.2:56
msgid ""
"B<stime>()  sets the system's idea of the time and date.  The time, pointed "
"to by I<t>, is measured in seconds since the Epoch, 1970-01-01 00:00:00 "
"+0000 (UTC).  B<stime>()  may be executed only by the superuser."
msgstr ""
"Вызов B<stime>() устанавливает системное (не аппаратное) время и дату "
"машины. Время, заданное в I<t>, измеряется в секундах с начала Эпохи, с "
"00:00:00 1 января 1970 года (UTC). Функцию B<stime>() может вызывать только "
"суперпользователь."

#. type: Plain text
#: man-pages/man2/stime.2:65
msgid "Error in getting information from user space."
msgstr "Ошибка при получении информации из пространства пользователя."

#. type: Plain text
#: man-pages/man2/stime.2:71
msgid ""
"The calling process has insufficient privilege.  Under Linux, the "
"B<CAP_SYS_TIME> privilege is required."
msgstr ""
"Вызвавшему процессу не хватает прав. В Linux для этого требуется мандат "
"B<CAP_SYS_TIME>."

#. type: Plain text
#: man-pages/man2/stime.2:73
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man2/stime.2:76
msgid "B<date>(1), B<settimeofday>(2), B<capabilities>(7)"
msgstr "B<date>(1), B<settimeofday>(2), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/statx.2:31
#, no-wrap
msgid "STATX"
msgstr "STATX"

#. type: Plain text
#: man-pages/man2/statx.2:34
msgid "statx - get file status (extended)"
msgstr "statx - считывает состояние файла (расширенный вариант)"

#. type: Plain text
#: man-pages/man2/statx.2:40
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>           >/* константы AT_* */\n"

#. type: Plain text
#: man-pages/man2/statx.2:43
#, no-wrap
msgid ""
"B<int statx(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<,>\n"
"B<          unsigned int >I<mask>B<, struct statx *>I<statxbuf>B<);>\n"
msgstr ""
"B<int statx(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<,>\n"
"B<          unsigned int >I<mask>B<, struct statx *>I<statxbuf>B<);>\n"

#. type: Plain text
#: man-pages/man2/statx.2:51
msgid ""
"This function returns information about a file, storing it in the buffer "
"pointed to by I<statxbuf>.  The returned buffer is a structure of the "
"following type:"
msgstr ""
"Этот системный вызов возвращает информацию о файле, записывая её в буфер, на "
"который указывает I<statxbuf>. Возвращаемый буфер представляет собой "
"структуру следующего вида:"

#. type: Plain text
#: man-pages/man2/statx.2:69
#, no-wrap
msgid ""
"struct statx {\n"
"    __u32 stx_mask;        /* Mask of bits indicating\n"
"                              filled fields */\n"
"    __u32 stx_blksize;     /* Block size for filesystem I/O */\n"
"    __u64 stx_attributes;  /* Extra file attribute indicators */\n"
"    __u32 stx_nlink;       /* Number of hard links */\n"
"    __u32 stx_uid;         /* User ID of owner */\n"
"    __u32 stx_gid;         /* Group ID of owner */\n"
"    __u16 stx_mode;        /* File type and mode */\n"
"    __u64 stx_ino;         /* Inode number */\n"
"    __u64 stx_size;        /* Total size in bytes */\n"
"    __u64 stx_blocks;      /* Number of 512B blocks allocated */\n"
"    __u64 stx_attributes_mask;\n"
"                           /* Mask to show what's supported\n"
"                              in stx_attributes */\n"
msgstr ""
"struct statx {\n"
"    __u32 stx_mask;        /* маска битов, показывающая\n"
"                              заполненные поля */\n"
"    __u32 stx_blksize;     /* размер блока ввода-вывода файловой системы */\n"
"    __u64 stx_attributes;  /* индикаторы дополнительных файловых атрибутов */\n"
"    __u32 stx_nlink;       /* количество жёстких ссылок */\n"
"    __u32 stx_uid;         /* идентификатор пользователя-владельца */\n"
"    __u32 stx_gid;         /* идентификатор группы-владельца */\n"
"    __u16 stx_mode;        /* тип файла и режим доступа */\n"
"    __u64 stx_ino;         /* номер иноды */\n"
"    __u64 stx_size;        /* полный размер в байтах */\n"
"    __u64 stx_blocks;      /* количество выделенных 512-байтовых блоков */\n"
"    __u64 stx_attributes_mask;\n"
"                           /* маска, показывающая поддерживаемые атрибуты\n"
"                              в stx_attributes */\n"

#. type: Plain text
#: man-pages/man2/statx.2:75
#, no-wrap
msgid ""
"    /* The following fields are file timestamps */\n"
"    struct statx_timestamp stx_atime;  /* Last access */\n"
"    struct statx_timestamp stx_btime;  /* Creation */\n"
"    struct statx_timestamp stx_ctime;  /* Last status change */\n"
"    struct statx_timestamp stx_mtime;  /* Last modification */\n"
msgstr ""
"    /* поля меток времени */\n"
"    struct statx_timestamp stx_atime;  /* последний доступ */\n"
"    struct statx_timestamp stx_btime;  /* создание */\n"
"    struct statx_timestamp stx_ctime;  /* последнее изменение состояния */\n"
"    struct statx_timestamp stx_mtime;  /* последнее изменение */\n"

#. type: Plain text
#: man-pages/man2/statx.2:80
#, no-wrap
msgid ""
"    /* If this file represents a device, then the next two\n"
"       fields contain the ID of the device */\n"
"    __u32 stx_rdev_major;  /* Major ID */\n"
"    __u32 stx_rdev_minor;  /* Minor ID */\n"
msgstr ""
"    /* если файл представляет устройство, то в следующих\n"
"       полях содержится идентификатор устройства */\n"
"    __u32 stx_rdev_major;  /* основной идентификатор */\n"
"    __u32 stx_rdev_minor;  /* дополнительный идентификатор */\n"

#. type: Plain text
#: man-pages/man2/statx.2:86
#, no-wrap
msgid ""
"    /* The next two fields contain the ID of the device\n"
"       containing the filesystem where the file resides */\n"
"    __u32 stx_dev_major;   /* Major ID */\n"
"    __u32 stx_dev_minor;   /* Minor ID */\n"
"};\n"
msgstr ""
"    /* поля идентификатора устройства с файловой системой,\n"
"       в которой содержится файл */\n"
"    __u32 stx_dev_major;   /* основной идентификатор */\n"
"    __u32 stx_dev_minor;   /* дополнительный идентификатор */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/statx.2:90
msgid "The file timestamps are structures of the following type:"
msgstr "Метки времени файла хранятся в структуре следующего вида:"

#. type: Plain text
#: man-pages/man2/statx.2:97
#, no-wrap
msgid ""
"struct statx_timestamp {\n"
"    __s64 tv_sec;    /* Seconds since the Epoch (UNIX time) */\n"
"    __u32 tv_nsec;   /* Nanoseconds since tv_sec */\n"
"};\n"
msgstr ""
"struct statx_timestamp {\n"
"    __s64 tv_sec;    /* количество секунд с начала Эпохи (время UNIX) */\n"
"    __u32 tv_nsec;   /* количество наносекунд, начиная с tv_sec */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/statx.2:101
msgid "(Note that reserved space and padding is omitted.)"
msgstr "(зарезервированное пространство и заполнители не показаны)"

#. type: SS
#: man-pages/man2/statx.2:101
#, no-wrap
msgid "Invoking statxR<():>"
msgstr "При вызове statxR<():>"

#. type: Plain text
#: man-pages/man2/statx.2:111
msgid ""
"To access a file's status, no permissions are required on the file itself, "
"but in the case of B<statx>()  with a pathname, execute (search) permission "
"is required on all of the directories in I<pathname> that lead to the file."
msgstr ""
"Для получения состояния файла не требуется иметь права доступа к самому "
"файлу, но в случае указания B<statx>() с путём, потребуются права выполнения "
"(поиска) во всех каталогах, указанных в полном имени файла I<pathname>."

#. type: Plain text
#: man-pages/man2/statx.2:119
msgid ""
"B<statx>()  uses I<pathname>, I<dirfd>, and I<flags> to identify the target "
"file in one of the following ways:"
msgstr ""
"Вызов B<statx>() для определения нужного файла использует I<pathname>, "
"I<dirfd> и I<flags> следующими путями:"

#. type: TP
#: man-pages/man2/statx.2:119
#, no-wrap
msgid "An absolute pathname"
msgstr "Абсолютный путь"

#. type: Plain text
#: man-pages/man2/statx.2:128
msgid ""
"If I<pathname> begins with a slash, then it is an absolute pathname that "
"identifies the target file.  In this case, I<dirfd> is ignored."
msgstr ""
"Если I<pathname> начинается с косой черты, то целевой файла задан абсолютным "
"путём. В этом случае значение I<dirfd> игнорируется."

#. type: TP
#: man-pages/man2/statx.2:128
#, no-wrap
msgid "A relative pathname"
msgstr "Относительный путь"

#. type: Plain text
#: man-pages/man2/statx.2:140
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is B<AT_FDCWD>, then I<pathname> is a relative pathname that is "
"interpreted relative to the process's current working directory."
msgstr ""
"Если I<pathname> начинается не с косой черты и I<dirfd> равно B<AT_FDCWD>, "
"то I<pathname> рассматривается относительно текущего рабочего каталога "
"процесса."

#. type: TP
#: man-pages/man2/statx.2:140
#, no-wrap
msgid "A directory-relative pathname"
msgstr "Путь, задаваемый относительно каталога"

#. type: Plain text
#: man-pages/man2/statx.2:151
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is a file descriptor that refers to a directory, then "
"I<pathname> is a relative pathname that is interpreted relative to the "
"directory referred to by I<dirfd>."
msgstr ""
"Если I<pathname> начинается не с косой черты и I<dirfd> содержит файловый "
"дескриптор, указывающий на каталог, то I<pathname> рассматривается "
"относительно каталога, на который ссылается I<dirfd>."

#. type: TP
#: man-pages/man2/statx.2:151
#, no-wrap
msgid "By file descriptor"
msgstr "По файловому дескриптору"

#. type: Plain text
#: man-pages/man2/statx.2:162
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is specified "
"in I<flags> (see below), then the target file is the one referred to by the "
"file descriptor I<dirfd>."
msgstr ""
"Если значение I<pathname> равно пустой строке и в I<flags> (смотрите ниже) "
"указан флаг B<AT_EMPTY_PATH>, то целевым файлом считается тот, на который "
"указывает файловый дескриптор в I<dirfd>."

#. type: Plain text
#: man-pages/man2/statx.2:168
msgid ""
"I<flags> can be used to influence a pathname-based lookup.  A value for "
"I<flags> is constructed by ORing together zero or more of the following "
"constants:"
msgstr ""
"Значение I<flags> можно использовать для уточнения поиска на основе пути. "
"Оно составляется из побитно слагаемых следующих констант:"

#. type: TP
#: man-pages/man2/statx.2:168
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr "B<AT_EMPTY_PATH>"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: man-pages/man2/statx.2:182
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory."
msgstr ""
"Если значение I<pathname> равно пустой строке, то вызов выполняет действие с "
"файлом, на который ссылается I<dirfd> (может быть получен с помощью "
"B<open>(2) с флагом B<O_PATH>). В этом случае I<dirfd> может ссылаться на "
"файл любого типа, а не только на каталог."

#. type: Plain text
#: man-pages/man2/statx.2:188
msgid ""
"If I<dirfd> is B<AT_FDCWD>, the call operates on the current working "
"directory."
msgstr ""
"Если I<dirfd> равно B<AT_FDCWD>, то вызов использует текущий рабочий каталог."

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/statx.2:193
msgid ""
"This flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr ""
"Данный флаг существует только в Linux; для его получения определите "
"B<_GNU_SOURCE>."

#. type: TP
#: man-pages/man2/statx.2:193
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT>"
msgstr "B<AT_NO_AUTOMOUNT>"

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/statx.2:209
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"This flag can be used in tools that scan directories to prevent mass-"
"automounting of a directory of automount points.  The B<AT_NO_AUTOMOUNT> "
"flag has no effect if the mount point has already been mounted over.  This "
"flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr ""
"Не выполнять автоматическое монтирование конечного компонента («basename») "
"I<pathname>, если это каталог, который является точкой монтирования. Это "
"позволяет вызывающему получить атрибуты точки монтирования (а не "
"расположения, где её предполагалось смонтировать). Этот флаг можно "
"использовать в инструментах, сканирующих каталоги, для предотвращения "
"массового автоматического монтирования каталогов в их точки монтирования. "
"Флаг B<AT_NO_AUTOMOUNT> не учитывается, если к точке уже уже была выполнено "
"монтирование. Этот флаг есть только Linux; для его получения нужно задать "
"B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man2/statx.2:216
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>(2)."
msgstr ""
"Если значение I<pathname> является символьной ссылкой, не разыменовывать её, "
"а выдать информацию о самой ссылке, подобно B<lstat>(2)."

#. type: Plain text
#: man-pages/man2/statx.2:221
msgid ""
"I<flags> can also be used to control what sort of synchronization the kernel "
"will do when querying a file on a remote filesystem.  This is done by ORing "
"in one of the following values:"
msgstr ""
"Значение I<flags> также может использоваться для контроля типа "
"синхронизации, которое выполняет ядро при опросе файла на удалённой файловой "
"системе. Оно составляется из побитно слагаемых следующих значений:"

#. type: TP
#: man-pages/man2/statx.2:221
#, no-wrap
msgid "B<AT_STATX_SYNC_AS_STAT>"
msgstr "B<AT_STATX_SYNC_AS_STAT>"

#. type: Plain text
#: man-pages/man2/statx.2:227
msgid ""
"Do whatever B<stat>(2)  does.  This is the default and is very much "
"filesystem-specific."
msgstr ""
"Работать подобно B<stat>(2). Используется по умолчанию и очень зависит от "
"файловой системы."

#. type: TP
#: man-pages/man2/statx.2:227
#, no-wrap
msgid "B<AT_STATX_FORCE_SYNC>"
msgstr "B<AT_STATX_FORCE_SYNC>"

#. type: Plain text
#: man-pages/man2/statx.2:232
msgid ""
"Force the attributes to be synchronized with the server.  This may require "
"that a network filesystem perform a data writeback to get the timestamps "
"correct."
msgstr ""
"Принудительно синхронизировать атрибуты с сервером. Может потребовать от "
"сетевой файловой системы выполнить запись данных для получения правильных "
"меток времени."

#. type: TP
#: man-pages/man2/statx.2:232
#, no-wrap
msgid "B<AT_STATX_DONT_SYNC>"
msgstr "B<AT_STATX_DONT_SYNC>"

#. type: Plain text
#: man-pages/man2/statx.2:239
msgid ""
"Don't synchronize anything, but rather just take whatever the system has "
"cached if possible.  This may mean that the information returned is "
"approximate, but, on a network filesystem, it may not involve a round trip "
"to the server - even if no lease is held."
msgstr ""
"Не выполнять синхронизацию, а использовать информацию из кэша (если есть). "
"Это может означать, что полученная информация будет не точна, но в случае с "
"сетевыми файловыми системами это позволяет не обращаться к серверу и даже "
"может быть разрыв соединения."

#. type: Plain text
#: man-pages/man2/statx.2:247
msgid ""
"The I<mask> argument to B<statx>()  is used to tell the kernel which fields "
"the caller is interested in.  I<mask> is an ORed combination of the "
"following constants:"
msgstr ""
"Аргумент I<mask> в B<statx>() используется для указания ядру какие поля поля "
"нужны вызывающему. Значение I<mask> представляет побитовую комбинацию "
"(посредством OR) следующих констант:"

#. type: tbl table
#: man-pages/man2/statx.2:251
#, no-wrap
msgid "STATX_TYPE"
msgstr "STATX_TYPE"

#. type: tbl table
#: man-pages/man2/statx.2:251
#, no-wrap
msgid "Want stx_mode & S_IFMT"
msgstr "Требуется stx_mode & S_IFMT"

#. type: tbl table
#: man-pages/man2/statx.2:252
#, no-wrap
msgid "STATX_MODE"
msgstr "STATX_MODE"

#. type: tbl table
#: man-pages/man2/statx.2:252
#, no-wrap
msgid "Want stx_mode & ~S_IFMT"
msgstr "Требуется stx_mode & ~S_IFMT"

#. type: tbl table
#: man-pages/man2/statx.2:253
#, no-wrap
msgid "STATX_NLINK"
msgstr "STATX_NLINK"

#. type: tbl table
#: man-pages/man2/statx.2:253
#, no-wrap
msgid "Want stx_nlink"
msgstr "Требуется stx_nlink"

#. type: tbl table
#: man-pages/man2/statx.2:254
#, no-wrap
msgid "STATX_UID"
msgstr "STATX_UID"

#. type: tbl table
#: man-pages/man2/statx.2:254
#, no-wrap
msgid "Want stx_uid"
msgstr "Требуется stx_uid"

#. type: tbl table
#: man-pages/man2/statx.2:255
#, no-wrap
msgid "STATX_GID"
msgstr "STATX_GID"

#. type: tbl table
#: man-pages/man2/statx.2:255
#, no-wrap
msgid "Want stx_gid"
msgstr "Требуется stx_gid"

#. type: tbl table
#: man-pages/man2/statx.2:256
#, no-wrap
msgid "STATX_ATIME"
msgstr "STATX_ATIME"

#. type: tbl table
#: man-pages/man2/statx.2:256
#, no-wrap
msgid "Want stx_atime"
msgstr "Требуется stx_atime"

#. type: tbl table
#: man-pages/man2/statx.2:257
#, no-wrap
msgid "STATX_MTIME"
msgstr "STATX_MTIME"

#. type: tbl table
#: man-pages/man2/statx.2:257
#, no-wrap
msgid "Want stx_mtime"
msgstr "Требуется stx_mtime"

#. type: tbl table
#: man-pages/man2/statx.2:258
#, no-wrap
msgid "STATX_CTIME"
msgstr "STATX_CTIME"

#. type: tbl table
#: man-pages/man2/statx.2:258
#, no-wrap
msgid "Want stx_ctime"
msgstr "Требуется stx_ctime"

#. type: tbl table
#: man-pages/man2/statx.2:259
#, no-wrap
msgid "STATX_INO"
msgstr "STATX_INO"

#. type: tbl table
#: man-pages/man2/statx.2:259
#, no-wrap
msgid "Want stx_ino"
msgstr "Требуется stx_ino"

#. type: tbl table
#: man-pages/man2/statx.2:260
#, no-wrap
msgid "STATX_SIZE"
msgstr "STATX_SIZE"

#. type: tbl table
#: man-pages/man2/statx.2:260
#, no-wrap
msgid "Want stx_size"
msgstr "Требуется stx_size"

#. type: tbl table
#: man-pages/man2/statx.2:261
#, no-wrap
msgid "STATX_BLOCKS"
msgstr "STATX_BLOCKS"

#. type: tbl table
#: man-pages/man2/statx.2:261
#, no-wrap
msgid "Want stx_blocks"
msgstr "Требуется stx_blocks"

#. type: tbl table
#: man-pages/man2/statx.2:262
#, no-wrap
msgid "STATX_BASIC_STATS"
msgstr "STATX_BASIC_STATS"

#. type: tbl table
#: man-pages/man2/statx.2:262
#, no-wrap
msgid "[All of the above]"
msgstr "[всё вышеперечисленное]"

#. type: tbl table
#: man-pages/man2/statx.2:263
#, no-wrap
msgid "STATX_BTIME"
msgstr "STATX_BTIME"

#. type: tbl table
#: man-pages/man2/statx.2:263
#, no-wrap
msgid "Want stx_btime"
msgstr "Требуется stx_btime"

#. type: tbl table
#: man-pages/man2/statx.2:264
#, no-wrap
msgid "STATX_ALL"
msgstr "STATX_ALL"

#. type: tbl table
#: man-pages/man2/statx.2:264
#, no-wrap
msgid "[All currently available fields]"
msgstr "[все доступные в данный момент поля]"

#. type: Plain text
#: man-pages/man2/statx.2:289
msgid ""
"Note that, in general, the kernel does I<not> reject values in I<mask> other "
"than the above.  (For an exception, see B<EINVAL> in errors.)  Instead, it "
"simply informs the caller which values are supported by this kernel and "
"filesystem via the I<statx.stx_mask> field.  Therefore, I<do not> simply set "
"I<mask> to B<UINT_MAX> (all bits set), as one or more bits may, in the "
"future, be used to specify an extension to the buffer."
msgstr ""

#. type: SS
#: man-pages/man2/statx.2:289
#, no-wrap
msgid "The returned information"
msgstr "Возвращаемая информация"

#. type: Plain text
#: man-pages/man2/statx.2:304
msgid ""
"The status information for the target file is returned in the I<statx> "
"structure pointed to by I<statxbuf>.  Included in this is I<stx_mask> which "
"indicates what other information has been returned.  I<stx_mask> has the "
"same format as the I<mask> argument and bits are set in it to indicate which "
"fields have been filled in."
msgstr ""
"Информация о состоянии целевого файла возвращается в структуре I<statx>, на "
"которую указывает I<statxbuf>. Она содержит I<stx_mask>, в котором "
"описывается возвращённая информация. Значение I<stx_mask> имеет тот же "
"формат, что и аргумент I<mask>, и установленные в нём бит показывают какие "
"поля были заполнены."

#. type: Plain text
#: man-pages/man2/statx.2:313
msgid ""
"It should be noted that the kernel may return fields that weren't requested "
"and may fail to return fields that were requested, depending on what the "
"backing filesystem supports.  (Fields that are given values despite being "
"unrequested can just be ignored.)  In either case, I<stx_mask> will not be "
"equal I<mask>."
msgstr ""
"Стоит упомянуть, что ядро может вернуть поля, которые не был запрошены и "
"запрошенные поля могут быть не заполнены, в зависимости от поддержки в "
"нижележащей файловой системе (поля, которым были присвоены значение, но "
"которые не были запрошены, можно игнорировать). В этих случаях I<stx_mask> "
"будет не равно I<mask>."

#. type: Plain text
#: man-pages/man2/statx.2:321
msgid ""
"If a filesystem does not support a field or if it has an unrepresentable "
"value (for instance, a file with an exotic type), then the mask bit "
"corresponding to that field will be cleared in I<stx_mask> even if the user "
"asked for it and a dummy value will be filled in for compatibility purposes "
"if one is available (e.g., a dummy UID and GID may be specified to mount "
"under some circumstances)."
msgstr ""
"Если файловая система не поддерживает поле или если значение поле содержит "
"непрезентабельное значение (например, файл экзотического типа), то битовая "
"маска в I<stx_mask>, соответствующая этому полю, будет очищена даже если "
"пользователь запросил его, и в целях совместимости в качестве значения, если "
"возможно, будет помещена пустышка (например, в некоторых случаях пустышки "
"UID и GID могут задаваться при монтировании)."

#. type: Plain text
#: man-pages/man2/statx.2:326
msgid ""
"A filesystem may also fill in fields that the caller didn't ask for if it "
"has values for them available and the information is available at no extra "
"cost.  If this happens, the corresponding bits will be set in I<stx_mask>."
msgstr ""
"Файловая система также может заполнить поля, которые вызывающий не "
"запрашивал, при условии, что их значения доступны и это ничего стоит. Если "
"это выполняется, то будут установлены соответствующие биты в I<stx_mask>."

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: man-pages/man2/statx.2:351
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<statx> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<stx_mode> or "
"I<stx_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<stx_mode> together with the "
"new I<stx_uid>, or the old I<stx_uid> together with the new I<stx_mode>."
msgstr ""
"I<Замечание>: с целью производительности и простоты различные поля в "
"структуре I<statx> могут содержать информацию о состоянии из различных "
"моментов выполнения системного вызова. Например, если изменяется I<stx_mode> "
"или I<stx_uid> другим процессом посредством вызова B<chmod>(2) или "
"B<chown>(2), то B<stat>() может вернуть старое значение I<stx_mode> вместе с "
"новым I<stx_uid>, или старое I<stx_uid> вместе с новым I<stx_mode>."

#. type: Plain text
#: man-pages/man2/statx.2:357
msgid ""
"Apart from I<stx_mask> (which is described above), the fields in the "
"I<statx> structure are:"
msgstr ""
"Помимо полей I<stx_mask> (описанной выше) структура I<statx> имеет следующие "
"поля:"

#. type: TP
#: man-pages/man2/statx.2:357
#, no-wrap
msgid "I<stx_blksize>"
msgstr "I<stx_blksize>"

#. type: Plain text
#: man-pages/man2/statx.2:362
msgid ""
"The \"preferred\" block size for efficient filesystem I/O.  (Writing to a "
"file in smaller chunks may cause an inefficient read-modify-rewrite.)"
msgstr ""
"«Предпочтительный» размер блока для эффективного ввода/вывода в файловой "
"системе (запись в файл более мелкими порциями может привести к "
"неэффективному чтению/изменению/повторной записи)."

#. type: TP
#: man-pages/man2/statx.2:362
#, no-wrap
msgid "I<stx_attributes>"
msgstr "I<stx_attributes>"

#. type: Plain text
#: man-pages/man2/statx.2:365
msgid ""
"Further status information about the file (see below for more information)."
msgstr "Дополнительная информация о состоянии файла (подробности ниже)."

#. type: TP
#: man-pages/man2/statx.2:365
#, no-wrap
msgid "I<stx_nlink>"
msgstr "I<stx_nlink>"

#. type: Plain text
#: man-pages/man2/statx.2:368
msgid "The number of hard links on a file."
msgstr "Количество жёстких ссылок на файл."

#. type: TP
#: man-pages/man2/statx.2:368
#, no-wrap
msgid "I<stx_uid>"
msgstr "I<stx_uid>"

#. type: TP
#: man-pages/man2/statx.2:371
#, no-wrap
msgid "I<stx_gid>"
msgstr "I<stx_gid>"

#. type: TP
#: man-pages/man2/statx.2:374
#, no-wrap
msgid "I<stx_mode>"
msgstr "I<stx_mode>"

#. type: Plain text
#: man-pages/man2/statx.2:380
msgid "The file type and mode.  See B<inode>(7)  for details."
msgstr "Тип файла и режим. Дополнительную информацию смотрите в B<inode>(7)."

#. type: TP
#: man-pages/man2/statx.2:380
#, no-wrap
msgid "I<stx_ino>"
msgstr "I<stx_ino>"

#. type: Plain text
#: man-pages/man2/statx.2:383
msgid "The inode number of the file."
msgstr "Номер иноды файла."

#. type: TP
#: man-pages/man2/statx.2:383
#, no-wrap
msgid "I<stx_size>"
msgstr "I<stx_size>"

#. type: Plain text
#: man-pages/man2/statx.2:388
msgid ""
"The size of the file (if it is a regular file or a symbolic link) in bytes.  "
"The size of a symbolic link is the length of the pathname it contains, "
"without a terminating null byte."
msgstr ""
"Размер файла (если он обычный или является символьной ссылкой) в байтах. "
"Размер символьной ссылки равен длине пути файла, на который она ссылается, "
"без конечного нулевого байта."

#. type: TP
#: man-pages/man2/statx.2:388
#, no-wrap
msgid "I<stx_blocks>"
msgstr "I<stx_blocks>"

#. type: Plain text
#: man-pages/man2/statx.2:394
msgid ""
"The number of blocks allocated to the file on the medium, in 512-byte "
"units.  (This may be smaller than I<stx_size>/512 when the file has holes.)"
msgstr ""
"Количество блоков (по 512 байт), выделенных для файла на носителе (может "
"быть меньше, чем I<stx_size>/512, когда в файле есть пропуски (holes))."

#. type: TP
#: man-pages/man2/statx.2:394
#, no-wrap
msgid "I<stx_attributes_mask>"
msgstr "I<stx_attributes_mask>"

#. type: Plain text
#: man-pages/man2/statx.2:399
msgid ""
"A mask indicating which bits in I<stx_attributes> are supported by the VFS "
"and the filesystem."
msgstr ""
"Маска, показывающая какие биты в I<stx_attributes> поддерживаются VFS и "
"файловой системой."

#. type: TP
#: man-pages/man2/statx.2:399
#, no-wrap
msgid "I<stx_atime>"
msgstr "I<stx_atime>"

#. type: Plain text
#: man-pages/man2/statx.2:402
msgid "The file's last access timestamp."
msgstr "Метка времени последнего доступа к файлу."

#. type: TP
#: man-pages/man2/statx.2:402
#, no-wrap
msgid "I<stx_btime>"
msgstr "I<stx_btime>"

#. type: Plain text
#: man-pages/man2/statx.2:405
msgid "The file's creation timestamp."
msgstr "Метка времени создания файла."

#. type: TP
#: man-pages/man2/statx.2:405
#, no-wrap
msgid "I<stx_ctime>"
msgstr "I<stx_ctime>"

#. type: Plain text
#: man-pages/man2/statx.2:408
msgid "The file's last status change timestamp."
msgstr "Метка времени последнего изменения состояния файла."

#. type: TP
#: man-pages/man2/statx.2:408
#, no-wrap
msgid "I<stx_mtime>"
msgstr "I<stx_mtime>"

#. type: Plain text
#: man-pages/man2/statx.2:411
msgid "The file's last modification timestamp."
msgstr "Метка времени последнего изменения файла."

#. type: TP
#: man-pages/man2/statx.2:411
#, no-wrap
msgid "I<stx_dev_major> and I<stx_dev_minor>"
msgstr "I<stx_dev_major> и I<stx_dev_minor>"

#. type: Plain text
#: man-pages/man2/statx.2:414
msgid "The device on which this file (inode) resides."
msgstr "Устройство, на котором находится файл (инода)."

#. type: TP
#: man-pages/man2/statx.2:414
#, no-wrap
msgid "I<stx_rdev_major> and I<stx_rdev_minor>"
msgstr "I<stx_rdev_major> и I<stx_rdev_minor>"

#. type: Plain text
#: man-pages/man2/statx.2:418
msgid ""
"The device that this file (inode) represents if the file is of block or "
"character device type."
msgstr ""
"Устройство, который этот файл (инода) представляет, если файл имеет блочный "
"или символьный тип устройства."

#. type: SS
#: man-pages/man2/statx.2:422
#, no-wrap
msgid "File attributes"
msgstr "Атрибуты файла"

#. type: Plain text
#: man-pages/man2/statx.2:435
msgid ""
"The I<stx_attributes> field contains a set of ORed flags that indicate "
"additional attributes of the file.  Note that any attribute that is not "
"indicated as supported by I<stx_attributes_mask> has no usable value here.  "
"The bits in I<stx_attributes_mask> correspond bit-by-bit to "
"I<stx_attributes>."
msgstr ""
"В поле I<stx_attributes> содержится набор флагов (объединённых через ИЛИ), "
"которые отображают дополнительные атрибуты файла. Заметим, что для атрибута, "
"не указанного как поддерживаемого в I<stx_attributes_mask>, имеющееся здесь "
"значение является не корректным. Биты I<stx_attributes_mask> точно бит в бит "
"соответствуют битам поля I<stx_attributes>."

#. type: Plain text
#: man-pages/man2/statx.2:437
msgid "The flags are as follows:"
msgstr "Флаги:"

#. type: TP
#: man-pages/man2/statx.2:437
#, no-wrap
msgid "B<STATX_ATTR_COMPRESSED>"
msgstr "B<STATX_ATTR_COMPRESSED>"

#. type: Plain text
#: man-pages/man2/statx.2:441
msgid ""
"The file is compressed by the filesystem and may take extra resources to "
"access."
msgstr ""
"Файл сжат файловой системой и для доступа могут потребоваться дополнительные "
"ресурсы."

#. type: TP
#: man-pages/man2/statx.2:441
#, no-wrap
msgid "B<STATX_ATTR_IMMUTABLE>"
msgstr "B<STATX_ATTR_IMMUTABLE>"

#. type: Plain text
#: man-pages/man2/statx.2:447
msgid ""
"The file cannot be modified: it cannot be deleted or renamed, no hard links "
"can be created to this file and no data can be written to it.  See "
"B<chattr>(1)."
msgstr ""
"Файл невозможно изменить: его нельзя переименовать или удалить, на этот файл "
"нельзя создать жёсткую ссылку и в него нельзя выполнить запись данных. "
"Смотрите B<chattr>(1)."

#. type: TP
#: man-pages/man2/statx.2:447
#, no-wrap
msgid "B<STATX_ATTR_APPEND>"
msgstr "B<STATX_ATTR_APPEND>"

#. type: Plain text
#: man-pages/man2/statx.2:454
msgid ""
"The file can only be opened in append mode for writing.  Random access "
"writing is not permitted.  See B<chattr>(1)."
msgstr ""
"Файл может быть открыт только для записи в режиме добавления. Запись в "
"произвольное место не разрешается. Смотрите B<chattr>(1)."

#. type: TP
#: man-pages/man2/statx.2:454
#, no-wrap
msgid "B<STATX_ATTR_NODUMP>"
msgstr "B<STATX_ATTR_NODUMP>"

#. type: Plain text
#: man-pages/man2/statx.2:461
msgid ""
"File is not a candidate for backup when a backup program such as B<dump>(8)  "
"is run.  See B<chattr>(1)."
msgstr ""
"Файл не предназначен для резервного копирования программой резервного "
"копирования, например B<dump>(8). Смотрите B<chattr>(1)."

#. type: TP
#: man-pages/man2/statx.2:461
#, no-wrap
msgid "B<STATX_ATTR_ENCRYPTED>"
msgstr "B<STATX_ATTR_ENCRYPTED>"

#. type: Plain text
#: man-pages/man2/statx.2:464
msgid "A key is required for the file to be encrypted by the filesystem."
msgstr "Для расшифровки файла файловой системой требуется ключ."

#. type: Plain text
#: man-pages/man2/statx.2:481
msgid "I<dirfd> is not a valid open file descriptor."
msgstr ""
"Значение I<dirfd> не является правильным открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man2/statx.2:488
msgid ""
"I<pathname> or I<statxbuf> is NULL or points to a location outside the "
"process's accessible address space."
msgstr ""
"Значение I<pathname> или I<statxbuf> равно NULL или указывает на "
"расположение вне доступного процессу адресного пространства."

#. type: Plain text
#: man-pages/man2/statx.2:499
msgid ""
"Reserved flag specified in I<mask>.  (Currently, there is one such flag, "
"designated by the constant B<STATX__RESERVED>, with the value 0x80000000U.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:502
msgid "Too many symbolic links encountered while traversing the pathname."
msgstr "Во время определения пути встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/statx.2:516
msgid ""
"A component of I<pathname> does not exist, or I<pathname> is an empty string "
"and B<AT_EMPTY_PATH> was not specified in I<flags>."
msgstr ""
"Компонент пути I<pathname> не существует или в I<pathname> указана пустая "
"строка и в I<flags> не указан B<AT_EMPTY_PATH>."

#. type: Plain text
#: man-pages/man2/statx.2:528
msgid ""
"A component of the path prefix of I<pathname> is not a directory or "
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Компонент префикса пути I<pathname> содержит относительный путь и I<dirfd> "
"содержит файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/statx.2:531
msgid ""
"B<statx>()  was added to Linux in kernel 4.11; library support was added in "
"glibc 2.28."
msgstr ""
"Вызов B<statx>() был добавлен в Linux 4.11; поддержка в glibc доступна с "
"версии 2.28."

#. type: Plain text
#: man-pages/man2/statx.2:534
msgid "B<statx>()  is Linux-specific."
msgstr "Вызов B<statx>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/statx.2:545
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<stat>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<stat>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"

#. type: TH
#: man-pages/man2/syslog.2:33
#, no-wrap
msgid "SYSLOG"
msgstr "SYSLOG"

#. type: Plain text
#: man-pages/man2/syslog.2:37
msgid ""
"syslog, klogctl - read and/or clear kernel message ring buffer; set "
"console_loglevel"
msgstr ""
"syslog, klogctl - читает и/или очищает кольцевой буфер сообщений ядра; "
"устанавливает console_loglevel"

#. type: Plain text
#: man-pages/man2/syslog.2:41
#, no-wrap
msgid ""
"B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
"B</* No wrapper provided in glibc */>\n"
msgstr ""
"B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
"B</* не имеет обёртки в glibc */>\n"

#. type: Plain text
#: man-pages/man2/syslog.2:44
#, no-wrap
msgid ""
"/* The glibc interface */\n"
"B<#include E<lt>sys/klog.hE<gt>>\n"
msgstr ""
"/* интерфейс glibc */\n"
"B<#include E<lt>sys/klog.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/syslog.2:46
#, no-wrap
msgid "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
msgstr "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/syslog.2:56
msgid ""
"I<Note>: Probably, you are looking for the C library function B<syslog>(), "
"which talks to B<syslogd>(8); see B<syslog>(3)  for details."
msgstr ""
"I<Замечание>: Вероятно, вы ищете библиотечную функцию Си B<syslog>(), "
"которая описана в B<syslogd>(8); подробности смотрите в B<syslog>(3)."

#. type: Plain text
#: man-pages/man2/syslog.2:63
msgid ""
"This page describes the kernel B<syslog>()  system call, which is used to "
"control the kernel I<printk>()  buffer; the glibc wrapper function for the "
"system call is called B<klogctl>()."
msgstr ""
"В этой странице описана системный вызов ядра B<syslog>(), который "
"используется для управления буфером I<printk>() в ядре; обёрточная функция "
"glibc для данного системного вызова называется B<klogctl>()."

#. type: SS
#: man-pages/man2/syslog.2:63
#, no-wrap
msgid "The kernel log buffer"
msgstr "Буфер журнала ядра"

#.  Under "General setup" ==> "Kernel log buffer size"
#.  For 2.6, precisely the option seems to have appeared in 2.5.55.
#. type: Plain text
#: man-pages/man2/syslog.2:80
msgid ""
"The kernel has a cyclic buffer of length B<LOG_BUF_LEN> in which messages "
"given as arguments to the kernel function B<printk>()  are stored "
"(regardless of their log level).  In early kernels, B<LOG_BUF_LEN> had the "
"value 4096; from kernel 1.3.54, it was 8192; from kernel 2.1.113, it was "
"16384; since kernel 2.4.23/2.6, the value is a kernel configuration option "
"(B<CONFIG_LOG_BUF_SHIFT>, default value dependent on the architecture).  "
"Since Linux 2.6.6, the size can be queried with command type 10 (see below)."
msgstr ""
"В ядре существует кольцевой буфер длиной B<LOG_BUF_LEN>, в котором хранятся "
"сообщения, переданные через аргументы функции ядра B<printk>() (независимо "
"от их уровня). В ранних версиях ядра значение B<LOG_BUF_LEN> было равно "
"4096, начиная с ядра 1.3.54 оно стало 8192, а начиная с 2.1.113 — 16384. "
"Начиная с версии 2.4.23/2.6 его значение задаётся в параметрах настройки "
"ядра (B<CONFIG_LOG_BUF_SHIFT>, значение по умолчанию зависит от "
"архитектуры). Начиная с Linux 2.6.6, размер можно узнать по команде 10 "
"(смотрите далее)."

#. type: SS
#: man-pages/man2/syslog.2:80
#, no-wrap
msgid "Commands"
msgstr "Команды"

#. type: Plain text
#: man-pages/man2/syslog.2:87
msgid ""
"The I<type> argument determines the action taken by this function.  The list "
"below specifies the values for I<type>.  The symbolic names are defined in "
"the kernel source, but are not exported to user space; you will either need "
"to use the numbers, or define the names yourself."
msgstr ""
"В аргументе I<type> задаётся действие функции. Далее приводится список со "
"всеми значениями I<type>. Символические имена определены в исходном коде "
"ядра, но не экспортируются в пользовательское пространство; вы должны "
"использовать или номера, или определить имена самостоятельно."

#. type: TP
#: man-pages/man2/syslog.2:87
#, no-wrap
msgid "B<SYSLOG_ACTION_CLOSE> (0)"
msgstr "B<SYSLOG_ACTION_CLOSE> (0)"

#. type: Plain text
#: man-pages/man2/syslog.2:91
msgid "Close the log.  Currently a NOP."
msgstr "Закрыть журнал. Ничего не делает."

#. type: TP
#: man-pages/man2/syslog.2:91
#, no-wrap
msgid "B<SYSLOG_ACTION_OPEN> (1)"
msgstr "B<SYSLOG_ACTION_OPEN> (1)"

#. type: Plain text
#: man-pages/man2/syslog.2:95
msgid "Open the log.  Currently a NOP."
msgstr "Открыть журнал. Ничего не делает."

#. type: TP
#: man-pages/man2/syslog.2:95
#, no-wrap
msgid "B<SYSLOG_ACTION_READ> (2)"
msgstr "B<SYSLOG_ACTION_READ> (2)"

#. type: Plain text
#: man-pages/man2/syslog.2:107
msgid ""
"Read from the log.  The call waits until the kernel log buffer is nonempty, "
"and then reads at most I<len> bytes into the buffer pointed to by I<bufp>.  "
"The call returns the number of bytes read.  Bytes read from the log "
"disappear from the log buffer: the information can be read only once.  This "
"is the function executed by the kernel when a user program reads I</proc/"
"kmsg>."
msgstr ""
"Читать из журнала. Вызов ждёт пока в буфере журнала ядра что-нибудь не "
"появится и затем записывает максимум I<len> байт в буфер, указанный I<bufp>. "
"Вызов возвращает количество прочитанных байт. Байты, прочитанные из журнала, "
"исчезают из буфера журнала: информацию можно прочесть только один раз. Эта "
"функция используется ядром когда пользовательская программа читает файл I</"
"proc/kmsg>."

#. type: TP
#: man-pages/man2/syslog.2:107
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_ALL> (3)"
msgstr "B<SYSLOG_ACTION_READ_ALL> (3)"

#. type: Plain text
#: man-pages/man2/syslog.2:117
msgid ""
"Read all messages remaining in the ring buffer, placing them in the buffer "
"pointed to by I<bufp>.  The call reads the last I<len> bytes from the log "
"buffer (nondestructively), but will not read more than was written into the "
"buffer since the last \"clear ring buffer\" command (see command 5 below)).  "
"The call returns the number of bytes read."
msgstr ""
"Читать все сообщения, оставшиеся в кольцевом буфере, помещая их в буфер, "
"указанный в I<bufp>. Вызов читает последние I<len> байт из буфера журнала "
"(не разрушая его), но не больше, чем было записано в буфер с момента вызова "
"команды «очистка кольцевого буфера» (смотрите команду 5 далее). Вызов "
"возвращает количество прочитанных байт."

#. type: TP
#: man-pages/man2/syslog.2:117
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_CLEAR> (4)"
msgstr "B<SYSLOG_ACTION_READ_CLEAR> (4)"

#. type: Plain text
#: man-pages/man2/syslog.2:123
msgid ""
"Read and clear all messages remaining in the ring buffer.  The call does "
"precisely the same as for a I<type> of 3, but also executes the \"clear ring "
"buffer\" command."
msgstr ""
"Прочитать и стереть все сообщения, оставшиеся в кольцевом буфере. Вызов "
"выполняет то же самое, что и  при I<type> равном 3, но ещё вызывает команду "
"«очистка кольцевого буфера»."

#. type: TP
#: man-pages/man2/syslog.2:123
#, no-wrap
msgid "B<SYSLOG_ACTION_CLEAR> (5)"
msgstr "B<SYSLOG_ACTION_CLEAR> (5)"

#. type: Plain text
#: man-pages/man2/syslog.2:131
msgid ""
"The call executes just the \"clear ring buffer\" command.  The I<bufp> and "
"I<len> arguments are ignored."
msgstr ""
"Вызов просто исполняет команду «очистка кольцевого буфера». Аргументы "
"I<bufp> и I<len> игнорируются."

#. type: Plain text
#: man-pages/man2/syslog.2:142
msgid ""
"This command does not really clear the ring buffer.  Rather, it sets a "
"kernel bookkeeping variable that determines the results returned by commands "
"3 (B<SYSLOG_ACTION_READ_ALL>)  and 4 (B<SYSLOG_ACTION_READ_CLEAR>).  This "
"command has no effect on commands 2 (B<SYSLOG_ACTION_READ>)  and 9 "
"(B<SYSLOG_ACTION_SIZE_UNREAD>)."
msgstr ""
"Эта команда на самом деле не очищает кольцевой буфер. Вместо этого она "
"изменяет переменную учёта в ядре, которая определяет результат, возвращаемый "
"командами 3 (B<SYSLOG_ACTION_READ_ALL>)  и 4 (B<SYSLOG_ACTION_READ_CLEAR>). "
"Эта команда не влияет на команды 2 (B<SYSLOG_ACTION_READ>) и 9 "
"(B<SYSLOG_ACTION_SIZE_UNREAD>)."

#. type: TP
#: man-pages/man2/syslog.2:142
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"
msgstr "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: man-pages/man2/syslog.2:160
msgid ""
"The command saves the current value of I<console_loglevel> and then sets "
"I<console_loglevel> to I<minimum_console_loglevel>, so that no messages are "
"printed to the console.  Before Linux 2.6.32, the command simply sets "
"I<console_loglevel> to I<minimum_console_loglevel>.  See the discussion of "
"I</proc/sys/kernel/printk>, below."
msgstr ""
"Данная команда сохраняет текущее значение I<console_loglevel> и затем "
"устанавливает I<console_loglevel> равным I<minimum_console_loglevel>, что "
"приводит к отключению вывода сообщений на консоль. До Linux 2.6.32, эта "
"команда просто изменяла I<console_loglevel> на I<minimum_console_loglevel>.  "
"Смотрите описание I</proc/sys/kernel/printk> далее."

#. type: Plain text
#: man-pages/man2/syslog.2:166 man-pages/man2/syslog.2:189
msgid "The I<bufp> and I<len> arguments are ignored."
msgstr "Аргументы I<bufp> и I<len> игнорируются."

#. type: TP
#: man-pages/man2/syslog.2:166
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_ON> (7)"
msgstr "B<SYSLOG_ACTION_CONSOLE_ON> (7)"

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: man-pages/man2/syslog.2:183
msgid ""
"If a previous B<SYSLOG_ACTION_CONSOLE_OFF> command has been performed, this "
"command restores I<console_loglevel> to the value that was saved by that "
"command.  Before Linux 2.6.32, this command simply sets I<console_loglevel> "
"to I<default_console_loglevel>.  See the discussion of I</proc/sys/kernel/"
"printk>, below."
msgstr ""
"Если ранее выполнялась команда B<SYSLOG_ACTION_CONSOLE_OFF>, то эта команда "
"восстанавливает значение I<console_loglevel>, которое было сохранено. До "
"Linux 2.6.32 эта команда просто изменяла I<console_loglevel> на "
"I<default_console_loglevel>. Смотрите описание I</proc/sys/kernel/printk> "
"ниже."

#. type: TP
#: man-pages/man2/syslog.2:189
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"
msgstr "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"

#. type: Plain text
#: man-pages/man2/syslog.2:206
msgid ""
"The call sets I<console_loglevel> to the value given in I<len>, which must "
"be an integer between 1 and 8 (inclusive).  The kernel silently enforces a "
"minimum value of I<minimum_console_loglevel> for I<len>.  See the I<log "
"level> section for details.  The I<bufp> argument is ignored."
msgstr ""
"Вызов присваивает I<console_loglevel> значение, указанное в I<len>, которое "
"должно быть целым числом от 1 до 8 (включительно). Ядро неявно изменяет "
"минимальное значение I<minimum_console_loglevel> на I<len>. Подробности "
"смотрите в разделе B<Уровень протоколирования>. Аргумент I<bufp> "
"игнорируется."

#. type: TP
#: man-pages/man2/syslog.2:206
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (since Linux 2.4.10)"
msgstr "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (начиная с Linux 2.4.10)"

#. type: Plain text
#: man-pages/man2/syslog.2:217
msgid ""
"The call returns the number of bytes currently available to be read from the "
"kernel log buffer via command 2 (B<SYSLOG_ACTION_READ>).  The I<bufp> and "
"I<len> arguments are ignored."
msgstr ""
"Вызов возвращает количество байт, доступных для чтения из буфера журнала "
"ядра командой 2 (B<SYSLOG_ACTION_READ>). Аргументы I<bufp> и I<len> "
"игнорируются."

#. type: TP
#: man-pages/man2/syslog.2:217
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (since Linux 2.6.6)"
msgstr "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (начиная с Linux 2.6.6)"

#. type: Plain text
#: man-pages/man2/syslog.2:225
msgid ""
"This command returns the total size of the kernel log buffer.  The I<bufp> "
"and I<len> arguments are ignored."
msgstr ""
"Эта команда возвращает полный размер буфера журнала ядра. Аргументы I<bufp> "
"и I<len> игнорируются."

#. type: Plain text
#: man-pages/man2/syslog.2:244
msgid ""
"All commands except 3 and 10 require privilege.  In Linux kernels before "
"2.6.37, command types 3 and 10 are allowed to unprivileged processes; since "
"Linux 2.6.37, these commands are allowed to unprivileged processes only if "
"I</proc/sys/kernel/dmesg_restrict> has the value 0.  Before Linux 2.6.37, "
"\"privileged\" means that the caller has the B<CAP_SYS_ADMIN> capability.  "
"Since Linux 2.6.37, \"privileged\" means that the caller has either the "
"B<CAP_SYS_ADMIN> capability (now deprecated for this purpose) or the (new)  "
"B<CAP_SYSLOG> capability."
msgstr ""
"Все команды кроме 3 и 10 требуют привилегий. В ядрах Linux до версии 2.6.37, "
"команды 3 и 10 были доступны непривилегированным процессам; начиная с Linux "
"2.6.37, эти команды разрешены из непривилегированных процессов только, если "
"значение I</proc/sys/kernel/dmesg_restrict> равно 0. До Linux 2.6.37 под "
"«привилегиями» понималось, что вызывающий имеет мандат B<CAP_SYS_ADMIN>. "
"Начиная с Linux 2.6.37 «привилегией» считается, что вызывающий имеет либо "
"мандат B<CAP_SYS_ADMIN> (теперь устарел для такого использования), либо "
"(новый) мандат B<CAP_SYSLOG>."

#. type: SS
#: man-pages/man2/syslog.2:244
#, no-wrap
msgid "/proc/sys/kernel/printk"
msgstr "I</proc/sys/kernel/printk>"

#. type: Plain text
#: man-pages/man2/syslog.2:250
msgid ""
"I</proc/sys/kernel/printk> is a writable file containing four integer values "
"that influence kernel I<printk()> behavior when printing or logging error "
"messages.  The four values are:"
msgstr ""
"Файл I</proc/sys/kernel/printk> доступен на запись и содержит 4 "
"целочисленных значения, которыми управляется поведение ядерного I<printk()> "
"при печати или протоколировании сообщений об ошибках. Четыре значения:"

#. type: TP
#: man-pages/man2/syslog.2:250
#, no-wrap
msgid "I<console_loglevel>"
msgstr "I<console_loglevel>"

#.  since Linux 2.4
#. type: Plain text
#: man-pages/man2/syslog.2:268
msgid ""
"Only messages with a log level lower than this value will be printed to the "
"console.  The default value for this field is B<DEFAULT_CONSOLE_LOGLEVEL> "
"(7), but it is set to 4 if the kernel command line contains the word \"quiet"
"\", 10 if the kernel command line contains the word \"debug\", and to 15 in "
"case of a kernel fault (the 10 and 15 are just silly, and equivalent to 8).  "
"The value of I<console_loglevel> can be set (to a value in the range "
"1\\(en8) by a B<syslog>()  call with a I<type> of 8."
msgstr ""
"На консоль выводятся только сообщения, у которых уровень протоколирования "
"меньше этого значения. По умолчанию значение этой переменной равно "
"B<DEFAULT_CONSOLE_LOGLEVEL> (7), но это значение будет равно 4, если "
"командная строка ядра содержит слово «quiet»; 10 — если командная строка "
"ядра содержит слово «debug», и 15 — в случае ошибки ядра (10 и 15 не имеют "
"большого смысла и аналогичны ). Значение (из диапазона от 1 до 8) "
"I<console_loglevel> устанавливается вызовом B<syslog>() с I<type> равным 8."

#. type: TP
#: man-pages/man2/syslog.2:268
#, no-wrap
msgid "I<default_message_loglevel>"
msgstr "I<default_message_loglevel>"

#.  commit 5af5bcb8d37f99ba415a1adc6da71051b84f93a5
#. type: Plain text
#: man-pages/man2/syslog.2:281
msgid ""
"This value will be used as the log level for I<printk()> messages that do "
"not have an explicit level.  Up to and including Linux 2.6.38, the hard-"
"coded default value for this field was 4 (B<KERN_WARNING>); since Linux "
"2.6.39, the default value is a defined by the kernel configuration option "
"B<CONFIG_DEFAULT_MESSAGE_LOGLEVEL>, which defaults to 4."
msgstr ""
"Это значение будет использовано как уровень протоколирования сообщений "
"I<printk()>, у которых уровень не указан. До версии Linux 2.6.38 "
"включительно это поле содержало неизменяемое значение 4 (B<KERN_WARNING>); "
"начиная с Linux 2.6.39, значение по умолчанию задаётся в параметре настройки "
"ядра B<CONFIG_DEFAULT_MESSAGE_LOGLEVEL> и по умолчанию равно 4."

#. type: TP
#: man-pages/man2/syslog.2:281
#, no-wrap
msgid "I<minimum_console_loglevel>"
msgstr "I<minimum_console_loglevel>"

#. type: Plain text
#: man-pages/man2/syslog.2:286
msgid ""
"The value in this field is the minimum value to which I<console_loglevel> "
"can be set."
msgstr ""
"Значение этого поля — минимальное значение, которое может быть указано в "
"I<console_loglevel>."

#. type: TP
#: man-pages/man2/syslog.2:286
#, no-wrap
msgid "I<default_console_loglevel>"
msgstr "I<default_console_loglevel>"

#. type: Plain text
#: man-pages/man2/syslog.2:292
msgid "This is the default value for I<console_loglevel>."
msgstr "Это значение по умолчанию для I<console_loglevel>."

#. type: SS
#: man-pages/man2/syslog.2:292
#, no-wrap
msgid "The log level"
msgstr "Уровень протоколирования"

#. type: Plain text
#: man-pages/man2/syslog.2:300
msgid ""
"Every I<printk>()  message has its own log level.  If the log level is not "
"explicitly specified as part of the message, it defaults to "
"I<default_message_loglevel>.  The conventional meaning of the log level is "
"as follows:"
msgstr ""
"Каждое сообщение I<printk>() имеет свой уровень протоколирования. Если "
"уровень протоколирования явно не задан в сообщении, то по умолчанию оно "
"равно I<default_message_loglevel>. Для удобства имеются следующие уровни "
"протоколирования:"

#. type: tbl table
#: man-pages/man2/syslog.2:303
#, no-wrap
msgid "Kernel constant"
msgstr "Ядерные постоянные"

#. type: tbl table
#: man-pages/man2/syslog.2:303
#, no-wrap
msgid "Level value"
msgstr "Уровень"

#. type: tbl table
#: man-pages/man2/syslog.2:303
#, no-wrap
msgid "Meaning"
msgstr "Смысл"

#. type: tbl table
#: man-pages/man2/syslog.2:304
#, no-wrap
msgid "KERN_EMERG"
msgstr "B<KERN_EMERG>"

#. type: tbl table
#: man-pages/man2/syslog.2:304
#, no-wrap
msgid "System is unusable"
msgstr "Система не пригодна к использованию "

#. type: tbl table
#: man-pages/man2/syslog.2:305
#, no-wrap
msgid "KERN_ALERT"
msgstr "B<KERN_ALERT>"

#. type: tbl table
#: man-pages/man2/syslog.2:305
#, no-wrap
msgid "Action must be taken immediately"
msgstr "Необходимо немедленно принять меры"

#. type: tbl table
#: man-pages/man2/syslog.2:306
#, no-wrap
msgid "KERN_CRIT"
msgstr "B<KERN_CRIT>"

#. type: tbl table
#: man-pages/man2/syslog.2:306
#, no-wrap
msgid "Critical conditions"
msgstr "Условная паника"

#. type: tbl table
#: man-pages/man2/syslog.2:307
#, no-wrap
msgid "KERN_ERR"
msgstr "B<KERN_ERR>"

#. type: tbl table
#: man-pages/man2/syslog.2:307
#, no-wrap
msgid "3"
msgstr "3"

#. type: tbl table
#: man-pages/man2/syslog.2:307
#, no-wrap
msgid "Error conditions"
msgstr "Условные ошибки "

#. type: tbl table
#: man-pages/man2/syslog.2:308
#, no-wrap
msgid "KERN_WARNING"
msgstr "B<KERN_WARNING>"

#. type: tbl table
#: man-pages/man2/syslog.2:308
#, no-wrap
msgid "Warning conditions"
msgstr "Условные предупреждения "

#. type: tbl table
#: man-pages/man2/syslog.2:309
#, no-wrap
msgid "KERN_NOTICE"
msgstr "B<KERN_NOTICE>"

#. type: tbl table
#: man-pages/man2/syslog.2:309
#, no-wrap
msgid "5"
msgstr "5"

#. type: tbl table
#: man-pages/man2/syslog.2:309
#, no-wrap
msgid "Normal but significant condition"
msgstr "Обычное, но важное условие"

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "KERN_INFO"
msgstr "B<KERN_INFO>"

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "6"
msgstr "6"

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "Informational"
msgstr "Информационное сообщение"

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "KERN_DEBUG"
msgstr "B<KERN_DEBUG>"

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "7"
msgstr "7"

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "Debug-level messages"
msgstr "Cообщения уровня отладки"

#. type: Plain text
#: man-pages/man2/syslog.2:319
msgid ""
"The kernel I<printk()> routine will print a message on the console only if "
"it has a log level less than the value of I<console_loglevel>."
msgstr ""
"Ядерная процедура I<printk()> печатает сообщение на консоль только, если его "
"уровень протоколирования меньше значения I<console_loglevel>."

#. type: Plain text
#: man-pages/man2/syslog.2:332
msgid ""
"For I<type> equal to 2, 3, or 4, a successful call to B<syslog>()  returns "
"the number of bytes read.  For I<type> 9, B<syslog>()  returns the number of "
"bytes currently available to be read on the kernel log buffer.  For I<type> "
"10, B<syslog>()  returns the total size of the kernel log buffer.  For other "
"values of I<type>, 0 is returned on success."
msgstr ""
"При успешном выполнении и если I<type> равно 2, 3 или 4, B<syslog>() "
"возвращает количество прочитанных байт. При I<type> равном 9, B<syslog>() "
"возвращает количество байт, доступных для чтения из кольцевого буфера ядра. "
"При I<type> равном 10, B<syslog>() возвращает полный размер кольцевого "
"буфера ядра. При других значениях I<type> и успешном выполнении возвращается "
"0."

#. type: Plain text
#: man-pages/man2/syslog.2:335
msgid ""
"In case of error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"При ошибке возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/syslog.2:353
msgid ""
"Bad arguments (e.g., bad I<type>; or for I<type> 2, 3, or 4, I<buf> is NULL, "
"or I<len> is less than zero; or for I<type> 8, the I<level> is outside the "
"range 1 to 8)."
msgstr ""
"Неправильные значения параметров (например, некорректное значение I<type>; "
"при I<type> равном 2, 3,  4, значение I<buf> равно NULL или значение I<len> "
"меньше нуля; при I<type> равном 8, значение I<level> лежит вне диапазона от "
"1 до 8)."

#. type: Plain text
#: man-pages/man2/syslog.2:360
msgid ""
"This B<syslog>()  system call is not available, because the kernel was "
"compiled with the B<CONFIG_PRINTK> kernel-configuration option disabled."
msgstr ""
"Системный вызов B<syslog>() недоступен, так как ядро было собрано с "
"отключённым параметром B<CONFIG_PRINTK>."

#. type: Plain text
#: man-pages/man2/syslog.2:371
msgid ""
"An attempt was made to change I<console_loglevel> or clear the kernel "
"message ring buffer by a process without sufficient privilege (more "
"precisely: without the B<CAP_SYS_ADMIN> or B<CAP_SYSLOG> capability)."
msgstr ""
"Процесс, не имеющий необходимых прав (мандата B<CAP_SYS_ADMIN> или "
"B<CAP_SYSLOG>), пытался изменить I<console_loglevel> или очистить кольцевой "
"буфер сообщений ядра."

#. type: TP
#: man-pages/man2/syslog.2:371
#, no-wrap
msgid "B<ERESTARTSYS>"
msgstr "B<ERESTARTSYS>"

#. type: Plain text
#: man-pages/man2/syslog.2:375
msgid ""
"System call was interrupted by a signal; nothing was read.  (This can be "
"seen only during a trace.)"
msgstr ""
"Системный вызов был прерван сигналом; ничего не было прочитано (может быть "
"замечено только при трассировке)."

#. type: Plain text
#: man-pages/man2/syslog.2:378
msgid ""
"This system call is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"Данный системный вызов существует только в Linux и не должен использоваться "
"переносимых программах."

#.  In libc4 and libc5 the number of this call was defined by
#.  .BR SYS_klog .
#.  In glibc 2.0 the syscall is baptized
#.  .BR klogctl ().
#. type: Plain text
#: man-pages/man2/syslog.2:386
msgid ""
"From the very start, people noted that it is unfortunate that a system call "
"and a library routine of the same name are entirely different animals."
msgstr ""
"С самого начала многим не нравится, что вызов ядра и библиотечная функция с "
"одинаковыми именами делают совершенно разные вещи."

#. type: Plain text
#: man-pages/man2/syslog.2:389
msgid "B<dmesg>(1), B<syslog>(3), B<capabilities>(7)"
msgstr "B<dmesg>(1), B<syslog>(3), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/seccomp.2:28
#, no-wrap
msgid "SECCOMP"
msgstr "SECCOMP"

#. type: Plain text
#: man-pages/man2/seccomp.2:31
msgid "seccomp - operate on Secure Computing state of the process"
msgstr "seccomp - переводит процесс в состояние безопасных вычислений"

#.  Kees Cook noted: Anything that uses SECCOMP_RET_TRACE returns will
#.                   need <sys/ptrace.h>
#. type: Plain text
#: man-pages/man2/seccomp.2:40
#, no-wrap
msgid ""
"B<#include E<lt>linux/seccomp.hE<gt>>\n"
"B<#include E<lt>linux/filter.hE<gt>>\n"
"B<#include E<lt>linux/audit.hE<gt>>\n"
"B<#include E<lt>linux/signal.hE<gt>>\n"
"B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/seccomp.hE<gt>>\n"
"B<#include E<lt>linux/filter.hE<gt>>\n"
"B<#include E<lt>linux/audit.hE<gt>>\n"
"B<#include E<lt>linux/signal.hE<gt>>\n"
"B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:43
#, no-wrap
msgid "B<int seccomp(unsigned int >I<operation>B<, unsigned int >I<flags>B<, void *>I<args>B<);>\n"
msgstr "B<int seccomp(unsigned int >I<operation>B<, unsigned int >I<flags>B<, void *>I<args>B<);>\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:49
msgid ""
"The B<seccomp>()  system call operates on the Secure Computing (seccomp) "
"state of the calling process."
msgstr ""
"Системный вызов B<seccomp>() переводит вызвавший процесс в состояние "
"безопасных вычислений (Secure Computing, seccomp)."

#. type: Plain text
#: man-pages/man2/seccomp.2:53
msgid "Currently, Linux supports the following I<operation> values:"
msgstr ""
"В настоящее время в Linux поддерживаются следующие значения I<operation>:"

#. type: TP
#: man-pages/man2/seccomp.2:53
#, no-wrap
msgid "B<SECCOMP_SET_MODE_STRICT>"
msgstr "B<SECCOMP_SET_MODE_STRICT>"

#. type: Plain text
#: man-pages/man2/seccomp.2:69
msgid ""
"The only system calls that the calling thread is permitted to make are "
"B<read>(2), B<write>(2), B<_exit>(2)  (but not B<exit_group>(2)), and "
"B<sigreturn>(2).  Other system calls result in the delivery of a B<SIGKILL> "
"signal.  Strict secure computing mode is useful for number-crunching "
"applications that may need to execute untrusted byte code, perhaps obtained "
"by reading from a pipe or socket."
msgstr ""
"Вызвавшей нити доступны только системные вызовы B<read>(2), B<write>(2), "
"B<_exit>(2) (но не B<exit_group>(2)) и B<sigreturn>(2). При запуске других "
"системных вызовов генерируется сигнал B<SIGKILL>. Строгий режим безопасных "
"вычислений полезен для вычислительных приложений, которым может "
"потребоваться выполнить недоверительный байт-код, возможно полученный при "
"чтении из канала или сокета."

#. type: Plain text
#: man-pages/man2/seccomp.2:96
msgid ""
"Note that although the calling thread can no longer call B<sigprocmask>(2), "
"it can use B<sigreturn>(2)  to block all signals apart from B<SIGKILL> and "
"B<SIGSTOP>.  This means that B<alarm>(2)  (for example) is not sufficient "
"for restricting the process's execution time.  Instead, to reliably "
"terminate the process, B<SIGKILL> must be used.  This can be done by using "
"B<timer_create>(2)  with B<SIGEV_SIGNAL> and I<sigev_signo> set to "
"B<SIGKILL>, or by using B<setrlimit>(2)  to set the hard limit for "
"B<RLIMIT_CPU>."
msgstr ""
"Заметим, что хотя вызывающая нить больше не вызывает B<sigprocmask>(2), она "
"может использовать B<sigreturn>(2) для блокировки всех сигналов (кроме "
"B<SIGKILL> и B<SIGSTOP>). Это означает, что B<alarm>(2) (например) "
"недостаточно для ограничения времени выполнения процесса. Вместо него для "
"надёжного завершения процесса нужно использовать B<SIGKILL>. Это можно "
"сделать с помощью B<timer_create>(2) с B<SIGEV_SIGNAL> и I<sigev_signo> "
"равным B<SIGKILL>, или используя B<setrlimit>(2) для задания жёсткого "
"ограничения по B<RLIMIT_CPU>."

#. type: Plain text
#: man-pages/man2/seccomp.2:100
msgid ""
"This operation is available only if the kernel is configured with "
"B<CONFIG_SECCOMP> enabled."
msgstr ""
"Эта операция доступна только, если в ядре включён параметр B<CONFIG_SECCOMP>."

#. type: Plain text
#: man-pages/man2/seccomp.2:106
msgid "The value of I<flags> must be 0, and I<args> must be NULL."
msgstr "Значение I<flags> должно быть равно 0, а I<args> — NULL."

#. type: Plain text
#: man-pages/man2/seccomp.2:108
msgid "This operation is functionally identical to the call:"
msgstr "Эта операция функционально идентична вызову:"

#. type: Plain text
#: man-pages/man2/seccomp.2:112
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n"
msgstr "prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n"

#. type: TP
#: man-pages/man2/seccomp.2:114
#, no-wrap
msgid "B<SECCOMP_SET_MODE_FILTER>"
msgstr "B<SECCOMP_SET_MODE_FILTER>"

#. type: Plain text
#: man-pages/man2/seccomp.2:129
msgid ""
"The system calls allowed are defined by a pointer to a Berkeley Packet "
"Filter (BPF) passed via I<args>.  This argument is a pointer to a I<struct\\ "
"sock_fprog>; it can be designed to filter arbitrary system calls and system "
"call arguments.  If the filter is invalid, B<seccomp>()  fails, returning "
"B<EINVAL> in I<errno>."
msgstr ""
"Разрешённые системные вызовы определяются указателем на Berkeley Packet "
"Filter (BPF), передаваемый через I<args>. Данный аргумент является "
"указателем на I<struct\\ sock_fprog>; эту структуру можно использовать для "
"отбора произвольных системных вызовов и их аргументов. Если фильтр "
"некорректен, то B<seccomp>() завершается с ошибкой B<EINVAL> в I<errno>."

#. type: Plain text
#: man-pages/man2/seccomp.2:141
msgid ""
"If B<fork>(2)  or B<clone>(2)  is allowed by the filter, any child processes "
"will be constrained to the same system call filters as the parent.  If "
"B<execve>(2)  is allowed, the existing filters will be preserved across a "
"call to B<execve>(2)."
msgstr ""
"Если фильтром разрешён B<fork>(2) или B<clone>(2), то все потомки будут "
"ограничены тем же фильтром системных вызовов что и родитель. Если разрешён "
"B<execve>(2), то существующий фильтр сохраняется и после вызова B<execve>(2)."

#. type: Plain text
#: man-pages/man2/seccomp.2:151
msgid ""
"In order to use the B<SECCOMP_SET_MODE_FILTER> operation, either the calling "
"thread must have the B<CAP_SYS_ADMIN> capability in its user namespace, or "
"the thread must already have the I<no_new_privs> bit set.  If that bit was "
"not already set by an ancestor of this thread, the thread must make the "
"following call:"
msgstr ""
"Чтобы использовать операцию B<SECCOMP_SET_MODE_FILTER> вызывающая нить "
"должна иметь мандат B<CAP_SYS_ADMIN> в своём пространстве имён пользователя "
"или у нити уже должен быть установлен бит I<no_new_privs>. Если этот бит не "
"установлен предком этой нити, то в нити нужно сделать следующий вызов:"

#. type: Plain text
#: man-pages/man2/seccomp.2:155
#, no-wrap
msgid "prctl(PR_SET_NO_NEW_PRIVS, 1);\n"
msgstr "prctl(PR_SET_NO_NEW_PRIVS, 1);\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:176
msgid ""
"Otherwise, the B<SECCOMP_SET_MODE_FILTER> operation fails and returns "
"B<EACCES> in I<errno>.  This requirement ensures that an unprivileged "
"process cannot apply a malicious filter and then invoke a set-user-ID or "
"other privileged program using B<execve>(2), thus potentially compromising "
"that program.  (Such a malicious filter might, for example, cause an attempt "
"to use B<setuid>(2)  to set the caller's user IDs to nonzero values to "
"instead return 0 without actually making the system call.  Thus, the program "
"might be tricked into retaining superuser privileges in circumstances where "
"it is possible to influence it to do dangerous things because it did not "
"actually drop privileges.)"
msgstr ""
"В противном случае операция B<SECCOMP_SET_MODE_FILTER> завершается ошибкой и "
"возвращает B<EACCES> в I<errno>. Данное требование гарантирует, что "
"непривилегированный процесс не сможет применить вредоносный фильтр и вызвать "
"программу с set-user-ID или другую привилегированную программу с помощью "
"B<execve>(2), то есть потенциально подвергнуть эту программу опасности "
"(такой вредоносный фильтр может, например, заставить попытаться использовать "
"B<setuid>(2) для установки ID вызывающего пользователя в ненулевые значения "
"вместо возврата 0 без действительного запуска системного вызова. Таким "
"образом, программа может быть обманута и остаться с правами "
"суперпользователя в окружении, где возможно заставить её сделать что-то "
"опасное, так как в действительности она не отказалась от своих прав)."

#. type: Plain text
#: man-pages/man2/seccomp.2:184
msgid ""
"If B<prctl>(2)  or B<seccomp>()  is allowed by the attached filter, further "
"filters may be added.  This will increase evaluation time, but allows for "
"further reduction of the attack surface during execution of a thread."
msgstr ""
"Если B<prctl>(2) или B<seccomp>() разрешены присоединённым фильтром, то "
"могут быть добавлены дополнительные фильтры. Это увеличит время вычисления, "
"но в дальнейшем позволит сократить область атаки при выполнении нити."

#. type: Plain text
#: man-pages/man2/seccomp.2:190
msgid ""
"The B<SECCOMP_SET_MODE_FILTER> operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""
"Операция B<SECCOMP_SET_MODE_FILTER> доступна только, если в ядре включён "
"параметр B<CONFIG_SECCOMP_FILTER>."

#. type: Plain text
#: man-pages/man2/seccomp.2:194
msgid ""
"When I<flags> is 0, this operation is functionally identical to the call:"
msgstr ""
"Если значение I<flags> равно 0, то эта операция функционально идентична "
"вызову:"

#. type: Plain text
#: man-pages/man2/seccomp.2:198
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);\n"
msgstr "prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:204
msgid "The recognized I<flags> are:"
msgstr "Возможные значения I<flags>:"

#. type: TP
#: man-pages/man2/seccomp.2:205
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_TSYNC>"
msgstr "B<SECCOMP_FILTER_FLAG_TSYNC>"

#. type: Plain text
#: man-pages/man2/seccomp.2:213
msgid ""
"When adding a new filter, synchronize all other threads of the calling "
"process to the same seccomp filter tree.  A \"filter tree\" is the ordered "
"list of filters attached to a thread.  (Attaching identical filters in "
"separate B<seccomp>()  calls results in different filters from this "
"perspective.)"
msgstr ""
"При добавлении нового фильтра, выполнять синхронизацию с одним деревом "
"фильтров seccomp все нити вызывающего процесса. «Дерево фильтров» — "
"упорядоченный список фильтров, присоединённых к нити (присоединённые "
"одинаковые фильтры отдельными вызовами B<seccomp>() считаются разными "
"фильтрами, с этой точки зрения)."

#. type: Plain text
#: man-pages/man2/seccomp.2:221
msgid ""
"If any thread cannot synchronize to the same filter tree, the call will not "
"attach the new seccomp filter, and will fail, returning the first thread ID "
"found that cannot synchronize.  Synchronization will fail if another thread "
"in the same process is in B<SECCOMP_MODE_STRICT> or if it has attached new "
"seccomp filters to itself, diverging from the calling thread's filter tree."
msgstr ""
"Если в какой-то нити невозможна синхронизация с единым деревом фильтров, то "
"вызов не присоединит новый фильтр seccomp, и завершится с ошибкой, вернув ID "
"первой обнаруженной нити, для которой синхронизация невозможна. "
"Синхронизации не получится, если другая нить того же процесса находится в "
"B<SECCOMP_MODE_STRICT>, или если она присоединила новые фильтры seccomp к "
"самой себе, отличающиеся от дерева фильтров вызывающей нити."

#. type: TP
#: man-pages/man2/seccomp.2:221
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_LOG> (since Linux 4.14)"
msgstr "B<SECCOMP_FILTER_FLAG_LOG> (начиная с Linux 4.14)"

#.  commit e66a39977985b1e69e17c4042cb290768eca9b02
#. type: Plain text
#: man-pages/man2/seccomp.2:231
msgid ""
"All filter return actions except B<SECCOMP_RET_ALLOW> should be logged.  An "
"administrator may override this filter flag by preventing specific actions "
"from being logged via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""
"Все фильтры, возвращающие действия, кроме B<SECCOMP_RET_ALLOW>, должны "
"протоколироваться. Администратор может заменить этот флаг фильтров, "
"предварительно запретив протоколировать определённые действия через файл I</"
"proc/sys/kernel/seccomp/actions_logged>."

#. type: TP
#: man-pages/man2/seccomp.2:231
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_SPEC_ALLOW> (since Linux 4.17)"
msgstr "B<SECCOMP_FILTER_FLAG_SPEC_ALLOW> (начиная с Linux 4.17)"

#.  commit 00a02d0c502a06d15e07b857f8ff921e3e402675
#. type: Plain text
#: man-pages/man2/seccomp.2:235
msgid "Disable Speculative Store Bypass mitigation."
msgstr "Выключить недопущение Speculative Store Bypass."

#. type: TP
#: man-pages/man2/seccomp.2:236
#, no-wrap
msgid "B<SECCOMP_GET_ACTION_AVAIL> (since Linux 4.14)"
msgstr "B<SECCOMP_GET_ACTION_AVAIL> (начиная с Linux 4.14)"

#.  commit d612b1fd8010d0d67b5287fe146b8b55bcbb8655
#. type: Plain text
#: man-pages/man2/seccomp.2:244
msgid ""
"Test to see if an action is supported by the kernel.  This operation is "
"helpful to confirm that the kernel knows of a more recently added filter "
"return action since the kernel treats all unknown actions as "
"B<SECCOMP_RET_KILL_PROCESS>."
msgstr ""
"Проверить, поддерживается ли действие ядром. Данная операция помогает "
"убедиться, что ядро знает о самых последних добавленных фильтрах, "
"возвращающих действие, так как ядро считает все неизвестные действия как "
"B<SECCOMP_RET_KILL_PROCESS>."

#. type: Plain text
#: man-pages/man2/seccomp.2:250
msgid ""
"The value of I<flags> must be 0, and I<args> must be a pointer to an "
"unsigned 32-bit filter return action."
msgstr ""
"Значение I<flags> должно быть равно 0, а I<args> должно быть указателем на "
"беззнаковый 32-битный фильтр, возвращающих действие."

#. type: SS
#: man-pages/man2/seccomp.2:250
#, no-wrap
msgid "Filters"
msgstr "Фильтры"

#. type: Plain text
#: man-pages/man2/seccomp.2:255
msgid ""
"When adding filters via B<SECCOMP_SET_MODE_FILTER>, I<args> points to a "
"filter program:"
msgstr ""
"При добавлении фильтров посредством B<SECCOMP_SET_MODE_FILTER>, значение "
"I<args> указывает на программу фильтрации:"

#. type: Plain text
#: man-pages/man2/seccomp.2:263
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;    /* Number of BPF instructions */\n"
"    struct sock_filter *filter; /* Pointer to array of\n"
"                                   BPF instructions */\n"
"};\n"
msgstr ""
"struct sock_fprog {\n"
"    unsigned short      len;    /* количество инструкций BPF */\n"
"    struct sock_filter *filter; /* указатель на массив\n"
"                                   инструкций BPF */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:267
msgid "Each program must contain one or more BPF instructions:"
msgstr "В каждой программе должно быть не менее одной инструкции BPF:"

#. type: Plain text
#: man-pages/man2/seccomp.2:276
#, no-wrap
msgid ""
"struct sock_filter {            /* Filter block */\n"
"    __u16 code;                 /* Actual filter code */\n"
"    __u8  jt;                   /* Jump true */\n"
"    __u8  jf;                   /* Jump false */\n"
"    __u32 k;                    /* Generic multiuse field */\n"
"};\n"
msgstr ""
"struct sock_filter {            /* блок фильтрации */\n"
"    __u16 code;                 /* действительный код фильтра */\n"
"    __u8  jt;                   /* переход при совпадении */\n"
"    __u8  jf;                   /* переход при несовпадении */\n"
"    __u32 k;                    /* общее поле для различных целей */\n"
"};\n"

#.  Quoting Kees Cook:
#.      If BPF even allows changing the data, it's not copied back to
#.      the syscall when it runs. Anything wanting to do things like
#.      that would need to use ptrace to catch the call and directly
#.      modify the registers before continuing with the call.
#. type: Plain text
#: man-pages/man2/seccomp.2:289
msgid ""
"When executing the instructions, the BPF program operates on the system call "
"information made available (i.e., use the B<BPF_ABS> addressing mode) as a "
"(read-only)  buffer of the following form:"
msgstr ""
"При выполнении инструкций информация о системном вызове (когда используется "
"режим адресации B<BPF_ABS>) программе BPF доступна из буфера (только для "
"чтения) в виде:"

#. type: Plain text
#: man-pages/man2/seccomp.2:299
#, no-wrap
msgid ""
"struct seccomp_data {\n"
"    int   nr;                   /* System call number */\n"
"    __u32 arch;                 /* AUDIT_ARCH_* value\n"
"                                   (see E<lt>linux/audit.hE<gt>) */\n"
"    __u64 instruction_pointer;  /* CPU instruction pointer */\n"
"    __u64 args[6];              /* Up to 6 system call arguments */\n"
"};\n"
msgstr ""
"struct seccomp_data {\n"
"    int   nr;                   /* номер системного вызова */\n"
"    __u32 arch;                 /* значение AUDIT_ARCH_* \n"
"                                   (смотрите E<lt>linux/audit.hE<gt>) */\n"
"    __u64 instruction_pointer;  /* указатель на инструкцию ЦП */\n"
"    __u64 args[6];              /* до 6 аргументов системного вызова */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:311
msgid ""
"Because numbering of system calls varies between architectures and some "
"architectures (e.g., x86-64) allow user-space code to use the calling "
"conventions of multiple architectures (and the convention being used may "
"vary over the life of a process that uses B<execve>(2)  to execute binaries "
"that employ the different conventions), it is usually necessary to verify "
"the value of the I<arch> field."
msgstr ""
"Так как количество системных вызовов различно на разных архитектурах и "
"некоторые архитектуры (например, x86-64) позволяют коду в пользовательском "
"пространстве использовать соглашения о вызовах нескольких архитектур (и "
"используемое соглашение может меняться на протяжении выполнения процесса, "
"если он использует B<execve>(2) для запуска выполняемых файлов, которые "
"задействуют другие соглашения), то, обычно, необходимо проверять значение "
"поля I<arch>."

#. type: Plain text
#: man-pages/man2/seccomp.2:322
msgid ""
"It is strongly recommended to use a whitelisting approach whenever possible "
"because such an approach is more robust and simple.  A blacklist will have "
"to be updated whenever a potentially dangerous system call is added (or a "
"dangerous flag or option if those are blacklisted), and it is often possible "
"to alter the representation of a value without altering its meaning, leading "
"to a blacklist bypass.  See also I<Caveats> below."
msgstr ""
"Настоятельно рекомендуется использовать подход белого списка, когда это "
"возможно, потому что такой подход более устойчив и прост. Черный список "
"нужно будет обновлять каждый раз, когда добавляется потенциально опасный "
"системный вызов (или опасный флаг или параметр, если они помещены в черный "
"список), и это часто возможно изменит представление значения, не изменяя его "
"смысла, что приведёт к обходу черного списка. Также смотрите I<ЗАМЕЧАНИЯ> "
"ниже."

#.  As noted by Dave Drysdale in a note at the end of
#.  https://lwn.net/Articles/604515/
#.      One additional detail to point out for the x32 ABI case:
#.      the syscall number gets a high bit set (__X32_SYSCALL_BIT),
#.      to mark it as an x32 call.
#.      If x32 support is included in the kernel, then __SYSCALL_MASK
#.      will have a value that is not all-ones, and this will trigger
#.      an extra instruction in system_call to mask off the extra bit,
#.      so that the syscall table indexing still works.
#. type: Plain text
#: man-pages/man2/seccomp.2:344
msgid ""
"The I<arch> field is not unique for all calling conventions.  The x86-64 ABI "
"and the x32 ABI both use B<AUDIT_ARCH_X86_64> as I<arch>, and they run on "
"the same processors.  Instead, the mask B<__X32_SYSCALL_BIT> is used on the "
"system call number to tell the two ABIs apart."
msgstr ""
"Поле I<arch> не уникально для всех соглашений о вызовах. В x86-64 ABI и x32 "
"ABI в I<arch> используется B<AUDIT_ARCH_X86_64>, и они запускаются на одних "
"и тех же процессорах. Чтобы отличать один ABI от другого используется маска "
"B<__X32_SYSCALL_BIT> с номером системного вызова."

#. type: Plain text
#: man-pages/man2/seccomp.2:355
msgid ""
"This means that in order to create a seccomp-based blacklist for system "
"calls performed through the x86-64 ABI, it is necessary to not only check "
"that I<arch> equals B<AUDIT_ARCH_X86_64>, but also to explicitly reject all "
"system calls that contain B<__X32_SYSCALL_BIT> in I<nr>."
msgstr ""
"Это означает, что для создания чёрного списка системных вызовов на основе "
"seccomp, выполняемых через x86-64 ABI, необходимо не только проверять что "
"I<arch> равно B<AUDIT_ARCH_X86_64>, но также явно отвергать все системные "
"вызовы, которые содержат B<__X32_SYSCALL_BIT> в I<nr>."

#. type: Plain text
#: man-pages/man2/seccomp.2:369
msgid ""
"The I<instruction_pointer> field provides the address of the machine-"
"language instruction that performed the system call.  This might be useful "
"in conjunction with the use of I</proc/[pid]/maps> to perform checks based "
"on which region (mapping) of the program made the system call.  (Probably, "
"it is wise to lock down the B<mmap>(2)  and B<mprotect>(2)  system calls to "
"prevent the program from subverting such checks.)"
msgstr ""
"В поле I<instruction_pointer> содержится адрес инструкции машинного языка, "
"который запускает системный вызов. Это может быть полезно вместе с I</proc/"
"[pid]/maps> для выполнения проверок из какой области (отображение) программы "
"делается системный вызов (вероятно, стоит блокировать системные вызовы "
"B<mmap>(2) и B<mprotect>(2) для запрета программе удалять такие проверки)."

#. type: Plain text
#: man-pages/man2/seccomp.2:383
msgid ""
"When checking values from I<args> against a blacklist, keep in mind that "
"arguments are often silently truncated before being processed, but after the "
"seccomp check.  For example, this happens if the i386 ABI is used on an "
"x86-64 kernel: although the kernel will normally not look beyond the 32 "
"lowest bits of the arguments, the values of the full 64-bit registers will "
"be present in the seccomp data.  A less surprising example is that if the "
"x86-64 ABI is used to perform a system call that takes an argument of type "
"I<int>, the more-significant half of the argument register is ignored by the "
"system call, but visible in the seccomp data."
msgstr ""
"При проверке значений из I<args> по чёрному списку имейте в виду, что часто "
"аргументы просто обрезаются до обработки, но после проверки seccomp. "
"Например, это случается, если на ядре x86-64 используется i386 ABI: хотя "
"ядро, обычно, не смотрит дальше 32 младших бит аргументов, в данные seccomp "
"попадут значения полных 64-битных регистров. Менее удивительный пример: если "
"для выполнения системного вызова с аргументом типа I<int> используется "
"x86-64 ABI, то старшая половина регистра аргумента игнорируется системным "
"вызовом, но видима в данных seccomp."

#. type: Plain text
#: man-pages/man2/seccomp.2:392
msgid ""
"A seccomp filter returns a 32-bit value consisting of two parts: the most "
"significant 16 bits (corresponding to the mask defined by the constant "
"B<SECCOMP_RET_ACTION_FULL>)  contain one of the \"action\" values listed "
"below; the least significant 16-bits (defined by the constant "
"B<SECCOMP_RET_DATA>)  are \"data\" to be associated with this return value."
msgstr ""
"Фильтр seccomp возвращает 32-битное значение, состоящее из двух частей: в "
"старших 16 битах (соответствует маске, определяемой константой "
"B<SECCOMP_RET_ACTION_FULL>) содержится одно из значений «действие», "
"перечисленных далее; в младших 16 битах (определяется константой "
"B<SECCOMP_RET_DATA>) содержатся «данные», связанные с возвращаемым значением."

#.  From an Aug 2015 conversation with Kees Cook where I asked why *all*
#.  filters are applied even if one of the early filters returns
#.  SECCOMP_RET_KILL:
#.      It's just because it would be an optimization that would only speed up
#.      the RET_KILL case, but it's the uncommon one and the one that doesn't
#.      benefit meaningfully from such a change (you need to kill the process
#.      really quickly?). We would speed up killing a program at the (albeit
#.      tiny) expense to all other filtered programs. Best to keep the filter
#.      execution logic clear, simple, and as fast as possible for all
#.      filters.
#. type: Plain text
#: man-pages/man2/seccomp.2:416
msgid ""
"If multiple filters exist, they are I<all> executed, in reverse order of "
"their addition to the filter tree\\(emthat is, the most recently installed "
"filter is executed first.  (Note that all filters will be called even if one "
"of the earlier filters returns B<SECCOMP_RET_KILL>.  This is done to "
"simplify the kernel code and to provide a tiny speed-up in the execution of "
"sets of filters by avoiding a check for this uncommon case.)  The return "
"value for the evaluation of a given system call is the first-seen action "
"value of highest precedence (along with its accompanying data)  returned by "
"execution of all of the filters."
msgstr ""
"Если существует несколько фильтров, то I<все> они выполняются в обратном "
"порядке их добавления в дерево фильтров — то есть последние добавленные "
"выполняются первыми (заметим, что все фильтры будут вызваны даже, если ранее "
"выполнявшиеся фильтры вернули B<SECCOMP_RET_KILL>. Это сделано для простоты "
"кода ядра и предоставления крошечного ускорения выполнения набора фильтров, "
"так как не выполняется проверка этого редкого случая). Возвращаемое значение "
"для вычисления данного системного вызова —первое встреченного значение "
"действия наивысшего приоритета (вместе с сопутствующими ему данными), "
"возвращаемое выполнением всех фильтров."

#. type: Plain text
#: man-pages/man2/seccomp.2:419
msgid ""
"In decreasing order of precedence, the action values that may be returned by "
"a seccomp filter are:"
msgstr ""
"Значения действий, которые могут возвращаться фильтром seccomp (в порядке "
"уменьшения приоритета):"

#. type: TP
#: man-pages/man2/seccomp.2:419
#, no-wrap
msgid "B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)"
msgstr "B<SECCOMP_RET_KILL_PROCESS> (начиная с Linux 4.14)"

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#.  commit 0466bdb99e8744bc9befa8d62a317f0fd7fd7421
#. type: Plain text
#: man-pages/man2/seccomp.2:433
msgid ""
"This value results in immediate termination of the process, with a core "
"dump.  The system call is not executed.  By contrast with "
"B<SECCOMP_RET_KILL_THREAD> below, all threads in the thread group are "
"terminated.  (For a discussion of thread groups, see the description of the "
"B<CLONE_THREAD> flag in B<clone>(2).)"
msgstr ""
"Это значение возвращается при немедленном завершении процесса с образованием "
"дампа. Системный вызов не выполняется. По сравнению с "
"B<SECCOMP_RET_KILL_THREAD>, описанном далее, завершаются все нити в группе "
"нитей (группы нитей представлены в описании B<CLONE_THREAD> в B<clone>(2))."

#. type: Plain text
#: man-pages/man2/seccomp.2:449
msgid ""
"The process terminates I<as though> killed by a B<SIGSYS> signal.  Even if a "
"signal handler has been registered for B<SIGSYS>, the handler will be "
"ignored in this case and the process always terminates.  To a parent process "
"that is waiting on this process (using B<waitpid>(2)  or similar), the "
"returned I<wstatus> will indicate that its child was terminated as though by "
"a B<SIGSYS> signal."
msgstr ""
"Процесс завершается I<думая>, что убит сигналом B<SIGSYS>. Даже если "
"обработчик сигнала B<SIGSYS> был зарегистрирован, в этом случае он будет "
"проигнорирован и процесс всегда прекращает выполнение. Родительскому "
"процессу, который ждёт этот процесс (с помощью B<waitpid>(2) или подобного "
"вызова) возвращается I<wstatus>, который будет показывать, что потомок "
"завершился по сигналу B<SIGSYS>."

#. type: TP
#: man-pages/man2/seccomp.2:449
#, no-wrap
msgid "B<SECCOMP_RET_KILL_THREAD> (or B<SECCOMP_RET_KILL>)"
msgstr "B<SECCOMP_RET_KILL_THREAD> (или B<SECCOMP_RET_KILL>)"

#. type: Plain text
#: man-pages/man2/seccomp.2:455
msgid ""
"This value results in immediate termination of the thread that made the "
"system call.  The system call is not executed.  Other threads in the same "
"thread group will continue to execute."
msgstr ""
"Это значение возвращается при немедленном завершении нити, сделавшей "
"системный вызов. Системный вызов не выполняется. Другие нити в той же группе "
"нитей продолжат выполнение."

#. type: Plain text
#: man-pages/man2/seccomp.2:464
msgid ""
"The thread terminates I<as though> killed by a B<SIGSYS> signal.  See "
"B<SECCOMP_RET_KILL_PROCESS> above."
msgstr ""
"Нить завершается I<думая>, что убита сигналом B<SIGSYS>. Смотрите описание "
"B<SECCOMP_RET_KILL_PROCESS> выше."

#.  See these commits:
#.  seccomp: dump core when using SECCOMP_RET_KILL
#.     (b25e67161c295c98acda92123b2dd1e7d8642901)
#.  seccomp: Only dump core when single-threaded
#.     (d7276e321ff8a53106a59c85ca46d03e34288893)
#. type: Plain text
#: man-pages/man2/seccomp.2:479
msgid ""
"Before Linux 4.11, any process terminated in this way would not trigger a "
"coredump (even though B<SIGSYS> is documented in B<signal>(7)  as having a "
"default action of termination with a core dump).  Since Linux 4.11, a single-"
"threaded process will dump core if terminated in this way."
msgstr ""
"До Linux 4.11 любой процесс, завершавшийся таким образом, не вызывал "
"образование дампа (несмотря на то, что описание B<SIGSYS> в B<signal>(7) "
"сообщает, что по умолчанию завершение приводит к дампу). Начиная с Linux "
"4.11 для процесса с единственной нитью будет сделан дамп, если он "
"завершается при таких обстоятельствах."

#. type: Plain text
#: man-pages/man2/seccomp.2:487
msgid ""
"With the addition of B<SECCOMP_RET_KILL_PROCESS> in Linux 4.14, "
"B<SECCOMP_RET_KILL_THREAD> was added as a synonym for B<SECCOMP_RET_KILL>, "
"in order to more clearly distinguish the two actions."
msgstr ""
"В дополнении к B<SECCOMP_RET_KILL_PROCESS> в Linux 4.14 как синоним "
"B<SECCOMP_RET_KILL> добавлено значение B<SECCOMP_RET_KILL_THREAD>, для более "
"ясного различения двух этих действий."

#. type: TP
#: man-pages/man2/seccomp.2:487
#, no-wrap
msgid "B<SECCOMP_RET_TRAP>"
msgstr "B<SECCOMP_RET_TRAP>"

#. type: Plain text
#: man-pages/man2/seccomp.2:498
msgid ""
"This value results in the kernel sending a thread-directed B<SIGSYS> signal "
"to the triggering thread.  (The system call is not executed.)  Various "
"fields will be set in the I<siginfo_t> structure (see B<sigaction>(2))  "
"associated with signal:"
msgstr ""
"Это значение приводит к отправке ядром направленного в нить сигнала "
"B<SIGSYS> возбудившей нити (системный вызов не выполняется). Заполняются "
"некоторые поля структуры I<siginfo_t> (смотрите B<sigaction>(2)), связанные "
"с сигналом:"

#. type: Plain text
#: man-pages/man2/seccomp.2:503
msgid "I<si_signo> will contain B<SIGSYS>."
msgstr "В I<si_signo> будет содержаться значение B<SIGSYS>."

#. type: Plain text
#: man-pages/man2/seccomp.2:506
msgid "I<si_call_addr> will show the address of the system call instruction."
msgstr "В I<si_call_addr> будет показан адрес инструкции системного вызова."

#. type: Plain text
#: man-pages/man2/seccomp.2:511
msgid ""
"I<si_syscall> and I<si_arch> will indicate which system call was attempted."
msgstr ""
"В I<si_syscall> и I<si_arch> будет указываться какой системный вызов была "
"попытка запустить."

#. type: Plain text
#: man-pages/man2/seccomp.2:515
msgid "I<si_code> will contain B<SYS_SECCOMP>."
msgstr "В I<si_code> будет содержаться значение B<SYS_SECCOMP>."

#. type: Plain text
#: man-pages/man2/seccomp.2:520
msgid ""
"I<si_errno> will contain the B<SECCOMP_RET_DATA> portion of the filter "
"return value."
msgstr ""
"В I<si_errno> будет содержаться часть B<SECCOMP_RET_DATA> из возвращаемого "
"значения фильтра."

#. type: Plain text
#: man-pages/man2/seccomp.2:529
msgid ""
"The program counter will be as though the system call happened (i.e., the "
"program counter will not point to the system call instruction).  The return "
"value register will contain an architecture-dependent value; if resuming "
"execution, set it to something appropriate for the system call.  (The "
"architecture dependency is because replacing it with B<ENOSYS> could "
"overwrite some useful information.)"
msgstr ""
"Программный счётчик будет таким же как при системном вызове (т. е., "
"программный счётчик не будет указывать на инструкцию системного вызова). В "
"регистре возвращаемого значения будет содержаться значение, зависящее от "
"архитектуры; если выполнение продолжится, оно равно чему-нибудь подходящему "
"для системного вызова (зависимость от архитектуры возникает из-за того, что "
"при замене его на B<ENOSYS> может перезаписаться какая-нибудь полезная "
"информация)."

#. type: TP
#: man-pages/man2/seccomp.2:529
#, no-wrap
msgid "B<SECCOMP_RET_ERRNO>"
msgstr "B<SECCOMP_RET_ERRNO>"

#. type: Plain text
#: man-pages/man2/seccomp.2:536
msgid ""
"This value results in the B<SECCOMP_RET_DATA> portion of the filter's return "
"value being passed to user space as the I<errno> value without executing the "
"system call."
msgstr ""
"Это значение приводит к тому, что часть B<SECCOMP_RET_DATA> возвращаемого "
"значения фильтра передаётся в пространство пользователя в виде значения "
"I<errno> без выполнения системного вызова."

#. type: TP
#: man-pages/man2/seccomp.2:536
#, no-wrap
msgid "B<SECCOMP_RET_TRACE>"
msgstr "B<SECCOMP_RET_TRACE>"

#. type: Plain text
#: man-pages/man2/seccomp.2:546
msgid ""
"When returned, this value will cause the kernel to attempt to notify a "
"B<ptrace>(2)-based tracer prior to executing the system call.  If there is "
"no tracer present, the system call is not executed and returns a failure "
"status with I<errno> set to B<ENOSYS>."
msgstr ""
"При возврате это значение заставит ядро попытаться уведомить трассировщик на "
"основе B<ptrace>(2) до выполнения системного вызова. Если трассировщика нет, "
"то системный вызов не выполняется и возвращается состояние ошибки со "
"значением I<errno> равным B<ENOSYS>."

#. type: Plain text
#: man-pages/man2/seccomp.2:557
msgid ""
"A tracer will be notified if it requests B<PTRACE_O_TRACESECCOMP> using "
"I<ptrace(PTRACE_SETOPTIONS)>.  The tracer will be notified of a "
"B<PTRACE_EVENT_SECCOMP> and the B<SECCOMP_RET_DATA> portion of the filter's "
"return value will be available to the tracer via B<PTRACE_GETEVENTMSG>."
msgstr ""
"Трассировщик будет уведомлён, если он запросил B<PTRACE_O_TRACESECCOMP> "
"посредством I<ptrace(PTRACE_SETOPTIONS)>. Трассировщик будет уведомлён о "
"B<PTRACE_EVENT_SECCOMP>, а часть B<SECCOMP_RET_DATA> возвращаемого значения "
"фильтра будет доступна через B<PTRACE_GETEVENTMSG>."

#. type: Plain text
#: man-pages/man2/seccomp.2:564
msgid ""
"The tracer can skip the system call by changing the system call number to "
"-1.  Alternatively, the tracer can change the system call requested by "
"changing the system call to a valid system call number.  If the tracer asks "
"to skip the system call, then the system call will appear to return the "
"value that the tracer puts in the return value register."
msgstr ""
"Трассировщик может пропустить системный вызов, изменив номер системного "
"вызова на -1. Или же он может изменить запрашиваемый системный вызов на "
"системный вызов с другим номером. Если трассировщик просит пропустить "
"системный вызов, то системный вызов появится в возвращаемом значении, "
"которое трассировщик помещает в регистр возвращаемого значения."

#.  This was changed in ce6526e8afa4.
#.  A related hole, using PTRACE_SYSCALL instead of SECCOMP_RET_TRACE, was
#.  changed in arch-specific commits, e.g. 93e35efb8de4 for X86 and
#.  0f3912fd934c for ARM.
#. type: Plain text
#: man-pages/man2/seccomp.2:578
msgid ""
"Before kernel 4.8, the seccomp check will not be run again after the tracer "
"is notified.  (This means that, on older kernels, seccomp-based sandboxes "
"B<must not> allow use of B<ptrace>(2)\\(emeven of other sandboxed processes"
"\\(emwithout extreme care; ptracers can use this mechanism to escape from "
"the seccomp sandbox.)"
msgstr ""
"До ядра 4.8 проверка seccomp не будет запущена ещё раз после уведомления "
"трассировщика (для старых ядер это означает, что ограниченные окружения "
"(sandbox) на основе seccomp B<не должны> позволять использовать B<ptrace>(2) "
"— даже другим процессам в окружении — без максимальной предосторожности; "
"ptracer-ы могут использовать этот механизм для выхода из окружения seccomp)."

#. type: TP
#: man-pages/man2/seccomp.2:578
#, no-wrap
msgid "B<SECCOMP_RET_LOG> (since Linux 4.14)"
msgstr "B<SECCOMP_RET_LOG> (начиная с Linux 4.14)"

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#. type: Plain text
#: man-pages/man2/seccomp.2:587
msgid ""
"This value results in the system call being executed after the filter return "
"action is logged.  An administrator may override the logging of this action "
"via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""
"Это значение приводит к выполнению системного вызова после протоколирования "
"фильтра, возвращающего действие. Администратор может заменить "
"протоколирование этого действия в файле I</proc/sys/kernel/seccomp/"
"actions_logged>."

#. type: TP
#: man-pages/man2/seccomp.2:587
#, no-wrap
msgid "B<SECCOMP_RET_ALLOW>"
msgstr "B<SECCOMP_RET_ALLOW>"

#. type: Plain text
#: man-pages/man2/seccomp.2:590
msgid "This value results in the system call being executed."
msgstr "Это значение приводит к выполнению системного вызова."

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#. type: Plain text
#: man-pages/man2/seccomp.2:600
msgid ""
"If an action value other than one of the above is specified, then the filter "
"action is treated as either B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)  "
"or B<SECCOMP_RET_KILL_THREAD> (in Linux 4.13 and earlier)."
msgstr ""
"Если значение действия ни одно из указанных выше, то действием фильтра "
"считается или B<SECCOMP_RET_KILL_PROCESS> (начиная с Linux 4.14), или "
"B<SECCOMP_RET_KILL_THREAD> (в Linux 4.13 и старее)."

#. type: Plain text
#: man-pages/man2/seccomp.2:604
msgid ""
"The files in the directory I</proc/sys/kernel/seccomp> provide additional "
"seccomp information and configuration:"
msgstr ""
"Файлы в каталоге I</proc/sys/kernel/seccomp> предоставляют дополнительную "
"информацию seccomp и настройку:"

#. type: TP
#: man-pages/man2/seccomp.2:604
#, no-wrap
msgid "I<actions_avail> (since Linux 4.14)"
msgstr "I<actions_avail> (начиная с Linux 4.14)"

#.  commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af
#. type: Plain text
#: man-pages/man2/seccomp.2:611
msgid ""
"A read-only ordered list of seccomp filter return actions in string form.  "
"The ordering, from left-to-right, is in decreasing order of precedence.  The "
"list represents the set of seccomp filter return actions supported by the "
"kernel."
msgstr ""
"Доступный только для чтения упорядоченный список возвращаемых действий "
"фильтром seccomp в виде строки. Список упорядочен слева направо в порядке "
"уменьшения приоритета. Представляет собой набор возвращаемых фильтром "
"seccomp действий, поддерживаемых ядром."

#. type: TP
#: man-pages/man2/seccomp.2:611
#, no-wrap
msgid "I<actions_logged> (since Linux 4.14)"
msgstr "I<actions_logged> (начиная с Linux 4.14)"

#.  commit 0ddec0fc8900201c0897b87b762b7c420436662f
#. type: Plain text
#: man-pages/man2/seccomp.2:620
msgid ""
"A read-write ordered list of seccomp filter return actions that are allowed "
"to be logged.  Writes to the file do not need to be in ordered form but "
"reads from the file will be ordered in the same way as the I<actions_avail> "
"file."
msgstr ""
"Доступный для чтения-записи упорядоченный список возвращаемых действий "
"фильтром seccomp, которые разрешено протоколировать. Записи в файл не нужно "
"упорядочивать, но прочитанные данные будут упорядочены также как в файле "
"I<actions_avail>."

#. type: Plain text
#: man-pages/man2/seccomp.2:631
msgid ""
"It is important to note that the value of I<actions_logged> does not prevent "
"certain filter return actions from being logged when the audit subsystem is "
"configured to audit a task.  If the action is not found in the "
"I<actions_logged> file, the final decision on whether to audit the action "
"for that task is ultimately left up to the audit subsystem to decide for all "
"filter return actions other than B<SECCOMP_RET_ALLOW>."
msgstr ""
"Важно отметить, что значение I<actions_logged> не останавливает от "
"протоколирования определённого фильтра возвращаемых действий, если "
"подсистема аудита настроена на аудит задачи. Если действие не найдено в "
"файле I<actions_logged>, то конечное решение об аудите действия для этой "
"задачи, в конечном итоге, основывается на действие подсистемы аудита для "
"всех фильтров возвращающих действия, кроме B<SECCOMP_RET_ALLOW>."

#. type: Plain text
#: man-pages/man2/seccomp.2:640
msgid ""
"The \"allow\" string is not accepted in the I<actions_logged> file as it is "
"not possible to log B<SECCOMP_RET_ALLOW> actions.  Attempting to write "
"\"allow\" to the file will fail with the error B<EINVAL>."
msgstr ""
"Строка «allow» недопустима в файле I<actions_logged>, так как невозможно "
"протоколирование действий B<SECCOMP_RET_ALLOW>. Попытка записи «allow» в "
"файле завершится ошибкой B<EINVAL>."

#. type: SS
#: man-pages/man2/seccomp.2:640
#, no-wrap
msgid "Audit logging of seccomp actions"
msgstr "Ведение журнала контроля действий seccomp"

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#.  or auditing could be enabled via the netlink API (AUDIT_SET)
#. type: Plain text
#: man-pages/man2/seccomp.2:652
msgid ""
"Since Linux 4.14, the kernel provides the facility to log the actions "
"returned by seccomp filters in the audit log.  The kernel makes the decision "
"to log an action based on the action type, whether or not the action is "
"present in the I<actions_logged> file, and whether kernel auditing is "
"enabled (e.g., via the kernel boot option I<audit=1>).  The rules are as "
"follows:"
msgstr ""
"Начиная с Linux 4.14 ядро позволяет протоколировать действия, возвращаемые "
"фильтрами seccomp в журнал контроля (audit log). Ядро принимает решение о "
"протоколировании действие основываясь на типе действия, имеется ли действие "
"в файле I<actions_logged> и включён ли контроль в ядре (например, "
"посредством параметра загрузки ядра I<audit=1>). Правила следующие:"

#. type: Plain text
#: man-pages/man2/seccomp.2:656
msgid "If the action is B<SECCOMP_RET_ALLOW>, the action is not logged."
msgstr "Если действие — B<SECCOMP_RET_ALLOW>, то оно не протоколируется."

#. type: Plain text
#: man-pages/man2/seccomp.2:664
msgid ""
"Otherwise, if the action is either B<SECCOMP_RET_KILL_PROCESS> or "
"B<SECCOMP_RET_KILL_THREAD>, and that action appears in the I<actions_logged> "
"file, the action is logged."
msgstr ""
"В противном случае, если действие B<SECCOMP_RET_KILL_PROCESS> или "
"B<SECCOMP_RET_KILL_THREAD>, и это действие есть в файле I<actions_logged>, "
"то действие протоколируется."

#. type: Plain text
#: man-pages/man2/seccomp.2:671
msgid ""
"Otherwise, if the filter has requested logging (the "
"B<SECCOMP_FILTER_FLAG_LOG> flag)  and the action appears in the "
"I<actions_logged> file, the action is logged."
msgstr ""
"В противном случае, если для фильтра запрошено протоколирование (флаг "
"B<SECCOMP_FILTER_FLAG_LOG>) и действие есть в файле I<actions_logged>, то "
"действие протоколируется."

#. type: Plain text
#: man-pages/man2/seccomp.2:675
msgid ""
"Otherwise, if kernel auditing is enabled and the process is being audited "
"(B<autrace>(8)), the action is logged."
msgstr ""
"В противном случае, если включён контроль в ядре и процесс контролируется "
"(B<autrace>(8)), то действие протоколируется."

#. type: Plain text
#: man-pages/man2/seccomp.2:677
msgid "Otherwise, the action is not logged."
msgstr "В противном случае действие не протоколируется."

#. type: Plain text
#: man-pages/man2/seccomp.2:693
msgid ""
"On success, B<seccomp>()  returns 0.  On error, if "
"B<SECCOMP_FILTER_FLAG_TSYNC> was used, the return value is the ID of the "
"thread that caused the synchronization failure.  (This ID is a kernel thread "
"ID of the type returned by B<clone>(2)  and B<gettid>(2).)  On other errors, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<seccomp>() возвращает 0. При ошибке, если был "
"использован B<SECCOMP_FILTER_FLAG_TSYNC>, то возвращается ID нити, которая "
"была причиной ошибки синхронизации (данный ID — идентификатор нити ядра с "
"типом, возвращаемом B<clone>(2) и B<gettid>(2)). При других ошибках "
"возвращается -1 и в I<errno> записывается причина ошибки."

#. type: Plain text
#: man-pages/man2/seccomp.2:696
msgid "B<seccomp>()  can fail for the following reasons:"
msgstr ""
"Функция B<seccomp>() может завершиться с ошибкой по следующим причинам:"

#. type: Plain text
#: man-pages/man2/seccomp.2:704
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in its user "
"namespace, or had not set I<no_new_privs> before using "
"B<SECCOMP_SET_MODE_FILTER>."
msgstr ""
"У вызывающего нет мандата B<CAP_SYS_ADMIN> в своём пространстве имён "
"пользователя или не установлен I<no_new_privs> до использования "
"B<SECCOMP_SET_MODE_FILTER>."

#. type: Plain text
#: man-pages/man2/seccomp.2:708
msgid "I<args> was not a valid address."
msgstr "Аргумент I<args> не содержит допустимого адреса."

#. type: Plain text
#: man-pages/man2/seccomp.2:712
msgid ""
"I<operation> is unknown or is not supported by this kernel version or "
"configuration."
msgstr ""
"Аргумент I<operation> неизвестен или не поддерживается этой версией ядра или "
"из-за настроек."

#. type: Plain text
#: man-pages/man2/seccomp.2:718
msgid "The specified I<flags> are invalid for the given I<operation>."
msgstr ""
"Указанное значение I<flags> некорректно для заданного значения I<operation>."

#. type: Plain text
#: man-pages/man2/seccomp.2:725
msgid ""
"I<operation> included B<BPF_ABS>, but the specified offset was not aligned "
"to a 32-bit boundary or exceeded I<sizeof(struct\\ seccomp_data)>."
msgstr ""
"Значение I<operation> включает B<BPF_ABS>, но указанное смещение не "
"выровнено по 32-битной границе или превышает I<sizeof(struct\\ "
"seccomp_data)>."

#.  See kernel/seccomp.c::seccomp_may_assign_mode() in 3.18 sources
#. type: Plain text
#: man-pages/man2/seccomp.2:731
msgid ""
"A secure computing mode has already been set, and I<operation> differs from "
"the existing setting."
msgstr ""
"Режим безопасных вычислений уже включён, и значение I<operation> отличается "
"от существующей настройки."

#. type: Plain text
#: man-pages/man2/seccomp.2:741
msgid ""
"I<operation> specified B<SECCOMP_SET_MODE_FILTER>, but the filter program "
"pointed to by I<args> was not valid or the length of the filter program was "
"zero or exceeded B<BPF_MAXINSNS> (4096) instructions."
msgstr ""
"В I<operation> указано B<SECCOMP_SET_MODE_FILTER>, но фильтрующая программа, "
"задаваемая в I<args>, некорректна или её длина равна 0 или превышает "
"B<BPF_MAXINSNS> (4096) инструкций."

#.  ENOMEM in kernel/seccomp.c::seccomp_attach_filter() in 3.18 sources
#. type: Plain text
#: man-pages/man2/seccomp.2:754
msgid ""
"The total length of all filter programs attached to the calling thread would "
"exceed B<MAX_INSNS_PER_PATH> (32768) instructions.  Note that for the "
"purposes of calculating this limit, each already existing filter program "
"incurs an overhead penalty of 4 instructions."
msgstr ""
"Общая длина всех фильтрующих программ, присоединённых к вызывающей нити, "
"превысила бы B<MAX_INSNS_PER_PATH> (32768) инструкций. Заметим, что для "
"вычисления этого предела на каждую уже существующую фильтрующую программу "
"прибавляются ещё 4 инструкции."

#. type: Plain text
#: man-pages/man2/seccomp.2:761
msgid ""
"I<operation> specified B<SECCOMP_GET_ACTION_AVAIL>, but the kernel does not "
"support the filter return action specified by I<args>."
msgstr ""
"В I<operation> указано B<SECCOMP_GET_ACTION_AVAIL>, но ядро не поддерживает "
"фильтр, возвращающий действие, указанное в I<args>."

#. type: Plain text
#: man-pages/man2/seccomp.2:765
msgid ""
"Another thread caused a failure during thread sync, but its ID could not be "
"determined."
msgstr ""
"Во время синхронизации нити произошла ошибка в другой нити, но её ID "
"невозможно определить."

#.  FIXME . Add glibc version
#. type: Plain text
#: man-pages/man2/seccomp.2:770
msgid "The B<seccomp>()  system call first appeared in Linux 3.17."
msgstr "Системный вызов B<seccomp>() впервые появился в Linux 3.17."

#. type: Plain text
#: man-pages/man2/seccomp.2:774
msgid "The B<seccomp>()  system call is a nonstandard Linux extension."
msgstr "Системный вызов B<seccomp>() является нестандартным расширением Linux."

#. type: Plain text
#: man-pages/man2/seccomp.2:779
msgid ""
"Rather than hand-coding seccomp filters as shown in the example below, you "
"may prefer to employ the I<libseccomp> library, which provides a front-end "
"for generating seccomp filters."
msgstr ""
"Вместо ручного кодирования фильтров seccomp, как показано в примере ниже, вы "
"можете воспользоваться библиотекой I<libseccomp>, которая предоставляет "
"клиентскую часть для генерации фильтров seccomp."

#. type: Plain text
#: man-pages/man2/seccomp.2:786
msgid ""
"The I<Seccomp> field of the I</proc/[pid]/status> file provides a method of "
"viewing the seccomp mode of a process; see B<proc>(5)."
msgstr ""
"В поле I<Seccomp> файла I</proc/[pid]/status> отображается метод просмотра "
"режима seccomp в процессе; смотрите B<proc>(5)."

#. type: Plain text
#: man-pages/man2/seccomp.2:793
msgid ""
"B<seccomp>()  provides a superset of the functionality provided by the "
"B<prctl>(2)  B<PR_SET_SECCOMP> operation (which does not support I<flags>)."
msgstr ""
"Вызов B<seccomp>() предоставляет больше возможностей по сравнению с "
"операцией B<PR_SET_SECCOMP> B<prctl>(2) (которая не поддерживает I<flags>)."

#. type: Plain text
#: man-pages/man2/seccomp.2:799
msgid ""
"Since Linux 4.4, the B<ptrace>(2)  B<PTRACE_SECCOMP_GET_FILTER> operation "
"can be used to dump a process's seccomp filters."
msgstr ""
"Начиная с Linux 4.4, вызов B<ptrace>(2) с операцией "
"B<PTRACE_SECCOMP_GET_FILTER> можно использовать для получения дампа фильтров "
"seccomp процесса."

#. type: SS
#: man-pages/man2/seccomp.2:799
#, no-wrap
msgid "Architecture support for seccomp BPF"
msgstr "Архитектурная поддержка seccomp BPF"

#.  Check by grepping for HAVE_ARCH_SECCOMP_FILTER in Kconfig files in
#.  kernel source. Last checked in Linux 4.16-rc source.
#. type: Plain text
#: man-pages/man2/seccomp.2:804
msgid ""
"Architecture support for seccomp BPF filtering is available on the following "
"architectures:"
msgstr ""
"Архитектурная поддержка фильтрации seccomp BPF доступна на следующих "
"архитектурах:"

#. type: Plain text
#: man-pages/man2/seccomp.2:806
msgid "x86-64, i386, x32 (since Linux 3.5)"
msgstr "x86-64, i386, x32 (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/seccomp.2:809
msgid "ARM (since Linux 3.8)"
msgstr "ARM (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/seccomp.2:811
msgid "s390 (since Linux 3.8)"
msgstr "s390 (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/seccomp.2:813
msgid "MIPS (since Linux 3.16)"
msgstr "MIPS (начиная с Linux 3.16)"

#. type: Plain text
#: man-pages/man2/seccomp.2:815
msgid "ARM-64 (since Linux 3.19)"
msgstr "ARM-64 (начиная с Linux 3.19)"

#. type: Plain text
#: man-pages/man2/seccomp.2:817
msgid "PowerPC (since Linux 4.3)"
msgstr "PowerPC (начиная с Linux 4.3)"

#. type: Plain text
#: man-pages/man2/seccomp.2:819
msgid "Tile (since Linux 4.3)"
msgstr "Tile (начиная с Linux 4.3)"

#.  User mode Linux since Linux 4.6
#. type: Plain text
#: man-pages/man2/seccomp.2:822
msgid "PA-RISC (since Linux 4.6)"
msgstr "PA-RISC (начиная с Linux 4.6)"

#. type: SS
#: man-pages/man2/seccomp.2:824
#, no-wrap
msgid "Caveats"
msgstr "Предостережения"

#. type: Plain text
#: man-pages/man2/seccomp.2:827
msgid ""
"There are various subtleties to consider when applying seccomp filters to a "
"program, including the following:"
msgstr ""
"Есть различные тонкости, которые нужно учитывать при применении фильтров "
"seccomp к программе:"

#. type: Plain text
#: man-pages/man2/seccomp.2:842
msgid ""
"Some traditional system calls have user-space implementations in the "
"B<vdso>(7)  on many architectures.  Notable examples include "
"B<clock_gettime>(2), B<gettimeofday>(2), and B<time>(2).  On such "
"architectures, seccomp filtering for these system calls will have no "
"effect.  (However, there are cases where the B<vdso>(7)  implementations may "
"fall back to invoking the true system call, in which case seccomp filters "
"would see the system call.)"
msgstr ""
"На многих архитектурах некоторые обычные системные вызовы реализованы в "
"пользовательском пространстве в B<vdso>(7). Заметными примерами можно "
"считать B<clock_gettime>(2), B<gettimeofday>(2) и B<time>(2). На таких "
"архитектурах фильтрация seccomp данных системных вызовов не действует "
"(однако, есть случаи где реализации B<vdso>(7) могут вызвать реальный "
"системный вызов и фильтры seccomp filters увидят такое обращение)."

#. type: Plain text
#: man-pages/man2/seccomp.2:848
msgid ""
"Seccomp filtering is based on system call numbers.  However, applications "
"typically do not directly invoke system calls, but instead call wrapper "
"functions in the C library which in turn invoke the system calls.  "
"Consequently, one must be aware of the following:"
msgstr ""
"Фильтрация seccomp работает по номерам системных вызовов. Однако, обычно, в "
"приложениях системные вызовы вызываются не напрямую, а через обёрточные "
"функции библиотеки C, которые, в свою очередь, вызывают системные вызовы. "
"Следовательно, нужно учитывать следующее:"

#. type: Plain text
#: man-pages/man2/seccomp.2:860
msgid ""
"The glibc wrappers for some traditional system calls may actually employ "
"system calls with different names in the kernel.  For example, the "
"B<exit>(2)  wrapper function actually employs the B<exit_group>(2)  system "
"call, and the B<fork>(2)  wrapper function actually calls B<clone>(2)."
msgstr ""
"Обёртки glibc некоторых обычных системных вызовов могут использовать "
"системные вызовы ядра с другими именами. Например, обёрточная функция "
"B<exit>(2) использует системный вызов B<exit_group>(2), а обёрточная функция "
"B<fork>(2) в действительности вызывает B<clone>(2)."

#. type: Plain text
#: man-pages/man2/seccomp.2:865
msgid ""
"The behavior of wrapper functions may vary across architectures, according "
"to the range of system calls provided on those architectures.  In other "
"words, the same wrapper function may invoke different system calls on "
"different architectures."
msgstr ""
"Поведение обёрточных функций могут быть различных на разных архитектурах, с "
"учётом диапазона системных вызовов, предоставляемых архитектурой. Другими "
"словами, одна обёрточная функция на разных архитектурах может вызывать "
"разные системные вызовы."

#. type: Plain text
#: man-pages/man2/seccomp.2:873
msgid ""
"Finally, the behavior of wrapper functions can change across glibc "
"versions.  For example, in older versions, the glibc wrapper function for "
"B<open>(2)  invoked the system call of the same name, but starting in glibc "
"2.26, the implementation switched to calling B<openat>(2)  on all "
"architectures."
msgstr ""
"И наконец, поведение обёрточных функций может различаться в разных версиях "
"glibc. Например, в старых версиях обёрточная функция glibc для B<open>(2) "
"вызывала системный вызов с тем же именем, но начиная с glibc 2.26, в "
"реализации начал вызываться B<openat>(2) на всех архитектурах."

#. type: Plain text
#: man-pages/man2/seccomp.2:881
msgid ""
"The consequence of the above points is that it may be necessary to filter "
"for a system call other than might be expected.  Various manual pages in "
"Section 2 provide helpful details about the differences between wrapper "
"functions and the underlying system calls in subsections entitled I<C "
"library/kernel differences>."
msgstr ""
"В следствии вышеупомянутого возможно понадобится фильтровать не тот "
"системный вызов, который ожидался. В различных справочных страницах раздела "
"2 есть абзац I<Отличия между библиотекой C и ядром>, в котором содержится "
"полезная информация о различиях между оберточными функциями и нижележащими "
"системными вызовами."

#. type: Plain text
#: man-pages/man2/seccomp.2:889
msgid ""
"Furthermore, note that the application of seccomp filters even risks causing "
"bugs in an application, when the filters cause unexpected failures for "
"legitimate operations that the application might need to perform.  Such bugs "
"may not easily be discovered when testing the seccomp filters if the bugs "
"occur in rarely used application code paths."
msgstr ""
"Кроме того, обратите внимание, что применение фильтров seccomp даже может "
"привести к появлению дефектов приложений, когда фильтры вызывают неожиданные "
"отказы для законных операций, которые приложение, возможно, должно было бы "
"выполнить. Такие дефекты может оказаться нелегко обнаружить при тестировании "
"фильтров seccomp, если дефекты возникают в редко используемых путях кода "
"приложения."

#. type: SS
#: man-pages/man2/seccomp.2:889
#, no-wrap
msgid "Seccomp-specific BPF details"
msgstr "Особенности seccomp в BPF"

#. type: Plain text
#: man-pages/man2/seccomp.2:891
msgid "Note the following BPF details specific to seccomp filters:"
msgstr ""
"Заметим, что следующие особенности BPF относятся только к фильтрам seccomp:"

#. type: Plain text
#: man-pages/man2/seccomp.2:899
msgid ""
"The B<BPF_H> and B<BPF_B> size modifiers are not supported: all operations "
"must load and store (4-byte) words (B<BPF_W>)."
msgstr ""
"Модификаторы размера B<BPF_H> и B<BPF_B> не поддерживаются: все операции "
"должны загружать и сохранять слова (4-байта) (B<BPF_W>)."

#. type: Plain text
#: man-pages/man2/seccomp.2:905
msgid ""
"To access the contents of the I<seccomp_data> buffer, use the B<BPF_ABS> "
"addressing mode modifier."
msgstr ""
"Для доступа к содержимому буфера I<seccomp_data> используйте модификатор "
"режима адресации B<BPF_ABS>."

#. type: Plain text
#: man-pages/man2/seccomp.2:912
msgid ""
"The B<BPF_LEN> addressing mode modifier yields an immediate mode operand "
"whose value is the size of the I<seccomp_data> buffer."
msgstr ""
"Модификатор режима адресации B<BPF_LEN> выдаёт непосредственный операнд "
"режима, чьё значение равно размеру буфера I<seccomp_data>."

#. type: Plain text
#: man-pages/man2/seccomp.2:918
msgid ""
"The program below accepts four or more arguments.  The first three arguments "
"are a system call number, a numeric architecture identifier, and an error "
"number.  The program uses these values to construct a BPF filter that is "
"used at run time to perform the following checks:"
msgstr ""
"Программа, показанная далее, обрабатывает четыре и более аргументов. Первые "
"три аргумента — номер системного вызова, числовой идентификатор архитектуры "
"и номер ошибки. Программа использует эти значения для создания фильтра BPF, "
"который используется во время работы для выполнения следующих проверок:"

#. type: Plain text
#: man-pages/man2/seccomp.2:922
msgid ""
"If the program is not running on the specified architecture, the BPF filter "
"causes system calls to fail with the error B<ENOSYS>."
msgstr ""
"Если программа не запущена на определённой архитектуре, то фильтр BPF "
"заставляет системные вызовы завершаться с ошибкой B<ENOSYS>."

#. type: Plain text
#: man-pages/man2/seccomp.2:927
msgid ""
"If the program attempts to execute the system call with the specified "
"number, the BPF filter causes the system call to fail, with I<errno> being "
"set to the specified error number."
msgstr ""
"Если программа попытается выполнить системный вызов с заданным номером, то "
"фильтр BPF заставит системный вызов завершиться с ошибкой, а в I<errno> "
"будет записан указанный номер ошибки."

#. type: Plain text
#: man-pages/man2/seccomp.2:936
msgid ""
"The remaining command-line arguments specify the pathname and additional "
"arguments of a program that the example program should attempt to execute "
"using B<execv>(3)  (a library function that employs the B<execve>(2)  system "
"call).  Some example runs of the program are shown below."
msgstr ""
"В оставшихся аргументах командной строки указываются путь и дополнительные "
"аргументы программы, которую программа из примера должна попытаться "
"выполнить с помощью B<execv>(3) (библиотечной функции, которая использует "
"системный вызов B<execve>(2)). Несколько примеров запуска программы показаны "
"далее."

#. type: Plain text
#: man-pages/man2/seccomp.2:940
msgid ""
"First, we display the architecture that we are running on (x86-64)  and then "
"construct a shell function that looks up system call numbers on this "
"architecture:"
msgstr ""
"Сначала мы выведем имя архитектуры, на которой работаем (x86-64), а затем "
"создадим функцию оболочки, которая выдаёт список номеров системных вызовов "
"этой архитектуры:"

#. type: Plain text
#: man-pages/man2/seccomp.2:949
#, no-wrap
msgid ""
"$ B<uname -m>\n"
"x86_64\n"
"$ B<syscall_nr() {\n"
"    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\e\n"
"    awk '$2 != \"x32\" && $3 == \"'$1'\" { print $1 }'\n"
"}>\n"
msgstr ""
"$ B<uname -m>\n"
"x86_64\n"
"$ B<syscall_nr() {\n"
"    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\e\n"
"    awk '$2 != \"x32\" && $3 == \"'$1'\" { print $1 }'\n"
"}>\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:956
msgid ""
"When the BPF filter rejects a system call (case [2] above), it causes the "
"system call to fail with the error number specified on the command line.  In "
"the experiments shown here, we'll use error number 99:"
msgstr ""
"Когда фильтр BPF отклоняет системный вызов (случай [2] выше), системный "
"вызов завершается с номером ошибки, указанной в командной строке. В наших "
"экспериментах используется номер ошибки 99:"

#. type: Plain text
#: man-pages/man2/seccomp.2:961
#, no-wrap
msgid ""
"$ B<errno 99>\n"
"EADDRNOTAVAIL 99 Cannot assign requested address\n"
msgstr ""
"$ B<errno 99>\n"
"EADDRNOTAVAIL 99 Cannot assign requested address\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:969
msgid ""
"In the following example, we attempt to run the command B<whoami>(1), but "
"the BPF filter rejects the B<execve>(2)  system call, so that the command is "
"not even executed:"
msgstr ""
"В следующем примере мы пытаемся выполнить команду B<whoami>(1), но фильтр "
"BPF отклоняет системный вызов B<execve>(2), и поэтому команда даже не начнёт "
"выполняться:"

#. type: Plain text
#: man-pages/man2/seccomp.2:980
#, no-wrap
msgid ""
"$ B<syscall_nr execve>\n"
"59\n"
"$ B<./a.out>\n"
"Usage: ./a.out E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\n"
"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x40000003\n"
"                 AUDIT_ARCH_X86_64: 0xC000003E\n"
"$ B<./a.out 59 0xC000003E 99 /bin/whoami>\n"
"execv: Cannot assign requested address\n"
msgstr ""
"$ B<syscall_nr execve>\n"
"59\n"
"$ B<./a.out>\n"
"Использование: ./a.out E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\n"
"Подсказка для E<lt>archE<gt>: AUDIT_ARCH_I386: 0x40000003\n"
"                 AUDIT_ARCH_X86_64: 0xC000003E\n"
"$ B<./a.out 59 0xC000003E 99 /bin/whoami>\n"
"execv: Cannot assign requested address\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:988
msgid ""
"In the next example, the BPF filter rejects the B<write>(2)  system call, so "
"that, although it is successfully started, the B<whoami>(1)  command is not "
"able to write output:"
msgstr ""
"В следующем примере фильтр BPF отклоняет системный вызов B<write>(2), и хотя "
"выполнение началось, команда B<whoami>(1) не может записать в стандартный "
"вывод:"

#. type: Plain text
#: man-pages/man2/seccomp.2:994
#, no-wrap
msgid ""
"$ B<syscall_nr write>\n"
"1\n"
"$ B<./a.out 1 0xC000003E 99 /bin/whoami>\n"
msgstr ""
"$ B<syscall_nr write>\n"
"1\n"
"$ B<./a.out 1 0xC000003E 99 /bin/whoami>\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1001
msgid ""
"In the final example, the BPF filter rejects a system call that is not used "
"by the B<whoami>(1)  command, so it is able to successfully execute and "
"produce output:"
msgstr ""
"В последнем примере фильтр BPF отклоняет системный вызов, который не "
"используется в команде B<whoami>(1), и поэтому она выполняется без ошибок и "
"выводит:"

#. type: Plain text
#: man-pages/man2/seccomp.2:1008
#, no-wrap
msgid ""
"$ B<syscall_nr preadv>\n"
"295\n"
"$ B<./a.out 295 0xC000003E 99 /bin/whoami>\n"
"cecilia\n"
msgstr ""
"$ B<syscall_nr preadv>\n"
"295\n"
"$ B<./a.out 295 0xC000003E 99 /bin/whoami>\n"
"cecilia\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1021
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/audit.hE<gt>\n"
"#include E<lt>linux/filter.hE<gt>\n"
"#include E<lt>linux/seccomp.hE<gt>\n"
"#include E<lt>sys/prctl.hE<gt>\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/audit.hE<gt>\n"
"#include E<lt>linux/filter.hE<gt>\n"
"#include E<lt>linux/seccomp.hE<gt>\n"
"#include E<lt>sys/prctl.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1023
#, no-wrap
msgid "#define X32_SYSCALL_BIT 0x40000000\n"
msgstr "#define X32_SYSCALL_BIT 0x40000000\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1028
#, no-wrap
msgid ""
"static int\n"
"install_filter(int syscall_nr, int t_arch, int f_errno)\n"
"{\n"
"    unsigned int upper_nr_limit = 0xffffffff;\n"
msgstr ""
"static int\n"
"install_filter(int syscall_nr, int t_arch, int f_errno)\n"
"{\n"
"    unsigned int upper_nr_limit = 0xffffffff;\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1034
#, no-wrap
msgid ""
"    /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI\n"
"       (in the x32 ABI, all system calls have bit 30 set in the\n"
"       'nr' field, meaning the numbers are E<gt>= X32_SYSCALL_BIT) */\n"
"    if (t_arch == AUDIT_ARCH_X86_64)\n"
"        upper_nr_limit = X32_SYSCALL_BIT - 1;\n"
msgstr ""
"    /* предполагается, что AUDIT_ARCH_X86_64 означает обычный x86-64 ABI\n"
"       (в x32 ABI у всех системных вызовов установлены 30 бит в поле\n"
"       «nr», то есть номера E<gt>= X32_SYSCALL_BIT) */\n"
"    if (t_arch == AUDIT_ARCH_X86_64)\n"
"        upper_nr_limit = X32_SYSCALL_BIT - 1;\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1040
#, no-wrap
msgid ""
"    struct sock_filter filter[] = {\n"
"        /* [0] Load architecture from 'seccomp_data' buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, arch))),\n"
msgstr ""
"    struct sock_filter filter[] = {\n"
"        /* [0] загружаем архитектуру из буфера «seccomp_data» в\n"
"               аккумулятор */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, arch))),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1044
#, no-wrap
msgid ""
"        /* [1] Jump forward 5 instructions if architecture does not\n"
"               match 't_arch' */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),\n"
msgstr ""
"        /* [1] прыгаем вперёд на 5 инструкции, если архитектура не совпадает\n"
"               с «t_arch» */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 4),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1049
#, no-wrap
msgid ""
"        /* [2] Load system call number from 'seccomp_data' buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, nr))),\n"
msgstr ""
"        /* [2] загружаем номер системного вызова из буфера «seccomp_data» в\n"
"               аккумулятор */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, nr))),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1054
#, no-wrap
msgid ""
"        /* [3] Check ABI - only needed for x86-64 in blacklist use\n"
"               cases.  Use BPF_JGT instead of checking against the bit\n"
"               mask to avoid having to reload the syscall number. */\n"
"        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),\n"
msgstr ""
"        /* [3] проверяем ABI — нужно только для чёрного списка на x86-64.\n"
"               Используем BPF_JGT вместо проверки битовой маски,\n"
"               чтобы избежать перезагрузки номера syscall. */\n"
"        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1058
#, no-wrap
msgid ""
"        /* [4] Jump forward 1 instruction if system call number\n"
"               does not match 'syscall_nr' */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),\n"
msgstr ""
"        /* [4] прыгаем вперёд на 1 инструкцию, если номер системного вызова\n"
"               не совпадает с «syscall_nr» */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1063
#, no-wrap
msgid ""
"        /* [5] Matching architecture and system call: don't execute\n"
"\t       the system call, and return 'f_errno' in 'errno' */\n"
"        BPF_STMT(BPF_RET | BPF_K,\n"
"                 SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),\n"
msgstr ""
"        /* [5] совпала архитектура и системный вызов: не выполняем\n"
"\t       системный вызов и возвращаем «f_errno» в «errno» */\n"
"        BPF_STMT(BPF_RET | BPF_K,\n"
"                 SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1067
#, no-wrap
msgid ""
"        /* [6] Destination of system call number mismatch: allow other\n"
"               system calls */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),\n"
msgstr ""
"        /* [6] не совпал номер системного вызова: разрешаем\n"
"               работу других системных вызовов */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1071
#, no-wrap
msgid ""
"        /* [7] Destination of architecture mismatch: kill task */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),\n"
"    };\n"
msgstr ""
"        /* [7] не совпала архитектура: прерываем задачу */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),\n"
"    };\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1076
#, no-wrap
msgid ""
"    struct sock_fprog prog = {\n"
"        .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),\n"
"        .filter = filter,\n"
"    };\n"
msgstr ""
"    struct sock_fprog prog = {\n"
"        .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),\n"
"        .filter = filter,\n"
"    };\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1081
#, no-wrap
msgid ""
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"
msgstr ""
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1084
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1096
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    if (argc E<lt> 5) {\n"
"        fprintf(stderr, \"Usage: \"\n"
"                \"%s E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\\en\"\n"
"                \"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x%X\\en\"\n"
"                \"                 AUDIT_ARCH_X86_64: 0x%X\\en\"\n"
"                \"\\en\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    if (argc E<lt> 5) {\n"
"        fprintf(stderr, \"Использование: \"\n"
"                \"%s E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> E<lt>progE<gt> [E<lt>argsE<gt>]\\en\"\n"
"                \"Подсказка для E<lt>archE<gt>: AUDIT_ARCH_I386: 0x%X\\en\"\n"
"                \"                 AUDIT_ARCH_X86_64: 0x%X\\en\"\n"
"                \"\\en\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1101
#, no-wrap
msgid ""
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1106
#, no-wrap
msgid ""
"    if (install_filter(strtol(argv[1], NULL, 0),\n"
"                       strtol(argv[2], NULL, 0),\n"
"                       strtol(argv[3], NULL, 0)))\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    if (install_filter(strtol(argv[1], NULL, 0),\n"
"                       strtol(argv[2], NULL, 0),\n"
"                       strtol(argv[3], NULL, 0)))\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1111
#, no-wrap
msgid ""
"    execv(argv[4], &argv[4]);\n"
"    perror(\"execv\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    execv(argv[4], &argv[4]);\n"
"    perror(\"execv\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/seccomp.2:1122
msgid ""
"B<bpfc>(1), B<strace>(1), B<bpf>(2), B<prctl>(2), B<ptrace>(2), "
"B<sigaction>(2), B<proc>(5), B<signal>(7), B<socket>(7)"
msgstr ""
"B<bpfc>(1), B<strace>(1), B<bpf>(2), B<prctl>(2), B<ptrace>(2), "
"B<sigaction>(2), B<proc>(5), B<signal>(7), B<socket>(7)"

#. type: Plain text
#: man-pages/man2/seccomp.2:1132
msgid ""
"Various pages from the I<libseccomp> library, including: "
"B<scmp_sys_resolver>(1), B<seccomp_init>(3), B<seccomp_load>(3), "
"B<seccomp_rule_add>(3), and B<seccomp_export_bpf>(3)."
msgstr ""
"Various pages from the I<libseccomp> library, including: "
"B<scmp_sys_resolver>(1), B<seccomp_init>(3), B<seccomp_load>(3), "
"B<seccomp_rule_add>(3) и B<seccomp_export_bpf>(3)."

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#. type: Plain text
#: man-pages/man2/seccomp.2:1141
msgid ""
"The kernel source files I<Documentation/networking/filter.txt> and "
"I<Documentation/userspace-api/seccomp_filter.rst> (or I<Documentation/prctl/"
"seccomp_filter.txt> before Linux 4.13)."
msgstr ""
"Файлы исходного кода ядра I<Documentation/networking/filter.txt> и "
"I<Documentation/userspace-api/seccomp_filter.rst> (до Linux 4.13 файл "
"I<Documentation/prctl/seccomp_filter.txt>)."

#. type: Plain text
#: man-pages/man2/seccomp.2:1146
msgid ""
"McCanne, S.\\& and Jacobson, V.\\& (1992)  I<The BSD Packet Filter: A New "
"Architecture for User-level Packet Capture>, Proceedings of the USENIX "
"Winter 1993 Conference E<.UR http://www.tcpdump.org/papers/bpf-usenix93.pdf> "
"E<.UE>"
msgstr ""
"McCanne, S.\\& and Jacobson, V.\\& (1992)  I<The BSD Packet Filter: A New "
"Architecture for User-level Packet Capture>, Proceedings of the USENIX "
"Winter 1993 Conference E<.UR http://www.tcpdump.org/papers/bpf-usenix93.pdf> "
"E<.UE>"

#. type: TH
#: man-pages/man2/select_tut.2:32
#, no-wrap
msgid "SELECT_TUT"
msgstr "SELECT_TUT"

#. type: Plain text
#: man-pages/man2/select_tut.2:36
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - многопоточный "
"синхронный ввод-вывод"

#. type: Plain text
#: man-pages/man2/select_tut.2:40
#, no-wrap
msgid ""
"/* According to POSIX.1-2001, POSIX.1-2008 */\n"
"B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""
"/* в соответствии с POSIX.1-2001, POSIX.1-2008 */\n"
"B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:45
#, no-wrap
msgid ""
"/* According to earlier standards */\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"/* в соответствии с ранними стандартами */\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:48
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:53
#, no-wrap
msgid ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:55
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:59
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:68
msgid "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/select_tut.2:76
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file "
"descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the file descriptors."
msgstr ""
"Вызов B<select>() (или B<pselect>()) используется для эффективного слежения "
"за несколькими файловыми дескрипторами — для ожидания, когда какой-то из них "
"не станет «готов», то есть появится возможность чтения-записи данных, или с "
"файловым дескриптором не возникнет «исключительная ситуация»."

#. type: Plain text
#: man-pages/man2/select_tut.2:101
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared "
"using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr ""
"Основные параметры задаются в виде «набора» файловых дескрипторов: "
"I<readfds>, I<writefds> и I<exceptfds>. Каждый набор имеет тип I<fd_set> и "
"его содержимое можно изменять с помощью макросов B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>() и B<FD_ZERO>(). При создании нового набора сначала его нужно "
"очистить с помощью B<FD_ZERO>(). Вызов B<select>() изменяет содержимое "
"наборов в соответствии с правилами, описанными далее; после вызова "
"B<select>() вы можете проверить существует ли ещё файловый дескриптор в "
"наборе с помощью макроса B<FD_ISSET>(). Макрос B<FD_ISSET>() возвращает "
"ненулевое значение, если указанный файловый дескриптор присутствует в наборе "
"и ноль, если отсутствует. Макрос B<FD_CLR>() удаляет файловый дескриптор из "
"набора."

#. type: SS
#: man-pages/man2/select_tut.2:101
#, no-wrap
msgid "Arguments"
msgstr "Аргументы"

#. type: TP
#: man-pages/man2/select_tut.2:102
#, no-wrap
msgid "I<readfds>"
msgstr "I<readfds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:111
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr ""
"Этот набор служит для слежения за появлением данных, доступных для чтения из "
"любого файлового дескриптора. После возврата из B<select>() в I<readfds> "
"остаются только те дескрипторы файлов, из которых возможно немедленное "
"чтение."

#. type: TP
#: man-pages/man2/select_tut.2:111
#, no-wrap
msgid "I<writefds>"
msgstr "I<writefds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:120
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr ""
"Этот набор служит для слежения за появлением места для записи данных в любой "
"из файловых дескрипторов набора. После возврата из B<select>() в I<writefds> "
"остаются только те файловые дескрипторы, в которые возможна немедленная "
"запись."

#. type: TP
#: man-pages/man2/select_tut.2:120
#, no-wrap
msgid "I<exceptfds>"
msgstr "I<exceptfds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:142
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<ioctl_tty>(2).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr ""
"Этот набор служит для слежения за «исключительными ситуациями». На самом "
"деле, отслеживается только одна распространённая исключительная ситуация: "
"доступность I<внепоточных> (out-of-band — OOB) данных для чтения из сокета "
"TCP. Более подробно о данных OOB смотрите в B<recv>(2), B<send>(2) и "
"B<tcp>(7). Другая менее распространённая ситуация: B<select>(2) указывает на "
"исключительную ситуацию с псевдотерминалом в пакетном режиме; смотрите "
"B<ioctl_tty>(2). После возврата из B<select>() в I<exceptfds> остаются "
"только те файловые дескрипторы, в которых произошла исключительная ситуация."

#. type: TP
#: man-pages/man2/select_tut.2:142
#, no-wrap
msgid "I<nfds>"
msgstr "I<nfds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:149
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr ""
"Представляет собой целое число, на единицу большее максимального файлового "
"дескриптора в любом из наборов. Другими словами, при добавлении файловых "
"дескрипторов в наборы вам необходимо вычислять максимальное целое значение "
"любого из них, а затем увеличивать это значение на единицу и передавать в "
"I<nfds>."

#. type: TP
#: man-pages/man2/select_tut.2:149
#, no-wrap
msgid "I<utimeout>"
msgstr "I<utimeout>"

#. type: Plain text
#: man-pages/man2/select_tut.2:162
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to "
"return immediately, with information about the readiness of file descriptors "
"at the time of the call.  The structure I<struct timeval> is defined as:"
msgstr ""
"Этот аргумент задаёт наибольшее время, которое вызов B<select>() будет "
"ожидать событий, по прошествии которого завершит работу, даже если ничего не "
"произойдёт. Если значение этого аргумента равно NULL, то B<select>() будет "
"ожидать бесконечно. Значение I<utimeout> может быть установлено в ноль "
"секунд; в этом случае B<select>() возвратит управление немедленно, с "
"информацией о готовности файловых дескрипторов на момент вызова. Структура "
"I<struct timeval> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/select_tut.2:169
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t tv_sec;    /* секунды */\n"
"    long tv_usec;     /* микросекунды */\n"
"};\n"

#. type: TP
#: man-pages/man2/select_tut.2:171
#, no-wrap
msgid "I<ntimeout>"
msgstr "I<ntimeout>"

#. type: Plain text
#: man-pages/man2/select_tut.2:180
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr ""
"Этот аргумент B<pselect>() имеет то же значение, что и I<utimeout>, но "
"структура I<struct timespec> позволяет указывать время с точностью до "
"наносекунд:"

#. type: Plain text
#: man-pages/man2/select_tut.2:187
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long tv_sec;    /* секунды */\n"
"    long tv_nsec;   /* наносекунды */\n"
"};\n"

#. type: TP
#: man-pages/man2/select_tut.2:189
#, no-wrap
msgid "I<sigmask>"
msgstr "I<sigmask>"

#. type: Plain text
#: man-pages/man2/select_tut.2:206
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, "
"B<pselect>()  will then behave just like B<select>()."
msgstr ""
"Этот аргумент содержит набор сигналов, которые ядро должно разблокировать "
"(то есть удалить из маски сигналов вызывающей нити) на время, пока "
"вызывающий заблокирован в вызове B<pselect>() (см. B<sigaddset>(3) и "
"B<sigprocmask>(2)). В качестве аргумента может быть передано значение NULL — "
"вызов не изменяет маску сигналов при входе и выходе из функции. То есть "
"B<pselect>() ведёт себя как B<select>()."

#. type: SS
#: man-pages/man2/select_tut.2:206
#, no-wrap
msgid "Combining signal and data events"
msgstr "Комбинирование событий сигналов и данных"

#. type: Plain text
#: man-pages/man2/select_tut.2:250
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely.  Now, somewhere in the main loop will "
"be a conditional to check the global flag.  So we must ask: what if a signal "
"arrives after the conditional, but before the B<select>()  call? The answer "
"is that B<select>()  would block indefinitely, even though an event is "
"actually pending.  This race condition is solved by the B<pselect>()  call.  "
"This call can be used to set the signal mask to a set of signals that are to "
"be received only within the B<pselect>()  call.  For instance, let us say "
"that the event in question was the exit of a child process.  Before the "
"start of the main loop, we would block B<SIGCHLD> using B<sigprocmask>(2).  "
"Our B<pselect>()  call would enable B<SIGCHLD> by using an empty signal "
"mask.  Our program would look like:"
msgstr ""
"Вызов B<pselect>() полезен как для ожидания сигнала, так и для ожидания "
"готовности файлового дескриптора для ввода-вывода. Программы, принимающие "
"сигналы, как правило, лишь выставляют в обработчике сигнала глобальный флаг, "
"который означает, что требуется обработка события в главном цикле программы. "
"Появление сигнала заставит вызов B<select>() (или B<pselect>()) вернуть "
"управление вызвавшей программе; при этом I<errno> будет присвоено B<EINTR>. "
"Это поведение продиктовано необходимостью обработки сигналов в главном цикле "
"программы во избежание бесконечной блокировки B<select>(). В главном цикле "
"программы должно быть условие, проверяющее глобальный флаг. Возникает "
"вопрос: а что если сигнал придёт после проверки этого условия, но до вызова "
"B<select>()? В этом случае программа навсегда останется в B<select>(), хотя "
"и есть ожидающее событие. Для разрешения этой проблемы существует вызов "
"B<pselect>(). Этот вызов можно использовать для установки в сигнальной маске "
"сигналов, которые принимаются только внутри вызова B<pselect>(). Например, "
"предположим что интересующее нас событие — это завершение дочернего "
"процесса. Перед запуском главного цикла заблокируем B<SIGCHLD> с помощью "
"B<sigprocmask>(2). Наш вызов B<pselect>() разблокирует B<SIGCHLD>, указав "
"пустую маску сигналов. Программа будет выглядеть так:"

#. type: Plain text
#: man-pages/man2/select_tut.2:253
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr "static volatile sig_atomic_t got_SIGCHLD = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:259
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:267
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:274
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:282
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:284
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr "    sigemptyset(&empty_mask);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:288
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""
"    for (;;) {          /* главный цикл */\n"
"        /* Инициализация readfds, writefds и exceptfds\n"
"           до вызова pselect() (код не показан). */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:294
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* обработка ошибки */\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:297
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:301
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""
"            /* Здесь обработка сигнального события; например с\n"
"               помощью wait() для завершения потомком (код не показан). */\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:305
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""
"        /* код основной программы */\n"
"    }\n"
"}\n"

#. type: SS
#: man-pages/man2/select_tut.2:306
#, no-wrap
msgid "Practical"
msgstr "Практика"

#. type: Plain text
#: man-pages/man2/select_tut.2:327
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my file "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""
"Итак, какой прок от использования B<select>()? Разве нельзя просто считывать "
"и записывать данные в файловые дескрипторы когда этого захочется? Смысл "
"использования B<select>() в том, что он позволяет следит за несколькими "
"дескрипторами одновременно и корректно переводить процесс в режим ожидания, "
"когда активности не наблюдается. Программисты UNIX часто попадают в "
"ситуацию, когда необходимо обработать ввод-вывод из более чем одного "
"файлового дескриптора в то время как поток данных может быть неравномерным. "
"Если вы просто создадите последовательность вызовов B<read>(2) и "
"B<write>(2), то можете попасть в ситуацию, когда один из вызовов будет "
"ожидать данные из/в файлового дескриптора, в то время как другой будет "
"простаивать, хотя данные для него уже появились. Вызов B<select>() позволяет "
"эффективно справиться с такой ситуацией."

#. type: SS
#: man-pages/man2/select_tut.2:327
#, no-wrap
msgid "Select law"
msgstr "Правила использования"

#. type: Plain text
#: man-pages/man2/select_tut.2:340
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""
"Многие из тех, кто пытался использовать B<select>(), сталкивались с "
"поведением, которое трудно понять, и которое приводило к непереносимым или "
"просто плохим результатам. Например, вышеприведенная программа тщательно "
"спланирована так, чтобы ни в каком случае не блокироваться, хотя для её "
"файловых дескрипторов не установлен неблокирующий режим. Несложно "
"перечислить не очевидные ошибки, которые лишат всех преимуществ "
"использования B<select>(), поэтому вот список основных моментов, на которые "
"нужно обращать внимание при использовании B<select>()."

#. type: Plain text
#: man-pages/man2/select_tut.2:349
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""
"Всегда старайтесь использовать B<select>() без указания времени ожидания. "
"Ваша программа не должна ничего делать, если нет данных. Код, зависимый от "
"времени ожидания, обычно плохо переносим и сложен для отладки."

#. type: Plain text
#: man-pages/man2/select_tut.2:353
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""
"Для повышения эффективности значение I<nfds> должно правильно вычисляться, "
"как это объяснялось выше."

#. type: Plain text
#: man-pages/man2/select_tut.2:360
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""
"Файловые дескрипторы не должны добавляться в наборы, если вы не планируете "
"после вызова B<select>() проверять результат и соответствующим образом "
"реагировать. Смотрите следующее правило."

#. type: Plain text
#: man-pages/man2/select_tut.2:366
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""
"После возврата из B<select>() должны быть проверены все файловые дескрипторы "
"во всех наборах."

#. type: Plain text
#: man-pages/man2/select_tut.2:381
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions managing to send or receive only a "
"single byte."
msgstr ""
"Вызовы B<read>(2), B<recv>(2), B<write>(2) и B<send>(2) I<не> обязательно "
"считывают/записывают данные в полном объёме. Такое, конечно, возможно при "
"низком трафике или быстром потоке, однако происходит далеко не всегда. Вы "
"должны рассчитывать, что ваши функции получают/отправляют только один байт "
"за раз."

#. type: TP
#: man-pages/man2/select_tut.2:381
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: man-pages/man2/select_tut.2:389
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""
"Никогда не считывайте/записывайте побайтно, если только вы не абсолютно "
"уверены в том, что нужно обработать небольшой объём данных. Крайне "
"неэффективно считывать/записывать меньшее количество байт, чем вы можете "
"поместить в буфер за один раз. Буферы в вышеприведённом примере имеют размер "
"1024 байта, однако могут быть легко увеличены до максимального размера "
"пакета в вашей локальной сети."

#. type: TP
#: man-pages/man2/select_tut.2:389
#, no-wrap
msgid "7."
msgstr "7."

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: man-pages/man2/select_tut.2:415
msgid ""
"Calls to B<read>(2), B<recv>(2), B<write>(2), B<send>(2), and B<select>()  "
"can fail with the error B<EINTR>, and calls to B<read>(2), B<recv>(2)  "
"B<write>(2), and B<send>(2)  can fail with I<errno> set to B<EAGAIN> "
"(B<EWOULDBLOCK>).  These results must be properly managed (not done properly "
"above).  If your program is not going to receive any signals, then it is "
"unlikely you will get B<EINTR>.  If your program does not set nonblocking I/"
"O, you will not get B<EAGAIN>."
msgstr ""
"Вызовы B<read>(2), B<recv>(2), B<write>(2), B<send>(2) и B<select>() могут "
"завершиться ошибкой B<EINTR>, а вызовы B<read>(2), B<recv>(2)  B<write>(2) и "
"B<send>(2) могут завершиться присвоением I<errno> значения B<EAGAIN> "
"(B<EWOULDBLOCK>). Эти варианты должны быть правильно обработаны (в "
"вышеприведенной программе этого не сделано). Если ваша программа не "
"собирается принимать сигналы, то маловероятно, что вы получите B<EINTR>. "
"Если ваша программа не использует неблокирующий ввод-вывод, то вы не "
"получите B<EAGAIN>."

#. type: TP
#: man-pages/man2/select_tut.2:415
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: man-pages/man2/select_tut.2:424
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""
"Никогда не вызывайте B<read>(2), B<recv>(2), B<write>(2) или B<send>(2) с "
"буфером нулевой длины."

#. type: TP
#: man-pages/man2/select_tut.2:424
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: man-pages/man2/select_tut.2:440
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that file "
"descriptor to B<select>()  again.  In the example below, I close the file "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""
"Если вызовы B<read>(2), B<recv>(2), B<write>(2) и B<send>(2) завершаются с "
"ошибками, отличными от перечисленных в пункте B<7.> или один из вызовов "
"ввода вернул 0, что указывает на конец файла, то вы I<не> должны передавать "
"этот файловый дескриптор в B<select>() снова. В примере выше я немедленно "
"закрываю файловый дескриптор и устанавливаю его в -1 для предотвращения его "
"включения в набор."

#. type: TP
#: man-pages/man2/select_tut.2:440
#, no-wrap
msgid "10."
msgstr "10."

#. type: Plain text
#: man-pages/man2/select_tut.2:447
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""
"Значение времени ожидания должно быть инициализировано при каждом новом "
"вызове B<select>(), так как некоторые операционные системы изменяют значение "
"структуры. Однако B<pselect>() не изменяет структуру времени ожидания."

#. type: TP
#: man-pages/man2/select_tut.2:447
#, no-wrap
msgid "11."
msgstr "11."

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: man-pages/man2/select_tut.2:466
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""
"Так как B<select>() изменяет переданные наборы файловых дескрипторов, то при "
"использовании его в цикле наборы должны повторно инициализироваться перед "
"каждым вызовом."

#. type: SS
#: man-pages/man2/select_tut.2:466
#, no-wrap
msgid "Usleep emulation"
msgstr "Эмуляция usleep"

#. type: Plain text
#: man-pages/man2/select_tut.2:473
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call "
"B<select>()  with a finite timeout and no file descriptors as follows:"
msgstr ""
"В системах, не имеющих функции B<usleep>(3), вы можете использовать "
"B<select>() с конечной задержкой и без файловых дескрипторов следующим "
"образом:"

#. type: Plain text
#: man-pages/man2/select_tut.2:480
#, no-wrap
msgid ""
"struct timeval tv;\n"
"tv.tv_sec = 0;\n"
"tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"select(0, NULL, NULL, NULL, &tv);\n"
msgstr ""
"struct timeval tv;\n"
"tv.tv_sec = 0;\n"
"tv.tv_usec = 200000;  /* 0.2 секунды */\n"
"select(0, NULL, NULL, NULL, &tv);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:484
msgid "This is guaranteed to work only on UNIX systems, however."
msgstr "Однако работа гарантируется только в системах UNIX."

#. type: Plain text
#: man-pages/man2/select_tut.2:489
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr ""
"При успешном выполнении B<select>() возвращает общее число файловых "
"дескрипторов, которые остались в наборах."

#. type: Plain text
#: man-pages/man2/select_tut.2:495
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr ""
"При выходе из B<select>() по окончании времени ожидания возвращается ноль. "
"Все наборы файловых дескрипторов будут пусты (но могут быть не пусты на "
"некоторых системах)."

#. type: Plain text
#: man-pages/man2/select_tut.2:502
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr ""
"Значение -1 указывает на ошибку, при этом I<errno> устанавливается "
"соответствующим образом. В случае ошибки содержимое наборов и структуры "
"I<struct timeout> не определено и не должно быть использовано. Однако вызов "
"B<pselect>() никогда не изменяет I<ntimeout>."

#. type: Plain text
#: man-pages/man2/select_tut.2:511
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""
"В общем случае, все операционные системы, поддерживающие сокеты, "
"поддерживают также и B<select>(). Вызов B<select>() можно применять для "
"переносимого и эффективного решения многих задач, вместо которого многие "
"программисты пытаются использовать нити, ветвление процессов, IPC, сигналы, "
"разделение памяти и другие методы."

#. type: Plain text
#: man-pages/man2/select_tut.2:520
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""
"Системный вызов B<poll>(2) имеет такую же функциональность, как и "
"B<select>() и иногда более эффективен для слежения за разреженным набором "
"файловых дескрипторов. В настоящее время он стал широко распространён, но "
"исторически является менее переносимым чем B<select>()."

#. type: Plain text
#: man-pages/man2/select_tut.2:528
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""
"Программный интерфейс Linux B<epoll>(7) предоставляет более эффективный "
"метод для слежения за большим количеством файловых дескрипторов чем "
"B<select>(2) и B<poll>(2)."

#. type: Plain text
#: man-pages/man2/select_tut.2:533
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""
"Вот пример, который лучше демонстрирует возможности B<select>(). Программа "
"осуществляет перенаправление одного порта TCP в другой. "

#. type: Plain text
#: man-pages/man2/select_tut.2:546
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:548
#, no-wrap
msgid "static int forward_port;\n"
msgstr "static int forward_port;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:551
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:558
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"
msgstr ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:564
#, no-wrap
msgid ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:572
#, no-wrap
msgid ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:581
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:586
#, no-wrap
msgid ""
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"
msgstr ""
"    printf(\"приём соединений на порту %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:592
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"
msgstr ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:598
#, no-wrap
msgid ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:602
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"
msgstr ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:608
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): bad IP address format\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): неправильный формат IP-адреса\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:617
#, no-wrap
msgid ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"
msgstr ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:625
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:633
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:635
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:644
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:650
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Использование\\en\\etfwd E<lt>прослушиваемый-портE<gt> \"\n"
"                 \"E<lt>порт-перенаправленияE<gt> E<lt>ip-адрес-перенаправленияE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:652
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr "    signal(SIGPIPE, SIG_IGN);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:654
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr "    forward_port = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:658
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:663
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"
msgstr ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:669
#, no-wrap
msgid ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"
msgstr ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:676
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds is updated below, when fd1 is added to\n"
"               exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"
msgstr ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Замечание: nfds обновляется ниже, когда добавляется fd1\n"
"               в exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:681
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"
msgstr ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:690
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:692
#, no-wrap
msgid "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"
msgstr "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:695
#, no-wrap
msgid ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:700
#, no-wrap
msgid ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:705
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"
msgstr ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:723
#, no-wrap
msgid ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"
msgstr ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:728
#, no-wrap
msgid ""
"                /* Skip any events on the old, closed file descriptors. */\n"
"                continue;\n"
"            }\n"
"        }\n"
msgstr ""
"                /* пропускаем все события для старых, закрытых\n"
"                   файловых дескрипторов */\n"
"                continue;\n"
"            }\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:730
#, no-wrap
msgid "        /* NB: read OOB data before normal reads */\n"
msgstr "        /* Замечание: чтение данных OOB до обычных */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:733
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"
msgstr ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:742
#, no-wrap
msgid ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"
msgstr ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:781
#, no-wrap
msgid ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"
msgstr ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:783
#, no-wrap
msgid "        /* Check if write data has caught read data */\n"
msgstr "        /* Проверить, что записанные данные были прочитаны */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:788
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:791
#, no-wrap
msgid ""
"        /* One side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""
"        /* Одна из сторон закрыла соединение, продолжать\n"
"            записывать, пока другая сторона не закончит */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:799
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:813
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""
"Вышеприведенная программа правильно перенаправляет большинство данных задач, "
"использующих соединения TCP, включая внепоточные (OOB) данные, передаваемые "
"серверами B<telnet>. Она справляется со сложной проблемой поддержания "
"одновременного двустороннего обмена данными. Возможно, вы решите, что "
"эффективнее использовать B<fork>(2) и выделить отдельную нить для каждого "
"потока. На самом деле это сложнее, чем кажется. Другой идеей может быть "
"использование неблокирующего ввода-вывода с помощью B<fcntl>(2). Это также "
"может вызвать проблемы из-за того, что придётся использовать неэффективные "
"таймауты."

#. type: Plain text
#: man-pages/man2/select_tut.2:819
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of buffers"
"\\(emone for each connection.  At the moment, new connections cause the "
"current connection to be dropped."
msgstr ""
"Программа не обрабатывает более одного соединения, однако она может быть "
"легко доработана путем добавления связанного списка буферов — по одному на "
"каждое соединение. В данный момент новые соединения приводят к закрытию "
"текущего."

#. type: Plain text
#: man-pages/man2/select_tut.2:835
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"

#. type: Plain text
#: man-pages/man2/signal.2:39
msgid "signal - ANSI C signal handling"
msgstr "signal - работа с сигналами ANSI C"

#. type: Plain text
#: man-pages/man2/signal.2:43
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr "B<typedef void (*sighandler_t)(int);>"

#. type: Plain text
#: man-pages/man2/signal.2:45
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: Plain text
#: man-pages/man2/signal.2:54
msgid ""
"The behavior of B<signal>()  varies across UNIX versions, and has also "
"varied historically across different versions of Linux.  B<Avoid its use>: "
"use B<sigaction>(2)  instead.  See I<Portability> below."
msgstr ""
"Работа вызова B<signal>() различается в различных версиях UNIX, и такая же "
"ситуация исторически сложилась и в различных версиях Linux. B<Не используйте "
"его>: используйте вместо него B<sigaction>(2). Смотрите абзац "
"I<Переносимость> далее."

#. type: Plain text
#: man-pages/man2/signal.2:64
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a programmer-"
"defined function (a \"signal handler\")."
msgstr ""
"Вызов B<signal>() устанавливает обработчик сигнала с номером I<signum> в "
"соответствии с параметром I<handler>, который может быть равен B<SIG_IGN>, "
"B<SIG_DFL> или адресу функции пользователя (\"обработчик сигнала\")."

#. type: Plain text
#: man-pages/man2/signal.2:68
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr "Если сигнал I<signum> доставляется процессу, то происходит следующее:"

#. type: Plain text
#: man-pages/man2/signal.2:73
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr "Если значение обработчика равно B<SIG_IGN>, то сигнал игнорируется."

#. type: Plain text
#: man-pages/man2/signal.2:80
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr ""
"Если значение обработчика равно B<SIG_DFL>, то выполняется стандартное "
"действие, связанное с сигналом (см. B<signal>(7))."

#. type: Plain text
#: man-pages/man2/signal.2:91
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below), "
"and then I<handler> is called with argument I<signum>.  If invocation of the "
"handler caused the signal to be blocked, then the signal is unblocked upon "
"return from the handler."
msgstr ""
"Если значение обработчика равно адресу функции, то сначала значение "
"обработчика сбрасывается в B<SIG_DFL> или сигнал блокируется (см. "
"I<Переносимость> далее), а затем вызывается функция I<handler> с аргументом "
"I<signum>. Если вызов обработчика приводит к блокировке сигнала, то сигнал "
"разблокируется после возврата из обработчика."

#. type: Plain text
#: man-pages/man2/signal.2:97
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr ""
"Сигналы B<SIGKILL> и B<SIGSTOP> не могут быть перехвачены или игнорированы."

#. type: Plain text
#: man-pages/man2/signal.2:105
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR> "
"on error.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"Вызов B<signal>() возвращает предыдущее значение обработчика сигнала или "
"B<SIG_ERR> при ошибке. В случае ошибки в I<errno> указывается номер ошибки."

#. type: Plain text
#: man-pages/man2/signal.2:110
msgid "I<signum> is invalid."
msgstr "Неверное значение I<signum>."

#. type: Plain text
#: man-pages/man2/signal.2:112
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man2/signal.2:116
msgid "The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr ""
"Результат работы B<signal>() в многонитевом процессе не регламентирован."

#. type: Plain text
#: man-pages/man2/signal.2:141
msgid ""
"See B<sigaction>(2)  for details on what happens when the disposition "
"B<SIGCHLD> is set to B<SIG_IGN>."
msgstr ""
"О том, что происходит когда обработчик B<SIGCHLD> приравнивается к "
"B<SIG_IGN>, смотрите на странице B<sigaction>(2)."

#. type: Plain text
#: man-pages/man2/signal.2:146
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called from inside a signal handler."
msgstr ""
"Список асинхронных функций работы с сигналами, которые можно безопасно "
"вызывать из обработчика сигналов, смотрите на странице B<signal-safety>(7)."

#.  libc4 and libc5 define
#.  .IR SignalHandler ;
#. type: Plain text
#: man-pages/man2/signal.2:166
msgid ""
"The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> is "
"defined; glibc also defines (the BSD-derived)  I<sig_t> if B<_BSD_SOURCE> "
"(glibc 2.19 and earlier)  or B<_DEFAULT_SOURCE> (glibc 2.19 and later)  is "
"defined.  Without use of such a type, the declaration of B<signal>()  is the "
"somewhat harder to read:"
msgstr ""
"Используемый I<sighandler_t> является расширением GNU, который определён, "
"если существует макрос B<_GNU_SOURCE>; в glibc также есть I<sig_t>, если "
"определён B<_BSD_SOURCE> (glibc 2.19 и старее) или B<_DEFAULT_SOURCE> (glibc "
"2.19 и новее). Без использования этого типа объявление B<signal>() сложнее "
"читать:"

#. type: Plain text
#: man-pages/man2/signal.2:170
#, no-wrap
msgid "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"
msgstr "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"

#. type: SS
#: man-pages/man2/signal.2:172
#, no-wrap
msgid "Portability"
msgstr "Переносимость"

#. type: Plain text
#: man-pages/man2/signal.2:184
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr ""
"Вызов B<signal>() считается переносимым, если обработчик сигнала равен "
"B<SIG_DFL> или B<SIG_IGN>. Семантика при использовании B<signal>() для "
"установки обработчика сигнала отличается в различных системах (и в POSIX.1 "
"явно разрешена такая перемена); B<не используйте данный вызов для этой цели.>"

#. type: Plain text
#: man-pages/man2/signal.2:190
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked; "
"use that interface instead of B<signal>()."
msgstr ""
"В POSIX.1 проблема переносимости решена введением B<sigaction>(2), который "
"предоставляет явное управление семантикой при вызове обработчика сигнала; "
"используйте этот интерфейс вместо B<signal>()."

#. type: Plain text
#: man-pages/man2/signal.2:200
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the "
"signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  This is equivalent to calling "
"B<sigaction>(2)  with the following flags:"
msgstr ""
"В первых системах UNIX, когда обработчик, установленный с помощью "
"B<signal>(), вызывался по получению сигнала, обработчик сигнала был бы "
"сброшен в B<SIG_DFL>, и система не заблокировала бы доставку этого сигнала в "
"последующие экземпляры."

#. type: Plain text
#: man-pages/man2/signal.2:203
#, no-wrap
msgid "    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"
msgstr "    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"

#. type: Plain text
#: man-pages/man2/signal.2:211
msgid ""
"System\\ V also provides these semantics for B<signal>().  This was bad "
"because the signal might be delivered again before the handler had a chance "
"to reestablish itself.  Furthermore, rapid deliveries of the same signal "
"could result in recursive invocations of the handler."
msgstr ""
"System\\ V также предоставляет эту семантику B<signal>(). Это плохо, так как "
"сигнал может быть доставлен снова, до того как обработчик сможет получить "
"шанс его переустановить. Кроме того, скоростные доставки одного сигнала "
"приводили к рекурсивным вызовам обработчика."

#. type: Plain text
#: man-pages/man2/signal.2:226
msgid ""
"BSD improved on this situation, but unfortunately also changed the semantics "
"of the existing B<signal>()  interface while doing so.  On BSD, when a "
"signal handler is invoked, the signal disposition is not reset, and further "
"instances of the signal are blocked from being delivered while the handler "
"is executing.  Furthermore, certain blocking system calls are automatically "
"restarted if interrupted by a signal handler (see B<signal>(7)).  The BSD "
"semantics are equivalent to calling B<sigaction>(2)  with the following "
"flags:"
msgstr ""
"В BSD улучшили эту ситуацию, но, к сожалению, изменили существующую "
"семантику для установки обработчика с помощью B<signal>(). В BSD при вызове "
"обработчика сигнала обработчик сигнала не сбрасывается, и дальнейшие "
"экземпляры сигнала блокируются и не доставляются пока выполняется "
"обработчик. Кроме этого, некоторые блокирующие системные вызовы "
"автоматически перезапускаются при прерывании обработчиком сигнала (смотрите "
"B<signal>(7)). Семантика BSD эквивалентна вызову B<sigaction>(2) со "
"следующими флагами:"

#. type: Plain text
#: man-pages/man2/signal.2:229
#, no-wrap
msgid "    sa.sa_flags = SA_RESTART;\n"
msgstr "    sa.sa_flags = SA_RESTART;\n"

#. type: Plain text
#: man-pages/man2/signal.2:232
msgid "The situation on Linux is as follows:"
msgstr "Ситуация в Linux:"

#. type: Plain text
#: man-pages/man2/signal.2:236
msgid "The kernel's B<signal>()  system call provides System\\ V semantics."
msgstr "Системный вызов ядра B<signal>() предоставляет семантику System\\ V."

#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#.  .IP *
#.  The
#.  .BR signal ()
#.  function in Linux libc4 and libc5 provide System\ V semantics.
#.  If one on a libc5 system includes
#.  .I <bsd/signal.h>
#.  instead of
#.  .IR <signal.h> ,
#.  then
#.  .BR signal ()
#.  provides BSD semantics.
#. type: Plain text
#: man-pages/man2/signal.2:270
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not "
"invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as a suitable feature test macro is defined: B<_BSD_SOURCE> on glibc 2.19 "
"and earlier or B<_DEFAULT_SOURCE> in glibc 2.19 and later.  (By default, "
"these macros are defined; see B<feature_test_macros>(7)  for details.)  If "
"such a feature test macro is not defined, then B<signal>()  provides System"
"\\ V semantics."
msgstr ""
"По умолчанию в glibc 2 и новее обёрточная функция B<signal>() не вызывает "
"системный вызов ядра. Вместо этого она вызывает B<sigaction>(2) с флагами, "
"которые активируют семантику BSD. Такое поведение по умолчанию "
"устанавливается, если определён макрос тестирования свойств B<_BSD_SOURCE> в "
"glibc 2.19 и старее или B<_DEFAULT_SOURCE> в glibc 2.19 и новее (по "
"умолчанию эти макросы определены; подробности смотрите в "
"B<feature_test_macros>(7)) . Если этот макрос тестирования свойств не "
"определён, B<signal>() работает согласно семантики System\\ V."

#. type: Plain text
#: man-pages/man2/signal.2:288
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<pause>(2), B<sigaction>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"
msgstr ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<pause>(2), B<sigaction>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"

#. type: TH
#: man-pages/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr "SET_MEMPOLICY"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:30
msgid ""
"set_mempolicy - set default NUMA memory policy for a thread and its children"
msgstr ""
"set_mempolicy - настраивает политику работы с памятью NUMA для потока и его "
"потомков"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:33
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"
msgstr ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:38
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "Компонуется при указании параметра I<-lnuma>.\n"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling thread, which "
"consists of a policy mode and zero or more nodes, to the values specified by "
"the I<mode>, I<nodemask> and I<maxnode> arguments."
msgstr ""
"Вызов B<set_mempolicy>() устанавливает политику работы с памятью NUMA для "
"вызывающей нити, которая определяется режимом политики и нулём или более "
"узлами (задаются в аргументах I<mode>, I<nodemask> и I<maxnode>)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:54
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the thread."
msgstr ""
"Машина с NUMA имеет различные контроллеры памяти с различными расстояниями "
"до определённых ЦП. Политикой памяти задаётся узел, на котором выделяется "
"память для нити."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the thread.  The thread "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"thread default policy also controls allocation of any pages for memory-"
"mapped files mapped using the B<mmap>(2)  call with the B<MAP_PRIVATE> flag "
"and that are only read (loaded) from by the thread and of memory-mapped "
"files mapped using the B<mmap>(2)  call with the B<MAP_SHARED> flag, "
"regardless of the access type.  The policy is applied only when a new page "
"is allocated for the thread.  For anonymous memory this is when the page is "
"first touched by the thread."
msgstr ""
"Этот системный вызов устанавливает в нити политику по умолчанию. Политика "
"нити управляет выделением страниц в адресном пространстве процесса из "
"областей памяти, которые не контролируются специальной политикой, заданной с "
"помощью B<mbind>(2). Политикой нити по умолчанию также контролируется "
"выделение любых страниц для отображаемых в память файлов с помощью вызова "
"B<mmap>(2) с флагом B<MAP_PRIVATE> (которые читаются (загружаются) только "
"этой нитью) и для отображаемых в память файлов с помощью вызова B<mmap>(2) с "
"флагом B<MAP_SHARED> (независимо от типа доступа). Эта политика применяется "
"только когда нить запрашивает выделение новой страницы. Для анонимной памяти "
"это применяется, когда страница впервые затрагивается приложением."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:92
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All modes except B<MPOL_DEFAULT> require the caller to "
"specify the node or nodes to which the mode applies, via the I<nodemask> "
"argument."
msgstr ""
"В  аргументе I<mode> должно быть указано одно из следующих значений: "
"B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED> или "
"B<MPOL_LOCAL> (описано далее). Для всех режимов, за исключением "
"B<MPOL_DEFAULT>, требуется, чтобы вызывающий указывал в аргументе "
"I<nodemask> узел или узлы, для которых применяется режим."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:100
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""
"Аргумент I<mode> также может содержать необязательный I<флаг режима>. "
"Поддерживаемые I<флаги режима>:"

#. type: TP
#: man-pages/man2/set_mempolicy.2:100
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:110
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux will not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""
"В аргументе I<nodemask> указываются идентификаторы физических узлов. Linux "
"не будет перераспределять I<nodemask>, если процесс перемещается в другой "
"контекст набора процессоров или когда изменяется набор узлов, который "
"доступен процессу согласно текущему контексту набора процессоров."

#. type: TP
#: man-pages/man2/set_mempolicy.2:110
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:116
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the process's current cpuset."
msgstr ""
"В аргументе I<nodemask> указываются идентификаторы узлов из набора "
"идентификаторов узлов, разрешённых процессу текущим контекстом набора "
"процессоров."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:136
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr ""
"В I<nodemask> указывается битовая маска идентификаторов узлов, которая может "
"содержать до I<maxnode> бит. Размер битовой маски округляется до следующего "
"значение кратного I<sizeof(unsigned long)>, но ядро будет использовать биты "
"только до I<maxnode>. Значение NULL в I<nodemask> или I<maxnode> указывает "
"на пустой набор узлов. Если значение I<maxnode> равно нулю, то аргумент "
"I<nodemask> игнорируется."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:157
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""
"Если требуется аргумент I<nodemask>, то его значение должно содержать не "
"менее одного работающего узла, разрешённого процессу из текущего контекста "
"набора процессоров (если не указан флаг режима B<MPOL_F_STATIC_NODES>) и "
"имеющего память. Если в I<mode> установлен флаг B<MPOL_F_STATIC_NODES> и "
"требуемое значение I<nodemask> не содержит узлов, разрешённых процессу из "
"текущего контекста набора процессоров, то политика памяти возвращается "
"обратно к I<локальному выделению>. Это эффективно заменяет указанную "
"политику до тех пор, пока в текущий контекст набора процессоров процесса не "
"добавится один или более узлов, указанных I<nodemask>."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:161
msgid "The I<mode> argument must include one of the following values:"
msgstr "Аргумент I<mode> должен включать одно из следующих значений:"

#. type: TP
#: man-pages/man2/set_mempolicy.2:161
#, no-wrap
msgid "B<MPOL_DEFAULT>"
msgstr "B<MPOL_DEFAULT>"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:171
msgid ""
"This mode specifies that any nondefault thread memory policy be removed, so "
"that the memory policy \"falls back\" to the system default policy.  The "
"system default policy is \"local allocation\"\\(emthat is, allocate memory "
"on the node of the CPU that triggered the allocation.  I<nodemask> must be "
"specified as NULL.  If the \"local node\" contains no free memory, the "
"system will attempt to allocate memory from a \"near by\" node."
msgstr ""
"Данный режим устанавливает, что любые политики памяти нити, не равные "
"политике по умолчанию, будут удалены, и политика памяти «вернётся» к "
"системной политике по умолчанию. Системная политика по умолчанию — это "
"«локальное выделение», то есть выделение памяти на узле с ЦП, на котором "
"возник запрос выделения Значение I<nodemask> должно быть равно NULL. Если на "
"«локальном узле» нет свободной памяти, то система попытается выделить память "
"на «ближайшем» узле."

#. type: TP
#: man-pages/man2/set_mempolicy.2:171
#, no-wrap
msgid "B<MPOL_BIND>"
msgstr "B<MPOL_BIND>"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:187
msgid ""
"This mode defines a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with the lowest numeric node "
"ID first, until that node contains no free memory.  Allocations will then "
"come from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contain free memory.  Pages "
"will not be allocated from any node not specified in the I<nodemask>."
msgstr ""
"Данный режим устанавливает жёсткую политику, при которой выделение памяти "
"выполняется только на узлах, заданных в I<nodemask>. Если в I<nodemask> "
"указано более одного узла, то выделение страниц начнётся с узла с меньшим "
"номером идентификатора и будет выполняться до тех пор, пока на нём не "
"кончится свободная память. Затем выделение продолжится на узле со следующим "
"большим номером идентификатора, указанного в I<nodemask>, и т.д. до тех пор, "
"пока на всех указанных узлах не закончится свободная память. Страницы не "
"будут выделяться на узлах, не указанных в I<nodemask>."

#. type: TP
#: man-pages/man2/set_mempolicy.2:188
#, no-wrap
msgid "B<MPOL_INTERLEAVE>"
msgstr "B<MPOL_INTERLEAVE>"

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1 MB or bigger.
#. type: Plain text
#: man-pages/man2/set_mempolicy.2:202
msgid ""
"This mode interleaves page allocations across the nodes specified in "
"I<nodemask> in numeric node ID order.  This optimizes for bandwidth instead "
"of latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  However, accesses to a single page will still be limited to "
"the memory bandwidth of a single node."
msgstr ""
"В этом режиме выделение страниц чередуется между узлами, указанными в "
"I<nodemask>, согласно порядку номеров идентификаторов узлов. При этом "
"происходит оптимизация полосы пропускания, а не задержки, так как происходит "
"рассеивание страниц и доступ к этим страницам памяти, разносится по "
"нескольким узлам. Однако доступ к отдельной странице по прежнему ограничен "
"шириной канала с памятью на отдельном узле."

#. type: TP
#: man-pages/man2/set_mempolicy.2:202
#, no-wrap
msgid "B<MPOL_PREFERRED>"
msgstr "B<MPOL_PREFERRED>"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:219
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to \"near by\" nodes if "
"the preferred node is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr ""
"В этом режиме задаётся предпочтительный узел для выделения памяти. Ядро "
"будет пытаться сначала выделить страницы на этом узле и только после того "
"как на предпочтительном узле не хватит памяти, попробует использовать "
"«ближайшие» узлы. Если в I<nodemask> указано более одного идентификатора "
"узла, то в качестве предпочтительного будет использован первый узел из "
"маски. Если в аргументах I<nodemask> и I<maxnode> указан пустой набор, то "
"политике предписывается использовать «локальное выделение» (как при "
"системной политике по умолчанию, описанной ранее)."

#. type: TP
#: man-pages/man2/set_mempolicy.2:219
#, no-wrap
msgid "B<MPOL_LOCAL> (since Linux 3.8)"
msgstr "B<MPOL_LOCAL> (начиная с Linux 3.8)"

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: man-pages/man2/set_mempolicy.2:238
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the process's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the process's current cpuset "
"context."
msgstr ""
"Этот режим задаёт «локальное выделение» (local allocation); память, "
"выделяется на узле ЦП, попавшем в выделение («локальный узел»). В аргументах "
"I<nodemask> и I<maxnode> должен быть указан пустой набор. Если на «локальном "
"узле»  мало свободной памяти, то ядро будет пытаться выделить память на "
"других узлах. Ядро будет выделять память на «локальном узле» сразу, как "
"только на этом узле освободится память. Если «локальный узел» не разрешён в "
"текущем контексте набора ЦП процесса, то ядро будет пытаться выделить памяти "
"на других узлах. Ядро начнёт выделять память на «локальном узле» сразу, как "
"только это будет разрешено в текущем контексте набора ЦП процесса."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:245
msgid ""
"The thread memory policy is preserved across an B<execve>(2), and is "
"inherited by child threads created using B<fork>(2)  or B<clone>(2)."
msgstr ""
"Политика памяти нити сохраняется при вызове B<execve>(2) и наследуется "
"дочерними нитями, созданными с помощью B<fork>(2) или B<clone>(2)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:252
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<set_mempolicy>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:260
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""
"Часть всего диапазона памяти, заданная в I<nodemask> и I<maxnode>, указывает "
"за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:297
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are on-"
"line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""
"Некорректное значение I<mode>. Или значение I<mode> равно B<MPOL_DEFAULT> и "
"значение I<nodemask> не пусто, или I<mode> равно B<MPOL_BIND> или "
"B<MPOL_INTERLEAVE> и значение I<nodemask> пусто. Или значение I<maxnode> "
"больше чем количество значимых бит страницы. Или в I<nodemask> указан один "
"или более идентификаторов узлов, значения которых больше чем максимальный "
"поддерживаемый идентификатор узла. Или ни один из идентификаторов узлов, "
"указанных в I<nodemask>, не работает или не разрешены для текущего набора "
"контекста процесса, или ни один из узлов не содержит памяти. Или в аргументе "
"I<mode> указаны B<MPOL_F_STATIC_NODES> и B<MPOL_F_RELATIVE_NODES> "
"одновременно."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:304
msgid ""
"The B<set_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""
"Системный вызов B<set_mempolicy>() был добавлен в ядро Linux версии  2.6.7."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:311
msgid ""
"Memory policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the thread or memory range "
"that is in effect at the time the page is allocated."
msgstr ""
"Политика памяти не запоминается, если страница помещается в пространство "
"подкачки. Когда страница возвращается в основную память, будет использована "
"политика нити или диапазона памяти, действующая на момент выделения страницы."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:314
msgid "For information on library support, see B<numa>(7)."
msgstr "Информация о библиотеке доступна в B<numa>(7)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:322
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"

#. type: TH
#: man-pages/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr "SCHED_SETPARAM"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""
"sched_setparam, sched_getparam - получает и устанавливает параметры "
"планирования"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:38
#, no-wrap
msgid "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:40
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:46
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:60
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the thread whose thread ID is specified in I<pid>.  If "
"I<pid> is zero, then the parameters of the calling thread are set.  The "
"interpretation of the argument I<param> depends on the scheduling policy of "
"the thread identified by I<pid>.  See B<sched>(7)  for a description of the "
"scheduling policies supported under Linux."
msgstr ""
"Вызов B<sched_setparam>() устанавливает параметры планирования, связанные с "
"алгоритмом планирования нити, идентификатор которой задан в I<pid>. Если "
"I<pid> равен нулю, то устанавливаются параметры вызывающей нити. Тип и "
"значение аргумента I<param> зависит от алгоритма планирования, назначенного "
"нити с идентификатором I<pid>. Описание алгоритмов планирования, "
"поддерживаемых в Linux, смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the thread "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"thread are retrieved."
msgstr ""
"Вызов B<sched_getparam>() получает текущие параметры планирования нити с "
"идентификатором I<pid>. Если I<pid> равно нулю, то возвращаются параметры "
"вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the thread.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""
"Вызов B<sched_setparam>() проверяет соответствие значения аргумента I<param> "
"политике планирования заданной нити. Значение I<param-E<gt>sched_priority> "
"должно находиться в диапазоне от B<sched_get_priority_min>(2) до "
"B<sched_get_priority_max>(2)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched>(7)."
msgstr ""
"Описание привилегий и ограничений ресурсов, связанных с планирование и "
"алгоритмами, смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"В POSIX-системах, в которых существуют вызовы B<sched_setparam>() и "
"B<sched_getparam>(), в I<E<lt>unistd.hE<gt>> определён макрос "
"B<_POSIX_PRIORITY_SCHEDULING>."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sched_setparam>() и B<sched_getparam>() возвращают "
"0. В случае ошибки возвращается -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:104
msgid "Invalid arguments: I<param> is NULL or I<pid> is negative"
msgstr ""
"Некорректные аргументы: значение I<pid> отрицательно или I<param> равно NULL"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:109
msgid ""
"(B<sched_setparam>())  The argument I<param> does not make sense for the "
"current scheduling policy."
msgstr ""
"(B<sched_setparam>()) Аргумент I<param> не соответствует текущей политике "
"планирования."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:116
msgid ""
"(B<sched_setparam>())  The caller does not have appropriate privileges "
"(Linux: does not have the B<CAP_SYS_NICE> capability)."
msgstr ""
"(B<sched_setparam>()) Вызывающий не имеет достаточного количества прав "
"(Linux: не имеет мандата B<CAP_SYS_NICE>)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:136
msgid ""
"B<gettid>(2), B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""
"B<gettid>(2), B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/sync.2:36
#, no-wrap
msgid "SYNC"
msgstr "SYNC"

#. type: Plain text
#: man-pages/man2/sync.2:39
msgid "sync, syncfs - commit filesystem caches to disk"
msgstr "sync, syncfs - записывает кэши файловых систем на диск"

#. type: Plain text
#: man-pages/man2/sync.2:43
msgid "B<void sync(void);>"
msgstr "B<void sync(void);>"

#. type: Plain text
#: man-pages/man2/sync.2:45
msgid "B<int syncfs(int >I<fd>B<);>"
msgstr "B<int syncfs(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man2/sync.2:52
msgid "B<sync>():"
msgstr "B<sync>():"

#. type: Plain text
#: man-pages/man2/sync.2:62
msgid "B<syncfs>():"
msgstr "B<syncfs>():"

#. type: Plain text
#: man-pages/man2/sync.2:65
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/sync.2:71
msgid ""
"B<sync>()  causes all pending modifications to filesystem metadata and "
"cached file data to be written to the underlying filesystems."
msgstr ""
"Вызов B<sync>() приводит к записи в файловую систему всех отложенных "
"изменений метаданных файловой системы и кэшированных файловых данных."

#. type: Plain text
#: man-pages/man2/sync.2:78
msgid ""
"B<syncfs>()  is like B<sync>(), but synchronizes just the filesystem "
"containing file referred to by the open file descriptor I<fd>."
msgstr ""
"Вызов B<syncfs>() подобен B<sync>(), но синхронизирует только файловую "
"систему, содержащую файл, на который указывает открытый файловый дескриптор "
"I<fd>."

#. type: Plain text
#: man-pages/man2/sync.2:84
msgid ""
"B<syncfs>()  returns 0 on success; on error, it returns -1 and sets I<errno> "
"to indicate the error."
msgstr ""
"При нормальном завершении работы B<syncfs>() возвращает 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sync.2:87
msgid "B<sync>()  is always successful."
msgstr "Вызов B<sync>() всегда выполняется без ошибок."

#. type: Plain text
#: man-pages/man2/sync.2:90
msgid "B<syncfs>()  can fail for at least the following reason:"
msgstr ""
"Вызов B<syncfs>() может завершиться с ошибкой, по крайней мере, по следующей "
"причине:"

#. type: Plain text
#: man-pages/man2/sync.2:98
msgid ""
"B<syncfs>()  first appeared in Linux 2.6.39; library support was added to "
"glibc in version 2.14."
msgstr ""
"Системный вызов B<syncfs>() впервые появился в Linux 2.6.39; поддержка в "
"glibc добавлена в версии 2.14."

#. type: Plain text
#: man-pages/man2/sync.2:101
msgid "B<sync>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "B<sync>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/sync.2:104
msgid "B<syncfs>()  is Linux-specific."
msgstr "B<syncfs>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/sync.2:113
msgid ""
"Since glibc 2.2.2, the Linux prototype for B<sync>()  is as listed above, "
"following the various standards.  In glibc 2.2.1 and earlier, it was \"int "
"sync(void)\", and B<sync>()  always returned 0."
msgstr ""
"Начиная с glibc 2.2.2 Linux-прототип B<sync>() стал соответствовать "
"различным стандартам. В glibc 2.21 и старее он объявлялся как «int "
"sync(void)» и вызов B<sync>() всегда возвращал 0."

#. type: Plain text
#: man-pages/man2/sync.2:124
msgid ""
"According to the standard specification (e.g., POSIX.1-2001), B<sync>()  "
"schedules the writes, but may return before the actual writing is done.  "
"However Linux waits for I/O completions, and thus B<sync>()  or B<syncfs>()  "
"provide the same guarantees as fsync called on every file in the system or "
"filesystem respectively."
msgstr ""
"В соответствии со стандартной спецификацией (например POSIX.1-2001), "
"B<sync>() только планирует запись, и может закончить работу до того как "
"запись будет на самом деле произведена. Однако в Linux выполняется ожидание "
"завершения операций ввода-вывода и поэтому B<sync>() или B<syncfs>() "
"предоставляют такие же гарантии как fsync при вызове для каждого файла в "
"системе или файловой системы, соответственно."

#. type: Plain text
#: man-pages/man2/sync.2:127
msgid ""
"Before version 1.3.20 Linux did not wait for I/O to complete before "
"returning."
msgstr ""
"До версии 1.3.20 Linux не ждёт завершения операций ввода-вывода перед "
"возвращением."

#. type: Plain text
#: man-pages/man2/sync.2:130
msgid "B<sync>(1), B<fdatasync>(2), B<fsync>(2)"
msgstr "B<sync>(1), B<fdatasync>(2), B<fsync>(2)"

#. type: TH
#: man-pages/man2/semop.2:35
#, no-wrap
msgid "SEMOP"
msgstr "SEMOP"

#. type: Plain text
#: man-pages/man2/semop.2:38
msgid "semop, semtimedop - System V semaphore operations"
msgstr "semop, semtimedop - операции с семафорами System V"

#. type: Plain text
#: man-pages/man2/semop.2:45
#, no-wrap
msgid "B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<);>\n"
msgstr "B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<);>\n"

#. type: Plain text
#: man-pages/man2/semop.2:48
#, no-wrap
msgid ""
"B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<,>\n"
"B<               const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<,>\n"
"B<               const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/semop.2:57
msgid "B<semtimedop>(): _GNU_SOURCE"
msgstr "B<semtimedop>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/semop.2:60
msgid ""
"Each semaphore in a System\\ V semaphore set has the following associated "
"values:"
msgstr ""
"С каждым семафором в наборе семафоров System\\ V связаны следующие значения:"

#. type: Plain text
#: man-pages/man2/semop.2:67
#, no-wrap
msgid ""
"unsigned short  semval;   /* semaphore value */\n"
"unsigned short  semzcnt;  /* # waiting for zero */\n"
"unsigned short  semncnt;  /* # waiting for increase */\n"
"pid_t           sempid;   /* PID of process that last\n"
msgstr ""
"unsigned short  semval;   /* значение семафора */\n"
"unsigned short  semzcnt;  /* # ожидает ноль */\n"
"unsigned short  semncnt;  /* # ожидает увеличения */\n"
"pid_t           sempid;   /* PID процесса, выполнявшегося последним \n"

#. type: Plain text
#: man-pages/man2/semop.2:82
msgid ""
"B<semop>()  performs operations on selected semaphores in the set indicated "
"by I<semid>.  Each of the I<nsops> elements in the array pointed to by "
"I<sops> is a structure that specifies an operation to be performed on a "
"single semaphore.  The elements of this structure are of type I<struct "
"sembuf>, containing the following members:"
msgstr ""
"Вызов B<semop>() производит операции над выбранными семафорами из набора "
"семафоров I<semid>. Каждый из элементов I<nsops> в массиве, указанном в "
"I<sops> является структурой, которой задаётся операция, выполняемая над "
"отдельным семафором. Элементы этой структуры имеют тип I<struct sembuf>, "
"который содержит поля:"

#. type: Plain text
#: man-pages/man2/semop.2:88
#, no-wrap
msgid ""
"unsigned short sem_num;  /* semaphore number */\n"
"short          sem_op;   /* semaphore operation */\n"
"short          sem_flg;  /* operation flags */\n"
msgstr ""
"unsigned short sem_num;  /* номер семафора */\n"
"short          sem_op;   /* операция над семафором */\n"
"short          sem_flg;  /* флаги операции */\n"

#. type: Plain text
#: man-pages/man2/semop.2:100
msgid ""
"Flags recognized in I<sem_flg> are B<IPC_NOWAIT> and B<SEM_UNDO>.  If an "
"operation specifies B<SEM_UNDO>, it will be automatically undone when the "
"process terminates."
msgstr ""
"Флаги в I<sem_flg> могут иметь значения B<IPC_NOWAIT> и B<SEM_UNDO>. Если "
"указан флаг B<SEM_UNDO>, то при завершении процесса будет выполнена откат "
"операции."

#. type: Plain text
#: man-pages/man2/semop.2:115
msgid ""
"The set of operations contained in I<sops> is performed in I<array order>, "
"and I<atomically>, that is, the operations are performed either as a "
"complete unit, or not at all.  The behavior of the system call if not all "
"operations can be performed immediately depends on the presence of the "
"B<IPC_NOWAIT> flag in the individual I<sem_flg> fields, as noted below."
msgstr ""
"Набор операций из I<sops> выполняется в I<порядке появления в массиве> и "
"I<является атомарным>, то есть выполняются или все операции, или ни одной. "
"Поведение системного вызова при обнаружении невозможности немедленного "
"выполнения операций зависит от наличия флага B<IPC_NOWAIT> в полях "
"I<sem_flg> отдельных операций, как это описано далее."

#. type: Plain text
#: man-pages/man2/semop.2:122
msgid ""
"Each operation is performed on the I<sem_num>-th semaphore of the semaphore "
"set, where the first semaphore of the set is numbered 0.  There are three "
"types of operation, distinguished by the value of I<sem_op>."
msgstr ""
"Каждая операция выполняется над I<sem_num>-тым семафором из набора, где "
"первый семафор имеет номер 0. Есть три типа операций, различающихся "
"значением I<sem_op>."

#. type: Plain text
#: man-pages/man2/semop.2:137
msgid ""
"If I<sem_op> is a positive integer, the operation adds this value to the "
"semaphore value (I<semval>).  Furthermore, if B<SEM_UNDO> is specified for "
"this operation, the system subtracts the value I<sem_op> from the semaphore "
"adjustment (I<semadj>)  value for this semaphore.  This operation can always "
"proceed\\(emit never forces a thread to wait.  The calling process must have "
"alter permission on the semaphore set."
msgstr ""
"Если значение I<sem_op> — положительное целое число, то оно добавляется к "
"значению семафора (I<semval>). Если для операции стоит флаг B<SEM_UNDO>, то "
"система вычитает значение I<sem_op> из значения регулировки (I<semadj>) "
"семафора. Эта операция выполняется всегда и не переводит нить в режим "
"ожидания. Вызывающий процесс должен иметь права на изменение набора "
"семафоров."

#. type: Plain text
#: man-pages/man2/semop.2:162
msgid ""
"If I<sem_op> is zero, the process must have read permission on the semaphore "
"set.  This is a \"wait-for-zero\" operation: if I<semval> is zero, the "
"operation can immediately proceed.  Otherwise, if B<IPC_NOWAIT> is specified "
"in I<sem_flg>, B<semop>()  fails with I<errno> set to B<EAGAIN> (and none of "
"the operations in I<sops> is performed).  Otherwise, I<semzcnt> (the count "
"of threads waiting until this semaphore's value becomes zero)  is "
"incremented by one and the thread sleeps until one of the following occurs:"
msgstr ""
"Если значение I<sem_op> равно нулю, то процесс должен иметь права на чтение "
"набора семафоров. Эта операция «ожидания нуля»: если I<semval> равно нулю, "
"то операция может выполнится сразу. Иначе, если в поле семафора I<sem_flg> "
"указан флаг B<IPC_NOWAIT>, то B<semop>() завершается с ошибкой и I<errno> "
"присваивается значение B<EAGAIN> (и ни одна операция из I<sops> не "
"выполняется). Или же I<semzcnt> (счётчик нитей, ожидающих пока значение "
"семафора не сравнялось с нулём) увеличивается на единицу, а нить переходит в "
"режим ожидания пока не случится одно из:"

#. type: Plain text
#: man-pages/man2/semop.2:167
msgid ""
"I<semval> becomes 0, at which time the value of I<semzcnt> is decremented."
msgstr ""
"Значение I<semval> станет равным 0, тогда значение I<semzcnt> уменьшается."

#. type: Plain text
#: man-pages/man2/semop.2:175
msgid ""
"The semaphore set is removed: B<semop>()  fails, with I<errno> set to "
"B<EIDRM>."
msgstr ""
"Набор семафоров удалится: B<semop>() завершается с ошибкой, а I<errno> "
"присваивается значение B<EIDRM>."

#. type: Plain text
#: man-pages/man2/semop.2:185
msgid ""
"The calling thread catches a signal: the value of I<semzcnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr ""
"Вызывающая нить получит сигнал: значение I<semncnt> уменьшается и B<semop>() "
"завершается с ошибкой, а I<errno> присваивается значение B<EINTR>."

#. type: Plain text
#: man-pages/man2/semop.2:227
msgid ""
"If I<sem_op> is less than zero, the process must have alter permission on "
"the semaphore set.  If I<semval> is greater than or equal to the absolute "
"value of I<sem_op>, the operation can proceed immediately: the absolute "
"value of I<sem_op> is subtracted from I<semval>, and, if B<SEM_UNDO> is "
"specified for this operation, the system adds the absolute value of "
"I<sem_op> to the semaphore adjustment (I<semadj>)  value for this "
"semaphore.  If the absolute value of I<sem_op> is greater than I<semval>, "
"and B<IPC_NOWAIT> is specified in I<sem_flg>, B<semop>()  fails, with "
"I<errno> set to B<EAGAIN> (and none of the operations in I<sops> is "
"performed).  Otherwise, I<semncnt> (the counter of threads waiting for this "
"semaphore's value to increase)  is incremented by one and the thread sleeps "
"until one of the following occurs:"
msgstr ""
"Если значение I<sem_op> меньше нуля, то процесс должен иметь права на "
"изменение набора семафоров. Если значение I<semval> больше или равно "
"абсолютному значению I<sem_op>, то операция может выполнятся сразу: "
"абсолютное значение I<sem_op> вычитается из I<semval>, и, если для этой "
"операции установлен флаг B<SEM_UNDO>, система добавляет абсолютное значение "
"I<sem_op> к значению регулировки (I<semadj>) семафора. Если абсолютное "
"значение I<sem_op> больше I<semval>, и в I<sem_flg> указан B<IPC_NOWAIT>, то "
"B<semop>() завершается с ошибкой, а I<errno> присваивается значение "
"B<EAGAIN> (и ни одна операция из I<sops> не выполняется). Иначе I<semncnt> "
"(счётчик нитей, ожидающих увеличения значения семафора) увеличивается на "
"единицу, а нить переходит в режим ожидания пока не случится одно из:"

#. type: Plain text
#: man-pages/man2/semop.2:232
msgid ""
"I<semval> becomes greater than or equal to the absolute value of I<sem_op>: "
"the operation now proceeds, as described above."
msgstr ""
"I<semval> становится больше или равно абсолютному значению I<sem_op>: "
"операция продолжается как описано выше."

#. type: Plain text
#: man-pages/man2/semop.2:239
msgid ""
"The semaphore set is removed from the system: B<semop>()  fails, with "
"I<errno> set to B<EIDRM>."
msgstr ""
"Набор семафоров удалится из системы: B<semop>() завершается с ошибкой, а "
"I<errno> присваивается значение B<EIDRM>."

#. type: Plain text
#: man-pages/man2/semop.2:249
msgid ""
"The calling thread catches a signal: the value of I<semncnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr ""
"Вызывающая нить получит сигнал: значение I<semncnt> уменьшается и B<semop>() "
"завершается с ошибкой, а I<errno> присваивается значение B<EINTR>."

#.  and
#.  .I sem_ctime
#. type: Plain text
#: man-pages/man2/semop.2:260
msgid ""
"On successful completion, the I<sempid> value for each semaphore specified "
"in the array pointed to by I<sops> is set to the caller's process ID.  In "
"addition, the I<sem_otime> is set to the current time."
msgstr ""
"При успешном выполнении значение I<sempid> для каждого семафора, указанного "
"в массиве, на который указывает I<sops>, устанавливается равным "
"идентификатору вызывающего процесса. Также I<sem_otime> присваивается "
"значение текущего времени."

#. type: SS
#: man-pages/man2/semop.2:260
#, no-wrap
msgid "semtimedop()"
msgstr "semtimedop()"

#. type: Plain text
#: man-pages/man2/semop.2:290
msgid ""
"B<semtimedop>()  behaves identically to B<semop>()  except that in those "
"cases where the calling thread would sleep, the duration of that sleep is "
"limited by the amount of elapsed time specified by the I<timespec> structure "
"whose address is passed in the I<timeout> argument.  (This sleep interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the interval may overrun by a small amount.)  If the "
"specified time limit has been reached, B<semtimedop>()  fails with I<errno> "
"set to B<EAGAIN> (and none of the operations in I<sops> is performed).  If "
"the I<timeout> argument is NULL, then B<semtimedop>()  behaves exactly like "
"B<semop>()."
msgstr ""
"Системный вызов B<semtimedop>() ведёт себя идентично B<semop>(), за  "
"исключением  того, что в случаях, когда вызывающая нить будет спать, "
"длительность этого сна ограничена количеством времени, определяемым "
"структурой I<timespec>, чей адрес передаётся в аргументе I<timeout>. Данное  "
"значение интервала будет округлено до точности системных часов, а из-за "
"задержки при планировании в ядре блокирующий интервал будет немного больше. "
"Если достигнут указанный лимит времени, то B<semtimedop>() завершится с "
"ошибкой, а I<errno> устанавливается в B<EAGAIN> (и ни одна из операций в "
"I<sops> не выполняется). Если значение аргумента I<timeout> равно NULL, то "
"B<semtimedop>() ведёт себя аналогично B<semop>()."

#. type: Plain text
#: man-pages/man2/semop.2:298
msgid ""
"Note that if B<semtimedop>()  is interrupted by a signal, causing the call "
"to fail with the error B<EINTR>, the contents of I<timeout> are left "
"unchanged."
msgstr ""
"Заметим, что если B<semtimedop>() прерывается сигналом, то вызов завершается "
"с ошибкой B<EINTR>, а содержимое I<timeout> не изменяется."

#. type: Plain text
#: man-pages/man2/semop.2:308
msgid ""
"If successful, B<semop>()  and B<semtimedop>()  return 0; otherwise they "
"return -1 with I<errno> indicating the error."
msgstr ""
"При успешном выполнении B<semop>() и B<semtimedop>() возвращается 0; иначе "
"возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: TP
#: man-pages/man2/semop.2:312
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/semop.2:320
msgid ""
"The argument I<nsops> is greater than B<SEMOPM>, the maximum number of "
"operations allowed per system call."
msgstr ""
"Значение аргумента I<nsops> больше B<SEMOPM>, максимального количества "
"операций, которое может выполнить один системный вызов."

#. type: Plain text
#: man-pages/man2/semop.2:327
msgid ""
"The calling process does not have the permissions required to perform the "
"specified semaphore operations, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""
"Вызывающий процесс не имеет прав, требуемых для выполнения указанных "
"операций над семафорами, и не имеет мандата B<CAP_IPC_OWNER>, который "
"управляет его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/semop.2:336
msgid ""
"An operation could not proceed immediately and either B<IPC_NOWAIT> was "
"specified in I<sem_flg> or the time limit specified in I<timeout> expired."
msgstr ""
"Операция не может быть выполнена немедленно и, либо B<IPC_NOWAIT> был указан "
"в I<sem_flg>, либо истекло время лимита, определённое в I<timeout>."

#. type: Plain text
#: man-pages/man2/semop.2:343
msgid ""
"An address specified in either the I<sops> or the I<timeout> argument isn't "
"accessible."
msgstr "Адрес, указанный в I<sops> или I<timeout>, не доступен."

#. type: TP
#: man-pages/man2/semop.2:343
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man2/semop.2:349
msgid ""
"For some operation the value of I<sem_num> is less than 0 or greater than or "
"equal to the number of semaphores in the set."
msgstr ""
"Для некоторых операций значение I<sem_num> меньше нуля или больше или равно "
"количеству семафоров в наборе."

#. type: Plain text
#: man-pages/man2/semop.2:356
msgid ""
"While blocked in this system call, the thread caught a signal; see "
"B<signal>(7)."
msgstr ""
"Нить, находясь в режиме ожидания, получила сигнал; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/semop.2:363
msgid ""
"The semaphore set doesn't exist, or I<semid> is less than zero, or I<nsops> "
"has a nonpositive value."
msgstr ""
"Набор семафоров не существует, или значение I<semid> меньше нуля, или "
"I<nsops> имеет не положительное значение."

#. type: Plain text
#: man-pages/man2/semop.2:371
msgid ""
"The I<sem_flg> of some operation specified B<SEM_UNDO> and the system does "
"not have enough memory to allocate the undo structure."
msgstr ""
"Для некоторых операций в поле I<sem_flg> задан флаг B<SEM_UNDO>, и система "
"не может выделить достаточно памяти для структуры откатов."

#. type: Plain text
#: man-pages/man2/semop.2:379
msgid ""
"For some operation I<sem_op+semval> is greater than B<SEMVMX>, the "
"implementation dependent maximum value for I<semval>."
msgstr ""
"Для некоторых операций I<sem_op+semval> больше чем B<SEMVMX>, максимального "
"значения I<semval> (зависит от реализации)."

#. type: Plain text
#: man-pages/man2/semop.2:386
msgid ""
"B<semtimedop>()  first appeared in Linux 2.5.52, and was subsequently "
"backported into kernel 2.4.22.  Glibc support for B<semtimedop>()  first "
"appeared in version 2.3.3."
msgstr ""
"Вызов B<semtimedop>() впервые появился в Linux 2.5.52, а затем был перенесён "
"в ядро версии 2.4.22. Поддержка в glibc для B<semtimedop>() впервые "
"появилась в версии 2.3.3."

#. type: Plain text
#: man-pages/man2/semop.2:410
msgid ""
"The I<sem_undo> structures of a process aren't inherited by the child "
"produced by B<fork>(2), but they are inherited across an B<execve>(2)  "
"system call."
msgstr ""
"Структуры процесса I<sem_undo> не наследуются потомками, созданными через "
"B<fork>(2), но они наследуются при выполнении системного вызова B<execve>(2)."

#. type: Plain text
#: man-pages/man2/semop.2:416
msgid ""
"B<semop>()  is never automatically restarted after being interrupted by a "
"signal handler, regardless of the setting of the B<SA_RESTART> flag when "
"establishing a signal handler."
msgstr ""
"Вызов B<semop>() никогда автоматически не перезапускается после прерывания "
"обработчиком сигнала, независимо от установки флага B<SA_RESTART> при "
"настройке обработчика сигнала."

#. type: Plain text
#: man-pages/man2/semop.2:449
msgid ""
"A semaphore adjustment (I<semadj>)  value is a per-process, per-semaphore "
"integer that is the negated sum of all operations performed on a semaphore "
"specifying the B<SEM_UNDO> flag.  Each process has a list of I<semadj> values"
"\\(emone value for each semaphore on which it has operated using "
"B<SEM_UNDO>.  When a process terminates, each of its per-semaphore I<semadj> "
"values is added to the corresponding semaphore, thus undoing the effect of "
"that process's operations on the semaphore (but see BUGS below).  When a "
"semaphore's value is directly set using the B<SETVAL> or B<SETALL> request "
"to B<semctl>(2), the corresponding I<semadj> values in all processes are "
"cleared.  The B<clone>(2)  B<CLONE_SYSVSEM> flag allows more than one "
"process to share a I<semadj> list; see B<clone>(2)  for details."
msgstr ""
"Значение регулировки семафора (I<semadj>) есть в каждом процессе. Это целое "
"число — простой (отрицательный) счётчик всех операций над семафорами, для "
"которых установлен флаг B<SEM_UNDO>. В каждом процессе есть список значений "
"I<semadj> — по одному значению на каждый семафор, у которых установлен флаг "
"B<SEM_UNDO>. При завершении процесса. каждое из значений I<semadj> семафора "
"добавляется к соответствующему семафору, достигая таким образом эффекта "
"выполнения операций процесса над семафорами (но смотрите раздел ДЕФЕКТЫ). "
"Когда значение семафора явно устанавливается с помощью запроса B<SETVAL> или "
"B<SETALL> вызовом B<semctl>(2), то соответствующие значения I<semadj> во "
"всех процессах очищаются. Флаг B<CLONE_SYSVSEM> B<clone>(2) позволяет "
"нескольким процессам совместно использовать список I<semadj>; подробности "
"смотрите в B<clone>(2)."

#. type: Plain text
#: man-pages/man2/semop.2:454
msgid ""
"The I<semval>, I<sempid>, I<semzcnt>, and I<semnct> values for a semaphore "
"can all be retrieved using appropriate B<semctl>(2)  calls."
msgstr ""
"Значения I<semval>, I<sempid>, I<semzcnt> и I<semnct> семафора можно "
"получить с помощью соответствующих вызовов B<semctl>(2)."

#. type: Plain text
#: man-pages/man2/semop.2:458
msgid ""
"The following limits on semaphore set resources affect the B<semop>()  call:"
msgstr ""
"Ниже приведены лимиты ресурсов наборов семафоров, влияющие на вызов "
"B<semop>():"

#. type: TP
#: man-pages/man2/semop.2:458
#, no-wrap
msgid "B<SEMOPM>"
msgstr "B<SEMOPM>"

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#.  See comment in Linux 3.19 source file include/uapi/linux/sem.h
#. type: Plain text
#: man-pages/man2/semop.2:478
msgid ""
"Maximum number of operations allowed for one B<semop>()  call.  Before Linux "
"3.19, the default value for this limit was 32.  Since Linux 3.19, the "
"default value is 500.  On Linux, this limit can be read and modified via the "
"third field of I</proc/sys/kernel/sem>.  I<Note>: this limit should not be "
"raised above 1000, because of the risk of that B<semop>()  fails due to "
"kernel memory fragmentation when allocating memory to copy the I<sops> array."
msgstr ""
"Максимальное количество операций, разрешённых для одного вызова B<semop>(). "
"До версии Linux 3.19, значение по умолчанию было 3. Начиная с Linux 3.19, "
"значение по умолчанию равно 500. В Linux это ограничение можно прочитать и "
"изменить через третье поле I</proc/sys/kernel/sem>. I<Замечание>: это "
"ограничение не должно превышать 1000, так как есть риск, что B<semop>(2) "
"завершится с ошибкой из-за фрагментации памяти ядра при выделении памяти при "
"копировании массива I<sops>."

#. type: Plain text
#: man-pages/man2/semop.2:483
msgid ""
"Maximum allowable value for I<semval>: implementation dependent (32767)."
msgstr ""
"Максимально допустимое значение I<semval>: зависит от реализации (32767)."

#. type: Plain text
#: man-pages/man2/semop.2:490
msgid ""
"The implementation has no intrinsic limits for the adjust on exit maximum "
"value (B<SEMAEM>), the system wide maximum number of undo structures "
"(B<SEMMNU>)  and the per-process maximum number of undo entries system "
"parameters."
msgstr ""
"Реализация не накладывает существенных ограничений на максимальное значение "
"(B<SEMAEM>), на которое можно изменить значение семафора при выходе, "
"максимальное количество системных структур откатываемых операций (B<SEMMNU>) "
"и максимальное количество элементов отката системных параметров на процесс."

#. type: Plain text
#: man-pages/man2/semop.2:511
msgid ""
"When a process terminates, its set of associated I<semadj> structures is "
"used to undo the effect of all of the semaphore operations it performed with "
"the B<SEM_UNDO> flag.  This raises a difficulty: if one (or more) of these "
"semaphore adjustments would result in an attempt to decrease a semaphore's "
"value below zero, what should an implementation do? One possible approach "
"would be to block until all the semaphore adjustments could be performed.  "
"This is however undesirable since it could force process termination to "
"block for arbitrarily long periods.  Another possibility is that such "
"semaphore adjustments could be ignored altogether (somewhat analogously to "
"failing when B<IPC_NOWAIT> is specified for a semaphore operation).  Linux "
"adopts a third approach: decreasing the semaphore value as far as possible "
"(i.e., to zero) and allowing process termination to proceed immediately."
msgstr ""
"При завершении процесса его набор связанных структур I<semadj> используется "
"для отката выполненных действий над семафорами, для которых был установлен "
"флаг B<SEM_UNDO>. Это повышает сложность: если одно (или более) этих "
"изменений семафоров привело бы в результате к попытке уменьшить значение "
"семафора ниже нуля, что должно быть сделано в реализации? Одним из возможных "
"решений была бы блокировка до тех пор, пока не выполнятся все изменения "
"семафоров. Однако это нежелательно, так как это привело бы к блокированию "
"процесса на неопределённый срок при его завершении. Другим вариантом "
"является игнорирование сразу всех изменений семафоров (в некоторой степени, "
"аналогично завершению с ошибкой, когда для операции с семафором указан "
"B<IPC_NOWAIT>). В Linux используется третий вариант: уменьшение значения "
"семафора до тех пор, пока это возможно ( т.е. до нуля) и разрешение "
"немедленного завершения процесса."

#.  The bug report:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110260821123863&w=2
#.  the fix:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110261701025794&w=2
#. type: Plain text
#: man-pages/man2/semop.2:520
msgid ""
"In kernels 2.6.x, x E<lt>= 10, there is a bug that in some circumstances "
"prevents a thread that is waiting for a semaphore value to become zero from "
"being woken up when the value does actually become zero.  This bug is fixed "
"in kernel 2.6.11."
msgstr ""
"В ядрах 2.6.x, где x E<lt>= 10, есть дефект, из-за которого при определённых "
"обстоятельствах нить, ожидающая установления значения семафора равного нулю, "
"не будет разбужен когда значение станет равным нулю. Этот дефект исправлен в "
"ядре 2.6.11."

#. type: Plain text
#: man-pages/man2/semop.2:525
msgid ""
"The following code segment uses B<semop>()  to atomically wait for the value "
"of semaphore 0 to become zero, and then increment the semaphore value by one."
msgstr ""
"В следующем фрагменте кода используется B<semop>() для атомарного ожидания "
"момента, когда значение семафора 0 станет равным нулю и последующего "
"увеличения значения семафора на единицу."

#. type: Plain text
#: man-pages/man2/semop.2:530
#, no-wrap
msgid ""
"struct sembuf sops[2];\n"
"int semid;\n"
msgstr ""
"struct sembuf sops[2];\n"
"int semid;\n"

#. type: Plain text
#: man-pages/man2/semop.2:532
#, no-wrap
msgid "/* Code to set I<semid> omitted */\n"
msgstr "/* код для установки I<semid> не показан */\n"

#. type: Plain text
#: man-pages/man2/semop.2:536
#, no-wrap
msgid ""
"sops[0].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[0].sem_op = 0;         /* Wait for value to equal 0 */\n"
"sops[0].sem_flg = 0;\n"
msgstr ""
"sops[0].sem_num = 0;        /* применяем к семафору 0 */\n"
"    sops[0].sem_op = 0;     /* ждём значения, равного 0 */\n"
"    sops[0].sem_flg = 0;\n"

#. type: Plain text
#: man-pages/man2/semop.2:540
#, no-wrap
msgid ""
"sops[1].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[1].sem_op = 1;         /* Increment value by one */\n"
"sops[1].sem_flg = 0;\n"
msgstr ""
"sops[1].sem_num = 0;        /* применяем к семафору 0 */\n"
"    sops[1].sem_op = 1;     /* увеличиваем значение на 1 */\n"
"    sops[1].sem_flg = 0;\n"

#. type: Plain text
#: man-pages/man2/semop.2:545
#, no-wrap
msgid ""
"if (semop(semid, sops, 2) == -1) {\n"
"    perror(\"semop\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"if (semop(semid, sops, 2) == -1) {\n"
"    perror(\"semop\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/semop.2:555
msgid ""
"B<clone>(2), B<semctl>(2), B<semget>(2), B<sigaction>(2), "
"B<capabilities>(7), B<sem_overview>(7), B<sysvipc>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr "SPU_CREATE"

#. type: Plain text
#: man-pages/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr "spu_create - создаёт новый контекст spu"

#. type: Plain text
#: man-pages/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/spu_create.2:36
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"

#. type: Plain text
#: man-pages/man2/spu_create.2:59
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU "
"filesystem (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr ""
"Системный вызов B<spu_create>() используется на машинах PowerPC с "
"архитектурой Cell Broadband Engine для получения доступа к Synergistic "
"Processor Unit (SPU). Он создаёт новый логический контекст для SPU в "
"I<pathname> и возвращает связанный с ним файловый дескриптор. Аргумент "
"I<pathname> должен указывать на несуществующий каталог в точке монтирования "
"файловой системы SPU (B<spufs>). Если работа B<spu_create>() выполнена без "
"ошибок, то создаётся каталог I<pathname>, а в нём создаются файлы, описанные "
"в B<spufs>(7)."

#. type: Plain text
#: man-pages/man2/spu_create.2:78
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr ""
"После создания контекста, полученный файловый дескриптор может быть передан "
"только B<spu_run>(2), семейству системных вызовов B<*at> (например, "
"B<openat>(2)) в аргументе I<dirfd> или закрыт; другие операции не "
"определены. Логический контекст SPU уничтожается (вместе с файлами, "
"созданными внутри каталога контекста I<pathname>) после освобождения "
"последней ссылки на контекст; обычно, это происходит после закрытия "
"файлового дескриптора, возвращённого B<spu_create>()."

#. type: Plain text
#: man-pages/man2/spu_create.2:83
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr ""
"Аргумент I<flags> может быть равен нулю или содержать любую побитовую "
"комбинацию (посредством OR) следующих констант:"

#. type: TP
#: man-pages/man2/spu_create.2:83
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr "B<SPU_CREATE_EVENTS_ENABLED>"

#. type: Plain text
#: man-pages/man2/spu_create.2:89
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr ""
"Вместо использования сигналов для сообщения об ошибках DMA, использовать "
"аргумент I<event> в B<spu_run>(2)."

#. type: TP
#: man-pages/man2/spu_create.2:89
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr "B<SPU_CREATE_GANG>"

#. type: Plain text
#: man-pages/man2/spu_create.2:97
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts "
"that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as "
"a single unit.)"
msgstr ""
"Создать блок (gang) SPU вместо контекста (блок — это группа контекстов SPU, "
"которые близки по функциям и у которых общие параметры планирования — "
"приоритет и политика. В будущем, планирование блока на включение и "
"выключение может быть реализовано как единого целое)."

#. type: Plain text
#: man-pages/man2/spu_create.2:104
msgid ""
"A new directory will be created at the location specified by the I<pathname> "
"argument.  This gang may be used to hold other SPU contexts, by providing a "
"pathname that is within the gang directory to further calls to "
"B<spu_create>()."
msgstr ""
"В месте, указанном в аргументе I<pathname>, будет создан новый каталог. Этот "
"блок может использоваться для хранения других контекстов SPU, если указывать "
"путь блока в последующих вызовах B<spu_create>()."

#. type: TP
#: man-pages/man2/spu_create.2:104
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr "B<SPU_CREATE_NOSCHED>"

#. type: Plain text
#: man-pages/man2/spu_create.2:110
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr ""
"Создать контекст, на который не влияет планировщик SPU. После запуска "
"контекста, он не будет планироваться для выполнения пока не будет уничтожен "
"создавшим его процессом."

#. type: Plain text
#: man-pages/man2/spu_create.2:121
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr ""
"Так как контекст не может быть удалён из SPU, у контекстов "
"B<SPU_CREATE_NOSCHED> отключены некоторые возможности. Не все файлы будут "
"доступны в каталоге этого контекста в B<spufs>. Также, для контекстов "
"B<SPU_CREATE_NOSCHED> не может быть создан файл дампа при поломке."

#. type: Plain text
#: man-pages/man2/spu_create.2:127
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr ""
"Для создания контекстов B<SPU_CREATE_NOSCHED> требуется мандат "
"B<CAP_SYS_NICE>."

#. type: TP
#: man-pages/man2/spu_create.2:127
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr "B<SPU_CREATE_ISOLATE>"

#. type: Plain text
#: man-pages/man2/spu_create.2:134
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr ""
"Создать изолированный контекст SPU. Изолированные контексты защищены от "
"некоторых операций PPE (PowerPC Processing Element), таких как доступ к "
"локальному хранилищу SPU и регистру NPC."

#. type: Plain text
#: man-pages/man2/spu_create.2:140
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""
"Для создания контекста B<SPU_CREATE_ISOLATE> также требуется флаг "
"B<SPU_CREATE_NOSCHED>."

#. type: TP
#: man-pages/man2/spu_create.2:140
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU>"
msgstr "B<SPU_CREATE_AFFINITY_SPU>"

#. type: Plain text
#: man-pages/man2/spu_create.2:148
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed "
"in the I<neighbor_fd> argument."
msgstr ""
"Создать контекст со связью с другим контекстом SPU. Эта информация о связи "
"используется в алгоритме планирования SPU. При использовании этого флага "
"требуется, чтобы файловый дескриптор, ссылающийся на другой контекст SPU, "
"передавался в аргументе I<neighbor_fd>."

#. type: TP
#: man-pages/man2/spu_create.2:148
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM>"
msgstr "B<SPU_CREATE_AFFINITY_MEM>"

#. type: Plain text
#: man-pages/man2/spu_create.2:153
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr ""
"Создать контекст со связью с системной памятью. Эта информация о связи "
"используется в алгоритме планирования SPU."

#. type: Plain text
#: man-pages/man2/spu_create.2:165
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr ""
"В аргументе I<mode> (не считая битов B<umask>(2) процесса) задаются права, "
"которые используются при создании нового каталога в B<spufs>. Полное "
"описание всех значений I<mode> смотрите в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/spu_create.2:172
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is "
"returned, and I<errno> is set to one of the error codes listed below."
msgstr ""
"При успешном выполнении B<spu_create>() возвращается новый файловый "
"дескриптор; при ошибке возвращается -1, а в I<errno> содержится один из "
"кодов ошибки, описанных далее."

#. type: Plain text
#: man-pages/man2/spu_create.2:178
msgid ""
"The current user does not have write access to the B<spufs>(7)  mount point."
msgstr ""
"Текущий пользователь не имеет прав на запись в точку монтирования "
"B<spufs>(7)."

#. type: Plain text
#: man-pages/man2/spu_create.2:181
msgid "An SPU context already exists at the given pathname."
msgstr "Контекст SPU с указанным именем пути уже существует."

#. type: Plain text
#: man-pages/man2/spu_create.2:186
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr ""
"Значение I<pathname> не является допустимым строковым указателем в адресном "
"пространстве вызывающего процесса."

#. type: Plain text
#: man-pages/man2/spu_create.2:192
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr ""
"Значение I<pathname> не является каталогом в точке монтирования B<spufs>(7), "
"или указаны неправильные флаги."

#. type: Plain text
#: man-pages/man2/spu_create.2:196
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr ""
"Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/spu_create.2:210
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr ""
"Был запрошен изолированный контекст, но аппаратная часть не поддерживает "
"изоляцию SPU."

#. type: Plain text
#: man-pages/man2/spu_create.2:215
msgid "Part of I<pathname> could not be resolved."
msgstr "Невозможно определить часть I<pathname>."

#. type: Plain text
#: man-pages/man2/spu_create.2:218
msgid "The kernel could not allocate all resources required."
msgstr "Ядро не может выделить все требуемые ресурсы."

#. type: Plain text
#: man-pages/man2/spu_create.2:223
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr ""
"Недостаточно ресурсов SPU для создания нового контекста или достигнуто "
"ограничение на количество контекстов SPU для пользователя."

#. type: Plain text
#: man-pages/man2/spu_create.2:228
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""
"Возможность не предоставляется текущей системой, так как или аппаратура не "
"предоставляет SPU, или не загружен модуль spufs."

#. type: Plain text
#: man-pages/man2/spu_create.2:233
msgid "A part of I<pathname> is not a directory."
msgstr "Часть I<pathname> не является каталогом."

#. type: Plain text
#: man-pages/man2/spu_create.2:240
msgid ""
"The I<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr ""
"Указан флаг I<SPU_CREATE_NOSCHED>, но пользователь не имеет мандата "
"B<CAP_SYS_NICE>."

#. type: Plain text
#: man-pages/man2/spu_create.2:246
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr ""
"Значение I<pathname> должно указываться относительно точки монтирования "
"B<spufs>. По соглашению всё монтируется в I</spu>."

#. type: Plain text
#: man-pages/man2/spu_create.2:250
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr ""
"Системный вызов B<spu_create>() был добавлен в ядро Linux версии 2.6.16."

#. type: Plain text
#: man-pages/man2/spu_create.2:254
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""
"Данный вызов существует только в Linux и реализован только для архитектуры "
"PowerPC. Программы, использующие данный вызов, не переносимы."

#. type: Plain text
#: man-pages/man2/spu_create.2:265
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR http://www.bsc.es\\:/projects\\:/"
"deepcomputing\\:/linuxoncell/> E<.UE> for the recommended libraries."
msgstr ""
"В glibc нет обёртки для этого системного вызова; запускайте его с помощью "
"B<syscall>(2). Однако заметим, что B<spu_run>() предназначен для работы в "
"библиотеках, которые реализуют более абстрактный интерфейс к SPU и не должен "
"вызываться из обычных приложений. Рекомендуемые библиотеки приведены на "
"странице E<.UR http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/"
"> E<.UE .>"

#. type: Plain text
#: man-pages/man2/spu_create.2:270
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr "В B<spu_run>(2) дан пример использования B<spu_create>()."

#. type: Plain text
#: man-pages/man2/spu_create.2:274
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: man-pages/man2/s390_runtime_instr.2:25
#, no-wrap
msgid "S390_RUNTIME_INSTR"
msgstr "S390_RUNTIME_INSTR"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:28
msgid "s390_runtime_instr - enable/disable s390 CPU run-time instrumentation"
msgstr ""
"s390_runtime_instr - включает/выключает технические средства ЦП s390 времени "
"выполнения"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:31
#, no-wrap
msgid "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"
msgstr "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:33
#, no-wrap
msgid "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"
msgstr "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:39
msgid ""
"The B<s390_runtime_instr>()  system call starts or stops CPU run-time "
"instrumentation for the calling thread."
msgstr ""
"Системный вызов B<s390_runtime_instr>() запускает или останавливает "
"технические средства ЦП времени выполнения для вызывающей нити."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:47
msgid ""
"The I<command> argument controls whether run-time instrumentation is started "
"(B<S390_RUNTIME_INSTR_START>, 1) or stopped (B<S390_RUNTIME_INSTR_STOP>, 2) "
"for the calling thread."
msgstr ""
"В аргументе I<command> указывается, что технические средства времени "
"выполнения нужно запустить (B<S390_RUNTIME_INSTR_START>, 1) или остановить "
"(B<S390_RUNTIME_INSTR_STOP>, 2) для вызывающей нити."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:54
msgid ""
"The I<signum> argument specifies the number of a real-time signal.  The real-"
"time signal is sent to the thread if the run-time instrumentation buffer is "
"full or if the run-time-instrumentation-halted interrupt occurred."
msgstr ""
"В аргументе I<signum> задаётся номер сигнала реального времени. Сигнал "
"реального времени посылается нити, если буфер технических средств времени "
"выполнения заполнился или произошло прерывание run-time-instrumentation-"
"halted."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:65
msgid ""
"On success, B<s390_runtime_instr>()  returns 0 and enables the thread for "
"run-time instrumentation by assigning the thread a default run-time "
"instrumentation control block.  The caller can then read and modify the "
"control block and start the run-time instrumentation.  On error, -1 is "
"returned and I<errno> is set to one of the error codes listed below."
msgstr ""
"При успешном выполнении B<s390_runtime_instr>() возвращает 0 и включает в "
"нити технические средства времени выполнения, назначая нити блок управления "
"техническими средствами времени выполнения. После этого вызывающий может "
"читать и изменять блок управления и запускать технические средства времени "
"выполнения. При ошибке возвращается -1 и в I<errno> записывается один из "
"кодов ошибки, показанных далее."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:73
msgid ""
"The value specified in I<command> is not a valid command or the value "
"specified in I<signum> is not a real-time signal number."
msgstr ""
"Значение I<command> не является допустимой командой, или значение I<signum> "
"не является номером сигнала реального времени."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:76
msgid ""
"Allocating memory for the run-time instrumentation control block failed."
msgstr ""
"Не удалось выделить память под блок управления техническими средствами "
"времени выполнения."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:79
msgid "The run-time instrumentation facility is not available."
msgstr "Технические средства времени выполнения недоступны."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:81
msgid "This system call is available since Linux 3.7."
msgstr "Данный системный вызов появился в Linux 3.7."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:84
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The run-time instrumentation facility is available beginning with System z "
"EC12."
msgstr ""
"Данный системный вызов есть только в Linux и только на архитектуре s390. "
"Технические средства времени выполнения доступны начиная с System z EC12."

#.  commit df2f815a7df7edb5335a3bdeee6a8f9f6f9c35c4
#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:94
msgid "The I<asm/runtime_instr.h> header file is available since Linux 4.16."
msgstr ""
"Заголовочный файл I<asm/runtime_instr.h> доступен в Linux начиная с версии "
"4.16."

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:96
msgid "B<syscall>(2), B<signal>(7)"
msgstr "B<syscall>(2), B<signal>(7)"

#. type: TH
#: man-pages/man2/sigaltstack.2:27
#, no-wrap
msgid "SIGALTSTACK"
msgstr "SIGALTSTACK"

#. type: TH
#: man-pages/man2/sigaltstack.2:27
#, no-wrap
msgid "2017-11-08"
msgstr "2017-11-08"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:30
msgid "sigaltstack - set and/or get signal stack context"
msgstr "sigaltstack - считывает или устанавливает расположение стека сигналов"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:34
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<old_ss>B<);>"
msgstr "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<old_ss>B<);>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:41
msgid "B<sigaltstack>():"
msgstr "B<sigaltstack>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/sigaltstack.2:48
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:60
msgid ""
"B<sigaltstack>()  allows a process to define a new alternate signal stack "
"and/or retrieve the state of an existing alternate signal stack.  An "
"alternate signal stack is used during the execution of a signal handler if "
"the establishment of that handler (see B<sigaction>(2))  requested it."
msgstr ""
"Вызов B<sigaltstack>() позволяет процессу определить новый альтернативный "
"стек сигналов и/или получить состояние уже имеющегося альтернативного стека "
"сигналов. Альтернативный стек сигналов используется при выполнении "
"обработчика сигналов, если он был запрошен при установлении обработчика (см. "
"B<sigaction>(2))."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:63
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr ""
"Обычный порядок действий для использования альтернативного стека сигналов:"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:67
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr ""
"Выделить область памяти, которая будет использована под альтернативный стек "
"сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:73
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr ""
"Вызвать B<sigaltstack>() для информирования системы о существовании и "
"расположении альтернативного стека сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:80
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr ""
"При установке обработчика сигналов с помощью B<sigaction>(2) (флагом "
"B<SA_ONSTACK>) сообщить системе, что обработчик сигналов должен выполняться "
"с альтернативным стеком сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:87
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<old_ss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks, then the other argument can be specified as NULL."
msgstr ""
"Аргумент I<ss> используется для указания нового альтернативного стека "
"сигналов, а аргумент I<old_ss> используется для получения информации об "
"установленном в данный момент стеке сигналов. Если интересует какая-то одна "
"из этих задач, то другой аргумент указывается как NULL."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:91
msgid ""
"The I<stack_t> type used to type the arguments of this function is defined "
"as follows:"
msgstr ""
"Тип I<stack_t>, используемый для аргументов этой функции, определён "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:99
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr ""
"typedef struct {\n"
"    void  *ss_sp;     /* базовый адрес стека */\n"
"    int    ss_flags;  /* флаги */\n"
"    size_t ss_size;   /* количество байт в стеке */\n"
"} stack_t;\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:104
msgid ""
"To establish a new alternate signal stack, the fields of this structure are "
"set as follows:"
msgstr ""
"Для организации нового альтернативного стека сигналов поля этой структуры "
"должны быть заполнены следующим образом:"

#. type: TP
#: man-pages/man2/sigaltstack.2:104
#, no-wrap
msgid "I<ss.ss_flags>"
msgstr "I<ss.ss_flags>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:107
msgid "This field contains either 0, or the following flag:"
msgstr "В этом поле содержится 0 или следующий флаг:"

#. type: TP
#: man-pages/man2/sigaltstack.2:108
#, no-wrap
msgid "B<SS_AUTODISARM> (since Linux 4.7)"
msgstr "B<SS_AUTODISARM> (начиная с Linux 4.7)"

#.  commit 2a74213838104a41588d86fd5e8d344972891ace
#.  See tools/testing/selftests/sigaltstack/sas.c in kernel sources
#. type: Plain text
#: man-pages/man2/sigaltstack.2:115
msgid ""
"Clear the alternate signal stack settings on entry to the signal handler.  "
"When the signal handler returns, the previous alternate signal stack "
"settings are restored."
msgstr ""
"Очистить настройки альтернативного стека сигналов в записи обработчика "
"сигналов. Когда происходит возврат из обработчика сигналов, "
"восстанавливаются предыдущие настройки альтернативного стека сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:126
msgid ""
"This flag was added in order make it safe to switch away from the signal "
"handler with B<swapcontext>(3).  Without this flag, a subsequently handled "
"signal will corrupt the state of the switched-away signal handler.  On "
"kernels where this flag is not supported, B<sigaltstack>()  fails with the "
"error B<EINVAL> when this flag is supplied."
msgstr ""
"Этот флаг был добавлен для безопасного переключения из обработчика сигналов "
"с помощью B<swapcontext>(3). Без этого флага следующий обрабатываемый сигнал "
"повредит состояние обработчика сигналов, в который выполняется переключение "
"(switched-away). В ядрах без поддержки этого флага вызов B<sigaltstack>() "
"завершается ошибкой B<EINVAL>, если этот флаг указан."

#. type: TP
#: man-pages/man2/sigaltstack.2:127
#, no-wrap
msgid "I<ss.ss_sp>"
msgstr "I<ss.ss_sp>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:133
msgid ""
"This field specifies the starting address of the stack.  When a signal "
"handler is invoked on the alternate stack, the kernel automatically aligns "
"the address given in I<ss.ss_sp> to a suitable address boundary for the "
"underlying hardware architecture."
msgstr ""
"Это поле задаёт начальный адрес стека. При вызове обработчика сигнала с "
"альтернативным стеком ядро автоматически выравнивает адрес, указанный в I<ss."
"ss_sp>, по границе адреса, подходящей для используемой аппаратной платформы."

#. type: TP
#: man-pages/man2/sigaltstack.2:133
#, no-wrap
msgid "I<ss.ss_size>"
msgstr "I<ss.ss_size>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:140
msgid ""
"This field specifies the size of the stack.  The constant B<SIGSTKSZ> is "
"defined to be large enough to cover the usual size requirements for an "
"alternate signal stack, and the constant B<MINSIGSTKSZ> defines the minimum "
"size required to execute a signal handler."
msgstr ""
"В этом поле задаётся размер стека. Для определения альтернативного стека "
"сигналов достаточного размера можно использовать константу B<SIGSTKSZ>, а "
"для выделения стека минимального размера можно указать константу "
"B<MINSIGSTKSZ>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:147
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the kernel ignores any other flags in I<ss.ss_flags> and the "
"remaining fields in I<ss>."
msgstr ""
"Для отключения существующего стека, укажите в I<ss.ss_flags> значение "
"B<SS_DISABLE>. В этом случае ядро игнорирует все флаги в I<ss.ss_flags> и "
"остальные поля в I<ss>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:155
msgid ""
"If I<old_ss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<old_ss.ss_sp> and I<old_ss.ss_size> fields return "
"the starting address and size of that stack.  The I<old_ss.ss_flags> may "
"return either of the following values:"
msgstr ""
"Если I<old_ss> не равно NULL, то в нём возвращается информация об "
"альтернативном стеке сигналов, который использовался до этого вызова "
"B<sigaltstack>(). В полях I<old_ss.ss_sp> и I<old_ss.ss_size> возвращаются "
"начальный адрес и размер стека. В I<old_ss.ss_flags> может быть возвращено "
"одно из следующих значений:"

#. type: TP
#: man-pages/man2/sigaltstack.2:155
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr "B<SS_ONSTACK>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:161
msgid ""
"The process is currently executing on the alternate signal stack.  (Note "
"that it is not possible to change the alternate signal stack if the process "
"is currently executing on it.)"
msgstr ""
"В данный момент альтернативный стек сигналов используется процессом "
"(заметим, что в этот момент невозможно изменить альтернативный стек "
"сигналов)."

#. type: TP
#: man-pages/man2/sigaltstack.2:161
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr "B<SS_DISABLE>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:164
msgid "The alternate signal stack is currently disabled."
msgstr "В данный момент альтернативный стек сигналов выключен."

#.  FIXME Was it intended that one can set up a different alternative
#.  signal stack in this scenario? (In passing, if one does this, the
#.  sigaltstack(NULL, &old_ss) now returns old_ss.ss_flags==SS_AUTODISARM
#.  rather than old_ss.ss_flags==SS_DISABLE. The API design here seems
#.  confusing...
#. type: Plain text
#: man-pages/man2/sigaltstack.2:179
msgid ""
"Alternatively, this value is returned if the process is currently executing "
"on an alternate signal stack that was established using the B<SS_AUTODISARM> "
"flag.  In this case, it is safe to switch away from the signal handler with "
"B<swapcontext>(3).  It is also possible to set up a different alternative "
"signal stack using a further call to B<sigaltstack>()."
msgstr ""
"Также это значение возвращается, если процесс уже выполняется с "
"альтернативным стеком сигналов, установленным с помощью флага "
"B<SS_AUTODISARM>. В этом случае с помощью B<swapcontext>(3) можно безопасно "
"переключаться в другой обработчик сигналов. Также возможно установить другой "
"альтернативный стек сигналов с помощью последующего вызова B<sigaltstack>()."

#. type: TP
#: man-pages/man2/sigaltstack.2:179
#, no-wrap
msgid "B<SS_AUTODISARM>"
msgstr "B<SS_AUTODISARM>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:183
msgid ""
"The alternate signal stack has been marked to be autodisarmed as described "
"above."
msgstr ""
"Альтернативный стек сигналов был помечен к автоматической очистке "
"(autodisarmed), как описывалось ранее."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:190
msgid ""
"By specifying I<ss> as NULL, and I<old_ss> as a non-NULL value, one can "
"obtain the current settings for the alternate signal stack without changing "
"them."
msgstr ""
"Если присвоить I<ss> значение NULL,а I<old_ss> — не NULL, то можно получить "
"текущие настройки альтернативного стека сигналов без его изменения."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:194
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr ""
"При успешном выполнении B<sigaltstack>() возвращается 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:199
msgid ""
"Either I<ss> or I<old_ss> is not NULL and points to an area outside of the "
"process's address space."
msgstr ""
"Значение I<ss> или I<old_ss> не равно NULL и указывает за пределы адресного "
"пространства процесса."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:203
msgid "I<ss> is not NULL and the I<ss_flags> field contains an invalid flag."
msgstr ""
"Значение I<ss> не равно NULL и в поле I<ss_flags> содержится некорректный "
"флаг."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:209
msgid ""
"The specified size of the new alternate signal stack I<ss.ss_size> was less "
"than B<MINSIGSTKSZ>."
msgstr ""
"Указанный размер нового альтернативного стека сигналов I<ss.ss_size> меньше "
"B<MINSIGSTKSZ>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:214
msgid ""
"An attempt was made to change the alternate signal stack while it was active "
"(i.e., the process was already executing on the current alternate signal "
"stack)."
msgstr ""
"Была попытка изменить альтернативный стек сигналов при его активности (т. е. "
"текущий альтернативный стек сигналов уже задействован при выполнении "
"процесса)."

#. type: SH
#: man-pages/man2/sigaltstack.2:214
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:217
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man2/sigaltstack.2:221
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man2/sigaltstack.2:221
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man2/sigaltstack.2:221
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man2/sigaltstack.2:224
#, no-wrap
msgid "B<sigaltstack>()"
msgstr "B<sigaltstack>()"

#. type: tbl table
#: man-pages/man2/sigaltstack.2:224
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man2/sigaltstack.2:224
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:228
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SUSv2, SVr4."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:232
msgid "The B<SS_AUTODISARM> flag is a Linux extension."
msgstr "Флаг B<SS_AUTODISARM> является расширением Linux."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:240
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the normal "
"process stack is exhausted: in this case, a signal handler for B<SIGSEGV> "
"cannot be invoked on the process stack; if we wish to handle it, we must use "
"an alternate signal stack."
msgstr ""
"В основном, альтернативный стек сигналов используется при обработке сигнала "
"B<SIGSEGV>, который возникает при нехватке свободного места в обычном стеке "
"процесса: в этом случае обработчик сигнала B<SIGSEGV> не может использовать "
"стек процесса; если требуется обработка данного сигнала, нужно использовать "
"альтернативный стек сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:250
msgid ""
"Establishing an alternate signal stack is useful if a process expects that "
"it may exhaust its standard stack.  This may occur, for example, because the "
"stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>.  "
"If the standard stack is exhausted, the kernel sends the process a "
"B<SIGSEGV> signal.  In these circumstances the only way to catch this signal "
"is on an alternate signal stack."
msgstr ""
"Назначение альтернативного стека сигналов полезно, если ожидается, что "
"процесс может задействовать весь свой обычный стек. Это может случиться, "
"например, когда стек становится настолько большим, что он встречается с "
"растущей в вверх «кучей», или достигает ограничения, заданного вызовом "
"B<setrlimit(RLIMIT_STACK, &rlim)>. Если стандартный стек закончился, то ядро "
"посылает процессу сигнал B<SIGSEGV>. В этих условиях единственным способом "
"поймать сигнал будет задействование альтернативного стека сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:256
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr ""
"На большинстве аппаратных архитектур, поддерживаемых Linux, стеки растут "
"сверху вниз. Вызов B<sigaltstack>() автоматически учтёт направление роста "
"стека."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:265
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the process is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr ""
"Функции, вызываемые из обработчика сигналов исполняемого с использованием "
"альтернативного стека сигналов, также будут использовать альтернативный стек "
"сигналов (это также применимо к любым обработчикам, вызванным по другим "
"сигналам в то время как процесс выполняется с альтернативным стеком "
"сигналов). В отличие от стандартного стека система автоматически не "
"расширяет альтернативный стек сигналов. Превышение выделенного размера "
"альтернативного стека сигналов приведёт к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:273
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings."
msgstr ""
"При успешном выполнении вызова B<execve>(2) любой существующий "
"альтернативный стек сигналов удаляется. Дочерний процесс, созданный с "
"помощью B<fork>(2), наследует копию настроек альтернативного стека сигналов "
"своего родителя."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:282
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr ""
"Вызов B<sigaltstack>() заменяет устаревший вызов B<sigstack>(). Для обратной "
"совместимости в glibc также есть функция B<sigstack>(). Во всех новых "
"приложениях нужно использовать B<sigaltstack>()."

#. type: SS
#: man-pages/man2/sigaltstack.2:282
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:289
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr ""
"Системный вызов B<sigstack>() появился в 4.2BSD. В нём использовалась слегка "
"другая структура, и его главным недостатком было то, что вызывающий должен "
"был учитывать направления роста стека."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:298
msgid ""
"The following code segment demonstrates the use of B<sigaltstack>()  (and "
"B<sigaction>(2))  to install an alternate signal stack that is employed by a "
"handler for the B<SIGSEGV> signal:"
msgstr ""
"В следующем сегменте кода показано использование B<sigaltstack>() (и "
"B<sigaction>(2)) для установки альтернативного стека сигналов, который "
"используется обработчиком для сигнала B<SIGSEGV>:"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:302
#, no-wrap
msgid "stack_t ss;\n"
msgstr "stack_t ss;\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:308
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL) {\n"
"    perror(\"malloc\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL) {\n"
"    perror(\"malloc\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:315
#, no-wrap
msgid ""
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1) {\n"
"    perror(\"sigaltstack\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1) {\n"
"    perror(\"sigaltstack\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:323
#, no-wrap
msgid ""
"sa.sa_flags = SA_ONSTACK;\n"
"sa.sa_handler = handler();      /* Address of a signal handler */\n"
"sigemptyset(&sa.sa_mask);\n"
"if (sigaction(SIGSEGV, &sa, NULL) == -1) {\n"
"    perror(\"sigaction\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"sa.sa_flags = SA_ONSTACK;\n"
"sa.sa_handler = handler();      /* адрес обработчика сигналов */\n"
"sigemptyset(&sa.sa_mask);\n"
"if (sigaction(SIGSEGV, &sa, NULL) == -1) {\n"
"    perror(\"sigaction\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#.  Linux 2.3.40
#.  After quite a bit of web and mail archive searching,
#.  I could not find the patch on any mailing list, and I
#.  could find no place where the rationale for this change
#.  explained -- mtk
#.  See the source code of Illumos and FreeBSD, for example.
#. type: Plain text
#: man-pages/man2/sigaltstack.2:363
msgid ""
"In Linux 2.2 and earlier, the only flag that could be specified in I<ss."
"sa_flags> was B<SS_DISABLE>.  In the lead up to the release of the Linux 2.4 "
"kernel, a change was made to allow B<sigaltstack>()  to allow I<ss."
"ss_flags==SS_ONSTACK> with the same meaning as I<ss.ss_flags==0> (i.e., the "
"inclusion of B<SS_ONSTACK> in I<ss.ss_flags> is a no-op).  On other "
"implementations, and according to POSIX.1, B<SS_ONSTACK> appears only as a "
"reported flag in I<old_ss.ss_flags>.  On Linux, there is no need ever to "
"specify B<SS_ONSTACK> in I<ss.ss_flags>, and indeed doing so should be "
"avoided on portability grounds: various other systems give an error if "
"B<SS_ONSTACK> is specified in I<ss.ss_flags>."
msgstr ""
"В Linux 2.2 и старее в I<ss.sa_flags> можно указывать только флаг "
"B<SS_DISABLE>. В версиях до ядра Linux 2.4 разрешалось B<sigaltstack>() "
"допускать I<ss.ss_flags==SS_ONSTACK> с тем же смыслом как I<ss.ss_flags==0> "
"(т. е., при включении B<SS_ONSTACK> в I<ss.ss_flags> ни к чему не "
"приводило). В других реализациях и согласно POSIX.1 флаг B<SS_ONSTACK> "
"появляется в I<old_ss.ss_flags> только как флаг результата. В Linux его не "
"нужно даже указывать в I<ss.ss_flags>, иначе это снизит переносимость, так "
"как некоторые системы выдают ошибку, если в I<ss.ss_flags> указан "
"B<SS_ONSTACK>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:369
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/sysfs.2:27
#, no-wrap
msgid "SYSFS"
msgstr "SYSFS"

#. type: Plain text
#: man-pages/man2/sysfs.2:30
msgid "sysfs - get filesystem type information"
msgstr "sysfs - получает информацию о типах файловых систем"

#. type: Plain text
#: man-pages/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"

#. type: Plain text
#: man-pages/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"
msgstr ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr "B<int sysfs(int >I<option>B<);>"

#. type: Plain text
#: man-pages/man2/sysfs.2:44
msgid ""
"B<Note>: if you are looking for information about the B<sysfs> filesystem "
"that is normally mounted at I</sys>, see B<sysfs>(5)."
msgstr ""
"B<Замечание>: информация о файловой системе B<sysfs>, обычно монтируемой в "
"I</sys>, приведена в B<sysfs>(5)."

#. type: Plain text
#: man-pages/man2/sysfs.2:54
msgid ""
"The (obsolete)  B<sysfs>()  system call returns information about the "
"filesystem types currently present in the kernel.  The specific form of the "
"B<sysfs>()  call and the information returned depends on the I<option> in "
"effect:"
msgstr ""
"Системный вызов (устаревший) B<sysfs>() возвращает информацию о типах "
"файловой системы, которые имеются в ядре. Форма вызова B<sysfs>() и "
"возвращаемая информация зависят от параметра I<option> согласно следующей "
"таблице:"

#. type: Plain text
#: man-pages/man2/sysfs.2:59
msgid ""
"Translate the filesystem identifier string I<fsname> into a filesystem type "
"index."
msgstr ""
"Преобразовать строку с идентификатором типа файловой системы I<fsname> в "
"индекс типа файловой системы."

#. type: Plain text
#: man-pages/man2/sysfs.2:70
msgid ""
"Translate the filesystem type index I<fs_index> into a null-terminated "
"filesystem identifier string.  This string will be written to the buffer "
"pointed to by I<buf>.  Make sure that I<buf> has enough space to accept the "
"string."
msgstr ""
"Преобразовать индекс типа файловой системы I<fs_index> в строку "
"(оканчивающуюся null) с идентификатором типа файловой системы. Эта строка "
"будет записана в буфер I<buf>. Убедитесь в том, что в I<buf> есть достаточно "
"места для размещения этой строки."

#. type: Plain text
#: man-pages/man2/sysfs.2:74
msgid ""
"Return the total number of filesystem types currently present in the kernel."
msgstr ""
"Получить количество типов файловой системы, находящихся в настоящий момент в "
"ядре."

#. type: Plain text
#: man-pages/man2/sysfs.2:76
msgid "The numbering of the filesystem type indexes begins with zero."
msgstr "Нумерация индексов типов файловой системы начинается с нуля."

#. type: Plain text
#: man-pages/man2/sysfs.2:88
msgid ""
"On success, B<sysfs>()  returns the filesystem index for option B<1>, zero "
"for option B<2>, and the number of currently configured filesystems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<sysfs>() возвращает индекс типа файловой системы "
"при значении option равном B<1>, ноль, если значение option равно B<2> и "
"количество существующих в данный момент типов файловых систем в ядре при "
"option, равном B<3>. При ошибке возвращается -1, а переменная I<errno> "
"устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/sysfs.2:93
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr ""
"I<fsname> или I<buf> указывают на адрес за пределами адресного пространства "
"процесса."

#. type: Plain text
#: man-pages/man2/sysfs.2:101
msgid ""
"I<fsname> is not a valid filesystem type identifier; I<fs_index> is out-of-"
"bounds; I<option> is invalid."
msgstr ""
"I<fsname> не является правильным идентификатором типа файловой системы; "
"превышены пределы I<fs_index>; неправильный параметр I<option>."

#. type: Plain text
#: man-pages/man2/sysfs.2:110
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via I</proc/"
"filesystems>; use that interface instead."
msgstr ""
"Данный вызов, унаследованный от System-V, устарел; не используйте его. В "
"системах с I</proc> такую же информацию можно получить из I</proc/"
"filesystems>; используйте данную возможность вместо этого вызова."

#. type: Plain text
#: man-pages/man2/sysfs.2:112
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr ""
"Нет поддержки в libc и glibc. Нет способа определить необходимый размер "
"буфера I<buf>."

#. type: TH
#: man-pages/man2/s390_guarded_storage.2:25
#, no-wrap
msgid "S390_GUARDED_STORAGE"
msgstr "S390_GUARDED_STORAGE"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:28
msgid ""
"s390_guarded_storage - operations with z/Architecture guarded storage "
"facility"
msgstr ""
"s390_guarded_storage - операции со средством защищённого хранения z/"
"Architecture"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:31
#, no-wrap
msgid "B<#include E<lt>asm/guarded_storage.hE<gt>>\n"
msgstr "B<#include E<lt>asm/guarded_storage.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:33
#, no-wrap
msgid "B<int s390_guarded_storage(int >I<command>B<, struct gs_cb *>I<gs_cb>B<);>\n"
msgstr "B<int s390_guarded_storage(int >I<command>B<, struct gs_cb *>I<gs_cb>B<);>\n"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:39
msgid ""
"The B<s390_guarded_storage>()  system call enables the use of the Guarded "
"Storage Facility (a z/Architecture-specific feature) for user-space "
"processes."
msgstr ""
"Системный вызов B<s390_guarded_storage>() задействует средство защищённого "
"хранения (Guarded Storage Facility, свойство z/Architecture) для процессов "
"пользовательского пространства."

#.  The description is based on
#.  http://www-05.ibm.com/de/linux-on-z-ws-us/agenda/pdfs/8_-_Linux_Whats_New_-_Stefan_Raspl.pdf
#.  and "z/Architecture Principles of Operation" obtained from
#.  http://publibfi.boulder.ibm.com/epubs/pdf/dz9zr011.pdf
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:50
msgid ""
"The guarded storage facility is a hardware feature that allows marking up to "
"64 memory regions (as of z14) as guarded; reading a pointer with a newly "
"introduced \"Load Guarded\" (LGG)  or \"Load Logical and Shift Guarded"
"\" (LLGFSG) instructions will cause a range check on the loaded value and "
"invoke a (previously set up)  user-space handler if one of the guarded "
"regions is affected."
msgstr ""
"Средство защищённого хранения — это аппаратное свойство, позволяющее "
"пометить до 64 областей памяти (в z14) для защиты; при чтении указателя "
"новыми инструкциями «Load Guarded» (LGG) или «Load Logical and Shift "
"Guarded» (LLGFSG) будет проверяться диапазон согласно загружаемому значению "
"и вызываться (установленный ранее) обработчик пользовательского "
"пространства, если затронута одна из защищённых областей."

#.  The command description is copied from v4.12-rc1~139^2~56^2 commit message
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:56
msgid ""
"The I<command> argument indicates which function to perform.  The following "
"commands are supported:"
msgstr ""
"В аргументе I<command> задаётся выполняемая функция. Поддерживаются "
"следующие команды:"

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:56
#, no-wrap
msgid "B<GS_ENABLE>"
msgstr "B<GS_ENABLE>"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:68
msgid ""
"Enable the guarded storage facility for the calling task.  The initial "
"content of the guarded storage control block will be all zeros.  After "
"enablement, user-space code can use the \"Load Guarded Storage Controls"
"\" (LGSC) instruction (or the B<load_gs_cb>()  function wrapper provided in "
"the I<asm/guarded_storage.h> header) to load an arbitrary control block.  "
"While a task is enabled, the kernel will save and restore the calling "
"content of the guarded storage registers on context switch."
msgstr ""
"Включает средство защищённого хранения для вызывающей задачи. Первоначально, "
"содержимое блока управления защищённым хранением будет заполнено нулями. "
"После включения из кода пользовательского пространства можно вызвать "
"инструкцию «Load Guarded Storage Controls» (LGSC) (или обёрточную функцию "
"B<load_gs_cb>(), предоставляемую заголовочным файлом I<asm/guarded_storage."
"h>) для загрузки произвольного блока управления. Пока задача включена, ядро "
"будет сохранять и восстанавливать вызывающее содержимое регистров "
"защищённого хранения при переключении контекста."

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:68
#, no-wrap
msgid "B<GS_DISABLE>"
msgstr "B<GS_DISABLE>"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:73
msgid ""
"Disables the use of the guarded storage facility for the calling task.  The "
"kernel will cease to save and restore the content of the guarded storage "
"registers, the task-specific content of these registers is lost."
msgstr ""
"Выключает средство защищённого хранения для вызывающей задачи. Ядро "
"перестанет сохранять и восстанавливать содержимое регистров защищённого "
"хранения,  содержимое регистров этой задачи будет утрачено."

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:73
#, no-wrap
msgid "B<GS_SET_BC_CB>"
msgstr "B<GS_SET_BC_CB>"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:82
msgid ""
"Set a broadcast guarded storage control block to the one provided in the "
"I<gs_cb> argument.  This is called per thread and associates a specific "
"guarded storage control block with the calling task.  This control block "
"will be used in the broadcast command B<GS_BROADCAST>."
msgstr ""
"Устанавливает широковещательный блок управления защищённым хранением равным "
"из предоставленного в аргументе I<gs_cb>. Вызывается для нити и связывает "
"заданный широковещательный блок управления защищённым хранением с вызывающей "
"задачей. Данный блок управления будет использован в команде широковещания "
"B<GS_BROADCAST>."

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:82
#, no-wrap
msgid "B<GS_CLEAR_BC_CB>"
msgstr "B<GS_CLEAR_BC_CB>"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:89
msgid ""
"Clears the broadcast guarded storage control block.  The guarded storage "
"control block will no longer have the association established by the "
"B<GS_SET_BC_CB> command."
msgstr ""
"Стирает широковещательный блок управления защищённым хранением. Блок "
"управления защищённым хранением больше не имеет связи, установленной с "
"помощью команды B<GS_SET_BC_CB>."

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:89
#, no-wrap
msgid "B<GS_BROADCAST>"
msgstr "B<GS_BROADCAST>"

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:98
msgid ""
"Sends a broadcast to all thread siblings of the calling task.  Every sibling "
"that has established a broadcast guarded storage control block will load "
"this control block and will be enabled for guarded storage.  The broadcast "
"guarded storage control block is consumed; a second broadcast without a "
"refresh of the stored control block with B<GS_SET_BC_CB> will not have any "
"effect."
msgstr ""
"Посылает широковещание всем нитям, родственным вызывающей задаче. Каждый "
"родственник с установленным широковещательным блоком управления защищённым "
"хранением загрузит этот блок управления и включит защищённое хранение. "
"Широковещательный блок управления защищённым хранением уничтожается; второе "
"широковещание без обновления хранимого блока управления с помощью "
"B<GS_SET_BC_CB> ни сработает."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:105
msgid ""
"The I<gs_cb> argument specifies the address of a guarded storage control "
"block structure and is currently used only by the B<GS_SET_BC_CB> command; "
"all other aforementioned commands ignore this argument."
msgstr ""
"В аргументе I<gs_cb> указывается адрес структуры блока управления защищённым "
"хранением и пока используется только в команде B<GS_SET_BC_CB>; все "
"остальные упомянутые команды игнорируют этот аргумент."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:109
msgid "On success, the return value of B<s390_guarded_storage>()  is 0."
msgstr ""
"При успешном выполнении B<s390_guarded_storage>() возвращает значение 0."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:122
msgid ""
"I<command> was B<GS_SET_BC_CB> and the copying of the guarded storage "
"control block structure pointed by the I<gs_cb> argument has failed."
msgstr ""
"Значение I<command> равно B<GS_SET_BC_CB> и копирование структуры блока "
"управления защищённым хранением, указанное в аргументе I<gs_cb> завершилось "
"ошибкой."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:127
msgid "The value provided in the I<command> argument was not valid."
msgstr "Значение аргумента I<command> некорректно."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:133
msgid ""
"I<command> was one of B<GS_ENABLE> or B<GS_SET_BC_CB>, and the allocation of "
"a new guarded storage control block has failed."
msgstr ""
"Значение I<command> равно B<GS_ENABLE> или B<GS_SET_BC_CB> и выделение места "
"под новый блока управления защищённым хранением завершилось ошибкой."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:136
msgid "The guarded storage facility is not supported by the hardware."
msgstr "Средство защищённого хранения не поддерживается оборудованием."

#.  916cda1aa1b412d7cf2991c3af7479544942d121, v4.12-rc1~139^2~56^2
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:139
msgid "This system call is available since Linux 4.12."
msgstr "Данный системный вызов появился в Linux 4.12."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:143
msgid "The guarded storage facility is available beginning with System z14."
msgstr "Средство защищённого хранения доступно начиная с System z14."

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:153
msgid ""
"The description of the guarded storage facility along with related "
"instructions and Guarded Storage Control Block and Guarded Storage Event "
"Parameter List structure layouts is available in \"z/Architecture Principles "
"of Operations\" beginning from the twelfth edition."
msgstr ""
"Описание средства защищённого хранения вместе с инструкциями, блоком "
"управления защищённым хранением, структурой списка событий защищённого "
"хранения доступно в «z/Architecture Principles of Operations» начиная с 12-"
"го выпуска."

#.  .PP
#.  For the example of using the guarded storage facility, see
#.  .UR https://developer.ibm.com/javasdk/2017/09/25/concurrent-scavenge-using-guarded-storage-facility-works/
#.  the article with the description of its usage in the Java Garbage Collection
#.  .UE
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:173
msgid ""
"The I<gs_cb> structure has a field I<gsepla> (Guarded Storage Event "
"Parameter List Address), which is a user-space pointer to a Guarded Storage "
"Event Parameter List structure (that contains the address of the "
"aforementioned event handler in the I<gseha> field), and its layout is "
"available as a B<gs_epl> structure type definition in the I<asm/"
"guarded_storage.h> header."
msgstr ""
"В структуре I<gs_cb> есть поле I<gsepla> (Guarded Storage Event Parameter "
"List Address), которое является указателем пользовательского пространства на "
"структуру Guarded Storage Event Parameter List (содержащей адрес "
"вышеупомянутого обработчика событий в поле I<gseha>), а её описание доступно "
"как определение структурного типа B<gs_epl> в заголовочном файле I<asm/"
"guarded_storage.h>."

#. type: TH
#: man-pages/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr "SPLICE"

#. type: Plain text
#: man-pages/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr "splice - подключает данные к каналу/выбирает данные из канала"

#.  Return type was long before glibc 2.7
#. type: Plain text
#: man-pages/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the file descriptors must refer to a pipe."
msgstr ""
"Вызов B<splice>() перемещает данные между двумя файловыми дескрипторами не "
"выполняя при этом копирование между адресным пространством пользователя и "
"ядра. Он пересылает до I<len> байт данных из файлового дескриптора I<fd_in> "
"в файловый дескриптор I<fd_out>, где один из файловых дескрипторов должен "
"ссылаться на канал."

#. type: Plain text
#: man-pages/man2/splice.2:55
msgid "The following semantics apply for I<fd_in> and I<off_in>:"
msgstr "К I<fd_in> и I<off_in> применяются следующие правила:"

#. type: Plain text
#: man-pages/man2/splice.2:61
msgid "If I<fd_in> refers to a pipe, then I<off_in> must be NULL."
msgstr ""
"Если I<fd_in> указывает на канал, то значение I<off_in> должно быть NULL."

#. type: Plain text
#: man-pages/man2/splice.2:70
msgid ""
"If I<fd_in> does not refer to a pipe and I<off_in> is NULL, then bytes are "
"read from I<fd_in> starting from the file offset, and the file offset is "
"adjusted appropriately."
msgstr ""
"Если I<fd_in> не указывает на канал и I<off_in> равно NULL, то из I<fd_in> "
"читаются байты начиная с смещения файла и это смещение соответственно "
"изменяется."

#. type: Plain text
#: man-pages/man2/splice.2:83
msgid ""
"If I<fd_in> does not refer to a pipe and I<off_in> is not NULL, then "
"I<off_in> must point to a buffer which specifies the starting offset from "
"which bytes will be read from I<fd_in>; in this case, the file offset of "
"I<fd_in> is not changed."
msgstr ""
"Если I<fd_in> не указывает на канал и I<off_in> не равно NULL, то I<off_in> "
"должен указывать на буфер, в котором задаётся начальное смещение для чтения "
"байтов из I<fd_in>; в этом случае файловое смещение I<fd_in> не изменяется."

#. type: Plain text
#: man-pages/man2/splice.2:88
msgid "Analogous statements apply for I<fd_out> and I<off_out>."
msgstr "Аналогичные правила относятся и к I<fd_out> и I<off_out>."

#. type: Plain text
#: man-pages/man2/splice.2:93
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""
"Аргумент I<flags> представляет собой битовую маску, которая составляется "
"логическим сложением (OR) следующих значений:"

#. type: TP
#: man-pages/man2/splice.2:93
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr "B<SPLICE_F_MOVE>"

#. type: Plain text
#: man-pages/man2/splice.2:106
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""
"Пытаться переместить страницы, а не копировать их. Используется только как "
"подсказка ядру: страницы всё равно будут копироваться, если ядро не сможет "
"переместить страницы из канала, или если буферы канала не ссылаются на "
"полные страницы. Первая реализация этого флага была с дефектами: поэтому "
"начиная с Linux 2.6.21 этот флаг ни на что не влияет (но по прежнему "
"разрешён в вызове B<splice>()); в будущем, возможно появится корректная "
"реализация."

#. type: TP
#: man-pages/man2/splice.2:106
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr "B<SPLICE_F_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/splice.2:115
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""
"Не блокировать при вводе-выводе. Это делает операции соединения с каналом "
"неблокируемыми, но B<splice>(), тем не менее, может заблокироваться, так как "
"файловые дескрипторы, с которыми ведётся работа, могут блокироваться (если у "
"них не установлен флаг B<O_NONBLOCK>)."

#. type: TP
#: man-pages/man2/splice.2:115
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr "B<SPLICE_F_MORE>"

#. type: Plain text
#: man-pages/man2/splice.2:129
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))."
msgstr ""
"В следующем подключении будут дополнительные данные. Полезно указывать, "
"когда I<fd_out> ссылается на сокет (смотрите также описание B<MSG_MORE> в "
"B<send>(2) и описание B<TCP_CORK> в B<tcp>(7))."

#. type: TP
#: man-pages/man2/splice.2:129
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr "B<SPLICE_F_GIFT>"

#. type: Plain text
#: man-pages/man2/splice.2:135
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr "Не используется в B<splice>(); смотрите B<vmsplice>(2)."

#. type: Plain text
#: man-pages/man2/splice.2:140
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe."
msgstr ""
"При успешном выполнении B<splice>() возвращает количество байт, которые были "
"записаны или получены из канала."

#. type: Plain text
#: man-pages/man2/splice.2:147
msgid ""
"A return value of 0 means end of input.  If I<fd_in> refers to a pipe, then "
"this means that there was no data to transfer, and it would not make sense "
"to block because there are no writers connected to the write end of the pipe."
msgstr ""
"Возвращаемое значение 0 означает конец ввода. Если I<fd_in> указывает на "
"канал, то это означает, что нет данных для передачи и и блокировка не имела "
"бы смысла, так как нет писателей, подключённых к пишущему концу канала."

#. type: Plain text
#: man-pages/man2/splice.2:153
msgid ""
"On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""
"В случае ошибки B<splice>() возвращает -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/splice.2:162
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags> or one of the file "
"descriptors had been marked as nonblocking (B<O_NONBLOCK>)B<,> and the "
"operation would block."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:166
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""
"Один или оба файловых дескриптора недействительны или в неправильном режиме "
"чтения-записи."

#. type: Plain text
#: man-pages/man2/splice.2:169
msgid "The target filesystem doesn't support splicing."
msgstr ""
"Целевая файловая система не поддерживает подключение данных (splicing)."

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: man-pages/man2/splice.2:174
msgid "The target file is opened in append mode."
msgstr "Файл назначения открыт в режиме добавления."

#. type: Plain text
#: man-pages/man2/splice.2:177
msgid "Neither of the file descriptors refers to a pipe."
msgstr "Ни один из файловых дескрипторов не ссылается на канал."

#. type: Plain text
#: man-pages/man2/splice.2:180
msgid "An offset was given for nonseekable device (e.g., a pipe)."
msgstr ""
"Указано смещение для устройства этого не поддерживающего (например, канала)."

#. type: Plain text
#: man-pages/man2/splice.2:186
msgid "I<fd_in> and I<fd_out> refer to the same pipe."
msgstr "Значение I<fd_in> и I<fd_out> указывают на один и тот же канал."

#. type: Plain text
#: man-pages/man2/splice.2:196
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""
"Значение I<off_in> или I<off_out> не равно NULL, но соответствующий файловый "
"дескриптор ссылается на канал."

#. type: Plain text
#: man-pages/man2/splice.2:201
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""
"Системный вызов B<splice>() впервые появился в Linux 2.6.17; поддержка в "
"glibc добавлена в версии 2.5."

#. type: Plain text
#: man-pages/man2/splice.2:213
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"user-space programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""
"Три системных вызова — B<splice>(), B<vmsplice>(2), and B<tee>(2), "
"предоставляют пользовательским программам полный контроль над произвольным "
"буфером ядра; они реализованы в ядре на базе того же типа буферов, который "
"используется для канала. Эти системные вызовы выполняют следующие задачи:"

#. type: TP
#: man-pages/man2/splice.2:213
#, no-wrap
msgid "B<splice>()"
msgstr "B<splice>()"

#. type: Plain text
#: man-pages/man2/splice.2:217
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr ""
"перемещает данные из буфера в произвольный файловый дескриптор или наоборот, "
"и из одного буфера в другой."

#. type: Plain text
#: man-pages/man2/splice.2:220
msgid "\"copies\" the data from one buffer to another."
msgstr "«копирует» данные из одного буфера в другой."

#. type: Plain text
#: man-pages/man2/splice.2:223
msgid "\"copies\" data from user space into the buffer."
msgstr "«копирует» данные из пользовательского пространства в буфер."

#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: man-pages/man2/splice.2:254
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""
"Хотя мы говорим о копировании, на самом деле копирования, обычно, не "
"происходит. Ядро реализует канальный буфер как набор указателей со счётчиком "
"ссылок на страницы памяти ядра. Ядро создаёт «копии» страниц в буфере "
"посредством создания новых указателей (для выходного буфера), указывающих на "
"страницы, и увеличивает счётчики ссылок страниц: копируются только "
"указатели, а не страницы буфера."

#.  commit 7c77f0b3f9208c339a4b40737bb2cb0f0319bb8d
#. type: Plain text
#: man-pages/man2/splice.2:264
msgid ""
"In Linux 2.6.30 and earlier, exactly one of I<fd_in> and I<fd_out> was "
"required to be a pipe.  Since Linux 2.6.31, both arguments may refer to "
"pipes."
msgstr ""
"В Linux 2.6.30 и старее, только один из I<fd_in> и I<fd_out> должен быть "
"каналом. Начиная с Linux 2.6.31 оба параметра должны быть каналами."

#. type: Plain text
#: man-pages/man2/splice.2:267
msgid "See B<tee>(2)."
msgstr "См. B<tee>(2)."

#. type: Plain text
#: man-pages/man2/splice.2:272
msgid ""
"B<copy_file_range>(2), B<sendfile>(2), B<tee>(2), B<vmsplice>(2), B<pipe>(7)"
msgstr ""
"B<copy_file_range>(2), B<sendfile>(2), B<tee>(2), B<vmsplice>(2), B<pipe>(7)"

#. type: TH
#: man-pages/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr "SPU_RUN"

#. type: Plain text
#: man-pages/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr "spu_run - выполняет контекст SPU"

#. type: Plain text
#: man-pages/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr "B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:35
#, no-wrap
msgid "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"
msgstr "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the "
"Cell Broadband Engine Architecture in order to access Synergistic Processor "
"Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr ""
"Системный вызов B<spu_run>() используется на машинах PowerPC с архитектурой "
"Cell Broadband Engine для получения доступа к Synergistic Processor Unit "
"(SPU). Аргумент I<fd> представляет собой файловый дескриптор, возвращаемый "
"вызовом B<spu_create>(2) и указывающий на определённый контекст SPU. Когда "
"контекст планируется на физическом SPU, он запускается на выполнение начиная "
"с инструкции, на которую указывает значение I<npc>."

#. type: Plain text
#: man-pages/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new "
"thread of execution must be created first (e.g., using B<pthread_create>(3))."
msgstr ""
"Выполнение кода SPU происходит синхронно, то есть B<spu_run>() блокируется "
"на время работы SPU. Если требуется параллельное выполнение кода SPU и кода "
"на основном процессоре или других SPU, то сначала нужно создать новую нить "
"выполнения (например с помощью B<pthread_create>(3))."

#. type: Plain text
#: man-pages/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr ""
"При завершении работы B<spu_run>() текущее значение программного счётчика "
"SPU записывается в I<npc>, что позволяет использовать тот же указатель "
"I<npc> в последующих вызовах B<spu_run>()."

#. type: Plain text
#: man-pages/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the "
"SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr ""
"В аргументе I<event> указывается буфер для расширенного кода состояния. Если "
"контекст SPU создан с флагом B<SPU_CREATE_EVENTS_ENABLED>, то ядро Linux "
"заполняет этот буфер перед возвратом из B<spu_run>()."

#. type: Plain text
#: man-pages/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr ""
"Код состояния может быть одной (или несколькими) из следующих констант:"

#. type: TP
#: man-pages/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr "B<SPE_EVENT_DMA_ALIGNMENT>"

#. type: Plain text
#: man-pages/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr "Произошла ошибка выравнивания DMA."

#. type: TP
#: man-pages/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr "B<SPE_EVENT_INVALID_DMA>"

#. type: Plain text
#: man-pages/man2/spu_run.2:90
msgid "An invalid MFC DMA command was attempted."
msgstr "Попытка выполнить неверную команду MFC DMA."

#. type: TP
#: man-pages/man2/spu_run.2:90
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr "B<SPE_EVENT_SPE_DATA_STORAGE>"

#. type: Plain text
#: man-pages/man2/spu_run.2:93
msgid "A DMA storage error occurred."
msgstr "Произошла ошибка хранилища DMA."

#. type: TP
#: man-pages/man2/spu_run.2:93
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr "B<SPE_EVENT_SPE_ERROR>"

#. type: Plain text
#: man-pages/man2/spu_run.2:96
msgid "An illegal instruction was executed."
msgstr "Выполнена недопустимая инструкция."

#. type: Plain text
#: man-pages/man2/spu_run.2:102
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr ""
"Для аргумента I<event> допускается значение NULL. В этом случае информация о "
"событиях не будет поступать в вызывающий процесс."

#. type: Plain text
#: man-pages/man2/spu_run.2:111
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error, it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr ""
"При успешном выполнении B<spu_run>() возвращается значение регистра "
"I<spu_status>. При ошибке возвращается -1, а в I<errno> содержится один из "
"кодов ошибки, описанных далее."

#. type: Plain text
#: man-pages/man2/spu_run.2:120
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on "
"the SPU.  The bit masks for the status codes are:"
msgstr ""
"Значение регистра I<spu_status> представляет собой битовую маску кодов "
"состояния и необязательный 14-битный код, возвращаемый при выполнении "
"инструкции B<stop-and-signal> SPU. Битовые маски кодов состояний:"

#. type: TP
#: man-pages/man2/spu_run.2:120
#, no-wrap
msgid "B<0x02>"
msgstr "B<0x02>"

#. type: Plain text
#: man-pages/man2/spu_run.2:125
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr "SPU остановлен инструкцией B<stop-and-signal>."

#. type: TP
#: man-pages/man2/spu_run.2:125
#, no-wrap
msgid "B<0x04>"
msgstr "B<0x04>"

#. type: Plain text
#: man-pages/man2/spu_run.2:130
msgid "SPU was stopped by a B<halt> instruction."
msgstr "SPU остановлен инструкцией B<halt>."

#. type: TP
#: man-pages/man2/spu_run.2:130
#, no-wrap
msgid "B<0x08>"
msgstr "B<0x08>"

#. type: Plain text
#: man-pages/man2/spu_run.2:133
msgid "SPU is waiting for a channel."
msgstr "SPU ожидает канала."

#. type: TP
#: man-pages/man2/spu_run.2:133
#, no-wrap
msgid "B<0x10>"
msgstr "B<0x10>"

#. type: Plain text
#: man-pages/man2/spu_run.2:136
msgid "SPU is in single-step mode."
msgstr "SPU в пошаговом режиме."

#. type: TP
#: man-pages/man2/spu_run.2:136
#, no-wrap
msgid "B<0x20>"
msgstr "B<0x20>"

#. type: Plain text
#: man-pages/man2/spu_run.2:139
msgid "SPU has tried to execute an invalid instruction."
msgstr "SPU пытался выполнить неверную инструкцию."

#. type: TP
#: man-pages/man2/spu_run.2:139
#, no-wrap
msgid "B<0x40>"
msgstr "B<0x40>"

#. type: Plain text
#: man-pages/man2/spu_run.2:142
msgid "SPU has tried to access an invalid channel."
msgstr "SPU пытался получить доступ к неверному каналу."

#. type: TP
#: man-pages/man2/spu_run.2:142
#, no-wrap
msgid "B<0x3fff0000>"
msgstr "B<0x3fff0000>"

#. type: Plain text
#: man-pages/man2/spu_run.2:148
msgid ""
"The bits masked with this value contain the code returned from a B<stop-and-"
"signal> instruction.  These bits are valid only if the 0x02 bit is set."
msgstr ""
"При наложении этой маски получается код, возвращаемый инструкцией B<stop-and-"
"signal>. Полученные биты корректны только, если установлен бит 0x02."

#. type: Plain text
#: man-pages/man2/spu_run.2:153
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower "
"eight ones are always set."
msgstr ""
"Если B<spu_run>() не вернул ошибку, то один или более младших восьми битов "
"всегда установлены."

#. type: Plain text
#: man-pages/man2/spu_run.2:164
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr ""
"Задан неправильный указатель в I<npc> или значение I<event> не равно NULL и "
"является неправильным указателем."

#. type: Plain text
#: man-pages/man2/spu_run.2:174
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr ""
"При выполнении B<spu_run>() получен сигнал; см. B<signal>(7). При "
"необходимости, значение I<npc> обновляется до нового значения программного "
"счётчика."

#. type: Plain text
#: man-pages/man2/spu_run.2:179
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr ""
"Значение I<fd> не является правильным файловым дескриптором, возвращённым "
"B<spu_create>(2)."

#. type: Plain text
#: man-pages/man2/spu_run.2:183
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr ""
"Недостаточно памяти для обработки страничного сбоя в результате прямого "
"доступа Memory Flow Controller (MFC)."

#. type: Plain text
#: man-pages/man2/spu_run.2:192
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr "Системный вызов B<spu_run>() был добавлен в ядро Linux версии 2.6.16."

#. type: Plain text
#: man-pages/man2/spu_run.2:196
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""
"Данный вызов существует только в Linux и реализован только для архитектуры "
"PowerPC. Программы, использующие данный вызов, не переносимы."

#. type: Plain text
#: man-pages/man2/spu_run.2:207
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR http://www.bsc.es\\:/projects\\:/"
"deepcomputing\\:/linuxoncell/> E<.UE> for the recommended libraries."
msgstr ""
"В glibc нет обёртки для этого системного вызова; запускайте его с помощью "
"B<syscall>(2). Однако заметим, что B<spu_run>() предназначен для работы в "
"библиотеках, которые реализуют более абстрактный интерфейс к SPU и не должен "
"вызываться из обычных приложений. Рекомендуемые библиотеки приведены на "
"странице E<.UR http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/"
"> E<.UE .>"

#. type: Plain text
#: man-pages/man2/spu_run.2:212
msgid ""
"The following is an example of running a simple, one-instruction SPU program "
"with the B<spu_run>()  system call."
msgstr ""
"В следующем примере реализована простая программа, состоящая из одной "
"инструкции SPU и системного вызова B<spu_run>()."

#. type: Plain text
#: man-pages/man2/spu_run.2:220
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:223
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:228
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:232
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:237
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr ""
"    /* записать инструкцию \\(aqstop 0x1234\\(aq в локальное хранилище\n"
"       памяти SPU\n"
"     */\n"
"    instruction = 0x00001234;\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:242
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:248
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr ""
"    /* присвоить npc адрес начальной инструкции программы\n"
"     * SPU. Так как мы записали инструкцию в начало\n"
"     * файла mem, точка входа будет равна 0x0\n"
"     */\n"
"    npc = 0;\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:252
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:258
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: 0x%08x\\en\", spu_status);\n"
msgstr ""
"    /* мы должны получить код состояния 0x1234002:\n"
"     *   0x00000002 (spu остановлен из-за stop-and-signal)\n"
"     * | 0x12340000 (код stop-and-signal)\n"
"     */\n"
"    printf(\"Состояние SPU: 0x%08x\\en\", spu_status);\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:268
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: man-pages/man2/signalfd.2:20
#, no-wrap
msgid "SIGNALFD"
msgstr "SIGNALFD"

#. type: Plain text
#: man-pages/man2/signalfd.2:23
msgid "signalfd - create a file descriptor for accepting signals"
msgstr "signalfd - создаёт файловый дескриптор для приёма сигналов"

#. type: Plain text
#: man-pages/man2/signalfd.2:25
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr "B<#include E<lt>sys/signalfd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/signalfd.2:27
msgid ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/signalfd.2:38
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal "
"handler or B<sigwaitinfo>(2), and has the advantage that the file descriptor "
"may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr ""
"Вызов B<signalfd>() создаёт файловый дескриптор, который можно использовать "
"для приёма сигналов, предназначенных вызывающему. Его можно использовать как "
"замену обработчику сигналов или B<sigwaitinfo>(2); преимущество в том, что "
"за файловым дескриптором можно следить с помощью B<select>(2), B<poll>(2) и "
"B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/signalfd.2:58
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr ""
"В аргументе I<mask> указывается набор сигналов, который вызывающий хочет "
"принимать через файловый дескриптор. Этот аргумент, содержащий набор "
"сигналов, можно инициализировать с помощью макросов, описанных в "
"B<sigsetops>(3). Обычно, набор сигналов, принимаемых через файловый "
"дескриптор, должен блокироваться с помощью B<sigprocmask>(2), чтобы "
"предотвратить обработку сигналов назначенными им обработчиками по умолчанию. "
"Через файловый дескриптор signalfd нельзя получить сигнал B<SIGKILL> или "
"B<SIGSTOP>; при указании их в I<mask> они просто игнорируются."

#. type: Plain text
#: man-pages/man2/signalfd.2:72
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and "
"associates the signal set specified in I<mask> with that file descriptor.  "
"If I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that file descriptor."
msgstr ""
"Если значение аргумента I<fd> равно -1, то вызов создаёт новый файловый "
"дескриптор и связывает с ним набор сигналов, указанный в I<mask>. Если I<fd> "
"не равно -1, то в нём должен быть указан допустимый существующий файловый "
"дескриптор signalfd, а значение I<mask> используется для замены набора "
"сигналов, связанного с этим файловым дескриптором."

#. type: Plain text
#: man-pages/man2/signalfd.2:77
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<signalfd>():"
msgstr ""
"Начиная с Linux 2.6.27, для изменения поведения B<signalfd>() можно "
"использовать следующие значения I<flags> (через OR):"

#. type: TP
#: man-pages/man2/signalfd.2:77
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr "B<SFD_NONBLOCK>"

#. type: TP
#: man-pages/man2/signalfd.2:87
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr "B<SFD_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/signalfd.2:101
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""
"До версии Linux 2.6.26 аргумент I<flags> не использовался, и должен быть "
"равен нулю."

#. type: Plain text
#: man-pages/man2/signalfd.2:104
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr ""
"Вызов B<signalfd>() возвращает файловый дескриптор, который поддерживает "
"следующие операции:"

#. type: Plain text
#: man-pages/man2/signalfd.2:123
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least "
"I<sizeof(struct signalfd_siginfo)> bytes.  The return value of the "
"B<read>(2)  is the total number of bytes read."
msgstr ""
"Если один или несколько сигналов, указанных в I<mask>, ожидают обработки, то "
"буфер, указанный в B<read>(2), используется для возврата одной или "
"нескольких структур I<signalfd_siginfo> (см. ниже), описывающих сигналы. "
"Вызов B<read>(2) возвращает информацию о всех ожидающих сигналах, которые "
"поместились в предоставленный буфер. Размер буфера должен быть не менее "
"I<sizeof(struct signalfd_siginfo)> байт. Возвращаемое B<read>(2) значение "
"представляет собой общее количество прочитанных байт."

#. type: Plain text
#: man-pages/man2/signalfd.2:131
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr ""
"После выполнения B<read>(2) сигналы считаются учтёнными, они больше не "
"считаются ожидающими обработки (т.е., они не будут переданы обработчикам "
"сигналов и не могут быть приняты с помощью B<sigwaitinfo>(2))."

#. type: Plain text
#: man-pages/man2/signalfd.2:142
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr ""
"Если ни один из сигналов из I<mask> не ожидает обработки, то вызов "
"B<read>(2) или блокируется до поступления сигналов согласно I<mask>, или "
"завершается с ошибкой B<EAGAIN>, если файловый дескриптор помечен как "
"неблокируемый."

#. type: TP
#: man-pages/man2/signalfd.2:142
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr "B<poll>(2), B<select>(2) (и подобные)"

#. type: Plain text
#: man-pages/man2/signalfd.2:155
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr ""
"Файловый дескриптор доступен для чтения (в B<select>(2) аргумент I<readfds>; "
"в B<poll>(2) флаг B<POLLIN>), если один или более сигналов из I<mask> "
"ожидают обработки."

#. type: Plain text
#: man-pages/man2/signalfd.2:162
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""
"Файловый дескриптор signalfd также поддерживает другие мультиплексные "
"вызовы: B<pselect>(2), B<ppoll>(2) и B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/signalfd.2:167
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"Если файловый дескриптор больше не требуется, его нужно закрыть. Когда все "
"файловые дескрипторы, связанные с одним объектом signalfd, будут закрыты, "
"ядро освобождает ресурсы объекта."

#. type: SS
#: man-pages/man2/signalfd.2:167
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr "Структура signalfd_siginfo"

#. type: Plain text
#: man-pages/man2/signalfd.2:173
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr ""
"Формат структур(ы) I<signalfd_siginfo>, возвращаемых B<read>(2) из файлового "
"дескриптора signalfd, имеет следующий вид:"

#.  ssi_trapno is unused on most arches
#.  ssi_addr_lsb: commit b8aeec34175fc8fe8b0d40efea4846dfc1ba663e
#. type: Plain text
#: man-pages/man2/signalfd.2:202
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;    /* Signal number */\n"
"    int32_t  ssi_errno;    /* Error number (unused) */\n"
"    int32_t  ssi_code;     /* Signal code */\n"
"    uint32_t ssi_pid;      /* PID of sender */\n"
"    uint32_t ssi_uid;      /* Real UID of sender */\n"
"    int32_t  ssi_fd;       /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;     /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun;  /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;   /* Trap number that caused signal */\n"
"    int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;      /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;      /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;    /* System CPU time consumed\n"
"                              (SIGCHLD) */\n"
"    uint64_t ssi_addr;     /* Address that generated signal\n"
"                              (for hardware-generated signals) */\n"
"    uint16_t ssi_addr_lsb; /* Least significant bit of address\n"
"                              (SIGBUS; since Linux 2.6.37)\n"
"    uint8_t  pad[I<X>];       /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;    /* номер сигнала */\n"
"    int32_t  ssi_errno;    /* номер ошибки (не используется) */\n"
"    int32_t  ssi_code;     /* код сигнала */\n"
"    uint32_t ssi_pid;      /* PID отправителя */\n"
"    uint32_t ssi_uid;      /* реальный UID отправителя */\n"
"    int32_t  ssi_fd;       /* файловый дескриптор (SIGIO) */\n"
"    uint32_t ssi_tid;      /* ID таймера ядра (таймеры POSIX)\n"
"    uint32_t ssi_band;     /* внутреннее событие (SIGIO) */\n"
"    uint32_t ssi_overrun;  /* счётчик переполнений таймера POSIX */\n"
"    uint32_t ssi_trapno;   /* номер ловушки, поймавшей сигнал */\n"
"    int32_t  ssi_status;   /* код выхода или сигнала (SIGCHLD) */\n"
"    int32_t  ssi_int;      /* целое, посланное sigqueue(3) */\n"
"    uint64_t ssi_ptr;      /* указатель, посланный sigqueue(3) */\n"
"    uint64_t ssi_utime;    /* пользовательское потреблённое\n"
"                              время ЦП (SIGCHLD) */\n"
"    uint64_t ssi_stime;    /* системное потреблённое\n"
"                              время ЦП (SIGCHLD) */\n"
"    uint64_t ssi_addr;     /* сгенерированный сигналом адрес\n"
"                              (для сигналов от аппаратуры) */\n"
"    uint16_t ssi_addr_lsb; /* наименее значимый бит адреса\n"
"                              (SIGBUS; начиная с Linux 2.6.37)\n"
"    uint8_t  pad[I<X>];       /* заполнитель до 128 байт (для\n"
"                              будущих дополнительных полей) */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:225
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code> "
"field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr ""
"Каждое из полей в этой структуре аналогично полям с тем же именем в "
"структуре I<siginfo_t>. Структура I<siginfo_t> описана в B<sigaction>(2). Не "
"все поля в возвращаемой структуре I<signalfd_siginfo> будут заполнены "
"правильно для каждого сигнала; набор допустимых полей можно определить по "
"значению, возвращённому в поле I<ssi_code>. Это поле является аналогом поля "
"I<si_code> в I<siginfo_t>; подробней смотрите в B<sigaction>(2)."

#. type: SS
#: man-pages/man2/signalfd.2:225
#, no-wrap
msgid "fork(2) semantics"
msgstr "Поведение при fork(2)"

#. type: Plain text
#: man-pages/man2/signalfd.2:233
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return "
"information about signals queued to the child."
msgstr ""
"После вызова B<fork>(2) потомок наследует копию файлового дескриптора "
"signalfd. Вызов B<read>(2) для файлового дескриптора в потомке вернёт "
"информацию о сигналах для потомка."

#. type: SS
#: man-pages/man2/signalfd.2:233
#, no-wrap
msgid "Semantics of file descriptor passing"
msgstr "Семантика передачи файлового дескриптора"

#. type: Plain text
#: man-pages/man2/signalfd.2:242
msgid ""
"As with other file descriptors, signalfd file descriptors can be passed to "
"another process via a UNIX domain socket (see B<unix>(7)).  In the receiving "
"process, a B<read>(2)  from the received file descriptor will return "
"information about signals queued to that process."
msgstr ""
"Как и другие файловые дескрипторы, файловые дескрипторы signalfd можно "
"передавать в другой процесс через доменный сокет UNIX (смотрите B<unix>(7)). "
"В принимающем процессе вызов B<read>(2) из принятого файлового дескриптора "
"возвратит информацию о сигналах в очереди этого процесса."

#. type: SS
#: man-pages/man2/signalfd.2:242
#, no-wrap
msgid "execve(2) semantics"
msgstr "Поведение при execve(2)"

#. type: Plain text
#: man-pages/man2/signalfd.2:254
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open "
"across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr ""
"Как и любой файловый дескриптор, файловый дескриптор signalfd остаётся "
"открытым после B<execve>(2), если он не помечен как close-on-exec (см. "
"B<fcntl>(2)). Все сигналы, которые были доступны для чтения перед "
"B<execve>(2), остаются доступными и для новой загруженной программы "
"(аналогично обычному поведению сигналов, когда блокированный сигнал, "
"ожидающий обработки, остаётся в очереди ожидания после B<execve>(2))."

#. type: SS
#: man-pages/man2/signalfd.2:254
#, no-wrap
msgid "Thread semantics"
msgstr "Поведение в нитях"

#. type: Plain text
#: man-pages/man2/signalfd.2:264
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror "
"the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e., "
"the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr ""
"Поведение файловых дескрипторов signalfd в многонитевых программах отражает "
"стандартное поведение сигналов. Иначе говоря, когда нить выполняет чтение из "
"файлового дескриптора signalfd, она прочтёт сигналы, которые предназначены "
"самой нити и сигналы, предназначенные процессу (т.е., всей группе нитей). "
"Нить не может прочитать сигналы, которые предназначены другим нитям процесса."

#. type: Plain text
#: man-pages/man2/signalfd.2:278
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"При успешном выполнении B<signalfd>() возвращает файловый дескриптор "
"signalfd; это будет или новый файловый дескриптор (если I<fd> равно -1), или "
"I<fd>, если I<fd> содержит допустимый файловый дескриптор signalfd. При "
"ошибке возвращается -1, а I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/signalfd.2:284
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr "Неправильный файловый дескриптор в I<fd>."

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: man-pages/man2/signalfd.2:292
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором signalfd."

#. type: Plain text
#: man-pages/man2/signalfd.2:299
msgid ""
"I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr ""
"Неправильное значение I<flags> или, для Linux 2.6.26 и старее, I<flags> не "
"равно 0."

#. type: Plain text
#: man-pages/man2/signalfd.2:309
msgid "Could not mount (internal) anonymous inode device."
msgstr "Не удалось смонтировать (внутреннее) безымянное устройство inode."

#. type: Plain text
#: man-pages/man2/signalfd.2:312
msgid "There was insufficient memory to create a new signalfd file descriptor."
msgstr ""
"Недостаточно памяти для создания нового файлового дескриптора signalfd."

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/signalfd.2:320
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr ""
"Вызов B<signalfd>() доступен в Linux, начиная с ядра 2.6.22. Поддержка в "
"glibc появилась в версии 2.8. Системный вызов B<signalfd4>() (см. ЗАМЕЧАНИЯ) "
"доступен в Linux, начиная с ядра 2.6.27."

#. type: Plain text
#: man-pages/man2/signalfd.2:325
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr "Вызовы B<signalfd>() и B<signalfd4>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/signalfd.2:339
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), "
"B<poll>(2), or B<epoll>(7): the arrival of different signals will make "
"different file descriptors ready.)  If a signal appears in the I<mask> of "
"more than one of the file descriptors, then occurrences of that signal can "
"be read (once) from any one of the file descriptors."
msgstr ""
"Процесс может создать несколько файловых дескрипторов signalfd. Это "
"позволяет принимать различные сигналы через различные файловые дескрипторы "
"(может быть полезно при слежении за файловым дескриптором с помощью "
"B<select>(2), B<poll>(2) или B<epoll>(7): прибытие различных сигналов делает "
"готовым различные файловые дескрипторы). Если сигнал указан в I<mask> для "
"нескольких файловых дескрипторов, то появление этого сигнала можно прочесть "
"(однократно) из любого файлового дескриптора."

#. type: Plain text
#: man-pages/man2/signalfd.2:347
msgid ""
"Attempts to include B<SIGKILL> and B<SIGSTOP> in I<mask> are silently "
"ignored."
msgstr ""
"Попытки включить B<SIGKILL> и B<SIGSTOP> в маску I<mask> просто игнорируются."

#. type: Plain text
#: man-pages/man2/signalfd.2:356
msgid ""
"The signal mask employed by a signalfd file descriptor can be viewed via the "
"entry for the corresponding file descriptor in the process's I</proc/[pid]/"
"fdinfo> directory.  See B<proc>(5)  for further details."
msgstr ""
"Маску сигналов, используемую файловым дескриптором signalfd, можно "
"посмотреть в записи соответствующего файлового дескриптора в каталоге "
"процесса I</proc/[pid]/fdinfo>. Подробности смотрите в B<proc>(5)."

#. type: SS
#: man-pages/man2/signalfd.2:356
#, no-wrap
msgid "Limitations"
msgstr "Ограничения"

#. type: Plain text
#: man-pages/man2/signalfd.2:365
msgid ""
"The signalfd mechanism can't be used to receive signals that are "
"synchronously generated, such as the B<SIGSEGV> signal that results from "
"accessing an invalid memory address or the B<SIGFPE> signal that results "
"from an arithmetic error.  Such signals can be caught only via signal "
"handler."
msgstr ""
"Механизм signalfd нельзя использовать для приёма сигналов, генерируемых "
"синхронно, например сигнала B<SIGSEGV> при доступе по неправильному адресу "
"памяти, или сигнала B<SIGFPE> при математических ошибках. Такие сигналы "
"можно поймать только через обработчик сигнала."

#. type: Plain text
#: man-pages/man2/signalfd.2:386
msgid ""
"As described above, in normal usage one blocks the signals that will be "
"accepted via B<signalfd>().  If spawning a child process to execute a helper "
"program (that does not need the signalfd file descriptor), then, after the "
"call to B<fork>(2), you will normally want to unblock those signals before "
"calling B<execve>(2), so that the helper program can see any signals that it "
"expects to see.  Be aware, however, that this won't be possible in the case "
"of a helper program spawned behind the scenes by any library function that "
"the program may call.  In such cases, one must fall back to using a "
"traditional signal handler that writes to a file descriptor monitored by "
"B<select>(2), B<poll>(2), or B<epoll>(7),"
msgstr ""
"Как сказано выше, обычно все сигналы, принимаемые через B<signalfd>(), "
"блокируются. Если порождается дочерний процесс для выполнения "
"вспомогательной программы (которой не нужен файловый дескриптор signalfd), "
"то после вызова B<fork>(2), обычно, нужно разблокировать эти сигналы перед "
"вызовом B<execve>(2) для того, чтобы вспомогательная программа видела все "
"сигналы, которые она ожидает увидеть. Однако имейте в виду, что это может "
"быть невозможно, если вспомогательная программа порождается не вами, а где-"
"то в библиотечной функции, которую может вызывать программа. В таких случаях "
"нужно использовать обычный обработчик сигналов, который пишет в файловый "
"дескриптор, отслеживаемый B<select>(2), B<poll>(2) или B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/signalfd.2:396
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr ""
"Лежащий в основе системный вызов Linux требует дополнительного аргумента, "
"I<size_t sizemask>, в котором указывается размер аргумента I<mask>. В "
"обёрточной функции glibc B<signalfd>() нет этого аргумента — требуемое для "
"системного вызова значение добавляется библиотекой."

#. type: Plain text
#: man-pages/man2/signalfd.2:412
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr ""
"Существуют два системных вызова Linux: B<signalfd>() и более новый "
"B<signalfd4>(). В первом системном вызове не реализован аргумент I<flags>. "
"Во втором системном вызове реализованы значения I<flags>, описанные ранее. "
"Начиная с glibc 2.9, обёрточная функция B<signalfd>() использует "
"B<signalfd4>(), если он доступен."

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: man-pages/man2/signalfd.2:420
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr ""
"В ядрах до версии 3.6.25, поля I<ssi_ptr> и I<ssi_int> не заполнялись "
"данными, поступающими при посылке сигнала с помощью B<sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/signalfd.2:430
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr ""
"Программа, представленная далее, принимает сигналы B<SIGINT> и B<SIGQUIT> "
"через файловый дескриптор signalfd. Она завершает работу при приёме сигнала "
"B<SIGQUIT>. Вот сеанс работы в оболочке, демонстрирующий использование "
"программы:"

#. type: Plain text
#: man-pages/man2/signalfd.2:441
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<^C>\n"
"Got SIGINT\n"
"B<^\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C генерирует SIGINT\n"
"Получен SIGINT\n"
"B<^C>\n"
"Получен SIGINT\n"
"B<^\\e>                    # Control-\\e генерирует SIGQUIT\n"
"Получен SIGQUIT\n"
"$\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:451
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:462
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:466
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:469
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr ""
"    /* Заблокировать сигналы для того, чтобы они не обрабатывались\n"
"       их обработчиками по умолчанию */\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:472
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:476
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:481
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"
msgstr ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:492
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Получен SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Получен SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Прочитан неожидаемый сигнал\\en\");\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:505
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"

#. type: TH
#: man-pages/man2/sigreturn.2:30
#, no-wrap
msgid "SIGRETURN"
msgstr "SIGRETURN"

#. type: Plain text
#: man-pages/man2/sigreturn.2:33
msgid ""
"sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame"
msgstr ""
"sigreturn, rt_sigreturn - выполняет возврат из обработчика сигнала и очищает "
"кадр стека"

#. type: Plain text
#: man-pages/man2/sigreturn.2:35
msgid "B<int sigreturn(...);>"
msgstr "B<int sigreturn(...);>"

#.  See arch/x86/kernel/signal.c::__setup_frame() [in 3.17 source code]
#. type: Plain text
#: man-pages/man2/sigreturn.2:45
msgid ""
"If the Linux kernel determines that an unblocked signal is pending for a "
"process, then, at the next transition back to user mode in that process (e."
"g., upon return from a system call or when the process is rescheduled onto "
"the CPU), it creates a new frame on the user-space stack where it saves "
"various pieces of process context (processor status word, registers, signal "
"mask, and signal stack settings)."
msgstr ""
"Если ядро Linux обнаруживает, что неблокированный сигнал ожидает обработки "
"процессом, то при следующем переключении в пользовательский режим в этом "
"процессе (например, при возврате из системного вызова или когда процесс "
"перепланируется на ЦП), оно создаёт новый кадр в стеке пользовательского "
"пространства, где сохраняет различные части контекста процесса (состояние "
"слова процессора, регистры, маску сигналов и настройки стека сигналов)."

#. type: Plain text
#: man-pages/man2/sigreturn.2:52
msgid ""
"The kernel also arranges that, during the transition back to user mode, the "
"signal handler is called, and that, upon return from the handler, control "
"passes to a piece of user-space code commonly called the \"signal trampoline"
"\".  The signal trampoline code in turn calls B<sigreturn>()."
msgstr ""
"Также ядро делает так, что при переходе в пользовательский режим вызывается "
"обработчик сигналов и при возврате из обработчика управление передаётся "
"части кода пользовательского пространства, называемого «сигнальным "
"батутом»(signal trampoline). Код сигнального батута, в свою очередь, "
"вызывает B<sigreturn>()."

#. type: Plain text
#: man-pages/man2/sigreturn.2:67
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching signal stacks (see "
"B<sigaltstack>(2))\\(emin order to invoke the signal handler.  Using the "
"information that was earlier saved on the user-space stack B<sigreturn>()  "
"restores the process's signal mask, switches stacks, and restores the "
"process's context (processor flags and registers, including the stack "
"pointer and instruction pointer), so that the process resumes execution at "
"the point where it was interrupted by the signal."
msgstr ""
"Вызов B<sigreturn>() очищает всё что накопилось — изменяет маску сигнала "
"процесса, переключает стеки сигналов (см. B<sigaltstack>(2)) — чтобы вызвать "
"обработчик сигнала. Используя информацию, которая была ранее сохранена в "
"стеке пользовательского пространства, B<sigreturn>() восстанавливает маску "
"сигналов процесса, переключает стеки и восстанавливает контекст процесса "
"(регистры и флаги процессора, включая указатель стека и инструкций), так что "
"процесс непосредственно возобновляет исполнение с точки где был прерван "
"сигналом."

#. type: Plain text
#: man-pages/man2/sigreturn.2:70
msgid "B<sigreturn>()  never returns."
msgstr "Вызов B<sigreturn>() не возвращает значений."

#. type: Plain text
#: man-pages/man2/sigreturn.2:76
msgid ""
"Many UNIX-type systems have a B<sigreturn>()  system call or near "
"equivalent.  However, this call is not specified in POSIX, and details of "
"its behavior vary across systems."
msgstr ""
"Во многих системах UNIX есть системный вызов B<sigreturn>() или его "
"эквивалент. Однако этот вызов отсутствует в POSIX, и в разных системах он "
"работает по-разному."

#.  See sysdeps/unix/sysv/linux/sigreturn.c and
#.  signal/sigreturn.c in the glibc source
#. type: Plain text
#: man-pages/man2/sigreturn.2:98
msgid ""
"B<sigreturn>()  exists only to allow the implementation of signal handlers.  "
"It should B<never> be called directly.  (Indeed, a simple B<sigreturn>()  "
"wrapper in the GNU C library simply returns -1, with I<errno> set to "
"B<ENOSYS>.)  Details of the arguments (if any) passed to B<sigreturn>()  "
"vary depending on the architecture.  (On some architectures, such as x86-64, "
"B<sigreturn>()  takes no arguments, since all of the information that it "
"requires is available in the stack frame that was previously created by the "
"kernel on the user-space stack.)"
msgstr ""
"Вызов B<sigreturn>() существует только для реализации обработчиков сигналов. "
"B<Никогда> не вызывайте его напрямую (на самом деле, простая обёртка "
"B<sigreturn>() в библиотеке GNU C просто вернёт -1 и присвоит I<errno> "
"значение B<ENOSYS>). Содержимое аргументов (если есть), передаваемое "
"B<sigreturn>(), для каждой архитектуры своё (на некоторых архитектурах, "
"например x86-64, у B<sigreturn>() нет аргументов, так как вся требуемая "
"информация доступна из кадра стека, который был создан ядром ранее в стеке "
"пользовательского пространства)."

#.  See, for example, sysdeps/unix/sysv/linux/i386/sigaction.c and
#.  sysdeps/unix/sysv/linux/x86_64/sigaction.c in the glibc (2.20) source.
#. type: Plain text
#: man-pages/man2/sigreturn.2:123
msgid ""
"Once upon a time, UNIX systems placed the signal trampoline code onto the "
"user stack.  Nowadays, pages of the user stack are protected so as to "
"disallow code execution.  Thus, on contemporary Linux systems, depending on "
"the architecture, the signal trampoline code lives either in the B<vdso>(7)  "
"or in the C library.  In the latter case, the C library's B<sigaction>(2)  "
"wrapper function informs the kernel of the location of the trampoline code "
"by placing its address in the I<sa_restorer> field of the I<sigaction> "
"structure, and sets the B<SA_RESTORER> flag in the I<sa_flags> field."
msgstr ""
"Когда-то системы UNIX помещали код сигнального перехода в пользовательский "
"стек. В настоящее время страницы пользовательского стека защищены и в них "
"невозможно выполнить код. Поэтому в современных системах Linux, в "
"зависимости от архитектуры, код хранится в B<vdso>(7) или в библиотеке C. В "
"последнем случае обёрточная функция B<sigaction>(2) библиотеки C информирует "
"ядро о расположении кода помещая его адрес в поле I<sa_restorer> структуры "
"I<sigaction> и устанавливает флаг B<SA_RESTORER> в поле I<sa_flags>."

#. type: Plain text
#: man-pages/man2/sigreturn.2:134
msgid ""
"The saved process context information is placed in a I<ucontext_t> structure "
"(see I<E<lt>sys/ucontext.hE<gt>>).  That structure is visible within the "
"signal handler as the third argument of a handler established via "
"B<sigaction>(2)  with the B<SA_SIGINFO> flag."
msgstr ""
"Сохранённая информация контекста процесса помещается в структуру "
"I<ucontext_t> (смотрите I<E<lt>sys/ucontext.hE<gt>>). Эта структура видима "
"внутри обработчика сигнала как третий аргумент обработчика, установленного "
"B<sigaction>(2) с флагом B<SA_SIGINFO>."

#. type: Plain text
#: man-pages/man2/sigreturn.2:143
msgid ""
"On some other UNIX systems, the operation of the signal trampoline differs a "
"little.  In particular, on some systems, upon transitioning back to user "
"mode, the kernel passes control to the trampoline (rather than the signal "
"handler), and the trampoline code calls the signal handler (and then calls "
"B<sigreturn>()  once the handler returns)."
msgstr ""
"В некоторых других системах UNIX работа сигнального батута несколько "
"отличается. В частности, в некоторых системах при переходе в "
"пользовательский режим ядро передаёт управление батуту (а не обработчику "
"сигнала) и код батута вызывает обработчик сигнала (и затем вызывает "
"B<sigreturn>() после завершения работы обработчика)."

#. type: Plain text
#: man-pages/man2/sigreturn.2:157
msgid ""
"The original Linux system call was named B<sigreturn>().  However, with the "
"addition of real-time signals in Linux 2.2, a new system call, "
"B<rt_sigreturn>()  was added to support an enlarged I<sigset_t> type.  The "
"GNU C library hides these details from us, transparently employing "
"B<rt_sigreturn>()  when the kernel provides it."
msgstr ""
"Первоначальное название системного вызова в Linux было B<sigreturn>(). "
"Однако с добавлением сигналов реального времени в Linux 2.2 для поддержки "
"увеличенного типа I<sigset_t> был добавлен новый системный вызов "
"B<rt_sigreturn>(). Библиотека GNU C скрывает это от нас, прозрачно используя "
"B<rt_sigreturn>(), если он есть в ядре."

#. type: Plain text
#: man-pages/man2/sigreturn.2:164
msgid ""
"B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), "
"B<getcontext>(3), B<signal>(7), B<vdso>(7)"
msgstr ""
"B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), "
"B<getcontext>(3), B<signal>(7), B<vdso>(7)"

#. type: TH
#: man-pages/man2/sched_setattr.2:26
#, no-wrap
msgid "SCHED_SETATTR"
msgstr "SCHED_SETATTR"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:30
msgid ""
"sched_setattr, sched_getattr - set and get scheduling policy and attributes"
msgstr ""
"sched_setattr, sched_getattr - назначает и возвращает алгоритм планирования "
"и атрибуты"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:36
#, no-wrap
msgid ""
"B<int sched_setattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int sched_setattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:39
#, no-wrap
msgid ""
"B<int sched_getattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int sched_getattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"

#. type: SS
#: man-pages/man2/sched_setattr.2:42
#, no-wrap
msgid "sched_setattr()"
msgstr "sched_setattr()"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:52
msgid ""
"The B<sched_setattr>()  system call sets the scheduling policy and "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be set."
msgstr ""
"Системный вызов B<sched_setattr>() задаёт алгоритм планирования и "
"соответствующие атрибуты для нити с идентификатором I<pid>. Если I<pid> "
"равно нулю, то будет изменён алгоритм и атрибуты планирования вызывающей "
"нити."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:86
msgid "Linux also provides the following policy:"
msgstr "В Linux также предоставляются следующий алгоритм планирования:"

#. type: TP
#: man-pages/man2/sched_setattr.2:86
#, no-wrap
msgid "B<SCHED_DEADLINE>"
msgstr "B<SCHED_DEADLINE>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:91
msgid "a deadline scheduling policy; see B<sched>(7)  for details."
msgstr "алгоритм планирования с предельным сроком; смотрите B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:97
msgid ""
"The I<attr> argument is a pointer to a structure that defines the new "
"scheduling policy and attributes for the specified thread.  This structure "
"has the following form:"
msgstr ""
"Аргумент I<attr> является указателем на структуру, в которой определяется "
"новый алгоритм планирования и атрибуты, для заданной нити. Данная структура "
"имеет следующий вид:"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:113
#, no-wrap
msgid ""
"struct sched_attr {\n"
"    u32 size;              /* Size of this structure */\n"
"    u32 sched_policy;      /* Policy (SCHED_*) */\n"
"    u64 sched_flags;       /* Flags */\n"
"    s32 sched_nice;        /* Nice value (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* Static priority (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* Remaining fields are for SCHED_DEADLINE */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"
msgstr ""
"struct sched_attr {\n"
"    u32 size;              /* размер этой структуры */\n"
"    u32 sched_policy;      /* алгоритм (SCHED_*) */\n"
"    u64 sched_flags;       /* флаги */\n"
"    s32 sched_nice;        /* значение уступчивости (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* статический приоритет (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* остальные поля нужны для SCHED_DEADLINE */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"

#. type: TP
#: man-pages/man2/sched_setattr.2:117
#, no-wrap
msgid "B<size>"
msgstr "B<size>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:132
msgid ""
"This field should be set to the size of the structure in bytes, as in "
"I<sizeof(struct sched_attr)>.  If the provided structure is smaller than the "
"kernel structure, any additional fields are assumed to be '0'.  If the "
"provided structure is larger than the kernel structure, the kernel verifies "
"that all additional fields are 0; if they are not, B<sched_setattr>()  fails "
"with the error B<E2BIG> and updates I<size> to contain the size of the "
"kernel structure."
msgstr ""
"В этом поле должен быть указан размер структуры в байтах с помощью "
"I<sizeof(struct sched_attr)>. Если предоставляемая структура меньше чем "
"структура ядра, то предполагается, что дополнительные поля равны «0». Если "
"представляемая структура больше ядерной, то ядро проверяет, что все "
"дополнительные поля равны 0; если нет, то B<sched_setattr>() завершается с "
"ошибкой B<E2BIG> и заменяет значение I<size> размером структуры ядра."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:146
msgid ""
"The above behavior when the size of the user-space I<sched_attr> structure "
"does not match the size of the kernel structure allows for future "
"extensibility of the interface.  Malformed applications that pass oversize "
"structures won't break in the future if the size of the kernel I<sched_attr> "
"structure is increased.  In the future, it could also allow applications "
"that know about a larger user-space I<sched_attr> structure to determine "
"whether they are running on an older kernel that does not support the larger "
"structure."
msgstr ""
"Возможность иметь разный размер структуры I<sched_attr> пользовательского "
"пространства и структуры ядра позволит расширять интерфейс с будущем. "
"Некорректные приложения, передающие больший размер структуры, ничего не "
"сломают в будущем, если увеличится размер ядерной структуры I<sched_attr>. В "
"будущем, это также может позволить приложениям, которые знают о большей "
"структуре I<sched_attr> пользовательского пространства, определять, что они "
"работают на старом ядре, которое не поддерживает структуру большего размера."

#. type: TP
#: man-pages/man2/sched_setattr.2:146
#, no-wrap
msgid "I<sched_policy>"
msgstr "I<sched_policy>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:151
msgid ""
"This field specifies the scheduling policy, as one of the B<SCHED_*> values "
"listed above."
msgstr ""
"В этом поле задаётся алгоритм планирования в виде значений B<SCHED_*>, "
"перечисленных выше."

#. type: TP
#: man-pages/man2/sched_setattr.2:151
#, no-wrap
msgid "I<sched_flags>"
msgstr "I<sched_flags>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:155
msgid ""
"This field contains zero or more of the following flags that are ORed "
"together to control scheduling behavior:"
msgstr ""
"Это поле содержит побитовое ИЛИ нуля и более следующих флагов, для "
"управления поведением планирования:"

#. type: TP
#: man-pages/man2/sched_setattr.2:156
#, no-wrap
msgid "B<SCHED_FLAG_RESET_ON_FORK>"
msgstr "B<SCHED_FLAG_RESET_ON_FORK>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:164
msgid ""
"Children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""
"Потомки, созданные B<fork>(2), не наследуют  привилегированные алгоритмы "
"планирования. Подробней смотрите в B<sched>(7)."

#. type: TP
#: man-pages/man2/sched_setattr.2:164
#, no-wrap
msgid "B<SCHED_FLAG_RECLAIM> (since Linux 4.13)"
msgstr "B<SCHED_FLAG_RECLAIM> (начиная с Linux 4.13)"

#.  2d4283e9d583a3ee8cfb1cbb9c1270614df4c29d
#.  Bandwidth reclaim is done via the GRUB algorithm; see
#.  Documentation/scheduler/sched-deadline.txt
#. type: Plain text
#: man-pages/man2/sched_setattr.2:172
msgid ""
"This flag allows a B<SCHED_DEADLINE> thread to reclaim bandwidth unused by "
"other real-time threads."
msgstr ""
"Этот флаг позволяет нити B<SCHED_DEADLINE> отхватить полосу пропускания, "
"которая не используется другими нитями реального времени."

#. type: TP
#: man-pages/man2/sched_setattr.2:172
#, no-wrap
msgid "B<SCHED_FLAG_DL_OVERRUN> (since Linux 4.16)"
msgstr "B<SCHED_FLAG_DL_OVERRUN> (начиная с Linux 4.16)"

#.  commit 34be39305a77b8b1ec9f279163c7cdb6cc719b91
#. type: Plain text
#: man-pages/man2/sched_setattr.2:183
msgid ""
"This flag allows an application to get informed about run-time overruns in "
"B<SCHED_DEADLINE> threads.  Such overruns may be caused by (for example) "
"coarse execution time accounting or incorrect parameter assignment.  "
"Notification takes the form of a B<SIGXCPU> signal which is generated on "
"each overrun."
msgstr ""
"Этот флаг позволяет приложению получать информацию о времени переработки "
"(run-time overrun) в нитях B<SCHED_DEADLINE>. Такие переработки могут быть "
"вызваны (например) неточным учётом времени выполнения или некорректным "
"назначением параметра. Уведомление поступает в виде сигнала B<SIGXCPU>, "
"который генерируется при каждой переработке."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:198
msgid ""
"This B<SIGXCPU> signal is I<process-directed> (see B<signal>(7))  rather "
"than thread-directed.  This is probably a bug.  On the one hand, "
"B<sched_setattr>()  is being used to set a per-thread attribute.  On the "
"other hand, if the process-directed signal is delivered to a thread inside "
"the process other than the one that had a run-time overrun, the application "
"has no way of knowing which thread overran."
msgstr ""
"Сигнал B<SIGXCPU> I<направляется процессу> (смотрите B<signal>(7)), а не "
"нити. Вероятно, это дефект. С одной стороны, B<sched_setattr>() используется "
"для задания атрибутов определённой нити. С другой стороны, если сигнал, "
"направленный процессу, доставляется нити внутри процесса, у которой не было "
"переработки, то приложение не может узнать какая нить переработала."

#. type: TP
#: man-pages/man2/sched_setattr.2:199
#, no-wrap
msgid "I<sched_nice>"
msgstr "I<sched_nice>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:210
msgid ""
"This field specifies the nice value to be set when specifying "
"I<sched_policy> as B<SCHED_OTHER> or B<SCHED_BATCH>.  The nice value is a "
"number in the range -20 (high priority)  to +19 (low priority); see "
"B<sched>(7)."
msgstr ""
"В этом поле задаётся значение уступчивости, которое будет назначено при "
"указании в I<sched_policy> значения B<SCHED_OTHER> или B<SCHED_BATCH>. "
"Значение уступчивости представляет собой число в диапазоне от -20 (высший "
"приоритет) до +19 (низший приоритет); смотрите B<sched>(7)."

#. type: TP
#: man-pages/man2/sched_setattr.2:210
#, no-wrap
msgid "I<sched_priority>"
msgstr "I<sched_priority>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:223
msgid ""
"This field specifies the static priority to be set when specifying "
"I<sched_policy> as B<SCHED_FIFO> or B<SCHED_RR>.  The allowed range of "
"priorities for these policies can be determined using "
"B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2).  For other "
"policies, this field must be specified as 0."
msgstr ""
"В этом поле указывается статический приоритет, который будет установлен при "
"указании в I<sched_policy> значения B<SCHED_FIFO> или B<SCHED_RR>. "
"Допустимый диапазон приоритетов для этих алгоритмов можно определить с "
"помощью B<sched_get_priority_min>(2) и B<sched_get_priority_max>(2). Для "
"других алгоритмов значение этого поля должно быть равно 0."

#. type: TP
#: man-pages/man2/sched_setattr.2:223
#, no-wrap
msgid "I<sched_runtime>"
msgstr "I<sched_runtime>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:232
msgid ""
"This field specifies the \"Runtime\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds.  This field, and the next two fields, are "
"used only for B<SCHED_DEADLINE> scheduling; for further details, see "
"B<sched>(7)."
msgstr ""
"В этом поле задаётся параметр «Runtime» для планирования с предельным "
"сроком. Значение выражается в наносекундах. Это и два следующих поля "
"используются только при алгоритме B<SCHED_DEADLINE>; подробности смотрите в "
"B<sched>(7)."

#. type: TP
#: man-pages/man2/sched_setattr.2:232
#, no-wrap
msgid "I<sched_deadline>"
msgstr "I<sched_deadline>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:236
msgid ""
"This field specifies the \"Deadline\" parameter for deadline scheduling.  "
"The value is expressed in nanoseconds."
msgstr ""
"В этом поле задаётся параметр «Deadline» для планирования с предельным "
"сроком. Значение выражается в наносекундах."

#. type: TP
#: man-pages/man2/sched_setattr.2:236
#, no-wrap
msgid "I<sched_period>"
msgstr "I<sched_period>"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:240
msgid ""
"This field specifies the \"Period\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds."
msgstr ""
"В этом поле задаётся параметр «Period» для планирования с предельным сроком. "
"Значение выражается в наносекундах."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:247 man-pages/man2/sched_setattr.2:299
msgid ""
"The I<flags> argument is provided to allow for future extensions to the "
"interface; in the current implementation it must be specified as 0."
msgstr ""
"Аргумент I<flags> предназначен для расширения интерфейса в будущем; в "
"текущей реализации его значение должно быть равно 0."

#. type: SS
#: man-pages/man2/sched_setattr.2:247
#, no-wrap
msgid "sched_getattr()"
msgstr "sched_getattr()"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:258
msgid ""
"The B<sched_getattr>()  system call fetches the scheduling policy and the "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be retrieved."
msgstr ""
"Системный вызов B<sched_getattr>() возвращает алгоритм планирования и "
"соответствующие атрибуты для нити с идентификатором I<pid>. Если I<pid> "
"равно нулю, то будет возвращён алгоритм и атрибуты планирования вызывающей "
"нити."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:268
msgid ""
"The I<size> argument should be set to the size of the I<sched_attr> "
"structure as known to user space.  The value must be at least as large as "
"the size of the initially published I<sched_attr> structure, or the call "
"fails with the error B<EINVAL>."
msgstr ""
"В аргументе I<size> должен быть задан размер структуры I<sched_attr>, каким "
"он известен в пользовательском пространстве. Значение должно быть не менее "
"размера изначально показанной структуры I<sched_attr> или вызов завершится с "
"ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:278
msgid ""
"The retrieved scheduling attributes are placed in the fields of the "
"I<sched_attr> structure pointed to by I<attr>.  The kernel sets I<attr.size> "
"to the size of its I<sched_attr> structure."
msgstr ""
"Возвращаемые атрибуты планирования помещаются в поля структуры "
"I<sched_attr>, на которую указывает I<attr>. Ядро присваивает I<attr.size> "
"размер своей структуры I<sched_attr>."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:294
msgid ""
"If the caller-provided I<attr> buffer is larger than the kernel's "
"I<sched_attr> structure, the additional bytes in the user-space structure "
"are not touched.  If the caller-provided structure is smaller than the "
"kernel I<sched_attr> structure and the kernel needs to return values outside "
"the provided space, B<sched_getattr>()  fails with the error B<E2BIG>.  As "
"with B<sched_setattr>(), these semantics allow for future extensibility of "
"the interface."
msgstr ""
"Если буфер I<attr>, предоставленный вызывающим, больше структуры ядра "
"I<sched_attr>, то лишние байты в структуре пользовательского пространства не "
"изменяются. Если структура, предоставленная вызывающим, меньше ядерной "
"структуры I<sched_attr> и ядру необходимо вернуть значение вне "
"предоставляемого пространства, то B<sched_getattr>() завершается с ошибкой "
"B<E2BIG>. Как и для B<sched_setattr>(), такая семантика позволяет расширить "
"интерфейс в будущем."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:308
msgid ""
"On success, B<sched_setattr>()  and B<sched_getattr>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<sched_setatt>() и B<sched_getattr>() возвращается "
"0. При ошибке возвращается -1, а в I<errno> содержится причина ошибки."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:313
msgid ""
"B<sched_getattr>()  and B<sched_setattr>()  can both fail for the following "
"reasons:"
msgstr ""
"Вызовы B<sched_getattr>() и B<sched_setattr>() могут завершиться с ошибкой "
"по следующим причинам:"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:321
msgid "I<attr> is NULL; or I<pid> is negative; or I<flags> is not zero."
msgstr ""
"Значение I<attr> равно NULL; или значение I<pid> отрицательно; или значение "
"I<flags> не равно 0."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:330
msgid "In addition, B<sched_getattr>()  can fail for the following reasons:"
msgstr ""
"Также B<sched_getattr>() может завершиться с ошибкой по следующим причинам:"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:337
msgid "The buffer specified by I<size> and I<attr> is too small."
msgstr "Буфер, задаваемый I<size> и I<attr>, слишком мал."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:343
msgid ""
"I<size> is invalid; that is, it is smaller than the initial version of the "
"I<sched_attr> structure (48 bytes) or larger than the system page size."
msgstr ""
"Некорректное значение I<size>; то есть, оно меньше чем первая версия "
"структуры I<sched_attr> (48 байт) или больше размера системной страницы."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:347
msgid "In addition, B<sched_setattr>()  can fail for the following reasons:"
msgstr ""
"Также B<sched_setattr>() может завершиться с ошибкой по следующим причинам:"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:355
msgid ""
"The buffer specified by I<size> and I<attr> is larger than the kernel "
"structure, and one or more of the excess bytes is nonzero."
msgstr ""
"Буфер, заданный I<size> и I<attr>, больше структуры ядра и один или более "
"превышающих байт не равны нулю."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:360
msgid "B<SCHED_DEADLINE> admission control failure, see B<sched>(7)."
msgstr "Ошибка контроля допуска B<SCHED_DEADLINE>, смотрите B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:376
msgid ""
"I<attr.sched_policy> is not one of the recognized policies; I<attr."
"sched_flags> contains a flag other than B<SCHED_FLAG_RESET_ON_FORK>; or "
"I<attr.sched_priority> is invalid; or I<attr.sched_policy> is "
"B<SCHED_DEADLINE> and the deadline scheduling parameters in I<attr> are "
"invalid."
msgstr ""
"Значение I<attr.sched_policy> не является одним из возможных алгоритмов; в "
"I<attr.sched_flags> содержится флаг отличный от B<SCHED_FLAG_RESET_ON_FORK>; "
"некорректное значение I<attr.sched_priority>; значение I<attr.sched_policy> "
"равно B<SCHED_DEADLINE> и есть некорректные параметры алгоритм планирования "
"с предельным сроком в I<attr>."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:379
msgid "The caller does not have appropriate privileges."
msgstr "Вызывающий не имеет соответствующих прав."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:386
msgid ""
"The CPU affinity mask of the thread specified by I<pid> does not include all "
"CPUs in the system (see B<sched_setaffinity>(2))."
msgstr ""
"В процессорной маске увязывания нити, заданной в I<pid>, отсутствуют все ЦП "
"системы (смотрите B<sched_setaffinity>(2))."

#.  FIXME . Add glibc version
#. type: Plain text
#: man-pages/man2/sched_setattr.2:389
msgid "These system calls first appeared in Linux 3.14."
msgstr "Данные системные вызовы впервые появились в Linux 3.14."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:391
msgid "These system calls are nonstandard Linux extensions."
msgstr "Данные системные вызовы являются нестандартными расширениями Linux."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:407
msgid ""
"B<sched_setattr>()  provides a superset of the functionality of "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<nice>(2), and (other than "
"the ability to set the priority of all processes belonging to a specified "
"user or all processes in a specified group)  B<setpriority>(2).  "
"Analogously, B<sched_getattr>()  provides a superset of the functionality of "
"B<sched_getscheduler>(2), B<sched_getparam>(2), and (partially)  "
"B<getpriority>(2)."
msgstr ""
"Вызов B<sched_setattr>() предоставляет весь набор возможностей "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<nice>(2) и (всё кроме "
"способности задавать приоритет всем процессам, принадлежащим указанному "
"пользователю или всем процессам указанной группы) B<setpriority>(2). "
"Аналогично, B<sched_getattr>() предоставляет весь набор возможностей "
"B<sched_getscheduler>(2), B<sched_getparam>(2) и (частично) "
"B<getpriority>(2)."

#.  FIXME . patch sent to Peter Zijlstra
#.  In Linux versions up to up 3.15,
#.  FIXME . patch from Peter Zijlstra pending
#.  .BR sched_setattr ()
#.  allowed a negative
#.  .I attr.sched_policy
#.  value.
#. type: Plain text
#: man-pages/man2/sched_setattr.2:423
msgid ""
"In Linux versions up to 3.15, B<sched_settattr>()  failed with the error "
"B<EFAULT> instead of B<E2BIG> for the case described in ERRORS."
msgstr ""
"В версиях Linux до 3.15, B<sched_settattr>() завершается с ошибкой "
"B<EFAULT>, а не B<E2BIG> в случаях, которые описаны в разделе ОШИБКИ."

#. type: Plain text
#: man-pages/man2/sched_setattr.2:445
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<capabilities>(7), "
"B<cpuset>(7), B<sched>(7)"
msgstr ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<capabilities>(7), "
"B<cpuset>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/select.2:38
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: Plain text
#: man-pages/man2/select.2:54
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/select.2:65
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/select.2:87
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become \"ready"
"\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform a corresponding "
"I/O operation (e.g., B<read>(2), or a sufficiently small B<write>(2))  "
"without blocking."
msgstr ""
"Вызовы B<select>() и B<pselect>() позволяют программам отслеживать изменения "
"нескольких файловых дескрипторов ожидая, когда один или более файловых "
"дескрипторов станут «готовы» для операции ввода-вывода определённого типа "
"(например, ввода). Файловый дескриптор считается готовым, если к нему "
"возможно применить соответствующую операцию ввода-вывода (например, "
"B<read>(2) или очень маленький B<write>(2)) без блокировки."

#. type: Plain text
#: man-pages/man2/select.2:94
msgid ""
"B<select>()  can monitor only file descriptors numbers that are less than "
"B<FD_SETSIZE>; B<poll>(2)  does not have this limitation.  See BUGS."
msgstr ""
"Вызов B<select>() может следить только за номерами файловых дескрипторов, "
"которые меньше B<FD_SETSIZE>; вызов B<poll>(2) не имеет этого ограничения. "
"Смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/select.2:100
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr ""
"Работа B<select>() и B<pselect>() идентична за исключением трёх моментов:"

#. type: TP
#: man-pages/man2/select.2:100
#, no-wrap
msgid "(i)"
msgstr "(i)"

#. type: Plain text
#: man-pages/man2/select.2:110
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""
"В вызове B<select>() время ожидания задаётся в структуре I<struct timeval> "
"(с секундами и микросекундами), а в B<pselect>() используется структура "
"I<struct timespec> (с секундами и наносекундами)."

#. type: TP
#: man-pages/man2/select.2:110
#, no-wrap
msgid "(ii)"
msgstr "(ii)"

#. type: Plain text
#: man-pages/man2/select.2:118
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""
"Вызов B<select>() может обновить аргумент I<timeout>, который показывает "
"сколько времени прошло. Вызов B<pselect>() не изменяет этот аргумент."

#. type: TP
#: man-pages/man2/select.2:118
#, no-wrap
msgid "(iii)"
msgstr "(iii)"

#. type: Plain text
#: man-pages/man2/select.2:127
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""
"Вызов B<select>() не имеет аргумента I<sigmask>, и ведёт себя также как "
"B<pselect>(), если при вызове было указано значение I<sigmask> равное NULL."

#. type: Plain text
#: man-pages/man2/select.2:145
msgid ""
"Three independent sets of file descriptors are watched.  The file "
"descriptors listed in I<readfds> will be watched to see if characters become "
"available for reading (more precisely, to see if a read will not block; in "
"particular, a file descriptor is also ready on end-of-file).  The file "
"descriptors in I<writefds> will be watched to see if space is available for "
"write (though a large write may still block).  The file descriptors in "
"I<exceptfds> will be watched for exceptional conditions.  (For examples of "
"some exceptional conditions, see the discussion of B<POLLPRI> in B<poll>(2).)"
msgstr ""
"Отслеживаются 3 независимых набора файловых дескрипторов. В тех, что "
"перечислены в I<readfds>, будет отслеживаться появление символов, доступных "
"для чтения (проверяется доступность чтения без блокировки; в частности, "
"файловый дескриптор готов для чтения, если он указывает на конец файла). "
"Файловые дескрипторы, указанные в I<writefds>, будут отслеживаться для "
"возможности записи без блокировки, если доступно пространство для записи "
"(хотя при большом количестве данных для записи будет по-прежнему выполнена "
"блокировка). Файловые дескрипторы, указанные в I<exceptfds>, будут "
"отслеживаться для обнаружения исключительных условий (примеры некоторых "
"исключительных условий смотрите в описании B<POLLPRI> из B<poll>(2))."

#. type: Plain text
#: man-pages/man2/select.2:151
msgid ""
"On exit, each of the file descriptor sets is modified in place to indicate "
"which file descriptors actually changed status.  (Thus, if using "
"B<select>()  within a loop, the sets must be reinitialized before each call.)"
msgstr ""
"При возврате из вызова наборы файловых дескрипторов изменяются, показывая "
"какие файловые дескрипторы фактически изменили состояние (то есть, если "
"используется B<select>() в цикле, то наборы должны переинициализироваться "
"перед каждым вызовом)."

#. type: Plain text
#: man-pages/man2/select.2:155
msgid ""
"Each of the three file descriptor sets may be specified as NULL if no file "
"descriptors are to be watched for the corresponding class of events."
msgstr ""
"Значение каждого из трёх наборов файловых дескрипторов может быть задано как "
"NULL, если слежение за определённым классом событий над файловыми "
"дескрипторами не требуется."

#. type: Plain text
#: man-pages/man2/select.2:168
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  add and remove a given file descriptor "
"from a set.  B<FD_ISSET>()  tests to see if a file descriptor is part of the "
"set; this is useful after B<select>()  returns."
msgstr ""
"Для манипуляций наборами существуют четыре макроса: B<FD_ZERO>() очищает "
"набор;  B<FD_SET>() добавляет заданный файловый дескриптор к набору; "
"B<FD_CLR>() удаляет файловый дескриптор из набора; B<FD_ISSET>() проверяет, "
"является ли файловый дескриптор частью набора. Эти макросы полезны после "
"возврата из вызова B<select>()."

#. type: Plain text
#: man-pages/man2/select.2:174
msgid ""
"I<nfds> should be set to the highest-numbered file descriptor in any of the "
"three sets, plus 1.  The indicated file descriptors in each set are checked, "
"up to this limit (but see BUGS)."
msgstr ""
"Значение I<nfds> должно быть на единицу больше самого большого номера "
"файлового дескриптора из всех трёх наборов плюс 1. Указанные файловые "
"дескрипторы в каждом наборе проверяются до этого порога (но смотрите "
"ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/select.2:181
msgid ""
"The I<timeout> argument specifies the interval that B<select>()  should "
"block waiting for a file descriptor to become ready.  The call will block "
"until either:"
msgstr ""
"В аргументе I<timeout> указывается интервал, на который должен "
"заблокироваться B<select>() в ожидании готовности файлового дескриптора. "
"Вызов будет блокирован пока:"

#. type: Plain text
#: man-pages/man2/select.2:183
msgid "a file descriptor becomes ready;"
msgstr "файловый дескриптор не станет готов;"

#. type: Plain text
#: man-pages/man2/select.2:185
msgid "the call is interrupted by a signal handler; or"
msgstr "вызов не прервётся обработчиком сигнала;"

#. type: Plain text
#: man-pages/man2/select.2:187
msgid "the timeout expires."
msgstr "не истечёт время ожидания."

#. type: Plain text
#: man-pages/man2/select.2:204
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  If both fields of the I<timeval> structure "
"are zero, then B<select>()  returns immediately.  (This is useful for "
"polling.)  If I<timeout> is NULL (no timeout), B<select>()  can block "
"indefinitely."
msgstr ""
"Заметим, что интервал I<timeout> будет округлён с точностью системных часов, "
"а из-за задержки при планировании в ядре блокирующий интервал будет немного "
"больше. Если оба поля структуры I<timeval> равны нулю, то B<select>() "
"завершится немедленно (полезно при опросе (polling)). Если значение "
"I<timeout> равно NULL (время ожидания не задано), то B<select>() может "
"блокировать работу неопределённо долго."

#. type: Plain text
#: man-pages/man2/select.2:214
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""
"Значение I<sigmask> является указателем на маску сигналов (смотрите "
"B<sigprocmask>(2)); если оно не равно NULL, то сначала B<pselect>() заменяет "
"текущую маску сигналов на заданную I<sigmask>, затем выполняет функцию "
"«select», после чего восстанавливает первоначальную сигнальную маску."

#. type: Plain text
#: man-pages/man2/select.2:220
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr "Кроме различия в точности аргумента I<timeout> вызов B<pselect>()"

#. type: Plain text
#: man-pages/man2/select.2:225
#, no-wrap
msgid ""
"ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                timeout, &sigmask);\n"
msgstr ""
"ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                timeout, &sigmask);\n"

#. type: Plain text
#: man-pages/man2/select.2:231
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "эквивалентен I<атомарному> выполнению следующих вызовов:"

#. type: Plain text
#: man-pages/man2/select.2:235
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr "sigset_t origmask;\n"

#. type: Plain text
#: man-pages/man2/select.2:239
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: man-pages/man2/select.2:262
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""
"Причина необходимости B<pselect>() в том, что если нужно ждать какого-то "
"сигнала или готовности файлового дескриптора, то необходимо атомарное "
"тестирование для избежания состязательности. (Предположим, что обработчик "
"сигнала устанавливает глобальный флаг и завершается. В этом случае тест "
"этого глобального флага после вызова B<select>() мог бы длиться бесконечно, "
"если сигнал прибыл бы сразу после тестирования, но до вызова. В отличие от "
"этого, B<pselect>() позволяет сначала заблокировать сигналы, обработать уже "
"поступившие и затем вызвать B<pselect>() с желаемым значением I<sigmask>, "
"избегая состязательности.)"

#. type: SS
#: man-pages/man2/select.2:262
#, no-wrap
msgid "The timeout"
msgstr "Время ожидания"

#. type: Plain text
#: man-pages/man2/select.2:266
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr ""
"Используемые структуры времени определены в I<E<lt>sys/time.hE<gt>> и "
"выглядят следующим образом:"

#. type: Plain text
#: man-pages/man2/select.2:273
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long    tv_sec;         /* секунды */\n"
"    long    tv_usec;        /* микросекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/select.2:277
msgid "and"
msgstr "и"

#. type: Plain text
#: man-pages/man2/select.2:284
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* секунды */\n"
"    long    tv_nsec;        /* наносекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/select.2:288
msgid "(However, see below on the POSIX.1 versions.)"
msgstr "(Однако, смотрите ниже про версию POSIX.1.)"

#. type: Plain text
#: man-pages/man2/select.2:296
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""
"Иногда B<select>() вызывается с пустыми наборами (всеми тремя), I<nfds> "
"равным нулю и непустым I<timeout> для переносимой реализации перехода в "
"режим ожидания (sleep) на периоды с точностью менее секунды."

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: man-pages/man2/select.2:319
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1 permits either "
"behavior.)  This causes problems both when Linux code which reads I<timeout> "
"is ported to other operating systems, and when code is ported to Linux that "
"reuses a I<struct timeval> for multiple B<select>()s in a loop without "
"reinitializing it.  Consider I<timeout> to be undefined after B<select>()  "
"returns."
msgstr ""
"В Linux вызов B<select>() изменяет I<timeout> для отражения времени, "
"проведённого не в режиме ожидания; большая часть других реализаций этого не "
"делает (согласно POSIX.1 допускается любой из этих вариантов). Это вызывает "
"проблемы как при переносе кода Linux, читающего I<timeout>, на другие "
"операционные системы, так и при переносе на Linux кода, использующего "
"I<struct timeval> для многократного вызова B<select>() в цикле без его "
"переинициализации. Во избежание этого следует считать, что значение "
"I<timeout> не определено после возврата из B<select>()."

#. type: Plain text
#: man-pages/man2/select.2:337
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set to indicate the "
"error; the file descriptor sets are unmodified, and I<timeout> becomes "
"undefined."
msgstr ""
"При успешном выполнении B<select>() и B<pselect>() возвращают количество "
"файловых дескрипторов, находящихся в трёх возвращаемых наборах (то есть, "
"общее количество бит, установленных в I<readfds>, I<writefds>, "
"I<exceptfds>), при чём это количество может быть нулевым, если время "
"ожидания истекло, а интересующие события так и не произошли. При ошибке "
"возвращается значение -1, а переменной I<errno> присваивается "
"соответствующий номер ошибки; наборы файловых дескрипторов не изменяются и "
"значение I<timeout> становится неопределённым."

#. type: Plain text
#: man-pages/man2/select.2:344
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)  "
"However, see BUGS."
msgstr ""
"В одном из наборов находится неверный файловый дескриптор (возможно файловый "
"дескриптор уже закрыт, или при работе с ним произошла ошибка). Однако "
"смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/select.2:348
msgid "A signal was caught; see B<signal>(7)."
msgstr "При выполнении поступил сигнал; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/select.2:355
msgid ""
"I<nfds> is negative or exceeds the B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""
"Значение I<nfds> отрицательно или превышает ограничение ресурса "
"B<RLIMIT_NOFILE> (смотрите B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man2/select.2:360
msgid "The value contained within I<timeout> is invalid."
msgstr "Значение, содержащееся внутри I<timeout>, некорректно."

#. type: Plain text
#: man-pages/man2/select.2:363
msgid "Unable to allocate memory for internal tables."
msgstr "Не удалось выделить память для внутренних таблиц."

#. type: Plain text
#: man-pages/man2/select.2:369
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""
"Вызов B<pselect>() был добавлен в ядро Linux версии 2.6.16. До этого "
"B<pselect>() эмулировался в glibc (но, см. ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/select.2:380
msgid ""
"B<select>()  conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD "
"(B<select>()  first appeared in 4.2BSD).  Generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants).  However, note that the System\\ V variant typically sets the "
"timeout variable before exit, but the BSD variant does not."
msgstr ""
"Вызов B<select>() соответствует POSIX.1-2001, POSIX.1-2008 и 4.4BSD (впервые "
"B<select>() появился в 4.2BSD).  Обычно перенос выполняется с не-BSD систем "
"и на них, если они поддерживают уровень BSD-сокетов (включая варианты System "
"V). Однако, заметим, что вариант System V, обычно, устанавливает значение "
"переменной timeout перед выходом, а вариант BSD - нет."

#. type: Plain text
#: man-pages/man2/select.2:384
msgid ""
"B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008."
msgstr ""
"Вызов B<pselect>() определён в стандартах POSIX.1g, в POSIX 1004.1-2001 и "
"POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/select.2:401
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""
"I<fd_set> представляет собой буфер фиксированного размера. Выполнение "
"B<FD_CLR>() или B<FD_SET>() с отрицательным значением I<fd>, равным или "
"большим чем B<FD_SETSIZE>, приводит к неопределённому поведению. Более того, "
"согласно POSIX I<fd> должен быть корректным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/select.2:409
msgid ""
"The operation of B<select>()  and B<pselect>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr "На операции B<select>() и B<pselect>() флаг B<O_NONBLOCK> не влияет."

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: man-pages/man2/select.2:426
msgid ""
"On some other UNIX systems, B<select>()  can fail with the error B<EAGAIN> "
"if the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX specifies this error for B<poll>(2), but not "
"for B<select>().  Portable programs may wish to check for B<EAGAIN> and "
"loop, just as with B<EINTR>."
msgstr ""
"В некоторых системах UNIX вызов B<select>() может завершаться с ошибкой "
"B<EAGAIN>, если системе не удаётся выделить внутренние ресурсы ядра, вместо "
"ошибки B<ENOMEM>, как это происходит в Linux. В POSIX эта ошибка указана для "
"B<poll>(2), но не для B<select>(). В переносимых программах лучше ожидать "
"B<EAGAIN> в цикле, как для B<EINTR>."

#. type: Plain text
#: man-pages/man2/select.2:439
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""
"В системах без B<pselect>(), надёжного (и более переносимого) перехвата "
"сигнала можно достичь с помощью трюка с каналом в самого себя. В этом методе "
"обработчик сигнала пишет байт в канал, чей второй конец отслеживается "
"B<select>() в основной программе (чтобы избежать возможной блокировки при "
"записи в канал, который может быть заполнен, или при чтении из канала, "
"который может быть пуст, нужно использовать неблокирующий ввод/вывод)."

#. type: Plain text
#: man-pages/man2/select.2:448
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1 situation "
"is"
msgstr ""
"Что касается задействованных типов, классическим вариантом является "
"структура I<timeval> с двумя полями типа I<long> (как показано ниже), "
"которая определена в I<E<lt>sys/time.hE<gt>>. В POSIX.1:"

#. type: Plain text
#: man-pages/man2/select.2:455
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t         tv_sec;     /* секунды */\n"
"    suseconds_t    tv_usec;    /* микросекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/select.2:466
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""
"где структура определена в I<E<lt>sys/select.hE<gt>>, а типы данных "
"I<time_t> и I<suseconds_t> определены в I<E<lt>sys/types.hE<gt>>."

#. type: Plain text
#: man-pages/man2/select.2:478
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""
"Что касается прототипов, классическим вариантом является объявление "
"B<select>() в I<E<lt>time.hE<gt>>. Согласно POSIX.1 объявления B<select>() и "
"B<pselect>() должны включаться в I<E<lt>sys/select.hE<gt>>."

#. type: Plain text
#: man-pages/man2/select.2:490
msgid ""
"Under glibc 2.0, I<E<lt>sys/select.hE<gt>> gives the wrong prototype for "
"B<pselect>().  Under glibc 2.1 to 2.2.1, it gives B<pselect>()  when "
"B<_GNU_SOURCE> is defined.  Since glibc 2.2.2, the requirements are as shown "
"in the SYNOPSIS."
msgstr ""
"В I<E<lt>sys/select.hE<gt>> из glibc 2.0 указан ошибочный прототип "
"B<pselect>(). В glibc 2.1 до версии 2.2.1 B<pselect>() доступен при "
"определённом B<_GNU_SOURCE>. Требования, которые необходимы для работы с "
"glibc начиная с версии 2.2.2, показаны в разделе ОБЗОР."

#. type: SS
#: man-pages/man2/select.2:490
#, no-wrap
msgid "Correspondence between select() and poll() notifications"
msgstr "Соотношение между уведомлениями select() и poll()"

#.  fs/select.c
#. type: Plain text
#: man-pages/man2/select.2:500
msgid ""
"Within the Linux kernel source, we find the following definitions which show "
"the correspondence between the readable, writable, and exceptional condition "
"notifications of B<select>()  and the event notifications provided by "
"B<poll>(2)  (and B<epoll>(7)):"
msgstr ""
"Внутри исходного кода ядра Linux имеются определения, которые показывают "
"соотношение между уведомлениями чтения, записи и исключительного условия "
"B<select>() и уведомляющими событиями, предоставляемыми B<poll>(2) (и "
"B<epoll>(7)):"

#. type: Plain text
#: man-pages/man2/select.2:510
#, no-wrap
msgid ""
"#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |\n"
"                    POLLERR)\n"
"                   /* Ready for reading */\n"
"#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n"
"                   /* Ready for writing */\n"
"#define POLLEX_SET (POLLPRI)\n"
"                   /* Exceptional condition */\n"
msgstr ""
"#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |\n"
"                    POLLERR)\n"
"                   /* готов для чтения */\n"
"#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n"
"                   /* готов для записи */\n"
"#define POLLEX_SET (POLLPRI)\n"
"                   /* исключительное условие */\n"

#. type: SS
#: man-pages/man2/select.2:513
#, no-wrap
msgid "Multithreaded applications"
msgstr "Многонитевые приложения"

#. type: Plain text
#: man-pages/man2/select.2:530
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"process reopens file descriptor between the time B<select>()  returned and "
"the I/O operation is performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr ""
"Если файловой дескриптор, отслеживаемый B<select>(), закрывается в другой "
"нити, то результат непредсказуем. В некоторых системах UNIX B<select>() "
"разблокируется и возвращает выполнение с указанием того, что файловый "
"дескриптор готов (последующая операция ввода-вывода, вероятно, завершится с "
"ошибкой, если другой процесс не переоткроет файловый дескриптор между "
"возвратом B<select>() и выполнением операции ввода-вывода). В Linux (и "
"некоторых других системах), закрытие файлового дескриптора в другой нити не "
"влияет на B<select>(). Резюмируя, любое приложение, которое полагается на "
"определённое поведение в таком сценарии, должно считаться ошибочным."

#. type: Plain text
#: man-pages/man2/select.2:538
msgid ""
"The Linux kernel allows file descriptor sets of arbitrary size, determining "
"the length of the sets to be checked from the value of I<nfds>.  However, in "
"the glibc implementation, the I<fd_set> type is fixed in size.  See also "
"BUGS."
msgstr ""
"Ядро Linux разрешает наборы файловых дескрипторов любого размера, определяя "
"длину набора по значению I<nfds>. Однако в реализации glibc тип I<fd_set> "
"имеет фиксированный размер. Смотрите также ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/select.2:546
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the glibc wrapper function."
msgstr ""
"Интерфейс B<pselect>(), описанный в этой странице, реализован в glibc. Для "
"этого используется системный вызов B<pselect6>(). Поведение данного "
"системного вызова несколько отличается от обёрточной функции glibc."

#. type: Plain text
#: man-pages/man2/select.2:561
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""
"В Linux системный вызов B<pselect6>() изменяет содержимое своего аргумента "
"I<timeout>. Однако, обёрточная функция glibc скрывает это поведение "
"используя локальную переменную для аргумента timeout при передаче в "
"системный вызов. Таким образом, функция B<pselect>() в glibc не изменяет "
"свой аргумент I<timeout>; это поведение требуется в POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/select.2:567
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr ""
"Последний аргумент системного вызова B<pselect6>() не является указателем "
"I<sigset_t\\ *>, он представляет собой структуру в виде:"

#. type: Plain text
#: man-pages/man2/select.2:575
#, no-wrap
msgid ""
"struct {\n"
"    const kernel_sigset_t *ss;   /* Pointer to signal set */\n"
"    size_t ss_len;               /* Size (in bytes) of object\n"
"                                    pointed to by 'ss' */\n"
"};\n"
msgstr ""
"struct {\n"
"    const kernel_sigset_t *ss;   /* указатель на набор сигналов */\n"
"    size_t ss_len;               /* размер (в байтах) объекта,\n"
"                                    на который указывает «ss» */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/select.2:586
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call.  See B<sigprocmask>(2)  for a "
"discussion of the difference between the kernel and libc notion of the "
"signal set."
msgstr ""
"Это позволяет системному вызову получить указатель на набор сигналов и его "
"размер, так как в большинстве архитектур системным вызовам можно передать "
"максимум 6 аргументов. В B<sigprocmask>(2) смотрите описание различий между "
"обозначением набора сигналов в ядре и libc."

#. type: Plain text
#: man-pages/man2/select.2:602
msgid ""
"POSIX allows an implementation to define an upper limit, advertised via the "
"constant B<FD_SETSIZE>, on the range of file descriptors that can be "
"specified in a file descriptor set.  The Linux kernel imposes no fixed "
"limit, but the glibc implementation makes I<fd_set> a fixed-size type, with "
"B<FD_SETSIZE> defined as 1024, and the B<FD_*>()  macros operating according "
"to that limit.  To monitor file descriptors greater than 1023, use "
"B<poll>(2)  instead."
msgstr ""
"В POSIX разрешено в реализации определять верхнее ограничение, объявляемое "
"через константу B<FD_SETSIZE>, для диапазона файловых дескрипторов, который "
"можно задать в наборе файловых дескрипторов. Ядро Linux не имеет "
"фиксированного ограничения, но реализация glibc использует тип I<fd_set> "
"постоянного размера, определяет B<FD_SETSIZE> равным 1024, а также "
"предоставляет набор макросов операций B<FD_*>(), учитывающих это "
"ограничение. Для слежения за файловыми дескрипторами большими чем 1023 "
"используйте вызов B<poll>(2)."

#. type: Plain text
#: man-pages/man2/select.2:611
msgid ""
"The implementation of the I<fd_set> arguments as value-result arguments "
"means that they must be reinitialized on each call to B<select>().  This "
"design error is avoided by B<poll>(2), which uses separate structure fields "
"for the input and output of the call."
msgstr ""
"Реализация аргументов I<fd_set> в виде аргументов значение-результат "
"означает, что они должен инициализироваться перед каждым вызовом "
"B<select>(). Такой ошибки проектирования избежали в B<poll>(2), где "
"используется отдельные поля структуры для входных и выходных параметров "
"вызова."

#. type: Plain text
#: man-pages/man2/select.2:623
msgid ""
"According to POSIX, B<select>()  should check all specified file descriptors "
"in the three file descriptor sets, up to the limit I<nfds-1>.  However, the "
"current implementation ignores any file descriptor in these sets that is "
"greater than the maximum file descriptor number that the process currently "
"has open.  According to POSIX, any such file descriptor that is specified in "
"one of the sets should result in the error B<EBADF>."
msgstr ""
"Согласно POSIX, B<select>() должен проверять все файловые дескрипторы, "
"указанные в трёх наборах файловых дескрипторов до верхнего порога I<nfds-1>. "
"Однако текущая реализация игнорирует любой файловый дескриптор в этих "
"наборах, значение которого больше максимального номера файлового "
"дескриптора, который в настоящий момент открыт процессом. Согласно POSIX, "
"такой файловый дескриптор, указанный в любом наборе, должен приводить к "
"ошибке B<EBADF>."

#. type: Plain text
#: man-pages/man2/select.2:629
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""
"Glibc 2.0 предоставляет версию B<pselect>(), которая не принимает аргумент "
"I<sigmask>."

#. type: Plain text
#: man-pages/man2/select.2:642
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""
"Начиная с версии 2.1, glibc предоставляет эмуляцию B<pselect>(), которая "
"реализована с помощью B<sigprocmask>(2) и B<select>(). Эта реализация "
"остаётся уязвимой к той самой состязательности, для устранения которой и был "
"разработан B<pselect>(). В современных версии glibc используется "
"(бессостязательный) системный вызов B<pselect>(), если он предоставляется "
"ядром."

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: man-pages/man2/select.2:658
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""
"В Linux, вызов B<select>() может сообщать о файловом дескрипторе сокета как "
"о «готовом для чтения», хотя при последующем чтении произойдёт блокировка. "
"Это может случиться, например, когда данные прибыли, но при анализе их "
"контрольная сумма не совпала и они были отброшены. Также могут быть другие "
"обстоятельства, при которых файловый дескриптор ошибочно считается готовым. "
"Поэтому, возможно безопасней будет использовать для сокетов B<O_NONBLOCK>, "
"которые не должны блокироваться."

#. type: Plain text
#: man-pages/man2/select.2:673
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""
"В Linux, вызов B<select>() также изменяет I<timeout>, если он прерван "
"обработчиком сигнала (т. е., возвращается ошибка B<EINTR>). Согласно POSIX.1 "
"это не разрешено. В Linux системный вызов B<pselect>() действует также, но "
"обёртка glibc скрывает это поведение копируя перед вызовом I<timeout> в "
"локальную переменную и передавая её в системный вызов."

#. type: Plain text
#: man-pages/man2/select.2:680
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/select.2:687
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"

#. type: Plain text
#: man-pages/man2/select.2:689
#, no-wrap
msgid "    /* Watch stdin (fd 0) to see when it has input. */\n"
msgstr ""
"    /* Следить, когда в stdin (fd 0) что-нибудь появится. */\n"
"\n"

#. type: Plain text
#: man-pages/man2/select.2:692
#, no-wrap
msgid ""
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#: man-pages/man2/select.2:694
#, no-wrap
msgid "    /* Wait up to five seconds. */\n"
msgstr "    /* Ждать не больше пяти секунд. */\n"

#. type: Plain text
#: man-pages/man2/select.2:697
#, no-wrap
msgid ""
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#: man-pages/man2/select.2:700
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Больше не полагаться на значение tv! */\n"

#. type: Plain text
#: man-pages/man2/select.2:708
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Есть данные.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"Данные не появились в течение пяти секунд.\\en\");\n"

#. type: Plain text
#: man-pages/man2/select.2:724
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"

#. type: Plain text
#: man-pages/man2/select.2:726
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr "Обсуждение и примеры смотрите в B<select_tut>(2)."

#. type: TH
#: man-pages/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr "STATFS"

#. type: Plain text
#: man-pages/man2/statfs.2:31
msgid "statfs, fstatfs - get filesystem statistics"
msgstr "statfs, fstatfs - возвращает статистику по файловой системе"

#. type: Plain text
#: man-pages/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr "B<#include E<lt>sys/vfs.hE<gt> >/* или E<lt>sys/statfs.hE<gt> */"

#. type: Plain text
#: man-pages/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/statfs.2:47
msgid ""
"The B<statfs>()  system call returns information about a mounted "
"filesystem.  I<path> is the pathname of any file within the mounted "
"filesystem.  I<buf> is a pointer to a I<statfs> structure defined "
"approximately as follows:"
msgstr ""
"Системный вызов B<statfs>() возвращает информацию о смонтированной файловой "
"системе. Значение I<path> является путём любого файла, расположенного в "
"смонтированной файловой системе. Значение I<buf> является указателем на "
"структуру I<statfs>, определённую, примерно, следующим образом:"

#. type: Plain text
#: man-pages/man2/statfs.2:67
#, no-wrap
msgid ""
"struct statfs {\n"
"    __fsword_t f_type;    /* Type of filesystem (see below) */\n"
"    __fsword_t f_bsize;   /* Optimal transfer block size */\n"
"    fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */\n"
"    fsblkcnt_t f_bfree;   /* Free blocks in filesystem */\n"
"    fsblkcnt_t f_bavail;  /* Free blocks available to\n"
"                             unprivileged user */\n"
"    fsfilcnt_t f_files;   /* Total file nodes in filesystem */\n"
"    fsfilcnt_t f_ffree;   /* Free file nodes in filesystem */\n"
"    fsid_t     f_fsid;    /* Filesystem ID */\n"
"    __fsword_t f_namelen; /* Maximum length of filenames */\n"
"    __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */\n"
"    __fsword_t f_flags;   /* Mount flags of filesystem\n"
"                             (since Linux 2.6.36) */\n"
"    __fsword_t f_spare[xxx];\n"
"                    /* Padding bytes reserved for future use */\n"
"};\n"
msgstr ""
"struct statfs {\n"
"    __fsword_t f_type;    /* тип файловой системы (смотрите далее) */\n"
"    __fsword_t f_bsize;   /* оптимальный размер пересылаемых блоков */\n"
"    fsblkcnt_t f_blocks;  /* общее количество блоков данных\n"
"                             в файловой системе */\n"
"    fsblkcnt_t f_bfree;   /* свободных блоков в файловой системе */\n"
"    fsblkcnt_t f_bavail;  /* свободных блоков, доступных\n"
"                             непривилегированному пользователю */\n"
"    fsfilcnt_t f_files;   /* общее количество файловых нод\n"
"                             в файловой системе */\n"
"    fsfilcnt_t f_ffree;   /* свободных файловых нод в файловой системе */\n"
"    fsid_t     f_fsid;    /* ID файловой системы */\n"
"    __fsword_t f_namelen; /* максимальная длина имён файлов */\n"
"    __fsword_t f_frsize;  /* размер фрагмента (начиная с Linux 2.6) */\n"
"    __fsword_t f_flags;   /* флаги монтирования файловой системы\n"
"                             (начиная с Linux 2.6.36) */\n"
"    __fsword_t f_spare[xxx];\n"
"                    /* дополняющие байты, зарезервированные для будущего\n"
"                       использования */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/statfs.2:72
msgid "The following filesystem types may appear in I<f_type>:"
msgstr "В I<f_type> могут быть указаны следующие типы файловых систем:"

#. type: Plain text
#: man-pages/man2/statfs.2:160
#, no-wrap
msgid ""
"ADFS_SUPER_MAGIC      0xadf5\n"
"AFFS_SUPER_MAGIC      0xadff\n"
"AFS_SUPER_MAGIC       0x5346414f\n"
"ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for\n"
"                                    pseudofiles that have no name;\n"
"                                    e.g., epoll, signalfd, bpf) */\n"
"AUTOFS_SUPER_MAGIC    0x0187\n"
"BDEVFS_MAGIC          0x62646576\n"
"BEFS_SUPER_MAGIC      0x42465331\n"
"BFS_MAGIC             0x1badface\n"
"BINFMTFS_MAGIC        0x42494e4d\n"
"BPF_FS_MAGIC          0xcafe4a11\n"
"BTRFS_SUPER_MAGIC     0x9123683e\n"
"BTRFS_TEST_MAGIC      0x73727279\n"
"CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */\n"
"CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */\n"
"CIFS_MAGIC_NUMBER     0xff534d42\n"
"CODA_SUPER_MAGIC      0x73757245\n"
"COH_SUPER_MAGIC       0x012ff7b7\n"
"CRAMFS_MAGIC          0x28cd3d45\n"
"DEBUGFS_MAGIC         0x64626720\n"
"DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */\n"
"DEVPTS_SUPER_MAGIC    0x1cd1\n"
"ECRYPTFS_SUPER_MAGIC  0xf15f\n"
"EFIVARFS_MAGIC        0xde5e81e4\n"
"EFS_SUPER_MAGIC       0x00414a53\n"
"EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */\n"
"EXT2_OLD_SUPER_MAGIC  0xef51\n"
"EXT2_SUPER_MAGIC      0xef53\n"
"EXT3_SUPER_MAGIC      0xef53\n"
"EXT4_SUPER_MAGIC      0xef53\n"
"F2FS_SUPER_MAGIC      0xf2f52010\n"
"FUSE_SUPER_MAGIC      0x65735546\n"
"FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */\n"
"HFS_SUPER_MAGIC       0x4244\n"
"HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"HPFS_SUPER_MAGIC      0xf995e849\n"
"HUGETLBFS_MAGIC       0x958458f6\n"
"ISOFS_SUPER_MAGIC     0x9660\n"
"JFFS2_SUPER_MAGIC     0x72b6\n"
"JFS_SUPER_MAGIC       0x3153464a\n"
"MINIX_SUPER_MAGIC     0x137f     /* original minix FS */\n"
"MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */\n"
"MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */\n"
"MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */\n"
"MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */\n"
"MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */\n"
"MSDOS_SUPER_MAGIC     0x4d44\n"
"MTD_INODE_FS_MAGIC    0x11307854\n"
"NCP_SUPER_MAGIC       0x564c\n"
"NFS_SUPER_MAGIC       0x6969\n"
"NILFS_SUPER_MAGIC     0x3434\n"
"NSFS_MAGIC            0x6e736673\n"
"NTFS_SB_MAGIC         0x5346544e\n"
"OCFS2_SUPER_MAGIC     0x7461636f\n"
"OPENPROM_SUPER_MAGIC  0x9fa1\n"
"OVERLAYFS_SUPER_MAGIC 0x794c7630\n"
"PIPEFS_MAGIC          0x50495045\n"
"PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */\n"
"PSTOREFS_MAGIC        0x6165676c\n"
"QNX4_SUPER_MAGIC      0x002f\n"
"QNX6_SUPER_MAGIC      0x68191122\n"
"RAMFS_MAGIC           0x858458f6\n"
"REISERFS_SUPER_MAGIC  0x52654973\n"
"ROMFS_MAGIC           0x7275\n"
"SECURITYFS_MAGIC      0x73636673\n"
"SELINUX_MAGIC         0xf97cff8c\n"
"SMACK_MAGIC           0x43415d53\n"
"SMB_SUPER_MAGIC       0x517b\n"
"SOCKFS_MAGIC          0x534f434b\n"
"SQUASHFS_MAGIC        0x73717368\n"
"SYSFS_MAGIC           0x62656572\n"
"SYSV2_SUPER_MAGIC     0x012ff7b6\n"
"SYSV4_SUPER_MAGIC     0x012ff7b5\n"
"TMPFS_MAGIC           0x01021994\n"
"TRACEFS_MAGIC         0x74726163\n"
"UDF_SUPER_MAGIC       0x15013346\n"
"UFS_MAGIC             0x00011954\n"
"USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"V9FS_MAGIC            0x01021997\n"
"VXFS_SUPER_MAGIC      0xa501fcf5\n"
"XENFS_SUPER_MAGIC     0xabba1974\n"
"XENIX_SUPER_MAGIC     0x012ff7b4\n"
"XFS_SUPER_MAGIC       0x58465342\n"
"_XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */\n"
msgstr ""
"ADFS_SUPER_MAGIC      0xadf5\n"
"AFFS_SUPER_MAGIC      0xadff\n"
"AFS_SUPER_MAGIC       0x5346414f\n"
"ANON_INODE_FS_MAGIC   0x09041934 /* ФС анонимных инод (для\n"
"                                    псевдофайлов без имени;\n"
"                                    например, epoll, signalfd, bpf) */\n"
"AUTOFS_SUPER_MAGIC    0x0187\n"
"BDEVFS_MAGIC          0x62646576\n"
"BEFS_SUPER_MAGIC      0x42465331\n"
"BFS_MAGIC             0x1badface\n"
"BINFMTFS_MAGIC        0x42494e4d\n"
"BPF_FS_MAGIC          0xcafe4a11\n"
"BTRFS_SUPER_MAGIC     0x9123683e\n"
"BTRFS_TEST_MAGIC      0x73727279\n"
"CGROUP_SUPER_MAGIC    0x27e0eb   /* псевдофайловая система cgroup */\n"
"CGROUP2_SUPER_MAGIC   0x63677270 /* псевдофайловая система cgroup v2 */\n"
"CIFS_MAGIC_NUMBER     0xff534d42\n"
"CODA_SUPER_MAGIC      0x73757245\n"
"COH_SUPER_MAGIC       0x012ff7b7\n"
"CRAMFS_MAGIC          0x28cd3d45\n"
"DEBUGFS_MAGIC         0x64626720\n"
"DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 и старее */\n"
"DEVPTS_SUPER_MAGIC    0x1cd1\n"
"ECRYPTFS_SUPER_MAGIC  0xf15f\n"
"EFIVARFS_MAGIC        0xde5e81e4\n"
"EFS_SUPER_MAGIC       0x00414a53\n"
"EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 и старее */\n"
"EXT2_OLD_SUPER_MAGIC  0xef51\n"
"EXT2_SUPER_MAGIC      0xef53\n"
"EXT3_SUPER_MAGIC      0xef53\n"
"EXT4_SUPER_MAGIC      0xef53\n"
"F2FS_SUPER_MAGIC      0xf2f52010\n"
"FUSE_SUPER_MAGIC      0x65735546\n"
"FUTEXFS_SUPER_MAGIC   0xbad1dea  /* не используется */\n"
"HFS_SUPER_MAGIC       0x4244\n"
"HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"HPFS_SUPER_MAGIC      0xf995e849\n"
"HUGETLBFS_MAGIC       0x958458f6\n"
"ISOFS_SUPER_MAGIC     0x9660\n"
"JFFS2_SUPER_MAGIC     0x72b6\n"
"JFS_SUPER_MAGIC       0x3153464a\n"
"MINIX_SUPER_MAGIC     0x137f     /* первая ФС minix */\n"
"MINIX_SUPER_MAGIC2    0x138f     /* 30-символьная ФС minix */\n"
"MINIX2_SUPER_MAGIC    0x2468     /* ФС minix V2 */\n"
"MINIX2_SUPER_MAGIC2   0x2478     /* ФС minix V2, имена 30 символов */\n"
"MINIX3_SUPER_MAGIC    0x4d5a     /* ФС minix V3, имена 60 символов */\n"
"MQUEUE_MAGIC          0x19800202 /* ФС очереди сообщений POSIX */\n"
"MSDOS_SUPER_MAGIC     0x4d44\n"
"MTD_INODE_FS_MAGIC    0x11307854\n"
"NCP_SUPER_MAGIC       0x564c\n"
"NFS_SUPER_MAGIC       0x6969\n"
"NILFS_SUPER_MAGIC     0x3434\n"
"NSFS_MAGIC            0x6e736673\n"
"NTFS_SB_MAGIC         0x5346544e\n"
"OCFS2_SUPER_MAGIC     0x7461636f\n"
"OPENPROM_SUPER_MAGIC  0x9fa1\n"
"OVERLAYFS_SUPER_MAGIC 0x794c7630\n"
"PIPEFS_MAGIC          0x50495045\n"
"PROC_SUPER_MAGIC      0x9fa0     /* ФС /proc */\n"
"PSTOREFS_MAGIC        0x6165676c\n"
"QNX4_SUPER_MAGIC      0x002f\n"
"QNX6_SUPER_MAGIC      0x68191122\n"
"RAMFS_MAGIC           0x858458f6\n"
"REISERFS_SUPER_MAGIC  0x52654973\n"
"ROMFS_MAGIC           0x7275\n"
"SECURITYFS_MAGIC      0x73636673\n"
"SELINUX_MAGIC         0xf97cff8c\n"
"SMACK_MAGIC           0x43415d53\n"
"SMB_SUPER_MAGIC       0x517b\n"
"SOCKFS_MAGIC          0x534f434b\n"
"SQUASHFS_MAGIC        0x73717368\n"
"SYSFS_MAGIC           0x62656572\n"
"SYSV2_SUPER_MAGIC     0x012ff7b6\n"
"SYSV4_SUPER_MAGIC     0x012ff7b5\n"
"TMPFS_MAGIC           0x01021994\n"
"TRACEFS_MAGIC         0x74726163\n"
"UDF_SUPER_MAGIC       0x15013346\n"
"UFS_MAGIC             0x00011954\n"
"USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"V9FS_MAGIC            0x01021997\n"
"VXFS_SUPER_MAGIC      0xa501fcf5\n"
"XENFS_SUPER_MAGIC     0xabba1974\n"
"XENIX_SUPER_MAGIC     0x012ff7b4\n"
"XFS_SUPER_MAGIC       0x58465342\n"
"_XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 и старее */\n"

#. type: Plain text
#: man-pages/man2/statfs.2:166
msgid ""
"Most of these MAGIC constants are defined in I</usr/include/linux/magic.h>, "
"and some are hardcoded in kernel sources."
msgstr ""
"Большинство этих констант MAGIC определены в I</usr/include/linux/magic.h>, "
"а некоторые находятся прямо в исходном коде ядра."

#.  XXX Keep this list in sync with statvfs(3)
#. type: Plain text
#: man-pages/man2/statfs.2:172
msgid ""
"The I<f_flags> field is a bit mask indicating mount options for the "
"filesystem.  It contains zero or more of the following bits:"
msgstr ""
"Поле I<flags> представляет собой битовую маску параметров монтирования "
"файловой системы. В нём содержится ноль или несколько следующих бит:"

#. type: TP
#: man-pages/man2/statfs.2:172
#, no-wrap
msgid "B<ST_MANDLOCK>"
msgstr "B<ST_MANDLOCK>"

#. type: Plain text
#: man-pages/man2/statfs.2:176
msgid "Mandatory locking is permitted on the filesystem (see B<fcntl>(2))."
msgstr ""
"Разрешена обязательная (mandatory) блокировка файловой системы (смотрите "
"B<fcntl>(2))."

#. type: TP
#: man-pages/man2/statfs.2:176
#, no-wrap
msgid "B<ST_NOATIME>"
msgstr "B<ST_NOATIME>"

#. type: Plain text
#: man-pages/man2/statfs.2:180
msgid "Do not update access times; see B<mount>(2)."
msgstr "Не обновлять времена доступа; смотрите B<mount>(2)."

#. type: TP
#: man-pages/man2/statfs.2:180
#, no-wrap
msgid "B<ST_NODEV>"
msgstr "B<ST_NODEV>"

#. type: Plain text
#: man-pages/man2/statfs.2:183
msgid "Disallow access to device special files on this filesystem."
msgstr ""
"Запретить доступ к специальным файлам устройств в этой файловой системе."

#. type: TP
#: man-pages/man2/statfs.2:183
#, no-wrap
msgid "B<ST_NODIRATIME>"
msgstr "B<ST_NODIRATIME>"

#. type: Plain text
#: man-pages/man2/statfs.2:187
msgid "Do not update directory access times; see B<mount>(2)."
msgstr "Не обновлять времена доступа к каталогам; смотрите B<mount>(2)."

#. type: TP
#: man-pages/man2/statfs.2:187
#, no-wrap
msgid "B<ST_NOEXEC>"
msgstr "B<ST_NOEXEC>"

#. type: Plain text
#: man-pages/man2/statfs.2:190
msgid "Execution of programs is disallowed on this filesystem."
msgstr "Исполнение программ в этой файловой системе запрещено."

#. type: TP
#: man-pages/man2/statfs.2:190
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr "B<ST_NOSUID>"

#. type: Plain text
#: man-pages/man2/statfs.2:195
msgid ""
"The set-user-ID and set-group-ID bits are ignored by B<exec>(3)  for "
"executable files on this filesystem"
msgstr ""
"Биты set-user-ID и set-group-ID игнорируются в B<exec>(3) для исполняемых "
"файлов в этой файловой системе."

#. type: TP
#: man-pages/man2/statfs.2:195
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr "B<ST_RDONLY>"

#. type: Plain text
#: man-pages/man2/statfs.2:198
msgid "This filesystem is mounted read-only."
msgstr "Файловая система смонтирована в режиме только для чтения."

#. type: TP
#: man-pages/man2/statfs.2:198
#, no-wrap
msgid "B<ST_RELATIME>"
msgstr "B<ST_RELATIME>"

#. type: Plain text
#: man-pages/man2/statfs.2:202
msgid "Update atime relative to mtime/ctime; see B<mount>(2)."
msgstr "Обновлять atime относительно mtime/ctime; смотрите B<mount>(2)."

#. type: TP
#: man-pages/man2/statfs.2:202
#, no-wrap
msgid "B<ST_SYNCHRONOUS>"
msgstr "B<ST_SYNCHRONOUS>"

#. type: Plain text
#: man-pages/man2/statfs.2:208
msgid ""
"Writes are synched to the filesystem immediately (see the description of "
"B<O_SYNC> in B<open>(2))."
msgstr ""
"Выполнять синхронную запись в файловую систему немедленно (смотрите описание "
"B<O_SYNC> в B<open>(2))."

#. type: Plain text
#: man-pages/man2/statfs.2:212
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr "Значение I<f_fsid> до конца не определено (но смотрите далее)."

#. type: Plain text
#: man-pages/man2/statfs.2:214
msgid "Fields that are undefined for a particular filesystem are set to 0."
msgstr ""
"Если поле не определёно для какой-то файловой системы, то его значение "
"устанавливается в 0."

#. type: Plain text
#: man-pages/man2/statfs.2:218
msgid ""
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""
"B<fstatfs>() возвращает такую же информацию об открытом файле через его "
"ссылку на дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/statfs.2:231
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statfs>()) В одном из каталогов префикса пути I<path> не разрешён поиск "
"(см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/statfs.2:236
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr ""
"(B<fstatfs>()) I<fd> не является корректным открытым дескриптором файла."

#. type: Plain text
#: man-pages/man2/statfs.2:242
msgid "I<buf> or I<path> points to an invalid address."
msgstr "Аргумент I<buf> или I<path> указывает на неправильный адрес."

#. type: Plain text
#: man-pages/man2/statfs.2:246
msgid "The call was interrupted by a signal; see B<signal>(7)."
msgstr "Вызов был прерван каким-либо сигналом. Смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/statfs.2:249
msgid "An I/O error occurred while reading from the filesystem."
msgstr "При чтении файловой системы произошла ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/statfs.2:254
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""
"(B<statfs>()) Было обнаружено слишком много символьных ссылок при трансляции "
"I<path>."

#. type: Plain text
#: man-pages/man2/statfs.2:259
msgid "(B<statfs>())  I<path> is too long."
msgstr "(B<statfs>()) Слишком длинное значение аргумента I<path>."

#. type: Plain text
#: man-pages/man2/statfs.2:265
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr "(B<statfs>()) Файл, на который ссылается I<path>, не существует."

#. type: Plain text
#: man-pages/man2/statfs.2:271
msgid "The filesystem does not support this call."
msgstr "Файловая система не поддерживает данный вызов."

#. type: Plain text
#: man-pages/man2/statfs.2:277
msgid ""
"(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr "(B<statfs>()) Компонент в префиксе пути I<path> не является каталогом."

#. type: Plain text
#: man-pages/man2/statfs.2:280
msgid "Some values were too large to be represented in the returned struct."
msgstr ""
"Некоторые значения слишком велики, чтобы быть представленными в возвращаемой "
"структуре."

#. type: Plain text
#: man-pages/man2/statfs.2:286
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr ""
"Есть только в Linux. Вызов B<statfs>() основан на подобном из 4.4BSD (но они "
"используют разные структуры)."

#. type: Plain text
#: man-pages/man2/statfs.2:298
msgid ""
"The I<__fsword_t> type used for various fields in the I<statfs> structure "
"definition is a glibc internal type, not intended for public use.  This "
"leaves the programmer in a bit of a conundrum when trying to copy or compare "
"these fields to local variables in a program.  Using I<unsigned\\ int> for "
"such variables suffices on most systems."
msgstr ""
"Тип I<__fsword_t>, используемый для различных полей в определении структуры "
"I<statfs>, является встроенным типом glibc и не предназначен для "
"использования вовне. Это подкидывает загадку программисту, который хочет "
"скопировать или сравнить эти поля с локальными переменными в программе. В "
"большинстве систем для переменных в этих случаях допустимо использовать тип "
"I<unsigned\\ int>."

#. type: Plain text
#: man-pages/man2/statfs.2:320
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased, "
"to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr ""
"Первые версии системных вызовов Linux B<statfs>() и B<fstatfs>() "
"разрабатывались без учёта огромных размеров файлов. В последствии, в Linux "
"2.6 были добавлены системные вызовы B<statfs64>() и B<fstatfs64>(), в "
"которых используется новая структура, I<statfs64>. Новая структура содержит "
"те же поля что и первоначальная структура I<statfs>, но размеры некоторых "
"полей были увеличены для учёта огромных размеров файлов. Обёрточные функции "
"в glibc B<statfs>() и B<fstatfs>() прозрачно скрывают это различие ядер."

#. type: Plain text
#: man-pages/man2/statfs.2:325
msgid ""
"Some systems have only I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr ""
"В одних системах есть только файл I<E<lt>sys/vfs.hE<gt>>, в других также "
"есть файл I<E<lt>sys/statfs.hE<gt>>, при чём первый включает последний. "
"Поэтому, вероятно, лучше включать первый."

#. type: Plain text
#: man-pages/man2/statfs.2:335
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr ""
"В LSB библиотечные вызовы B<statfs>() и B<fstatfs>() помечены как "
"устаревшие, вместе них предлагается использовать B<statvfs>(2) и "
"B<fstatvfs>(2)."

#. type: SS
#: man-pages/man2/statfs.2:335
#, no-wrap
msgid "The f_fsid field"
msgstr "Поле f_fsid"

#. type: Plain text
#: man-pages/man2/statfs.2:360
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in I<E<lt>sys/vfs."
"hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> is defined as "
"I<struct { int val[2]; }>.  The same holds for FreeBSD, except that it uses "
"the include file I<E<lt>sys/mount.hE<gt>>."
msgstr ""
"В Solaris, Irix и POSIX имеется системный вызов B<statvfs>(2), который "
"возвращает I<struct statvfs> (определена в I<E<lt>sys/statvfs.hE<gt>>), и в "
"ней содержится поле I<unsigned long> I<f_fsid>. В Linux, SunOS, HP-UX, "
"4.4BSD имеется системный вызов B<statfs>(), который возвращает I<struct "
"statfs> (определена в I<E<lt>sys/vfs.hE<gt>>), и в ней содержится I<fsid_t> "
"I<f_fsid>, где тип I<fsid_t> определён как I<struct { int val[2]; }>. Того "
"же придерживается FreeBSD, за исключением того, что в ней используется "
"включаемый файл I<E<lt>sys/mount.hE<gt>>."

#. type: Plain text
#: man-pages/man2/statfs.2:373
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems "
"use (a variation on) the device number, or the device number combined with "
"the filesystem type.  Several operating systems restrict giving out the "
"I<f_fsid> field to the superuser only (and zero it for unprivileged users), "
"because this field is used in the filehandle of the filesystem when NFS-"
"exported, and giving it out is a security concern."
msgstr ""
"Общая идея в том, что в I<f_fsid> содержится какая-то произвольная "
"информация, например пара (I<f_fsid>,I<ino>) уникально определяющая файл. В "
"некоторых операционных системах для этого используется номер устройства "
"(один из вариантов) или номер устройства вместе с типом файловой системы. В "
"других ОС поле I<f_fsid> доступно только суперпользователю (и равно нулю для "
"остальных пользователей), так как это поле используется в файловом указателе "
"(filehandle) файловой системы при экспорте NFS, и выдача его значения влияет "
"на безопасность."

#. type: Plain text
#: man-pages/man2/statfs.2:379
msgid ""
"Under some operating systems, the I<fsid> can be used as the second argument "
"to the B<sysfs>(2)  system call."
msgstr ""
"В некоторых ОС  I<fsid> может использоваться в качестве второго аргумента "
"системного вызова B<sysfs>(2)."

#.  broken in commit ff0c7d15f9787b7e8c601533c015295cc68329f8
#.  fixed in commit d70ef97baf048412c395bb5d65791d8fe133a52b
#. type: Plain text
#: man-pages/man2/statfs.2:388
msgid ""
"From Linux 2.6.38 up to and including Linux 3.1, B<fstatfs>()  failed with "
"the error B<ENOSYS> for file descriptors created by B<pipe>(2)."
msgstr ""
"В Linux 2.6.38 и до Linux 3.1 включительно, вызов B<fstatfs>() завершался с "
"ошибкой B<ENOSYS> для файловых дескрипторов, созданных с помощью B<pipe>(2)."

#. type: Plain text
#: man-pages/man2/statfs.2:391
msgid "B<stat>(2), B<statvfs>(3), B<path_resolution>(7)"
msgstr "B<stat>(2), B<statvfs>(3), B<path_resolution>(7)"

#. type: TH
#: man-pages/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr "SUBPAGE_PROT"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr "subpage_prot - определяет подстраничную защиту адресного диапазона"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4\\ kB subpages on systems "
"configured with a page size of 64\\ kB."
msgstr ""
"Системный вызов (есть только для PowerPC) B<subpage_prot>() предоставляет "
"возможность контроля доступа к отдельным 4\\ КБ подстраницам в системах, где "
"размер страницы равен 64\\ КБ."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""
"Карта защиты налагается на страницы памяти для области, начинающейся с "
"I<addr> и имеющей размер I<len> байт. Значения обоих аргументов должны быть "
"выровнены на 64-КБ границу."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4\\ kB subpage; thus each 32-bit word specifies the "
"protections of 16 4\\ kB subpages inside a 64\\ kB page (so, the number of "
"32-bit words pointed to by I<map> should equate to the number of 64-kB pages "
"specified by I<len>).  Each 2-bit field in the protection map is either 0 to "
"allow any access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""
"Карта защиты задаётся в буфере, на который указывает I<map>. В карте на "
"каждую 4-килобайтную подстраницу выделяется 2 бита; таким образом, в каждом "
"32-битном слове задаётся защита для 16 4-килобайтных подстраниц внутри 64-"
"килобайтной страницы (поэтому количество 32-битных слов, на которые "
"указывает I<map>, должно быть равно количеству 64-килобайтных страниц, "
"указанному в I<len>). Каждое 2-битное поле в карте защиты может быть: 0 — "
"полный доступ, 1 — защита от записи, 2 или 3 — запрет на любой доступ."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""
"При успешном выполнении B<subpage_prot>() возвращается 0. В противном случае "
"возвращается один из кодов ошибок, описанных далее."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr "Буфер, на который ссылается I<map>, недоступен."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""
"Некорректное значение аргумента I<addr> или I<len>. Оба значения должны быть "
"кратны размеру системной страницы, и они не должны указывать на область вне "
"адресного пространства процесса, или на область, которая состоит из огромных "
"страниц."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""
"Данный системный вызов предоставляется для архитектуры PowerPC начиная с "
"Linux 2.6.25. Для его сборки в ядре должен быть указан параметр "
"B<CONFIG_PPC_64K_PAGES>. В библиотеке поддержка данного вызова отсутствует."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""
"Обычная страничная защита также работает (на уровне 64-килобайтных страниц); "
"механизм подстраничной защиты является дополнительным ограничением, поэтому "
"указание 0 в 2-битном поле не разрешит запись в страницу, которая защищена "
"от записи другим способом."

#. type: SS
#: man-pages/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr "Обоснование"

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4 kB hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: man-pages/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the memory-"
"management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is "
"slow.)  The idea is that the emulator supplies an array of protection masks "
"to apply to a specified range of virtual addresses.  These masks are applied "
"at the level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""
"Данный системный вызов предоставляется для облегчения написания эмуляторов, "
"которые работают с 64-КБ страницами в системах PowerPC. При эмуляции систем, "
"в которых используется меньший размер страницы (таких как x86), эмулятор не "
"может использовать блок управления памятью (MMU) и обычные системные вызовы "
"управления защитой страниц (эмулятор может эмулировать MMU с помощью ПО "
"проверяя и, возможно, перераспределяя адрес при каждом обращении к памяти, "
"но это медленно). Идея в том, что эмулятор задаёт массив защитных масок для "
"указанного диапазона виртуальных адресов. Эти маски накладываются в месте, "
"где аппаратные табличные записи страниц (PTE) вставляются в аппаратную "
"таблицу страниц на основе Linux PTE, при этом Linux PTE не затрагиваются. В "
"этом случае для защищённых областей адресного пространства начинают неявно "
"использоваться 4-килобайтные аппаратные страницы, а не 64-килобайтные "
"аппаратные страницы (на машинах с аппаратной поддержкой 64-килобайтных "
"страниц)."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:131
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr "B<mprotect>(2), B<syscall>(2)"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:133
msgid ""
"I<Documentation/admin-guide/mm/hugetlbpage.rst> in the Linux kernel source "
"tree"
msgstr ""
"I<Documentation/admin-guide/mm/hugetlbpage.rst> в дереве исходного кода ядра "
"Linux"

#. type: TH
#: man-pages/man5/slabinfo.5:26
#, no-wrap
msgid "SLABINFO"
msgstr "SLABINFO"

#. type: Plain text
#: man-pages/man5/slabinfo.5:29
msgid "slabinfo - kernel slab allocator statistics"
msgstr "slabinfo - сводная таблица использования блоков кэша (slab) ядра"

#. type: Plain text
#: man-pages/man5/slabinfo.5:31
msgid "B<cat /proc/slabinfo>"
msgstr "B<cat /proc/slabinfo>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:40
msgid ""
"Frequently used objects in the Linux kernel (buffer heads, inodes, dentries, "
"etc.)  have their own cache.  The file I</proc/slabinfo> gives statistics on "
"these caches.  The following (edited) output shows an example of the "
"contents of this file:"
msgstr ""
"Часто используемые объекты в ядре Linux (заголовки буферов, иноды, элементы "
"dentry и тп.) имеют свои собственные кэши. В файле I</proc/slabinfo> "
"отражена статистика их работы. Пример (отредактированный) содержимого этого "
"файла:"

#. type: Plain text
#: man-pages/man5/slabinfo.5:50
#, no-wrap
msgid ""
"$ B<sudo cat /proc/slabinfo>\n"
"slabinfo - version: 2.1\n"
"# name    E<lt>active_objsE<gt> E<lt>num_objsE<gt> E<lt>objsizeE<gt> E<lt>objperslabE<gt> E<lt>pagesperslabE<gt> ...\n"
"sigqueue      100  100  160   25  1 : tunables  0  0  0 : slabdata   4   4  0\n"
"sighand_cache 355   405 2112  15  8 : tunables  0  0  0 : slabdata  27  27  0\n"
"kmalloc-8192   96   96  8192   4  8 : tunables  0  0  0 : slabdata  24  24  0\n"
"\\&...\n"
msgstr ""
"$ B<sudo cat /proc/slabinfo>\n"
"slabinfo - version: 2.1\n"
"# name    E<lt>active_objsE<gt> E<lt>num_objsE<gt> E<lt>objsizeE<gt> E<lt>objperslabE<gt> E<lt>pagesperslabE<gt> ...\n"
"sigqueue      100  100  160   25  1 : tunables  0  0  0 : slabdata   4   4  0\n"
"sighand_cache 355   405 2112  15  8 : tunables  0  0  0 : slabdata  27  27  0\n"
"kmalloc-8192   96   96  8192   4  8 : tunables  0  0  0 : slabdata  24  24  0\n"
"\\&...\n"

#. type: Plain text
#: man-pages/man5/slabinfo.5:58
msgid ""
"The first line of output includes a version number, which allows an "
"application that is reading the file to handle changes in the file format.  "
"(See VERSIONS, below.)  The next line lists the names of the columns in the "
"remaining lines."
msgstr ""
"В первой строке содержится номер версии, который позволяет приложению, "
"читающему файл, определить формат файла (смотрите ВЕРСИИ ниже). В следующей "
"строке перечисляются имена столбцов в оставшихся строках."

#. type: Plain text
#: man-pages/man5/slabinfo.5:62
msgid ""
"Each of the remaining lines displays information about a specified cache.  "
"Following the cache name, the output shown in each line shows three "
"components for each cache:"
msgstr ""
"В каждой оставшейся строке выводится информация об определённом кэше. После "
"имени данные каждого кэша делятся на три компонента:"

#. type: Plain text
#: man-pages/man5/slabinfo.5:64
msgid "statistics"
msgstr "статистика"

#. type: Plain text
#: man-pages/man5/slabinfo.5:66
msgid "tunables"
msgstr "регулировки (tunables)"

#. type: Plain text
#: man-pages/man5/slabinfo.5:68
msgid "slabdata"
msgstr "slabdata"

#. type: Plain text
#: man-pages/man5/slabinfo.5:70
msgid "The statistics are as follows:"
msgstr "Поля статистики:"

#. type: TP
#: man-pages/man5/slabinfo.5:70
#, no-wrap
msgid "I<active_objs>"
msgstr "I<active_objs>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:73
msgid "The number of objects that are currently active (i.e., in use)."
msgstr "Количество активных (т. е., использующихся) в данный момент объектов."

#. type: TP
#: man-pages/man5/slabinfo.5:73
#, no-wrap
msgid "I<num_objs>"
msgstr "I<num_objs>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:77
msgid ""
"The total number of allocated objects (i.e., objects that are both in use "
"and not in use)."
msgstr ""
"Общее количество выделенных объектов (т. е., используемых и не используемых "
"объектов)."

#. type: TP
#: man-pages/man5/slabinfo.5:77
#, no-wrap
msgid "I<objsize>"
msgstr "I<objsize>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:80
msgid "The size of objects in this slab, in bytes."
msgstr "Размер объектов в этом кэше (slab), в байтах."

#. type: TP
#: man-pages/man5/slabinfo.5:80
#, no-wrap
msgid "I<objperslab>"
msgstr "I<objperslab>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:83
msgid "The number of objects stored in each slab."
msgstr "Количество объектов, хранящихся в каждом кэше (slab)."

#. type: TP
#: man-pages/man5/slabinfo.5:83
#, no-wrap
msgid "I<pagesperslab>"
msgstr "I<pagesperslab>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:86
msgid "The number of pages allocated for each slab."
msgstr "Количество страниц, выделенных для каждого кэша (slab)."

#. type: Plain text
#: man-pages/man5/slabinfo.5:97
msgid ""
"The I<tunables> entries in each line show tunable parameters for the "
"corresponding cache.  When using the default SLUB allocator, there are no "
"tunables, the I</proc/slabinfo> file is not writable, and the value 0 is "
"shown in these fields.  When using the older SLAB allocator, the tunables "
"for a particular cache can be set by writing lines of the following form to "
"I</proc/slabinfo>:"
msgstr ""
"Элементы I<регулировок> в каждой строке содержат подстроечные параметры "
"соответствующего кэша. При использовании выделителя по умолчанию SLUB они "
"отсутствуют, файл I</proc/slabinfo> недоступен для записи и в этих полях "
"показываются значения 0. При использовании старого выделителя SLAB "
"регулировки определённого кэша можно изменять посредством записи строк в "
"формате I</proc/slabinfo>:"

#. type: Plain text
#: man-pages/man5/slabinfo.5:101
#, no-wrap
msgid "# B<echo 'name limit batchcount sharedfactor' E<gt> /proc/slabinfo>\n"
msgstr "# B<echo 'name limit batchcount sharedfactor' E<gt> /proc/slabinfo>\n"

#. type: Plain text
#: man-pages/man5/slabinfo.5:123
msgid ""
"Here, I<name> is the cache name, and I<limit>, I<batchcount>, and "
"I<sharedfactor> are integers defining new values for the corresponding "
"tunables.  The I<limit> value should be a positive value, I<batchcount> "
"should be a positive value that is less than or equal to I<limit>, and "
"I<sharedfactor> should be nonnegative.  If any of the specified values is "
"invalid, the cache settings are left unchanged."
msgstr ""
"Здесь I<name> — имя кэша, I<limit>, I<batchcount> и I<sharedfactor> — целые "
"числа, задающие новые значения соответствующих регулировок. Значение "
"I<limit> должно быть положительным, I<batchcount> должно быть положительным "
"числом меньшим или равным I<limit>, а I<sharedfactor> должно быть "
"неотрицательным. Если одно из значений некорректно, то настройки кэша не "
"изменяются."

#. type: Plain text
#: man-pages/man5/slabinfo.5:127
msgid "The I<tunables> entries in each line contain the following fields:"
msgstr "Записи I<регулировок> в каждой строке имеют следующие поля:"

#. type: TP
#: man-pages/man5/slabinfo.5:127
#, no-wrap
msgid "I<limit>"
msgstr "I<limit>"

#.  https://lwn.net/Articles/56360/
#.      This is the limit on the number of free objects that can be stored
#.      in the per-CPU free list for this slab cache.
#. type: Plain text
#: man-pages/man5/slabinfo.5:133
msgid "The maximum number of objects that will be cached."
msgstr "Максимальное количество объектов, которые будут кэшироваться."

#. type: TP
#: man-pages/man5/slabinfo.5:133
#, no-wrap
msgid "I<batchcount>"
msgstr "I<batchcount>"

#.  https://lwn.net/Articles/56360/
#.      On SMP systems, when we refill the available object list, instead
#.      of doing one object at a time, we do batch-count objects at a time.
#. type: Plain text
#: man-pages/man5/slabinfo.5:140
msgid ""
"On SMP systems, this specifies the number of objects to transfer at one time "
"when refilling the available object list."
msgstr ""
"Для многопроцессорных систем здесь задаётся количество объектов передаваемых "
"одновременно, происходит наполнение списка доступных объектов."

#. type: TP
#: man-pages/man5/slabinfo.5:140
#, no-wrap
msgid "I<sharedfactor>"
msgstr "I<sharedfactor>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:144 man-pages/man5/slabinfo.5:157
msgid "[To be documented]"
msgstr "[Будет описано]"

#. type: Plain text
#: man-pages/man5/slabinfo.5:148
msgid "The I<slabdata> entries in each line contain the following fields:"
msgstr "Записи I<slabdata> в каждой строке имеют следующие поля:"

#. type: TP
#: man-pages/man5/slabinfo.5:148
#, no-wrap
msgid "I<active_slabs>"
msgstr "I<active_slabs>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:151
msgid "The number of active slabs."
msgstr "Количество активных кэшей (slabs)."

#. type: TP
#: man-pages/man5/slabinfo.5:151
#, no-wrap
msgid "I<nums_slabs>"
msgstr "I<nums_slabs>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:154
msgid "The total number of slabs."
msgstr "Общее количество активных кэшей (slabs)."

#. type: TP
#: man-pages/man5/slabinfo.5:154
#, no-wrap
msgid "I<sharedavail>"
msgstr "I<sharedavail>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:162
msgid ""
"Note that because of object alignment and slab cache overhead, objects are "
"not normally packed tightly into pages.  Pages with even one in-use object "
"are considered in-use and cannot be freed."
msgstr ""
"Заметим, что из-за выравнивания объектов и заголовков блоков кэша объекты "
"обычно не упакованы ровно по страницам. Страницы даже с единственным "
"используемым объектом уже сами считаются используемыми и не могут быть "
"высвобождены."

#.  SMP systems will also have "(SMP)" in the first line of
#.  output, and will have two additional columns for each slab,
#.  reporting the slab allocation policy for the CPU-local
#.  cache (to reduce the need for inter-CPU synchronization
#.  when allocating objects from the cache).
#.  The first column is the per-CPU limit: the maximum number of objects that
#.  will be cached for each CPU.
#.  The second column is the
#.  batchcount: the maximum number of free objects in the
#.  global cache that will be transferred to the per-CPU cache
#.  if it is empty, or the number of objects to be returned
#.  to the global cache if the per-CPU cache is full.
#.  If both slab cache statistics and SMP are defined, there
#.  will be four additional columns, reporting the per-CPU
#.  cache statistics.
#.  The first two are the per-CPU cache
#.  allocation hit and miss counts: the number of times an
#.  object was or was not available in the per-CPU cache
#.  for allocation.
#.  The next two are the per-CPU cache free
#.  hit and miss counts: the number of times a freed object
#.  could or could not fit within the per-CPU cache limit,
#.  before flushing objects to the global cache.
#. type: Plain text
#: man-pages/man5/slabinfo.5:199
msgid ""
"Kernels configured with B<CONFIG_DEBUG_SLAB> will also have additional "
"statistics fields in each line, and the first line of the file will contain "
"the string \"(statistics)\".  The statistics field include : the high water "
"mark of active objects; the number of times objects have been allocated; the "
"number of times the cache has grown (new pages added to this cache); the "
"number of times the cache has been reaped (unused pages removed from this "
"cache); and the number of times there was an error allocating new pages to "
"this cache."
msgstr ""
"Ядра с включённым параметром B<CONFIG_DEBUG_SLAB> также будут выдавать в "
"каждой дополнительные поля статистики, а в первой строке файла будет слово "
"«(statistics)». Поля статистики: максимальная отметка по активным объектам, "
"количество раз, когда был выделен объект, количество раз, когда кэш рос (в "
"этот кэш добавлялись новые страницы), количество раз, когда кэш урезался (из "
"этого кэша удалялись неиспользуемые страницы), количество раз, когда "
"возникала ошибка при выделении новых страниц для кэша."

#. type: Plain text
#: man-pages/man5/slabinfo.5:205
msgid ""
"The I</proc/slabinfo> file first appeared in Linux 2.1.23.  The file is "
"versioned, and over time there have been a number of versions with different "
"layouts:"
msgstr ""
"Фай I</proc/slabinfo> впервые появился в Linux 2.1.23. Файл содержит номер "
"версии, которых было создано несколько с разными форматами:"

#. type: Plain text
#: man-pages/man5/slabinfo.5:208
msgid "Present throughout the Linux 2.2.x kernel series."
msgstr "В ядрах Linux 2.2.x."

#. type: TP
#: man-pages/man5/slabinfo.5:208
#, no-wrap
msgid "1.1"
msgstr "1.1"

#.  First appeared in 2.4.0-test3
#. type: Plain text
#: man-pages/man5/slabinfo.5:212
msgid "Present in the Linux 2.4.x kernel series."
msgstr "В ядрах Linux 2.4.x."

#.  from 2.5.45 to 2.5.70
#. type: Plain text
#: man-pages/man5/slabinfo.5:216
msgid "A format that was briefly present in the Linux 2.5 development series."
msgstr ""
"Формат, существовавший короткое время в разрабатываемых версиях Linux 2.5."

#.  First appeared in 2.5.71
#. type: Plain text
#: man-pages/man5/slabinfo.5:220
msgid "Present in Linux 2.6.x kernels up to and including Linux 2.6.9."
msgstr "В ядрах Linux 2.6.x по Linux 2.6.9, включительно."

#. type: TP
#: man-pages/man5/slabinfo.5:220
#, no-wrap
msgid "2.1"
msgstr "2.1"

#. type: Plain text
#: man-pages/man5/slabinfo.5:223
msgid "The current format, which first appeared in Linux 2.6.10."
msgstr "Текущий формат, появился в Linux 2.6.10."

#. type: Plain text
#: man-pages/man5/slabinfo.5:229
msgid ""
"Only root can read and (if the kernel was configured with B<CONFIG_SLAB>)  "
"write the I</proc/slabinfo> file."
msgstr ""
"Только суперпользователь может читать и (если ядро собрано с B<CONFIG_SLAB>) "
"изменять файл I</proc/slabinfo>."

#. type: Plain text
#: man-pages/man5/slabinfo.5:234
msgid ""
"The total amount of memory allocated to the SLAB/SLUB cache is shown in the "
"I<Slab> field of I</proc/meminfo>."
msgstr ""
"Общее количество памяти, выделенное под кэш SLAB/SLUB, показано в поле "
"I<Slab> файла I</proc/meminfo>."

#. type: Plain text
#: man-pages/man5/slabinfo.5:236
msgid "B<slabtop>(1)"
msgstr "B<slabtop>(1)"

#. type: Plain text
#: man-pages/man5/slabinfo.5:240
msgid ""
"The kernel source file I<Documentation/vm/slub.txt> and I<tools/vm/slabinfo."
"c>."
msgstr ""
"Файл из дерева исходного кода ядра I<Documentation/vm/slub.txt> и I<tools/vm/"
"slabinfo.c>."

#. type: TH
#: man-pages/man5/securetty.5:26
#, no-wrap
msgid "SECURETTY"
msgstr "SECURETTY"

#. type: TH
#: man-pages/man5/securetty.5:26
#, no-wrap
msgid "2015-03-29"
msgstr "2015-03-29"

#. type: Plain text
#: man-pages/man5/securetty.5:29
msgid "securetty - file which lists terminals from which root can log in"
msgstr ""
"securetty - файл со списком терминалов, с которых пользователь root может "
"входить в систему"

#. type: Plain text
#: man-pages/man5/securetty.5:37
msgid ""
"The file I</etc/securetty> contains the names of terminals (one per line, "
"without leading I</dev/>)  which are considered secure for the transmission "
"of certain authentication tokens."
msgstr ""
"Файл I</etc/securetty> содержит имена терминалов (по одному на строку, без "
"начального I</dev/>), которые считаются безопасными для передачи некоторых "
"токенов аутентификации."

#. type: Plain text
#: man-pages/man5/securetty.5:45
msgid ""
"It is used by (some versions of)  B<login>(1)  to restrict the terminals on "
"which root is allowed to login.  See B<login.defs>(5)  if you use the shadow "
"suite."
msgstr ""
"Он используется B<login>(1) (некоторыми версиями) для ограничения списка "
"терминалов, с которых пользователю root разрешается вход в систему. Смотрите "
"B<login.defs>(5), если используется механизм теневых паролей."

#. type: Plain text
#: man-pages/man5/securetty.5:49
msgid ""
"On PAM enabled systems, it is used for the same purpose by "
"B<pam_securetty>(8)  to restrict the terminals on which empty passwords are "
"accepted."
msgstr ""
"В системах с включённым PAM он используется с той же целью из "
"B<pam_securetty>(8), для ограничения списка терминалов, для которых разрешён "
"пустой пароль."

#. type: Plain text
#: man-pages/man5/securetty.5:51
msgid "I</etc/securetty>"
msgstr "I</etc/securetty>"

#. type: Plain text
#: man-pages/man5/securetty.5:54
msgid "B<login>(1), B<login.defs>(5), B<pam_securetty>(8)"
msgstr "B<login>(1), B<login.defs>(5), B<pam_securetty>(8)"

#. type: TH
#: man-pages/man5/services.5:34
#, no-wrap
msgid "SERVICES"
msgstr "SERVICES"

#. type: TH
#: man-pages/man5/services.5:34
#, no-wrap
msgid "2010-05-22"
msgstr "2010-05-22"

#. type: Plain text
#: man-pages/man5/services.5:37
msgid "services - Internet network services list"
msgstr "services - список служб сети Интернет"

#. type: Plain text
#: man-pages/man5/services.5:52
msgid ""
"B<services> is a plain ASCII file providing a mapping between human-friendly "
"textual names for internet services, and their underlying assigned port "
"numbers and protocol types.  Every networking program should look into this "
"file to get the port number (and protocol) for its service.  The C library "
"routines B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<setservent>(3), and B<endservent>(3)  support querying this file from "
"programs."
msgstr ""
"B<services> — это простой файл в кодировке ASCII, обеспечивающий "
"распределение соответствующих текстовых имён между службами интернет, "
"связанных с ними назначений портов и типов протоколов. Любая сетевая "
"программа должна сначала обратиться к этому файлу для получения номера порта "
"(и протокола) для своей службы. Функции библиотеки C B<getservent>(3), "
"B<getservbyname>(3), B<getservbyport>(3), B<setservent>(3) и "
"B<endservent>(3) выполняют запросы программ к этому файлу."

#. type: Plain text
#: man-pages/man5/services.5:58
msgid ""
"Port numbers are assigned by the IANA (Internet Assigned Numbers Authority), "
"and their current policy is to assign both TCP and UDP protocols when "
"assigning a port number.  Therefore, most entries will have two entries, "
"even for TCP-only services."
msgstr ""
"Номера портов назначаются IANA (Internet Assigned Numbers Authority), и их "
"текущей политикой является указание TCP- и UDP-протоколов при назначении "
"номера порта. Следовательно, большинство элементов будет иметь двойные "
"значения даже для служб, которые используют только TCP."

#. type: Plain text
#: man-pages/man5/services.5:70
msgid ""
"Port numbers below 1024 (so-called \"low numbered\" ports) can be bound to "
"only by root (see B<bind>(2), B<tcp>(7), and B<udp>(7)).  This is so clients "
"connecting to low numbered ports can trust that the service running on the "
"port is the standard implementation, and not a rogue service run by a user "
"of the machine.  Well-known port numbers specified by the IANA are normally "
"located in this root-only space."
msgstr ""
"Номера портов меньше 1024 (так называемые «привилегированные» порты) могут "
"быть задействованы только суперпользователем (смотрите B<bind>(2), B<tcp>(7) "
"и B<udp>(7)). Это делается для того, чтобы клиенты, подключающиеся к "
"привилегированным портам, могли не сомневаться в том, что служба, работающая "
"на порту, обеспечивает стандартную реализацию, и не является «подставной» "
"службой какого-нибудь пользователя в машине. Известные номера портов, "
"определённые IANA, обычно располагаются только в пространстве "
"суперпользователя."

#. type: Plain text
#: man-pages/man5/services.5:85
msgid ""
"The presence of an entry for a service in the B<services> file does not "
"necessarily mean that the service is currently running on the machine.  See "
"B<inetd.conf>(5)  for the configuration of Internet services offered.  Note "
"that not all networking services are started by B<inetd>(8), and so won't "
"appear in B<inetd.conf>(5).  In particular, news (NNTP) and mail (SMTP) "
"servers are often initialized from the system boot scripts."
msgstr ""
"Присутствие элемента службы в файле B<services> не обязательно означает, что "
"эта служба сейчас запущена на машине. Смотрите B<inetd.conf>(5) для "
"знакомства с настройкой служб интернета. Заметим, что не все сетевые службы "
"запускаются с помощью B<inetd>(8), и поэтому могут отсутствовать в B<inetd."
"conf>(5). В частности, серверы новостей (NNTP) и почтовые серверы (SMTP) "
"часто запускаются с помощью системных загрузочных сценариев."

#. type: Plain text
#: man-pages/man5/services.5:94
msgid ""
"The location of the B<services> file is defined by B<_PATH_SERVICES> in "
"I<E<lt>netdb.hE<gt>>.  This is usually set to I</etc/services>."
msgstr ""
"Расположение файла B<services> определяется B<_PATH_SERVICES> в I<E<lt>netdb."
"hE<gt>>. Обычно значением является I</etc/services>."

#. type: Plain text
#: man-pages/man5/services.5:96
msgid "Each line describes one service, and is of the form:"
msgstr "Каждая строка определяет одну службу и имеет следующий формат:"

#. type: Plain text
#: man-pages/man5/services.5:98
msgid "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"
msgstr "I<имя-службы\\ \\ \\ порт>B</>I<протокол\\ \\ \\ >[I<псевдонимы ...>]"

#. type: TP
#: man-pages/man5/services.5:98
#, no-wrap
msgid "where:"
msgstr "где:"

#. type: TP
#: man-pages/man5/services.5:100
#, no-wrap
msgid "I<service-name>"
msgstr "I<имя-службы>"

#. type: Plain text
#: man-pages/man5/services.5:106
msgid ""
"is the friendly name the service is known by and looked up under.  It is "
"case sensitive.  Often, the client program is named after the I<service-"
"name>."
msgstr ""
"Известное имя службы, по которому она в дальнейшем будет определяться. "
"Регистр символов имеет значение. Часто клиентские программы называются по "
"I<имени-службы>."

#. type: TP
#: man-pages/man5/services.5:106
#, no-wrap
msgid "I<port>"
msgstr "I<порт>"

#. type: Plain text
#: man-pages/man5/services.5:109
msgid "is the port number (in decimal) to use for this service."
msgstr "Номер порта (в десятичном формате), используемый данной службой."

#. type: TP
#: man-pages/man5/services.5:109
#, no-wrap
msgid "I<protocol>"
msgstr "I<протокол>"

#. type: Plain text
#: man-pages/man5/services.5:120
msgid ""
"is the type of protocol to be used.  This field should match an entry in the "
"B<protocols>(5)  file.  Typical values include B<tcp> and B<udp>."
msgstr ""
"Тип протокола, который будет использоваться. Это поле должно совпадать с "
"элементом в файле B<protocols>(5). Обычно, значением является B<tcp> и "
"B<udp>."

#. type: TP
#: man-pages/man5/services.5:120
#, no-wrap
msgid "I<aliases>"
msgstr "I<псевдонимы>"

#. type: Plain text
#: man-pages/man5/services.5:126
msgid ""
"is an optional space or tab separated list of other names for this service.  "
"Again, the names are case sensitive."
msgstr ""
"Дополнительный список имён этой службы, разделённых символами табуляции или "
"пробелами. Снова заметим, что имеет значение регистр символов."

#. type: Plain text
#: man-pages/man5/services.5:128
msgid "Either spaces or tabs may be used to separate the fields."
msgstr ""
"Для разделения полей могут использоваться пробелы или символы табуляции."

#. type: Plain text
#: man-pages/man5/services.5:132
msgid ""
"Comments are started by the hash sign (#) and continue until the end of the "
"line.  Blank lines are skipped."
msgstr ""
"Комментарии начинаются с символа решетки (#) и продолжаются до конца строки. "
"Пустые строки пропускаются."

#. type: Plain text
#: man-pages/man5/services.5:143
msgid ""
"The I<service-name> should begin in the first column of the file, since "
"leading spaces are not stripped.  I<service-names> can be any printable "
"characters excluding space and tab.  However, a conservative choice of "
"characters should be used to minimize compatibility problems.  For example, "
"a-z, 0-9, and hyphen (-) would seem a sensible choice."
msgstr ""
"I<Имя службы> должно начинаться с первого столбца файла, так как начальные "
"пробелы не удаляются В I<имени службы> могут использоваться любые печатные "
"символы (исключая пробелы и символы табуляции). Однако, лучше использовать "
"стандартный набор символов для уменьшения проблем с совместимостью. "
"Например, a-z, 0-9 и дефис (-) наиболее подходящий набор."

#. type: Plain text
#: man-pages/man5/services.5:152
msgid ""
"Lines not matching this format should not be present in the file.  "
"(Currently, they are silently skipped by B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  However, this behavior should "
"not be relied on.)"
msgstr ""
"В файле не должно быть строк в другом формате (в данный момент они просто "
"пропускаются программами B<getservent>(3), B<getservbyname>(3) и "
"B<getservbyport>(3). Однако, на это не стоит полагаться)."

#.  The following is not true as at glibc 2.8 (a line with a comma is
#.  ignored by getservent()); it's not clear if/when it was ever true.
#.    As a backward compatibility feature, the slash (/) between the
#.    .I port
#.    number and
#.    .I protocol
#.    name can in fact be either a slash or a comma (,).
#.    Use of the comma in
#.    modern installations is deprecated.
#. type: Plain text
#: man-pages/man5/services.5:165
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr ""
"Данный файл может распространяться по сети с помощью сетевых служб имён, "
"таких как Yellow Pages/NIS или BIND/Hesiod."

#. type: Plain text
#: man-pages/man5/services.5:169
msgid "A sample B<services> file might look like this:"
msgstr "Пример файла B<services>:"

#. type: Plain text
#: man-pages/man5/services.5:181
#, no-wrap
msgid ""
"netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp\n"
msgstr ""
"netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp\n"

#. type: TP
#: man-pages/man5/services.5:184
#, no-wrap
msgid "I</etc/services>"
msgstr "I</etc/services>"

#. type: Plain text
#: man-pages/man5/services.5:187
msgid "The Internet network services list"
msgstr "список сетевых служб интернет"

#. type: TP
#: man-pages/man5/services.5:187
#, no-wrap
msgid "I<E<lt>netdb.hE<gt>>"
msgstr "I<E<lt>netdb.hE<gt>>"

#.  .SH BUGS
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     There is a maximum of 35 aliases, due to the way the
#.     .BR getservent (3)
#.     code is written.
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     Lines longer than
#.     .B BUFSIZ
#.     (currently 1024) characters will be ignored by
#.     .BR getservent (3),
#.     .BR getservbyname (3),
#.     and
#.     .BR getservbyport (3).
#.     However, this will also cause the next line to be mis-parsed.
#. type: Plain text
#: man-pages/man5/services.5:208
msgid "Definition of B<_PATH_SERVICES>"
msgstr "Определение B<_PATH_SERVICES>"

#. type: Plain text
#: man-pages/man5/services.5:218
msgid ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"
msgstr ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"

#. type: Plain text
#: man-pages/man5/services.5:219
msgid "Assigned Numbers RFC, most recently RFC\\ 1700, (AKA STD0002)."
msgstr "RFC с назначенными номерами, последний RFC\\ 1700, (т.н. STD0002)."

#. type: Plain text
#: man-pages/man5/sysfs.5:28
msgid "sysfs - a filesystem for exporting kernel objects"
msgstr "sysfs - файловая система для экспортируемых объектов ядра"

#. type: Plain text
#: man-pages/man5/sysfs.5:42
msgid ""
"The B<sysfs> filesystem is a pseudo-filesystem which provides an interface "
"to kernel data structures.  (More precisely, the files and directories in "
"B<sysfs> provide a view of the I<kobject> structures defined internally "
"within the kernel.)  The files under B<sysfs> provide information about "
"devices, kernel modules, filesystems, and other kernel components."
msgstr ""
"Файловая система B<sysfs> — это псевдофайловая система, предоставляющая "
"интерфейс к структурам данных ядра (точнее, файлы и каталоги в B<sysfs> "
"позволяют видеть структуры I<kobject>, определённые внутри ядра). Файлы в "
"B<sysfs> показывают информацию об устройствах, модулях ядра, файловых "
"системах и других компонентах ядра."

#. type: Plain text
#: man-pages/man5/sysfs.5:49
msgid ""
"The B<sysfs> filesystem is commonly mounted at I</sys>.  Typically, it is "
"mounted automatically by the system, but it can also be mounted manually "
"using a command such as:"
msgstr ""
"Обычно, файловая система B<sysfs> монтируется в I</sys>. Это выполняется "
"системой автоматически, но также можно монтировать её вручную с помощью "
"команды:"

#. type: Plain text
#: man-pages/man5/sysfs.5:53
#, no-wrap
msgid "mount -t sysfs sysfs /sys\n"
msgstr "mount -t sysfs sysfs /sys\n"

#. type: Plain text
#: man-pages/man5/sysfs.5:63
msgid ""
"Many of the files in the B<sysfs> filesystem are read-only, but some files "
"are writable, allowing kernel variables to be changed.  To avoid redundancy, "
"symbolic links are heavily used to connect entries across the filesystem "
"tree."
msgstr ""
"Многие из файлов файловой системы B<sysfs> доступны только для чтения, но "
"есть и доступные на запись, через которые можно изменять переменные ядра. В "
"целях сокращения избыточности для связи элементов в дереве файловой системы "
"широко применяются символьные ссылки."

#. type: SS
#: man-pages/man5/sysfs.5:63
#, no-wrap
msgid "Files and directories"
msgstr "Файлы и каталоги"

#. type: Plain text
#: man-pages/man5/sysfs.5:67
msgid ""
"The following list describes some of the files and directories under the I</"
"sys> hierarchy."
msgstr ""
"В следующем списке описаны некоторые файлы и каталоги в иерархии I</sys>."

#. type: TP
#: man-pages/man5/sysfs.5:67
#, no-wrap
msgid "I</sys/block>"
msgstr "I</sys/block>"

#. type: Plain text
#: man-pages/man5/sysfs.5:73
msgid ""
"This subdirectory contains one symbolic link for each block device that has "
"been discovered on the system.  The symbolic links point to corresponding "
"directories under I</sys/devices>."
msgstr ""
"В этом подкаталоге содержится по одной символьной ссылке на каждое блочное "
"устройство, обнаруженное в системе. Символьные ссылки указывают на "
"соответствующие каталоги в I</sys/devices>."

#. type: TP
#: man-pages/man5/sysfs.5:73
#, no-wrap
msgid "I</sys/bus>"
msgstr "I</sys/bus>"

#. type: Plain text
#: man-pages/man5/sysfs.5:78
msgid ""
"This directory contains one subdirectory for each of the bus types in the "
"kernel.  Inside each of these directories are two subdirectories:"
msgstr ""
"В этом каталоге содержится по одному подкаталогу на каждый тип шины ядра. "
"Внутри каждого каталога есть два подкаталога:"

#. type: TP
#: man-pages/man5/sysfs.5:79
#, no-wrap
msgid "I<devices>"
msgstr "I<devices>"

#. type: Plain text
#: man-pages/man5/sysfs.5:84
msgid ""
"This subdirectory contains symbolic links to entries in I</sys/devices> that "
"correspond to the devices discovered on this bus."
msgstr ""
"Этот подкаталог содержит символьные ссылки на элементы в I</sys/devices>, "
"которые соответствуют устройствам, обнаруженным на этой шине."

#. type: TP
#: man-pages/man5/sysfs.5:84 man-pages/man5/sysfs.5:249
#, no-wrap
msgid "I<drivers>"
msgstr "I<drivers>"

#. type: Plain text
#: man-pages/man5/sysfs.5:88
msgid ""
"This subdirectory contains one subdirectory for each device driver that is "
"loaded on this bus."
msgstr ""
"Этот подкаталог содержит по одному подкаталогу на каждый драйвер устройства, "
"загруженный для этой шины."

#. type: TP
#: man-pages/man5/sysfs.5:89
#, no-wrap
msgid "I</sys/class>"
msgstr "I</sys/class>"

#. type: Plain text
#: man-pages/man5/sysfs.5:100
msgid ""
"This subdirectory contains a single layer of further subdirectories for each "
"of the device classes that have been registered on the system (e.g., "
"terminals, network devices, block devices, graphics devices, sound devices, "
"and so on).  Inside each of these subdirectories are symbolic links for each "
"of the devices in this class.  These symbolic links refer to entries in the "
"I</sys/devices> directory."
msgstr ""
"Этот подкаталог содержит по одному слою дополнительных подкаталогов на "
"каждый класс устройств, зарегистрированных в системе (например, терминалы, "
"сетевые устройства, блочные устройства, графические устройства, звуковые "
"устройства и т. д.). Внутри каждого из этих подкаталогов находятся "
"символьные ссылки на каждое из устройств этого класса. Данные символьные "
"ссылки указывают на элементы в каталоге I</sys/devices>."

#. type: TP
#: man-pages/man5/sysfs.5:100
#, no-wrap
msgid "I</sys/class/net>"
msgstr "I</sys/class/net>"

#. type: Plain text
#: man-pages/man5/sysfs.5:109
msgid ""
"Each of the entries in this directory is a symbolic link representing one of "
"the real or virtual networking devices that are visible in the network "
"namespace of the process that is accessing the directory.  Each of these "
"symbolic links refers to entries in the I</sys/devices> directory."
msgstr ""
"Каждый элемент этого каталога представляет собой символьную ссылку на одно "
"из  реальных или виртуальных сетевых устройств, видимых в сетевом "
"пространстве имён процесса, обратившегося к каталогу. Эти символьные ссылки "
"указывают на элементы в каталоге I</sys/devices>."

#. type: TP
#: man-pages/man5/sysfs.5:109
#, no-wrap
msgid "I</sys/dev>"
msgstr "I</sys/dev>"

#. type: Plain text
#: man-pages/man5/sysfs.5:130
msgid ""
"This directory contains two subdirectories I<block>/ and I<char/>, "
"corresponding, respectively, to the block and character devices on the "
"system.  Inside each of these subdirectories are symbolic links with names "
"of the form I<major-ID>:I<minor-ID>, where the ID values correspond to the "
"major and minor ID of a specific device.  Each symbolic link points to the "
"B<sysfs> directory for a device.  The symbolic links inside I</sys/dev> thus "
"provide an easy way to look up the B<sysfs> interface using the device IDs "
"returned by a call to B<stat>(2)  (or similar)."
msgstr ""
"Этот каталог содержит два подкаталога — I<block>/ и I<char/>, "
"соответствующие блочным и символьным устройствам в системе. Внутри каждого "
"подкаталога находятся символьные ссылки с именами в виде I<основной-ID>:"
"I<дополнительный-ID>, где значения ID соответствуют основному и "
"дополнительному идентификаторами определённого устройства. Каждая символьная "
"ссылка указывает на каталог B<sysfs> для устройства. Таким образом, "
"символьные ссылки в I</sys/dev> предоставляют простой способ просмотра "
"интерфейса B<sysfs> по идентификаторам устройств, возвращаемых вызовом "
"B<stat>(2) (или подобным)."

#. type: Plain text
#: man-pages/man5/sysfs.5:133
msgid "The following shell session shows an example from I</sys/dev>:"
msgstr "Пример сеанса оболочки с выводом I</sys/dev>:"

#. type: Plain text
#: man-pages/man5/sysfs.5:147
#, no-wrap
msgid ""
"$ B<stat -c \"%t %T\" /dev/null>\n"
"1 3\n"
"$ B<readlink /sys/dev/char/1\\e:3>\n"
"\\&../../devices/virtual/mem/null\n"
"$ B<ls -Fd /sys/devices/virtual/mem/null>\n"
"/sys/devices/virtual/mem/null/\n"
"$ B<ls -d1 /sys/devices/virtual/mem/null/*>\n"
"/sys/devices/virtual/mem/null/dev\n"
"/sys/devices/virtual/mem/null/power/\n"
"/sys/devices/virtual/mem/null/subsystem@\n"
"/sys/devices/virtual/mem/null/uevent\n"
msgstr ""
"$ B<stat -c \"%t %T\" /dev/null>\n"
"1 3\n"
"$ B<readlink /sys/dev/char/1\\e:3>\n"
"\\&../../devices/virtual/mem/null\n"
"$ B<ls -Fd /sys/devices/virtual/mem/null>\n"
"/sys/devices/virtual/mem/null/\n"
"$ B<ls -d1 /sys/devices/virtual/mem/null/*>\n"
"/sys/devices/virtual/mem/null/dev\n"
"/sys/devices/virtual/mem/null/power/\n"
"/sys/devices/virtual/mem/null/subsystem@\n"
"/sys/devices/virtual/mem/null/uevent\n"

#. type: TP
#: man-pages/man5/sysfs.5:149
#, no-wrap
msgid "I</sys/devices>"
msgstr "I</sys/devices>"

#. type: Plain text
#: man-pages/man5/sysfs.5:156
msgid ""
"This is a directory that contains a filesystem representation of the kernel "
"device tree, which is a hierarchy of I<device> structures within the kernel."
msgstr ""
"В данном каталоге содержится представление в виде файловой системы для "
"дерева устройств ядра, которое является иерархией структур I<device> внутри "
"ядра."

#. type: TP
#: man-pages/man5/sysfs.5:156
#, no-wrap
msgid "I</sys/firmware>"
msgstr "I</sys/firmware>"

#. type: Plain text
#: man-pages/man5/sysfs.5:160
msgid ""
"This subdirectory contains interfaces for viewing and manipulating firmware-"
"specific objects and attributes."
msgstr ""
"В этом подкаталоге содержатся интерфейсы для просмотра и изменения объектов "
"и атрибутов микропрограмм."

#. type: TP
#: man-pages/man5/sysfs.5:160
#, no-wrap
msgid "I</sys/fs>"
msgstr "I</sys/fs>"

#. type: Plain text
#: man-pages/man5/sysfs.5:165
msgid ""
"This directory contains subdirectories for some filesystems.  A filesystem "
"will have a subdirectory here only if it chose to explicitly create the "
"subdirectory."
msgstr ""
"В этом каталоге содержатся подкаталоги для некоторых файловых систем. Здесь "
"файловая система будет иметь подкаталог только, если она явно создаст "
"подкаталог."

#. type: TP
#: man-pages/man5/sysfs.5:165
#, no-wrap
msgid "I</sys/fs/cgroup>"
msgstr "I</sys/fs/cgroup>"

#. type: Plain text
#: man-pages/man5/sysfs.5:172
msgid ""
"This directory conventionally is used as a mount point for a B<tmpfs>(5)  "
"filesystem containing mount points for B<cgroups>(7)  filesystems."
msgstr ""
"Обычно, этот каталог используется как точка монтирования файловой системы "
"B<tmpfs>(5), содержащей точки монтирования для файловых систем B<cgroups>(7)."

#. type: TP
#: man-pages/man5/sysfs.5:172
#, no-wrap
msgid "I</sys/fs/smackfs>"
msgstr "I</sys/fs/smackfs>"

#. type: Plain text
#: man-pages/man5/sysfs.5:177
msgid ""
"The directory contains configuration files for the SMACK LSM.  See the "
"kernel source file I<Documentation/admin-guide/LSM/Smack.rst>."
msgstr ""
"В каталоге содержатся файлы настройки SMACK LSM. Смотрите файл исходного "
"кода ядра I<Documentation/admin-guide/LSM/Smack.rst>."

#. type: TP
#: man-pages/man5/sysfs.5:177
#, no-wrap
msgid "I</sys/hypervisor>"
msgstr "I</sys/hypervisor>"

#. type: TP
#: man-pages/man5/sysfs.5:180
#, no-wrap
msgid "I</sys/kernel>"
msgstr "I</sys/kernel>"

#. type: Plain text
#: man-pages/man5/sysfs.5:184
msgid ""
"This subdirectory contains various files and subdirectories that provide "
"information about the running kernel."
msgstr ""
"В этом подкаталоге содержатся различные файлы и подкаталоги, предоставляющие "
"информацию о работающем ядре."

#. type: TP
#: man-pages/man5/sysfs.5:184
#, no-wrap
msgid "I</sys/kernel/cgroup/>"
msgstr "I</sys/kernel/cgroup/>"

#. type: Plain text
#: man-pages/man5/sysfs.5:188
msgid "For information about the files in this directory, see B<cgroups>(7)."
msgstr "Файлы этого каталога описаны в B<cgroups>(7)."

#. type: TP
#: man-pages/man5/sysfs.5:188
#, no-wrap
msgid "I</sys/kernel/debug/tracing>"
msgstr "I</sys/kernel/debug/tracing>"

#. type: Plain text
#: man-pages/man5/sysfs.5:199
msgid ""
"Mount point for the I<tracefs> filesystem used by the kernel's I<ftrace> "
"facility.  (For information on I<ftrace>, see the kernel source file "
"I<Documentation/trace/ftrace.txt>.)"
msgstr ""
"Точка монтирования файловой системы I<tracefs>, используемая свойством ядра "
"I<ftrace> (информацию по I<ftrace> смотрите в файле исходного кода ядра "
"I<Documentation/trace/ftrace.txt>)."

#. type: TP
#: man-pages/man5/sysfs.5:199
#, no-wrap
msgid "I</sys/kernel/mm>"
msgstr "I</sys/kernel/mm>"

#. type: Plain text
#: man-pages/man5/sysfs.5:203
msgid ""
"This subdirectory contains various files and subdirectories that provide "
"information about the kernel's memory management subsystem."
msgstr ""
"В этом подкаталоге содержатся различные файлы и подкаталоги, предоставляющие "
"информацию о подсистеме ядра управления памятью."

#. type: TP
#: man-pages/man5/sysfs.5:203
#, no-wrap
msgid "I</sys/kernel/mm/hugepages>"
msgstr "I</sys/kernel/mm/hugepages>"

#. type: Plain text
#: man-pages/man5/sysfs.5:214
msgid ""
"This subdirectory contains one subdirectory for each of the huge page sizes "
"that the system supports.  The subdirectory name indicates the huge page "
"size (e.g., I<hugepages-2048kB>).  Within each of these subdirectories is a "
"set of files that can be used to view and (in some cases) change settings "
"associated with that huge page size.  For further information, see the "
"kernel source file I<Documentation/admin-guide/mm/hugetlbpage.rst>."
msgstr ""
"Этот подкаталог содержит по одному подкаталогу на каждый размер огромных "
"страниц ядра, поддерживаемых системой. В имени подкаталога показан размер "
"огромной страницы (например, I<hugepages-2048kB>). Внутри каждого "
"подкаталога содержится набор файлов, которые могут быть использованы для "
"просмотра и (в некоторых случаях) изменения настроек, относящихся к размеру "
"огромных страниц. Дополнительную информацию смотрите в файле исходного кода "
"ядра I<Documentation/admin-guide/mm/hugetlbpage.rst>."

#. type: TP
#: man-pages/man5/sysfs.5:214
#, no-wrap
msgid "I</sys/module>"
msgstr "I</sys/module>"

#. type: Plain text
#: man-pages/man5/sysfs.5:220
msgid ""
"This subdirectory contains one subdirectory for each module that is loaded "
"into the kernel.  The name of each directory is the name of the module.  In "
"each of the subdirectories, there may be following files:"
msgstr ""
"Этот подкаталог содержит по одному подкаталогу на каждый модуль, загруженный "
"в ядро. Подкаталоги называются по имени модулей. В каждом подкаталоге могут "
"быть следующие файлы:"

#. type: TP
#: man-pages/man5/sysfs.5:221
#, no-wrap
msgid "I<coresize>"
msgstr "I<coresize>"

#. type: Plain text
#: man-pages/man5/sysfs.5:224 man-pages/man5/sysfs.5:227
#: man-pages/man5/sysfs.5:230 man-pages/man5/sysfs.5:233
#: man-pages/man5/sysfs.5:236 man-pages/man5/sysfs.5:239
#: man-pages/man5/sysfs.5:242 man-pages/man5/sysfs.5:245
msgid "[to be documented]"
msgstr "[Будет описано]"

#. type: TP
#: man-pages/man5/sysfs.5:224
#, no-wrap
msgid "I<initsize>"
msgstr "I<initsize>"

#. type: TP
#: man-pages/man5/sysfs.5:227
#, no-wrap
msgid "I<initstate>"
msgstr "I<initstate>"

#. type: TP
#: man-pages/man5/sysfs.5:230
#, no-wrap
msgid "I<refcnt>"
msgstr "I<refcnt>"

#. type: TP
#: man-pages/man5/sysfs.5:233
#, no-wrap
msgid "I<srcversion>"
msgstr "I<srcversion>"

#. type: TP
#: man-pages/man5/sysfs.5:236
#, no-wrap
msgid "I<taint>"
msgstr "I<taint>"

#. type: TP
#: man-pages/man5/sysfs.5:239
#, no-wrap
msgid "I<uevent>"
msgstr "I<uevent>"

#. type: TP
#: man-pages/man5/sysfs.5:242
#, no-wrap
msgid "I<version>"
msgstr "I<version>"

#. type: Plain text
#: man-pages/man5/sysfs.5:248
msgid "In each of the subdirectories, there may be following subdirectories:"
msgstr "В каждом подкаталоге могут быть следующие подкаталоги:"

#. type: TP
#: man-pages/man5/sysfs.5:252
#, no-wrap
msgid "I<holders>"
msgstr "I<holders>"

#. type: TP
#: man-pages/man5/sysfs.5:255
#, no-wrap
msgid "I<notes>"
msgstr "I<notes>"

#. type: TP
#: man-pages/man5/sysfs.5:258
#, no-wrap
msgid "I<parameters>"
msgstr "I<parameters>"

#. type: Plain text
#: man-pages/man5/sysfs.5:263
msgid ""
"This directory contains one file for each module parameter, with each file "
"containing the value of the corresponding parameter.  Some of these files "
"are writable, allowing the"
msgstr ""
"Этот каталог содержит по одному файлу на каждый параметр модуля; в каждом "
"файле хранится значение соответствующего параметра. Некоторые файлы доступны "
"на запись."

#. type: TP
#: man-pages/man5/sysfs.5:263
#, no-wrap
msgid "I<sections>"
msgstr "I<sections>"

#. type: Plain text
#: man-pages/man5/sysfs.5:267
msgid ""
"This subdirectories contains files with information about module sections.  "
"This information is mainly used for debugging."
msgstr ""
"В этих подкаталогах содержатся файла с информацией о разделах модуля. Эта "
"информацию, в основном, используется для отладки."

#. type: TP
#: man-pages/man5/sysfs.5:267
#, no-wrap
msgid "I<[To be documented]>"
msgstr "I<[Будет описано]>"

#. type: TP
#: man-pages/man5/sysfs.5:271
#, no-wrap
msgid "I</sys/power>"
msgstr "I</sys/power>"

#. type: Plain text
#: man-pages/man5/sysfs.5:278
msgid "The B<sysfs> filesystem first appeared in Linux 2.6.0."
msgstr "Файловая система B<sysfs> впервые появилась в Linux 2.6.0."

#. type: Plain text
#: man-pages/man5/sysfs.5:282
msgid "The B<sysfs> filesystem is Linux-specific."
msgstr "Файловая система B<sysfs> есть только в Linux."

#. type: Plain text
#: man-pages/man5/sysfs.5:285
msgid ""
"This manual page is incomplete, possibly inaccurate, and is the kind of "
"thing that needs to be updated very often."
msgstr ""
"Данная справочная страница неполна, в ней могут быть неточности и является "
"одной из страниц, которую требуется обновлять очень часто."

#. type: Plain text
#: man-pages/man5/sysfs.5:288
msgid "B<proc>(5), B<udev>(7)"
msgstr "B<proc>(5), B<udev>(7)"

#.  https://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf
#. type: Plain text
#: man-pages/man5/sysfs.5:293
msgid ""
"P.\\& Mochel. (2005).  I<The sysfs filesystem>.  Proceedings of the 2005 "
"Ottawa Linux Symposium."
msgstr ""
"P.\\& Mochel. (2005).  I<Файловая система sysfs>. Представлен на симпозиуме "
"Linux в Оттаве в 2005 году."

#. type: Plain text
#: man-pages/man5/sysfs.5:299
msgid ""
"The kernel source file I<Documentation/filesystems/sysfs.txt> and various "
"other files in I<Documentation/ABI> and I<Documentation/*/sysfs.txt>"
msgstr ""
"Файл исходного кода ядра I<Documentation/filesystems/sysfs.txt> и другие "
"различные файлы в I<Documentation/ABI> и I<Documentation/*/sysfs.txt>"

#. type: TH
#: man-pages/man5/shells.5:28
#, no-wrap
msgid "SHELLS"
msgstr "SHELLS"

#. type: Plain text
#: man-pages/man5/shells.5:31
msgid "shells - pathnames of valid login shells"
msgstr "shells - полные имена файлов разрешённых входных оболочек"

#. type: Plain text
#: man-pages/man5/shells.5:37
msgid ""
"I</etc/shells> is a text file which contains the full pathnames of valid "
"login shells.  This file is consulted by B<chsh>(1)  and available to be "
"queried by other programs."
msgstr ""
"I</etc/shells> - это текстовый файл, содержащий полные имена файлов "
"разрешённых входных оболочек. Этот файл учитывается B<chsh>(1)  и может быть "
"затребован другими программами."

#. type: Plain text
#: man-pages/man5/shells.5:43
msgid ""
"Be aware that there are programs which consult this file to find out if a "
"user is a normal user; for example, FTP daemons traditionally disallow "
"access to users with shells not included in this file."
msgstr ""
"Удостоверьтесь, что те программы, которые учитывают этот файл, если "
"пользователь является обычным пользователем; например, службы FTP, обычно, "
"отключают доступ для тех пользователей, входные оболочки которых не указаны "
"в этом файле."

#. type: Plain text
#: man-pages/man5/shells.5:45
msgid "I</etc/shells>"
msgstr "I</etc/shells>"

#. type: Plain text
#: man-pages/man5/shells.5:48
msgid "I</etc/shells> may contain the following paths:"
msgstr "I</etc/shells> может содержать следующие пути:"

#. type: Plain text
#: man-pages/man5/shells.5:54
#, no-wrap
msgid ""
"I</bin/sh>\n"
"I</bin/bash>\n"
"I</bin/csh>\n"
msgstr ""
"I</bin/sh>\n"
"I</bin/bash>\n"
"I</bin/csh>\n"

#. type: Plain text
#: man-pages/man5/shells.5:59
msgid "B<chsh>(1), B<getusershell>(3), B<pam_shells>(8)"
msgstr "B<chsh>(1), B<getusershell>(3), B<pam_shells>(8)"

#. type: TH
#: man-pages/man3/strlen.3:30
#, no-wrap
msgid "STRLEN"
msgstr "STRLEN"

#. type: Plain text
#: man-pages/man3/strlen.3:33
msgid "strlen - calculate the length of a string"
msgstr "strlen - вычисление длины строки"

#. type: Plain text
#: man-pages/man3/strlen.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strlen.3:38
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>\n"
msgstr "B<size_t strlen(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/strlen.3:45
msgid ""
"The B<strlen>()  function calculates the length of the string pointed to by "
"I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""
"Функция B<strlen>() подсчитывает длину строки, на которую указывает I<s>, "
"без учета завершающего байта null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/strlen.3:50
msgid ""
"The B<strlen>()  function returns the number of bytes in the string pointed "
"to by I<s>."
msgstr ""
"Функция B<strlen>() возвращает количество байт в строке, на которую "
"указывает I<s>."

#. type: tbl table
#: man-pages/man3/strlen.3:60
#, no-wrap
msgid "B<strlen>()"
msgstr "B<strlen>()"

#. type: Plain text
#: man-pages/man3/strlen.3:64
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/strlen.3:68
msgid "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"
msgstr "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"

#. type: TH
#: man-pages/man3/shm_open.3:26
#, no-wrap
msgid "SHM_OPEN"
msgstr "SHM_OPEN"

#. type: Plain text
#: man-pages/man3/shm_open.3:29
msgid ""
"shm_open, shm_unlink - create/open or unlink POSIX shared memory objects"
msgstr ""
"shm_open, shm_unlink - создаёт/открывает или удаляет объекты общей памяти "
"POSIX"

#. type: Plain text
#: man-pages/man3/shm_open.3:31
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: man-pages/man3/shm_open.3:33
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr "B<#include E<lt>sys/stat.hE<gt>> /* константы для mode */"

#. type: Plain text
#: man-pages/man3/shm_open.3:35
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr "B<#include E<lt>fcntl.hE<gt>>    /* константы O_* */"

#. type: Plain text
#: man-pages/man3/shm_open.3:37
msgid ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"

#. type: Plain text
#: man-pages/man3/shm_open.3:39
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr "B<int shm_unlink(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man3/shm_open.3:41
msgid "Link with I<-lrt>."
msgstr "Компонуется при указании параметра I<-lrt>."

#. type: Plain text
#: man-pages/man3/shm_open.3:53
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can "
"be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr ""
"Функция B<shm_open>() создаёт и открывает новый (или открывает уже "
"существующий) объект общей памяти POSIX. Объект общей памяти POSIX — это "
"описатель, используемый несвязанными процессами для выполнения B<mmap>(2) "
"для одной области общей памяти. Функция B<shm_unlink>() выполняет обратную "
"операцию, удаляя объект, созданный ранее с помощью B<shm_open>()."

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: man-pages/man3/shm_open.3:74
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name> "
"specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form I</"
"somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr ""
"Действие B<shm_open>() аналогично B<open>(2). Значением I<name> определяется "
"создаваемый или открываемый объект общей памяти. Для использования в "
"переносимых программах объект общей памяти должен опознаваться по имени в "
"виде I</какое_то_имя>, то есть строкой, оканчивающейся null и длиной до "
"I<NAME_MAX> (т.е., 255) символов, состоящей из начальной косой черты и "
"одного или более символов (любых, кроме косой черты)."

#. type: Plain text
#: man-pages/man3/shm_open.3:81
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr ""
"Аргумент I<oflag> содержит маску битов, созданную логическим сложением OR "
"одного из флагов B<O_RDONLY> или B<O_RWDR> и любых других флагов, "
"перечисленных далее:"

#. type: TP
#: man-pages/man3/shm_open.3:81
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: man-pages/man3/shm_open.3:89
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can be B<mmap>(2)ed only for read (B<PROT_READ>)  access."
msgstr ""
"Открыть объект для чтения. Открытый таким образом объект общей памяти можно "
"указывать в B<mmap>(2) только для чтения (B<PROT_READ>)."

#. type: TP
#: man-pages/man3/shm_open.3:89
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: man-pages/man3/shm_open.3:92
msgid "Open the object for read-write access."
msgstr "Открыть объект для чтения и записи."

#. type: TP
#: man-pages/man3/shm_open.3:92
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In truth it is actually the filesystem IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: man-pages/man3/shm_open.3:112
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr ""
"Создать объект общей памяти, если он не существует. Владелец и группа "
"объекта устанавливаются из соответствующих эффективных ID вызвавшего "
"процесса, а биты прав на объект устанавливаются в соответствии с младшими 9 "
"битами I<mode>, за исключением того, что биты, установленные маске режима "
"создания файла (см. B<umask>(2)), очищаются у новых объектов. Набор макросов-"
"констант, используемых для определения I<mode>, описан в B<open>(2). "
"Символические определения этих констант можно получить включением I<E<lt>sys/"
"stat.hE<gt>>."

#. type: Plain text
#: man-pages/man3/shm_open.3:118
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr ""
"Новый объект общей памяти изначально имеет нулевую длину; размер объекта "
"можно установить, используя B<ftruncate>(2). Новые выделенные байты объекта "
"общей памяти автоматически заполняются 0."

#. type: TP
#: man-pages/man3/shm_open.3:118
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: man-pages/man3/shm_open.3:127
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the "
"object, and its creation if it does not exist, are performed atomically."
msgstr ""
"Если также был указан B<O_CREAT> и объект общей памяти с заданным I<name> "
"уже существует, то возвращается ошибка. Проверка существования объекта и его "
"создание, если он не существует, выполняется атомарно."

#. type: TP
#: man-pages/man3/shm_open.3:127
#, no-wrap
msgid "B<O_TRUNC>"
msgstr "B<O_TRUNC>"

#. type: Plain text
#: man-pages/man3/shm_open.3:130
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr "Если объект общей памяти уже существует, то обрезать его до 0 байтов."

#. type: Plain text
#: man-pages/man3/shm_open.3:133
msgid ""
"Definitions of these flag values can be obtained by including I<E<lt>fcntl."
"hE<gt>>."
msgstr ""
"Определения значений этих флагов можно получить включением I<E<lt>fcntl."
"hE<gt>>."

#. type: Plain text
#: man-pages/man3/shm_open.3:144
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr ""
"При успешном выполнении B<shm_open>() возвращает новый файловый дескриптор, "
"ссылающийся на объект общей памяти. Этот файловый дескриптор гарантированно "
"будет дескриптором файла с самым маленьким номером среди ещё не открытых "
"процессом. У дескриптора файла устанавливается флаг B<FD_CLOEXEC> (см. "
"B<fcntl>(2))."

#. type: Plain text
#: man-pages/man3/shm_open.3:153
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)  "
"(for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr ""
"Дескриптор файла обычно используется в последующих вызовах B<ftruncate>(2) "
"(для новых объектов) и B<mmap>(2). После вызова B<mmap>(2) дескриптор файла "
"может быть закрыт без влияния на отображение памяти."

#. type: Plain text
#: man-pages/man3/shm_open.3:171
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a "
"shared memory object name, and, once all processes have unmapped the object, "
"de-allocates and destroys the contents of the associated memory region.  "
"After a successful B<shm_unlink>(), attempts to B<shm_open>()  an object "
"with the same I<name> fail (unless B<O_CREAT> was specified, in which case a "
"new, distinct object is created)."
msgstr ""
"Действие B<shm_unlink>() аналогично B<unlink>(2): оно удаляет имя объекта "
"общей памяти и, как только все процессы завершили работу с объектом и "
"отменили его отображение, очищает пространство и уничтожает связанную с ним "
"область памяти. После успешного выполнения B<shm_unlink>() попытка выполнить "
"B<shm_open>() для объекта с тем же именем I<name> завершается ошибкой (если "
"не был указан B<O_CREAT>, в этом случае создаётся новый, уже другой объект)."

#. type: Plain text
#: man-pages/man3/shm_open.3:180
msgid ""
"On success, B<shm_open>()  returns a nonnegative file descriptor.  On "
"failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns 0 on success, "
"or -1 on error."
msgstr ""
"При успешном выполнении B<shm_open>() возвращает неотрицательный дескриптор "
"файла. При ошибках B<shm_open>() возвращает -1. При успешном выполнении "
"B<shm_unlink>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/shm_open.3:187
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr ""
"При ошибках в I<errno> записываются причины ошибки. Значения I<errno> могут "
"быть такими:"

#. type: Plain text
#: man-pages/man3/shm_open.3:192
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr "Отказ в доступе для B<shm_unlink>() для объекта общей памяти."

#. type: Plain text
#: man-pages/man3/shm_open.3:202
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or "
"B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr ""
"Отказ в доступе для B<shm_open>() с заданным I<name> и режимом I<mode>, или "
"был указан B<O_TRUNC>, а вызывающий не имеет прав на запись для объекта."

#. type: Plain text
#: man-pages/man3/shm_open.3:213
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr ""
"В B<shm_open>() указаны B<O_CREAT> и B<O_EXCL>, но объект общей памяти "
"I<name> уже существует."

#. type: Plain text
#: man-pages/man3/shm_open.3:220
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr "Аргумент I<name> для B<shm_open>() некорректен."

#. type: Plain text
#: man-pages/man3/shm_open.3:229
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr "Длина I<name> превышает B<PATH_MAX>."

#. type: Plain text
#: man-pages/man3/shm_open.3:241
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr ""
"Была сделана попытка выполнить B<shm_open>() для несуществующего I<name> и "
"при этом не был указан B<O_CREAT>."

#. type: Plain text
#: man-pages/man3/shm_open.3:248
msgid ""
"An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr ""
"Была сделана попытка выполнить B<shm_unlink>() для несуществующего I<name>."

#. type: Plain text
#: man-pages/man3/shm_open.3:250
msgid "These functions are provided in glibc 2.2 and later."
msgstr "Эти функции присутствуют в glibc 2.2 и более новых."

#. type: tbl table
#: man-pages/man3/shm_open.3:261
#, no-wrap
msgid ""
"B<shm_open>(),\n"
"B<shm_unlink>()"
msgstr ""
"B<shm_open>(),\n"
"B<shm_unlink>()"

#. type: tbl table
#: man-pages/man3/shm_open.3:261
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: man-pages/man3/shm_open.3:274
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\".  POSIX.1-2008 says that the group ownership may "
"be set to either the calling process's effective group ID or, if the object "
"is visible in the filesystem, the group ID of the parent directory."
msgstr ""
"В POSIX.1-2001 сказано, что группа-владелец нового объекта общей памяти "
"устанавливается или в эффективный ID группы вызвавшего процесса, или «ID "
"системной группы по умолчанию». В POSIX.1-2008 сказано, что группа-владелец "
"может быть установлена или в эффективный ID группы вызвавшего процесса или, "
"если объект видим в файловой системе, ID группы родительского каталога."

#. type: Plain text
#: man-pages/man3/shm_open.3:283
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr ""
"POSIX оставляет неопределённым поведение при комбинации B<O_RDONLY> и "
"B<O_TRUNC>. В Linux это приводит к успешному обрезанию существующего объекта "
"общей памяти, но в других системах UNIX может быть по-другому."

#. type: Plain text
#: man-pages/man3/shm_open.3:289
msgid ""
"The POSIX shared memory object implementation on Linux makes use of a "
"dedicated B<tmpfs>(5)  filesystem that is normally mounted under I</dev/shm>."
msgstr ""
"Реализация объектов общей памяти POSIX в Linux использует выделенную "
"файловую систему B<tmpfs>(5), которая обычно монтируется в I</dev/shm>."

#. type: Plain text
#: man-pages/man3/shm_open.3:300
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<memfd_create>(2), B<mmap>(2), B<open>(2), B<umask>(2), "
"B<shm_overview>(7)"
msgstr ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<memfd_create>(2), B<mmap>(2), B<open>(2), B<umask>(2), "
"B<shm_overview>(7)"

#. type: TH
#: man-pages/man3/strtoul.3:33
#, no-wrap
msgid "STRTOUL"
msgstr "STRTOUL"

#. type: Plain text
#: man-pages/man3/strtoul.3:36
msgid ""
"strtoul, strtoull, strtouq - convert a string to an unsigned long integer"
msgstr ""
"strtoul, strtoull, strtouq - преобразование строки в целое с типом unsigned "
"long integer"

#. type: Plain text
#: man-pages/man3/strtoul.3:39
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:42
#, no-wrap
msgid "B<unsigned long int strtoul(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
msgstr "B<unsigned long int strtoul(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:45
#, no-wrap
msgid ""
"B<unsigned long long int strtoull(const char *>I<nptr>B<, char **>I<endptr>B<,>\n"
"B<                                int >I<base>B<);>\n"
msgstr ""
"B<unsigned long long int strtoull(const char *>I<nptr>B<, char **>I<endptr>B<,>\n"
"B<                                int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:54
msgid "B<strtoull>():"
msgstr "B<strtoull>():"

#. type: Plain text
#: man-pages/man3/strtoul.3:57
#, no-wrap
msgid ""
"_ISOC99_SOURCE ||\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE ||\n"
"    || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:72
msgid ""
"The B<strtoul>()  function converts the initial part of the string in "
"I<nptr> to an I<unsigned long int> value according to the given I<base>, "
"which must be between 2 and 36 inclusive, or be the special value 0."
msgstr ""
"Функция B<strtoul>() преобразует начальную часть строки I<nptr> в число с "
"типом I<unsigned long int> согласно системе счисления I<base>, значение "
"которой может быть от 2 до 36 включительно или равно специальному значению 0."

#. type: Plain text
#: man-pages/man3/strtoul.3:86
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3))  followed by a single optional \\(aq+\\(aq or \\(aq-\\(aq "
"sign.  If I<base> is zero or 16, the string may then include a \"0x\" "
"prefix, and the number will be read in base 16; otherwise, a zero I<base> is "
"taken as 10 (decimal) unless the next character is \\(aq0\\(aq, in which "
"case it is taken as 8 (octal)."
msgstr ""
"Строка может начинаться с произвольного количества пробельных символов "
"(определяемых при помощи B<isspace>(3)), затем может быть указан знак «+» "
"или «-». Если I<base> равно 0 или 16, то строка может начинаться с приставки "
"«0x», что означает использование шестнадцатеричной системы исчисления; "
"иначе, если I<base> равно нулю, то используется десятичная система счисления "
"(кроме, когда последующий символ также равен «0»: в этом случае используется "
"восьмеричная система исчисления)."

#. type: Plain text
#: man-pages/man3/strtoul.3:95
msgid ""
"The remainder of the string is converted to an I<unsigned long int> value in "
"the obvious manner, stopping at the first character which is not a valid "
"digit in the given base.  (In bases above 10, the letter \\(aqA\\(aq in "
"either uppercase or lowercase represents 10, \\(aqB\\(aq represents 11, and "
"so forth, with \\(aqZ\\(aq representing 35.)"
msgstr ""
"Остаток строки преобразуется в число с типом I<unsigned long int>. Этот "
"процесс останавливается, если в строке встречается некорректный символ для "
"указанной системе счисления. В системах счисления больших 10, символ «A» в "
"верхнем или нижнем регистре означает 10, «B» означает 11 и так далее до «Z», "
"означающего 35."

#. type: Plain text
#: man-pages/man3/strtoul.3:116
msgid ""
"If I<endptr> is not NULL, B<strtoul>()  stores the address of the first "
"invalid character in I<*endptr>.  If there were no digits at all, "
"B<strtoul>()  stores the original value of I<nptr> in I<*endptr> (and "
"returns 0).  In particular, if I<*nptr> is not \\(aq\\e0\\(aq but "
"I<**endptr> is \\(aq\\e0\\(aq on return, the entire string is valid."
msgstr ""
"Если значение I<endptr> не NULL, то B<strtoul>() записывает адрес первого "
"некорректного символа в I<*endptr>. Если в строке вообще нет цифр, то "
"B<strtoul>() сохраняет изначальное значение I<nptr> в I<*endptr> (и "
"возвращает 0). В частности, если I<*nptr> не равно \\(aq\\e0\\(aq, но "
"I<**endptr> равно \\(aq\\e0\\(aq при возврате, то вся строка состоит из "
"корректных символов."

#. type: Plain text
#: man-pages/man3/strtoul.3:124
msgid ""
"The B<strtoull>()  function works just like the B<strtoul>()  function but "
"returns an I<unsigned long long int> value."
msgstr ""
"Функция B<strtoull>() работает так же, как и B<strtoul>(), но возвращает "
"число с типом I<unsigned long long int>."

#. type: Plain text
#: man-pages/man3/strtoul.3:145
msgid ""
"The B<strtoul>()  function returns either the result of the conversion or, "
"if there was a leading minus sign, the negation of the result of the "
"conversion represented as an unsigned value, unless the original "
"(nonnegated) value would overflow; in the latter case, B<strtoul>()  returns "
"B<ULONG_MAX> and sets I<errno> to B<ERANGE>.  Precisely the same holds for "
"B<strtoull>()  (with B<ULLONG_MAX> instead of B<ULONG_MAX>)."
msgstr ""
"Функция B<strtoul>() возвращает результат преобразования, либо, если был "
"указан знак минуса, возвращается отрицательный результат преобразования, "
"представленный в виде положительного числа, если изначальное "
"(неотрицательное) значение не вызывает переполнения; в этом случае "
"B<strtoul>() возвращает B<ULONG_MAX>, а переменной I<errno> присваивается "
"значение B<ERANGE>. То же самое относится к B<strtoull>(), только вместо "
"B<ULONG_MAX> возвращается B<ULLONG_MAX>."

#. type: Plain text
#: man-pages/man3/strtoul.3:152
msgid "(not in C99)  The given I<base> contains an unsupported value."
msgstr "(нет в C99) Аргумент I<base> содержит неподдерживаемое значение."

#. type: Plain text
#: man-pages/man3/strtoul.3:155
msgid "The resulting value was out of range."
msgstr "Полученное значение вне диапазона."

#. type: Plain text
#: man-pages/man3/strtoul.3:162
msgid ""
"The implementation may also set I<errno> to B<EINVAL> in case no conversion "
"was performed (no digits seen, and 0 returned)."
msgstr ""
"Реализация может также устанавливать I<errno> в B<EINVAL> в случае, когда "
"преобразование не было выполнено (не было встречено цифр и возвращён 0)."

#. type: tbl table
#: man-pages/man3/strtoul.3:174
#, no-wrap
msgid ""
"B<strtoul>(),\n"
"B<strtoull>(),\n"
"B<strtouq>()"
msgstr ""
"B<strtoul>(),\n"
"B<strtoull>(),\n"
"B<strtouq>()"

#. type: Plain text
#: man-pages/man3/strtoul.3:179
msgid "B<strtoul>(): POSIX.1-2001, POSIX.1-2008, C89, C99 SVr4."
msgstr "B<strtoul>(): POSIX.1-2001, POSIX.1-2008, C89, C99 SVr4."

#. type: Plain text
#: man-pages/man3/strtoul.3:182
msgid "B<strtoull>(): POSIX.1-2001, POSIX.1-2008, C99."
msgstr "B<strtoull>(): POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/strtoul.3:196
msgid ""
"Since B<strtoul>()  can legitimately return 0 or B<ULONG_MAX> (B<ULLONG_MAX> "
"for B<strtoull>())  on both success and failure, the calling program should "
"set I<errno> to 0 before the call, and then determine if an error occurred "
"by checking whether I<errno> has a nonzero value after the call."
msgstr ""
"Так как B<strtoul>() может обоснованно вернуть 0 или B<ULONG_MAX> "
"(B<ULLONG_MAX> для B<strtoull>()) при успешном выполнении и ошибке, "
"вызывающая программа до вызова должна присвоить I<errno> значение 0, а после "
"вызова определить возникновение ошибки по ненулевому значению I<errno>."

#. type: Plain text
#: man-pages/man3/strtoul.3:200
msgid ""
"In locales other than the \"C\" locale, other strings may be accepted.  (For "
"example, the thousands separator of the current locale may be supported.)"
msgstr ""
"При помощи локалей могут приниматься строки, отличные от допустимых в локали "
"«C» (например, может поддерживаться разделитель тысяч из текущей локали)."

#. type: Plain text
#: man-pages/man3/strtoul.3:202
msgid "BSD also has"
msgstr "В BSD также есть функция "

#. type: Plain text
#: man-pages/man3/strtoul.3:206
#, no-wrap
msgid "B<u_quad_t strtouq(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
msgstr "B<u_quad_t strtouq(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:215
msgid ""
"with completely analogous definition.  Depending on the wordsize of the "
"current architecture, this may be equivalent to B<strtoull>()  or to "
"B<strtoul>()."
msgstr ""
"с полностью аналогичным определением. В зависимости от длины слова в текущей "
"архитектуре, она может быть аналогом B<strtoull>() или B<strtoul>()."

#. type: Plain text
#: man-pages/man3/strtoul.3:220
msgid ""
"Negative values are considered valid input and are silently converted to the "
"equivalent I<unsigned long int> value."
msgstr ""
"Отрицательные значения допустимы во входных данных и без ошибки "
"преобразуются в эквивалентное значение с типом I<unsigned long int>."

#. type: Plain text
#: man-pages/man3/strtoul.3:225
msgid ""
"See the example on the B<strtol>(3)  manual page; the use of the functions "
"described in this manual page is similar."
msgstr ""
"Пример можно найти в справочной странице B<strtol>(3); в ней показано "
"использование похожих функций."

#. type: Plain text
#: man-pages/man3/strtoul.3:232
msgid ""
"B<a64l>(3), B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoumax>(3)"
msgstr ""
"B<a64l>(3), B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoumax>(3)"

#. type: TH
#: man-pages/man3/setbuf.3:48
#, no-wrap
msgid "SETBUF"
msgstr "SETBUF"

#. type: Plain text
#: man-pages/man3/setbuf.3:51
msgid "setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations"
msgstr ""
"setbuf, setbuffer, setlinebuf, setvbuf - операции с буферизацией потока"

#. type: Plain text
#: man-pages/man3/setbuf.3:54
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:56
#, no-wrap
msgid "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"
msgstr "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:58
#, no-wrap
msgid "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:60
#, no-wrap
msgid "B<void setlinebuf(FILE *>I<stream>B<);>\n"
msgstr "B<void setlinebuf(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:63
#, no-wrap
msgid "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"
msgstr "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:76
#, no-wrap
msgid ""
"B<setbuffer>(),\n"
"B<setlinebuf>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<setbuffer>(),\n"
"B<setlinebuf>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:89
msgid ""
"The three types of buffering available are unbuffered, block buffered, and "
"line buffered.  When an output stream is unbuffered, information appears on "
"the destination file or terminal as soon as written; when it is block "
"buffered many characters are saved up and written as a block; when it is "
"line buffered characters are saved up until a newline is output or input is "
"read from any stream attached to a terminal device (typically I<stdin>).  "
"The function B<fflush>(3)  may be used to force the block out early.  (See "
"B<fclose>(3).)"
msgstr ""
"Существует три типа буферизации: отсутствие буферизации, блочная буферизация "
"и строковая буферизация. Когда выходной поток не буферизируется, то "
"информация незамедлительно оказывается на терминале или в файле назначения; "
"при блочной буферизации сначала сохраняется большое количество символов, а "
"затем они записываются за один раз; при строковой буферизации все символы "
"сохраняются в буфере до появления символа перевода строки при выводе или при "
"вводе из любого потока, подключённого к устройству терминала (обычно, "
"I<stdin>). Функцию B<fflush>(3) можно использовать для досрочного окончания "
"блочной буферизации (смотрите B<fclose>(3))."

#. type: Plain text
#: man-pages/man3/setbuf.3:97
msgid ""
"Normally all files are block buffered.  If a stream refers to a terminal (as "
"I<stdout> normally does), it is line buffered.  The standard error stream "
"I<stderr> is always unbuffered by default."
msgstr ""
"Обычно, для файлов включена блочная буферизация. Если поток ссылается на "
"терминал (обычно для I<stdout>), то он буферизируется построчно. Стандартный "
"поток ошибок I<stderr> по умолчанию никогда не буферизируется."

#. type: Plain text
#: man-pages/man3/setbuf.3:104
msgid ""
"The B<setvbuf>()  function may be used on any open stream to change its "
"buffer.  The I<mode> argument must be one of the following three macros:"
msgstr ""
"Функция B<setvbuf>() может быть использована для изменения типа буферизации "
"любого открытого потока. Параметр I<mode> должен быть одним из трёх "
"следующих макросов:"

#. type: TP
#: man-pages/man3/setbuf.3:105
#, no-wrap
msgid "B<_IONBF>"
msgstr "B<_IONBF>"

#. type: Plain text
#: man-pages/man3/setbuf.3:108
msgid "unbuffered"
msgstr "отключить буферизацию"

#. type: TP
#: man-pages/man3/setbuf.3:108
#, no-wrap
msgid "B<_IOLBF>"
msgstr "B<_IOLBF>"

#. type: Plain text
#: man-pages/man3/setbuf.3:111
msgid "line buffered"
msgstr "строковая буферизация"

#. type: TP
#: man-pages/man3/setbuf.3:111
#, no-wrap
msgid "B<_IOFBF>"
msgstr "B<_IOFBF>"

#. type: Plain text
#: man-pages/man3/setbuf.3:114
msgid "fully buffered"
msgstr "полная буферизация"

#. type: Plain text
#: man-pages/man3/setbuf.3:130
msgid ""
"Except for unbuffered files, the I<buf> argument should point to a buffer at "
"least I<size> bytes long; this buffer will be used instead of the current "
"buffer.  If the argument I<buf> is NULL, only the mode is affected; a new "
"buffer will be allocated on the next read or write operation.  The "
"B<setvbuf>()  function may be used only after opening a stream and before "
"any other operations have been performed on it."
msgstr ""
"За исключением небуферизованных файлов аргумент I<buf> должен указывать на "
"буфер размером, как минимум, I<size> байт; этот буфер будет использоваться "
"вместо текущего. Если аргумент I<buf> равен NULL, то это отразится только на "
"типе буферизации; при следующей операции чтения или записи будет создан "
"новый буфер. Функция B<setvbuf>() может быть использована только после "
"открытия потока и до выполнения над ним любых операций."

#. type: Plain text
#: man-pages/man3/setbuf.3:136
msgid ""
"The other three calls are, in effect, simply aliases for calls to "
"B<setvbuf>().  The B<setbuf>()  function is exactly equivalent to the call"
msgstr ""
"Остальные три вызова, фактически, являются псевдонимами вызова B<setvbuf>(). "
"Функция B<setbuf>() в точности соответствует вызову"

#. type: Plain text
#: man-pages/man3/setbuf.3:139
msgid "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"
msgstr "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"

#. type: Plain text
#: man-pages/man3/setbuf.3:149
msgid ""
"The B<setbuffer>()  function is the same, except that the size of the buffer "
"is up to the caller, rather than being determined by the default B<BUFSIZ>.  "
"The B<setlinebuf>()  function is exactly equivalent to the call:"
msgstr ""
"Функция B<setbuffer>() также аналогична ей, но размер буфера в данном случае "
"определяется вызывающим, а не размером по умолчанию B<BUFSIZ>. Функция "
"B<setlinebuf>() полностью идентична вызову"

#. type: Plain text
#: man-pages/man3/setbuf.3:152
msgid "setvbuf(stream, NULL, _IOLBF, 0);"
msgstr "setvbuf(stream, NULL, _IOLBF, 0);"

#. type: Plain text
#: man-pages/man3/setbuf.3:163
msgid ""
"The function B<setvbuf>()  returns 0 on success.  It returns nonzero on "
"failure (I<mode> is invalid or the request cannot be honored).  It may set "
"I<errno> on failure."
msgstr ""
"Функция B<setvbuf>() возвращает 0 при нормальном завершении работы. При "
"ошибках она возвращает ненулевое значение (некорректное значение I<mode> или "
"запрос невозможно выполнить). При ошибках может быть соответственно изменено "
"значение I<errno>."

#. type: Plain text
#: man-pages/man3/setbuf.3:165
msgid "The other functions do not return a value."
msgstr "Другие функции не возвращают никаких значений."

#. type: tbl table
#: man-pages/man3/setbuf.3:176
#, no-wrap
msgid ""
"B<setbuf>(),\n"
"B<setbuffer>(),\n"
msgstr ""
"B<setbuf>(),\n"
"B<setbuffer>(),\n"

#. type: tbl table
#: man-pages/man3/setbuf.3:179
#, no-wrap
msgid ""
"B<setlinebuf>(),\n"
"B<setvbuf>()"
msgstr ""
"B<setlinebuf>(),\n"
"B<setvbuf>()"

#. type: Plain text
#: man-pages/man3/setbuf.3:187
msgid "The B<setbuf>()  and B<setvbuf>()  functions conform to C89 and C99."
msgstr "Функции B<setbuf>() и B<setvbuf>() соответствуют стандарту C89 и C99."

#. type: Plain text
#: man-pages/man3/setbuf.3:204
msgid ""
"You must make sure that the space that I<buf> points to still exists by the "
"time I<stream> is closed, which also happens at program termination.  For "
"example, the following is invalid:"
msgstr ""
"Вы должны удостовериться, что пространство, на которое указывает I<buf>, всё "
"ещё существует, в то время как I<stream> закрыт, что обычно случается при "
"закрытии программы. Например, следующее будет неправильным:"

#. type: Plain text
#: man-pages/man3/setbuf.3:207
#, no-wrap
msgid "#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:216
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:225
msgid ""
"B<stdbuf>(1), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), "
"B<malloc>(3), B<printf>(3), B<puts>(3)"
msgstr ""
"B<stdbuf>(1), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), "
"B<malloc>(3), B<printf>(3), B<puts>(3)"

#. type: TH
#: man-pages/man3/strerror.3:39
#, no-wrap
msgid "STRERROR"
msgstr "STRERROR"

#. type: Plain text
#: man-pages/man3/strerror.3:42
msgid ""
"strerror, strerror_r, strerror_l - return string describing error number"
msgstr ""
"strerror, strerror_r, strerror_l - возвращают строку описания номера ошибки"

#. type: Plain text
#: man-pages/man3/strerror.3:47
#, no-wrap
msgid "B<char *strerror(int >I<errnum>B<);>\n"
msgstr "B<char *strerror(int >I<errnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/strerror.3:50
#, no-wrap
msgid ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"
msgstr ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-совместимо */\n"

#. type: Plain text
#: man-pages/man3/strerror.3:53
#, no-wrap
msgid ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* GNU-specific */\n"
msgstr ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* есть только в GNU */\n"

#. type: Plain text
#: man-pages/man3/strerror.3:55
#, no-wrap
msgid "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"
msgstr "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"

#. type: Plain text
#: man-pages/man3/strerror.3:64
msgid "B<strerror_r>():"
msgstr "B<strerror_r>():"

#. type: Plain text
#: man-pages/man3/strerror.3:66
msgid "The XSI-compliant version is provided if:"
msgstr "Совместимая с XSI версия предоставляется если:"

#. type: Plain text
#: man-pages/man3/strerror.3:68
msgid "(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L) && ! \\ _GNU_SOURCE"
msgstr "(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L) && ! \\ _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/strerror.3:70
msgid "Otherwise, the GNU-specific version is provided."
msgstr "В противном случае предоставляется версия GNU."

#. type: Plain text
#: man-pages/man3/strerror.3:95
msgid ""
"The B<strerror>()  function returns a pointer to a string that describes the "
"error code passed in the argument I<errnum>, possibly using the "
"B<LC_MESSAGES> part of the current locale to select the appropriate "
"language.  (For example, if I<errnum> is B<EINVAL>, the returned description "
"will be \"Invalid argument\".)  This string must not be modified by the "
"application, but may be modified by a subsequent call to B<strerror>()  or "
"B<strerror_l>().  No other library function, including B<perror>(3), will "
"modify this string."
msgstr ""
"Функция B<strerror>() возвращает указатель на строку, которая описывает код "
"ошибки, переданный в аргументе I<errnum>, возможно, с помощью части "
"B<LC_MESSAGES> текущей локали для выбора соответствующего языка (например, "
"если I<errnum> равно B<EINVAL>, то возвращается описание «Invalid "
"argument»). Эту строку нельзя изменять в приложении, она может измениться "
"при последующих вызовах B<strerror>() или B<strerror_l>(). Другие "
"библиотечные функции, включая B<perror>(3), не изменяют эту строку."

#. type: SS
#: man-pages/man3/strerror.3:95
#, no-wrap
msgid "strerror_r()"
msgstr "strerror_r()"

#. type: Plain text
#: man-pages/man3/strerror.3:116
msgid ""
"The B<strerror_r>()  function is similar to B<strerror>(), but is thread "
"safe.  This function is available in two versions: an XSI-compliant version "
"specified in POSIX.1-2001 (available since glibc 2.3.4, but not POSIX-"
"compliant until glibc 2.13), and a GNU-specific version (available since "
"glibc 2.0).  The XSI-compliant version is provided with the feature test "
"macros settings shown in the SYNOPSIS; otherwise the GNU-specific version is "
"provided.  If no feature test macros are explicitly defined, then (since "
"glibc 2.4)  B<_POSIX_C_SOURCE> is defined by default with the value 200112L, "
"so that the XSI-compliant version of B<strerror_r>()  is provided by default."
msgstr ""
"Функция B<strerror_r>() подобна B<strerror>(), но её можно безопасно "
"использовать в нитях. Она доступна в двух версиях: версия, совместимая с "
"XSI, определена в POSIX.1-2001 (доступна в glibc начиная с 2.3.4, но не "
"совместима с POSIX до glibc 2.13) и версия, совместимая с GNU (доступна, "
"начиная с glibc 2.0). Версия, совместимая с XSI, предоставляется при наличии "
"набора макросов тестирования свойств, показанных в ОБЗОРЕ; в противном "
"случае предоставляется версия GNU. Если макросы тестирования свойств не "
"указаны явным образом, то (начиная с glibc 2.4) по умолчанию определяется "
"B<_POSIX_C_SOURCE> со значением 200112L, то есть версия B<strerror_r>() XSI "
"предоставляется по умолчанию."

#. type: Plain text
#: man-pages/man3/strerror.3:124
msgid ""
"The XSI-compliant B<strerror_r>()  is preferred for portable applications.  "
"It returns the error string in the user-supplied buffer I<buf> of length "
"I<buflen>."
msgstr ""
"Совместимая с XSI версия B<strerror_r>() более предпочтительна для "
"переносимых приложений. Она возвращает строку ошибки в предоставляемом "
"пользователем буфере I<buf> длиной I<buflen>."

#. type: Plain text
#: man-pages/man3/strerror.3:145
msgid ""
"The GNU-specific B<strerror_r>()  returns a pointer to a string containing "
"the error message.  This may be either a pointer to a string that the "
"function stores in I<buf>, or a pointer to some (immutable) static string "
"(in which case I<buf> is unused).  If the function stores a string in "
"I<buf>, then at most I<buflen> bytes are stored (the string may be truncated "
"if I<buflen> is too small and I<errnum> is unknown).  The string always "
"includes a terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""
"Специальная GNU-версия B<strerror_r>() возвращает строку, содержащую "
"сообщение об ошибке. Это может быть или указатель на строку, которую функция "
"записывает в I<buf>, или указатель на некую (неизменную) статическую строку "
"(в этом случае I<buf> не используется). Если функция сохраняет строку в "
"I<buf>, то сохраняется не более I<buflen> байт (строка может быть обрезана, "
"если значение I<buflen> слишком мало и I<errnum> неизвестно). В строке "
"всегда содержится конечный байт null (\\(aq\\e0\\(aq)."

#. type: SS
#: man-pages/man3/strerror.3:145
#, no-wrap
msgid "strerror_l()"
msgstr "strerror_l()"

#. type: Plain text
#: man-pages/man3/strerror.3:160
msgid ""
"B<strerror_l>()  is like B<strerror>(), but maps I<errnum> to a locale-"
"dependent error message in the locale specified by I<locale>.  The behavior "
"of B<strerror_l>()  is undefined if I<locale> is the special locale object "
"B<LC_GLOBAL_LOCALE> or is not a valid locale object handle."
msgstr ""
"Функция B<strerror_l>() подобна B<strerror>(), но отражает I<errnum> в "
"локале-зависимое сообщение об ошибке, в зависимости от локали, заданной в "
"I<locale>. Поведение B<strerror_l>() не определено, если значение I<locale> "
"равно специальному объекту локали B<LC_GLOBAL_LOCALE> или некорректному "
"описателю объекта локали."

#. type: Plain text
#: man-pages/man3/strerror.3:169
msgid ""
"The B<strerror>(), B<strerror_l>(), and the GNU-specific B<strerror_r>()  "
"functions return the appropriate error description string, or an \"Unknown "
"error nnn\" message if the error number is unknown."
msgstr ""
"Функции B<strerror>(), B<strerror_l>() и GNU-версия B<strerror_r>() "
"возвращают соответствующую строку описания ошибки или сообщение «Unknown "
"error nnn», если номер ошибки неизвестен."

#. type: Plain text
#: man-pages/man3/strerror.3:178
msgid ""
"The XSI-compliant B<strerror_r>()  function returns 0 on success.  On error, "
"a (positive) error number is returned (since glibc 2.13), or -1 is returned "
"and I<errno> is set to indicate the error (glibc versions before 2.13)."
msgstr ""
"При успешном выполнении совместимая с XSI функция B<strerror_r>() возвращает "
"0. При ошибке возвращается (положительный) номер ошибки (начиная с glibc "
"2.13), или -1 с изменением I<errno> на соответствующий код ошибки (версии "
"glibc до 2.13)."

#. type: Plain text
#: man-pages/man3/strerror.3:193
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that a successful call to "
"B<strerror>()  or B<strerror_l>()  shall leave I<errno> unchanged, and note "
"that, since no function return value is reserved to indicate an error, an "
"application that wishes to check for errors should initialize I<errno> to "
"zero before the call, and then check I<errno> after the call."
msgstr ""
"В POSIX.1-2001 и POSIX.1-2008 требуется, чтобы успешный вызов B<strerror>() "
"или B<strerror_l>() не изменял I<errno>, и отмечается, что так как для "
"указания на ошибку не зарезервировано возвращаемого значения, в приложениях "
"для проверки ошибки нужно инициализировать I<errno> нулём до вызова и "
"проверять I<errno> после вызова."

#. type: Plain text
#: man-pages/man3/strerror.3:199
msgid "The value of I<errnum> is not a valid error number."
msgstr "Значение I<errnum> не является допустимым номером ошибки."

#. type: Plain text
#: man-pages/man3/strerror.3:202
msgid ""
"Insufficient storage was supplied to contain the error description string."
msgstr "Предоставлено недостаточно места для сохранения описания ошибки."

#. type: Plain text
#: man-pages/man3/strerror.3:206
msgid "The B<strerror_l>()  function first appeared in glibc 2.6."
msgstr "Функция B<strerror_l>() впервые появилась в glibc 2.6."

#. type: tbl table
#: man-pages/man3/strerror.3:216
#, no-wrap
msgid "B<strerror>()"
msgstr "B<strerror>()"

#. type: tbl table
#: man-pages/man3/strerror.3:216
#, no-wrap
msgid "MT-Unsafe race:strerror"
msgstr "MT-Unsafe race:strerror"

#. type: tbl table
#: man-pages/man3/strerror.3:219
#, no-wrap
msgid "B<strerror_r>(),\n"
msgstr "B<strerror_r>(),\n"

#. type: tbl table
#: man-pages/man3/strerror.3:221
#, no-wrap
msgid "B<strerror_l>()"
msgstr "B<strerror_l>()"

#.  FIXME . for later review when Issue 8 is one day released...
#.  A future POSIX.1 may remove strerror_r()
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=508
#. type: Plain text
#: man-pages/man3/strerror.3:232
msgid ""
"B<strerror>()  is specified by POSIX.1-2001, POSIX.1-2008, C89, and C99.  "
"B<strerror_r>()  is specified by POSIX.1-2001 and POSIX.1-2008."
msgstr ""
"Функция B<strerror>() определена в POSIX.1-2001, POSIX.1-2008, C89 и C99. "
"Функция B<strerror_r>() определена в POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/strerror.3:235
msgid "B<strerror_l>()  is specified in POSIX.1-2008."
msgstr "Функция B<strerror_l>() описана в POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/strerror.3:239
msgid "The GNU-specific B<strerror_r>()  function is a nonstandard extension."
msgstr "Функция GNU B<strerror_r>() является нестандартизованным расширением."

#.  e.g., Solaris 8, HP-UX 11
#.  e.g., FreeBSD 5.4, Tru64 5.1B
#. type: Plain text
#: man-pages/man3/strerror.3:259
msgid ""
"POSIX.1-2001 permits B<strerror>()  to set I<errno> if the call encounters "
"an error, but does not specify what value should be returned as the function "
"result in the event of an error.  On some systems, B<strerror>()  returns "
"NULL if the error number is unknown.  On other systems, B<strerror>()  "
"returns a string something like \"Error nnn occurred\" and sets I<errno> to "
"B<EINVAL> if the error number is unknown.  C99 and POSIX.1-2008 require the "
"return value to be non-NULL."
msgstr ""
"В POSIX.1-2001 разрешено B<strerror>() изменять I<errno>, если при вызове "
"возникла ошибка, но не указано какое значение нужно возвращать в качестве "
"результата функции. В некоторых системах B<strerror>() возвращает NULL, если "
"номер ошибки неизвестен. В других системах B<strerror>() возвращает строку "
"вроде «Error nnn occurred» и записывает в I<errno> значение B<EINVAL>, если "
"номер ошибки неизвестен. В C99 и POSIX.1-2008 требуется, чтобы возвращаемое "
"значение не было равно NULL."

#. type: Plain text
#: man-pages/man3/strerror.3:266
msgid ""
"The GNU C Library uses a buffer of 1024 characters for B<strerror>().  This "
"buffer size therefore should be sufficient to avoid an B<ERANGE> error when "
"calling B<strerror_r>()."
msgstr ""
"В библиотеке GNU C для B<strerror>() используется буфер в 1024 символов. "
"Размер буфера должен быть достаточным для исключения возникновения ошибки "
"B<ERANGE> при вызове B<strerror_r>()."

#. type: Plain text
#: man-pages/man3/strerror.3:272
msgid ""
"B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), "
"B<locale>(7)"
msgstr ""
"B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), "
"B<locale>(7)"

#. type: TH
#: man-pages/man3/stdio_ext.3:25
#, no-wrap
msgid "STDIO_EXT"
msgstr "STDIO_EXT"

#. type: TH
#: man-pages/man3/stdio_ext.3:25
#, no-wrap
msgid "2015-03-02"
msgstr "2015-03-02"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:30
msgid ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - interfaces to stdio FILE "
"structure"
msgstr ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - интерфейс к структуре "
"stdio FILE"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:34
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:45
#, no-wrap
msgid ""
"B<size_t __fbufsize(FILE *>I<stream>B<);>\n"
"B<size_t __fpending(FILE *>I<stream>B<);>\n"
"B<int __flbf(FILE *>I<stream>B<);>\n"
"B<int __freadable(FILE *>I<stream>B<);>\n"
"B<int __fwritable(FILE *>I<stream>B<);>\n"
"B<int __freading(FILE *>I<stream>B<);>\n"
"B<int __fwriting(FILE *>I<stream>B<);>\n"
"B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>\n"
"B<void _flushlbf(void);>\n"
"B<void __fpurge(FILE *>I<stream>B<);>\n"
msgstr ""
"B<size_t __fbufsize(FILE *>I<stream>B<);>\n"
"B<size_t __fpending(FILE *>I<stream>B<);>\n"
"B<int __flbf(FILE *>I<stream>B<);>\n"
"B<int __freadable(FILE *>I<stream>B<);>\n"
"B<int __fwritable(FILE *>I<stream>B<);>\n"
"B<int __freading(FILE *>I<stream>B<);>\n"
"B<int __fwriting(FILE *>I<stream>B<);>\n"
"B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>\n"
"B<void _flushlbf(void);>\n"
"B<void __fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:51
msgid ""
"Solaris introduced routines to allow portable access to the internals of the "
"I<FILE> structure, and glibc also implemented these."
msgstr ""
"В Solaris были представлены процедуры, представляющие переносимый способ "
"доступа к внутренностям структуры I<FILE>, в glibc они также реализованы."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:56
msgid ""
"The B<__fbufsize>()  function returns the size of the buffer currently used "
"by the given stream."
msgstr ""
"Функция B<__fbufsize>() возвращает размер буфера, использующегося в данным "
"момент указанным потоком."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:63
msgid ""
"The B<__fpending>()  function returns the number of bytes in the output "
"buffer.  For wide-oriented streams the unit is wide characters.  This "
"function is undefined on buffers in reading mode, or opened read-only."
msgstr ""
"Функция B<__fpending>() возвращает количество байт в буфере вывода. В "
"потоках с широкими символами единицей является широкий символ. Эта функция "
"не определена для буферов, находящихся в процессе чтения, или открытых в "
"режиме только для чтения."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:68
msgid ""
"The B<__flbf>()  function returns a nonzero value if the stream is line-"
"buffered, and zero otherwise."
msgstr ""
"Функция B<__flbf>() возвращает ненулевое значение, если поток буферизируется "
"построчно, и ноль в противном случае."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:73
msgid ""
"The B<__freadable>()  function returns a nonzero value if the stream allows "
"reading, and zero otherwise."
msgstr ""
"Функция B<__freadable>() возвращает ненулевое значение, если поток доступен "
"для чтения, и ноль в противном случае."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:78
msgid ""
"The B<__fwritable>()  function returns a nonzero value if the stream allows "
"writing, and zero otherwise."
msgstr ""
"Функция B<__fwritable>() возвращает ненулевое значение, если поток доступен "
"для записи, и ноль в противном случае."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:84
msgid ""
"The B<__freading>()  function returns a nonzero value if the stream is read-"
"only, or if the last operation on the stream was a read operation, and zero "
"otherwise."
msgstr ""
"Функция B<__freading>() возвращает ненулевое значение, если поток доступен "
"только для чтения, или если последняя операция с потоком была операцией "
"чтения, и ноль в противном случае."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:90
msgid ""
"The B<__fwriting>()  function returns a nonzero value if the stream is write-"
"only (or append-only), or if the last operation on the stream was a write "
"operation, and zero otherwise."
msgstr ""
"Функция B<__fwriting>() возвращает ненулевое значение, если поток доступен "
"только для записи (или открыт только для добавления), или если последняя "
"операция с потоком была операцией записи, и ноль в противном случае."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:98
msgid ""
"The B<__fsetlocking>()  function can be used to select the desired type of "
"locking on the stream.  It returns the current type.  The I<type> argument "
"can take the following three values:"
msgstr ""
"Функция B<__fsetlocking>() может быть использована для выбора желаемого типа "
"блокировки потока. Она возвращает текущий тип. В аргументе I<type> может "
"быть указано одно из трёх значений:"

#. type: TP
#: man-pages/man3/stdio_ext.3:98
#, no-wrap
msgid "B<FSETLOCKING_INTERNAL>"
msgstr "B<FSETLOCKING_INTERNAL>"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:103
msgid ""
"Perform implicit locking around every operation on the given stream (except "
"for the *_unlocked ones).  This is the default."
msgstr ""
"Выполнять неявную блокировку при каждой операции с заданным потоком (за "
"исключением *_unlocked). Действует по умолчанию."

#. type: TP
#: man-pages/man3/stdio_ext.3:103
#, no-wrap
msgid "B<FSETLOCKING_BYCALLER>"
msgstr "B<FSETLOCKING_BYCALLER>"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:110
msgid ""
"The caller will take care of the locking (possibly using B<flockfile>(3)  in "
"case there is more than one thread), and the stdio routines will not do "
"locking until the state is reset to B<FSETLOCKING_INTERNAL>."
msgstr ""
"Вызывающий сам выполняет блокировку (возможно, с помощью B<flockfile>(3), "
"если есть несколько нитей), и процедуры stdio не выполняют блокировки до тех "
"пор, пока состояние не сбросится в B<FSETLOCKING_INTERNAL>."

#. type: TP
#: man-pages/man3/stdio_ext.3:110
#, no-wrap
msgid "B<FSETLOCKING_QUERY>"
msgstr "B<FSETLOCKING_QUERY>"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:114
msgid "Don't change the type of locking.  (Only return it.)"
msgstr "Не изменять тип блокировки (только вернуть текущий)."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:120
msgid ""
"The B<_flushlbf>()  function flushes all line-buffered streams.  (Presumably "
"so that output to a terminal is forced out, say before reading keyboard "
"input.)"
msgstr ""
"Функция B<_flushlbf>() сбрасывает (flushes) все буферизируемые построчно "
"потоки (например для того, чтобы вывести всё на терминал перед чтением ввода "
"с клавиатуры)."

#. type: Plain text
#: man-pages/man3/stdio_ext.3:124
msgid ""
"The B<__fpurge>()  function discards the contents of the stream's buffer."
msgstr "Функция B<__fpurge>()  удаляет содержимое поточного буфера."

#. type: tbl table
#: man-pages/man3/stdio_ext.3:135
#, no-wrap
msgid ""
"B<__fbufsize>(),\n"
"B<__fpending>(),\n"
msgstr ""
"B<__fbufsize>(),\n"
"B<__fpending>(),\n"

#. type: tbl table
#: man-pages/man3/stdio_ext.3:138
#, no-wrap
msgid ""
"B<__fpurge>(),\n"
"B<__fsetlocking>()"
msgstr ""
"B<__fpurge>(),\n"
"B<__fsetlocking>()"

#. type: tbl table
#: man-pages/man3/stdio_ext.3:138
#, no-wrap
msgid "MT-Safe race:stream"
msgstr "MT-Safe race:stream"

#. type: tbl table
#: man-pages/man3/stdio_ext.3:142
#, no-wrap
msgid ""
"B<__flbf>(),\n"
"B<__freadable>(),\n"
msgstr ""
"B<__flbf>(),\n"
"B<__freadable>(),\n"

#. type: tbl table
#: man-pages/man3/stdio_ext.3:145
#, no-wrap
msgid ""
"B<__freading>(),\n"
"B<__fwritable>(),\n"
msgstr ""
"B<__freading>(),\n"
"B<__fwritable>(),\n"

#. type: tbl table
#: man-pages/man3/stdio_ext.3:148
#, no-wrap
msgid ""
"B<__fwriting>(),\n"
"B<_flushlbf>()"
msgstr ""
"B<__fwriting>(),\n"
"B<_flushlbf>()"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:152
msgid "B<flockfile>(3), B<fpurge>(3)"
msgstr "B<flockfile>(3), B<fpurge>(3)"

#. type: TH
#: man-pages/man3/sched_getcpu.3:26
#, no-wrap
msgid "SCHED_GETCPU"
msgstr "SCHED_GETCPU"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:29
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr "sched_getcpu - определяет ЦП, на котором выполняется вызывающая нить"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr "B<int sched_getcpu(void);>\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:42
msgid "B<sched_getcpu>():"
msgstr "B<sched_getcpu>():"

#. type: TP
#: man-pages/man3/sched_getcpu.3:45
#, no-wrap
msgid "Since glibc 2.14:"
msgstr "Начиная с glibc 2.14:"

#. type: TP
#: man-pages/man3/sched_getcpu.3:48
#, no-wrap
msgid "Before glibc 2.14:"
msgstr "До glibc 2.14:"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:52
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE also suffices */\n"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* также достаточно _GNU_SOURCE */\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:58
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""
"B<sched_getcpu>() возвращает номер центрального процессора, на котором "
"выполняется вызывающая нить."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:65
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<sched_getcpu>() возвращает неотрицательный номер "
"ЦП. При ошибке возвращается -1 и I<errno> устанавливается в соответствующее "
"значение."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:70
msgid "This kernel does not implement B<getcpu>(2)."
msgstr "В данном ядре B<getcpu>(2) не реализован."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:72
msgid "This function is available since glibc 2.6."
msgstr "Эта функция доступна в glibc начиная с версии 2.6."

#. type: tbl table
#: man-pages/man3/sched_getcpu.3:82
#, no-wrap
msgid "B<sched_getcpu>()"
msgstr "B<sched_getcpu>()"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:87
msgid "B<sched_getcpu>()  is glibc-specific."
msgstr "B<sched_getcpu>() есть только в glibc."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:89
msgid "The call"
msgstr "Вызов"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:93
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr "cpu = sched_getcpu();\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:99
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr "эквивалентен следующему вызову B<getcpu>(2):"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:105
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:109
msgid "B<getcpu>(2), B<sched>(7)"
msgstr "B<getcpu>(2), B<sched>(7)"

#. type: TH
#: man-pages/man3/swab.3:31
#, no-wrap
msgid "SWAB"
msgstr "SWAB"

#. type: TH
#: man-pages/man3/swab.3:31
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man3/swab.3:34
msgid "swab - swap adjacent bytes"
msgstr "swab - меняет местами соседние байты"

#. type: Plain text
#: man-pages/man3/swab.3:38
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE>       /* См. feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/swab.3:40
#, no-wrap
msgid "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"
msgstr "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/swab.3:55
msgid ""
"The B<swab>()  function copies I<n> bytes from the array pointed to by "
"I<from> to the array pointed to by I<to>, exchanging adjacent even and odd "
"bytes.  This function is used to exchange data between machines that have "
"different low/high byte ordering."
msgstr ""
"Функция B<swab>() копирует I<n> байт из массива, указанного в I<from> в "
"массив, указанный в I<to>, меняя местами смежные чётные и нечётные байты. "
"Эта функция используется при обмене данными между машинами, у которых "
"разный  порядок младшего/старшего байтов."

#. type: Plain text
#: man-pages/man3/swab.3:68
msgid ""
"This function does nothing when I<n> is negative.  When I<n> is positive and "
"odd, it handles I<n-1> bytes as above, and does something unspecified with "
"the last byte.  (In other words, I<n> should be even.)"
msgstr ""
"Данная функция ничего не делает, если I<n> отрицательно. Если I<n> "
"положительно и нечётно, то обрабатываются I<n-1> байт, как описано выше, а "
"для последнего байта действие не определено (другими словами, I<n> должно "
"быть чётно)."

#. type: Plain text
#: man-pages/man3/swab.3:72
msgid "The B<swab>()  function returns no value."
msgstr "Функция B<swab>() не возвращает никаких значений."

#. type: tbl table
#: man-pages/man3/swab.3:82
#, no-wrap
msgid "B<swab>()"
msgstr "B<swab>()"

#. type: Plain text
#: man-pages/man3/swab.3:86
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/swab.3:87
msgid "B<bstring>(3)"
msgstr "B<bstring>(3)"

#. type: TH
#: man-pages/man3/significand.3:9
#, no-wrap
msgid "SIGNIFICAND"
msgstr "SIGNIFICAND"

#. type: Plain text
#: man-pages/man3/significand.3:13
msgid ""
"significand, significandf, significandl - get mantissa of floating-point "
"number"
msgstr ""
"significand, significandf, significandl - возвращает мантиссу числа с "
"плавающей запятой"

#. type: Plain text
#: man-pages/man3/significand.3:15
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: man-pages/man3/significand.3:17
msgid "B<double significand(double >I<x>B<);>"
msgstr "B<double significand(double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/significand.3:19
msgid "B<float significandf(float >I<x>B<);>"
msgstr "B<float significandf(float >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/significand.3:21
msgid "B<long double significandl(long double >I<x>B<);>"
msgstr "B<long double significandl(long double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/significand.3:23
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/significand.3:33
msgid "B<significand>(), B<significandf>(), B<significandl>():"
msgstr "B<significand>(), B<significandf>(), B<significandl>():"

#. type: Plain text
#: man-pages/man3/significand.3:36
#, no-wrap
msgid ""
"/* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/significand.3:43
msgid ""
"These functions return the mantissa of I<x> scaled to the range [1,2).  They "
"are equivalent to"
msgstr ""
"Эти функции возвращают мантиссу I<x>, приведённую к диапазону [1,2). Они "
"эквивалентны"

#. type: Plain text
#: man-pages/man3/significand.3:47
#, no-wrap
msgid "scalb(x, (double) -ilogb(x))\n"
msgstr "scalb(x, (double) -ilogb(x))\n"

#. type: Plain text
#: man-pages/man3/significand.3:52
msgid ""
"This function exists mainly for use in certain standardized tests for IEEE "
"754 conformance."
msgstr ""
"В основном, эта функция используется в определённых стандартизованных тестах "
"для соответствия IEEE 754."

#. type: tbl table
#: man-pages/man3/significand.3:62
#, no-wrap
msgid "B<significand>(),\n"
msgstr "B<significand>(),\n"

#. type: tbl table
#: man-pages/man3/significand.3:64
#, no-wrap
msgid "B<significandf>(),\n"
msgstr "B<significandf>(),\n"

#. type: tbl table
#: man-pages/man3/significand.3:66
#, no-wrap
msgid "B<significandl>()"
msgstr "B<significandl>()"

#.  .SH HISTORY
#.  This function came from BSD.
#. type: Plain text
#: man-pages/man3/significand.3:75
msgid ""
"These functions are nonstandard; the I<double> version is available on a "
"number of other systems."
msgstr ""
"Эти функции являются нестандартными; в некоторых системах есть функция "
"I<double>."

#. type: Plain text
#: man-pages/man3/significand.3:77
msgid "B<ilogb>(3), B<scalb>(3)"
msgstr "B<ilogb>(3), B<scalb>(3)"

#. type: TH
#: man-pages/man3/sigsetops.3:31
#, no-wrap
msgid "SIGSETOPS"
msgstr "SIGSETOPS"

#. type: Plain text
#: man-pages/man3/sigsetops.3:35
msgid ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal "
"set operations"
msgstr ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - операции с "
"набором сигналов POSIX"

#. type: Plain text
#: man-pages/man3/sigsetops.3:39
msgid "B<int sigemptyset(sigset_t *>I<set>B<);>"
msgstr "B<int sigemptyset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:41
msgid "B<int sigfillset(sigset_t *>I<set>B<);>"
msgstr "B<int sigfillset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:43
msgid "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:45
msgid "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:47
msgid "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:59
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"
msgstr ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"

#. type: Plain text
#: man-pages/man3/sigsetops.3:61
msgid "_POSIX_C_SOURCE"
msgstr "_POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man3/sigsetops.3:65
msgid "These functions allow the manipulation of POSIX signal sets."
msgstr "Эти функции позволяют управлять наборами сигналов POSIX."

#. type: Plain text
#: man-pages/man3/sigsetops.3:70
msgid ""
"B<sigemptyset>()  initializes the signal set given by I<set> to empty, with "
"all signals excluded from the set."
msgstr ""
"Функция B<sigemptyset>() инициализирует набор сигналов, задаваемый I<set>, "
"пустым значением, то есть все сигналы исключены из набора."

#. type: Plain text
#: man-pages/man3/sigsetops.3:75
msgid "B<sigfillset>()  initializes I<set> to full, including all signals."
msgstr ""
"Функция B<sigfillset>() инициализирует I<set> максимальным значением, то "
"есть все сигналы входят в набор."

#. type: Plain text
#: man-pages/man3/sigsetops.3:83
msgid ""
"B<sigaddset>()  and B<sigdelset>()  add and delete respectively signal "
"I<signum> from I<set>."
msgstr ""
"Функция B<sigaddset>() и B<sigdelset>(), соответственно, добавляет и удаляет "
"сигнал I<signum> из I<set>."

#. type: Plain text
#: man-pages/man3/sigsetops.3:89
msgid "B<sigismember>()  tests whether I<signum> is a member of I<set>."
msgstr ""
"Функция B<sigismember>() проверяет, является ли I<signum> членом набора "
"I<set>."

#. type: Plain text
#: man-pages/man3/sigsetops.3:107
msgid ""
"Objects of type I<sigset_t> must be initialized by a call to either "
"B<sigemptyset>()  or B<sigfillset>()  before being passed to the functions "
"B<sigaddset>(), B<sigdelset>()  and B<sigismember>()  or the additional "
"glibc functions described below (B<sigisemptyset>(), B<sigandset>(), and "
"B<sigorset>()).  The results are undefined if this is not done."
msgstr ""
"Объекты типа I<sigset_t> должны быть инициированы вызовом B<sigemptyset>() "
"или B<sigfillset>() до передачи в функции B<sigaddset>(), B<sigdelset>() и "
"B<sigismember>(), или другие дополнительные функции glibc, описанные ниже "
"(B<sigisemptyset>(), B<sigandset>() и B<sigorset>()). Если этого не делать, "
"то результат не определён."

#. type: Plain text
#: man-pages/man3/sigsetops.3:114
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), and B<sigdelset>()  "
"return 0 on success and -1 on error."
msgstr ""
"При успешном выполнении функции B<sigemptyset>(), B<sigfillset>(), "
"B<sigaddset>() и B<sigdelset>() возвращают 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/sigsetops.3:123
msgid ""
"B<sigismember>()  returns 1 if I<signum> is a member of I<set>, 0 if "
"I<signum> is not a member, and -1 on error."
msgstr ""
"Функция B<sigismember>() возвращает 1, если I<signum> является членом набора "
"I<set>, 0, если I<signum> не является членом и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/sigsetops.3:127
msgid ""
"On error, these functions set I<errno> to indicate the cause of the error."
msgstr ""
"При ошибке эти функции изменяют значение I<errno> соответствующим образом."

#. type: Plain text
#: man-pages/man3/sigsetops.3:132
msgid "I<signum> is not a valid signal."
msgstr "В I<signum> задан неправильный сигнал."

#. type: tbl table
#: man-pages/man3/sigsetops.3:143
#, no-wrap
msgid ""
"B<sigemptyset>(),\n"
"B<sigfillset>(),\n"
msgstr ""
"B<sigemptyset>(),\n"
"B<sigfillset>(),\n"

#. type: tbl table
#: man-pages/man3/sigsetops.3:146
#, no-wrap
msgid ""
"B<sigaddset>(),\n"
"B<sigdelset>(),\n"
msgstr ""
"B<sigaddset>(),\n"
"B<sigdelset>(),\n"

#. type: tbl table
#: man-pages/man3/sigsetops.3:149
#, no-wrap
msgid ""
"B<sigismember>(),\n"
"B<sigisemptyset>(),\n"
msgstr ""
"B<sigismember>(),\n"
"B<sigisemptyset>(),\n"

#. type: tbl table
#: man-pages/man3/sigsetops.3:152
#, no-wrap
msgid ""
"B<sigorset>(),\n"
"B<sigandset>()"
msgstr ""
"B<sigorset>(),\n"
"B<sigandset>()"

#. type: Plain text
#: man-pages/man3/sigsetops.3:165
msgid ""
"When creating a filled signal set, the glibc B<sigfillset>()  function does "
"not include the two real-time signals used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""
"При создании заполненного набора сигналов функция glibc для B<sigfillset>() "
"не включает два сигнала реального времени, которые используются внутри "
"реализации NPTL. Подробности смотрите в B<nptl>(7)."

#. type: SS
#: man-pages/man3/sigsetops.3:165
#, no-wrap
msgid "Glibc extensions"
msgstr "Расширения glibc"

#. type: Plain text
#: man-pages/man3/sigsetops.3:171
msgid ""
"If the B<_GNU_SOURCE> feature test macro is defined, then I<E<lt>signal."
"hE<gt>> exposes three other functions for manipulating signal sets:"
msgstr ""
"Если определён макрос тестирования свойств B<_GNU_SOURCE>, то I<E<lt>signal."
"hE<gt>> поставляет три другие функции для управления набором сигналов:"

#. type: Plain text
#: man-pages/man3/sigsetops.3:178
#, no-wrap
msgid ""
"B<int sigisemptyset(const sigset_t *>I<set>B<);>\n"
"B<int sigorset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
"B<int sigandset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
msgstr ""
"B<int sigisemptyset(const sigset_t *>I<set>B<);>\n"
"B<int sigorset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
"B<int sigandset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"

#. type: Plain text
#: man-pages/man3/sigsetops.3:184
msgid ""
"B<sigisemptyset>()  returns 1 if I<set> contains no signals, and 0 otherwise."
msgstr ""
"Функция B<sigisemptyset>() возвращает 1, если I<set> не содержит сигналов и "
"0 в противном случае."

#. type: Plain text
#: man-pages/man3/sigsetops.3:200
msgid ""
"B<sigorset>()  places the union of the sets I<left> and I<right> in "
"I<dest>.  B<sigandset>()  places the intersection of the sets I<left> and "
"I<right> in I<dest>.  Both functions return 0 on success, and -1 on failure."
msgstr ""
"Функция B<sigorset>() помещает объединение наборов I<left> и I<right> в "
"I<dest>. Функция B<sigandset>() помещает пересечение наборов I<left> и "
"I<right> в I<dest>. При успешном выполнении обе функции возвращают 0 и -1 "
"при ошибке."

#. type: Plain text
#: man-pages/man3/sigsetops.3:203
msgid ""
"These functions are nonstandard (a few other systems provide similar "
"functions) and their use should be avoided in portable applications."
msgstr ""
"Эти функции являются нестандартными (но в некоторых других системах имеют "
"подобные)и их лучше не использовать в переносимых приложениях."

#. type: Plain text
#: man-pages/man3/sigsetops.3:207
msgid "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"
msgstr "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"

#. type: TH
#: man-pages/man3/sem_unlink.3:26
#, no-wrap
msgid "SEM_UNLINK"
msgstr "SEM_UNLINK"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:29
msgid "sem_unlink - remove a named semaphore"
msgstr "sem_unlink - удаляет именованный семафор"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:32
#, no-wrap
msgid "B<#include E<lt>semaphore.hE<gt>>\n"
msgstr "B<#include E<lt>semaphore.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:34
#, no-wrap
msgid "B<int sem_unlink(const char *>I<name>B<);>\n"
msgstr "B<int sem_unlink(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:37
msgid "Link with I<-pthread>."
msgstr "Компонуется при указании параметра I<-pthread>."

#. type: Plain text
#: man-pages/man3/sem_unlink.3:44
msgid ""
"B<sem_unlink>()  removes the named semaphore referred to by I<name>.  The "
"semaphore name is removed immediately.  The semaphore is destroyed once all "
"other processes that have the semaphore open close it."
msgstr ""
"Функция B<sem_unlink>() удаляет именованный семафор, на который ссылается "
"I<name>. Имя семафора удаляется немедленно. Семафор уничтожается после того, "
"как все остальные процессы, в которых он открыт, закроют его."

#. type: Plain text
#: man-pages/man3/sem_unlink.3:50
msgid ""
"On success B<sem_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"При успешном выполнении B<sem_unlink>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/sem_unlink.3:54
msgid "The caller does not have permission to unlink this semaphore."
msgstr "Вызывающий не имеет прав для удаления этого семафора."

#. type: Plain text
#: man-pages/man3/sem_unlink.3:58
msgid "I<name> was too long."
msgstr "Слишком длинное значение аргумента I<name>."

#. type: Plain text
#: man-pages/man3/sem_unlink.3:62
msgid "There is no semaphore with the given I<name>."
msgstr "Семафор с указанным I<name> отсутствует."

#. type: tbl table
#: man-pages/man3/sem_unlink.3:72
#, no-wrap
msgid "B<sem_unlink>()"
msgstr "B<sem_unlink>()"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:81
msgid ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_wait>(3), "
"B<sem_overview>(7)"
msgstr ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_wait>(3), "
"B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sem_open.3:26
#, no-wrap
msgid "SEM_OPEN"
msgstr "SEM_OPEN"

#. type: Plain text
#: man-pages/man3/sem_open.3:29
msgid "sem_open - initialize and open a named semaphore"
msgstr "sem_open - инициализирует и открывает именованный семафор"

#. type: Plain text
#: man-pages/man3/sem_open.3:34
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>semaphore.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>           /* константы O_* */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* константы для mode */\n"
"B<#include E<lt>semaphore.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sem_open.3:38
#, no-wrap
msgid ""
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<, >\n"
"B<                mode_t >I<mode>B<, unsigned int >I<value>B<);>\n"
msgstr ""
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<, >\n"
"B<                mode_t >I<mode>B<, unsigned int >I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_open.3:50
msgid ""
"B<sem_open>()  creates a new POSIX semaphore or opens an existing "
"semaphore.  The semaphore is identified by I<name>.  For details of the "
"construction of I<name>, see B<sem_overview>(7)."
msgstr ""
"Функция B<sem_open>() создаёт новый семафор POSIX или открывает существующий "
"семафор. Семафору присваивается имя I<name>. Подробней об устройстве I<name> "
"смотрите B<sem_overview>(7)."

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: man-pages/man3/sem_open.3:76
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  If B<O_CREAT> is specified in I<oflag>, then the "
"semaphore is created if it does not already exist.  The owner (user ID) of "
"the semaphore is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process.  If both B<O_CREAT> and B<O_EXCL> are specified in I<oflag>, then "
"an error is returned if a semaphore with the given I<name> already exists."
msgstr ""
"В аргументе I<oflag> задаются флаги, которые управляют работой вызова "
"(определения значений флагов можно получить включив I<E<lt>fcntl.hE<gt>>). "
"Если в I<oflag> указано B<O_CREAT>, то семафор создаётся, если ещё не "
"существует. Владельцем (ID пользователя) семафора устанавливается "
"эффективный ID пользователя вызывающего процесса. Владельцем группы (ID "
"группы) устанавливается эффективный ID группы вызывающего процесса. Если в "
"I<oflag> указаны B<O_CREAT> и B<O_EXCL> одновременно и семафор с заданным "
"I<name> уже существует, то возвращается ошибка."

#. type: Plain text
#: man-pages/man3/sem_open.3:104
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on "
"the new semaphore, as for B<open>(2).  (Symbolic definitions for the "
"permissions bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The "
"permissions settings are masked against the process umask.  Both read and "
"write permission should be granted to each class of user that will access "
"the semaphore.  The I<value> argument specifies the initial value for the "
"new semaphore.  If B<O_CREAT> is specified, and a semaphore with the given "
"I<name> already exists, then I<mode> and I<value> are ignored."
msgstr ""
"Если в I<oflag> указано B<O_CREAT>, то должны быть заданы ещё два аргумента. "
"В аргументе I<mode> задаются права для нового семафора, подобно B<open>(2) "
"(символические определения бит прав можно получить включив I<E<lt>sys/stat."
"hE<gt>>). Настройки прав маскируются маской процесса. Права чтения и записи "
"должны быть заданы для каждого класса пользователей, которым нужен доступ к "
"семафору. В аргументе I<value> задаётся начальное значение нового семафора. "
"Если указан B<O_CREAT> и семафор с заданным I<name> существует, то I<mode> и "
"I<value> игнорируются."

#. type: Plain text
#: man-pages/man3/sem_open.3:116
msgid ""
"On success, B<sem_open>()  returns the address of the new semaphore; this "
"address is used when calling other semaphore-related functions.  On error, "
"B<sem_open>()  returns B<SEM_FAILED>, with I<errno> set to indicate the "
"error."
msgstr ""
"При успешном выполнении B<sem_open>() возвращает адрес нового семафора; этот "
"адрес используется при вызове других функций, работающих с семафорами. При "
"ошибке B<sem_open>() возвращает B<SEM_FAILED>, а в I<errno> записывается "
"номер ошибки."

#. type: Plain text
#: man-pages/man3/sem_open.3:121
msgid ""
"The semaphore exists, but the caller does not have permission to open it."
msgstr "Семафор существует, но вызывающий не имеет прав для его открытия."

#. type: Plain text
#: man-pages/man3/sem_open.3:132
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a semaphore "
"with this I<name> already exists."
msgstr ""
"В I<oflag> указаны B<O_CREAT> и B<O_EXCL>, но семафор I<name> уже существует."

#. type: Plain text
#: man-pages/man3/sem_open.3:137
msgid "I<value> was greater than B<SEM_VALUE_MAX>."
msgstr "Значение I<value> было больше B<SEM_VALUE_MAX>."

#. type: Plain text
#: man-pages/man3/sem_open.3:141
msgid "I<name> consists of just \"/\", followed by no other characters."
msgstr "В I<name> есть только «/», и нет других символов."

#.  this error can occur if we have a name of the (nonportable) form
#.  /dir/name, and the directory /dev/shm/dir does not exist.
#. type: Plain text
#: man-pages/man3/sem_open.3:167
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag> and no semaphore with this "
"I<name> exists; or, B<O_CREAT> was specified, but I<name> wasn't well formed."
msgstr ""
"В I<oflag> не указан B<O_CREAT> и семафор I<name> не существует; или указан "
"B<O_CREAT>, но I<name> указан в некорректной форме."

#. type: tbl table
#: man-pages/man3/sem_open.3:180
#, no-wrap
msgid "B<sem_open>()"
msgstr "B<sem_open>()"

#. type: Plain text
#: man-pages/man3/sem_open.3:191
msgid ""
"B<sem_close>(3), B<sem_getvalue>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""
"B<sem_close>(3), B<sem_getvalue>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sem_close.3:26
#, no-wrap
msgid "SEM_CLOSE"
msgstr "SEM_CLOSE"

#. type: Plain text
#: man-pages/man3/sem_close.3:29
msgid "sem_close - close a named semaphore"
msgstr "sem_close - закрывает именованный семафор"

#. type: Plain text
#: man-pages/man3/sem_close.3:34
#, no-wrap
msgid "B<int sem_close(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_close(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_close.3:43
msgid ""
"B<sem_close>()  closes the named semaphore referred to by I<sem>, allowing "
"any resources that the system has allocated to the calling process for this "
"semaphore to be freed."
msgstr ""
"Функция B<sem_close>() закрывает именованный семафор, на который указывает "
"I<sem>, позволяя освободить все ресурсы, которые система выделила под "
"семафор вызывающему процессу."

#. type: Plain text
#: man-pages/man3/sem_close.3:49
msgid ""
"On success B<sem_close>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"При успешном выполнении B<sem_close>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/sem_close.3:54
msgid "I<sem> is not a valid semaphore."
msgstr "Значение I<sem> не является корректным для семафора."

#. type: tbl table
#: man-pages/man3/sem_close.3:64
#, no-wrap
msgid "B<sem_close>()"
msgstr "B<sem_close>()"

#. type: Plain text
#: man-pages/man3/sem_close.3:73
msgid ""
"All open named semaphores are automatically closed on process termination, "
"or upon B<execve>(2)."
msgstr ""
"Все открытые именные семафоры автоматически закрываются при завершении "
"процесса или при B<execve>(2)."

#. type: Plain text
#: man-pages/man3/sem_close.3:79
msgid ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/strpbrk.3:30
#, no-wrap
msgid "STRPBRK"
msgstr "STRPBRK"

#. type: Plain text
#: man-pages/man3/strpbrk.3:33
msgid "strpbrk - search a string for any of a set of bytes"
msgstr "strpbrk - ищет в строке любой символ из набора байтов"

#. type: Plain text
#: man-pages/man3/strpbrk.3:38
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: man-pages/man3/strpbrk.3:47
msgid ""
"The B<strpbrk>()  function locates the first occurrence in the string I<s> "
"of any of the bytes in the string I<accept>."
msgstr ""
"Функция B<strpbrk>() ищет первое появление в строке I<s> любых байтов из "
"строки I<accept>."

#. type: Plain text
#: man-pages/man3/strpbrk.3:56
msgid ""
"The B<strpbrk>()  function returns a pointer to the byte in I<s> that "
"matches one of the bytes in I<accept>, or NULL if no such byte is found."
msgstr ""
"Функция B<strpbrk>() возвращает указатель на байт в I<s>, который совпадает "
"с одним из байтов в I<accept>, или NULL, если такой байт не найден."

#. type: tbl table
#: man-pages/man3/strpbrk.3:66
#, no-wrap
msgid "B<strpbrk>()"
msgstr "B<strpbrk>()"

#. type: Plain text
#: man-pages/man3/strpbrk.3:70
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/strpbrk.3:80
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"

#. type: TH
#: man-pages/man3/strsignal.3:30
#, no-wrap
msgid "STRSIGNAL"
msgstr "STRSIGNAL"

#. type: Plain text
#: man-pages/man3/strsignal.3:33
msgid "strsignal - return string describing signal"
msgstr "strsignal - возвращает строку, описывающую сигнал"

#. type: Plain text
#: man-pages/man3/strsignal.3:38
#, no-wrap
msgid "B<char *strsignal(int >I<sig>B<);>\n"
msgstr "B<char *strsignal(int >I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/strsignal.3:40
#, no-wrap
msgid "B<extern const char * const >I<sys_siglist>B<[];>\n"
msgstr "B<extern const char * const >I<sys_siglist>B<[];>\n"

#. type: Plain text
#: man-pages/man3/strsignal.3:48
msgid "B<strsignal>():"
msgstr "B<strsignal>():"

#. type: Plain text
#: man-pages/man3/strsignal.3:68
msgid ""
"The B<strsignal>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  The string can be used only until the next "
"call to B<strsignal>()."
msgstr ""
"Функция B<strsignal>() возвращает строку, которая описывает номер сигнала, "
"переданный в аргументе I<sig>. Строку можно использовать только до "
"следующего вызова B<strsignal>()."

#. type: Plain text
#: man-pages/man3/strsignal.3:77
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number.  The B<strsignal>()  function should be used if possible "
"instead of this array."
msgstr ""
"В массиве I<sys_siglist> содержатся строки описаний сигналов, упорядоченные "
"по номеру сигнала. Если возможно, вместо этого массива лучше использовать "
"функцию B<strsignal>()."

#. type: Plain text
#: man-pages/man3/strsignal.3:84
msgid ""
"The B<strsignal>()  function returns the appropriate description string, or "
"an unknown signal message if the signal number is invalid.  On some systems "
"(but not on Linux), NULL may instead be returned for an invalid signal "
"number."
msgstr ""
"Функция B<strsignal>() возвращает соответствующую строку описания, или "
"сообщение о неизвестном сигнале, если указан некорректный номер сигнала. В "
"некоторых системах (но не Linux), может быть возвращён NULL при некорректном "
"номере сигнала."

#. type: tbl table
#: man-pages/man3/strsignal.3:94
#, no-wrap
msgid "B<strsignal>()"
msgstr "B<strsignal>()"

#. type: tbl table
#: man-pages/man3/strsignal.3:94
#, no-wrap
msgid "MT-Unsafe race:strsignal locale"
msgstr "MT-Unsafe race:strsignal locale"

#. type: Plain text
#: man-pages/man3/strsignal.3:100
msgid "POSIX.1-2008.  Present on Solaris and the BSDs."
msgstr "POSIX.1-2008. Если в Solaris и BSD."

#. type: Plain text
#: man-pages/man3/strsignal.3:102
msgid "B<psignal>(3), B<strerror>(3)"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/strcoll.3:30
#, no-wrap
msgid "STRCOLL"
msgstr "STRCOLL"

#. type: Plain text
#: man-pages/man3/strcoll.3:33
msgid "strcoll - compare two strings using the current locale"
msgstr "strcoll - сравнение двух строк применяя правила текущей локали"

#. type: Plain text
#: man-pages/man3/strcoll.3:38
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcoll.3:58
msgid ""
"The B<strcoll>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>.  "
"The comparison is based on strings interpreted as appropriate for the "
"program's current locale for category B<LC_COLLATE>.  (See B<setlocale>(3).)"
msgstr ""
"Функция B<strcoll>() сравнивает строки I<s1> и I<s2>. Она возвращает целое "
"число, которое может быть меньше, равно или больше ноля, если выяснится, что "
"I<s1> меньше, равна или больше I<s2> соответственно. Сравнение производится "
"на основе правил текущей локали, указанной в категории B<LC_COLLATE> (см. "
"B<setlocale>(3))."

#. type: Plain text
#: man-pages/man3/strcoll.3:69
msgid ""
"The B<strcoll>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be less than, to "
"match, or be greater than I<s2>, when both are interpreted as appropriate "
"for the current locale."
msgstr ""
"Функция B<strcoll>() возвращает целое число меньше, равное или большее нуля, "
"если выяснится, что I<s1> меньше, равна или больше  I<s2> соответственно. "
"При этом сравнение строк производится по правилам текущей локали."

#. type: tbl table
#: man-pages/man3/strcoll.3:79
#, no-wrap
msgid "B<strcoll>()"
msgstr "B<strcoll>()"

#. type: Plain text
#: man-pages/man3/strcoll.3:93
msgid ""
"In the I<POSIX> or I<C> locales B<strcoll>()  is equivalent to B<strcmp>(3)."
msgstr ""
"Если локаль равна I<POSIX> или I<C>, то работа функции B<strcoll>() "
"эквивалентна B<strcmp>(3)."

#. type: Plain text
#: man-pages/man3/strcoll.3:100
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"

#. type: TH
#: man-pages/man3/strchr.3:33
#, no-wrap
msgid "STRCHR"
msgstr "STRCHR"

#. type: Plain text
#: man-pages/man3/strchr.3:36
msgid "strchr, strrchr, strchrnul - locate character in string"
msgstr ""
"strchr, strrchr, strchrnul - определение местонахождения символа в строке"

#. type: Plain text
#: man-pages/man3/strchr.3:41
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:43
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:46
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:48
#, no-wrap
msgid "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:57
msgid ""
"The B<strchr>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"Функция B<strchr>() возвращает указатель на местонахождение первого "
"совпадения с символом I<c> в строке I<s>."

#. type: Plain text
#: man-pages/man3/strchr.3:65
msgid ""
"The B<strrchr>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"Функция B<strrchr>() возвращает указатель на местонахождение последнего "
"совпадения с символом I<c> в строке I<s>."

#. type: Plain text
#: man-pages/man3/strchr.3:78
msgid ""
"The B<strchrnul>()  function is like B<strchr>()  except that if I<c> is not "
"found in I<s>, then it returns a pointer to the null byte at the end of "
"I<s>, rather than NULL."
msgstr ""
"Функция B<strchrnul>() подобна B<strchr>(), за исключением того, что если "
"символ I<c> не найден в строке I<s>, то возвращается указатель на байт null "
"в конце I<s>, а не NULL."

#. type: Plain text
#: man-pages/man3/strchr.3:81
msgid ""
"Here \"character\" means \"byte\"; these functions do not work with wide or "
"multibyte characters."
msgstr ""
"Здесь под «символом» подразумевается «байт» — данные функции не работают с "
"широкими и многобайтными символами."

#. type: Plain text
#: man-pages/man3/strchr.3:93
msgid ""
"The B<strchr>()  and B<strrchr>()  functions return a pointer to the matched "
"character or NULL if the character is not found.  The terminating null byte "
"is considered part of the string, so that if I<c> is specified as \\(aq"
"\\e0\\(aq, these functions return a pointer to the terminator."
msgstr ""
"Функции B<strchr>() и B<strrchr>() возвращает указатель на местонахождение "
"первого совпадения с символом или NULL, если символ не найден. Завершающий "
"байт null считается частью строки, и поэтому, если символ I<c> задан как "
"\\(aq\\e0\\(aq, то эти функции возвращают указатель на завершающий символ."

#. type: Plain text
#: man-pages/man3/strchr.3:102
msgid ""
"The B<strchrnul>()  function returns a pointer to the matched character, or "
"a pointer to the null byte at the end of I<s> (i.e., I<s+strlen(s)>)  if the "
"character is not found."
msgstr ""
"Функция B<strchrnul>() возвращает указатель на совпавший символ, или "
"указатель на байт null в конце строки I<s> (т.е., I<s+strlen(s)>), если "
"символ не найден."

#. type: Plain text
#: man-pages/man3/strchr.3:105
msgid "B<strchrnul>()  first appeared in glibc in version 2.1.1."
msgstr "Функция B<strchrnul>() впервые появилась в glibc версии 2.1.1."

#. type: tbl table
#: man-pages/man3/strchr.3:117
#, no-wrap
msgid ""
"B<strchr>(),\n"
"B<strrchr>(),\n"
"B<strchrnul>()"
msgstr ""
"B<strchr>(),\n"
"B<strrchr>(),\n"
"B<strchrnul>()"

#. type: Plain text
#: man-pages/man3/strchr.3:123
msgid ""
"B<strchr>(), B<strrchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, "
"4.3BSD."
msgstr ""
"B<strchr>(), B<strrchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, "
"4.3BSD."

#. type: Plain text
#: man-pages/man3/strchr.3:126
msgid "B<strchrnul>()  is a GNU extension."
msgstr "Функция B<strchrnul>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/strchr.3:138
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"

#. type: TH
#: man-pages/man3/setaliasent.3:9
#, no-wrap
msgid "SETALIASENT"
msgstr "SETALIASENT"

#. type: Plain text
#: man-pages/man3/setaliasent.3:13
msgid ""
"setaliasent, endaliasent, getaliasent, getaliasent_r, getaliasbyname, "
"getaliasbyname_r - read an alias entry"
msgstr ""
"setaliasent, endaliasent, getaliasent, getaliasent_r, getaliasbyname, "
"getaliasbyname_r - читает запись о псевдониме"

#. type: Plain text
#: man-pages/man3/setaliasent.3:15
msgid "B<#include E<lt>aliases.hE<gt>>"
msgstr "B<#include E<lt>aliases.hE<gt>>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:17
msgid "B<void setaliasent(void);>"
msgstr "B<void setaliasent(void);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:19
msgid "B<void endaliasent(void);>"
msgstr "B<void endaliasent(void);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:21
msgid "B<struct aliasent *getaliasent(void);>"
msgstr "B<struct aliasent *getaliasent(void);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:23
msgid "B<int getaliasent_r(struct aliasent *>I<result>B<,>"
msgstr "B<int getaliasent_r(struct aliasent *>I<result>B<,>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:25 man-pages/man3/setaliasent.3:31
msgid ""
"B< char *>I<buffer>B<, size_t >I<buflen>B<, struct aliasent **>I<res>B<);>"
msgstr ""
"B< char *>I<buffer>B<, size_t >I<buflen>B<, struct aliasent **>I<res>B<);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:27
msgid "B<struct aliasent *getaliasbyname(const char *>I<name>B<);>"
msgstr "B<struct aliasent *getaliasbyname(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:29
msgid ""
"B<int getaliasbyname_r(const char *>I<name>B<, struct aliasent *>I<result>B<,"
">"
msgstr ""
"B<int getaliasbyname_r(const char *>I<name>B<, struct aliasent *>I<result>B<,"
">"

#. type: Plain text
#: man-pages/man3/setaliasent.3:37
msgid ""
"One of the databases available with the Name Service Switch (NSS)  is the "
"aliases database, that contains mail aliases.  (To find out which databases "
"are supported, try I<getent --help>.)  Six functions are provided to access "
"the aliases database."
msgstr ""
"Одной из баз данных, доступных в диспетчере службы имён (NSS), является база "
"данных псевдонимов (aliases), в которой содержатся почтовые псевдонимы (для "
"вывода поддерживаемых баз  данных, запустите I<getent --help>.) Для доступа "
"к базе данных псевдонимов существуют шесть функций."

#. type: Plain text
#: man-pages/man3/setaliasent.3:44
msgid ""
"The B<getaliasent>()  function returns a pointer to a structure containing "
"the group information from the aliases database.  The first time it is "
"called it returns the first entry; thereafter, it returns successive entries."
msgstr ""
"Функция B<getaliasent>() возвращает указатель на структуру, содержащую "
"информацию о группе из базы данных псевдонимов. Во время первого вызова "
"функция возвращает первую запись; в дальнейшем она возвращает все "
"последующие записи."

#. type: Plain text
#: man-pages/man3/setaliasent.3:49
msgid ""
"The B<setaliasent>()  function rewinds the file pointer to the beginning of "
"the aliases database."
msgstr ""
"Функция B<setaliasent>() возвращает файловый указатель в начало базы данных "
"псевдонимов."

#. type: Plain text
#: man-pages/man3/setaliasent.3:53
msgid "The B<endaliasent>()  function closes the aliases database."
msgstr "Функция B<endaliasent>() закрывает базу данных псевдонимов."

#. type: Plain text
#: man-pages/man3/setaliasent.3:60
msgid ""
"B<getaliasent_r>()  is the reentrant version of the previous function.  The "
"requested structure is stored via the first argument but the programmer "
"needs to fill the other arguments also.  Not providing enough space causes "
"the function to fail."
msgstr ""
"Функция B<getaliasent_r>() является реентерабельной версией предыдущей "
"функции. Запрашиваемая структура сохраняется через первый аргумент, но "
"программисту также требуется передать и другие аргументы. При нехватке места "
"функция завершается с ошибкой."

#. type: Plain text
#: man-pages/man3/setaliasent.3:66
msgid ""
"The function B<getaliasbyname>()  takes the name argument and searches the "
"aliases database.  The entry is returned as a pointer to a I<struct "
"aliasent>."
msgstr ""
"Функция B<getaliasbyname>() берёт имя из аргумента и ищет его в базе данных "
"псевдонимов. Найденный элемент возвращается в виде указателя на I<struct "
"aliasent>."

#. type: Plain text
#: man-pages/man3/setaliasent.3:73
msgid ""
"B<getaliasbyname_r>()  is the reentrant version of the previous function.  "
"The requested structure is stored via the second argument but the programmer "
"needs to fill the other arguments also.  Not providing enough space causes "
"the function to fail."
msgstr ""
"Функция B<getaliasbyname_r>() является реентерабельной версией предыдущей "
"функции. Запрашиваемая структура сохраняется через второй аргумент, но "
"программисту также требуется передать и другие аргументы. При нехватке места "
"функция завершается с ошибкой."

#. type: Plain text
#: man-pages/man3/setaliasent.3:78
msgid "The I<struct aliasent> is defined in I<E<lt>aliases.hE<gt>>:"
msgstr "Структура I<struct aliasent> определена в I<E<lt>aliases.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/setaliasent.3:87
#, no-wrap
msgid ""
"struct aliasent {\n"
"    char    *alias_name;             /* alias name */\n"
"    size_t   alias_members_len;\n"
"    char   **alias_members;          /* alias name list */\n"
"    int      alias_local;\n"
"};\n"
msgstr ""
"struct aliasent {\n"
"    char    *alias_name;             /* имя псевдонима */\n"
"    size_t   alias_members_len;\n"
"    char   **alias_members;          /* список имён псевдонима */\n"
"    int      alias_local;\n"
"};\n"

#. type: Plain text
#: man-pages/man3/setaliasent.3:95
msgid ""
"The functions B<getaliasent_r>()  and B<getaliasbyname_r>()  return a "
"nonzero value on error."
msgstr ""
"При ошибке функции B<getaliasent_r>() и B<getaliasbyname_r>() возвращают "
"ненулевое значение."

#. type: Plain text
#: man-pages/man3/setaliasent.3:101
msgid ""
"The default alias database is the file I</etc/aliases>.  This can be changed "
"in the I</etc/nsswitch.conf> file."
msgstr ""
"По умолчанию файлом базы данных псевдонимов является I</etc/aliases>. Это "
"можно изменить в файле I</etc/nsswitch.conf>."

#. type: tbl table
#: man-pages/man3/setaliasent.3:115
#, no-wrap
msgid ""
"B<setaliasent>(),\n"
"B<endaliasent>(),\n"
"B<getaliasent_r>(),\n"
"B<getaliasbyname_r>()"
msgstr ""
"B<setaliasent>(),\n"
"B<endaliasent>(),\n"
"B<getaliasent_r>(),\n"
"B<getaliasbyname_r>()"

#. type: tbl table
#: man-pages/man3/setaliasent.3:119
#, no-wrap
msgid ""
"B<getaliasent>(),\n"
"B<getaliasbyname>()"
msgstr ""
"B<getaliasent>(),\n"
"B<getaliasbyname>()"

#. type: tbl table
#: man-pages/man3/setaliasent.3:119
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: man-pages/man3/setaliasent.3:125
msgid ""
"These routines are glibc-specific.  The NeXT system has similar routines:"
msgstr "Эти функции есть только в glibc. В системе NeXT есть подобные функции:"

#. type: Plain text
#: man-pages/man3/setaliasent.3:129
#, no-wrap
msgid "#include E<lt>aliasdb.hE<gt>\n"
msgstr "#include E<lt>aliasdb.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/setaliasent.3:134
#, no-wrap
msgid ""
"void alias_setent(void);\n"
"void alias_endent(void);\n"
"alias_ent *alias_getent(void);\n"
"alias_ent *alias_getbyname(char *name);\n"
msgstr ""
"void alias_setent(void);\n"
"void alias_endent(void);\n"
"alias_ent *alias_getent(void);\n"
"alias_ent *alias_getbyname(char *name);\n"

#. type: Plain text
#: man-pages/man3/setaliasent.3:140
msgid ""
"The following example compiles with I<gcc example.c -o example>.  It will "
"dump all names in the alias database."
msgstr ""
"Следующий пример компилируется командой I<gcc example.c -o example>. Он "
"выводит все имена из баз данных псевдонимов."

#. type: Plain text
#: man-pages/man3/setaliasent.3:146
#, no-wrap
msgid ""
"#include E<lt>aliases.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>aliases.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/setaliasent.3:165
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct aliasent *al;\n"
"    setaliasent();\n"
"    for (;;) {\n"
"        al = getaliasent();\n"
"        if (al == NULL)\n"
"            break;\n"
"        printf(\"Name: %s\\en\", al-E<gt>alias_name);\n"
"    }\n"
"    if (errno) {\n"
"        perror(\"reading alias\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    endaliasent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct aliasent *al;\n"
"    setaliasent();\n"
"    for (;;) {\n"
"        al = getaliasent();\n"
"        if (al == NULL)\n"
"            break;\n"
"        printf(\"Имя: %s\\en\", al-E<gt>alias_name);\n"
"    }\n"
"    if (errno) {\n"
"        perror(\"чтение псевдонимов\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    endaliasent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/setaliasent.3:170
msgid "B<getgrent>(3), B<getpwent>(3), B<getspent>(3), B<aliases>(5)"
msgstr "B<getgrent>(3), B<getpwent>(3), B<getspent>(3), B<aliases>(5)"

#. type: TH
#: man-pages/man3/sin.3:35
#, no-wrap
msgid "SIN"
msgstr "SIN"

#. type: Plain text
#: man-pages/man3/sin.3:38
msgid "sin, sinf, sinl - sine function"
msgstr "sin, sinf, sinl - функция вычисления синуса"

#. type: Plain text
#: man-pages/man3/sin.3:41
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sin.3:45
#, no-wrap
msgid ""
"B<double sin(double >I<x>B<);>\n"
"B<float sinf(float >I<x>B<);>\n"
"B<long double sinl(long double >I<x>B<);>\n"
msgstr ""
"B<double sin(double >I<x>B<);>\n"
"B<float sinf(float >I<x>B<);>\n"
"B<long double sinl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sin.3:57
msgid "B<sinf>(), B<sinl>():"
msgstr "B<sinf>(), B<sinl>():"

#. type: Plain text
#: man-pages/man3/sin.3:61
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/sin.3:70
msgid ""
"These functions return the sine of I<x>, where I<x> is given in radians."
msgstr "Эти функции возвращают синус от I<x>, где I<x> указан в радианах."

#. type: Plain text
#: man-pages/man3/sin.3:73
msgid "On success, these functions return the sine of I<x>."
msgstr "В случае успеха эти функции возвращают синус от I<x>."

#. type: Plain text
#: man-pages/man3/sin.3:77
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN."

#.  POSIX.1 allows an optional range error for subnormal x
#.  glibc 2.8 doesn't do this
#. type: Plain text
#: man-pages/man3/sin.3:86
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности или минус бесконечности, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата "
"будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/sin.3:91
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать "
"при вызове этих функций."

#. type: Plain text
#: man-pages/man3/sin.3:93
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/sin.3:93
#, no-wrap
msgid "Domain error: I<x> is an infinity"
msgstr "Ошибка области: I<x> стремится к бесконечности"

#. type: Plain text
#: man-pages/man3/sin.3:102
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM> (но см. ДЕФЕКТЫ). Возникает исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#. type: tbl table
#: man-pages/man3/sin.3:114
#, no-wrap
msgid ""
"B<sin>(),\n"
"B<sinf>(),\n"
"B<sinl>()"
msgstr ""
"B<sin>(),\n"
"B<sinf>(),\n"
"B<sinl>()"

#. type: Plain text
#: man-pages/man3/sin.3:118
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/sin.3:123
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""
"Вариант, возвращающий значение типа I<double>, также соответствует SVr4, "
"4.3BSD, C89."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6781
#. type: Plain text
#: man-pages/man3/sin.3:130
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred."
msgstr ""
"До версии 2.10 в реализации glibc при возникновении ошибки области I<errno> "
"не устанавливалось в значение B<EDOM>."

#. type: Plain text
#: man-pages/man3/sin.3:138
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<csin>(3), "
"B<sincos>(3), B<tan>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<csin>(3), "
"B<sincos>(3), B<tan>(3)"

#. type: TH
#: man-pages/man3/sockatmark.3:25
#, no-wrap
msgid "SOCKATMARK"
msgstr "SOCKATMARK"

#. type: Plain text
#: man-pages/man3/sockatmark.3:28
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr "sockatmark - определяет, есть ли в сокете отметка о внеполосных данных"

#. type: Plain text
#: man-pages/man3/sockatmark.3:32
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr "B<int sockatmark(int >I<sockfd>B<);>"

#. type: Plain text
#: man-pages/man3/sockatmark.3:41
msgid "B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/sockatmark.3:51
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If "
"the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""
"Функция B<sockatmark>() возвращает значение, показывающее присутствует ли в "
"сокете, на который ссылается файловый дескриптор I<sockfd>, отметка о "
"внеполосных данных (out-of-band mark). Если сокет имеет отметку, то "
"возвращается 1; если сокет не имеет отметки, то возвращается 0. Эта функция "
"не удаляет отметку о внеполосных данных."

#. type: Plain text
#: man-pages/man3/sockatmark.3:58
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the out-"
"of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"При успешном выполнении B<sockatmark>() возвращает 1, если сокет имеет "
"отметку о внеполосных данных, и 0, если нет. При ошибке возвращается -1, и в "
"I<errno> записывается номер ошибки."

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: man-pages/man3/sockatmark.3:70
msgid ""
"I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""
"Значение I<sockfd> является файловым дескриптором, к которому не применима "
"функция B<sockatmark>()."

#. type: Plain text
#: man-pages/man3/sockatmark.3:73
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr "Функция B<sockatmark>() впервые появилась в glibc 2.2.4."

#. type: tbl table
#: man-pages/man3/sockatmark.3:83
#, no-wrap
msgid "B<sockatmark>()"
msgstr "B<sockatmark>()"

#. type: Plain text
#: man-pages/man3/sockatmark.3:94
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""
"Если B<sockatmark>() возвращает 1, то внеполосные данные можно прочитать "
"используя флаг B<MSG_OOB> в B<recv>(2)."

#. type: Plain text
#: man-pages/man3/sockatmark.3:96
msgid "Out-of-band data is supported only on some stream socket protocols."
msgstr ""
"Внеполосные данные поддерживаются только для некоторых потоковых сокетных "
"протоколов."

#. type: Plain text
#: man-pages/man3/sockatmark.3:101
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""
"Функцию B<sockatmark>() можно безопасно вызывать из обработчика сигнала "
"B<SIGURG>."

#. type: Plain text
#: man-pages/man3/sockatmark.3:107
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""
"Функция B<sockatmark>() реализована с помощью B<ioctl>(2) с операцией "
"B<SIOCATMARK>."

#. type: Plain text
#: man-pages/man3/sockatmark.3:111
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr "До glibc 2.4, B<sockatmark>() не работала."

#. type: Plain text
#: man-pages/man3/sockatmark.3:116
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the "
"mark:"
msgstr ""
"Следующий код можно использовать после получения сигнала B<SIGURG> для "
"чтения (и удаления) всех данных до отметки, и затем для чтения байта данных "
"отметки:"

#. type: Plain text
#: man-pages/man3/sockatmark.3:121
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:128
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:131
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr ""
"        if (atmark)\n"
"            break;\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:138
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr ""
"        s = read(sockfd, buf, BUF_LEN);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:145
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:150
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"

#. type: TH
#: man-pages/man3/stdin.3:13
#, no-wrap
msgid "STDIN"
msgstr "STDIN"

#. type: Plain text
#: man-pages/man3/stdin.3:16
msgid "stdin, stdout, stderr - standard I/O streams"
msgstr "stdin, stdout, stderr - стандартные потоки ввода/вывода"

#. type: Plain text
#: man-pages/man3/stdin.3:23
#, no-wrap
msgid ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"
msgstr ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"

#. type: Plain text
#: man-pages/man3/stdin.3:35
msgid ""
"Under normal circumstances every UNIX program has three streams opened for "
"it when it starts up, one for input, one for output, and one for printing "
"diagnostic or error messages.  These are typically attached to the user's "
"terminal (see B<tty>(4))  but might instead refer to files or other devices, "
"depending on what the parent process chose to set up.  (See also the "
"\"Redirection\" section of B<sh>(1).)"
msgstr ""
"В обычном состоянии каждая программа UNIX после запуска имеет при открытых "
"потока, один для ввода данных, один для вывода и один для печати "
"диагностических сообщений или ошибок. Обычно, они присоединены к терминалу "
"пользователя (смотрите B<tty>(4)), но также они могут ссылаться на файлы или "
"другие устройства, в зависимости от того, как это настроил родительский "
"процесс (также смотрите раздел «Перенаправление (redirection)» в B<sh>(1))."

#. type: Plain text
#: man-pages/man3/stdin.3:45
msgid ""
"The input stream is referred to as \"standard input\"; the output stream is "
"referred to as \"standard output\"; and the error stream is referred to as "
"\"standard error\".  These terms are abbreviated to form the symbols used to "
"refer to these files, namely I<stdin>, I<stdout>, and I<stderr>."
msgstr ""
"Входной поток называют «стандартным вводом»; выходной поток называют "
"«стандартным выводом»; поток ошибок называют «стандартным потоком ошибок». "
"Эти термины в сокращённой форме (символы I<stdin>, I<stdout> и I<stderr>) "
"используются для обращения к соответствующим файлам."

#. type: Plain text
#: man-pages/man3/stdin.3:54
msgid ""
"Each of these symbols is a B<stdio>(3)  macro of type pointer to I<FILE>, "
"and can be used with functions like B<fprintf>(3)  or B<fread>(3)."
msgstr ""
"Каждый из этих символов является макросом B<stdio>(3) с типом указателя на "
"I<FILE> и может быть использован в функциях вроде B<fprintf>(3) или "
"B<fread>(3)."

#. type: Plain text
#: man-pages/man3/stdin.3:63
msgid ""
"Since I<FILE>s are a buffering wrapper around UNIX file descriptors, the "
"same underlying files may also be accessed using the raw UNIX file "
"interface, that is, the functions like B<read>(2)  and B<lseek>(2)."
msgstr ""
"Так как I<FILE> — буферная обёртка вокруг файловых дескрипторов UNIX, файлы, "
"на которые она ссылается, могут быть доступны через обычный низкоуровневый "
"файловый интерфейс UNIX, то есть через функции B<read>(2) и B<lseek>(2)."

#. type: Plain text
#: man-pages/man3/stdin.3:82
msgid ""
"On program startup, the integer file descriptors associated with the streams "
"I<stdin>, I<stdout>, and I<stderr> are 0, 1, and 2, respectively.  The "
"preprocessor symbols B<STDIN_FILENO>, B<STDOUT_FILENO>, and B<STDERR_FILENO> "
"are defined with these values in I<E<lt>unistd.hE<gt>>.  (Applying "
"B<freopen>(3)  to one of these streams can change the file descriptor number "
"associated with the stream.)"
msgstr ""
"При запуске программы с потоками I<stdin>, I<stdout> и I<stderr> связываются "
"целочисленные файловые дескрипторы 0, 1 и 2, соответственно. Для этих "
"значений в I<E<lt>unistd.hE<gt>> определены препроцессорные символы "
"B<STDIN_FILENO>, B<STDOUT_FILENO> и B<STDERR_FILENO> (с помощью "
"B<freopen>(3) у любого из этих потоков можно изменить номер файлового "
"дескриптора, связанного с потоком)."

#. type: Plain text
#: man-pages/man3/stdin.3:95
msgid ""
"Note that mixing use of I<FILE>s and raw file descriptors can produce "
"unexpected results and should generally be avoided.  (For the masochistic "
"among you: POSIX.1, section 8.2.3, describes in detail how this interaction "
"is supposed to work.)  A general rule is that file descriptors are handled "
"in the kernel, while stdio is just a library.  This means for example, that "
"after an B<exec>(3), the child inherits all open file descriptors, but all "
"old streams have become inaccessible."
msgstr ""
"Заметим, что одновременное использование I<FILE> и низкоуровневых файловых "
"дескрипторов может привести к непредсказуемым результатам и этого нужно "
"избегать (для мазохистов: в POSIX.1, раздел 8.2.3, подробно описано как "
"должно работать такое взаимодействие). Общее правило: файловые дескрипторы "
"обрабатываются в ядре, а stdio всего лишь библиотека. Это означает, что, "
"например, после B<exec>(3) потомок наследует все открытые файловые "
"дескрипторы, но все старые потоки становятся недоступными."

#. type: Plain text
#: man-pages/man3/stdin.3:113
msgid ""
"Since the symbols I<stdin>, I<stdout>, and I<stderr> are specified to be "
"macros, assigning to them is nonportable.  The standard streams can be made "
"to refer to different files with help of the library function B<freopen>(3), "
"specially introduced to make it possible to reassign I<stdin>, I<stdout>, "
"and I<stderr>.  The standard streams are closed by a call to B<exit>(3)  and "
"by normal program termination."
msgstr ""
"Так как символы I<stdin>, I<stdout> и I<stderr> определены как макросы, "
"присвоение им значения непереносимо. Стандартные потоки можно связать с "
"различными файлами с помощью библиотечной функции B<freopen>(3), специально "
"созданной для переназначения I<stdin>, I<stdout> и I<stderr>. Стандартные "
"потоки закрываются вызовом B<exit>(3) и при нормально завершении программы."

#. type: Plain text
#: man-pages/man3/stdin.3:122
msgid ""
"The I<stdin>, I<stdout>, and I<stderr> macros conform to C89 and this "
"standard also stipulates that these three streams shall be open at program "
"startup."
msgstr ""
"Макросы I<stdin>, I<stdout> и I<stderr> соответствуют C89 и этот стандарт "
"также оговаривает, что три этих потока должны открываться при запуске "
"программы."

#. type: Plain text
#: man-pages/man3/stdin.3:154
msgid ""
"The stream I<stderr> is unbuffered.  The stream I<stdout> is line-buffered "
"when it points to a terminal.  Partial lines will not appear until "
"B<fflush>(3)  or B<exit>(3)  is called, or a newline is printed.  This can "
"produce unexpected results, especially with debugging output.  The buffering "
"mode of the standard streams (or any other stream)  can be changed using the "
"B<setbuf>(3)  or B<setvbuf>(3)  call.  Note that in case I<stdin> is "
"associated with a terminal, there may also be input buffering in the "
"terminal driver, entirely unrelated to stdio buffering.  (Indeed, normally "
"terminal input is line buffered in the kernel.)  This kernel input handling "
"can be modified using calls like B<tcsetattr>(3); see also B<stty>(1), and "
"B<termios>(3)."
msgstr ""
"Поток I<stderr> является небуферизованным. Поток I<stdout> буферизируется "
"построчно, если подключён к терминалу. Часть строки не появляется до тех "
"пор, пока не будет вызвана функция B<fflush>(3) или B<exit>(3), или не "
"появится символ новой строки. Это может приводить к неожиданным результатам, "
"особенно при выводе диагностических сообщений. Режим буферизации стандартных "
"потоков (или любого другого потока) модно изменить с помощью вызова "
"B<setbuf>(3) или B<setvbuf>(3). Заметим, что в случае когда I<stdin> связан "
"с терминалом, также может быть буферизация ввода в драйвере терминала, никак "
"не связанная с буферизацией stdio (более того, обычный терминальный ввод "
"буферизируется построчно в ядре). Работу ядра по обработке ввода можно "
"изменить с помощью вызова B<tcsetattr>(3) и подобным; также смотрите "
"B<stty>(1) и B<termios>(3)."

#. type: Plain text
#: man-pages/man3/stdin.3:159
msgid "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"
msgstr "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"

#. type: TH
#: man-pages/man3/stdarg.3:43
#, no-wrap
msgid "STDARG"
msgstr "STDARG"

#. type: Plain text
#: man-pages/man3/stdarg.3:46
msgid "stdarg, va_start, va_arg, va_end, va_copy - variable argument lists"
msgstr ""
"stdarg, va_start, va_arg, va_end, va_copy - работа со списком переменного "
"количества аргументов"

#. type: Plain text
#: man-pages/man3/stdarg.3:48
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr "B<#include E<lt>stdarg.hE<gt>>"

#. type: Plain text
#: man-pages/man3/stdarg.3:50
msgid "B<void va_start(va_list >I<ap>B<, >I<last>B<);>"
msgstr "B<void va_start(va_list >I<ap>B<, >I<last>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:52
msgid "I<type>B< va_arg(va_list >I<ap>B<, >I<type>B<);>"
msgstr "I<type>B< va_arg(va_list >I<ap>B<, >I<type>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:54
msgid "B<void va_end(va_list >I<ap>B<);>"
msgstr "B<void va_end(va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:56
msgid "B<void va_copy(va_list >I<dest>B<, va_list >I<src>B<);>"
msgstr "B<void va_copy(va_list >I<dest>B<, va_list >I<src>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:65
msgid ""
"A function may be called with a varying number of arguments of varying "
"types.  The include file I<E<lt>stdarg.hE<gt>> declares a type I<va_list> "
"and defines three macros for stepping through a list of arguments whose "
"number and types are not known to the called function."
msgstr ""
"Функцию можно вызвать передав ей произвольное количество аргументов разных "
"типов. Во включаемом файле I<E<lt>stdarg.hE<gt>> объявляется тип I<va_list> "
"и определяется три макроса для пошагового обхода списка аргументов, чьё "
"количество и типы неизвестны вызываемой функции."

#. type: Plain text
#: man-pages/man3/stdarg.3:73
msgid ""
"The called function must declare an object of type I<va_list> which is used "
"by the macros B<va_start>(), B<va_arg>(), and B<va_end>()."
msgstr ""
"В вызываемой функции требуется объявить объект с типом I<va_list>, который "
"используется макросами B<va_start>(), B<va_arg>() и B<va_end>()."

#. type: SS
#: man-pages/man3/stdarg.3:73
#, no-wrap
msgid "va_start()"
msgstr "va_start()"

#. type: Plain text
#: man-pages/man3/stdarg.3:83
msgid ""
"The B<va_start>()  macro initializes I<ap> for subsequent use by "
"B<va_arg>()  and B<va_end>(), and must be called first."
msgstr ""
"Макрос B<va_start>() инициализирует I<ap> для последующего использования в "
"B<va_arg>()и B<va_end>(), и должен вызываться первым."

#. type: Plain text
#: man-pages/man3/stdarg.3:88
msgid ""
"The argument I<last> is the name of the last argument before the variable "
"argument list, that is, the last argument of which the calling function "
"knows the type."
msgstr ""
"Аргумент I<last> это имя последнего аргумента перед списком с переменным "
"количеством аргументов, то есть это последний аргумент, тип которого "
"известен вызывающей функции."

#. type: Plain text
#: man-pages/man3/stdarg.3:93
msgid ""
"Because the address of this argument may be used in the B<va_start>()  "
"macro, it should not be declared as a register variable, or as a function or "
"an array type."
msgstr ""
"Так как адрес этого аргумента может быть использован в макросе "
"B<va_start>(), он не должен быть объявлен как регистровая переменная, иметь "
"тип функции или массива."

#. type: SS
#: man-pages/man3/stdarg.3:93
#, no-wrap
msgid "va_arg()"
msgstr "va_arg()"

#. type: Plain text
#: man-pages/man3/stdarg.3:115
msgid ""
"The B<va_arg>()  macro expands to an expression that has the type and value "
"of the next argument in the call.  The argument I<ap> is the I<va_list> "
"I<ap> initialized by B<va_start>().  Each call to B<va_arg>()  modifies "
"I<ap> so that the next call returns the next argument.  The argument I<type> "
"is a type name specified so that the type of a pointer to an object that has "
"the specified type can be obtained simply by adding a * to I<type>."
msgstr ""
"Макрос B<va_arg>() раскрывается в выражение, которое имеет тип и значение "
"следующего аргумента в вызове. Аргумент I<ap> — это I<va_list> I<ap>, "
"инициализированный B<va_start>(). Каждый вызов B<va_arg>() изменяет I<ap> "
"так, что следующий вызов возвращает следующий аргумент. Аргумент I<type> — "
"это имя типа, указанное так, что тип указателя на объект, который имеет "
"указанный тип, можно получить просто добавив * в I<type>."

#. type: Plain text
#: man-pages/man3/stdarg.3:123
msgid ""
"The first use of the B<va_arg>()  macro after that of the B<va_start>()  "
"macro returns the argument after I<last>.  Successive invocations return the "
"values of the remaining arguments."
msgstr ""
"Первый вызов макроса B<va_arg>() после B<va_start>() вернёт аргумент после "
"I<last>. Последующие вызовы вернут значения оставшихся аргументов."

#. type: Plain text
#: man-pages/man3/stdarg.3:128
msgid ""
"If there is no next argument, or if I<type> is not compatible with the type "
"of the actual next argument (as promoted according to the default argument "
"promotions), random errors will occur."
msgstr ""
"Если аргументы закончились, или если I<type> не совместим с типом настоящего "
"следующего аргумента (преобразование происходит согласно преобразованию "
"аргументов по умолчанию), может произойти любая ошибка."

#. type: Plain text
#: man-pages/man3/stdarg.3:136
msgid ""
"If I<ap> is passed to a function that uses B<va_arg(>I<ap>B<,>I<type>B<),> "
"then the value of I<ap> is undefined after the return of that function."
msgstr ""
"Если I<ap> передан в функцию, которая использует B<va_arg(>I<ap>B<,"
">I<type>B<),> то значение I<ap> не определено после возврата из функции."

#. type: SS
#: man-pages/man3/stdarg.3:136
#, no-wrap
msgid "va_end()"
msgstr "va_end()"

#. type: Plain text
#: man-pages/man3/stdarg.3:155
msgid ""
"Each invocation of B<va_start>()  must be matched by a corresponding "
"invocation of B<va_end>()  in the same function.  After the call "
"B<va_end(>I<ap>B<)> the variable I<ap> is undefined.  Multiple traversals of "
"the list, each bracketed by B<va_start>()  and B<va_end>()  are possible.  "
"B<va_end>()  may be a macro or a function."
msgstr ""
"Каждый использование B<va_start>() должно завершаться соответствующим "
"вызовом B<va_end>() в той же функции. После вызова B<va_end(>I<ap>B<)> "
"значение переменной I<ap> не определено. Возможно несколько проходов по "
"списку, если каждый из них начинать B<va_start>() и заканчивать B<va_end>(). "
"Макрос B<va_end>() может быть и функцией."

#. type: SS
#: man-pages/man3/stdarg.3:155
#, no-wrap
msgid "va_copy()"
msgstr "va_copy()"

#. type: Plain text
#: man-pages/man3/stdarg.3:172
msgid ""
"The B<va_copy>()  macro copies the (previously initialized) variable "
"argument list I<src> to I<dest>.  The behavior is as if B<va_start>()  were "
"applied to I<dest> with the same I<last> argument, followed by the same "
"number of B<va_arg>()  invocations that was used to reach the current state "
"of I<src>."
msgstr ""
"Макрос B<va_copy>() копирует (ранее инициализированный) список с переменным "
"количеством аргументов I<src> в I<dest>. Его действие такое же, как если бы "
"B<va_start>() применили к I<dest> с тем же аргументом I<last>, после чего "
"было бы совершено такое же количество вызовов B<va_arg>(), которое имеется в "
"текущем состоянии I<src>."

#.  Proposal from clive@demon.net, 1997-02-28
#. type: Plain text
#: man-pages/man3/stdarg.3:179
msgid ""
"An obvious implementation would have a I<va_list> be a pointer to the stack "
"frame of the variadic function.  In such a setup (by far the most common) "
"there seems nothing against an assignment"
msgstr ""
"Очевидной реализацией было бы создать переменную с типом I<va_list>, "
"указывающую на стековый фрейм функции с переменным количеством аргументов. В "
"этом случае (безусловно, наиболее распространенном) кажется, что достаточно "
"присвоения"

#. type: Plain text
#: man-pages/man3/stdarg.3:183
#, no-wrap
msgid "va_list aq = ap;\n"
msgstr "va_list aq = ap;\n"

#. type: Plain text
#: man-pages/man3/stdarg.3:188
msgid ""
"Unfortunately, there are also systems that make it an array of pointers (of "
"length 1), and there one needs"
msgstr ""
"К сожалению, есть системы, в которых это массив указателей (длиной 1), и "
"нужно делать"

#. type: Plain text
#: man-pages/man3/stdarg.3:193
#, no-wrap
msgid ""
"va_list aq;\n"
"*aq = *ap;\n"
msgstr ""
"va_list aq;\n"
"*aq = *ap;\n"

#. type: Plain text
#: man-pages/man3/stdarg.3:209
msgid ""
"Finally, on systems where arguments are passed in registers, it may be "
"necessary for B<va_start>()  to allocate memory, store the arguments there, "
"and also an indication of which argument is next, so that B<va_arg>()  can "
"step through the list.  Now B<va_end>()  can free the allocated memory "
"again.  To accommodate this situation, C99 adds a macro B<va_copy>(), so "
"that the above assignment can be replaced by"
msgstr ""
"Наконец, в системах, где аргументы передаются через регистры, в  "
"B<va_start>() может потребоваться выделить память, сохранить там аргументы, "
"а также индекс следующего элемента для того, чтобы B<va_arg>() мог обойти "
"список. Также B<va_end>() может освобождать выделенную память. Чтобы всё это "
"учесть в C99 добавлен макрос B<va_copy>(), который позволяет показанное выше "
"назначение заменить на"

#. type: Plain text
#: man-pages/man3/stdarg.3:216
#, no-wrap
msgid ""
"va_list aq;\n"
"va_copy(aq, ap);\n"
"\\&...\n"
"va_end(aq);\n"
msgstr ""
"va_list aq;\n"
"va_copy(aq, ap);\n"
"\\&...\n"
"va_end(aq);\n"

#. type: Plain text
#: man-pages/man3/stdarg.3:229
msgid ""
"Each invocation of B<va_copy>()  must be matched by a corresponding "
"invocation of B<va_end>()  in the same function.  Some systems that do not "
"supply B<va_copy>()  have B<__va_copy> instead, since that was the name used "
"in the draft proposal."
msgstr ""
"Для каждого вызова B<va_copy>() должен быть соответствующий вызов "
"B<va_end>() в той же функции. В некоторых системах нет B<va_copy>(), а есть "
"B<__va_copy> — имя, которое использовалось в черновике стандарта."

#. type: tbl table
#: man-pages/man3/stdarg.3:241
#, no-wrap
msgid ""
"B<va_start>(),\n"
"B<va_end>(),\n"
"B<va_copy>()"
msgstr ""
"B<va_start>(),\n"
"B<va_end>(),\n"
"B<va_copy>()"

#. type: tbl table
#: man-pages/man3/stdarg.3:244
#, no-wrap
msgid "B<va_arg>()"
msgstr "B<va_arg>()"

#. type: tbl table
#: man-pages/man3/stdarg.3:244
#, no-wrap
msgid "MT-Safe race:ap"
msgstr "MT-Safe race:ap"

#. type: Plain text
#: man-pages/man3/stdarg.3:256
msgid ""
"The B<va_start>(), B<va_arg>(), and B<va_end>()  macros conform to C89.  C99 "
"defines the B<va_copy>()  macro."
msgstr ""
"Макросы B<va_start>(), B<va_arg>() и B<va_end>() соответствуют C89. В C99 "
"определён макрос B<va_copy>()."

#. type: Plain text
#: man-pages/man3/stdarg.3:272
msgid ""
"Unlike the historical B<varargs> macros, the B<stdarg> macros do not permit "
"programmers to code a function with no fixed arguments.  This problem "
"generates work mainly when converting B<varargs> code to B<stdarg> code, but "
"it also creates difficulties for variadic functions that wish to pass all of "
"their arguments on to a function that takes a I<va_list> argument, such as "
"B<vfprintf>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:277
msgid ""
"The function I<foo> takes a string of format characters and prints out the "
"argument associated with each format character based on the type."
msgstr ""
"Функция I<foo> берёт строку с символами формата и печатает аргумент, "
"связанный с каждым таким символом, на основе его типа."

#. type: Plain text
#: man-pages/man3/stdarg.3:281
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/stdarg.3:284
#, no-wrap
msgid ""
"void\n"
"foo(char *fmt, ...)   /* '...' is C syntax for a variadic function */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:289
#, no-wrap
msgid ""
"{\n"
"    va_list ap;\n"
"    int d;\n"
"    char c, *s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:310
#, no-wrap
msgid ""
"    va_start(ap, fmt);\n"
"    while (*fmt)\n"
"        switch (*fmt++) {\n"
"        case \\(aqs\\(aq:              /* string */\n"
"            s = va_arg(ap, char *);\n"
"            printf(\"string %s\\en\", s);\n"
"            break;\n"
"        case \\(aqd\\(aq:              /* int */\n"
"            d = va_arg(ap, int);\n"
"            printf(\"int %d\\en\", d);\n"
"            break;\n"
"        case \\(aqc\\(aq:              /* char */\n"
"            /* need a cast here since va_arg only\n"
"               takes fully promoted types */\n"
"            c = (char) va_arg(ap, int);\n"
"            printf(\"char %c\\en\", c);\n"
"            break;\n"
"        }\n"
"    va_end(ap);\n"
"}\n"
msgstr ""
"    va_start(ap, fmt);\n"
"    while (*fmt)\n"
"        switch (*fmt++) {\n"
"        case \\(aqs\\(aq:              /* строка */\n"
"            s = va_arg(ap, char *);\n"
"            printf(\"строка %s\\en\", s);\n"
"            break;\n"
"        case \\(aqd\\(aq:              /* int */\n"
"            d = va_arg(ap, int);\n"
"            printf(\"int %d\\en\", d);\n"
"            break;\n"
"        case \\(aqc\\(aq:              /* символ */\n"
"            /* здесь требуется преобразование, так как va_arg только\n"
"               с полностью описанными (promoted) типами */\n"
"            c = (char) va_arg(ap, int);\n"
"            printf(\"символ %c\\en\", c);\n"
"            break;\n"
"        }\n"
"    va_end(ap);\n"
"}\n"

#. type: TH
#: man-pages/man3/strcasecmp.3:30
#, no-wrap
msgid "STRCASECMP"
msgstr "STRCASECMP"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:33
msgid "strcasecmp, strncasecmp - compare two strings ignoring case"
msgstr "strcasecmp, strncasecmp - сравнение двух строк без учёта регистра"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:36
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr "B<#include E<lt>strings.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:40
#, no-wrap
msgid "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:55
msgid ""
"The B<strcasecmp>()  function performs a byte-by-byte comparison of the "
"strings I<s1> and I<s2>, ignoring the case of the characters.  It returns an "
"integer less than, equal to, or greater than zero if I<s1> is found, "
"respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""
"Функция B<strcasecmp>() выполняет побайтовое сравнение строк I<s1> и I<s2>, "
"игнорируя регистр символов. Она возвращает целое число, которое меньше, "
"равно или больше нуля, если выяснится, что I<s1> меньше, равна или больше "
"I<s2> соответственно."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:65
msgid ""
"The B<strncasecmp>()  function is similar, except that it compares no more "
"than I<n> bytes of I<s1> and I<s2>."
msgstr ""
"Функция B<strncasecmp>() работает аналогичным образом, но сравниваются не "
"более I<n> байт строк I<s1> и I<s2>."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:77
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions return an integer less "
"than, equal to, or greater than zero if I<s1> is, after ignoring case, found "
"to be less than, to match, or be greater than I<s2>, respectively."
msgstr ""
"Функции B<strcasecmp>() и B<strncasecmp>() возвращают целое число, которое "
"меньше, больше нуля или равно ему, если I<s1>, без учёта регистра, "
"соответственно меньше, больше или равна I<s2>."

#. type: tbl table
#: man-pages/man3/strcasecmp.3:88
#, no-wrap
msgid ""
"B<strcasecmp>(),\n"
"B<strncasecmp>()"
msgstr ""
"B<strcasecmp>(),\n"
"B<strncasecmp>()"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:92
msgid "4.4BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "4.4BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:106
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions first appeared in "
"4.4BSD, where they were declared in I<E<lt>string.hE<gt>>.  Thus, for "
"reasons of historical compatibility, the glibc I<E<lt>string.hE<gt>> header "
"file also declares these functions, if the B<_DEFAULT_SOURCE> (or, in glibc "
"2.19 and earlier, B<_BSD_SOURCE>)  feature test macro is defined."
msgstr ""
"Впервые, функции B<strcasecmp>() и B<strncasecmp>() появились в 4.4BSD, где "
"они объявлялись в I<E<lt>string.hE<gt>>. Из-за этого, по причине "
"исторической совместимости, в заголовочном файле glibc I<E<lt>string.hE<gt>> "
"также объявлены эти функции, если определён макрос тестирования свойств "
"B<_DEFAULT_SOURCE> (или, в glibc 2.19 и старее, B<_BSD_SOURCE>)."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:108
msgid "The POSIX.1-2008 standard says of these functions:"
msgstr "В стандарте POSIX.1-2008 об этих функциях сказано:"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:116
msgid ""
"When the B<LC_CTYPE> category of the locale being used is from the POSIX "
"locale, these functions shall behave as if the strings had been converted to "
"lowercase and then a byte comparison performed.  Otherwise, the results are "
"unspecified."
msgstr ""
"Если используется категория локали B<LC_CTYPE> из локали POSIX, то эти "
"функции должны работать как если бы строки были преобразованы к нижнему "
"регистру и проводилось побайтовое сравнение. В противном случае результаты "
"не определёны."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:125
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"

#. type: TH
#: man-pages/man3/strtoimax.3:24
#, no-wrap
msgid "STRTOIMAX"
msgstr "STRTOIMAX"

#. type: Plain text
#: man-pages/man3/strtoimax.3:27
msgid "strtoimax, strtoumax - convert string to integer"
msgstr "strtoimax, strtoumax - преобразует строку в integer"

#. type: Plain text
#: man-pages/man3/strtoimax.3:30
#, no-wrap
msgid "B<#include E<lt>inttypes.hE<gt>>\n"
msgstr "B<#include E<lt>inttypes.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strtoimax.3:33
#, no-wrap
msgid ""
"B<intmax_t strtoimax(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
"B<uintmax_t strtoumax(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
msgstr ""
"B<intmax_t strtoimax(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
"B<uintmax_t strtoumax(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoimax.3:44
msgid ""
"These functions are just like B<strtol>(3)  and B<strtoul>(3), except that "
"they return a value of type I<intmax_t> and I<uintmax_t>, respectively."
msgstr ""
"Данные функции подобны B<strtol>(3) и B<strtoul>(3), за исключением того, "
"что возвращают значение типа I<intmax_t> и I<uintmax_t>, соответственно."

#. type: Plain text
#: man-pages/man3/strtoimax.3:57
msgid ""
"On success, the converted value is returned.  If nothing was found to "
"convert, zero is returned.  On overflow or underflow B<INTMAX_MAX> or "
"B<INTMAX_MIN> or B<UINTMAX_MAX> is returned, and I<errno> is set to "
"B<ERANGE>."
msgstr ""
"При успешном выполнении возвращается преобразованное значение. Если для "
"преобразования ничего не нашлось, то возвращается ноль. При переполнении или "
"исчерпании возвращается B<INTMAX_MAX>, B<INTMAX_MIN> или B<UINTMAX_MAX>, а в "
"I<errno> записывается B<ERANGE>."

#. type: tbl table
#: man-pages/man3/strtoimax.3:68
#, no-wrap
msgid ""
"B<strtoimax>(),\n"
"B<strtoumax>()"
msgstr ""
"B<strtoimax>(),\n"
"B<strtoumax>()"

#. type: Plain text
#: man-pages/man3/strtoimax.3:72
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/strtoimax.3:77
msgid ""
"B<imaxabs>(3), B<imaxdiv>(3), B<strtol>(3), B<strtoul>(3), B<wcstoimax>(3)"
msgstr ""
"B<imaxabs>(3), B<imaxdiv>(3), B<strtol>(3), B<strtoul>(3), B<wcstoimax>(3)"

#. type: TH
#: man-pages/man3/sysv_signal.3:25
#, no-wrap
msgid "SYSV_SIGNAL"
msgstr "SYSV_SIGNAL"

#. type: Plain text
#: man-pages/man3/sysv_signal.3:28
msgid "sysv_signal - signal handling with System V semantics"
msgstr "sysv_signal - обрабатывает сигналы согласно семантике System V"

#. type: Plain text
#: man-pages/man3/sysv_signal.3:36
msgid ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: Plain text
#: man-pages/man3/sysv_signal.3:41
msgid ""
"The B<sysv_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""
"Функция B<sysv_signal>() ожидает те же аргументы и выполняет ту же задачу, "
"что и B<signal>(2)."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:51
msgid ""
"However B<sysv_signal>()  provides the System V unreliable signal semantics, "
"that is: a) the disposition of the signal is reset to the default when the "
"handler is invoked; b) delivery of further instances of the signal is not "
"blocked while the signal handler is executing; and c) if the handler "
"interrupts (certain) blocking system calls, then the system call is not "
"automatically restarted."
msgstr ""
"Однако B<sysv_signal>() предоставляет ненадёжную семантику сигналов System "
"V, то есть: a) обработчик сигнала сбрасывается в значение по умолчанию, при "
"его вызове; b) доставка последующих экземпляров сигнала не блокируется на "
"время выполнения обработчика сигнала; c) если обработчик сигнала прерывает "
"(некоторые) блокирующие системные вызовы, то системный вызов автоматически "
"не перезапускается."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:57
msgid ""
"The B<sysv_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""
"Функция B<sysv_signal>() возвращает предыдущее значение обработчика сигнала "
"или B<SIG_ERR> при ошибке."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:60
msgid "As for B<signal>(2)."
msgstr "Как в B<signal>(2)."

#. type: tbl table
#: man-pages/man3/sysv_signal.3:70
#, no-wrap
msgid "B<sysv_signal>()"
msgstr "B<sysv_signal>()"

#. type: Plain text
#: man-pages/man3/sysv_signal.3:74
msgid "This function is nonstandard."
msgstr "Эта функция не является стандартной."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:80
msgid ""
"Use of B<sysv_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""
"Избегайте использования B<sysv_signal>(), используйте вместо неё "
"B<sigaction>(2)."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:91
msgid ""
"On older Linux systems, B<sysv_signal>()  and B<signal>(2)  were "
"equivalent.  But on newer systems, B<signal>(2)  provides reliable signal "
"semantics; see B<signal>(2)  for details."
msgstr ""
"В старых Linux-системах B<sysv_signal>() и B<signal>(2) были эквивалентны. "
"Однако в новых системах B<signal>(2) предоставляет надежную семантику "
"сигналов. Подробности смотрите в B<signal>(2)."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:99
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is defined only if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""
"Используемый параметр I<sighandler_t> является расширением GNU; данный тип "
"определён только в том случае, если определён макрос B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:103
msgid "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/string.3:30
#, no-wrap
msgid "STRING"
msgstr "STRING"

#. type: Plain text
#: man-pages/man3/string.3:36
msgid ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - string "
"operations"
msgstr ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - операции "
"со строками"

#. type: Plain text
#: man-pages/man3/string.3:38
msgid "B<#include E<lt>strings.hE<gt>>"
msgstr "B<#include E<lt>strings.hE<gt>>"

#. type: TP
#: man-pages/man3/string.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:45
msgid "Compare the strings I<s1> and I<s2> ignoring case."
msgstr "Сравнение строк I<s1> и I<s2> без учета регистра."

#. type: TP
#: man-pages/man3/string.3:45
#, no-wrap
msgid "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:54
msgid ""
"Compare the first I<n> bytes of the strings I<s1> and I<s2> ignoring case."
msgstr "Сравнивает первые I<n> байт строк I<s1> и I<s2> без учета регистра."

#. type: TP
#: man-pages/man3/string.3:54
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *index(const char *>I<s>B<, int >I<c>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:60 man-pages/man3/string.3:90
msgid ""
"Return a pointer to the first occurrence of the character I<c> in the string "
"I<s>."
msgstr ""
"Возвращает указатель на местонахождение первого совпадения с символом I<c> в "
"строке I<s>."

#. type: TP
#: man-pages/man3/string.3:60
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:66 man-pages/man3/string.3:171
msgid ""
"Return a pointer to the last occurrence of the character I<c> in the string "
"I<s>."
msgstr ""
"Возвращает указатель на местонахождение последнего совпадения с символом "
"I<c> в строке I<s>."

#. type: TP
#: man-pages/man3/string.3:66
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>"
msgstr "B<#include E<lt>string.hE<gt>>"

#. type: TP
#: man-pages/man3/string.3:68
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:76
msgid ""
"Copy a string from I<src> to I<dest>, returning a pointer to the end of the "
"resulting string at I<dest>."
msgstr ""
"Копирует строку из I<src> в I<dest>, возвращая указатель на конец строки "
"результата в I<dest>."

#. type: TP
#: man-pages/man3/string.3:76
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:84
msgid ""
"Append the string I<src> to the string I<dest>, returning a pointer I<dest>."
msgstr ""
"Добавляет строку I<src> к строке I<dest>, возвращая указатель на I<dest>."

#. type: TP
#: man-pages/man3/string.3:84
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"

#. type: TP
#: man-pages/man3/string.3:90
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:96
msgid "Compare the strings I<s1> with I<s2>."
msgstr "Сравнивает строки I<s1> и I<s2>."

#. type: TP
#: man-pages/man3/string.3:96
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:103
msgid "Compare the strings I<s1> with I<s2> using the current locale."
msgstr "Сравнивает строки I<s1> и I<s2>, применяя правила текущей локали."

#. type: TP
#: man-pages/man3/string.3:103
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:111
msgid ""
"Copy the string I<src> to I<dest>, returning a pointer to the start of "
"I<dest>."
msgstr ""
"Копирует строку I<src> в I<dest>, возвращая указатель на начало строки в "
"I<dest>."

#. type: TP
#: man-pages/man3/string.3:111
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:117
msgid ""
"Calculate the length of the initial segment of the string I<s> which does "
"not contain any of bytes in the string I<reject>,"
msgstr ""
"Вычисляет длину начального сегмента строки I<s>, состоящего только из байт, "
"не указанных в строке I<reject>,"

#. type: TP
#: man-pages/man3/string.3:117
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>"
msgstr "B<char *strdup(const char *>I<s>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:123
msgid ""
"Return a duplicate of the string I<s> in memory allocated using B<malloc>(3)."
msgstr ""
"Возвращает копию строки I<s>, память для которой выделяется с помощью "
"B<malloc>(3)."

#. type: TP
#: man-pages/man3/string.3:123
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>"
msgstr "B<char *strfry(char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:127
msgid "Randomly swap the characters in I<string>."
msgstr "Переставляет символы в I<string> в произвольном порядке."

#. type: TP
#: man-pages/man3/string.3:127
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>"
msgstr "B<size_t strlen(const char *>I<s>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:131
msgid "Return the length of the string I<s>."
msgstr "Возвращает длину строки I<s>."

#. type: TP
#: man-pages/man3/string.3:131
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:141
msgid ""
"Append at most I<n> bytes from the string I<src> to the string I<dest>, "
"returning a pointer to I<dest>."
msgstr ""
"Добавляет не более I<n> байт из строки I<src> в строку I<dest>, возвращая "
"указатель на I<dest>."

#. type: TP
#: man-pages/man3/string.3:141
#, no-wrap
msgid "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:149
msgid "Compare at most I<n> bytes of the strings I<s1> and I<s2>."
msgstr "Сравнивает не более I<n> байт строк I<s1> и I<s2>."

#. type: TP
#: man-pages/man3/string.3:149
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:159
msgid ""
"Copy at most I<n> bytes from string I<src> to I<dest>, returning a pointer "
"to the start of I<dest>."
msgstr ""
"Копирует не более I<n> байт из строки I<src> в строку I<dest>, возвращая "
"указатель на I<dest>."

#. type: TP
#: man-pages/man3/string.3:159
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:165
msgid ""
"Return a pointer to the first occurrence in the string I<s> of one of the "
"bytes in the string I<accept>."
msgstr ""
"Возвращает первое появление в строке I<s> любых байтов из строки I<accept>."

#. type: TP
#: man-pages/man3/string.3:165
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"

#. type: TP
#: man-pages/man3/string.3:171
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:177
msgid ""
"Extract the initial token in I<stringp> that is delimited by one of the "
"bytes in I<delim>."
msgstr ""
"Извлекает начальный токен из I<stringp>, который отделён одним из байтов из "
"I<delim>."

#. type: TP
#: man-pages/man3/string.3:177
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:183
msgid ""
"Calculate the length of the starting segment in the string I<s> that "
"consists entirely of bytes in I<accept>."
msgstr ""
"Вычисляет длину начального сегмента из строки I<s>, состоящего только из "
"байт, указанных в I<accept>."

#. type: TP
#: man-pages/man3/string.3:183
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:190
msgid ""
"Find the first occurrence of the substring I<needle> in the string "
"I<haystack>, returning a pointer to the found substring."
msgstr ""
"Ищет первое соответствие подстроки I<needle> в строке I<haystack> и "
"возвращает указатель на найденную подстроку."

#. type: TP
#: man-pages/man3/string.3:190
#, no-wrap
msgid "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"
msgstr "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:196
msgid ""
"Extract tokens from the string I<s> that are delimited by one of the bytes "
"in I<delim>."
msgstr ""
"Извлекает токены из строки I<s>, которые отделены одним из байтов из "
"I<delim>."

#. type: TP
#: man-pages/man3/string.3:196
#, no-wrap
msgid "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:204
msgid ""
"Transforms I<src> to the current locale and copies the first I<n> bytes to "
"I<dest>."
msgstr ""
"Преобразует I<src> в текущую локаль и копирует первые I<n> байт в I<dest>."

#. type: Plain text
#: man-pages/man3/string.3:208
msgid ""
"The string functions perform operations on null-terminated strings.  See the "
"individual man pages for descriptions of each function."
msgstr ""
"Строковые функции работают со строками, заканчивающимися null. Подробное "
"описание функций смотрите в соответствующей справочной странице."

#. type: Plain text
#: man-pages/man3/string.3:232
msgid ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"
msgstr ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"

#. type: TH
#: man-pages/man3/strnlen.3:13
#, no-wrap
msgid "STRNLEN"
msgstr "STRNLEN"

#. type: Plain text
#: man-pages/man3/strnlen.3:16
msgid "strnlen - determine the length of a fixed-size string"
msgstr "strnlen - вычисление длины строки постоянного размера"

#. type: Plain text
#: man-pages/man3/strnlen.3:21
#, no-wrap
msgid "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"
msgstr "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"

#. type: Plain text
#: man-pages/man3/strnlen.3:29
msgid "B<strnlen>():"
msgstr "B<strnlen>():"

#. type: Plain text
#: man-pages/man3/strnlen.3:58
msgid ""
"The B<strnlen>()  function returns the number of bytes in the string pointed "
"to by I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq), but at "
"most I<maxlen>.  In doing this, B<strnlen>()  looks only at the first "
"I<maxlen> characters in the string pointed to by I<s> and never beyond I<s"
"+maxlen>."
msgstr ""
"Функция B<strnlen>() возвращает количество байт в строке, на которую "
"указывает I<s>, не считая завершающего байта null (\\(aq\\e0\\(aq), но не "
"более I<maxlen>. При этом B<strnlen>() обращается только к первым I<maxlen> "
"символам, на которые указывает I<s>, и никогда не выходит дальше I<s+maxlen>."

#. type: Plain text
#: man-pages/man3/strnlen.3:71
msgid ""
"The B<strnlen>()  function returns I<strlen(s)>, if that is less than "
"I<maxlen>, or I<maxlen> if there is no null terminating (\\(aq\\e0\\(aq) "
"among the first I<maxlen> characters pointed to by I<s>."
msgstr ""
"Функция B<strnlen>() возвращает I<strlen(s)>, если оно меньше I<maxlen>, или "
"I<maxlen>, если среди первых I<maxlen> байт, на которую указывает I<s>, не "
"встретился завершающий байт null (\\(aq\\e0\\(aq)."

#. type: tbl table
#: man-pages/man3/strnlen.3:81
#, no-wrap
msgid "B<strnlen>()"
msgstr "B<strnlen>()"

#. type: Plain text
#: man-pages/man3/strnlen.3:85
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: TH
#: man-pages/man3/strfromd.3:32
#, no-wrap
msgid "STRFROMD"
msgstr "STRFROMD"

#. type: Plain text
#: man-pages/man3/strfromd.3:36
msgid ""
"strfromd, strfromf, strfroml - convert a floating-point value into a string"
msgstr ""
"strfromd, strfromf, strfroml - преобразуют значение с плавающей запятой в "
"строку"

#. type: Plain text
#: man-pages/man3/strfromd.3:46
#, no-wrap
msgid ""
"B<int strfromd(char *restrict >I<str>B<, size_t >I<n>B<,>\n"
"B<             const char *restrict >I<format>B<, double >I<fp>B<);>\n"
"B<int strfromf(char *restrict >I<str>B<, size_t >I<n>B<,>\n"
"B<             const char *restrict >I<format>B<, float >I<fp>B<);>\n"
"B<int strfroml(char *restrict >I<str>B<, size_t >I<n>B<,>\n"
"B<             const char *restrict >I<format>B<, long double >I<fp>B<);>\n"
msgstr ""
"B<int strfromd(char *restrict >I<str>B<, size_t >I<n>B<,>\n"
"B<             const char *restrict >I<format>B<, double >I<fp>B<);>\n"
"B<int strfromf(char *restrict >I<str>B<, size_t >I<n>B<,>\n"
"B<             const char *restrict >I<format>B<, float >I<fp>B<);>\n"
"B<int strfroml(char *restrict >I<str>B<, size_t >I<n>B<,>\n"
"B<             const char *restrict >I<format>B<, long double >I<fp>B<);>\n"

#. type: Plain text
#: man-pages/man3/strfromd.3:57
msgid "B<strfromd>(), B<strfromf>(), B<strfroml>():"
msgstr "B<strfromd>(), B<strfromf>(), B<strfroml>():"

#. type: Plain text
#: man-pages/man3/strfromd.3:59
msgid "__STDC_WANT_IEC_60559_BFP_EXT__"
msgstr "__STDC_WANT_IEC_60559_BFP_EXT__"

#. type: Plain text
#: man-pages/man3/strfromd.3:73
msgid ""
"These functions convert a floating-point value, I<fp>, into a string of "
"characters, I<str>, with a configurable I<format> string.  At most I<n> "
"characters are stored into I<str>."
msgstr ""
"Данные функции преобразуют значение с плавающей запятой I<fp> в строку "
"символов I<str> в соответствии со строкой формата I<format>. В I<str> "
"записывается не более I<n> символов."

#. type: Plain text
#: man-pages/man3/strfromd.3:79
msgid ""
"The terminating null character ('\\e0') is written if and only if I<n> is "
"sufficiently large, otherwise the written string is truncated at I<n> "
"characters."
msgstr ""
"Конечный символ null ('\\e0') записывается только, если I<n> достаточно "
"велико; в противном случае записываемая строка обрезается до I<n> символов."

#. type: Plain text
#: man-pages/man3/strfromd.3:86
msgid ""
"The B<strfromd>(), B<strfromf>(), and B<strfroml>()  functions are "
"equivalent to"
msgstr "Функции B<strfromd>(), B<strfromf>() и B<strfroml>() эквивалентны"

#. type: Plain text
#: man-pages/man3/strfromd.3:90
#, no-wrap
msgid "snprintf(str, n, format, fp);\n"
msgstr "snprintf(str, n, format, fp);\n"

#. type: Plain text
#: man-pages/man3/strfromd.3:96
msgid "except for the I<format> string."
msgstr "не считая строки I<format>."

#. type: SS
#: man-pages/man3/strfromd.3:96
#, no-wrap
msgid "Format of the format string"
msgstr "Структура строки формата"

#. type: Plain text
#: man-pages/man3/strfromd.3:114
msgid ""
"The I<format> string must start with the character \\(aq%\\(aq.  This is "
"followed by an optional precision which starts with the period character "
"(.), followed by an optional decimal integer.  If no integer is specified "
"after the period character, a precision of zero is used.  Finally, the "
"format string should have one of the conversion specifiers B<a>, B<A>, B<e>, "
"B<E>, B<f>, B<F>, B<g>, or B<G>."
msgstr ""
"Строка I<format> должна начинаться с символа \\(aq%\\(aq. За ним следует "
"необязательное значение точности, состоящее из символа точки (.) и "
"необязательного десятичного числа. Если число не указано, то используется "
"точность ноль. В конце строка формата должна содержать один из "
"преобразователей: B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g> или B<G>."

#. type: Plain text
#: man-pages/man3/strfromd.3:123
msgid ""
"The conversion specifier is applied based on the floating-point type "
"indicated by the function suffix.  Therefore, unlike B<snprintf>(), the "
"format string does not have a length modifier character.  See "
"B<snprintf>(3)  for a detailed description of these conversion specifiers."
msgstr ""
"Преобразователи применяются в соответствии с типом плавающей запятой, "
"представленным суффиксом функции. В связи с этим, в отличии от B<snprintf>() "
"строка формата не содержит символа модификатора длины. Подробное описание "
"преобразователей смотрите в B<snprintf>(3)."

#. type: Plain text
#: man-pages/man3/strfromd.3:126
msgid ""
"The implementation conforms to the C99 standard on conversion of NaN and "
"infinity values:"
msgstr ""
"Для значений бесконечности и NaN реализация соответствует стандарту C99:"

#. type: Plain text
#: man-pages/man3/strfromd.3:145
msgid ""
"If I<fp> is a NaN, +NaN, or -NaN, and B<f> (or B<a>, B<e>, B<g>)  is the "
"conversion specifier, the conversion is to \"nan\", \"nan\", or \"-nan\", "
"respectively.  If B<F> (or B<A>, B<E>, B<G>)  is the conversion specifier, "
"the conversion is to \"NAN\" or \"-NAN\"."
msgstr ""
"Если I<fp> равно NaN, +NaN или -NaN и указан преобразователь B<f> (или B<a>, "
"B<e>, B<g>), то выполняется преобразование в «nan», «nan» или «-nan», "
"соответственно. Если указан преобразователь B<F> (или B<A>, B<E>, B<G>), то "
"выполняется преобразование в «NAN» или «-NAN»."

#. type: Plain text
#: man-pages/man3/strfromd.3:149
msgid "Likewise if I<fp> is infinity, it is converted to [-]inf or [-]INF."
msgstr ""
"Если I<fp> равно бесконечности, то она схожим образом преобразуется в [-]inf "
"или [-]INF."

#. type: Plain text
#: man-pages/man3/strfromd.3:154
msgid "A malformed I<format> string results in undefined behavior."
msgstr "Некорректная строка I<format> вызывает непредсказуемое поведение."

#. type: Plain text
#: man-pages/man3/strfromd.3:169
msgid ""
"The B<strfromd>(), B<strfromf>(), and B<strfroml>()  functions return the "
"number of characters that would have been written in I<str> if I<n> had "
"enough space, not counting the terminating null character.  Thus, a return "
"value of I<n> or greater means that the output was truncated."
msgstr ""
"Функции B<strfromd>(), B<strfromf>() и B<strfroml>() возвращают количество "
"символов, которое было бы записано в I<str>, если был I<n> было бы "
"достаточно большим, без учёта конечного символа null.  То есть если было "
"возвращено значение I<n> или больше, то это указывает на то, что результат "
"был обрезан."

#. type: Plain text
#: man-pages/man3/strfromd.3:176
msgid ""
"The B<strfromd>(), B<strfromf>(), and B<strfroml>()  functions are available "
"in glibc since version 2.25."
msgstr ""
"Функции B<strfromd>(), B<strfromf>() и B<strfroml>() доступны в glibc "
"начиная с версии 2.25."

#. type: Plain text
#: man-pages/man3/strfromd.3:182
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)  "
"and the B<POSIX Safety Concepts> section in GNU C Library manual."
msgstr ""
"Описание терминов данного раздела смотрите в B<attributes>(7) и разделе "
"B<POSIX Safety Concepts> руководства библиотеки GNU C."

#. type: tbl table
#: man-pages/man3/strfromd.3:192
#, no-wrap
msgid ""
"B<strfromd>(),\n"
"B<strfromf>(),\n"
"B<strfroml>()"
msgstr ""
"B<strfromd>(),\n"
"B<strfromf>(),\n"
"B<strfroml>()"

#. type: tbl table
#: man-pages/man3/strfromd.3:193 man-pages/man3/strfromd.3:194
#, no-wrap
msgid "\\^"
msgstr "\\^"

#. type: tbl table
#: man-pages/man3/strfromd.3:193
#, no-wrap
msgid "Asynchronous signal safety"
msgstr "Безопасность в асинхронных сигналах"

#. type: tbl table
#: man-pages/man3/strfromd.3:193
#, no-wrap
msgid "AS-Unsafe heap"
msgstr "AS-Unsafe heap"

#. type: tbl table
#: man-pages/man3/strfromd.3:194
#, no-wrap
msgid "Asynchronous cancellation safety"
msgstr "Безопасность в асинхронной отмене"

#. type: tbl table
#: man-pages/man3/strfromd.3:194
#, no-wrap
msgid "AC-Unsafe mem"
msgstr "AC-Unsafe mem"

#. type: Plain text
#: man-pages/man3/strfromd.3:198
msgid "Note: these attributes are preliminary."
msgstr "Замечание: эти атрибуты только предварительны."

#. type: Plain text
#: man-pages/man3/strfromd.3:200
msgid "C99, ISO/IEC TS 18661-1."
msgstr "C99, ISO/IEC TS 18661-1."

#. type: Plain text
#: man-pages/man3/strfromd.3:209
msgid ""
"The B<strfromd>(), B<strfromf>(), and B<strfroml>()  functions take account "
"of the B<LC_NUMERIC> category of the current locale."
msgstr ""
"Функции B<strfromd>(), B<strfromf>() и B<strfroml>() учитывают категорию "
"B<LC_NUMERIC> текущей локали."

#. type: SH
#: man-pages/man3/strfromd.3:209
#, no-wrap
msgid "EXAMPLES"
msgstr "ПРИМЕРЫ"

#. type: Plain text
#: man-pages/man3/strfromd.3:212
msgid ""
"To convert the value 12.1 as a float type to a string using decimal "
"notation, resulting in \"12.100000\":"
msgstr ""
"Преобразует значение 12.1 с типом float в строку используя десятичное "
"написание, равную «12.100000»:"

#. type: Plain text
#: man-pages/man3/strfromd.3:220
#, no-wrap
msgid ""
"#define __STDC_WANT_IEC_60559_BFP_EXT__\n"
"#include E<lt>stdlib.hE<gt>\n"
"int ssize = 10;\n"
"char s[ssize];\n"
"strfromf(s, ssize, \"%f\", 12.1);\n"
msgstr ""
"#define __STDC_WANT_IEC_60559_BFP_EXT__\n"
"#include E<lt>stdlib.hE<gt>\n"
"int ssize = 10;\n"
"char s[ssize];\n"
"strfromf(s, ssize, \"%f\", 12.1);\n"

#. type: Plain text
#: man-pages/man3/strfromd.3:225
msgid ""
"To convert the value 12.3456 as a float type to a string using decimal "
"notation with two digits of precision, resulting in \"12.35\":"
msgstr ""
"Преобразует значение 12.3456 с типом float в строку используя десятичное "
"написание с двумя цифрами точности, равную «12.35»:"

#. type: Plain text
#: man-pages/man3/strfromd.3:233
#, no-wrap
msgid ""
"#define __STDC_WANT_IEC_60559_BFP_EXT__\n"
"#include E<lt>stdlib.hE<gt>\n"
"int ssize = 10;\n"
"char s[ssize];\n"
"strfromf(s, ssize, \"%.2f\", 12.3456);\n"
msgstr ""
"#define __STDC_WANT_IEC_60559_BFP_EXT__\n"
"#include E<lt>stdlib.hE<gt>\n"
"int ssize = 10;\n"
"char s[ssize];\n"
"strfromf(s, ssize, \"%.2f\", 12.3456);\n"

#. type: Plain text
#: man-pages/man3/strfromd.3:238
msgid ""
"To convert the value 12.345e19 as a double type to a string using scientific "
"notation with zero digits of precision, resulting in \"1E+20\":"
msgstr ""
"Преобразует значение 12.345e19 с типом double в строку используя научное "
"написание с нулевой точностью, равную «1E+20»:"

#. type: Plain text
#: man-pages/man3/strfromd.3:246
#, no-wrap
msgid ""
"#define __STDC_WANT_IEC_60559_BFP_EXT__\n"
"#include E<lt>stdlib.hE<gt>\n"
"int ssize = 10;\n"
"char s[ssize];\n"
"strfromd(s, ssize, \"%.E\", 12.345e19);\n"
msgstr ""
"#define __STDC_WANT_IEC_60559_BFP_EXT__\n"
"#include E<lt>stdlib.hE<gt>\n"
"int ssize = 10;\n"
"char s[ssize];\n"
"strfromd(s, ssize, \"%.E\", 12.345e19);\n"

#. type: Plain text
#: man-pages/man3/strfromd.3:251
msgid "B<atof>(3), B<snprintf>(3), B<strtod>(3)"
msgstr "B<atof>(3), B<snprintf>(3), B<strtod>(3)"

#. type: TH
#: man-pages/man3/setenv.3:37
#, no-wrap
msgid "SETENV"
msgstr "SETENV"

#. type: Plain text
#: man-pages/man3/setenv.3:40
msgid "setenv - change or add an environment variable"
msgstr "setenv - изменяет или добавляет переменную окружения"

#. type: Plain text
#: man-pages/man3/setenv.3:45
#, no-wrap
msgid "B<int setenv(const char *>I<name>B<, const char *>I<value>B<, int >I<overwrite>B<);>\n"
msgstr "B<int setenv(const char *>I<name>B<, const char *>I<value>B<, int >I<overwrite>B<);>\n"

#. type: Plain text
#: man-pages/man3/setenv.3:47
#, no-wrap
msgid "B<int unsetenv(const char *>I<name>B<);>\n"
msgstr "B<int unsetenv(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/setenv.3:57
msgid "B<setenv>(), B<unsetenv>():"
msgstr "B<setenv>(), B<unsetenv>():"

#. type: Plain text
#: man-pages/man3/setenv.3:95
msgid ""
"The B<setenv>()  function adds the variable I<name> to the environment with "
"the value I<value>, if I<name> does not already exist.  If I<name> does "
"exist in the environment, then its value is changed to I<value> if "
"I<overwrite> is nonzero; if I<overwrite> is zero, then the value of I<name> "
"is not changed (and B<setenv>()  returns a success status).  This function "
"makes copies of the strings pointed to by I<name> and I<value> (by contrast "
"with B<putenv>(3))."
msgstr ""
"Функция B<setenv>() добавляет переменную I<name> в окружение со значением "
"I<value>, если I<name> ещё не существует. Если I<name> в окружении "
"существует, то её значение изменяется на I<value>, если I<overwrite> имеет "
"ненулевое значение; если I<overwrite> равно нулю, то значение I<name> не "
"изменяется (и B<setenv>() завершается без ошибки). Эта функция делает копию "
"строк, указанных в I<name> и I<value> (в отличии от B<putenv>(3))."

#. type: Plain text
#: man-pages/man3/setenv.3:106
msgid ""
"The B<unsetenv>()  function deletes the variable I<name> from the "
"environment.  If I<name> does not exist in the environment, then the "
"function succeeds, and the environment is unchanged."
msgstr ""
"Функция B<unsetenv>() удаляет переменную I<name> из окружения. Если I<name> "
"в окружении не существует, то функция завершается без ошибки и окружение не "
"изменяется."

#. type: Plain text
#: man-pages/man3/setenv.3:113
msgid ""
"The B<setenv>()  function returns zero on success, or -1 on error, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<setenv>() возвращает ноль, при ошибке возвращается "
"-1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/setenv.3:120
msgid ""
"The B<unsetenv>()  function returns zero on success, or -1 on error, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<unsetenv>() возвращает ноль, при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/setenv.3:126
msgid ""
"I<name> is NULL, points to a string of length 0, or contains an \\(aq=\\(aq "
"character."
msgstr ""
"Значение I<name> равно NULL, указывает на строку нулевой длины или "
"содержащую символ \\(aq=\\(aq."

#. type: Plain text
#: man-pages/man3/setenv.3:129
msgid "Insufficient memory to add a new variable to the environment."
msgstr "Недостаточно памяти для добавления новой переменной в окружение."

#. type: tbl table
#: man-pages/man3/setenv.3:141
#, no-wrap
msgid ""
"B<setenv>(),\n"
"B<unsetenv>()"
msgstr ""
"B<setenv>(),\n"
"B<unsetenv>()"

#. type: tbl table
#: man-pages/man3/setenv.3:141
#, no-wrap
msgid "MT-Unsafe const:env"
msgstr "MT-Unsafe const:env"

#. type: Plain text
#: man-pages/man3/setenv.3:152
msgid ""
"POSIX.1 does not require B<setenv>()  or B<unsetenv>()  to be reentrant."
msgstr ""
"В POSIX.1 не требуется, чтобы B<setenv>() или B<unsetenv>() были "
"реентерабельными."

#. type: Plain text
#: man-pages/man3/setenv.3:160
msgid ""
"Prior to glibc 2.2.2, B<unsetenv>()  was prototyped as returning I<void>; "
"more recent glibc versions follow the POSIX.1-compliant prototype shown in "
"the SYNOPSIS."
msgstr ""
"До glibc 2.2.2, B<unsetenv>() объявлялась как возвращающая I<void>; более "
"новые версии glibc следуют объявлению из POSIX.1, показанному в ОБЗОРЕ."

#. type: Plain text
#: man-pages/man3/setenv.3:169
msgid ""
"POSIX.1 specifies that if I<name> contains an \\(aq=\\(aq character, then "
"B<setenv>()  should fail with the error B<EINVAL>; however, versions of "
"glibc before 2.3.4 allowed an \\(aq=\\(aq sign in I<name>."
msgstr ""
"В POSIX.1 указано, что если I<name> содержит символ \\(aq=\\(aq, то "
"B<setenv>() должна завершаться с ошибкой B<EINVAL>; однако версии glibc до "
"2.3.4 допускали знак \\(aq=\\(aq в I<name>."

#. type: Plain text
#: man-pages/man3/setenv.3:173
msgid "B<clearenv>(3), B<getenv>(3), B<putenv>(3), B<environ>(7)"
msgstr "B<clearenv>(3), B<getenv>(3), B<putenv>(3), B<environ>(7)"

#. type: TH
#: man-pages/man3/scandir.3:62
#, no-wrap
msgid "SCANDIR"
msgstr "SCANDIR"

#. type: Plain text
#: man-pages/man3/scandir.3:66
msgid ""
"scandir, scandirat, alphasort, versionsort - scan a directory for matching "
"entries"
msgstr "scandir, scandirat, alphasort, versionsort - ищет записи в каталоге"

#. type: Plain text
#: man-pages/man3/scandir.3:69
#, no-wrap
msgid "B<#include E<lt>dirent.hE<gt>>\n"
msgstr "B<#include E<lt>dirent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:71
#, no-wrap
msgid "B<int scandir(const char *>I<dirp>B<, struct dirent ***>I<namelist>B<,>\n"
msgstr "B<int scandir(const char *>I<dirp>B<, struct dirent ***>I<namelist>B<,>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:74 man-pages/man3/scandir.3:90
#, no-wrap
msgid ""
"B<int (*>I<filter>B<)(const struct dirent *),>\n"
"B<int (*>I<compar>B<)(const struct dirent **, const struct dirent **));>\n"
msgstr ""
"B<int (*>I<filter>B<)(const struct dirent *),>\n"
"B<int (*>I<compar>B<)(const struct dirent **, const struct dirent **));>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:77
#, no-wrap
msgid "B<int alphasort(const struct dirent **>I<a>B<, const struct dirent **>I<b>B<);>\n"
msgstr "B<int alphasort(const struct dirent **>I<a>B<, const struct dirent **>I<b>B<);>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:79
#, no-wrap
msgid "B<int versionsort(const struct dirent **>I<a>B<, const struct dirent **>I<b>B<);>\n"
msgstr "B<int versionsort(const struct dirent **>I<a>B<, const struct dirent **>I<b>B<);>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:82
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>          /* Definition of AT_* constants */\n"
"B<#include E<lt>dirent.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>          /* определения констант AT_* */\n"
"B<#include E<lt>dirent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:86
msgid ""
"B<int scandirat(int >I<dirfd>B<, const char *>I<dirp>B<,> B<struct dirent "
"***>I<namelist>B<,>"
msgstr ""
"B<int scandirat(int >I<dirfd>B<, const char *>I<dirp>B<,> B<struct dirent "
"***>I<namelist>B<,>"

#. type: Plain text
#: man-pages/man3/scandir.3:100
msgid "B<scandir>(), B<alphasort>():"
msgstr "B<scandir>(), B<alphasort>():"

#. type: Plain text
#: man-pages/man3/scandir.3:106
#, no-wrap
msgid ""
"/* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/scandir.3:111
msgid "B<versionsort>(): _GNU_SOURCE"
msgstr "B<versionsort>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/scandir.3:114
msgid "B<scandirat>(): _GNU_SOURCE"
msgstr "B<scandirat>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/scandir.3:129
msgid ""
"The B<scandir>()  function scans the directory I<dirp>, calling I<filter>() "
"on each directory entry.  Entries for which I<filter>() returns nonzero are "
"stored in strings allocated via B<malloc>(3), sorted using B<qsort>(3)  with "
"the comparison function I<compar>(), and collected in array I<namelist> "
"which is allocated via B<malloc>(3).  If I<filter> is NULL, all entries are "
"selected."
msgstr ""
"Функция B<scandir>() обходит каталог I<dirp>, вызывая I<filter>() для каждой "
"записи каталога. Записи, для которых I<filter>() возвращает не ноль, "
"сохраняются в строках, выделяемых с помощью B<malloc>(3), сортируются "
"B<qsort>(3) с помощью функции сравнения I<compar>() и собираются в массиве "
"I<namelist>, который выделяется с помощью B<malloc>(3). Если I<filter> равно "
"NULL, то выбираются все записи."

#. type: Plain text
#: man-pages/man3/scandir.3:141
msgid ""
"The B<alphasort>()  and B<versionsort>()  functions can be used as the "
"comparison function I<compar>().  The former sorts directory entries using "
"B<strcoll>(3), the latter using B<strverscmp>(3)  on the strings I<(*a)-"
"E<gt>d_name> and I<(*b)-E<gt>d_name>."
msgstr ""
"В качестве функции сравнения I<compar>() можно использовать B<alphasort>() и "
"B<versionsort>(). Первая сортирует записи (строки I<(*a)-E<gt>d_name> и "
"I<(*b)-E<gt>d_name>) каталога с помощью B<strcoll>(3), а последняя с помощью "
"B<strverscmp>(3)."

#. type: SS
#: man-pages/man3/scandir.3:141
#, no-wrap
msgid "scandirat()"
msgstr "scandirat()"

#. type: Plain text
#: man-pages/man3/scandir.3:147
msgid ""
"The B<scandirat>()  function operates in exactly the same way as "
"B<scandir>(), except for the differences described here."
msgstr ""
"Системный вызов B<scandirat>() работает также как системный вызов "
"B<scandir>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man3/scandir.3:157
msgid ""
"If the pathname given in I<dirp> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<scandir>()  for a relative pathname)."
msgstr ""
"Если в I<dirp> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<scandir>())."

#. type: Plain text
#: man-pages/man3/scandir.3:169
msgid ""
"If I<dirp> is relative and I<dirfd> is the special value B<AT_FDCWD>, then "
"I<dirp> is interpreted relative to the current working directory of the "
"calling process (like B<scandir>())."
msgstr ""
"Если в I<dirp> задан относительный путь и значение I<dirfd> равно "
"B<AT_FDCWD>, то I<dirp> рассматривается относительно текущего рабочего "
"каталога вызывающего процесса (как B<scandir>())."

#. type: Plain text
#: man-pages/man3/scandir.3:175
msgid "If I<dirp> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<dirp> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man3/scandir.3:180
msgid "See B<openat>(2)  for an explanation of the need for B<scandirat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<scandirat>()."

#. type: Plain text
#: man-pages/man3/scandir.3:188
msgid ""
"The B<scandir>()  function returns the number of directory entries "
"selected.  On error, -1 is returned, with I<errno> set to indicate the cause "
"of the error."
msgstr ""
"При успешном выполнении B<scandir>() возвращается количество выбранных "
"записей каталога. При ошибке возвращается -1, а в I<errno> содержится код "
"ошибки."

#. type: Plain text
#: man-pages/man3/scandir.3:196
msgid ""
"The B<alphasort>()  and B<versionsort>()  functions return an integer less "
"than, equal to, or greater than zero if the first argument is considered to "
"be respectively less than, equal to, or greater than the second."
msgstr ""
"Функции B<alphasort>() и B<versionsort>() возвращают целое, меньшее, равное "
"или большее нуля, если первый аргумент считается меньшим, равным или большим "
"чем второй, соответственно."

#. type: Plain text
#: man-pages/man3/scandir.3:200
msgid "The path in I<dirp> does not exist."
msgstr "Путь в I<dirp> не существует."

#. type: Plain text
#: man-pages/man3/scandir.3:203
msgid "Insufficient memory to complete the operation."
msgstr "Недостаточно памяти для завершения операции."

#. type: Plain text
#: man-pages/man3/scandir.3:206
msgid "The path in I<dirp> is not a directory."
msgstr "Путь в I<dirp> не является каталогом."

#. type: Plain text
#: man-pages/man3/scandir.3:209
msgid "The following additional errors can occur for B<scandirat>():"
msgstr "В B<scandirat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man3/scandir.3:219
msgid ""
"I<dirp> is a relative path and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<dirp> содержит относительный путь и I<dirfd> содержит файловый "
"дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man3/scandir.3:222
msgid "B<versionsort>()  was added to glibc in version 2.1."
msgstr "Функция B<versionsort>() впервые появилась в glibc 2.1."

#. type: Plain text
#: man-pages/man3/scandir.3:225
msgid "B<scandirat>()  was added to glibc in version 2.15."
msgstr "Функция B<scandirat>() впервые появилась в glibc 2.15."

#. type: tbl table
#: man-pages/man3/scandir.3:236
#, no-wrap
msgid ""
"B<scandir>(),\n"
"B<scandirat>()"
msgstr ""
"B<scandir>(),\n"
"B<scandirat>()"

#. type: tbl table
#: man-pages/man3/scandir.3:240
#, no-wrap
msgid ""
"B<alphasort>(),\n"
"B<versionsort>()"
msgstr ""
"B<alphasort>(),\n"
"B<versionsort>()"

#. type: Plain text
#: man-pages/man3/scandir.3:247
msgid "B<alphasort>(), B<scandir>(): 4.3BSD, POSIX.1-2008."
msgstr "B<alphasort>(), B<scandir>(): 4.3BSD, POSIX.1-2008."

#.  .LP
#.  The functions
#.  .BR scandir ()
#.  and
#.  .BR alphasort ()
#.  are from 4.3BSD, and have been available under Linux since libc4.
#.  Libc4 and libc5 use the more precise prototype
#.  .sp
#.  .nf
#.     int alphasort(const struct dirent ** a,
#.                   const struct dirent **b);
#.  .fi
#.  .sp
#.  but glibc 2.0 returns to the imprecise BSD prototype.
#. type: Plain text
#: man-pages/man3/scandir.3:266
msgid "B<versionsort>()  and B<scandirat>()  are GNU extensions."
msgstr "Функции B<versionsort>() и B<scandirat>() являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/scandir.3:273
msgid ""
"Since glibc 2.1, B<alphasort>()  calls B<strcoll>(3); earlier it used "
"B<strcmp>(3)."
msgstr ""
"Начиная с glibc 2.1, B<alphasort>() вызывает B<strcoll>(3); раньше в ней "
"использовалась B<strcmp>(3)."

#. type: Plain text
#: man-pages/man3/scandir.3:290
msgid ""
"Before glibc 2.10, the two arguments of B<alphasort>()  and "
"B<versionsort>()  were typed as I<const void\\ *>.  When B<alphasort>()  was "
"standardized in POSIX.1-2008, the argument type was specified as the type-"
"safe I<const struct dirent\\ **>, and glibc 2.10 changed the definition of "
"B<alphasort>()  (and the nonstandard B<versionsort>())  to match the "
"standard."
msgstr ""
"До glibc 2.10, два аргумента B<alphasort>() и B<versionsort>() имели тип "
"I<const void\\ *>. После стандартизации B<alphasort>() в  POSIX.1-2008, тип "
"аргумента argument стал типобезопасным I<const struct dirent\\ **>, и в "
"glibc 2.10 функция B<alphasort>() (и нестандартная B<versionsort>()) была "
"приведена в соответствие со стандартом."

#. type: Plain text
#: man-pages/man3/scandir.3:294
msgid ""
"The program below prints a list of the files in the current directory in "
"reverse order."
msgstr ""
"Программа, показанная ниже, печатает список файлов в текущем каталоге в "
"обратном порядке."

#. type: Plain text
#: man-pages/man3/scandir.3:301
#, no-wrap
msgid ""
"#define _DEFAULT_SOURCE\n"
"#include E<lt>dirent.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _DEFAULT_SOURCE\n"
"#include E<lt>dirent.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:307
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct dirent **namelist;\n"
"    int n;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct dirent **namelist;\n"
"    int n;\n"

#. type: Plain text
#: man-pages/man3/scandir.3:313
#, no-wrap
msgid ""
"    n = scandir(\".\", &namelist, NULL, alphasort);\n"
"    if (n == -1) {\n"
"        perror(\"scandir\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    n = scandir(\".\", &namelist, NULL, alphasort);\n"
"    if (n == -1) {\n"
"        perror(\"scandir\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/scandir.3:319
#, no-wrap
msgid ""
"    while (n--) {\n"
"        printf(\"%s\\en\", namelist[n]-E<gt>d_name);\n"
"        free(namelist[n]);\n"
"    }\n"
"    free(namelist);\n"
msgstr ""
"    while (n--) {\n"
"        printf(\"%s\\en\", namelist[n]-E<gt>d_name);\n"
"        free(namelist[n]);\n"
"    }\n"
"    free(namelist);\n"

#. type: Plain text
#: man-pages/man3/scandir.3:333
msgid ""
"B<closedir>(3), B<fnmatch>(3), B<opendir>(3), B<readdir>(3), "
"B<rewinddir>(3), B<seekdir>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strverscmp>(3), B<telldir>(3)"
msgstr ""
"B<closedir>(3), B<fnmatch>(3), B<opendir>(3), B<readdir>(3), "
"B<rewinddir>(3), B<seekdir>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strverscmp>(3), B<telldir>(3)"

#. type: TH
#: man-pages/man3/siginterrupt.3:31
#, no-wrap
msgid "SIGINTERRUPT"
msgstr "SIGINTERRUPT"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:34
msgid "siginterrupt - allow signals to interrupt system calls"
msgstr "siginterrupt - разрешает сигналам прерывать системные вызовы"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:39
#, no-wrap
msgid "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"
msgstr "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:47
msgid "B<siginterrupt>():"
msgstr "B<siginterrupt>():"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:64
msgid ""
"The B<siginterrupt>()  function changes the restart behavior when a system "
"call is interrupted by the signal I<sig>.  If the I<flag> argument is false "
"(0), then system calls will be restarted if interrupted by the specified "
"signal I<sig>.  This is the default behavior in Linux."
msgstr ""
"Функция B<siginterrupt>() изменяет поведение перезапуска когда системный "
"вызов прерывается сигналом I<sig>. Если аргумент I<flag> ложен (0), то "
"системные вызова будут перезапускаться, если они прерывались указанным "
"сигналом I<sig>. Это поведение Linux по умолчанию."

#. type: Plain text
#: man-pages/man3/siginterrupt.3:69
msgid ""
"If the I<flag> argument is true (1) and no data has been transferred, then a "
"system call interrupted by the signal I<sig> will return -1 and I<errno> "
"will be set to B<EINTR>."
msgstr ""
"Если аргумент I<flag> истинен (1) и не пересылались данные, то системный "
"вызов, прерванный сигналом I<sig> вернёт -1 и I<errno> будет присвоено "
"значение B<EINTR>."

#. type: Plain text
#: man-pages/man3/siginterrupt.3:73
msgid ""
"If the I<flag> argument is true (1) and data transfer has started, then the "
"system call will be interrupted and will return the actual amount of data "
"transferred."
msgstr ""
"Если аргумент I<flag> истинен (1) и началась пересылка данных, то системный "
"вызов будет прерван и вернёт действительное количество пересланных данных."

#. type: Plain text
#: man-pages/man3/siginterrupt.3:83
msgid ""
"The B<siginterrupt>()  function returns 0 on success.  It returns -1 if the "
"signal number I<sig> is invalid, with I<errno> set to indicate the cause of "
"the error."
msgstr ""
"При успешном выполнении B<siginterrupt>() возвращает ноль. Она возвращает "
"-1, если был указан неправильный номер сигнала I<sig>, ив I<errno> будет "
"указан код ошибки."

#. type: Plain text
#: man-pages/man3/siginterrupt.3:87
msgid "The specified signal number is invalid."
msgstr "Задан некорректный номер сигнала."

#. type: tbl table
#: man-pages/man3/siginterrupt.3:97
#, no-wrap
msgid "B<siginterrupt>()"
msgstr "B<siginterrupt>()"

#. type: tbl table
#: man-pages/man3/siginterrupt.3:97
#, no-wrap
msgid "MT-Unsafe const:sigintr"
msgstr "MT-Unsafe const:sigintr"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:108
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<siginterrupt>()  as obsolete, "
"recommending the use of B<sigaction>(2)  with the B<SA_RESTART> flag instead."
msgstr ""
"4.3BSD, POSIX.1-2001. В POSIX.1-2008 функция B<siginterrupt>() помечена как "
"устаревшая, вместо неё рекомендуется использовать B<sigaction>(2) с флагом "
"B<SA_RESTART>."

#. type: TH
#: man-pages/man3/statvfs.3:30
#, no-wrap
msgid "STATVFS"
msgstr "STATVFS"

#. type: Plain text
#: man-pages/man3/statvfs.3:33
msgid "statvfs, fstatvfs - get filesystem statistics"
msgstr "statvfs, fstatvfs - получение статистики по файловой системе"

#. type: Plain text
#: man-pages/man3/statvfs.3:35
msgid "B<#include E<lt>sys/statvfs.hE<gt>>"
msgstr "B<#include E<lt>sys/statvfs.hE<gt>>"

#. type: Plain text
#: man-pages/man3/statvfs.3:37
msgid "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man3/statvfs.3:39
msgid "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man3/statvfs.3:49
msgid ""
"The function B<statvfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statvfs> structure defined approximately as follows:"
msgstr ""
"Функция B<statvfs>() возвращает информацию о смонтированной файловой "
"системе. I<path> является путём любого файла, расположенного в "
"смонтированной файловой системе. I<buf> является указателем на структуру "
"I<statvfs>, определённую примерно следующим образом:"

#. type: Plain text
#: man-pages/man3/statvfs.3:67
#, no-wrap
msgid ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* Filesystem block size */\n"
"    unsigned long  f_frsize;   /* Fragment size */\n"
"    fsblkcnt_t     f_blocks;   /* Size of fs in f_frsize units */\n"
"    fsblkcnt_t     f_bfree;    /* Number of free blocks */\n"
"    fsblkcnt_t     f_bavail;   /* Number of free blocks for\n"
"                                  unprivileged users */\n"
"    fsfilcnt_t     f_files;    /* Number of inodes */\n"
"    fsfilcnt_t     f_ffree;    /* Number of free inodes */\n"
"    fsfilcnt_t     f_favail;   /* Number of free inodes for\n"
"                                  unprivileged users */\n"
"    unsigned long  f_fsid;     /* Filesystem ID */\n"
"    unsigned long  f_flag;     /* Mount flags */\n"
"    unsigned long  f_namemax;  /* Maximum filename length */\n"
"};\n"
msgstr ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* размер блока файловой системы */\n"
"    unsigned long  f_frsize;   /* размер фрагмента */\n"
"    fsblkcnt_t     f_blocks;   /* размер ФС в единицах f_frsize */\n"
"    fsblkcnt_t     f_bfree;    /* количество свободных блоков */\n"
"    fsblkcnt_t     f_bavail;   /* количество свободных блоков\n"
"                                  для непривилегированных пользователей */\n"
"    fsfilcnt_t     f_files;    /* количество inodes */\n"
"    fsfilcnt_t     f_ffree;    /* количество свободных inodes */\n"
"    fsfilcnt_t     f_favail;   /* количество свободных inodes\n"
"                                  для непривилегированных пользователей */\n"
"    unsigned long  f_fsid;     /* идентификатор файловой системы */\n"
"    unsigned long  f_flag;     /* параметры монтирования */\n"
"    unsigned long  f_namemax;  /* максимальная длина имени файла */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/statvfs.3:78
msgid ""
"Here the types I<fsblkcnt_t> and I<fsfilcnt_t> are defined in I<E<lt>sys/"
"types.hE<gt>>.  Both used to be I<unsigned long>."
msgstr ""
"Типы I<fsblkcnt_t> и I<fsfilcnt_t> определены в файле I<E<lt>sys/types."
"hE<gt>>. Для их определения используется тип I<unsigned long>."

#.  XXX Keep this list in sync with statfs(2)
#. type: Plain text
#: man-pages/man3/statvfs.3:85
msgid ""
"The field I<f_flag> is a bit mask indicating various options that were "
"employed when mounting this filesystem.  It contains zero or more of the "
"following flags:"
msgstr ""
"Значение поля I<f_flag> — битовая маска различных параметров, которые были "
"указаны при монтировании этой файловой системы. В нём содержится ноль или "
"несколько следующих флагов:"

#. type: Plain text
#: man-pages/man3/statvfs.3:124
msgid ""
"It is unspecified whether all members of the returned struct have meaningful "
"values on all filesystems."
msgstr ""
"Не указывается, будут ли при любых файловых системах членам возвращаемой "
"структуры присвоены осмысленные данные."

#. type: Plain text
#: man-pages/man3/statvfs.3:128
msgid ""
"B<fstatvfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""
"B<fstatvfs>() возвращает такую же информацию об открытом файле через его "
"ссылку на дескриптор I<fd>."

#. type: Plain text
#: man-pages/man3/statvfs.3:141
msgid ""
"(B<statvfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statvfs>()) Нет права на поиск одного из компонентов префикса пути "
"I<path> (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man3/statvfs.3:146
msgid "(B<fstatvfs>())  I<fd> is not a valid open file descriptor."
msgstr ""
"(B<fstatvfs>()) I<fd> не является корректным открытым дескриптором файла."

#. type: Plain text
#: man-pages/man3/statvfs.3:152
msgid "I<Buf> or I<path> points to an invalid address."
msgstr "I<Buf> или I<path> указывает на неправильный адрес."

#. type: Plain text
#: man-pages/man3/statvfs.3:156
msgid "This call was interrupted by a signal; see B<signal>(7)."
msgstr "Данный вызов был прерван сигналом; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/statvfs.3:164
msgid ""
"(B<statvfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""
"(B<statvfs>()) Было обнаружено слишком много символьных ссылок при "
"трансляции I<path>."

#. type: Plain text
#: man-pages/man3/statvfs.3:169
msgid "(B<statvfs>())  I<path> is too long."
msgstr "(B<statvfs>()) Слишком длинное значение аргумента I<path>."

#. type: Plain text
#: man-pages/man3/statvfs.3:175
msgid "(B<statvfs>())  The file referred to by I<path> does not exist."
msgstr "(B<statvfs>()) Файл, указанный в I<path>, не существует."

#. type: Plain text
#: man-pages/man3/statvfs.3:187
msgid ""
"(B<statvfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""
"(B<statvfs>()) Один из компонентов префикса пути I<path> не является "
"каталогом."

#. type: tbl table
#: man-pages/man3/statvfs.3:201
#, no-wrap
msgid ""
"B<statvfs>(),\n"
"B<fstatvfs>()"
msgstr ""
"B<statvfs>(),\n"
"B<fstatvfs>()"

#. type: Plain text
#: man-pages/man3/statvfs.3:215
msgid ""
"Only the B<ST_NOSUID> and B<ST_RDONLY> flags of the I<f_flag> field are "
"specified in POSIX.1.  To obtain definitions of the remaining flags, one "
"must define B<_GNU_SOURCE>."
msgstr ""
"В POSIX.1 в поле I<f_flag> определены только флаги B<ST_NOSUID> и "
"B<ST_RDONLY>. Чтобы получить определения остальных флагов нужно определить "
"B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man3/statvfs.3:221
msgid ""
"The Linux kernel has system calls B<statfs>(2)  and B<fstatfs>(2)  to "
"support this library call."
msgstr ""
"Для поддержки данной библиотечной функции в ядре Linux есть системные вызовы "
"B<statfs>(2) и B<fstatfs>(2)."

#.  glibc commit 3cdaa6adb113a088fdfb87aa6d7747557eccc58d
#. type: Plain text
#: man-pages/man3/statvfs.3:237
msgid ""
"In glibc versions before 2.13, B<statvfs>()  populated the bits of the "
"I<f_flag> field by scanning the mount options shown in I</proc/mounts>.  "
"However, starting with Linux 2.6.36, the underlying B<statfs>(2)  system "
"call provides the necessary information via the I<f_flags> field, and since "
"glibc version 2.13, the B<statvfs>()  function will use information from "
"that field rather than scanning I</proc/mounts>."
msgstr ""
"В версиях glibc до 2.13, B<statvfs>() заполняла биты поля I<f_flag> сканируя "
"параметры монтирования в I</proc/mounts>. Однако начиная с Linux 2.6.36, "
"нижележащий системный вызов B<statfs>(2) предоставляет необходимую "
"информацию через поле I<f_flags>, и начиная с glibc версии 2.13, функция "
"B<statvfs>() будет использовать информацию из этого поля, а не сканируя I</"
"proc/mounts>."

#. type: Plain text
#: man-pages/man3/statvfs.3:239
msgid "The glibc implementations of"
msgstr "Реализации функций в glibc"

#. type: Plain text
#: man-pages/man3/statvfs.3:245
#, no-wrap
msgid ""
"pathconf(path, _PC_REC_XFER_ALIGN);\n"
"pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"
msgstr ""
"pathconf(path, _PC_REC_XFER_ALIGN);\n"
"pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"

#. type: Plain text
#: man-pages/man3/statvfs.3:257
msgid ""
"respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields "
"returned by a call to B<statvfs>()  with the argument I<path>."
msgstr ""
"используют, соответственно, поля I<f_frsize>, I<f_frsize> и I<f_bsize>, "
"возвращаемые вызовом B<statvfs>() с аргументом I<path>."

#. type: TH
#: man-pages/man3/scanf.3:52
#, no-wrap
msgid "SCANF"
msgstr "SCANF"

#. type: Plain text
#: man-pages/man3/scanf.3:55
msgid ""
"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr ""
"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - преобразует данные в "
"соответствии с форматом"

#. type: Plain text
#: man-pages/man3/scanf.3:62
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/scanf.3:64
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/scanf.3:68
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"

#. type: Plain text
#: man-pages/man3/scanf.3:79
msgid "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"
msgstr "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"

#. type: Plain text
#: man-pages/man3/scanf.3:81
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/scanf.3:100
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the "
"corresponding conversion specification."
msgstr ""
"Группа функций B<scanf>() считывает вводимую информацию в соответствии с "
"форматом I<format> так, как описано ниже. В формате могут указываться "
"I<определители преобразования> (conversion specifications); результаты "
"каждого преобразования, если они производились, сохраняются по адресам "
"параметров I<указателей>, передаваемых после I<format>. Каждый параметр "
"I<указатель> должен быть того же типа, что и значение, получаемое  в "
"результате преобразования данных в соответствии с форматом."

#. type: Plain text
#: man-pages/man3/scanf.3:111
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""
"Если количество определителей преобразования в I<format> превышает "
"количество параметров I<указателей>, то результат не определён. Если "
"количество параметров I<указателей> превышает количество определителей "
"преобразования, то лишние параметры I<указатели> вычисляются, но "
"игнорируются."

#. type: Plain text
#: man-pages/man3/scanf.3:123
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""
"Функция B<scanf>() считывает информацию из стандартного потока ввода "
"I<stdin>; B<fscanf>() считывает информацию из потока, на который указывает "
"I<stream>, а B<sscanf>() считывает информацию из символьной строки, на "
"которую указывает I<str>."

#. type: Plain text
#: man-pages/man3/scanf.3:141
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers "
"(see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument list "
"from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""
"Функция B<vfscanf>() является аналогом B<vfprintf>(3) и читает информацию из "
"потока, на который указывает указатель I<stream>, используя список "
"указателей переменной длины (смотрите B<stdarg>(3)). Функция B<vscanf>() "
"считывает список параметров переменной длины из стандартного ввода, а "
"функция B<vsscanf>() считывает его из строки. Эти функции являются аналогами "
"функций B<vprintf>(3) и B<vsprintf>(3), соответственно."

#. type: Plain text
#: man-pages/man3/scanf.3:155
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""
"Строка I<format> состоит из последовательности I<инструкций> (directives), "
"которые описывают порядок обработки входных символов. Если обработка "
"инструкции завершается с ошибкой, то чтение прекращается и B<scanf>() "
"завершает работу. «Отказом» может быть: I<ошибка ввода>, то есть "
"недоступность входных символов или I<ошибка совпадения>, то есть получены "
"неподходящие данные (смотрите далее)."

#. type: Plain text
#: man-pages/man3/scanf.3:157
msgid "A directive is one of the following:"
msgstr "Инструкцией может быть:"

#. type: Plain text
#: man-pages/man3/scanf.3:163
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including "
"none, in the input."
msgstr ""
"Последовательность пробельных символов (пробел, табуляция, символ новой "
"строки и т. д.; смотрите B<isspace>(3)). Эта инструкция совпадает с любым "
"количеством пустого места, включая отсутствие данных."

#. type: Plain text
#: man-pages/man3/scanf.3:167
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""
"Обычный символ (т. е., отличный от пробельного или «%»). Такой символ должен "
"точно совпадать со следующим символом входных данных."

#. type: Plain text
#: man-pages/man3/scanf.3:178
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails\\(emthis is a I<matching "
"failure>."
msgstr ""
"Определитель преобразования, который начинается с символа «%» (процент). "
"Последовательность символов ввода преобразуется в соответствии с "
"определителем, а результат помещается в соответствующий параметр "
"I<указатель>. Если следующий элемент ввода не соответствует определителю "
"преобразования, то преобразование завершается с ошибкой — I<ошибкой "
"совпадения>."

#. type: Plain text
#: man-pages/man3/scanf.3:186
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""
"Каждый I<определитель преобразования> в I<format> начинается с символа «%» "
"или последовательности символов «B<%>I<n>B<$>» (смотрите о разнице далее) за "
"которым следует:"

#. type: Plain text
#: man-pages/man3/scanf.3:197
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""
"Необязательный символ подавления назначения «*»: B<scanf>() читает данные "
"как предписано определителем преобразования, но отбрасывает их. "
"Соответствующий параметр I<указатель> необязателен, и этот определитель не "
"учитывается в счётчике успешных назначений, возвращаемом B<scanf>()."

#. type: Plain text
#: man-pages/man3/scanf.3:208
msgid ""
"For decimal conversions, an optional quote character (\\(aq).  This "
"specifies that the input number may include thousands' separators as defined "
"by the B<LC_NUMERIC> category of the current locale.  (See "
"B<setlocale>(3).)  The quote character may precede or follow the \\(aq*\\(aq "
"assignment-suppression character."
msgstr ""
"Для десятичных преобразований необязательный символ кавычки (\\(aq). "
"Указывает, что входное число можно содержать разделитель тысяч, определяемый "
"категорией B<LC_NUMERIC> текущей локали (смотрите B<setlocale>(3).) Символ "
"кавычки может быть до или после символа подавления \\(aq*\\(aq."

#. type: Plain text
#: man-pages/man3/scanf.3:227
msgid ""
"An optional \\(aqm\\(aq character.  This is used with string conversions (I<"
"%s>, I<%c>, I<%[>), and relieves the caller of the need to allocate a "
"corresponding buffer to hold the input: instead, B<scanf>()  allocates a "
"buffer of sufficient size, and assigns the address of this buffer to the "
"corresponding I<pointer> argument, which should be a pointer to a I<char\\ "
"*> variable (this variable does not need to be initialized before the "
"call).  The caller should subsequently B<free>(3)  this buffer when it is no "
"longer required."
msgstr ""
"Необязательный символ «m». Используется в строковых преобразованиях (I<%s>, "
"I<%c>, I<%[>) и освобождает вызывающего от необходимости выделять "
"соответствующий буфер для хранения входных данных: вместо этого B<scanf>() "
"выделяет буфер достаточного размера и присваивает адрес этого буфера "
"соответствующему параметру I<указателю>, который должен быть указателем на "
"переменную I<char\\ *> (эту переменную не нужно инициализировать перед "
"вызовом). Вызывающий должен вызвать B<free>(3) для этого буфера, как только "
"он станет ненужным."

#. type: Plain text
#: man-pages/man3/scanf.3:239
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and "
"these discarded characters don't count toward the maximum field width.  "
"String input conversions store a terminating null byte (\\(aq\\e0\\(aq)  to "
"mark the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""
"Необязательное целое десятичное число, которое задаёт I<максимальную ширину "
"поля>. Чтение символов прерывается по достижении этого максимума или при "
"нахождении несовпадающего символа, неважно что случится раньше. В "
"большинстве преобразований начальные пробельные символы отбрасываются "
"(исключения приведены далее), и эти отброшенные символы не учитываются в "
"максимальной ширине поля. В преобразованных строках ввода сохраняется "
"конечный байт null (\\(aq\\e0\\(aq) для отметки конца ввода; в максимальной "
"ширине поля он также не учитывается."

#. type: Plain text
#: man-pages/man3/scanf.3:253
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier "
"is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long int> rather than a "
"pointer to an I<int>."
msgstr ""
"Необязательный I<символ модификатора типа>. Например, модификатор типа B<l> "
"используется в преобразованиях целых чисел, например с помощью B<%d>, для "
"указания того, что  соответствующий параметр I<указатель> ссылается на "
"I<long int>, а не на I<int>."

#. type: Plain text
#: man-pages/man3/scanf.3:258
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr ""
"I<Определитель преобразования>, который задаёт тип входного преобразования."

#. type: Plain text
#: man-pages/man3/scanf.3:287
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string "
"containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If "
"I<format> contains \\(aq%\\(aq specifications, then these correspond in "
"order with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form "
"(which is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer "
"that specifies that the converted input should be placed in the location "
"referred to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""
"Определители преобразования в I<format> бывают двух видов: начинающиеся с "
"«%» и начинающиеся с «B<%>I<n>B<$>». Эти два вида не должны использоваться "
"одновременно в строке I<format>, за исключением случая, когда строка, "
"содержащая определители «B<%>I<n>B<$>», может включать B<%%> и B<%*>. Если в "
"I<format> содержатся определители «%», то они задаются в порядке появления "
"параметров I<указателей>, указанных после. В форме «B<%>I<n>B<$>» (есть в "
"POSIX.1-2001, но отсутствует в C99), I<n> — это десятичное целое, которое "
"задаёт в какое место должен быть помещён ввод, то есть указывает на "
"расположение I<n>-го параметра I<указателя>, передаваемого после I<format>."

#. type: SS
#: man-pages/man3/scanf.3:287
#, no-wrap
msgid "Conversions"
msgstr "Преобразования"

#. type: Plain text
#: man-pages/man3/scanf.3:291
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr ""
"Следующие I<символы модификаторов типа> (type modifier characters) могут "
"появляться в определении преобразования:"

#. type: TP
#: man-pages/man3/scanf.3:291
#, no-wrap
msgid "B<h>"
msgstr "B<h>"

#. type: Plain text
#: man-pages/man3/scanf.3:301
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short int> or "
"I<unsigned short int> (rather than I<int>)."
msgstr ""
"Обозначает, что преобразование будет одним из B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X> или B<n> и следующий указатель является указателем на I<short int> или "
"на I<unsigned short int> (но не I<int>)."

#. type: TP
#: man-pages/man3/scanf.3:301
#, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#: man-pages/man3/scanf.3:309
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""
"Как B<h>, но следующий указатель — указатель на I<signed char> или "
"I<unsigned char>."

#. type: TP
#: man-pages/man3/scanf.3:309
#, no-wrap
msgid "B<j>"
msgstr "B<j>"

#. type: Plain text
#: man-pages/man3/scanf.3:318
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""
"Как B<h>, но следующий указатель — указатель на I<intmax_t> или "
"I<uintmax_t>. Этот модификатор появился в C99."

#. type: TP
#: man-pages/man3/scanf.3:318
#, no-wrap
msgid "B<l>"
msgstr "B<l>"

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#: man-pages/man3/scanf.3:345
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long int> or "
"I<unsigned long int> (rather than I<int>), or that the conversion will be "
"one of B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> "
"(rather than I<float>).  Specifying two B<l> characters is equivalent to "
"B<L>.  If used with B<%c> or B<%s>, the corresponding parameter is "
"considered as a pointer to a wide character or wide-character string "
"respectively."
msgstr ""
"Обозначает, что преобразование будет одним из B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X> или B<n> и следующий указатель является указателем на I<long int> или "
"I<unsigned long int> (но не I<int>), или что преобразование будет одним из "
"B<e>, B<f> или B<g> и следующий указатель является указателем на I<double> "
"(но не I<float>). Указание двух символов B<l> эквивалентно B<L>. Если "
"используется с B<%c> или B<%s>, то соответствующий параметр считается "
"указателем на широкий символ или строку широких символов, соответственно."

#. type: TP
#: man-pages/man3/scanf.3:345
#, no-wrap
msgid "B<L>"
msgstr "B<L>"

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#: man-pages/man3/scanf.3:361
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""
"Обозначает, что преобразование будет одним из B<e>, B<f> или B<g> и "
"следующий указатель является указателем на I<long double> или преобразование "
"будет одним из B<d>, B<i>, B<o>, B<u> или B<x> и следующий указатель "
"является указателем на I<long long>."

#. type: TP
#: man-pages/man3/scanf.3:361
#, no-wrap
msgid "B<q>"
msgstr "B<q>"

#. type: Plain text
#: man-pages/man3/scanf.3:366
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr "Эквивалентен B<L>. Данный определитель отсутствует в ANSI C."

#. type: TP
#: man-pages/man3/scanf.3:366
#, no-wrap
msgid "B<t>"
msgstr "B<t>"

#. type: Plain text
#: man-pages/man3/scanf.3:373
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""
"Как B<h>, но следующий указатель — указатель на I<ptrdiff_t>. Этот "
"модификатор появился в C99."

#. type: TP
#: man-pages/man3/scanf.3:373
#, no-wrap
msgid "B<z>"
msgstr "B<z>"

#. type: Plain text
#: man-pages/man3/scanf.3:380
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""
"Как B<h>, но следующий указатель — указатель на I<size_t>. Этот модификатор "
"появился в C99."

#. type: Plain text
#: man-pages/man3/scanf.3:384
msgid "The following I<conversion specifiers> are available:"
msgstr "Доступны следующие I<определители преобразования>:"

#. type: TP
#: man-pages/man3/scanf.3:384
#, no-wrap
msgid "B<%>"
msgstr "B<%>"

#. type: Plain text
#: man-pages/man3/scanf.3:393
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not occur."
msgstr ""
"Совпадает с литерой «%». То есть B<%\\&%> в строке формата соответствует "
"одиночному символу данных «%». Преобразование не выполняется (но начальные "
"пробельные символы отбрасываются) и назначения не происходит."

#. type: TP
#: man-pages/man3/scanf.3:393
#, no-wrap
msgid "B<d>"
msgstr "B<d>"

#. type: Plain text
#: man-pages/man3/scanf.3:398
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""
"Совпадает с необязательным знаковым десятичным целым; следующий указатель "
"должен быть указателем на I<int>."

#. type: TP
#: man-pages/man3/scanf.3:398
#, no-wrap
msgid "B<D>"
msgstr "B<D>"

#. type: Plain text
#: man-pages/man3/scanf.3:407
msgid ""
"Equivalent to I<ld>; this exists only for backward compatibility.  (Note: "
"thus only in libc4.  In libc5 and glibc the B<%D> is silently ignored, "
"causing old programs to fail mysteriously.)"
msgstr ""
"Эквивалентно I<ld>; оставлено только для обратной совместимости (замечание: "
"есть только в libc4. В libc5 и glibc B<%D> просто игнорируется, что приводит "
"к непонятным ошибкам в старых программах)."

#. type: TP
#: man-pages/man3/scanf.3:407
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: man-pages/man3/scanf.3:419
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in "
"base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""
"Совпадает с необязательным знаковым целым; следующий указатель должен быть "
"указателем на I<int>. Целое считывается как шестнадцатеричное число, если "
"начинается с I<0x> или I<0X>, как восьмеричное, если начинается с I<0> и как "
"десятичное в остальных случаях. Используются только символы, подходящие для "
"работы с выбранным основанием системы счисления."

#. type: TP
#: man-pages/man3/scanf.3:419
#, no-wrap
msgid "B<o>"
msgstr "B<o>"

#. type: Plain text
#: man-pages/man3/scanf.3:423
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"Совпадает с необязательным беззнаковым восьмеричным целым; следующий "
"указатель должен быть указателем на I<unsigned int>."

#. type: TP
#: man-pages/man3/scanf.3:423
#, no-wrap
msgid "B<u>"
msgstr "B<u>"

#. type: Plain text
#: man-pages/man3/scanf.3:428
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"Совпадает с необязательным беззнаковым десятичным целым; следующий указатель "
"должен быть указателем на I<unsigned int>."

#. type: TP
#: man-pages/man3/scanf.3:428
#, no-wrap
msgid "B<x>"
msgstr "B<x>"

#. type: Plain text
#: man-pages/man3/scanf.3:433
msgid ""
"Matches an unsigned hexadecimal integer; the next pointer must be a pointer "
"to I<unsigned int>."
msgstr ""
"Совпадает с необязательным беззнаковым шестнадцатеричным целым; следующий "
"указатель должен быть указателем на I<unsigned int>."

#. type: TP
#: man-pages/man3/scanf.3:433
#, no-wrap
msgid "B<X>"
msgstr "B<X>"

#. type: Plain text
#: man-pages/man3/scanf.3:437
msgid "Equivalent to B<x>."
msgstr "Эквивалентно B<x>."

#. type: TP
#: man-pages/man3/scanf.3:437
#, no-wrap
msgid "B<f>"
msgstr "B<f>"

#. type: Plain text
#: man-pages/man3/scanf.3:442
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be "
"a pointer to I<float>."
msgstr ""
"Совпадает с необязательным знаковым числом с плавающей запятой; следующий "
"указатель должен быть указателем на I<float>."

#. type: TP
#: man-pages/man3/scanf.3:442
#, no-wrap
msgid "B<e>"
msgstr "B<e>"

#. type: Plain text
#: man-pages/man3/scanf.3:446 man-pages/man3/scanf.3:450
#: man-pages/man3/scanf.3:454
msgid "Equivalent to B<f>."
msgstr "Эквивалентно B<f>."

#. type: TP
#: man-pages/man3/scanf.3:446
#, no-wrap
msgid "B<g>"
msgstr "B<g>"

#. type: TP
#: man-pages/man3/scanf.3:450
#, no-wrap
msgid "B<E>"
msgstr "B<E>"

#. type: TP
#: man-pages/man3/scanf.3:454
#, no-wrap
msgid "B<a>"
msgstr "B<a>"

#. type: Plain text
#: man-pages/man3/scanf.3:458
msgid "(C99) Equivalent to B<f>."
msgstr "(C99) Эквивалентно B<f>."

#. type: TP
#: man-pages/man3/scanf.3:458
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#: man-pages/man3/scanf.3:466
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a "
"pointer to the initial element of a character array that is long enough to "
"hold the input sequence and the terminating null byte (\\(aq\\e0\\(aq), "
"which is added automatically.  The input string stops at white space or at "
"the maximum field width, whichever occurs first."
msgstr ""
"Совпадает с последовательностью непробельных символов; следующий указатель "
"должен указывать на первый элемент массива символов достаточной длины для "
"сохранения входной последовательности и завершающего байта null (\\(aq"
"\\e0\\(aq), который добавляется автоматически. Входная строка обрывается при "
"появлении пробельного символа или достижении максимальной ширины поля, "
"неважно что случится раньше."

#. type: TP
#: man-pages/man3/scanf.3:466
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#: man-pages/man3/scanf.3:476
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and "
"there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""
"Совпадает с последовательностью символов, чья длина задаётся I<максимальной "
"шириной поля> (по умолчанию 1); следующий указатель должен быть указателем "
"на I<char>, и должно быть достаточно места для всех символов (завершающий "
"байт null не добавляется). Обычный пропуск начальных пробелов не "
"выполняется. Чтобы пропустить пробелы, явно укажите их в формате."

#. type: TP
#: man-pages/man3/scanf.3:476
#, no-wrap
msgid "B<\\&[>"
msgstr "B<\\&[>"

#. type: Plain text
#: man-pages/man3/scanf.3:509
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted "
"characters; the next pointer must be a pointer to I<char>, and there must be "
"enough room for all the characters in the string, plus a terminating null "
"byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<^>).  To include a "
"close bracket in the set, make it the first character after the open bracket "
"or the circumflex; any other position will end the set.  The hyphen "
"character B<-> is also special; when placed between two other characters, it "
"adds all intervening characters to the set.  To include a hyphen, make it "
"the last character before the final close bracket.  For instance, "
"B<[^]0-9-]> means the set \"everything except close bracket, zero through "
"nine, and hyphen\".  The string ends with the appearance of a character not "
"in the (or, with a circumflex, in) set or when the field width runs out."
msgstr ""
"Совпадает с непустой последовательностью символов из задаваемого набора "
"допустимых символов; следующий указатель должен быть указателем на I<char> и "
"должно быть достаточно места для всех символов в строке плюс завершающий "
"байт null. Обычный пропуск начальных пробелов не выполняется. Строка будет "
"состоять (или нет) из символов определённого набора; набор задаётся "
"указанием символов между символом открывающей скобки B<[> и закрывающей "
"скобки B<]>. Набором определяются I<исключающиеся> символы, если первым "
"символом после открывающей скобки является символ диакритического знака "
"(B<^>). Чтобы включить закрывающую скобку в набор, укажите её первым "
"символом после открывающей скобки или диакритического знака; в любой другой "
"позиции она закрывает набор. Символ переноса B<-> также является "
"специализированным; если он указывается между двумя символами, то в набор "
"добавляются все лежащие в промежутке символы. Чтобы добавить в набор символ "
"переноса укажите его последним, перед конечной закрывающей скобкой. "
"Например, B<[^]0-9-]> означает, что «все символы, кроме закрывающей скобки, "
"цифр от 0 до 9 и переноса». Строка обрывается при появлении символа не из "
"набора (или, при указании символа диакритического знака, из) или при "
"достижении ширины поля."

#. type: TP
#: man-pages/man3/scanf.3:509
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: man-pages/man3/scanf.3:517
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""
"Совпадает со значением указателя (как выводится при B<%p> в B<printf>(3)); "
"следующий указатель должен быть указателем на I<void>."

#. type: TP
#: man-pages/man3/scanf.3:517
#, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#: man-pages/man3/scanf.3:535
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion and does I<not> increase the count "
"returned by the function.  The assignment can be suppressed with the B<*> "
"assignment-suppression character, but the effect on the return value is "
"undefined.  Therefore B<%*n> conversions should not be used."
msgstr ""
"Ничего не ожидается; вместо этого количество символов, использованных к "
"настоящему времени из ввода, сохраняется по следующему указателю, который "
"должен быть указателем на I<int>. Это I<не> преобразование и I<не> "
"увеличивает счётчик, возвращаемый функцией. Назначение может подавляться при "
"указании символа подавления назначения B<*>, но влияние этого на "
"возвращаемое значение не определено. Поэтому преобразования B<%*n> лучше не "
"использовать."

#. type: Plain text
#: man-pages/man3/scanf.3:540
msgid ""
"On success, these functions return the number of input items successfully "
"matched and assigned; this can be fewer than provided for, or even zero, in "
"the event of an early matching failure."
msgstr ""
"При успешном выполнении данные функции возвращают количество входных "
"совпавших и назначенных элементов, которое может быть меньше, чем "
"предусматривалось, или даже равно нулю, в случае преждевременной ошибки при "
"поиске совпадений."

#. type: Plain text
#: man-pages/man3/scanf.3:552
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set to indicate the "
"error."
msgstr ""
"Если конец входных данных был достигнут раньше, чем произошло хотя бы одно "
"совпадение или при ошибке совпадения возвращается значение B<EOF>. Значение "
"B<EOF> также возвращается при ошибке чтения; в этом случае для потока "
"устанавливается индикатор ошибки (смотрите B<ferror>(3)), а в I<errno> "
"указывается номер ошибки."

#. type: Plain text
#: man-pages/man3/scanf.3:558
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read "
"operation would block."
msgstr ""
"Файловый дескриптор I<stream> помечен как неблокирующий, а чтение вызвало бы "
"блокировку."

#. type: Plain text
#: man-pages/man3/scanf.3:563
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for reading."
msgstr ""
"Неправильный файловый дескриптор для I<stream> или он не открыт на чтение."

#. type: TP
#: man-pages/man3/scanf.3:563
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: man-pages/man3/scanf.3:566
msgid "Input byte sequence does not form a valid character."
msgstr ""
"Из входной байтовой последовательности невозможно создать корректный символ."

#. type: Plain text
#: man-pages/man3/scanf.3:570
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr "Операция чтения была прервана сигналом; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/scanf.3:575
msgid "Not enough arguments; or I<format> is NULL."
msgstr "Недостаточно параметров или I<format> равен NULL."

#. type: Plain text
#: man-pages/man3/scanf.3:582
msgid ""
"The result of an integer conversion would exceed the size that can be stored "
"in the corresponding integer type."
msgstr ""
"Результат преобразования целого превысил бы размер, который можно хранить в "
"соответствующем целочисленном типе."

#. type: tbl table
#: man-pages/man3/scanf.3:593
#, no-wrap
msgid ""
"B<scanf>(),\n"
"B<fscanf>(),\n"
msgstr ""
"B<scanf>(),\n"
"B<fscanf>(),\n"

#. type: tbl table
#: man-pages/man3/scanf.3:596
#, no-wrap
msgid ""
"B<sscanf>(),\n"
"B<vscanf>(),\n"
msgstr ""
"B<sscanf>(),\n"
"B<vscanf>(),\n"

#. type: tbl table
#: man-pages/man3/scanf.3:599
#, no-wrap
msgid ""
"B<vsscanf>(),\n"
"B<vfscanf>()"
msgstr ""
"B<vsscanf>(),\n"
"B<vfscanf>()"

#. type: Plain text
#: man-pages/man3/scanf.3:612
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""
"Функции B<fscanf>(), B<scanf>() и B<sscanf>() соответствуют C89, C99 и "
"POSIX.1-2001. В этих стандартах не определена ошибка B<ERANGE>."

#. type: Plain text
#: man-pages/man3/scanf.3:622
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""
"Определитель B<q> в 4.4BSD используется для I<long long>, а определители "
"B<ll> или B<L> используются в GNU для преобразования целых чисел."

#. type: Plain text
#: man-pages/man3/scanf.3:633
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc "
"(glibc-1.08)> for a more concise description."
msgstr ""
"Версия Linux этих функций основана на библиотеке I<GNU> I<libio>. Более "
"точное описание функций можно найти в документации в формате I<info> на "
"I<GNU> I<libc (glibc-1.08)>."

#. type: SS
#: man-pages/man3/scanf.3:634
#, no-wrap
msgid "The 'a' assignment-allocation modifier"
msgstr "Модификатор выделения-назначения «a»"

#. type: Plain text
#: man-pages/man3/scanf.3:645
msgid ""
"Originally, the GNU C library supported dynamic allocation for string inputs "
"(as a nonstandard extension) via the B<a> character.  (This feature is "
"present at least as far back as glibc 2.0.)  Thus, one could write the "
"following to have B<scanf>()  allocate a buffer for an input string, with a "
"pointer to that buffer being returned in I<*buf>:"
msgstr ""
"Первоначально, в библиотеке GNU C поддерживалось динамическое выделение "
"памяти для входных строк при указании символа B<a> (нестандартное "
"расширение) (это свойство существует до glibc 2.0). То есть можно указать "
"B<scanf>() выделить буфер под входную строку, передав в указателе только "
"указатель на буфер I<*buf>:"

#. type: Plain text
#: man-pages/man3/scanf.3:648
#, no-wrap
msgid ""
"    char *buf;\n"
"    scanf(\"%as\", &buf);\n"
msgstr ""
"    char *buf;\n"
"    scanf(\"%as\", &buf);\n"

#. type: Plain text
#: man-pages/man3/scanf.3:659
msgid ""
"The use of the letter B<a> for this purpose was problematic, since B<a> is "
"also specified by the ISO C standard as a synonym for B<f> (floating-point "
"input).  POSIX.1-2008 instead specifies the B<m> modifier for assignment "
"allocation (as documented in DESCRIPTION, above)."
msgstr ""
"Использование буквы B<a> для этой цели проблематично, так как B<a> также "
"используется в стандарте ISO C как синоним B<f> (ввод данных с плавающей "
"запятой). В POSIX.1-2008 для назначения с выделением определён модификатор "
"B<m> (смотрите в ОПИСАНИЕ выше)."

#. type: Plain text
#: man-pages/man3/scanf.3:671
msgid ""
"Note that the B<a> modifier is not available if the program is compiled with "
"I<gcc -std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""
"Заметим, что модификатор B<a> недоступен, если программа скомпилирована "
"посредством I<gcc -std=c99> или I<gcc -D_ISOC99_SOURCE> (если не определён "
"B<_GNU_SOURCE>); в этом случае B<a> рассматривается как определитель чисел с "
"плавающей запятой (смотрите выше)."

#. type: Plain text
#: man-pages/man3/scanf.3:677
msgid ""
"Support for the B<m> modifier was added to glibc starting with version 2.7, "
"and new programs should use that modifier instead of B<a>."
msgstr ""
"Поддержка модификатора B<m> была добавлена в glibc начиная с версии 2.7, и в "
"новых программах нужно использовать этот модификатор вместо B<a>."

#. type: Plain text
#: man-pages/man3/scanf.3:683
msgid ""
"As well as being standardized by POSIX, the B<m> modifier has the following "
"further advantages over the use of B<a:>"
msgstr ""
"Стандартизированный в POSIX модификатор B<m> имеет дополнительные "
"преимущества над B<a>:"

#. type: Plain text
#: man-pages/man3/scanf.3:688
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr ""
"Он может также применяться к определителям преобразования B<%c> (например, B<"
"%3mc>)."

#. type: Plain text
#: man-pages/man3/scanf.3:694
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)."
msgstr ""
"Исчезает неоднозначность с определителем преобразования чисел с плавающей "
"запятой B<%a> (не подвержен влиянию I<gcc -std=c99>)."

#. type: Plain text
#: man-pages/man3/scanf.3:707
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""
"Все функции полностью соответствуют C89, но предоставляют дополнительные "
"определители B<q> и B<a>, а также дополнительные возможности определителей "
"B<L> и B<l>. Последнее может считаться дефектом, так как это изменяет "
"поведение определителей, заданное в C89."

#. type: Plain text
#: man-pages/man3/scanf.3:723
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by "
"ANSI C do not make sense (e.g., B<%Ld>).  While they may have a well-defined "
"behavior on Linux, this need not to be so on other architectures.  Therefore "
"it usually is better to use modifiers that are not defined by ANSI C at all, "
"that is, use B<q> instead of B<L> in combination with B<d>, B<i>, B<o>, "
"B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""
"Некоторые комбинации модификаторов типов и определителей преобразования, "
"определённые в ANSI C, не имеют смысла (например, B<%Ld>). Хотя они могут "
"иметь хорошо описанное поведение в Linux, это не обязательно так на других "
"архитектурах. Поэтому, обычно, лучше использовать модификаторы, не "
"определённые в ANSI C, то есть использовать B<q> вместо B<L> в комбинации с "
"преобразованием B<d>, B<i>, B<o>, B<u>, B<x> и B<X> или B<ll>."

#. type: Plain text
#: man-pages/man3/scanf.3:729
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""
"Работа B<q> отличается от работы в 4.4BSD, так как может использоваться при "
"преобразовании вещественных числе подобно B<L>."

#. type: Plain text
#: man-pages/man3/scanf.3:739
msgid ""
"To use the dynamic allocation conversion specifier, specify B<m> as a length "
"modifier (thus B<%ms> or B<%m[>I<range>B<]>).  The caller must B<free>(3)  "
"the returned string, as in the following example:"
msgstr ""
"Чтобы использовать определитель динамического выделения при преобразовании, "
"укажите B<m> в качестве модификатора длины (в виде B<%ms> или B<"
"%m[>I<диапазон>B<]>). Вызывающий должен вызвать B<free>(3) для возвращённой "
"строки как в следующем примере:"

#. type: Plain text
#: man-pages/man3/scanf.3:744
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""
"char *p;\n"
"int n;\n"

#. type: Plain text
#: man-pages/man3/scanf.3:755
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%m[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"
msgstr ""
"errno = 0;\n"
"n = scanf(\"%m[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"чтение: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"Нет совпадающих символов\\en\");\n"
"}\n"

#. type: Plain text
#: man-pages/man3/scanf.3:763
msgid ""
"As shown in the above example, it is necessary to call B<free>(3)  only if "
"the B<scanf>()  call successfully read a string."
msgstr ""
"Как показано в примере выше, необходимо вызывать B<free>(3) только, если при "
"вызове B<scanf>() была прочитана строка."

#. type: Plain text
#: man-pages/man3/scanf.3:769
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"

#. type: TH
#: man-pages/man3/sinh.3:36
#, no-wrap
msgid "SINH"
msgstr "SINH"

#. type: Plain text
#: man-pages/man3/sinh.3:39
msgid "sinh, sinhf, sinhl - hyperbolic sine function"
msgstr "sinh, sinhf, sinhl - функция вычисления гиперболического синуса"

#. type: Plain text
#: man-pages/man3/sinh.3:46
#, no-wrap
msgid ""
"B<double sinh(double >I<x>B<);>\n"
"B<float sinhf(float >I<x>B<);>\n"
"B<long double sinhl(long double >I<x>B<);>\n"
msgstr ""
"B<double sinh(double >I<x>B<);>\n"
"B<float sinhf(float >I<x>B<);>\n"
"B<long double sinhl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sinh.3:58
msgid "B<sinhf>(), B<sinhl>():"
msgstr "B<sinhf>(), B<sinhl>():"

#. type: Plain text
#: man-pages/man3/sinh.3:69
msgid ""
"These functions return the hyperbolic sine of I<x>, which is defined "
"mathematically as:"
msgstr ""
"Эти функции возвращают гиперболический синус от I<x>, как это математически "
"определено:"

#. type: Plain text
#: man-pages/man3/sinh.3:72
#, no-wrap
msgid "    sinh(x) = (exp(x) - exp(-x)) / 2\n"
msgstr "    sinh(x) = (exp(x) - exp(-x)) / 2\n"

#. type: Plain text
#: man-pages/man3/sinh.3:76
msgid "On success, these functions return the hyperbolic sine of I<x>."
msgstr ""
"В случае успеха данные функции возвращают гиперболический синус от I<x>."

#. type: Plain text
#: man-pages/man3/sinh.3:84
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0), будет возвращено +0 (-0)."

#. type: Plain text
#: man-pages/man3/sinh.3:89
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned."
msgstr ""
"Если I<x>  стремится к плюс или минус бесконечности, будет возвращена плюс "
"или минус бесконечность."

#.  POSIX.1-2001 documents an optional range error (underflow)
#.  for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/sinh.3:103
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the same sign "
"as I<x>."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, "
"соответственно, с тем же знаком что и I<x>."

#. type: TP
#: man-pages/man3/sinh.3:110
#, no-wrap
msgid "Range error: result overflow"
msgstr "Ошибка диапазона: результат превысил разрядность"

#. type: Plain text
#: man-pages/man3/sinh.3:118
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: tbl table
#: man-pages/man3/sinh.3:130
#, no-wrap
msgid ""
"B<sinh>(),\n"
"B<sinhf>(),\n"
"B<sinhl>()"
msgstr ""
"B<sinh>(),\n"
"B<sinhf>(),\n"
"B<sinhl>()"

#. type: Plain text
#: man-pages/man3/sinh.3:145
msgid ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<csinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<csinh>(3), B<tanh>(3)"

#. type: TH
#: man-pages/man3/strtol.3:31
#, no-wrap
msgid "STRTOL"
msgstr "STRTOL"

#. type: Plain text
#: man-pages/man3/strtol.3:34
msgid "strtol, strtoll, strtoq - convert a string to a long integer"
msgstr "strtol, strtoll, strtoq - преобразует строку в длинное целое число"

#. type: Plain text
#: man-pages/man3/strtol.3:39
#, no-wrap
msgid "B<long int strtol(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
msgstr "B<long int strtol(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtol.3:42
#, no-wrap
msgid "B<long long int strtoll(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
msgstr "B<long long int strtoll(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtol.3:51
msgid "B<strtoll>():"
msgstr "B<strtoll>():"

#. type: Plain text
#: man-pages/man3/strtol.3:54
#, no-wrap
msgid ""
"_ISOC99_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/strtol.3:65
msgid ""
"The B<strtol>()  function converts the initial part of the string in I<nptr> "
"to a long integer value according to the given I<base>, which must be "
"between 2 and 36 inclusive, or be the special value 0."
msgstr ""
"Функция B<strtol>() преобразует начальную часть строки I<nptr> в длинное "
"целое число согласно системе счисления I<base>, значение которой может быть "
"от 2 до 36 включительно или равно специальному значению 0."

#. type: Plain text
#: man-pages/man3/strtol.3:78
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3))  followed by a single optional \\(aq+\\(aq or \\(aq-\\(aq "
"sign.  If I<base> is zero or 16, the string may then include a \"0x\" or \"0X"
"\" prefix, and the number will be read in base 16; otherwise, a zero I<base> "
"is taken as 10 (decimal) unless the next character is \\(aq0\\(aq, in which "
"case it is taken as 8 (octal)."
msgstr ""
"Строка может начинаться с произвольного количества пробельных символов "
"(определяемых при помощи B<isspace>(3)), затем может быть указан знак «+» "
"или «-». Если I<base> равно 0 или 16, то строка может начинаться с приставки "
"«0x» или «0X», что означает использование шестнадцатеричной системы "
"исчисления; иначе, если I<base> равно нулю, то используется десятичная "
"система счисления (кроме, когда последующий символ также равен «0»: в этом "
"случае используется восьмеричная система исчисления)."

#. type: Plain text
#: man-pages/man3/strtol.3:87
msgid ""
"The remainder of the string is converted to a I<long int> value in the "
"obvious manner, stopping at the first character which is not a valid digit "
"in the given base.  (In bases above 10, the letter \\(aqA\\(aq in either "
"uppercase or lowercase represents 10, \\(aqB\\(aq represents 11, and so "
"forth, with \\(aqZ\\(aq representing 35.)"
msgstr ""
"Остаток строки преобразуется в число с типом I<long int>. Этот процесс "
"останавливается, если в строке встречается некорректный символ для указанной "
"системе счисления. В системах счисления больших 10, символ «A» в верхнем или "
"нижнем регистре означает 10, «B» означает 11 и так далее до «Z», означающего "
"35."

#. type: Plain text
#: man-pages/man3/strtol.3:108
msgid ""
"If I<endptr> is not NULL, B<strtol>()  stores the address of the first "
"invalid character in I<*endptr>.  If there were no digits at all, "
"B<strtol>()  stores the original value of I<nptr> in I<*endptr> (and returns "
"0).  In particular, if I<*nptr> is not \\(aq\\e0\\(aq but I<**endptr> is "
"\\(aq\\e0\\(aq on return, the entire string is valid."
msgstr ""
"Если значение I<endptr> не NULL, то B<strtol>() записывает адрес первого "
"некорректного символа в I<*endptr>. Если в строке вообще нет цифр, то "
"B<strtoul>() сохраняет изначальное значение I<nptr> в I<*endptr> (и "
"возвращает 0). В частности, если I<*nptr> не равно \\(aq\\e0\\(aq, но "
"I<**endptr> равно \\(aq\\e0\\(aq при возврате, то вся строка состоит из "
"корректных символов."

#. type: Plain text
#: man-pages/man3/strtol.3:114
msgid ""
"The B<strtoll>()  function works just like the B<strtol>()  function but "
"returns a long long integer value."
msgstr ""
"Функция B<strtoll>() работает так же, как и B<strtol>(), но возвращает число "
"с типом I<long long int>."

#. type: Plain text
#: man-pages/man3/strtol.3:141
msgid ""
"The B<strtol>()  function returns the result of the conversion, unless the "
"value would underflow or overflow.  If an underflow occurs, B<strtol>()  "
"returns B<LONG_MIN>.  If an overflow occurs, B<strtol>()  returns "
"B<LONG_MAX>.  In both cases, I<errno> is set to B<ERANGE>.  Precisely the "
"same holds for B<strtoll>()  (with B<LLONG_MIN> and B<LLONG_MAX> instead of "
"B<LONG_MIN> and B<LONG_MAX>)."
msgstr ""
"Функция B<strtol>() возвращает результат преобразования, если значение не "
"возникают переполнения или исчерпания. Если возникает исчерпание, то "
"B<strtol>() возвращает B<LONG_MIN>. Если возникает переполнение, то "
"B<strtoul>() возвращает B<LONG_MAX>. В обоих случаях переменной I<errno> "
"присваивается значение B<ERANGE>. То же самое относится к B<strtoll>(), "
"только вместо B<LONG_MIN> и B<LONG_MAX> возвращается B<LLONG_MIN> и "
"B<LLONG_MAX>."

#. type: tbl table
#: man-pages/man3/strtol.3:170
#, no-wrap
msgid ""
"B<strtol>(),\n"
"B<strtoll>(),\n"
"B<strtoq>()"
msgstr ""
"B<strtol>(),\n"
"B<strtoll>(),\n"
"B<strtoq>()"

#. type: Plain text
#: man-pages/man3/strtol.3:175
msgid "B<strtol>(): POSIX.1-2001, POSIX.1-2008, C89, C99 SVr4, 4.3BSD."
msgstr "B<strtol>(): POSIX.1-2001, POSIX.1-2008, C89, C99 SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/strtol.3:178
msgid "B<strtoll>(): POSIX.1-2001, POSIX.1-2008, C99."
msgstr "B<strtoll>(): POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/strtol.3:196
msgid ""
"Since B<strtol>()  can legitimately return 0, B<LONG_MAX>, or B<LONG_MIN> "
"(B<LLONG_MAX> or B<LLONG_MIN> for B<strtoll>())  on both success and "
"failure, the calling program should set I<errno> to 0 before the call, and "
"then determine if an error occurred by checking whether I<errno> has a "
"nonzero value after the call."
msgstr ""
"Так как B<strtol>() может обоснованно вернуть 0, B<LONG_MAX> или B<LONG_MIN> "
"(а B<strtoll>() — B<LLONG_MAX> или B<LLONG_MIN>) при успешном выполнении и "
"ошибке, вызывающая программа до вызова должна присвоить I<errno> значение 0, "
"а после вызова определить возникновение ошибки по ненулевому значению "
"I<errno>."

#. type: Plain text
#: man-pages/man3/strtol.3:201
msgid ""
"According to POSIX.1, in locales other than the \"C\" and \"POSIX\", these "
"functions may accept other, implementation-defined numeric strings."
msgstr ""
"Согласно POSIX.1, в локалях отличных от «C» и «POSIX», эти функции могут "
"преобразовывать другие, определяемые реализацией, строки с числами."

#. type: Plain text
#: man-pages/man3/strtol.3:207
#, no-wrap
msgid "B<quad_t strtoq(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"
msgstr "B<quad_t strtoq(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtol.3:216
msgid ""
"with completely analogous definition.  Depending on the wordsize of the "
"current architecture, this may be equivalent to B<strtoll>()  or to "
"B<strtol>()."
msgstr ""
"с полностью аналогичным определением. В зависимости от длины слова в текущей "
"архитектуре, она может быть аналогом B<strtoll>() или B<strtol>()."

#. type: Plain text
#: man-pages/man3/strtol.3:230
msgid ""
"The program shown below demonstrates the use of B<strtol>().  The first "
"command-line argument specifies a string from which B<strtol>()  should "
"parse a number.  The second (optional) argument specifies the base to be "
"used for the conversion.  (This argument is converted to numeric form using "
"B<atoi>(3), a function that performs no error checking and has a simpler "
"interface than B<strtol>().)  Some examples of the results produced by this "
"program are the following:"
msgstr ""
"Программа, представленная далее, показывает использование B<strtol>(). В "
"первом аргументе командной строки указывается срока, из которой B<strtol>() "
"должна извлечь число. Во втором (необязательном) аргументе указывается "
"система счисления, используемая для преобразования (этот аргумент "
"преобразуется в число с помощью B<atoi>(3), функции, которая не учитывает "
"ошибки и имеет более простой интерфейс по сравнению с B<strtol>()). Вот "
"несколько результатов работы этой программы:"

#. type: Plain text
#: man-pages/man3/strtol.3:246
#, no-wrap
msgid ""
"$B< ./a.out 123>\n"
"strtol() returned 123\n"
"$B< ./a.out \\(aq    123\\(aq>\n"
"strtol() returned 123\n"
"$B< ./a.out 123abc>\n"
"strtol() returned 123\n"
"Further characters after number: abc\n"
"$B< ./a.out 123abc 55>\n"
"strtol: Invalid argument\n"
"$B< ./a.out \\(aq\\(aq>\n"
"No digits were found\n"
"$B< ./a.out 4000000000>\n"
"strtol: Numerical result out of range\n"
msgstr ""
"$B< ./a.out 123>\n"
"strtol() вернула 123\n"
"$B< ./a.out \\(aq    123\\(aq>\n"
"strtol() вернула 123\n"
"$B< ./a.out 123abc>\n"
"strtol() вернула 123\n"
"Остальные символы после числа: abc\n"
"$B< ./a.out 123abc 55>\n"
"strtol: некорректный аргумент\n"
"$B< ./a.out \\(aq\\(aq>\n"
"Цифры отсутствуют\n"
"$B< ./a.out 4000000000>\n"
"strtol: Числовой результат выходит за диапазон\n"

#. type: Plain text
#: man-pages/man3/strtol.3:255
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strtol.3:262
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int base;\n"
"    char *endptr, *str;\n"
"    long val;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int base;\n"
"    char *endptr, *str;\n"
"    long val;\n"

#. type: Plain text
#: man-pages/man3/strtol.3:267
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s str [base]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Использование: %s строка [система_счисления]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strtol.3:270
#, no-wrap
msgid ""
"    str = argv[1];\n"
"    base = (argc E<gt> 2) ? atoi(argv[2]) : 10;\n"
msgstr ""
"    str = argv[1];\n"
"    base = (argc E<gt> 2) ? atoi(argv[2]) : 10;\n"

#. type: Plain text
#: man-pages/man3/strtol.3:273
#, no-wrap
msgid ""
"    errno = 0;    /* To distinguish success/failure after call */\n"
"    val = strtol(str, &endptr, base);\n"
msgstr ""
"    errno = 0;    /* чтобы выявить ошибку после вызова */\n"
"    val = strtol(str, &endptr, base);\n"

#. type: Plain text
#: man-pages/man3/strtol.3:275
#, no-wrap
msgid "    /* Check for various possible errors */\n"
msgstr "    /* проверка возможных ошибок */\n"

#. type: Plain text
#: man-pages/man3/strtol.3:281
#, no-wrap
msgid ""
"    if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))\n"
"            || (errno != 0 && val == 0)) {\n"
"        perror(\"strtol\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))\n"
"            || (errno != 0 && val == 0)) {\n"
"        perror(\"strtol\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strtol.3:286
#, no-wrap
msgid ""
"    if (endptr == str) {\n"
"        fprintf(stderr, \"No digits were found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (endptr == str) {\n"
"        fprintf(stderr, \"Цифры отсутствуют\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strtol.3:288
#, no-wrap
msgid "    /* If we got here, strtol() successfully parsed a number */\n"
msgstr "    /* если мы дошли сюда, то strtol() успешно преобразовала число */\n"

#. type: Plain text
#: man-pages/man3/strtol.3:290
#, no-wrap
msgid "    printf(\"strtol() returned %ld\\en\", val);\n"
msgstr "    printf(\"strtol() вернула %ld\\en\", val);\n"

#. type: Plain text
#: man-pages/man3/strtol.3:293
#, no-wrap
msgid ""
"    if (*endptr != \\(aq\\e0\\(aq)        /* Not necessarily an error... */\n"
"        printf(\"Further characters after number: %s\\en\", endptr);\n"
msgstr ""
"    if (*endptr != \\(aq\\e0\\(aq)        /* необязательно ошибка… */\n"
"        printf(\"Остальные символы после числа: %s\\en\", endptr);\n"

#. type: Plain text
#: man-pages/man3/strtol.3:303
msgid ""
"B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtoul>(3), "
"B<strtoimax>(3)"
msgstr ""
"B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtoul>(3), "
"B<strtoimax>(3)"

#. type: TH
#: man-pages/man3/strfmon.3:24
#, no-wrap
msgid "STRFMON"
msgstr "STRFMON"

#. type: Plain text
#: man-pages/man3/strfmon.3:27
msgid "strfmon, strfmon_l - convert monetary value to a string"
msgstr "strfmon, strfmon_l - преобразует денежное значение в строку"

#. type: Plain text
#: man-pages/man3/strfmon.3:30
#, no-wrap
msgid "B<#include E<lt>monetary.hE<gt>>\n"
msgstr "B<#include E<lt>monetary.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strfmon.3:33
#, no-wrap
msgid ""
"B<ssize_t strfmon(char *>I<s>B<, size_t >I<max>B<, const char *>I<format>B<,>\n"
"B<...);>\n"
msgstr ""
"B<ssize_t strfmon(char *>I<s>B<, size_t >I<max>B<, const char *>I<format>B<,>\n"
"B<...);>\n"

#. type: Plain text
#: man-pages/man3/strfmon.3:36
#, no-wrap
msgid ""
"B<ssize_t strfmon_l(char *>I<s>B<, size_t >I<max>B<, locale_t >I<locale>B<,>\n"
"B<const char *\" format , ...);>\n"
msgstr ""
"B<ssize_t strfmon_l(char *>I<s>B<, size_t >I<max>B<, locale_t >I<locale>B<,>\n"
"B<const char *\" format , ...);>\n"

#. type: Plain text
#: man-pages/man3/strfmon.3:49
msgid ""
"The B<strfmon>()  function formats the specified monetary amount according "
"to the current locale and format specification I<format> and places the "
"result in the character array I<s> of size I<max>."
msgstr ""
"Функция B<strfmon>() преобразует заданные денежные суммы в соответствии с "
"текущей локалью и указанным форматом I<format> и помещает результат в "
"символьный массив I<s> размера I<max>."

#. type: Plain text
#: man-pages/man3/strfmon.3:65
msgid ""
"The B<strfmon_l>()  function performs the same task, but uses the locale "
"specified by I<locale>.  The behavior of B<strfmon_l>()  is undefined if "
"I<locale> is the special locale object B<LC_GLOBAL_LOCALE> (see "
"B<duplocale>(3))  or is not a valid locale object handle."
msgstr ""
"Функция B<strfmon_l>() производит то же действие, но используется локаль, "
"заданная в I<locale>. Поведение B<strfmon_l>() не определёно, если значение "
"I<locale> равно специальному объекту локали B<LC_GLOBAL_LOCALE> (смотрите "
"B<duplocale>(3)) или описатель объекта локали не корректен."

#. type: Plain text
#: man-pages/man3/strfmon.3:75
msgid ""
"Ordinary characters in I<format> are copied to I<s> without conversion.  "
"Conversion specifiers are introduced by a \\(aq%\\(aq character.  "
"Immediately following it there can be zero or more of the following flags:"
msgstr ""
"Обычные символы, заданные в аргументе I<format>, копируются в I<s> без "
"преобразования. Определители преобразования начинаются с символа \\(aq%"
"\\(aq. Непосредственно за ними может следовать ноль или более флагов:"

#. type: TP
#: man-pages/man3/strfmon.3:75
#, no-wrap
msgid "B<=>I<f>"
msgstr "B<=>I<f>"

#. type: Plain text
#: man-pages/man3/strfmon.3:82
msgid ""
"The single-byte character I<f> is used as the numeric fill character (to be "
"used with a left precision, see below).  When not specified, the space "
"character is used."
msgstr ""
"Однобайтовый символ I<f> используется в качестве числового символа-"
"заполнителя (для выравнивания слева, смотрите ниже). Если символ не указан, "
"то используется символ пробела."

#. type: TP
#: man-pages/man3/strfmon.3:82
#, no-wrap
msgid "B<^>"
msgstr "B<^>"

#. type: Plain text
#: man-pages/man3/strfmon.3:87
msgid ""
"Do not use any grouping characters that might be defined for the current "
"locale.  By default, grouping is enabled."
msgstr ""
"Не использовать группирующие символы, которые могут быть определены в "
"текущей локали. По умолчанию, разделение на группы разрядов разрешено."

#. type: TP
#: man-pages/man3/strfmon.3:87
#, no-wrap
msgid "B<(> or B<+>"
msgstr "B<(> или B<+>"

#. type: Plain text
#: man-pages/man3/strfmon.3:94
msgid ""
"The ( flag indicates that negative amounts should be enclosed between "
"parentheses.  The + flag indicates that signs should be handled in the "
"default way, that is, amounts are preceded by the locale's sign indication, "
"for example, nothing for positive, \"-\" for negative."
msgstr ""
"Флаг ( указывает на то, что отрицательные суммы должны быть заключены в "
"скобки. Флаг + указывает на то, что наличие знака у суммы должно "
"обрабатываться стандартным способом, то есть зависит от локали, например "
"может быть так, что в результате ничего не указывается для положительных "
"сумм и «-» для отрицательных."

#. type: TP
#: man-pages/man3/strfmon.3:94
#, no-wrap
msgid "B<!>"
msgstr "B<!>"

#. type: Plain text
#: man-pages/man3/strfmon.3:97
msgid "Omit the currency symbol."
msgstr "Пропустить текущий символ."

#. type: TP
#: man-pages/man3/strfmon.3:97
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#: man-pages/man3/strfmon.3:101
msgid "Left justify all fields.  The default is right justification."
msgstr ""
"Выровнять все поля по левому краю. По умолчанию выравнивание по правому краю."

#. type: Plain text
#: man-pages/man3/strfmon.3:107
msgid ""
"Next, there may be a field width: a decimal digit string specifying a "
"minimum field width in bytes.  The default is 0.  A result smaller than this "
"width is padded with spaces (on the left, unless the left-justify flag was "
"given)."
msgstr ""
"Далее может быть указана ширина поля: строка с десятичным числом, "
"определяющая минимальную ширину поля в байтах. По умолчанию 0. Если "
"результат меньше чем эта ширина, то он дополняется пробелами (слева, если "
"установлен флаг выравнивания по левому краю)."

#. type: Plain text
#: man-pages/man3/strfmon.3:114
msgid ""
"Next, there may be a left precision of the form \"#\" followed by a decimal "
"digit string.  If the number of digits left of the radix character is "
"smaller than this, the representation is padded on the left with the numeric "
"fill character.  Grouping characters are not counted in this field width."
msgstr ""
"Далее может быть указана ширина целой части числа: символ «#», за которым "
"следует строка с десятичным числом. Если количество цифр слева от символа "
"разделителя меньше, чем ширина целой части, то предоставление дополняется "
"слева числовым символом-заполнителем. Группирующие символы не учитываются "
"при подсчете этой ширины поля."

#. type: Plain text
#: man-pages/man3/strfmon.3:129
msgid ""
"Next, there may be a right precision of the form \".\" followed by a decimal "
"digit string.  The amount being formatted is rounded to the specified number "
"of digits prior to formatting.  The default is specified in the "
"I<frac_digits> and I<int_frac_digits> items of the current locale.  If the "
"right precision is 0, no radix character is printed.  (The radix character "
"here is determined by B<LC_MONETARY>, and may differ from that specified by "
"B<LC_NUMERIC>.)"
msgstr ""
"Далее может быть указана точность десятичной части: символ «.», за которым "
"следует строка с десятичным числом. Перед форматированием сумма будет "
"округлена до указанного числа знаков. По умолчанию, точность задаётся в "
"элементах I<frac_digits> и I<int_frac_digits> текущей локали. Если "
"десятичная точность равна 0, то разделитель целой и дробной части не "
"печатается (символ-разделитель определяется переменной B<LC_MONETARY> и "
"может отличаться от символа определенного в переменной B<LC_NUMERIC>)."

#. type: Plain text
#: man-pages/man3/strfmon.3:133
msgid ""
"Finally, the conversion specification must be ended with a conversion "
"character.  The three conversion characters are"
msgstr ""
"И, наконец, определение преобразования может заканчиваться символом "
"преобразования. Существует три символа преобразования:"

#. type: Plain text
#: man-pages/man3/strfmon.3:137
msgid ""
"(In this case, the entire specification must be exactly \"%%\".)  Put a \\(aq"
"%\\(aq character in the result string."
msgstr ""
"(Если в строку необходимо включить этот символ, то он задаётся как «%%».) "
"Помещает символ \\(aq%\\(aq в строку-результат."

#. type: Plain text
#: man-pages/man3/strfmon.3:142
msgid ""
"One argument of type I<double> is converted using the locale's international "
"currency format."
msgstr ""
"Аргумент типа I<double> преобразуется с использованием локального "
"интернационального формата валюты."

#. type: Plain text
#: man-pages/man3/strfmon.3:147
msgid ""
"One argument of type I<double> is converted using the locale's national "
"currency format."
msgstr ""
"Аргумент типа I<double> преобразуется с использованием локального "
"национального формата валюты."

#. type: Plain text
#: man-pages/man3/strfmon.3:160
msgid ""
"The B<strfmon>()  function returns the number of characters placed in the "
"array I<s>, not including the terminating null byte, provided the string, "
"including the terminating null byte, fits.  Otherwise, it sets I<errno> to "
"B<E2BIG>, returns -1, and the contents of the array is undefined."
msgstr ""
"При успешном выполнении функция B<strfmon>() возвращает количество символов, "
"помещённых в массив I<s>, без учёта конечного байта null, предоставляя "
"строку, включающую конечный байт null. Иначе она устанавливает I<errno> в "
"значение B<E2BIG>, возвращает -1, а содержимое массива не определено."

#. type: tbl table
#: man-pages/man3/strfmon.3:170
#, no-wrap
msgid "B<strfmon>()"
msgstr "B<strfmon>()"

#. type: tbl table
#: man-pages/man3/strfmon.3:173
#, no-wrap
msgid "B<strfmon_l>()"
msgstr "B<strfmon_l>()"

#. type: Plain text
#: man-pages/man3/strfmon.3:185
#, no-wrap
msgid ""
"strfmon(buf, sizeof(buf), \"[%^=*#6n] [%=*#6i]\",\n"
"        1234.567, 1234.567);\n"
msgstr ""
"strfmon(buf, sizeof(buf), \"[%^=*#6n] [%=*#6i]\",\n"
"        1234.567, 1234.567);\n"

#. type: Plain text
#: man-pages/man3/strfmon.3:189
msgid "outputs"
msgstr "результат"

#. type: Plain text
#: man-pages/man3/strfmon.3:193
#, no-wrap
msgid "[€ **1234,57] [EUR **1 234,57]\n"
msgstr "[€ **1234,57] [EUR **1 234,57]\n"

#. type: Plain text
#: man-pages/man3/strfmon.3:206
msgid ""
"in the I<nl_NL> locale.  The I<de_DE>, I<de_CH>, I<en_AU>, and I<en_GB> "
"locales yield"
msgstr ""
"с локалью I<nl_NL>. С локалями I<de_DE>, I<de_CH>, I<en_AU> и I<en_GB>:"

#. type: Plain text
#: man-pages/man3/strfmon.3:213
#, no-wrap
msgid ""
"[ **1234,57 €] [ **1.234,57 EUR]\n"
"[ Fr. **1234.57] [ CHF **1'234.57]\n"
"[ $**1234.57] [ AUD**1,234.57]\n"
"[ £**1234.57] [ GBP**1,234.57]\n"
msgstr ""
"[ **1234,57 €] [ **1.234,57 EUR]\n"
"[ Fr. **1234.57] [ CHF **1'234.57]\n"
"[ $**1234.57] [ AUD**1,234.57]\n"
"[ £**1234.57] [ GBP**1,234.57]\n"

#. type: Plain text
#: man-pages/man3/strfmon.3:219
msgid "B<duplocale>(3), B<setlocale>(3), B<sprintf>(3), B<locale>(7)"
msgstr "B<duplocale>(3), B<setlocale>(3), B<sprintf>(3), B<locale>(7)"

#. type: TH
#: man-pages/man3/stpcpy.3:25
#, no-wrap
msgid "STPCPY"
msgstr "STPCPY"

#. type: Plain text
#: man-pages/man3/stpcpy.3:28
msgid "stpcpy - copy a string returning a pointer to its end"
msgstr "stpcpy - копирование строки с возвращением указателя на её конец"

#. type: Plain text
#: man-pages/man3/stpcpy.3:33
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:41
msgid "B<stpcpy>():"
msgstr "B<stpcpy>():"

#. type: Plain text
#: man-pages/man3/stpcpy.3:63
msgid ""
"The B<stpcpy>()  function copies the string pointed to by I<src> (including "
"the terminating null byte (\\(aq\\e0\\(aq)) to the array pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy."
msgstr ""
"Функция B<strcpy>() копирует строку, указанную в I<src>, включая завершающий "
"байт null (\\(aq\\e0\\(aq), в массив, указанный в I<dest>. Строки не могут "
"перекрываться, а строка назначения I<dest> должна быть достаточно велика, "
"чтобы хранить копию."

#. type: Plain text
#: man-pages/man3/stpcpy.3:71
msgid ""
"B<stpcpy>()  returns a pointer to the B<end> of the string I<dest> (that is, "
"the address of the terminating null byte)  rather than the beginning."
msgstr ""
"Функция B<stpcpy>() возвращает указатель на B<конец> строки I<dest> (то есть "
"адрес конечного байта null), а не на её начало."

#. type: tbl table
#: man-pages/man3/stpcpy.3:81
#, no-wrap
msgid "B<stpcpy>()"
msgstr "B<stpcpy>()"

#. type: Plain text
#: man-pages/man3/stpcpy.3:92
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was not part of "
"the C or POSIX.1 standards, nor customary on UNIX systems.  It first "
"appeared at least as early as 1986, in the Lattice C AmigaDOS compiler, then "
"in the GNU fileutils and GNU textutils in 1989, and in the GNU C library by "
"1992.  It is also present on the BSDs."
msgstr ""
"Эта функция была добавлена в POSIX.1-2008. До этого, она не была частью "
"стандарта C или POSIX.1, или обычной для систем UNIX. Впервые она появилась "
"не раньше 1986 года в компиляторе Lattice C AmigaDOS, затем в GNU fileutils "
"и GNU textutils в 1989 году, и в библиотеке GNU C в 1992 году. Также она "
"есть в разных BSD."

#. type: Plain text
#: man-pages/man3/stpcpy.3:95
msgid "This function may overrun the buffer I<dest>."
msgstr "Эта функция может переполнить буфер I<dest>."

#. type: Plain text
#: man-pages/man3/stpcpy.3:105
msgid ""
"For example, this program uses B<stpcpy>()  to concatenate B<foo> and B<bar> "
"to produce B<foobar>, which it then prints."
msgstr ""
"Данная программа использует B<stpcpy>() для объединения B<foo> и B<bar>, "
"чтобы получить строку B<foobar>, которая затем выводится."

#. type: Plain text
#: man-pages/man3/stpcpy.3:110
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:116
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:121
#, no-wrap
msgid ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"
msgstr ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:130
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"

#. type: TH
#: man-pages/man3/seekdir.3:31
#, no-wrap
msgid "SEEKDIR"
msgstr "SEEKDIR"

#. type: Plain text
#: man-pages/man3/seekdir.3:35
msgid ""
"seekdir - set the position of the next readdir() call in the directory "
"stream."
msgstr ""
"seekdir - установить позицию для последующего вызова readdir() в потоке "
"каталога."

#. type: Plain text
#: man-pages/man3/seekdir.3:40
#, no-wrap
msgid "B<void seekdir(DIR *>I<dirp>B<, long >I<loc>B<);>\n"
msgstr "B<void seekdir(DIR *>I<dirp>B<, long >I<loc>B<);>\n"

#. type: Plain text
#: man-pages/man3/seekdir.3:51
#, no-wrap
msgid ""
"B<seekdir>():\n"
" _XOPEN_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<seekdir>():\n"
" _XOPEN_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/seekdir.3:62
msgid ""
"The B<seekdir>()  function sets the location in the directory stream from "
"which the next B<readdir>(2)  call will start.  The I<loc> argument should "
"be a value returned by a previous call to B<telldir>(3)."
msgstr ""
"Функция B<seekdir>() устанавливает в потоке каталога позицию, с которой "
"начнёт работу следующий вызов B<readdir>(2). Аргумент I<loc> должен быть "
"значением, которое возвращается ранее вызванной функцией B<telldir>(3)."

#. type: Plain text
#: man-pages/man3/seekdir.3:66
msgid "The B<seekdir>()  function returns no value."
msgstr "Функция B<seekdir>() не возвращает никаких значений."

#. type: tbl table
#: man-pages/man3/seekdir.3:76
#, no-wrap
msgid "B<seekdir>()"
msgstr "B<seekdir>()"

#. type: Plain text
#: man-pages/man3/seekdir.3:92
msgid ""
"In glibc up to version 2.1.1, the type of the I<loc> argument was I<off_t>.  "
"POSIX.1-2001 specifies I<long>, and this is the type used since glibc "
"2.1.2.  See B<telldir>(3)  for information on why you should be careful in "
"making any assumptions about the value in this argument."
msgstr ""
"В glibc до версии 2.1.1 тип аргумента I<loc> был I<off_t>. В POSIX.1-2001 он "
"имеет тип I<long>, и это учтено в glibc начиная с версии 2.1.2. В "
"B<telldir>(3) читайте почему нужно быть осторожным в своих предположениях о "
"значении в этом аргументе."

#. type: Plain text
#: man-pages/man3/seekdir.3:99
msgid ""
"B<lseek>(2), B<closedir>(3), B<opendir>(3), B<readdir>(3), B<rewinddir>(3), "
"B<scandir>(3), B<telldir>(3)"
msgstr ""
"B<lseek>(2), B<closedir>(3), B<opendir>(3), B<readdir>(3), B<rewinddir>(3), "
"B<scandir>(3), B<telldir>(3)"

#. type: TH
#: man-pages/man3/sincos.3:9
#, no-wrap
msgid "SINCOS"
msgstr "SINCOS"

#. type: Plain text
#: man-pages/man3/sincos.3:12
msgid "sincos, sincosf, sincosl - calculate sin and cos simultaneously"
msgstr "sincos, sincosf, sincosl - одновременное вычисление синуса и косинуса"

#. type: Plain text
#: man-pages/man3/sincos.3:16
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sincos.3:20
#, no-wrap
msgid ""
"B<void sincos(double >I<x>B<, double *>I<sin>B<, double *>I<cos>B<);>\n"
"B<void sincosf(float >I<x>B<, float *>I<sin>B<, float *>I<cos>B<);>\n"
"B<void sincosl(long double >I<x>B<, long double *>I<sin>B<, long double *>I<cos>B<);>\n"
msgstr ""
"B<void sincos(double >I<x>B<, double *>I<sin>B<, double *>I<cos>B<);>\n"
"B<void sincosf(float >I<x>B<, float *>I<sin>B<, float *>I<cos>B<);>\n"
"B<void sincosl(long double >I<x>B<, long double *>I<sin>B<, long double *>I<cos>B<);>\n"

#. type: Plain text
#: man-pages/man3/sincos.3:34
msgid ""
"Several applications need sine and cosine of the same angle I<x>.  These "
"functions compute both at the same time, and store the results in I<*sin> "
"and I<*cos>.  Using this function can be more efficient than two separate "
"calls to B<sin>(3)  and B<cos>(3)."
msgstr ""
"Некоторым приложениям необходимы значения синуса и косинуса одного и того же "
"угла I<x>. Эти функции вычисляют одновременно оба значения и сохраняют "
"результаты в I<*sin> и I<*cos>. Использование этой функции может быть более "
"эффективно, чем два отдельных вызова B<sin>(3) и B<cos>(3)."

#. type: Plain text
#: man-pages/man3/sincos.3:42
msgid "If I<x> is a NaN, a NaN is returned in I<*sin> and I<*cos>."
msgstr ""
"Если I<x> имеет значение NaN, будет возвращено NaN для I<*sin> и I<*cos>."

#. type: Plain text
#: man-pages/man3/sincos.3:51
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned in I<*sin> and I<*cos>."
msgstr ""
"Если I<x> стремится к плюс бесконечности или минус бесконечности, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата в "
"I<*sin> and I<*cos> будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/sincos.3:54
msgid "These functions return I<void>."
msgstr "Эти функции возвращают I<void>."

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/sincos.3:69
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "Возникает исключение неправильной плавающей точки (B<FE_INVALID>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  sin() and cos() also don't set errno; bugs have been raised for
#.  those functions.
#.  See https://www.sourceware.org/bugzilla/show_bug.cgi?id=15467
#. type: Plain text
#: man-pages/man3/sincos.3:76
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: Plain text
#: man-pages/man3/sincos.3:78
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: tbl table
#: man-pages/man3/sincos.3:90
#, no-wrap
msgid ""
"B<sincos>(),\n"
"B<sincosf>(),\n"
"B<sincosl>()"
msgstr ""
"B<sincos>(),\n"
"B<sincosf>(),\n"
"B<sincosl>()"

#. type: Plain text
#: man-pages/man3/sincos.3:94
msgid "These functions are GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/sincos.3:100
msgid ""
"To see the performance advantage of B<sincos>(), it may be necessary to "
"disable B<gcc>(1)  built-in optimizations, using flags such as:"
msgstr ""
"Чтобы увидеть выгоду B<sincos>() может потребоваться отключить встроенные "
"оптимизации B<gcc>(1) с помощью следующих флагов:"

#. type: Plain text
#: man-pages/man3/sincos.3:104
#, no-wrap
msgid "cc -O -lm -fno-builtin prog.c\n"
msgstr "cc -O -lm -fno-builtin prog.c\n"

#. type: Plain text
#: man-pages/man3/sincos.3:109
msgid "B<cos>(3), B<sin>(3), B<tan>(3)"
msgstr "B<cos>(3), B<sin>(3), B<tan>(3)"

#. type: TH
#: man-pages/man3/strfry.3:30
#, no-wrap
msgid "STRFRY"
msgstr "STRFRY"

#. type: Plain text
#: man-pages/man3/strfry.3:33
msgid "strfry - randomize a string"
msgstr "strfry - изменяет строку произвольным образом"

#. type: Plain text
#: man-pages/man3/strfry.3:39
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>\n"
msgstr "B<char *strfry(char *>I<string>B<);>\n"

#. type: Plain text
#: man-pages/man3/strfry.3:48
msgid ""
"The B<strfry>()  function randomizes the contents of I<string> by randomly "
"swapping characters in the string.  The result is an anagram of I<string>."
msgstr ""
"Функция B<strfry>() случайным образом переставляет элементы (символы) в "
"строке I<string>. В результате получается анаграмма строки I<string>."

#. type: Plain text
#: man-pages/man3/strfry.3:53
msgid "The B<strfry>()  functions returns a pointer to the randomized string."
msgstr "Функция B<strfry>() возвращает указатель на строку-анаграмму."

#. type: tbl table
#: man-pages/man3/strfry.3:63
#, no-wrap
msgid "B<strfry>()"
msgstr "B<strfry>()"

#. type: Plain text
#: man-pages/man3/strfry.3:70
msgid "The B<strfry>()  function is unique to the GNU C Library."
msgstr "Функция B<strfry>() есть только в библиотеке GNU C."

#. type: Plain text
#: man-pages/man3/strfry.3:72
msgid "B<memfrob>(3), B<string>(3)"
msgstr "B<memfrob>(3), B<string>(3)"

#. type: TH
#: man-pages/man3/strxfrm.3:30
#, no-wrap
msgid "STRXFRM"
msgstr "STRXFRM"

#. type: Plain text
#: man-pages/man3/strxfrm.3:33
msgid "strxfrm - string transformation"
msgstr "strxfrm - преобразование строки"

#. type: Plain text
#: man-pages/man3/strxfrm.3:38
#, no-wrap
msgid "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strxfrm.3:62
msgid ""
"The B<strxfrm>()  function transforms the I<src> string into a form such "
"that the result of B<strcmp>(3)  on two strings that have been transformed "
"with B<strxfrm>()  is the same as the result of B<strcoll>(3)  on the two "
"strings before their transformation.  The first I<n> bytes of the "
"transformed string are placed in I<dest>.  The transformation is based on "
"the program's current locale for category B<LC_COLLATE>.  (See "
"B<setlocale>(3))."
msgstr ""
"Функция B<strxfrm>() преобразует строку I<src> в такую форму, что выполнение "
"B<strcmp>(3) над двумя такими строками, преобразованными посредством "
"B<strxfrm>(), будет таким же, как и выполнение B<strcoll>(3) над строками до "
"преобразования. Первые I<n> байт преобразованной строки помещаются в "
"I<dest>. Преобразование основывается на настройках категории текущей локали "
"B<LC_COLLATE> программы (смотрите B<setlocale>(3))."

#. type: Plain text
#: man-pages/man3/strxfrm.3:76
msgid ""
"The B<strxfrm>()  function returns the number of bytes required to store the "
"transformed string in I<dest> excluding the terminating null byte (\\(aq"
"\\e0\\(aq).  If the value returned is I<n> or more, the contents of I<dest> "
"are indeterminate."
msgstr ""
"Функция B<strxfrm>() возвращает количество байт, необходимое для размещения "
"преобразованной строки в I<dest> без завершающего байта null («\\e0»). Если "
"возвращённое значение равно I<n> или больше этой величины, то содержимое "
"I<dest> не определено."

#. type: tbl table
#: man-pages/man3/strxfrm.3:86
#, no-wrap
msgid "B<strxfrm>()"
msgstr "B<strxfrm>()"

#. type: Plain text
#: man-pages/man3/strxfrm.3:97
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"

#. type: TH
#: man-pages/man3/strstr.3:33
#, no-wrap
msgid "STRSTR"
msgstr "STRSTR"

#. type: Plain text
#: man-pages/man3/strstr.3:36
msgid "strstr, strcasestr - locate a substring"
msgstr "strstr, strcasestr - поиск подстроки"

#. type: Plain text
#: man-pages/man3/strstr.3:41
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: man-pages/man3/strstr.3:43
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"

#. type: Plain text
#: man-pages/man3/strstr.3:47
#, no-wrap
msgid "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: man-pages/man3/strstr.3:56
msgid ""
"The B<strstr>()  function finds the first occurrence of the substring "
"I<needle> in the string I<haystack>.  The terminating null bytes (\\(aq"
"\\e0\\(aq) are not compared."
msgstr ""
"Функция B<strstr>() ищет первое соответствие подстроки I<needle> в строке "
"I<haystack>. Конечные байты null (\\(aq\\e0\\(aq) не сравниваются."

#. type: Plain text
#: man-pages/man3/strstr.3:62
msgid ""
"The B<strcasestr>()  function is like B<strstr>(), but ignores the case of "
"both arguments."
msgstr ""
"B<strcasestr>() аналогична B<strstr>(), но при этом игнорируется регистр "
"обеих строк."

#. type: Plain text
#: man-pages/man3/strstr.3:65
msgid ""
"These functions return a pointer to the beginning of the located substring, "
"or NULL if the substring is not found."
msgstr ""
"Данные функции возвращают указатель на начало найденной подстроки или NULL, "
"если подстрока не найдена."

#. type: tbl table
#: man-pages/man3/strstr.3:75
#, no-wrap
msgid "B<strstr>()"
msgstr "B<strstr>()"

#. type: tbl table
#: man-pages/man3/strstr.3:78
#, no-wrap
msgid "B<strcasestr>()"
msgstr "B<strcasestr>()"

#. type: Plain text
#: man-pages/man3/strstr.3:83
msgid "B<strstr>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "B<strstr>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#.  .SH BUGS
#.  Early versions of Linux libc (like 4.5.26) would not allow
#.  an empty
#.  .I needle
#.  argument for
#.  .BR strstr ().
#.  Later versions (like 4.6.27) work correctly,
#.  and return
#.  .IR haystack
#.  when
#.  .I needle
#.  is empty.
#. type: Plain text
#: man-pages/man3/strstr.3:99
msgid "The B<strcasestr>()  function is a nonstandard extension."
msgstr "B<strcasestr>() является нестандартизованным расширением."

#. type: Plain text
#: man-pages/man3/strstr.3:111
msgid ""
"B<index>(3), B<memchr>(3), B<memmem>(3), B<rindex>(3), B<strcasecmp>(3), "
"B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), "
"B<strtok>(3), B<wcsstr>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<memmem>(3), B<rindex>(3), B<strcasecmp>(3), "
"B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), "
"B<strtok>(3), B<wcsstr>(3)"

#. type: TH
#: man-pages/man3/strcat.3:32
#, no-wrap
msgid "STRCAT"
msgstr "STRCAT"

#. type: Plain text
#: man-pages/man3/strcat.3:35
msgid "strcat, strncat - concatenate two strings"
msgstr "strcat, strncat - объединяет две строки"

#. type: Plain text
#: man-pages/man3/strcat.3:40
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcat.3:42
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcat.3:62
msgid ""
"The B<strcat>()  function appends the I<src> string to the I<dest> string, "
"overwriting the terminating null byte (\\(aq\\e0\\(aq) at the end of "
"I<dest>, and then adds a terminating null byte.  The strings may not "
"overlap, and the I<dest> string must have enough space for the result.  If "
"I<dest> is not large enough, program behavior is unpredictable; I<buffer "
"overruns are a favorite avenue for attacking secure programs>."
msgstr ""
"Функция B<strcat>() добавляет строку I<src> к строке I<dest>, перезаписывая "
"байт null (\\(aq\\e0\\(aq) в конце I<dest> и добавляет завершающий байт "
"null. Строки не могут перекрываться, а в строке I<dest> должно хватать "
"свободного места для размещения объединённой строки. Если размер I<dest> "
"мал, то поведение программы непредсказуемо; I<переполнение буфера — любимое "
"средство для атаки защищённых программ>."

#. type: Plain text
#: man-pages/man3/strcat.3:66
msgid "The B<strncat>()  function is similar, except that"
msgstr "Функция B<strncat>() работает аналогичным образом, но"

#. type: Plain text
#: man-pages/man3/strcat.3:72
msgid "it will use at most I<n> bytes from I<src>; and"
msgstr "задействует не более I<n> первых байт строки I<src> и"

#. type: Plain text
#: man-pages/man3/strcat.3:77
msgid ""
"I<src> does not need to be null-terminated if it contains I<n> or more bytes."
msgstr ""
"строка I<src> может не завершаться байтом null, если в ней содержится I<n> "
"или более байт."

#. type: Plain text
#: man-pages/man3/strcat.3:83
msgid ""
"As with B<strcat>(), the resulting string in I<dest> is always null-"
"terminated."
msgstr ""
"Как и B<strcat>(), строка-результат в I<dest> всегда заканчивается байтом "
"null."

#. type: Plain text
#: man-pages/man3/strcat.3:102
msgid ""
"If I<src> contains I<n> or more bytes, B<strncat>()  writes I<n+1> bytes to "
"I<dest> (I<n> from I<src> plus the terminating null byte).  Therefore, the "
"size of I<dest> must be at least I<strlen(dest)+n+1>."
msgstr ""
"Если в I<src> содержится I<n> или более байт, то B<strncat>() записывает I<n"
"+1> байт в I<dest> (I<n> из I<src> плюс завершающий байт null). Поэтому "
"размер I<dest> должен быть не менее I<strlen(dest)+n+1>."

#. type: Plain text
#: man-pages/man3/strcat.3:106
msgid "A simple implementation of B<strncat>()  might be:"
msgstr "Простейшей реализацией B<strncat>() может быть:"

#. type: Plain text
#: man-pages/man3/strcat.3:114
#, no-wrap
msgid ""
"char *\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"
msgstr ""
"char *\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"

#. type: Plain text
#: man-pages/man3/strcat.3:118
#, no-wrap
msgid ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: man-pages/man3/strcat.3:121
#, no-wrap
msgid ""
"    return dest;\n"
"}\n"
msgstr ""
"    return dest;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/strcat.3:130
msgid ""
"The B<strcat>()  and B<strncat>()  functions return a pointer to the "
"resulting string I<dest>."
msgstr ""
"Функции B<strcat>() и B<strncat>() возвращают указатель на скопированную "
"строку I<dest>."

#. type: tbl table
#: man-pages/man3/strcat.3:141
#, no-wrap
msgid ""
"B<strcat>(),\n"
"B<strncat>()"
msgstr ""
"B<strcat>(),\n"
"B<strncat>()"

#. type: Plain text
#: man-pages/man3/strcat.3:147
msgid ""
"Some systems (the BSDs, Solaris, and others) provide the following function:"
msgstr "В некоторых системах (BSD, Solaris и других) есть следующая функция:"

#. type: Plain text
#: man-pages/man3/strcat.3:149
#, no-wrap
msgid "    size_t strlcat(char *dest, const char *src, size_t size);\n"
msgstr "    size_t strlcat(char *dest, const char *src, size_t size);\n"

#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: man-pages/man3/strcat.3:183
msgid ""
"This function appends the null-terminated string I<src> to the string "
"I<dest>, copying at most I<size-strlen(dest)-1> from I<src>, and adds a "
"terminating null byte to the result, I<unless> I<size> is less than "
"I<strlen(dest)>.  This function fixes the buffer overrun problem of "
"B<strcat>(), but the caller must still handle the possibility of data loss "
"if I<size> is too small.  The function returns the length of the string "
"B<strlcat>()  tried to create; if the return value is greater than or equal "
"to I<size>, data loss occurred.  If data loss matters, the caller I<must> "
"either check the arguments before the call, or test the function return "
"value.  B<strlcat>()  is not present in glibc and is not standardized by "
"POSIX, but is available on Linux via the I<libbsd> library."
msgstr ""
"Эта функция добавляет строку I<src>, оканчивающуюся null, к строке I<dest>, "
"копируя не более I<size-strlen(dest)-1> байт из I<src>, и добавляет к "
"результату конечный байт null, I<если> I<size> менее I<strlen(dest)>. Эта "
"функция исправляет проблему с переполнением буфера в B<strcat>(), но "
"вызывающий по прежнему должен рассматривать возможность потери данных, если "
"I<size> слишком мал. Функция возвращает длину строки, которую B<strlcat>() "
"пыталась создать; если возвращаемое значение больше или равно I<size>, то "
"произошла потеря данных. Если потеря данных критична, то вызывающий "
"I<должен> или проверять аргументы перед вызовом, или проверять возвращаемое "
"функцией значение. Функция B<strlcat>() отсутствует в glibc и не "
"стандартизована POSIX, но доступна в Linux в библиотеке I<libbsd>."

#. type: Plain text
#: man-pages/man3/strcat.3:200
msgid ""
"Because B<strcat>()  and B<strncat>()  must find the null byte that "
"terminates the string I<dest> using a search that starts at the beginning of "
"the string, the execution time of these functions scales according to the "
"length of the string I<dest>.  This can be demonstrated by running the "
"program below.  (If the goal is to concatenate many strings to one target, "
"then manually copying the bytes from each source string while maintaining a "
"pointer to the end of the target string will provide better performance.)"
msgstr ""
"Так как B<strcat>() и B<strncat>() должны найти байт null, завершающий "
"строку I<dest>, начиная поиск от начала строки, время выполнения этих "
"функций пропорционально длине строки I<dest>. Это можно увидеть из запуска "
"программы, представленной ниже (если целью является склейка несколько строк "
"в одну, то ручное копирование байт из одного источника и управление концом "
"строки назначения будет более производительным)."

#. type: Plain text
#: man-pages/man3/strcat.3:206
#, no-wrap
msgid ""
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strcat.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define LIM 4000000\n"
"    int j;\n"
"    char p[LIM + 1];    /* +1 for terminating null byte */\n"
"    time_t base;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strcat.3:217
#, no-wrap
msgid ""
"    base = time(NULL);\n"
"    p[0] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    base = time(NULL);\n"
"    p[0] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: man-pages/man3/strcat.3:224
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> LIM; j++) {\n"
"        if ((j % 10000) == 0)\n"
"            printf(\"%d %ld\\en\", j, (long) (time(NULL) - base));\n"
"        strcat(p, \"a\");\n"
"    }\n"
"}\n"
msgstr ""
"    for (j = 0; j E<lt> LIM; j++) {\n"
"        if ((j % 10000) == 0)\n"
"            printf(\"%d %ld\\en\", j, (long) (time(NULL) - base));\n"
"        strcat(p, \"a\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/strcat.3:234
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"

#. type: TH
#: man-pages/man3/setlogmask.3:25
#, no-wrap
msgid "SETLOGMASK"
msgstr "SETLOGMASK"

#. type: Plain text
#: man-pages/man3/setlogmask.3:28
msgid "setlogmask - set log priority mask"
msgstr "setlogmask - изменяет маску приоритета журнала"

#. type: Plain text
#: man-pages/man3/setlogmask.3:31
#, no-wrap
msgid "B<#include E<lt>syslog.hE<gt>>\n"
msgstr "B<#include E<lt>syslog.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setlogmask.3:33
#, no-wrap
msgid "B<int setlogmask(int >I<mask>B<);>\n"
msgstr "B<int setlogmask(int >I<mask>B<);>\n"

#. type: Plain text
#: man-pages/man3/setlogmask.3:43
msgid ""
"A process has a log priority mask that determines which calls to "
"B<syslog>(3)  may be logged.  All other calls will be ignored.  Logging is "
"enabled for the priorities that have the corresponding bit set in I<mask>.  "
"The initial mask is such that logging is enabled for all priorities."
msgstr ""
"У процессов есть маска приоритета журнала, которая определяет, какие вызовы "
"B<syslog>(3) будут заноситься в журнал. Все остальные вызовы игнорируются. "
"Протоколирование разрешено для приоритетов, для которых установлен "
"соответствующий бит в I<mask>. Начальная маска такова, что протоколирование "
"разрешено для всех приоритетов."

#. type: Plain text
#: man-pages/man3/setlogmask.3:49
msgid ""
"The B<setlogmask>()  function sets this logmask for the calling process, and "
"returns the previous mask.  If the mask argument is 0, the current logmask "
"is not modified."
msgstr ""
"Функция B<setlogmask>() устанавливает маску для вызывающего процесса и "
"возвращает предыдущую маску. Если аргумент маски равен 0, то текущая маска "
"не изменяется."

#. type: Plain text
#: man-pages/man3/setlogmask.3:69
msgid ""
"The eight priorities are B<LOG_EMERG>, B<LOG_ALERT>, B<LOG_CRIT>, "
"B<LOG_ERR>, B<LOG_WARNING>, B<LOG_NOTICE>, B<LOG_INFO>, and B<LOG_DEBUG>.  "
"The bit corresponding to a priority I<p> is I<LOG_MASK(p)>.  Some systems "
"also provide a macro I<LOG_UPTO(p)> for the mask of all priorities in the "
"above list up to and including I<p>."
msgstr ""
"Существует восемь приоритетов: B<LOG_EMERG>, B<LOG_ALERT>, B<LOG_CRIT>, "
"B<LOG_ERR>, B<LOG_WARNING>, B<LOG_NOTICE>, B<LOG_INFO> и B<LOG_DEBUG>. Бит, "
"соответствующий приоритету I<p>, вычисляется как I<LOG_MASK(p)>. Некоторые "
"системы также предоставляют макрос I<LOG_UPTO(p)> для маски всех приоритетов "
"вышеперечисленного списка плюс I<p>."

#. type: Plain text
#: man-pages/man3/setlogmask.3:71
msgid "This function returns the previous log priority mask."
msgstr "Функция возвращает предыдущую маску приоритета журнала."

#.  .SH NOTES
#.  The glibc logmask handling was broken in versions before glibc 2.1.1.
#. type: Plain text
#: man-pages/man3/setlogmask.3:75
msgid "None."
msgstr "Ничего."

#. type: tbl table
#: man-pages/man3/setlogmask.3:85
#, no-wrap
msgid "B<setlogmask>()"
msgstr "B<setlogmask>()"

#. type: tbl table
#: man-pages/man3/setlogmask.3:85
#, no-wrap
msgid "MT-Unsafe race:LogMask"
msgstr "MT-Unsafe race:LogMask"

#. type: Plain text
#: man-pages/man3/setlogmask.3:94
msgid "B<closelog>(3), B<openlog>(3), B<syslog>(3)"
msgstr "B<closelog>(3), B<openlog>(3), B<syslog>(3)"

#. type: TH
#: man-pages/man3/sigwait.3:26
#, no-wrap
msgid "SIGWAIT"
msgstr "SIGWAIT"

#. type: Plain text
#: man-pages/man3/sigwait.3:29
msgid "sigwait - wait for a signal"
msgstr "sigwait - ожидание сигнала"

#. type: Plain text
#: man-pages/man3/sigwait.3:34
#, no-wrap
msgid "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"
msgstr "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/sigwait.3:43
msgid "B<sigwait>():"
msgstr "B<sigwait>():"

#. type: Plain text
#: man-pages/man3/sigwait.3:46
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"
msgstr ""
"начиная с glibc 2.26:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"

#. type: Plain text
#: man-pages/man3/sigwait.3:49
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _POSIX_C_SOURCE\n"
msgstr ""
"в glibc 2.25 и старее:\n"
"    _POSIX_C_SOURCE\n"

#. type: Plain text
#: man-pages/man3/sigwait.3:62
msgid ""
"The B<sigwait>()  function suspends execution of the calling thread until "
"one of the signals specified in the signal set I<set> becomes pending.  The "
"function accepts the signal (removes it from the pending list of signals), "
"and returns the signal number in I<sig>."
msgstr ""
"Функция B<sigwait>() приостанавливает выполнение вызвавшей нити до тех пор, "
"пока в ожидании не появится сигнал из заданного набора сигналов I<set>. "
"Функция принимает сигнал (удаляет его из списка ожидающих сигналов) и "
"возвращает номер сигнала в I<sig>."

#. type: Plain text
#: man-pages/man3/sigwait.3:68
msgid ""
"The operation of B<sigwait>()  is the same as B<sigwaitinfo>(2), except that:"
msgstr "Действие B<sigwait>() тоже, что и B<sigwaitinfo>(2), за исключением:"

#. type: Plain text
#: man-pages/man3/sigwait.3:73
msgid ""
"B<sigwait>()  returns only the signal number, rather than a I<siginfo_t> "
"structure describing the signal."
msgstr ""
"Функция B<sigwait>() возвращает только номер сигнала, а не структуру "
"I<siginfo_t>, описывающую сигнал."

#. type: Plain text
#: man-pages/man3/sigwait.3:75
msgid "The return values of the two functions are different."
msgstr "Функции отличаются возвращаемыми значениями."

#. type: Plain text
#: man-pages/man3/sigwait.3:80
msgid ""
"On success, B<sigwait>()  returns 0.  On error, it returns a positive error "
"number (listed in ERRORS)."
msgstr ""
"При успешном выполнении B<sigwait>() возвращает 0. При ошибке возвращается "
"положительный номер ошибки (перечислены в разделе ОШИБКИ)."

#.  Does not occur for glibc.
#. type: Plain text
#: man-pages/man3/sigwait.3:86
msgid "I<set> contains an invalid signal number."
msgstr "В I<set> содержится некорректный номер сигнала."

#. type: tbl table
#: man-pages/man3/sigwait.3:96
#, no-wrap
msgid "B<sigwait>()"
msgstr "B<sigwait>()"

#. type: Plain text
#: man-pages/man3/sigwait.3:104
msgid "B<sigwait>()  is implemented using B<sigtimedwait>(2)."
msgstr "Функция B<sigwait>() реализована с помощью B<sigtimedwait>(2)."

#. type: Plain text
#: man-pages/man3/sigwait.3:112
msgid ""
"The glibc implementation of B<sigwait>()  silently ignores attempts to wait "
"for the two real-time signals that are used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""
"В реализации glibc B<sigwait>() просто игнорирует попытки ожидания двух "
"сигналов реального времени, которые используются внутри реализации NPTL. "
"Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man3/sigwait.3:115
msgid "See B<pthread_sigmask>(3)."
msgstr "Смотрите B<pthread_sigmask>(3)."

#. type: Plain text
#: man-pages/man3/sigwait.3:122
msgid ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/sem_init.3:26
#, no-wrap
msgid "SEM_INIT"
msgstr "SEM_INIT"

#. type: Plain text
#: man-pages/man3/sem_init.3:29
msgid "sem_init - initialize an unnamed semaphore"
msgstr "sem_init - инициализирует безымянный семафор"

#. type: Plain text
#: man-pages/man3/sem_init.3:34
#, no-wrap
msgid "B<int sem_init(sem_t *>I<sem>B<, int >I<pshared>B<, unsigned int >I<value>B<);>\n"
msgstr "B<int sem_init(sem_t *>I<sem>B<, int >I<pshared>B<, unsigned int >I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_init.3:44
msgid ""
"B<sem_init>()  initializes the unnamed semaphore at the address pointed to "
"by I<sem>.  The I<value> argument specifies the initial value for the "
"semaphore."
msgstr ""
"Функция B<sem_init>() инициализирует безымянный семафор по адресу, "
"указанному в I<sem>. В аргументе I<value> задаётся начальное значение "
"семафора."

#. type: Plain text
#: man-pages/man3/sem_init.3:49
msgid ""
"The I<pshared> argument indicates whether this semaphore is to be shared "
"between the threads of a process, or between processes."
msgstr ""
"Аргументом I<pshared> определяется, будет ли данный семафор доступен в нитях "
"процесса или в разных процессах."

#. type: Plain text
#: man-pages/man3/sem_init.3:57
msgid ""
"If I<pshared> has the value 0, then the semaphore is shared between the "
"threads of a process, and should be located at some address that is visible "
"to all threads (e.g., a global variable, or a variable allocated dynamically "
"on the heap)."
msgstr ""
"Если значение I<pshared> равно 0, то семафор будет коллективно "
"использоваться в нитях процесса, и должен располагаться по адресу, который "
"доступен из всех нитей (например, глобальная переменная или динамически "
"выделенная из кучи переменная)."

#. type: Plain text
#: man-pages/man3/sem_init.3:74
msgid ""
"If I<pshared> is nonzero, then the semaphore is shared between processes, "
"and should be located in a region of shared memory (see B<shm_open>(3), "
"B<mmap>(2), and B<shmget>(2)).  (Since a child created by B<fork>(2)  "
"inherits its parent's memory mappings, it can also access the semaphore.)  "
"Any process that can access the shared memory region can operate on the "
"semaphore using B<sem_post>(3), B<sem_wait>(3), and so on."
msgstr ""
"Если значение I<pshared> не равно нулю, то семафор будет коллективно "
"использоваться несколькими процессами, и должен располагаться в области "
"общей памяти (смотрите B<shm_open>(3), B<mmap>(2) и B<shmget>(2)) (так как "
"потомок, создаваемый B<fork>(2), наследует отображение памяти родителя, то "
"ему также доступен и семафор). Любой процесс, имеющий доступ к области общей "
"памяти, может обращаться к семафору с помощью B<sem_post>(3), B<sem_wait>(3) "
"и т. п. функций."

#. type: Plain text
#: man-pages/man3/sem_init.3:77
msgid ""
"Initializing a semaphore that has already been initialized results in "
"undefined behavior."
msgstr ""
"Инициализация семафора, который уже был инициализирован, приводит к "
"непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/sem_init.3:83
msgid ""
"B<sem_init>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"При успешном выполнении B<sem_init>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/sem_init.3:89
msgid "I<value> exceeds B<SEM_VALUE_MAX>."
msgstr "Значение I<value> превышает B<SEM_VALUE_MAX>."

#. type: Plain text
#: man-pages/man3/sem_init.3:95
msgid ""
"I<pshared> is nonzero, but the system does not support process-shared "
"semaphores (see B<sem_overview>(7))."
msgstr ""
"Значение I<pshared> не равно нулю, то система не поддерживает семафоры, "
"коллективно используемые процессами (смотрите B<sem_overview>(7))."

#. type: tbl table
#: man-pages/man3/sem_init.3:105
#, no-wrap
msgid "B<sem_init>()"
msgstr "B<sem_init>()"

#. type: Plain text
#: man-pages/man3/sem_init.3:109
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/sem_init.3:114
msgid ""
"Bizarrely, POSIX.1-2001 does not specify the value that should be returned "
"by a successful call to B<sem_init>().  POSIX.1-2008 rectifies this, "
"specifying the zero return on success."
msgstr ""
"Странно, но в POSIX.1-2001 не определено значение, которое должно "
"возвращаться при успешном выполнении вызова B<sem_init>(). В POSIX.1-2008 "
"это исправлено: при успешном выполнении должен возвращаться ноль."

#. type: Plain text
#: man-pages/man3/sem_init.3:118
msgid "B<sem_destroy>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_destroy>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sem_getvalue.3:26
#, no-wrap
msgid "SEM_GETVALUE"
msgstr "SEM_GETVALUE"

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:29
msgid "sem_getvalue - get the value of a semaphore"
msgstr "sem_getvalue - возвращает значение семафора"

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:34
#, no-wrap
msgid "B<int sem_getvalue(sem_t *>I<sem>B<, int *>I<sval>B<);>\n"
msgstr "B<int sem_getvalue(sem_t *>I<sem>B<, int *>I<sval>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:43
msgid ""
"B<sem_getvalue>()  places the current value of the semaphore pointed to "
"I<sem> into the integer pointed to by I<sval>."
msgstr ""
"Функция B<sem_getvalue>() помещает текущее значение семафора, заданного в "
"I<sem>, в виде целого, на которое указывает I<sval>."

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:54
msgid ""
"If one or more processes or threads are blocked waiting to lock the "
"semaphore with B<sem_wait>(3), POSIX.1 permits two possibilities for the "
"value returned in I<sval>: either 0 is returned; or a negative number whose "
"absolute value is the count of the number of processes and threads currently "
"blocked in B<sem_wait>(3).  Linux adopts the former behavior."
msgstr ""
"Если один или более процессов или нитей заблокированы в ожидании блокировки "
"семафора с помощью B<sem_wait>(3), то в этом случае в POSIX.1 разрешено "
"возвращать два варианта значения I<sval>: 0 или отрицательное число, чьё "
"абсолютное значение равно количеству процессов и нитей заблокированных в "
"B<sem_wait>(3). В Linux используется первый вариант."

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:60
msgid ""
"B<sem_getvalue>()  returns 0 on success; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<sem_getvalue>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: tbl table
#: man-pages/man3/sem_getvalue.3:75
#, no-wrap
msgid "B<sem_getvalue>()"
msgstr "B<sem_getvalue>()"

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:83
msgid ""
"The value of the semaphore may already have changed by the time "
"B<sem_getvalue>()  returns."
msgstr ""
"Значение семафора может уже быть изменено при возврате B<sem_getvalue>()."

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:86
msgid "B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sem_destroy.3:26
#, no-wrap
msgid "SEM_DESTROY"
msgstr "SEM_DESTROY"

#. type: Plain text
#: man-pages/man3/sem_destroy.3:29
msgid "sem_destroy - destroy an unnamed semaphore"
msgstr "sem_destroy - уничтожает безымянный семафор"

#. type: Plain text
#: man-pages/man3/sem_destroy.3:34
#, no-wrap
msgid "B<int sem_destroy(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_destroy(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_destroy.3:41
msgid ""
"B<sem_destroy>()  destroys the unnamed semaphore at the address pointed to "
"by I<sem>."
msgstr ""
"Функция B<sem_destroy>() уничтожает безымянный семафор, расположенный по "
"адресу I<sem>."

#. type: Plain text
#: man-pages/man3/sem_destroy.3:46
msgid ""
"Only a semaphore that has been initialized by B<sem_init>(3)  should be "
"destroyed using B<sem_destroy>()."
msgstr ""
"С помощью B<sem_destroy>() должны уничтожаться только семафоры, которые были "
"инициализированы с помощью B<sem_init>(3)."

#. type: Plain text
#: man-pages/man3/sem_destroy.3:51
msgid ""
"Destroying a semaphore that other processes or threads are currently blocked "
"on (in B<sem_wait>(3))  produces undefined behavior."
msgstr ""
"Уничтожение семафора, заблокированного другим процессом или нитью (в "
"B<sem_wait>(3)), приводит к непредсказуемым последствиям."

#. type: Plain text
#: man-pages/man3/sem_destroy.3:55
msgid ""
"Using a semaphore that has been destroyed produces undefined results, until "
"the semaphore has been reinitialized using B<sem_init>(3)."
msgstr ""
"Использование уничтоженного семафора (и повторно не инициализированного с "
"помощью B<sem_init>(3)) приводит к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/sem_destroy.3:61
msgid ""
"B<sem_destroy>()  returns 0 on success; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<sem_destroy>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: tbl table
#: man-pages/man3/sem_destroy.3:76
#, no-wrap
msgid "B<sem_destroy>()"
msgstr "B<sem_destroy>()"

#.  But not on NPTL, where sem_destroy () is a no-op..
#. type: Plain text
#: man-pages/man3/sem_destroy.3:86
msgid ""
"An unnamed semaphore should be destroyed with B<sem_destroy>()  before the "
"memory in which it is located is deallocated.  Failure to do this can result "
"in resource leaks on some implementations."
msgstr ""
"Безымянный семафор должен уничтожаться с помощью B<sem_destroy>() до "
"высвобождения памяти, которую он использует. Неследование этому правилу "
"приводит в некоторых реализациях к утечке ресурсов."

#. type: Plain text
#: man-pages/man3/sem_destroy.3:90
msgid "B<sem_init>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_init>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sleep.3:26
#, no-wrap
msgid "SLEEP"
msgstr "SLEEP"

#. type: Plain text
#: man-pages/man3/sleep.3:29
msgid "sleep - sleep for a specified number of seconds"
msgstr "sleep - приостанавливает выполнение на заданное число секунд"

#. type: Plain text
#: man-pages/man3/sleep.3:34
#, no-wrap
msgid "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: man-pages/man3/sleep.3:41
msgid ""
"B<sleep>()  causes the calling thread to sleep either until the number of "
"real-time seconds specified in I<seconds> have elapsed or until a signal "
"arrives which is not ignored."
msgstr ""
"Функция B<sleep>() заставляет вызывающую нить заснуть пока не пройдёт число "
"секунд реального времени I<seconds> или пока не поступит сигнал, который "
"невозможно проигнорировать."

#. type: Plain text
#: man-pages/man3/sleep.3:45
msgid ""
"Zero if the requested time has elapsed, or the number of seconds left to "
"sleep, if the call was interrupted by a signal handler."
msgstr ""
"Ноль, если запрошенное время истекло, или число секунд, оставшихся до "
"пробуждения в случае, когда вызов был прерван обработчиком сигнала."

#. type: tbl table
#: man-pages/man3/sleep.3:55
#, no-wrap
msgid "B<sleep>()"
msgstr "B<sleep>()"

#. type: tbl table
#: man-pages/man3/sleep.3:55
#, no-wrap
msgid "MT-Unsafe sig:SIGCHLD/linux"
msgstr "MT-Unsafe sig:SIGCHLD/linux"

#. type: Plain text
#: man-pages/man3/sleep.3:68
msgid ""
"On Linux, B<sleep>()  is implemented via B<nanosleep>(2).  See the "
"B<nanosleep>(2)  man page for a discussion of the clock used."
msgstr ""
"В Linux B<sleep>() реализована через вызов B<nanosleep>(2). Описание "
"задействованных часов смотрите в справочной странице B<nanosleep>(2)."

#. type: SS
#: man-pages/man3/sleep.3:68
#, no-wrap
msgid "Portability notes"
msgstr "Замечания о переносимости"

#. type: Plain text
#: man-pages/man3/sleep.3:81
msgid ""
"On some systems, B<sleep>()  may be implemented using B<alarm>(2)  and "
"B<SIGALRM> (POSIX.1 permits this); mixing calls to B<alarm>(2)  and "
"B<sleep>()  is a bad idea."
msgstr ""
"В некоторых системах функция B<sleep>() может быть реализована с помощью "
"B<alarm>(2) или B<SIGALRM> (POSIX.1 это допускает); лучше не смешивать "
"вызовы B<alarm>(2) и B<sleep>()."

#. type: Plain text
#: man-pages/man3/sleep.3:87
msgid ""
"Using B<longjmp>(3)  from a signal handler or modifying the handling of "
"B<SIGALRM> while sleeping will cause undefined results."
msgstr ""
"Использование B<longjmp>(3) из обработчика сигнала или изменение обработки "
"B<SIGALRM> в момент сна может привести к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/sleep.3:92
msgid "B<sleep>(1), B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"
msgstr "B<sleep>(1), B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"

#. type: TH
#: man-pages/man3/setjmp.3:24
#, no-wrap
msgid "SETJMP"
msgstr "SETJMP"

#. type: Plain text
#: man-pages/man3/setjmp.3:27
msgid "setjmp, sigsetjmp, longjmp, siglongjmp - performing a nonlocal goto"
msgstr "setjmp, sigsetjmp, longjmp, siglongjmp - выполняет нелокальный переход"

#. type: Plain text
#: man-pages/man3/setjmp.3:30
#, no-wrap
msgid "B<#include E<lt>setjmp.hE<gt>>\n"
msgstr "B<#include E<lt>setjmp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setjmp.3:33
#, no-wrap
msgid ""
"B<int setjmp(jmp_buf >I<env>B<);>\n"
"B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"
msgstr ""
"B<int setjmp(jmp_buf >I<env>B<);>\n"
"B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"

#. type: Plain text
#: man-pages/man3/setjmp.3:36
#, no-wrap
msgid ""
"B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"
"B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"
msgstr ""
"B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"
"B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"

#. type: Plain text
#: man-pages/man3/setjmp.3:45
msgid "B<setjmp>(): see NOTES."
msgstr "B<setjmp>(): смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man3/setjmp.3:48
msgid "B<sigsetjmp>(): _POSIX_C_SOURCE"
msgstr "B<sigsetjmp>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man3/setjmp.3:58
msgid ""
"The functions described on this page are used for performing \"nonlocal gotos"
"\": transferring execution from one function to a predetermined location in "
"another function.  The B<setjmp>()  function dynamically establishes the "
"target to which control will later be transferred, and B<longjmp>()  "
"performs the transfer of execution."
msgstr ""
"Функции, описываемые в этой странице, используются для выполнения "
"«нелокального goto»: передачи исполнения из одной функции в заранее "
"определённое место другой. Функция B<setjmp>() динамически устанавливает "
"точку для будущей передачи исполнения, а B<longjmp>() выполняет передачу "
"исполнения."

#. type: Plain text
#: man-pages/man3/setjmp.3:71
msgid ""
"The B<setjmp>()  function saves various information about the calling "
"environment (typically, the stack pointer, the instruction pointer, possibly "
"the values of other registers and the signal mask)  in the buffer I<env> for "
"later use by B<longjmp>().  In this case, B<setjmp>()  returns 0."
msgstr ""
"Функция B<setjmp>() сохраняет различную информацию об окружении вызова "
"(обычно, указатель стека, указатель инструкции, значения других регистров и "
"маску сигналов) в буфер I<env> для последующего использования в "
"B<longjmp>(). В этом случае B<setjmp>() возвращает 0."

#. type: Plain text
#: man-pages/man3/setjmp.3:86
msgid ""
"The B<longjmp>()  function uses the information saved in I<env> to transfer "
"control back to the point where B<setjmp>()  was called and to restore "
"(\"rewind\") the stack to its state at the time of the B<setjmp>()  call.  "
"In addition, and depending on the implementation (see NOTES), the values of "
"some other registers and the process signal mask may be restored to their "
"state at the time of the B<setjmp>()  call."
msgstr ""
"Функция B<longjmp>() использует информацию, сохранённую в I<env>, для "
"передачи управления обратно в точку, откуда была вызвана B<setjmp>(), и "
"восстанавливает («отматывает») стек до состояния на время вызова "
"B<setjmp>(). Также, в зависимости от реализации (смотрите ЗАМЕЧАНИЯ), "
"значения некоторых регистров маска сигналов процесса могут быть "
"восстановлены в их состояние на момент вызова B<setjmp>()."

#. type: Plain text
#: man-pages/man3/setjmp.3:99
msgid ""
"Following a successful B<longjmp>(), execution continues as if B<setjmp>()  "
"had returned for a second time.  This \"fake\" return can be distinguished "
"from a true B<setjmp>()  call because the \"fake\" return returns the value "
"provided in I<val>.  If the programmer mistakenly passes the value 0 in "
"I<val>, the \"fake\" return will instead return 1."
msgstr ""
"После успешного вызова B<longjmp>() выполнение продолжается как если бы "
"B<setjmp>() была вызвана второй раз. Этот «фиктивный» возврат можно "
"распознать от настоящего вызова B<setjmp>(), так как «фиктивный» возврат "
"возвращает значение, указанное в I<val>. Если программист ошибочно передаст "
"значение 0 в I<val>, то «фиктивный» возврат вернёт вместо него 1."

#. type: SS
#: man-pages/man3/setjmp.3:100
#, no-wrap
msgid "sigsetjmp() and siglongjmp()"
msgstr "sigsetjmp() и siglongjmp()"

#. type: Plain text
#: man-pages/man3/setjmp.3:106
msgid ""
"B<sigsetjmp>()  and B<siglongjmp>()  also perform nonlocal gotos, but "
"provide predictable handling of the process signal mask."
msgstr ""
"Функции B<sigsetjmp>() и B<siglongjmp>() также выполняют нелокальные "
"переходы, но предоставляют предсказуемую обработку сигнальной маски процесса."

#. type: Plain text
#: man-pages/man3/setjmp.3:117
msgid ""
"If, and only if, the I<savesigs> argument provided to B<sigsetjmp>()  is "
"nonzero, the process's current signal mask is saved in I<env> and will be "
"restored if a B<siglongjmp>()  is later performed with this I<env>."
msgstr ""
"Если, и только если, аргумент I<savesigs>, передаваемый в B<sigsetjmp>(), не "
"равен нулю, то текущая маска сигналов процесса сохраняется в I<env> и будет "
"восстановлена, если позднее будет запущена B<siglongjmp>() с этим I<env>."

#. type: Plain text
#: man-pages/man3/setjmp.3:129
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  return 0 when called directly; on the \"fake"
"\" return that occurs after B<longjmp>()  or B<siglongjmp>(), the nonzero "
"value specified in I<val> is returned."
msgstr ""
"Функции B<setjmp>() и B<sigsetjmp>() возвращают 0, если вызывают явно; при "
"«фиктивном» возврате, который возникает после B<longjmp>() или "
"B<siglongjmp>(), возвращается ненулевое значение, указанное в I<val>."

#. type: Plain text
#: man-pages/man3/setjmp.3:135
msgid "The B<longjmp>()  or B<siglongjmp>()  functions do not return."
msgstr "Функции B<longjmp>() и B<siglongjmp>() не выполняют возврат."

#. type: tbl table
#: man-pages/man3/setjmp.3:146
#, no-wrap
msgid ""
"B<setjmp>(),\n"
"B<sigsetjmp>()"
msgstr ""
"B<setjmp>(),\n"
"B<sigsetjmp>()"

#. type: tbl table
#: man-pages/man3/setjmp.3:150
#, no-wrap
msgid ""
"B<longjmp>(),\n"
"B<siglongjmp>()"
msgstr ""
"B<longjmp>(),\n"
"B<siglongjmp>()"

#. type: Plain text
#: man-pages/man3/setjmp.3:157
msgid "B<setjmp>(), B<longjmp>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "B<setjmp>(), B<longjmp>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man3/setjmp.3:161
msgid "B<sigsetjmp>(), B<siglongjmp>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<sigsetjmp>(), B<siglongjmp>(): POSIX.1-2001, POSIX.1-2008."

#.  so that _FAVOR_BSD is triggered
#.  .BR _XOPEN_SOURCE_EXTENDED ,
#. type: Plain text
#: man-pages/man3/setjmp.3:201
msgid ""
"POSIX does not specify whether B<setjmp>()  will save the signal mask (to be "
"later restored during B<longjmp>()).  In System V it will not.  In 4.3BSD it "
"will, and there is a function B<_setjmp>()  that will not.  The behavior "
"under Linux depends on the glibc version and the setting of feature test "
"macros.  On Linux with glibc versions before 2.19, B<setjmp>()  follows the "
"System V behavior by default, but the BSD behavior is provided if the "
"B<_BSD_SOURCE> feature test macro is explicitly defined and none of "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_GNU_SOURCE>, or "
"B<_SVID_SOURCE> is defined.  Since glibc 2.19, I<E<lt>setjmp.hE<gt>> exposes "
"only the System V version of B<setjmp>().  Programs that need the BSD "
"semantics should replace calls to B<setjmp>()  with calls to B<sigsetjmp>()  "
"with a nonzero I<savesigs> argument."
msgstr ""
"В POSIX не уточняется, должна ли B<setjmp>() сохранять сигнальную маску "
"(чтобы позднее восстановить её при B<longjmp>()). В System V — не должна. В "
"4.3BSD сохранение выполняется и есть функция B<_setjmp>, в которой этого не "
"происходит. Поведение в Linux зависит от версии glibc и установленных "
"макросов тестирования свойств. В Linux с glibc до версии 2.19 функция "
"B<setjmp>() по умолчанию ведёт себя как в System V, но можно включить "
"поведение как в BSD, если определить макрос тестирования свойств "
"B<_BSD_SOURCE> и будут не определены B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, "
"B<_XOPEN_SOURCE>, B<_GNU_SOURCE> или B<_SVID_SOURCE>. Начиная с glibc 2.19, "
"в I<E<lt>setjmp.hE<gt>> представляется только версия System V для "
"B<setjmp>(). Если в программе нужно задействовать семантику BSD, замените "
"вызовы B<setjmp>() на вызовы B<sigsetjmp>() с ненулевым аргументом "
"I<savesigs>."

#. type: Plain text
#: man-pages/man3/setjmp.3:216
msgid ""
"B<setjmp>()  and B<longjmp>()  can be useful for dealing with errors inside "
"deeply nested function calls or to allow a signal handler to pass control to "
"a specific point in the program, rather than returning to the point where "
"the handler interrupted the main program.  In the latter case, if you want "
"to portably save and restore signal masks, use B<sigsetjmp>()  and "
"B<siglongjmp>().  See also the discussion of program readability below."
msgstr ""
"Функции B<setjmp>() и B<longjmp>() можно использовать для обработки ошибок "
"внутри глубоко вложенных вызовов функций или чтобы позволить обработчику "
"сигналов передать управление в определённую точку программы, и не возвращать "
"исполнение главной программе в точку прерывания обработчиком. В последнем "
"случае, если вы хотите сохранить и восстановить маску сигналов переносимым "
"образом, то используйте B<sigsetjmp>() и B<siglongjmp>(). Также смотрите "
"раздел про читаемость программы далее."

#. type: Plain text
#: man-pages/man3/setjmp.3:225
msgid ""
"The compiler may optimize variables into registers, and B<longjmp>()  may "
"restore the values of other registers in addition to the stack pointer and "
"program counter.  Consequently, the values of automatic variables are "
"unspecified after a call to B<longjmp>()  if they meet all the following "
"criteria:"
msgstr ""
"Компилятор может оптимизировать переменные в регистрах и B<longjmp>() может "
"восстановить значения регистров помимо указателя стека и счётчика программы. "
"Следовательно, значения автоматических переменных непредсказуемы после "
"вызова B<longjmp>(), если они удовлетворяют следующим критериям:"

#. type: Plain text
#: man-pages/man3/setjmp.3:229
msgid ""
"they are local to the function that made the corresponding B<setjmp>()  call;"
msgstr ""
"они локальны для функции, которая сделала соответствующий вызов B<setjmp>();"

#. type: Plain text
#: man-pages/man3/setjmp.3:235
msgid ""
"their values are changed between the calls to B<setjmp>()  and B<longjmp>(); "
"and"
msgstr "их значения изменились между вызовами B<setjmp>() и B<longjmp>(); и"

#. type: Plain text
#: man-pages/man3/setjmp.3:238
msgid "they are not declared as I<volatile>."
msgstr "они не объявлены как I<volatile>."

#. type: Plain text
#: man-pages/man3/setjmp.3:242
msgid "Analogous remarks apply for B<siglongjmp>()."
msgstr "Аналогичные замечания относятся и к B<siglongjmp>()."

#. type: SS
#: man-pages/man3/setjmp.3:242
#, no-wrap
msgid "Nonlocal gotos and program readability"
msgstr "Нелокальные переходы и читаемость программы"

#. type: Plain text
#: man-pages/man3/setjmp.3:262
msgid ""
"While it can be abused, the traditional C \"goto\" statement at least has "
"the benefit that lexical cues (the goto statement and the target label)  "
"allow the programmer to easily perceive the flow of control.  Nonlocal gotos "
"provide no such cues: multiple B<setjmp>()  calls might employ the same "
"I<jmp_buf> variable so that the content of the variable may change over the "
"lifetime of the application.  Consequently, the programmer may be forced to "
"perform detailed reading of the code to determine the dynamic target of a "
"particular B<longjmp>()  call.  (To make the programmer's life easier, each "
"B<setjmp>()  call should employ a unique I<jmp_buf> variable.)"
msgstr ""
"Хотя этим и можно злоупотребить, обычный оператор C «goto» имеет "
"преимущество в виде лексических отметок (оператор goto и метка перехода), "
"которые позволяют программисту легко понять поток выполнения. Нелокальные "
"переходы не имеют таких отметок: многократные вызовы B<setjmp>() могут "
"использовать одну переменную I<jmp_buf>, то есть контекст переменной может "
"изменяться на протяжении времени работы приложения. Следовательно, "
"программисту придёт вчитываться в код для определения динамической точки "
"перехода определённого вызова B<longjmp>() (для облегчения жизни "
"программиста в каждом вызове B<setjmp>() должна использоваться уникальная "
"переменная I<jmp_buf>)."

#. type: Plain text
#: man-pages/man3/setjmp.3:268
msgid ""
"Adding further difficulty, the B<setjmp>()  and B<longjmp>()  calls may not "
"even be in the same source code module."
msgstr ""
"Дополнительная сложность: вызовы B<setjmp>() и B<longjmp>() даже могут быть "
"в разных модулях исходного кода."

#. type: Plain text
#: man-pages/man3/setjmp.3:272
msgid ""
"In summary, nonlocal gotos can make programs harder to understand and "
"maintain, and an alternative should be used if possible."
msgstr ""
"Таким образом, нелокальные переходы могут сделать программу тяжелее для "
"понимания и поддержки, и, если это возможно, нужно использовать "
"альтернативные варианты."

#. type: Plain text
#: man-pages/man3/setjmp.3:279
msgid ""
"If the function which called B<setjmp>()  returns before B<longjmp>()  is "
"called, the behavior is undefined.  Some kind of subtle or unsubtle chaos is "
"sure to result."
msgstr ""
"Если функция, вызвавшая B<setjmp>() завершилась до вызова B<longjmp>(), то "
"поведение не определено. Результатом может стать маленький (или не очень) "
"хаос."

#.  The following statement appeared in versions up to POSIX.1-2008 TC1,
#.  but is set to be removed in POSIX.1-2008 TC2:
#.      According to POSIX.1, if a
#.      .BR longjmp ()
#.      call is performed from a nested signal handler
#.      (i.e., from a handler that was invoked in response to a signal that was
#.      generated while another signal was already in the process of being
#.      handled), the behavior is undefined.
#. type: Plain text
#: man-pages/man3/setjmp.3:297
msgid ""
"If, in a multithreaded program, a B<longjmp>()  call employs an I<env> "
"buffer that was initialized by a call to B<setjmp>()  in a different thread, "
"the behavior is undefined."
msgstr ""
"Если в многонитевой программе вызов B<longjmp>() использует буфер I<env>, "
"инициализированный вызовом B<setjmp>() в другой нити, то поведение не "
"определено."

#.  http://austingroupbugs.net/view.php?id=516#c1195
#. type: Plain text
#: man-pages/man3/setjmp.3:315
msgid ""
"POSIX.1-2008 Technical Corrigendum 2 adds B<longjmp>()  and B<siglongjmp>()  "
"to the list of async-signal-safe functions.  However, the standard "
"recommends avoiding the use of these functions from signal handlers and goes "
"on to point out that if these functions are called from a signal handler "
"that interrupted a call to a non-async-signal-safe function (or some "
"equivalent, such as the steps equivalent to B<exit>(3)  that occur upon a "
"return from the initial call to I<main>()), the behavior is undefined if the "
"program subsequently makes a call to a non-async-signal-safe function.  The "
"only way of avoiding undefined behavior is to ensure one of the following:"
msgstr ""
"В POSIX.1-2008 Technical Corrigendum 2 вызовы B<longjmp>() и B<siglongjmp>() "
"добавлены в список функций async-signal-safe. Однако стандарт рекомендует "
"избегать использования этих функций в обработчиках сигналов и указывает, что "
"если эти функции вызваны из обработчика сигналов, который прервал вызов "
"функции не async-signal-safe (или её эквивалент, например шагам B<exit>(3), "
"который возникают  при возврате из начального вызова I<main>()), то "
"поведение не определено, если программа далее вызывает функцию не async-"
"signal-safe. Единственным способом избежать неопределённого поведения, "
"является проверка следующего:"

#. type: Plain text
#: man-pages/man3/setjmp.3:320
msgid ""
"After long jumping from the signal handler, the program does not call any "
"non-async-signal-safe functions and does not return from the initial call to "
"I<main>()."
msgstr ""
"После длинного перехода из обработчика сигналов программа не вызывает каких-"
"либо функций не async-signal-safe и не возвращается из первоначального "
"вызова в I<main>()."

#. type: Plain text
#: man-pages/man3/setjmp.3:327
msgid ""
"Any signal whose handler performs a long jump must be blocked during "
"I<every> call to a non-async-signal-safe function and no non-async-signal-"
"safe functions are called after returning from the initial call to I<main>()."
msgstr ""
"Любой сигнал, чей обработчик выполняет длинный переход, должен быть "
"заблокирован на время I<каждого> вызова функции не async-signal-safe и не "
"вызывать функции не async-signal-safe после возврата из начального вызова в "
"I<main>()."

#. type: Plain text
#: man-pages/man3/setjmp.3:329
msgid "B<signal>(7), B<signal-safety>(7)"
msgstr "B<signal>(7), B<signal-safety>(7)"

#. type: TH
#: man-pages/man3/sigpause.3:25
#, no-wrap
msgid "SIGPAUSE"
msgstr "SIGPAUSE"

#. type: Plain text
#: man-pages/man3/sigpause.3:28
msgid "sigpause - atomically release blocked signals and wait for interrupt"
msgstr "sigpause - автоматически разблокирует сигналы и ждёт прерывания"

#. type: Plain text
#: man-pages/man3/sigpause.3:33
#, no-wrap
msgid "B<int sigpause(int >I<sigmask>B<);  /* BSD (but see NOTES) */>\n"
msgstr "B<int sigpause(int >I<sigmask>B<);  /* BSD (но см. ЗАМЕЧАНИЯ) */>\n"

#. type: Plain text
#: man-pages/man3/sigpause.3:35
#, no-wrap
msgid "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"
msgstr "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"

#. type: Plain text
#: man-pages/man3/sigpause.3:41
msgid "Don't use this function.  Use B<sigsuspend>(2)  instead."
msgstr "Не используйте эту функцию. Вместо неё используйте B<sigsuspend>(2)."

#. type: Plain text
#: man-pages/man3/sigpause.3:48
msgid ""
"The function B<sigpause>()  is designed to wait for some signal.  It changes "
"the process's signal mask (set of blocked signals), and then waits for a "
"signal to arrive.  Upon arrival of a signal, the original signal mask is "
"restored."
msgstr ""
"Функция B<sigpause>() предназначена для ожидания какого-нибудь сигнала. Она "
"изменяет сигнальную маску процесса (набор блокируемых сигналов) и ждёт "
"появления сигнала. При прибытии сигнала первоначальная сигнальная маска "
"восстанавливается."

#. type: Plain text
#: man-pages/man3/sigpause.3:56
msgid ""
"If B<sigpause>()  returns, it was interrupted by a signal and the return "
"value is -1 with I<errno> set to B<EINTR>."
msgstr ""
"Если B<sigpause>() возвращает выполнение, то это означает, что она была "
"прервана сигналом и возвращается значение -1, а I<errno> присваивается "
"значение B<EINTR>."

#. type: tbl table
#: man-pages/man3/sigpause.3:66
#, no-wrap
msgid "B<sigpause>()"
msgstr "B<sigpause>()"

#. type: Plain text
#: man-pages/man3/sigpause.3:81
msgid ""
"The System V version of B<sigpause>()  is standardized in POSIX.1-2001.  It "
"is also specified in POSIX.1-2008, where it is marked obsolete."
msgstr ""
"Версия B<sigpause>() из System V стандартизована в POSIX.1-2001. Также она "
"есть в POSIX.1-2008, но помечена как устаревшая."

#.  __xpg_sigpause: UNIX 95, spec 1170, SVID, SVr4, XPG
#. type: Plain text
#: man-pages/man3/sigpause.3:98
msgid ""
"The classical BSD version of this function appeared in 4.2BSD.  It sets the "
"process's signal mask to I<sigmask>.  UNIX 95 standardized the incompatible "
"System V version of this function, which removes only the specified signal "
"I<sig> from the process's signal mask.  The unfortunate situation with two "
"incompatible functions with the same name was solved by the B<\\"
"%sigsuspend>(2)  function, that takes a I<sigset_t\\ *> argument (instead of "
"an I<int>)."
msgstr ""
"Классическая BSD-версия этой функции появилась в 4.2BSD. Она изменяет "
"сигнальную маску процесса на I<sigmask>. В UNIX 95 стандартизована "
"несовместимая с System V версия этой функции, которая удаляет сигнальной "
"маски процесса только указанный сигнал I<sig>. Проблемная ситуация двух "
"несовместимых функций с одним именем была исправлена функцией B<\\"
"%sigsuspend>(2), которая ожидает аргумент с типом I<sigset_t\\ *> (вместо "
"I<int>)."

#. type: Plain text
#: man-pages/man3/sigpause.3:101
msgid ""
"On Linux, this routine is a system call only on the Sparc (sparc64)  "
"architecture."
msgstr ""
"В Linux эта процедура является системным вызовом только на архитектуре Sparc "
"(sparc64)."

#.  Libc4 and libc5 know only about the BSD version.
#. type: Plain text
#: man-pages/man3/sigpause.3:116
msgid ""
"Glibc uses the BSD version if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined.  Otherwise, the System V "
"version is used, and feature test macros must be defined as follows to "
"obtain the declaration:"
msgstr ""
"В glibc используется версия BSD, если определён макрос тестирования свойств "
"B<_BSD_SOURCE> и отсутствуют B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, "
"B<_XOPEN_SOURCE>, B<_GNU_SOURCE> или B<_SVID_SOURCE>. В противном случае "
"используется версия System V и для получения объявления должен быть "
"определен следующие макросы тестирования свойств:"

#.  || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: man-pages/man3/sigpause.3:120
msgid "Since glibc 2.26: _XOPEN_SOURCE E<gt>= 500"
msgstr "Начиная с glibc 2.26: _XOPEN_SOURCE E<gt>= 500"

#. type: Plain text
#: man-pages/man3/sigpause.3:122
msgid "Glibc 2.25 and earlier: _XOPEN_SOURCE"
msgstr "glibc 2.25 и старее: _XOPEN_SOURCE"

#.  For the BSD version, one usually uses a zero
#.  .I sigmask
#.  to indicate that no signals are to be blocked.
#. type: Plain text
#: man-pages/man3/sigpause.3:133
msgid ""
"Since glibc 2.19, only the System V version is exposed by I<E<lt>signal."
"hE<gt>>; applications that formerly used the BSD B<sigpause>()  should be "
"amended to use B<sigsuspend>(2)."
msgstr ""
"Начиная с glibc 2.19, в I<E<lt>signal.hE<gt>> представлена только версия "
"System V; в приложениях, которые использовали BSD-версию B<sigpause>(), "
"нужно заменить его на B<sigsuspend>(2)."

#. type: Plain text
#: man-pages/man3/sigpause.3:140
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"

#. type: TH
#: man-pages/man3/strtod.3:45
#, no-wrap
msgid "STRTOD"
msgstr "STRTOD"

#. type: Plain text
#: man-pages/man3/strtod.3:48
msgid "strtod, strtof, strtold - convert ASCII string to floating-point number"
msgstr ""
"strtod, strtof, strtold - преобразует строку ASCII в число с плавающей точкой"

#. type: Plain text
#: man-pages/man3/strtod.3:50
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/strtod.3:52
msgid "B<double strtod(const char *>I<nptr>B<, char **>I<endptr>B<);>"
msgstr "B<double strtod(const char *>I<nptr>B<, char **>I<endptr>B<);>"

#. type: Plain text
#: man-pages/man3/strtod.3:54
msgid "B<float strtof(const char *>I<nptr>B<, char **>I<endptr>B<);>"
msgstr "B<float strtof(const char *>I<nptr>B<, char **>I<endptr>B<);>"

#. type: Plain text
#: man-pages/man3/strtod.3:56
msgid "B<long double strtold(const char *>I<nptr>B<, char **>I<endptr>B<);>"
msgstr "B<long double strtold(const char *>I<nptr>B<, char **>I<endptr>B<);>"

#. type: Plain text
#: man-pages/man3/strtod.3:65
msgid "B<strtof>(), B<strtold>():"
msgstr "B<strtof>(), B<strtold>():"

#. type: Plain text
#: man-pages/man3/strtod.3:83
msgid ""
"The B<strtod>(), B<strtof>(), and B<strtold>()  functions convert the "
"initial portion of the string pointed to by I<nptr> to I<double>, I<float>, "
"and I<long double> representation, respectively."
msgstr ""
"Функции B<strtod>(), B<strtof>() и B<strtold>() преобразуют начальную часть "
"строки, на которую указывает I<nptr>, в числа типа I<double>, I<float>, и "
"I<long double>, соответственно."

#. type: Plain text
#: man-pages/man3/strtod.3:90
msgid ""
"The expected form of the (initial portion of the) string is optional leading "
"white space as recognized by B<isspace>(3), an optional plus (\\(aq+\\(aq) "
"or minus sign (\\(aq-\\(aq) and then either (i) a decimal number, or (ii) a "
"hexadecimal number, or (iii) an infinity, or (iv) a NAN (not-a-number)."
msgstr ""
"Ожидаемый вид строки (её начальная часть) — это начальные пробельные символы "
"(необязательно), распознаваемые функцией B<isspace>(3), возможно знаки плюс "
"(\\(aq+\\(aq) или минус (\\(aq-\\(aq), а затем либо (а) десятичное число, "
"либо (б) шестнадцатеричное число, либо (в) бесконечность, либо (г) NAN (not-"
"a-number, нечисловое значение)."

#. type: Plain text
#: man-pages/man3/strtod.3:99
msgid ""
"A I<decimal number> consists of a nonempty sequence of decimal digits "
"possibly containing a radix character (decimal point, locale-dependent, "
"usually \\(aq.\\(aq), optionally followed by a decimal exponent.  A decimal "
"exponent consists of an \\(aqE\\(aq or \\(aqe\\(aq, followed by an optional "
"plus or minus sign, followed by a nonempty sequence of decimal digits, and "
"indicates multiplication by a power of 10."
msgstr ""
"I<Десятичное число> состоит из не пустой последовательности десятичных цифр "
"от 0 до 9, возможно содержащей символ дробного разделителя (десятичная "
"точка, зависит от настройки локали; обычно это символ точки \\(aq.\\(aq), "
"возможно с последующей десятичной экспонентой. Десятичная экспонента состоит "
"из символа \\(aqE\\(aq или \\(aqe\\(aq, далее возможен знак плюс или минус, "
"а затем непустая последовательность десятичных цифр, означающая умножение "
"всей начальной части на 10 в указанной степени."

#. type: Plain text
#: man-pages/man3/strtod.3:110
msgid ""
"A I<hexadecimal number> consists of a \"0x\" or \"0X\" followed by a "
"nonempty sequence of hexadecimal digits possibly containing a radix "
"character, optionally followed by a binary exponent.  A binary exponent "
"consists of a \\(aqP\\(aq or \\(aqp\\(aq, followed by an optional plus or "
"minus sign, followed by a nonempty sequence of decimal digits, and indicates "
"multiplication by a power of 2.  At least one of radix character and binary "
"exponent must be present."
msgstr ""
"I<Шестнадцатеричное число> состоит из символов «0x» или «0X» с последующей "
"непустой последовательностью из шестнадцатеричных цифр, возможно содержащей "
"символ дробного разделителя, далее может следовать двоичная экспонента. "
"Двоичная экспонента состоит из символа \\(aqP\\(aq или \\(aqp\\(aq, далее, "
"возможно, знака плюс или минус, и непустой последовательности десятичных "
"цифр, обозначающих умножение всего начального числа на 2 в указанной "
"степени. По меньшей мере должен быть указан либо символ дробного разделителя "
"либо двоичная экспонента."

#. type: Plain text
#: man-pages/man3/strtod.3:114
msgid "An I<infinity> is either \"INF\" or \"INFINITY\", disregarding case."
msgstr ""
"I<Бесконечность> — это либо значение «INF» либо «INFINITY», регистр символов "
"не учитывается."

#. type: Plain text
#: man-pages/man3/strtod.3:123
msgid ""
"A I<NAN> is \"NAN\" (disregarding case) optionally followed by a string, "
"I<(n-char-sequence)>, where I<n-char-sequence> specifies in an "
"implementation-dependent way the type of NAN (see NOTES)."
msgstr ""
"Нечисловое значение (I<NAN>) — это значение «NAN» (регистр символов не "
"учитывается) возможно сопровождаемое I<(последовательность n символов)>, где "
"I<последовательность n символов>, определяет тип нечислового значения в "
"зависимости от текущего представления NAN в системе (смотрите ЗАМЕЧАНИЯ)."

#. type: Plain text
#: man-pages/man3/strtod.3:125
msgid "These functions return the converted value, if any."
msgstr "Функции возвращают преобразованное значение, если таковое существует."

#. type: Plain text
#: man-pages/man3/strtod.3:132
msgid ""
"If I<endptr> is not NULL, a pointer to the character after the last "
"character used in the conversion is stored in the location referenced by "
"I<endptr>."
msgstr ""
"Если I<endptr> не равно NULL, то указатель на символ, следующий за последним "
"обработанным символом, сохраняется в место, указываемое I<endptr>."

#. type: Plain text
#: man-pages/man3/strtod.3:139
msgid ""
"If no conversion is performed, zero is returned and (unless I<endptr> is "
"null) the value of I<nptr> is stored in the location referenced by I<endptr>."
msgstr ""
"Если никаких преобразований не производилось, то возвращается ноль, а "
"значение I<nptr> сохраняется в той позиции, на которую ссылается I<endptr> "
"(если I<endptr> не равно null)."

#. type: Plain text
#: man-pages/man3/strtod.3:153
msgid ""
"If the correct value would cause overflow, plus or minus B<HUGE_VAL> "
"(B<HUGE_VALF>, B<HUGE_VALL>)  is returned (according to the sign of the "
"value), and B<ERANGE> is stored in I<errno>.  If the correct value would "
"cause underflow, zero is returned and B<ERANGE> is stored in I<errno>."
msgstr ""
"Если правильное значение вызвало бы переполнение, то возвращается "
"B<HUGE_VAL> (B<HUGE_VALF>, B<HUGE_VALL>)  (в зависимости от знака величины), "
"а B<ERANGE> записывается в переменную I<errno>. Если правильное значение "
"было исчерпанным, то возвращается ноль, а переменной I<errno> присваивается "
"значение I<ERANGE>."

#. type: Plain text
#: man-pages/man3/strtod.3:157
msgid "Overflow or underflow occurred."
msgstr "Величина оказалась слишком большой или очень маленькой."

#. type: tbl table
#: man-pages/man3/strtod.3:169
#, no-wrap
msgid ""
"B<strtod>(),\n"
"B<strtof>(),\n"
"B<strtold>()"
msgstr ""
"B<strtod>(),\n"
"B<strtof>(),\n"
"B<strtold>()"

#. type: Plain text
#: man-pages/man3/strtod.3:176
msgid "B<strtod>()  was also described in C89."
msgstr "B<strtod>() была также описана в C89."

#. type: Plain text
#: man-pages/man3/strtod.3:185
msgid ""
"Since 0 can legitimately be returned on both success and failure, the "
"calling program should set I<errno> to 0 before the call, and then determine "
"if an error occurred by checking whether I<errno> has a nonzero value after "
"the call."
msgstr ""
"Так как возвращаемым значением может быть 0 при успешном выполнении и "
"ошибке, вызывающая программа должна присвоить I<errno> значение 0 до вызова, "
"а после вызова определить возникновение ошибки по ненулевому значению "
"I<errno>."

#.  From glibc 2.8's stdlib/strtod_l.c:
#.      We expect it to be a number which is put in the
#.      mantissa of the number.
#.  It looks as though at least FreeBSD (according to the manual) does
#.  something similar.
#.  C11 says: "An implementation may use the n-char sequence to determine
#. 	extra information to be represented in the NaN's significant."
#. type: Plain text
#: man-pages/man3/strtod.3:200
msgid ""
"In the glibc implementation, the I<n-char-sequence> that optionally follows "
"\"NAN\" is interpreted as an integer number (with an optional '0' or '0x' "
"prefix to select base 8 or 16)  that is to be placed in the mantissa "
"component of the returned value."
msgstr ""
"В реализации glibc I<последовательность n символов>, которая может "
"появляться после «NAN», рассматривается как целое число (с необязательным "
"префиксом «0» или «0x» для указания системы счисления 8 или 16), которое "
"будет помещено в мантиссу возвращаемого значения."

#. type: Plain text
#: man-pages/man3/strtod.3:214
msgid ""
"B<atof>(3), B<atoi>(3), B<atol>(3), B<nan>(3), B<nanf>(3), B<nanl>(3), "
"B<strfromd>(3), B<strtol>(3), B<strtoul>(3)"
msgstr ""
"B<atof>(3), B<atoi>(3), B<atol>(3), B<nan>(3), B<nanf>(3), B<nanl>(3), "
"B<strfromd>(3), B<strtol>(3), B<strtoul>(3)"

#. type: TH
#: man-pages/man3/system.3:31
#, no-wrap
msgid "SYSTEM"
msgstr "SYSTEM"

#. type: Plain text
#: man-pages/man3/system.3:34
msgid "system - execute a shell command"
msgstr "system - выполняет команду оболочки (shell)"

#. type: Plain text
#: man-pages/man3/system.3:39
#, no-wrap
msgid "B<int system(const char *>I<command>B<);>\n"
msgstr "B<int system(const char *>I<command>B<);>\n"

#. type: Plain text
#: man-pages/man3/system.3:50
msgid ""
"The B<system>()  library function uses B<fork>(2)  to create a child process "
"that executes the shell command specified in I<command> using B<execl>(3)  "
"as follows:"
msgstr ""
"В библиотечной функции B<system>() используется B<fork>(2) для создания "
"процесса-потомка, в котором посредством B<execl>(3) запускается команда "
"оболочки, указанная в I<command>:"

#. type: Plain text
#: man-pages/man3/system.3:54
#, no-wrap
msgid "execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n"
msgstr "execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n"

#. type: Plain text
#: man-pages/man3/system.3:59
msgid "B<system>()  returns after the command has been completed."
msgstr ""
"Функция B<system>() возвращает результат после завершения работы команды."

#. type: Plain text
#: man-pages/man3/system.3:71
msgid ""
"During execution of the command, B<SIGCHLD> will be blocked, and B<SIGINT> "
"and B<SIGQUIT> will be ignored, in the process that calls B<system>().  "
"(These signals will be handled according to their defaults inside the child "
"process that executes I<command>.)"
msgstr ""
"На время выполнения команды B<SIGCHLD> блокируется, а B<SIGINT> и B<SIGQUIT> "
"игнорируются в процессе, который вызвал B<system>() (эти сигналы будут "
"обработаны их действиями по умолчанию внутри процесса-потомка, который "
"выполняет I<command>)."

#. type: Plain text
#: man-pages/man3/system.3:77
msgid ""
"If I<command> is NULL, then B<system>()  returns a status indicating whether "
"a shell is available on the system."
msgstr ""
"Если значение I<command> равно NULL, то B<system>() возвращает состояние, "
"показывающее доступна ли оболочка в системе."

#. type: Plain text
#: man-pages/man3/system.3:81
msgid "The return value of B<system>()  is one of the following:"
msgstr "Возвращаемым значением B<system>() может быть одно из:"

#. type: Plain text
#: man-pages/man3/system.3:86
msgid ""
"If I<command> is NULL, then a nonzero value if a shell is available, or 0 if "
"no shell is available."
msgstr ""
"Если значение I<command> равно NULL, то возвращается ненулевое значение, "
"если оболочка присутствует в системе, или 0, если оболочка недоступна."

#. type: Plain text
#: man-pages/man3/system.3:92
msgid ""
"If a child process could not be created, or its status could not be "
"retrieved, the return value is -1 and I<errno> is set to indicate the error."
msgstr ""
"Если процесс-потомок не может быть создан или его состояние невозможно "
"вернуть, то возвращается значение -1, а I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/system.3:97
msgid ""
"If a shell could not be executed in the child process, then the return value "
"is as though the child shell terminated by calling B<_exit>(2)  with the "
"status 127."
msgstr ""
"Если оболочка не может выполниться в процессе-потомке, то возвращается "
"значение будет таким же как если бы оболочка-потомок завершилась вызовом "
"B<_exit>(2) с состоянием 127."

#. type: Plain text
#: man-pages/man3/system.3:104
msgid ""
"If all system calls succeed, then the return value is the termination status "
"of the child shell used to execute I<command>.  (The termination status of a "
"shell is the termination status of the last command it executes.)"
msgstr ""
"Если все системные вызовы выполнены без ошибок, то возвращается значение "
"состояния завершения процесса-потомка, использовавшегося для выполнения "
"I<command> (состояние завершения оболочки — это состояние завершения "
"последней выполнявшейся команды)."

#. type: Plain text
#: man-pages/man3/system.3:113
msgid ""
"In the last two cases, the return value is a \"wait status\" that can be "
"examined using the macros described in B<waitpid>(2).  (i.e., "
"B<WIFEXITED>(), B<WEXITSTATUS>(), and so on)."
msgstr ""
"В последних двух случаях возвращаемое значение — это «состояние ожидания», "
"которое можно определить с помощью макроса описанного в B<waitpid>(2) (т. "
"е., B<WIFEXITED>(), B<WEXITSTATUS>() и т. п.)."

#. type: Plain text
#: man-pages/man3/system.3:116
msgid "B<system>()  does not affect the wait status of any other children."
msgstr "Функция B<system>() не отражает состояние ожидание других потомков."

#. type: Plain text
#: man-pages/man3/system.3:120
msgid "B<system>()  can fail with any of the same errors as B<fork>(2)."
msgstr ""
"Функция B<system>() может завершиться  с теми же ошибками что и B<fork>(2)."

#. type: tbl table
#: man-pages/man3/system.3:130
#, no-wrap
msgid "B<system>()"
msgstr "B<system>()"

#. type: Plain text
#: man-pages/man3/system.3:151
msgid ""
"B<system>()  provides simplicity and convenience: it handles all of the "
"details of calling B<fork>(2), B<execl>(3), and B<waitpid>(2), as well as "
"the necessary manipulations of signals; in addition, the shell performs the "
"usual substitutions and I/O redirections for I<command>.  The main cost of "
"B<system>()  is inefficiency: additional system calls are required to create "
"the process that runs the shell and to execute the shell."
msgstr ""
"Функция B<system>() проста и удобна: она позаботится обо всём для вызовов "
"B<fork>(2), B<execl>(3) и B<waitpid>(2), а также необходимых действиях с "
"сигналами; также оболочка выполнит обычные подстановки и перенаправления "
"ввода-вывода I<command>. Но B<system>() не эффективна: для создания процесса "
"требуются дополнительные системные вызовы, которые запускают оболочку и "
"выполняют команду."

#. type: Plain text
#: man-pages/man3/system.3:163
msgid ""
"If the B<_XOPEN_SOURCE> feature test macro is defined (before including "
"I<any> header files), then the macros described in B<waitpid>(2)  "
"(B<WEXITSTATUS>(), etc.) are made available when including I<E<lt>stdlib."
"hE<gt>>."
msgstr ""
"Если определён макрос тестирования свойств B<_XOPEN_SOURCE> (до включения "
"I<всех> заголовочных файлов), то при включении I<E<lt>stdlib.hE<gt>> "
"становятся доступны макросы, описанные в B<waitpid>(2) (B<WEXITSTATUS>() и "
"т. п.)."

#. type: Plain text
#: man-pages/man3/system.3:174
msgid ""
"As mentioned, B<system>()  ignores B<SIGINT> and B<SIGQUIT>.  This may make "
"programs that call it from a loop uninterruptible, unless they take care "
"themselves to check the exit status of the child.  For example:"
msgstr ""
"Как уже упоминалось,  функция B<system>() игнорирует B<SIGINT> и B<SIGQUIT>. "
"Это может привести к тому, что программы вызывающие её из цикла станут не "
"прерываемыми, пока сами не проверят условия выхода для своих дочерних "
"процессов. Пример:"

#. type: Plain text
#: man-pages/man3/system.3:179
#, no-wrap
msgid ""
"while (something) {\n"
"    int ret = system(\"foo\");\n"
msgstr ""
"while (something) {\n"
"    int ret = system(\"foo\");\n"

#. type: Plain text
#: man-pages/man3/system.3:184
#, no-wrap
msgid ""
"    if (WIFSIGNALED(ret) &&\n"
"        (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT))\n"
"            break;\n"
"}\n"
msgstr ""
"    if (WIFSIGNALED(ret) &&\n"
"        (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT))\n"
"            break;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/system.3:192
msgid ""
"According to POSIX.1, it is unspecified whether handlers registered using "
"B<pthread_atfork>(3)  are called during the execution of B<system>().  In "
"the glibc implementation, such handlers are not called."
msgstr ""
"В POSIX.1 не определено, вызываются ли обработчики, зарегистрированные "
"B<pthread_atfork>(3), при выполнении B<system>(). В реализации glibc такие "
"обработчики не вызываются."

#. type: Plain text
#: man-pages/man3/system.3:206
msgid ""
"In versions of glibc before 2.1.3, the check for the availability of I</bin/"
"sh> was not actually performed if I<command> was NULL; instead it was always "
"assumed to be available, and B<system>()  always returned 1 in this case.  "
"Since glibc 2.1.3, this check is performed because, even though POSIX.1-2001 "
"requires a conforming implementation to provide a shell, that shell may not "
"be available or executable if the calling program has previously called "
"B<chroot>(2)  (which is not specified by POSIX.1-2001)."
msgstr ""
"В версиях glibc до 2.1.3 проверка доступности I</bin/sh> в действительности "
"не выполнялась, если значение I<command> равно NULL; вместо этого всегда "
"предполагалось наличие, и в этом случае B<system>() всегда возвращала 1. "
"Начиная с glibc 2.1.3, эта проверка выполняется, так как несмотря на "
"требование POSIX.1-2001   a conforming implementation to provide a shell, "
"that shell may not be available or executable if the calling program has "
"previously called B<chroot>(2)  (which is not specified by POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/system.3:213
msgid ""
"It is possible for the shell command to terminate with a status of 127, "
"which yields a B<system>()  return value that is indistinguishable from the "
"case where a shell could not be executed in the child process."
msgstr ""
"Существует вероятность, что команда оболочки возвратит значение 127, которое "
"также является и возвращаемым значением самой B<system>(); в этом случае "
"нельзя понять, что невозможно выполнить оболочку в процессе-потомке."

#. type: Plain text
#: man-pages/man3/system.3:234
msgid ""
"Do not use B<system>()  from a privileged program (a set-user-ID or set-"
"group-ID program, or a program with capabilities)  because strange values "
"for some environment variables might be used to subvert system integrity.  "
"For example, B<PATH> could be manipulated so that an arbitrary program is "
"executed with privilege.  Use the B<exec>(3)  family of functions instead, "
"but not B<execlp>(3)  or B<execvp>(3)  (which also use the B<PATH> "
"environment variable to search for an executable)."
msgstr ""
"Не используйте B<system>() в привилегированных программах (программы с set-"
"user-ID или set-group-ID, или программы с мандатами), так как могут "
"использоваться странные значения некоторых переменных окружения для "
"разрушения целостности системы. Например, B<PATH> может быть изменена так, "
"что произвольная программа выполняется с расширенными правами. Вместо этого "
"используйте семейство функций B<exec>(3), но не B<execlp>(3) или "
"B<execvp>(3) (которые также используют переменную окружения B<PATH> для "
"поиска исполняемого файла)."

#. type: Plain text
#: man-pages/man3/system.3:244
msgid ""
"B<system>()  will not, in fact, work properly from programs with set-user-ID "
"or set-group-ID privileges on systems on which I</bin/sh> is bash version 2: "
"as a security measure, bash 2 drops privileges on startup.  (Debian uses a "
"different shell, B<dash>(1), which does not do this when invoked as B<sh>.)"
msgstr ""
"Функция B<system>(), фактически, работает неправильно для программ с "
"привилегиями set-user-ID или set-group-ID в системах, где I</bin/sh> это "
"bash версии 2: для безопасности bash 2 при запуске убирает привилегии (в "
"Debian используется другая оболочка, B<dash>(1), которая не делает этого, "
"если вызывается как B<sh>)."

#. type: Plain text
#: man-pages/man3/system.3:254
msgid ""
"Any user input that is employed as part of I<command> should be I<carefully> "
"sanitized, to ensure that unexpected shell commands or command options are "
"not executed.  Such risks are especially grave when using B<system>()  from "
"a privileged program."
msgstr ""
"Любой введённые пользователем данные, выполняемые как часть I<команды>, "
"должны быть I<внимательно> отцензурированы так, чтобы не выполнились "
"неожидаемые команды оболочки или параметры команды. Эти риски особенно "
"серьезны при использовании B<system>() из привилегированной программы."

#. type: Plain text
#: man-pages/man3/system.3:262
msgid ""
"B<sh>(1), B<execve>(2), B<fork>(2), B<sigaction>(2), B<sigprocmask>(2), "
"B<wait>(2), B<exec>(3), B<signal>(7)"
msgstr ""
"B<sh>(1), B<execve>(2), B<fork>(2), B<sigaction>(2), B<sigprocmask>(2), "
"B<wait>(2), B<exec>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/setnetgrent.3:10
#, no-wrap
msgid "SETNETGRENT"
msgstr "SETNETGRENT"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:14
msgid ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - handle "
"network group entries"
msgstr ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - работа с "
"элементами групп сетей"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:17
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:19
#, no-wrap
msgid "B<int setnetgrent(const char *>I<netgroup>B<);>\n"
msgstr "B<int setnetgrent(const char *>I<netgroup>B<);>\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:21
#, no-wrap
msgid "B<void endnetgrent(void);>\n"
msgstr "B<void endnetgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:23
#, no-wrap
msgid "B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char **>I<domain>B<);>\n"
msgstr "B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char **>I<domain>B<);>\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:26
#, no-wrap
msgid ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
msgstr ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:29
#, no-wrap
msgid ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"
msgstr ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:46
#, no-wrap
msgid ""
"B<setnetgrent>(),\n"
"B<endnetgrent>(),\n"
"B<getnetgrent>(),\n"
"B<getnetgrent_r>(),\n"
"B<innetgr>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<setnetgrent>(),\n"
"B<endnetgrent>(),\n"
"B<getnetgrent>(),\n"
"B<getnetgrent_r>(),\n"
"B<innetgr>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 и старее:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:60
msgid ""
"The I<netgroup> is a SunOS invention.  A netgroup database is a list of "
"string triples (I<hostname>, I<username>, I<domainname>)  or other netgroup "
"names.  Any of the elements in a triple can be empty, which means that "
"anything matches.  The functions described here allow access to the netgroup "
"databases.  The file I</etc/nsswitch.conf> defines what database is searched."
msgstr ""
"Файл I<netgroup> впервые появился в SunOS. База данных netgroup представляет "
"собой список строк с тремя элементами (I<hostname>, I<username>, "
"I<domainname>)  или с другими именами netgroup. Любой из элементов тройки "
"может быть пустым, то есть совпадает с любым значением. Описываемые здесь "
"функции предоставляют доступ к базам данных netgroup. В файле I</etc/"
"nsswitch.conf> задаётся какая база данных будет использована при поиске."

#. type: Plain text
#: man-pages/man3/setnetgrent.3:80
msgid ""
"The B<setnetgrent>()  call defines the netgroup that will be searched by "
"subsequent B<getnetgrent>()  calls.  The B<getnetgrent>()  function "
"retrieves the next netgroup entry, and returns pointers in I<host>, I<user>, "
"I<domain>.  A null pointer means that the corresponding entry matches any "
"string.  The pointers are valid only as long as there is no call to other "
"netgroup-related functions.  To avoid this problem you can use the GNU "
"function B<getnetgrent_r>()  that stores the strings in the supplied "
"buffer.  To free all allocated buffers use B<endnetgrent>()."
msgstr ""
"Вызов B<setnetgrent>() настраивает netgroup, которая будет использована при "
"поиске в последующих вызовах B<getnetgrent>(). Функция B<getnetgrent>() "
"выбирает следующий элемент netgroup и возвращает указатели в I<host>, "
"I<user>, I<domain>. Указатель null означает, что соответствующая запись "
"совпадает с любой строкой. Значения указателей корректны до тех пор, пока не "
"произойдёт других вызовов функций работы с netgroup. Чтобы избежать этой "
"проблемы вы можете использовать функцию GNU B<getnetgrent_r>(), которая "
"хранит строки в переданной ей буфере. Чтобы освободить все выделенные буферы "
"используйте B<endnetgrent>()."

#. type: Plain text
#: man-pages/man3/setnetgrent.3:89
msgid ""
"In most cases you want to check only if the triplet (I<hostname>, "
"I<username>, I<domainname>)  is a member of a netgroup.  The function "
"B<innetgr>()  can be used for this without calling the above three "
"functions.  Again, a null pointer is a wildcard and matches any string.  The "
"function is thread-safe."
msgstr ""
"В большинстве случаев чаще всего проверяется присутствие тройки "
"(I<hostname>, I<username>, I<domainname>)  в netgroup. Для этого можно "
"использовать функцию B<innetgr>() и не вызывать остальные три функции. Не "
"забудьте, что указатель null — универсальный символ и совпадает с любой "
"строкой. Функцию можно безопасно использовать в нитях."

#. type: Plain text
#: man-pages/man3/setnetgrent.3:91
msgid "These functions return 1 on success and 0 for failure."
msgstr "При успешном выполнении эти функции возвращают 1 и 0 при ошибке."

#. type: Plain text
#: man-pages/man3/setnetgrent.3:93
msgid "I</etc/netgroup>"
msgstr "I</etc/netgroup>"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:95
msgid "I</etc/nsswitch.conf>"
msgstr "I</etc/nsswitch.conf>"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:105
#, no-wrap
msgid "B<setnetgrent>(),\n"
msgstr "B<setnetgrent>(),\n"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:107
#, no-wrap
msgid "B<getnetgrent_r>(),\n"
msgstr "B<getnetgrent_r>(),\n"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:109
#, no-wrap
msgid "B<innetgr>()"
msgstr "B<innetgr>()"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:111 man-pages/man3/setnetgrent.3:121
#, no-wrap
msgid "MT-Unsafe race:netgrent\n"
msgstr "MT-Unsafe race:netgrent\n"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:113
#, no-wrap
msgid "locale"
msgstr "locale"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:116
#, no-wrap
msgid "B<endnetgrent>()"
msgstr "B<endnetgrent>()"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:116
#, no-wrap
msgid "MT-Unsafe race:netgrent"
msgstr "MT-Unsafe race:netgrent"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:119
#, no-wrap
msgid "B<getnetgrent>()"
msgstr "B<getnetgrent>()"

#. type: tbl table
#: man-pages/man3/setnetgrent.3:123
#, no-wrap
msgid "race:netgrentbuf locale"
msgstr "race:netgrentbuf locale"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:139
msgid ""
"In the above table, I<netgrent> in I<race:netgrent> signifies that if any of "
"the functions B<setnetgrent>(), B<getnetgrent_r>(), B<innetgr>(), "
"B<getnetgrent>(), or B<endnetgrent>()  are used in parallel in different "
"threads of a program, then data races could occur."
msgstr ""
"В приведённой выше таблице I<netgrent> в I<race:netgrent> означает, что если "
"в нескольких нитях программы одновременно используются функции "
"B<setnetgrent>(), B<getnetgrent_r>(), B<innetgr>(), B<getnetgrent>() или "
"B<endnetgrent>(), то может возникнуть состязательность по данным."

#.  getnetgrent_r() is on Solaris 8 and AIX 5.1, but not the BSDs.
#. type: Plain text
#: man-pages/man3/setnetgrent.3:150
msgid ""
"These functions are not in POSIX.1, but B<setnetgrent>(), B<endnetgrent>(), "
"B<getnetgrent>(), and B<innetgr>()  are available on most UNIX systems.  "
"B<getnetgrent_r>()  is not widely available on other systems."
msgstr ""
"Эти функции отсутствуют в POSIX.1, но B<setnetgrent>(), B<endnetgrent>(), "
"B<getnetgrent>() и B<innetgr>() доступны в большинстве систем UNIX. Функция "
"B<getnetgrent_r>() не так широко распространена в других системах."

#. type: Plain text
#: man-pages/man3/setnetgrent.3:154
msgid "In the BSD implementation, B<setnetgrent>()  returns void."
msgstr "В реализации BSD функция B<setnetgrent>() возвращает void."

#. type: Plain text
#: man-pages/man3/setnetgrent.3:157
msgid "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"
msgstr "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"

#. type: TH
#: man-pages/man3/sem_post.3:26
#, no-wrap
msgid "SEM_POST"
msgstr "SEM_POST"

#. type: Plain text
#: man-pages/man3/sem_post.3:29
msgid "sem_post - unlock a semaphore"
msgstr "sem_post - разблокирует семафор"

#. type: Plain text
#: man-pages/man3/sem_post.3:34
#, no-wrap
msgid "B<int sem_post(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_post(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_post.3:45
msgid ""
"B<sem_post>()  increments (unlocks) the semaphore pointed to by I<sem>.  If "
"the semaphore's value consequently becomes greater than zero, then another "
"process or thread blocked in a B<sem_wait>(3)  call will be woken up and "
"proceed to lock the semaphore."
msgstr ""
"Функция B<sem_post>() увеличивает (разблокирует) семафор, на который "
"указывает I<sem>. Если значение семафора после этого становится больше нуля, "
"то другой процесс или нить заблокированная в вызове B<sem_wait>(3), "
"проснётся и заблокирует семафор."

#. type: Plain text
#: man-pages/man3/sem_post.3:52
msgid ""
"B<sem_post>()  returns 0 on success; on error, the value of the semaphore is "
"left unchanged, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<sem_post>() возвращается 0; при ошибке значение "
"семафора остаётся неизменным, возвращается -1, а в I<errno> содержится код "
"ошибки."

#.  Added in POSIX.1-2008 TC1 (Austin Interpretation 213)
#. type: Plain text
#: man-pages/man3/sem_post.3:61
msgid "The maximum allowable value for a semaphore would be exceeded."
msgstr "Превышено максимально допустимое значение для семафора."

#. type: tbl table
#: man-pages/man3/sem_post.3:71
#, no-wrap
msgid "B<sem_post>()"
msgstr "B<sem_post>()"

#. type: Plain text
#: man-pages/man3/sem_post.3:79
msgid ""
"B<sem_post>()  is async-signal-safe: it may be safely called within a signal "
"handler."
msgstr ""
"Функция B<sem_post>() безопасна для асинхронных сигналов: её можно "
"использовать внутри обработчика сигналов."

#. type: Plain text
#: man-pages/man3/sem_post.3:82
msgid "See B<sem_wait>(3)."
msgstr "Смотрите B<sem_wait>(3)."

#. type: Plain text
#: man-pages/man3/sem_post.3:86
msgid ""
"B<sem_getvalue>(3), B<sem_wait>(3), B<sem_overview>(7), B<signal-safety>(7)"
msgstr ""
"B<sem_getvalue>(3), B<sem_wait>(3), B<sem_overview>(7), B<signal-safety>(7)"

#. type: TH
#: man-pages/man3/sigqueue.3:28
#, no-wrap
msgid "SIGQUEUE"
msgstr "SIGQUEUE"

#. type: Plain text
#: man-pages/man3/sigqueue.3:31
msgid "sigqueue - queue a signal and data to a process"
msgstr "sigqueue - вставляет сигнал и данные в очередь процесса"

#. type: Plain text
#: man-pages/man3/sigqueue.3:35
msgid ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"
msgstr ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"

#. type: Plain text
#: man-pages/man3/sigqueue.3:43
msgid "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: man-pages/man3/sigqueue.3:55
msgid ""
"B<sigqueue>()  sends the signal specified in I<sig> to the process whose PID "
"is given in I<pid>.  The permissions required to send a signal are the same "
"as for B<kill>(2).  As with B<kill>(2), the null signal (0) can be used to "
"check if a process with a given PID exists."
msgstr ""
"Вызов B<sigqueue>() отправляет сигнал, указанный в I<sig>, процессу с "
"идентификатором PID, определённом в I<pid>. Требуются определённые права для "
"отправки сигнала, такие же как для B<kill>(2). Как и в случае с B<kill>(2), "
"пустой сигнал (0) может использоваться для проверки того, что заданный PID "
"вообще существует."

#. type: Plain text
#: man-pages/man3/sigqueue.3:60
msgid ""
"The I<value> argument is used to specify an accompanying item of data "
"(either an integer or a pointer value) to be sent with the signal, and has "
"the following type:"
msgstr ""
"Аргумент I<value> используется для указания сопутствующего элемента данных "
"(либо целого, либо указателя), отправляемых сигналу, и имеет следующий тип:"

#. type: Plain text
#: man-pages/man3/sigqueue.3:67
#, no-wrap
msgid ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"
msgstr ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"

#. type: Plain text
#: man-pages/man3/sigqueue.3:83
msgid ""
"If the receiving process has installed a handler for this signal using the "
"B<SA_SIGINFO> flag to B<sigaction>(2), then it can obtain this data via the "
"I<si_value> field of the I<siginfo_t> structure passed as the second "
"argument to the handler.  Furthermore, the I<si_code> field of that "
"structure will be set to B<SI_QUEUE>."
msgstr ""
"Если у процесса, принимающего сигнал, установлен обработчик посредством "
"B<sigaction>(2) с флагом B<SA_SIGINFO>, то он может получить данные через "
"поле I<si_value> структуры I<siginfo_t>, передаваемой как второй аргумент "
"для обработчика. Кроме этого, значение поля I<si_code> этой структуры будет "
"установлено в B<SI_QUEUE>."

#. type: Plain text
#: man-pages/man3/sigqueue.3:91
msgid ""
"On success, B<sigqueue>()  returns 0, indicating that the signal was "
"successfully queued to the receiving process.  Otherwise, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<sigqueue>() возвращается 0, что означает, что "
"сигнал попал в очередь принимающего процесса. При ошибке возвращается -1 и в "
"I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/sigqueue.3:98
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""
"Достигнуто ограничение на количество сигналов в очереди (подробней об этом "
"смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man3/sigqueue.3:102
msgid "I<sig> was invalid."
msgstr "Значение I<sig> некорректно."

#. type: Plain text
#: man-pages/man3/sigqueue.3:108
msgid ""
"The process does not have permission to send the signal to the receiving "
"process.  For the required permissions, see B<kill>(2)."
msgstr ""
"Процесс не имеет прав для отправки сигнала принимающему процессу. Требуемые "
"права смотрите в B<kill>(2)."

#. type: Plain text
#: man-pages/man3/sigqueue.3:112
msgid "No process has a PID matching I<pid>."
msgstr "Нет процесса с идентификатором PID, соответствующем указанному I<pid>."

#. type: Plain text
#: man-pages/man3/sigqueue.3:117
msgid ""
"B<sigqueue>()  and the underlying B<rt_sigqueueinfo>()  system call first "
"appeared in Linux 2.2."
msgstr ""
"Функция B<sigqueue>() и используемый ей системный вызов B<rt_sigqueueinfo>() "
"впервые появились в Linux 2.2."

#. type: tbl table
#: man-pages/man3/sigqueue.3:127
#, no-wrap
msgid "B<sigqueue>()"
msgstr "B<sigqueue>()"

#. type: Plain text
#: man-pages/man3/sigqueue.3:139
msgid ""
"If this function results in the sending of a signal to the process that "
"invoked it, and that signal was not blocked by the calling thread, and no "
"other threads were willing to handle this signal (either by having it "
"unblocked, or by waiting for it using B<sigwait>(3)), then at least some "
"signal must be delivered to this thread before this function returns."
msgstr ""
"Если этот вызов приводит к отправке сигнала процессу, который его вызвал, и "
"этот сигнал не заблокирован вызывающей нитью, и никакие другие нити не "
"желают обрабатывать сигнал (либо он для них не заблокирован, либо они "
"ожидали его с помощью B<sigwait>(3), то, по меньшей мере, сигнал должен быть "
"доставлен этой нити до завершения этого вызова."

#. type: Plain text
#: man-pages/man3/sigqueue.3:156
msgid ""
"On Linux, B<sigqueue>()  is implemented using the B<rt_sigqueueinfo>(2)  "
"system call.  The system call differs in its third argument, which is the "
"I<siginfo_t> structure that will be supplied to the receiving process's "
"signal handler or returned by the receiving process's B<sigtimedwait>(2)  "
"call.  Inside the glibc B<sigqueue>()  wrapper, this argument, I<uinfo>, is "
"initialized as follows:"
msgstr ""
"В Linux B<sigqueue>() реализована через системный вызов "
"B<rt_sigqueueinfo>(2). Данный системный вызов отличается от неё третьим "
"аргументом: структура I<siginfo_t>, которая будет предоставляться "
"обработчику сигнала принимающего процесса или возвращаться вызовом "
"B<sigtimedwait>(2) из принимающего процесса. В обёрточной функции glibc "
"B<sigqueue>() этот аргумент, I<uinfo>, инициализируется следующим образом:"

#. type: Plain text
#: man-pages/man3/sigqueue.3:164
#, no-wrap
msgid ""
"uinfo.si_signo = sig;      /* Argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* Argument supplied to sigqueue() */\n"
msgstr ""
"uinfo.si_signo = sig;      /* аргумент, передаваемый в sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* ID процесса отправителя */\n"
"uinfo.si_uid = getuid();   /* реальный UID отправителя */\n"
"uinfo.si_value = val;      /* аргумент, передаваемый в sigqueue() */\n"

#. type: Plain text
#: man-pages/man3/sigqueue.3:173
msgid ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/strcmp.3:32
#, no-wrap
msgid "STRCMP"
msgstr "STRCMP"

#. type: Plain text
#: man-pages/man3/strcmp.3:35
msgid "strcmp, strncmp - compare two strings"
msgstr "strcmp, strncmp - сравнивает две строки"

#. type: Plain text
#: man-pages/man3/strcmp.3:40
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcmp.3:42
#, no-wrap
msgid "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcmp.3:58
msgid ""
"The B<strcmp>()  function compares the two strings I<s1> and I<s2>.  The "
"locale is not taken into account (for a locale-aware comparison, see "
"B<strcoll>(3)).  It returns an integer less than, equal to, or greater than "
"zero if I<s1> is found, respectively, to be less than, to match, or be "
"greater than I<s2>."
msgstr ""
"Функция B<strcmp>() сравнивает строки I<s1> и I<s2>. При этом локаль не "
"учитывается (для её учёта используйте функцию B<strcoll>(3)). Она возвращает "
"целое число, которое меньше, больше нуля или равно ему, если выяснится, что "
"I<s1> меньше, равна или больше I<s2> соответственно."

#. type: Plain text
#: man-pages/man3/strcmp.3:68
msgid ""
"The B<strncmp>()  function is similar, except it compares only the first (at "
"most)  I<n> bytes of I<s1> and I<s2>."
msgstr ""
"Функция B<strncmp>() работает аналогичным образом, но сравниваются только "
"первые (не более) I<n> байт строки I<s1> и I<s2>."

#. type: Plain text
#: man-pages/man3/strcmp.3:81
msgid ""
"The B<strcmp>()  and B<strncmp>()  functions return an integer less than, "
"equal to, or greater than zero if I<s1> (or the first I<n> bytes thereof) is "
"found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""
"Функции B<strcmp>() и B<strncmp>() возвращают целое число, которое меньше, "
"больше нуля или равно ему, если строка I<s1> (или её первые I<n> байтов) "
"соответственно меньше, больше или равна I<s2>."

#. type: tbl table
#: man-pages/man3/strcmp.3:92
#, no-wrap
msgid ""
"B<strcmp>(),\n"
"B<strncmp>()"
msgstr ""
"B<strcmp>(),\n"
"B<strncmp>()"

#. type: Plain text
#: man-pages/man3/strcmp.3:105
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"

#. type: TH
#: man-pages/man3/strptime.3:31
#, no-wrap
msgid "STRPTIME"
msgstr "STRPTIME"

#. type: Plain text
#: man-pages/man3/strptime.3:34
msgid ""
"strptime - convert a string representation of time to a time tm structure"
msgstr ""
"strptime - преобразование строкового представления времени в структуру "
"времени tm"

#. type: Plain text
#: man-pages/man3/strptime.3:36
msgid "B<#define _XOPEN_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _XOPEN_SOURCE> /* См. feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man3/strptime.3:41
msgid ""
"B<char *strptime(const char *>I<s>B<, const char *>I<format>B<,> B<struct tm "
"*>I<tm>B<);>"
msgstr ""
"B<char *strptime(const char *>I<s>B<, const char *>I<format>B<,> B<struct tm "
"*>I<tm>B<);>"

#. type: Plain text
#: man-pages/man3/strptime.3:54
msgid ""
"The B<strptime>()  function is the converse of B<strftime>(3); it converts "
"the character string pointed to by I<s> to values which are stored in the "
"\"broken-down time\" structure pointed to by I<tm>, using the format "
"specified by I<format>."
msgstr ""
"Функция B<strptime>() является конвертирующей функцией, дополняющей "
"B<strftime>(3): она преобразует символьную строку, на которую указывает "
"I<s>, сохраняя значения в структуре I<tm> (описывает время в виде компонент, "
"broken-down time) согласно формата, заданного в I<format>."

#. type: Plain text
#: man-pages/man3/strptime.3:60
msgid ""
"The broken-down time structure I<tm> is defined in I<E<lt>time.hE<gt>> as "
"follows:"
msgstr ""
"структура времени I<tm> в виде компонент определена в I<E<lt>time.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/strptime.3:74
#, no-wrap
msgid ""
"struct tm {\n"
"    int tm_sec;    /* Seconds (0-60) */\n"
"    int tm_min;    /* Minutes (0-59) */\n"
"    int tm_hour;   /* Hours (0-23) */\n"
"    int tm_mday;   /* Day of the month (1-31) */\n"
"    int tm_mon;    /* Month (0-11) */\n"
"    int tm_year;   /* Year - 1900 */\n"
"    int tm_wday;   /* Day of the week (0-6, Sunday = 0) */\n"
"    int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */\n"
"    int tm_isdst;  /* Daylight saving time */\n"
"};\n"
msgstr ""
"struct tm {\n"
"    int tm_sec;    /* секунды (0-60) */\n"
"    int tm_min;    /* минуты (0-59) */\n"
"    int tm_hour;   /* часы (0-23) */\n"
"    int tm_mday;   /* день месяца (1-31) */\n"
"    int tm_mon;    /* месяц (0-11) */\n"
"    int tm_year;   /* год - 1900 */\n"
"    int tm_wday;   /* день недели (0-6, воскресенье = 0) */\n"
"    int tm_yday;   /* день года (0-365, 1 января = 0) */\n"
"    int tm_isdst;  /* летнее время */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/strptime.3:81
msgid "For more details on the I<tm> structure, see B<ctime>(3)."
msgstr "Дополнительную информацию о структуре I<tm> смотрите в B<ctime>(3)."

#. type: Plain text
#: man-pages/man3/strptime.3:99
msgid ""
"The I<format> argument is a character string that consists of field "
"descriptors and text characters, reminiscent of B<scanf>(3).  Each field "
"descriptor consists of a B<%> character followed by another character that "
"specifies the replacement for the field descriptor.  All other characters in "
"the I<format> string must have a matching character in the input string, "
"except for whitespace, which matches zero or more whitespace characters in "
"the input string.  There should be white\\%space or other alphanumeric "
"characters between any two field descriptors."
msgstr ""
"Аргумент I<format> является символьной строкой, состоящей из описателей поля "
"и текстовых символов, напоминающей B<scanf>(3). Каждый описатель поля "
"состоит из символа B<%> с последующим символом, который указывает на замену "
"описателя поля. Остальные символы в строке I<format> должны совпадать со "
"строкой входных данных. Исключениями являются пробелы, которые совпадают с "
"любым количеством пробелов в строке входных данных. Между любыми двумя "
"описателями полей должно быть пустое место (пробелы) или другие алфавитно-"
"цифровые символы."

#. type: Plain text
#: man-pages/man3/strptime.3:108
msgid ""
"The B<strptime>()  function processes the input string from left to right.  "
"Each of the three possible input elements (whitespace, literal, or format) "
"are handled one after the other.  If the input cannot be matched to the "
"format string, the function stops.  The remainder of the format and input "
"strings are not processed."
msgstr ""
"Функция B<strptime>() обрабатывает строку ввода слева направо. Каждый из "
"трёх возможных входных элементов (пробел, буква или форматирующие символы) "
"обрабатываются один за другим. Если ввод не соответствует строке "
"форматирования, то функция прекращает работу. Оставшиеся части формата и "
"данных не обрабатываются."

#. type: Plain text
#: man-pages/man3/strptime.3:114
msgid ""
"The supported input field descriptors are listed below.  In case a text "
"string (such as the name of a day of the week or a month name)  is to be "
"matched, the comparison is case insensitive.  In case a number is to be "
"matched, leading zeros are permitted but not required."
msgstr ""
"Ниже приведён список поддерживаемых описателей полей. В случае поиска "
"текстовой строки (например, день недели или месяц), сравнение происходит вне "
"зависимости от регистра символов. В случае с цифрами допустимы начальные "
"нули."

#. type: TP
#: man-pages/man3/strptime.3:114
#, no-wrap
msgid "B<%%>"
msgstr "B<%%>"

#. type: Plain text
#: man-pages/man3/strptime.3:119
msgid "The B<%> character."
msgstr "Символ B<%>."

#. type: TP
#: man-pages/man3/strptime.3:119
#, no-wrap
msgid "B<%a> or B<%A>"
msgstr "B<%a> или B<%A>"

#. type: Plain text
#: man-pages/man3/strptime.3:123
msgid ""
"The name of the day of the week according to the current locale, in "
"abbreviated form or the full name."
msgstr ""
"Название дня недели согласно текущей локали, в форме аббревиатуры или "
"полного имени."

#. type: TP
#: man-pages/man3/strptime.3:123
#, no-wrap
msgid "B<%b> or B<%B> or B<%h>"
msgstr "B<%b>, B<%B> или B<%h>"

#. type: Plain text
#: man-pages/man3/strptime.3:127
msgid ""
"The month name according to the current locale, in abbreviated form or the "
"full name."
msgstr ""
"Название месяца согласно текущей локали, в форме аббревиатуры или полного "
"имени."

#. type: TP
#: man-pages/man3/strptime.3:127
#, no-wrap
msgid "B<%c>"
msgstr "B<%c>"

#. type: Plain text
#: man-pages/man3/strptime.3:130
msgid "The date and time representation for the current locale."
msgstr "Дата и время, отображенные согласно текущей локали."

#. type: TP
#: man-pages/man3/strptime.3:130
#, no-wrap
msgid "B<%C>"
msgstr "B<%C>"

#. type: Plain text
#: man-pages/man3/strptime.3:133
msgid "The century number (0\\(en99)."
msgstr "Номер столетия (0\\(en99)."

#. type: TP
#: man-pages/man3/strptime.3:133
#, no-wrap
msgid "B<%d> or B<%e>"
msgstr "B<%d> или B<%e>"

#. type: Plain text
#: man-pages/man3/strptime.3:136
msgid "The day of month (1\\(en31)."
msgstr "День месяца (1\\(en31)."

#. type: TP
#: man-pages/man3/strptime.3:136
#, no-wrap
msgid "B<%D>"
msgstr "B<%D>"

#. type: Plain text
#: man-pages/man3/strptime.3:146
msgid ""
"Equivalent to B<%m/%d/%y>.  (This is the American style date, very confusing "
"to non-Americans, especially since B<%d/%m/%y> is widely used in Europe.  "
"The ISO 8601 standard format is B<%Y-%m-%d>.)"
msgstr ""
"Эквивалент B<%m/%d/%y> (американское представление даты, которое может "
"запутать не американцев, особенно с учетом того, что B<%d/%m/%y> широко "
"используется в Европе. Форматом ISO 8601 является B<%Y-%m-%d>)."

#. type: TP
#: man-pages/man3/strptime.3:146
#, no-wrap
msgid "B<%H>"
msgstr "B<%H>"

#. type: Plain text
#: man-pages/man3/strptime.3:149
msgid "The hour (0\\(en23)."
msgstr "Час (0\\(en23)."

#. type: TP
#: man-pages/man3/strptime.3:149
#, no-wrap
msgid "B<%I>"
msgstr "B<%I>"

#. type: Plain text
#: man-pages/man3/strptime.3:152
msgid "The hour on a 12-hour clock (1\\(en12)."
msgstr "Час на 2-часовом циферблате (1\\(en12)."

#. type: TP
#: man-pages/man3/strptime.3:152
#, no-wrap
msgid "B<%j>"
msgstr "B<%j>"

#. type: Plain text
#: man-pages/man3/strptime.3:155
msgid "The day number in the year (1\\(en366)."
msgstr "Номер дня в году (1\\(en366)."

#. type: TP
#: man-pages/man3/strptime.3:155
#, no-wrap
msgid "B<%m>"
msgstr "B<%m>"

#. type: Plain text
#: man-pages/man3/strptime.3:158
msgid "The month number (1\\(en12)."
msgstr "Номер месяца (1\\(en12)."

#. type: TP
#: man-pages/man3/strptime.3:158
#, no-wrap
msgid "B<%M>"
msgstr "B<%M>"

#. type: Plain text
#: man-pages/man3/strptime.3:161
msgid "The minute (0\\(en59)."
msgstr "Минута (0\\(en59)."

#. type: TP
#: man-pages/man3/strptime.3:161
#, no-wrap
msgid "B<%n>"
msgstr "B<%n>"

#. type: Plain text
#: man-pages/man3/strptime.3:164 man-pages/man3/strptime.3:190
msgid "Arbitrary whitespace."
msgstr "Обязательный пробел."

#. type: TP
#: man-pages/man3/strptime.3:164
#, no-wrap
msgid "B<%p>"
msgstr "B<%p>"

#. type: Plain text
#: man-pages/man3/strptime.3:168
msgid "The locale's equivalent of AM or PM.  (Note: there may be none.)"
msgstr "Локализованный эквивалент AM или PM (примечание: его может не быть)."

#. type: TP
#: man-pages/man3/strptime.3:168
#, no-wrap
msgid "B<%r>"
msgstr "B<%r>"

#. type: Plain text
#: man-pages/man3/strptime.3:179
msgid ""
"The 12-hour clock time (using the locale's AM or PM).  In the POSIX locale "
"equivalent to B<%I:%M:%S %p>.  If I<t_fmt_ampm> is empty in the B<LC_TIME> "
"part of the current locale, then the behavior is undefined."
msgstr ""
"Время по 12-ти часовым часам (используя AM или PM локали). В локали POSIX "
"это эквивалентно B<%I:%M:%S %p>. Если I<t_fmt_ampm> пусто в поле B<LC_TIME> "
"текущей локали, то поведение не определено."

#. type: TP
#: man-pages/man3/strptime.3:179
#, no-wrap
msgid "B<%R>"
msgstr "B<%R>"

#. type: Plain text
#: man-pages/man3/strptime.3:183
msgid "Equivalent to B<%H:%M>."
msgstr "Эквивалент B<%H:%M>."

#. type: TP
#: man-pages/man3/strptime.3:183
#, no-wrap
msgid "B<%S>"
msgstr "B<%S>"

#. type: Plain text
#: man-pages/man3/strptime.3:187
msgid ""
"The second (0\\(en60; 60 may occur for leap seconds; earlier also 61 was "
"allowed)."
msgstr ""
"Секунда (0\\(en60; 60 может появляться для високосных секунд;  ранее также "
"допускалось появление 61)."

#. type: TP
#: man-pages/man3/strptime.3:187
#, no-wrap
msgid "B<%t>"
msgstr "B<%t>"

#. type: TP
#: man-pages/man3/strptime.3:190
#, no-wrap
msgid "B<%T>"
msgstr "B<%T>"

#. type: Plain text
#: man-pages/man3/strptime.3:194
msgid "Equivalent to B<%H:%M:%S>."
msgstr "Эквивалент B<%H:%M:%S>."

#. type: TP
#: man-pages/man3/strptime.3:194
#, no-wrap
msgid "B<%U>"
msgstr "B<%U>"

#. type: Plain text
#: man-pages/man3/strptime.3:198
msgid ""
"The week number with Sunday the first day of the week (0\\(en53).  The first "
"Sunday of January is the first day of week 1."
msgstr ""
"Номер недели в году, начинающейся с воскресенья ((0\\(en53). Первое "
"воскресенье января является первым днем недели 1."

#. type: TP
#: man-pages/man3/strptime.3:198
#, no-wrap
msgid "B<%w>"
msgstr "B<%w>"

#. type: Plain text
#: man-pages/man3/strptime.3:201
msgid "The ordinal number of the day of the week (0\\(en6), with Sunday = 0."
msgstr "Порядковый номер дня недели (0\\(en6), воскресенье = 0."

#. type: TP
#: man-pages/man3/strptime.3:201
#, no-wrap
msgid "B<%W>"
msgstr "B<%W>"

#. type: Plain text
#: man-pages/man3/strptime.3:205
msgid ""
"The week number with Monday the first day of the week (0\\(en53).  The first "
"Monday of January is the first day of week 1."
msgstr ""
"Номер недели в году, начинающейся с понедельника (0\\(en53). Первый "
"понедельник января является первым днем недели 1."

#. type: TP
#: man-pages/man3/strptime.3:205
#, no-wrap
msgid "B<%x>"
msgstr "B<%x>"

#. type: Plain text
#: man-pages/man3/strptime.3:208
msgid "The date, using the locale's date format."
msgstr "Дата в локализованном формате представления."

#. type: TP
#: man-pages/man3/strptime.3:208
#, no-wrap
msgid "B<%X>"
msgstr "B<%X>"

#. type: Plain text
#: man-pages/man3/strptime.3:211
msgid "The time, using the locale's time format."
msgstr "Время в локализованном формате представления."

#. type: TP
#: man-pages/man3/strptime.3:211
#, no-wrap
msgid "B<%y>"
msgstr "B<%y>"

#. type: Plain text
#: man-pages/man3/strptime.3:217
msgid ""
"The year within century (0\\(en99).  When a century is not otherwise "
"specified, values in the range 69\\(en99 refer to years in the twentieth "
"century (1969\\(en1999); values in the range 00\\(en68 refer to years in the "
"twenty-first century (2000\\(en2068)."
msgstr ""
"Год века (0\\(en99). Если век никак не указывается, то года 69\\(en99 "
"относятся к двадцатому веку (1969\\(en1999), а года в диапазоне 00\\(en68 "
"относятся к двадцать первому веку (2000\\(en2068)."

#. type: TP
#: man-pages/man3/strptime.3:217
#, no-wrap
msgid "B<%Y>"
msgstr "B<%Y>"

#. type: Plain text
#: man-pages/man3/strptime.3:220
msgid "The year, including century (for example, 1991)."
msgstr "Год, включая столетие (например, 1991)."

#. type: Plain text
#: man-pages/man3/strptime.3:226
msgid ""
"Some field descriptors can be modified by the E or O modifier characters to "
"indicate that an alternative format or specification should be used.  If the "
"alternative format or specification does not exist in the current locale, "
"the unmodified field descriptor is used."
msgstr ""
"Некоторые описатели полей могут быть изменены модификаторами E или O, "
"указывающими, что нужно использовать альтернативный формат или спецификацию. "
"Если альтернативный формат или спецификация не существует в текущей локали, "
"то используются неизменённые описатели полей."

#. type: Plain text
#: man-pages/man3/strptime.3:229
msgid ""
"The E modifier specifies that the input string may contain alternative "
"locale-dependent versions of the date and time representation:"
msgstr ""
"Модификатор E указывает на то, что строка ввода может содержать "
"альтернативные локале-зависимые версии представления даты и времени:"

#. type: TP
#: man-pages/man3/strptime.3:229
#, no-wrap
msgid "B<%Ec>"
msgstr "B<%Ec>"

#. type: Plain text
#: man-pages/man3/strptime.3:232
msgid "The locale's alternative date and time representation."
msgstr "Альтернативный формат представления даты и времени в текущей локали."

#. type: TP
#: man-pages/man3/strptime.3:232
#, no-wrap
msgid "B<%EC>"
msgstr "B<%EC>"

#. type: Plain text
#: man-pages/man3/strptime.3:235
msgid ""
"The name of the base year (period) in the locale's alternative "
"representation."
msgstr ""
"Альтернативный формат представления базового года в зависимости от текущей "
"локали."

#. type: TP
#: man-pages/man3/strptime.3:235
#, no-wrap
msgid "B<%Ex>"
msgstr "B<%Ex>"

#. type: Plain text
#: man-pages/man3/strptime.3:238
msgid "The locale's alternative date representation."
msgstr ""
"Альтернативный формат представления даты в зависимости от текущей локали."

#. type: TP
#: man-pages/man3/strptime.3:238
#, no-wrap
msgid "B<%EX>"
msgstr "B<%EX>"

#. type: Plain text
#: man-pages/man3/strptime.3:241
msgid "The locale's alternative time representation."
msgstr ""
"Альтернативный формат представления времени в зависимости от текущей локали."

#. type: TP
#: man-pages/man3/strptime.3:241
#, no-wrap
msgid "B<%Ey>"
msgstr "B<%Ey>"

#. type: Plain text
#: man-pages/man3/strptime.3:246
msgid ""
"The offset from B<%EC> (year only) in the locale's alternative "
"representation."
msgstr ""
"Альтернативный формат представления смещения от B<%EC> в зависимости от "
"текущей локали."

#. type: TP
#: man-pages/man3/strptime.3:246
#, no-wrap
msgid "B<%EY>"
msgstr "B<%EY>"

#. type: Plain text
#: man-pages/man3/strptime.3:249
msgid "The full alternative year representation."
msgstr "Альтернативный формат полного представления года."

#. type: Plain text
#: man-pages/man3/strptime.3:252
msgid ""
"The O modifier specifies that the numerical input may be in an alternative "
"locale-dependent format:"
msgstr ""
"Модификатор O указывает, что числовой ввод может производиться в "
"альтернативном формате в зависимости от текущей локали:"

#. type: TP
#: man-pages/man3/strptime.3:252
#, no-wrap
msgid "B<%Od> or B<%Oe>"
msgstr "B<%Od> или B<%Oe>"

#. type: Plain text
#: man-pages/man3/strptime.3:256
msgid ""
"The day of the month using the locale's alternative numeric symbols; leading "
"zeros are permitted but not required."
msgstr ""
"Число месяца с использованием альтернативных чисел локали; предшествующие "
"нули можно ставить, но это необязательно."

#. type: TP
#: man-pages/man3/strptime.3:256
#, no-wrap
msgid "B<%OH>"
msgstr "B<%OH>"

#. type: Plain text
#: man-pages/man3/strptime.3:259
msgid ""
"The hour (24-hour clock) using the locale's alternative numeric symbols."
msgstr "Часы (0-24) с использованием альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:259
#, no-wrap
msgid "B<%OI>"
msgstr "B<%OI>"

#. type: Plain text
#: man-pages/man3/strptime.3:262
msgid ""
"The hour (12-hour clock) using the locale's alternative numeric symbols."
msgstr "Часы (1-12) с использованием альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:262
#, no-wrap
msgid "B<%Om>"
msgstr "B<%Om>"

#. type: Plain text
#: man-pages/man3/strptime.3:265
msgid "The month using the locale's alternative numeric symbols."
msgstr "Месяц с использованием альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:265
#, no-wrap
msgid "B<%OM>"
msgstr "B<%OM>"

#. type: Plain text
#: man-pages/man3/strptime.3:268
msgid "The minutes using the locale's alternative numeric symbols."
msgstr "Минуты с использованием альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:268
#, no-wrap
msgid "B<%OS>"
msgstr "B<%OS>"

#. type: Plain text
#: man-pages/man3/strptime.3:271
msgid "The seconds using the locale's alternative numeric symbols."
msgstr "Секунды с использованием альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:271
#, no-wrap
msgid "B<%OU>"
msgstr "B<%OU>"

#. type: Plain text
#: man-pages/man3/strptime.3:275
msgid ""
"The week number of the year (Sunday as the first day of the week)  using the "
"locale's alternative numeric symbols."
msgstr ""
"Номер недели в году (воскресенье — первый день недели) с использованием "
"альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:275
#, no-wrap
msgid "B<%Ow>"
msgstr "B<%Ow>"

#. type: Plain text
#: man-pages/man3/strptime.3:279
#, no-wrap
msgid ""
"The ordinal number of the day of the week (Sunday=0),\n"
" using the locale's alternative numeric symbols.\n"
msgstr ""
"Обычный номер дня недели (воскресенье — нулевой день недели)\n"
"с использованием альтернативных чисел локали.\n"

#. type: TP
#: man-pages/man3/strptime.3:279
#, no-wrap
msgid "B<%OW>"
msgstr "B<%OW>"

#. type: Plain text
#: man-pages/man3/strptime.3:283
msgid ""
"The week number of the year (Monday as the first day of the week)  using the "
"locale's alternative numeric symbols."
msgstr ""
"Номер недели в году (понедельник — первый день недели) с использованием "
"альтернативных чисел локали."

#. type: TP
#: man-pages/man3/strptime.3:283
#, no-wrap
msgid "B<%Oy>"
msgstr "B<%Oy>"

#. type: Plain text
#: man-pages/man3/strptime.3:288
msgid ""
"The year (offset from B<%C>)  using the locale's alternative numeric symbols."
msgstr "Год (смещение от B<%C>) с использованием альтернативных чисел локали."

#. type: Plain text
#: man-pages/man3/strptime.3:301
msgid ""
"The return value of the function is a pointer to the first character not "
"processed in this function call.  In case the input string contains more "
"characters than required by the format string, the return value points right "
"after the last consumed input character.  In case the whole input string is "
"consumed, the return value points to the null byte at the end of the "
"string.  If B<strptime>()  fails to match all of the format string and "
"therefore an error occurred, the function returns NULL."
msgstr ""
"Возвращаемым значением функции является указатель на первый символ, не "
"обработанный вызовом. В случае, когда строка ввода содержит больше символов, "
"чем требуется для строки формата, возвращаемое значение будет указателем на "
"место за последним обработанным символом. В случае, когда вся строка ввода "
"обработана, возвращается указатель на завершающий символ строки null. Если "
"B<strptime>() не может найти все соответствия строке формата, то возникает "
"ошибка и возвращается значение NULL."

#. type: tbl table
#: man-pages/man3/strptime.3:311
#, no-wrap
msgid "B<strptime>()"
msgstr "B<strptime>()"

#. type: tbl table
#: man-pages/man3/strptime.3:311
#, no-wrap
msgid "MT-Safe env locale"
msgstr "MT-Safe env locale"

#. type: Plain text
#: man-pages/man3/strptime.3:315
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2."
msgstr "POSIX.1-2001, POSIX.1-2008, SUSv2."

#.  .PP
#.  This function is available since libc 4.6.8.
#.  Linux libc4 and libc5 includes define the prototype unconditionally;
#.  glibc2 includes provide a prototype only when
#.  .B _XOPEN_SOURCE
#.  or
#.  .B _GNU_SOURCE
#.  are defined.
#.  .PP
#.  Before libc 5.4.13 whitespace
#.  (and the \(aqn\(aq and \(aqt\(aq specifications) was not handled,
#.  no \(aqE\(aq and \(aqO\(aq locale modifier characters were accepted,
#.  and the \(aqC\(aq specification was a synonym for the \(aqc\(aq specification.
#. type: Plain text
#: man-pages/man3/strptime.3:344
msgid ""
"In principle, this function does not initialize I<tm> but stores only the "
"values specified.  This means that I<tm> should be initialized before the "
"call.  Details differ a bit between different UNIX systems.  The glibc "
"implementation does not touch those fields which are not explicitly "
"specified, except that it recomputes the I<tm_wday> and I<tm_yday> field if "
"any of the year, month, or day elements changed."
msgstr ""
"В принципе, эта функция не инициализирует I<tm>, а только сохраняет "
"указанные значения. Это означает, что I<tm> должна быть инициализирована до "
"этого вызова. Существует небольшая разница между системами UNIX. Функция из "
"glibc не не изменяет поля, которые не описаны явно, за исключением "
"пересчитываемых полей I<tm_wday> и I<tm_yday>, если изменился один из "
"элементов: день, месяц или год."

#.  in the 20th century by libc4 and libc5.
#.  It is taken to be a year
#.  In libc4 and libc5 the code for %I is broken (fixed in glibc;
#.  %OI was fixed in glibc 2.2.4).
#. type: Plain text
#: man-pages/man3/strptime.3:353
msgid ""
"The \\(aqy\\(aq (year in century) specification is taken to specify a year "
"in the range 1950\\(en2049 by glibc 2.0.  It is taken to be a year in "
"1969\\(en2068 since glibc 2.1."
msgstr ""
"В glibc 2.0 спецификатор «y» (год столетия) указывает на год в диапазоне "
"1950\\(en2049. Начиная с glibc 2.1 этот диапазон равен 1969\\(en2068."

#. type: Plain text
#: man-pages/man3/strptime.3:362
msgid ""
"For reasons of symmetry, glibc tries to support for B<strptime>()  the same "
"format characters as for B<strftime>(3).  (In most cases, the corresponding "
"fields are parsed, but no field in I<tm> is changed.)  This leads to"
msgstr ""
"Для симметрии glibc пытается поддерживать в B<strptime>() тот же формат "
"символов что и в B<strftime>(3) (в большинстве случаев, соответствующие поля "
"анализируются, но поле в I<tm> не изменяется). В результате:"

#. type: TP
#: man-pages/man3/strptime.3:362
#, no-wrap
msgid "B<%F>"
msgstr "B<%F>"

#. type: Plain text
#: man-pages/man3/strptime.3:367
msgid "Equivalent to B<%Y-%m-%d>, the ISO 8601 date format."
msgstr "Эквивалентно B<%Y-%m-%d> в формате ISO 8601."

#. type: TP
#: man-pages/man3/strptime.3:367
#, no-wrap
msgid "B<%g>"
msgstr "B<%g>"

#. type: Plain text
#: man-pages/man3/strptime.3:371
msgid ""
"The year corresponding to the ISO week number, but without the century "
"(0\\(en99)."
msgstr ""
"Год, соответствующий номеру недели по ISO, но без номера века (0\\(en99)."

#. type: TP
#: man-pages/man3/strptime.3:371
#, no-wrap
msgid "B<%G>"
msgstr "B<%G>"

#. type: Plain text
#: man-pages/man3/strptime.3:375
msgid "The year corresponding to the ISO week number.  (For example, 1991.)"
msgstr "Год, соответствующий номеру недели по ISO (например, 1991)."

#. type: TP
#: man-pages/man3/strptime.3:375
#, no-wrap
msgid "B<%u>"
msgstr "B<%u>"

#. type: Plain text
#: man-pages/man3/strptime.3:378
msgid "The day of the week as a decimal number (1\\(en7, where Monday = 1)."
msgstr "День недели в цифровом формате (1\\(en7, где понедельник — 1)."

#. type: TP
#: man-pages/man3/strptime.3:378
#, no-wrap
msgid "B<%V>"
msgstr "B<%V>"

#. type: Plain text
#: man-pages/man3/strptime.3:385
msgid ""
"The ISO 8601:1988 week number as a decimal number (1\\(en53).  If the week "
"(starting on Monday) containing 1 January has four or more days in the new "
"year, then it is considered week 1.  Otherwise, it is the last week of the "
"previous year, and the next week is week 1."
msgstr ""
"Номер недели в виде числа (1\\(en53) по стандарту ISO 8601:1988 Если неделя "
"(начинающаяся с понедельника) содержит 1 января и имеет 4 или более дней в "
"новом году, то это первая неделя. Иначе это последняя неделя предыдущего "
"года, а следующая неделя первая."

#. type: TP
#: man-pages/man3/strptime.3:385
#, no-wrap
msgid "B<%z>"
msgstr "B<%z>"

#. type: Plain text
#: man-pages/man3/strptime.3:388
msgid "An RFC-822/ISO 8601 standard timezone specification."
msgstr "Часовой пояс согласно спецификациям стандарта RFC-822/ISO 8601."

#. type: TP
#: man-pages/man3/strptime.3:388
#, no-wrap
msgid "B<%Z>"
msgstr "B<%Z>"

#. type: Plain text
#: man-pages/man3/strptime.3:391
msgid "The timezone name."
msgstr "Название часового пояса."

#. type: Plain text
#: man-pages/man3/strptime.3:407
msgid ""
"Similarly, because of GNU extensions to B<strftime>(3), B<%k> is accepted as "
"a synonym for B<%H>, and B<%l> should be accepted as a synonym for B<%I>, "
"and B<%P> is accepted as a synonym for B<%p>.  Finally"
msgstr ""
"Аналогично, учитывая расширения GNU для B<strftime>(3), B<%k> принято "
"считать синонимом B<%H>, а B<%l> — синонимом для B<%I>, и B<%P> синонимом B<"
"%p>. И"

#. type: TP
#: man-pages/man3/strptime.3:407
#, no-wrap
msgid "B<%s>"
msgstr "B<%s>"

#. type: Plain text
#: man-pages/man3/strptime.3:411
msgid ""
"The number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  "
"Leap seconds are not counted unless leap second support is available."
msgstr ""
"Количество секунд с начала эпохи, с 1970-01-01 00:00:00 +0000 (UTC). Если "
"нет поддержки для високосных секунд, то они не учитываются."

#. type: Plain text
#: man-pages/man3/strptime.3:414
msgid ""
"The glibc implementation does not require whitespace between two field "
"descriptors."
msgstr ""
"В реализации glibc не требуется пустого места (пробелов) между двумя "
"описателями полей."

#. type: Plain text
#: man-pages/man3/strptime.3:419
msgid ""
"The following example demonstrates the use of B<strptime>()  and "
"B<strftime>(3)."
msgstr ""
"Следующий пример демонстрирует использование B<strptime>() и B<strftime>(3)."

#. type: Plain text
#: man-pages/man3/strptime.3:426
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strptime.3:432
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct tm tm;\n"
"    char buf[255];\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct tm tm;\n"
"    char buf[255];\n"

#. type: Plain text
#: man-pages/man3/strptime.3:439
#, no-wrap
msgid ""
"    memset(&tm, 0, sizeof(struct tm));\n"
"    strptime(\"2001-11-12 18:31:01\", \"%Y-%m-%d %H:%M:%S\", &tm);\n"
"    strftime(buf, sizeof(buf), \"%d %b %Y %H:%M\", &tm);\n"
"    puts(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    memset(&tm, 0, sizeof(struct tm));\n"
"    strptime(\"2001-11-12 18:31:01\", \"%Y-%m-%d %H:%M:%S\", &tm);\n"
"    strftime(buf, sizeof(buf), \"%d %b %Y %H:%M\", &tm);\n"
"    puts(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/strptime.3:445
msgid "B<time>(2), B<getdate>(3), B<scanf>(3), B<setlocale>(3), B<strftime>(3)"
msgstr ""
"B<time>(2), B<getdate>(3), B<scanf>(3), B<setlocale>(3), B<strftime>(3)"

#. type: TH
#: man-pages/man3/sigset.3:26
#, no-wrap
msgid "SIGSET"
msgstr "SIGSET"

#. type: Plain text
#: man-pages/man3/sigset.3:29
msgid "sigset, sighold, sigrelse, sigignore - System V signal API"
msgstr ""
"sigset, sighold, sigrelse, sigignore - программный интерфейс сигналов System "
"V"

#. type: Plain text
#: man-pages/man3/sigset.3:35
msgid "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"
msgstr "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"

#. type: Plain text
#: man-pages/man3/sigset.3:37
msgid "B<int sighold(int >I<sig>B<);>"
msgstr "B<int sighold(int >I<sig>B<);>"

#. type: Plain text
#: man-pages/man3/sigset.3:39
msgid "B<int sigrelse(int >I<sig>B<);>"
msgstr "B<int sigrelse(int >I<sig>B<);>"

#. type: Plain text
#: man-pages/man3/sigset.3:41
msgid "B<int sigignore(int >I<sig>B<);>"
msgstr "B<int sigignore(int >I<sig>B<);>"

#. type: Plain text
#: man-pages/man3/sigset.3:52
msgid "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"
msgstr "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"

#. type: Plain text
#: man-pages/man3/sigset.3:65
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical System V signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""
"Данные функции предоставляются glibc для совместимости с программами, в "
"которых используются старый программный интерфейс сигналов System V. Данный "
"программный интерфейс устарел: в новых приложениях нужно использовать "
"программный интерфейс сигналов POSIX (B<sigaction>(2), B<sigprocmask>(2) и т."
"п.)."

#. type: Plain text
#: man-pages/man3/sigset.3:74
msgid ""
"The B<sigset>()  function modifies the disposition of the signal I<sig>.  "
"The I<disp> argument can be the address of a signal handler function, or one "
"of the following constants:"
msgstr ""
"Функция B<sigset>() изменяет обработку сигнала I<sig>. В аргументе I<disp> "
"может быть указан адрес функции обработчика сигнала или одна из следующих "
"констант:"

#. type: TP
#: man-pages/man3/sigset.3:74
#, no-wrap
msgid "B<SIG_DFL>"
msgstr "B<SIG_DFL>"

#. type: Plain text
#: man-pages/man3/sigset.3:79
msgid "Reset the disposition of I<sig> to the default."
msgstr "Сбросить обработку I<sig> в значение по умолчанию."

#. type: TP
#: man-pages/man3/sigset.3:79
#, no-wrap
msgid "B<SIG_IGN>"
msgstr "B<SIG_IGN>"

#. type: Plain text
#: man-pages/man3/sigset.3:83
msgid "Ignore I<sig>."
msgstr "Игнорировать I<sig>."

#. type: TP
#: man-pages/man3/sigset.3:83
#, no-wrap
msgid "B<SIG_HOLD>"
msgstr "B<SIG_HOLD>"

#. type: Plain text
#: man-pages/man3/sigset.3:90
msgid ""
"Add I<sig> to the process's signal mask, but leave the disposition of I<sig> "
"unchanged."
msgstr ""
"Добавить I<sig> в маску сигналов процесса, но оставить обработку I<sig> "
"неизменной."

#. type: Plain text
#: man-pages/man3/sigset.3:96
msgid ""
"If I<disp> specifies the address of a signal handler, then I<sig> is added "
"to the process's signal mask during execution of the handler."
msgstr ""
"Если в I<disp> задан адрес обработчика сигналов, то при его выполнении "
"I<sig> добавляется в маску сигналов процесса."

#. type: Plain text
#: man-pages/man3/sigset.3:104
msgid ""
"If I<disp> was specified as a value other than B<SIG_HOLD>, then I<sig> is "
"removed from the process's signal mask."
msgstr ""
"Если в I<disp> было указано значение отличное от B<SIG_HOLD>, то I<sig> "
"удаляется из маски сигналов процесса."

#. type: Plain text
#: man-pages/man3/sigset.3:110
msgid "The dispositions for B<SIGKILL> and B<SIGSTOP> cannot be changed."
msgstr "Обработку сигналов B<SIGKILL> и B<SIGSTOP> невозможно изменить."

#. type: Plain text
#: man-pages/man3/sigset.3:116
msgid ""
"The B<sighold>()  function adds I<sig> to the calling process's signal mask."
msgstr ""
"Функция B<sighold>() добавляет I<sig> в маску сигналов вызвавшего процесса."

#. type: Plain text
#: man-pages/man3/sigset.3:122
msgid ""
"The B<sigrelse>()  function removes I<sig> from the calling process's signal "
"mask."
msgstr ""
"Функция B<sigrelse>() удаляет I<sig> из маски сигналов вызвавшего процесса."

#. type: Plain text
#: man-pages/man3/sigset.3:129
msgid ""
"The B<sigignore>()  function sets the disposition of I<sig> to B<SIG_IGN>."
msgstr ""
"Функция B<sigignore>() устанавливает обработку I<sig> равной B<SIG_IGN>."

#. type: Plain text
#: man-pages/man3/sigset.3:145
msgid ""
"On success, B<sigset>()  returns B<SIG_HOLD> if I<sig> was blocked before "
"the call, or the signal's previous disposition if it was not blocked before "
"the call.  On error, B<sigset>()  returns -1, with I<errno> set to indicate "
"the error.  (But see BUGS below.)"
msgstr ""
"При успешном выполнении B<sigset>() возвращает B<SIG_HOLD>, если I<sig> был "
"заблокирован до вызова, или предыдущий обработчик сигнала, если блокировки "
"не было. При ошибке B<sigset>() возвращает -1, а I<errno> записывает номер "
"ошибки (но смотрите раздел ДЕФЕКТЫ далее)."

#. type: Plain text
#: man-pages/man3/sigset.3:154
msgid ""
"The B<sighold>(), B<sigrelse>(), and B<sigignore>()  functions return 0 on "
"success; on error, these functions return -1 and set I<errno> to indicate "
"the error."
msgstr ""
"При успешном выполнении функции B<sighold>(), B<sigrelse>() и B<sigignore>() "
"возвращают 0; при ошибке возвращается -1, а в I<errno> — номер ошибки."

#. type: Plain text
#: man-pages/man3/sigset.3:161
msgid ""
"For B<sigset>()  see the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr ""
"Для функции B<sigset>() смотрите раздел ОШИБКИ в B<sigaction>(2) и "
"B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man3/sigset.3:168
msgid ""
"For B<sighold>()  and B<sigrelse>()  see the ERRORS under B<sigprocmask>(2)."
msgstr ""
"Для функции B<sighold>() и B<sigrelse>() смотрите раздел ОШИБКИ в "
"B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man3/sigset.3:173
msgid "For B<sigignore>(), see the errors under B<sigaction>(2)."
msgstr "Для функции B<sigignore>() смотрите раздел ОШИБКИ в B<sigaction>(2)."

#. type: tbl table
#: man-pages/man3/sigset.3:184
#, no-wrap
msgid ""
"B<sigset>(),\n"
"B<sighold>(),\n"
msgstr ""
"B<sigset>(),\n"
"B<sighold>(),\n"

#. type: tbl table
#: man-pages/man3/sigset.3:187
#, no-wrap
msgid ""
"B<sigrelse>(),\n"
"B<sigignore>()"
msgstr ""
"B<sigrelse>(),\n"
"B<sigignore>()"

#. type: Plain text
#: man-pages/man3/sigset.3:206
msgid ""
"SVr4, POSIX.1-2001, POSIX.1-2008.  These functions are obsolete: do not use "
"them in new programs.  POSIX.1-2008 marks B<sighold>(), B<sigignore>(), "
"B<sigpause>(3), B<sigrelse>(), and B<sigset>()  as obsolete, recommending "
"the use of B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), and "
"B<sigsuspend>(2)  instead."
msgstr ""
"Существует в SVr4, POSIX.1-2001, POSIX.1-2008. Эти функции устарели: не "
"используйте их в новых программах. В POSIX.1-2008 функции B<sighold>(), "
"B<sigignore>(), B<sigpause>(3), B<sigrelse>() и B<sigset>() помечены как "
"устаревшие, вместо них рекомендуется использовать B<sigaction>(2), "
"B<sigprocmask>(2), B<pthread_sigmask>(3) и B<sigsuspend>(2)."

#. type: Plain text
#: man-pages/man3/sigset.3:208
msgid "These functions appeared in glibc version 2.1."
msgstr "Данные функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/sigset.3:214
msgid ""
"The I<sighandler_t> type is a GNU extension; it is used on this page only to "
"make the B<sigset>()  prototype more easily readable."
msgstr ""
"Тип I<sighandler_t> является расширением GNU; в этой странице он "
"используется только для более понятного описания прототипа B<sigset>()."

#. type: Plain text
#: man-pages/man3/sigset.3:222
msgid ""
"The B<sigset>()  function provides reliable signal handling semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to 0)."
msgstr ""
"Функция B<sigset>() предоставляет семантику надёжной обработки сигналов (как "
"при вызове B<sigaction>(2) с значением I<sa_mask> равным 0)."

#. type: Plain text
#: man-pages/man3/sigset.3:240
msgid ""
"On System V, the B<signal>()  function provides unreliable semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to I<SA_RESETHAND | "
"SA_NODEFER>).  On BSD, B<signal>()  provides reliable semantics.  "
"POSIX.1-2001 leaves these aspects of B<signal>()  unspecified.  See "
"B<signal>(2)  for further details."
msgstr ""
"В System V, функция B<signal>() предоставляет ненадёжную семантику (как при "
"вызове B<sigaction>(2) со значением I<sa_mask> равным I<SA_RESETHAND | "
"SA_NODEFER>). В BSD, B<signal>() предоставляет надёжную семантику. В "
"POSIX.1-2001 эти аспекты B<signal>() не определены. Подробности смотрите в "
"B<signal>(2)."

#. type: Plain text
#: man-pages/man3/sigset.3:248
msgid ""
"In order to wait for a signal, BSD and System V both provided a function "
"named B<sigpause>(3), but this function has a different argument on the two "
"systems.  See B<sigpause>(3)  for details."
msgstr ""
"Для ожидания сигналов в BSD и System V предоставляется функция "
"B<sigpause>(3), но в других системах она описана с другим аргументом. "
"Подробности смотрите в B<sigpause>(3)."

#. type: Plain text
#: man-pages/man3/sigset.3:257
msgid ""
"In versions of glibc before 2.2, B<sigset>()  did not unblock I<sig> if "
"I<disp> was specified as a value other than B<SIG_HOLD>."
msgstr ""
"В версиях glibc до 2.2, B<sigset>() не блокирует I<sig>, если в I<disp> было "
"указано значение, отличное от B<SIG_HOLD>."

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1951
#. type: Plain text
#: man-pages/man3/sigset.3:282
msgid ""
"In versions of glibc before 2.5, B<sigset>()  does not correctly return the "
"previous disposition of the signal in two cases.  First, if I<disp> is "
"specified as B<SIG_HOLD>, then a successful B<sigset>()  always returns "
"B<SIG_HOLD>.  Instead, it should return the previous disposition of the "
"signal (unless the signal was blocked, in which case B<SIG_HOLD> should be "
"returned).  Second, if the signal is currently blocked, then the return "
"value of a successful B<sigset>()  should be B<SIG_HOLD>.  Instead, the "
"previous disposition of the signal is returned.  These problems have been "
"fixed since glibc 2.5."
msgstr ""
"В версиях glibc до 2.5, B<sigset>() в двух случаях некорректно возвращает "
"предыдущий обработчик сигнала. Во-первых, если I<disp> равно B<SIG_HOLD>, то "
"при успешном выполнении B<sigset>() всегда возвращается B<SIG_HOLD>. Вместо "
"этого должен возвращаться предыдущий обработчик сигнала (если сигнал не "
"заблокирован, в этом случае должно возвращаться B<SIG_HOLD>). Во-вторых, "
"если сигнал в данный момент заблокирован, то  возвращаемое значение "
"успешного выполнения B<sigset>() должно быть равно B<SIG_HOLD>. Вместо этого "
"возвращается предыдущий обработчик сигнала. Эти проблемы были устранены "
"начиная с glibc 2.5."

#. type: Plain text
#: man-pages/man3/sigset.3:291
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/stdio.3:39
#, no-wrap
msgid "STDIO"
msgstr "STDIO"

#. type: Plain text
#: man-pages/man3/stdio.3:42
msgid "stdio - standard input/output library functions"
msgstr "stdio - библиотека функций стандартного ввода-вывода"

#. type: Plain text
#: man-pages/man3/stdio.3:44
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/stdio.3:46
msgid "B<FILE *>I<stdin>B<;>"
msgstr "B<FILE *>I<stdin>B<;>"

#. type: Plain text
#: man-pages/man3/stdio.3:48
msgid "B<FILE *>I<stdout>B<;>"
msgstr "B<FILE *>I<stdout>B<;>"

#. type: Plain text
#: man-pages/man3/stdio.3:50
msgid "B<FILE *>I<stderr>B<;>"
msgstr "B<FILE *>I<stderr>B<;>"

#. type: Plain text
#: man-pages/man3/stdio.3:57
msgid ""
"The standard I/O library provides a simple and efficient buffered stream I/O "
"interface.  Input and output is mapped into logical data streams and the "
"physical I/O characteristics are concealed.  The functions and macros are "
"listed below; more information is available from the individual man pages."
msgstr ""
"Библиотеки стандартного ввода-вывода предоставляют простой и эффективный "
"интерфейс буферизируемого потока ввода-вывода. Ввод и вывод представляется "
"логическим потоком данных, а физические характеристики ввода-вывода "
"скрываются. Далее приводится список функций и макросов; более подробная "
"информация находится в соответствующих страницах."

#. type: Plain text
#: man-pages/man3/stdio.3:80
msgid ""
"A stream is associated with an external file (which may be a physical "
"device) by I<opening> a file, which may involve creating a new file.  "
"Creating an existing file causes its former contents to be discarded.  If a "
"file can support positioning requests (such as a disk file, as opposed to a "
"terminal), then a I<file position indicator> associated with the stream is "
"positioned at the start of the file (byte zero), unless the file is opened "
"with append mode.  If append mode is used, it is unspecified whether the "
"position indicator will be placed at the start or the end of the file.  The "
"position indicator is maintained by subsequent reads, writes and positioning "
"requests.  All input occurs as if the characters were read by successive "
"calls to the B<fgetc>(3)  function; all output takes place as if all "
"characters were written by successive calls to the B<fputc>(3)  function."
msgstr ""
"Поток соотносится с внешним файлом (который также может быть физическим "
"устройством) при I<открытии> файла. Такое открытие может вызвать создание "
"нового файла. Создание существующего файла вызовет потерю его содержимого. "
"Если для файла поддерживаются запросы позиционирования (например для файла "
"на диске, а не терминал), то I<индикатор позиции в файле>, соответствующий "
"потоку, устанавливается в начало файла (нулевой байт), если только файл не "
"открыт в режиме добавления. Если используется режим добавления, то не "
"определено, будет ли индикатор позиции в файле будет указывать на конец "
"файла. Индикатор позиции изменяется при последующих запросах чтения, записи "
"и изменения индикатора. Все операции ввода осуществляются так, как если бы "
"все символы последовательно считывались вызовом функции B<fgetc>(3); а вывод "
"осуществляется, как если бы все символы последовательно записывались вызовом "
"функции B<fputc>(3)."

#. type: Plain text
#: man-pages/man3/stdio.3:90
msgid ""
"A file is disassociated from a stream by I<closing> the file.  Output "
"streams are flushed (any unwritten buffer contents are transferred to the "
"host environment) before the stream is disassociated from the file.  The "
"value of a pointer to a I<FILE> object is indeterminate after a file is "
"closed (garbage)."
msgstr ""
"Соотношение потока с файлом прекращается при I<закрытии> файла. Перед "
"прекращением потоки вывода очищаются (flushed) (содержимое незаписанного "
"буфера передаётся в системное окружение). Значение указателя на объект "
"I<FILE> после закрытия файла становится неопределённым (мусорным)."

#. type: Plain text
#: man-pages/man3/stdio.3:103
msgid ""
"A file may be subsequently reopened, by the same or another program "
"execution, and its contents reclaimed or modified (if it can be repositioned "
"at the start).  If the main function returns to its original caller, or the "
"B<exit>(3)  function is called, all open files are closed (hence all output "
"streams are flushed) before program termination.  Other methods of program "
"termination, such as B<abort>(3)  do not bother about closing files properly."
msgstr ""
"Впоследствии файл может быть открыт ещё раз той же самой или другой "
"программой, а его содержание может быть восстановлено или изменено (если "
"можно перейти в его начало). Если основная функция завершает работу и "
"возвращает значения своему родителю или если вызывается функция B<exit>(3), "
"то перед закрытием программы закрываются все открытые файлы (и, "
"следовательно, очищаются все потоки вывода). Другие методы закрытия "
"программ, например, B<abort>(3), не всегда приводят к корректному закрытию "
"файлов."

#. type: Plain text
#: man-pages/man3/stdio.3:120
msgid ""
"At program startup, three text streams are predefined and need not be opened "
"explicitly: I<standard input> (for reading conventional input), I<standard "
"output> (for writing conventional output), and I<standard error> (for "
"writing diagnostic output).  These streams are abbreviated I<stdin>, "
"I<stdout>, and I<stderr>.  When opened, the standard error stream is not "
"fully buffered; the standard input and output streams are fully buffered if "
"and only if the streams do not refer to an interactive device."
msgstr ""
"При запуске программы предопределяются три текстовых потока, которые не "
"следует открывать явно: I<стандартный ввод> (standard input) (для чтения "
"условного ввода), I<стандартный вывод> (standard output) (для записи "
"условного вывода) и I<стандартный поток ошибок> (standard error) (для вывода "
"диагностики). Сокращённые названия потоков: I<stdin>, I<stdout> и I<stderr>. "
"При открытии, стандартный поток ошибок буферизируется не полностью; "
"стандартные потоки ввода и вывода полностью буферизируются только при "
"условии, что они не ссылаются на какое-либо интерактивное устройство."

#. type: Plain text
#: man-pages/man3/stdio.3:130
msgid ""
"Output streams that refer to terminal devices are always line buffered by "
"default; pending output to such streams is written automatically whenever an "
"input stream that refers to a terminal device is read.  In cases where a "
"large amount of computation is done after printing part of a line on an "
"output terminal, it is necessary to B<fflush>(3)  the standard output before "
"going off and computing so that the output will appear."
msgstr ""
"Потоки вывода, ссылающиеся на устройства терминала, по умолчанию "
"буферизируются построчно; ожидающие в таких потоках данные записываются "
"автоматически всякий раз при чтении из потока ввода, ссылающегося на "
"терминал. В случаях, когда после вывода на терминал части строки объём "
"производимых вычислений велик, необходимо выполнять B<fflush>(3), чтобы "
"появилась часть строки до вычислений."

#. type: Plain text
#: man-pages/man3/stdio.3:142
msgid ""
"The I<stdio> library is a part of the library B<libc> and routines are "
"automatically loaded as needed by B<cc>(1).  The SYNOPSIS sections of the "
"following manual pages indicate which include files are to be used, what the "
"compiler declaration for the function looks like and which external "
"variables are of interest."
msgstr ""
"Библиотека I<stdio> является частью библиотеки B<libc>, а функции "
"автоматически загружаются B<cc>(1) по мере надобности. В разделе СИНТАКСИС "
"справочных страниц указано какие файлы заголовков необходимо использовать, "
"как выглядят объявления функций и какие внешние переменные представляют "
"интерес для работы."

#.  Not on Linux: .BR fropen ,
#.  Not on Linux: .BR fwopen ,
#. type: Plain text
#: man-pages/man3/stdio.3:182
msgid ""
"The following are defined as macros; these names may not be reused without "
"first removing their current definitions with B<#undef>: B<BUFSIZ>, B<EOF>, "
"B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, B<L_ctermid>, B<L_tmpnam>, "
"B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, B<TMP_MAX>, B<clearerr>, "
"B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar>, "
"B<stderr>, B<stdin>, B<stdout>.  Function versions of the macro functions "
"B<feof>, B<ferror>, B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, "
"and B<putchar> exist and will be used if the macros definitions are "
"explicitly removed."
msgstr ""
"В списке далее перечислены макросы; эти имена не могут быть использованы "
"повторно без предварительного удаления их определений с помощью B<#undef>: "
"B<BUFSIZ>, B<EOF>, B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, "
"B<L_ctermid>, B<L_tmpnam>, B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, "
"B<TMP_MAX>, B<clearerr>, B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, "
"B<putc>, B<putchar>, B<stderr>, B<stdin>, B<stdout>. Для B<feof>, B<ferror>, "
"B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, и B<putchar> "
"существуют версии в виде функций, которые используются если определения "
"макросов были удалены явно."

#. type: SS
#: man-pages/man3/stdio.3:182
#, no-wrap
msgid "List of functions"
msgstr "Список функций"

#. type: tbl table
#: man-pages/man3/stdio.3:187
#, no-wrap
msgid "Description"
msgstr "описание"

#. type: tbl table
#: man-pages/man3/stdio.3:188
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: man-pages/man3/stdio.3:189
#, no-wrap
msgid "B<clearerr>(3)"
msgstr "B<clearerr>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:189 man-pages/man3/stdio.3:192
#: man-pages/man3/stdio.3:193
#, no-wrap
msgid "check and reset stream status"
msgstr "проверяет и сбрасывает состояние потока"

#. type: tbl table
#: man-pages/man3/stdio.3:190
#, no-wrap
msgid "B<fclose>(3)"
msgstr "B<fclose>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:190
#, no-wrap
msgid "close a stream"
msgstr "закрывает поток"

#. type: tbl table
#: man-pages/man3/stdio.3:191
#, no-wrap
msgid "B<fdopen>(3)"
msgstr "B<fdopen>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:191 man-pages/man3/stdio.3:199
#: man-pages/man3/stdio.3:205
#, no-wrap
msgid "stream open functions"
msgstr "функции для открытия потоков"

#. type: tbl table
#: man-pages/man3/stdio.3:192
#, no-wrap
msgid "B<feof>(3)"
msgstr "B<feof>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:193
#, no-wrap
msgid "B<ferror>(3)"
msgstr "B<ferror>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:194
#, no-wrap
msgid "B<fflush>(3)"
msgstr "B<fflush>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:194 man-pages/man3/stdio.3:201
#, no-wrap
msgid "flush a stream"
msgstr "сбрасывает поток"

#. type: tbl table
#: man-pages/man3/stdio.3:195
#, no-wrap
msgid "B<fgetc>(3)"
msgstr "B<fgetc>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:195 man-pages/man3/stdio.3:211
#: man-pages/man3/stdio.3:212 man-pages/man3/stdio.3:214
#, no-wrap
msgid "get next character or word from input stream"
msgstr "считывает следующий символ или слово из входного потока"

#. type: tbl table
#: man-pages/man3/stdio.3:196
#, no-wrap
msgid "B<fgetpos>(3)"
msgstr "B<fgetpos>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:196 man-pages/man3/stdio.3:207
#: man-pages/man3/stdio.3:208 man-pages/man3/stdio.3:209
#: man-pages/man3/stdio.3:223
#, no-wrap
msgid "reposition a stream"
msgstr "смена указания в потоке"

#. type: tbl table
#: man-pages/man3/stdio.3:197
#, no-wrap
msgid "B<fgets>(3)"
msgstr "B<fgets>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:197 man-pages/man3/stdio.3:213
#, no-wrap
msgid "get a line from a stream"
msgstr "считывает строку из потока"

#. type: tbl table
#: man-pages/man3/stdio.3:198
#, no-wrap
msgid "B<fileno>(3)"
msgstr "B<fileno>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:198
#, no-wrap
msgid "return the integer descriptor of the argument stream"
msgstr "возвращает целочисленный дескриптор аргумента потока"

#. type: tbl table
#: man-pages/man3/stdio.3:199
#, no-wrap
msgid "B<fopen>(3)"
msgstr "B<fopen>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:200
#, no-wrap
msgid "B<fprintf>(3)"
msgstr "B<fprintf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:200 man-pages/man3/stdio.3:217
#: man-pages/man3/stdio.3:229 man-pages/man3/stdio.3:238
#: man-pages/man3/stdio.3:240 man-pages/man3/stdio.3:242
#, no-wrap
msgid "formatted output conversion"
msgstr "вывод по формату"

#. type: tbl table
#: man-pages/man3/stdio.3:201
#, no-wrap
msgid "B<fpurge>(3)"
msgstr "B<fpurge>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:202
#, no-wrap
msgid "B<fputc>(3)"
msgstr "B<fputc>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:202 man-pages/man3/stdio.3:218
#: man-pages/man3/stdio.3:219 man-pages/man3/stdio.3:221
#, no-wrap
msgid "output a character or word to a stream"
msgstr "выводит символ или слово в поток"

#. type: tbl table
#: man-pages/man3/stdio.3:203
#, no-wrap
msgid "B<fputs>(3)"
msgstr "B<fputs>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:203 man-pages/man3/stdio.3:220
#, no-wrap
msgid "output a line to a stream"
msgstr "выводит строку в поток"

#. type: tbl table
#: man-pages/man3/stdio.3:204
#, no-wrap
msgid "B<fread>(3)"
msgstr "B<fread>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:204 man-pages/man3/stdio.3:210
#, no-wrap
msgid "binary stream input/output"
msgstr "считывает двоичные данные потока ввода-вывода"

#. type: tbl table
#: man-pages/man3/stdio.3:205
#, no-wrap
msgid "B<freopen>(3)"
msgstr "B<freopen>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:206
#, no-wrap
msgid "B<fscanf>(3)"
msgstr "B<fscanf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:206 man-pages/man3/stdio.3:224
#: man-pages/man3/stdio.3:230 man-pages/man3/stdio.3:239
#: man-pages/man3/stdio.3:241 man-pages/man3/stdio.3:243
#, no-wrap
msgid "input format conversion"
msgstr "форматирует входные данные"

#. type: tbl table
#: man-pages/man3/stdio.3:207
#, no-wrap
msgid "B<fseek>(3)"
msgstr "B<fseek>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:208
#, no-wrap
msgid "B<fsetpos>(3)"
msgstr "B<fsetpos>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:209
#, no-wrap
msgid "B<ftell>(3)"
msgstr "B<ftell>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:210
#, no-wrap
msgid "B<fwrite>(3)"
msgstr "B<fwrite>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:211
#, no-wrap
msgid "B<getc>(3)"
msgstr "B<getc>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:212
#, no-wrap
msgid "B<getchar>(3)"
msgstr "B<getchar>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:213
#, no-wrap
msgid "B<gets>(3)"
msgstr "B<gets>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:214
#, no-wrap
msgid "B<getw>(3)"
msgstr "B<getw>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:215
#, no-wrap
msgid "B<mktemp>(3)"
msgstr "B<mktemp>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:215
#, no-wrap
msgid "make temporary filename (unique)"
msgstr "создаёт имя временного файла (уникальное)"

#. type: tbl table
#: man-pages/man3/stdio.3:216
#, no-wrap
msgid "B<perror>(3)"
msgstr "B<perror>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:216 man-pages/man3/stdio.3:231
#: man-pages/man3/stdio.3:232 man-pages/man3/stdio.3:233
#, no-wrap
msgid "system error messages"
msgstr "сообщения о системных ошибках"

#. type: tbl table
#: man-pages/man3/stdio.3:217
#, no-wrap
msgid "B<printf>(3)"
msgstr "B<printf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:218
#, no-wrap
msgid "B<putc>(3)"
msgstr "B<putc>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:219
#, no-wrap
msgid "B<putchar>(3)"
msgstr "B<putchar>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:220
#, no-wrap
msgid "B<puts>(3)"
msgstr "B<puts>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:221
#, no-wrap
msgid "B<putw>(3)"
msgstr "B<putw>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:222
#, no-wrap
msgid "B<remove>(3)"
msgstr "B<remove>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:222
#, no-wrap
msgid "remove directory entry"
msgstr "удаляет запись из каталога"

#. type: tbl table
#: man-pages/man3/stdio.3:223
#, no-wrap
msgid "B<rewind>(3)"
msgstr "B<rewind>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:224
#, no-wrap
msgid "B<scanf>(3)"
msgstr "B<scanf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:225
#, no-wrap
msgid "B<setbuf>(3)"
msgstr "B<setbuf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:225 man-pages/man3/stdio.3:226
#: man-pages/man3/stdio.3:227 man-pages/man3/stdio.3:228
#, no-wrap
msgid "stream buffering operations"
msgstr "операции буферизации потока"

#. type: tbl table
#: man-pages/man3/stdio.3:226
#, no-wrap
msgid "B<setbuffer>(3)"
msgstr "B<setbuffer>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:227
#, no-wrap
msgid "B<setlinebuf>(3)"
msgstr "B<setlinebuf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:228
#, no-wrap
msgid "B<setvbuf>(3)"
msgstr "B<setvbuf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:229
#, no-wrap
msgid "B<sprintf>(3)"
msgstr "B<sprintf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:230
#, no-wrap
msgid "B<sscanf>(3)"
msgstr "B<sscanf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:231
#, no-wrap
msgid "B<strerror>(3)"
msgstr "B<strerror>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:232
#, no-wrap
msgid "B<sys_errlist>(3)"
msgstr "B<sys_errlist>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:233
#, no-wrap
msgid "B<sys_nerr>(3)"
msgstr "B<sys_nerr>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:234
#, no-wrap
msgid "B<tempnam>(3)"
msgstr "B<tempnam>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:234 man-pages/man3/stdio.3:235
#: man-pages/man3/stdio.3:236
#, no-wrap
msgid "temporary file routines"
msgstr "функции для работы с временным файлом"

#. type: tbl table
#: man-pages/man3/stdio.3:235
#, no-wrap
msgid "B<tmpfile>(3)"
msgstr "B<tmpfile>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:236
#, no-wrap
msgid "B<tmpnam>(3)"
msgstr "B<tmpnam>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:237
#, no-wrap
msgid "B<ungetc>(3)"
msgstr "B<ungetc>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:237
#, no-wrap
msgid "un-get character from input stream"
msgstr "возвращает символ во входной поток"

#. type: tbl table
#: man-pages/man3/stdio.3:238
#, no-wrap
msgid "B<vfprintf>(3)"
msgstr "B<vfprintf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:239
#, no-wrap
msgid "B<vfscanf>(3)"
msgstr "B<vfscanf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:240
#, no-wrap
msgid "B<vprintf>(3)"
msgstr "B<vprintf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:241
#, no-wrap
msgid "B<vscanf>(3)"
msgstr "B<vscanf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:242
#, no-wrap
msgid "B<vsprintf>(3)"
msgstr "B<vsprintf>(3)"

#. type: tbl table
#: man-pages/man3/stdio.3:243
#, no-wrap
msgid "B<vsscanf>(3)"
msgstr "B<vsscanf>(3)"

#. type: Plain text
#: man-pages/man3/stdio.3:249
msgid "The I<stdio> library conforms to C89."
msgstr "Библиотека I<stdio> соответствует C89."

#. type: Plain text
#: man-pages/man3/stdio.3:255
msgid ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"
msgstr ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/strverscmp.3:26
#, no-wrap
msgid "STRVERSCMP"
msgstr "STRVERSCMP"

#. type: Plain text
#: man-pages/man3/strverscmp.3:29
msgid "strverscmp - compare two version strings"
msgstr "strverscmp - сравнение двух строк версий"

#. type: Plain text
#: man-pages/man3/strverscmp.3:35
#, no-wrap
msgid "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#.  classical solution: "rename jan jan0 jan?"
#. type: Plain text
#: man-pages/man3/strverscmp.3:52
msgid ""
"Often one has files I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  and it "
"feels wrong when B<ls>(1)  orders them I<jan1>, I<jan10>, ..., I<jan2>, ..., "
"I<jan9>.  In order to rectify this, GNU introduced the I<-v> option to "
"B<ls>(1), which is implemented using B<versionsort>(3), which again uses "
"B<strverscmp>()."
msgstr ""
"Часто имеются файлы I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, … и при выводе "
"списка командой B<ls>(1) они выводятся как I<jan1>, I<jan10>, ..., I<jan2>, "
"…, I<jan9>, что несколько не то, что хотелось бы. Чтобы исправить это, в GNU "
"добавлен аргумент командной строки I<-v> команды B<ls>(1), который "
"реализован через функцию B<versionsort>(3), которая, в свою очередь, "
"использует функцию B<strverscmp>()."

#. type: Plain text
#: man-pages/man3/strverscmp.3:63
msgid ""
"Thus, the task of B<strverscmp>()  is to compare two strings and find the "
"\"right\" order, while B<strcmp>(3)  finds only the lexicographic order.  "
"This function does not use the locale category B<LC_COLLATE>, so is meant "
"mostly for situations where the strings are expected to be in ASCII."
msgstr ""
"Таким образом, задача функции B<strverscmp>()  в том, чтобы сравнить две "
"строки и найти «правильную» очередность, в то время как B<strcmp>(3) "
"обнаруживает только лексикографический порядок. Эта функция не использует "
"категорию локали B<LC_COLLATE>, что, в общем случае, означает, что строки "
"должны быть в кодировке ASCII."

#. type: Plain text
#: man-pages/man3/strverscmp.3:81
msgid ""
"What this function does is the following.  If both strings are equal, return "
"0.  Otherwise, find the position between two bytes with the property that "
"before it both strings are equal, while directly after it there is a "
"difference.  Find the largest consecutive digit strings containing (or "
"starting at, or ending at) this position.  If one or both of these is empty, "
"then return what B<strcmp>(3)  would have returned (numerical ordering of "
"byte values).  Otherwise, compare both digit strings numerically, where "
"digit strings with one or more leading zeros are interpreted as if they have "
"a decimal point in front (so that in particular digit strings with more "
"leading zeros come before digit strings with fewer leading zeros).  Thus, "
"the ordering is I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, I<1>, I<9>, I<10>."
msgstr ""
"Функция делает следующее. Если обе строки равны, то возвращается 0. Иначе "
"находится позиция между двумя байтами в обеих строках, до которой строки "
"равны, а после которой не равны. Далее находятся наибольшие последовательные "
"строки цифр, содержащие (или начинающиеся, или заканчивающиеся) эту позицию. "
"Если такие последовательности не найдены в обеих строках, то возвращается "
"такой же результат, какой вернула бы функция B<strcmp>(3) (численная "
"сортировка по значениям байтов). В противном случае обе строки цифр "
"сравниваются численно. При этом строки, начинающиеся с одного или более "
"нулей рассматриваются таким образом, как если бы перед ними стояла "
"десятичная запятая (то есть строки цифр начинающиеся с большего количества "
"нулей, будут идти перед строками с меньшим количеством). Пример: I<000>, "
"I<00>, I<01>, I<010>, I<09>, I<0>, I<1>, I<9>, I<10>."

#. type: Plain text
#: man-pages/man3/strverscmp.3:90
msgid ""
"The B<strverscmp>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be earlier than, equal "
"to, or later than I<s2>."
msgstr ""
"Функция B<strverscmp>() возвращает целое число меньшее, равное или большее "
"нуля, если, соответственно, I<s1> должно идти раньше, на том же месте, или "
"позже I<s2>."

#. type: tbl table
#: man-pages/man3/strverscmp.3:100
#, no-wrap
msgid "B<strverscmp>()"
msgstr "B<strverscmp>()"

#. type: Plain text
#: man-pages/man3/strverscmp.3:114
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/strverscmp.3:121
msgid ""
"The program below can be used to demonstrate the behavior of "
"B<strverscmp>().  It uses B<strverscmp>()  to compare the two strings given "
"as its command-line arguments.  An example of its use is the following:"
msgstr ""
"Показанная далее программа демонстрирует поведение B<strverscmp>(). Функция "
"B<strverscmp>() используется для сравнения двух строк, заданных в аргументах "
"командной строки. Пример работы:"

#. type: Plain text
#: man-pages/man3/strverscmp.3:126
#, no-wrap
msgid ""
"$ B<./a.out jan1 jan10>\n"
"jan1 E<lt> jan10\n"
msgstr ""
"$ B<./a.out jan1 jan10>\n"
"jan1 E<lt> jan10\n"

#. type: Plain text
#: man-pages/man3/strverscmp.3:135
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strverscmp.3:140
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int res;\n"

#. type: Plain text
#: man-pages/man3/strverscmp.3:145
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>string1E<gt> E<lt>string2E<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>string1E<gt> E<lt>string2E<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strverscmp.3:147
#, no-wrap
msgid "    res = strverscmp(argv[1], argv[2]);\n"
msgstr "    res = strverscmp(argv[1], argv[2]);\n"

#. type: Plain text
#: man-pages/man3/strverscmp.3:150
#, no-wrap
msgid ""
"    printf(\"%s %s %s\\en\", argv[1],\n"
"            (res E<lt> 0) ? \"E<lt>\" : (res == 0) ? \"==\" : \"E<gt>\", argv[2]);\n"
msgstr ""
"    printf(\"%s %s %s\\en\", argv[1],\n"
"            (res E<lt> 0) ? \"E<lt>\" : (res == 0) ? \"==\" : \"E<gt>\", argv[2]);\n"

#. type: Plain text
#: man-pages/man3/strverscmp.3:158
msgid "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"
msgstr "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"

#. type: TH
#: man-pages/man3/scalbln.3:27
#, no-wrap
msgid "SCALBLN"
msgstr "SCALBLN"

#. type: Plain text
#: man-pages/man3/scalbln.3:31
msgid ""
"scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl - multiply floating-"
"point number by integral power of radix"
msgstr ""
"scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl - умножает число с "
"плавающей запятой на основание в степени целого числа"

#. type: Plain text
#: man-pages/man3/scalbln.3:35
msgid "B<double scalbln(double >I<x>B<, long int >I<exp>B<);>"
msgstr "B<double scalbln(double >I<x>B<, long int >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalbln.3:37
msgid "B<float scalblnf(float >I<x>B<, long int >I<exp>B<);>"
msgstr "B<float scalblnf(float >I<x>B<, long int >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalbln.3:39
msgid "B<long double scalblnl(long double >I<x>B<, long int >I<exp>B<);>"
msgstr "B<long double scalblnl(long double >I<x>B<, long int >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalbln.3:41
msgid "B<double scalbn(double >I<x>B<, int >I<exp>B<);>"
msgstr "B<double scalbn(double >I<x>B<, int >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalbln.3:43
msgid "B<float scalbnf(float >I<x>B<, int >I<exp>B<);>"
msgstr "B<float scalbnf(float >I<x>B<, int >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalbln.3:45
msgid "B<long double scalbnl(long double >I<x>B<, int >I<exp>B<);>"
msgstr "B<long double scalbnl(long double >I<x>B<, int >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalbln.3:57
msgid "B<scalbln>(), B<scalblnf>(), B<scalblnl>():"
msgstr "B<scalbln>(), B<scalblnf>(), B<scalblnl>():"

#. type: Plain text
#: man-pages/man3/scalbln.3:60
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"

#. type: Plain text
#: man-pages/man3/scalbln.3:65
msgid "B<scalbn>(), B<scalbnf>(), B<scalbnl>():"
msgstr "B<scalbn>(), B<scalbnf>(), B<scalbnl>():"

#. type: Plain text
#: man-pages/man3/scalbln.3:80
msgid ""
"These functions multiply their first argument I<x> by B<FLT_RADIX> (probably "
"2)  to the power of I<exp>, that is:"
msgstr ""
"Эти функции умножают свой первый аргумент I<x> на B<FLT_RADIX> (обычно, 2), "
"возведённый в степень I<exp>, то есть:"

#. type: Plain text
#: man-pages/man3/scalbln.3:83
#, no-wrap
msgid "    x * FLT_RADIX ** exp\n"
msgstr "    x * FLT_RADIX ** exp\n"

#.  not in /usr/include but in a gcc lib
#. type: Plain text
#: man-pages/man3/scalbln.3:90
msgid ""
"The definition of B<FLT_RADIX> can be obtained by including I<E<lt>float."
"hE<gt>>."
msgstr ""
"Определение значения B<FLT_RADIX> можно получить включив файл I<E<lt>float."
"hE<gt>>."

#. type: Plain text
#: man-pages/man3/scalbln.3:97
msgid "On success, these functions return I<x> * B<FLT_RADIX> ** I<exp>."
msgstr ""
"При успешном выполнении данные функции возвращают I<x> * B<FLT_RADIX> ** "
"I<exp>."

#. type: Plain text
#: man-pages/man3/scalbln.3:120
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with a sign the "
"same as I<x>."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, "
"соответственно, с тем же знаком что и I<x>."

#. type: Plain text
#: man-pages/man3/scalbln.3:125
msgid ""
"If the result underflows, a range error occurs, and the functions return "
"zero, with a sign the same as I<x>."
msgstr ""
"Если результат исчерпал степень, генерируется ошибка диапазона, а функции "
"возвращают 0 с тем же знаком что и I<x>."

#. type: TP
#: man-pages/man3/scalbln.3:132
#, no-wrap
msgid "Range error, overflow"
msgstr "Ошибка диапазона, переполнение"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/scalbln.3:140
msgid "An overflow floating-point exception (B<FE_OVERFLOW>)  is raised."
msgstr "Вызывается исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: TP
#: man-pages/man3/scalbln.3:140
#, no-wrap
msgid "Range error, underflow"
msgstr "Ошибка диапазона, исчерпана степень"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/scalbln.3:148
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Возникает исключение исчерпания степени чисел с плавающей запятой "
"(B<FE_UNDERFLOW>)."

#. type: tbl table
#: man-pages/man3/scalbln.3:167
#, no-wrap
msgid ""
"B<scalbn>(),\n"
"B<scalbnf>(),\n"
"B<scalbnl>(),\n"
msgstr ""
"B<scalbn>(),\n"
"B<scalbnf>(),\n"
"B<scalbnl>(),\n"

#. type: tbl table
#: man-pages/man3/scalbln.3:171
#, no-wrap
msgid ""
"B<scalbln>(),\n"
"B<scalblnf>(),\n"
"B<scalblnl>()"
msgstr ""
"B<scalbln>(),\n"
"B<scalblnf>(),\n"
"B<scalblnl>()"

#. type: Plain text
#: man-pages/man3/scalbln.3:184
msgid ""
"These functions differ from the obsolete functions described in B<scalb>(3)  "
"in the type of their second argument.  The functions described on this page "
"have a second argument of an integral type, while those in B<scalb>(3)  have "
"a second argument of type I<double>."
msgstr ""
"Эти функции отличаются от устаревших функций, описанных в B<scalb>(3), типом "
"второго аргумента. У функций, описанных здесь, второй аргумент имеет "
"целочисленный тип, а у описанных в B<scalb>(3) второй аргумент имеет тип "
"I<double>."

#. type: Plain text
#: man-pages/man3/scalbln.3:191
msgid ""
"If B<FLT_RADIX> equals 2 (which is usual), then B<scalbn>()  is equivalent "
"to B<ldexp>(3)."
msgstr ""
"Если B<FLT_RADIX> равно 2 (обычно), то B<scalbn>() эквивалентна B<ldexp>(3)."

#. type: Plain text
#: man-pages/man3/scalbln.3:193
msgid "B<ldexp>(3), B<scalb>(3)"
msgstr "B<ldexp>(3), B<scalb>(3)"

#. type: TH
#: man-pages/man3/strsep.3:33
#, no-wrap
msgid "STRSEP"
msgstr "STRSEP"

#. type: Plain text
#: man-pages/man3/strsep.3:36
msgid "strsep - extract token from string"
msgstr "strsep - извлечение токена из строки"

#. type: Plain text
#: man-pages/man3/strsep.3:41
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: man-pages/man3/strsep.3:53
#, no-wrap
msgid ""
"B<strsep>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<strsep>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/strsep.3:76
msgid ""
"If I<*stringp> is NULL, the B<strsep>()  function returns NULL and does "
"nothing else.  Otherwise, this function finds the first token in the string "
"I<*stringp>, that is delimited by one of the bytes in the string I<delim>.  "
"This token is terminated by overwriting the delimiter with a null byte (\\(aq"
"\\e0\\(aq), and I<*stringp> is updated to point past the token.  In case no "
"delimiter was found, the token is taken to be the entire string I<*stringp>, "
"and I<*stringp> is made NULL."
msgstr ""
"Если значение I<*stringp> равно NULL, то функция B<strsep>() возвращает NULL "
"и ничего не делает. В противном случае она ищет первый токен в строке "
"I<*stringp>, который отделён в строке одним байтом из I<delim>. Этот токен "
"завершается символом null (\\(aq\\e0\\(aq), который устанавливается на место "
"символа разделителя, а значению I<*stringp> присваивается значение, "
"указывающее на следующий символ после токена. Если разделитель не найден, то "
"токеном считается вся строка I<*stringp> и значению I<*stringp> "
"присваивается NULL."

#. type: Plain text
#: man-pages/man3/strsep.3:82
msgid ""
"The B<strsep>()  function returns a pointer to the token, that is, it "
"returns the original value of I<*stringp>."
msgstr ""
"Функция B<strsep>() возвращает указатель на токен, то есть возвращает "
"исходное значение I<*stringp>."

#. type: tbl table
#: man-pages/man3/strsep.3:92
#, no-wrap
msgid "B<strsep>()"
msgstr "B<strsep>()"

#. type: Plain text
#: man-pages/man3/strsep.3:96
msgid "4.4BSD."
msgstr "4.4BSD."

#. type: Plain text
#: man-pages/man3/strsep.3:105
msgid ""
"The B<strsep>()  function was introduced as a replacement for B<strtok>(3), "
"since the latter cannot handle empty fields.  However, B<strtok>(3)  "
"conforms to C89/C99 and hence is more portable."
msgstr ""
"Функция B<strsep>() была введена в качестве замены функции B<strtok>(3), "
"потому что последняя не может обрабатывать пустые поля. Тем не менее, "
"функция B<strtok>(3) соответствует C89/C99 и поэтому более переносима."

#. type: Plain text
#: man-pages/man3/strsep.3:108
msgid "Be cautious when using this function.  If you do use it, note that:"
msgstr "Используйте данную функцию с осторожностью. Учитывайте, что:"

#. type: Plain text
#: man-pages/man3/strsep.3:110
msgid "This function modifies its first argument."
msgstr "Данная функция изменяет первый аргумент."

#. type: Plain text
#: man-pages/man3/strsep.3:112
msgid "This function cannot be used on constant strings."
msgstr "Эта функция не может использоваться со строками-константами."

#. type: Plain text
#: man-pages/man3/strsep.3:114
msgid "The identity of the delimiting character is lost."
msgstr "Теряется идентичность символа-разделителя."

#. type: Plain text
#: man-pages/man3/strsep.3:123
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"

#. type: TH
#: man-pages/man3/scalb.3:27
#, no-wrap
msgid "SCALB"
msgstr "SCALB"

#. type: Plain text
#: man-pages/man3/scalb.3:31
msgid ""
"scalb, scalbf, scalbl - multiply floating-point number by integral power of "
"radix (OBSOLETE)"
msgstr ""
"scalb, scalbf, scalbl - умножает число с плавающей запятой на основание в "
"степени целого числа (УСТАРЕЛИ)"

#. type: Plain text
#: man-pages/man3/scalb.3:35
msgid "B<double scalb(double >I<x>B<, double >I<exp>B<);>"
msgstr "B<double scalb(double >I<x>B<, double >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalb.3:37
msgid "B<float scalbf(float >I<x>B<, float >I<exp>B<);>"
msgstr "B<float scalbf(float >I<x>B<, float >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalb.3:39
msgid "B<long double scalbl(long double >I<x>B<, long double >I<exp>B<);>"
msgstr "B<long double scalbl(long double >I<x>B<, long double >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalb.3:49
msgid "B<scalb>():"
msgstr "B<scalb>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/scalb.3:54
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/scalb.3:58
msgid "B<scalbf>(), B<scalbl>():"
msgstr "B<scalbf>(), B<scalbl>():"

#. type: Plain text
#: man-pages/man3/scalb.3:62
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/scalb.3:96
msgid "If I<x> or I<exp> is a NaN, a NaN is returned."
msgstr "Если значение I<x> или I<exp> равно NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/scalb.3:104
msgid ""
"If I<x> is positive infinity (negative infinity), and I<exp> is not negative "
"infinity, positive infinity (negative infinity) is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности (минус бесконечности) и I<exp> — не "
"минус бесконечность, то возвращается плюс бесконечность (минус "
"бесконечность)."

#. type: Plain text
#: man-pages/man3/scalb.3:110
msgid ""
"If I<x> is +0 (-0), and I<exp> is not positive infinity, +0 (-0) is returned."
msgstr ""
"Если I<x> равно +0 (-0), и I<exp> не положительная бесконечность, то "
"возвращается +0 (-0)."

#. type: Plain text
#: man-pages/man3/scalb.3:118
msgid ""
"If I<x> is zero, and I<exp> is positive infinity, a domain error occurs, and "
"a NaN is returned."
msgstr ""
"If I<x> равно нулю и I<exp> — положительная бесконечность, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата "
"будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/scalb.3:127
msgid ""
"If I<x> is an infinity, and I<exp> is negative infinity, a domain error "
"occurs, and a NaN is returned."
msgstr ""
"Если I<x> равно бесконечности, а I<exp> — отрицательной бесконечности, то "
"будет сгенерирована ошибка выхода за пределы области, а в качестве "
"результата будет возвращено NaN."

#. type: TP
#: man-pages/man3/scalb.3:149
#, no-wrap
msgid "Domain error: I<x> is 0, and I<exp> is positive infinity, or I<x> is positive infinity and I<exp> is negative infinity and the other argument is not a NaN"
msgstr "Ошибка области: I<x> равно 0, и I<exp> — положительная бесконечность, или I<x> — положительная бесконечность и I<exp> — отрицательная бесконечность, а другой аргумент не NaN."

#. type: tbl table
#: man-pages/man3/scalb.3:193
#, no-wrap
msgid ""
"B<scalb>(),\n"
"B<scalbf>(),\n"
"B<scalbl>()"
msgstr ""
"B<scalb>(),\n"
"B<scalbf>(),\n"
"B<scalbl>()"

#. type: Plain text
#: man-pages/man3/scalb.3:209
msgid ""
"B<scalb>()  is specified in POSIX.1-2001, but marked obsolescent.  "
"POSIX.1-2008 removes the specification of B<scalb>(), recommending the use "
"of B<scalbln>(3), B<scalblnf>(3), or B<scalblnl>(3)  instead.  The "
"B<scalb>()  function is from 4.3BSD."
msgstr ""
"Функция B<scalb>() определена в POSIX.1-2001, но помечена как устаревшая. Из "
"POSIX.1-2008 удалено описание B<scalb>(), рекомендуется использовать "
"B<scalbln>(3), B<scalblnf>(3) или B<scalblnl>(3). Функция B<scalb>() впервые "
"появилась в 4.3BSD."

#.  Looking at header files: scalbf() is present on the
#.  BSDs, Tru64, HP-UX 11, Irix 6.5; scalbl() is on HP-UX 11 and Tru64.
#. type: Plain text
#: man-pages/man3/scalb.3:218
msgid ""
"B<scalbf>()  and B<scalbl>()  are unstandardized; B<scalbf>()  is "
"nevertheless present on several other systems"
msgstr ""
"Функции B<scalbf>() и B<scalbl>() не стандартизованы; несмотря на это, "
"B<scalbf>() есть в нескольких системах"

#. type: Plain text
#: man-pages/man3/scalb.3:220
msgid "B<ldexp>(3), B<scalbln>(3)"
msgstr "B<ldexp>(3), B<scalbln>(3)"

#. type: TH
#: man-pages/man3/strspn.3:30
#, no-wrap
msgid "STRSPN"
msgstr "STRSPN"

#. type: Plain text
#: man-pages/man3/strspn.3:33
msgid "strspn, strcspn - get length of a prefix substring"
msgstr "strspn, strcspn - определение длины префикса подстроки"

#. type: Plain text
#: man-pages/man3/strspn.3:38
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: man-pages/man3/strspn.3:40
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"

#. type: Plain text
#: man-pages/man3/strspn.3:49
msgid ""
"The B<strspn>()  function calculates the length (in bytes) of the initial "
"segment of I<s> which consists entirely of bytes in I<accept>."
msgstr ""
"Функция B<strspn>() вычисляет длину (в байтах) начального сегмента строки "
"I<s>, состоящего только из байт строки I<accept>."

#. type: Plain text
#: man-pages/man3/strspn.3:57
msgid ""
"The B<strcspn>()  function calculates the length of the initial segment of "
"I<s> which consists entirely of bytes not in I<reject>."
msgstr ""
"Функция B<strcspn>() вычисляет длину начального сегмента строки I<s>, "
"состоящего только из байт, не указанных в строке I<reject>."

#. type: Plain text
#: man-pages/man3/strspn.3:66
msgid ""
"The B<strspn>()  function returns the number of bytes in the initial segment "
"of I<s> which consist only of bytes from I<accept>."
msgstr ""
"Функция B<strspn>() возвращает количество байт в начальном сегменте I<s>, "
"который составляют байты из I<accept>."

#. type: Plain text
#: man-pages/man3/strspn.3:74
msgid ""
"The B<strcspn>()  function returns the number of bytes in the initial "
"segment of I<s> which are not in the string I<reject>."
msgstr ""
"Функция B<strcspn>() возвращает количество байт в начальном сегменте I<s>, "
"состоящем только из символов, не указанных в I<reject>."

#. type: tbl table
#: man-pages/man3/strspn.3:85
#, no-wrap
msgid ""
"B<strspn>(),\n"
"B<strcspn>()"
msgstr ""
"B<strspn>(),\n"
"B<strcspn>()"

#. type: Plain text
#: man-pages/man3/strspn.3:100
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"

#. type: TH
#: man-pages/man3/strdup.3:31
#, no-wrap
msgid "STRDUP"
msgstr "STRDUP"

#. type: Plain text
#: man-pages/man3/strdup.3:34
msgid "strdup, strndup, strdupa, strndupa - duplicate a string"
msgstr "strdup, strndup, strdupa, strndupa - дублирование строки"

#. type: Plain text
#: man-pages/man3/strdup.3:39
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>\n"
msgstr "B<char *strdup(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/strdup.3:43
#, no-wrap
msgid ""
"B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
"B<char *strdupa(const char *>I<s>B<);>\n"
"B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""
"B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
"B<char *strdupa(const char *>I<s>B<);>\n"
"B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strdup.3:53
msgid "B<strdup>():"
msgstr "B<strdup>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/strdup.3:58
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/strdup.3:61
msgid "B<strndup>():"
msgstr "B<strndup>():"

#. type: Plain text
#: man-pages/man3/strdup.3:73
msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgstr "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/strdup.3:86
msgid ""
"The B<strdup>()  function returns a pointer to a new string which is a "
"duplicate of the string I<s>.  Memory for the new string is obtained with "
"B<malloc>(3), and can be freed with B<free>(3)."
msgstr ""
"Функция B<strdup>() возвращает указатель на новую строку, являющуюся "
"дубликатом строки I<s>. Память под новую строку выделятся с помощью "
"B<malloc>(3) и может быть высвобождены с помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/strdup.3:99
msgid ""
"The B<strndup>()  function is similar, but copies at most I<n> bytes.  If "
"I<s> is longer than I<n>, only I<n> bytes are copied, and a terminating null "
"byte (\\(aq\\e0\\(aq) is added."
msgstr ""
"Функция B<strndup>() похожа на предыдущую, но копирует не более I<n> байт. "
"Если I<s> длиннее I<n>, то копируется только I<n> байт и добавляется "
"конечный байт null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/strdup.3:109
msgid ""
"B<strdupa>()  and B<strndupa>()  are similar, but use B<alloca>(3)  to "
"allocate the buffer.  They are available only when using the GNU GCC suite, "
"and suffer from the same limitations described in B<alloca>(3)."
msgstr ""
"Функции B<strdupa>() и B<strndupa>() подобны предыдущим, но для выделения "
"буфера используют B<alloca>(3). Эти функции доступны только при "
"использовании GNU GCC и имеют ограничения, описанные в B<alloca>(3)."

#. type: Plain text
#: man-pages/man3/strdup.3:117
msgid ""
"On success, the B<strdup>()  function returns a pointer to the duplicated "
"string.  It returns NULL if insufficient memory was available, with I<errno> "
"set to indicate the cause of the error."
msgstr ""
"При успешном выполнении функция B<strdup>() возвращает указатель на копию "
"строки. Она возвращает NULL, если недостаточно памяти и записывает в "
"I<errno> номер ошибки."

#. type: Plain text
#: man-pages/man3/strdup.3:121
msgid "Insufficient memory available to allocate duplicate string."
msgstr "Недостаточно памяти для размещения копии строки."

#. type: tbl table
#: man-pages/man3/strdup.3:133
#, no-wrap
msgid ""
"B<strdup>(),\n"
"B<strndup>(),\n"
"B<strdupa>(),\n"
msgstr ""
"B<strdup>(),\n"
"B<strndup>(),\n"
"B<strdupa>(),\n"

#. type: tbl table
#: man-pages/man3/strdup.3:135
#, no-wrap
msgid "B<strndupa>()"
msgstr "B<strndupa>()"

#.  4.3BSD-Reno, not (first) 4.3BSD.
#. type: Plain text
#: man-pages/man3/strdup.3:148
msgid ""
"B<strdup>()  conforms to SVr4, 4.3BSD, POSIX.1-2001.  B<strndup>()  conforms "
"to POSIX.1-2008.  B<strdupa>()  and B<strndupa>()  are GNU extensions."
msgstr ""
"Функция B<strdup>() соответствует SVr4, 4.3BSD и POSIX.1-2001. B<strndup>() "
"соответствует POSIX.1-2008. B<strdupa>() и B<strndupa>() являются "
"расширениями GNU."

#. type: Plain text
#: man-pages/man3/strdup.3:155
msgid ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"
msgstr ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"

#. type: TH
#: man-pages/man3/strtok.3:32
#, no-wrap
msgid "STRTOK"
msgstr "STRTOK"

#. type: Plain text
#: man-pages/man3/strtok.3:35
msgid "strtok, strtok_r - extract tokens from strings"
msgstr "strtok, strtok_r - извлечение элементов (токенов) из строки"

#. type: Plain text
#: man-pages/man3/strtok.3:40
#, no-wrap
msgid "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtok.3:42
#, no-wrap
msgid "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"
msgstr "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtok.3:53
#, no-wrap
msgid ""
"B<strtok_r>():\n"
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<strtok_r>():\n"
"_POSIX_C_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/strtok.3:66
msgid ""
"The B<strtok>()  function breaks a string into a sequence of zero or more "
"nonempty tokens.  On the first call to B<strtok>(), the string to be parsed "
"should be specified in I<str>.  In each subsequent call that should parse "
"the same string, I<str> must be NULL."
msgstr ""
"Функция B<strtok>() разделяет строку на последовательность нуля или более "
"непустых токенов. При первом вызове B<strtok>() анализируемую строку нужно "
"указывать в аргументе I<str>. В каждом последующем вызове, в котором "
"анализируется эта же строка, значение I<str> должно быть NULL."

#. type: Plain text
#: man-pages/man3/strtok.3:75
msgid ""
"The I<delim> argument specifies a set of bytes that delimit the tokens in "
"the parsed string.  The caller may specify different strings in I<delim> in "
"successive calls that parse the same string."
msgstr ""
"В аргументе I<delim> задаётся набор байт, которые считаются разделителями "
"токенов в анализируемой строке. Вызывающий может указывать разные строки в "
"I<delim> в последующих вызовах при анализе той же строки."

#. type: Plain text
#: man-pages/man3/strtok.3:84
msgid ""
"Each call to B<strtok>()  returns a pointer to a null-terminated string "
"containing the next token.  This string does not include the delimiting "
"byte.  If no more tokens are found, B<strtok>()  returns NULL."
msgstr ""
"Каждый вызов B<strtok>() возвращает указатель на строку, завершающуюся null, "
"которая содержит следующий токен. Эта строка не включает байт-разделитель. "
"Если больше токенов нет, то B<strtok>() возвращает NULL."

#. type: Plain text
#: man-pages/man3/strtok.3:104
msgid ""
"A sequence of calls to B<strtok>()  that operate on the same string "
"maintains a pointer that determines the point from which to start searching "
"for the next token.  The first call to B<strtok>()  sets this pointer to "
"point to the first byte of the string.  The start of the next token is "
"determined by scanning forward for the next nondelimiter byte in I<str>.  If "
"such a byte is found, it is taken as the start of the next token.  If no "
"such byte is found, then there are no more tokens, and B<strtok>()  returns "
"NULL.  (A string that is empty or that contains only delimiters will thus "
"cause B<strtok>()  to return NULL on the first call.)"
msgstr ""
"Последовательность вызовов B<strtok>(), оперирующих одной строкой, "
"поддерживает указатель, который определяет точку, с которой начинается поиск "
"следующего токена. Первый вызов B<strtok>() назначает этому указателю ссылку "
"на первый байт строки. Начало следующего токена определяется поиском вперёд "
"в I<str> следующего байта не разделителя. Если байт найден, то он берётся в "
"качестве начала следующего токена. Если такой байт не найден, то токенов "
"больше нет и B<strtok>() возвращает NULL (для пустой строки или состоящей "
"только из разделителей в этом случае NULL вернётся при первом вызове "
"B<strtok>())."

#. type: Plain text
#: man-pages/man3/strtok.3:117
msgid ""
"The end of each token is found by scanning forward until either the next "
"delimiter byte is found or until the terminating null byte (\\(aq\\e0\\(aq) "
"is encountered.  If a delimiter byte is found, it is overwritten with a null "
"byte to terminate the current token, and B<strtok>()  saves a pointer to the "
"following byte; that pointer will be used as the starting point when "
"searching for the next token.  In this case, B<strtok>()  returns a pointer "
"to the start of the found token."
msgstr ""
"Конец каждого токена находится поиском вперёд, длящемся до тех пор, пока не "
"будет найден байт-разделитель или завершающий байт null (\\(aq\\e0\\(aq). "
"Если найден байт-разделитель, то он заменяется байтом null для завершения "
"текущего токена, и B<strtok>() сохраняет указатель на следующий байт; этот "
"указатель будет использован в качестве начальной точки при поиске следующего "
"токена. В этом случае B<strtok>() возвращает указатель на начало найденного "
"токена."

#. type: Plain text
#: man-pages/man3/strtok.3:131
msgid ""
"From the above description, it follows that a sequence of two or more "
"contiguous delimiter bytes in the parsed string is considered to be a single "
"delimiter, and that delimiter bytes at the start or end of the string are "
"ignored.  Put another way: the tokens returned by B<strtok>()  are always "
"nonempty strings.  Thus, for example, given the string \"I<aaa;;bbb,>\", "
"successive calls to B<strtok>()  that specify the delimiter string \"I<;,>\" "
"would return the strings \"I<aaa>\" and \"I<bbb>\", and then a null pointer."
msgstr ""
"Из описания выше следует, что последовательность из двух и более непрерывных "
"байтов-разделителей в просматриваемой строке считается одним разделителем, а "
"байты-разделители в начале или конце строки игнорируются. Другими словами, "
"токены, возвращаемые B<strtok>() — всегда не пустые строки. То есть, "
"например, если есть строка «I<aaa;;bbb,>», то последующие вызовы B<strtok>() "
"с заданными разделителями строк «I<;,>» вернули бы строки «I<aaa>» и "
"«I<bbb>», а затем указатель null."

#. type: Plain text
#: man-pages/man3/strtok.3:144
msgid ""
"The B<strtok_r>()  function is a reentrant version B<strtok>().  The "
"I<saveptr> argument is a pointer to a I<char\\ *> variable that is used "
"internally by B<strtok_r>()  in order to maintain context between successive "
"calls that parse the same string."
msgstr ""
"Функция B<strtok_r>() является реентерабельной версией B<strtok>(). Аргумент "
"I<saveptr> является указателем на переменную I<char\\ *>, которая "
"используется внутри B<strtok_r>() для учёта контекста между последующими "
"вызовами при анализе одной и той же строки."

#. type: Plain text
#: man-pages/man3/strtok.3:156
msgid ""
"On the first call to B<strtok_r>(), I<str> should point to the string to be "
"parsed, and the value of I<saveptr> is ignored.  In subsequent calls, I<str> "
"should be NULL, and I<saveptr> should be unchanged since the previous call."
msgstr ""
"При первом вызове B<strtok_r>() значение I<str> должно указывать на "
"анализируемую строку, а значение I<saveptr> игнорируется. При последующих "
"вызовах значение I<str> должно быть NULL, а значение I<saveptr> не должно "
"изменяться с момента предыдущего вызова."

#. type: Plain text
#: man-pages/man3/strtok.3:162
msgid ""
"Different strings may be parsed concurrently using sequences of calls to "
"B<strtok_r>()  that specify different I<saveptr> arguments."
msgstr ""
"Одновременно могут анализироваться разные строки при нескольких запусках "
"B<strtok_r>() с различными аргументами I<saveptr>."

#. type: Plain text
#: man-pages/man3/strtok.3:169
msgid ""
"The B<strtok>()  and B<strtok_r>()  functions return a pointer to the next "
"token, or NULL if there are no more tokens."
msgstr ""
"Функции B<strtok>() и B<strtok_r>() возвращают указатель на следующий токен "
"или NULL, если больше токенов нет."

#. type: TP
#: man-pages/man3/strtok.3:179 man-pages/man3/strtok.3:185
#, no-wrap
msgid "B<strtok>()"
msgstr "B<strtok>()"

#. type: tbl table
#: man-pages/man3/strtok.3:179
#, no-wrap
msgid "MT-Unsafe race:strtok"
msgstr "MT-Unsafe race:strtok"

#. type: TP
#: man-pages/man3/strtok.3:182 man-pages/man3/strtok.3:188
#, no-wrap
msgid "B<strtok_r>()"
msgstr "B<strtok_r>()"

#. type: Plain text
#: man-pages/man3/strtok.3:194
msgid "Be cautious when using these functions.  If you do use them, note that:"
msgstr "Используйте данные функции с осторожностью. Учитывайте, что:"

#. type: Plain text
#: man-pages/man3/strtok.3:196
msgid "These functions modify their first argument."
msgstr "Эти функции изменяют свой первый аргумент."

#. type: Plain text
#: man-pages/man3/strtok.3:198
msgid "These functions cannot be used on constant strings."
msgstr "Эти функции не могут использоваться со строками-константами."

#. type: Plain text
#: man-pages/man3/strtok.3:200
msgid "The identity of the delimiting byte is lost."
msgstr "Теряется идентичность байта-разделителя."

#. type: Plain text
#: man-pages/man3/strtok.3:207
msgid ""
"The B<strtok>()  function uses a static buffer while parsing, so it's not "
"thread safe.  Use B<strtok_r>()  if this matters to you."
msgstr ""
"При анализе функция B<strtok>() использует статический буфер, поэтому не "
"является безопасной для нитей. Используйте B<strtok_r>() в этом случае."

#. type: Plain text
#: man-pages/man3/strtok.3:216
msgid ""
"The program below uses nested loops that employ B<strtok_r>()  to break a "
"string into a two-level hierarchy of tokens.  The first command-line "
"argument specifies the string to be parsed.  The second argument specifies "
"the delimiter byte(s)  to be used to separate that string into \"major\" "
"tokens.  The third argument specifies the delimiter byte(s)  to be used to "
"separate the \"major\" tokens into subtokens."
msgstr ""
"В программе, представленной далее, используются вложенные циклы, которые "
"вызывают B<strtok_r>() для разделения строки на составляющие её токены. В "
"первом параметре командной строки задаётся анализируемая строка. Во втором "
"параметре задаётся байт(ы)- разделитель, который используется для деления "
"строки на «составные» токены. В третьем параметре указывается байт(ы)- "
"разделитель, который используется для разделения «составных» токенов на "
"подтокены."

#. type: Plain text
#: man-pages/man3/strtok.3:218
msgid "An example of the output produced by this program is the following:"
msgstr "Пример результата вывода программы:"

#. type: Plain text
#: man-pages/man3/strtok.3:230
#, no-wrap
msgid ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"
msgstr ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"

#. type: Plain text
#: man-pages/man3/strtok.3:238
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strtok.3:245
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man3/strtok.3:251
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Использование: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strtok.3:257
#, no-wrap
msgid ""
"    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"
msgstr ""
"    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"

#. type: Plain text
#: man-pages/man3/strtok.3:265
#, no-wrap
msgid ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"
msgstr ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strtok.3:274
msgid ""
"Another example program using B<strtok>()  can be found in "
"B<getaddrinfo_a>(3)."
msgstr ""
"Ещё один пример программы, использующей B<strtok>(), можно найти в "
"B<getaddrinfo_a>(3)."

#. type: Plain text
#: man-pages/man3/strtok.3:284
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"

#. type: TH
#: man-pages/man3/sigvec.3:26
#, no-wrap
msgid "SIGVEC"
msgstr "SIGVEC"

#. type: Plain text
#: man-pages/man3/sigvec.3:29
msgid "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD signal API"
msgstr ""
"sigvec, sigblock, sigsetmask, siggetmask, sigmask - программный интерфейс "
"сигналов BSD"

#. type: Plain text
#: man-pages/man3/sigvec.3:33
msgid ""
"B<int sigvec(int >I<sig>B<, const struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"
msgstr ""
"B<int sigvec(int >I<sig>B<, const struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"

#. type: Plain text
#: man-pages/man3/sigvec.3:35
msgid "B<int sigmask(int >I<signum>B<);>"
msgstr "B<int sigmask(int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigvec.3:37
msgid "B<int sigblock(int >I<mask>B<);>"
msgstr "B<int sigblock(int >I<mask>B<);>"

#. type: Plain text
#: man-pages/man3/sigvec.3:39
msgid "B<int sigsetmask(int >I<mask>B<);>"
msgstr "B<int sigsetmask(int >I<mask>B<);>"

#. type: Plain text
#: man-pages/man3/sigvec.3:41
msgid "B<int siggetmask(void);>"
msgstr "B<int siggetmask(void);>"

#. type: Plain text
#: man-pages/man3/sigvec.3:52
#, no-wrap
msgid ""
"All functions shown above:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"Для всех функций, показанных выше:\n"
"    Начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/sigvec.3:59
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical BSD signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)."
msgstr ""
"Данные функции предоставляются glibc для совместимости с программами, в "
"которых используются старый программный интерфейс сигналов BSD. Данный "
"программный интерфейс устарел: в новых приложениях нужно использовать "
"программный интерфейс сигналов POSIX (B<sigaction>(2), B<sigprocmask>(2) и т."
"п.)."

#. type: Plain text
#: man-pages/man3/sigvec.3:84
msgid ""
"The B<sigvec>()  function sets and/or gets the disposition of the signal "
"I<sig> (like the POSIX B<sigaction>(2)).  If I<vec> is not NULL, it points "
"to a I<sigvec> structure that defines the new disposition for I<sig>.  If "
"I<ovec> is not NULL, it points to a I<sigvec> structure that is used to "
"return the previous disposition of I<sig>.  To obtain the current "
"disposition of I<sig> without changing it, specify NULL for I<vec>, and a "
"non-null pointer for I<ovec>."
msgstr ""
"Функция B<sigvec>() назначает или возвращает обработчик сигнала I<sig> "
"(подобно POSIX B<sigaction>(2)). Если I<vec> не равно NULL, то это значение "
"указывает на структуру I<sigvec>, в которой определён новый обработчик для "
"I<sig>. Если I<ovec> не равно NULL, то это значение указывает на структуру "
"I<sigvec>, которая используется для возврата предыдущего обработчика I<sig>. "
"Чтобы получить текущий обработчик I<sig> без его изменения, укажите NULL в "
"I<vec> и не-null указатель в I<ovec>."

#. type: Plain text
#: man-pages/man3/sigvec.3:94
msgid "The I<sigvec> structure has the following form:"
msgstr "Структура I<sigvec> описана следующим образом:"

#. type: Plain text
#: man-pages/man3/sigvec.3:102
#, no-wrap
msgid ""
"struct sigvec {\n"
"    void (*sv_handler)(int); /* Signal disposition */\n"
"    int    sv_mask;          /* Signals to be blocked in handler */\n"
"    int    sv_flags;         /* Flags */\n"
"};\n"
msgstr ""
"struct sigvec {\n"
"    void (*sv_handler)(int); /* обработчик сигнала */\n"
"    int    sv_mask;          /* сигналы для блокировки в обработчике */\n"
"    int    sv_flags;         /* флаги */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/sigvec.3:113
msgid ""
"The I<sv_handler> field specifies the disposition of the signal, and is "
"either: the address of a signal handler function; B<SIG_DFL>, meaning the "
"default disposition applies for the signal; or B<SIG_IGN>, meaning that the "
"signal is ignored."
msgstr ""
"В поле I<sv_handler> задаётся обработчик сигнала и это может быть: адрес "
"функции сигнального обработчика; B<SIG_DFL>, означающее, что к сигналу "
"применяется обработчик по умолчанию; B<SIG_IGN>, означающее, что сигнал "
"игнорируется."

#. type: Plain text
#: man-pages/man3/sigvec.3:127
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then I<sv_mask> "
"specifies a mask of signals that are to be blocked while the handler is "
"executing.  In addition, the signal for which the handler is invoked is also "
"blocked.  Attempts to block B<SIGKILL> or B<SIGSTOP> are silently ignored."
msgstr ""
"Если в I<sv_handler> задан адрес обработчика сигнала, то в I<sv_mask> "
"задаётся маска сигналов, которые будут блокироваться на время выполнения "
"обработчика. Также блокируется сигнал, для которого вызывается обработчик. "
"Попытка заблокировать B<SIGKILL> или B<SIGSTOP> просто игнорируется."

#. type: Plain text
#: man-pages/man3/sigvec.3:134
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then the "
"I<sv_flags> field specifies flags controlling what happens when the handler "
"is called.  This field may contain zero or more of the following flags:"
msgstr ""
"Если в I<sv_handler> задан адрес обработчика сигнала, то в поле I<sv_flags> "
"задаются флаги, контролирующие, что происходит при вызове обработчика. Это "
"поле может содержать ноль или несколько следующих флагов:"

#. type: TP
#: man-pages/man3/sigvec.3:134
#, no-wrap
msgid "B<SV_INTERRUPT>"
msgstr "B<SV_INTERRUPT>"

#. type: Plain text
#: man-pages/man3/sigvec.3:142
msgid ""
"If the signal handler interrupts a blocking system call, then upon return "
"from the handler the system call s not be restarted: instead it fails with "
"the error B<EINTR>.  If this flag is not specified, then system calls are "
"restarted by default."
msgstr ""
"Если обработчик сигнала прерывает блокирующий системный вызов, то по "
"окончании обработчика системный вызов не будет перезапущен: вместо этого он "
"завершается ошибкой B<EINTR>. Если этот флаг не указан, то по умолчанию "
"системные вызовы перезапускаются."

#. type: TP
#: man-pages/man3/sigvec.3:142
#, no-wrap
msgid "B<SV_RESETHAND>"
msgstr "B<SV_RESETHAND>"

#. type: Plain text
#: man-pages/man3/sigvec.3:151
msgid ""
"Reset the disposition of the signal to the default before calling the signal "
"handler.  If this flag is not specified, then the handler remains "
"established until explicitly removed by a later call to B<sigvec>()  or "
"until the process performs an B<execve>(2)."
msgstr ""
"Сбросить обработку сигнала в значение по умолчанию перед вызовом обработчика "
"сигнала. Если этот флаг не указан, то обработчик остаётся установленным до "
"его явного удаления позднее вызовом B<sigvec>() или пока процесс не вызовет "
"B<execve>(2)."

#. type: TP
#: man-pages/man3/sigvec.3:151
#, no-wrap
msgid "B<SV_ONSTACK>"
msgstr "B<SV_ONSTACK>"

#. type: Plain text
#: man-pages/man3/sigvec.3:158
msgid ""
"Handle the signal on the alternate signal stack (historically established "
"under BSD using the obsolete B<sigstack>()  function; the POSIX replacement "
"is B<sigaltstack>(2))."
msgstr ""
"Обрабатывать сигнал в альтернативном стеке сигналов (исторически "
"устанавливается в BSD с помощью устаревшей функции B<sigstack>(); замена из "
"POSIX — B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man3/sigvec.3:168
msgid ""
"The B<sigmask>()  macro constructs and returns a \"signal mask\" for "
"I<signum>.  For example, we can initialize the I<vec.sv_mask> field given to "
"B<sigvec>()  using code such as the following:"
msgstr ""
"Макрос B<sigmask>() создаёт и возвращает «сигнальную маску» для I<signum>. "
"Например, мы можем инициализировать поле I<vec.sv_mask> передаваемого в "
"B<sigvec>() с помощью такого кода:"

#. type: Plain text
#: man-pages/man3/sigvec.3:174
#, no-wrap
msgid ""
"vec.sv_mask = sigmask(SIGQUIT) | sigmask(SIGABRT);\n"
"            /* Block SIGQUIT and SIGABRT during\n"
"               handler execution */\n"
msgstr ""
"vec.sv_mask = sigmask(SIGQUIT) | sigmask(SIGABRT);\n"
"            /* Блокировать SIGQUIT и SIGABRT при\n"
"               выполнении обработчика */\n"

#. type: Plain text
#: man-pages/man3/sigvec.3:190
msgid ""
"The B<sigblock>()  function adds the signals in I<mask> to the process's "
"signal mask (like POSIX I<sigprocmask(SIG_BLOCK)>), and returns the "
"process's previous signal mask.  Attempts to block B<SIGKILL> or B<SIGSTOP> "
"are silently ignored."
msgstr ""
"Функция B<sigblock>() добавляет сигналы в I<mask> в сигнальную маску "
"процесса (подобно POSIX I<sigprocmask(SIG_BLOCK)>) и возвращает старую "
"сигнальную маску процесса. Попытка блокировать B<SIGKILL> или B<SIGSTOP> "
"просто игнорируется."

#. type: Plain text
#: man-pages/man3/sigvec.3:198
msgid ""
"The B<sigsetmask>()  function sets the process's signal mask to the value "
"given in I<mask> (like POSIX I<sigprocmask(SIG_SETMASK)>), and returns the "
"process's previous signal mask."
msgstr ""
"Функция B<sigsetmask>() устанавливает сигнальную маску процесса равной "
"значению I<mask> (подобно POSIX I<sigprocmask(SIG_SETMASK)>) и возвращает "
"старую сигнальную маску процесса."

#. type: Plain text
#: man-pages/man3/sigvec.3:204
msgid ""
"The B<siggetmask>()  function returns the process's current signal mask.  "
"This call is equivalent to I<sigblock(0)>."
msgstr ""
"Функция B<siggetmask>() возвращает текущую сигнальную маску процесса. Этот "
"вызов эквивалентен I<sigblock(0)>."

#. type: Plain text
#: man-pages/man3/sigvec.3:210
msgid ""
"The B<sigvec>()  function returns 0 on success; on error, it returns -1 and "
"sets I<errno> to indicate the error."
msgstr ""
"При успешном выполнении B<sigvec>() возвращается 0; при ошибке возвращается "
"-1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/sigvec.3:216
msgid ""
"The B<sigblock>()  and B<sigsetmask>()  functions return the previous signal "
"mask."
msgstr ""
"Функции B<sigblock>() и B<sigsetmask>() возвращают предыдущую сигнальную "
"маску процесса."

#. type: Plain text
#: man-pages/man3/sigvec.3:221
msgid "The B<sigmask>()  macro returns the signal mask for I<signum>."
msgstr "Макрос B<sigmask>() возвращает сигнальную маску для I<signum>."

#. type: Plain text
#: man-pages/man3/sigvec.3:226
msgid "See the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr "Смотрите раздел ОШИБКИ в B<sigaction>(2) и B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man3/sigvec.3:233
msgid ""
"Starting with version 2.21, the GNU C library no longer exports the "
"B<sigvec>()  function as part of the ABI.  (To ensure backward "
"compatibility, the glibc symbol versioning scheme continues to export the "
"interface to binaries linked against older versions of the library.)"
msgstr ""
"Начиная с версии 2.21, библиотека GNU C больше не экспортирует функцию "
"B<sigvec>() как часть программного интерфейса (для обеспечения обратной "
"совместимости схема версий символов glibc продолжает экспортировать "
"интерфейс для двоичного кода, скомпонованного со старыми версиями "
"библиотеки)."

#. type: tbl table
#: man-pages/man3/sigvec.3:247
#, no-wrap
msgid ""
"B<sigvec>(),\n"
"B<sigmask>(),\n"
"B<sigblock>(),\n"
"B<sigsetmask>(),\n"
"B<siggetmask>()"
msgstr ""
"B<sigvec>(),\n"
"B<sigmask>(),\n"
"B<sigblock>(),\n"
"B<sigsetmask>(),\n"
"B<siggetmask>()"

#. type: Plain text
#: man-pages/man3/sigvec.3:255
msgid ""
"All of these functions were in 4.3BSD, except B<siggetmask>(), whose origin "
"is unclear.  These functions are obsolete: do not use them in new programs."
msgstr ""
"Все эти функции появились из 4.3BSD, за исключением B<siggetmask>(), чьё "
"происхождение неясно. Эти функции устарели: не используйте их в новых "
"программах."

#. type: Plain text
#: man-pages/man3/sigvec.3:272
msgid ""
"On 4.3BSD, the B<signal>()  function provided reliable semantics (as when "
"calling B<sigvec>()  with I<vec.sv_mask> equal to 0).  On System V, "
"B<signal>()  provides unreliable semantics.  POSIX.1 leaves these aspects of "
"B<signal>()  unspecified.  See B<signal>(2)  for further details."
msgstr ""
"В 4.3BSD, функция B<signal>() предоставляет надёжную семантику (как при "
"вызове B<sigvec>() со значением I<vec.sv_mask> равным 0). В System V, "
"B<signal>() предоставляет ненадёжную семантику. В POSIX.1 эти аспекты "
"B<signal>() не определены. Подробности смотрите в B<signal>(2)."

#. type: Plain text
#: man-pages/man3/sigvec.3:289
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/setlocale.3:32
#, no-wrap
msgid "SETLOCALE"
msgstr "SETLOCALE"

#. type: Plain text
#: man-pages/man3/setlocale.3:35
msgid "setlocale - set the current locale"
msgstr "setlocale - задаёт текущую локаль"

#. type: Plain text
#: man-pages/man3/setlocale.3:38
#, no-wrap
msgid "B<#include E<lt>locale.hE<gt>>\n"
msgstr "B<#include E<lt>locale.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setlocale.3:40
#, no-wrap
msgid "B<char *setlocale(int >I<category>B<, const char *>I<locale>B<);>\n"
msgstr "B<char *setlocale(int >I<category>B<, const char *>I<locale>B<);>\n"

#. type: Plain text
#: man-pages/man3/setlocale.3:45
msgid ""
"The B<setlocale>()  function is used to set or query the program's current "
"locale."
msgstr ""
"Функция B<setlocale>() используется для назначения или запроса текущей "
"локали программы."

#. type: Plain text
#: man-pages/man3/setlocale.3:53
msgid ""
"If I<locale> is not NULL, the program's current locale is modified according "
"to the arguments.  The argument I<category> determines which parts of the "
"program's current locale should be modified."
msgstr ""
"Если I<locale> не равно NULL, то текущая локаль программы изменяется "
"согласно переданным аргументам. Аргументом I<category> определяется какую "
"часть текущей локали программы нужно изменить."

#. type: tbl table
#: man-pages/man3/setlocale.3:56
#, no-wrap
msgid "Category"
msgstr "Категория"

#. type: tbl table
#: man-pages/man3/setlocale.3:56
#, no-wrap
msgid "Governs"
msgstr "Назначение"

#. type: tbl table
#: man-pages/man3/setlocale.3:57
#, no-wrap
msgid "LC_ALL"
msgstr "B<LC_ALL>"

#. type: tbl table
#: man-pages/man3/setlocale.3:57
#, no-wrap
msgid "All of the locale"
msgstr "Локаль целиком"

#. type: tbl table
#: man-pages/man3/setlocale.3:58
#, no-wrap
msgid "LC_ADDRESS"
msgstr "B<LC_ADDRESS>"

#. type: tbl table
#: man-pages/man3/setlocale.3:60
#, no-wrap
msgid "Formatting of addresses and\n"
msgstr "Форматирование адресов и\n"

#. type: tbl table
#: man-pages/man3/setlocale.3:62
#, no-wrap
msgid "geography-related items (*)"
msgstr "элементов, относящихся к географии (*)"

#. type: tbl table
#: man-pages/man3/setlocale.3:63
#, no-wrap
msgid "LC_COLLATE"
msgstr "B<LC_COLLATE>"

#. type: tbl table
#: man-pages/man3/setlocale.3:63
#, no-wrap
msgid "String collation"
msgstr "Сортировка строк"

#. type: tbl table
#: man-pages/man3/setlocale.3:64
#, no-wrap
msgid "LC_CTYPE"
msgstr "B<LC_CTYPE>"

#. type: tbl table
#: man-pages/man3/setlocale.3:64
#, no-wrap
msgid "Character classification"
msgstr "Классы символов"

#. type: tbl table
#: man-pages/man3/setlocale.3:65
#, no-wrap
msgid "LC_IDENTIFICATION"
msgstr "B<LC_IDENTIFICATION>"

#. type: tbl table
#: man-pages/man3/setlocale.3:65
#, no-wrap
msgid "Metadata describing the locale (*)"
msgstr "Метаданные, описывающие локаль (*)"

#. type: tbl table
#: man-pages/man3/setlocale.3:66
#, no-wrap
msgid "LC_MEASUREMENT"
msgstr "B<LC_MEASUREMENT>"

#. type: tbl table
#: man-pages/man3/setlocale.3:68
#, no-wrap
msgid "Settings related to measurements\n"
msgstr "Настройки, относящиеся к единицам измерения\n"

#. type: tbl table
#: man-pages/man3/setlocale.3:70
#, no-wrap
msgid "(metric versus US customary) (*)"
msgstr "(метрические или системы мер США) (*)"

#. type: tbl table
#: man-pages/man3/setlocale.3:71
#, no-wrap
msgid "LC_MESSAGES"
msgstr "B<LC_MESSAGES>"

#. type: tbl table
#: man-pages/man3/setlocale.3:71
#, no-wrap
msgid "Localizable natural-language messages"
msgstr "Локализированные сообщения на родном языке"

#. type: tbl table
#: man-pages/man3/setlocale.3:72
#, no-wrap
msgid "LC_MONETARY"
msgstr "B<LC_MONETARY>"

#. type: tbl table
#: man-pages/man3/setlocale.3:72
#, no-wrap
msgid "Formatting of monetary values"
msgstr "Форматирование значений денежных единиц"

#. type: tbl table
#: man-pages/man3/setlocale.3:73
#, no-wrap
msgid "LC_NAME"
msgstr "B<LC_NAME>"

#. type: tbl table
#: man-pages/man3/setlocale.3:73
#, no-wrap
msgid "Formatting of salutations for persons (*)"
msgstr "Форматирование приветствий людей (*)"

#. type: tbl table
#: man-pages/man3/setlocale.3:74
#, no-wrap
msgid "LC_NUMERIC"
msgstr "B<LC_NUMERIC>"

#. type: tbl table
#: man-pages/man3/setlocale.3:74
#, no-wrap
msgid "Formatting of nonmonetary numeric values"
msgstr "Форматирование не денежных числовых значений"

#. type: tbl table
#: man-pages/man3/setlocale.3:75
#, no-wrap
msgid "LC_PAPER"
msgstr "B<LC_PAPER>"

#. type: tbl table
#: man-pages/man3/setlocale.3:75
#, no-wrap
msgid "Settings related to the standard paper size (*)"
msgstr "Настройки стандартных размеров бумаги (*)"

#. type: tbl table
#: man-pages/man3/setlocale.3:76
#, no-wrap
msgid "LC_TELEPHONE"
msgstr "B<LC_TELEPHONE>"

#. type: tbl table
#: man-pages/man3/setlocale.3:76
#, no-wrap
msgid "Formats to be used with telephone services (*)"
msgstr "Форматы, используемые в телефонных службах (*) "

#. type: tbl table
#: man-pages/man3/setlocale.3:77
#, no-wrap
msgid "LC_TIME"
msgstr "B<LC_TIME>"

#. type: tbl table
#: man-pages/man3/setlocale.3:77
#, no-wrap
msgid "Formatting of date and time values"
msgstr "Форматирование значений дат и времени "

#. type: Plain text
#: man-pages/man3/setlocale.3:84
msgid ""
"The categories marked with an asterisk in the above table are GNU "
"extensions.  For further information on these locale categories, see "
"B<locale>(7)."
msgstr ""
"Категории, помеченные в таблице звёздочкой, являются расширениями GNU. "
"Дополнительную информацию об этих категориях локали смотрите в B<locale>(7)."

#. type: Plain text
#: man-pages/man3/setlocale.3:93
msgid ""
"The argument I<locale> is a pointer to a character string containing the "
"required setting of I<category>.  Such a string is either a well-known "
"constant like \"C\" or \"da_DK\" (see below), or an opaque string that was "
"returned by another call of B<setlocale>()."
msgstr ""
"Аргумент I<locale> — это указатель на строку символов, содержащую требуемую "
"настройку I<category>.  Эта строка может быть понятной константой «C» или "
"«da_DK» (смотрите ниже), или строкой со скрытым форматом, которую вернул "
"другой вызов B<setlocale>()."

#. type: Plain text
#: man-pages/man3/setlocale.3:115
msgid ""
"If I<locale> is an empty string, B<\"\">, each part of the locale that "
"should be modified is set according to the environment variables.  The "
"details are implementation-dependent.  For glibc, first (regardless of "
"I<category>), the environment variable B<LC_ALL> is inspected, next the "
"environment variable with the same name as the category (see the table "
"above), and finally the environment variable B<LANG>.  The first existing "
"environment variable is used.  If its value is not a valid locale "
"specification, the locale is unchanged, and B<setlocale>()  returns NULL."
msgstr ""
"Если I<locale> — пустая строка, B<\"\">, то любая часть локали, которую "
"требуется изменить, будет задана исходя из переменных окружения. Как это "
"происходит — зависит от реализации. В glibc, во-первых (независимо от "
"I<category>), просматривается переменная окружения B<LC_ALL>, затем "
"переменная окружения с именем как у категории (смотрите таблицу выше), и в "
"конце учитывается переменная окружения B<LANG>. Используется первая "
"найденная переменная окружения. Если её значение некорректно определяет "
"локаль, то локаль не изменяется и B<setlocale>() возвращает NULL."

#. type: Plain text
#: man-pages/man3/setlocale.3:122
msgid ""
"The locale B<\"C\"> or B<\"POSIX\"> is a portable locale; it exists on all "
"conforming systems."
msgstr ""
"Локали B<\"C\"> или B<\"POSIX\"> являются переносимыми локалями; они "
"существуют во всех соответствующих системах."

#. type: Plain text
#: man-pages/man3/setlocale.3:137
msgid ""
"A locale name is typically of the form I<language>[_I<territory>][."
"I<codeset>][@I<modifier>], where I<language> is an ISO 639 language code, "
"I<territory> is an ISO 3166 country code, and I<codeset> is a character set "
"or encoding identifier like B<ISO-8859-1> or B<UTF-8>.  For a list of all "
"supported locales, try \"locale -a\" (see B<locale>(1))."
msgstr ""
"Имя локали, обычно, состоит из I<языка>[_I<территории>][I<таблицы символов>]"
"[@I<модификатора>], где I<язык> — код языка согласно ISO 639, I<территория> "
"— код страны согласно ISO 3166 и I<таблица символов> — набор символов или "
"кодировка типа B<ISO-8859-1> или B<UTF-8>. Список поддерживаемых локалей "
"можно получить по команде «locale -a» (смотрите B<locale>(1))."

#. type: Plain text
#: man-pages/man3/setlocale.3:141
msgid "If I<locale> is NULL, the current locale is only queried, not modified."
msgstr ""
"Если I<locale> равно NULL, то только возвращается текущая локаль и ничего не "
"меняется."

#. type: Plain text
#: man-pages/man3/setlocale.3:146
msgid ""
"On startup of the main program, the portable B<\"C\"> locale is selected as "
"default.  A program may be made portable to all locales by calling:"
msgstr ""
"При запуске основной программы по умолчанию выбирается переносимая локаль B<"
"\"C\">. Программу можно сделать переносимой для всех локалей вызвав"

#. type: Plain text
#: man-pages/man3/setlocale.3:150
#, no-wrap
msgid "setlocale(LC_ALL, \"\");\n"
msgstr "setlocale(LC_ALL, \"\");\n"

#. type: Plain text
#: man-pages/man3/setlocale.3:167
msgid ""
"after program initialization, by using the values returned from a "
"B<localeconv>(3)  call for locale-dependent information, by using the "
"multibyte and wide character functions for text processing if B<MB_CUR_MAX "
"E<gt> 1>, and by using B<strcoll>(3), B<wcscoll>(3)  or B<strxfrm>(3), "
"B<wcsxfrm>(3)  to compare strings."
msgstr ""
"после инициализации программы, используя информацию об установках локали, "
"полученную из вызова B<localeconv>(3), используя многобайтные или "
"широкосимвольные функции при обработке текста, если B<MB_CUR_MAX E<gt> 1> и "
"используя B<strcoll>(3), B<wcscoll>(3) или B<strxfrm>(3), B<wcsxfrm>(3) для "
"сравнения строк."

#. type: Plain text
#: man-pages/man3/setlocale.3:176
msgid ""
"A successful call to B<setlocale>()  returns an opaque string that "
"corresponds to the locale set.  This string may be allocated in static "
"storage.  The string returned is such that a subsequent call with that "
"string and its associated category will restore that part of the process's "
"locale.  The return value is NULL if the request cannot be honored."
msgstr ""
"При успешном выполнении B<setlocale>() возвращает строку со скрытым "
"форматом, которая соответствует набору локали. Эта строка может находиться в "
"статическом хранилище. Строка возвращается таким образом, что последующий "
"вызов с этой строкой и связанной с ней категорией, восстанавливают эту часть "
"локали процесса. Если вызов не может быть выполнен, то возвращается значение "
"NULL."

#. type: tbl table
#: man-pages/man3/setlocale.3:186
#, no-wrap
msgid "B<setlocale>()"
msgstr "B<setlocale>()"

#. type: tbl table
#: man-pages/man3/setlocale.3:186
#, no-wrap
msgid "MT-Unsafe const:locale env"
msgstr "MT-Unsafe const:locale env"

#. type: Plain text
#: man-pages/man3/setlocale.3:203
msgid ""
"The C standards specify only the categories B<LC_ALL>, B<LC_COLLATE>, "
"B<LC_CTYPE>, B<LC_MONETARY>, B<LC_NUMERIC>, and B<LC_TIME>.  POSIX.1 adds "
"B<LC_MESSAGES>.  The remaining categories are GNU extensions."
msgstr ""
"В стандарте C определены только следующие категории: B<LC_ALL>, "
"B<LC_COLLATE>, B<LC_CTYPE>, B<LC_MONETARY>, B<LC_NUMERIC> и B<LC_TIME>. В "
"POSIX.1 добавлена B<LC_MESSAGES>. Остальные категории являются расширением "
"GNU."

#. type: Plain text
#: man-pages/man3/setlocale.3:213
msgid ""
"B<locale>(1), B<localedef>(1), B<isalpha>(3), B<localeconv>(3), "
"B<nl_langinfo>(3), B<rpmatch>(3), B<strcoll>(3), B<strftime>(3), "
"B<charsets>(7), B<locale>(7)"
msgstr ""
"B<locale>(1), B<localedef>(1), B<isalpha>(3), B<localeconv>(3), "
"B<nl_langinfo>(3), B<rpmatch>(3), B<strcoll>(3), B<strftime>(3), "
"B<charsets>(7), B<locale>(7)"

#. type: Plain text
#: man-pages/man3/syslog.3:40
msgid "closelog, openlog, syslog, vsyslog - send messages to the system logger"
msgstr ""
"closelog, openlog, syslog, vsyslog - отправка сообщений в службу "
"журналирования"

#. type: Plain text
#: man-pages/man3/syslog.3:42
msgid "B<#include E<lt>syslog.hE<gt>>"
msgstr "B<#include E<lt>syslog.hE<gt>>"

#. type: Plain text
#: man-pages/man3/syslog.3:44
msgid ""
"B<void openlog(const char *>I<ident>B<, int >I<option>B<, int "
">I<facility>B<);>"
msgstr ""
"B<void openlog(const char *>I<ident>B<, int >I<option>B<, int "
">I<facility>B<);>"

#. type: Plain text
#: man-pages/man3/syslog.3:46
msgid "B<void syslog(int >I<priority>B<, const char *>I<format>B<, ...);>"
msgstr "B<void syslog(int >I<priority>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: man-pages/man3/syslog.3:48
msgid "B<void closelog(void);>"
msgstr "B<void closelog(void);>"

#. type: Plain text
#: man-pages/man3/syslog.3:50
msgid ""
"B<void vsyslog(int >I<priority>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr ""
"B<void vsyslog(int >I<priority>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/syslog.3:61
#, no-wrap
msgid ""
"B<vsyslog>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<vsyslog>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: SS
#: man-pages/man3/syslog.3:62
#, no-wrap
msgid "openlog()"
msgstr "openlog()"

#. type: Plain text
#: man-pages/man3/syslog.3:65
msgid "B<openlog>()  opens a connection to the system logger for a program."
msgstr ""
"Функция B<openlog>() открывает для программы соединение со службой "
"журналирования."

#. type: Plain text
#: man-pages/man3/syslog.3:75
msgid ""
"The string pointed to by I<ident> is prepended to every message, and is "
"typically set to the program name.  If I<ident> is NULL, the program name is "
"used.  (POSIX.1-2008 does not specify the behavior when I<ident> is NULL.)"
msgstr ""
"Строка, на которую указывает I<ident>, будет предварять каждое сообщение, "
"обычно это имя программы. Если значение I<ident> равно NULL, то используется "
"имя программы (в POSIX.1-2008 не указано, что случается, если I<ident> равно "
"NULL)."

#. type: Plain text
#: man-pages/man3/syslog.3:92
msgid ""
"The I<option> argument specifies flags which control the operation of "
"B<openlog>()  and subsequent calls to B<syslog>().  The I<facility> argument "
"establishes a default to be used if none is specified in subsequent calls to "
"B<syslog>().  The values that may be specified for I<option> and I<facility> "
"are described below."
msgstr ""
"В аргументе I<option> указываются флаги, контролирующие действия "
"B<openlog>() и последующих вызовов B<syslog>(). Аргумент I<facility> "
"устанавливает значения по умолчанию, если не будет указано другое в "
"последующих вызовах B<syslog>(). Значения для I<option> и I<facility> "
"представлены ниже."

#. type: Plain text
#: man-pages/man3/syslog.3:101
msgid ""
"The use of B<openlog>()  is optional; it will automatically be called by "
"B<syslog>()  if necessary, in which case I<ident> will default to NULL."
msgstr ""
"Использование B<openlog>() не обязательно; она будет вызвана B<syslog>() в "
"случае необходимости (в этом случае по умолчанию I<ident> будет установлено "
"в NULL)."

#. type: SS
#: man-pages/man3/syslog.3:101
#, no-wrap
msgid "syslog() and vsyslog()"
msgstr "syslog() и vsyslog()"

#. type: Plain text
#: man-pages/man3/syslog.3:105
msgid ""
"B<syslog>()  generates a log message, which will be distributed by "
"B<syslogd>(8)."
msgstr ""
"Функция B<syslog>() генерирует сообщение журнала, которое будет передавать "
"B<syslogd>(8)."

#. type: Plain text
#: man-pages/man3/syslog.3:124
msgid ""
"The I<priority> argument is formed by ORing together a I<facility> value and "
"a I<level> value (described below).  If no I<facility> value is ORed into "
"I<priority>, then the default value set by B<openlog>()  is used, or, if "
"there was no preceding B<openlog>()  call, a default of B<LOG_USER> is "
"employed."
msgstr ""
"Аргумент I<priority> составляется из объединения значений I<facility> и "
"I<level> (описано ниже). Если значения I<facility> нет в I<priority>, то по "
"умолчанию используется значение, заданное B<openlog>(), или, если до этого "
"B<openlog>() не вызывался, используется значение B<LOG_USER>."

#. type: Plain text
#: man-pages/man3/syslog.3:137
msgid ""
"The remaining arguments are a I<format>, as in B<printf>(3), and any "
"arguments required by the I<format>, except that the two-character sequence "
"B<%m> will be replaced by the error message string I<strerror>(I<errno>).  "
"The format string need not include a terminating newline character."
msgstr ""
"Оставшиеся аргументы — I<format>, задаются в формате как у B<printf>(3) (а "
"также аргументы, необходимые для I<format>) за исключением "
"последовательности двух символов B<%m>, которые заменяются строкой ошибки "
"I<strerror>(I<errno>). В строку формата не нужно включать конечный символ "
"новой строки."

#. type: Plain text
#: man-pages/man3/syslog.3:147
msgid ""
"The function B<vsyslog>()  performs the same task as B<syslog>()  with the "
"difference that it takes a set of arguments which have been obtained using "
"the B<stdarg>(3)  variable argument list macros."
msgstr ""
"Функция B<vsyslog>() выполняет то же самое, что и B<syslog>() с той лишь "
"разницей, что она принимает набор аргументов, получаемых с использованием "
"списка макросов B<stdarg>(3)."

#. type: SS
#: man-pages/man3/syslog.3:147
#, no-wrap
msgid "closelog()"
msgstr "closelog()"

#. type: Plain text
#: man-pages/man3/syslog.3:154
msgid ""
"B<closelog>()  closes the file descriptor being used to write to the system "
"logger.  The use of B<closelog>()  is optional."
msgstr ""
"Функция B<closelog>() закрывает файловый дескриптор, использованный для "
"записи в службу журналирования. Использование B<closelog>() не обязательно."

#. type: SS
#: man-pages/man3/syslog.3:154
#, no-wrap
msgid "Values for I<option>"
msgstr "Значения I<option>"

#. type: Plain text
#: man-pages/man3/syslog.3:160
msgid ""
"The I<option> argument to B<openlog>()  is a bit mask constructed by ORing "
"together any of the following values:"
msgstr ""
"Аргумент I<option> у B<openlog>() представляет собой битовую маску "
"объединённых следующих значений:"

#. type: TP
#: man-pages/man3/syslog.3:160
#, no-wrap
msgid "B<LOG_CONS>"
msgstr "B<LOG_CONS>"

#. type: Plain text
#: man-pages/man3/syslog.3:164
msgid ""
"Write directly to the system console if there is an error while sending to "
"the system logger."
msgstr ""
"Писать напрямую в системную консоль, если при отправке в систему "
"журналирования возникла ошибка."

#. type: TP
#: man-pages/man3/syslog.3:164
#, no-wrap
msgid "B<LOG_NDELAY>"
msgstr "B<LOG_NDELAY>"

#. type: Plain text
#: man-pages/man3/syslog.3:171
msgid ""
"Open the connection immediately (normally, the connection is opened when the "
"first message is logged).  This may be useful, for example, if a subsequent "
"B<chroot>(2)  would make the pathname used internally by the logging "
"facility unreachable."
msgstr ""
"Немедленно открыть соединение (обычно соединение открывается при первом "
"сообщении). Например, это может быть полезно, если последующий B<chroot>(2) "
"делает недоступным путь, используемый внутри свойства протоколирования."

#. type: TP
#: man-pages/man3/syslog.3:171
#, no-wrap
msgid "B<LOG_NOWAIT>"
msgstr "B<LOG_NOWAIT>"

#. type: Plain text
#: man-pages/man3/syslog.3:177
msgid ""
"Don't wait for child processes that may have been created while logging the "
"message.  (The GNU C library does not create a child process, so this option "
"has no effect on Linux.)"
msgstr ""
"Не ждать дочерних процессов, которые могут быть созданы во время "
"журналирования сообщения (библиотека GNU C не создаёт дочерних процессов, "
"так что в Linux этот параметр не действует)."

#. type: TP
#: man-pages/man3/syslog.3:177
#, no-wrap
msgid "B<LOG_ODELAY>"
msgstr "B<LOG_ODELAY>"

#. type: Plain text
#: man-pages/man3/syslog.3:185
msgid ""
"The converse of B<LOG_NDELAY>; opening of the connection is delayed until "
"B<syslog>()  is called.  (This is the default, and need not be specified.)"
msgstr ""
"Противоположен B<LOG_NDELAY>; открытие подключения откладывается, пока не "
"будет вызван B<syslog>() (этот параметр используется по умолчанию, нет "
"необходимости выставлять его вручную)."

#. type: TP
#: man-pages/man3/syslog.3:185
#, no-wrap
msgid "B<LOG_PERROR>"
msgstr "B<LOG_PERROR>"

#. type: Plain text
#: man-pages/man3/syslog.3:190
msgid ""
"(Not in POSIX.1-2001 or POSIX.1-2008.)  Also log the message to I<stderr>."
msgstr ""
"(нет в POSIX.1-2001 или POSIX.1-2008) Также протоколировать сообщение в "
"I<stderr>."

#. type: TP
#: man-pages/man3/syslog.3:190
#, no-wrap
msgid "B<LOG_PID>"
msgstr "B<LOG_PID>"

#. type: Plain text
#: man-pages/man3/syslog.3:194
msgid "Include the caller's PID with each message."
msgstr "Включать PID вызывающего в каждое сообщение."

#. type: SS
#: man-pages/man3/syslog.3:194
#, no-wrap
msgid "Values for I<facility>"
msgstr "Значения I<facility>"

#. type: Plain text
#: man-pages/man3/syslog.3:200
msgid ""
"The I<facility> argument is used to specify what type of program is logging "
"the message.  This lets the configuration file specify that messages from "
"different facilities will be handled differently."
msgstr ""
"Аргумент I<facility> используется для указания типа программы, записывающей "
"сообщение. Благодаря этому с помощью файла настройки можно по-разному "
"обрабатывать сообщения от разных объектов."

#. type: TP
#: man-pages/man3/syslog.3:200
#, no-wrap
msgid "B<LOG_AUTH>"
msgstr "B<LOG_AUTH>"

#. type: Plain text
#: man-pages/man3/syslog.3:203
msgid "security/authorization messages"
msgstr "сообщения безопасности/авторизации"

#. type: TP
#: man-pages/man3/syslog.3:203
#, no-wrap
msgid "B<LOG_AUTHPRIV>"
msgstr "B<LOG_AUTHPRIV>"

#. type: Plain text
#: man-pages/man3/syslog.3:206
msgid "security/authorization messages (private)"
msgstr "сообщения безопасности/авторизации (private)"

#. type: TP
#: man-pages/man3/syslog.3:206
#, no-wrap
msgid "B<LOG_CRON>"
msgstr "B<LOG_CRON>"

#. type: Plain text
#: man-pages/man3/syslog.3:210
msgid "clock daemon (B<cron> and B<at>)"
msgstr "планировщик заданий (B<cron> и B<at>)"

#. type: TP
#: man-pages/man3/syslog.3:210
#, no-wrap
msgid "B<LOG_DAEMON>"
msgstr "B<LOG_DAEMON>"

#. type: Plain text
#: man-pages/man3/syslog.3:213
msgid "system daemons without separate facility value"
msgstr "системные службы без определенного значения объекта"

#. type: TP
#: man-pages/man3/syslog.3:213
#, no-wrap
msgid "B<LOG_FTP>"
msgstr "B<LOG_FTP>"

#. type: Plain text
#: man-pages/man3/syslog.3:216
msgid "ftp daemon"
msgstr "служба FTP"

#. type: TP
#: man-pages/man3/syslog.3:216
#, no-wrap
msgid "B<LOG_KERN>"
msgstr "B<LOG_KERN>"

#.  LOG_KERN has the value 0; if used as a facility, zero translates to:
#.  "use the default facility".
#. type: Plain text
#: man-pages/man3/syslog.3:221
msgid "kernel messages (these can't be generated from user processes)"
msgstr "сообщения ядра (не могут быть созданы пользовательскими процессами)"

#. type: TP
#: man-pages/man3/syslog.3:221
#, no-wrap
msgid "B<LOG_LOCAL0> through B<LOG_LOCAL7>"
msgstr "с B<LOG_LOCAL0> по B<LOG_LOCAL7>"

#. type: Plain text
#: man-pages/man3/syslog.3:224
msgid "reserved for local use"
msgstr "зарезервировано для локального использования"

#. type: TP
#: man-pages/man3/syslog.3:224
#, no-wrap
msgid "B<LOG_LPR>"
msgstr "B<LOG_LPR>"

#. type: Plain text
#: man-pages/man3/syslog.3:227
msgid "line printer subsystem"
msgstr "подсистема печати"

#. type: TP
#: man-pages/man3/syslog.3:227
#, no-wrap
msgid "B<LOG_MAIL>"
msgstr "B<LOG_MAIL>"

#. type: Plain text
#: man-pages/man3/syslog.3:230
msgid "mail subsystem"
msgstr "почтовая подсистема"

#. type: TP
#: man-pages/man3/syslog.3:230
#, no-wrap
msgid "B<LOG_NEWS>"
msgstr "B<LOG_NEWS>"

#. type: Plain text
#: man-pages/man3/syslog.3:233
msgid "USENET news subsystem"
msgstr "подсистема новостей USENET"

#. type: TP
#: man-pages/man3/syslog.3:233
#, no-wrap
msgid "B<LOG_SYSLOG>"
msgstr "B<LOG_SYSLOG>"

#. type: Plain text
#: man-pages/man3/syslog.3:237
msgid "messages generated internally by B<syslogd>(8)"
msgstr "сообщения, сгенерированные самой службой B<syslogd>(8)"

#. type: TP
#: man-pages/man3/syslog.3:237
#, no-wrap
msgid "B<LOG_USER> (default)"
msgstr "B<LOG_USER> (по умолчанию)"

#. type: Plain text
#: man-pages/man3/syslog.3:240
msgid "generic user-level messages"
msgstr "обычные сообщения пользовательского уровня"

#. type: TP
#: man-pages/man3/syslog.3:240
#, no-wrap
msgid "B<LOG_UUCP>"
msgstr "B<LOG_UUCP>"

#. type: Plain text
#: man-pages/man3/syslog.3:244
msgid "UUCP subsystem"
msgstr "подсистема UUCP"

#. type: SS
#: man-pages/man3/syslog.3:244
#, no-wrap
msgid "Values for I<level>"
msgstr "Значения I<level>"

#. type: Plain text
#: man-pages/man3/syslog.3:247
msgid ""
"This determines the importance of the message.  The levels are, in order of "
"decreasing importance:"
msgstr ""
"Определяет важность сообщения. Ниже указаны уровни по уменьшению важности:"

#. type: TP
#: man-pages/man3/syslog.3:247
#, no-wrap
msgid "B<LOG_EMERG>"
msgstr "B<LOG_EMERG>"

#. type: Plain text
#: man-pages/man3/syslog.3:250
msgid "system is unusable"
msgstr "система в нерабочем состоянии"

#. type: TP
#: man-pages/man3/syslog.3:250
#, no-wrap
msgid "B<LOG_ALERT>"
msgstr "B<LOG_ALERT>"

#. type: Plain text
#: man-pages/man3/syslog.3:253
msgid "action must be taken immediately"
msgstr "необходимо срочное вмешательство"

#. type: TP
#: man-pages/man3/syslog.3:253
#, no-wrap
msgid "B<LOG_CRIT>"
msgstr "B<LOG_CRIT>"

#. type: Plain text
#: man-pages/man3/syslog.3:256
msgid "critical conditions"
msgstr "критические состояния"

#. type: TP
#: man-pages/man3/syslog.3:256
#, no-wrap
msgid "B<LOG_ERR>"
msgstr "B<LOG_ERR>"

#. type: Plain text
#: man-pages/man3/syslog.3:259
msgid "error conditions"
msgstr "ошибки"

#. type: TP
#: man-pages/man3/syslog.3:259
#, no-wrap
msgid "B<LOG_WARNING>"
msgstr "B<LOG_WARNING>"

#. type: Plain text
#: man-pages/man3/syslog.3:262
msgid "warning conditions"
msgstr "предупреждения"

#. type: TP
#: man-pages/man3/syslog.3:262
#, no-wrap
msgid "B<LOG_NOTICE>"
msgstr "B<LOG_NOTICE>"

#. type: Plain text
#: man-pages/man3/syslog.3:265
msgid "normal, but significant, condition"
msgstr "обычные, но важные сообщения"

#. type: TP
#: man-pages/man3/syslog.3:265
#, no-wrap
msgid "B<LOG_INFO>"
msgstr "B<LOG_INFO>"

#. type: Plain text
#: man-pages/man3/syslog.3:268
msgid "informational message"
msgstr "информационные сообщения"

#. type: TP
#: man-pages/man3/syslog.3:268
#, no-wrap
msgid "B<LOG_DEBUG>"
msgstr "B<LOG_DEBUG>"

#. type: Plain text
#: man-pages/man3/syslog.3:271
msgid "debug-level message"
msgstr "сообщения уровня отладки"

#. type: Plain text
#: man-pages/man3/syslog.3:275
msgid ""
"The function B<setlogmask>(3)  can be used to restrict logging to specified "
"levels only."
msgstr ""
"Для ограничения журналирования только в определенные уровни можно "
"использовать функцию B<setlogmask>(3)."

#. type: tbl table
#: man-pages/man3/syslog.3:286
#, no-wrap
msgid ""
"B<openlog>(),\n"
"B<closelog>()"
msgstr ""
"B<openlog>(),\n"
"B<closelog>()"

#. type: tbl table
#: man-pages/man3/syslog.3:290
#, no-wrap
msgid ""
"B<syslog>(),\n"
"B<vsyslog>()"
msgstr ""
"B<syslog>(),\n"
"B<vsyslog>()"

#. type: Plain text
#: man-pages/man3/syslog.3:301
msgid ""
"The functions B<openlog>(), B<closelog>(), and B<syslog>()  (but not "
"B<vsyslog>())  are specified in SUSv2, POSIX.1-2001, and POSIX.1-2008."
msgstr ""
"Функции B<openlog>(), B<closelog>() и B<syslog>() (но не B<vsyslog>()) "
"определены в SUSv2, POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/syslog.3:315
msgid ""
"POSIX.1-2001 specifies only the B<LOG_USER> and B<LOG_LOCAL*> values for "
"I<facility>.  However, with the exception of B<LOG_AUTHPRIV> and B<LOG_FTP>, "
"the other I<facility> values appear on most UNIX systems."
msgstr ""
"В POSIX.1-2001 для I<facility> описаны только значения B<LOG_USER> и "
"B<LOG_LOCAL*>. Однако, за исключением B<LOG_AUTHPRIV> и B<LOG_FTP>, "
"остальные значения I<facility> присутствуют в большинстве систем UNIX."

#.  .SH HISTORY
#.  A
#.  .BR syslog ()
#.  function call appeared in 4.2BSD.
#.  4.3BSD documents
#.  .BR openlog (),
#.  .BR syslog (),
#.  .BR closelog (),
#.  and
#.  .BR setlogmask ().
#.  4.3BSD-Reno also documents
#.  .BR vsyslog ().
#.  Of course early v* functions used the
#.  .I <varargs.h>
#.  mechanism, which is not compatible with
#.  .IR <stdarg.h> .
#. type: Plain text
#: man-pages/man3/syslog.3:338
msgid ""
"The B<LOG_PERROR> value for I<option> is not specified by POSIX.1-2001 or "
"POSIX.1-2008, but is available in most versions of UNIX."
msgstr ""
"Значение B<LOG_PERROR> для I<option> не описано в POSIX.1-2001 или "
"POSIX.1-2008, однако доступно в большинстве версий UNIX."

#. type: Plain text
#: man-pages/man3/syslog.3:350
msgid ""
"The argument I<ident> in the call of B<openlog>()  is probably stored as-"
"is.  Thus, if the string it points to is changed, B<syslog>()  may start "
"prepending the changed string, and if the string it points to ceases to "
"exist, the results are undefined.  Most portable is to use a string constant."
msgstr ""
"Аргумент I<ident> при вызове B<openlog>() сохраняется как есть. Поэтому, "
"если строка меняется, B<syslog>() может начать добавлять уже изменённую "
"строку. Если строка перестаёт существовать, то это может привести к "
"непредвиденным результатам. Наиболее переносимый способ в данном случае "
"\\(em использовать строковую константу."

#. type: Plain text
#: man-pages/man3/syslog.3:353
msgid ""
"Never pass a string with user-supplied data as a format, use the following "
"instead:"
msgstr ""
"Никогда не подставляйте пользовательские данные в качестве формата "
"представления, используйте вместо этого:"

#. type: Plain text
#: man-pages/man3/syslog.3:357
#, no-wrap
msgid "syslog(priority, \"%s\", string);\n"
msgstr "syslog(priority, \"%s\", string);\n"

#. type: Plain text
#: man-pages/man3/syslog.3:364
msgid ""
"B<journalctl>(1), B<logger>(1), B<setlogmask>(3), B<syslog.conf>(5), "
"B<syslogd>(8)"
msgstr ""
"B<journalctl>(1), B<logger>(1), B<setlogmask>(3), B<syslog.conf>(5), "
"B<syslogd>(8)"

#. type: TH
#: man-pages/man3/stpncpy.3:14
#, no-wrap
msgid "STPNCPY"
msgstr "STPNCPY"

#. type: Plain text
#: man-pages/man3/stpncpy.3:17
msgid "stpncpy - copy a fixed-size string, returning a pointer to its end"
msgstr ""
"stpncpy - копирование строки фиксированной длины с возвращением указателя на "
"её конец"

#. type: Plain text
#: man-pages/man3/stpncpy.3:22
#, no-wrap
msgid "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/stpncpy.3:30
msgid "B<stpncpy>():"
msgstr "B<stpncpy>():"

#. type: Plain text
#: man-pages/man3/stpncpy.3:74
msgid ""
"The B<stpncpy>()  function copies at most I<n> characters from the string "
"pointed to by I<src>, including the terminating null byte (\\(aq\\e0\\(aq), "
"to the array pointed to by I<dest>.  Exactly I<n> characters are written at "
"I<dest>.  If the length I<strlen(src)> is smaller than I<n>, the remaining "
"characters in the array pointed to by I<dest> are filled with null bytes "
"(\\(aq\\e0\\(aq), If the length I<strlen(src)> is greater than or equal to "
"I<n>, the string pointed to by I<dest> will not be null-terminated."
msgstr ""
"Функция B<stpncpy>() копирует не более I<n> символов из строки, на которую "
"ссылается указатель I<src>, включая конечный байт null (\\(aq\\e0\\(aq), в "
"массив по указателю I<dest>. В I<dest> будет записано точно I<n> символов. "
"Если длина I<strlen(src)> меньше I<n>, то оставшиеся символы в массиве "
"I<dest> будут заполнены байтами null (\\(aq\\e\\(aq). Если длина "
"I<strlen(src)> больше или равна I<n>, то строка, на которую ссылается "
"указатель I<dest>, не будет завершаться null."

#. type: Plain text
#: man-pages/man3/stpncpy.3:76
msgid "The strings may not overlap."
msgstr "Строки не должны пересекаться."

#. type: Plain text
#: man-pages/man3/stpncpy.3:82
msgid ""
"The programmer must ensure that there is room for at least I<n> characters "
"at I<dest>."
msgstr ""
"Программист должен быть уверен, что в I<dest> достаточно места для по "
"крайней мере I<n> символов."

#. type: Plain text
#: man-pages/man3/stpncpy.3:91
msgid ""
"B<stpncpy>()  returns a pointer to the terminating null byte in I<dest>, or, "
"if I<dest> is not null-terminated, I<dest>+I<n>."
msgstr ""
"B<stpncpy>() возвращает указатель на завершающий байт null в I<dest> или, "
"если I<dest> не завершается null, I<dest>+I<n>."

#. type: tbl table
#: man-pages/man3/stpncpy.3:101
#, no-wrap
msgid "B<stpncpy>()"
msgstr "B<stpncpy>()"

#. type: Plain text
#: man-pages/man3/stpncpy.3:107
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was a GNU "
"extension.  It first appeared in version 1.07 of the GNU C library in 1993."
msgstr ""
"Эта функция была добавлена в POSIX.1-2008. До этого она считалась "
"расширением GNU. Впервые она появилась в версии 1.07 библиотеки GNU C в 1993 "
"году."

#. type: Plain text
#: man-pages/man3/stpncpy.3:109
msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: TH
#: man-pages/man3/signbit.3:11
#, no-wrap
msgid "SIGNBIT"
msgstr "SIGNBIT"

#. type: Plain text
#: man-pages/man3/signbit.3:14
msgid "signbit - test sign of a real floating-point number"
msgstr "signbit - проверка знака вещественного числа с плавающей точкой"

#. type: Plain text
#: man-pages/man3/signbit.3:18
msgid "B<int signbit(>I<x>B<);>"
msgstr "B<int signbit(>I<x>B<);>"

#. type: Plain text
#: man-pages/man3/signbit.3:28
msgid "B<signbit>():"
msgstr "B<signbit>():"

#. type: Plain text
#: man-pages/man3/signbit.3:38
msgid ""
"B<signbit>()  is a generic macro which can work on all real floating-point "
"types.  It returns a nonzero value if the value of I<x> has its sign bit set."
msgstr ""
"Функция B<signbit>() является общим макросом, который может работать со всем "
"типами вещественных чисел с плавающей точкой. Она возвращает ненулевое "
"значение, если у I<x> установлен бит знака."

#. type: Plain text
#: man-pages/man3/signbit.3:47
msgid ""
"This is not the same as I<x E<lt> 0.0>, because IEEE 754 floating point "
"allows zero to be signed.  The comparison I<-0.0 E<lt> 0.0> is false, but "
"I<signbit(-0.0)> will return a nonzero value."
msgstr ""
"Это не подходит для I<x E<lt> 0.0>, так как, согласно IEEE 754, спецификация "
"плавающей точки допускает, что ноль может иметь знак. Сравнение I<-0.0 E<lt> "
"0.0> будет ложным, однако I<signbit(-0.0)> вернет ненулевое значение."

#. type: Plain text
#: man-pages/man3/signbit.3:49
msgid "NaNs and infinities have a sign bit."
msgstr "Значение NaN и бесконечностей имеют бит знака."

#. type: Plain text
#: man-pages/man3/signbit.3:55
msgid ""
"The B<signbit>()  macro returns nonzero if the sign of I<x> is negative; "
"otherwise it returns zero."
msgstr ""
"Макрос B<signbit>() возвращает ненулевое значение, если знак I<x> "
"отрицателен, иначе он возвращает ноль."

#. type: Plain text
#: man-pages/man3/signbit.3:57
msgid "No errors occur."
msgstr "Ошибки не возникают."

#. type: tbl table
#: man-pages/man3/signbit.3:67
#, no-wrap
msgid "B<signbit>()"
msgstr "B<signbit>()"

#. type: Plain text
#: man-pages/man3/signbit.3:73
msgid ""
"POSIX.1-2001, POSIX.1-2008, C99.  This function is defined in IEC 559 (and "
"the appendix with recommended functions in IEEE 754/IEEE 854)."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, C99. Эта функция определена в IEC 559 (и в "
"приложении с рекомендуемыми функциями IEEE 754/IEEE 854)."

#. type: Plain text
#: man-pages/man3/signbit.3:74
msgid "B<copysign>(3)"
msgstr "B<copysign>(3)"

#. type: TH
#: man-pages/man3/sysconf.3:27
#, no-wrap
msgid "SYSCONF"
msgstr "SYSCONF"

#. type: Plain text
#: man-pages/man3/sysconf.3:30
msgid "sysconf - get configuration information at run time"
msgstr "sysconf - считывает информацию о настройках во время работы системы"

#. type: Plain text
#: man-pages/man3/sysconf.3:35
#, no-wrap
msgid "B<long sysconf(int >I<name>B<);>\n"
msgstr "B<long sysconf(int >I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/sysconf.3:40
msgid ""
"POSIX allows an application to test at compile or run time whether certain "
"options are supported, or what the value is of certain configurable "
"constants or limits."
msgstr ""
"POSIX позволяет приложению проверять наличие поддержки определённых "
"параметров на стадии компиляции или выполнения  или получать значения "
"некоторых настраиваемых констант или ограничений."

#. type: Plain text
#: man-pages/man3/sysconf.3:46
msgid ""
"At compile time this is done by including I<E<lt>unistd.hE<gt>> and/or "
"I<E<lt>limits.hE<gt>> and testing the value of certain macros."
msgstr ""
"На стадии компиляции это осуществляется при помощи включения I<E<lt>unistd."
"hE<gt>> и/или I<E<lt>limits.hE<gt>> и проверки значений определённых "
"макросов."

#. type: Plain text
#: man-pages/man3/sysconf.3:56
msgid ""
"At run time, one can ask for numerical values using the present function "
"B<sysconf>().  One can ask for numerical values that may depend on the "
"filesystem in which a file resides using B<fpathconf>(3)  and "
"B<pathconf>(3).  One can ask for string values using B<confstr>(3)."
msgstr ""
"Во время выполнения можно запрашивать числовые значение посредством функции "
"B<sysconf>(). Можно запросить числовые значения, которые могут зависеть "
"файловой системы, в которой находится файл, с помощью вызовов "
"B<fpathconf>(3) и B<pathconf>(3). Строковые значения можно запрашивать с "
"помощью B<confstr>(3)."

#.  except that sysconf(_SC_OPEN_MAX) may change answer after a call
#.  to setrlimit( ) which changes the RLIMIT_NOFILE soft limit
#. type: Plain text
#: man-pages/man3/sysconf.3:61
msgid ""
"The values obtained from these functions are system configuration "
"constants.  They do not change during the lifetime of a process."
msgstr ""
"Значения, полученные с помощью этих функций, являются системными "
"настроечными константами. Они не изменятся пока выполняется процесс."

#.  and 999 to indicate support for options no longer present in the latest
#.  standard. (?)
#. type: Plain text
#: man-pages/man3/sysconf.3:84
msgid ""
"For options, typically, there is a constant B<_POSIX_FOO> that may be "
"defined in I<E<lt>unistd.hE<gt>>.  If it is undefined, one should ask at run "
"time.  If it is defined to -1, then the option is not supported.  If it is "
"defined to 0, then relevant functions and headers exist, but one has to ask "
"at run time what degree of support is available.  If it is defined to a "
"value other than -1 or 0, then the option is supported.  Usually the value "
"(such as 200112L) indicates the year and month of the POSIX revision "
"describing the option.  Glibc uses the value 1 to indicate support as long "
"as the POSIX revision has not been published yet.  The B<sysconf>()  "
"argument will be B<_SC_FOO>.  For a list of options, see B<posixoptions>(7)."
msgstr ""
"Для параметров, как правило, используются константы вида B<_POSIX_FOO>, "
"которые могут быть определены в I<E<lt>unistd.hE<gt>>. Если параметр не "
"определён, то его можно запросить во время выполнения. Если он определён со "
"значением -1, то этот параметр не поддерживается. Если его значение равно 0, "
"то соответствующие функции и заголовочные файлы существуют, но нужно во "
"время выполнения запрашивать степень поддержки. Если он определён со "
"значениями не -1 и 0, то параметр поддерживается. Обычно значение (например "
"200112L) отражает год и месяц версии POSIX, в которой описан параметр. В "
"glibc используется значение 1, означающее, что поддержка в версии POSIX пока "
"не опубликована. В этом случае аргумент B<sysconf>() будет выглядеть как "
"B<_SC_FOO>. Список параметров смотрите в B<posixoptions>(7)."

#. type: Plain text
#: man-pages/man3/sysconf.3:104
msgid ""
"For variables or limits, typically, there is a constant B<_FOO>, maybe "
"defined in I<E<lt>limits.hE<gt>>, or B<_POSIX_FOO>, maybe defined in "
"I<E<lt>unistd.hE<gt>>.  The constant will not be defined if the limit is "
"unspecified.  If the constant is defined, it gives a guaranteed value, and a "
"greater value might actually be supported.  If an application wants to take "
"advantage of values which may change between systems, a call to "
"B<sysconf>()  can be made.  The B<sysconf>()  argument will be B<_SC_FOO>."
msgstr ""
"Для переменных или ограничений, как правило, используются константы вида "
"B<_FOO>, возможно определённые в I<E<lt>limits.hE<gt>>, или B<_POSIX_FOO>, "
"возможно определённые в I<E<lt>unistd.hE<gt>>. Константа не будет "
"определена, если не указано ограничение. Если константа определена, то это "
"даёт гарантированное значение и в реальности может поддерживаться большее "
"значение. Если приложение хочет получить преимущества учёта значений, "
"которые могут быть разными в системах, то этого можно достичь с помощью "
"B<sysconf>(). В этом случае аргумент B<sysconf>() будет выглядеть как "
"B<_SC_FOO>."

#. type: SS
#: man-pages/man3/sysconf.3:104
#, no-wrap
msgid "POSIX.1 variables"
msgstr "Переменные POSIX.1"

#. type: Plain text
#: man-pages/man3/sysconf.3:109
msgid ""
"We give the name of the variable, the name of the B<sysconf>()  argument "
"used to inquire about its value, and a short description."
msgstr ""
"Далее показаны имя переменной, имя аргумента B<sysconf>(), используемого для "
"опроса этого значения, и короткое описание."

#.  [for the moment: only the things that are unconditionally present]
#.  .TP
#.  .BR AIO_LISTIO_MAX " - " _SC_AIO_LISTIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of I/O operations in a single list I/O call.
#.  Must not be less than _POSIX_AIO_LISTIO_MAX.
#.  .TP
#.  .BR AIO_MAX " - " _SC_AIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of outstanding asynchronous I/O operations.
#.  Must not be less than _POSIX_AIO_MAX.
#.  .TP
#.  .BR AIO_PRIO_DELTA_MAX " - " _SC_AIO_PRIO_DELTA_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  The maximum amount by which a process can decrease its
#.  asynchronous I/O priority level from its own scheduling priority.
#.  Must be nonnegative.
#. type: Plain text
#: man-pages/man3/sysconf.3:128
msgid "First, the POSIX.1 compatible values."
msgstr "Сначала совместимые с POSIX.1 значения."

#. type: TP
#: man-pages/man3/sysconf.3:128
#, no-wrap
msgid "B<ARG_MAX> - B<_SC_ARG_MAX>"
msgstr "B<ARG_MAX> - B<_SC_ARG_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:136
msgid ""
"The maximum length of the arguments to the B<exec>(3)  family of functions.  "
"Must not be less than B<_POSIX_ARG_MAX> (4096)."
msgstr ""
"Максимально допустимая длина аргументов для семейства функций B<exec>(3). "
"Должна быть не меньше B<_POSIX_ARG_MAX> (4096)."

#. type: TP
#: man-pages/man3/sysconf.3:136
#, no-wrap
msgid "B<CHILD_MAX> - B<_SC_CHILD_MAX>"
msgstr "B<CHILD_MAX> - B<_SC_CHILD_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:142
msgid ""
"The maximum number of simultaneous processes per user ID.  Must not be less "
"than B<_POSIX_CHILD_MAX> (25)."
msgstr ""
"Максимально допустимое количество одновременно работающих процессов для "
"каждого пользовательского ID. Должно быть не меньше B<_POSIX_CHILD_MAX> (25)."

#. type: TP
#: man-pages/man3/sysconf.3:142
#, no-wrap
msgid "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"
msgstr "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:150
msgid ""
"Maximum length of a hostname, not including the terminating null byte, as "
"returned by B<gethostname>(2).  Must not be less than "
"B<_POSIX_HOST_NAME_MAX> (255)."
msgstr ""
"Максимально допустимая длина имени узла (без завершающего null-байта), "
"возвращаемая B<gethostname>(2). Должна быть не меньше "
"B<_POSIX_HOST_NAME_MAX> (255)."

#. type: TP
#: man-pages/man3/sysconf.3:150
#, no-wrap
msgid "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"
msgstr "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:156
msgid ""
"Maximum length of a login name, including the terminating null byte.  Must "
"not be less than B<_POSIX_LOGIN_NAME_MAX> (9)."
msgstr ""
"Максимально допустимая длина имени пользователя (включая завершающий null-"
"байт). Должна быть не меньше B<_POSIX_LOGIN_NAME_MAX> (9)."

#. type: TP
#: man-pages/man3/sysconf.3:156
#, no-wrap
msgid "B<NGROUPS_MAX> - B<_SC_NGROUPS_MAX>"
msgstr "B<NGROUPS_MAX> - B<_SC_NGROUPS_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:159
msgid "Maximum number of supplementary group IDs."
msgstr "Максимальное количество идентификаторов дополнительных групп."

#. type: TP
#: man-pages/man3/sysconf.3:159
#, no-wrap
msgid "clock ticks - B<_SC_CLK_TCK>"
msgstr "такты часов - B<_SC_CLK_TCK>"

#. type: Plain text
#: man-pages/man3/sysconf.3:168
msgid ""
"The number of clock ticks per second.  The corresponding variable is "
"obsolete.  It was of course called B<CLK_TCK>.  (Note: the macro "
"B<CLOCKS_PER_SEC> does not give information: it must equal 1000000.)"
msgstr ""
"Количество тактов часов в секунду. Соответствующая переменная устарела. "
"Ранее она называлась B<CLK_TCK> (примечание: макрос B<CLOCKS_PER_SEC> не "
"даёт необходимую информацию, он должен быть равен 1000000)."

#. type: TP
#: man-pages/man3/sysconf.3:168
#, no-wrap
msgid "B<OPEN_MAX> - B<_SC_OPEN_MAX>"
msgstr "B<OPEN_MAX> - B<_SC_OPEN_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:174
msgid ""
"The maximum number of files that a process can have open at any time.  Must "
"not be less than B<_POSIX_OPEN_MAX> (20)."
msgstr ""
"Максимально допустимое количество файлов, которое одновременно может открыть "
"процесс. Должно быть не меньше B<_POSIX_OPEN_MAX> (20)."

#. type: TP
#: man-pages/man3/sysconf.3:174
#, no-wrap
msgid "B<PAGESIZE> - B<_SC_PAGESIZE>"
msgstr "B<PAGESIZE> - B<_SC_PAGESIZE>"

#. type: Plain text
#: man-pages/man3/sysconf.3:178
msgid "Size of a page in bytes.  Must not be less than 1."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:178
#, no-wrap
msgid "B<PAGE_SIZE> - B<_SC_PAGE_SIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:187
msgid ""
"A synonym for B<PAGESIZE>/B<_SC_PAGESIZE>.  (Both B<PAGESIZE> and "
"B<PAGE_SIZE> are specified in POSIX.)"
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:187 man-pages/man3/sysconf.3:274
#, no-wrap
msgid "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"
msgstr "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:196
msgid ""
"The number of repeated occurrences of a BRE permitted by B<regexec>(3)  and "
"B<regcomp>(3).  Must not be less than B<_POSIX2_RE_DUP_MAX> (255)."
msgstr ""
"Количество повторяемых совпадений BRE, разрешённых B<regexec>(3) и "
"B<regcomp>(3). Должно быть не меньше B<_POSIX2_RE_DUP_MAX> (255)."

#. type: TP
#: man-pages/man3/sysconf.3:196
#, no-wrap
msgid "B<STREAM_MAX> - B<_SC_STREAM_MAX>"
msgstr "B<STREAM_MAX> - B<_SC_STREAM_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:205
msgid ""
"The maximum number of streams that a process can have open at any time.  If "
"defined, it has the same value as the standard C macro B<FOPEN_MAX>.  Must "
"not be less than B<_POSIX_STREAM_MAX> (8)."
msgstr ""
"Максимально допустимое количество потоков, которое может одновременно "
"открывать процесс. Если определёно, то оно имеет то же значение, что и "
"стандартный макрос C B<FOPEN_MAX>. Должно быть не меньше "
"B<_POSIX_STREAM_MAX> (8)."

#. type: TP
#: man-pages/man3/sysconf.3:205
#, no-wrap
msgid "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"
msgstr "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:213
msgid ""
"The maximum number of symbolic links seen in a pathname before resolution "
"returns B<ELOOP>.  Must not be less than B<_POSIX_SYMLOOP_MAX> (8)."
msgstr ""
"Максимальное количество символических ссылок, допустимое при разрешении "
"имени пути до того, как не будет возвращена ошибка B<ELOOP>. Должно быть не "
"меньше B<_POSIX_SYMLOOP_MAX> (8)."

#. type: TP
#: man-pages/man3/sysconf.3:213
#, no-wrap
msgid "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"
msgstr "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:220
msgid ""
"The maximum length of terminal device name, including the terminating null "
"byte.  Must not be less than B<_POSIX_TTY_NAME_MAX> (9)."
msgstr ""
"Максимально допустимая длина имени устройства терминала, включая завершающий "
"байт null. Должна быть не меньше B<_POSIX_TTY_NAME_MAX> (9)."

#. type: TP
#: man-pages/man3/sysconf.3:220
#, no-wrap
msgid "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"
msgstr "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:226
msgid ""
"The maximum number of bytes in a timezone name.  Must not be less than "
"B<_POSIX_TZNAME_MAX> (6)."
msgstr ""
"Максимально количество байт в имени часового пояса. Должно быть не меньше "
"B<_POSIX_TZNAME_MAX> (6)."

#. type: TP
#: man-pages/man3/sysconf.3:226
#, no-wrap
msgid "B<_POSIX_VERSION> - B<_SC_VERSION>"
msgstr "B<_POSIX_VERSION> - B<_SC_VERSION>"

#. type: Plain text
#: man-pages/man3/sysconf.3:234
msgid ""
"indicates the year and month the POSIX.1 standard was approved in the format "
"B<YYYYMML>; the value B<199009L> indicates the Sept. 1990 revision."
msgstr ""
"Отображает год и месяц, в котором был утверждён стандарт POSIX.1, в формате "
"B<YYYYMML>; значение B<199009L> указывает на версию сентября 1990 года."

#. type: SS
#: man-pages/man3/sysconf.3:234
#, no-wrap
msgid "POSIX.2 variables"
msgstr "Переменные POSIX.2"

#. type: Plain text
#: man-pages/man3/sysconf.3:236
msgid "Next, the POSIX.2 values, giving limits for utilities."
msgstr "Далее перечислены значения POSIX.2, задающие ограничения для утилит."

#. type: TP
#: man-pages/man3/sysconf.3:236
#, no-wrap
msgid "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"
msgstr "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:243
msgid "indicates the maximum I<obase> value accepted by the B<bc>(1)  utility."
msgstr ""
"Отображает максимальное значение I<obase>, принимаемое утилитой B<bc>(1)."

#. type: TP
#: man-pages/man3/sysconf.3:243
#, no-wrap
msgid "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"
msgstr "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:247
msgid ""
"indicates the maximum value of elements permitted in an array by B<bc>(1)."
msgstr ""
"Отображает максимальное количество элементов, разрешённых в массиве в "
"B<bc>(1)."

#. type: TP
#: man-pages/man3/sysconf.3:247
#, no-wrap
msgid "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"
msgstr "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:253
msgid "indicates the maximum I<scale> value allowed by B<bc>(1)."
msgstr ""
"Отображает максимальное значение I<scale>, которое может принимать B<bc>(1)."

#. type: TP
#: man-pages/man3/sysconf.3:253
#, no-wrap
msgid "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"
msgstr "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:257
msgid "indicates the maximum length of a string accepted by B<bc>(1)."
msgstr ""
"Отображает максимальную длину строки, которую может принимать B<bc>(1)."

#. type: TP
#: man-pages/man3/sysconf.3:257
#, no-wrap
msgid "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"
msgstr "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:263
msgid ""
"indicates the maximum numbers of weights that can be assigned to an entry of "
"the B<LC_COLLATE order> keyword in the locale definition file,"
msgstr ""
"Отображает максимальное количество весов, которые можно назначить элементу "
"ключевого слова B<LC_COLLATE order> в файле определения локали"

#. type: TP
#: man-pages/man3/sysconf.3:263
#, no-wrap
msgid "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"
msgstr "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:268
msgid ""
"is the maximum number of expressions which can be nested within parentheses "
"by B<expr>(1)."
msgstr ""
"Максимальное количество выражений, которые могут быть вложены внутри скобок "
"B<expr>(1)."

#. type: TP
#: man-pages/man3/sysconf.3:268
#, no-wrap
msgid "B<LINE_MAX> - B<_SC_LINE_MAX>"
msgstr "B<LINE_MAX> - B<_SC_LINE_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:274
msgid ""
"The maximum length of a utility's input line, either from standard input or "
"from a file.  This includes space for a trailing newline."
msgstr ""
"Максимальная длина входной строки утилит, или из стандартного ввода или из "
"файла. Учитывается пробел для символа новой строки в конце."

#. type: Plain text
#: man-pages/man3/sysconf.3:280
msgid ""
"The maximum number of repeated occurrences of a regular expression when the "
"interval notation B<\\e{m,n\\e}> is used."
msgstr ""
"Максимальное количество повторяемых совпадений регулярного выражения при "
"указании интервала в нотации B<\\e{m,n\\e}>"

#. type: TP
#: man-pages/man3/sysconf.3:280
#, no-wrap
msgid "B<POSIX2_VERSION> - B<_SC_2_VERSION>"
msgstr "B<POSIX2_VERSION> - B<_SC_2_VERSION>"

#. type: Plain text
#: man-pages/man3/sysconf.3:284
msgid "indicates the version of the POSIX.2 standard in the format of YYYYMML."
msgstr "Отображает версию стандарта POSIX.2 в формате YYYYMML."

#. type: TP
#: man-pages/man3/sysconf.3:284
#, no-wrap
msgid "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"
msgstr "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"

#. type: Plain text
#: man-pages/man3/sysconf.3:288
msgid ""
"indicates whether the POSIX.2 C language development facilities are "
"supported."
msgstr "Отображает, поддерживаются ли средства разработки языка Си POSIX.2."

#. type: TP
#: man-pages/man3/sysconf.3:288
#, no-wrap
msgid "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"
msgstr "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"

#. type: Plain text
#: man-pages/man3/sysconf.3:292
msgid ""
"indicates whether the POSIX.2 FORTRAN development utilities are supported."
msgstr ""
"Отображает, поддерживаются ли средства разработки языка FORTRAN POSIX.2."

#. type: TP
#: man-pages/man3/sysconf.3:292
#, no-wrap
msgid "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"
msgstr "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"

#. type: Plain text
#: man-pages/man3/sysconf.3:295
msgid "indicates whether the POSIX.2 FORTRAN run-time utilities are supported."
msgstr ""
"Отображает, поддерживаются ли утилиты времени выполнения языка FORTRAN "
"POSIX.2."

#. type: TP
#: man-pages/man3/sysconf.3:295
#, no-wrap
msgid "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"
msgstr "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"

#. type: Plain text
#: man-pages/man3/sysconf.3:300
msgid ""
"indicates whether the POSIX.2 creation of locates via B<localedef>(1)  is "
"supported."
msgstr ""
"Отображает, поддерживается создание локалей с помощью B<localedef>(1) "
"согласно POSIX.2."

#. type: TP
#: man-pages/man3/sysconf.3:300
#, no-wrap
msgid "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"
msgstr "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"

#. type: Plain text
#: man-pages/man3/sysconf.3:304
msgid ""
"indicates whether the POSIX.2 software development utilities option is "
"supported."
msgstr "Отображает, поддерживаются ли параметры утилит разработки ПО POSIX.2."

#. type: Plain text
#: man-pages/man3/sysconf.3:306
msgid "These values also exist, but may not be standard."
msgstr ""
"Также могут существовать следующие значения, однако они могут быть не "
"стандартизированы."

#. type: TP
#: man-pages/man3/sysconf.3:306
#, no-wrap
msgid " - B<_SC_PHYS_PAGES>"
msgstr " - B<_SC_PHYS_PAGES>"

#. type: Plain text
#: man-pages/man3/sysconf.3:313
msgid ""
"The number of pages of physical memory.  Note that it is possible for the "
"product of this value and the value of B<_SC_PAGESIZE> to overflow."
msgstr ""
"Количество страниц физической памяти. Заметим, что возможно переполнение при "
"перемножении этого значения и B<_SC_PAGESIZE>."

#. type: TP
#: man-pages/man3/sysconf.3:313
#, no-wrap
msgid " - B<_SC_AVPHYS_PAGES>"
msgstr " - B<_SC_AVPHYS_PAGES>"

#. type: Plain text
#: man-pages/man3/sysconf.3:316
msgid "The number of currently available pages of physical memory."
msgstr "Количество доступных в данный момент страниц физической памяти."

#. type: TP
#: man-pages/man3/sysconf.3:316
#, no-wrap
msgid " - B<_SC_NPROCESSORS_CONF>"
msgstr " - B<_SC_NPROCESSORS_CONF>"

#. type: Plain text
#: man-pages/man3/sysconf.3:321
msgid "The number of processors configured.  See also B<get_nprocs_conf>(3)."
msgstr ""
"Количество настроенных процессоров. Смотрите также B<get_nprocs_conf>(3)."

#. type: TP
#: man-pages/man3/sysconf.3:321
#, no-wrap
msgid " - B<_SC_NPROCESSORS_ONLN>"
msgstr " - B<_SC_NPROCESSORS_ONLN>"

#. type: Plain text
#: man-pages/man3/sysconf.3:326
msgid ""
"The number of processors currently online (available).  See also "
"B<get_nprocs_conf>(3)."
msgstr ""
"Количество включенных (доступных) процессоров. Смотрите также "
"B<get_nprocs_conf>(3)."

#. type: Plain text
#: man-pages/man3/sysconf.3:330
msgid "The return value of B<sysconf>()  is one of the following:"
msgstr "Возвращаемым значением B<sysconf>() может быть одно из:"

#. type: Plain text
#: man-pages/man3/sysconf.3:339
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error (for example, B<EINVAL>, indicating that I<name> is invalid)."
msgstr ""
"При ошибке возвращается -1, а в I<errno> содержится код ошибки (например, "
"B<EINVAL> означает, что некорректно I<name>)."

#. type: Plain text
#: man-pages/man3/sysconf.3:351
msgid ""
"If I<name> corresponds to a maximum or minimum limit, and that limit is "
"indeterminate, -1 is returned and I<errno> is not changed.  (To distinguish "
"an indeterminate limit from an error, set I<errno> to zero before the call, "
"and then check whether I<errno> is nonzero when -1 is returned.)"
msgstr ""
"Если I<name> соответствует максимальному или минимальному ограничителю и "
"этот ограничитель не определён, то возвращается -1 и I<errno> не изменяется "
"(чтобы отличать  неопределённый ограничитель от ошибки, сбросьте I<errno> в "
"ноль пере вызовом, а затем проверьте, что I<errno> не равно нулю, если "
"возвращается -1)."

#. type: Plain text
#: man-pages/man3/sysconf.3:357
msgid ""
"If I<name> corresponds to an option, a positive value is returned if the "
"option is supported, and -1 is returned if the option is not supported."
msgstr ""
"Если I<name> соответствует параметру, то возвращается положительное "
"значение, если параметр поддерживается и -1, если параметр не поддерживается."

#. type: Plain text
#: man-pages/man3/sysconf.3:366
msgid ""
"Otherwise, the current value of the option or limit is returned.  This value "
"will not be more restrictive than the corresponding value that was described "
"to the application in I<E<lt>unistd.hE<gt>> or I<E<lt>limits.hE<gt>> when "
"the application was compiled."
msgstr ""
"В противном случае возвращается текущее значение параметра или ограничителя. "
"Это значение будет не более ограничивающем чем соответствующее значение, "
"которое было показано приложению в I<E<lt>unistd.hE<gt>> или I<E<lt>limits."
"hE<gt>> при компиляции."

#. type: Plain text
#: man-pages/man3/sysconf.3:371
msgid "I<name> is invalid."
msgstr "Неверное значение I<name>."

#. type: tbl table
#: man-pages/man3/sysconf.3:381
#, no-wrap
msgid "B<sysconf>()"
msgstr "B<sysconf>()"

#. type: tbl table
#: man-pages/man3/sysconf.3:381
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: Plain text
#: man-pages/man3/sysconf.3:391
msgid ""
"It is difficult to use B<ARG_MAX> because it is not specified how much of "
"the argument space for B<exec>(3)  is consumed by the user's environment "
"variables."
msgstr ""
"Трудно использовать B<ARG_MAX>, так как не указано как много места под "
"аргумент B<exec>(3) потребляется пользовательскими переменными окружения."

#. type: Plain text
#: man-pages/man3/sysconf.3:394
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""
"Некоторые возвращаемые значения могут быть огромны; соответствующие им "
"объекты невозможно разместить в памяти."

#. type: Plain text
#: man-pages/man3/sysconf.3:402
msgid ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<confstr>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<posixoptions>(7)"
msgstr ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<confstr>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<posixoptions>(7)"

#. type: TH
#: man-pages/man3/strftime.3:37
#, no-wrap
msgid "STRFTIME"
msgstr "STRFTIME"

#. type: Plain text
#: man-pages/man3/strftime.3:40
msgid "strftime - format date and time"
msgstr "strftime - форматирование даты и времени"

#. type: Plain text
#: man-pages/man3/strftime.3:43
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr "B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strftime.3:46
#, no-wrap
msgid ""
"B<size_t strftime(char *>I<s>B<, size_t >I<max>B<, const char *>I<format>B<,>\n"
"B<                const struct tm *>I<tm>B<);>\n"
msgstr ""
"B<size_t strftime(char *>I<s>B<, size_t >I<max>B<, const char *>I<format>B<,>\n"
"B<                const struct tm *>I<tm>B<);>\n"

#.  FIXME . POSIX says: Local timezone information is used as though
#.  strftime() called tzset().  But this doesn't appear to be the case
#. type: Plain text
#: man-pages/man3/strftime.3:67
msgid ""
"The B<strftime>()  function formats the broken-down time I<tm> according to "
"the format specification I<format> and places the result in the character "
"array I<s> of size I<max>.  The broken-down time structure I<tm> is defined "
"in I<E<lt>time.hE<gt>>.  See also B<ctime>(3)."
msgstr ""
"Функция B<strftime>() преобразует время из структуры I<tm> в соответствии с "
"определённым форматом I<format> и помещает результат в символьный массив "
"I<s> размера I<max>. Структура I<tm> определена в I<E<lt>time.hE<gt>>. "
"Смотрите также B<ctime>(3)."

#. type: Plain text
#: man-pages/man3/strftime.3:76
msgid ""
"The format specification is a null-terminated string and may contain special "
"character sequences called I<conversion specifications>, each of which is "
"introduced by a \\(aq%\\(aq character and terminated by some other character "
"known as a I<conversion specifier character>.  All other character sequences "
"are I<ordinary character sequences>."
msgstr ""
"Формат представляет собой строку с null в конце, в которой могут содержаться "
"специальные символьные последовательности, называемые I<определителями "
"преобразования>, каждая из которых состоит из символа \\(aq%\\(aq и ещё "
"одного символа, называемого I<символом определителя преобразования>. Все "
"остальные символьные последовательности являются I<обычными символьными "
"последовательностями>."

#. type: Plain text
#: man-pages/man3/strftime.3:87
msgid ""
"The characters of ordinary character sequences (including the null byte)  "
"are copied verbatim from I<format> to I<s>.  However, the characters of "
"conversion specifications are replaced as shown in the list below.  In this "
"list, the field(s) employed from the I<tm> structure are also shown."
msgstr ""
"Символы из обычных символьных последовательностей (включая байт null) "
"копируются как есть из I<format> в I<s>. Однако, символы из определителей "
"преобразования заменяются согласно списку, представленному ниже. В этом "
"списке также показаны использованные поля из структуры I<tm>."

#. type: TP
#: man-pages/man3/strftime.3:87
#, no-wrap
msgid "B<%a>"
msgstr "B<%a>"

#. type: Plain text
#: man-pages/man3/strftime.3:92
msgid ""
"The abbreviated name of the day of the week according to the current "
"locale.  (Calculated from I<tm_wday>.)"
msgstr ""
"Сокращённое название дня недели в зависимости от текущей локали (вычисляется "
"из I<tm_wday>)."

#. type: TP
#: man-pages/man3/strftime.3:92
#, no-wrap
msgid "B<%A>"
msgstr "B<%A>"

#. type: Plain text
#: man-pages/man3/strftime.3:97
msgid ""
"The full name of the day of the week according to the current locale.  "
"(Calculated from I<tm_wday>.)"
msgstr ""
"Полное название дня недели в зависимости от текущей локали (вычисляется из "
"I<tm_wday>)."

#. type: TP
#: man-pages/man3/strftime.3:97
#, no-wrap
msgid "B<%b>"
msgstr "B<%b>"

#. type: Plain text
#: man-pages/man3/strftime.3:102
msgid ""
"The abbreviated month name according to the current locale.  (Calculated "
"from I<tm_mon>.)"
msgstr ""
"Сокращённое название месяца в зависимости от текущей локали (вычисляется из "
"I<tm_mon>)."

#. type: TP
#: man-pages/man3/strftime.3:102
#, no-wrap
msgid "B<%B>"
msgstr "B<%B>"

#. type: Plain text
#: man-pages/man3/strftime.3:107
msgid ""
"The full month name according to the current locale.  (Calculated from "
"I<tm_mon>.)"
msgstr ""
"Полное название месяца в зависимости от текущей локали (вычисляется из "
"I<tm_mon>)."

#. type: Plain text
#: man-pages/man3/strftime.3:110
msgid "The preferred date and time representation for the current locale."
msgstr "Предпочтительный формат даты и времени для текущей локали."

#. type: Plain text
#: man-pages/man3/strftime.3:115
msgid ""
"The century number (year/100) as a 2-digit integer. (SU)  (Calculated from "
"I<tm_year>.)"
msgstr ""
"Век (год/100) как целое двухразрядное число (SU, вычисляется из I<tm_year>)."

#. type: TP
#: man-pages/man3/strftime.3:115
#, no-wrap
msgid "B<%d>"
msgstr "B<%d>"

#. type: Plain text
#: man-pages/man3/strftime.3:120
msgid ""
"The day of the month as a decimal number (range 01 to 31).  (Calculated from "
"I<tm_mday>.)"
msgstr ""
"День месяца в десятичной форме (от 01 до 31) (вычисляется из I<tm_mday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:130
msgid ""
"Equivalent to B<%m/%d/%y>.  (Yecch\\(emfor Americans only.  Americans should "
"note that in other countries B<%d/%m/%y> is rather common.  This means that "
"in international context this format is ambiguous and should not be used.) "
"(SU)"
msgstr ""
"Эквивалентно  B<%m/%d/%y> (только для американцев, в других странах обычная "
"форма — B<%d/%m/%y>. Это означает, что международный контекст этого формата "
"сомнителен и лучше этот формат не использовать). (SU)"

#. type: TP
#: man-pages/man3/strftime.3:130
#, no-wrap
msgid "B<%e>"
msgstr "B<%e>"

#. type: Plain text
#: man-pages/man3/strftime.3:138
msgid ""
"Like B<%d>, the day of the month as a decimal number, but a leading zero is "
"replaced by a space. (SU)  (Calculated from I<tm_mday>.)"
msgstr ""
"То же, что и B<%d>: десятичное число, обозначающее номер дня месяца, но "
"вместо начального нуля ставится пробел (SU, вычисляется из I<tm_mday>)."

#. type: TP
#: man-pages/man3/strftime.3:138
#, no-wrap
msgid "B<%E>"
msgstr "B<%E>"

#. type: Plain text
#: man-pages/man3/strftime.3:141 man-pages/man3/strftime.3:224
msgid "Modifier: use alternative format, see below. (SU)"
msgstr "Модификатор: использовать другой формат, смотрите далее. (SU)"

#. type: Plain text
#: man-pages/man3/strftime.3:146
msgid "Equivalent to B<%Y-%m-%d> (the ISO\\ 8601 date format). (C99)"
msgstr "Эквивалентно B<%Y-%m-%d> (формат даты согласно ISO\\ 8601). (C99)"

#. type: Plain text
#: man-pages/man3/strftime.3:160
msgid ""
"The ISO\\ 8601 week-based year (see NOTES) with century as a decimal "
"number.  The 4-digit year corresponding to the ISO week number (see B<%V>).  "
"This has the same format and value as B<%Y>, except that if the ISO week "
"number belongs to the previous or next year, that year is used instead. "
"(TZ)  (Calculated from I<tm_year>, I<tm_yday>, and I<tm_wday>.)"
msgstr ""
"Год на основе недель с веком в виде десятичного числа, согласно ISO\\ 8601 "
"(смотрите ЗАМЕЧАНИЯ). Год как четырехзначное число, соответствующее номер "
"недели ISO (смотрите B<%V>). Это тот же формат и значение, что и B<%Y>, но "
"если номер недели ISO входит также в прошедший или последующий год, то в "
"этом случае отображается прошедший год (TZ, вычисляется из I<tm_wday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:170
msgid ""
"Like B<%G>, but without century, that is, with a 2-digit year (00\\(en99). "
"(TZ)  (Calculated from I<tm_year>, I<tm_yday>, and I<tm_wday>.)"
msgstr ""
"То же, что и B<%G>, но без века, то есть двухразрядное число года "
"(00\\(en99) (TZ, вычисляется из I<tm_wday>, I<tm_yday> и I<tm_wday>)."

#. type: TP
#: man-pages/man3/strftime.3:170
#, no-wrap
msgid "B<%h>"
msgstr "B<%h>"

#. type: Plain text
#: man-pages/man3/strftime.3:175
msgid "Equivalent to B<%b>.  (SU)"
msgstr "Эквивалентно B<%b>.  (SU)"

#. type: Plain text
#: man-pages/man3/strftime.3:180
msgid ""
"The hour as a decimal number using a 24-hour clock (range 00 to 23).  "
"(Calculated from I<tm_hour>.)"
msgstr ""
"Час как десятичное число в 24-часовых часах (от 00 до 23) (вычисляется из "
"I<tm_hour>)."

#. type: Plain text
#: man-pages/man3/strftime.3:185
msgid ""
"The hour as a decimal number using a 12-hour clock (range 01 to 12).  "
"(Calculated from I<tm_hour>.)"
msgstr ""
"Час как десятичное число в 12-часовых часах (от 01 до 12) (вычисляется из "
"I<tm_hour>)."

#. type: Plain text
#: man-pages/man3/strftime.3:190
msgid ""
"The day of the year as a decimal number (range 001 to 366).  (Calculated "
"from I<tm_yday>.)"
msgstr ""
"День года в десятичной форме (от 001 до 366) (вычисляется из I<tm_yday>)."

#. type: TP
#: man-pages/man3/strftime.3:190
#, no-wrap
msgid "B<%k>"
msgstr "B<%k>"

#. type: Plain text
#: man-pages/man3/strftime.3:199
msgid ""
"The hour (24-hour clock) as a decimal number (range 0 to 23); single digits "
"are preceded by a blank.  (See also B<%H>.)  (Calculated from I<tm_hour>.)  "
"(TZ)"
msgstr ""
"Час (24-часовые часы) в виде десятичного числа (от 0 до 23); цифры "
"предваряются пробелом (TZ, смотрите также B<%H>, вычисляется из I<tm_hour>)."

#. type: TP
#: man-pages/man3/strftime.3:199
#, no-wrap
msgid "B<%l>"
msgstr "B<%l>"

#. type: Plain text
#: man-pages/man3/strftime.3:208
msgid ""
"The hour (12-hour clock) as a decimal number (range 1 to 12); single digits "
"are preceded by a blank.  (See also B<%I>.)  (Calculated from I<tm_hour>.)  "
"(TZ)"
msgstr ""
"Час (12-часовые часы) в виде десятичного числа (от 1 до 12); цифры "
"предваряются пробелом (TZ, смотрите также B<%I>, вычисляется из I<tm_hour>)."

#. type: Plain text
#: man-pages/man3/strftime.3:213
msgid ""
"The month as a decimal number (range 01 to 12).  (Calculated from I<tm_mon>.)"
msgstr "Месяц в десятичной форме (от 01 до 12) (вычисляется из I<tm_mon>)."

#. type: Plain text
#: man-pages/man3/strftime.3:218
msgid ""
"The minute as a decimal number (range 00 to 59).  (Calculated from "
"I<tm_min>.)"
msgstr "Минута в десятичной форме (от 00 до 59) (вычисляется из I<tm_min>)."

#. type: Plain text
#: man-pages/man3/strftime.3:221
msgid "A newline character. (SU)"
msgstr "Символ новой строки. (SU)"

#. type: TP
#: man-pages/man3/strftime.3:221
#, no-wrap
msgid "B<%O>"
msgstr "B<%O>"

#. type: Plain text
#: man-pages/man3/strftime.3:231
msgid ""
"Either \"AM\" or \"PM\" according to the given time value, or the "
"corresponding strings for the current locale.  Noon is treated as \"PM\" and "
"midnight as \"AM\".  (Calculated from I<tm_hour>.)"
msgstr ""
"Или «AM» или «PM», в соответствии со значением времени, или соответствующая "
"строка из текущей локали. Полдень считается как «PM», а полночь как "
"«AM» (вычисляется из I<tm_hour>)."

#. type: TP
#: man-pages/man3/strftime.3:231
#, no-wrap
msgid "B<%P>"
msgstr "B<%P>"

#. type: Plain text
#: man-pages/man3/strftime.3:240
msgid ""
"Like B<%p> but in lowercase: \"am\" or \"pm\" or a corresponding string for "
"the current locale.  (Calculated from I<tm_hour>.)  (GNU)"
msgstr ""
"Подобно B<%p> но в нижнем регистре: «am» или «pm»  или соответствующая "
"строка из текущей локали (GNU, вычисляется из I<tm_hour>)."

#. type: Plain text
#: man-pages/man3/strftime.3:246
msgid ""
"The time in a.m. or p.m. notation.  In the POSIX locale this is equivalent "
"to B<%I:%M:%S %p>.  (SU)"
msgstr ""
"Время в формате с a.m. или p.m. notation. В локали POSIX это эквивалентно B<"
"%I:%M:%S %p>.  (SU)"

#. type: Plain text
#: man-pages/man3/strftime.3:254
msgid ""
"The time in 24-hour notation (B<%H:%M>).  (SU)  For a version including the "
"seconds, see B<%T> below."
msgstr ""
"Время в 24-часовом формате (B<%H:%M>). (SU) Версия с секундами описана для B<"
"%T> далее."

#. type: Plain text
#: man-pages/man3/strftime.3:259
msgid ""
"The number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC). "
"(TZ)  (Calculated from I<mktime(tm)>.)"
msgstr ""
"Количество секунд, которое прошло с начала эпохи, 1970-01-01 00:00:00 +0000 "
"(UTC, TZ, вычисляется из I<mktime(tm)>)."

#. type: Plain text
#: man-pages/man3/strftime.3:265
msgid ""
"The second as a decimal number (range 00 to 60).  (The range is up to 60 to "
"allow for occasional leap seconds.)  (Calculated from I<tm_sec>.)"
msgstr ""
"Секунда в виде десятичного числа (от 00 до 60) (диапазон до 60 включительно "
"позволяет учитывать високосные секунды, вычисляется из I<tm_sec>)."

#. type: Plain text
#: man-pages/man3/strftime.3:268
msgid "A tab character. (SU)"
msgstr "Символ табуляции. (SU)"

#. type: Plain text
#: man-pages/man3/strftime.3:273
msgid "The time in 24-hour notation (B<%H:%M:%S>).  (SU)"
msgstr "Время в 24-часовом формате (B<%H:%M:%S>). (SU)"

#. type: Plain text
#: man-pages/man3/strftime.3:281
msgid ""
"The day of the week as a decimal, range 1 to 7, Monday being 1.  See also B<"
"%w>.  (Calculated from I<tm_wday>.)  (SU)"
msgstr ""
"День недели в цифровом формате (от 1 до 7), понедельник это 1. Смотрите "
"также B<%w>. (SU, вычисляется из I<tm_wday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:294
msgid ""
"The week number of the current year as a decimal number, range 00 to 53, "
"starting with the first Sunday as the first day of week 01.  See also B<%V> "
"and B<%W>.  (Calculated from I<tm_yday> and I<tm_wday>.)"
msgstr ""
"Номер недели текущего года в виде десятичного числа (от 00 до 53), начиная с "
"первого воскресенья как первого дня недели 01. Смотрите также B<%V> и B<%W> "
"(вычисляется из I<tm_yday> и I<tm_wday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:309
msgid ""
"The ISO\\ 8601 week number (see NOTES) of the current year as a decimal "
"number, range 01 to 53, where week 1 is the first week that has at least 4 "
"days in the new year.  See also B<%U> and B<%W>.  (Calculated from "
"I<tm_year>, I<tm_yday>, and I<tm_wday>.)  (SU)"
msgstr ""
"Номер недели согласно ISO\\ 8601 (смотрите ЗАМЕЧАНИЯ) в текущем году в виде "
"десятичного числа (от 01 до 53), где неделя 1 это первая неделя, минимум 4 "
"дня которой находятся в новом году. Смотрите также B<%U> и B<%W> (SU, "
"вычисляется из I<tm_year>, I<tm_yday> и I<tm_wday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:316
msgid ""
"The day of the week as a decimal, range 0 to 6, Sunday being 0.  See also B<"
"%u>.  (Calculated from I<tm_wday>.)"
msgstr ""
"День недели в цифровом формате (от 0 до 6), понедельник это 0. Смотрите "
"также B<%u> (вычисляется из I<tm_wday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:324
msgid ""
"The week number of the current year as a decimal number, range 00 to 53, "
"starting with the first Monday as the first day of week 01.  (Calculated "
"from I<tm_yday> and I<tm_wday>.)"
msgstr ""
"Номер недели текущего года в виде десятичного числа (от 00 до 53), начиная с "
"первого понедельника как первого дня недели 01 (вычисляется из I<tm_yday> и "
"I<tm_wday>)."

#. type: Plain text
#: man-pages/man3/strftime.3:327
msgid ""
"The preferred date representation for the current locale without the time."
msgstr "Предпочтительный формат даты без времени для текущей локали."

#. type: Plain text
#: man-pages/man3/strftime.3:330
msgid ""
"The preferred time representation for the current locale without the date."
msgstr "Предпочтительный формат времени без даты для текущей локали."

#. type: Plain text
#: man-pages/man3/strftime.3:335
msgid ""
"The year as a decimal number without a century (range 00 to 99).  "
"(Calculated from I<tm_year>)"
msgstr ""
"Год без века в виде десятичного числа (от 00 до 99) (вычисляется из "
"I<tm_year>)."

#. type: Plain text
#: man-pages/man3/strftime.3:340
msgid ""
"The year as a decimal number including the century.  (Calculated from "
"I<tm_year>)"
msgstr "Год с веком в виде десятичного числа (вычисляется из I<tm_year>)."

#. type: Plain text
#: man-pages/man3/strftime.3:347
msgid ""
"The I<+hhmm> or I<-hhmm> numeric timezone (that is, the hour and minute "
"offset from UTC). (SU)"
msgstr ""
"Числовой часовой пояс I<+hhmm> или I<-hhmm> (то есть смещение часов и минут "
"относительно UTC). (SU)"

#. type: Plain text
#: man-pages/man3/strftime.3:350
msgid "The timezone name or abbreviation."
msgstr "Название или сокращение часового пояса."

#. type: TP
#: man-pages/man3/strftime.3:350
#, no-wrap
msgid "B<%+>"
msgstr "B<%+>"

#.  Nov 05 -- Not in Linux/glibc, but is in some BSDs (according to
#.  their man pages)
#. type: Plain text
#: man-pages/man3/strftime.3:358
msgid ""
"The date and time in B<date>(1)  format. (TZ)  (Not supported in glibc2.)"
msgstr "Дата и время в формате B<date>(1). (TZ) (не поддерживается в glibc2)"

#. type: Plain text
#: man-pages/man3/strftime.3:361
msgid "A literal \\(aq%\\(aq character."
msgstr "Символ \\(aq%\\(aq."

#. type: Plain text
#: man-pages/man3/strftime.3:397
msgid ""
"Some conversion specifications can be modified by preceding the conversion "
"specifier character by the B<E> or B<O> I<modifier> to indicate that an "
"alternative format should be used.  If the alternative format or "
"specification does not exist for the current locale, the behavior will be as "
"if the unmodified conversion specification were used. (SU)  The Single UNIX "
"Specification mentions B<%Ec>, B<%EC>, B<%Ex>, B<%EX>, B<%Ey>, B<%EY>, B<"
"%Od>, B<%Oe>, B<%OH>, B<%OI>, B<%Om>, B<%OM>, B<%OS>, B<%Ou>, B<%OU>, B<"
"%OV>, B<%Ow>, B<%OW>, B<%Oy>, where the effect of the B<O> modifier is to "
"use alternative numeric symbols (say, roman numerals), and that of the E "
"modifier is to use a locale-dependent alternative representation."
msgstr ""
"Некоторые определения преобразования могут быть изменены с помощью указания "
"перед символом определителя преобразования I<модификатора> B<E> или B<O>, "
"который указывает на необходимость использования альтернативного формата. "
"Если альтернативный формат или определение не существует в текущей локали, "
"то поведение будет таким же как если бы проводилось не изменённое "
"преобразование. (SU) В Single UNIX Specification упомянуты B<%Ec>, B<%EC>, B<"
"%Ex>, B<%EX>, B<%Ey>, B<%EY>, B<%Od>, B<%Oe>, B<%OH>, B<%OI>, B<%Om>, B<"
"%OM>, B<%OS>, B<%Ou>, B<%OU>, B<%OV>, B<%Ow>, B<%OW>, B<%Oy>, где "
"модификатор B<O> означает использование альтернативных численных символов "
"(например, римские цифры), а модификатор E отражает альтернативное "
"представление, зависящее от текущей локали."

#.  (This behavior applies since at least libc 4.4.4;
#.  very old versions of libc, such as libc 4.4.1,
#.  would return
#.  .I max
#.  if the array was too small.)
#. type: Plain text
#: man-pages/man3/strftime.3:417
msgid ""
"Provided that the result string, including the terminating null byte, does "
"not exceed I<max> bytes, B<strftime>()  returns the number of bytes "
"(excluding the terminating null byte)  placed in the array I<s>.  If the "
"length of the result string (including the terminating null byte)  would "
"exceed I<max> bytes, then B<strftime>()  returns 0, and the contents of the "
"array are undefined."
msgstr ""
"Предоставляя строку результата с завершающим байтом null, не превышающую "
"I<max> байт, функция B<strftime>() возвращает количество символов (без учёта "
"конечного байта null), помещённых в массив I<s>. Если длина строки "
"результата (включая завершающий байт null) превысила бы I<max> байт, то "
"B<strftime>() возвращает 0, а содержимое массива будет неопределенным."

#. type: Plain text
#: man-pages/man3/strftime.3:425
msgid ""
"Note that the return value 0 does not necessarily indicate an error.  For "
"example, in many locales B<%p> yields an empty string.  An empty I<format> "
"string will likewise yield an empty string."
msgstr ""
"Заметим, что возвращаемое значение 0 не всегда означает ошибку. Например, во "
"многих локалях B<%p> представляет собой пустую строку. Пустая строка "
"I<format> считается пустой строкой."

#. type: SH
#: man-pages/man3/strftime.3:425
#, no-wrap
msgid "ENVIRONMENT"
msgstr "ОКРУЖЕНИЕ"

#. type: Plain text
#: man-pages/man3/strftime.3:431
msgid "The environment variables B<TZ> and B<LC_TIME> are used."
msgstr "Используются переменные окружения B<TZ> и B<LC_TIME>."

#. type: tbl table
#: man-pages/man3/strftime.3:441
#, no-wrap
msgid "B<strftime>()"
msgstr "B<strftime>()"

#.  FIXME strftime() is in POSIX.1-2001 and POSIX.1-2008, but the details
#.  in the standards changed across versions. Investigate and
#.  write up.
#. type: Plain text
#: man-pages/man3/strftime.3:463
msgid ""
"SVr4, C89, C99.  There are strict inclusions between the set of conversions "
"given in ANSI C (unmarked), those given in the Single UNIX Specification "
"(marked SU), those given in Olson's timezone package (marked TZ), and those "
"given in glibc (marked GNU), except that B<%+> is not supported in glibc2.  "
"On the other hand glibc2 has several more extensions.  POSIX.1 only refers "
"to ANSI C; POSIX.2 describes under B<date>(1)  several extensions that could "
"apply to B<strftime>()  as well.  The B<%F> conversion is in C99 and "
"POSIX.1-2001."
msgstr ""
"SVr4, C89, C99. Большинство этих определителей поддерживаются стандартом "
"ANSI C (не помечен), Single UNIX Specification (помечен как SU), пакетом "
"часовых поясов Олсона (Olson) (помечен как TZ) и glibc (помечен как GNU), "
"кроме B<%+>, которое не поддерживается в glibc2. С другой стороны, в glibc2 "
"есть несколько дополнительных расширений. В POSIX.1 есть ссылка только на "
"ANSI C; в POSIX.2 описание B<date>(1) содержит несколько расширений, которые "
"можно применить и к B<strftime>(). Преобразование B<%F> есть в C99 и "
"POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/strftime.3:470
msgid ""
"In SUSv2, the B<%S> specifier allowed a range of 00 to 61, to allow for the "
"theoretical possibility of a minute that included a double leap second "
"(there never has been such a minute)."
msgstr ""
"В SUSv2 определитель B<%S> позволяет использовать диапазон от 00 до 61, что "
"даёт теоретическую возможность включать в минуту двойную високосную секунду "
"(такой минуты ещё никогда не было)."

#. type: SS
#: man-pages/man3/strftime.3:471
#, no-wrap
msgid "ISO 8601 week dates"
msgstr "Учёт недель в ISO 8601"

#. type: Plain text
#: man-pages/man3/strftime.3:496
msgid ""
"B<%G>, B<%g>, and B<%V> yield values calculated from the week-based year "
"defined by the ISO\\ 8601 standard.  In this system, weeks start on a "
"Monday, and are numbered from 01, for the first week, up to 52 or 53, for "
"the last week.  Week 1 is the first week where four or more days fall within "
"the new year (or, synonymously, week 01 is: the first week of the year that "
"contains a Thursday; or, the week that has 4 January in it).  When three of "
"fewer days of the first calendar week of the new year fall within that year, "
"then the ISO 8601 week-based system counts those days as part of week 53 of "
"the preceding year.  For example, 1 January 2010 is a Friday, meaning that "
"just three days of that calendar week fall in 2010.  Thus, the ISO\\ 8601 "
"week-based system considers these days to be part of week 53 (B<%V>)  of the "
"year 2009 (B<%G>); week 01 of ISO\\ 8601 year 2010 starts on Monday, 4 "
"January 2010."
msgstr ""
"Определители B<%G>, B<%g> и B<%V> заменяются значениями, вычисленными из "
"года на основе недели, который определяется стандартом ISO\\ 8601. В этой "
"системе недели начинаются с понедельника и нумеруются с 01 до 52 или 53. "
"Неделя 1 — это первая неделя, где четыре или более дней находятся в новом "
"году (иначе говоря, неделя 01 это первая неделя года, в которой есть "
"четверг; или неделя с 4 января). Если три или менее дней первой календарной "
"недели выпадают на новый год, то согласно системе счёта недель ISO 8601 эти "
"дни являются частью недели 53 предыдущего года. Например, 1 января 2010 это "
"пятница, то есть только три дня этой календарной недели выпадают на 2010. То "
"есть согласно системе недель ISO\\ 8601 эти три дня являются частью недели "
"53 (B<%V>) 2009 года (B<%G>); неделя 01 по ISO\\ 8601 для 2010 года "
"начинается с понедельника 4 января 2010 года."

#.  HP-UX and Tru64 also have features like this.
#. type: Plain text
#: man-pages/man3/strftime.3:512
msgid ""
"Glibc provides some extensions for conversion specifications.  (These "
"extensions are not specified in POSIX.1-2001, but a few other systems "
"provide similar features.)  Between the \\(aq%\\(aq character and the "
"conversion specifier character, an optional I<flag> and field I<width> may "
"be specified.  (These precede the B<E> or B<O> modifiers, if present.)"
msgstr ""
"В glibc есть несколько расширений определений преобразования (эти расширения "
"не входят в POSIX.1-2001, но в некоторых других системах есть подобные "
"возможности). Между символом \\(aq%\\(aq и символом определителя "
"преобразования может быть указан I<flag> и поле I<width> (и они указываются "
"до модификаторов B<E> или B<O>)."

#. type: Plain text
#: man-pages/man3/strftime.3:514
msgid "The following flag characters are permitted:"
msgstr "Допускаются следующие символьные флаги:"

#. type: TP
#: man-pages/man3/strftime.3:514
#, no-wrap
msgid "B<_>"
msgstr "B<_>"

#. type: Plain text
#: man-pages/man3/strftime.3:518
msgid "(underscore)  Pad a numeric result string with spaces."
msgstr "(подчёркивание) Дополнять строку числового результата пробелами."

#. type: Plain text
#: man-pages/man3/strftime.3:522
msgid "(dash)  Do not pad a numeric result string."
msgstr "(перенос) Не дополнять строку числового результата."

#. type: Plain text
#: man-pages/man3/strftime.3:526
msgid ""
"Pad a numeric result string with zeros even if the conversion specifier "
"character uses space-padding by default."
msgstr ""
"Дополнять строку числового результата нулями, даже если для символа "
"определителя преобразования по умолчанию используются пробелы для дополнения."

#. type: Plain text
#: man-pages/man3/strftime.3:529
msgid "Convert alphabetic characters in result string to uppercase."
msgstr "Преобразовывать алфавитные символы в строке результата в заглавные."

#. type: TP
#: man-pages/man3/strftime.3:529
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#: man-pages/man3/strftime.3:535
msgid ""
"Swap the case of the result string.  (This flag works only with certain "
"conversion specifier characters, and of these, it is only really useful with "
"B<%Z>.)"
msgstr ""
"Изменять регистр символов в строке результата на противоположный (этот флаг "
"работает только с некоторыми символами определителей преобразования, и среди "
"них действительно реально полезно только с B<%Z>)."

#. type: Plain text
#: man-pages/man3/strftime.3:539
msgid ""
"An optional decimal width specifier may follow the (possibly absent) flag.  "
"If the natural size of the field is smaller than this width, then the result "
"string is padded (on the left) to the specified width."
msgstr ""
"После флага (возможно отсутствующего) может быть указан десятичный "
"определитель ширины. Если реальный размер поля меньше чем эта ширина, то "
"строка результата дополняется (слева) до указанной ширины."

#. type: Plain text
#: man-pages/man3/strftime.3:557
msgid ""
"If the output string would exceed I<max> bytes, I<errno> is I<not> set.  "
"This makes it impossible to distinguish this error case from cases where the "
"I<format> string legitimately produces a zero-length output string.  "
"POSIX.1-2001 does I<not> specify any I<errno> settings for B<strftime>()."
msgstr ""
"Если строка результата превысила бы I<max> байт, значение I<errno> I<не> "
"изменяется. Это делает невозможным отличить данную ошибку от случая, когда "
"для строки I<format> обоснованно создаётся строка результата нулевой длины. "
"В POSIX.1-2001 I<не> определены какие-либо значения I<errno> для "
"B<strftime>()."

#. type: Plain text
#: man-pages/man3/strftime.3:572
msgid ""
"Some buggy versions of B<gcc>(1)  complain about the use of B<%c>: "
"I<warning: `%c' yields only last 2 digits of year in some locales>.  Of "
"course programmers are encouraged to use B<%c>, it gives the preferred date "
"and time representation.  One meets all kinds of strange obfuscations to "
"circumvent this B<gcc>(1)  problem.  A relatively clean one is to add an "
"intermediate function"
msgstr ""
"Некоторые дефектные версии B<gcc>(1) выдают сообщение об использовании B<"
"%c>: I<warning: `%c' yields only last 2 digits of year in some locales>. "
"Естественно, программистам предлагается использовать B<%c>, что даёт "
"предпочтительное представление даты и времени. Каждый, кто встречает "
"подобного вида странные путаницы, обходит эту проблему B<gcc>(1). "
"Относительно понятный способ — это добавить промежуточную функцию"

#. type: Plain text
#: man-pages/man3/strftime.3:581
#, no-wrap
msgid ""
"size_t\n"
"my_strftime(char *s, size_t max, const char *fmt,\n"
"            const struct tm *tm)\n"
"{\n"
"    return strftime(s, max, fmt, tm);\n"
"}\n"
msgstr ""
"size_t\n"
"my_strftime(char *s, size_t max, const char *fmt,\n"
"            const struct tm *tm)\n"
"{\n"
"    return strftime(s, max, fmt, tm);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/strftime.3:590
msgid ""
"Nowadays, B<gcc>(1)  provides the I<-Wno-format-y2k> option to prevent the "
"warning, so that the above workaround is no longer required."
msgstr ""
"В настоящее время, у B<gcc>(1) есть параметр I<-Wno-format-y2k>, который "
"отключает предупреждение, поэтому такой способ решения больше не нужен."

#. type: Plain text
#: man-pages/man3/strftime.3:593
msgid ""
"B<RFC\\ 2822-compliant date format> (with an English locale for %a and %b)"
msgstr "B<Формат даты согласно RFC\\ 2822> (в английской локали с %a и %b)"

#. type: Plain text
#: man-pages/man3/strftime.3:596
msgid "%a,\\ %d\\ %b\\ %Y\\ %T\\ %z"
msgstr "%a,\\ %d\\ %b\\ %Y\\ %T\\ %z"

#. type: Plain text
#: man-pages/man3/strftime.3:599
msgid ""
"B<RFC\\ 822-compliant date format> (with an English locale for %a and %b)"
msgstr "B<Формат даты согласно RFC\\ 822> (в английской локали с %a и %b)"

#. type: Plain text
#: man-pages/man3/strftime.3:602
msgid "%a,\\ %d\\ %b\\ %y\\ %T\\ %z"
msgstr "%a,\\ %d\\ %b\\ %y\\ %T\\ %z"

#. type: SS
#: man-pages/man3/strftime.3:602
#, no-wrap
msgid "Example program"
msgstr "Пример программы"

#. type: Plain text
#: man-pages/man3/strftime.3:605
msgid "The program below can be used to experiment with B<strftime>()."
msgstr ""
"Представленную ниже программу можно использовать для экспериментов с "
"B<strftime>()."

#. type: Plain text
#: man-pages/man3/strftime.3:609
msgid ""
"Some examples of the result string produced by the glibc implementation of "
"B<strftime>()  are as follows:"
msgstr ""
"Несколько примеров строк результата, созданных B<strftime>() в реализации "
"glibc:"

#. type: Plain text
#: man-pages/man3/strftime.3:618
#, no-wrap
msgid ""
"$B< ./a.out \\(aq%m\\(aq>\n"
"Result string is \"11\"\n"
"$B< ./a.out \\(aq%5m\\(aq>\n"
"Result string is \"00011\"\n"
"$B< ./a.out \\(aq%_5m\\(aq>\n"
"Result string is \"   11\"\n"
msgstr ""
"$B< ./a.out \\(aq%m\\(aq>\n"
"Строка результата: \"11\"\n"
"$B< ./a.out \\(aq%5m\\(aq>\n"
"Строка результата: \"00011\"\n"
"$B< ./a.out \\(aq%_5m\\(aq>\n"
"Строка результата: \"   11\"\n"

#. type: Plain text
#: man-pages/man3/strftime.3:626
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strftime.3:633
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char outstr[200];\n"
"    time_t t;\n"
"    struct tm *tmp;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char outstr[200];\n"
"    time_t t;\n"
"    struct tm *tmp;\n"

#. type: Plain text
#: man-pages/man3/strftime.3:640
#, no-wrap
msgid ""
"    t = time(NULL);\n"
"    tmp = localtime(&t);\n"
"    if (tmp == NULL) {\n"
"        perror(\"localtime\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    t = time(NULL);\n"
"    tmp = localtime(&t);\n"
"    if (tmp == NULL) {\n"
"        perror(\"localtime\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strftime.3:645
#, no-wrap
msgid ""
"    if (strftime(outstr, sizeof(outstr), argv[1], tmp) == 0) {\n"
"        fprintf(stderr, \"strftime returned 0\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (strftime(outstr, sizeof(outstr), argv[1], tmp) == 0) {\n"
"        fprintf(stderr, \"strftime вернула 0\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/strftime.3:649
#, no-wrap
msgid ""
"    printf(\"Result string is \\e\"%s\\e\"\\en\", outstr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Строка результата: \\e\"%s\\e\"\\en\", outstr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/strftime.3:656
msgid ""
"B<date>(1), B<time>(2), B<ctime>(3), B<setlocale>(3), B<sprintf>(3), "
"B<strptime>(3)"
msgstr ""
"B<date>(1), B<time>(2), B<ctime>(3), B<setlocale>(3), B<sprintf>(3), "
"B<strptime>(3)"

#. type: TH
#: man-pages/man3/sem_wait.3:26
#, no-wrap
msgid "SEM_WAIT"
msgstr "SEM_WAIT"

#. type: Plain text
#: man-pages/man3/sem_wait.3:29
msgid "sem_wait, sem_timedwait, sem_trywait - lock a semaphore"
msgstr "sem_wait, sem_timedwait, sem_trywait - блокирует семафор"

#. type: Plain text
#: man-pages/man3/sem_wait.3:34
#, no-wrap
msgid "B<int sem_wait(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_wait(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:36
#, no-wrap
msgid "B<int sem_trywait(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_trywait(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:38
#, no-wrap
msgid "B<int sem_timedwait(sem_t *>I<sem>B<, const struct timespec *>I<abs_timeout>B<);>\n"
msgstr "B<int sem_timedwait(sem_t *>I<sem>B<, const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:49
msgid "B<sem_timedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<sem_timedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/sem_wait.3:59
msgid ""
"B<sem_wait>()  decrements (locks) the semaphore pointed to by I<sem>.  If "
"the semaphore's value is greater than zero, then the decrement proceeds, and "
"the function returns, immediately.  If the semaphore currently has the value "
"zero, then the call blocks until either it becomes possible to perform the "
"decrement (i.e., the semaphore value rises above zero), or a signal handler "
"interrupts the call."
msgstr ""
"Функция B<sem_wait>() уменьшает (блокирует) семафор, на который указывает "
"I<sem>. Если значение семафор больше нуля, то выполняется уменьшение и "
"функция сразу завершается. Если значение семафора равно нулю, то вызов "
"блокируется до тех пор, пока не станет возможным выполнить уменьшение (т. "
"е., значение семафора не станет больше нуля), или пока не вызовется "
"обработчик сигнала."

#. type: Plain text
#: man-pages/man3/sem_wait.3:69
msgid ""
"B<sem_trywait>()  is the same as B<sem_wait>(), except that if the decrement "
"cannot be immediately performed, then call returns an error (I<errno> set to "
"B<EAGAIN>)  instead of blocking."
msgstr ""
"Функция B<sem_trywait>() подобна B<sem_wait>(), за исключением того, что "
"если уменьшение нельзя выполнить сразу, то вызов завершается с ошибкой "
"(I<errno> становится равным B<EAGAIN>), а не блокируется."

#. type: Plain text
#: man-pages/man3/sem_wait.3:82
msgid ""
"B<sem_timedwait>()  is the same as B<sem_wait>(), except that I<abs_timeout> "
"specifies a limit on the amount of time that the call should block if the "
"decrement cannot be immediately performed.  The I<abs_timeout> argument "
"points to a structure that specifies an absolute timeout in seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This "
"structure is defined as follows:"
msgstr ""
"Функция B<sem_timedwait>() подобна B<sem_wait>(), за исключением того, что в "
"I<abs_timeout> задаётся ограничение по количеству времени, на которое вызов "
"должен заблокироваться, если уменьшение невозможно выполнить сразу. Аргумент "
"I<abs_timeout> указывает на структуру, в которой задаётся абсолютное время "
"ожидания в секундах и наносекундах, начиная с эпохи, 1970-01-01 00:00:00 "
"+0000 (UTC). Эта структура определена следующим образом:"

#. type: Plain text
#: man-pages/man3/sem_wait.3:89
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;      /* Seconds */\n"
"    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;      /* секунды */\n"
"    long   tv_nsec;     /* наносекунды [0 .. 999999999] */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:100
msgid ""
"If the timeout has already expired by the time of the call, and the "
"semaphore could not be locked immediately, then B<sem_timedwait>()  fails "
"with a timeout error (I<errno> set to B<ETIMEDOUT>)."
msgstr ""
"Если на момент вызова время ожидания уже истекло и семафор нельзя "
"заблокировать сразу, то B<sem_timedwait>() завершается с ошибкой просрочки "
"(I<errno> становится равным B<ETIMEDOUT>)."

#. type: Plain text
#: man-pages/man3/sem_wait.3:108
msgid ""
"If the operation can be performed immediately, then B<sem_timedwait>()  "
"never fails with a timeout error, regardless of the value of "
"I<abs_timeout>.  Furthermore, the validity of I<abs_timeout> is not checked "
"in this case."
msgstr ""
"Если операцию можно выполнить сразу, то B<sem_timedwait>() никогда не "
"завершится с ошибкой просрочки, независимо от значения I<abs_timeout>. Кроме "
"того, в этом случае не проверяется корректность I<abs_timeout>."

#. type: Plain text
#: man-pages/man3/sem_wait.3:114
msgid ""
"All of these functions return 0 on success; on error, the value of the "
"semaphore is left unchanged, -1 is returned, and I<errno> is set to indicate "
"the error."
msgstr ""
"При успешном выполнении все функции возвращают 0; при ошибке значение "
"семафора не изменяется, возвращается -1, а в I<errno> указывается причина "
"ошибки."

#. type: Plain text
#: man-pages/man3/sem_wait.3:119
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr "Вызов был прерван обработчиком сигнала; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/sem_wait.3:126
msgid "The following additional error can occur for B<sem_trywait>():"
msgstr "В B<sem_trywait>() может возникать следующая дополнительная ошибка:"

#. type: Plain text
#: man-pages/man3/sem_wait.3:130
msgid ""
"The operation could not be performed without blocking (i.e., the semaphore "
"currently has the value zero)."
msgstr ""
"Операция не может быть выполнена без блокировки (т. е., значение семафор "
"равно нулю)."

#. type: Plain text
#: man-pages/man3/sem_wait.3:133
msgid "The following additional errors can occur for B<sem_timedwait>():"
msgstr "В B<sem_timedwait>() дополнительно могут возникать следующие ошибки:"

#. type: Plain text
#: man-pages/man3/sem_wait.3:138
msgid ""
"The value of I<abs_timeout.tv_nsecs> is less than 0, or greater than or "
"equal to 1000 million."
msgstr ""
"Значение I<abs_timeout.tv_nsecs> меньше 0, или больше или равно 1000 "
"миллионов."

#. type: TP
#: man-pages/man3/sem_wait.3:138
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#.  POSIX.1-2001 also allows EDEADLK -- "A deadlock condition
#.  was detected", but this does not occur on Linux(?).
#. type: Plain text
#: man-pages/man3/sem_wait.3:143
msgid "The call timed out before the semaphore could be locked."
msgstr "Истёк период ожидания в вызове раньше возможности блокировки семафора."

#. type: tbl table
#: man-pages/man3/sem_wait.3:155
#, no-wrap
msgid ""
"B<sem_wait>(),\n"
"B<sem_trywait>(),\n"
"B<sem_timedwait>()"
msgstr ""
"B<sem_wait>(),\n"
"B<sem_trywait>(),\n"
"B<sem_timedwait>()"

#. type: Plain text
#: man-pages/man3/sem_wait.3:178
msgid ""
"The (somewhat trivial) program shown below operates on an unnamed "
"semaphore.  The program expects two command-line arguments.  The first "
"argument specifies a seconds value that is used to set an alarm timer to "
"generate a B<SIGALRM> signal.  This handler performs a B<sem_post>(3)  to "
"increment the semaphore that is being waited on in I<main()> using "
"B<sem_timedwait>().  The second command-line argument specifies the length "
"of the timeout, in seconds, for B<sem_timedwait>().  The following shows "
"what happens on two different runs of the program:"
msgstr ""
"Программа (несколько упрощённая), показанная ниже, работает с безымянным "
"семафором. Она ожидает два аргумента командной строки. В первом аргументе "
"задаётся значение в секундах, которое используется в будильнике для "
"генерации сигнала B<SIGALRM>. Этот обработчик выполняет B<sem_post>(3) для "
"увеличения семафора, которого ждёт в I<main()> вызов B<sem_timedwait>(). Во "
"втором аргументе задаётся период ожидания в секундах для B<sem_timedwait>(). "
"Далее показано что происходит в двух разных запусках программы:"

#. type: Plain text
#: man-pages/man3/sem_wait.3:188
#, no-wrap
msgid ""
"$B< ./a.out 2 3>\n"
"About to call sem_timedwait()\n"
"sem_post() from handler\n"
"sem_timedwait() succeeded\n"
"$B< ./a.out 2 1>\n"
"About to call sem_timedwait()\n"
"sem_timedwait() timed out\n"
msgstr ""
"$B< ./a.out 2 3>\n"
"About to call sem_timedwait()\n"
"sem_post() из обработчика\n"
"sem_timedwait() выполнена успешно\n"
"$B< ./a.out 2 1>\n"
"About to call sem_timedwait()\n"
"истекло время ожидания sem_timedwait()\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:201
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:203
#, no-wrap
msgid "sem_t sem;\n"
msgstr "sem_t sem;\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:216
#, no-wrap
msgid ""
"static void\n"
"handler(int sig)\n"
"{\n"
"    write(STDOUT_FILENO, \"sem_post() from handler\\en\", 24);\n"
"    if (sem_post(&sem) == -1) {\n"
"        write(STDERR_FILENO, \"sem_post() failed\\en\", 18);\n"
"        _exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""
"static void\n"
"handler(int sig)\n"
"{\n"
"    write(STDOUT_FILENO, \"sem_post() из обработчика\\en\", 24);\n"
"    if (sem_post(&sem) == -1) {\n"
"        write(STDERR_FILENO, \"ошибка sem_post()\\en\", 18);\n"
"        _exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:223
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sigaction sa;\n"
"    struct timespec ts;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sigaction sa;\n"
"    struct timespec ts;\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:229
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>alarm-secsE<gt> E<lt>wait-secsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>alarm-secsE<gt> E<lt>wait-secsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:232
#, no-wrap
msgid ""
"    if (sem_init(&sem, 0, 0) == -1)\n"
"        handle_error(\"sem_init\");\n"
msgstr ""
"    if (sem_init(&sem, 0, 0) == -1)\n"
"        handle_error(\"sem_init\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:234
#, no-wrap
msgid "    /* Establish SIGALRM handler; set alarm timer using argv[1] */\n"
msgstr ""
"    /* установка обработчика SIGALRM; зададим таймер будильника,\n"
"       используя argv[1] */\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:240
#, no-wrap
msgid ""
"    sa.sa_handler = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_flags = 0;\n"
"    if (sigaction(SIGALRM, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""
"    sa.sa_handler = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_flags = 0;\n"
"    if (sigaction(SIGALRM, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:242
#, no-wrap
msgid "    alarm(atoi(argv[1]));\n"
msgstr "    alarm(atoi(argv[1]));\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:245
#, no-wrap
msgid ""
"    /* Calculate relative interval as current time plus\n"
"       number of seconds given argv[2] */\n"
msgstr ""
"    /* вычисляем относительный интервал как текущее время плюс\n"
"       количество секунд из argv[2] */\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:248
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:250
#, no-wrap
msgid "    ts.tv_sec += atoi(argv[2]);\n"
msgstr "    ts.tv_sec += atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:254
#, no-wrap
msgid ""
"    printf(\"main() about to call sem_timedwait()\\en\");\n"
"    while ((s = sem_timedwait(&sem, &ts)) == -1 && errno == EINTR)\n"
"        continue;       /* Restart if interrupted by handler */\n"
msgstr ""
"    printf(\"в main() вызывается sem_timedwait()\\en\");\n"
"    while ((s = sem_timedwait(&sem, &ts)) == -1 && errno == EINTR)\n"
"        continue;       /* перезапускаем, если прервано обработчиком */\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:256
#, no-wrap
msgid "    /* Check what happened */\n"
msgstr "    /* проверяем  что произошло */\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:264
#, no-wrap
msgid ""
"    if (s == -1) {\n"
"        if (errno == ETIMEDOUT)\n"
"            printf(\"sem_timedwait() timed out\\en\");\n"
"        else\n"
"            perror(\"sem_timedwait\");\n"
"    } else\n"
"        printf(\"sem_timedwait() succeeded\\en\");\n"
msgstr ""
"    if (s == -1) {\n"
"        if (errno == ETIMEDOUT)\n"
"            printf(\"истекло время ожидания sem_timedwait()\\en\");\n"
"        else\n"
"            perror(\"sem_timedwait\");\n"
"    } else\n"
"        printf(\"sem_timedwait() выполнена успешно\\en\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:267
#, no-wrap
msgid ""
"    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:273
msgid ""
"B<clock_gettime>(2), B<sem_getvalue>(3), B<sem_post>(3), B<sem_overview>(7), "
"B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<sem_getvalue>(3), B<sem_post>(3), B<sem_overview>(7), "
"B<time>(7)"

#. type: TH
#: man-pages/man3/sqrt.3:34
#, no-wrap
msgid "SQRT"
msgstr "SQRT"

#. type: Plain text
#: man-pages/man3/sqrt.3:37
msgid "sqrt, sqrtf, sqrtl - square root function"
msgstr "sqrt, sqrtf, sqrtl - функция извлечения квадратного корня"

#. type: Plain text
#: man-pages/man3/sqrt.3:44
#, no-wrap
msgid ""
"B<double sqrt(double >I<x>B<);>\n"
"B<float sqrtf(float >I<x>B<);>\n"
"B<long double sqrtl(long double >I<x>B<);>\n"
msgstr ""
"B<double sqrt(double >I<x>B<);>\n"
"B<float sqrtf(float >I<x>B<);>\n"
"B<long double sqrtl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sqrt.3:56
msgid "B<sqrtf>(), B<sqrtl>():"
msgstr "B<sqrtf>(), B<sqrtl>():"

#. type: Plain text
#: man-pages/man3/sqrt.3:65
msgid "These functions return the nonnegative square root of I<x>."
msgstr "Данные функции возвращают неотрицательный квадратный корень от I<x>."

#. type: Plain text
#: man-pages/man3/sqrt.3:68
msgid "On success, these functions return the square root of I<x>."
msgstr "В случае успеха эти функции возвращают квадратный корень от I<x>."

#. type: Plain text
#: man-pages/man3/sqrt.3:80
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности, то будет возвращена плюс "
"бесконечность."

#. type: Plain text
#: man-pages/man3/sqrt.3:86
msgid "If I<x> is less than -0, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> меньше -0, то будет сгенерирована ошибка выхода за пределы "
"области, а в качестве результата будет возвращено NaN."

#. type: TP
#: man-pages/man3/sqrt.3:93
#, no-wrap
msgid "Domain error: I<x> less than -0"
msgstr "Ошибка области: I<x> меньше -0"

#. type: Plain text
#: man-pages/man3/sqrt.3:101
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM>. Вызывается исключение неправильной "
"плавающей точки (B<FE_INVALID>)."

#. type: tbl table
#: man-pages/man3/sqrt.3:113
#, no-wrap
msgid ""
"B<sqrt>(),\n"
"B<sqrtf>(),\n"
"B<sqrtl>()"
msgstr ""
"B<sqrt>(),\n"
"B<sqrtf>(),\n"
"B<sqrtl>()"

#. type: Plain text
#: man-pages/man3/sqrt.3:125
msgid "B<cbrt>(3), B<csqrt>(3), B<hypot>(3)"
msgstr "B<cbrt>(3), B<csqrt>(3), B<hypot>(3)"

#. type: TH
#: man-pages/man3/strcpy.3:35
#, no-wrap
msgid "STRCPY"
msgstr "STRCPY"

#. type: Plain text
#: man-pages/man3/strcpy.3:38
msgid "strcpy, strncpy - copy a string"
msgstr "strcpy, strncpy - копирование строки"

#. type: Plain text
#: man-pages/man3/strcpy.3:43
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:45
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:59
msgid ""
"The B<strcpy>()  function copies the string pointed to by I<src>, including "
"the terminating null byte (\\(aq\\e0\\(aq), to the buffer pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy.  I<Beware of buffer overruns!> "
"(See BUGS.)"
msgstr ""
"Функция B<strcpy>() копирует строку (включая завершающий нулевой байт \\(aq"
"\\e0\\(aq), указанную в указателе I<src>, в буфер, указанный в указателе "
"I<dest>. Строки не могут пересекаться, а строка в назначении I<dest> должна "
"быть достаточно большой, чтобы принять копию. I<Берегитесь переполнения "
"буфера> (См. ОШИБКИ)!"

#. type: Plain text
#: man-pages/man3/strcpy.3:76
msgid ""
"The B<strncpy>()  function is similar, except that at most I<n> bytes of "
"I<src> are copied.  B<Warning>: If there is no null byte among the first "
"I<n> bytes of I<src>, the string placed in I<dest> will not be null-"
"terminated."
msgstr ""
"Функция B<strncpy>() сходна, за исключением того, что скопировано будет "
"только первые I<n> байт из I<src>.  B<Внимание>: если в первых I<n> байт из "
"I<src> не окажется нулевого байта, то строка в I<dest> также не будет "
"завершена нулевым байтом."

#. type: Plain text
#: man-pages/man3/strcpy.3:87
msgid ""
"If the length of I<src> is less than I<n>, B<strncpy>()  writes additional "
"null bytes to I<dest> to ensure that a total of I<n> bytes are written."
msgstr ""
"Если длина I<src> меньше I<n>, B<strncpy>() дописывает в  I<dest> нулевые "
"байты, чтобы убедиться, что всего было записано I<n> байт."

#. type: Plain text
#: man-pages/man3/strcpy.3:91
msgid "A simple implementation of B<strncpy>()  might be:"
msgstr "Простейшей реализацией B<strncpy>() может быть:"

#. type: Plain text
#: man-pages/man3/strcpy.3:98
#, no-wrap
msgid ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"
msgstr ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:103
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:116
msgid ""
"The B<strcpy>()  and B<strncpy>()  functions return a pointer to the "
"destination string I<dest>."
msgstr ""
"Функции B<strcpy>() и B<strncpy>() возвращают указатель на скопированную "
"строку I<dest>."

#. type: tbl table
#: man-pages/man3/strcpy.3:127
#, no-wrap
msgid ""
"B<strcpy>(),\n"
"B<strncpy>()"
msgstr ""
"B<strcpy>(),\n"
"B<strncpy>()"

#. type: Plain text
#: man-pages/man3/strcpy.3:144
msgid ""
"Some programmers consider B<strncpy>()  to be inefficient and error prone.  "
"If the programmer knows (i.e., includes code to test!)  that the size of "
"I<dest> is greater than the length of I<src>, then B<strcpy>()  can be used."
msgstr ""
"Некоторые программисты считают B<strncpy>() неэффективной и склонной к "
"ошибкам. Если программист точно знает (в том числе с помощью проверок в "
"коде), что размер I<dest> больше I<src>, то B<strcpy>() может быть "
"использована."

#. type: Plain text
#: man-pages/man3/strcpy.3:153
msgid ""
"One valid (and intended) use of B<strncpy>()  is to copy a C string to a "
"fixed-length buffer while ensuring both that the buffer is not overflowed "
"and that unused bytes in the destination buffer are zeroed out (perhaps to "
"prevent information leaks if the buffer is to be written to media or "
"transmitted to another process via an interprocess communication technique)."
msgstr ""
"Единственным правильным (и предполагаемым) использованием B<strncpy>() "
"является копирование C-строки в буфер фиксированной длины с одновременной "
"проверкой того, что буфер не переполнен и неиспользованные байты в буфере "
"назначения обнулены (для исключения возможной утечки информации в случае, "
"если буфер будет записан на носитель или передан другому процессу через "
"межпроцессовое общение)."

#. type: Plain text
#: man-pages/man3/strcpy.3:166
msgid ""
"If there is no terminating null byte in the first I<n> bytes of I<src>, "
"B<strncpy>()  produces an unterminated string in I<dest>.  If I<buf> has "
"length I<buflen>, you can force termination using something like the "
"following:"
msgstr ""
"Если в первых I<n> байт I<src> не будет завершающего нулевого байта, "
"B<strncpy>() создаст ничем не ограниченную строку в I<dest>. Если размер "
"I<buf> равен I<buflen>, вы можете принудительно завершить строку с помощью "
"следующего кода:"

#. type: Plain text
#: man-pages/man3/strcpy.3:173
#, no-wrap
msgid ""
"if (buflen E<gt> 0) {\n"
"    strncpy(buf, str, buflen - 1);\n"
"    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"
"}\n"
msgstr ""
"if (buflen E<gt> 0) {\n"
"    strncpy(buf, str, buflen - 1);\n"
"    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:183
msgid ""
"(Of course, the above technique ignores the fact that, if I<src> contains "
"more than I<buflen\\ -\\ 1> bytes, information is lost in the copying to "
"I<dest>.)"
msgstr ""
"Конечно же, вышеприведенный пример не учитывает того, что если размер I<src> "
"больше I<buflen\\ -\\ 1> байт, при копировании в I<dest> будет потеряна "
"часть информации."

#. type: SS
#: man-pages/man3/strcpy.3:183
#, no-wrap
msgid "strlcpy()"
msgstr "strlcpy()"

#. type: Plain text
#: man-pages/man3/strcpy.3:187
#, no-wrap
msgid "    size_t strlcpy(char *dest, const char *src, size_t size);\n"
msgstr "    size_t strlcpy(char *dest, const char *src, size_t size);\n"

#.  http://static.usenix.org/event/usenix99/full_papers/millert/millert_html/index.html
#.      "strlcpy and strlcat - consistent, safe, string copy and concatenation"
#.      1999 USENIX Annual Technical Conference
#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: man-pages/man3/strcpy.3:222
msgid ""
"This function is similar to B<strncpy>(), but it copies at most I<size-1> "
"bytes to I<dest>, always adds a terminating null byte, and does not pad the "
"destination with (further) null bytes.  This function fixes some of the "
"problems of B<strcpy>()  and B<strncpy>(), but the caller must still handle "
"the possibility of data loss if I<size> is too small.  The return value of "
"the function is the length of I<src>, which allows truncation to be easily "
"detected: if the return value is greater than or equal to I<size>, "
"truncation occurred.  If loss of data matters, the caller I<must> either "
"check the arguments before the call, or test the function return value.  "
"B<strlcpy>()  is not present in glibc and is not standardized by POSIX, but "
"is available on Linux via the I<libbsd> library."
msgstr ""
"Эта функция подобна B<strncpy>(), но копирует не более I<size-1> байт в "
"I<dest>, всегда добавляет конечный байт null и не дополняет назначение "
"(помимо этого) байтами null. В данной функции исправлены некоторые проблемы "
"B<strcpy>() и B<strncpy>(), но вызывающий по-прежнему должен обрабатывать "
"возможность потери данных, если значение I<size> окажется слишком мало. "
"Возвращаемое значение функции — длина I<src>, что позволяет легко обнаружить "
"усечение: если возвращаемое значение больше или равно I<size>, то "
"выполнялось усечение. Если потеря данных неприемлема, то вызывающий "
"I<должен> или проверять аргументы перед вызовом, или проверять возвращаемое "
"значение. Функция B<strlcpy>() отсутствует в glibc и не стандартизована в "
"POSIX, но доступна в Linux из библиотеки I<libbsd>."

#. type: Plain text
#: man-pages/man3/strcpy.3:233
msgid ""
"If the destination string of a B<strcpy>()  is not large enough, then "
"anything might happen.  Overflowing fixed-length string buffers is a "
"favorite cracker technique for taking complete control of the machine.  Any "
"time a program reads or copies data into a buffer, the program first needs "
"to check that there's enough space.  This may be unnecessary if you can show "
"that overflow is impossible, but be careful: programs can get changed over "
"time, in ways that may make the impossible possible."
msgstr ""
"Если строка назначения B<strcpy>() недостаточно велика, то может случиться "
"всё что угодно. Переполнение буферных строк фиксированной длины является "
"излюбленным методом взломщиков для захвата управления машиной. Каждый раз "
"когда программа читает или копирует данные в буфер, сначала нужно проверять "
"достаточно ли места. Это может необязательным, если вы можете доказать, что "
"переполнение невозможно, но будьте осторожны: со временем программы могут "
"измениться и невозможное станет возможным."

#. type: Plain text
#: man-pages/man3/strcpy.3:243
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"
