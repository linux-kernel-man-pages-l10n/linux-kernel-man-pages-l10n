# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:25+0300\n"
"PO-Revision-Date: 2019-08-26 06:20+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Hindi (India) (http://www.transifex.com/kruvalig/man-pages/language/hi_IN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: hi_IN\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "FULL"
msgstr ""

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man4/full.4:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:29
msgid "full - always full device"
msgstr ""

#. type: SH
#: man-pages/man4/full.4:29
#, no-wrap
msgid "CONFIGURATION"
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:34
msgid ""
"If your system does not have I</dev/full> created already, it can be created"
" with the following commands:"
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:39
#, no-wrap
msgid ""
"mknod -m 666 /dev/full c 1 7\n"
"chown root:root /dev/full\n"
msgstr ""

#. type: SH
#: man-pages/man4/full.4:41
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:46
msgid ""
"The file I</dev/full> has major device number 1 and minor device number 7."
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:53
msgid ""
"Writes to the I</dev/full> device fail with an B<ENOSPC> error.  This can be"
" used to test how a program handles disk-full errors."
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:57
msgid "Reads from the I</dev/full> device will return \\e0 characters."
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:61
msgid "Seeks on I</dev/full> will always succeed."
msgstr ""

#. type: SH
#: man-pages/man4/full.4:61
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:63
msgid "I</dev/full>"
msgstr ""

#. type: SH
#: man-pages/man4/full.4:63
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man4/full.4:66
msgid "B<mknod>(1), B<null>(4), B<zero>(4)"
msgstr ""

#. type: TH
#: man-pages/man4/fd.4:28
#, no-wrap
msgid "FD"
msgstr ""

#. type: TH
#: man-pages/man4/fd.4:28
#, no-wrap
msgid "2014-05-10"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:31
msgid "fd - floppy disk device"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:48
msgid ""
"Floppy drives are block devices with major number 2.  Typically they are "
"owned by root:floppy (i.e., user root, group floppy) and have either mode "
"0660 (access checking via group membership) or mode 0666 (everybody has "
"access).  The minor numbers encode the device type, drive number, and "
"controller number.  For each device type (that is, combination of density "
"and track count)  there is a base minor number.  To this base number, add "
"the drive's number on its controller and 128 if the drive is on the "
"secondary controller.  In the following device tables, I<n> represents the "
"drive number."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:55
msgid ""
"B<Warning: if you use formats with more tracks than supported by your drive,"
" you may cause it mechanical damage.> Trying once if more tracks than the "
"usual 40/80 are supported should not damage it, but no warranty is given for"
" that.  If you are not sure, don't create device entries for those formats, "
"so as to prevent their usage."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:58
msgid ""
"Drive-independent device files which automatically detect the media format "
"and capacity:"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:61 man-pages/man4/fd.4:71 man-pages/man4/fd.4:81
#: man-pages/man4/fd.4:100 man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Name"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:61 man-pages/man4/fd.4:71 man-pages/man4/fd.4:81
#: man-pages/man4/fd.4:100 man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Base"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:62 man-pages/man4/fd.4:72 man-pages/man4/fd.4:82
#: man-pages/man4/fd.4:101 man-pages/man4/fd.4:115 man-pages/man4/fd.4:136
#, no-wrap
msgid "minor #"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:63 man-pages/man4/fd.4:73 man-pages/man4/fd.4:83
#: man-pages/man4/fd.4:102 man-pages/man4/fd.4:116 man-pages/man4/fd.4:137
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:64
#, no-wrap
msgid "B<fd>I<n>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:64
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:68
msgid "5.25 inch double-density device files:"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Capacity"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Cyl."
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Sect."
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Heads"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:72 man-pages/man4/fd.4:82 man-pages/man4/fd.4:101
#: man-pages/man4/fd.4:115 man-pages/man4/fd.4:136
#, no-wrap
msgid "KiB"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:74
#, no-wrap
msgid "B<fd>I<n>B<d360>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:103
#: man-pages/man4/fd.4:117
#, no-wrap
msgid "360"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:90
#: man-pages/man4/fd.4:117 man-pages/man4/fd.4:140
#, no-wrap
msgid "40"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:87
#: man-pages/man4/fd.4:103 man-pages/man4/fd.4:104 man-pages/man4/fd.4:117
#: man-pages/man4/fd.4:118
#, no-wrap
msgid "9"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:85
#: man-pages/man4/fd.4:86 man-pages/man4/fd.4:87 man-pages/man4/fd.4:88
#: man-pages/man4/fd.4:89 man-pages/man4/fd.4:90 man-pages/man4/fd.4:91
#: man-pages/man4/fd.4:92 man-pages/man4/fd.4:93 man-pages/man4/fd.4:104
#: man-pages/man4/fd.4:105 man-pages/man4/fd.4:106 man-pages/man4/fd.4:107
#: man-pages/man4/fd.4:117 man-pages/man4/fd.4:118 man-pages/man4/fd.4:119
#: man-pages/man4/fd.4:120 man-pages/man4/fd.4:121 man-pages/man4/fd.4:122
#: man-pages/man4/fd.4:123 man-pages/man4/fd.4:124 man-pages/man4/fd.4:125
#: man-pages/man4/fd.4:126 man-pages/man4/fd.4:127 man-pages/man4/fd.4:128
#: man-pages/man4/fd.4:138 man-pages/man4/fd.4:139 man-pages/man4/fd.4:140
#: man-pages/man4/fd.4:141 man-pages/man4/fd.4:142
#, no-wrap
msgid "2"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:74
#, no-wrap
msgid "4"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:78
msgid "5.25 inch high-density device files:"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:84
#, no-wrap
msgid "B<fd>I<n>B<h360>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:84 man-pages/man4/fd.4:93 man-pages/man4/fd.4:122
#, no-wrap
msgid "20"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "B<fd>I<n>B<h410>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "410"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "41"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:85 man-pages/man4/fd.4:86 man-pages/man4/fd.4:105
#: man-pages/man4/fd.4:119 man-pages/man4/fd.4:120
#, no-wrap
msgid "10"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:85 man-pages/man4/fd.4:142
#, no-wrap
msgid "48"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "B<fd>I<n>B<h420>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "420"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "42"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "64"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:87
#, no-wrap
msgid "B<fd>I<n>B<h720>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:87 man-pages/man4/fd.4:104 man-pages/man4/fd.4:118
#, no-wrap
msgid "720"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:87 man-pages/man4/fd.4:88 man-pages/man4/fd.4:89
#: man-pages/man4/fd.4:90 man-pages/man4/fd.4:93 man-pages/man4/fd.4:103
#: man-pages/man4/fd.4:104 man-pages/man4/fd.4:105 man-pages/man4/fd.4:106
#: man-pages/man4/fd.4:107 man-pages/man4/fd.4:118 man-pages/man4/fd.4:121
#: man-pages/man4/fd.4:122 man-pages/man4/fd.4:123 man-pages/man4/fd.4:126
#: man-pages/man4/fd.4:127 man-pages/man4/fd.4:128 man-pages/man4/fd.4:138
#: man-pages/man4/fd.4:139 man-pages/man4/fd.4:140 man-pages/man4/fd.4:141
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "80"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:87 man-pages/man4/fd.4:128
#, no-wrap
msgid "24"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:88
#, no-wrap
msgid "B<fd>I<n>B<h880>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:88
#, no-wrap
msgid "880"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:88
#, no-wrap
msgid "11"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "B<fd>I<n>B<h1200>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "1200"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "15"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "8"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:90
#, no-wrap
msgid "B<fd>I<n>B<h1440>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:90 man-pages/man4/fd.4:121
#, no-wrap
msgid "1440"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:90 man-pages/man4/fd.4:91 man-pages/man4/fd.4:92
#: man-pages/man4/fd.4:121
#, no-wrap
msgid "18"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:91
#, no-wrap
msgid "B<fd>I<n>B<h1476>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:91
#, no-wrap
msgid "1476"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:91 man-pages/man4/fd.4:119 man-pages/man4/fd.4:124
#, no-wrap
msgid "82"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:91
#, no-wrap
msgid "56"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:92
#, no-wrap
msgid "B<fd>I<n>B<h1494>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:92
#, no-wrap
msgid "1494"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:92 man-pages/man4/fd.4:120 man-pages/man4/fd.4:125
#, no-wrap
msgid "83"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:92
#, no-wrap
msgid "72"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:93
#, no-wrap
msgid "B<fd>I<n>B<h1600>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:93 man-pages/man4/fd.4:122
#, no-wrap
msgid "1600"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:93
#, no-wrap
msgid "92"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:97
msgid "3.5 inch double-density device files:"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:103 man-pages/man4/fd.4:117
#, no-wrap
msgid "B<fd>I<n>B<u360>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:103
#, no-wrap
msgid "1"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:103 man-pages/man4/fd.4:117
#, no-wrap
msgid "12"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:104 man-pages/man4/fd.4:118
#, no-wrap
msgid "B<fd>I<n>B<u720>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:104 man-pages/man4/fd.4:118
#, no-wrap
msgid "16"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:105
#, no-wrap
msgid "B<fd>I<n>B<u800>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:105
#, no-wrap
msgid "800"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:105
#, no-wrap
msgid "120"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "B<fd>I<n>B<u1040>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "1040"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "13"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "84"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "B<fd>I<n>B<u1120>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "1120"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "14"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "88"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:111
msgid "3.5 inch high-density device files:"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:119
#, no-wrap
msgid "B<fd>I<n>B<u820>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:119
#, no-wrap
msgid "820"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:119
#, no-wrap
msgid "52"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:120
#, no-wrap
msgid "B<fd>I<n>B<u830>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:120
#, no-wrap
msgid "830"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:120
#, no-wrap
msgid "68"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:121
#, no-wrap
msgid "B<fd>I<n>B<u1440>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:121
#, no-wrap
msgid "28"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:122
#, no-wrap
msgid "B<fd>I<n>B<u1600>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:122
#, no-wrap
msgid "124"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:123
#, no-wrap
msgid "B<fd>I<n>B<u1680>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:123
#, no-wrap
msgid "1680"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:123 man-pages/man4/fd.4:124 man-pages/man4/fd.4:125
#, no-wrap
msgid "21"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:123 man-pages/man4/fd.4:141
#, no-wrap
msgid "44"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:124
#, no-wrap
msgid "B<fd>I<n>B<u1722>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:124
#, no-wrap
msgid "1722"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:124
#, no-wrap
msgid "60"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:125
#, no-wrap
msgid "B<fd>I<n>B<u1743>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:125
#, no-wrap
msgid "1743"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:125
#, no-wrap
msgid "76"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "B<fd>I<n>B<u1760>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "1760"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "22"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "96"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "B<fd>I<n>B<u1840>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "1840"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "23"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "116"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "B<fd>I<n>B<u1920>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "1920"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "100"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:132
msgid "3.5 inch extra-density device files:"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:138
#, no-wrap
msgid "B<fd>I<n>B<u2880>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:138 man-pages/man4/fd.4:139
#, no-wrap
msgid "2880"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:138 man-pages/man4/fd.4:139
#, no-wrap
msgid "36"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:138
#, no-wrap
msgid "32"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:139
#, no-wrap
msgid "B<fd>I<n>B<CompaQ>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:140
#, no-wrap
msgid "B<fd>I<n>B<u3200>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:140
#, no-wrap
msgid "3200"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:140
#, no-wrap
msgid "104"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:141
#, no-wrap
msgid "B<fd>I<n>B<u3520>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:141
#, no-wrap
msgid "3520"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:141
#, no-wrap
msgid "108"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "B<fd>I<n>B<u3840>"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "3840"
msgstr ""

#. type: tbl table
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "112"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:149
msgid ""
"B<fd> special files access the floppy disk drives in raw mode.  The "
"following B<ioctl>(2)  calls are supported by B<fd> devices:"
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:149
#, no-wrap
msgid "B<FDCLRPRM>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:151
msgid "clears the media information of a drive (geometry of disk in drive)."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:151
#, no-wrap
msgid "B<FDSETPRM>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:155
msgid ""
"sets the media information of a drive.  The media information will be lost "
"when the media is changed."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:155
#, no-wrap
msgid "B<FDDEFPRM>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:161
msgid ""
"sets the media information of a drive (geometry of disk in drive).  The "
"media information will not be lost when the media is changed.  This will "
"disable autodetection.  In order to reenable autodetection, you have to "
"issue an B<FDCLRPRM>."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:161 man-pages/man4/fd.4:173
#, no-wrap
msgid "B<FDGETDRVTYP>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:166
msgid ""
"returns the type of a drive (name parameter).  For formats which work in "
"several drive types, B<FDGETDRVTYP> returns a name which is appropriate for "
"the oldest drive type which supports this format."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:166
#, no-wrap
msgid "B<FDFLUSH>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:168
msgid "invalidates the buffer cache for the given drive."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:168 man-pages/man4/fd.4:171
#, no-wrap
msgid "B<FDSETMAXERRS>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:171
msgid ""
"sets the error thresholds for reporting errors, aborting the operation, "
"recalibrating, resetting, and reading sector by sector."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:173
msgid "gets the current error thresholds."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:175
msgid "gets the internal name of the drive."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:175
#, no-wrap
msgid "B<FDWERRORCLR>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:177
msgid "clears the write error statistics."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:177
#, no-wrap
msgid "B<FDWERRORGET>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:184
msgid ""
"reads the write error statistics.  These include the total number of write "
"errors, the location and disk of the first write error, and the location and"
" disk of the last write error.  Disks are identified by a generation number "
"which is incremented at (almost) each disk change."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:184
#, no-wrap
msgid "B<FDTWADDLE>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:188
msgid ""
"Switch the drive motor off for a few microseconds.  This might be needed in "
"order to access a disk whose sectors are too close together."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:188
#, no-wrap
msgid "B<FDSETDRVPRM>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:190
msgid "sets various drive parameters."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:190
#, no-wrap
msgid "B<FDGETDRVPRM>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:192
msgid "reads these parameters back."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:192
#, no-wrap
msgid "B<FDGETDRVSTAT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:194
msgid "gets the cached drive state (disk changed, write protected et al.)"
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:194
#, no-wrap
msgid "B<FDPOLLDRVSTAT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:196
msgid "polls the drive and return its state."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:196
#, no-wrap
msgid "B<FDGETFDCSTAT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:198
msgid "gets the floppy controller state."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:198
#, no-wrap
msgid "B<FDRESET>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:200
msgid "resets the floppy controller under certain conditions."
msgstr ""

#. type: IP
#: man-pages/man4/fd.4:200
#, no-wrap
msgid "B<FDRAWCMD>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:202
msgid "sends a raw command to the floppy controller."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:207
msgid ""
"For more precise information, consult also the I<E<lt>linux/fd.hE<gt>> and "
"I<E<lt>linux/fdreg.hE<gt>> include files, as well as the B<floppycontrol>(1)"
"  manual page."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:209
msgid "I</dev/fd*>"
msgstr ""

#. type: SH
#: man-pages/man4/fd.4:209
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:215
msgid ""
"The various formats permit reading and writing many types of disks.  "
"However, if a floppy is formatted with an inter-sector gap that is too "
"small, performance may drop, to the point of needing a few seconds to access"
" an entire track.  To prevent this, use interleaved formats."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:219
msgid ""
"It is not possible to read floppies which are formatted using GCR (group "
"code recording), which is used by Apple II and Macintosh computers (800k "
"disks)."
msgstr ""

#.  .SH AUTHORS
#.  Alain Knaff (Alain.Knaff@imag.fr), David Niemi
#.  (niemidc@clark.net), Bill Broadhurst (bbroad@netcom.com).
#. type: Plain text
#: man-pages/man4/fd.4:226
msgid ""
"Reading floppies which are hard sectored (one hole per sector, with the "
"index hole being a little skewed) is not supported.  This used to be common "
"with older 8-inch floppies."
msgstr ""

#. type: Plain text
#: man-pages/man4/fd.4:233
msgid ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), "
"B<superformat>(1), B<mount>(8), B<setfdprm>(8)"
msgstr ""

#. type: TH
#: man-pages/man4/fuse.4:26
#, no-wrap
msgid "FUSE"
msgstr ""

#. type: TH
#: man-pages/man4/fuse.4:26
#, no-wrap
msgid "2018-02-02"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:29
msgid "fuse - Filesystem in Userspace (FUSE) device"
msgstr ""

#. type: SH
#: man-pages/man4/fuse.4:29
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:32
#, no-wrap
msgid "B<#include E<lt>linux/fuse.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:45
msgid ""
"This device is the primary interface between the FUSE filesystem driver and "
"a user-space process wishing to provide the filesystem (referred to in the "
"rest of this manual page as the I<filesystem daemon>).  This manual page is "
"intended for those interested in understanding the kernel interface itself."
"  Those implementing a FUSE filesystem may wish to make use of a user-space "
"library such as I<libfuse> that abstracts away the low-level interface."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:59
msgid ""
"At its core, FUSE is a simple client-server protocol, in which the Linux "
"kernel is the client and the daemon is the server.  After obtaining a file "
"descriptor for this device, the daemon may B<read>(2)  requests from that "
"file descriptor and is expected to B<write>(2)  back its replies.  It is "
"important to note that a file descriptor is associated with a unique FUSE "
"filesystem.  In particular, opening a second copy of this device, will not "
"allow access to resources created through the first file descriptor (and "
"vice versa)."
msgstr ""

#. type: SS
#: man-pages/man4/fuse.4:59
#, no-wrap
msgid "The basic protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:62
msgid ""
"Every message that is read by the daemon begins with a header described by "
"the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:77
#, no-wrap
msgid ""
"struct fuse_in_header {\n"
"    uint32_t len;       /* Total length of the data,\n"
"                           including this header */\n"
"    uint32_t opcode;    /* The kind of operation (see below) */\n"
"    uint64_t unique;    /* A unique identifier for this request */\n"
"    uint64_t nodeid;    /* ID of the filesystem object\n"
"                           being operated on */\n"
"    uint32_t uid;       /* UID of the requesting process */\n"
"    uint32_t gid;       /* GID of the requesting process */\n"
"    uint32_t pid;       /* PID of the requesting process */\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:84
msgid ""
"The header is followed by a variable-length data portion (which may be "
"empty) specific to the requested operation (the requested operation is "
"indicated by I<opcode>)."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:91
msgid ""
"The daemon should then process the request and if applicable send a reply "
"(almost all operations require a reply; if they do not, this is documented "
"below), by performing a B<write>(2)  to the file descriptor.  All replies "
"must start with the following header:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:101
#, no-wrap
msgid ""
"struct fuse_out_header {\n"
"    uint32_t len;       /* Total length of data written to\n"
"                           the file descriptor */\n"
"    int32_t  error;     /* Any error that occurred (0 if none) */\n"
"    uint64_t unique;    /* The value from the\n"
"                           corresponding request */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:111
msgid ""
"This header is also followed by (potentially empty) variable-sized data "
"depending on the executed request.  However, if the reply is an error reply "
"(i.e., I<error> is set), then no further payload data should be sent, "
"independent of the request."
msgstr ""

#. type: SS
#: man-pages/man4/fuse.4:111
#, no-wrap
msgid "Exchanged messages"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:118
msgid ""
"This section should contain documentation for each of the messages in the "
"protocol.  This manual page is currently incomplete, so not all messages are"
" documented.  For each message, first the struct sent by the kernel is "
"given, followed by a description of the semantics of the message."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:118
#, no-wrap
msgid "B<FUSE_INIT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:129
#, no-wrap
msgid ""
"struct fuse_init_in {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead; /* Since protocol v7.6 */\n"
"    uint32_t flags;         /* Since protocol v7.6 */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:141
msgid ""
"This is the first request sent by the kernel to the daemon.  It is used to "
"negotiate the protocol version and other filesystem parameters.  Note that "
"the protocol version may affect the layout of any structure in the protocol "
"(including this structure).  The daemon must thus remember the negotiated "
"version and flags for each session.  As of the writing of this man page, the"
" highest supported kernel protocol version is I<7.26>."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:144
msgid ""
"Users should be aware that the descriptions in this manual page may be "
"incomplete or incorrect for older or more recent protocol versions."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:146
msgid "The reply for this request has the following format:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:161
#, no-wrap
msgid ""
"struct fuse_init_out {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead;   /* Since v7.6 */\n"
"    uint32_t flags;           /* Since v7.6; some flags bits\n"
"                                 were introduced later */\n"
"    uint16_t max_background;  /* Since v7.13 */\n"
"    uint16_t congestion_threshold;  /* Since v7.13 */\n"
"    uint32_t max_write;       /* Since v7.5 */\n"
"    uint32_t time_gran;       /* Since v7.6 */\n"
"    uint32_t unused[9];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:174
msgid ""
"If the major version supported by the kernel is larger than that supported "
"by the daemon, the reply shall consist of only I<uint32_t major> (following "
"the usual header), indicating the largest major version supported by the "
"daemon.  The kernel will then issue a new B<FUSE_INIT> request conforming to"
" the older version.  In the reverse case, the daemon should quietly fall "
"back to the kernel's major version."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:178
msgid ""
"The negotiated minor version is considered to be the minimum of the minor "
"versions provided by the daemon and the kernel and both parties should use "
"the protocol corresponding to said minor version."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:178
#, no-wrap
msgid "B<FUSE_GETATTR>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:189
#, no-wrap
msgid ""
"struct fuse_getattr_in {\n"
"    uint32_t getattr_flags;\n"
"    uint32_t dummy;\n"
"    uint64_t fh;      /* Set only if\n"
"                         (getattr_flags & FUSE_GETATTR_FH)\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:205
msgid ""
"The requested operation is to compute the attributes to be returned by "
"B<stat>(2)  and similar operations for the given file system object.  The "
"object for which the attributes should be computed is indicated either by "
"I<header-E<gt>nodeid> or, if the I<FUSE_GETATTR_FH> flag is set, by the file"
" handle I<fh>.  The latter case of operation is analogous to B<fstat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:212
msgid ""
"For performance reasons, these attributes may be cached in the kernel for a "
"specified duration of time.  While the cache timeout has not been exceeded, "
"the attributes will be served from the cache and will not cause additional "
"B<FUSE_GETATTR> requests."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:215
msgid ""
"The computed attributes and the requested cache timeout should then be "
"returned in the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:242
#, no-wrap
msgid ""
"struct fuse_attr_out {\n"
"    /* Attribute cache duration (seconds + nanoseconds) */\n"
"    uint64_t attr_valid;\n"
"    uint32_t attr_valid_nsec;\n"
"    uint32_t dummy;\n"
"    struct fuse_attr {\n"
"        uint64_t ino;\n"
"        uint64_t size;\n"
"        uint64_t blocks;\n"
"        uint64_t atime;\n"
"        uint64_t mtime;\n"
"        uint64_t ctime;\n"
"        uint32_t atimensec;\n"
"        uint32_t mtimensec;\n"
"        uint32_t ctimensec;\n"
"        uint32_t mode;\n"
"        uint32_t nlink;\n"
"        uint32_t uid;\n"
"        uint32_t gid;\n"
"        uint32_t rdev;\n"
"        uint32_t blksize;\n"
"        uint32_t padding;\n"
"    } attr;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:245
#, no-wrap
msgid "B<FUSE_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:254
#, no-wrap
msgid ""
"struct fuse_access_in {\n"
"    uint32_t mask;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:266
msgid ""
"If the I<default_permissions> mount options is not used, this request may be"
" used for permissions checking.  No reply data is expected, but errors may "
"be indicated as usual by setting the I<error> field in the reply header (in "
"particular, access denied errors may be indicated by returning B<-EACCES>)."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:266
#, no-wrap
msgid "B<FUSE_OPEN> and B<FUSE_OPENDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:275
#, no-wrap
msgid ""
"struct fuse_open_in {\n"
"    uint32_t flags;     /* The flags that were passed\n"
"                           to the open(2) */\n"
"    uint32_t unused;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:287
msgid ""
"The requested operation is to open the node indicated by "
"I<header-E<gt>nodeid>.  The exact semantics of what this means will depend "
"on the filesystem being implemented.  However, at the very least the "
"filesystem should validate that the requested I<flags> are valid for the "
"indicated resource and then send a reply with the following format:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:296
#, no-wrap
msgid ""
"struct fuse_open_out {\n"
"    uint64_t fh;\n"
"    uint32_t open_flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:308
msgid ""
"The I<fh> field is an opaque identifier that the kernel will use to refer to"
" this resource The I<open_flags> field is a bit mask of any number of the "
"flags that indicate properties of this file handle to the kernel:"
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:309
#, no-wrap
msgid "B<FOPEN_DIRECT_IO>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:312
msgid "Bypass page cache for this open file."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:312
#, no-wrap
msgid "B<FOPEN_KEEP_CACHE>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:315
msgid "Don't invalidate the data cache on open."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:315
#, no-wrap
msgid "B<FOPEN_NONSEEKABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:318
msgid "The file is not seekable."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:319
#, no-wrap
msgid "B<FUSE_READ> and B<FUSE_READDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:333
#, no-wrap
msgid ""
"struct fuse_read_in {\n"
"    uint64_t fh;\n"
"    uint64_t offset;\n"
"    uint32_t size;\n"
"    uint32_t read_flags;\n"
"    uint64_t lock_owner;\n"
"    uint32_t flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:342
msgid ""
"The requested action is to read up to I<size> bytes of the file or "
"directory, starting at I<offset>.  The bytes should be returned directly "
"following the usual reply header."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:342
#, no-wrap
msgid "B<FUSE_INTERRUPT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:349
#, no-wrap
msgid ""
"struct fuse_interrupt_in {\n"
"    uint64_t unique;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:365
msgid ""
"The requested action is to cancel the pending operation indicated by "
"I<unique>.  This request requires no response.  However, receipt of this "
"message does not by itself cancel the indicated operation.  The kernel will "
"still expect a reply to said operation (e.g., an I<EINTR> error or a short "
"read).  At most one B<FUSE_INTERRUPT> request will be issued for a given "
"operation.  After issuing said operation, the kernel will wait "
"uninterruptibly for completion of the indicated request."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:365
#, no-wrap
msgid "B<FUSE_LOOKUP>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:371
msgid ""
"Directly following the header is a filename to be looked up in the directory"
" indicated by I<header-E<gt>nodeid>.  The expected reply is of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:383
#, no-wrap
msgid ""
"struct fuse_entry_out {\n"
"    uint64_t nodeid;            /* Inode ID */\n"
"    uint64_t generation;        /* Inode generation */\n"
"    uint64_t entry_valid;\n"
"    uint64_t attr_valid;\n"
"    uint32_t entry_valid_nsec;\n"
"    uint32_t attr_valid_nsec;\n"
"    struct fuse_attr attr;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:391
msgid ""
"The combination of I<nodeid> and I<generation> must be unique for the "
"filesystem's lifetime."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:396
msgid "The interpretation of timeouts and I<attr> is as for B<FUSE_GETATTR>."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:396
#, no-wrap
msgid "B<FUSE_FLUSH>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:406
#, no-wrap
msgid ""
"struct fuse_flush_in {\n"
"    uint64_t fh;\n"
"    uint32_t unused;\n"
"    uint32_t padding;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:414
msgid ""
"The requested action is to flush any pending changes to the indicated file "
"handle.  No reply data is expected.  However, an empty reply message still "
"needs to be issued once the flush operation is complete."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:414
#, no-wrap
msgid "B<FUSE_RELEASE> and B<FUSE_RELEASEDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:424
#, no-wrap
msgid ""
"struct fuse_release_in {\n"
"    uint64_t fh;\n"
"    uint32_t flags;\n"
"    uint32_t release_flags;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:439
msgid ""
"These are the converse of B<FUSE_OPEN> and B<FUSE_OPENDIR> respectively.  "
"The daemon may now free any resources associated with the file handle I<fh> "
"as the kernel will no longer refer to it.  There is no reply data associated"
" with this request, but a reply still needs to be issued once the request "
"has been completely processed."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:439
#, no-wrap
msgid "B<FUSE_STATFS>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:446
msgid ""
"This operation implements B<statfs>(2)  for this filesystem.  There is no "
"input data associated with this request.  The expected reply data has the "
"following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:461
#, no-wrap
msgid ""
"struct fuse_kstatfs {\n"
"    uint64_t blocks;\n"
"    uint64_t bfree;\n"
"    uint64_t bavail;\n"
"    uint64_t files;\n"
"    uint64_t ffree;\n"
"    uint32_t bsize;\n"
"    uint32_t namelen;\n"
"    uint32_t frsize;\n"
"    uint32_t padding;\n"
"    uint32_t spare[6];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:465
#, no-wrap
msgid ""
"struct fuse_statfs_out {\n"
"    struct fuse_kstatfs st;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:470
msgid "For the interpretation of these fields, see B<statfs>(2)."
msgstr ""

#. type: SH
#: man-pages/man4/fuse.4:470
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:471
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:478
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer and the request was B<FUSE_SETXATTR>."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:478
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:487
msgid ""
"Returned from B<write>(2)  if validation of the reply failed.  Not all "
"mistakes in replies will be caught by this validation.  However, basic "
"mistakes, such as short replies or an incorrect I<unique> value, are "
"detected."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:487
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:492
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:498
msgid ""
"I<Note>: There are various ways in which incorrect use of these interfaces "
"can cause operations on the provided filesystem's files and directories to "
"fail with B<EIO>.  Among the possible incorrect uses are:"
msgstr ""

#. type: IP
#: man-pages/man4/fuse.4:499 man-pages/man4/fuse.4:503
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:503
msgid ""
"changing I<mode & S_IFMT> for an inode that has previously been reported to "
"the kernel; or"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:505
msgid ""
"giving replies to the kernel that are shorter than what the kernel expected."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:506
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:513
msgid ""
"Returned from B<read>(2)  and B<write>(2)  if the FUSE filesystem was "
"unmounted."
msgstr ""

#. type: TP
#: man-pages/man4/fuse.4:513
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:518
msgid ""
"Returned from operations on a I</dev/fuse> file descriptor that has not been"
" mounted."
msgstr ""

#. type: SH
#: man-pages/man4/fuse.4:518
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:520
msgid "The FUSE filesystem is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:522
msgid "The following messages are not yet documented in this manual page:"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:556
#, no-wrap
msgid ""
"B<FUSE_BATCH_FORGET>\n"
"B<FUSE_BMAP>\n"
"B<FUSE_CREATE>\n"
"B<FUSE_DESTROY>\n"
"B<FUSE_FALLOCATE>\n"
"B<FUSE_FORGET>\n"
"B<FUSE_FSYNC>\n"
"B<FUSE_FSYNCDIR>\n"
"B<FUSE_GETLK>\n"
"B<FUSE_GETXATTR>\n"
"B<FUSE_IOCTL>\n"
"B<FUSE_LINK>\n"
"B<FUSE_LISTXATTR>\n"
"B<FUSE_LSEEK>\n"
"B<FUSE_MKDIR>\n"
"B<FUSE_MKNOD>\n"
"B<FUSE_NOTIFY_REPLY>\n"
"B<FUSE_POLL>\n"
"B<FUSE_READDIRPLUS>\n"
"B<FUSE_READLINK>\n"
"B<FUSE_REMOVEXATTR>\n"
"B<FUSE_RENAME>\n"
"B<FUSE_RENAME2>\n"
"B<FUSE_RMDIR>\n"
"B<FUSE_SETATTR>\n"
"B<FUSE_SETLK>\n"
"B<FUSE_SETLKW>\n"
"B<FUSE_SYMLINK>\n"
"B<FUSE_UNLINK>\n"
"B<FUSE_WRITE>\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/fuse.4:560
msgid "B<fusermount>(1), B<mount.fuse>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/fanotify.7:25
#, no-wrap
msgid "FANOTIFY"
msgstr ""

#. type: TH
#: man-pages/man7/fanotify.7:25
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:28
msgid "fanotify - monitoring filesystem events"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:37
msgid ""
"The fanotify API provides notification and interception of filesystem "
"events.  Use cases include virus scanning and hierarchical storage "
"management.  Currently, only a limited set of events is supported.  In "
"particular, there is no support for create, delete, and move events.  (See "
"B<inotify>(7)  for details of an API that does notify those events.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:44
msgid ""
"Additional capabilities compared to the B<inotify>(7)  API include the "
"ability to monitor all of the objects in a mounted filesystem, the ability "
"to make access permission decisions, and the possibility to read or modify "
"files before access by other applications."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:52
msgid ""
"The following system calls are used with this API: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:52
#, no-wrap
msgid "fanotify_init(), fanotify_mark(), and notification groups"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:57
msgid ""
"The B<fanotify_init>(2)  system call creates and initializes an fanotify "
"notification group and returns a file descriptor referring to it."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:61
msgid ""
"An fanotify notification group is a kernel-internal object that holds a list"
" of files, directories, filesystems, and mount points for which events shall"
" be created."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:72
msgid ""
"For each entry in an fanotify notification group, two bit masks exist: the "
"I<mark> mask and the I<ignore> mask.  The mark mask defines file activities "
"for which an event shall be created.  The ignore mask defines activities for"
" which no event shall be generated.  Having these two types of masks permits"
" a filesystem, mount point, or directory to be marked for receiving events, "
"while at the same time ignoring events for specific objects under a mount "
"point or directory."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:78
msgid ""
"The B<fanotify_mark>(2)  system call adds a file, directory, filesystem or "
"mount point to a notification group and specifies which events shall be "
"reported (or ignored), or removes or modifies such an entry."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:91
msgid ""
"A possible usage of the ignore mask is for a file cache.  Events of interest"
" for a file cache are modification of a file and closing of the same.  "
"Hence, the cached directory or mount point is to be marked to receive these "
"events.  After receiving the first event informing that a file has been "
"modified, the corresponding cache entry will be invalidated.  No further "
"modification events for this file are of interest until the file is closed."
"  Hence, the modify event can be added to the ignore mask.  Upon receiving "
"the close event, the modify event can be removed from the ignore mask and "
"the file cache entry can be updated."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:98
msgid ""
"The entries in the fanotify notification groups refer to files and "
"directories via their inode number and to mounts via their mount ID.  If "
"files or directories are renamed or moved within the same mount, the "
"respective entries survive.  If files or directories are deleted or moved to"
" another mount or if filesystems or mounts are unmounted, the corresponding "
"entries are deleted."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:98
#, no-wrap
msgid "The event queue"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:107
msgid ""
"As events occur on the filesystem objects monitored by a notification group,"
" the fanotify system generates events that are collected in a queue.  These "
"events can then be read (using B<read>(2)  or similar)  from the fanotify "
"file descriptor returned by B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:125
msgid ""
"Two types of events are generated: I<notification> events and I<permission> "
"events.  Notification events are merely informative and require no action to"
" be taken by the receiving application with the exception being that the "
"file descriptor provided within a generic event must be closed.  The closing"
" of file descriptors for each event applies only to applications that have "
"initialized fanotify without using B<FAN_REPORT_FID> (see below).  "
"Permission events are requests to the receiving application to decide "
"whether permission for a file access shall be granted.  For these events, "
"the recipient must write a response which decides whether access is granted "
"or not."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:132
msgid ""
"An event is removed from the event queue of the fanotify group when it has "
"been read.  Permission events that have been read are kept in an internal "
"list of the fanotify group until either a permission decision has been taken"
" by writing to the fanotify file descriptor or the fanotify file descriptor "
"is closed."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:132
#, no-wrap
msgid "Reading fanotify events"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:144
msgid ""
"Calling B<read>(2)  for the file descriptor returned by B<fanotify_init>(2)"
"  blocks (if the flag B<FAN_NONBLOCK> is not specified in the call to "
"B<fanotify_init>(2))  until either a file event occurs or the call is "
"interrupted by a signal (see B<signal>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:154
msgid ""
"The use of the B<FAN_REPORT_FID> flag in B<fanotify_init>(2)  influences "
"what data structures are returned to the event listener for each event.  "
"After a successful B<read>(2), the read buffer contains one or more of the "
"following structures:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:166
#, no-wrap
msgid ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:177
msgid ""
"In the case where B<FAN_REPORT_FID> is supplied as one of the flags to "
"B<fanotify_init>(2), you should also expect to receive the structure "
"detailed below following the generic I<fanotify_event_metadata> structure "
"within the read buffer:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:185
#, no-wrap
msgid ""
"struct fanotify_event_info_fid {\n"
"    struct fanotify_event_info_header hdr;\n"
"    __kernel_fsid_t fsid;\n"
"    unsigned char file_handle[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:192
msgid ""
"For performance reasons, it is recommended to use a large buffer size (for "
"example, 4096 bytes), so that multiple events can be retrieved by a single "
"B<read>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:197
msgid ""
"The return value of B<read>(2)  is the number of bytes placed in the buffer,"
" or -1 in case of an error (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:201
msgid "The fields of the I<fanotify_event_metadata> structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:201
#, no-wrap
msgid "I<event_len>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:215
msgid ""
"This is the length of the data for the current event and the offset to the "
"next event in the buffer.  Without B<FAN_REPORT_FID>, the value of "
"I<event_len> is always B<FAN_EVENT_METADATA_LEN>.  With B<FAN_REPORT_FID>, "
"I<event_len> also includes the variable length file identifier."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:215
#, no-wrap
msgid "I<vers>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:224
msgid ""
"This field holds a version number for the structure.  It must be compared to"
" B<FANOTIFY_METADATA_VERSION> to verify that the structures returned at run "
"time match the structures defined at compile time.  In case of a mismatch, "
"the application should abandon trying to use the fanotify file descriptor."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:224
#, no-wrap
msgid "I<reserved>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:227
msgid "This field is not used."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:227
#, no-wrap
msgid "I<metadata_len>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:233
msgid ""
"This is the length of the structure.  The field was introduced to facilitate"
" the implementation of optional headers per event type.  No such optional "
"headers exist in the current implementation."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:233
#, no-wrap
msgid "I<mask>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:236
msgid "This is a bit mask describing the event (see below)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:236 man-pages/man7/fanotify.7:510
#, no-wrap
msgid "I<fd>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:249
msgid ""
"This is an open file descriptor for the object being accessed, or "
"B<FAN_NOFD> if a queue overflow occurred.  If the fanotify file descriptor "
"has been initialized using B<FAN_REPORT_FID>, applications should expect "
"this value to be set to B<FAN_NOFD> for each event that is received.  The "
"file descriptor can be used to access the contents of the monitored file or "
"directory.  The reading application is responsible for closing this file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:262
msgid ""
"When calling B<fanotify_init>(2), the caller may specify (via the "
"I<event_f_flags> argument) various file status flags that are to be set on "
"the open file description that corresponds to this file descriptor.  In "
"addition, the (kernel-internal)  B<FMODE_NONOTIFY> file status flag is set "
"on the open file description.  This flag suppresses fanotify event "
"generation.  Hence, when the receiver of the fanotify event accesses the "
"notified file or directory using this file descriptor, no additional events "
"will be created."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:262
#, no-wrap
msgid "I<pid>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:270
msgid ""
"If flag B<FAN_REPORT_TID> was set in B<fanotify_init>(2), this is the TID of"
" the thread that caused the event.  Otherwise, this the PID of the process "
"that caused the event."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:276
msgid ""
"A program listening to fanotify events can compare this PID to the PID "
"returned by B<getpid>(2), to determine whether the event is caused by the "
"listener itself, or is due to a file access by another process."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:286
msgid ""
"The bit mask in I<mask> indicates which events have occurred for a single "
"filesystem object.  Multiple bits may be set in this mask, if more than one "
"event occurred for the monitored filesystem object.  In particular, "
"consecutive events for the same filesystem object and originating from the "
"same process may be merged into a single event, with the exception that two "
"permission events are never merged into one queue entry."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:290
msgid "The bits that may appear in I<mask> are as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:290
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:293
msgid "A file or a directory (but see BUGS) was accessed (read)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:293
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:296
msgid "A file or a directory was opened."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:296
#, no-wrap
msgid "B<FAN_OPEN_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:302
msgid ""
"A file was opened with the intent to be executed.  See NOTES in "
"B<fanotify_mark>(2)  for additional details."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:302
#, no-wrap
msgid "B<FAN_ATTRIB>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:305
msgid "A file or directory metadata was changed."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:305
#, no-wrap
msgid "B<FAN_CREATE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:308
msgid "A child file or directory was created in a watched parent."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:308
#, no-wrap
msgid "B<FAN_DELETE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:311
msgid "A child file or directory was deleted in a watched parent."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:311
#, no-wrap
msgid "B<FAN_DELETE_SELF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:314
msgid "A watched file or directory was deleted."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:314
#, no-wrap
msgid "B<FAN_MOVED_FROM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:317
msgid "A file or directory has been moved from a watched parent directory."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:317
#, no-wrap
msgid "B<FAN_MOVED_TO>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:320
msgid "A file or directory has been moved to a watched parent directory."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:320
#, no-wrap
msgid "B<FAN_MOVE_SELF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:323
msgid "A watched file or directory was moved."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:323
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:326
msgid "A file was modified."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:326
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:333
msgid ""
"A file that was opened for writing (B<O_WRONLY> or B<O_RDWR>)  was closed."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:333
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:338
msgid ""
"A file or directory that was opened read-only (B<O_RDONLY>)  was closed."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:338
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:345
msgid ""
"The event queue exceeded the limit of 16384 entries.  This limit can be "
"overridden by specifying the B<FAN_UNLIMITED_QUEUE> flag when calling "
"B<fanotify_init>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:345
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:354
msgid ""
"An application wants to read a file or directory, for example using "
"B<read>(2)  or B<readdir>(2).  The reader must write a response (as "
"described below)  that determines whether the permission to access the "
"filesystem object shall be granted."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:354
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:359
msgid ""
"An application wants to open a file or directory.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object shall be granted."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:359
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:367
msgid ""
"An application wants to open a file for execution.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object for execution shall be granted.  See NOTES in B<fanotify_mark>(2)  "
"for additional details."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:369
msgid "To check for any close event, the following bit mask may be used:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:369
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:373
msgid "A file was closed.  This is a synonym for:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:375
#, no-wrap
msgid "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:377
msgid "To check for any move event, the following bit mask may be used:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:377
#, no-wrap
msgid "B<FAN_MOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:381
msgid "A file or directory was moved.  This is a synonym for:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:383
#, no-wrap
msgid "    FAN_MOVED_FROM | FAN_MOVED_TO\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:387
msgid "The fields of the I<fanotify_event_info_fid> structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:387
#, no-wrap
msgid "I<hdr>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:409
msgid ""
"This is a structure of type I<fanotify_event_info_header>.  It is a generic "
"header that contains information used to describe additional information "
"attached to the event.  For example, when an fanotify file descriptor is "
"created using B<FAN_REPORT_FID>, the I<info_type> field of this header is "
"set to B<FAN_EVENT_INFO_TYPE_FID>.  Event listeners can use this field to "
"check that the additional information received for an event is of the "
"correct type.  Additionally, the I<fanotify_event_info_header> also contains"
" a I<len> field.  In the current implementation, the value of I<len> is "
"always (event_len - FAN_EVENT_METADATA_LEN)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:409
#, no-wrap
msgid "I<fsid>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:419
msgid ""
"This is a unique identifier of the filesystem containing the object "
"associated with the event.  It is a structure of type I<__kernel_fsid_t> and"
" contains the same value as I<f_fsid> when calling B<statfs>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:419
#, no-wrap
msgid "I<file_handle>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:446
msgid ""
"This is a variable length structure of type I<file_handle>.  It is an opaque"
" handle that corresponds to a specified object on a filesystem as returned "
"by B<name_to_handle_at>(2).  It can be used to uniquely identify a file on a"
" filesystem and can be passed as an argument to B<open_by_handle_at>(2).  "
"Note that for directory entry events, such as B<FAN_CREATE>, B<FAN_DELETE>, "
"and B<FAN_MOVE>, the I<file_handle> describes the modified directory and not"
" the created/deleted/moved child object.  The events B<FAN_ATTRIB>, "
"B<FAN_DELETE_SELF>, and B<FAN_MOVE_SELF> will carry the I<file_handle> "
"information for the child object if the child object is being watched."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:451
msgid ""
"The following macros are provided to iterate over a buffer containing "
"fanotify event metadata returned by a B<read>(2)  from an fanotify file "
"descriptor:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:451
#, no-wrap
msgid "B<FAN_EVENT_OK(meta, len)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:460
msgid ""
"This macro checks the remaining length I<len> of the buffer I<meta> against "
"the length of the metadata structure and the I<event_len> field of the first"
" metadata structure in the buffer."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:460
#, no-wrap
msgid "B<FAN_EVENT_NEXT(meta, len)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:479
msgid ""
"This macro uses the length indicated in the I<event_len> field of the "
"metadata structure pointed to by I<meta> to calculate the address of the "
"next metadata structure that follows I<meta>.  I<len> is the number of bytes"
" of metadata that currently remain in the buffer.  The macro returns a "
"pointer to the next metadata structure that follows I<meta>, and reduces "
"I<len> by the number of bytes in the metadata structure that has been "
"skipped over (i.e., it subtracts I<meta-E<gt>event_len> from I<len>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:481
msgid "In addition, there is:"
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:481
#, no-wrap
msgid "B<FAN_EVENT_METADATA_LEN>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:487
msgid ""
"This macro returns the size (in bytes) of the structure "
"I<fanotify_event_metadata>.  This is the minimum size (and currently the "
"only size) of any event metadata."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:487
#, no-wrap
msgid "Monitoring an fanotify file descriptor for events"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:494
msgid ""
"When an fanotify event occurs, the fanotify file descriptor indicates as "
"readable when passed to B<epoll>(7), B<poll>(2), or B<select>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:494
#, no-wrap
msgid "Dealing with permission events"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:499
msgid ""
"For permission events, the application must B<write>(2)  a structure of the "
"following form to the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:506
#, no-wrap
msgid ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:510
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:514
msgid ""
"This is the file descriptor from the structure I<fanotify_event_metadata>."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:514
#, no-wrap
msgid "I<response>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:522
msgid ""
"This field indicates whether or not the permission is to be granted.  Its "
"value must be either B<FAN_ALLOW> to allow the file operation or B<FAN_DENY>"
" to deny the file operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:526
msgid ""
"If access is denied, the requesting application call will receive an "
"B<EPERM> error."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:526
#, no-wrap
msgid "Closing the fanotify file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:534
msgid ""
"When all file descriptors referring to the fanotify notification group are "
"closed, the fanotify group is released and its resources are freed for reuse"
" by the kernel.  Upon B<close>(2), outstanding permission events will be set"
" to allowed."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:534
#, no-wrap
msgid "/proc/[pid]/fdinfo"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:544
msgid ""
"The file I</proc/[pid]/fdinfo/[fd]> contains information about fanotify "
"marks for file descriptor I<fd> of process I<pid>.  See B<proc>(5)  for "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:549
msgid ""
"In addition to the usual errors for B<read>(2), the following errors can "
"occur when reading from the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:552
msgid "The buffer is too small to hold the event."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:552
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:559
msgid ""
"The per-process limit on the number of open files has been reached.  See the"
" description of B<RLIMIT_NOFILE> in B<getrlimit>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:559
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:566
msgid ""
"The system-wide limit on the total number of open files has been reached.  "
"See I</proc/sys/fs/file-max> in B<proc>(5)."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:566
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:579
msgid ""
"This error is returned by B<read>(2)  if B<O_RDWR> or B<O_WRONLY> was "
"specified in the I<event_f_flags> argument when calling B<fanotify_init>(2)"
"  and an event occurred for a monitored file that is currently being "
"executed."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:583
msgid ""
"In addition to the usual errors for B<write>(2), the following errors can "
"occur when writing to the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:589
msgid ""
"Fanotify access permissions are not enabled in the kernel configuration or "
"the value of I<response> in the response structure is not valid."
msgstr ""

#. type: TP
#: man-pages/man7/fanotify.7:589
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:596
msgid ""
"The file descriptor I<fd> in the response structure is not valid.  This may "
"occur when a response for the permission event has already been written."
msgstr ""

#. type: SH
#: man-pages/man7/fanotify.7:596
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:600
msgid ""
"The fanotify API was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37.  Fdinfo support was added in version 3.8."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:602
msgid "The fanotify API is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:609
msgid ""
"The fanotify API is available only if the kernel was built with the "
"B<CONFIG_FANOTIFY> configuration option enabled.  In addition, fanotify "
"permission handling is available only if the "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> configuration option is enabled."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:609
#, no-wrap
msgid "Limitations and caveats"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:614
msgid ""
"Fanotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:621
msgid ""
"The fanotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:626
msgid ""
"Events for directories are created only if the directory itself is opened, "
"read, and closed.  Adding, removing, or changing children of a marked "
"directory does not create events for the monitored directory itself."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:636
msgid ""
"Fanotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional marks must be created.  (But "
"note that the fanotify API provides no way of detecting when a subdirectory "
"has been created under a marked directory, which makes recursive monitoring "
"difficult.)  Monitoring mounts offers the capability to monitor a whole "
"directory tree.  Monitoring filesystems offers the capability to monitor "
"changes made from any mount of a filesystem instance."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:639
msgid "The event queue can overflow.  In this case, events are lost."
msgstr ""

#. type: SH
#: man-pages/man7/fanotify.7:639
#, no-wrap
msgid "BUGS"
msgstr ""

#.  commit 820c12d5d6c0890bc93dd63893924a13041fdc35
#. type: Plain text
#: man-pages/man7/fanotify.7:650
msgid ""
"Before Linux 3.19, B<fallocate>(2)  did not generate fanotify events.  Since"
" Linux 3.19, calls to B<fallocate>(2)  generate B<FAN_MODIFY> events."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:653
msgid "As of Linux 3.17, the following bugs exist:"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:662
msgid ""
"On Linux, a filesystem object may be accessible through multiple paths, for "
"example, a part of a filesystem may be remounted using the I<--bind> option "
"of B<mount>(8).  A listener that marked a mount will be notified only of "
"events that were triggered for a filesystem object using the same mount.  "
"Any other event will pass unnoticed."
msgstr ""

#.  FIXME . A patch was proposed.
#. type: Plain text
#: man-pages/man7/fanotify.7:671
msgid ""
"When an event is generated, no check is made to see whether the user ID of "
"the receiving process has authorization to read or write the file before "
"passing a file descriptor for that file.  This poses a security risk, when "
"the B<CAP_SYS_ADMIN> capability is set for programs executed by unprivileged"
" users."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:681
msgid ""
"If a call to B<read>(2)  processes multiple events from the fanotify queue "
"and an error occurs, the return value will be the total length of the events"
" successfully copied to the user-space buffer before the error occurred.  "
"The return value will not be -1, and I<errno> will not be set.  Thus, the "
"reading application has no way to detect the error."
msgstr ""

#. type: SH
#: man-pages/man7/fanotify.7:681
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:683
msgid ""
"The two example programs below demonstrate the usage of the fanotify API."
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:683
#, no-wrap
msgid "Example program: fanotify_example.c"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:695
msgid ""
"The first program is an example of fanotify being used with its event object"
" information passed in the form of a file descriptor.  The program marks the"
" mount point passed as a command-line argument and waits for events of type "
"B<FAN_OPEN_PERM> and B<FAN_CLOSE_WRITE>.  When a permission event occurs, a "
"B<FAN_ALLOW> response is given."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:707
msgid ""
"The following shell session shows an example of running this program.  This "
"session involved editing the file I</home/user/temp/notes>.  Before the file"
" was opened, a B<FAN_OPEN_PERM> event occurred.  After the file was closed, "
"a B<FAN_CLOSE_WRITE> event occurred.  Execution of the program ends when the"
" user presses the ENTER key."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:715
#, no-wrap
msgid ""
"# B<./fanotify_example /home>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:717
#, no-wrap
msgid "Listening for events stopped.\n"
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:721
#, no-wrap
msgid "Program source: fanotify_example.c"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:733
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:735
#, no-wrap
msgid ""
"/* Read all available fanotify events from the file descriptor \\(aqfd\\(aq "
"*/\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:746
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:748
#, no-wrap
msgid "    /* Loop while events can be read from fanotify file descriptor */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:750
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:752
#, no-wrap
msgid "        /* Read some events */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:758
#, no-wrap
msgid ""
"        len = read(fd, (void *) &buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:760
#, no-wrap
msgid "        /* Check if end of available data reached */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:763
#, no-wrap
msgid ""
"        if (len E<lt>= 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:765
#, no-wrap
msgid "        /* Point to the first event in the buffer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:767
#, no-wrap
msgid "        metadata = buf;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:769
#, no-wrap
msgid "        /* Loop over all events in the buffer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:771
#, no-wrap
msgid "        while (FAN_EVENT_OK(metadata, len)) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:773
#, no-wrap
msgid ""
"            /* Check that run-time and compile-time structures match */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:779
#, no-wrap
msgid ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:783
#, no-wrap
msgid ""
"            /* metadata-E<gt>fd contains either FAN_NOFD, indicating a\n"
"               queue overflow, or a file descriptor (a nonnegative\n"
"               integer). Here, we simply ignore queue overflow. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:785
#, no-wrap
msgid "            if (metadata-E<gt>fd E<gt>= 0) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:787
#, no-wrap
msgid "                /* Handle open permission event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:790
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:792
#, no-wrap
msgid "                    /* Allow file to be opened */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:798
#, no-wrap
msgid ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response,\n"
"                          sizeof(struct fanotify_response));\n"
"                }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:800
#, no-wrap
msgid "                /* Handle closing of writable file event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:803
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:805
#, no-wrap
msgid "                /* Retrieve and print pathname of the accessed file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:814
#, no-wrap
msgid ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:817
#, no-wrap
msgid ""
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"                printf(\"File %s\\en\", path);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:819
#, no-wrap
msgid "                /* Close the file descriptor of the event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:822
#, no-wrap
msgid ""
"                close(metadata-E<gt>fd);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:824
#, no-wrap
msgid "            /* Advance to next event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:829
#, no-wrap
msgid ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:837
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:839
#, no-wrap
msgid "    /* Check mount point is supplied */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:844
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:846
#, no-wrap
msgid "    printf(\"Press enter key to terminate.\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:848
#, no-wrap
msgid "    /* Create the file descriptor for accessing the fanotify API */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:855
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:860
#, no-wrap
msgid ""
"    /* Mark the mount for:\n"
"       - permission events before opening files\n"
"       - notification events after closing a write-enabled\n"
"         file descriptor */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:867
#, no-wrap
msgid ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:869
#, no-wrap
msgid "    /* Prepare for polling */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:871
#, no-wrap
msgid "    nfds = 2;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:873
#, no-wrap
msgid "    /* Console input */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:876
#, no-wrap
msgid ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:878
#, no-wrap
msgid "    /* Fanotify input */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:881
#, no-wrap
msgid ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:883
#, no-wrap
msgid "    /* This is the loop to wait for incoming events */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:885
#, no-wrap
msgid "    printf(\"Listening for events.\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:891
#, no-wrap
msgid ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* Interrupted by a signal */\n"
"                continue;           /* Restart poll() */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:895
#, no-wrap
msgid ""
"            perror(\"poll\");         /* Unexpected error */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:898
#, no-wrap
msgid ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:900
#, no-wrap
msgid "                /* Console input is available: empty stdin and quit */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:905
#, no-wrap
msgid ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != \\(aq\\en\\(aq)\n"
"                    continue;\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:907
#, no-wrap
msgid "            if (fds[1].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:909
#, no-wrap
msgid "                /* Fanotify events are available */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:914
#, no-wrap
msgid ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:918
#, no-wrap
msgid ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:920
#, no-wrap
msgid "Example program: fanotify_fid.c"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:933
msgid ""
"The second program is an example of fanotify being used with "
"B<FAN_REPORT_FID> enabled.  The program marks the filesystem object that is "
"passed as a command-line argument and waits until an event of type "
"B<FAN_CREATE> has occurred.  The event mask indicates which type of "
"filesystem object\\(emeither a file or a directory\\(emwas created\".  Once "
"all events have been read from the buffer and processed accordingly, the "
"program simply terminates."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:936
msgid ""
"The following shell sessions show two different invocations of this program,"
" with different actions performed on a watched object."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:949
msgid ""
"The first session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a regular file, I</home/user/testfile.txt>.  "
"This results in a B<FAN_CREATE> event being created and reported against the"
" file's parent watched directory object.  Program execution ends once all "
"events captured within the buffer have been processed.  Program execution "
"ends once all events captured within the buffer are processed."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:956
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE (file created): Directory /home/user has been modified.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:958
#, no-wrap
msgid "$ B<touch /home/user/testing>              # In another terminal\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:970
msgid ""
"The second session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a directory, I</home/user/testdir>.  This "
"specific action results in the program producing a B<FAN_CREATE> and "
"B<FAN_ONDIR> event."
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:978
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE | FAN_ONDIR (subdirectory created):\n"
"        Directory /home/user has been modified.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:980
#, no-wrap
msgid "$ B<mkdir -p /home/user/testing>          # In another terminal\n"
msgstr ""

#. type: SS
#: man-pages/man7/fanotify.7:982
#, no-wrap
msgid "Program source: fanotify_fid.c"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:995
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:997
#, no-wrap
msgid "#define BUF_SIZE 256\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1009
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd, ret, event_fd;\n"
"    ssize_t len, path_len;\n"
"    char path[PATH_MAX];\n"
"    char procfd_path[PATH_MAX];\n"
"    char events_buf[BUF_SIZE];\n"
"    struct file_handle *file_handle;\n"
"    struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_info_fid *fid;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1014
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Invalid number of command line arguments.\\e\\n\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1017
#, no-wrap
msgid ""
"    /* Create an fanotify file descriptor with FAN_REPORT_FID as a flag\n"
"       so that program can receive fid events. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1023
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_FID, 0);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1025
#, no-wrap
msgid "    /* Place a mark on the filesystem object supplied in argv[1]. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1033
#, no-wrap
msgid ""
"    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,\n"
"                        FAN_CREATE | FAN_ONDIR,\n"
"                        AT_FDCWD, argv[1]);\n"
"    if (ret == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1035
#, no-wrap
msgid "    printf(\"Listening for events.\\e\\n\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1037
#, no-wrap
msgid "    /* Read events from the event queue into a buffer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1043
#, no-wrap
msgid ""
"    len = read(fd, (void *) &events_buf, sizeof(events_buf));\n"
"    if (len == -1 && errno != EAGAIN) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1045
#, no-wrap
msgid "    /* Process all events within the buffer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1051
#, no-wrap
msgid ""
"    for (metadata = (struct fanotify_event_metadata *) events_buf;\n"
"            FAN_EVENT_OK(metadata, len);\n"
"            metadata = FAN_EVENT_NEXT(metadata, len)) {\n"
"        fid = (struct fanotify_event_info_fid *) (metadata + 1);\n"
"        file_handle = (struct file_handle *) fid-E<gt>handle;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1053
#, no-wrap
msgid "        /* Ensure that the event info is of the correct type */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1058
#, no-wrap
msgid ""
"        if (fid-E<gt>hdr.info_type != FAN_EVENT_INFO_TYPE_FID) {\n"
"            fprintf(stderr, \"Received unexpected event info type.\\e\\n\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1061
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == FAN_CREATE)\n"
"            printf(\"FAN_CREATE (file created):\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1064
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == FAN_CREATE | FAN_ONDIR)\n"
"            printf(\"FAN_CREATE | FAN_ONDIR (subdirectory created):\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1072
#, no-wrap
msgid ""
"        /* metadata-E<gt>fd is set to FAN_NOFD when FAN_REPORT_FID is enabled.\n"
"           To obtain a file descriptor for the file object corresponding to\n"
"           an event you can use the struct file_handle that\\(aqs provided\n"
"           within the fanotify_event_info_fid in conjunction with the\n"
"           open_by_handle_at(2) system call. A check for ESTALE is done\n"
"           to accommodate for the situation where the file handle for the\n"
"           object was deleted prior to this system call. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1084
#, no-wrap
msgid ""
"        event_fd = open_by_handle_at(AT_FDCWD, file_handle, O_RDONLY);\n"
"        if (ret == -1) {\n"
"            if (errno == ESTALE) {\n"
"                printf(\"File handle is no longer valid. \"\n"
"                        \"File has been deleted\\e\\n\");\n"
"                continue;\n"
"            } else {\n"
"                perror(\"open_by_handle_at\");\n"
"                exit(EXIT_FAILURE);\n"
"\t    }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1087
#, no-wrap
msgid ""
"        snprintf(procfd_path, sizeof(procfd_path), \"/proc/self/fd/%d\",\n"
"                event_fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1089
#, no-wrap
msgid "        /* Retrieve and print the path of the modified dentry */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1095
#, no-wrap
msgid ""
"        path_len = readlink(procfd_path, path, sizeof(path) - 1);\n"
"        if (path_len == -1) {\n"
"            perror(\"readlink\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1098
#, no-wrap
msgid ""
"        path[path_len] = \\(aq\\e\\0\\(aq;\n"
"        printf(\"\\etDirectory \\(aq%s\\(aq has been modified.\\e\\n\", path);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1100
#, no-wrap
msgid "        /* Close associated file descriptor for this event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1103
#, no-wrap
msgid ""
"        close(event_fd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1107
#, no-wrap
msgid ""
"    printf(\"All events processed successfully. Program exiting.\\e\\n\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/fanotify.7:1112
msgid "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/feature_test_macros.7:25
#, no-wrap
msgid "FEATURE_TEST_MACROS"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:28
msgid "feature_test_macros - feature test macros"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:31
msgid ""
"Feature test macros allow the programmer to control the definitions that are"
" exposed by system header files when a program is compiled."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:48
msgid ""
"B<NOTE:> In order to be effective, a feature test macro I<must be defined "
"before including any header files>.  This can be done either in the "
"compilation command (I<cc -DMACRO=value>)  or by defining the macro within "
"the source code before including any headers.  The requirement that the "
"macro must be defined before including any header file exists because header"
" files may freely include one another.  Thus, for example, in the following "
"lines, defining the B<_GNU_SOURCE> macro may have no effect because the "
"header I<E<lt>abc.hE<gt>> itself includes I<E<lt>xyz.hE<gt>> (POSIX "
"explicitly allows this):"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:54
#, no-wrap
msgid ""
"#include E<lt>abc.hE<gt>\n"
"#define _GNU_SOURCE\n"
"#include E<lt>xys.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:61
msgid ""
"Some feature test macros are useful for creating portable applications, by "
"preventing nonstandard definitions from being exposed.  Other macros can be "
"used to expose nonstandard definitions that are not exposed by default."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:73
msgid ""
"The precise effects of each of the feature test macros described below can "
"be ascertained by inspecting the I<E<lt>features.hE<gt>> header file.  "
"B<Note>: applications do I<not> need to directly include "
"I<E<lt>features.hE<gt>>; indeed, doing so is actively discouraged.  See "
"NOTES."
msgstr ""

#. type: SS
#: man-pages/man7/feature_test_macros.7:73
#, no-wrap
msgid "Specification of feature test macro requirements in manual pages"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:79
msgid ""
"When a function requires that a feature test macro is defined, the manual "
"page SYNOPSIS typically includes a note of the following form (this example "
"from the B<acct>(2)  manual page):"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:82
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:84
msgid "B<int acct(const char *>I<filename>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:89
#, no-wrap
msgid ""
"Feature Test Macro Requirements for glibc (see\n"
"B<feature_test_macros>(7)):\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:94
msgid "B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:105
msgid ""
"The B<||> means that in order to obtain the declaration of B<acct>(2)  from "
"I<E<lt>unistd.hE<gt>>, I<either> of the following macro definitions must be "
"made before including any header files:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:110
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#define _XOPEN_SOURCE        /* or any value E<lt> 500 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:115
msgid ""
"Alternatively, equivalent definitions can be included in the compilation "
"command:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:120
#, no-wrap
msgid ""
"cc -D_BSD_SOURCE\n"
"cc -D_XOPEN_SOURCE           # Or any value E<lt> 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:128
msgid ""
"Note that, as described below, B<some feature test macros are defined by "
"default>, so that it may not always be necessary to explicitly specify the "
"feature test macro(s) shown in the SYNOPSIS."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:132
msgid ""
"In a few cases, manual pages use a shorthand for expressing the feature test"
" macro requirements (this example from B<readahead>(2)):"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:137
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:139
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t *>I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:145
msgid ""
"This format is employed in cases where only a single feature test macro can "
"be used to expose the function declaration, and that macro is not defined by"
" default."
msgstr ""

#. type: SS
#: man-pages/man7/feature_test_macros.7:145
#, no-wrap
msgid "Feature test macros understood by glibc"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:150
msgid ""
"The paragraphs below explain how feature test macros are handled in Linux "
"glibc 2.I<x>, I<x> E<gt> 0."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:152
msgid "First, though a summary of a few details for the impatient:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:162
msgid ""
"The macros that you most likely need to use in modern source code are "
"B<_POSIX_C_SOURCE> (for definitions from various versions of POSIX.1), "
"B<_XOPEN_SOURCE> (for definitions from various versions of SUS), "
"B<_GNU_SOURCE> (for GNU and/or Linux specific stuff), and B<_DEFAULT_SOURCE>"
" (to get definitions that would normally be provided by default)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:168
msgid ""
"Certain macros are defined with default values.  Thus, although one or more "
"macros may be indicated as being required in the SYNOPSIS of a man page, it "
"may not be necessary to define them explicitly.  Full details of the "
"defaults are given later in this man page."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:175
msgid ""
"Defining B<_XOPEN_SOURCE> with a value of 600 or greater produces the same "
"effects as defining B<_POSIX_C_SOURCE> with a value of 200112L or greater.  "
"Where one sees"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:179
#, no-wrap
msgid "_POSIX_C_SOURCE E<gt>= 200112L\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:184
#: man-pages/man7/feature_test_macros.7:206
msgid ""
"in the feature test macro requirements in the SYNOPSIS of a man page, it is "
"implicit that the following has the same effect:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:188
#, no-wrap
msgid "_XOPEN_SOURCE E<gt>= 600\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:197
msgid ""
"Defining B<_XOPEN_SOURCE> with a value of 700 or greater produces the same "
"effects as defining B<_POSIX_C_SOURCE> with a value of 200809L or greater.  "
"Where one sees"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:201
#, no-wrap
msgid "_POSIX_C_SOURCE E<gt>= 200809L\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:210
#, no-wrap
msgid "_XOPEN_SOURCE E<gt>= 700\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:217
msgid "Linux glibc understands the following feature test macros:"
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:217
#, no-wrap
msgid "B<__STRICT_ANSI__>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:227
msgid ""
"ISO Standard C.  This macro is implicitly defined by B<gcc>(1)  when invoked"
" with, for example, the I<-std=c99> or I<-ansi> flag."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:227
#, no-wrap
msgid "B<_POSIX_C_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:230
#: man-pages/man7/feature_test_macros.7:269
msgid ""
"Defining this macro causes header files to expose definitions as follows:"
msgstr ""

#. type: IP
#: man-pages/man7/feature_test_macros.7:231
#: man-pages/man7/feature_test_macros.7:234
#: man-pages/man7/feature_test_macros.7:237
#: man-pages/man7/feature_test_macros.7:241
#: man-pages/man7/feature_test_macros.7:244
#: man-pages/man7/feature_test_macros.7:252
#: man-pages/man7/feature_test_macros.7:270
#: man-pages/man7/feature_test_macros.7:273
#: man-pages/man7/feature_test_macros.7:276
#: man-pages/man7/feature_test_macros.7:280
#: man-pages/man7/feature_test_macros.7:299
#: man-pages/man7/feature_test_macros.7:302
#: man-pages/man7/feature_test_macros.7:709
#: man-pages/man7/feature_test_macros.7:714
#: man-pages/man7/feature_test_macros.7:720
#: man-pages/man7/feature_test_macros.7:725
#: man-pages/man7/feature_test_macros.7:731
#: man-pages/man7/feature_test_macros.7:736
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:234
msgid ""
"The value 1 exposes definitions conforming to POSIX.1-1990 and ISO C (1990)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:237
msgid ""
"The value 2 or greater additionally exposes definitions for POSIX.2-1992."
msgstr ""

#.  199506L functionality is available only since glibc 2.1
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:241
msgid ""
"The value 199309L or greater additionally exposes definitions for POSIX.1b "
"(real-time extensions)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:244
msgid ""
"The value 199506L or greater additionally exposes definitions for POSIX.1c "
"(threads)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:252
msgid ""
"(Since glibc 2.3.3)  The value 200112L or greater additionally exposes "
"definitions corresponding to the POSIX.1-2001 base specification (excluding "
"the XSI extension).  This value also causes C95 (since glibc 2.12) and C99 "
"(since glibc 2.10) features to be exposed (in other words, the equivalent of"
" defining B<_ISOC99_SOURCE>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:256
msgid ""
"(Since glibc 2.10)  The value 200809L or greater additionally exposes "
"definitions corresponding to the POSIX.1-2008 base specification (excluding "
"the XSI extension)."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:257
#, no-wrap
msgid "B<_POSIX_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:262
msgid ""
"Defining this obsolete macro with any value is equivalent to defining "
"B<_POSIX_C_SOURCE> with the value 1."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:266
msgid ""
"Since this macro is obsolete, its usage is generally not documented when "
"discussing feature test macro requirements in the man pages."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:266
#, no-wrap
msgid "B<_XOPEN_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:273
msgid ""
"Defining with any value exposes definitions conforming to POSIX.1, POSIX.2, "
"and XPG4."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:276
msgid ""
"The value 500 or greater additionally exposes definitions for SUSv2 (UNIX "
"98)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:280
msgid ""
"(Since glibc 2.2) The value 600 or greater additionally exposes definitions "
"for SUSv3 (UNIX 03; i.e., the POSIX.1-2001 base specification plus the XSI "
"extension) and C99 definitions."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:284
msgid ""
"(Since glibc 2.10) The value 700 or greater additionally exposes definitions"
" for SUSv4 (i.e., the POSIX.1-2008 base specification plus the XSI "
"extension)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:298
msgid ""
"If B<__STRICT_ANSI__> is not defined, or B<_XOPEN_SOURCE> is defined with a "
"value greater than or equal to 500 I<and> neither B<_POSIX_SOURCE> nor "
"B<_POSIX_C_SOURCE> is explicitly defined, then the following macros are "
"implicitly defined:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:302
msgid "B<_POSIX_SOURCE> is defined with the value 1."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:306
msgid ""
"B<_POSIX_C_SOURCE> is defined, according to the value of B<_XOPEN_SOURCE>:"
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:307
#, no-wrap
msgid "B<_XOPEN_SOURCE> E<lt> 500"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:311
msgid "B<_POSIX_C_SOURCE> is defined with the value 2."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:311
#, no-wrap
msgid "500 E<lt>= B<_XOPEN_SOURCE> E<lt> 600"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:315
msgid "B<_POSIX_C_SOURCE> is defined with the value 199506L."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:315
#, no-wrap
msgid "600 E<lt>= B<_XOPEN_SOURCE> E<lt> 700"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:319
msgid "B<_POSIX_C_SOURCE> is defined with the value 200112L."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:319
#, no-wrap
msgid "700 E<lt>= B<_XOPEN_SOURCE> (since glibc 2.10)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:323
msgid "B<_POSIX_C_SOURCE> is defined with the value 200809L."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:330
msgid ""
"In addition, defining B<_XOPEN_SOURCE> with a value of 500 or greater "
"produces the same effects as defining B<_XOPEN_SOURCE_EXTENDED>."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:330
#, no-wrap
msgid "B<_XOPEN_SOURCE_EXTENDED>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:344
msgid ""
"If this macro is defined, I<and> B<_XOPEN_SOURCE> is defined, then expose "
"definitions corresponding to the XPG4v2 (SUSv1) UNIX extensions (UNIX 95).  "
"Defining B<_XOPEN_SOURCE> with a value of 500 or more also produces the same"
" effect as defining B<_XOPEN_SOURCE_EXTENDED>.  Use of "
"B<_XOPEN_SOURCE_EXTENDED> in new source code should be avoided."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:351
msgid ""
"Since defining B<_XOPEN_SOURCE> with a value of 500 or more has the same "
"effect as defining B<_XOPEN_SOURCE_EXTENDED>, the latter (obsolete) feature "
"test macro is generally not described in the SYNOPSIS in man pages."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:351
#, no-wrap
msgid "B<_ISOC99_SOURCE> (since glibc 2.1.3)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:354
msgid "Exposes declarations consistent with the ISO C99 standard."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:360
msgid ""
"Earlier glibc 2.1.x versions recognized an equivalent macro named "
"B<_ISOC9X_SOURCE> (because the C99 standard had not then been finalized).  "
"Although the use of this macro is obsolete, glibc continues to recognize it "
"for backward compatibility."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:365
msgid ""
"Defining B<_ISOC99_SOURCE> also exposes ISO C (1990) Amendment 1 (\"C95\") "
"definitions.  (The primary change in C95 was support for international "
"character sets.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:369
msgid ""
"Invoking the C compiler with the option I<-std=c99> produces the same "
"effects as defining this macro."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:369
#, no-wrap
msgid "B<_ISOC11_SOURCE> (since glibc 2.16)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:374
msgid ""
"Exposes declarations consistent with the ISO C11 standard.  Defining this "
"macro also enables C99 and C95 features (like B<_ISOC99_SOURCE>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:378
msgid ""
"Invoking the C compiler with the option I<-std=c11> produces the same "
"effects as defining this macro."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:378
#, no-wrap
msgid "B<_LARGEFILE64_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:399
msgid ""
"Expose definitions for the alternative API specified by the LFS (Large File "
"Summit) as a \"transitional extension\" to the Single UNIX Specification.  "
"(See E<.UR http:\\:/\\:/opengroup.org\\:/platform\\:/lfs.html> E<.UE .)> The"
" alternative API consists of a set of new objects (i.e., functions and "
"types) whose names are suffixed with \"64\" (e.g., I<off64_t> versus "
"I<off_t>, B<lseek64>()  versus B<lseek>(), etc.).  New programs should not "
"employ this macro; instead I<_FILE_OFFSET_BITS=64> should be employed."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:399
#, no-wrap
msgid "B<_LARGEFILE_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:421
msgid ""
"This macro was historically used to expose certain functions (specifically "
"B<fseeko>(3)  and B<ftello>(3))  that address limitations of earlier APIs "
"(B<fseek>(3)  and B<ftell>(3))  that use I<long int> for file offsets.  This"
" macro is implicitly defined if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 500.  New programs should not employ this macro; "
"defining B<_XOPEN_SOURCE> as just described or defining B<_FILE_OFFSET_BITS>"
" with the value 64 is the preferred mechanism to achieve the same result."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:421
#, no-wrap
msgid "B<_FILE_OFFSET_BITS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:431
msgid ""
"Defining this macro with the value 64 automatically converts references to "
"32-bit functions and data types related to file I/O and filesystem "
"operations into references to their 64-bit counterparts.  This is useful for"
" performing I/O on large files (E<gt> 2 Gigabytes)  on 32-bit systems.  "
"(Defining this macro permits correctly written programs to use large files "
"with only a recompilation being required.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:434
msgid ""
"64-bit systems naturally permit file sizes greater than 2 Gigabytes, and on "
"those systems this macro has no effect."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:434
#, no-wrap
msgid "B<_BSD_SOURCE> (deprecated since glibc 2.20)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:438
msgid ""
"Defining this macro with any value causes header files to expose BSD-derived"
" definitions."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:453
msgid ""
"In glibc versions up to and including 2.18, defining this macro also causes "
"BSD definitions to be preferred in some situations where standards conflict,"
" unless one or more of B<_SVID_SOURCE>, B<_POSIX_SOURCE>, "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, or "
"B<_GNU_SOURCE> is defined, in which case BSD definitions are disfavored.  "
"Since glibc 2.19, B<_BSD_SOURCE> no longer causes BSD definitions to be "
"preferred in case of conflicts."
msgstr ""

#.  commit c941736c92fa3a319221f65f6755659b2a5e0a20
#.  commit 498afc54dfee41d33ba519f496e96480badace8e
#.  commit acd7f096d79c181866d56d4aaf3b043e741f1e2c
#.  commit ade40b10ff5fa59a318cf55b9d8414b758e8df78
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:476
msgid ""
"Since glibc 2.20, this macro is deprecated.  It now has the same effect as "
"defining B<_DEFAULT_SOURCE>, but generates a compile-time warning (unless "
"B<_DEFAULT_SOURCE> is also defined).  Use B<_DEFAULT_SOURCE> instead.  To "
"allow code that requires B<_BSD_SOURCE> in glibc 2.19 and earlier and "
"B<_DEFAULT_SOURCE> in glibc 2.20 and later to compile without warnings, "
"define I<both> B<_BSD_SOURCE> and B<_DEFAULT_SOURCE>."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:476
#, no-wrap
msgid "B<_SVID_SOURCE> (deprecated since glibc 2.20)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:482
msgid ""
"Defining this macro with any value causes header files to expose System "
"V-derived definitions.  (SVID == System V Interface Definition; see "
"B<standards>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:485
msgid ""
"Since glibc 2.20, this macro is deprecated in the same fashion as "
"B<_BSD_SOURCE>."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:485
#, no-wrap
msgid "B<_DEFAULT_SOURCE> (since glibc 2.19)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:497
msgid ""
"This macro can be defined to ensure that the \"default\" definitions are "
"provided even when the defaults would otherwise be disabled, as happens when"
" individual macros are explicitly defined, or the compiler is invoked in one"
" of its \"standard\" modes (e.g., I<cc\\ -std=c99>).  Defining "
"B<_DEFAULT_SOURCE> without defining other individual macros or invoking the "
"compiler in one of its \"standard\" modes has no effect."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:502
msgid ""
"The \"default\" definitions comprise those required by POSIX.1-2008 and ISO "
"C99, as well as various definitions originally derived from BSD and System "
"V.  On glibc 2.19 and earlier, these defaults were approximately equivalent "
"to explicitly defining the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:504
#, no-wrap
msgid "    cc -D_BSD_SOURCE -D_SVID_SOURCE -D_POSIX_C_SOURCE=200809\n"
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:504
#, no-wrap
msgid "B<_ATFILE_SOURCE> (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:513
msgid ""
"Defining this macro with any value causes header files to expose "
"declarations of a range of functions with the suffix \"at\"; see "
"B<openat>(2).  Since glibc 2.10, this macro is also implicitly defined if "
"B<_POSIX_C_SOURCE> is defined with a value greater than or equal to 200809L."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:513
#, no-wrap
msgid "B<_GNU_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:532
msgid ""
"Defining this macro (with any value) implicitly defines B<_ATFILE_SOURCE>, "
"B<_LARGEFILE64_SOURCE>, B<_ISOC99_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE> with the value 200809L (200112L in "
"glibc versions before 2.10; 199506L in glibc versions before 2.5; 199309L in"
" glibc versions before 2.1)  and B<_XOPEN_SOURCE> with the value 700 (600 in"
" glibc versions before 2.10; 500 in glibc versions before 2.2).  In "
"addition, various GNU-specific extensions are also exposed."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:543
msgid ""
"Since glibc 2.19, defining B<_GNU_SOURCE> also has the effect of implicitly "
"defining B<_DEFAULT_SOURCE>.  In glibc versions before 2.20, defining "
"B<_GNU_SOURCE> also had the effect of implicitly defining B<_BSD_SOURCE> and"
" B<_SVID_SOURCE>."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:543
#, no-wrap
msgid "B<_REENTRANT>"
msgstr ""

#.  Zack Weinberg
#.      There did once exist C libraries where it was necessary. The ones
#.      I remember were proprietary Unix vendor libcs from the mid-1990s
#.      You would get completely unlocked stdio without _REENTRANT.
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:555
msgid ""
"Historically, on various C libraries it was necessary to define this macro "
"in all multithreaded code.  (Some C libraries may still require this.)  In "
"glibc, this macro also exposed definitions of certain reentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:563
msgid ""
"However, glibc has been thread-safe by default for many years; since glibc "
"2.3, the only effect of defining B<_REENTRANT> has been to enable one or two"
" of the same declarations that are also enabled by defining "
"B<_POSIX_C_SOURCE> with a value of 199606L or greater."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:582
msgid ""
"B<_REENTRANT> is now obsolete.  In glibc 2.25 and later, defining "
"B<_REENTRANT> is equivalent to defining B<_POSIX_C_SOURCE> with the value "
"199606L.  If a higher POSIX conformance level is selected by any other means"
" (such as B<_POSIX_C_SOURCE> itself, B<_XOPEN_SOURCE>, B<_DEFAULT_SOURCE>, "
"or B<_GNU_SOURCE>), then defining B<_REENTRANT> has no effect."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:585
msgid ""
"This macro is automatically defined if one compiles with I<cc\\ -pthread>."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:585
#, no-wrap
msgid "B<_THREAD_SAFE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:590
msgid ""
"Synonym for the (deprecated)  B<_REENTRANT>, provided for compatibility with"
" some other implementations."
msgstr ""

#. type: TP
#: man-pages/man7/feature_test_macros.7:590
#, no-wrap
msgid "B<_FORTIFY_SOURCE> (since glibc 2.3.4)"
msgstr ""

#.  For more detail, see:
#.  http://gcc.gnu.org/ml/gcc-patches/2004-09/msg02055.html
#.  [PATCH] Object size checking to prevent (some) buffer overflows
#.  * From: Jakub Jelinek <jakub at redhat dot com>
#.  * To: gcc-patches at gcc dot gnu dot org
#.  * Date: Tue, 21 Sep 2004 04:16:40 -0400
#.  Look for __USE_FORTIFY_LEVEL in the header files
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:623
msgid ""
"Defining this macro causes some lightweight checks to be performed to detect"
" some buffer overflow errors when employing various string and memory "
"manipulation functions (for example, B<memcpy>(3), B<memset>(3), "
"B<stpcpy>(3), B<strcpy>(3), B<strncpy>(3), B<strcat>(3), B<strncat>(3), "
"B<sprintf>(3), B<snprintf>(3), B<vsprintf>(3), B<vsnprintf>(3), B<gets>(3), "
"and wide character variants thereof).  For some functions, argument "
"consistency is checked; for example, a check is made that B<open>(2)  has "
"been supplied with a I<mode> argument when the specified flags include "
"B<O_CREAT>.  Not all problems are detected, just some common cases."
msgstr ""

#.  For example, given the following code
#.         int d;
#.         char buf[1000], buf[1000];
#.         strcpy(fmt, "Hello world
#. %n");
#.         snprintf(buf, sizeof(buf), fmt, &d);
#.  Compiling with "gcc -D_FORTIFY_SOURCE=2 -O1" and then running will
#.  cause the following diagnostic at run time at the snprintf() call
#.         *** %n in writable segment detected ***
#.         Aborted (core dumped)
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:646
msgid ""
"If B<_FORTIFY_SOURCE> is set to 1, with compiler optimization level 1 "
"(I<gcc\\ -O1>)  and above, checks that shouldn't change the behavior of "
"conforming programs are performed.  With B<_FORTIFY_SOURCE> set to 2, some "
"more checking is added, but some conforming programs might fail."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:652
msgid ""
"Some of the checks can be performed at compile time (via macros logic "
"implemented in header files), and result in compiler warnings; other checks "
"take place at run time, and result in a run-time error if the check fails."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:656
msgid ""
"Use of this macro requires compiler support, available with B<gcc>(1)  since"
" version 4.0."
msgstr ""

#. type: SS
#: man-pages/man7/feature_test_macros.7:656
#, no-wrap
msgid "Default definitions, implicit definitions, and combining definitions"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:672
msgid ""
"If no feature test macros are explicitly defined, then the following feature"
" test macros are defined by default: B<_BSD_SOURCE> (in glibc 2.19 and "
"earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), B<_DEFAULT_SOURCE> "
"(since glibc 2.19), B<_POSIX_SOURCE>, and B<_POSIX_C_SOURCE>=200809L "
"(200112L in glibc versions before 2.10; 199506L in glibc versions before "
"2.4; 199309L in glibc versions before 2.1)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:691
msgid ""
"If any of B<__STRICT_ANSI__>, B<_ISOC99_SOURCE>, B<_POSIX_SOURCE>, "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, "
"B<_BSD_SOURCE> (in glibc 2.19 and earlier), or B<_SVID_SOURCE> (in glibc "
"2.19 and earlier)  is explicitly defined, then B<_BSD_SOURCE>, "
"B<_SVID_SOURCE>, and B<_DEFAULT_SOURCE> are not defined by default."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:702
msgid ""
"If B<_POSIX_SOURCE> and B<_POSIX_C_SOURCE> are not explicitly defined, and "
"either B<__STRICT_ANSI__> is not defined or B<_XOPEN_SOURCE> is defined with"
" a value of 500 or more, then"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:705
msgid "B<_POSIX_SOURCE> is defined with the value 1; and"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:708
msgid "B<_POSIX_C_SOURCE> is defined with one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:714
msgid "2, if B<_XOPEN_SOURCE> is defined with a value less than 500;"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:720
msgid ""
"199506L, if B<_XOPEN_SOURCE> is defined with a value greater than or equal "
"to 500 and less than 600; or"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:725
msgid ""
"(since glibc 2.4) 200112L, if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 600 and less than 700."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:731
msgid ""
"(Since glibc 2.10)  200809L, if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 700."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:736
msgid ""
"Older versions of glibc do not know about the values 200112L and 200809L for"
" B<_POSIX_C_SOURCE>, and the setting of this macro will depend on the glibc "
"version."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:745
msgid ""
"If B<_XOPEN_SOURCE> is undefined, then the setting of B<_POSIX_C_SOURCE> "
"depends on the glibc version: 199506L, in glibc versions before 2.4; "
"200112L, in glibc 2.4 to 2.9; and 200809L, since glibc 2.10."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:748
msgid "Multiple macros can be defined; the results are additive."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:754
msgid ""
"POSIX.1 specifies B<_POSIX_C_SOURCE>, B<_POSIX_SOURCE>, and "
"B<_XOPEN_SOURCE>."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:760
msgid ""
"B<_XOPEN_SOURCE_EXTENDED> was specified by XPG4v2 (aka SUSv1), but is not "
"present in SUSv2 and later.  B<_FILE_OFFSET_BITS> is not specified by any "
"standard, but is employed on some other implementations."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:771
msgid ""
"B<_BSD_SOURCE>, B<_SVID_SOURCE>, B<_DEFAULT_SOURCE>, B<_ATFILE_SOURCE>, "
"B<_GNU_SOURCE>, B<_FORTIFY_SOURCE>, B<_REENTRANT>, and B<_THREAD_SAFE> are "
"specific to Linux (glibc)."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:778
msgid ""
"I<E<lt>features.hE<gt>> is a Linux/glibc-specific header file.  Other "
"systems have an analogous file, but typically with a different name.  This "
"header file is automatically included by other header files as required: it "
"is not necessary to explicitly include it in order to employ feature test "
"macros."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:790
msgid ""
"According to which of the above feature test macros are defined, "
"I<E<lt>features.hE<gt>> internally defines various other macros that are "
"checked by other glibc header files.  These macros have names prefixed by "
"two underscores (e.g., B<__USE_MISC>).  Programs should I<never> define "
"these macros directly: instead, the appropriate feature test macro(s) from "
"the list above should be employed."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:796
msgid ""
"The program below can be used to explore how the various feature test macros"
" are set depending on the glibc version and what feature test macros are "
"explicitly set.  The following shell session, on a system with glibc 2.10, "
"shows some examples of what we would see:"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:823
#, no-wrap
msgid ""
"$ B<cc ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"$ B<cc -D_XOPEN_SOURCE=500 ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 199506L\n"
"_XOPEN_SOURCE defined: 500\n"
"$ B<cc -D_GNU_SOURCE ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_ISOC99_SOURCE defined\n"
"_XOPEN_SOURCE defined: 700\n"
"_XOPEN_SOURCE_EXTENDED defined\n"
"_LARGEFILE64_SOURCE defined\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"_GNU_SOURCE defined\n"
msgstr ""

#. type: SS
#: man-pages/man7/feature_test_macros.7:825
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:829
#, no-wrap
msgid "/* ftm.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:833
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:840
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#ifdef _POSIX_SOURCE\n"
"    printf(\"_POSIX_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:844
#, no-wrap
msgid ""
"#ifdef _POSIX_C_SOURCE\n"
"    printf(\"_POSIX_C_SOURCE defined: %ldL\\en\", (long) _POSIX_C_SOURCE);\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:848
#, no-wrap
msgid ""
"#ifdef _ISOC99_SOURCE\n"
"    printf(\"_ISOC99_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:852
#, no-wrap
msgid ""
"#ifdef _ISOC11_SOURCE\n"
"    printf(\"_ISOC11_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:856
#, no-wrap
msgid ""
"#ifdef _XOPEN_SOURCE\n"
"    printf(\"_XOPEN_SOURCE defined: %d\\en\", _XOPEN_SOURCE);\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:860
#, no-wrap
msgid ""
"#ifdef _XOPEN_SOURCE_EXTENDED\n"
"    printf(\"_XOPEN_SOURCE_EXTENDED defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:864
#, no-wrap
msgid ""
"#ifdef _LARGEFILE64_SOURCE\n"
"    printf(\"_LARGEFILE64_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:868
#, no-wrap
msgid ""
"#ifdef _FILE_OFFSET_BITS\n"
"    printf(\"_FILE_OFFSET_BITS defined: %d\\en\", _FILE_OFFSET_BITS);\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:872
#, no-wrap
msgid ""
"#ifdef _BSD_SOURCE\n"
"    printf(\"_BSD_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:876
#, no-wrap
msgid ""
"#ifdef _SVID_SOURCE\n"
"    printf(\"_SVID_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:880
#, no-wrap
msgid ""
"#ifdef _DEFAULT_SOURCE\n"
"    printf(\"_DEFAULT_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:884
#, no-wrap
msgid ""
"#ifdef _ATFILE_SOURCE\n"
"    printf(\"_ATFILE_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:888
#, no-wrap
msgid ""
"#ifdef _GNU_SOURCE\n"
"    printf(\"_GNU_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:892
#, no-wrap
msgid ""
"#ifdef _REENTRANT\n"
"    printf(\"_REENTRANT defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:896
#, no-wrap
msgid ""
"#ifdef _THREAD_SAFE\n"
"    printf(\"_THREAD_SAFE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:900
#, no-wrap
msgid ""
"#ifdef _FORTIFY_SOURCE\n"
"    printf(\"_FORTIFY_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:903
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:907
msgid "B<libc>(7), B<standards>(7)"
msgstr ""

#.  But beware: the info libc document is out of date (Jul 07, mtk)
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:911
msgid "The section \"Feature Test Macros\" under I<info libc>."
msgstr ""

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:912
msgid "I</usr/include/features.h>"
msgstr ""

#. type: TH
#: man-pages/man7/fifo.7:12
#, no-wrap
msgid "FIFO"
msgstr ""

#. type: TH
#: man-pages/man7/fifo.7:12
#, no-wrap
msgid "2017-11-26"
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:15
msgid "fifo - first-in first-out special file, named pipe"
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:27
msgid ""
"A FIFO special file (a named pipe) is similar to a pipe, except that it is "
"accessed as part of the filesystem.  It can be opened by multiple processes "
"for reading or writing.  When processes are exchanging data via the FIFO, "
"the kernel passes all data internally without writing it to the filesystem."
"  Thus, the FIFO special file has no contents on the filesystem; the "
"filesystem entry merely serves as a reference point so that processes can "
"access the pipe using a name in the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:34
msgid ""
"The kernel maintains exactly one pipe object for each FIFO special file that"
" is opened by at least one process.  The FIFO must be opened on both ends "
"(reading and writing)  before data can be passed.  Normally, opening the "
"FIFO blocks until the other end is opened also."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:43
msgid ""
"A process can open a FIFO in nonblocking mode.  In this case, opening for "
"read-only succeeds even if no one has opened on the write side yet and "
"opening for write-only fails with B<ENXIO> (no such device or address) "
"unless the other end has already been opened."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:53
msgid ""
"Under Linux, opening a FIFO for read and write will succeed both in blocking"
" and nonblocking mode.  POSIX leaves this behavior undefined.  This can be "
"used to open a FIFO for writing while there are no readers available.  A "
"process that uses both ends of the connection in order to communicate with "
"itself should be very careful to avoid deadlocks."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:56
msgid "For details of the semantics of I/O on FIFOs, see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:61
msgid ""
"When a process tries to write to a FIFO that is not opened for read on the "
"other side, the process is sent a B<SIGPIPE> signal."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:67
msgid ""
"FIFO special files can be created by B<mkfifo>(3), and are indicated by "
"I<ls\\ -l> with the file type \\(aqp\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man7/fifo.7:75
msgid ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), "
"B<socketpair>(2), B<mkfifo>(3), B<pipe>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/futex.7:11
#, no-wrap
msgid "FUTEX"
msgstr ""

#. type: TH
#: man-pages/man7/futex.7:11
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:14
msgid "futex - fast user-space locking"
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:17
#, no-wrap
msgid "B<#include E<lt>linux/futex.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:26
msgid ""
"The Linux kernel provides futexes (\"Fast user-space mutexes\")  as a "
"building block for fast user-space locking and semaphores.  Futexes are very"
" basic and lend themselves well for building higher-level locking "
"abstractions such as mutexes, condition variables, read-write locks, "
"barriers, and semaphores."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:31
msgid ""
"Most programmers will in fact not be using futexes directly but will instead"
" rely on system libraries built on them, such as the Native POSIX Thread "
"Library (NPTL) (see B<pthreads>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:38
msgid ""
"A futex is identified by a piece of memory which can be shared between "
"processes or threads.  In these different processes, the futex need not have"
" identical addresses.  In its bare form, a futex has semaphore semantics; it"
" is a counter that can be incremented and decremented atomically; processes "
"can wait for the value to become positive."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:43
msgid ""
"Futex operation occurs entirely in user space for the noncontended case.  "
"The kernel is involved only to arbitrate the contended case.  As any sane "
"design will strive for noncontention, futexes are also optimized for this "
"situation."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:51
msgid ""
"In its bare form, a futex is an aligned integer which is touched only by "
"atomic assembler instructions.  This integer is four bytes long on all "
"platforms.  Processes can share this integer using B<mmap>(2), via shared "
"memory segments, or because they share memory space, in which case the "
"application is commonly called multithreaded."
msgstr ""

#. type: SS
#: man-pages/man7/futex.7:51
#, no-wrap
msgid "Semantics"
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:57
msgid ""
"Any futex operation starts in user space, but it may be necessary to "
"communicate with the kernel using the B<futex>(2)  system call."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:63
msgid ""
"To \"up\" a futex, execute the proper assembler instructions that will cause"
" the host CPU to atomically increment the integer.  Afterward, check if it "
"has in fact changed from 0 to 1, in which case there were no waiters and the"
" operation is done.  This is the noncontended case which is fast and should "
"be common."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:71
msgid ""
"In the contended case, the atomic increment changed the counter from -1 (or "
"some other negative number).  If this is detected, there are waiters.  User "
"space should now set the counter to 1 and instruct the kernel to wake up any"
" waiters using the B<FUTEX_WAKE> operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:80
msgid ""
"Waiting on a futex, to \"down\" it, is the reverse operation.  Atomically "
"decrement the counter and check if it changed to 0, in which case the "
"operation is done and the futex was uncontended.  In all other "
"circumstances, the process should set the counter to -1 and request that the"
" kernel wait for another process to up the futex.  This is done using the "
"B<FUTEX_WAIT> operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:92
msgid ""
"The B<futex>(2)  system call can optionally be passed a timeout specifying "
"how long the kernel should wait for the futex to be upped.  In this case, "
"semantics are more complex and the programmer is referred to B<futex>(2)  "
"for more details.  The same holds for asynchronous futex waiting."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:97
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics"
" from those described above.  Current semantics are available from Linux "
"2.5.40 onward."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:104
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end users.  Implementors are expected to be assembly literate and to "
"have read the sources of the futex user-space library referenced below."
msgstr ""

#.  .SH AUTHORS
#.  .PP
#.  Futexes were designed and worked on by Hubertus Franke
#.  (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat) and
#.  Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: man-pages/man7/futex.7:115
msgid ""
"This man page illustrates the most common use of the B<futex>(2)  "
"primitives; it is by no means the only one."
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:122
msgid ""
"B<clone>(2), B<futex>(2), B<get_robust_list>(2), B<set_robust_list>(2), "
"B<set_tid_address>(2), B<pthreads>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/futex.7:127
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), futex example library, futex-*.tar.bz2 "
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE .>"
msgstr ""

#. type: TH
#: man-pages/man2/fork.2:39
#, no-wrap
msgid "FORK"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:42
msgid "fork - create a child process"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:44
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:48
msgid "B<pid_t fork(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:57
msgid ""
"B<fork>()  creates a new process by duplicating the calling process.  The "
"new process is referred to as the I<child> process.  The calling process is "
"referred to as the I<parent> process."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:67
msgid ""
"The child process and the parent process run in separate memory spaces.  At "
"the time of B<fork>()  both memory spaces have the same content.  Memory "
"writes, file mappings (B<mmap>(2)), and unmappings (B<munmap>(2))  performed"
" by one of the processes do not affect the other."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:70
msgid ""
"The child process is an exact duplicate of the parent process except for the"
" following points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:75
msgid ""
"The child has its own unique process ID, and this PID does not match the ID "
"of any existing process group (B<setpgid>(2))  or session."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:77
msgid "The child's parent process ID is the same as the parent's process ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:81
msgid ""
"The child does not inherit its parent's memory locks (B<mlock>(2), "
"B<mlockall>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:87
msgid ""
"Process resource utilizations (B<getrusage>(2))  and CPU time counters "
"(B<times>(2))  are reset to zero in the child."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:90
msgid ""
"The child's set of pending signals is initially empty (B<sigpending>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:93
msgid ""
"The child does not inherit semaphore adjustments from its parent "
"(B<semop>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:101
msgid ""
"The child does not inherit process-associated record locks from its parent "
"(B<fcntl>(2)).  (On the other hand, it does inherit B<fcntl>(2)  open file "
"description locks and B<flock>(2)  locks from its parent.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:106
msgid ""
"The child does not inherit timers from its parent (B<setitimer>(2), "
"B<alarm>(2), B<timer_create>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:113
msgid ""
"The child does not inherit outstanding asynchronous I/O operations from its "
"parent (B<aio_read>(3), B<aio_write>(3)), nor does it inherit any "
"asynchronous I/O contexts from its parent (see B<io_setup>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:118
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The parent and child also differ with respect to the following Linux-"
"specific process attributes:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:125
msgid ""
"The child does not inherit directory change notifications (dnotify)  from "
"its parent (see the description of B<F_NOTIFY> in B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:131
msgid ""
"The B<prctl>(2)  B<PR_SET_PDEATHSIG> setting is reset so that the child does"
" not receive a signal when its parent terminates."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:138
msgid ""
"The default timer slack value is set to the parent's current timer slack "
"value.  See the description of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:144
msgid ""
"Memory mappings that have been marked with the B<madvise>(2)  "
"B<MADV_DONTFORK> flag are not inherited across a B<fork>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:153
msgid ""
"Memory in address ranges that have been marked with the B<madvise>(2)  "
"B<MADV_WIPEONFORK> flag is zeroed in the child after a B<fork>().  (The "
"B<MADV_WIPEONFORK> setting remains in place for those address ranges in the "
"child.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:158
msgid ""
"The termination signal of the child is always B<SIGCHLD> (see B<clone>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:164
msgid ""
"The port access permission bits set by B<ioperm>(2)  are not inherited by "
"the child; the child must turn on any bits that it requires using "
"B<ioperm>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:166
msgid "Note the following further points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:175
msgid ""
"The child process is created with a single thread\\(emthe one that called "
"B<fork>().  The entire virtual address space of the parent is replicated in "
"the child, including the states of mutexes, condition variables, and other "
"pthreads objects; the use of B<pthread_atfork>(3)  may be helpful for "
"dealing with problems that this can cause."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:183
msgid ""
"After a B<fork>()  in a multithreaded program, the child can safely call "
"only async-signal-safe functions (see B<signal-safety>(7))  until such time "
"as it calls B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:197
msgid ""
"The child inherits copies of the parent's set of open file descriptors.  "
"Each file descriptor in the child refers to the same open file description "
"(see B<open>(2))  as the corresponding file descriptor in the parent.  This "
"means that the two file descriptors share open file status flags, file "
"offset, and signal-driven I/O attributes (see the description of B<F_SETOWN>"
" and B<F_SETSIG> in B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:206
msgid ""
"The child inherits copies of the parent's set of open message queue "
"descriptors (see B<mq_overview>(7)).  Each file descriptor in the child "
"refers to the same open message queue description as the corresponding file "
"descriptor in the parent.  This means that the two file descriptors share "
"the same flags (I<mq_flags>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:214
msgid ""
"The child inherits copies of the parent's set of open directory streams (see"
" B<opendir>(3)).  POSIX.1 says that the corresponding directory streams in "
"the parent and child I<may> share the directory stream positioning; on "
"Linux/glibc they do not."
msgstr ""

#. type: SH
#: man-pages/man2/fork.2:214
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:221
msgid ""
"On success, the PID of the child process is returned in the parent, and 0 is"
" returned in the child.  On failure, -1 is returned in the parent, no child "
"process is created, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/fork.2:222 man-pages/man2/fork.2:251
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#.  NOTE! The following should match the description in pthread_create(3)
#. type: Plain text
#: man-pages/man2/fork.2:227
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:235
msgid ""
"the B<RLIMIT_NPROC> soft resource limit (set via B<setrlimit>(2)), which "
"limits the number of processes and threads for a real user ID, was reached;"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:240
msgid ""
"the kernel's system-wide limit on the number of processes and threads, "
"I</proc/sys/kernel/threads-max>, was reached (see B<proc>(5));"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:246
msgid ""
"the maximum number of PIDs, I</proc/sys/kernel/pid_max>, was reached (see "
"B<proc>(5)); or"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:250
msgid ""
"the PID limit (I<pids.max>)  imposed by the cgroup \"process number\" (PIDs)"
" controller was reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:258
msgid ""
"The caller is operating under the B<SCHED_DEADLINE> scheduling policy and "
"does not have the reset-on-fork flag set.  See B<sched>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/fork.2:258 man-pages/man2/fork.2:262
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:262
msgid ""
"B<fork>()  failed to allocate the necessary kernel structures because memory"
" is tight."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:268
msgid ""
"An attempt was made to create a child process in a PID namespace whose "
"\"init\" process has terminated.  See B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/fork.2:268
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#.  e.g., arm (optionally), blackfin, c6x, frv, h8300, microblaze, xtensa
#. type: Plain text
#: man-pages/man2/fork.2:274
msgid ""
"B<fork>()  is not supported on this platform (for example, hardware without "
"a Memory-Management Unit)."
msgstr ""

#. type: TP
#: man-pages/man2/fork.2:274
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr ""

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
#: man-pages/man2/fork.2:279
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be"
" seen only during a trace.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:281
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:288
msgid ""
"Under Linux, B<fork>()  is implemented using copy-on-write pages, so the "
"only penalty that it incurs is the time and memory required to duplicate the"
" parent's page tables, and to create a unique task structure for the child."
msgstr ""

#. type: SS
#: man-pages/man2/fork.2:288
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  nptl/sysdeps/unix/sysv/linux/fork.c
#.  and does some magic to ensure that getpid(2) returns the right value.
#. type: Plain text
#: man-pages/man2/fork.2:312
msgid ""
"Since version 2.3.3, rather than invoking the kernel's B<fork>()  system "
"call, the glibc B<fork>()  wrapper that is provided as part of the NPTL "
"threading implementation invokes B<clone>(2)  with flags that provide the "
"same effect as the traditional system call.  (A call to B<fork>()  is "
"equivalent to a call to B<clone>(2)  specifying I<flags> as just "
"B<SIGCHLD>.)  The glibc wrapper invokes any fork handlers that have been "
"established using B<pthread_atfork>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:317
msgid "See B<pipe>(2)  and B<wait>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:328
msgid ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<pthread_atfork>(3), "
"B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:30
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:35
#, no-wrap
msgid ""
"B<int futex(int *>I<uaddr>B<, int >I<futex_op>B<, int >I<val>B<,>\n"
"B<          const struct timespec *>I<timeout>B<,>I< >  /* or: B<uint32_t >I<val2>B< */>\n"
"B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:57
msgid ""
"The B<futex>()  system call provides a method for waiting until a certain "
"condition becomes true.  It is typically used as a blocking construct in the"
" context of shared-memory synchronization.  When using futexes, the majority"
" of the synchronization operations are performed in user space.  A user-"
"space program employs the B<futex>()  system call only when it is likely "
"that the program has to block for a longer time until the condition becomes "
"true.  Other B<futex>()  operations can be used to wake any processes or "
"threads waiting for a particular condition."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:76
msgid ""
"A futex is a 32-bit value\\(emreferred to below as a I<futex word>\\(emwhose"
" address is supplied to the B<futex>()  system call.  (Futexes are 32 bits "
"in size on all platforms, including 64-bit systems.)  All futex operations "
"are governed by this value.  In order to share a futex between processes, "
"the futex is placed in a region of shared memory, created using (for "
"example)  B<mmap>(2)  or B<shmat>(2).  (Thus, the futex word may have "
"different virtual addresses in different processes, but these addresses all "
"refer to the same location in physical memory.)  In a multithreaded program,"
" it is sufficient to place the futex word in a global variable shared by all"
" threads."
msgstr ""

#.  Notes from Darren Hart (Dec 2015):
#.      Totally ordered with respect futex operations refers to semantics
#.      of the ACQUIRE/RELEASE operations and how they impact ordering of
#.      memory reads and writes. The kernel futex operations are protected
#.      by spinlocks, which ensure that all operations are serialized
#.      with respect to one another.
#.      This is a lot to attempt to define in this document. Perhaps a
#.      reference to linux/Documentation/memory-barriers.txt as a footnote
#.      would be sufficient? Or perhaps for this manual, "serialized" would
#.      be sufficient, with a footnote regarding "totally ordered" and a
#.      pointer to the memory-barrier documentation?
#.  FIXME(Torvald Riegel):
#.  Eventually we want to have some text in NOTES to satisfy
#.  the reference in the following sentence
#.      See NOTES for a detailed specification of
#.      the synchronization semantics.
#. type: Plain text
#: man-pages/man2/futex.2:109
msgid ""
"When executing a futex operation that requests to block a thread, the kernel"
" will block only if the futex word has the value that the calling thread "
"supplied (as one of the arguments of the B<futex>()  call) as the expected "
"value of the futex word.  The loading of the futex word's value, the "
"comparison of that value with the expected value, and the actual blocking "
"will happen atomically and will be totally ordered with respect to "
"concurrent operations performed by other threads on the same futex word.  "
"Thus, the futex word is used to connect the synchronization in user space "
"with the implementation of blocking by the kernel.  Analogously to an atomic"
" compare-and-exchange operation that potentially changes shared memory, "
"blocking via a futex is an atomic compare-and-block operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:136
msgid ""
"One use of futexes is for implementing locks.  The state of the lock (i.e., "
"acquired or not acquired)  can be represented as an atomically accessed flag"
" in shared memory.  In the uncontended case, a thread can access or modify "
"the lock state with atomic instructions, for example atomically changing it "
"from not acquired to acquired using an atomic compare-and-exchange "
"instruction.  (Such instructions are performed entirely in user mode, and "
"the kernel maintains no information about the lock state.)  On the other "
"hand, a thread may be unable to acquire a lock because it is already "
"acquired by another thread.  It then may pass the lock's flag as a futex "
"word and the value representing the acquired state as the expected value to "
"a B<futex>()  wait operation.  This B<futex>()  operation will block if and "
"only if the lock is still acquired (i.e., the value in the futex word still "
"matches the \"acquired state\").  When releasing the lock, a thread has to "
"first reset the lock state to not acquired and then execute a futex "
"operation that wakes threads blocked on the lock flag used as a futex word "
"(this can be further optimized to avoid unnecessary wake-ups).  See "
"B<futex>(7)  for more detail on how to use futexes."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:139
msgid ""
"Besides the basic wait and wake-up futex functionality, there are further "
"futex operations aimed at supporting more complex use cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:148
msgid ""
"Note that no explicit initialization or destruction is necessary to use "
"futexes; the kernel maintains a futex (i.e., the kernel-internal "
"implementation artifact)  only while operations such as B<FUTEX_WAIT>, "
"described below, are being performed on a particular futex word."
msgstr ""

#. type: SS
#: man-pages/man2/futex.2:148
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:160
msgid ""
"The I<uaddr> argument points to the futex word.  On all platforms, futexes "
"are four-byte integers that must be aligned on a four-byte boundary.  The "
"operation to perform on the futex is specified in the I<futex_op> argument; "
"I<val> is a value whose meaning and purpose depends on I<futex_op>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:168
msgid ""
"The remaining arguments (I<timeout>, I<uaddr2>, and I<val3>)  are required "
"only for certain of the futex operations described below.  Where one of "
"these arguments is not required, it is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:186
msgid ""
"For several blocking operations, the I<timeout> argument is a pointer to a "
"I<timespec> structure that specifies a timeout for the operation.  However, "
"notwithstanding the prototype shown above, for some operations, the least "
"significant four bytes of this argument are instead used as an integer whose"
" meaning is determined by the operation.  For these operations, the kernel "
"casts the I<timeout> value first to I<unsigned long>, then to I<uint32_t>, "
"and in the remainder of this page, this argument is referred to as I<val2> "
"when interpreted in this fashion."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:191
msgid ""
"Where it is required, the I<uaddr2> argument is a pointer to a second futex "
"word that is employed by the operation."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:198
msgid ""
"The interpretation of the final integer argument, I<val3>, depends on the "
"operation."
msgstr ""

#. type: SS
#: man-pages/man2/futex.2:198
#, no-wrap
msgid "Futex operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:208
msgid ""
"The I<futex_op> argument consists of two parts: a command that specifies the"
" operation to be performed, bit-wise ORed with zero or more options that "
"modify the behaviour of the operation.  The options that may be included in "
"I<futex_op> are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:208
#, no-wrap
msgid "B<FUTEX_PRIVATE_FLAG> (since Linux 2.6.22)"
msgstr ""

#.  commit 34f01cc1f512fa783302982776895c73714ebbc2
#.  I.e., It allows the kernel choose the fast path for validating
#.  the user-space address and avoids expensive VMA lookups,
#.  taking reference counts on file backing store, and so on.
#. type: Plain text
#: man-pages/man2/futex.2:219
msgid ""
"This option bit can be employed with all futex operations.  It tells the "
"kernel that the futex is process-private and not shared with another process"
" (i.e., it is being used for synchronization only between threads of the "
"same process).  This allows the kernel to make some additional performance "
"optimizations."
msgstr ""

#.  except the obsolete FUTEX_FD, for which the "private" flag was
#.  meaningless
#. type: Plain text
#: man-pages/man2/futex.2:234
msgid ""
"As a convenience, I<E<lt>linux/futex.hE<gt>> defines a set of constants with"
" the suffix B<_PRIVATE> that are equivalents of all of the operations listed"
" below, but with the B<FUTEX_PRIVATE_FLAG> ORed into the constant value.  "
"Thus, there are B<FUTEX_WAIT_PRIVATE>, B<FUTEX_WAKE_PRIVATE>, and so on."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:234
#, no-wrap
msgid "B<FUTEX_CLOCK_REALTIME> (since Linux 2.6.28)"
msgstr ""

#.  commit 1acdac104668a0834cfa267de9946fac7764d486
#.  commit 337f13046ff03717a9e99675284a817527440a49
#. type: Plain text
#: man-pages/man2/futex.2:245
msgid ""
"This option bit can be employed only with the B<FUTEX_WAIT_BITSET>, "
"B<FUTEX_WAIT_REQUEUE_PI>, and (since Linux 4.5)  B<FUTEX_WAIT> operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:251
msgid ""
"If this option is set, the kernel measures the I<timeout> against the "
"B<CLOCK_REALTIME> clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:257
msgid ""
"If this option is not set, the kernel measures the I<timeout> against the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:264
msgid "The operation specified in I<futex_op> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:264
#, no-wrap
msgid "B<FUTEX_WAIT> (since Linux 2.6.0)"
msgstr ""

#.  Strictly speaking, since some time in 2.5.x
#.  FIXME: Torvald, I think we may need to add some explanation of
#.  "totally ordered" here.
#. type: Plain text
#: man-pages/man2/futex.2:290
msgid ""
"This operation tests that the value at the futex word pointed to by the "
"address I<uaddr> still contains the expected value I<val>, and if so, then "
"sleeps waiting for a B<FUTEX_WAKE> operation on the futex word.  The load of"
" the value of the futex word is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with the expected value, and starting to sleep are performed "
"atomically and totally ordered with respect to other futex operations on the"
" same futex word.  If the thread starts to sleep, it is considered a waiter "
"on this futex word.  If the futex value does not match I<val>, then the call"
" fails immediately with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:301
msgid ""
"The purpose of the comparison with the expected value is to prevent lost "
"wake-ups.  If another thread changed the value of the futex word after the "
"calling thread decided to block based on the prior value, and if the other "
"thread executed a B<FUTEX_WAKE> operation (or similar wake-up) after the "
"value change and before this B<FUTEX_WAIT> operation, then the calling "
"thread will observe the value change and will not start to sleep."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:319
msgid ""
"If the I<timeout> is not NULL, the structure it points to specifies a "
"timeout for the wait.  (This interval will be rounded up to the system clock"
" granularity, and is guaranteed not to expire early.)  The timeout is by "
"default measured according to the B<CLOCK_MONOTONIC> clock, but, since Linux"
" 4.5, the B<CLOCK_REALTIME> clock can be selected by specifying "
"B<FUTEX_CLOCK_REALTIME> in I<futex_op>.  If I<timeout> is NULL, the call "
"blocks indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:338
msgid ""
"I<Note>: for B<FUTEX_WAIT>, I<timeout> is interpreted as a I<relative> "
"value.  This differs from other futex operations, where I<timeout> is "
"interpreted as an absolute value.  To obtain the equivalent of B<FUTEX_WAIT>"
" with an absolute timeout, employ B<FUTEX_WAIT_BITSET> with I<val3> "
"specified as B<FUTEX_BITSET_MATCH_ANY>."
msgstr ""

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to a
#.  different example.
#.      For
#.      .BR futex (7),
#.      this call is executed if decrementing the count gave a negative value
#.      (indicating contention),
#.      and will sleep until another process or thread releases
#.      the futex and executes the
#.      .B FUTEX_WAKE
#.      operation.
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:358
msgid "The arguments I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:358
#, no-wrap
msgid "B<FUTEX_WAKE> (since Linux 2.6.0)"
msgstr ""

#.  Strictly speaking, since Linux 2.5.x
#. type: Plain text
#: man-pages/man2/futex.2:375
msgid ""
"This operation wakes at most I<val> of the waiters that are waiting (e.g., "
"inside B<FUTEX_WAIT>)  on the futex word at the address I<uaddr>.  Most "
"commonly, I<val> is specified as either 1 (wake up a single waiter) or "
"B<INT_MAX> (wake up all waiters).  No guarantee is provided about which "
"waiters are awoken (e.g., a waiter with a higher scheduling priority is not "
"guaranteed to be awoken in preference to a waiter with a lower priority)."
msgstr ""

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to
#.  a different example.
#.      For
#.      .BR futex (7),
#.      this is executed if incrementing the count showed that
#.      there were waiters,
#.      once the futex value has been set to 1
#.      (indicating that it is available).
#.  How does "incrementing the count show that there were waiters"?
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:396
msgid "The arguments I<timeout>, I<uaddr2>, and I<val3> are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:396
#, no-wrap
msgid "B<FUTEX_FD> (from Linux 2.6.0 up to and including Linux 2.6.25)"
msgstr ""

#.  Strictly speaking, from Linux 2.5.x to 2.6.25
#. type: Plain text
#: man-pages/man2/futex.2:410
msgid ""
"This operation creates a file descriptor that is associated with the futex "
"at I<uaddr>.  The caller must close the returned file descriptor after use."
"  When another process or thread performs a B<FUTEX_WAKE> on the futex word,"
" the file descriptor indicates as being readable with B<select>(2), "
"B<poll>(2), and B<epoll>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:417
msgid ""
"The file descriptor can be used to obtain asynchronous notifications: if "
"I<val> is nonzero, then, when another process or thread executes a "
"B<FUTEX_WAKE>, the caller will receive the signal number that was passed in "
"I<val>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:424
msgid "The arguments I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""

#.  commit 82af7aca56c67061420d618cc5a30f0fd4106b80
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:433
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:433
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.6.0)"
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:445
msgid ""
"This operation performs the same task as B<FUTEX_CMP_REQUEUE> (see below), "
"except that no check is made using the value in I<val3>.  (The argument "
"I<val3> is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:445
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:469
msgid ""
"This operation first checks whether the location I<uaddr> still contains the"
" value I<val3>.  If not, the operation fails with the error B<EAGAIN>.  "
"Otherwise, the operation wakes up a maximum of I<val> waiters that are "
"waiting on the futex at I<uaddr>.  If there are more than I<val> waiters, "
"then the remaining waiters are removed from the wait queue of the source "
"futex at I<uaddr> and added to the wait queue of the target futex at "
"I<uaddr2>.  The I<val2> argument specifies an upper limit on the number of "
"waiters that are requeued to the futex at I<uaddr2>."
msgstr ""

#.  FIXME(Torvald) Is the following correct?  Or is just the decision
#.  which threads to wake or requeue part of the atomic operation?
#.  Notes from a f2f conversation with Thomas Gleixner (Aug 2015): ###
#. 	The operation is serialized with respect to operations on both
#. 	source and target futex. No other waiter can enqueue itself
#. 	for waiting and no other waiter can dequeue itself because of
#. 	a timeout or signal.
#. type: Plain text
#: man-pages/man2/futex.2:485
msgid ""
"The load from I<uaddr> is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with I<val3>, and the requeueing of any waiters are performed "
"atomically and totally ordered with respect to other operations on the same "
"futex word."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:503
msgid ""
"Typical values to specify for I<val> are 0 or 1.  (Specifying B<INT_MAX> is "
"not useful, because it would make the B<FUTEX_CMP_REQUEUE> operation "
"equivalent to B<FUTEX_WAKE>.)  The limit value specified via I<val2> is "
"typically either 1 or B<INT_MAX>.  (Specifying the argument as 0 is not "
"useful, because it would make the B<FUTEX_CMP_REQUEUE> operation equivalent "
"to B<FUTEX_WAIT>.)"
msgstr ""

#.  But, as Rich Felker points out, there remain valid use cases for
#.  FUTEX_REQUEUE, for example, when the calling thread is requeuing
#.  the target(s) to a lock that the calling thread owns
#.      From: Rich Felker <dalias@libc.org>
#.      Date: Wed, 29 Oct 2014 22:43:17 -0400
#.      To: Darren Hart <dvhart@infradead.org>
#.      CC: libc-alpha@sourceware.org, ...
#.      Subject: Re: Add futex wrapper to glibc?
#. type: Plain text
#: man-pages/man2/futex.2:520
msgid ""
"The B<FUTEX_CMP_REQUEUE> operation was added as a replacement for the "
"earlier B<FUTEX_REQUEUE>.  The difference is that the check of the value at "
"I<uaddr> can be used to ensure that requeueing happens only under certain "
"conditions, which allows race conditions to be avoided in certain use cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:532
msgid ""
"Both B<FUTEX_REQUEUE> and B<FUTEX_CMP_REQUEUE> can be used to avoid "
"\"thundering herd\" wake-ups that could occur when using B<FUTEX_WAKE> in "
"cases where all of the waiters that are woken need to acquire another futex."
"  Consider the following scenario, where multiple waiter threads are waiting"
" on B, a wait queue implemented using a futex:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:542
#, no-wrap
msgid ""
"lock(A)\n"
"while (!check_value(V)) {\n"
"    unlock(A);\n"
"    block_on(B);\n"
"    lock(A);\n"
"};\n"
"unlock(A);\n"
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:557
msgid ""
"If a waker thread used B<FUTEX_WAKE>, then all waiters waiting on B would be"
" woken up, and they would all try to acquire lock A.  However, waking all of"
" the threads in this manner would be pointless because all except one of the"
" threads would immediately block on lock A again.  By contrast, a requeue "
"operation wakes just one waiter and moves the other waiters to lock A, and "
"when the woken waiter unlocks A then the next waiter can proceed."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:557
#, no-wrap
msgid "B<FUTEX_WAKE_OP> (since Linux 2.6.14)"
msgstr ""

#.  commit 4732efbeb997189d9f9b04708dc26bf8613ed721
#. 	Author: Jakub Jelinek <jakub@redhat.com>
#. 	Date:   Tue Sep 6 15:16:25 2005 -0700
#.  FIXME. (Torvald) The glibc condvar implementation is currently being
#.      revised (e.g., to not use an internal lock anymore).
#.      It is probably more future-proof to remove this paragraph.
#.  [Torvald, do you have an update here?]
#. type: Plain text
#: man-pages/man2/futex.2:576
msgid ""
"This operation was added to support some user-space use cases where more "
"than one futex must be handled at the same time.  The most notable example "
"is the implementation of B<pthread_cond_signal>(3), which requires "
"operations on two futexes, the one used to implement the mutex and the one "
"used in the implementation of the wait queue associated with the condition "
"variable.  B<FUTEX_WAKE_OP> allows such cases to be implemented without "
"leading to high rates of contention and context switching."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:582
msgid ""
"The B<FUTEX_WAKE_OP> operation is equivalent to executing the following code"
" atomically and totally ordered with respect to other futex operations on "
"any of the two supplied futex words:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:590
#, no-wrap
msgid ""
"int oldval = *(int *) uaddr2;\n"
"*(int *) uaddr2 = oldval I<op> I<oparg>;\n"
"futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);\n"
"if (oldval I<cmp> I<cmparg>)\n"
"    futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:596
msgid "In other words, B<FUTEX_WAKE_OP> does the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:604
msgid ""
"saves the original value of the futex word at I<uaddr2> and performs an "
"operation to modify the value of the futex at I<uaddr2>; this is an atomic "
"read-modify-write memory access (i.e., using atomic machine instructions of "
"the respective architecture)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:610
msgid ""
"wakes up a maximum of I<val> waiters on the futex for the futex word at "
"I<uaddr>; and"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:618
msgid ""
"dependent on the results of a test of the original value of the futex word "
"at I<uaddr2>, wakes up a maximum of I<val2> waiters on the futex for the "
"futex word at I<uaddr2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:624
msgid ""
"The operation and comparison that are to be performed are encoded in the "
"bits of the argument I<val3>.  Pictorially, the encoding is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:631
#, no-wrap
msgid ""
"+---+---+-----------+-----------+\n"
"|op |cmp|   oparg   |  cmparg   |\n"
"+---+---+-----------+-----------+\n"
"  4   4       12          12    E<lt>== # of bits\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:635
msgid "Expressed in code, the encoding is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:643
#, no-wrap
msgid ""
"#define FUTEX_OP(op, oparg, cmp, cmparg) \\e\n"
"                (((op & 0xf) E<lt>E<lt> 28) | \\e\n"
"                ((cmp & 0xf) E<lt>E<lt> 24) | \\e\n"
"                ((oparg & 0xfff) E<lt>E<lt> 12) | \\e\n"
"                (cmparg & 0xfff))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:656
msgid ""
"In the above, I<op> and I<cmp> are each one of the codes listed below.  The "
"I<oparg> and I<cmparg> components are literal numeric values, except as "
"noted below."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:660
msgid "The I<op> component has one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:668
#, no-wrap
msgid ""
"FUTEX_OP_SET        0  /* uaddr2 = oparg; */\n"
"FUTEX_OP_ADD        1  /* uaddr2 += oparg; */\n"
"FUTEX_OP_OR         2  /* uaddr2 |= oparg; */\n"
"FUTEX_OP_ANDN       3  /* uaddr2 &= ~oparg; */\n"
"FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:676
msgid ""
"In addition, bit-wise ORing the following value into I<op> causes I<(1\\ "
"E<lt>E<lt>\\ oparg)> to be used as the operand:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:680
#, no-wrap
msgid "FUTEX_OP_ARG_SHIFT  8  /* Use (1 E<lt>E<lt> oparg) as operand */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:686
msgid "The I<cmp> field is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:695
#, no-wrap
msgid ""
"FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */\n"
"FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */\n"
"FUTEX_OP_CMP_LT     2  /* if (oldval E<lt> cmparg) wake */\n"
"FUTEX_OP_CMP_LE     3  /* if (oldval E<lt>= cmparg) wake */\n"
"FUTEX_OP_CMP_GT     4  /* if (oldval E<gt> cmparg) wake */\n"
"FUTEX_OP_CMP_GE     5  /* if (oldval E<gt>= cmparg) wake */\n"
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:707
msgid ""
"The return value of B<FUTEX_WAKE_OP> is the sum of the number of waiters "
"woken on the futex I<uaddr> plus the number of waiters woken on the futex "
"I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:707
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET> (since Linux 2.6.25)"
msgstr ""

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: man-pages/man2/futex.2:720
msgid ""
"This operation is like B<FUTEX_WAIT> except that I<val3> is used to provide "
"a 32-bit bit mask to the kernel.  This bit mask, in which at least one bit "
"must be set, is stored in the kernel-internal state of the waiter.  See the "
"description of B<FUTEX_WAKE_BITSET> for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:728 man-pages/man2/futex.2:1269
msgid ""
"If I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout for the wait operation.  If I<timeout> is NULL, the operation can "
"block indefinitely."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:736
msgid "The I<uaddr2> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:736
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET> (since Linux 2.6.25)"
msgstr ""

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: man-pages/man2/futex.2:754
msgid ""
"This operation is the same as B<FUTEX_WAKE> except that the I<val3> argument"
" is used to provide a 32-bit bit mask to the kernel.  This bit mask, in "
"which at least one bit must be set, is used to select which waiters should "
"be woken up.  The selection is done by a bit-wise AND of the \"wake\" bit "
"mask (i.e., the value in I<val3>)  and the bit mask which is stored in the "
"kernel-internal state of the waiter (the \"wait\" bit mask that is set using"
" B<FUTEX_WAIT_BITSET>).  All of the waiters for which the result of the AND "
"is nonzero are woken up; the remaining waiters are left sleeping."
msgstr ""

#.  According to http://locklessinc.com/articles/futex_cheat_sheet/:
#.     "The original reason for the addition of these extensions
#.      was to improve the performance of pthread read-write locks
#.      in glibc. However, the pthreads library no longer uses the
#.      same locking algorithm, and these extensions are not used
#.      without the bitset parameter being all ones.
#.  The page goes on to note that the FUTEX_WAIT_BITSET operation
#.  is nevertheless used (with a bit mask of all ones) in order to
#.  obtain the absolute timeout functionality that is useful
#.  for efficiently implementing Pthreads APIs (which use absolute
#.  timeouts); FUTEX_WAIT provides only relative timeouts.
#. type: Plain text
#: man-pages/man2/futex.2:781
msgid ""
"The effect of B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET> is to allow "
"selective wake-ups among multiple waiters that are blocked on the same "
"futex.  However, note that, depending on the use case, employing this bit-"
"mask multiplexing feature on a futex can be less efficient than simply using"
" multiple futexes, because employing bit-mask multiplexing requires the "
"kernel to check all waiters on a futex, including those that are not "
"interested in being woken up (i.e., they do not have the relevant bit set in"
" their \"wait\" bit mask)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:810
msgid ""
"The constant B<FUTEX_BITSET_MATCH_ANY>, which corresponds to all 32 bits set"
" in the bit mask, can be used as the I<val3> argument for "
"B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET>.  Other than differences in "
"the handling of the I<timeout> argument, the B<FUTEX_WAIT> operation is "
"equivalent to B<FUTEX_WAIT_BITSET> with I<val3> specified as "
"B<FUTEX_BITSET_MATCH_ANY>; that is, allow a wake-up by any waker.  The "
"B<FUTEX_WAKE> operation is equivalent to B<FUTEX_WAKE_BITSET> with I<val3> "
"specified as B<FUTEX_BITSET_MATCH_ANY>; that is, wake up any waiter(s)."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:819
msgid "The I<uaddr2> and I<timeout> arguments are ignored."
msgstr ""

#. type: SS
#: man-pages/man2/futex.2:819
#, no-wrap
msgid "Priority-inheritance futexes"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:829
msgid ""
"Linux supports priority-inheritance (PI) futexes in order to handle "
"priority-inversion problems that can be encountered with normal futex locks."
"  Priority inversion is the problem that occurs when a high-priority task is"
" blocked waiting to acquire a lock held by a low-priority task, while tasks "
"at an intermediate priority continuously preempt the low-priority task from "
"the CPU.  Consequently, the low-priority task makes no progress toward "
"releasing the lock, and the high-priority task remains blocked."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:846
msgid ""
"Priority inheritance is a mechanism for dealing with the priority-inversion "
"problem.  With this mechanism, when a high-priority task becomes blocked by "
"a lock held by a low-priority task, the priority of the low-priority task is"
" temporarily raised to that of the high-priority task, so that it is not "
"preempted by any intermediate level tasks, and can thus make progress toward"
" releasing the lock.  To be effective, priority inheritance must be "
"transitive, meaning that if a high-priority task blocks on a lock held by a "
"lower-priority task that is itself blocked by a lock held by another "
"intermediate-priority task (and so on, for chains of arbitrary length), then"
" both of those tasks (or more generally, all of the tasks in a lock chain)  "
"have their priorities raised to be the same as the high-priority task."
msgstr ""

#.  Quoting Darren Hart:
#.      These opcodes paired with the PI futex value policy (described below)
#.      defines a "futex" as PI aware. These were created very specifically
#.      in support of PI pthread_mutexes, so it makes a lot more sense to
#.      talk about a PI aware pthread_mutex, than a PI aware futex, since
#.      there is a lot of policy and scaffolding that has to be built up
#.      around it to use it properly (this is what a PI pthread_mutex is).
#. type: Plain text
#: man-pages/man2/futex.2:862
msgid ""
"From a user-space perspective, what makes a futex PI-aware is a policy "
"agreement (described below)  between user space and the kernel about the "
"value of the futex word, coupled with the use of the PI-futex operations "
"described below.  (Unlike the other futex operations described above, the "
"PI-futex operations are designed for the implementation of very specific IPC"
" mechanisms.)"
msgstr ""

#.        mtk: The following text is drawn from the Hart/Guniguntala paper
#.        (listed in SEE ALSO), but I have reworded some pieces
#.        significantly.
#. type: Plain text
#: man-pages/man2/futex.2:870
msgid ""
"The PI-futex operations described below differ from the other futex "
"operations in that they impose policy on the use of the value of the futex "
"word:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:872
msgid "If the lock is not acquired, the futex word's value shall be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:878
msgid ""
"If the lock is acquired, the futex word's value shall be the thread ID (TID;"
" see B<gettid>(2))  of the owning thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:883
msgid ""
"If the lock is owned and there are threads contending for the lock, then the"
" B<FUTEX_WAITERS> bit shall be set in the futex word's value; in other "
"words, this value is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:885
#, no-wrap
msgid "    FUTEX_WAITERS | TID\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:889
msgid ""
"(Note that is invalid for a PI futex word to have no owner and "
"B<FUTEX_WAITERS> set.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:900
msgid ""
"With this policy in place, a user-space application can acquire an "
"unacquired lock or release a lock using atomic instructions executed in user"
" mode (e.g., a compare-and-swap operation such as I<cmpxchg> on the x86 "
"architecture).  Acquiring a lock simply consists of using compare-and-swap "
"to atomically set the futex word's value to the caller's TID if its previous"
" value was 0.  Releasing a lock requires using compare-and-swap to set the "
"futex word's value to 0 if the previous value was the expected TID."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:911
msgid ""
"If a futex is already acquired (i.e., has a nonzero value), waiters must "
"employ the B<FUTEX_LOCK_PI> operation to acquire the lock.  If other threads"
" are waiting for the lock, then the B<FUTEX_WAITERS> bit is set in the futex"
" value; in this case, the lock owner must employ the B<FUTEX_UNLOCK_PI> "
"operation to release the lock."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:921
msgid ""
"In the cases where callers are forced into the kernel (i.e., required to "
"perform a B<futex>()  call), they then deal directly with a so-called RT-"
"mutex, a kernel locking mechanism which implements the required priority-"
"inheritance semantics.  After the RT-mutex is acquired, the futex value is "
"updated accordingly, before the calling thread returns to user space."
msgstr ""

#.  tglx (July 2015):
#.      If there are multiple waiters on a pi futex then a wake pi operation
#.      will wake the first waiter and hand over the lock to this waiter. This
#.      includes handing over the rtmutex which represents the futex in the
#.      kernel. The strict requirement is that the futex owner and the rtmutex
#.      owner must be the same, except for the update period which is
#.      serialized by the futex internal locking. That means the kernel must
#.      update the user-space value prior to returning to user space
#. type: Plain text
#: man-pages/man2/futex.2:938
msgid ""
"It is important to note that the kernel will update the futex word's value "
"prior to returning to user space.  (This prevents the possibility of the "
"futex word's value ending up in an invalid state, such as having an owner "
"but the value being 0, or having waiters but not having the B<FUTEX_WAITERS>"
" bit set.)"
msgstr ""

#.  tglx (July 2015):
#.      The FUTEX_OWNER_DIED bit can also be set on uncontended futexes, where
#.      the kernel has no state associated. This happens via the robust futex
#.      mechanism. In that case the futex value will be set to
#.      FUTEX_OWNER_DIED. The robust futex mechanism is also available for non
#.      PI futexes.
#. type: Plain text
#: man-pages/man2/futex.2:957
msgid ""
"If a futex has an associated RT-mutex in the kernel (i.e., there are blocked"
" waiters)  and the owner of the futex/RT-mutex dies unexpectedly, then the "
"kernel cleans up the RT-mutex and hands it over to the next waiter.  This in"
" turn requires that the user-space value is updated accordingly.  To "
"indicate that this is required, the kernel sets the B<FUTEX_OWNER_DIED> bit "
"in the futex word along with the thread ID of the new owner.  User space can"
" detect this situation via the presence of the B<FUTEX_OWNER_DIED> bit and "
"is then responsible for cleaning up the stale state left over by the dead "
"owner."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:962
msgid ""
"PI futexes are operated on by specifying one of the values listed below in "
"I<futex_op>.  Note that the PI futex operations must be used as paired "
"operations and are subject to some additional requirements:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:973
msgid ""
"B<FUTEX_LOCK_PI> and B<FUTEX_TRYLOCK_PI> pair with B<FUTEX_UNLOCK_PI>.  "
"B<FUTEX_UNLOCK_PI> must be called only on a futex owned by the calling "
"thread, as defined by the value policy, otherwise the error B<EPERM> "
"results."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:987
msgid ""
"B<FUTEX_WAIT_REQUEUE_PI> pairs with B<FUTEX_CMP_REQUEUE_PI>.  This must be "
"performed from a non-PI futex to a distinct PI futex (or the error B<EINVAL>"
" results).  Additionally, I<val> (the number of waiters to be woken) must be"
" 1 (or the error B<EINVAL> results)."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:992
msgid "The PI futex operations are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:992
#, no-wrap
msgid "B<FUTEX_LOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:999
msgid ""
"This operation is used after an attempt to acquire the lock via an atomic "
"user-mode instruction failed because the futex word has a nonzero "
"value\\(emspecifically, because it contained the (PID-namespace-specific) "
"TID of the lock owner."
msgstr ""

#.  tglx (July 2015):
#.      The operation here is similar to the FUTEX_WAIT logic. When the user
#.      space atomic acquire does not succeed because the futex value was non
#.      zero, then the waiter goes into the kernel, takes the kernel internal
#.      lock and retries the acquisition under the lock. If the acquisition
#.      does not succeed either, then it sets the FUTEX_WAITERS bit, to signal
#.      the lock owner that it needs to go into the kernel. Here is the pseudo
#.      code:
#.      	lock(kernel_lock);
#.      retry:
#.      	/*
#.      	 * Owner might have unlocked in userspace before we
#.      	 * were able to set the waiter bit.
#.               */
#.              if (atomic_acquire(futex) == SUCCESS) {
#.      	   unlock(kernel_lock());
#.      	   return 0;
#.      	}
#.      	/*
#.      	 * Owner might have unlocked after the above atomic_acquire()
#.      	 * attempt.
#.      	 */
#.      	if (atomic_set_waiters_bit(futex) != SUCCESS)
#.      	   goto retry;
#.      	queue_waiter();
#.      	unlock(kernel_lock);
#.      	block();
#. type: Plain text
#: man-pages/man2/futex.2:1042
msgid ""
"The operation checks the value of the futex word at the address I<uaddr>.  "
"If the value is 0, then the kernel tries to atomically set the futex value "
"to the caller's TID.  If the futex word's value is nonzero, the kernel "
"atomically sets the B<FUTEX_WAITERS> bit, which signals the futex owner that"
" it cannot unlock the futex in user space atomically by setting the futex "
"value to 0.  After that, the kernel:"
msgstr ""

#. type: IP
#: man-pages/man2/futex.2:1043
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1045
msgid "Tries to find the thread which is associated with the owner TID."
msgstr ""

#. type: IP
#: man-pages/man2/futex.2:1045
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1051
msgid ""
"Creates or reuses kernel state on behalf of the owner.  (If this is the "
"first waiter, there is no kernel state for this futex, so kernel state is "
"created by locking the RT-mutex and the futex owner is made the owner of the"
" RT-mutex.  If there are existing waiters, then the existing state is "
"reused.)"
msgstr ""

#. type: IP
#: man-pages/man2/futex.2:1051
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1054
msgid ""
"Attaches the waiter to the futex (i.e., the waiter is enqueued on the RT-"
"mutex waiter list)."
msgstr ""

#.  August 2015:
#.      mtk: If the realm is restricted purely to SCHED_OTHER (SCHED_NORMAL)
#.           processes, does the nice value come into play also?
#.      tglx: No. SCHED_OTHER/NORMAL tasks are handled in FIFO order
#.  (i.e., task 1 blocks on lock A, held by task 2,
#.  while task 2 blocks on lock B, held by task 3)
#. type: Plain text
#: man-pages/man2/futex.2:1082
msgid ""
"If more than one waiter exists, the enqueueing of the waiter is in "
"descending priority order.  (For information on priority ordering, see the "
"discussion of the B<SCHED_DEADLINE>, B<SCHED_FIFO>, and B<SCHED_RR> "
"scheduling policies in B<sched>(7).)  The owner inherits either the waiter's"
" CPU bandwidth (if the waiter is scheduled under the B<SCHED_DEADLINE> "
"policy) or the waiter's priority (if the waiter is scheduled under the "
"B<SCHED_RR> or B<SCHED_FIFO> policy).  This inheritance follows the lock "
"chain in the case of nested locking and performs deadlock detection."
msgstr ""

#.  2016-07-07 response from Thomas Gleixner on LKML:
#.  From: Thomas Gleixner <tglx@linutronix.de>
#.  Date: 6 July 2016 at 20:57
#.  Subject: Re: futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op
#.  On Thu, 23 Jun 2016, Michael Kerrisk (man-pages) wrote:
#.  > On 06/23/2016 08:28 PM, Darren Hart wrote:
#.  > > And as a follow-on, what is the reason for FUTEX_LOCK_PI only using
#.  > > CLOCK_REALTIME? It seems reasonable to me that a user may want to wait
#. a
#.  > > specific amount of time, regardless of wall time.
#.  >
#.  > Yes, that's another weird inconsistency.
#.  The reason is that phtread_mutex_timedlock() uses absolute timeouts based
#. on
#.  CLOCK_REALTIME. glibc folks asked to make that the default behaviour back
#.  then when we added LOCK_PI.
#. type: Plain text
#: man-pages/man2/futex.2:1111
msgid ""
"The I<timeout> argument provides a timeout for the lock attempt.  If "
"I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout, measured against the B<CLOCK_REALTIME> clock.  If I<timeout> is "
"NULL, the operation will block indefinitely."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1121
msgid "The I<uaddr2>, I<val>, and I<val3> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1121
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:1128
msgid ""
"This operation tries to acquire the lock at I<uaddr>.  It is invoked when a "
"user-space atomic acquire did not succeed because the futex word was not 0."
msgstr ""

#.  Paraphrasing a f2f conversation with Thomas Gleixner about the
#.  above point (Aug 2015): ###
#. 	There is a rare possibility of a race condition involving an
#. 	uncontended futex with no owner, but with waiters.  The
#. 	kernel-user-space contract is that if a futex is nonzero, you must
#. 	go into kernel.  The futex was owned by a task, and that task dies
#. 	but there are no waiters, so the futex value is non zero.
#. 	Therefore, the next locker has to go into the kernel,
#. 	so that the kernel has a chance to clean up. (CMXCH on zero
#. 	in user space would fail, so kernel has to clean up.)
#.  Darren Hart (Oct 2015):
#.      The trylock in the kernel has more state, so it can independently
#.      verify the  flags that userspace must trust implicitly.
#. type: Plain text
#: man-pages/man2/futex.2:1152
msgid ""
"Because the kernel has access to more state information than user space, "
"acquisition of the lock might succeed if performed by the kernel in cases "
"where the futex word (i.e., the state information accessible to use-space) "
"contains stale state (B<FUTEX_WAITERS> and/or B<FUTEX_OWNER_DIED>).  This "
"can happen when the owner of the futex died.  User space cannot handle this "
"condition in a race-free manner, but the kernel can fix this up and acquire "
"the futex."
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1163 man-pages/man2/futex.2:1186
msgid "The I<uaddr2>, I<val>, I<timeout>, and I<val3> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1163
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:1171
msgid ""
"This operation wakes the top priority waiter that is waiting in "
"B<FUTEX_LOCK_PI> on the futex address provided by the I<uaddr> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1175
msgid ""
"This is called when the user-space value at I<uaddr> cannot be changed "
"atomically from a TID (of the owner) to 0."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1186
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI> (since Linux 2.6.31)"
msgstr ""

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: man-pages/man2/futex.2:1199
msgid ""
"This operation is a PI-aware variant of B<FUTEX_CMP_REQUEUE>.  It requeues "
"waiters that are blocked via B<FUTEX_WAIT_REQUEUE_PI> on I<uaddr> from a "
"non-PI source futex (I<uaddr>)  to a PI target futex (I<uaddr2>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1215
msgid ""
"As with B<FUTEX_CMP_REQUEUE>, this operation wakes up a maximum of I<val> "
"waiters that are waiting on the futex at I<uaddr>.  However, for "
"B<FUTEX_CMP_REQUEUE_PI>, I<val> is required to be 1 (since the main point is"
" to avoid a thundering herd).  The remaining waiters are removed from the "
"wait queue of the source futex at I<uaddr> and added to the wait queue of "
"the target futex at I<uaddr2>."
msgstr ""

#.  val2 is the cap on the number of requeued waiters.
#.  In the glibc pthread_cond_broadcast() implementation, this argument
#.  is specified as INT_MAX, and for pthread_cond_signal() it is 0.
#.        The page at http://locklessinc.com/articles/futex_cheat_sheet/
#.        notes that "priority-inheritance Futex to priority-inheritance
#.        Futex requeues are currently unsupported". However, probably
#.        the page does not need to say nothing about this, since
#.        Thomas Gleixner commented (July 2015): "they never will be
#.        supported because they make no sense at all"
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1235
msgid ""
"The I<val2> and I<val3> arguments serve the same purposes as for "
"B<FUTEX_CMP_REQUEUE>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1235
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI> (since Linux 2.6.31)"
msgstr ""

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: man-pages/man2/futex.2:1249
msgid ""
"Wait on a non-PI futex at I<uaddr> and potentially be requeued (via a "
"B<FUTEX_CMP_REQUEUE_PI> operation in another task) onto a PI futex at "
"I<uaddr2>.  The wait operation on I<uaddr> is the same as for B<FUTEX_WAIT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1261
msgid ""
"The waiter can be removed from the wait on I<uaddr> without requeueing on "
"I<uaddr2> via a B<FUTEX_WAKE> operation in another task.  In this case, the "
"B<FUTEX_WAIT_REQUEUE_PI> operation fails with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1273
msgid "The I<val3> argument is ignored."
msgstr ""

#.  Darren Hart notes that a patch to allow glibc to fully support
#.  PI-aware pthreads condition variables has not yet been accepted into
#.  glibc. The story is complex, and can be found at
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11588
#.  Darren notes that in the meantime, the patch is shipped with various
#.  PREEMPT_RT-enabled Linux systems.
#.  Related to the preceding, Darren proposed that somewhere, man-pages
#.  should document the following point:
#.      While the Linux kernel, since 2.6.31, supports requeueing of
#.      priority-inheritance (PI) aware mutexes via the
#.      FUTEX_WAIT_REQUEUE_PI and FUTEX_CMP_REQUEUE_PI futex operations,
#.      the glibc implementation does not yet take full advantage of this.
#.      Specifically, the condvar internal data lock remains a non-PI aware
#.      mutex, regardless of the type of the pthread_mutex associated with
#.      the condvar. This can lead to an unbounded priority inversion on
#.      the internal data lock even when associating a PI aware
#.      pthread_mutex with a condvar during a pthread_cond*_wait
#.      operation. For this reason, it is not recommended to rely on
#.      priority inheritance when using pthread condition variables.
#.  The problem is that the obvious location for this text is
#.  the pthread_cond*wait(3) man page. However, such a man page
#.  does not currently exist.
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1317
msgid ""
"The B<FUTEX_WAIT_REQUEUE_PI> and B<FUTEX_CMP_REQUEUE_PI> were added to "
"support a fairly specific use case: support for priority-inheritance-aware "
"POSIX threads condition variables.  The idea is that these operations should"
" always be paired, in order to ensure that user space and the kernel remain "
"in sync.  Thus, in the B<FUTEX_WAIT_REQUEUE_PI> operation, the user-space "
"application pre-specifies the target of the requeue that takes place in the "
"B<FUTEX_CMP_REQUEUE_PI> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1326
msgid ""
"In the event of an error (and assuming that B<futex>()  was invoked via "
"B<syscall>(2)), all operations return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1329
msgid ""
"The return value on success depends on the operation, as described in the "
"following list:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1329
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1340
msgid ""
"Returns 0 if the caller was woken up.  Note that a wake-up can also be "
"caused by common futex usage patterns in unrelated code that happened to "
"have previously used the futex word's memory location (e.g., typical futex-"
"based implementations of Pthreads mutexes can cause this under some "
"conditions).  Therefore, callers should always conservatively assume that a "
"return value of 0 can mean a spurious wake-up, and use the futex word's "
"value (i.e., the user-space synchronization scheme)  to decide whether to "
"continue to block or not."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1340
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1343 man-pages/man2/futex.2:1349
#: man-pages/man2/futex.2:1376
msgid "Returns the number of waiters that were woken up."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1343
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1346
msgid "Returns the new file descriptor associated with the futex."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1346
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1349
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1359
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then the difference is the number of waiters requeued to the futex "
"for the futex word at I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1359
#, no-wrap
msgid "B<FUTEX_WAKE_OP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1367
msgid ""
"Returns the total number of waiters that were woken up.  This is the sum of "
"the woken waiters on the two futexes for the futex words at I<uaddr> and "
"I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1367
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1373
msgid ""
"Returns 0 if the caller was woken up.  See B<FUTEX_WAIT> for how to "
"interpret this correctly in practice."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1373
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET>"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1376
#, no-wrap
msgid "B<FUTEX_LOCK_PI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1379 man-pages/man2/futex.2:1382
msgid "Returns 0 if the futex was successfully locked."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1379
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI>"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1382
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1385
msgid "Returns 0 if the futex was successfully unlocked."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1385
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1395
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then difference is the number of waiters requeued to the futex for "
"the futex word at I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1395
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI>"
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1403
msgid ""
"Returns 0 if the caller was successfully requeued to the futex for the futex"
" word at I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1404
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1407
msgid "No read access to the memory of a futex word."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1417
msgid ""
"(B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, B<FUTEX_WAIT_REQUEUE_PI>)  The value "
"pointed to by I<uaddr> was not equal to the expected value I<val> at the "
"time of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1425
msgid ""
"B<Note>: on Linux, the symbolic names B<EAGAIN> and B<EWOULDBLOCK> (both of "
"which appear in different parts of the kernel futex code)  have the same "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1433
msgid ""
"(B<FUTEX_CMP_REQUEUE>, B<FUTEX_CMP_REQUEUE_PI>)  The value pointed to by "
"I<uaddr> is not equal to the expected value I<val3>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1446
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"owner thread ID of I<uaddr> (for B<FUTEX_CMP_REQUEUE_PI>: I<uaddr2>)  is "
"about to exit, but has not yet handled the internal state cleanup.  Try "
"again."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1446 man-pages/man2/futex.2:1454
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1454
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"word at I<uaddr> is already locked by the caller."
msgstr ""

#.  FIXME . I see that kernel/locking/rtmutex.c uses EDEADLK in some
#.        places, and EDEADLOCK in others. On almost all architectures
#.        these constants are synonymous. Is there a reason that both
#.        names are used?
#.        tglx (July 2015): "No. We should probably fix that."
#. type: Plain text
#: man-pages/man2/futex.2:1467
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  While requeueing a waiter to the PI futex for the"
" futex word at I<uaddr2>, the kernel detected a deadlock."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1467
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1475
msgid ""
"A required pointer argument (i.e., I<uaddr>, I<uaddr2>, or I<timeout>)  did "
"not point to a valid user-space address."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1475
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1485
msgid ""
"A B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> operation was interrupted by a "
"signal (see B<signal>(7)).  In kernels before Linux 2.6.22, this error could"
" also be returned for a spurious wakeup; since Linux 2.6.22, this no longer "
"happens."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1496
msgid ""
"The operation in I<futex_op> is one of those that employs a timeout, but the"
" supplied I<timeout> argument was invalid (I<tv_sec> was less than zero, or "
"I<tv_nsec> was not less than 1,000,000,000)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1506
msgid ""
"The operation specified in I<futex_op> employs one or both of the pointers "
"I<uaddr> and I<uaddr2>, but one of these does not point to a valid "
"object\\(emthat is, the address is not four-byte-aligned."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1513
msgid ""
"(B<FUTEX_WAIT_BITSET>, B<FUTEX_WAKE_BITSET>)  The bit mask supplied in "
"I<val3> is zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1520
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  I<uaddr> equals I<uaddr2> (i.e., an attempt was "
"made to requeue to the same futex)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1526
msgid "(B<FUTEX_FD>)  The signal number supplied in I<val> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1539
msgid ""
"(B<FUTEX_WAKE>, B<FUTEX_WAKE_OP>, B<FUTEX_WAKE_BITSET>, B<FUTEX_REQUEUE>, "
"B<FUTEX_CMP_REQUEUE>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state\\(emthat is, it detected a"
" waiter which waits in B<FUTEX_LOCK_PI> on I<uaddr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1554
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>)  The kernel "
"detected an inconsistency between the user-space state at I<uaddr> and the "
"kernel state.  This indicates either state corruption or that the kernel "
"found a waiter on I<uaddr> which is waiting via B<FUTEX_WAIT> or "
"B<FUTEX_WAIT_BITSET>."
msgstr ""

#.  From a conversation with Thomas Gleixner (Aug 2015): ###
#. 	The kernel sees: I have non PI state for a futex you tried to
#.      tell me was PI
#. type: Plain text
#: man-pages/man2/futex.2:1569
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr2> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> on "
"I<uaddr2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1581
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITESET> on "
"I<uaddr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1593
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits on I<uaddr> via B<FUTEX_LOCK_PI> (instead of "
"B<FUTEX_WAIT_REQUEUE_PI>)."
msgstr ""

#.  This deals with the case:
#.      wait_requeue_pi(A, B);
#.      requeue_pi(A, C);
#. type: Plain text
#: man-pages/man2/futex.2:1603
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  An attempt was made to requeue a waiter to a "
"futex other than that specified by the matching B<FUTEX_WAIT_REQUEUE_PI> "
"call for that waiter."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1609
msgid "(B<FUTEX_CMP_REQUEUE_PI>)  The I<val> argument is not 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1612
msgid "Invalid argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1616
msgid ""
"(B<FUTEX_FD>)  The system-wide limit on the total number of open files has "
"been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1622
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The kernel"
" could not allocate memory to hold state information."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1626
msgid "Invalid operation specified in I<futex_op>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1637
msgid ""
"The B<FUTEX_CLOCK_REALTIME> option was specified in I<futex_op>, but the "
"accompanying operation was neither B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, nor "
"B<FUTEX_WAIT_REQUEUE_PI>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1647
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>, "
"B<FUTEX_CMP_REQUEUE_PI>, B<FUTEX_WAIT_REQUEUE_PI>)  A run-time check "
"determined that the operation is not available.  The PI-futex operations are"
" not implemented on all architectures and are not supported on some CPU "
"variants."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1659
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The caller"
" is not allowed to attach itself to the futex at I<uaddr> (for "
"B<FUTEX_CMP_REQUEUE_PI>: the futex at I<uaddr2>).  (This may be caused by a "
"state corruption in user space.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1663
msgid ""
"(B<FUTEX_UNLOCK_PI>)  The caller does not own the lock represented by the "
"futex word."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1663 man-pages/man2/futex.2:1671
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1671
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The thread"
" ID in the futex word at I<uaddr> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1677
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The thread ID in the futex word at I<uaddr2> does"
" not exist."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1677
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1687
msgid ""
"The operation in I<futex_op> employed the timeout specified in I<timeout>, "
"and the timeout expired before the operation completed."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1691
msgid ""
"Futexes were first made available in a stable kernel release with Linux "
"2.6.0."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1698
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics"
" from what was described above.  A four-argument system call with the "
"semantics described in this page was introduced in Linux 2.5.40.  A fifth "
"argument was added in Linux 2.5.70, and a sixth argument was added in Linux "
"2.6.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1700
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1703
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#.  TODO FIXME(Torvald) Above, we cite this section and claim it contains
#.  details on the synchronization semantics; add the C11 equivalents
#.  here (or whatever we find consensus for).
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1714
msgid ""
"Several higher-level programming abstractions are implemented via futexes, "
"including POSIX semaphores and various POSIX threads synchronization "
"mechanisms (mutexes, condition variables, read-write locks, and barriers)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1725
msgid ""
"The program below demonstrates use of futexes in a program where a parent "
"process and a child process use a pair of futexes located inside a shared "
"anonymous mapping to synchronize access to a shared resource: the terminal."
"  The two processes each write I<nloops> (a command-line argument that "
"defaults to 5 if omitted)  messages to the terminal and employ a "
"synchronization protocol that ensures that they alternate in writing "
"messages.  Upon running this program we see output such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1739
#, no-wrap
msgid ""
"$ B<./futex_demo>\n"
"Parent (18534) 0\n"
"Child  (18535) 0\n"
"Parent (18534) 1\n"
"Child  (18535) 1\n"
"Parent (18534) 2\n"
"Child  (18535) 2\n"
"Parent (18534) 3\n"
"Child  (18535) 3\n"
"Parent (18534) 4\n"
"Child  (18535) 4\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1745
#, no-wrap
msgid "/* futex_demo.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1748
#, no-wrap
msgid ""
"   Usage: futex_demo [nloops]\n"
"                    (Default: 5)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1767
#, no-wrap
msgid ""
"   Demonstrate the use of futexes in a program where parent and child\n"
"   use a pair of futexes located inside a shared anonymous mapping to\n"
"   synchronize access to a shared resource: the terminal. The two\n"
"   processes each write \\(aqnum-loops\\(aq messages to the terminal and employ\n"
"   a synchronization protocol that ensures that they alternate in\n"
"   writing messages.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdatomic.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/futex.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1770
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1772
#, no-wrap
msgid "static int *futex1, *futex2, *iaddr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1780
#, no-wrap
msgid ""
"static int\n"
"futex(int *uaddr, int futex_op, int val,\n"
"      const struct timespec *timeout, int *uaddr2, int val3)\n"
"{\n"
"    return syscall(SYS_futex, uaddr, futex_op, val,\n"
"                   timeout, uaddr, val3);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1783
#, no-wrap
msgid ""
"/* Acquire the futex pointed to by \\(aqfutexp\\(aq: wait for its value to\n"
"   become 1, and then set the value to 0. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1788
#, no-wrap
msgid ""
"static void\n"
"fwait(int *futexp)\n"
"{\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1791
#, no-wrap
msgid ""
"    /* atomic_compare_exchange_strong(ptr, oldval, newval)\n"
"       atomically performs the equivalent of:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1794
#, no-wrap
msgid ""
"           if (*ptr == *oldval)\n"
"               *ptr = newval;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1796
#, no-wrap
msgid ""
"       It returns true if the test yielded true and *ptr was updated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1798
#, no-wrap
msgid "    while (1) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1803
#, no-wrap
msgid ""
"        /* Is the futex available? */\n"
"        const int zero = 0;\n"
"        if (atomic_compare_exchange_strong(futexp, &zero, 1))\n"
"            break;      /* Yes */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1805
#, no-wrap
msgid "        /* Futex is not available; wait */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1811
#, no-wrap
msgid ""
"        s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);\n"
"        if (s == -1 && errno != EAGAIN)\n"
"            errExit(\"futex-FUTEX_WAIT\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1815
#, no-wrap
msgid ""
"/* Release the futex pointed to by \\(aqfutexp\\(aq: if the futex currently\n"
"   has the value 0, set its value to 1 and the wake any futex waiters,\n"
"   so that if the peer is blocked in fpost(), it can proceed. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1820
#, no-wrap
msgid ""
"static void\n"
"fpost(int *futexp)\n"
"{\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1822
#, no-wrap
msgid ""
"    /* atomic_compare_exchange_strong() was described in comments above */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1830
#, no-wrap
msgid ""
"    const int one = 1;\n"
"    if (atomic_compare_exchange_strong(futexp, &one, 0)) {\n"
"        s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
"        if (s  == -1)\n"
"            errExit(\"futex-FUTEX_WAKE\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1836
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t childPid;\n"
"    int j, nloops;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1838
#, no-wrap
msgid "    setbuf(stdout, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1840
#, no-wrap
msgid "    nloops = (argc E<gt> 1) ? atoi(argv[1]) : 5;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1845
#, no-wrap
msgid ""
"    /* Create a shared anonymous mapping that will hold the futexes.\n"
"       Since the futexes are being shared between processes, we\n"
"       subsequently use the \"shared\" futex operations (i.e., not the\n"
"       ones suffixed \"_PRIVATE\") */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1850
#, no-wrap
msgid ""
"    iaddr = mmap(NULL, sizeof(int) * 2, PROT_READ | PROT_WRITE,\n"
"                MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n"
"    if (iaddr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1853
#, no-wrap
msgid ""
"    futex1 = &iaddr[0];\n"
"    futex2 = &iaddr[1];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1856
#, no-wrap
msgid ""
"    *futex1 = 0;        /* State: unavailable */\n"
"    *futex2 = 1;        /* State: available */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1859
#, no-wrap
msgid ""
"    /* Create a child process that inherits the shared anonymous\n"
"       mapping */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1863
#, no-wrap
msgid ""
"    childPid = fork();\n"
"    if (childPid == -1)\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1870
#, no-wrap
msgid ""
"    if (childPid == 0) {        /* Child */\n"
"        for (j = 0; j E<lt> nloops; j++) {\n"
"            fwait(futex1);\n"
"            printf(\"Child  (%ld) %d\\en\", (long) getpid(), j);\n"
"            fpost(futex2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1873
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1875
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1881
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        fwait(futex2);\n"
"        printf(\"Parent (%ld) %d\\en\", (long) getpid(), j);\n"
"        fpost(futex1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1883
#, no-wrap
msgid "    wait(NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1894
msgid ""
"B<get_robust_list>(2), B<restart_syscall>(2), "
"B<pthread_mutexattr_getprotocol>(3), B<futex>(7), B<sched>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1896
msgid "The following kernel source files:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1898
msgid "I<Documentation/pi-futex.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1900
msgid "I<Documentation/futex-requeue-pi.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1902
msgid "I<Documentation/locking/rt-mutex.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1904
msgid "I<Documentation/locking/rt-mutex-design.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1906
msgid "I<Documentation/robust-futex-ABI.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1910
msgid ""
"Franke, H., Russell, R., and Kirwood, M., 2002.  I<Fuss, Futexes and "
"Furwocks: Fast Userlevel Locking in Linux> (from proceedings of the Ottawa "
"Linux Symposium 2002),"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1913
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1917
msgid ""
"Hart, D., 2009. I<A futex overview and update>, E<.UR "
"http://lwn.net/Articles/360699/> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1923
msgid ""
"Hart, D.\\& and Guniguntala, D., 2009.  I<Requeue-PI: Making Glibc Condvars "
"PI-Aware> (from proceedings of the 2009 Real-Time Linux Workshop), E<.UR "
"http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1927
msgid ""
"Drepper, U., 2011. I<Futexes Are Tricky>, E<.UR "
"http://www.akkadia.org/drepper/futex.pdf> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1929
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1931
msgid "E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man2/futimesat.2:25
#, no-wrap
msgid "FUTIMESAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:29
msgid ""
"futimesat - change timestamps of a file relative to a directory file "
"descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:36
#, no-wrap
msgid ""
"B<int futimesat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timeval >I<times>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:41
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:45
msgid "B<futimesat>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:50
msgid "This system call is obsolete.  Use B<utimensat>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:56
msgid ""
"The B<futimesat>()  system call operates in exactly the same way as "
"B<utimes>(2), except for the differences described in this manual page."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:66
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<utimes>(2)  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:78
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<utimes>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:84
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:91
msgid ""
"On success, B<futimesat>()  returns a 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:98
msgid ""
"The same errors that occur for B<utimes>(2)  can also occur for "
"B<futimesat>().  The following additional errors can occur for "
"B<futimesat>():"
msgstr ""

#. type: TP
#: man-pages/man2/futimesat.2:98
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:102
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/futimesat.2:102
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:108
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:112
msgid ""
"B<futimesat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:117
msgid ""
"This system call is nonstandard.  It was implemented from a specification "
"that was proposed for POSIX.1, but that specification was replaced by the "
"one for B<utimensat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:119
msgid "A similar system call exists on Solaris."
msgstr ""

#. type: SS
#: man-pages/man2/futimesat.2:120
#, no-wrap
msgid "Glibc notes"
msgstr ""

#.  The Solaris futimesat() also has this strangeness.
#. type: Plain text
#: man-pages/man2/futimesat.2:128
msgid ""
"If I<pathname> is NULL, then the glibc B<futimesat>()  wrapper function "
"updates the times for the file referred to by I<dirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:133
msgid ""
"B<stat>(2), B<utimensat>(2), B<utimes>(2), B<futimes>(3), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/flock.2:35
#, no-wrap
msgid "FLOCK"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:38
msgid "flock - apply or remove an advisory lock on an open file"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:40
msgid "B<#include E<lt>sys/file.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:42
msgid "B<int flock(int >I<fd>B<, int >I<operation>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:48
msgid ""
"Apply or remove an advisory lock on the open file specified by I<fd>.  The "
"argument I<operation> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:49
#, no-wrap
msgid "B<LOCK_SH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:54
msgid ""
"Place a shared lock.  More than one process may hold a shared lock for a "
"given file at a given time."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:54
#, no-wrap
msgid "B<LOCK_EX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:59
msgid ""
"Place an exclusive lock.  Only one process may hold an exclusive lock for a "
"given file at a given time."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:59
#, no-wrap
msgid "B<LOCK_UN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:62
msgid "Remove an existing lock held by this process."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:71
msgid ""
"A call to B<flock>()  may block if an incompatible lock is held by another "
"process.  To make a nonblocking request, include B<LOCK_NB> (by ORing)  with"
" any of the above operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:73
msgid ""
"A single file may not simultaneously have both shared and exclusive locks."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:88
msgid ""
"Locks created by B<flock>()  are associated with an open file description "
"(see B<open>(2)).  This means that duplicate file descriptors (created by, "
"for example, B<fork>(2)  or B<dup>(2))  refer to the same lock, and this "
"lock may be modified or released using any of these file descriptors.  "
"Furthermore, the lock is released either by an explicit B<LOCK_UN> operation"
" on any of these duplicate file descriptors, or when all such file "
"descriptors have been closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:97
msgid ""
"If a process uses B<open>(2)  (or similar) to obtain more than one file "
"descriptor for the same file, these file descriptors are treated "
"independently by B<flock>().  An attempt to lock the file using one of these"
" file descriptors may be denied by a lock that the calling process has "
"already placed via another file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:104
msgid ""
"A process may hold only one type of lock (shared or exclusive)  on a file.  "
"Subsequent B<flock>()  calls on an already locked file will convert an "
"existing lock to the new lock mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:109
msgid "Locks created by B<flock>()  are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:112
msgid ""
"A shared or exclusive lock can be placed on a file regardless of the mode in"
" which the file was opened."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:117
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:122
msgid "I<fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:127
msgid ""
"While waiting to acquire a lock, the call was interrupted by delivery of a "
"signal caught by a handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:131
msgid "I<operation> is invalid."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:131
#, no-wrap
msgid "B<ENOLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:134
msgid "The kernel ran out of memory for allocating lock records."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:134
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:139
msgid "The file is locked and the B<LOCK_NB> flag was selected."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:148
msgid ""
"4.4BSD (the B<flock>()  call first appeared in 4.2BSD).  A version of "
"B<flock>(), possibly implemented in terms of B<fcntl>(2), appears on most "
"UNIX systems."
msgstr ""

#.  E.g., according to the flock(2) man page, FreeBSD since at least 5.3
#. type: Plain text
#: man-pages/man2/flock.2:171
msgid ""
"Since kernel 2.0, B<flock>()  is implemented as a system call in its own "
"right rather than being emulated in the GNU C library as a call to "
"B<fcntl>(2).  With this implementation, there is no interaction between the "
"types of lock placed by B<flock>()  and B<fcntl>(2), and B<flock>()  does "
"not detect deadlock.  (Note, however, that on some systems, such as the "
"modern BSDs, B<flock>()  and B<fcntl>(2)  locks I<do> interact with one "
"another.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:177
msgid ""
"B<flock>()  places advisory locks only; given suitable permissions on a "
"file, a process is free to ignore the use of B<flock>()  and perform I/O on "
"the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:190
msgid ""
"B<flock>()  and B<fcntl>(2)  locks have different semantics with respect to "
"forked processes and B<dup>(2).  On systems that implement B<flock>()  using"
" B<fcntl>(2), the semantics of B<flock>()  will be different from those "
"described in this manual page."
msgstr ""

#.  Kernel 2.5.21 changed things a little: during lock conversion
#.  it is now the highest priority process that will get the lock -- mtk
#. type: Plain text
#: man-pages/man2/flock.2:203
msgid ""
"Converting a lock (shared to exclusive, or vice versa) is not guaranteed to "
"be atomic: the existing lock is first removed, and then a new lock is "
"established.  Between these two steps, a pending lock request by another "
"process may be granted, with the result that the conversion either blocks, "
"or fails if B<LOCK_NB> was specified.  (This is the original BSD behavior, "
"and occurs on many other implementations.)"
msgstr ""

#. type: SS
#: man-pages/man2/flock.2:203
#, no-wrap
msgid "NFS details"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:213
msgid ""
"In Linux kernels up to 2.6.11, B<flock>()  does not lock files over NFS "
"(i.e., the scope of locks was limited to the local system).  Instead, one "
"could use B<fcntl>(2)  byte-range locking, which does work over NFS, given a"
" sufficiently recent version of Linux and a server which supports locking."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:228
msgid ""
"Since Linux 2.6.12, NFS clients support B<flock>()  locks by emulating them "
"as B<fcntl>(2)  byte-range locks on the entire file.  This means that "
"B<fcntl>(2)  and B<flock>()  locks I<do> interact with one another over NFS."
"  It also means that in order to place an exclusive lock, the file must be "
"opened for writing."
msgstr ""

#.  commit 5eebde23223aeb0ad2d9e3be6590ff8bbfab0fc2
#. type: Plain text
#: man-pages/man2/flock.2:240
msgid ""
"Since Linux 2.6.37, the kernel supports a compatibility mode that allows "
"B<flock>()  locks (and also B<fcntl>(2)  byte region locks) to be treated as"
" local; see the discussion of the I<local_lock> option in B<nfs>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:250
msgid ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3), B<lslocks>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:254
msgid ""
"I<Documentation/filesystems/locks.txt> in the Linux kernel source tree "
"(I<Documentation/locks.txt> in older kernels)"
msgstr ""

#. type: TH
#: man-pages/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>()  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:94
msgid ""
"Remove either all marks for filesystems, all marks for mounts, or all marks "
"for directories and files from the fanotify group.  If I<flags> contains "
"B<FAN_MARK_MOUNT>, all marks for mounts are removed from the group.  If "
"I<flags> contains B<FAN_MARK_FILESYSTEM>, all marks for filesystems are "
"removed from the group.  Otherwise, all marks for directories and files are "
"removed.  No flag other than and at most one of the flags B<FAN_MARK_MOUNT> "
"or B<FAN_MARK_FILESYSTEM> can be used in conjunction with B<FAN_MARK_FLUSH>."
"  I<mask> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:98
msgid ""
"If none of the values above is specified, or more than one is specified, the"
" call fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:102
msgid ""
"In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:102
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:113
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:113
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:118
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:118
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:138
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself"
" a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will"
" be monitored.  This value cannot be used if the I<fanotify_fd> file "
"descriptor has been initialized with the flag B<FAN_REPORT_FID> or if any of"
" the new directory modification events are provided as a I<mask>.  "
"Attempting to do so will result in the error B<EINVAL> being returned."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:138
#, no-wrap
msgid "B<FAN_MARK_FILESYSTEM> (since Linux 4.20)"
msgstr ""

#.  commit d54f4fba889b205e9cd8239182ca5d27d0ac3bc2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:148
msgid ""
"Mark the filesystem specified by I<pathname>.  The filesystem containing "
"I<pathname> will be marked.  All the contained files and directories of the "
"filesystem from any mount point will be monitored."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:148
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:153
msgid ""
"The events in I<mask> shall be added to or removed from the ignore mask."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:153
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:159
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:163
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:166
msgid ""
"Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:169
msgid "Create an event when a file is modified (write)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:172
msgid "Create an event when a writable file is closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:175
msgid "Create an event when a read-only file or directory is closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:178
msgid "Create an event when a file or directory is opened."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:178
#, no-wrap
msgid "B<FAN_OPEN_EXEC  (since Linux 5.0)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:182
msgid ""
"Create an event when a file is opened with the intent to be executed.  See "
"NOTES for additional details."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:185
msgid "Create an event when the metadata for a file or directory has changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:189
msgid ""
"Create an event when a file or directory has been created in a marked parent"
" directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:193
msgid ""
"Create an event when a file or directory has been deleted in a marked parent"
" directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:196
msgid "Create an event when a marked file or directory itself is deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:200
msgid ""
"Create an event when a file or directory has been moved from a marked parent"
" directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:204
msgid ""
"Create an event when a file or directory has been moved to a marked parent "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:211
msgid ""
"Create an event when an overflow of the event queue occurs.  The size of the"
" event queue is limited to 16384 entries if B<FAN_UNLIMITED_QUEUE> is not "
"set in B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:219
msgid ""
"Create an event when a permission to open a file or directory is requested."
"  An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:219
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM> (since Linux 5.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:229
msgid ""
"Create an event when a permission to open a file for execution is requested."
"  An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required.  See NOTES for additional details."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:237
msgid ""
"Create an event when a permission to read a file or directory is requested."
"  An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:237
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:268
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(3), "
"B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without this"
" flag, only events for files are created.  The B<FAN_ONDIR> flag is reported"
" in an event mask only if the I<fanotify_fd> file descriptor has been "
"initialized with the flag B<FAN_REPORT_FID>.  In the context of directory "
"entry events, such as B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and "
"B<FAN_MOVED_TO> for example, specifying the flag B<FAN_ONDIR> is required in"
" order to create events when subdirectory entries are modified (i.e., "
"B<mkdir>(2)/ B<rmdir>(2)).  Subdirectory entry modification events will "
"never be merged with nonsubdirectory entry modification events.  This flag "
"is never reported individually within an event and is always supplied in "
"conjunction with another event type."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:268
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:276
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts and filesystems.  Note that "
"events are not generated for children of the subdirectories of marked "
"directories.  To monitor complete directory trees it is necessary to mark "
"the relevant mount."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:278
msgid "The following composed values are defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:282
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:286
msgid ""
"A file or directory has been moved (B<FAN_MOVED_FROM>|B<FAN_MOVED_TO>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:291
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:297
msgid ""
"If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:305
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:311
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:322
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:332
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the"
" filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:339
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:344
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:353
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:363
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> or "
"B<FAN_REPORT_FID> and mask contains a flag for permission events "
"(B<FAN_OPEN_PERM> or B<FAN_ACCESS_PERM>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:372
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist."
"  This error also occurs when trying to remove a mark from an object which "
"is not marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:375
msgid "The necessary memory could not be allocated."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:375
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:381
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS>"
" flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:387
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:397
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:397
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:411
msgid ""
"The filesystem object indicated by I<pathname> resides within a filesystem "
"subvolume (e.g., B<btrfs>(5))  which uses a different I<fsid> than its root "
"superblock.  This error can be returned only when an fanotify file "
"descriptor returned by B<fanotify_init>(2)  has been created with "
"B<FAN_REPORT_FID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:424
msgid ""
"The filesystem object indicated by I<pathname> is not associated with a "
"filesystem that supports I<fsid> (e.g., B<tmpfs>(5)).  This error can be "
"returned only when an fanotify file descriptor returned by "
"B<fanotify_init>(2)  has been created with B<FAN_REPORT_FID>."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:424
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:435
msgid ""
"The object indicated by I<pathname> is associated with a filesystem that "
"does not support the encoding of file handles.  This error can be returned "
"only when an fanotify file descriptor returned by B<fanotify_init>(2)  has "
"been created with B<FAN_REPORT_FID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:439
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and"
" enabled in version 2.6.37."
msgstr ""

#. type: SS
#: man-pages/man2/fanotify_mark.2:442
#, no-wrap
msgid "FAN_OPEN_EXEC and FAN_OPEN_EXEC_PERM"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:459
msgid ""
"When using either B<FAN_OPEN_EXEC> or B<FAN_OPEN_EXEC_PERM> within the "
"I<mask>, events of these types will be returned only when the direct "
"execution of a program occurs.  More specifically, this means that events of"
" these types will be generated for files that are opened using B<execve>(2),"
" B<execveat>(2), or B<uselib>(2).  Events of these types will not be raised "
"in the situation where an interpreter is passed (or reads) a script file for"
" interpretation."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:466
msgid ""
"Additionally, if a mark has also been placed on the Linux dynamic linker, a "
"user should also expect to receive an event for it when an ELF object has "
"been successfully opened using B<execve>(2)  or B<execveat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:470
msgid ""
"For example, if the following ELF binary were to be invoked and a "
"B<FAN_OPEN_EXEC> mark has been placed on /:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:474
#, no-wrap
msgid "$ /bin/echo foo\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:480
msgid ""
"The listening application in this case would receive B<FAN_OPEN_EXEC> events"
" for both the ELF binary and interpreter, respectively:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:485
#, no-wrap
msgid ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:489
msgid "The following bugs were present in Linux kernels before version 3.16:"
msgstr ""

#.  Fixed by commit 0a8dd2db579f7a0ac7033d6b857c3d5dbaa77563
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:499
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd> and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""

#.  Fixed by commit d4c7cf6cffb1bc711a833b5e304ba5bcfe76398b
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:505
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr ""

#.  Fixed by commit cc299a98eb13a9853675a9cbb90b30b4011e1406
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:513
msgid ""
"If B<fanotify_mark>()  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:515
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/fcntl.2:68
#, no-wrap
msgid "FCNTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:71
msgid "fcntl - manipulate file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:75
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:77
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:84
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:98
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is"
" indicated in parentheses after each I<cmd> name (in most cases, the "
"required type is I<int>, and we identify the argument using the name "
"I<arg>), or I<void> is specified if the argument is not required."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:109
msgid ""
"Certain of the operations below are supported only since a particular Linux "
"kernel version.  The preferred method of checking whether the host kernel "
"supports a particular operation is to invoke B<fcntl>()  with the desired "
"I<cmd> value and then test whether the call failed with B<EINVAL>, "
"indicating that the kernel does not recognize this value."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:109
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:110
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:119
msgid ""
"Duplicate the file descriptor I<fd> using the lowest-numbered available file"
" descriptor greater than or equal to I<arg>.  This is different from "
"B<dup2>(2), which uses exactly the file descriptor specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:121
msgid "On success, the new file descriptor is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:125
msgid "See B<dup>(2)  for further details."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:125
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:142
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate file descriptor.  Specifying this flag permits a program to avoid "
"an additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> "
"flag.  For an explanation of why this flag is useful, see the description of"
" B<O_CLOEXEC> in B<open>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:142
#, no-wrap
msgid "File descriptor flags"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:160
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is set, the file descriptor "
"will automatically be closed during a successful B<execve>(2).  (If the "
"B<execve>(2)  fails, the file descriptor is left open.)  If the "
"B<FD_CLOEXEC> bit is not set, the file descriptor will remain open across an"
" B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:160
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:165
msgid ""
"Return (as the function result) the file descriptor flags; I<arg> is "
"ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:165
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:169
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:184
msgid ""
"In multithreaded programs, using B<fcntl>()  B<F_SETFD> to set the close-on-"
"exec flag at the same time as another thread performs a B<fork>(2)  plus "
"B<execve>(2)  is vulnerable to a race condition that may unintentionally "
"leak the file descriptor to the program executed in the child process.  See "
"the discussion of the B<O_CLOEXEC> flag in B<open>(2)  for details and a "
"remedy to the problem."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:184
#, no-wrap
msgid "File status flags"
msgstr ""

#.  or
#.  .BR creat (2),
#. type: Plain text
#: man-pages/man2/fcntl.2:199
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer"
" to the same open file description, and thus share the same file status "
"flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:202
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:202
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:208
msgid ""
"Return (as the function result)  the file access mode and the file status "
"flags; I<arg> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:208
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:233
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux, this command can change only the B<O_APPEND>, B<O_ASYNC>, "
"B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to "
"change the B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:233
#, no-wrap
msgid "Advisory record locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:238
msgid ""
"Linux implements traditional (\"process-associated\") UNIX record locks, as "
"standardized by POSIX.  For a Linux-specific alternative with better "
"semantics, see the discussion of open file description locks below."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:249
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as byte-range, file-"
"segment, or file-region locks).  The third argument, I<lock>, is a pointer "
"to a structure that has at least the following fields (in unspecified "
"order)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:264
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:272
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:292
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:307
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:320
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:339
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:339
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:364
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>.  (The error returned in this case differs across "
"implementations, so POSIX requires a portable application to check for both "
"errors.)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:364
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:378
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the"
" call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:378
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:392
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:409
msgid ""
"If one or more incompatible locks would prevent this lock being placed, then"
" B<fcntl>()  returns details about one of those locks in the I<l_type>, "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If the conflicting"
" lock is a traditional (process-associated) record lock, then the I<l_pid> "
"field is set to the PID of the process holding that lock.  If the "
"conflicting lock is an open file description lock, then I<l_pid> is set to "
"-1.  Note that the returned information may already be out of date by the "
"time the caller inspects it."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:417
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:440
msgid ""
"When placing locks with B<F_SETLKW>, the kernel detects I<deadlocks>, "
"whereby two or more processes have their lock requests mutually blocked by "
"locks held by the other processes.  For example, suppose process A holds a "
"write lock on byte 100 of a file, and process B holds a write lock on byte "
"200.  If each process then attempts to lock the byte already locked by the "
"other process using B<F_SETLKW>, then, without deadlock detection, both "
"processes would remain blocked indefinitely.  When the kernel detects such "
"deadlocks, it causes one of the blocking lock requests to immediately fail "
"with the error B<EDEADLK>; an application that encounters such an error "
"should release some of its locks to allow other applications to proceed "
"before attempting regain the locks that it requires.  Circular deadlocks "
"involving more than two processes are also detected.  Note, however, that "
"there are limitations to the kernel's deadlock-detection algorithm; see "
"BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:444
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:449
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:458
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use "
"B<read>(2)  and B<write>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:462
msgid ""
"The record locks described above are associated with the process (unlike the"
" open file description locks described below).  This has some unfortunate "
"consequences:"
msgstr ""

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
#: man-pages/man2/fcntl.2:478
msgid ""
"If a process closes I<any> file descriptor referring to a file, then all of "
"the process's locks on that file are released, regardless of the file "
"descriptor(s) on which the locks were obtained.  This is bad: it means that "
"a process can lose its locks on a file such as I</etc/passwd> or "
"I</etc/mtab> when for some reason a library function decides to open, read, "
"and close the same file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:483
msgid ""
"The threads in a process share locks.  In other words, a multithreaded "
"program can't use record locking to ensure that threads don't simultaneously"
" access the same region of a file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:485
msgid "Open file description locks solve both of these problems."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:485
#, no-wrap
msgid "Open file description locks (non-POSIX)"
msgstr ""

#.  FIXME . Review progress into POSIX
#.  http://austingroupbugs.net/view.php?id=768
#. type: Plain text
#: man-pages/man2/fcntl.2:496
msgid ""
"Open file description locks are advisory byte-range locks whose operation is"
" in most respects identical to the traditional record locks described above."
"  This lock type is Linux-specific, and available since Linux 3.15.  (There "
"is a proposal with the Austin Group to include this lock type in the next "
"revision of POSIX.1.)  For an explanation of open file descriptions, see "
"B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:514
msgid ""
"The principal difference between the two lock types is that whereas "
"traditional record locks are associated with a process, open file "
"description locks are associated with the open file description on which "
"they are acquired, much like locks acquired with B<flock>(2).  Consequently "
"(and unlike traditional advisory record locks), open file description locks "
"are inherited across B<fork>(2)  (and B<clone>(2)  with B<CLONE_FILES>), and"
" are only automatically released on the last close of the open file "
"description, instead of being released on any close of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:520
msgid ""
"Conflicting lock combinations (i.e., a read lock and a write lock or two "
"write locks)  where one lock is an open file description lock and the other "
"is a traditional record lock conflict even when they are acquired by the "
"same process on the same file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:533
msgid ""
"Open file description locks placed via the same open file description (i.e.,"
" via the same file descriptor, or via a duplicate of the file descriptor "
"created by B<fork>(2), B<dup>(2), B<fcntl>()  B<F_DUPFD>, and so on) are "
"always compatible: if a new lock is placed on an already locked region, then"
" the existing lock is converted to the new lock type.  (Such conversions may"
" result in splitting, shrinking, or coalescing with an existing lock as "
"discussed above.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:541
msgid ""
"On the other hand, open file description locks may conflict with each other "
"when they are acquired via different open file descriptions.  Thus, the "
"threads in a multithreaded program can use open file description locks to "
"synchronize access to a file region by having each thread perform its own "
"B<open>(2)  on the file and applying locks via the resulting file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:552
msgid ""
"As with traditional advisory locks, the third argument to B<fcntl>(), "
"I<lock>, is a pointer to an I<flock> structure.  By contrast with "
"traditional record locks, the I<l_pid> field of that structure must be set "
"to zero when using the commands described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:555
msgid ""
"The commands for working with open file description locks are analogous to "
"those used with traditional locks:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:555
#, no-wrap
msgid "B<F_OFD_SETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:576
msgid ""
"Acquire an open file description lock (when I<l_type> is B<F_RDLCK> or "
"B<F_WRLCK>)  or release an open file description lock (when I<l_type> is "
"B<F_UNLCK>)  on the bytes specified by the I<l_whence>, I<l_start>, and "
"I<l_len> fields of I<lock>.  If a conflicting lock is held by another "
"process, this call returns -1 and sets I<errno> to B<EAGAIN>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:576
#, no-wrap
msgid "B<F_OFD_SETLKW> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:590
msgid ""
"As for B<F_OFD_SETLK>, but if a conflicting lock is held on the file, then "
"wait for that lock to be released.  If a signal is caught while waiting, "
"then the call is interrupted and (after the signal handler has returned) "
"returns immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:590
#, no-wrap
msgid "B<F_OFD_GETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:609
msgid ""
"On input to this call, I<lock> describes an open file description lock we "
"would like to place on the file.  If the lock could be placed, B<fcntl>()  "
"does not actually place it, but returns B<F_UNLCK> in the I<l_type> field of"
" I<lock> and leaves the other fields of the structure unchanged.  If one or "
"more incompatible locks would prevent this lock being placed, then details "
"about one of these locks are returned via I<lock>, as described above for "
"B<F_GETLK>."
msgstr ""

#.  commit 57b65325fe34ec4c917bc4e555144b4a94d9e1f7
#. type: Plain text
#: man-pages/man2/fcntl.2:616
msgid ""
"In the current implementation, no deadlock detection is performed for open "
"file description locks.  (This contrasts with process-associated record "
"locks, for which the kernel does perform deadlock detection.)"
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:616 man-pages/man2/fcntl.2:2067
#, no-wrap
msgid "Mandatory locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:626
msgid ""
"I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
"See BUGS below.  Because of these bugs, and the fact that the feature is "
"believed to be little used, since Linux 4.5, mandatory locking has been made"
" an optional feature, governed by a configuration option "
"(B<CONFIG_MANDATORY_FILE_LOCKING>).  This is an initial step toward removing"
" this feature completely."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:631
msgid ""
"By default, both traditional (process-associated) and open file description "
"record locks are advisory.  Advisory locks are not enforced and are useful "
"only between cooperating processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:651
msgid ""
"Both lock types can also be mandatory.  Mandatory locks are enforced for all"
" processes.  If a process tries to perform an incompatible access (e.g., "
"B<read>(2)  or B<write>(2))  on a file region that has an incompatible "
"mandatory lock, then the result depends upon whether the B<O_NONBLOCK> flag "
"is enabled for its open file description.  If the B<O_NONBLOCK> flag is not "
"enabled, then the system call is blocked until the lock is removed or "
"converted to a mode that is compatible with the access.  If the "
"B<O_NONBLOCK> flag is enabled, then the system call fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:668
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself."
"  Mandatory locking is enabled on a filesystem using the \"-o mand\" option "
"to B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory "
"locking is enabled on a file by disabling group execute permission on the "
"file and enabling the set-group-ID permission bit (see B<chmod>(1)  and "
"B<chmod>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:673
msgid ""
"Mandatory locking is not specified by POSIX.  Some other systems also "
"support mandatory locking, although the details of how to enable it vary "
"across systems."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:673
#, no-wrap
msgid "Lost locks"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:680
msgid ""
"When an advisory lock is obtained on a networked filesystem such as NFS it "
"is possible that the lock might get lost.  This may happen due to "
"administrative action on the server, or due to a network partition (i.e., "
"loss of network connectivity with the server)  which lasts long enough for "
"the server to assume that the client is no longer functioning."
msgstr ""

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#. type: Plain text
#: man-pages/man2/fcntl.2:692
msgid ""
"When the filesystem determines that a lock has been lost, future B<read>(2)"
"  or B<write>(2)  requests may fail with the error B<EIO>.  This error will "
"persist until the lock is removed or the file descriptor is closed.  Since "
"Linux 3.12, this happens at least for NFSv4 (including all minor versions)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:699
msgid ""
"Some versions of UNIX send a signal (B<SIGLOST>)  in this circumstance.  "
"Linux does not define this signal, and does not provide any asynchronous "
"notification of lost locks."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:699
#, no-wrap
msgid "Managing signals"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:708
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:708
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:721
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:721
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:738
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on the file descriptor I<fd>.  The target "
"process or process group ID is specified in I<arg>.  A process ID is "
"specified as a positive value; a process group ID is specified as a negative"
" value.  Most commonly, the calling process specifies itself as the owner "
"(that is, I<arg> is specified as B<getpid>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:756
msgid ""
"As well as setting the file descriptor owner, one must also enable "
"generation of signals on the file descriptor.  This is done by using the "
"B<fcntl>()  B<F_SETFL> command to set the B<O_ASYNC> file status flag on the"
" file descriptor.  Subsequently, a B<SIGIO> signal is sent whenever input or"
" output becomes possible on the file descriptor.  The B<fcntl>()  "
"B<F_SETSIG> command can be used to obtain delivery of a signal other than "
"B<SIGIO>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:773
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below).  If this permission check fails, then the signal is silently "
"discarded.  I<Note>: The B<F_SETOWN> operation records the caller's "
"credentials at the time of the B<fcntl>()  call, and it is these saved "
"credentials that are used for the permission checks."
msgstr ""

#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
#: man-pages/man2/fcntl.2:797
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where "
"B<select>(2)  would report the socket as having an \"exceptional "
"condition\".)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:800
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr ""

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
#: man-pages/man2/fcntl.2:840
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current"
" Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:851
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:851
#, no-wrap
msgid "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:860
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:867
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:884
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:884
#, no-wrap
msgid "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:900
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller"
" to direct I/O availability signals to a specific thread, process, or "
"process group.  The caller specifies the target of signals via I<arg>, which"
" is a pointer to a I<f_owner_ex> structure.  The I<type> field has one of "
"the following values, which define how I<pid> is interpreted:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:901
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:910
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:910
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:915
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:915
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:923
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note"
" that, unlike with B<F_SETOWN>, a process group ID is specified as a "
"positive value here.)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:924
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:939
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:939
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr ""

#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
#: man-pages/man2/fcntl.2:962
msgid ""
"Set the signal sent when input or output becomes possible to the value given"
" in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any"
" other value (including B<SIGIO>)  is the signal to send instead, and in "
"this case additional info is available to the signal handler if installed "
"with B<SA_SIGINFO>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:990
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the"
" signal handler (see B<sigaction>(2)), extra information about I/O events is"
" passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field"
" indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1003
msgid ""
"Note that the file descriptor provided in I<si_fd> is the one that was "
"specified during the B<F_SETSIG> operation.  This can lead to an unusual "
"corner case.  If the file descriptor is duplicated (B<dup>(2)  or similar), "
"and the original file descriptor is closed, then I/O events will continue to"
" be generated, but the I<si_fd> field will contain the number of the now "
"closed file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1012
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory.)  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
#: man-pages/man2/fcntl.2:1025
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1032
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1056
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1056
#, no-wrap
msgid "Leases"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1071
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used to establish a "
"new lease, and retrieve the current lease, on the open file description "
"referred to by the file descriptor I<fd>.  A file lease provides a mechanism"
" whereby the process holding the lease (the \"lease holder\") is notified "
"(via delivery of a signal)  when a process (the \"lease breaker\") tries to "
"B<open>(2)  or B<truncate>(2)  the file referred to by that file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1071
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1076
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1077
#, no-wrap
msgid "B<F_RDLCK>"
msgstr ""

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
#: man-pages/man2/fcntl.2:1086
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1086
#, no-wrap
msgid "B<F_WRLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1093
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be"
" placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1093
#, no-wrap
msgid "B<F_UNLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1096
msgid "Remove our lease from the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1110
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released"
" by either an explicit B<F_UNLCK> operation on any of these duplicate file "
"descriptors, or when all such file descriptors have been closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1117
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID"
" of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1117
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1126
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by"
" returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1157
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or "
"B<truncate>(2)  that conflicts with a lease established via B<F_SETLEASE>, "
"the system call is blocked by the kernel and the kernel notifies the lease "
"holder by sending it a signal (B<SIGIO> by default).  The lease holder "
"should respond to receipt of this signal by doing whatever cleanup is "
"required in preparation for the file to be accessed by another process "
"(e.g., flushing cached buffers) and then either remove or downgrade its "
"lease.  A lease is removed by performing an B<F_SETLEASE> command specifying"
" I<arg> as B<F_UNLCK>.  If the lease holder currently holds a write lease on"
" the file, and the lease breaker is opening the file for reading, then it is"
" sufficient for the lease holder to downgrade the lease to a read lease.  "
"This is done by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_RDLCK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1162
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number"
" of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1172
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1176
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1197
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted"
" by a signal handler, then the system call fails with the error B<EINTR>, "
"but the other steps still occur as described above.  If the lease breaker is"
" killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the"
" other steps still occur as described above.  If the lease breaker specifies"
" the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1218
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can"
" be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the file descriptor of the leased file that has been"
" accessed by another process.  (This is useful if the caller holds leases "
"against multiple files.)"
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1218
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1219
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1229
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1232
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1239
msgid ""
"A file was accessed (B<read>(2), B<pread>(2), B<readv>(2), and similar)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1239
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1248
msgid ""
"A file was modified (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2), and similar)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1248
#, no-wrap
msgid "B<DN_CREATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1259
msgid ""
"A file was created (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2)  into this directory)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1259
#, no-wrap
msgid "B<DN_DELETE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1266
msgid ""
"A file was unlinked (B<unlink>(2), B<rename>(2)  to another directory, "
"B<rmdir>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1266
#, no-wrap
msgid "B<DN_RENAME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1270
msgid "A file was renamed within this directory (B<rename>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1270
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1278
msgid ""
"The attributes of a file were changed (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2), and similar)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1286
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro"
" must be defined before including I<any> header files.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1294
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""

#.  The following does seem a poor API-design choice...
#. type: Plain text
#: man-pages/man2/fcntl.2:1306
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1329
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to "
"B<fcntl>().  (Note that B<SIGIO> is one of the nonqueuing standard signals; "
"switching to the use of a real-time signal means that multiple notifications"
" can be queued to the process.)  In the latter case, the signal handler "
"receives a I<siginfo_t> structure as its second argument (if the handler was"
" established using B<SA_SIGINFO>)  and the I<si_fd> field of this structure "
"contains the file descriptor which generated the notification (useful when "
"establishing notification on multiple directories)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1334
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for"
" notification, so that multiple notifications can be queued."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1343
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining"
" notifications of filesystem events.  See B<inotify>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1343
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1344
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1365
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"max-size> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in "
"I</proc/sys/fs/pipe-max-size> yield the error B<EPERM>; a privileged process"
" (B<CAP_SYS_RESOURCE>)  can override the limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1374
msgid ""
"When allocating the buffer for the pipe, the kernel may use a capacity "
"larger than I<arg>, if that is convenient for the implementation.  (In the "
"current implementation, the allocation is the next higher power-of-two page-"
"size multiple of the requested size.)  The actual capacity (in bytes) that "
"is set is returned as the function result."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1378
msgid ""
"Attempting to set the pipe capacity smaller than the amount of buffer space "
"currently used to store data produces the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1383
msgid ""
"Note that because of the way the pages of the pipe buffer are employed when "
"data is written to the pipe, the number of bytes that can be written may be "
"less than the nominal size, depending on the size of the writes."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1383
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1388
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1388
#, no-wrap
msgid "File Sealing"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1400
msgid ""
"File seals limit the set of allowed operations on a given file.  For each "
"seal that is set on a file, a specific set of operations will fail with "
"B<EPERM> on this file from now on.  The file is said to be sealed.  The "
"default set of seals depends on the type of the underlying file and "
"filesystem.  For an overview of file sealing, a discussion of its purpose, "
"and some code examples, see B<memfd_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1411
msgid ""
"Currently, file seals can be applied only to a file descriptor returned by "
"B<memfd_create>(2)  (if the B<MFD_ALLOW_SEALING> was employed).  On other "
"filesystems, all B<fcntl>()  operations that operate on seals will return "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1416
msgid ""
"Seals are a property of an inode.  Thus, all open file descriptors referring"
" to the same inode share the same set of seals.  Furthermore, seals can "
"never be removed, only added."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1416
#, no-wrap
msgid "B<F_ADD_SEALS> (I<int>; since Linux 3.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1434
msgid ""
"Add the seals given in the bit-mask argument I<arg> to the set of seals of "
"the inode referred to by the file descriptor I<fd>.  Seals cannot be removed"
" again.  Once this call succeeds, the seals are enforced by the kernel "
"immediately.  If the current set of seals includes B<F_SEAL_SEAL> (see "
"below), then this call will be rejected with B<EPERM>.  Adding a seal that "
"is already set is a no-op, in case B<F_SEAL_SEAL> is not set already.  In "
"order to place a seal, the file descriptor I<fd> must be writable."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1434
#, no-wrap
msgid "B<F_GET_SEALS> (I<void>; since Linux 3.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1444
msgid ""
"Return (as the function result) the current set of seals of the inode "
"referred to by I<fd>.  If no seals are set, 0 is returned.  If the file does"
" not support sealing, -1 is returned and I<errno> is set to B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1446
msgid "The following seals are available:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1446
#, no-wrap
msgid "B<F_SEAL_SEAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1458
msgid ""
"If this seal is set, any further call to B<fcntl>()  with B<F_ADD_SEALS> "
"fails with the error B<EPERM>.  Therefore, this seal prevents any "
"modifications to the set of seals itself.  If the initial set of seals of a "
"file includes B<F_SEAL_SEAL>, then this effectively causes the set of seals "
"to be constant and locked."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1458
#, no-wrap
msgid "B<F_SEAL_SHRINK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1473
msgid ""
"If this seal is set, the file in question cannot be reduced in size.  This "
"affects B<open>(2)  with the B<O_TRUNC> flag as well as B<truncate>(2)  and "
"B<ftruncate>(2).  Those calls fail with B<EPERM> if you try to shrink the "
"file in question.  Increasing the file size is still possible."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1473
#, no-wrap
msgid "B<F_SEAL_GROW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1487
msgid ""
"If this seal is set, the size of the file in question cannot be increased.  "
"This affects B<write>(2)  beyond the end of the file, B<truncate>(2), "
"B<ftruncate>(2), and B<fallocate>(2).  These calls fail with B<EPERM> if you"
" use them to increase the file size.  If you keep the size or shrink it, "
"those calls still work as expected."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1487
#, no-wrap
msgid "B<F_SEAL_WRITE>"
msgstr ""

#.  One or more other seals are typically used with F_SEAL_WRITE
#.  because, given a file with the F_SEAL_WRITE seal set, then,
#.  while it would no longer be possible to (say) write zeros into
#.  the last 100 bytes of a file, it would still be possible
#.  to (say) shrink the file by 100 bytes using ftruncate(), and
#.  then increase the file size by 100 bytes, which would have
#.  the effect of replacing the last hundred bytes by zeros.
#. type: Plain text
#: man-pages/man2/fcntl.2:1515
msgid ""
"If this seal is set, you cannot modify the contents of the file.  Note that "
"shrinking or growing the size of the file is still possible and allowed.  "
"Thus, this seal is normally used in combination with one of the other seals."
"  This seal affects B<write>(2)  and B<fallocate>(2)  (only in combination "
"with the B<FALLOC_FL_PUNCH_HOLE> flag).  Those calls fail with B<EPERM> if "
"this seal is set.  Furthermore, trying to create new shared, writable "
"memory-mappings via B<mmap>(2)  will also fail with B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1529
msgid ""
"Using the B<F_ADD_SEALS> operation to set the B<F_SEAL_WRITE> seal fails "
"with B<EBUSY> if any writable, shared mapping exists.  Such mappings must be"
" unmapped before you can add this seal.  Furthermore, if there are any "
"asynchronous I/O operations (B<io_submit>(2))  pending on the file, all "
"outstanding writes will be discarded."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1529
#, no-wrap
msgid "File read/write hints"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1539
msgid ""
"Write lifetime hints can be used to inform the kernel about the relative "
"expected lifetime of writes on a given inode or via a particular open file "
"description.  (See B<open>(2)  for an explanation of open file "
"descriptions.)  In this context, the term \"write lifetime\" means the "
"expected time the data will live on media, before being overwritten or "
"erased."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1547
msgid ""
"An application may use the different hint values specified below to separate"
" writes into different write classes, so that multiple users or applications"
" running on a single storage back-end can aggregate their I/O patterns in a "
"consistent manner.  However, there are no functional semantics implied by "
"these flags, and different I/O classes can use the write lifetime hints in "
"arbitrary ways, so long as the hints are used consistently."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1550
msgid "The following operations can be applied to the file descriptor, I<fd>:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1550
#, no-wrap
msgid "B<F_GET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1555
msgid ""
"Returns the value of the read/write hint associated with the underlying "
"inode referred to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1555
#, no-wrap
msgid "B<F_SET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1562
msgid ""
"Sets the read/write hint value associated with the underlying inode referred"
" to by I<fd>.  This hint persists until either it is explicitly modified or "
"the underlying filesystem is unmounted."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1562
#, no-wrap
msgid "B<F_GET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1567
msgid ""
"Returns the value of the read/write hint associated with the open file "
"description referred to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1567
#, no-wrap
msgid "B<F_SET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1572
msgid ""
"Sets the read/write hint value associated with the open file description "
"referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1575
msgid ""
"If an open file description has not been assigned a read/write hint, then it"
" shall use the value assigned to the inode, if any."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1578
msgid "The following read/write hints are valid since Linux 4.13:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1578
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NOT_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1582
msgid "No specific hint has been set.  This is the default value."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1582
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1585
msgid "No specific write lifetime is associated with this file or inode."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1585
#, no-wrap
msgid "B<RWH_WRITE_LIFE_SHORT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1589
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a short lifetime."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1589
#, no-wrap
msgid "B<RWH_WRITE_LIFE_MEDIUM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1595
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_SHORT>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1595
#, no-wrap
msgid "B<RWH_WRITE_LIFE_LONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1601
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_MEDIUM>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1601
#, no-wrap
msgid "B<RWH_WRITE_LIFE_EXTREME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1607
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_LONG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1610
msgid ""
"All the write-specific hints are relative to each other, and no individual "
"absolute meaning should be attributed to them."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1612
msgid "For a successful call, the return value depends on the operation:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1612
#, no-wrap
msgid "B<F_DUPFD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1615
msgid "The new file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1615
#, no-wrap
msgid "B<F_GETFD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1618
msgid "Value of file descriptor flags."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1618
#, no-wrap
msgid "B<F_GETFL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1621
msgid "Value of file status flags."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1621
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1624
msgid "Type of lease held on file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1624
#, no-wrap
msgid "B<F_GETOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1627
msgid "Value of file descriptor owner."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1627
#, no-wrap
msgid "B<F_GETSIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1633
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1633
#, no-wrap
msgid "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1636
msgid "The pipe capacity."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1636
#, no-wrap
msgid "B<F_GET_SEALS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1641
msgid ""
"A bit mask identifying the seals that have been set for the inode referred "
"to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1641
#, no-wrap
msgid "All other commands"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1644
msgid "Zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1648
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1649
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1652
msgid "Operation is prohibited by locks held by other processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1656
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1660
msgid "I<fd> is not an open file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1669
msgid ""
"I<cmd> is B<F_SETLK> or B<F_SETLKW> and the file descriptor open mode "
"doesn't match with the type of lock requested."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1669 man-pages/man2/fcntl.2:1678
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1678
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the new pipe capacity specified in I<arg> is "
"smaller than the amount of buffer space currently used to store data in the "
"pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1688
msgid ""
"I<cmd> is B<F_ADD_SEALS>, I<arg> includes B<F_SEAL_WRITE>, and there exists "
"a writable, shared mapping on the file referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1693
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1697
msgid "I<lock> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1706
msgid ""
"I<cmd> is B<F_SETLKW> or B<F_OFD_SETLKW> and the operation was interrupted "
"by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1719
msgid ""
"I<cmd> is B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK>, or B<F_OFD_SETLK>, and the"
" operation was interrupted by a signal before the lock was checked or "
"acquired.  Most likely when locking a remote file (e.g., locking over NFS), "
"but can sometimes happen locally."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1724
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1732
msgid ""
"I<cmd> is B<F_ADD_SEALS> and I<arg> includes an unrecognized sealing bit."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1742
msgid ""
"I<cmd> is B<F_ADD_SEALS> or B<F_GET_SEALS> and the filesystem containing the"
" inode referred to by I<fd> does not support sealing."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1754
msgid ""
"I<cmd> is B<F_DUPFD> and I<arg> is negative or is greater than the maximum "
"allowable value (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1762
msgid "I<cmd> is B<F_SETSIG> and I<arg> is not an allowable signal number."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1773
msgid ""
"I<cmd> is B<F_OFD_SETLK>, B<F_OFD_SETLKW>, or B<F_OFD_GETLK>, and I<l_pid> "
"was not specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1780
msgid ""
"I<cmd> is B<F_DUPFD> and the per-process limit on the number of open file "
"descriptors has been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1784
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1792
msgid ""
"B<F_NOTIFY> was specified in I<cmd>, but I<fd> does not refer to a "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1799
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the soft or hard user pipe limit has been "
"reached; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1804
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1814
msgid ""
"I<cmd> was B<F_ADD_SEALS>, but I<fd> was not open for writing or the current"
" set of seals on the file already includes B<F_SEAL_SEAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1827
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""

#.  .BR _BSD_SOURCE ,
#.  or
#. type: Plain text
#: man-pages/man2/fcntl.2:1839
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define either B<_XOPEN_SOURCE> with the value 500 or greater, "
"or B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1847
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
#: man-pages/man2/fcntl.2:1864
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1873
msgid ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, and B<F_OFD_GETLK> are Linux-specific (and "
"one must define B<_GNU_SOURCE> to obtain their definitions), but work is "
"being done to have them included in the next version of POSIX.1."
msgstr ""

#.  FIXME . Once glibc adds support, add a note about FTM requirements
#. type: Plain text
#: man-pages/man2/fcntl.2:1879
msgid "B<F_ADD_SEALS> and B<F_GET_SEALS> are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1885
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1885
#, no-wrap
msgid "File locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1907 man-pages/man2/fcntl.2:1949
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1907
#, no-wrap
msgid "Record locks"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1913
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#.  Also, FreeBSD documents it (Apr 2014).
#. type: Plain text
#: man-pages/man2/fcntl.2:1928
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid> (to identify the machine where the lock is held).  Clearly, "
"I<l_pid> alone is not going to be very useful if the process holding the "
"lock may live on a different machine; on Linux, while present on some "
"architectures (such as MIPS32), this field is not used."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1949
#, no-wrap
msgid "Record locking and NFS"
msgstr ""

#.  Neil Brown: With NFSv3 the failure mode is the reverse.  If
#.      the server loses contact with a client then any lock stays in place
#.      indefinitely ("why can't I read my mail"... I remember it well).
#.  Jeff Layton:
#.      Note that this is not a firm timeout. The server runs a job
#.      periodically to clean out expired stateful objects, and it's likely
#.      that there is some time (maybe even up to another whole lease period)
#.      between when the timeout expires and the job actually runs. If the
#.      client gets a RENEW in there within that window, its lease will be
#.      renewed and its state preserved.
#. type: Plain text
#: man-pages/man2/fcntl.2:1977
msgid ""
"Before Linux 3.12, if an NFSv4 client loses contact with the server for a "
"period of time (defined as more than 90 seconds with no communication), it "
"might lose and regain a lock without ever being aware of the fact.  (The "
"period of time after which contact is assumed lost is known as the NFSv4 "
"leasetime.  On a Linux NFS server, this can be determined by looking at "
"I</proc/fs/nfsd/nfsv4leasetime>, which expresses the period in seconds.  The"
" default value for this file is 90.)  This scenario potentially risks data "
"corruption, since another process might acquire a lock in the intervening "
"period and perform file I/O."
msgstr ""

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#.  commit f6de7a39c181dfb8a2c534661a53c73afb3081cd
#. type: Plain text
#: man-pages/man2/fcntl.2:1991
msgid ""
"Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O "
"to the file by a process which \"thinks\" it holds a lock will fail until "
"that process closes and reopens the file.  A kernel parameter, "
"I<nfs.recover_lost_locks>, can be set to 1 to obtain the pre-3.12 behavior, "
"whereby the client will attempt to recover lost locks when contact is "
"reestablished with the server.  Because of the attendant risk of data "
"corruption, this parameter defaults to 0 (disabled)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1992
#, no-wrap
msgid "F_SETFL"
msgstr ""

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
#: man-pages/man2/fcntl.2:2004
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:2004
#, no-wrap
msgid "F_GETOWN"
msgstr ""

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
#: man-pages/man2/fcntl.2:2030
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:2030
#, no-wrap
msgid "F_SETOWN"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2048
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as"
" a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group)"
" is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:2048
#, no-wrap
msgid "Deadlock detection"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2067
msgid ""
"The deadlock-detection algorithm employed by the kernel when dealing with "
"B<F_SETLKW> requests can yield both false negatives (failures to detect "
"deadlocks, leaving a set of deadlocked processes blocked indefinitely)  and "
"false positives (B<EDEADLK> errors when there is no deadlock).  For example,"
" the kernel limits the lock depth of its dependency search to 10 steps, "
"meaning that circular deadlock chains that exceed that size will not be "
"detected.  In addition, the kernel may falsely indicate a deadlock when two "
"or more processes created using the B<clone>(2)  B<CLONE_FILES> flag place "
"locks that appear (to the kernel) to conflict."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#.  Reconfirmed by Jeff Layton
#.      From: Jeff Layton <jlayton <at> redhat.com>
#.      Subject: Re: Status of fcntl() mandatory locking
#.      Newsgroups: gmane.linux.file-systems
#.      Date: 2014-04-28 10:07:57 GMT
#.      http://thread.gmane.org/gmane.linux.file-systems/84481/focus=84518
#. type: Plain text
#: man-pages/man2/fcntl.2:2089
msgid ""
"The Linux implementation of mandatory locking is subject to race conditions "
"which render it unreliable: a B<write>(2)  call that overlaps with a lock "
"may modify data after the mandatory lock is acquired; a B<read>(2)  call "
"that overlaps with a lock may detect changes to data that were made only "
"after a write lock was acquired.  Similar races exist between mandatory "
"locks and B<mmap>(2).  It is therefore inadvisable to rely on mandatory "
"locking."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2098
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2110
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and I"
"<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""

#. type: TH
#: man-pages/man2/fsync.2:38
#, no-wrap
msgid "FSYNC"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:41
msgid ""
"fsync, fdatasync - synchronize a file's in-core state with storage device"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:45
msgid "B<int fsync(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:47
msgid "B<int fdatasync(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:59
#, no-wrap
msgid ""
"B<fsync>():\n"
"    Glibc 2.16 and later:\n"
"        No feature test macros need be defined\n"
"    Glibc up to and including 2.15:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\n"
"            || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:62
#, no-wrap
msgid ""
"B<fdatasync>():\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:73
msgid ""
"B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
"modified buffer cache pages for) the file referred to by the file descriptor"
" I<fd> to the disk device (or other permanent storage device) so that all "
"changed information can be retrieved even if the system crashes or is "
"rebooted.  This includes writing through or flushing a disk cache if "
"present.  The call blocks until the device reports that the transfer has "
"completed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:78
msgid ""
"As well as flushing the file data, B<fsync>()  also flushes the metadata "
"information associated with the file (see B<inode>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:86
msgid ""
"Calling B<fsync>()  does not necessarily ensure that the entry in the "
"directory containing the file has also reached disk.  For that an explicit "
"B<fsync>()  on a file descriptor for the directory is also needed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:107
msgid ""
"B<fdatasync>()  is similar to B<fsync>(), but does not flush modified "
"metadata unless that metadata is needed in order to allow a subsequent data "
"retrieval to be correctly handled.  For example, changes to I<st_atime> or "
"I<st_mtime> (respectively, time of last access and time of last "
"modification; see B<inode>(7))  do not require flushing because they are not"
" necessary for a subsequent data read to be handled correctly.  On the other"
" hand, a change to the file size (I<st_size>, as made by say "
"B<ftruncate>(2)), would require a metadata flush."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:112
msgid ""
"The aim of B<fdatasync>()  is to reduce disk activity for applications that "
"do not require all metadata to be synchronized with the disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:117
msgid ""
"On success, these system calls return zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:122
msgid "I<fd> is not a valid open file descriptor."
msgstr ""

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: man-pages/man2/fsync.2:136
msgid ""
"An error occurred during synchronization.  This error may relate to data "
"written to some other file descriptor on the same file.  Since Linux 4.13, "
"errors from write-back will be reported to all file descriptors that might "
"have written the data which triggered the error.  Some filesystems (e.g., "
"NFS) keep close track of which data came through which file descriptor, and "
"give more precise reporting.  Other filesystems (e.g., most local "
"filesystems) will report errors to all file descriptors that were open on "
"the file when the error was recorded."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:139
msgid "Disk space was exhausted while synchronizing."
msgstr ""

#. type: TP
#: man-pages/man2/fsync.2:139
#, no-wrap
msgid "B<EROFS>, B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:144
msgid ""
"I<fd> is bound to a special file (e.g., a pipe, FIFO, or socket)  which does"
" not support synchronization."
msgstr ""

#. type: TP
#: man-pages/man2/fsync.2:144
#, no-wrap
msgid "B<ENOSPC>, B<EDQUOT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:152
msgid ""
"I<fd> is bound to a file on NFS or another filesystem which does not "
"allocate space at the time of a B<write>(2)  system call, and some previous "
"write failed due to insufficient storage space."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:154
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: SH
#: man-pages/man2/fsync.2:154
#, no-wrap
msgid "AVAILABILITY"
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/fsync.2:167
msgid ""
"On POSIX systems on which B<fdatasync>()  is available, "
"B<_POSIX_SYNCHRONIZED_IO> is defined in I<E<lt>unistd.hE<gt>> to a value "
"greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:173
msgid ""
"On some UNIX systems (but not Linux), I<fd> must be a I<writable> file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:179
msgid ""
"In Linux 2.2 and earlier, B<fdatasync>()  is equivalent to B<fsync>(), and "
"so has no performance advantage."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:189
msgid ""
"The B<fsync>()  implementations in older kernels and lesser used filesystems"
" do not know how to flush disk caches.  In these cases disk caches need to "
"be disabled using B<hdparm>(8)  or B<sdparm>(8)  to guarantee safe "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:200
msgid ""
"B<sync>(1), B<bdflush>(2), B<open>(2), B<posix_fadvise>(2), B<pwritev>(2), "
"B<sync>(2), B<sync_file_range>(2), B<fflush>(3), B<fileno>(3), B<hdparm>(8),"
" B<mount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, mounts or filesystems for which fanotify events shall be"
" created.  These events are received by reading from the file descriptor.  "
"Some events are only informative, indicating that a file has been accessed."
"  Other events can be used to determine whether another application is "
"permitted to access a file or directory.  Permission to access filesystem "
"objects is granted by writing to the file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is"
" used to establish the sequence in which the listeners receive the events."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:80
msgid ""
"Only one of the following notification classes may be specified in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_REPORT_FID> (since Linux 5.1)"
msgstr ""

#.  commit a8b13aa20afb69161b5123b4f1acc7ea0a03d360
#. type: Plain text
#: man-pages/man2/fanotify_init.2:126
msgid ""
"This value allows the receipt of events which contain additional information"
" about the underlying filesystem object correlated to an event.  An "
"additional structure encapsulates the information about the object and is "
"included alongside the generic event metadata structure.  The file "
"descriptor that is used to represent the object correlated to an event is "
"instead substituted with a file handle.  It is intended for applications "
"that may find the use of a file handle to identify an object more suitable "
"than a file descriptor.  Additionally, it may be used for applications that "
"are interested in directory entry events, such as B<FAN_CREATE>, "
"B<FAN_ATTRIB>, B<FAN_MOVE>, and B<FAN_DELETE> for example.  Note that the "
"use of directory modification events are not supported when monitoring a "
"mount point.  The use of B<FAN_CLASS_CONTENT> or B<FAN_CLASS_PRE_CONTENT> is"
" not permitted with this flag and will result in the error B<EINVAL>.  See "
"B<fanotify>(7)  for additional information."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:126
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:133
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:141
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:144
msgid "The following bits can additionally be set in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:144
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:153
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:153
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:163
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  fails with the error B<EAGAIN>."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:163
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:169
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:169
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:175
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:175
#, no-wrap
msgid "B<FAN_REPORT_TID> (since Linux 4.20)"
msgstr ""

#.  commit d0a6a87e40da49cfc7954c491d3065a25a641b29
#. type: Plain text
#: man-pages/man2/fanotify_init.2:187
msgid ""
"Report thread ID (TID) instead of process ID (PID)  in the I<pid> field of "
"the I<struct fanotify_event_metadata> supplied to B<read>(2)  (see "
"B<fanotify>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:200
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set"
" on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:200
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:203
msgid "This value allows only read access."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:203
#, no-wrap
msgid "B<O_WRONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:206
msgid "This value allows only write access."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:206
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:209
msgid "This value allows read and write access."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:213
msgid ""
"Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:213
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:220
msgid ""
"Enable support for files exceeding 2\\ GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:220
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 3.18)"
msgstr ""

#.  commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:229
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:242
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags>"
" yields the error B<EINVAL> (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:249
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1"
" is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  commit 23c9deeb3285d34fd243abb3d6b9f07db60c3cf4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:261
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> (deprecated since Linux kernel version 4.20)  defines "
"all allowable bits for I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:264
msgid "The number of fanotify groups for this user exceeds 128."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:267
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:270
msgid "The allocation of memory for the notification group failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:276
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:281
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN>"
" capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:285
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and"
" enabled in version 2.6.37."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:289
msgid "The following bug was present in Linux kernels before version 3.18:"
msgstr ""

#.  Fixed by commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:295
msgid "The B<O_CLOEXEC> is ignored when passed in I<event_f_flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:297
msgid "The following bug was present in Linux kernels before version 3.14:"
msgstr ""

#.  Fixed by commit 48149e9d3a7e924010a0daab30a6197b7d7b6580
#. type: Plain text
#: man-pages/man2/fanotify_init.2:307
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from"
" the fanotify file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:309
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr ""

#. type: TH
#: man-pages/man2/fallocate.2:11
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:18
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:21
#, no-wrap
msgid ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see"
" B<posix_fallocate>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:65
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"the disk space within the range specified by I<offset> and I<len>.  The file"
" size (as reported by B<stat>(2))  will be changed if I<offset>+I<len> is "
"greater than the file size.  Any subregion within the range specified by "
"I<offset> and I<len> that did not contain data before the call will be "
"initialized to zero.  This default behavior closely resembles the behavior "
"of the B<posix_fallocate>(3)  library function, and is intended as a method "
"of optimally implementing that function."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:71
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:82
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if "
"I<offset>+I<len> is greater than the file size.  Preallocating zeroed blocks"
" beyond the end of the file in this manner is useful for optimizing append "
"workloads."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:92
msgid ""
"If the B<FALLOC_FL_UNSHARE> flag is specified in I<mode>, shared file data "
"extents will be made private to the file to guarantee that a subsequent "
"write will not fail due to lack of space.  Typically, this will be done by "
"performing a copy-on-write operation on all shared data in the file.  This "
"flag may not be supported by all filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:96
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:96
#, no-wrap
msgid "Deallocating file space"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:111
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified"
" range, partial filesystem blocks are zeroed, and whole filesystem blocks "
"are removed from the file.  After a successful call, subsequent reads from "
"this range will return zeros."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:122
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in"
" I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:127
msgid ""
"Not all filesystems support B<FALLOC_FL_PUNCH_HOLE>; if a filesystem doesn't"
" support the operation, an error is returned.  The operation is supported on"
" at least the following filesystems:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:129
msgid "XFS (since Linux 2.6.38)"
msgstr ""

#.  commit a4bb6b64e39abc0e41ca077725f2a72c868e7622
#. type: Plain text
#: man-pages/man2/fallocate.2:132
msgid "ext4 (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:134
msgid "Btrfs (since Linux 3.7)"
msgstr ""

#.  commit 83e4fa9c16e4af7122e31be3eca5d57881d236fe
#. type: Plain text
#: man-pages/man2/fallocate.2:138
msgid "B<tmpfs>(5)  (since Linux 3.5)\""
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:138
#, no-wrap
msgid "Collapsing file space"
msgstr ""

#.  commit 00f5e61998dd17f5375d9dfc01331f104b83f841
#. type: Plain text
#: man-pages/man2/fallocate.2:158
msgid ""
"Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux 3.15)"
" in I<mode> removes a byte range from a file, without leaving a hole.  The "
"byte range to be collapsed starts at I<offset> and continues for I<len> "
"bytes.  At the completion of the operation, the contents of the file "
"starting at the location I<offset+len> will be appended at the location "
"I<offset>, and the file will be I<len> bytes smaller."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:172
msgid ""
"A filesystem may place limitations on the granularity of the operation, in "
"order to ensure efficient implementation.  Typically, I<offset> and I<len> "
"must be a multiple of the filesystem logical block size, which varies "
"according to the filesystem type and configuration.  If a filesystem has "
"such a requirement, B<fallocate>()  fails with the error B<EINVAL> if this "
"requirement is violated."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:181
msgid ""
"If the region specified by I<offset> plus I<len> reaches or passes the end "
"of file, an error is returned; instead, use B<ftruncate>(2)  to truncate a "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:186
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""

#.  commit 9eb79482a97152930b113b51dff530aba9e28c8e
#.  commit e1d8fb88a64c1f8094b9f6c3b6d2d9e6719c970d
#. type: Plain text
#: man-pages/man2/fallocate.2:194
msgid ""
"As at Linux 3.15, B<FALLOC_FL_COLLAPSE_RANGE> is supported by ext4 (only for"
" extent-based files)  and XFS."
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:194
#, no-wrap
msgid "Zeroing file space"
msgstr ""

#.  commit 409332b65d3ed8cfa7a8030f1e9d52f372219642
#. type: Plain text
#: man-pages/man2/fallocate.2:210
msgid ""
"Specifying the B<FALLOC_FL_ZERO_RANGE> flag (available since Linux 3.15)  in"
" I<mode> zeros space in the byte range starting at I<offset> and continuing "
"for I<len> bytes.  Within the specified range, blocks are preallocated for "
"the regions that span the holes in the file.  After a successful call, "
"subsequent reads from this range will return zeros."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:216
msgid ""
"Zeroing is done within the filesystem preferably by converting the range "
"into unwritten extents.  This approach means that the specified range will "
"not be physically zeroed out on the device (except for partial blocks at the"
" either end of the range), and I/O is (otherwise) required only to update "
"metadata."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:228
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is additionally specified in I<mode>, the"
" behavior of the call is similar, but the file size will not be changed even"
" if I<offset>+I<len> is greater than the file size.  This behavior is the "
"same as when preallocating space with B<FALLOC_FL_KEEP_SIZE> specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:233
msgid ""
"Not all filesystems support B<FALLOC_FL_ZERO_RANGE>; if a filesystem doesn't"
" support the operation, an error is returned.  The operation is supported on"
" at least the following filesystems:"
msgstr ""

#.  commit 376ba313147b4172f3e8cf620b9fb591f3e8cdfa
#. type: Plain text
#: man-pages/man2/fallocate.2:236
msgid "XFS (since Linux 3.15)"
msgstr ""

#.  commit b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
#. type: Plain text
#: man-pages/man2/fallocate.2:239
msgid "ext4, for extent-based files (since Linux 3.15)"
msgstr ""

#.  commit 30175628bf7f521e9ee31ac98fa6d6fe7441a556
#. type: Plain text
#: man-pages/man2/fallocate.2:242
msgid "SMB3 (since Linux 3.17)"
msgstr ""

#.  commit f27451f229966874a8793995b8e6b74326d125df
#. type: Plain text
#: man-pages/man2/fallocate.2:245
msgid "Btrfs (since Linux 4.16)"
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:245
#, no-wrap
msgid "Increasing file space"
msgstr ""

#.  commit dd46c787788d5bf5b974729d43e4c405814a4c7d
#. type: Plain text
#: man-pages/man2/fallocate.2:268
msgid ""
"Specifying the B<FALLOC_FL_INSERT_RANGE> flag (available since Linux 4.1)  "
"in I<mode> increases the file space by inserting a hole within the file size"
" without overwriting any existing data.  The hole will start at I<offset> "
"and continue for I<len> bytes.  When inserting the hole inside file, the "
"contents of the file starting at I<offset> will be shifted upward (i.e., to "
"a higher file offset) by I<len> bytes.  Inserting a hole inside a file "
"increases the file size by I<len> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:282
msgid ""
"This mode has the same limitations as B<FALLOC_FL_COLLAPSE_RANGE> regarding "
"the granularity of the operation.  If the granularity requirements are not "
"met, B<fallocate>()  fails with the error B<EINVAL>.  If the I<offset> is "
"equal to or greater than the end of file, an error is returned.  For such "
"operations (i.e., inserting a hole at the end of file), B<ftruncate>(2)  "
"should be used."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:287
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_INSERT_RANGE>."
msgstr ""

#.  commit a904b1ca5751faf5ece8600e18cd3b674afcca1b
#.  commit 331573febb6a224bc50322e3670da326cb7f4cfc
#.  f2fs also has support since Linux 4.2
#.      commit f62185d0e283e9d311e3ac1020f159d95f0aab39
#. type: Plain text
#: man-pages/man2/fallocate.2:297
msgid ""
"B<FALLOC_FL_INSERT_RANGE> requires filesystem support.  Filesystems that "
"support this operation include XFS (since Linux 4.1)  and ext4 (since Linux "
"4.2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:304
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:309
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:309 man-pages/man2/fallocate.2:313
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:313
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:319
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE>, and the current file size+I<len> "
"exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:323
msgid "A signal was caught during execution; see B<signal>(7)."
msgstr ""

#.  FIXME . (raise a kernel bug) Probably the len==0 case should be
#.  a no-op, rather than an error. That would be consistent with
#.  similar APIs for the len==0 case.
#.  See "Re: [PATCH] fallocate.2: add FALLOC_FL_PUNCH_HOLE flag definition"
#.  21 Sep 2012
#.  http://thread.gmane.org/gmane.linux.file-systems/48331/focus=1193526
#. type: Plain text
#: man-pages/man2/fallocate.2:335
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:345
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by I<offset> "
"plus I<len> reaches or passes the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:353
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE> and the range specified by I<offset> "
"reaches or passes the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:365
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, but "
"either I<offset> or I<len> is not a multiple of the filesystem block size."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:377
msgid ""
"I<mode> contains one of B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and also other flags; no other flags are permitted"
" with B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>."
msgstr ""

#.  There was an inconsistency in 3.15-rc1, that should be resolved so that
#. all
#.  filesystems use this error for this case. (Tytso says ex4 will change.)
#.  http://thread.gmane.org/gmane.comp.file-
#. systems.xfs.general/60485/focus=5521
#.  From: Michael Kerrisk (man-pages <mtk.manpages@...>
#.  Subject: Re: [PATCH v5 10/10] manpage: update FALLOC_FL_COLLAPSE_RANGE
#. flag in fallocate
#.  Newsgroups: gmane.linux.man, gmane.linux.file-systems
#.  Date: 2014-04-17 13:40:05 GMT
#. type: Plain text
#: man-pages/man2/fallocate.2:396
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_ZERO_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE>, but the file referred to by I<fd> is not a "
"regular file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:399
msgid "An I/O error occurred while reading from or writing to a filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:406
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:411
msgid ""
"There is not enough space left on the device containing the file referred to"
" by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:415
msgid "This kernel does not implement B<fallocate>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:424
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the filesystem containing"
" the file referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:430
msgid "The file referred to by I<fd> is marked immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:445
msgid ""
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> or B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and the file referred to by I<fd> is marked "
"append-only (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:449
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:449
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:453
msgid "I<fd> refers to a pipe or FIFO."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:463
msgid ""
"I<mode> specifies B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, "
"but the file referred to by I<fd> is currently being executed."
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: man-pages/man2/fallocate.2:471
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:474
msgid "B<fallocate>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:478
msgid ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: man-pages/man5/ftpusers.5:19
#, no-wrap
msgid "FTPUSERS"
msgstr ""

#. type: TH
#: man-pages/man5/ftpusers.5:19
#, no-wrap
msgid "2000-08-27"
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:22
msgid "ftpusers - list of users that may not log in via the FTP daemon"
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:30
msgid ""
"The text file B<ftpusers> contains a list of users that may not log in using"
" the File Transfer Protocol (FTP) server daemon.  This file is used not "
"merely for system administration purposes but also for improving security "
"within a TCP/IP networked environment."
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:37
msgid ""
"The B<ftpusers> file will typically contain a list of the users that either "
"have no business using ftp or have too many privileges to be allowed to log "
"in through the FTP server daemon.  Such users usually include root, daemon, "
"bin, uucp, and news."
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:45
msgid ""
"If your FTP server daemon doesn't use B<ftpusers>, then it is suggested that"
" you read its documentation to find out how to block access for certain "
"users.  Washington University FTP server Daemon (wuftpd) and Professional "
"FTP Daemon (proftpd) are known to make use of B<ftpusers>."
msgstr ""

#. type: SS
#: man-pages/man5/ftpusers.5:45
#, no-wrap
msgid "Format"
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:51
msgid ""
"The format of B<ftpusers> is very simple.  There is one account name (or "
"username) per line.  Lines starting with a # are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:53
msgid "I</etc/ftpusers>"
msgstr ""

#. type: Plain text
#: man-pages/man5/ftpusers.5:56
msgid "B<passwd>(5), B<proftpd>(8), B<wuftpd>(8)"
msgstr ""

#. type: TH
#: man-pages/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:32
msgid ""
"filesystems - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, "
"JFS, minix, msdos, ncpfs nfs, ntfs, proc, Reiserfs, smb, sysv, umsdos, vfat,"
" XFS, xiafs,"
msgstr ""

#.  commit: 6af9f7bf3c399e0ab1eee048e13572c6d4e15fe9
#. type: Plain text
#: man-pages/man5/filesystems.5:53
msgid ""
"When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which filesystems your kernel "
"currently supports; see B<proc>(5)  for more details.  There is also a "
"legacy B<sysfs>(2)  system call (whose availability is controlled by the "
"B<CONFIG_SYSFS_SYSCALL> kernel build configuration option since Linux 3.15)"
"  that enables enumeration of the currently available filesystem types "
"regardless of I</proc> availability and/or sanity."
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:56
msgid ""
"If you need a currently unsupported filesystem, insert the corresponding "
"kernel module or recompile the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:63
msgid ""
"In order to use a filesystem, you have to I<mount> it; see B<mount>(2)  and "
"B<mount>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:69
msgid ""
"iThe following list provides a short description of the available or "
"historically available filesystems in the Linux kernel.  See the kernel "
"documentation for a comprehensive description of all options and "
"limitations."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:69
#, no-wrap
msgid "B<ext>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:78
msgid ""
"is an elaborate extension of the B<minix> filesystem.  It has been "
"completely superseded by the second version of the extended filesystem "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:78
#, no-wrap
msgid "B<ext2>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:87
msgid ""
"is the high performance disk filesystem used by Linux for fixed disks as "
"well as removable media.  The second extended filesystem was designed as an "
"extension of the extended filesystem (B<ext>).  See B<ext2>(5)."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:87
#, no-wrap
msgid "B<ext3>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:99
msgid ""
"is a journaling version of the B<ext2> filesystem.  It is easy to switch "
"back and forth between B<ext2> and B<ext3>.  See B<ext3>(5)."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:99
#, no-wrap
msgid "B<ext4>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:108
msgid ""
"is a set of upgrades to B<ext3> including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits.  See B<ext4>(5)."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:108
#, no-wrap
msgid "B<hpfs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:113
msgid ""
"is the High Performance Filesystem, used in OS/2.  This filesystem is read-"
"only under Linux due to the lack of available documentation."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:113
#, no-wrap
msgid "B<iso9660>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:116
msgid "is a CD-ROM filesystem type conforming to the ISO 9660 standard."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:117
#, no-wrap
msgid "B<High Sierra>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:124
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for CD-"
"ROM filesystems.  It is automatically recognized within the B<iso9660> "
"filesystem support under Linux."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:124
#, no-wrap
msgid "B<Rock Ridge>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:135
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the"
" Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> filesystem to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> filesystem support under "
"Linux."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:136
#, no-wrap
msgid "B<JFS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:140
msgid ""
"is a journaling filesystem, developed by IBM, that was integrated into Linux"
" in kernel 2.4.24."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:140
#, no-wrap
msgid "B<minix>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:147
msgid ""
"is the filesystem used in the Minix operating system, the first to run under"
" Linux.  It has a number of shortcomings, including a 64\\ MB partition size"
" limit, short filenames, and a single timestamp.  It remains useful for "
"floppies and RAM disks."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:147
#, no-wrap
msgid "B<msdos>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:153
msgid ""
"is the filesystem used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period"
" and 3 character extension."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:153
#, no-wrap
msgid "B<ncpfs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:157
msgid ""
"is a network filesystem that supports the NCP protocol, used by Novell "
"NetWare."
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:163
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:163
#, no-wrap
msgid "B<nfs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:166
msgid ""
"is the network filesystem used to access disks located on remote computers."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:166
#, no-wrap
msgid "B<ntfs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:171
msgid ""
"replaces Microsoft Window's FAT filesystems (VFAT, FAT32).  It has "
"reliability, performance, and space-utilization enhancements plus features "
"like ACLs, journaling, encryption, and so on."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:171
#, no-wrap
msgid "B<proc>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:179
msgid ""
"is a pseudo filesystem which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:179
#, no-wrap
msgid "B<Reiserfs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:183
msgid ""
"is a journaling filesystem, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:183
#, no-wrap
msgid "B<smb>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:190
msgid ""
"is a network filesystem that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager.  See E<.UR "
"https://www.samba.org\\:/samba\\:/smbfs/> E<.UE .>"
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:190
#, no-wrap
msgid "B<sysv>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:194
msgid ""
"is an implementation of the SystemV/Coherent filesystem for Linux.  It "
"implements all of Xenix FS, SystemV/386 FS, and Coherent FS."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:194
#, no-wrap
msgid "B<umsdos>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:201
msgid ""
"is an extended DOS filesystem used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.) under the DOS filesystem, without sacrificing compatibility "
"with DOS."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:201
#, no-wrap
msgid "B<tmpfs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:208
msgid ""
"is a filesystem whose contents reside in virtual memory.  Since the files on"
" such filesystems typically reside in RAM, file access is extremely fast.  "
"See B<tmpfs>(5)."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:208
#, no-wrap
msgid "B<vfat>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:213
msgid ""
"is an extended FAT filesystem used by Microsoft Windows95 and Windows NT.  "
"B<vfat> adds the capability to use long filenames under the MSDOS "
"filesystem."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:213
#, no-wrap
msgid "B<XFS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:217
msgid ""
"is a journaling filesystem, developed by SGI, that was integrated into Linux"
" in kernel 2.4.20."
msgstr ""

#. type: TP
#: man-pages/man5/filesystems.5:217
#, no-wrap
msgid "B<xiafs>"
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:227
msgid ""
"was designed and implemented to be a stable, safe filesystem by extending "
"the Minix filesystem code.  It provides the basic most requested features "
"without undue complexity.  The B<xiafs> filesystem is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr ""

#. type: Plain text
#: man-pages/man5/filesystems.5:238
msgid ""
"B<fuse>(4), B<btrfs>(5), B<ext2>(5), B<ext3>(5), B<ext4>(5), B<nfs>(5), "
"B<proc>(5), B<tmpfs>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/finite.3:25
#, no-wrap
msgid "FINITE"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:29
msgid ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - BSD"
" floating-point classification functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:32
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:36
#, no-wrap
msgid ""
"B<int finite(double >I<x>B<);>\n"
"B<int finitef(float >I<x>B<);>\n"
"B<int finitel(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:40
#, no-wrap
msgid ""
"B<int isinf(double >I<x>B<);>\n"
"B<int isinff(float >I<x>B<);>\n"
"B<int isinfl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:44
#, no-wrap
msgid ""
"B<int isnan(double >I<x>B<);>\n"
"B<int isnanf(float >I<x>B<);>\n"
"B<int isnanl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:55
msgid "B<finite>(), B<finitef>(), B<finitel>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:58 man-pages/man3/finite.3:71
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:60
msgid "B<isinf>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:64
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:68
msgid "B<isinff>(), B<isinfl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:73
msgid "B<isnan>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:77
#, no-wrap
msgid ""
"_XOPEN_SOURCE || _ISOC99_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:80
msgid "B<isnanf>(), B<isnanl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:84
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:96
msgid ""
"The B<finite>(), B<finitef>(), and B<finitel>()  functions return a nonzero "
"value if I<x> is neither infinite nor a \"not-a-number\" (NaN) value, and 0 "
"otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:106
msgid ""
"The B<isnan>(), B<isnanf>(), and B<isnanl>()  functions return a nonzero "
"value if I<x> is a NaN value, and 0 otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:117
msgid ""
"The B<isinf>(), B<isinff>(), and B<isinfl>()  functions return 1 if I<x> is "
"positive infinity, -1 if I<x> is negative infinity, and 0 otherwise."
msgstr ""

#. type: SH
#: man-pages/man3/finite.3:117
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:120
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:124
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:124
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:124
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:129
#, no-wrap
msgid ""
"B<finite>(),\n"
"B<finitef>(),\n"
"B<finitel>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:129 man-pages/man3/finite.3:133
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:133
#, no-wrap
msgid ""
"B<isinf>(),\n"
"B<isinff>(),\n"
"B<isinfl>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:137
#, no-wrap
msgid ""
"B<isnan>(),\n"
"B<isnanf>(),\n"
"B<isnanl>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:137
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man3/finite.3:137
#, no-wrap
msgid "MT-Safe"
msgstr ""

#.  finite* not on HP-UX; they exist on Tru64.
#.  .SH HISTORY
#.  The
#.  .BR finite ()
#.  function occurs in 4.3BSD.
#.  see IEEE.3 in the 4.3BSD manual
#. type: Plain text
#: man-pages/man3/finite.3:159
msgid ""
"Note that these functions are obsolete.  C99 defines macros B<isfinite>(), "
"B<isinf>(), and B<isnan>()  (for all types) replacing them.  Further note "
"that the C99 B<isinf>()  has weaker guarantees on the return value.  See "
"B<fpclassify>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/finite.3:160
msgid "B<fpclassify>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fdim.3:9
#, no-wrap
msgid "FDIM"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:12
msgid "fdim, fdimf, fdiml - positive difference"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:14
msgid "B<#include E<lt>math.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:16
msgid "B<double fdim(double >I<x>B<, double >I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:18
msgid "B<float fdimf(float >I<x>B<, float >I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:20
msgid "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:22
msgid "Link with I<-lm>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:31
msgid "B<fdimf>(), B<fdiml>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:33
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:38
msgid ""
"These functions return the positive difference, max(I<x>-I<y>,0), between "
"their arguments."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:40
msgid "On success, these functions return the positive difference."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:46
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:55
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:60
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:62
msgid "The following errors can occur:"
msgstr ""

#. type: TP
#: man-pages/man3/fdim.3:62
#, no-wrap
msgid "Range error: result overflow"
msgstr ""

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/fdim.3:70
msgid "An overflow floating-point exception (B<FE_OVERFLOW>)  is raised."
msgstr ""

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6796
#. type: Plain text
#: man-pages/man3/fdim.3:75
msgid "These functions do not set I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:77
msgid "These functions first appeared in glibc in version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/fdim.3:89
#, no-wrap
msgid ""
"B<fdim>(),\n"
"B<fdimf>(),\n"
"B<fdiml>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:93
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/fdim.3:94
msgid "B<fmax>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "FNMATCH"
msgstr ""

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:31
msgid "fnmatch - match filename or pathname"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:34
#, no-wrap
msgid "B<#include E<lt>fnmatch.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:36
#, no-wrap
msgid ""
"B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:46
msgid ""
"The B<fnmatch>()  function checks whether the I<string> argument matches the"
" I<pattern> argument, which is a shell wildcard pattern (see B<glob>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:51
msgid ""
"The I<flags> argument modifies the behavior; it is the bitwise OR of zero or"
" more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:51
#, no-wrap
msgid "B<FNM_NOESCAPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:55
msgid ""
"If this flag is set, treat backslash as an ordinary character, instead of an"
" escape character."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:55
#, no-wrap
msgid "B<FNM_PATHNAME>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:63
msgid ""
"If this flag is set, match a slash in I<string> only with a slash in "
"I<pattern> and not by an asterisk (*) or a question mark (?) metacharacter, "
"nor by a bracket expression ([]) containing a slash."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:63
#, no-wrap
msgid "B<FNM_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:74
msgid ""
"If this flag is set, a leading period in I<string> has to be matched exactly"
" by a period in I<pattern>.  A period is considered to be leading if it is "
"the first character in I<string>, or if both B<FNM_PATHNAME> is set and the "
"period immediately follows a slash."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:74
#, no-wrap
msgid "B<FNM_FILE_NAME>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:78
msgid "This is a GNU synonym for B<FNM_PATHNAME>."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:78
#, no-wrap
msgid "B<FNM_LEADING_DIR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:86
msgid ""
"If this flag (a GNU extension) is set, the pattern is considered to be "
"matched if it matches an initial segment of I<string> which is followed by a"
" slash.  This flag is mainly for the internal use of glibc and is "
"implemented only in certain cases."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:86
#, no-wrap
msgid "B<FNM_CASEFOLD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:90
msgid ""
"If this flag (a GNU extension) is set, the pattern is matched case-"
"insensitively."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:90
#, no-wrap
msgid "B<FNM_EXTMATCH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:96
msgid ""
"If this flag (a GNU extension) is set, extended patterns are supported, as "
"introduced by \\&'ksh' and now supported by other shells.  The extended "
"format is as follows, with I<pattern-list> being a \\&'|' separated list of "
"patterns."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:96
#, no-wrap
msgid "\\&'?(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:100
msgid ""
"The pattern matches if zero or one occurrences of any of the patterns in the"
" I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:100
#, no-wrap
msgid "\\&'*(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:104
msgid ""
"The pattern matches if zero or more occurrences of any of the patterns in "
"the I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:104
#, no-wrap
msgid "\\&'+(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:108
msgid ""
"The pattern matches if one or more occurrences of any of the patterns in the"
" I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:108
#, no-wrap
msgid "\\&'@(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:112
msgid ""
"The pattern matches if exactly one occurrence of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""

#. type: TP
#: man-pages/man3/fnmatch.3:112
#, no-wrap
msgid "\\&'!(I<pattern-list>)'"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:116
msgid ""
"The pattern matches if the input I<string> cannot be matched with any of the"
" patterns in the I<pattern-list>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:123
msgid ""
"Zero if I<string> matches I<pattern>, B<FNM_NOMATCH> if there is no match or"
" another nonzero value if there is an error."
msgstr ""

#. type: tbl table
#: man-pages/man3/fnmatch.3:133
#, no-wrap
msgid "B<fnmatch>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fnmatch.3:133
#, no-wrap
msgid "MT-Safe env locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:140
msgid ""
"POSIX.1-2001, POSIX.1-2008, POSIX.2.  The B<FNM_FILE_NAME>, "
"B<FNM_LEADING_DIR>, and B<FNM_CASEFOLD> flags are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/fnmatch.3:145
msgid "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/fmtmsg.3:13
#, no-wrap
msgid "FMTMSG"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:16
msgid "fmtmsg - print formatted error messages"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:19
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:23
#, no-wrap
msgid ""
"B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
"B<           int >I<severity>B<, const char *>I<text>B<,>\n"
"B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:34
msgid ""
"This function displays a message described by its arguments on the device(s)"
"  specified in the I<classification> argument.  For messages written to "
"I<stderr>, the format depends on the B<MSGVERB> environment variable."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:41
msgid ""
"The I<label> argument identifies the source of the message.  The string must"
" consist of two colon separated parts where the first part has not more than"
" 10 and the second part not more than 14 characters."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:45
msgid "The I<text> argument describes the condition of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:50
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:58
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique"
" identification number."
msgstr ""

#. type: SS
#: man-pages/man3/fmtmsg.3:58
#, no-wrap
msgid "Dummy arguments"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:77
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed."
"  The dummy severity value B<NO_SEV> (0) says that no severity is supplied."
"  The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char\\ *)\\ 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""

#. type: SS
#: man-pages/man3/fmtmsg.3:77
#, no-wrap
msgid "The classification argument"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:81
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:83
msgid "The first value defines the output channel."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:83
#, no-wrap
msgid "B<MM_PRINT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:87
msgid "Output to I<stderr>."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:87
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:90
msgid "Output to the system console."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:90
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:93
msgid "Output to both."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:95
msgid "The second value is the source of the error:"
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:95
#, no-wrap
msgid "B<MM_HARD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:98
msgid "A hardware error occurred."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:98
#, no-wrap
msgid "B<MM_FIRM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:101
msgid "A firmware error occurred."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:101
#, no-wrap
msgid "B<MM_SOFT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:104
msgid "A software error occurred."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:106
msgid "The third value encodes the detector of the problem:"
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:106
#, no-wrap
msgid "B<MM_APPL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:109
msgid "It is detected by an application."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:109
#, no-wrap
msgid "B<MM_UTIL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:112
msgid "It is detected by a utility."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:112
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:115
msgid "It is detected by the operating system."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:117
msgid "The fourth value shows the severity of the incident:"
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:117
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:120
msgid "It is a recoverable error."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:120
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:123
msgid "It is a nonrecoverable error."
msgstr ""

#. type: SS
#: man-pages/man3/fmtmsg.3:123
#, no-wrap
msgid "The severity argument"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:127
msgid "The I<severity> argument can take one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:127
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:130
msgid "No severity is printed."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:130
#, no-wrap
msgid "B<MM_HALT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:133
msgid "This value is printed as HALT."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:133
#, no-wrap
msgid "B<MM_ERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:136
msgid "This value is printed as ERROR."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:136
#, no-wrap
msgid "B<MM_WARNING>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:139
msgid "This value is printed as WARNING."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:139
#, no-wrap
msgid "B<MM_INFO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:142
msgid "This value is printed as INFO."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:149
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:151
msgid "The function can return 4 values:"
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:151
#, no-wrap
msgid "B<MM_OK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:154
msgid "Everything went smooth."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:154
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:157
msgid "Complete failure."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:157
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:161
msgid "Error writing to I<stderr>."
msgstr ""

#. type: TP
#: man-pages/man3/fmtmsg.3:161
#, no-wrap
msgid "B<MM_NOCON>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:164
msgid "Error writing to the console."
msgstr ""

#. type: SH
#: man-pages/man3/fmtmsg.3:164
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:175
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to"
" the console.)  When this variable is defined, is non-NULL, and is a colon-"
"separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:187
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:190
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:195
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:198
msgid "severity-keyword,level,printstring"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:205
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0\\(en4), and use the indicated printstring "
"when such a level occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:219
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the"
" string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:222
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/fmtmsg.3:232
#, no-wrap
msgid "B<fmtmsg>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fmtmsg.3:234
#, no-wrap
msgid "glibc E<gt>= 2.16: MT-Safe\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/fmtmsg.3:236
#, no-wrap
msgid "glibc E<lt> 2.16: MT-Unsafe"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:243
msgid ""
"Before glibc 2.16, the B<fmtmsg>()  function uses a static variable that is "
"not protected, so it is not thread-safe."
msgstr ""

#.  Modified in commit 7724defcf8873116fe4efab256596861eef21a94
#. type: Plain text
#: man-pages/man3/fmtmsg.3:249
msgid ""
"Since glibc 2.16, the B<fmtmsg>()  function uses a lock to protect the "
"static variable, so it is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:259
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:265
msgid ""
"The function B<fmtmsg>()  and the environment variable B<MSGVERB> are "
"described in POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:269
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:274
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:280
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:301
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:304
msgid "The output should be:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:309
#, no-wrap
msgid ""
"util-linux:mount: ERROR: unknown mount option\n"
"TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:313
msgid "and after"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:317
#, no-wrap
msgid "MSGVERB=text:action; export MSGVERB\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:321
msgid "the output becomes:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:326
#, no-wrap
msgid ""
"unknown mount option\n"
"TO FIX: See mount(8).\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmtmsg.3:331
msgid "B<addseverity>(3), B<perror>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fmemopen.3:7
#, no-wrap
msgid "FMEMOPEN"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:10
msgid "fmemopen - open memory as stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:13
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:15
#, no-wrap
msgid ""
"B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char "
"*>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:23
msgid "B<fmemopen>():"
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:26
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:29
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:29
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:32
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:43
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified"
" by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:48
msgid ""
"The I<mode> argument specifies the semantics of I/O on the stream, and is "
"one of the following:"
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:48
#, no-wrap
msgid "I<r>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:51
msgid "The stream is opened for reading."
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:51
#, no-wrap
msgid "I<w>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:54
msgid "The stream is opened for writing."
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:54
#, no-wrap
msgid "I<a>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:58
msgid ""
"Append; open the stream for writing, with the initial buffer position set to"
" the first null byte."
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:58
#, no-wrap
msgid "I<r+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:61
msgid "Open the stream for reading and writing."
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:61
#, no-wrap
msgid "I<w+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:66
msgid ""
"Open the stream for reading and writing.  The buffer contents are truncated "
"(i.e., \\(aq\\e0\\(aq is placed in the first byte of the buffer)."
msgstr ""

#. type: TP
#: man-pages/man3/fmemopen.3:66
#, no-wrap
msgid "I<a+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:70
msgid ""
"Append; open the stream for reading and writing, with the initial buffer "
"position set to the first null byte."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:83
msgid ""
"The stream maintains the notion of a current position, the location where "
"the next I/O operation will be performed.  The current position is "
"implicitly updated by I/O operations.  It can be explicitly updated using "
"B<fseek>(3), and determined using B<ftell>(3).  In all modes other than "
"append, the initial position is set to the start of the buffer.  In append "
"mode, if no null byte is found within the buffer, then the initial position "
"is I<size+1>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:98
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  allocates a buffer of "
"I<size> bytes.  This is useful for an application that wants to write data "
"to a temporary buffer and then read it back again.  The initial position is "
"set to the start of the buffer.  The buffer is automatically freed when the "
"stream is closed.  Note that the caller has no way to obtain a pointer to "
"the temporary buffer allocated by this call (but see B<open_memstream>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:104
msgid ""
"If I<buf> is not NULL, then it should point to a buffer of at least I<len> "
"bytes allocated by the caller."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:116
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or"
" closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in"
" the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:124
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do"
" not cause read operations to return an end-of-file indication.  A read from"
" the buffer will indicate end-of-file only when the current buffer position "
"advances I<size> bytes past the start of the buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:128
msgid ""
"Write operations take place either at the current position (for modes other "
"than append), or at the current size of the stream (for append modes)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:138
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error."
"  By default, such errors will be visible (by the absence of data) only when"
" the I<stdio> buffer is flushed.  Disabling buffering with the following "
"call may be useful to detect errors at the time of an output operation:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:140
#, no-wrap
msgid "    setbuf(stream, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:149
msgid ""
"Upon successful completion, B<fmemopen>()  returns a I<FILE> pointer.  "
"Otherwise, NULL is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:152
msgid "B<fmemopen>()  was already available in glibc 1.0.x."
msgstr ""

#. type: tbl table
#: man-pages/man3/fmemopen.3:162
#, no-wrap
msgid "B<fmemopen>(),"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:169
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=396
#. type: Plain text
#: man-pages/man3/fmemopen.3:177
msgid ""
"POSIX.1-2008 specifies that \\(aqb\\(aq in I<mode> shall be ignored.  "
"However, Technical Corrigendum 1 adjusts the standard to allow "
"implementation-specific treatment for this case, thus permitting the glibc "
"treatment of \\(aqb\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:183
msgid ""
"There is no file descriptor associated with the file stream returned by this"
" function (i.e., B<fileno>(3)  will return an error if called on the "
"returned stream)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:189
msgid ""
"With version 2.22, binary mode (see below) was removed, many longstanding "
"bugs in the implementation of B<fmemopen>()  were fixed, and a new versioned"
" symbol was created for this interface."
msgstr ""

#. type: SS
#: man-pages/man3/fmemopen.3:189
#, no-wrap
msgid "Binary mode"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:202
msgid ""
"From version 2.9 to 2.21, the glibc implementation of B<fmemopen>()  "
"supported a \"binary\" mode, enabled by specifying the letter \\(aqb\\(aq as"
" the second character in I<mode>.  In this mode, writes don't implicitly add"
" a terminating null byte, and B<fseek>(3)  B<SEEK_END> is relative to the "
"end of the buffer (i.e., the value specified by the I<size> argument), "
"rather than the current string length."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12836
#. type: Plain text
#: man-pages/man3/fmemopen.3:214
msgid ""
"An API bug afflicted the implementation of binary mode: to specify binary "
"mode, the \\(aqb\\(aq must be the I<second> character in I<mode>.  Thus, for"
" example, \"wb+\" has the desired effect, but \"w+b\" does not.  This is "
"inconsistent with the treatment of I<mode> by B<fopen>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:218
msgid ""
"Binary mode was removed in glibc 2.22; a \\(aqb\\(aq specified in I<mode> "
"has no effect."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=11216
#. type: Plain text
#: man-pages/man3/fmemopen.3:229
msgid ""
"In versions of glibc before 2.22, if I<size> is specified as zero, "
"B<fmemopen>()  fails with the error B<EINVAL>.  It would be more consistent "
"if this case successfully created a stream that then returned end-of-file on"
" the first attempt at reading; since version 2.22, the glibc implementation "
"provides that behavior."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13152
#. type: Plain text
#: man-pages/man3/fmemopen.3:239
msgid ""
"In versions of glibc before 2.22, specifying append mode (\"a\" or \"a+\") "
"for B<fmemopen>()  sets the initial buffer position to the first null byte, "
"but (if the current position is reset to a location other than the end of "
"the stream)  does not force subsequent writes to append at the end of the "
"stream.  This bug is fixed in glibc 2.22."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13151
#. type: Plain text
#: man-pages/man3/fmemopen.3:256
msgid ""
"In versions of glibc before 2.22, if the I<mode> argument to B<fmemopen>()  "
"specifies append (\"a\" or \"a+\"), and the I<size> argument does not cover "
"a null byte in I<buf>, then, according to POSIX.1-2008, the initial buffer "
"position should be set to the next byte after the end of the buffer.  "
"However, in this case the glibc B<fmemopen>()  sets the buffer position to "
"-1.  This bug is fixed in glibc 2.22."
msgstr ""

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14292
#. type: Plain text
#: man-pages/man3/fmemopen.3:273
msgid ""
"In versions of glibc before 2.22, when a call to B<fseek>(3)  with a "
"I<whence> value of B<SEEK_END> was performed on a stream created by "
"B<fmemopen>(), the I<offset> was I<subtracted> from the end-of-stream "
"position, instead of being added.  This bug is fixed in glibc 2.22."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6544
#. type: Plain text
#: man-pages/man3/fmemopen.3:281
msgid ""
"The glibc 2.9 addition of \"binary\" mode for B<fmemopen>()  silently "
"changed the ABI: previously, B<fmemopen>()  ignored \\(aqb\\(aq in I<mode>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:291
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>(3)  to open a dynamically sized output buffer.  The "
"program scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:296
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:305
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:308
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:321
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s \\(aqE<lt>numE<gt>...\\(aq\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:325
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:329
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:334
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:339
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:342
#, no-wrap
msgid ""
"    fclose(in);\n"
"    fclose(out);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:344
#, no-wrap
msgid "    printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:348
#, no-wrap
msgid ""
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmemopen.3:352
msgid "B<fopen>(3), B<fopencookie>(3), B<open_memstream>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fseek.3:42
#, no-wrap
msgid "FSEEK"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:45
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:47
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:49
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:51
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:53
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:55
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:57
msgid "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:81
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or end-"
"of-file, respectively.  A successful call to the B<fseek>()  function clears"
" the end-of-file indicator for the stream and undoes any effects of the "
"B<ungetc>(3)  function on the same stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:87
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:94
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:97
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:101
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:121
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with I<whence> set to "
"B<SEEK_SET>), setting and storing the current value of the file offset into "
"or from the object referenced by I<pos>.  On some non-UNIX systems, an "
"I<fpos_t> object may be a complex object and these routines may be the only "
"way to portably reposition a text stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:136
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:149
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>.  Or: the resulting file offset would be negative."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:154
msgid ""
"The file descriptor underlying I<stream> is not seekable (e.g., it refers to"
" a pipe, FIFO, or socket)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:169
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/fseek.3:181
#, no-wrap
msgid ""
"B<fseek>(),\n"
"B<ftell>(),\n"
"B<rewind>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/fseek.3:184
#, no-wrap
msgid ""
"B<fgetpos>(),\n"
"B<fsetpos>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:189
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseek.3:191
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/frexp.3:33
#, no-wrap
msgid "FREXP"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:37
msgid ""
"frexp, frexpf, frexpl - convert floating-point number to fractional and "
"integral components"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:44
#, no-wrap
msgid ""
"B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"
"B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"
"B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:56
msgid "B<frexpf>(), B<frexpl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:60
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:68
msgid ""
"These functions are used to split the number I<x> into a normalized fraction"
" and an exponent which is stored in I<exp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:78
msgid ""
"These functions return the normalized fraction.  If the argument I<x> is not"
" zero, the normalized fraction is I<x> times a power of two, and its "
"absolute value is always in the range 1/2 (inclusive) to 1 (exclusive), that"
" is, [0.5,1)."
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:84
msgid ""
"If I<x> is zero, then the normalized fraction is zero and zero is stored in "
"I<exp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:91
msgid ""
"If I<x> is a NaN, a NaN is returned, and the value of I<*exp> is "
"unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:98
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned, and the value of I<*exp> is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:100
msgid "No errors occur."
msgstr ""

#. type: tbl table
#: man-pages/man3/frexp.3:112
#, no-wrap
msgid ""
"B<frexp>(),\n"
"B<frexpf>(),\n"
"B<frexpl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:121
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:123
msgid "The program below produces results such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:130
#, no-wrap
msgid ""
"$B< ./a.out 2560>\n"
"frexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n"
"$B< ./a.out -4>\n"
"frexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:139
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>float.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:145
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x, r;\n"
"    int exp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:148
#, no-wrap
msgid ""
"    x = strtod(argv[1], NULL);\n"
"    r = frexp(x, &exp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:153
#, no-wrap
msgid ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n"
"           x, r, r, FLT_RADIX, exp, x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/frexp.3:156
msgid "B<ldexp>(3), B<modf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fclose.3:44
#, no-wrap
msgid "FCLOSE"
msgstr ""

#. type: TH
#: man-pages/man3/fclose.3:44
#, no-wrap
msgid "2016-12-12"
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:47
msgid "fclose - close a stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:51
msgid "B<int fclose(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:59
msgid ""
"The B<fclose>()  function flushes the stream pointed to by I<stream> "
"(writing any buffered output data using B<fflush>(3))  and closes the "
"underlying file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:70
msgid ""
"Upon successful completion, 0 is returned.  Otherwise, B<EOF> is returned "
"and I<errno> is set to indicate the error.  In either case, any further "
"access (including another call to B<fclose>())  to the stream results in "
"undefined behavior."
msgstr ""

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(stream)).
#. type: Plain text
#: man-pages/man3/fclose.3:80
msgid "The file descriptor underlying I<stream> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:90
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2), or B<fflush>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/fclose.3:100
#, no-wrap
msgid "B<fclose>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:114
msgid ""
"Note that B<fclose>()  flushes only the user-space buffers provided by the C"
" library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fclose.3:120
msgid ""
"B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fileno>(3), B<fopen>(3), "
"B<setbuf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fwide.3:16
#, no-wrap
msgid "FWIDE"
msgstr ""

#. type: TH
#: man-pages/man3/fwide.3:16
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:19
msgid "fwide - set and determine the orientation of a FILE stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:22
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:24
#, no-wrap
msgid "B<int fwide(FILE *>I<stream>B<, int >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:33
msgid "B<fwide>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:35
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:37
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:54
msgid ""
"When I<mode> is zero, the B<fwide>()  function determines the current "
"orientation of I<stream>.  It returns a positive value if I<stream> is wide-"
"character oriented, that is, if wide-character I/O is permitted but char I/O"
" is disallowed.  It returns a negative value if I<stream> is byte "
"oriented\\(emthat is, if char I/O is permitted but wide-character I/O is "
"disallowed.  It returns zero if I<stream> has no orientation yet; in this "
"case the next I/O operation might change the orientation (to byte oriented "
"if it is a char I/O operation, or to wide-character oriented if it is a "
"wide-character I/O operation)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:57
msgid ""
"Once a stream has an orientation, it cannot be changed and persists until "
"the stream is closed."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:66
msgid ""
"When I<mode> is nonzero, the B<fwide>()  function first attempts to set "
"I<stream>'s orientation (to wide-character oriented if I<mode> is greater "
"than 0, or to byte oriented if I<mode> is less than 0).  It then returns a "
"value denoting the current orientation, as above."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:74
msgid ""
"The B<fwide>()  function returns the stream's orientation, after possibly "
"changing it.  A positive return value means wide-character oriented.  A "
"negative return value means byte oriented.  A return value of zero means "
"undecided."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:76
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:84
msgid ""
"Wide-character output to a byte oriented stream can be performed through the"
" B<fprintf>(3)  function with the B<%lc> and B<%ls> directives."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:93
msgid ""
"Char oriented output to a wide-character oriented stream can be performed "
"through the B<fwprintf>(3)  function with the B<%c> and B<%s> directives."
msgstr ""

#. type: Plain text
#: man-pages/man3/fwide.3:95
msgid "B<fprintf>(3), B<fwprintf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fexecve.3:25
#, no-wrap
msgid "FEXECVE"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:28
msgid "fexecve - execute program specified via file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:31
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:33
#, no-wrap
msgid ""
"B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const "
">I<envp>B<[]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:41
msgid "B<fexecve>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:69
msgid ""
"B<fexecve>()  performs the same task as B<execve>(2), with the difference "
"that the file to be executed is specified via a file descriptor, I<fd>, "
"rather than via a pathname.  The file descriptor I<fd> must be opened read-"
"only (B<O_RDONLY>)  or with the B<O_PATH> flag and the caller must have "
"permission to execute the file that it refers to."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:76
msgid ""
"A successful call to B<fexecve>()  never returns.  On error, the function "
"does return, with a result value of -1, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:80
msgid "Errors are as for B<execve>(2), with the following additions:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:88
msgid ""
"I<fd> is not a valid file descriptor, or I<argv> is NULL, or I<envp> is "
"NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:93
msgid "The I</proc> filesystem could not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:96
msgid "B<fexecve>()  is implemented since glibc 2.3.2."
msgstr ""

#. type: tbl table
#: man-pages/man3/fexecve.3:106
#, no-wrap
msgid "B<fexecve>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:114
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems.  It is specified in POSIX.1-2008."
msgstr ""

#.  glibc commit 43ffc53a352a67672210c9dd4959f6c6b7407e60
#. type: Plain text
#: man-pages/man3/fexecve.3:131
msgid ""
"On Linux with glibc versions 2.26 and earlier, B<fexecve>()  is implemented "
"using the B<proc>(5)  filesystem, so I</proc> needs to be mounted and "
"available at the time of the call.  Since glibc 2.27, if the underlying "
"kernel supports the B<execveat>(2)  system call, then B<fexecve>()  is "
"implemented using that system call, with the benefit that I</proc> does not "
"need to be mounted."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:148
msgid ""
"The idea behind B<fexecve>()  is to allow the caller to verify (checksum) "
"the contents of an executable before executing it.  Simply opening the file,"
" checksumming the contents, and then doing an B<execve>(2)  would not "
"suffice, since, between the two steps, the filename, or a directory prefix "
"of the pathname, could have been exchanged (by, for example, modifying the "
"target of a symbolic link).  B<fexecve>()  does not mitigate the problem "
"that the I<contents> of a file could be changed between the checksumming and"
" the call to B<fexecve>(); for that, the solution is to ensure that the "
"permissions on the file prevent it from being modified by malicious users."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:166
msgid ""
"The natural idiom when using B<fexecve>()  is to set the close-on-exec flag "
"on I<fd>, so that the file descriptor does not leak through to the program "
"that is executed.  This approach is natural for two reasons.  First, it "
"prevents file descriptors being consumed unnecessarily.  (The executed "
"program normally has no need of a file descriptor that refers to the program"
" itself.)  Second, if B<fexecve>()  is used recursively, employing the "
"close-on-exec flag prevents the file descriptor exhaustion that would result"
" from the fact that each step in the recursion would cause one more file "
"descriptor to be passed to the new program.  (But see BUGS.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:185
msgid ""
"If I<fd> refers to a script (i.e., it is an executable text file that names "
"a script interpreter with a first line that begins with the characters "
"I<#!>)  and the close-on-exec flag has been set for I<fd>, then B<fexecve>()"
"  fails with the error B<ENOENT>.  This error occurs because, by the time "
"the script interpreter is executed, I<fd> has already been closed because of"
" the close-on-exec flag.  Thus, the close-on-exec flag can't be set on I<fd>"
" if it refers to a script, leading to the problems described in NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man3/fexecve.3:187
msgid "B<execve>(2), B<execveat>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/fgetws.3:18
#, no-wrap
msgid "FGETWS"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:21
msgid "fgetws - read a wide-character string from a FILE stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:26
#, no-wrap
msgid ""
"B<wchar_t *fgetws(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:40
msgid ""
"The B<fgetws>()  function is the wide-character equivalent of the "
"B<fgets>(3)  function.  It reads a string of at most I<n-1> wide characters "
"into the wide-character array pointed to by I<ws>, and adds a terminating "
"null wide character (L\\(aq\\e0\\(aq).  It stops reading wide characters "
"after it has encountered and stored a newline wide character.  It also stops"
" when end of stream is reached."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:43
msgid ""
"The programmer must ensure that there is room for at least I<n> wide "
"characters at I<ws>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:46
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:52
msgid ""
"The B<fgetws>()  function, if successful, returns I<ws>.  If end of stream "
"was already reached or if an error occurred, it returns NULL."
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetws.3:62
#, no-wrap
msgid "B<fgetws>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:73
msgid ""
"The behavior of B<fgetws>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:81
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fgetws>()  will actually read a multibyte "
"string from the stream and then convert it to a wide-character string."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:85
msgid ""
"This function is unreliable, because it does not permit to deal properly "
"with null wide characters that may be present in the input."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetws.3:87
msgid "B<fgetwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/flockfile.3:25
#, no-wrap
msgid "FLOCKFILE"
msgstr ""

#. type: TH
#: man-pages/man3/flockfile.3:25
#, no-wrap
msgid "2017-07-13"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:28
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:35
#, no-wrap
msgid ""
"B<void flockfile(FILE *>I<filehandle>B<);>\n"
"B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
"B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:44
msgid "All functions shown above:"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:48
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:62
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:68
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:76
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the"
" I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:93
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming"
" in between.  If the reason for doing this was to achieve greater "
"efficiency, one does the I/O with the nonlocking versions of the stdio "
"functions: with B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of "
"B<getc>(3)  and B<putc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:104
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked"
" by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:108
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:119
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>()."
"  It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:124
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:126
msgid "None."
msgstr ""

#. type: tbl table
#: man-pages/man3/flockfile.3:138
#, no-wrap
msgid ""
"B<flockfile>(),\n"
"B<ftrylockfile>(),\n"
"B<funlockfile>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:142
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:146
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/flockfile.3:147
msgid "B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fmin.3:9
#, no-wrap
msgid "FMIN"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:12
msgid "fmin, fminf, fminl - determine minimum of two floating-point numbers"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:16
msgid "B<double fmin(double >I<x>B<, double >I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:18
msgid "B<float fminf(float >I<x>B<, float >I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:20
msgid "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:32
msgid "B<fmin>(), B<fminf>(), B<fminl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:41
msgid "These functions return the lesser value of I<x> and I<y>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:46
msgid "These functions return the minimum of I<x> and I<y>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:48
msgid "If one argument is a NaN, the other argument is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:50
msgid "If both arguments are NaN, a NaN is returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/fmin.3:66
#, no-wrap
msgid ""
"B<fmin>(),\n"
"B<fminf>(),\n"
"B<fminl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmin.3:72
msgid "B<fdim>(3), B<fmax>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fopencookie.3:26
#, no-wrap
msgid "FOPENCOOKIE"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:29
msgid "fopencookie - opening a custom stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:36
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:49
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the"
" stream's data at a location of its own choosing; for example, "
"B<fopencookie>()  is used to implement B<fmemopen>(3), which provides a "
"stream interface to data that is stored in a buffer in memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:51
msgid "In order to create a custom stream the programmer must:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:54
msgid ""
"Implement four \"hook\" functions that are used internally by the standard "
"I/O library when performing I/O on the stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:65
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to "
"B<fopencookie>()), but automatically supplies the cookie as the first "
"argument when calling the hook functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:70
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:78
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to"
" operate on that stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:85
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is"
" to be associated with the new stream.  This pointer is supplied as the "
"first argument when the standard I/O library invokes any of the hook "
"functions described below."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:101
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:107
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:116
#, no-wrap
msgid ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:120
msgid "The four fields are as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:120
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:124
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:126
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:141
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:146
msgid ""
"If I<*read> is a null pointer, then reads from the custom stream always "
"return end of file."
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:146
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:150
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:152
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:168
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or 0 on error.  (The function must not return a negative value.)  The "
"I<write> function should update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:173
msgid ""
"If I<*write> is a null pointer, then output to the stream is discarded."
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:173
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:177
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:179
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:185
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:186
#, no-wrap
msgid "B<SEEK_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:191
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:191
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:195
msgid "I<*offset> should be added to the current stream offset."
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:195
#, no-wrap
msgid "B<SEEK_END>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:199
msgid ""
"The stream offset should be set to the size of the stream plus I<*offset>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:206
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:210
msgid ""
"As its function result, the I<seek> function should return 0 on success, and"
" -1 on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:215
msgid ""
"If I<*seek> is a null pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""

#. type: TP
#: man-pages/man3/fopencookie.3:215
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:221
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:223
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:228
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:234
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:238
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is"
" closed."
msgstr ""

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: man-pages/man3/fopencookie.3:245
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error,"
" NULL is returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/fopencookie.3:255
#, no-wrap
msgid "B<fopencookie>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:259
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:268
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:276
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:283
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a"
" cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:292
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:294
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:301
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:307
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:309
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:319
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:321
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:325
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:328
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:334
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:336
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:342
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:344
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:348
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:354
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:363
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:366
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:371
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:376
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:380
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:383
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:399
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *stream;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:401
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:407
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:411
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:417
#, no-wrap
msgid ""
"    stream = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (stream == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:419
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:425
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], stream) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:427
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:442
#, no-wrap
msgid ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(stream, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, stream);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:445
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopencookie.3:453
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fgetpwent.3:33
#, no-wrap
msgid "FGETPWENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:36
msgid "fgetpwent - get password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:41
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:43
#, no-wrap
msgid "B<struct passwd *fgetpwent(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:55
#, no-wrap
msgid ""
"B<fgetpwent>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:68
msgid ""
"The B<fgetpwent>()  function returns a pointer to a structure containing the"
" broken out fields of a line in the file I<stream>.  The first time it is "
"called it returns the first entry; thereafter, it returns successive "
"entries.  The file referred to by I<stream> must have the same format as "
"I</etc/passwd> (see B<passwd>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:70
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:82
#, no-wrap
msgid ""
"struct passwd {\n"
"    char   *pw_name;       /* username */\n"
"    char   *pw_passwd;     /* user password */\n"
"    uid_t   pw_uid;        /* user ID */\n"
"    gid_t   pw_gid;        /* group ID */\n"
"    char   *pw_gecos;      /* real name */\n"
"    char   *pw_dir;        /* home directory */\n"
"    char   *pw_shell;      /* shell program */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:94
msgid ""
"The B<fgetpwent>()  function returns a pointer to a I<passwd> structure, or "
"NULL if there are no more entries or an error occurs.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:100
msgid "Insufficient memory to allocate I<passwd> structure."
msgstr ""

#. type: TP
#: man-pages/man3/fgetpwent.3:101
#, no-wrap
msgid "I</etc/passwd>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:104
msgid "password database file"
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetpwent.3:114
#, no-wrap
msgid "B<fgetpwent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetpwent.3:114
#, no-wrap
msgid "MT-Unsafe race:fgetpwent"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:127
msgid "SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetpwent.3:137
msgid ""
"B<endpwent>(3), B<fgetpwent_r>(3), B<fopen>(3), B<getpw>(3), B<getpwent>(3),"
" B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), "
"B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/fcloseall.3:25
#, no-wrap
msgid "FCLOSEALL"
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:28
msgid "fcloseall - close all open streams"
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:34
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:43
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as"
" for B<fflush>(3)); buffered input is discarded."
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:50
msgid ""
"The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:55
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/fcloseall.3:65
#, no-wrap
msgid "B<fcloseall>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fcloseall.3:65
#, no-wrap
msgid "MT-Unsafe race:streams"
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:71
msgid ""
"The B<fcloseall>()  function does not lock the streams, so it is not thread-"
"safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:73
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/fcloseall.3:78
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fread.3:45
#, no-wrap
msgid "FREAD"
msgstr ""

#. type: TH
#: man-pages/man3/fread.3:45
#, no-wrap
msgid "2015-07-23"
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:48
msgid "fread, fwrite - binary stream input/output"
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:54
#, no-wrap
msgid ""
"B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:57
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:69
msgid ""
"The function B<fread>()  reads I<nmemb> items of data, each I<size> bytes "
"long, from the stream pointed to by I<stream>, storing them at the location "
"given by I<ptr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:80
msgid ""
"The function B<fwrite>()  writes I<nmemb> items of data, each I<size> bytes "
"long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:83
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:94
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of items read or "
"written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:101
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""

#. type: tbl table
#: man-pages/man3/fread.3:112
#, no-wrap
msgid ""
"B<fread>(),\n"
"B<fwrite>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:116
msgid "POSIX.1-2001, POSIX.1-2008, C89."
msgstr ""

#. type: Plain text
#: man-pages/man3/fread.3:121
msgid ""
"B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fabs.3:32
#, no-wrap
msgid "FABS"
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:35
msgid "fabs, fabsf, fabsl - absolute value of floating-point number"
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:42
#, no-wrap
msgid ""
"B<double fabs(double >I<x>B<);>\n"
"B<float fabsf(float >I<x>B<);>\n"
"B<long double fabsl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:54
msgid "B<fabsf>(), B<fabsl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:64
msgid ""
"These functions return the absolute value of the floating-point number I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:67
msgid "These functions return the absolute value of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:71
msgid "If I<x> is a NaN, a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:75
msgid "If I<x> is -0, +0 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:79
msgid ""
"If I<x> is negative infinity or positive infinity, positive infinity is "
"returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/fabs.3:93
#, no-wrap
msgid ""
"B<fabs>(),\n"
"B<fabsf>(),\n"
"B<fabsl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fabs.3:108
msgid "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ferror.3:44
#, no-wrap
msgid "FERROR"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:47
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:51
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:53
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:55
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:57
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:65
msgid "B<fileno>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:70
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:78
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can be cleared only by the function B<clearerr>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:87
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can be"
" reset only by the B<clearerr>()  function."
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:101
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns the "
"integer file descriptor used to implement this stream.  The file descriptor "
"is still owned by I<stream> and will be closed when B<fclose>(3)  is called."
"  Duplicate the file descriptor with B<dup>(2)  before passing it to code "
"that might close it."
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:114
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a"
" valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""

#. type: tbl table
#: man-pages/man3/ferror.3:125
#, no-wrap
msgid ""
"B<clearerr>(),\n"
"B<feof>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/ferror.3:128
#, no-wrap
msgid ""
"B<ferror>(),\n"
"B<fileno>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:137
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89, "
"C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:141
msgid "The function B<fileno>()  conforms to POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/ferror.3:145
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fgetc.3:27
#, no-wrap
msgid "FGETC"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:30
msgid "fgetc, fgets, getc, getchar, ungetc - input of characters and strings"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:35
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:37
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:39
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:41
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as"
" a macro which evaluates I<stream> more than once."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:80
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream>"
" and stores them into the buffer pointed to by I<s>.  Reading stops after an"
" B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  "
"A terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character"
" in the buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:91
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will"
" be returned in reverse order; only one pushback is guaranteed."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:96
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:111
msgid ""
"B<fgetc>(), B<getc>()  and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:117
msgid ""
"B<fgets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:124
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetc.3:136
#, no-wrap
msgid ""
"B<fgetc>(),\n"
"B<fgets>(),\n"
"B<getc>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetc.3:139
#, no-wrap
msgid ""
"B<getchar>(),\n"
"B<ungetc>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:151
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetc.3:167
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/fflush.3:45
#, no-wrap
msgid "FFLUSH"
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:48
msgid "fflush - flush a stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:52
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:58
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:64
msgid ""
"For input streams associated with seekable files (e.g., disk files, but not "
"pipes or terminals), B<fflush>()  discards any buffered data that has been "
"fetched from the underlying file, but has not been consumed by the "
"application."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:66
msgid "The open status of the stream is unaffected."
msgstr ""

#.  mtk: POSIX specifies that only output streams are flushed for this case.
#.  Also verified for glibc by experiment.
#. type: Plain text
#: man-pages/man3/fflush.3:76
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:86
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and"
" I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:91
msgid "I<stream> is not an open stream, or is not open for writing."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:98
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""

#. type: tbl table
#: man-pages/man3/fflush.3:108
#, no-wrap
msgid "B<fflush>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:112
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:115
msgid ""
"POSIX.1-2001 did not specify the behavior for flushing of input streams, but"
" the behavior is specified in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:124
msgid ""
"Note that B<fflush>()  flushes only the user-space buffers provided by the C"
" library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fflush.3:132
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fileno>(3), "
"B<fopen>(3), B<setbuf>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fputws.3:16
#, no-wrap
msgid "FPUTWS"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:19
msgid "fputws - write a wide-character string to a FILE stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:24
#, no-wrap
msgid "B<int fputws(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:34
msgid ""
"The B<fputws>()  function is the wide-character equivalent of the "
"B<fputs>(3)  function.  It writes the wide-character string starting at "
"I<ws>, up to but not including the terminating null wide character "
"(L\\(aq\\e0\\(aq), to I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:43
msgid ""
"The B<fputws>()  function returns a nonnegative integer if the operation was"
" successful, or -1 to indicate an error."
msgstr ""

#. type: tbl table
#: man-pages/man3/fputws.3:53
#, no-wrap
msgid "B<fputws>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:65
msgid ""
"The behavior of B<fputws>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:73
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fputws>()  will actually write the multibyte"
" string corresponding to the wide-character string I<ws>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputws.3:75
msgid "B<fputwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ffs.3:33
#, no-wrap
msgid "FFS"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:36
msgid "ffs, ffsl, ffsll - find first bit set in a word"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:39
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:41
#, no-wrap
msgid "B<int ffs(int >I<i>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:43
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:45
#, no-wrap
msgid "B<int ffsl(long int >I<i>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:47
#, no-wrap
msgid "B<int ffsll(long long int >I<i>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:57
msgid "B<ffs>():"
msgstr ""

#. type: TP
#: man-pages/man3/ffs.3:58
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:64
#, no-wrap
msgid ""
"    _XOPEN_SOURCE E<gt>= 700\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: man-pages/man3/ffs.3:64
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:67
msgid "none"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:71
msgid "B<ffsl>(), B<ffsll>():"
msgstr ""

#. type: TP
#: man-pages/man3/ffs.3:73
#, no-wrap
msgid "Since glibc 2.27:"
msgstr ""

#.  glibc commit 68fe16dd327c895c08b9ee443b234c49c13b36e9
#. type: Plain text
#: man-pages/man3/ffs.3:77
#, no-wrap
msgid "    _DEFAULT_SOURCE\n"
msgstr ""

#. type: TP
#: man-pages/man3/ffs.3:77
#, no-wrap
msgid "Before glibc 2.27:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:80
#, no-wrap
msgid "    _GNU_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:97
msgid ""
"The B<ffs>()  function returns the position of the first (least significant)"
" bit set in the word I<i>.  The least significant bit is position 1 and the "
"most significant position is, for example, 32 or 64.  The functions "
"B<ffsll>()  and B<ffsl>()  do the same but take arguments of possibly "
"different size."
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:101
msgid ""
"These functions return the position of the first bit set, or 0 if no bits "
"are set in I<i>."
msgstr ""

#. type: tbl table
#: man-pages/man3/ffs.3:113
#, no-wrap
msgid ""
"B<ffs>(),\n"
"B<ffsl>(),\n"
"B<ffsll>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:118
msgid "B<ffs>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:124
msgid "The B<ffsl>()  and B<ffsll>()  functions are glibc extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:127
msgid "BSD systems have a prototype in I<E<lt>string.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ffs.3:128
msgid "B<memchr>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fmod.3:35
#, no-wrap
msgid "FMOD"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:38
msgid "fmod, fmodf, fmodl - floating-point remainder function"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:45
#, no-wrap
msgid ""
"B<double fmod(double >I<x>B<, double >I<y>B<);>\n"
"B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:57
msgid "B<fmodf>(), B<fmodl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:81
msgid ""
"These functions compute the floating-point remainder of dividing I<x> by "
"I<y>.  The return value is I<x> - I<n> * I<y>, where I<n> is the quotient of"
" I<x> / I<y>, rounded toward zero to an integer."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:90
msgid ""
"On success, these functions return the value I<x>\\ -\\ I<n>*I<y>, for some "
"integer I<n>, such that the returned value has the same sign as I<x> and a "
"magnitude less than the magnitude of I<y>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:102
msgid "If I<x> is an infinity, a domain error occurs, and a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:108
msgid "If I<y> is zero, a domain error occurs, and a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:114
msgid "If I<x> is +0 (-0), and I<y> is not zero, +0 (-0) is returned."
msgstr ""

#. type: TP
#: man-pages/man3/fmod.3:121
#, no-wrap
msgid "Domain error: I<x> is an infinity"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:130
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""

#. type: TP
#: man-pages/man3/fmod.3:130
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr ""

#.  POSIX.1 documents an optional underflow error, but AFAICT it doesn't
#.  (can't?) occur -- mtk, Jul 2008
#. type: Plain text
#: man-pages/man3/fmod.3:140
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""

#. type: tbl table
#: man-pages/man3/fmod.3:152
#, no-wrap
msgid ""
"B<fmod>(),\n"
"B<fmodf>(),\n"
"B<fmodl>()"
msgstr ""

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6784
#. type: Plain text
#: man-pages/man3/fmod.3:169
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred for an infinite I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmod.3:170
msgid "B<remainder>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ftw.3:36
#, no-wrap
msgid "FTW"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:39
msgid "ftw, nftw - file tree walk"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:42 man-pages/man3/ftw.3:49
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:47
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:63
msgid "B<nftw>(): _XOPEN_SOURCE E<gt>= 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:70
msgid ""
"B<nftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By"
" default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:83
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<nftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<nftw>()  will become "
"slower because directories have to be closed and reopened.  B<nftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:111
msgid ""
"For each entry found in the tree, B<nftw>()  calls I<fn>() with four "
"arguments: I<fpath>, I<sb>, I<typeflag>, and I<ftwbuf>.  I<fpath> is the "
"pathname of the entry, and is expressed either as a pathname relative to the"
" calling process's current working directory at the time of the call to "
"B<nftw>(), if I<dirpath> was expressed as a relative pathname, or as an "
"absolute pathname, if I<dirpath> was expressed as an absolute pathname.  "
"I<sb> is a pointer to the I<stat> structure returned by a call to B<stat>(2)"
"  for I<fpath>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:117
msgid ""
"The I<typeflag> argument passed to I<fn>()  is an integer that has one of "
"the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:117
#, no-wrap
msgid "B<FTW_F>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:121
msgid "I<fpath> is a regular file."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:121
#, no-wrap
msgid "B<FTW_D>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:125
msgid "I<fpath> is a directory."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:125
#, no-wrap
msgid "B<FTW_DNR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:129
msgid "I<fpath> is a directory which can't be read."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:129
#, no-wrap
msgid "B<FTW_DP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:143
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  (If "
"B<FTW_DEPTH> was not specified in I<flags>, then directories will always be "
"visited with I<typeflag> set to B<FTW_D>.)  All of the files and "
"subdirectories within I<fpath> have been processed."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:143
#, no-wrap
msgid "B<FTW_NS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:160
msgid ""
"The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  The "
"probable cause for this is that the caller had read permission on the parent"
" directory, so that the filename I<fpath> could be seen, but did not have "
"execute permission, so that the file could not be reached for B<stat>(2).  "
"The contents of the buffer pointed to by I<sb> are undefined."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:160
#, no-wrap
msgid "B<FTW_SL>"
msgstr ""

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: man-pages/man3/ftw.3:171
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:171
#, no-wrap
msgid "B<FTW_SLN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:184
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)  On most implementations, in this case the "
"I<sb> argument passed to I<fn>()  contains information returned by "
"performing B<lstat>(2)  on the symbolic link.  For the details on Linux, see"
" BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:192
msgid ""
"The fourth argument (I<ftwbuf>)  that B<nftw>()  supplies when calling "
"I<fn>()  is a pointer to a structure of type I<FTW>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:199
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:212
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:223
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<nftw>().  As long as I<fn>() returns 0, "
"B<nftw>()  will continue either until it has traversed the entire tree, in "
"which case it will return zero, or until it encounters an error (such as a "
"B<malloc>(3)  failure), in which case it will return -1."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:233
msgid ""
"Because B<nftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler"
" set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:238
msgid ""
"The I<flags> argument of B<nftw>()  is formed by ORing zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:238
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:247
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value"
" from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:248
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:253
msgid "Instructs B<nftw>()  to continue normally."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:253
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr ""

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: man-pages/man3/ftw.3:261
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:261
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:269
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from"
" being passed as arguments to I<fn>().  B<nftw>()  continues processing with"
" the next sibling of the directory."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:269
#, no-wrap
msgid "B<FTW_STOP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:275
msgid ""
"Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:278
msgid ""
"Other return values could be associated with new actions in the future; "
"I<fn>() should not return values other than those listed above."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:287
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:288
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:299
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides.  (Specifying this flag has no effect on the "
"pathname that is passed in the I<fpath> argument of I<fn>.)"
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:299
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:305
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:305
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:309
msgid ""
"If set, stay within the same filesystem (i.e., do not cross mount points)."
msgstr ""

#. type: TP
#: man-pages/man3/ftw.3:309
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:314
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set,"
" symbolic links are followed, but no file is reported twice."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:319
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function "
"I<fn>()  is never called for a directory that would be a descendant of "
"itself."
msgstr ""

#. type: SS
#: man-pages/man3/ftw.3:319
#, no-wrap
msgid "ftw()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:324
msgid ""
"B<ftw>()  is an older function that offers a subset of the functionality of "
"B<nftw>().  The notable differences are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:334
msgid ""
"B<ftw>()  has no I<flags> argument.  It behaves the same as when B<nftw>()  "
"is called with I<flags> specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:338
msgid ""
"The callback function, I<fn>(), is not supplied with a fourth argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:350
msgid ""
"The range of values that is passed via the I<typeflag> argument supplied to "
"I<fn>()  is smaller: just B<FTW_F>, B<FTW_D>, B<FTW_DNR>, B<FTW_NS>, and "
"(possibly)  B<FTW_SL>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:352
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:359
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:367
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:370
msgid "B<nftw>()  is available under glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/ftw.3:380
#, no-wrap
msgid "B<nftw>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/ftw.3:380
#, no-wrap
msgid "MT-Safe cwd"
msgstr ""

#. type: tbl table
#: man-pages/man3/ftw.3:383
#, no-wrap
msgid "B<ftw>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:391
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as "
"obsolete."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:395
msgid ""
"POSIX.1-2008 notes that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:401
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:419
msgid ""
"In some implementations (e.g., glibc), B<ftw>()  will never use B<FTW_SL>, "
"on other systems B<FTW_SL> occurs only for symbolic links that do not point "
"to an existing file, and again on other systems B<ftw>()  will use B<FTW_SL>"
" for each symbolic link.  If I<fpath> is a symbolic link and B<stat>(2)  "
"failed, POSIX.1-2008 states that it is undefined whether B<FTW_NS> or "
"B<FTW_SL> is passed in I<typeflag>.  For predictable results, use B<nftw>()."
msgstr ""

#.  FIXME .
#.  https://bugzilla.redhat.com/show_bug.cgi?id=1422736
#.  http://austingroupbugs.net/view.php?id=1121
#. type: Plain text
#: man-pages/man3/ftw.3:458
msgid ""
"In the specification of B<nftw>(), POSIX.1 notes that when B<FTW_NS> is "
"passed as the I<typeflag> argument of I<fn>(), then the contents of the "
"buffer pointed to by the I<sb> argument are undefined.  The standard makes "
"no such statement for the case where B<FTW_SLN> is passed in I<typeflag>, "
"with the implication that the contents of the buffer pointed to by I<sb> are"
" defined.  And indeed this is the case on most implementations: the buffer "
"pointed to by I<sb> contains the results produced by applying B<lstat>(2)  "
"to the symbolic link.  In early glibc, the behavior was the same.  However, "
"since glibc 2.4, the contents of the buffer pointed to by I<sb> are "
"undefined when B<FTW_SLN> is passed in I<typeflag>.  This change I<appears> "
"to be an unintended regression, but it is not (yet) clear if the behavior "
"will be restored to that provided in the original glibc implementation (and "
"on other implementations)."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:467
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The"
" second command-line argument can be used to specify characters that control"
" the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:476
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:487
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d \",\n"
"            (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"            (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"            (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"            (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"            ftwbuf-E<gt>level);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:492
#, no-wrap
msgid ""
"    if (tflag == FTW_NS)\n"
"        printf(\"-------\");\n"
"    else\n"
"        printf(\"%7jd\", (intmax_t) sb-E<gt>st_size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:495
#, no-wrap
msgid ""
"    printf(\"   %-40s %d %s\\en\",\n"
"            fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:498
#, no-wrap
msgid ""
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:503
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:508
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:514
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftw.3:521
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fseeko.3:25
#, no-wrap
msgid "FSEEKO"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:28
msgid "fseeko, ftello - seek to or report file position"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:33
#, no-wrap
msgid ""
"B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:35
#, no-wrap
msgid "B<off_t ftello(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:44
msgid "B<fseeko>(), B<ftello>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:48
msgid "_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:50
msgid "(defining the obsolete _LARGEFILE_SOURCE macro also works)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:73
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:86
msgid ""
"On some architectures, both I<off_t> and I<long> are 32-bit types, but "
"defining B<_FILE_OFFSET_BITS> with the value 64 (before including I<any> "
"header files)  will turn I<off_t> into a 64-bit type."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:95
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns"
" the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:98
msgid "See the ERRORS in B<fseek>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:100
msgid "These functions are available under glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/fseeko.3:111
#, no-wrap
msgid ""
"B<fseeko>(),\n"
"B<ftello>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:116
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2."
msgstr ""

#. type: Plain text
#: man-pages/man3/fseeko.3:117
msgid "B<fseek>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fgetwc.3:18
#, no-wrap
msgid "FGETWC"
msgstr ""

#. type: TH
#: man-pages/man3/fgetwc.3:18
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:21
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:25
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:28
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:43
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the "
"B<fgetc>(3)  function.  It reads a wide character from I<stream> and returns"
" it.  If the end of stream is reached, or if I<ferror(stream)> becomes true,"
" it returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:51
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than once."
"  There is no reason ever to use it."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:63
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>.  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:65
msgid "Apart from the usual ones, there is"
msgstr ""

#. type: TP
#: man-pages/man3/fgetwc.3:65
#, no-wrap
msgid "B<EILSEQ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:69
msgid ""
"The data obtained from the input stream does not form a valid character."
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetwc.3:80
#, no-wrap
msgid ""
"B<fgetwc>(),\n"
"B<getwc>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:91
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:99
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetwc.3:103
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fpathconf.3:42
#, no-wrap
msgid "FPATHCONF"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:45
msgid "fpathconf, pathconf - get configuration values for files"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:51
#, no-wrap
msgid ""
"B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
"B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:58
msgid ""
"B<fpathconf>()  gets a value for the configuration option I<name> for the "
"open file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:64
msgid ""
"B<pathconf>()  gets a value for configuration option I<name> for the "
"filename I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:73
msgid ""
"The corresponding macros defined in I<E<lt>unistd.hE<gt>> are minimum "
"values; if an application wants to take advantage of values which may "
"change, a call to B<fpathconf>()  or B<pathconf>()  can be made, which may "
"yield more liberal results."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:78
msgid ""
"Setting I<name> equal to one of the following constants returns the "
"following configuration options:"
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:78
#, no-wrap
msgid "B<_PC_LINK_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:88
msgid ""
"The maximum number of links to the file.  If I<fd> or I<path> refer to a "
"directory, then the value applies to the whole directory.  The corresponding"
" macro is B<_POSIX_LINK_MAX>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:88
#, no-wrap
msgid "B<_PC_MAX_CANON>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:97
msgid ""
"The maximum length of a formatted input line, where I<fd> or I<path> must "
"refer to a terminal.  The corresponding macro is B<_POSIX_MAX_CANON>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:97
#, no-wrap
msgid "B<_PC_MAX_INPUT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:106
msgid ""
"The maximum length of an input line, where I<fd> or I<path> must refer to a "
"terminal.  The corresponding macro is B<_POSIX_MAX_INPUT>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:106
#, no-wrap
msgid "B<_PC_NAME_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:115
msgid ""
"The maximum length of a filename in the directory I<path> or I<fd> that the "
"process is allowed to create.  The corresponding macro is "
"B<_POSIX_NAME_MAX>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:115
#, no-wrap
msgid "B<_PC_PATH_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:124
msgid ""
"The maximum length of a relative pathname when I<path> or I<fd> is the "
"current working directory.  The corresponding macro is B<_POSIX_PATH_MAX>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:124
#, no-wrap
msgid "B<_PC_PIPE_BUF>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:138
msgid ""
"The maximum number of bytes that can be written atomically to a pipe of "
"FIFO.  For B<fpathconf>(), I<fd> should refer to a pipe or FIFO.  For "
"B<fpathconf>(), I<path> should refer to a FIFO or a directory; in the latter"
" case, the returned value corresponds to FIFOs created in that directory.  "
"The corresponding macro is B<_POSIX_PIPE_BUF>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:138
#, no-wrap
msgid "B<_PC_CHOWN_RESTRICTED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:153
msgid ""
"This returns a positive value if the use of B<chown>(2)  and B<fchown>(2)  "
"for changing a file's user ID is restricted to a process with appropriate "
"privileges, and changing a file's group ID to a value other than the "
"process's effective group ID or one of its supplementary group IDs is "
"restricted to a process with appropriate privileges.  According to POSIX.1, "
"this variable shall always be defined with a value other than -1.  The "
"corresponding macro is B<_POSIX_CHOWN_RESTRICTED>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:160
msgid ""
"If I<fd> or I<path> refers to a directory, then the return value applies to "
"all files in that directory."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:160
#, no-wrap
msgid "B<_PC_NO_TRUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:167
msgid ""
"This returns nonzero if accessing filenames longer than B<_POSIX_NAME_MAX> "
"generates an error.  The corresponding macro is B<_POSIX_NO_TRUNC>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:167
#, no-wrap
msgid "B<_PC_VDISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:174
msgid ""
"This returns nonzero if special character processing can be disabled, where "
"I<fd> or I<path> must refer to a terminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:176
msgid "The return value of these functions is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:185
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error (for example, B<EINVAL>, indicating that I<name> is invalid)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:197
msgid ""
"If I<name> corresponds to a maximum or minimum limit, and that limit is "
"indeterminate, -1 is returned and I<errno> is not changed.  (To distinguish "
"an indeterminate limit from an error, set I<errno> to zero before the call, "
"and then check whether I<errno> is nonzero when -1 is returned.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:203
msgid ""
"If I<name> corresponds to an option, a positive value is returned if the "
"option is supported, and -1 is returned if the option is not supported."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:212
msgid ""
"Otherwise, the current value of the option or limit is returned.  This value"
" will not be more restrictive than the corresponding value that was "
"described to the application in I<E<lt>unistd.hE<gt>> or "
"I<E<lt>limits.hE<gt>> when the application was compiled."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:218
msgid ""
"(B<pathconf>())  Search permission is denied for one of the directories in "
"the path prefix of I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:223
msgid "(B<fpathconf>())  I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:227
msgid "I<name> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:232
msgid ""
"The implementation does not support an association of I<name> with the "
"specified file."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:232
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:237
msgid ""
"(B<pathconf>())  Too many symbolic links were encountered while resolving "
"I<path>."
msgstr ""

#. type: TP
#: man-pages/man3/fpathconf.3:237
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:242
msgid "(B<pathconf>())  I<path> is too long."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:250
msgid ""
"(B<pathconf>())  A component of I<path> does not exist, or I<path> is an "
"empty string."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:256
msgid ""
"(B<pathconf>())  A component used as a directory in I<path> is not in fact a"
" directory."
msgstr ""

#. type: tbl table
#: man-pages/man3/fpathconf.3:267
#, no-wrap
msgid ""
"B<fpathconf>(),\n"
"B<pathconf>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:277
msgid ""
"Files with name lengths longer than the value returned for I<name> equal to "
"B<_PC_NAME_MAX> may exist in the given directory."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:280
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpathconf.3:285
msgid "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<instr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<instr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:80
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" (of type "
"I<FTS\\ *>)  that refers to a file hierarchy \"stream\".  This handle is "
"then supplied to the other fts functions.  The function B<fts_read>()  "
"returns a pointer to a structure describing one of the files in the file "
"hierarchy.  The function B<fts_children>()  returns a pointer to a linked "
"list of structures, each of which describes one of the files contained in a "
"directory in the hierarchy."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:90
msgid ""
"In general, directories are visited two distinguishable times; in preorder "
"(before any of their descendants are visited) and in postorder (after all of"
" their descendants have been visited).  Files are visited once.  It is "
"possible to walk the hierarchy \"logically\" (visiting the files that "
"symbolic links point to)  or physically (visiting the symbolic links "
"themselves), order the walk of the hierarchy or prune and/or revisit "
"portions of the hierarchy."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:107
msgid ""
"Two structures (and associated types) are defined in the include file "
"I<E<lt>fts.hE<gt>>.  The first type is I<FTS>, the structure that represents"
" the file hierarchy itself.  The second type is I<FTSENT>, the structure "
"that represents a file in the file hierarchy.  Normally, an I<FTSENT> "
"structure is returned for every file in the file hierarchy.  In this manual "
"page, \"file\" and \"FTSENT structure\" are generally interchangeable."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:114
msgid ""
"The I<FTSENT> structure contains fields describing a file.  The structure "
"contains at least the following fields (there are additional fields that "
"should be considered private to the implementation):"
msgstr ""

#.  Also:
#.      ino_t fts_ino;                  /* inode (only for directories)*/
#.      dev_t fts_dev;                  /* device (only for directories)*/
#.      nlink_t fts_nlink;              /* link count (only for directories)*/
#.      u_short fts_flags;              /* private flags for FTSENT structure
#. */
#.      u_short fts_instr;              /* fts_set() instructions */
#. type: Plain text
#: man-pages/man3/fts.3:140
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short  fts_info;     /* flags for FTSENT structure */\n"
"    char           *fts_accpath;  /* access path */\n"
"    char           *fts_path;     /* root path */\n"
"    short           fts_pathlen;  /* strlen(fts_path) +\n"
"                                     strlen(fts_name) */\n"
"    char           *fts_name;     /* filename */\n"
"    short           fts_namelen;  /* strlen(fts_name) */\n"
"    short           fts_level;    /* depth (-1 to N) */\n"
"    int             fts_errno;    /* file errno */\n"
"    long            fts_number;   /* local numeric value */\n"
"    void           *fts_pointer;  /* local address value */\n"
"    struct _ftsent *fts_parent;   /* parent directory */\n"
"    struct _ftsent *fts_link;     /* next file structure */\n"
"    struct _ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat    *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: man-pages/man3/fts.3:145
msgid "These fields are defined as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:145
#, no-wrap
msgid "I<fts_info>"
msgstr ""

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: man-pages/man3/fts.3:157
msgid ""
"One of the following values describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:158
#, no-wrap
msgid "B<FTS_D>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:161
msgid "A directory being visited in preorder."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:161
#, no-wrap
msgid "B<FTS_DC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:169
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the"
" I<FTSENT> structure will be filled in as well.)"
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:169
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:177
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described"
" by one of the other I<fts_info> values."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:177
#, no-wrap
msgid "B<FTS_DNR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:183
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:183
#, no-wrap
msgid "B<FTS_DOT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:193
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:193
#, no-wrap
msgid "B<FTS_DP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:203
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:203
#, no-wrap
msgid "B<FTS_ERR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:208
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:208
#, no-wrap
msgid "B<FTS_F>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:211
msgid "A regular file."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:211
#, no-wrap
msgid "B<FTS_NS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:222
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:222
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:230
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:230
#, no-wrap
msgid "B<FTS_SL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:233
msgid "A symbolic link."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:233
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr ""

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:241
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp>"
" field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:242
#, no-wrap
msgid "I<fts_accpath>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:245
msgid "A path for accessing the file from the current directory."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:245
#, no-wrap
msgid "I<fts_path>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:251
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:251
#, no-wrap
msgid "I<fts_pathlen>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:257
msgid ""
"The sum of the lengths of the strings referenced by I<fts_path> and "
"I<fts_name>."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:257
#, no-wrap
msgid "I<fts_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:260
msgid "The name of the file."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:260
#, no-wrap
msgid "I<fts_namelen>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:264
msgid "The length of the string referenced by I<fts_name>."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:264
#, no-wrap
msgid "I<fts_level>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:275
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:275
#, no-wrap
msgid "I<fts_errno>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:299
msgid ""
"If B<fts_children>()  or B<fts_read>()  returns an I<FTSENT> structure whose"
" I<fts_info> field is set to B<FTS_DNR>, B<FTS_ERR>, or B<FTS_NS>, the "
"I<fts_errno> field contains the error number (i.e., the I<errno> value)  "
"specifying the cause of the error.  Otherwise, the contents of the "
"I<fts_errno> field are undefined."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:299
#, no-wrap
msgid "I<fts_number>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:305
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:305
#, no-wrap
msgid "I<fts_pointer>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:312
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:312
#, no-wrap
msgid "I<fts_parent>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:326
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number>, and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:326
#, no-wrap
msgid "I<fts_link>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:337
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory"
" members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:337
#, no-wrap
msgid "I<fts_cycle>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:353
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:353
#, no-wrap
msgid "I<fts_statp>"
msgstr ""

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:359
msgid "A pointer to B<stat>(2)  information for the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:386
msgid ""
"A single buffer is used for all of the paths of all of the files in the file"
" hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned"
" by B<fts_read>().  To use these fields to reference any files represented "
"by other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen>"
" field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always null-"
"terminated."
msgstr ""

#. type: SS
#: man-pages/man3/fts.3:386
#, no-wrap
msgid "fts_open()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:393
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a null pointer."
msgstr ""

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: man-pages/man3/fts.3:403
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:403
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:409
msgid ""
"This option causes any symbolic link specified as a root path to be followed"
" immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:409
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:428
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this"
" option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either"
" B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()"
"  function."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:428
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:444
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:444
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:460
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes"
" that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:460
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:479
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:479
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:492
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures"
" for them."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:492
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr ""

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:498
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:537
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path>, "
"and I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used "
"in this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""

#. type: SS
#: man-pages/man3/fts.3:537
#, no-wrap
msgid "fts_read()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:550
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may"
" cause files to be visited more than once, or directories more than twice.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:571
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and"
" sets I<errno> appropriately.  If an error related to a returned file "
"occurs, a pointer to an I<FTSENT> structure is returned, and I<errno> may or"
" may not have been set (see I<fts_info>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:588
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after"
" a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""

#. type: SS
#: man-pages/man3/fts.3:588
#, no-wrap
msgid "fts_children()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:606
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will re-create this "
"linked list."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:634
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, "
"B<fts_children>()  returns NULL and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:645
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>(), or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: man-pages/man3/fts.3:650
msgid "The I<instr> argument is either zero or the following value:"
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:650
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr ""

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:660
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""

#. type: SS
#: man-pages/man3/fts.3:660
#, no-wrap
msgid "fts_set()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:672
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs."
msgstr ""

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: man-pages/man3/fts.3:677
msgid ""
"The I<instr> argument is either 0 (meaning \"do nothing\") or one of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:677
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:695
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:695
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:723
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()"
"  returns the file with the I<fts_info> and I<fts_statp> fields "
"reinitialized to reflect the target of the symbolic link instead of the "
"symbolic link itself.  If the file is one of those most recently returned by"
" B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the "
"structure, when returned by B<fts_read>(), will reflect the target of the "
"symbolic link instead of the symbolic link itself.  In either case, if the "
"target of the symbolic link does not exist, the fields of the returned "
"structure will be unchanged and the I<fts_info> field will be set to "
"B<FTS_SLNONE>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:727
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""

#. type: TP
#: man-pages/man3/fts.3:727
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr ""

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:735
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""

#. type: SS
#: man-pages/man3/fts.3:735
#, no-wrap
msgid "fts_close()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:748
msgid ""
"The B<fts_close>()  function closes the file hierarchy stream referred to by"
" I<ftsp> and restores the current directory to the directory from which "
"B<fts_open>()  was called to open I<ftsp>.  The B<fts_close>()  function "
"returns 0 on success, and -1 if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:757
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:766
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors"
" specified for B<chdir>(2)  and B<close>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:780
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), and B<stat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:789
msgid ""
"In addition, B<fts_children>(), B<fts_open>(), and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:795
msgid "I<options> or I<instr> was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:797
msgid "These functions are available in Linux since glibc2."
msgstr ""

#. type: tbl table
#: man-pages/man3/fts.3:809
#, no-wrap
msgid ""
"B<fts_open>(),\n"
"B<fts_set>(),\n"
"B<fts_close>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fts.3:813
#, no-wrap
msgid ""
"B<fts_read>(),\n"
"B<fts_children>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fts.3:813
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:818
msgid "4.4BSD."
msgstr ""

#.  Fixed by commit 8b7b7f75d91f7bac323dd6a370aeb3e9c5c4a7d5
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=15838
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11460
#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: man-pages/man3/fts.3:834
msgid ""
"In versions of glibc before 2.23, all of the APIs described in this man page"
" are not safe when compiling a program using the LFS APIs (e.g., when "
"compiling with I<-D_FILE_OFFSET_BITS=64>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fts.3:839
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/floor.3:27
#, no-wrap
msgid "FLOOR"
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:30
msgid ""
"floor, floorf, floorl - largest integral value not greater than argument"
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:37
#, no-wrap
msgid ""
"B<double floor(double >I<x>B<);>\n"
"B<float floorf(float >I<x>B<);>\n"
"B<long double floorl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:49
msgid "B<floorf>(), B<floorl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:58
msgid ""
"These functions return the largest integral value that is not greater than "
"I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:64
msgid "For example, I<floor(0.5)> is 0.0, and I<floor(-0.5)> is -1.0."
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:67
msgid "These functions return the floor of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:73
msgid ""
"If I<x> is integral, +0, -0, NaN, or an infinity, I<x> itself is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:76
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""

#. type: tbl table
#: man-pages/man3/floor.3:88
#, no-wrap
msgid ""
"B<floor>(),\n"
"B<floorf>(),\n"
"B<floorl>()"
msgstr ""

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: man-pages/man3/floor.3:113
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno>"
" to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of"
" mantissa bits is 24 (respectively, 53).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/floor.3:119
msgid ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), "
"B<trunc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fputwc.3:16
#, no-wrap
msgid "FPUTWC"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:19
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:26
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:42
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the "
"B<fputc>(3)  function.  It writes the wide character I<wc> to I<stream>.  If"
" I<ferror(stream)> becomes true, it returns B<WEOF>.  If a wide-character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>."
"  Otherwise, it returns I<wc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:50
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than once."
"  There is no reason ever to use it."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:62
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error.  In the event of an error, I<errno> is set to indicate "
"the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:67
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr ""

#. type: tbl table
#: man-pages/man3/fputwc.3:78
#, no-wrap
msgid ""
"B<fputwc>(),\n"
"B<putwc>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:90
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:98
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fputwc>()  will actually write the multibyte"
" sequence corresponding to the wide character I<wc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fputwc.3:101
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fmax.3:9
#, no-wrap
msgid "FMAX"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmax.3:12
msgid "fmax, fmaxf, fmaxl - determine maximum of two floating-point numbers"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmax.3:18
msgid ""
"B<double fmax(double >I<x>B<, double >I<y>B<);> B<float fmaxf(float >I<x>B<,"
" float >I<y>B<);> B<long double fmaxl(long double >I<x>B<, long double "
">I<y>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmax.3:30
msgid "B<fmax>(), B<fmaxf>(), B<fmaxl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmax.3:39
msgid "These functions return the larger value of I<x> and I<y>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fmax.3:44
msgid "These functions return the maximum of I<x> and I<y>."
msgstr ""

#. type: tbl table
#: man-pages/man3/fmax.3:64
#, no-wrap
msgid ""
"B<fmax>(),\n"
"B<fmaxf>(),\n"
"B<fmaxl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fmax.3:70
msgid "B<fdim>(3), B<fmin>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fma.3:12
#, no-wrap
msgid "FMA"
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:15
msgid "fma, fmaf, fmal - floating-point multiply and add"
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:22
#, no-wrap
msgid ""
"B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"
"B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"
"B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double >I<z>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:35
msgid "B<fma>(), B<fmaf>(), B<fmal>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:45
msgid ""
"These functions compute I<x> * I<y> + I<z>.  The result is rounded as one "
"ternary operation according to the current rounding mode (see B<fenv>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:49
msgid ""
"These functions return the value of I<x> * I<y> + I<z>, rounded as one "
"ternary operation."
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:65
msgid ""
"If I<x> times I<y> is an exact infinity, and I<z> is an infinity with the "
"opposite sign, a domain error occurs, and a NaN is returned."
msgstr ""

#.  POSIX.1-2008 allows some possible differences for the following two
#.  domain error cases, but on Linux they are treated the same (AFAICS).
#.  Nevertheless, we'll mirror POSIX.1 and describe the two cases
#.  separately.
#.  POSIX.1 says that a NaN or an implementation-defined value shall
#.  be returned for this case.
#. type: Plain text
#: man-pages/man3/fma.3:81
msgid ""
"If one of I<x> or I<y> is an infinity, the other is 0, and I<z> is not a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""

#.  POSIX.1 makes the domain error optional for this case.
#. type: Plain text
#: man-pages/man3/fma.3:92
msgid ""
"If one of I<x> or I<y> is an infinity, and the other is 0, and I<z> is a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:101
msgid ""
"If I<x> times I<y> is not an infinity times zero (or vice versa), and I<z> "
"is a NaN, a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:105
msgid ""
"If the result overflows, a range error occurs, and an infinity with the "
"correct sign is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:109
msgid ""
"If the result underflows, a range error occurs, and a signed 0 is returned."
msgstr ""

#. type: TP
#: man-pages/man3/fma.3:116
#, no-wrap
msgid ""
"Domain error: I<x> * I<y> + I<z>, or I<x> * I<y> is invalid and I<z> is not "
"a NaN"
msgstr ""

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/fma.3:125
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr ""

#. type: TP
#: man-pages/man3/fma.3:133
#, no-wrap
msgid "Range error: result underflow"
msgstr ""

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/fma.3:141
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""

#. type: tbl table
#: man-pages/man3/fma.3:160
#, no-wrap
msgid ""
"B<fma>(),\n"
"B<fmaf>(),\n"
"B<fmal>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fma.3:166
msgid "B<remainder>(3), B<remquo>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fenv.3:27
#, no-wrap
msgid "FENV"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:33
msgid ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, "
"fetestexcept, fegetenv, fegetround, feholdexcept, fesetround, fesetenv, "
"feupdateenv, feenableexcept, fedisableexcept, fegetexcept - floating-point "
"rounding and exception handling"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:36
#, no-wrap
msgid "B<#include E<lt>fenv.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:42
#, no-wrap
msgid ""
"B<int feclearexcept(int >I<excepts>B<);>\n"
"B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
"B<int feraiseexcept(int >I<excepts>B<);>\n"
"B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
"B<int fetestexcept(int >I<excepts>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:45
#, no-wrap
msgid ""
"B<int fegetround(void);>\n"
"B<int fesetround(int >I<rounding_mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:50
#, no-wrap
msgid ""
"B<int fegetenv(fenv_t *>I<envp>B<);>\n"
"B<int feholdexcept(fenv_t *>I<envp>B<);>\n"
"B<int fesetenv(const fenv_t *>I<envp>B<);>\n"
"B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:56
msgid ""
"These eleven functions were defined in C99, and describe the handling of "
"floating-point rounding and exceptions (overflow, zero-divide, etc.)."
msgstr ""

#. type: SS
#: man-pages/man3/fenv.3:56
#, no-wrap
msgid "Exceptions"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:61
msgid ""
"The I<divide-by-zero> exception occurs when an operation on finite numbers "
"produces infinity as exact answer."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:67
msgid ""
"The I<overflow> exception occurs when a result has to be represented as a "
"floating-point number, but has (much) larger absolute value than the largest"
" (finite) floating-point number that is representable."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:74
msgid ""
"The I<underflow> exception occurs when a result has to be represented as a "
"floating-point number, but has smaller absolute value than the smallest "
"positive normalized floating-point number (and would lose much accuracy when"
" represented as a denormalized number)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:84
msgid ""
"The I<inexact> exception occurs when the rounded result of an operation is "
"not equal to the infinite precision result.  It may occur whenever "
"I<overflow> or I<underflow> occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:89
msgid ""
"The I<invalid> exception occurs when there is no well-defined result for an "
"operation, as for 0/0 or infinity - infinity or sqrt(-1)."
msgstr ""

#. type: SS
#: man-pages/man3/fenv.3:89
#, no-wrap
msgid "Exception handling"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:95
msgid ""
"Exceptions are represented in two ways: as a single bit (exception "
"present/absent), and these bits correspond in some implementation-defined "
"way with bit positions in an integer, and also as an opaque structure that "
"may contain more information about the exception (perhaps the code address "
"where it occurred)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:111
msgid ""
"Each of the macros B<FE_DIVBYZERO>, B<FE_INEXACT>, B<FE_INVALID>, "
"B<FE_OVERFLOW>, B<FE_UNDERFLOW> is defined when the implementation supports "
"handling of the corresponding exception, and if so then defines the "
"corresponding bit(s), so that one can call exception handling functions, for"
" example, using the integer argument B<FE_OVERFLOW>|B<FE_UNDERFLOW>.  Other "
"exceptions may be supported.  The macro B<FE_ALL_EXCEPT> is the bitwise OR "
"of all bits corresponding to supported exceptions."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:116
msgid ""
"The B<feclearexcept>()  function clears the supported exceptions represented"
" by the bits in its argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:124
msgid ""
"The B<fegetexceptflag>()  function stores a representation of the state of "
"the exception flags represented by the argument I<excepts> in the opaque "
"object I<*flagp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:129
msgid ""
"The B<feraiseexcept>()  function raises the supported exceptions represented"
" by the bits in I<excepts>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:140
msgid ""
"The B<fesetexceptflag>()  function sets the complete status for the "
"exceptions represented by I<excepts> to the value I<*flagp>.  This value "
"must have been obtained by an earlier call of B<fegetexceptflag>()  with a "
"last argument that contained all bits in I<excepts>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:147
msgid ""
"The B<fetestexcept>()  function returns a word in which the bits are set "
"that were set in the argument I<excepts> and for which the corresponding "
"exception is currently set."
msgstr ""

#. type: SS
#: man-pages/man3/fenv.3:147
#, no-wrap
msgid "Rounding mode"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:155
msgid ""
"The rounding mode determines how the result of floating-point operations is "
"treated when the result cannot be exactly represented in the significand.  "
"Various rounding modes may be provided: round to nearest (the default), "
"round up (toward positive infinity), round down (toward negative infinity), "
"and round toward zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:164
msgid ""
"Each of the macros B<FE_TONEAREST>, B<FE_UPWARD>, B<FE_DOWNWARD>, and "
"B<FE_TOWARDZERO> is defined when the implementation supports getting and "
"setting the corresponding rounding direction."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:169
msgid ""
"The B<fegetround>()  function returns the macro corresponding to the current"
" rounding mode."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:174
msgid ""
"The B<fesetround>()  function sets the rounding mode as specified by its "
"argument and returns zero when it was successful."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:182
msgid ""
"C99 and POSIX.1-2008 specify an identifier, B<FLT_ROUNDS>, defined in "
"I<E<lt>float.hE<gt>>, which indicates the implementation-defined rounding "
"behavior for floating-point addition.  This identifier has one of the "
"following values:"
msgstr ""

#. type: IP
#: man-pages/man3/fenv.3:182
#, no-wrap
msgid "-1"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:184
msgid "The rounding mode is not determinable."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:186
msgid "Rounding is toward 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:188
msgid "Rounding is toward nearest number."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:190
msgid "Rounding is toward positive infinity."
msgstr ""

#. type: IP
#: man-pages/man3/fenv.3:190
#, no-wrap
msgid "3"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:192
msgid "Rounding is toward negative infinity."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:194
msgid "Other values represent machine-dependent, nonstandard rounding modes."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:200
msgid ""
"The value of B<FLT_ROUNDS> should reflect the current rounding mode as set "
"by B<fesetround>()  (but see BUGS)."
msgstr ""

#. type: SS
#: man-pages/man3/fenv.3:200
#, no-wrap
msgid "Floating-point environment"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:212
msgid ""
"The entire floating-point environment, including control modes and status "
"flags, can be handled as one opaque object, of type I<fenv_t>.  The default "
"environment is denoted by B<FE_DFL_ENV> (of type I<const fenv_t\\ *>).  This"
" is the environment setup at program start and it is defined by ISO C to "
"have round to nearest, all exceptions cleared and a nonstop (continue on "
"exceptions) mode."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:217
msgid ""
"The B<fegetenv>()  function saves the current floating-point environment in "
"the object I<*envp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:224
msgid ""
"The B<feholdexcept>()  function does the same, then clears all exception "
"flags, and sets a nonstop (continue on exceptions) mode, if available.  It "
"returns zero when successful."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:237
msgid ""
"The B<fesetenv>()  function restores the floating-point environment from the"
" object I<*envp>.  This object must be known to be valid, for example, the "
"result of a call to B<fegetenv>()  or B<feholdexcept>()  or equal to "
"B<FE_DFL_ENV>.  This call does not raise exceptions."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:250
msgid ""
"The B<feupdateenv>()  function installs the floating-point environment "
"represented by the object I<*envp>, except that currently raised exceptions "
"are not cleared.  After calling this function, the raised exceptions will be"
" a bitwise OR of those previously set with those in I<*envp>.  As before, "
"the object I<*envp> must be known to be valid."
msgstr ""

#.  Earlier seven of these functions were listed as returning void.
#.  This was corrected in Corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001(E))
#.  of the C99 Standard.
#. type: Plain text
#: man-pages/man3/fenv.3:255
msgid ""
"These functions return zero on success and nonzero if an error occurred."
msgstr ""

#. type: tbl table
#: man-pages/man3/fenv.3:282
#, no-wrap
msgid ""
"B<feclearexcept>(),\n"
"B<fegetexceptflag>(),\n"
"B<feraiseexcept>(),\n"
"B<fesetexceptflag>(),\n"
"B<fetestexcept>(),\n"
"B<fegetround>(),\n"
"B<fesetround>(),\n"
"B<fegetenv>(),\n"
"B<feholdexcept>(),\n"
"B<fesetenv>(),\n"
"B<feupdateenv>(),\n"
"B<feenableexcept>(),\n"
"B<fedisableexcept>(),\n"
"B<fegetexcept>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:290
msgid "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:310
msgid ""
"If possible, the GNU C Library defines a macro B<FE_NOMASK_ENV> which "
"represents an environment where every exception raised causes a trap to "
"occur.  You can test for this macro using B<#ifdef>.  It is defined only if "
"B<_GNU_SOURCE> is defined.  The C99 standard does not define a way to set "
"individual bits in the floating-point mask, for example, to trap on specific"
" flags.  Since version 2.2, glibc supports the functions B<feenableexcept>()"
"  and B<fedisableexcept>()  to set individual floating-point traps, and "
"B<fegetexcept>()  to query the state."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:314
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fenv.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:318
#, no-wrap
msgid ""
"B<int feenableexcept(int >I<excepts>B<);>\n"
"B<int fedisableexcept(int >I<excepts>B<);>\n"
"B<int fegetexcept(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:331
msgid ""
"The B<feenableexcept>()  and B<fedisableexcept>()  functions enable "
"(disable) traps for each of the exceptions represented by I<excepts> and "
"return the previous set of enabled exceptions when successful, and -1 "
"otherwise.  The B<fegetexcept>()  function returns the set of all currently "
"enabled exceptions."
msgstr ""

#.  Aug 08, glibc 2.8
#.  See http://gcc.gnu.org/ml/gcc/2002-02/msg01535.html
#. type: Plain text
#: man-pages/man3/fenv.3:342
msgid ""
"C99 specifies that the value of B<FLT_ROUNDS> should reflect changes to the "
"current rounding mode, as set by B<fesetround>().  Currently, this does not "
"occur: B<FLT_ROUNDS> always has the value 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/fenv.3:343
msgid "B<math_error>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/fpclassify.3:10
#, no-wrap
msgid "FPCLASSIFY"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:14
msgid ""
"fpclassify, isfinite, isnormal, isnan, isinf - floating-point classification"
" macros"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:19
#, no-wrap
msgid "B<int fpclassify(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:21
#, no-wrap
msgid "B<int isfinite(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:23
#, no-wrap
msgid "B<int isnormal(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:25
#, no-wrap
msgid "B<int isnan(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:27
#, no-wrap
msgid "B<int isinf(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:42
msgid "B<fpclassify>(), B<isfinite>(), B<isnormal>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:51
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:69
msgid ""
"Floating point numbers can have special values, such as infinite or NaN.  "
"With the macro B<fpclassify(>I<x>B<)> you can find out what type I<x> is.  "
"The macro takes any floating-point expression as argument.  The result is "
"one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:69
#, no-wrap
msgid "B<FP_NAN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:73
msgid "I<x> is \"Not a Number\"."
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:73
#, no-wrap
msgid "B<FP_INFINITE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:77
msgid "I<x> is either positive infinity or negative infinity."
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:77
#, no-wrap
msgid "B<FP_ZERO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:81
msgid "I<x> is zero."
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:81
#, no-wrap
msgid "B<FP_SUBNORMAL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:85
msgid "I<x> is too small to be represented in normalized format."
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:85
#, no-wrap
msgid "B<FP_NORMAL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:89
msgid ""
"if nothing of the above is correct then it must be a normal floating-point "
"number."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:91
msgid "The other macros provide a short answer to some standard questions."
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:91
#, no-wrap
msgid "B<isfinite(>I<x>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:94
msgid "returns a nonzero value if"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:96
msgid "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:96
#, no-wrap
msgid "B<isnormal(>I<x>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:100
msgid "returns a nonzero value if (fpclassify(x) == FP_NORMAL)"
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:100
#, no-wrap
msgid "B<isnan(>I<x>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:104
msgid "returns a nonzero value if (fpclassify(x) == FP_NAN)"
msgstr ""

#. type: TP
#: man-pages/man3/fpclassify.3:104
#, no-wrap
msgid "B<isinf(>I<x>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:111
msgid ""
"returns 1 if I<x> is positive infinity, and -1 if I<x> is negative infinity."
msgstr ""

#. type: tbl table
#: man-pages/man3/fpclassify.3:126
#, no-wrap
msgid ""
"B<fpclassify>(),\n"
"B<isfinite>(),\n"
"B<isnormal>(),\n"
"B<isnan>(),\n"
"B<isinf>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:136
msgid ""
"For B<isinf>(), the standards merely say that the return value is nonzero if"
" and only if the argument has an infinite value."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:143
msgid ""
"In glibc 2.01 and earlier, B<isinf>()  returns a nonzero value (actually: 1)"
" if I<x> is positive infinity or negative infinity.  (This is all that C99 "
"requires.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpclassify.3:147
msgid "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/fpurge.3:25
#, no-wrap
msgid "FPURGE"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:28
msgid "fpurge, __fpurge - purge a stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:32
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:34
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:38
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:40
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:53
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:57
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a"
" value."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:64
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:69
msgid "I<stream> is not an open stream."
msgstr ""

#. type: tbl table
#: man-pages/man3/fpurge.3:79
#, no-wrap
msgid "B<__fpurge>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fpurge.3:79
#, no-wrap
msgid "MT-Safe race:stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:90
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()"
"  was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and"
" later."
msgstr ""

#. type: Plain text
#: man-pages/man3/fpurge.3:92
msgid "Usually it is a mistake to want to discard input buffers."
msgstr ""

#.  .BR fclean (3),
#. type: Plain text
#: man-pages/man3/fpurge.3:96
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/futimes.3:25
#, no-wrap
msgid "FUTIMES"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:28
msgid "futimes, lutimes - change file timestamps"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:31
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:33
#, no-wrap
msgid "B<int futimes(int >I<fd>B<, const struct timeval >I<tv>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:35
#, no-wrap
msgid ""
"B<int lutimes(const char *>I<filename>B<, const struct timeval "
">I<tv>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:48
#, no-wrap
msgid ""
"B<futimes>(),\n"
"B<lutimes>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:56
msgid ""
"B<futimes>()  changes the access and modification times of a file in the "
"same way as B<utimes>(2), with the difference that the file whose timestamps"
" are to be changed is specified via a file descriptor, I<fd>, rather than "
"via a pathname."
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:64
msgid ""
"B<lutimes>()  changes the access and modification times of a file in the "
"same way as B<utimes>(2), with the difference that if I<filename> refers to "
"a symbolic link, then the link is not dereferenced: instead, the timestamps "
"of the symbolic link are changed."
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:74
msgid ""
"Errors are as for B<utimes>(2), with the following additions for "
"B<futimes>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:78
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:86
msgid "The following additional error may occur for B<lutimes>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:89
msgid ""
"The kernel does not support this call; Linux 2.6.22 or later is required."
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:96
msgid ""
"B<futimes>()  is available since glibc 2.3.  B<lutimes>()  is available "
"since glibc 2.6, and is implemented using the B<utimensat>(2)  system call, "
"which is supported since kernel 2.6.22."
msgstr ""

#. type: tbl table
#: man-pages/man3/futimes.3:107
#, no-wrap
msgid ""
"B<futimes>(),\n"
"B<lutimes>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:112
msgid ""
"These functions are not specified in any standard.  Other than Linux, they "
"are available only on the BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man3/futimes.3:115
msgid "B<utime>(2), B<utimensat>(2), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/fgetgrent.3:30
#, no-wrap
msgid "FGETGRENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:33
msgid "fgetgrent - get group file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:38
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:40
#, no-wrap
msgid "B<struct group *fgetgrent(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:52
#, no-wrap
msgid ""
"B<fgetgrent>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:66
msgid ""
"The B<fgetgrent>()  function returns a pointer to a structure containing the"
" group information from the file referred to by I<stream>.  The first time "
"it is called it returns the first entry; thereafter, it returns successive "
"entries.  The file referred to by I<stream> must have the same format as "
"I</etc/group> (see B<group>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:68
msgid "The I<group> structure is defined in I<E<lt>grp.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:78
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;        /* group name */\n"
"    char   *gr_passwd;      /* group password */\n"
"    gid_t   gr_gid;         /* group ID */\n"
"    char  **gr_mem;         /* NULL-terminated array of pointers\n"
"                               to names of group members */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:90
msgid ""
"The B<fgetgrent>()  function returns a pointer to a I<group> structure, or "
"NULL if there are no more entries or an error occurs.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:96
msgid "Insufficient memory to allocate I<group> structure."
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetgrent.3:106
#, no-wrap
msgid "B<fgetgrent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/fgetgrent.3:106
#, no-wrap
msgid "MT-Unsafe race:fgetgrent"
msgstr ""

#. type: Plain text
#: man-pages/man3/fgetgrent.3:128
msgid ""
"B<endgrent>(3), B<fgetgrent_r>(3), B<fopen>(3), B<getgrent>(3), "
"B<getgrgid>(3), B<getgrnam>(3), B<putgrent>(3), B<setgrent>(3), B<group>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/ftok.3:29
#, no-wrap
msgid "FTOK"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:32
msgid ""
"ftok - convert a pathname and a project identifier to a System V IPC key"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:39
msgid "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:54
msgid ""
"The B<ftok>()  function uses the identity of the file named by the given "
"I<pathname> (which must refer to an existing, accessible file)  and the "
"least significant 8 bits of I<proj_id> (which must be nonzero) to generate a"
" I<key_t> type System V IPC key, suitable for use with B<msgget>(2), "
"B<semget>(2), or B<shmget>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:61
msgid ""
"The resulting value is the same for all pathnames that name the same file, "
"when the same value of I<proj_id> is used.  The value returned should be "
"different when the (simultaneously existing) files or the project IDs "
"differ."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:70
msgid ""
"On success, the generated I<key_t> value is returned.  On failure -1 is "
"returned, with I<errno> indicating the error as for the B<stat>(2)  system "
"call."
msgstr ""

#. type: tbl table
#: man-pages/man3/ftok.3:80
#, no-wrap
msgid "B<ftok>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:86
msgid "On some ancient systems, the prototype was:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:90
#, no-wrap
msgid "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:103
msgid ""
"Today, I<proj_id> is an I<int>, but still only 8 bits are used.  Typical "
"usage has an ASCII character I<proj_id>, that is why the behavior is said to"
" be undefined when I<proj_id> is zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:115
msgid ""
"Of course, no guarantee can be given that the resulting I<key_t> is unique."
"  Typically, a best-effort attempt combines the given I<proj_id> byte, the "
"lower 16 bits of the inode number, and the lower 8 bits of the device number"
" into a 32-bit result.  Collisions may easily happen, for example between "
"files on I</dev/hda1> and files on I</dev/sda1>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftok.3:120
msgid "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/fopen.3:44
#, no-wrap
msgid "FOPEN"
msgstr ""

#. type: TH
#: man-pages/man3/fopen.3:44
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:47
msgid "fopen, fdopen, freopen - stream open functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fopen(const char *>I<pathname>B<, const char *>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:54
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:56
#, no-wrap
msgid ""
"B<FILE *freopen(const char *>I<pathname>B<, const char *>I<mode>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:65
msgid "B<fdopen>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:71
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<pathname> and associates a stream with it."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:76
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (possibly followed by additional characters, as described below):"
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:76
#, no-wrap
msgid "B<r>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:80
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:80
#, no-wrap
msgid "B<r+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:84
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:84
#, no-wrap
msgid "B<w>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:88
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is"
" positioned at the beginning of the file."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:88
#, no-wrap
msgid "B<w+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:94
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the"
" file."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:94
#, no-wrap
msgid "B<a>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:99
msgid ""
"Open for appending (writing at end of file).  The file is created if it does"
" not exist.  The stream is positioned at the end of the file."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:99
#, no-wrap
msgid "B<a+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:108
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  Output is always appended to the end of the "
"file.  POSIX is silent on what the initial read position is when using this "
"mode.  For glibc, the initial file position for reading is at the beginning "
"of the file, but for Android/BSD/MacOS, the initial file position for "
"reading is at the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:121
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the two-"
"character strings described above.  This is strictly for compatibility with "
"C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX conforming "
"systems, including Linux.  (Other systems may treat text files and binary "
"files differently, and adding the \\(aqb\\(aq may be a good idea if you do "
"I/O to a binary file and expect that your program may be ported to non-UNIX "
"environments.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:124
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:129
msgid ""
"Any created file will have the mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:144
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note"
" that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or "
"B<fgetpos>(3)  operation between write and read operations on such a stream."
"  This operation may be an apparent no-op (as in I<fseek(..., 0L, SEEK_CUR)>"
" called for its synchronizing side effect)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:149
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at end-of-"
"file, as if preceded the call:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:153
#, no-wrap
msgid "fseek(stream, 0, SEEK_END);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:159
msgid ""
"The file descriptor associated with the stream is opened as if by a call to "
"B<open>(2)  with the following flags:"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:164
#, no-wrap
msgid "fopen() mode"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:164
#, no-wrap
msgid "open() flags"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:165
#, no-wrap
msgid "O_RDONLY"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:166
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_TRUNC"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:167
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_APPEND"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:168
#, no-wrap
msgid "O_RDWR"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:169
#, no-wrap
msgid "O_RDWR | O_CREAT | O_TRUNC"
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:170
#, no-wrap
msgid "O_RDWR | O_CREAT | O_APPEND"
msgstr ""

#. type: SS
#: man-pages/man3/fopen.3:174
#, no-wrap
msgid "fdopen()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:196
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", "
"\"r+\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of "
"the file descriptor.  The file position indicator of the new stream is set "
"to that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by"
" B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""

#. type: SS
#: man-pages/man3/fopen.3:196
#, no-wrap
msgid "freopen()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:210
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<pathname> and associates the stream pointed to by I<stream> with it."
"  The original stream (if it exists) is closed.  The I<mode> argument is "
"used just as in the B<fopen>()  function."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:221
msgid ""
"If the I<pathname> argument is a null pointer, B<freopen>()  changes the "
"mode of the stream to that specified in I<mode>; that is, B<freopen>()  "
"reopens the pathname that is associated with the stream.  The specification "
"for this behavior was added in the C99 standard, which says:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:230
msgid ""
"In this case, the file descriptor associated with the stream need not be "
"closed if the call to B<freopen>()  succeeds.  It is implementation-defined "
"which changes of mode are permitted (if any), and under what circumstances."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:236
msgid ""
"The primary use of the B<freopen>()  function is to change the file "
"associated with a standard text stream (I<stderr>, I<stdin>, or I<stdout>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:248
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>()  and B<freopen>()  return"
" a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:259
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:269
msgid ""
"The B<fopen>(), B<fdopen>()  and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:276
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:283
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:293
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3), and "
"B<fflush>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/fopen.3:305
#, no-wrap
msgid ""
"B<fopen>(),\n"
"B<fdopen>(),\n"
"B<freopen>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:311
msgid "B<fopen>(), B<freopen>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:314
msgid "B<fdopen>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:318
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:318
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:325
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points.  This flag is ignored for B<fdopen>()."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:325
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:335
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information.  This flag is ignored for B<fdopen>()."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:335
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr ""

#.  As at glibc 2.4:
#. type: Plain text
#: man-pages/man3/fopen.3:347
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is attempted only "
"for a file opened for reading."
msgstr ""

#. type: TP
#: man-pages/man3/fopen.3:347
#, no-wrap
msgid "B<x>"
msgstr ""

#.  Since glibc 2.0?
#.  FIXME . C11 specifies this flag
#. type: Plain text
#: man-pages/man3/fopen.3:364
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:372
msgid ""
"In addition to the above characters, B<fopen>()  and B<freopen>()  support "
"the following syntax in I<mode>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:374
msgid "B< ,ccs=>I<string>"
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:390
msgid ""
"The given I<string> is taken as the name of a coded character set and the "
"stream is marked as wide-oriented.  Thereafter, internal conversion "
"functions convert I/O to and from the character set I<string>.  If the "
"B<,ccs=>I<string> syntax is not specified, then the wide-orientation of the "
"stream is determined by the first file operation.  If that operation is a "
"wide-character operation, the stream is marked wide-oriented, and functions "
"to convert to the coded character set are loaded."
msgstr ""

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12685
#. type: Plain text
#: man-pages/man3/fopen.3:407
msgid ""
"When parsing for individual flag characters in I<mode> (i.e., the characters"
" preceding the \"ccs\" specification), the glibc implementation of "
"B<fopen>()  and B<freopen>()  limits the number of characters examined in "
"I<mode> to 7 (or, in glibc versions before 2.14, to 6, which was not enough "
"to include possible specifications such as \"rb+cmxe\").  The current "
"implementation of B<fdopen>()  parses at most 5 characters in I<mode>."
msgstr ""

#. type: Plain text
#: man-pages/man3/fopen.3:413
msgid ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3), "
"B<open_memstream>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ftime.3:30
#, no-wrap
msgid "FTIME"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:33
msgid "ftime - return date and time"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:35
msgid "B<#include E<lt>sys/timeb.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:37
msgid "B<int ftime(struct timeb *>I<tp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:43
msgid ""
"This function returns the current time as seconds and milliseconds since the"
" Epoch, 1970-01-01 00:00:00 +0000 (UTC).  The time is returned in I<tp>, "
"which is declared as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:52
#, no-wrap
msgid ""
"struct timeb {\n"
"    time_t         time;\n"
"    unsigned short millitm;\n"
"    short          timezone;\n"
"    short          dstflag;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:64
msgid ""
"Here I<time> is the number of seconds since the Epoch, and I<millitm> is the"
" number of milliseconds since I<time> seconds since the Epoch.  The "
"I<timezone> field is the local timezone measured in minutes of time west of "
"Greenwich (with a negative value indicating minutes east of Greenwich).  The"
" I<dstflag> field is a flag that, if nonzero, indicates that Daylight Saving"
" time applies locally during the appropriate part of the year."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:67
msgid ""
"POSIX.1-2001 says that the contents of the I<timezone> and I<dstflag> fields"
" are unspecified; avoid relying on them."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:70
msgid ""
"This function always returns 0.  (POSIX.1-2001 specifies, and some systems "
"document, a -1 error return.)"
msgstr ""

#. type: tbl table
#: man-pages/man3/ftime.3:80
#, no-wrap
msgid "B<ftime>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:86
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of B<ftime>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:97
msgid ""
"This function is obsolete.  Don't use it.  If the time in seconds suffices, "
"B<time>(2)  can be used; B<gettimeofday>(2)  gives microseconds; "
"B<clock_gettime>(2)  gives nanoseconds but is not as widely available."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR ftime ()
#.  function appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man3/ftime.3:107
msgid ""
"Early glibc2 is buggy and returns 0 in the I<millitm> field; glibc 2.1.1 is "
"correct again."
msgstr ""

#. type: Plain text
#: man-pages/man3/ftime.3:109
msgid "B<gettimeofday>(2), B<time>(2)"
msgstr ""
