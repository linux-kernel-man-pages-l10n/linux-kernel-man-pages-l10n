# Copyright (C) 2014 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2014.
# Yuri Kozlov <yuray@komyakino.ru>, 2013.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2013-10-12 09:15+0400\n"
"PO-Revision-Date: 2014-09-10 11:57+0400\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<"
"=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "FULL"
msgstr "FULL"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "2007-11-24"
msgstr "2007-11-24"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/full.4:27
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/full.4:29
msgid "full - always full device"
msgstr "full - всегда полное устройство"

#. type: SH
#: man-pages/man4/full.4:29
#, no-wrap
msgid "CONFIGURATION"
msgstr "НАСТРОЙКА"

#. type: Plain text
#: man-pages/man4/full.4:34
msgid ""
"If your system does not have I</dev/full> created already, it can be created"
" with the following commands:"
msgstr ""
"Если в системе нет файла I</dev/full>, то его можно создать при помощи "
"следующих команд:"

#. type: Plain text
#: man-pages/man4/full.4:38
#, no-wrap
msgid ""
"        mknod -m 666 /dev/full c 1 7\n"
"        chown root:root /dev/full\n"
msgstr ""
"        mknod -m 666 /dev/full c 1 7\n        chown root:root /dev/full\n"

#. type: SH
#: man-pages/man4/full.4:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/full.4:44
msgid "File I</dev/full> has major device number 1 and minor device number 7."
msgstr ""
"Файл I</dev/full> имеет основной номер устройства, равный 1, и "
"второстепенный, равный 7."

#. type: Plain text
#: man-pages/man4/full.4:51
msgid ""
"Writes to the I</dev/full> device will fail with an B<ENOSPC> error.  This "
"can be used to test how a program handles disk-full errors."
msgstr ""
"При записи в файл I</dev/full> будет возвращено сообщение об ошибке B<ENOSPC>"
". Это можно использовать на программе для проверки обработки ошибки "
"переполнения диска."

#. type: Plain text
#: man-pages/man4/full.4:55
msgid "Reads from the I</dev/full> device will return \\e0 characters."
msgstr "При попытке чтения файла I</dev/full> будут возвращаться символы \\e0."

#. type: Plain text
#: man-pages/man4/full.4:59
msgid "Seeks on I</dev/full> will always succeed."
msgstr "Перемещение по I</dev/full> всегда выполняется успешно."

#. type: SH
#: man-pages/man4/full.4:59
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/full.4:61
msgid "/dev/full"
msgstr "/dev/full"

#. type: SH
#: man-pages/man4/full.4:61
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/full.4:64
msgid "B<mknod>(1), B<null>(4), B<zero>(4)"
msgstr "B<mknod>(1), B<null>(4), B<zero>(4)"

#. type: TH
#: man-pages/man4/fd.4:28
#, no-wrap
msgid "FD"
msgstr "FD"

#. type: TH
#: man-pages/man4/fd.4:28
#, no-wrap
msgid "2014-05-10"
msgstr "2014-05-10"

#. type: Plain text
#: man-pages/man4/fd.4:31
msgid "fd - floppy disk device"
msgstr "fd - устройство для работы с дисководом"

#. type: Plain text
#: man-pages/man4/fd.4:48
msgid ""
"Floppy drives are block devices with major number 2.  Typically they are "
"owned by I<root.floppy> (i.e., user root, group floppy) and have either mode"
" 0660 (access checking via group membership) or mode 0666 (everybody has "
"access).  The minor numbers encode the device type, drive number, and "
"controller number.  For each device type (that is, combination of density "
"and track count)  there is a base minor number.  To this base number, add "
"the drive's number on its controller and 128 if the drive is on the "
"secondary controller.  In the following device tables, I<n> represents the "
"drive number."
msgstr ""
"Дисководы гибких дисков — это блочные устройства со старшим номером 2. Обычно "
"их владельцем является I<root.floppy> (т.е. пользователь root, группа "
"floppy), а права доступа к ним — 0660 (доступно членам группы) или 0666 "
"(доступно всем). Младшим номером определяется тип устройства, номер "
"устройства и номер контроллера. Для каждого типа устройства, то есть "
"комбинации объёма и количества дорожек, существует базовый младший номер. К "
"этому базовому номеру прибавьте номер устройства в пределах его контроллера и "
"ещё 128, если дисковод подключен к вторичному контроллеру. В нижеследующих "
"таблицах I<n> означает номер дисковода."

#. type: Plain text
#: man-pages/man4/fd.4:55
msgid ""
"B<Warning: If you use formats with more tracks than supported by your drive,"
" you may cause it mechanical damage.> Trying once if more tracks than the "
"usual 40/80 are supported should not damage it, but no warranty is given for"
" that.  If you are not sure, don't create device entries for those formats, "
"so as to prevent their usage."
msgstr ""
"B<Предупреждение: Если вы используете формат дискет с большим числом дорожек, "
"чем поддерживает ваш дисковод, вы можете вызвать механическое повреждение.> "
"Однократная попытка поработать с числом дорожек больше обычных 40/80, не "
"должна его повредить, но нет гарантии, что этого не произойдет. Если вы не "
"уверены, не создавайте устройства для таких форматов, чтобы предотвратить их "
"использование."

#. type: Plain text
#: man-pages/man4/fd.4:58
msgid ""
"Drive-independent device files which automatically detect the media format "
"and capacity:"
msgstr ""
"Файлы устройств, не зависящие от дисковода, которые автоматически определяют "
"формат носителя и ёмкость диска:"

#. type: tbl table
#: man-pages/man4/fd.4:60
#, no-wrap
msgid "Name\tBase minor #\n"
msgstr "Имя\tБазовый младший #\n"

#. type: tbl table
#: man-pages/man4/fd.4:61 man-pages/man4/fd.4:69 man-pages/man4/fd.4:77
#: man-pages/man4/fd.4:94 man-pages/man4/fd.4:106 man-pages/man4/fd.4:125
#, no-wrap
msgid "_\n"
msgstr "_\n"

#. type: tbl table
#: man-pages/man4/fd.4:62
#, no-wrap
msgid "B<fd>I<n>\t0\n"
msgstr "B<fd>I<n>\t0\n"

#. type: Plain text
#: man-pages/man4/fd.4:66
msgid "5.25 inch double-density device files:"
msgstr "Файлы устройств с носителями 5.25 дюймов с двойной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:68 man-pages/man4/fd.4:76 man-pages/man4/fd.4:93
#: man-pages/man4/fd.4:105 man-pages/man4/fd.4:124
#, no-wrap
msgid "Name\tCapac.\tCyl.\tSect.\tHeads\tBase minor #\n"
msgstr "Имя\tЁмк.\tЦил.\tСек.\tГоловок\tБазовый младший #\n"

#. type: tbl table
#: man-pages/man4/fd.4:70
#, no-wrap
msgid "B<fd>I<n>B<d360>\t360K\t40\t9\t2\t4\n"
msgstr "B<fd>I<n>B<d360>\t360K\t40\t9\t2\t4\n"

#. type: Plain text
#: man-pages/man4/fd.4:74
msgid "5.25 inch high-density device files:"
msgstr "Файлы устройств с носителями 5.25 дюймов повышенной плотности:"

#. type: tbl table
#: man-pages/man4/fd.4:78
#, no-wrap
msgid "B<fd>I<n>B<h360>\t360K\t40\t9\t2\t20\n"
msgstr "B<fd>I<n>B<h360>\t360K\t40\t9\t2\t20\n"

#. type: tbl table
#: man-pages/man4/fd.4:79
#, no-wrap
msgid "B<fd>I<n>B<h410>\t410K\t41\t10\t2\t48\n"
msgstr "B<fd>I<n>B<h410>\t410K\t41\t10\t2\t48\n"

#. type: tbl table
#: man-pages/man4/fd.4:80
#, no-wrap
msgid "B<fd>I<n>B<h420>\t420K\t42\t10\t2\t64\n"
msgstr "B<fd>I<n>B<h420>\t420K\t42\t10\t2\t64\n"

#. type: tbl table
#: man-pages/man4/fd.4:81
#, no-wrap
msgid "B<fd>I<n>B<h720>\t720K\t80\t9\t2\t24\n"
msgstr "B<fd>I<n>B<h720>\t720K\t80\t9\t2\t24\n"

#. type: tbl table
#: man-pages/man4/fd.4:82
#, no-wrap
msgid "B<fd>I<n>B<h880>\t880K\t80\t11\t2\t80\n"
msgstr "B<fd>I<n>B<h880>\t880K\t80\t11\t2\t80\n"

#. type: tbl table
#: man-pages/man4/fd.4:83
#, no-wrap
msgid "B<fd>I<n>B<h1200>\t1200K\t80\t15\t2\t8\n"
msgstr "B<fd>I<n>B<h1200>\t1200K\t80\t15\t2\t8\n"

#. type: tbl table
#: man-pages/man4/fd.4:84
#, no-wrap
msgid "B<fd>I<n>B<h1440>\t1440K\t80\t18\t2\t40\n"
msgstr "B<fd>I<n>B<h1440>\t1440K\t80\t18\t2\t40\n"

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "B<fd>I<n>B<h1476>\t1476K\t82\t18\t2\t56\n"
msgstr "B<fd>I<n>B<h1476>\t1476K\t82\t18\t2\t56\n"

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "B<fd>I<n>B<h1494>\t1494K\t83\t18\t2\t72\n"
msgstr "B<fd>I<n>B<h1494>\t1494K\t83\t18\t2\t72\n"

#. type: tbl table
#: man-pages/man4/fd.4:87
#, no-wrap
msgid "B<fd>I<n>B<h1600>\t1600K\t80\t20\t2\t92\n"
msgstr "B<fd>I<n>B<h1600>\t1600K\t80\t20\t2\t92\n"

#. type: Plain text
#: man-pages/man4/fd.4:91
msgid "3.5 inch double-density device files:"
msgstr "Файлы устройств с носителями 3.5 дюймов с двойной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:95
#, no-wrap
msgid "B<fd>I<n>B<u360>\t360K\t80\t9\t1\t12\n"
msgstr "B<fd>I<n>B<u360>\t360K\t80\t9\t1\t12\n"

#. type: tbl table
#: man-pages/man4/fd.4:96 man-pages/man4/fd.4:108
#, no-wrap
msgid "B<fd>I<n>B<u720>\t720K\t80\t9\t2\t16\n"
msgstr "B<fd>I<n>B<u720>\t720K\t80\t9\t2\t16\n"

#. type: tbl table
#: man-pages/man4/fd.4:97
#, no-wrap
msgid "B<fd>I<n>B<u800>\t800K\t80\t10\t2\t120\n"
msgstr "B<fd>I<n>B<u800>\t800K\t80\t10\t2\t120\n"

#. type: tbl table
#: man-pages/man4/fd.4:98
#, no-wrap
msgid "B<fd>I<n>B<u1040>\t1040K\t80\t13\t2\t84\n"
msgstr "B<fd>I<n>B<u1040>\t1040K\t80\t13\t2\t84\n"

#. type: tbl table
#: man-pages/man4/fd.4:99
#, no-wrap
msgid "B<fd>I<n>B<u1120>\t1120K\t80\t14\t2\t88\n"
msgstr "B<fd>I<n>B<u1120>\t1120K\t80\t14\t2\t88\n"

#. type: Plain text
#: man-pages/man4/fd.4:103
msgid "3.5 inch high-density device files:"
msgstr "Файлы устройств с носителями 3.5 дюймов повышенной плотности:"

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "B<fd>I<n>B<u360>\t360K\t40\t9\t2\t12\n"
msgstr "B<fd>I<n>B<u360>\t360K\t40\t9\t2\t12\n"

#. type: tbl table
#: man-pages/man4/fd.4:109
#, no-wrap
msgid "B<fd>I<n>B<u820>\t820K\t82\t10\t2\t52\n"
msgstr "B<fd>I<n>B<u820>\t820K\t82\t10\t2\t52\n"

#. type: tbl table
#: man-pages/man4/fd.4:110
#, no-wrap
msgid "B<fd>I<n>B<u830>\t830K\t83\t10\t2\t68\n"
msgstr "B<fd>I<n>B<u830>\t830K\t83\t10\t2\t68\n"

#. type: tbl table
#: man-pages/man4/fd.4:111
#, no-wrap
msgid "B<fd>I<n>B<u1440>\t1440K\t80\t18\t2\t28\n"
msgstr "B<fd>I<n>B<u1440>\t1440K\t80\t18\t2\t28\n"

#. type: tbl table
#: man-pages/man4/fd.4:112
#, no-wrap
msgid "B<fd>I<n>B<u1600>\t1600K\t80\t20\t2\t124\n"
msgstr "B<fd>I<n>B<u1600>\t1600K\t80\t20\t2\t124\n"

#. type: tbl table
#: man-pages/man4/fd.4:113
#, no-wrap
msgid "B<fd>I<n>B<u1680>\t1680K\t80\t21\t2\t44\n"
msgstr "B<fd>I<n>B<u1680>\t1680K\t80\t21\t2\t44\n"

#. type: tbl table
#: man-pages/man4/fd.4:114
#, no-wrap
msgid "B<fd>I<n>B<u1722>\t1722K\t82\t21\t2\t60\n"
msgstr "B<fd>I<n>B<u1722>\t1722K\t82\t21\t2\t60\n"

#. type: tbl table
#: man-pages/man4/fd.4:115
#, no-wrap
msgid "B<fd>I<n>B<u1743>\t1743K\t83\t21\t2\t76\n"
msgstr "B<fd>I<n>B<u1743>\t1743K\t83\t21\t2\t76\n"

#. type: tbl table
#: man-pages/man4/fd.4:116
#, no-wrap
msgid "B<fd>I<n>B<u1760>\t1760K\t80\t22\t2\t96\n"
msgstr "B<fd>I<n>B<u1760>\t1760K\t80\t22\t2\t96\n"

#. type: tbl table
#: man-pages/man4/fd.4:117
#, no-wrap
msgid "B<fd>I<n>B<u1840>\t1840K\t80\t23\t2\t116\n"
msgstr "B<fd>I<n>B<u1840>\t1840K\t80\t23\t2\t116\n"

#. type: tbl table
#: man-pages/man4/fd.4:118
#, no-wrap
msgid "B<fd>I<n>B<u1920>\t1920K\t80\t24\t2\t100\n"
msgstr "B<fd>I<n>B<u1920>\t1920K\t80\t24\t2\t100\n"

#. type: Plain text
#: man-pages/man4/fd.4:122
msgid "3.5 inch extra-density device files:"
msgstr "Файлы устройств 3.5 дюймов с дополнительной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "B<fd>I<n>B<u2880>\t2880K\t80\t36\t2\t32\n"
msgstr "B<fd>I<n>B<u2880>\t2880K\t80\t36\t2\t32\n"

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "B<fd>I<n>B<CompaQ>\t2880K\t80\t36\t2\t36\n"
msgstr "B<fd>I<n>B<CompaQ>\t2880K\t80\t36\t2\t36\n"

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "B<fd>I<n>B<u3200>\t3200K\t80\t40\t2\t104\n"
msgstr "B<fd>I<n>B<u3200>\t3200K\t80\t40\t2\t104\n"

#. type: tbl table
#: man-pages/man4/fd.4:129
#, no-wrap
msgid "B<fd>I<n>B<u3520>\t3520K\t80\t44\t2\t108\n"
msgstr "B<fd>I<n>B<u3520>\t3520K\t80\t44\t2\t108\n"

#. type: tbl table
#: man-pages/man4/fd.4:130
#, no-wrap
msgid "B<fd>I<n>B<u3840>\t3840K\t80\t48\t2\t112\n"
msgstr "B<fd>I<n>B<u3840>\t3840K\t80\t48\t2\t112\n"

#. type: Plain text
#: man-pages/man4/fd.4:137
msgid ""
"B<fd> special files access the floppy disk drives in raw mode.  The "
"following B<ioctl>(2)  calls are supported by B<fd> devices:"
msgstr ""
"Специальные файлы B<fd> обеспечивают доступ к дисководам в режиме без "
"обработки (raw mode). Устройства B<fd> поддерживают следующие вызовы B<ioctl>"
"(2):"

#. type: IP
#: man-pages/man4/fd.4:137
#, no-wrap
msgid "B<FDCLRPRM>"
msgstr "B<FDCLRPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:139
msgid "clears the media information of a drive (geometry of disk in drive)."
msgstr ""
"Очищает информацию о носителе в дисководе (геометрию диска в дисководе)."

#. type: IP
#: man-pages/man4/fd.4:139
#, no-wrap
msgid "B<FDSETPRM>"
msgstr "B<FDSETPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:143
msgid ""
"sets the media information of a drive.  The media information will be lost "
"when the media is changed."
msgstr ""
"Устанавливает информацию о носителе в дисководе. Информация о носителе "
"потеряется, когда носитель будет сменён."

#. type: IP
#: man-pages/man4/fd.4:143
#, no-wrap
msgid "B<FDDEFPRM>"
msgstr "B<FDDEFPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:149
msgid ""
"sets the media information of a drive (geometry of disk in drive).  The "
"media information will not be lost when the media is changed.  This will "
"disable autodetection.  In order to reenable autodetection, you have to "
"issue an B<FDCLRPRM>."
msgstr ""
"Устанавливает информацию о носителе в дисководе (геометрию диска в "
"дисководе). Информация о носителе не будет потеряна, когда носитель будет "
"сменён. При этом автоопределение носителя будет выключено. Чтобы снова его "
"включить, выполните B<FDCLRPRM>."

#. type: IP
#: man-pages/man4/fd.4:149 man-pages/man4/fd.4:161
#, no-wrap
msgid "B<FDGETDRVTYP>"
msgstr "B<FDGETDRVTYP>"

#. type: Plain text
#: man-pages/man4/fd.4:154
msgid ""
"returns the type of a drive (name parameter).  For formats which work in "
"several drive types, B<FDGETDRVTYP> returns a name which is appropriate for "
"the oldest drive type which supports this format."
msgstr ""
"Возвращает тип дисковода (параметр имени). Для форматов, работающих на "
"нескольких типах дисководов, B<FDGETDRVTYP> возвращает имя, соответствующее "
"самому старому типу дисковода, который поддерживает данный формат."

#. type: IP
#: man-pages/man4/fd.4:154
#, no-wrap
msgid "B<FDFLUSH>"
msgstr "B<FDFLUSH>"

#. type: Plain text
#: man-pages/man4/fd.4:156
msgid "invalidates the buffer cache for the given drive."
msgstr "Объявляет недействительными данные буферного кэша указанного привода."

#. type: IP
#: man-pages/man4/fd.4:156 man-pages/man4/fd.4:159
#, no-wrap
msgid "B<FDSETMAXERRS>"
msgstr "B<FDSETMAXERRS>"

#. type: Plain text
#: man-pages/man4/fd.4:159
msgid ""
"sets the error thresholds for reporting errors, aborting the operation, "
"recalibrating, resetting, and reading sector by sector."
msgstr ""
"Устанавливает пороговые значения для сообщения об ошибках, остановки "
"действий, перекалибровки, сброса в начальное состояние и посекторного чтения."

#. type: Plain text
#: man-pages/man4/fd.4:161
msgid "gets the current error thresholds."
msgstr "Возвращает текущие пороговые значения для ошибок."

#. type: Plain text
#: man-pages/man4/fd.4:163
msgid "gets the internal name of the drive."
msgstr "Возвращает внутреннее имя дисковода. "

#. type: IP
#: man-pages/man4/fd.4:163
#, no-wrap
msgid "B<FDWERRORCLR>"
msgstr "B<FDWERRORCLR>"

#. type: Plain text
#: man-pages/man4/fd.4:165
msgid "clears the write error statistics."
msgstr "Очищает статистику ошибок записи."

#. type: IP
#: man-pages/man4/fd.4:165
#, no-wrap
msgid "B<FDWERRORGET>"
msgstr "B<FDWERRORGET>"

#. type: Plain text
#: man-pages/man4/fd.4:172
msgid ""
"reads the write error statistics.  These include the total number of write "
"errors, the location and disk of the first write error, and the location and"
" disk of the last write error.  Disks are identified by a generation number "
"which is incremented at (almost) each disk change."
msgstr ""
"Читает статистику ошибок записи. Она включает общее число ошибок записи, "
"расположение и диск, на котором произошла первая ошибка записи, и "
"расположение и диск, на котором произошла последняя ошибка записи. Диски "
"обозначаются генерирующимся числом, которое увеличивается на единицу при "
"(почти) каждой смене диска."

#. type: IP
#: man-pages/man4/fd.4:172
#, no-wrap
msgid "B<FDTWADDLE>"
msgstr "B<FDTWADDLE>"

#. type: Plain text
#: man-pages/man4/fd.4:176
msgid ""
"Switch the drive motor off for a few microseconds.  This might be needed in "
"order to access a disk whose sectors are too close together."
msgstr ""
"Выключает на несколько микросекунд мотор привода. Это может быть необходимо "
"для получения доступа к диску, чьи сектора располагаются слишком близко друг "
"к другу."

#. type: IP
#: man-pages/man4/fd.4:176
#, no-wrap
msgid "B<FDSETDRVPRM>"
msgstr "B<FDSETDRVPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:178
msgid "sets various drive parameters."
msgstr "Устанавливает различные параметры дисковода."

#. type: IP
#: man-pages/man4/fd.4:178
#, no-wrap
msgid "B<FDGETDRVPRM>"
msgstr "B<FDGETDRVPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:180
msgid "reads these parameters back."
msgstr "Возвращает различные параметры."

#. type: IP
#: man-pages/man4/fd.4:180
#, no-wrap
msgid "B<FDGETDRVSTAT>"
msgstr "B<FDGETDRVSTAT>"

#. type: Plain text
#: man-pages/man4/fd.4:182
msgid "gets the cached drive state (disk changed, write protected et al.)"
msgstr ""
"Возвращает кэшированное состояние дисковода (диск сменён, защищён от записи и "
"т. д.)"

#. type: IP
#: man-pages/man4/fd.4:182
#, no-wrap
msgid "B<FDPOLLDRVSTAT>"
msgstr "B<FDPOLLDRVSTAT>"

#. type: Plain text
#: man-pages/man4/fd.4:184
msgid "polls the drive and return its state."
msgstr "Обращается к дисководу и возвращает его состояние."

#. type: IP
#: man-pages/man4/fd.4:184
#, no-wrap
msgid "B<FDGETFDCSTAT>"
msgstr "B<FDGETFDCSTAT>"

#. type: Plain text
#: man-pages/man4/fd.4:186
msgid "gets the floppy controller state."
msgstr "Возвращает состояние контроллера дисководов."

#. type: IP
#: man-pages/man4/fd.4:186
#, no-wrap
msgid "B<FDRESET>"
msgstr "B<FDRESET>"

#. type: Plain text
#: man-pages/man4/fd.4:188
msgid "resets the floppy controller under certain conditions."
msgstr ""
"Сбрасывает в начальное состояние контроллер дисководов при определённых "
"условиях."

#. type: IP
#: man-pages/man4/fd.4:188
#, no-wrap
msgid "B<FDRAWCMD>"
msgstr "B<FDRAWCMD>"

#. type: Plain text
#: man-pages/man4/fd.4:190
msgid "sends a raw command to the floppy controller."
msgstr ""
"Посылает команду в необработанном виде (raw command) контроллеру дисководов."

#. type: Plain text
#: man-pages/man4/fd.4:195
msgid ""
"For more precise information, consult also the I<E<lt>linux/fd.hE<gt>> and "
"I<E<lt>linux/fdreg.hE<gt>> include files, as well as the B<floppycontrol>(1)"
"  manual page."
msgstr ""
"За более точной информацией обратитесь также к файлам  I<E<lt>linux/fd.hE<gt>>"
" и I<E<lt>linux/fdreg.hE<gt>>, а также к справочной странице B<floppycontrol>"
"(1)."

#. type: Plain text
#: man-pages/man4/fd.4:197
msgid "/dev/fd*"
msgstr "/dev/fd*"

#. type: SH
#: man-pages/man4/fd.4:197
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/fd.4:203
msgid ""
"The various formats permit reading and writing many types of disks.  "
"However, if a floppy is formatted with an inter-sector gap that is too "
"small, performance may drop, to the point of needing a few seconds to access"
" an entire track.  To prevent this, use interleaved formats."
msgstr ""
"Разные форматы позволяют читать и записывать многие типы дисков. Однако, если "
"дискета отформатирована со слишком маленьким межсекторным промежутком, "
"производительность может снизиться вплоть до того, что для доступа к дорожке "
"может понадобиться несколько секунд. Во избежание этого, используйте "
"перемежающиеся (interleaved) форматы."

#. type: Plain text
#: man-pages/man4/fd.4:207
msgid ""
"It is not possible to read floppies which are formatted using GCR (group "
"code recording), which is used by Apple II and Macintosh computers (800k "
"disks)."
msgstr ""
"Невозможно прочитать дискеты, отформатированные с использованием GCR "
"(групповая запись кодов), которые используются компьютерами Apple II и "
"Macintosh (диски 800k)."

#.  .SH AUTHORS
#.  Alain Knaff (Alain.Knaff@imag.fr), David Niemi
#.  (niemidc@clark.net), Bill Broadhurst (bbroad@netcom.com).
#. type: Plain text
#: man-pages/man4/fd.4:214
msgid ""
"Reading floppies which are hard sectored (one hole per sector, with the "
"index hole being a little skewed) is not supported.  This used to be common "
"with older 8-inch floppies."
msgstr ""
"Чтение аппаратно размеченных на секторы дискет (с отверстием на каждый сектор "
"и слегка повернутым индексным отверстием) не поддерживается. Такими были "
"старые 8-дюймовые дискеты."

#. type: Plain text
#: man-pages/man4/fd.4:221
msgid ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), "
"B<superformat>(1), B<mount>(8), B<setfdprm>(8)"
msgstr ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), B<superformat>"
"(1), B<mount>(8), B<setfdprm>(8)"

#. type: TH
#: man-pages/man7/fanotify.7:25
#, no-wrap
msgid "FANOTIFY"
msgstr "FANOTIFY"

#. type: TH
#: man-pages/man7/fanotify.7:25
#, no-wrap
msgid "2014-05-21"
msgstr "2014-05-21"

#. type: Plain text
#: man-pages/man7/fanotify.7:28
msgid "fanotify - monitoring filesystem events"
msgstr "fanotify - отслеживание событий в файловой системе"

#. type: Plain text
#: man-pages/man7/fanotify.7:37
msgid ""
"The fanotify API provides notification and interception of filesystem "
"events.  Use cases include virus scanning and hierarchical storage "
"management.  Currently, only a limited set of events is supported.  In "
"particular, there is no support for create, delete, and move events.  (See "
"B<inotify>(7)  for details of an API that does notify those events.)"
msgstr ""
"Программный интерфейс fanotify уведомляет о событиях в файловой системе и "
"перехватывает их. Например, его можно использовать для сканирования файлов на "
"вирусы и управления иерархическим хранилищем. В настоящее время, "
"поддерживается только ограниченный набор событий. В частности, не "
"поддерживаются события создания, удаления и перемещения (о программном "
"интерфейсе для этих событий смотрите в B<inotify>(7))."

#. type: Plain text
#: man-pages/man7/fanotify.7:44
msgid ""
"Additional capabilities compared to the B<inotify>(7)  API include the "
"ability to monitor all of the objects in a mounted filesystem, the ability "
"to make access permission decisions, and the possibility to read or modify "
"files before access by other applications."
msgstr ""
"Дополнительные возможности по сравнению с программным интерфейсом B<inotify>"
"(7): способность отслеживать все объекты в смонтированной файловой системе, "
"давать права на доступ и читать или изменять файлы перед тем как доступ "
"получат другие приложения."

#. type: Plain text
#: man-pages/man7/fanotify.7:52
msgid ""
"The following system calls are used with this API: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""
"В программный интерфейс входят следующие системные вызовы: B<fanotify_init>"
"(2), B<fanotify_mark>(2), B<read>(2), B<write>(2) и B<close>(2)."

#. type: SS
#: man-pages/man7/fanotify.7:52
#, no-wrap
msgid "fanotify_init(), fanotify_mark(), and notification groups"
msgstr "Вызовы fanotify_init(), fanotify_mark() и группы уведомлений"

#. type: Plain text
#: man-pages/man7/fanotify.7:57
msgid ""
"The B<fanotify_init>(2)  system call creates and initializes an fanotify "
"notification group and returns a file descriptor referring to it."
msgstr ""
"Системный вызов B<fanotify_init>(2) создаёт и инициализирует группу "
"уведомления fanotify и возвращает указывающий на неё файловый дескриптор."

#. type: Plain text
#: man-pages/man7/fanotify.7:61
msgid ""
"An fanotify notification group is a kernel-internal object that holds a list"
" of files, directories, and mount points for which events shall be created."
msgstr ""
"Группа уведомления fanotify — это внутренний объект ядра, в котором хранится "
"список файлов, каталогов и точек монтирования, для которых должны создаваться "
"события."

#. type: Plain text
#: man-pages/man7/fanotify.7:72
msgid ""
"For each entry in an fanotify notification group, two bit masks exist: the "
"I<mark> mask and the I<ignore> mask.  The mark mask defines file activities "
"for which an event shall be created.  The ignore mask defines activities for"
" which no event shall be generated.  Having these two types of masks permits"
" a mount point or directory to be marked for receiving events, while at the "
"same time ignoring events for specific objects under that mount point or "
"directory."
msgstr ""
"У каждой записи в группе уведомления fanotify есть две битовые маски: I<меток>"
" и I<игнорирования>. В маске меток указывается для каких действий на файлами "
"должны создаваться события. В маске игнорирования указывается для каких "
"действий не должны создаваться события. Имея маски таких типов можно пометить "
"точку монтирования или каталог для получения событий, и в тоже время "
"игнорировать события для определённых объектов в этой точке монтирования или "
"каталоге."

#. type: Plain text
#: man-pages/man7/fanotify.7:78
msgid ""
"The B<fanotify_mark>(2)  system call adds a file, directory, or mount to a "
"notification group and specifies which events shall be reported (or "
"ignored), or removes or modifies such an entry."
msgstr ""
"Системный вызов B<fanotify_mark>(2) добавляет файл, каталог или точку "
"монтирования в группу уведомления и задаёт какие события должны отслеживаться "
"(или игнорироваться), или удаляет или изменяет нужную запись."

#. type: Plain text
#: man-pages/man7/fanotify.7:91
msgid ""
"A possible usage of the ignore mask is for a file cache.  Events of interest"
" for a file cache are modification of a file and closing of the same.  "
"Hence, the cached directory or mount point is to be marked to receive these "
"events.  After receiving the first event informing that a file has been "
"modified, the corresponding cache entry will be invalidated.  No further "
"modification events for this file are of interest until the file is closed."
"  Hence, the modify event can be added to the ignore mask.  Upon receiving "
"the close event, the modify event can be removed from the ignore mask and "
"the file cache entry can be updated."
msgstr ""
"Возможное применение маски игнорирования — кэш файлов. Интересующие события "
"для файлового кэша — изменение файла и закрытие. Для этого добавляем "
"кэшируемый каталог или точку монтирования для приёма этих событий. После "
"получения первого события об изменении файла, соответствующая запись кэша "
"помечается как недействительная. Дальнейшие события об изменении файла нас не "
"интересуют, пока файл не будет закрыт. Для этого событие об изменении можно "
"добавить в маску игнорирования. При получении события о закрытии, событие об "
"изменении можно удалить из маски игнорирования и запись файлового кэша можно "
"обновить."

#. type: Plain text
#: man-pages/man7/fanotify.7:98
msgid ""
"The entries in the fanotify notification groups refer to files and "
"directories via their inode number and to mounts via their mount ID.  If "
"files or directories are renamed or moved, the respective entries survive.  "
"If files or directories are deleted or mounts are unmounted, the "
"corresponding entries are deleted."
msgstr ""
"Записи в группе уведомления fanotify ссылаются на файл и каталог по номеру "
"иноды (inode), а на точку монтирования — через ID монтирования. При "
"переименовании или перемещении файла или каталога, соответствующая запись "
"остаётся. Если файл или каталог удаляется, а точка монтирования "
"размонтируется, то соответствующая запись удаляется."

#. type: SS
#: man-pages/man7/fanotify.7:98
#, no-wrap
msgid "The event queue"
msgstr "Очередь событий"

#. type: Plain text
#: man-pages/man7/fanotify.7:107
msgid ""
"As events occur on the filesystem objects monitored by a notification group,"
" the fanotify system generates events that are collected in a queue.  These "
"events can then be read (using B<read>(2)  or similar)  from the fanotify "
"file descriptor returned by B<fanotify_init>(2)."
msgstr ""
"Для возникающих событий с объектами файловой системы, которые отслеживаются "
"группой уведомления, система fanotify генерирует события и помещает их в "
"очередь. После этого события можно прочитать (с помощью B<read>(2) и "
"подобных) из файлового дескриптора fanotify, возвращённого B<fanotify_init>"
"(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:121
msgid ""
"Two types of events are generated: I<notification> events and I<permission> "
"events.  Notification events are merely informative and require no action to"
" be taken by the receiving application except for closing the file "
"descriptor passed in the event (see below).  Permission events are requests "
"to the receiving application to decide whether permission for a file access "
"shall be granted.  For these events, the recipient must write a response "
"which decides whether access is granted or not."
msgstr ""
"Генерируется два типа событий: события I<уведомления> и события I<доступа>. "
"Уведомляющие события просто информируют и не требуют действия от принявшего "
"приложения, за исключением закрытия файлового дескриптора, передаваемого в "
"событии (смотрите далее). События доступа запрашивают получившее приложение о "
"разрешении доступа к файлу. Для этих событий получатель должен написать "
"ответ, давать ли доступ или нет."

#. type: Plain text
#: man-pages/man7/fanotify.7:128
msgid ""
"An event is removed from the event queue of the fanotify group when it has "
"been read.  Permission events that have been read are kept in an internal "
"list of the fanotify group until either a permission decision has been taken"
" by writing to the fanotify file descriptor or the fanotify file descriptor "
"is closed."
msgstr ""
"Событие удаляется из очереди событий группы fanotify после прочтения. События "
"доступа, которые были прочитаны, остаются во внутреннем списке группы "
"fanotify до тех пор, пока решение о доступе не будет записано в файловый "
"дескриптор fanotify, или файловый дескриптор fanotify не будет закрыт."

#. type: SS
#: man-pages/man7/fanotify.7:128
#, no-wrap
msgid "Reading fanotify events"
msgstr "Чтение событий fanotify"

#. type: Plain text
#: man-pages/man7/fanotify.7:140
msgid ""
"Calling B<read>(2)  for the file descriptor returned by B<fanotify_init>(2)"
"  blocks (if the flag B<FAN_NONBLOCK> is not specified in the call to "
"B<fanotify_init>(2))  until either a file event occurs or the call is "
"interrupted by a signal (see B<signal>(7))."
msgstr ""
"Вызов B<read>(2) с файловым дескриптором, полученным от B<fanotify_init>(2), "
"блокирует выполнение (если не указан флаг B<FAN_NONBLOCK> в вызове B<"
"fanotify_init>(2)) до тех пор, пока не произойдёт файловое событие или вызов "
"не будет прерван сигналом (смотрите B<signal>(7))."

#. type: Plain text
#: man-pages/man7/fanotify.7:144
msgid ""
"After a successful B<read>(2), the read buffer contains one or more of the "
"following structures:"
msgstr ""
"После успешного выполнения B<read>(2) буфер чтения содержит одну или более "
"следующих структур:"

#. type: Plain text
#: man-pages/man7/fanotify.7:156
#, no-wrap
msgid ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"
msgstr ""
"struct fanotify_event_metadata {\n    __u32 event_len;\n    __u8 vers;\n    "
"__u8 reserved;\n    __u16 metadata_len;\n    __aligned_u64 mask;\n    __s32 "
"fd;\n    __s32 pid;\n};\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:163
msgid ""
"For performance reasons, it is recommended to use a large buffer size (for "
"example, 4096 bytes), so that multiple events can be retrieved by a single "
"B<read>(2)."
msgstr ""
"Для увеличения производительности рекомендуется использовать буфер большого "
"размера (например, 4096 байт) для того, чтобы получить несколько событий за "
"один вызов B<read>(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:168
msgid ""
"The return value of B<read>(2)  is the number of bytes placed in the buffer,"
" or -1 in case of an error (but see BUGS)."
msgstr ""
"Возвращаемое B<read>(2) значение — количество байт помещённых в буфер, или -1 "
"в случае ошибки (но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man7/fanotify.7:172
msgid "The fields of the I<fanotify_event_metadata> structure are as follows:"
msgstr "Поля структуры I<fanotify_event_metadata>:"

#. type: TP
#: man-pages/man7/fanotify.7:172
#, no-wrap
msgid "I<event_len>"
msgstr "I<event_len>"

#. type: Plain text
#: man-pages/man7/fanotify.7:182
msgid ""
"This is the length of the data for the current event and the offset to the "
"next event in the buffer.  In the current implementation, the value of "
"I<event_len> is always B<FAN_EVENT_METADATA_LEN>.  However, the API is "
"designed to allow variable-length structures to be returned in the future."
msgstr ""
"Длина данных текущего события и смещение на следующее событие в буфере. В "
"текущей реализации значение I<event_len> всегда равно B<"
"FAN_EVENT_METADATA_LEN>. Однако, благодаря программному интерфейсу в будущем "
"будут возвращаться структуры переменной длины."

#. type: TP
#: man-pages/man7/fanotify.7:182
#, no-wrap
msgid "I<vers>"
msgstr "I<vers>"

#. type: Plain text
#: man-pages/man7/fanotify.7:191
msgid ""
"This field holds a version number for the structure.  It must be compared to"
" B<FANOTIFY_METADATA_VERSION> to verify that the structures returned at "
"runtime match the structures defined at compile time.  In case of a "
"mismatch, the application should abandon trying to use the fanotify file "
"descriptor."
msgstr ""
"Номер версии структуры. Он должен сравниваться с B<FANOTIFY_METADATA_VERSION> "
"для проверки того, что структуры, возвращаемые во время выполнения, "
"соответствуют структурам, определённым во время компиляция. В случае "
"несоответствия приложение должно прекратить попытки использовать файловый "
"дескриптор fanotify."

#. type: TP
#: man-pages/man7/fanotify.7:191
#, no-wrap
msgid "I<reserved>"
msgstr "I<reserved>"

#. type: Plain text
#: man-pages/man7/fanotify.7:194
msgid "This field is not used."
msgstr "Не используется."

#. type: TP
#: man-pages/man7/fanotify.7:194
#, no-wrap
msgid "I<metadata_len>"
msgstr "I<metadata_len>"

#. type: Plain text
#: man-pages/man7/fanotify.7:200
msgid ""
"This is the length of the structure.  The field was introduced to facilitate"
" the implementation of optional headers per event type.  No such optional "
"headers exist in the current implementation."
msgstr ""
"Длина структуры. Это поле было добавлено для облегчения реализации "
"необязательных заголовков разных типов событий. В текущей реализации такие "
"необязательные заголовки отсутствуют."

#. type: TP
#: man-pages/man7/fanotify.7:200
#, no-wrap
msgid "I<mask>"
msgstr "I<mask>"

#. type: Plain text
#: man-pages/man7/fanotify.7:203
msgid "This is a bit mask describing the event (see below)."
msgstr "Битовая маска, описывающая событие (смотрите далее)."

#. type: TP
#: man-pages/man7/fanotify.7:203 man-pages/man7/fanotify.7:360
#, no-wrap
msgid "I<fd>"
msgstr "I<fd>"

#. type: Plain text
#: man-pages/man7/fanotify.7:211
msgid ""
"This is an open file descriptor for the object being accessed, or "
"B<FAN_NOFD> if a queue overflow occurred.  The file descriptor can be used "
"to access the contents of the monitored file or directory.  The reading "
"application is responsible for closing this file descriptor."
msgstr ""
"Файловый дескриптор отслеживаемого объекта или B<FAN_NOFD>, если возникло "
"переполнение очереди. Файловый дескриптор можно использовать для доступа к "
"содержимому отслеживаемого файла или каталога. Читающее приложение "
"ответственно за закрытие этого файлового дескриптора."

#. type: Plain text
#: man-pages/man7/fanotify.7:224
msgid ""
"When calling B<fanotify_init>(2), the caller may specify (via the "
"I<event_f_flags> argument) various file status flags that are to be set on "
"the open file description that corresponds to this file descriptor.  In "
"addition, the (kernel-internal)  B<FMODE_NONOTIFY> file status flag is set "
"on the open file description.  This flag suppresses fanotify event "
"generation.  Hence, when the receiver of the fanotify event accesses the "
"notified file or directory using this file descriptor, no additional events "
"will be created."
msgstr ""
"Когда вызывается B<fanotify_init>(2) вызывающий может указать (в аргументе I<"
"event_f_flags>) различные флаги состояния файла, которые будут установлены на "
"открытом файловом дескрипторе, соответствующем этому файловому дескриптору. "
"Также, на отрываемом файловом дескрипторе устанавливается (внутри ядра) флаг "
"состояния файла B<FMODE_NONOTIFY>. Этот флаг подавляет генерацию событий "
"fanotify. Таким образом, когда получатель события fanotify обратится к "
"отслеживаемому файлу или каталогу через этот файловый дескриптор, "
"дополнительных событий создано не будет."

#. type: TP
#: man-pages/man7/fanotify.7:224
#, no-wrap
msgid "I<pid>"
msgstr "I<pid>"

#. type: Plain text
#: man-pages/man7/fanotify.7:232
msgid ""
"This is the ID of the process that caused the event.  A program listening to"
" fanotify events can compare this PID to the PID returned by B<getpid>(2), "
"to determine whether the event is caused by the listener itself, or is due "
"to a file access by another process."
msgstr ""
"Идентификатор процесса, из-за которого произошло событие. Программа, "
"слушающая события fanotify, может сравнить этот PID с PID, возвращаемым B<"
"getpid>(2), для проверки, что событие не возникло из-за самого слушающего, а "
"из-за доступа к файлу другого процесса."

#. type: Plain text
#: man-pages/man7/fanotify.7:242
msgid ""
"The bit mask in I<mask> indicates which events have occurred for a single "
"filesystem object.  Multiple bits may be set in this mask, if more than one "
"event occurred for the monitored filesystem object.  In particular, "
"consecutive events for the same filesystem object and originating from the "
"same process may be merged into a single event, with the exception that two "
"permission events are never merged into one queue entry."
msgstr ""
"В битовой маске I<mask> указывают события, произошедшие с одиночным объектом "
"файловой системы. В маске может быть установлено несколько бит, если было "
"более одного события с отслеживаемым объектом файловой системы. В частности, "
"возникшие друг за другом события с одним объектом файловой системы и "
"произошедшие из-за одного процесса могут быть объединены в одно событие, за "
"исключением того, что два события доступа никогда не объединяются в одном "
"элементе очереди."

#. type: Plain text
#: man-pages/man7/fanotify.7:246
msgid "The bits that may appear in I<mask> are as follows:"
msgstr "Биты маски I<mask>:"

#. type: TP
#: man-pages/man7/fanotify.7:246
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr "B<FAN_ACCESS>"

#. type: Plain text
#: man-pages/man7/fanotify.7:249
msgid "A file or a directory (but see BUGS) was accessed (read)."
msgstr "Доступ (на чтение) к файлу или каталогу (но смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man7/fanotify.7:249
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr "B<FAN_OPEN>"

#. type: Plain text
#: man-pages/man7/fanotify.7:252
msgid "A file or a directory was opened."
msgstr "Файл или каталог открыт."

#. type: TP
#: man-pages/man7/fanotify.7:252
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr "B<FAN_MODIFY>"

#. type: Plain text
#: man-pages/man7/fanotify.7:255
msgid "A file was modified."
msgstr "Файл изменён."

#. type: TP
#: man-pages/man7/fanotify.7:255
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr "B<FAN_CLOSE_WRITE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:262
msgid ""
"A file that was opened for writing (B<O_WRONLY> or B<O_RDWR>)  was closed."
msgstr "Файл, открытый на запись (B<O_WRONLY> или B<O_RDWR>), закрыт."

#. type: TP
#: man-pages/man7/fanotify.7:262
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr "B<FAN_CLOSE_NOWRITE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:267
msgid ""
"A file or directory that was opened read-only (B<O_RDONLY>)  was closed."
msgstr "Файл или каталог, открытый только для чтения (B<O_RDONLY>), закрыт."

#. type: TP
#: man-pages/man7/fanotify.7:267
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr "B<FAN_Q_OVERFLOW>"

#. type: Plain text
#: man-pages/man7/fanotify.7:274
msgid ""
"The event queue exceeded the limit of 16384 entries.  This limit can be "
"overridden by specifying the B<FAN_UNLIMITED_QUEUE> flag when calling "
"B<fanotify_init>(2)."
msgstr ""
"Очередь событий превысила ограничение в 16384 записи. Это ограничение можно "
"изменить, указав флаг B<FAN_UNLIMITED_QUEUE> при вызове B<fanotify_init>(2)."

#. type: TP
#: man-pages/man7/fanotify.7:274
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr "B<FAN_ACCESS_PERM>"

#. type: Plain text
#: man-pages/man7/fanotify.7:283
msgid ""
"An application wants to read a file or directory, for example using "
"B<read>(2)  or B<readdir>(2).  The reader must write a response (as "
"described below)  that determines whether the permission to access the "
"filesystem object shall be granted."
msgstr ""
"Приложение хочет прочитать файл или каталог, например, с помощью B<read>(2) "
"или B<readdir>(2). Читатель события должен написать ответ (описано далее) о "
"разрешении доступа к объекту файловой системы."

#. type: TP
#: man-pages/man7/fanotify.7:283
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr "B<FAN_OPEN_PERM>"

#. type: Plain text
#: man-pages/man7/fanotify.7:288
msgid ""
"An application wants to open a file or directory.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object shall be granted."
msgstr ""
"Приложение хочет открыть файл или каталог. Читатель события должен написать "
"ответ о разрешении открытия объекта файловой системы."

#. type: Plain text
#: man-pages/man7/fanotify.7:290
msgid "To check for any close event, the following bit mask may be used:"
msgstr ""
"Для проверки любого события закрытия может использоваться следующая битовая "
"маска:"

#. type: TP
#: man-pages/man7/fanotify.7:290
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr "B<FAN_CLOSE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:294
msgid "A file was closed.  This is a synonym for:"
msgstr "Файл закрыт. Это синоним:"

#. type: Plain text
#: man-pages/man7/fanotify.7:296
#, no-wrap
msgid "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"
msgstr "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:301
msgid ""
"The following macros are provided to iterate over a buffer containing "
"fanotify event metadata returned by a B<read>(2)  from an fanotify file "
"descriptor:"
msgstr ""
"Следующие макросы позволяют обходить буфер с метаданными событий fanotify, "
"возвращаемый B<read>(2) из файлового дескриптора fanotify:"

#. type: TP
#: man-pages/man7/fanotify.7:301
#, no-wrap
msgid "B<FAN_EVENT_OK(meta, len)>"
msgstr "B<FAN_EVENT_OK(meta, len)>"

#. type: Plain text
#: man-pages/man7/fanotify.7:310
msgid ""
"This macro checks the remaining length I<len> of the buffer I<meta> against "
"the length of the metadata structure and the I<event_len> field of the first"
" metadata structure in the buffer."
msgstr ""
"Этот макрос сверяет оставшуюся длину I<len> буфера I<meta> с длиной структуры "
"метаданных и полем I<event_len> из первой структуры метаданных в буфере."

#. type: TP
#: man-pages/man7/fanotify.7:310
#, no-wrap
msgid "B<FAN_EVENT_NEXT(meta, len)>"
msgstr "B<FAN_EVENT_NEXT(meta, len)>"

#. type: Plain text
#: man-pages/man7/fanotify.7:329
msgid ""
"This macro uses the length indicated in the I<event_len> field of the "
"metadata structure pointed to by I<meta> to calculate the address of the "
"next metadata structure that follows I<meta>.  I<len> is the number of bytes"
" of metadata that currently remain in the buffer.  The macro returns a "
"pointer to the next metadata structure that follows I<meta>, and reduces "
"I<len> by the number of bytes in the the metadata structure that has been "
"skipped over (i.e., it subtracts I<meta-E<gt>event_len> from I<len>)."
msgstr ""
"Этот макрос использует длину из поля I<event_len> структуры метаданных, на "
"которую указывает I<meta>, для вычисления адреса следующей структуры "
"метаданных, которая находится после I<meta>. В поле I<len> указано количество "
"байт метаданных, оставшихся в буфере. Макрос возвращает указатель на "
"следующую структуру метаданных после I<meta> и уменьшает I<len> на количество "
"байт в структуре метаданных, которая была пропущена (т. е., вычитает I<"
"meta-E<gt>event_len> из I<len>)."

#. type: Plain text
#: man-pages/man7/fanotify.7:331
msgid "In addition, there is:"
msgstr "Дополнительно есть:"

#. type: TP
#: man-pages/man7/fanotify.7:331
#, no-wrap
msgid "B<FAN_EVENT_METADATA_LEN>"
msgstr "B<FAN_EVENT_METADATA_LEN>"

#. type: Plain text
#: man-pages/man7/fanotify.7:337
msgid ""
"This macro returns the size (in bytes) of the structure "
"I<fanotify_event_metadata>.  This is the minimum size (and currently the "
"only size) of any event metadata."
msgstr ""
"Этот макрос возвращает размер (в байтах) структуры I<fanotify_event_metadata>"
". Это минимальный размер (и, в настоящее время, единственный) метаданных "
"любого события."

#. type: SS
#: man-pages/man7/fanotify.7:337
#, no-wrap
msgid "Monitoring an fanotify file descriptor for events"
msgstr "Отслеживание событий через файловый дескриптор fanotify"

#. type: Plain text
#: man-pages/man7/fanotify.7:344
msgid ""
"When an fanotify event occurs, the fanotify file descriptor indicates as "
"readable when passed to B<epoll>(7), B<poll>(2), or B<select>(2)."
msgstr ""
"Когда возникает событие fanotify файловый дескриптор fanotify помечается как "
"доступный для чтения при его передаче в B<epoll>(7), B<poll>(2) или B<select>"
"(2)."

#. type: SS
#: man-pages/man7/fanotify.7:344
#, no-wrap
msgid "Dealing with permission events"
msgstr "Работа с событиями доступа"

#. type: Plain text
#: man-pages/man7/fanotify.7:349
msgid ""
"For permission events, the application must B<write>(2)  a structure of the "
"following form to the fanotify file descriptor:"
msgstr ""
"Для событий доступа приложение должно записать (B<write>(2)) в файловый "
"дескриптор fanotify следующую структуру:"

#. type: Plain text
#: man-pages/man7/fanotify.7:356
#, no-wrap
msgid ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"
msgstr "struct fanotify_response {\n    __s32 fd;\n    __u32 response;\n};\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:360
msgid "The fields of this structure are as follows:"
msgstr "Поля этой структуры имеют следующее назначение:"

#. type: Plain text
#: man-pages/man7/fanotify.7:364
msgid ""
"This is the file descriptor from the structure I<fanotify_event_metadata>."
msgstr "Файловый дескриптор из структуры I<fanotify_event_metadata>."

#. type: TP
#: man-pages/man7/fanotify.7:364
#, no-wrap
msgid "I<response>"
msgstr "I<response>"

#. type: Plain text
#: man-pages/man7/fanotify.7:372
msgid ""
"This field indicates whether or not the permission is to be granted.  Its "
"value must be either B<FAN_ALLOW> to allow the file operation or B<FAN_DENY>"
" to deny the file operation."
msgstr ""
"В этом поле указывает о разрешении доступа или запрещении. Данное значение "
"должно быть равно B<FAN_ALLOW>, чтобы разрешить операцию с файлом, или B<"
"FAN_DENY> для запрета."

#. type: Plain text
#: man-pages/man7/fanotify.7:376
msgid ""
"If access is denied, the requesting application call will receive an "
"B<EPERM> error."
msgstr ""
"Если доступ запрещается, то запрашивающее приложение получит ошибку B<EPERM>."

#. type: SS
#: man-pages/man7/fanotify.7:376
#, no-wrap
msgid "Closing the fanotify file descriptor"
msgstr "Закрытие файлового дескриптора fanotify"

#. type: Plain text
#: man-pages/man7/fanotify.7:384
msgid ""
"When all file descriptors referring to the fanotify notification group are "
"closed, the fanotify group is released and its resources are freed for reuse"
" by the kernel.  Upon B<close>(2), outstanding permission events will be set"
" to allowed."
msgstr ""
"Когда все файловые дескрипторы, указывающие на группу уведомления fanotify, "
"закрыты, группа fanotify освобождается и её ресурсы становятся доступны ядру "
"для повторного использования. После B<close>(2) все оставшиеся "
"непросмотренные события доступа будут разрешены."

#. type: SS
#: man-pages/man7/fanotify.7:384
#, no-wrap
msgid "/proc/[pid]/fdinfo"
msgstr "/proc/[pid]/fdinfo"

#. type: Plain text
#: man-pages/man7/fanotify.7:394
msgid ""
"The file I</proc/[pid]/fdinfo/[fd]> contains information about fanotify "
"marks for file descriptor I<fd> of process I<pid>.  See the kernel source "
"file I<Documentation/filesystems/proc.txt> for details."
msgstr ""
"Файл I</proc/[pid]/fdinfo/[fd]> содержит информацию о метках fanotify для "
"файлового дескриптора I<fd> процесса I<pid>. Подробности смотрите в файле "
"исходного кода ядра I<Documentation/filesystems/proc.txt>."

#. type: SH
#: man-pages/man7/fanotify.7:394
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: Plain text
#: man-pages/man7/fanotify.7:399
msgid ""
"In addition to the usual errors for B<read>(2), the following errors can "
"occur when reading from the fanotify file descriptor:"
msgstr ""
"Кроме обычных ошибок B<read>(2) при чтении из файлового дескриптора fanotify "
"могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man7/fanotify.7:399 man-pages/man7/fanotify.7:433
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/fanotify.7:402
msgid "The buffer is too small to hold the event."
msgstr "Буфер слишком мал для хранения события."

#. type: TP
#: man-pages/man7/fanotify.7:402
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:409
msgid ""
"The per-process limit on the number of open files has been reached.  See the"
" description of B<RLIMIT_NOFILE> in B<getrlimit>(2)."
msgstr ""
"Достигнуто максимальное попроцессное количество открытых файлов. Смотрите "
"описание B<RLIMIT_NOFILE> в B<getrlimit>(2)."

#. type: TP
#: man-pages/man7/fanotify.7:409
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:416
msgid ""
"The system-wide limit on the number of open files has been reached.  See "
"I</proc/sys/fs/file-max> in B<proc>(5)."
msgstr ""
"Достигнут предел на количество открытых файлов в системе. Смотрите I<"
"/proc/sys/fs/file-max> в B<proc>(5)."

#. type: TP
#: man-pages/man7/fanotify.7:416
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: man-pages/man7/fanotify.7:429
msgid ""
"This error is returned by B<read>(2)  if B<O_RDWR> or B<O_WRONLY> was "
"specified in the I<event_f_flags> argument when calling B<fanotify_init>(2)"
"  and an event occurred for a monitored file that is currently being "
"executed."
msgstr ""
"Эта ошибка возвращается B<read>(2), если при вызове B<fanotify_init>(2) в "
"аргументе I<event_f_flags> был указан B<O_RDWR> или B<O_WRONLY> и произошло "
"событие с отслеживаемым файлом, который в данный момент выполняется."

#. type: Plain text
#: man-pages/man7/fanotify.7:433
msgid ""
"In addition to the usual errors for B<write>(2), the following errors can "
"occur when writing to the fanotify file descriptor:"
msgstr ""
"Кроме обычных ошибок B<write>(2) при записи в файловый дескриптор fanotify "
"могут возникать следующие ошибки:"

#. type: Plain text
#: man-pages/man7/fanotify.7:439
msgid ""
"Fanotify access permissions are not enabled in the kernel configuration or "
"the value of I<response> in the response structure is not valid."
msgstr ""
"Свойство для проверки прав доступа fanotify не включено в настройках ядра или "
"некорректное значение I<response> в структуре ответа."

#. type: TP
#: man-pages/man7/fanotify.7:439
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man7/fanotify.7:446
msgid ""
"The file descriptor I<fd> in the response structure is not valid.  This may "
"occur when a response for the permission event has already been written."
msgstr ""
"Некорректный файловый дескриптор I<fd> в структуре ответа. Это может "
"происходить, когда ответ на право доступа уже был записан."

#. type: SH
#: man-pages/man7/fanotify.7:446
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/fanotify.7:450
msgid ""
"The fanotify API was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37.  Fdinfo support was added in version 3.8."
msgstr ""
"Программный интерфейс fanotify представлен в версии 2.6.36 ядра Linux и "
"включён в версии 2.6.37. Поддержка fdinfo была добавлена в версии 3.8."

#. type: SH
#: man-pages/man7/fanotify.7:450
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/fanotify.7:452
msgid "The fanotify API is Linux-specific."
msgstr "Программный интерфейс fanotify есть только в Linux."

#. type: Plain text
#: man-pages/man7/fanotify.7:459
msgid ""
"The fanotify API is available only if the kernel was built with the "
"B<CONFIG_FANOTIFY> configuration option enabled.  In addition, fanotify "
"permission handling is available only if the "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> configuration option is enabled."
msgstr ""
"Программный интерфейс fanotify доступен только, если ядро собрано с "
"включённым параметром настройки B<CONFIG_FANOTIFY>. Также, работа с доступом "
"в fanotify доступна только, если включён параметр настройки B<"
"CONFIG_FANOTIFY_ACCESS_PERMISSIONS>."

#. type: SS
#: man-pages/man7/fanotify.7:459
#, no-wrap
msgid "Limitations and caveats"
msgstr "Ограничения и подводные камни"

#. type: Plain text
#: man-pages/man7/fanotify.7:464
msgid ""
"Fanotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems."
msgstr ""
"Fanotify сообщает только о событиях, которые возникли при использовании "
"пользовательскими программами программного интерфейса файловой системы. "
"Поэтому события об обращении к файлам в сетевых файловых системах не "
"отлавливаются."

#. type: Plain text
#: man-pages/man7/fanotify.7:471
msgid ""
"The fanotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""
"Программный интерфейс fanotify не сообщает о доступе и изменениях, которые "
"могут произойти из-за B<mmap>(2), B<msync>(2) и B<munmap>(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:476
msgid ""
"Events for directories are created only if the directory itself is opened, "
"read, and closed.  Adding, removing, or changing children of a marked "
"directory does not create events for the monitored directory itself."
msgstr ""
"События для каталогов создаются только, если сам каталог открывается, "
"читается и закрывается. Добавление, удаление и изменение потомков "
"отслеживаемого каталога не приводит к возникновению событий."

#. type: Plain text
#: man-pages/man7/fanotify.7:484
msgid ""
"Fanotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional marks must be created.  (But "
"note that the fanotify API provides no way of detecting when a subdirectory "
"has been created under a marked directory, which makes recursive monitoring "
"difficult.)  Monitoring mounts offers the capability to monitor a whole "
"directory tree."
msgstr ""
"Fanotify не следит за каталогами рекурсивно: чтобы следить за подкаталогами "
"каталога, нужно их явно пометить (и, заметим, что программный интерфейс "
"fanotify не позволяет отслеживать создание подкаталога, что затрудняет "
"рекурсивное слежение). Отслеживание точек монтирования позволяет следить за "
"всем деревом каталогов."

#. type: Plain text
#: man-pages/man7/fanotify.7:487
msgid "The event queue can overflow.  In this case, events are lost."
msgstr "Очередь событий может переполниться. В этом случае события теряются."

#. type: SH
#: man-pages/man7/fanotify.7:487
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/fanotify.7:490
msgid "As of Linux 3.15, the following bugs exist:"
msgstr "В Linux 3.15 существуют следующие дефекты:"

#. type: IP
#: man-pages/man7/fanotify.7:490 man-pages/man7/fanotify.7:499
#, no-wrap
msgid "*"
msgstr "*"

#.  FIXME: A patch was proposed.
#. type: Plain text
#: man-pages/man7/fanotify.7:499
msgid ""
"When an event is generated, no check is made to see whether the user ID of "
"the receiving process has authorization to read or write the file before "
"passing a file descriptor for that file.  This poses a security risk, when "
"the B<CAP_SYS_ADMIN> capability is set for programs executed by unprivileged"
" users."
msgstr ""
"При генерации события не делается проверка, что пользовательскому ID "
"получающего процесса разрешено читать или писать в файл перед передачей "
"файлового дескриптора на этот файл. Это представляет некоторый риск "
"безопасности, когда у программ, выполняющихся непривилегированными "
"пользователями, есть мандат B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man7/fanotify.7:509
msgid ""
"If a call to B<read>(2)  processes multiple events from the fanotify queue "
"and an error occurs, the return value will be the total length of the events"
" successfully copied to the user-space buffer before the error occurred.  "
"The return value will not be -1, and I<errno> will not be set.  Thus, the "
"reading application has no way to detect the error."
msgstr ""
"Если вызов B<read>(2) получает несколько событий из очереди fanotify и "
"возникает ошибка, будет возвращена полная длина событий, которые были успешно "
"скопированы в буфер пользовательского пространства до ошибки. Возвращаемое "
"значение не будет равно -1, и в I<errno> не записывается код ошибки. То есть "
"читающее приложение не может обнаружить ошибку."

#. type: SH
#: man-pages/man7/fanotify.7:509
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man7/fanotify.7:519
msgid ""
"The following program demonstrates the usage of the fanotify API.  It marks "
"the mount point passed as a command-line argument and waits for events of "
"type B<FAN_PERM_OPEN> and B<FAN_CLOSE_WRITE>.  When a permission event "
"occurs, a B<FAN_ALLOW> response is given."
msgstr ""
"Следующая программа демонстрирует использование программного интерфейса "
"fanotify. Она следит за точкой монтирования, переданной в аргументе командной "
"строки, и ждёт событий с типом B<FAN_PERM_OPEN> и B<FAN_CLOSE_WRITE>. При "
"возникновении событий доступа выдаёт ответ B<FAN_ALLOW>."

#. type: Plain text
#: man-pages/man7/fanotify.7:529
msgid ""
"The following output was recorded while editing the file "
"I</home/user/temp/notes>.  Before the file was opened, a B<FAN_OPEN_PERM> "
"event occurred.  After the file was closed, a B<FAN_CLOSE_WRITE> event "
"occurred.  Execution of the program ends when the user presses the ENTER "
"key."
msgstr ""
"Следующий вывод записан при редактировании файла I</home/user/temp/notes>. "
"Перед открытием файла произошло событие B<FAN_OPEN_PERM>. После закрытия "
"файла произошло событие B<FAN_CLOSE_WRITE>. Выполнение программы закончилось "
"после нажатия пользователем клавиши ENTER."

#. type: SS
#: man-pages/man7/fanotify.7:529
#, no-wrap
msgid "Example output"
msgstr "Пример вывода"

#. type: Plain text
#: man-pages/man7/fanotify.7:537
#, no-wrap
msgid ""
"# ./fanotify_example /home\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"
msgstr ""
"# ./fanotify_example /home\nНажмите enter для завершения работы.\nОжидание "
"событий.\nFAN_OPEN_PERM: файл /home/user/temp/notes\nFAN_CLOSE_WRITE: файл "
"/home/user/temp/notes\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:539
#, no-wrap
msgid "Listening for events stopped.\n"
msgstr "Ожидание событий прекращено.\n"

#. type: SS
#: man-pages/man7/fanotify.7:541
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man7/fanotify.7:552
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* требуется для получения O_LARGEFILE */\n#include "
"E<lt>errno.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>limits.hE<gt>"
"\n#include E<lt>poll.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>"
"stdlib.hE<gt>\n#include E<lt>sys/fanotify.hE<gt>\n#include E<lt>unistd.hE<gt>"
"\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:554
#, no-wrap
msgid ""
"/* Read all available fanotify events from the file descriptor 'fd' */\n"
msgstr ""
"/* читаем все доступные события fanotify из файлового дескриптора «fd» */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:565
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"
msgstr ""
"static void\nhandle_events(int fd)\n{\n    const struct "
"fanotify_event_metadata *metadata;\n    struct fanotify_event_metadata "
"buf[200];\n    ssize_t len;\n    char path[PATH_MAX];\n    ssize_t "
"path_len;\n    char procfd_path[PATH_MAX];\n    struct fanotify_response "
"response;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:567
#, no-wrap
msgid "    /* Loop while events can be read from fanotify file descriptor */\n"
msgstr ""
"    /* проходим по всем событиям, которые можем прочитать\n       из "
"файлового дескриптора fanotify */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:569
#, no-wrap
msgid "    for(;;) {\n"
msgstr "    for(;;) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:571
#, no-wrap
msgid "        /* Read some events */\n"
msgstr "        /* читаем несколько событий */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:577
#, no-wrap
msgid ""
"        len = read(fd, (void *) &buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        len = read(fd, (void *) &buf, sizeof(buf));\n        if (len == -1 && "
"errno != EAGAIN) {\n            perror(\"read\");\n            "
"exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:579
#, no-wrap
msgid "        /* Check if end of available data reached */\n"
msgstr "        /* проверяем, достигнут ли конец доступных данных */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:582
#, no-wrap
msgid ""
"        if (len E<lt>= 0)\n"
"            break;\n"
msgstr "        if (len E<lt>= 0)\n            break;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:584
#, no-wrap
msgid "        /* Point to the first event in the buffer */\n"
msgstr "        /* выбираем первое событие в буфере */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:586
#, no-wrap
msgid "        metadata = buf;\n"
msgstr "        metadata = buf;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:588
#, no-wrap
msgid "        /* Loop over all events in the buffer */\n"
msgstr "        /* проходим по всем событиям в буфере */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:590
#, no-wrap
msgid "        while (FAN_EVENT_OK(metadata, len)) {\n"
msgstr "        while (FAN_EVENT_OK(metadata, len)) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:592
#, no-wrap
msgid ""
"            /* Check that run-time and compile-time structures match */\n"
msgstr ""
"            /* проверяем, что структуры, использовавшиеся при сборке,\n       "
"        идентичны структурам при выполнении */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:598
#, no-wrap
msgid ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n          "
"      fprintf(stderr,\n                        \"Версия метаданных fanotify "
"не совпадает.\\en\");\n                exit(EXIT_FAILURE);\n            }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:602
#, no-wrap
msgid ""
"            /* metadata-E<gt>fd contains either FAN_NOFD, indicating a\n"
"               queue overflow, or a file descriptor (a nonnegative\n"
"               integer). Here, we simply ignore queue overflow. */\n"
msgstr ""
"            /* metadata-E<gt>fd содержит или FAN_NOFD, указывающее\n          "
"     на переполнение очереди, или файловый дескриптор\n               "
"(неотрицательное целое). Здесь мы просто игнорируем\n               "
"переполнение очереди. */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:604
#, no-wrap
msgid "            if (metadata-E<gt>fd E<gt>= 0) {\n"
msgstr "            if (metadata-E<gt>fd E<gt>= 0) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:606
#, no-wrap
msgid "                /* Handle open permission event */\n"
msgstr "                /* обрабатываем событие на право открытия */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:609
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"
msgstr ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n                   "
" printf(\"FAN_OPEN_PERM: \");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:611
#, no-wrap
msgid "                    /* Allow file to be opened */\n"
msgstr "                    /* разрешаем открыть файл */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:617
#, no-wrap
msgid ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response,\n"
"                          sizeof(struct fanotify_response));\n"
"                }\n"
msgstr ""
"                    response.fd = metadata-E<gt>fd;\n                    "
"response.response = FAN_ALLOW;\n                    write(fd, &response,\n    "
"                      sizeof(struct fanotify_response));\n                }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:619
#, no-wrap
msgid "                /* Handle closing of writable file event */\n"
msgstr ""
"                /* обрабатываем событие закрытия записываемого файла */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:622
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"
msgstr ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n                   "
" printf(\"FAN_CLOSE_WRITE: \");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:624
#, no-wrap
msgid ""
"                /* Retrieve and print pathname of the accessed file */\n"
msgstr ""
"                /* получаем и выводим имя файла, к которому\n                 "
"  отслеживается доступ */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:633
#, no-wrap
msgid ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
msgstr ""
"                snprintf(procfd_path, sizeof(procfd_path),\n                  "
"       \"/proc/self/fd/%d\", metadata-E<gt>fd);\n                path_len = "
"readlink(procfd_path, path,\n                                    sizeof(path) "
"- 1);\n                if (path_len == -1) {\n                    "
"perror(\"readlink\");\n                    exit(EXIT_FAILURE);\n              "
"  }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:636
#, no-wrap
msgid ""
"                path[path_len] = '\\e0';\n"
"                printf(\"File %s\\en\", path);\n"
msgstr ""
"                path[path_len] = '\\e0';\n                printf(\"файл %"
"s\\en\", path);\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:638
#, no-wrap
msgid "                /* Close the file descriptor of the event */\n"
msgstr "                /* закрываем файловый дескриптор из события */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:641
#, no-wrap
msgid ""
"                close(metadata-E<gt>fd);\n"
"            }\n"
msgstr "                close(metadata-E<gt>fd);\n            }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:643
#, no-wrap
msgid "            /* Advance to next event */\n"
msgstr "            /* переходим на следующее событие */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:648
#, no-wrap
msgid ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n        }\n    }\n}\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:656
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    char buf;\n    int fd, poll_num;\n  "
"  nfds_t nfds;\n    struct pollfd fds[2];\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:658
#, no-wrap
msgid "    /* Check mount point is supplied */\n"
msgstr "    /* проверяем заданную точку монтирования */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:663
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s "
"ТОЧКА_МОНТИРОВАНИЯ\\en\",\n                                        "
"argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:665
#, no-wrap
msgid "    printf(\"Press enter key to terminate.\\en\");\n"
msgstr "    printf(\"Нажмите enter для завершения работы.\\en\");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:667
#, no-wrap
msgid "    /* Create the file descriptor for accessing the fanotify API */\n"
msgstr "    /* Создаём файловый дескриптор для доступа к fanotify API */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:674
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n      "
"                 O_RDONLY | O_LARGEFILE);\n    if (fd == -1) {\n        "
"perror(\"fanotify_init\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:679
#, no-wrap
msgid ""
"    /* Mark the mount for:\n"
"       - permission events before opening files\n"
"       - notification events after closing a write-enabled\n"
"         file descriptor */\n"
msgstr ""
"    /* Помечаем точку монтирования для:\n       - событий доступа перед "
"открытием файлов\n       - событий уведомления после закрытия файлового "
"дескриптора\n         для файла открытого для записи */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:686
#, no-wrap
msgid ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, -1,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n                    "
"  FAN_OPEN_PERM | FAN_CLOSE_WRITE, -1,\n                      argv[1]) == -1) "
"{\n        perror(\"fanotify_mark\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:688
#, no-wrap
msgid "    /* Prepare for polling */\n"
msgstr "    /* подготовка к опросу */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:690
#, no-wrap
msgid "    nfds = 2;\n"
msgstr "    nfds = 2;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:692
#, no-wrap
msgid "    /* Console input */\n"
msgstr "    /* ввод с консоли  */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:695
#, no-wrap
msgid ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"
msgstr "    fds[0].fd = STDIN_FILENO;\n    fds[0].events = POLLIN;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:697
#, no-wrap
msgid "    /* Fanotify input */\n"
msgstr "    /* ввод из fanotify */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:700
#, no-wrap
msgid ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"
msgstr "    fds[1].fd = fd;\n    fds[1].events = POLLIN;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:702
#, no-wrap
msgid "    /* This is the loop to wait for incoming events */\n"
msgstr "    /* цикл ожидания входящих событий */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:704
#, no-wrap
msgid "    printf(\"Listening for events.\\en\");\n"
msgstr "    printf(\"Ожидание событий.\\en\");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:710
#, no-wrap
msgid ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* Interrupted by a signal */\n"
"                continue;           /* Restart poll() */\n"
msgstr ""
"    while (1) {\n        poll_num = poll(fds, nfds, -1);\n        if "
"(poll_num == -1) {\n            if (errno == EINTR)     /* прервано сигналом "
"*/\n                continue;           /* перезапуск poll() */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:714
#, no-wrap
msgid ""
"            perror(\"poll\");         /* Unexpected error */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"            perror(\"poll\");         /* неожиданная ошибка */\n            "
"exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:717
#, no-wrap
msgid ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"
msgstr ""
"        if (poll_num E<gt> 0) {\n            if (fds[0].revents & POLLIN) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:719
#, no-wrap
msgid ""
"                /* Console input is available: empty stdin and quit */\n"
msgstr ""
"                /* доступен ввод с консоли: опустошаем stdin и выходим */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:724
#, no-wrap
msgid ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != '\\en')\n"
"                    continue;\n"
"                break;\n"
"            }\n"
msgstr ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != "
"'\\en')\n                    continue;\n                break;\n            "
"}\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:726
#, no-wrap
msgid "            if (fds[1].revents & POLLIN) {\n"
msgstr "            if (fds[1].revents & POLLIN) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:728
#, no-wrap
msgid "                /* Fanotify events are available */\n"
msgstr "                /* доступны события fanotify */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:733
#, no-wrap
msgid ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr "                handle_events(fd);\n            }\n        }\n    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:737
#, no-wrap
msgid ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Ожидание событий прекращено.\\en\");\n    "
"exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:742
msgid "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"
msgstr "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"

#. type: TH
#: man-pages/man7/feature_test_macros.7:25
#, no-wrap
msgid "FEATURE_TEST_MACROS"
msgstr "FEATURE_TEST_MACROS"

#. type: TH
#: man-pages/man7/feature_test_macros.7:25
#, no-wrap
msgid "2014-03-20"
msgstr "2014-03-20"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:28
msgid "feature_test_macros - feature test macros"
msgstr "feature_test_macros - макросы тестирования свойств"

#. type: SH
#: man-pages/man7/feature_test_macros.7:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:31
#, no-wrap
msgid "B<#include E<lt>features.hE<gt>>\n"
msgstr "B<#include E<lt>features.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:35
msgid ""
"Feature test macros allow the programmer to control the definitions that are"
" exposed by system header files when a program is compiled."
msgstr ""
"Макросы тестирования свойств позволяют программисту контролировать какие "
"определения будут доступны из системных заголовочных файлов при компиляции "
"программы."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:43
msgid ""
"B<NOTE:> In order to be effective, a feature test macro I<must be defined "
"before including any header files>.  This can be done either in the "
"compilation command (I<cc -DMACRO=value>)  or by defining the macro within "
"the source code before including any headers."
msgstr ""
"B<ЗАМЕЧАНИЕ:> В целях эффективности, макрос тестирования свойств I<должен "
"быть определён до включения всех заголовочных файлов>. Это можно сделать или "
"в команде компиляции (I<cc -DМАКРОС=значение>) или определив макрос в "
"исходном коде до включения заголовочных файлов."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:52
msgid ""
"Some feature test macros are useful for creating portable applications, by "
"preventing nonstandard definitions from being exposed.  Other macros can be "
"used to expose nonstandard definitions that are not exposed by default.  The"
" precise effects of each of the feature test macros described below can be "
"ascertained by inspecting the I<E<lt>features.hE<gt>> header file."
msgstr ""
"Некоторые макросы тестирования свойств полезны для создания переносимых "
"приложений; они позволяют блокировать нестандартные определения. Другие "
"макросы можно использовать для разблокировки нестандартных определений, "
"которые по умолчанию недоступны. Влияние каждого макроса тестирования "
"свойств, описанного далее, можно узнать из содержимого заголовочного файла I<"
"E<lt>features.hE<gt>>."

#. type: SS
#: man-pages/man7/feature_test_macros.7:52
#, no-wrap
msgid "Specification of feature test macro requirements in manual pages"
msgstr "Обозначение макросов тестирования свойств в справочных страницах"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:58
msgid ""
"When a function requires that a feature test macro is defined, the manual "
"page SYNOPSIS typically includes a note of the following form (this example "
"from the B<acct>(2)  manual page):"
msgstr ""
"Когда функции требуется определение макроса тестирования свойств в ОБЗОРЕ "
"справочной страницы, обычно, содержится упоминание в следующем виде (этот "
"пример взят из справочной страницы B<acct>(2)):"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:61
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:63
msgid "B<int acct(const char *>I<filename>B<);>"
msgstr "B<int acct(const char *>I<filename>B<);>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:68
#, no-wrap
msgid ""
"Feature Test Macro Requirements for glibc (see\n"
"B<feature_test_macros>(7)):\n"
msgstr ""
"Требования макроса тестирования свойств для glibc\n(см. B<feature_test_macros>"
"(7)):\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:73
msgid ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:84
msgid ""
"The B<||> means that in order to obtain the declaration of B<acct>(2)  from "
"I<E<lt>unistd.hE<gt>>, I<either> of the following macro definitions must be "
"made before including any header files:"
msgstr ""
"Символ B<||> означает, что для получения объявления B<acct>(2) из I<E<lt>"
"unistd.hE<gt>> нужно определить I<любой> из следующих макросов до включения "
"любых заголовочных файлов:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:89
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#define _XOPEN_SOURCE        /* or any value E<lt> 500 */\n"
msgstr ""
"#define _BSD_SOURCE\n#define _XOPEN_SOURCE        /* или любое значение E<lt> "
"500 */\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:94
msgid ""
"Alternatively, equivalent definitions can be included in the compilation "
"command:"
msgstr ""
"Или же эквивалентные определения могут быть включены следующей командой "
"компиляции:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:99
#, no-wrap
msgid ""
"cc -D_BSD_SOURCE\n"
"cc -D_XOPEN_SOURCE           # Or any value E<lt> 500\n"
msgstr ""
"cc -D_BSD_SOURCE\ncc -D_XOPEN_SOURCE           # или любое значение E<lt> "
"500\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:107
msgid ""
"Note that, as described below, B<some feature test macros are defined by "
"default>, so that it may not always be necessary to explicitly specify the "
"feature test macro(s) shown in the SYNOPSIS."
msgstr ""
"Как описывается далее, B<некоторые макросы тестирования свойств определяются "
"по умолчанию>, поэтому макрос не всегда нужно указывать явно даже, если он "
"приведён в ОБЗОРЕ."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:111
msgid ""
"In a few cases, manual pages use a shorthand for expressing the feature test"
" macro requirements (this example from B<readahead>(2)):"
msgstr ""
"В некоторых случаях в справочных страницах используется сокращённая запись "
"требований макросов тестирования свойств (пример из B<readahead>(2)):"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:116
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>\nB<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:118
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t *>I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""
"B<ssize_t readahead(int >I<fd>B<, off64_t *>I<offset>B<, size_t >I<count>B<);>"
"\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:124
msgid ""
"This format is employed in cases where only a single feature test macro can "
"be used to expose the function declaration, and that macro is not defined by"
" default."
msgstr ""
"Такой формат употребляется в случаях, когда достаточно одного макроса для "
"получения объявления функции, и этот макрос не определён по умолчанию."

#. type: SS
#: man-pages/man7/feature_test_macros.7:124
#, no-wrap
msgid "Feature test macros understood by glibc"
msgstr "Макросы тестирования свойств, распознаваемые glibc"

#.  The details in glibc 2.0 are simpler, but combining a
#.  a description of them with the details in later glibc versions
#.  would make for a complicated description.
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:132
msgid ""
"The following paragraphs explain how feature test macros are handled in "
"Linux glibc 2.I<x>, I<x> E<gt> 0."
msgstr ""
"В следующих параграфах описаны макросы тестирования свойств, управляющие "
"Linux glibc 2.I<x>, где I<x> E<gt> 0."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:134
msgid "Linux glibc understands the following feature test macros:"
msgstr "В Linux glibc распознаются следующие макросы тестирования свойств:"

#. type: TP
#: man-pages/man7/feature_test_macros.7:134
#, no-wrap
msgid "B<__STRICT_ANSI__>"
msgstr "B<__STRICT_ANSI__>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:144
msgid ""
"ISO Standard C.  This macro is implicitly defined by B<gcc>(1)  when invoked"
" with, for example, the I<-std=c99> or I<-ansi> flag."
msgstr ""
"Стандарт ISO C. Этот макрос неявно определяется компилятором B<gcc>(1), если "
"он вызывается с флагом I<-std=c99> или I<-ansi>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:144
#, no-wrap
msgid "B<_POSIX_C_SOURCE>"
msgstr "B<_POSIX_C_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:147
#: man-pages/man7/feature_test_macros.7:180
msgid ""
"Defining this macro causes header files to expose definitions as follows:"
msgstr ""
"При определении этого макроса из заголовочных файлов становится доступно "
"следующее:"

#. type: IP
#: man-pages/man7/feature_test_macros.7:148
#: man-pages/man7/feature_test_macros.7:151
#: man-pages/man7/feature_test_macros.7:154
#: man-pages/man7/feature_test_macros.7:158
#: man-pages/man7/feature_test_macros.7:161
#: man-pages/man7/feature_test_macros.7:167
#: man-pages/man7/feature_test_macros.7:181
#: man-pages/man7/feature_test_macros.7:184
#: man-pages/man7/feature_test_macros.7:187
#: man-pages/man7/feature_test_macros.7:191
#: man-pages/man7/feature_test_macros.7:210
#: man-pages/man7/feature_test_macros.7:213
#: man-pages/man7/feature_test_macros.7:543
#: man-pages/man7/feature_test_macros.7:548
#: man-pages/man7/feature_test_macros.7:554
#: man-pages/man7/feature_test_macros.7:559
#: man-pages/man7/feature_test_macros.7:565
#: man-pages/man7/feature_test_macros.7:570
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:151
msgid ""
"The value 1 exposes definitions conforming to POSIX.1-1990 and ISO C (1990)."
msgstr ""
"При значении 1 доступны определения, удовлетворяющие POSIX.1-1990 и ISO C "
"(1990)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:154
msgid ""
"The value 2 or greater additionally exposes definitions for POSIX.2-1992."
msgstr ""
"При значении 2 и более дополнительно доступны определения, удовлетворяющие "
"POSIX.2-1992."

#.  199506L functionality is available only since glibc 2.1
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:158
msgid ""
"The value 199309L or greater additionally exposes definitions for POSIX.1b "
"(real-time extensions)."
msgstr ""
"При значении 199309L и более дополнительно доступны определения, "
"удовлетворяющие POSIX.1b (расширения для реального времени)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:161
msgid ""
"The value 199506L or greater additionally exposes definitions for POSIX.1c "
"(threads)."
msgstr ""
"При значении 199506L и более дополнительно доступны определения, "
"удовлетворяющие POSIX.1c (нити)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:167
msgid ""
"(Since glibc 2.3.3)  The value 200112L or greater additionally exposes "
"definitions corresponding to the POSIX.1-2001 base specification (excluding "
"the XSI extension)  and also causes C95 (since glibc 2.12) and C99 (since "
"glibc 2.10) features to be exposed."
msgstr ""
"(начиная с glibc 2.3.3) При значении 200112L и более доступны определения, "
"удовлетворяющие базовой спецификации POSIX.1-2001 (за исключением расширения "
"XSI), а также свойства C95 (начиная с glibc 2.12) и C99 (начиная с glibc "
"2.10)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:171
msgid ""
"(Since glibc 2.10)  The value 200809L or greater additionally exposes "
"definitions corresponding to the POSIX.1-2008 base specification (excluding "
"the XSI extension)."
msgstr ""
"(начиная с glibc 2.10) При значении 200809L и более доступны определения, "
"удовлетворяющие базовой спецификации POSIX.1-2008 (за исключением расширения "
"XSI)."

#. type: TP
#: man-pages/man7/feature_test_macros.7:172
#, no-wrap
msgid "B<_POSIX_SOURCE>"
msgstr "B<_POSIX_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:177
msgid ""
"Defining this obsolete macro with any value is equivalent to defining "
"B<_POSIX_C_SOURCE> with the value 1."
msgstr ""
"Определение этого устаревшего макроса с любым значением эквивалентно "
"определению B<_POSIX_C_SOURCE> со значением 1."

#. type: TP
#: man-pages/man7/feature_test_macros.7:177
#, no-wrap
msgid "B<_XOPEN_SOURCE>"
msgstr "B<_XOPEN_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:184
msgid ""
"Defining with any value exposes definitions conforming to POSIX.1, POSIX.2, "
"and XPG4."
msgstr ""
"Определение с любым значением делает доступным определения, удовлетворяющие "
"POSIX.1, POSIX.2 и XPG4."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:187
msgid ""
"The value 500 or greater additionally exposes definitions for SUSv2 (UNIX "
"98)."
msgstr ""
"При значении 500 и более дополнительно доступны определения, удовлетворяющие "
"SUSv2 (UNIX 98)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:191
msgid ""
"(Since glibc 2.2) The value 600 or greater additionally exposes definitions "
"for SUSv3 (UNIX 03; i.e., the POSIX.1-2001 base specification plus the XSI "
"extension) and C99 definitions."
msgstr ""
"(начиная с glibc 2.2) При значении 600L и более дополнительно доступны "
"определения, удовлетворяющие SUSv3 (UNIX 03; т. е., базовой спецификации "
"POSIX.1-2001 плюс расширение XSI), и определения C99."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:195
msgid ""
"(Since glibc 2.10) The value 700 or greater additionally exposes definitions"
" for SUSv4 (i.e., the POSIX.1-2008 base specification plus the XSI "
"extension)."
msgstr ""
"(начиная с glibc 2.10) При значении 700 и более дополнительно доступны "
"определения, удовлетворяющие SUSv4 (т. е., базовой спецификации POSIX.1-2008 "
"плюс расширение XSI)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:209
msgid ""
"If B<__STRICT_ANSI__> is not defined, or B<_XOPEN_SOURCE> is defined with a "
"value greater than or equal to 500 I<and> neither B<_POSIX_SOURCE> not "
"B<_POSIX_C_SOURCE> is explicitly defined, then the following macros are "
"implicitly defined:"
msgstr ""
"If B<__STRICT_ANSI__> не определено или определено B<_XOPEN_SOURCE> со "
"значением больше или равно 500 I<и> явно не определено B<_POSIX_SOURCE> и B<"
"_POSIX_C_SOURCE>, то неявно определяются следующие макросы:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:213
msgid "B<_POSIX_SOURCE> is defined with the value 1."
msgstr "B<_POSIX_SOURCE> определяется со значением 1."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:217
msgid ""
"B<_POSIX_C_SOURCE> is defined, according to the value of B<_XOPEN_SOURCE>:"
msgstr "B<_POSIX_C_SOURCE> определяется согласно значению B<_XOPEN_SOURCE>:"

#. type: TP
#: man-pages/man7/feature_test_macros.7:218
#, no-wrap
msgid "B<_XOPEN_SOURCE> E<lt> 500"
msgstr "B<_XOPEN_SOURCE> E<lt> 500"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:222
msgid "B<_POSIX_C_SOURCE> is defined with the value 2."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 2."

#. type: TP
#: man-pages/man7/feature_test_macros.7:222
#, no-wrap
msgid "500 E<lt>= B<_XOPEN_SOURCE> E<lt> 600"
msgstr "500 E<lt>= B<_XOPEN_SOURCE> E<lt> 600"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:226
msgid "B<_POSIX_C_SOURCE> is defined with the value 199506L."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 199506L."

#. type: TP
#: man-pages/man7/feature_test_macros.7:226
#, no-wrap
msgid "600 E<lt>= B<_XOPEN_SOURCE> E<lt> 700"
msgstr "600 E<lt>= B<_XOPEN_SOURCE> E<lt> 700"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:230
msgid "B<_POSIX_C_SOURCE> is defined with the value 200112L."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 200112L."

#. type: TP
#: man-pages/man7/feature_test_macros.7:230
#, no-wrap
msgid "700 E<lt>= B<_XOPEN_SOURCE> (since glibc 2.10)"
msgstr "700 E<lt>= B<_XOPEN_SOURCE> (начиная с glibc 2.10)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:234
msgid "B<_POSIX_C_SOURCE> is defined with the value 200809L."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 200809L."

#. type: TP
#: man-pages/man7/feature_test_macros.7:236
#, no-wrap
msgid "B<_XOPEN_SOURCE_EXTENDED>"
msgstr "B<_XOPEN_SOURCE_EXTENDED>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:245
msgid ""
"If this macro is defined, and B<_XOPEN_SOURCE> is defined, then expose "
"definitions corresponding to the XPG4v2 (SUSv1) UNIX extensions (UNIX 95).  "
"This macro is also implicitly defined if B<_XOPEN_SOURCE> is defined with a "
"value of 500 or more."
msgstr ""
"Если этот макрос определён вместе с B<_XOPEN_SOURCE>, то доступны "
"определения, соответствующие расширениям UNIX (UNIX 95) XPG4v2 (SUSv1). "
"Данный макрос также неявно определён, если определён B<_XOPEN_SOURCE> со "
"значением 500 и более."

#. type: TP
#: man-pages/man7/feature_test_macros.7:245
#, no-wrap
msgid "B<_ISOC99_SOURCE> (since glibc 2.1.3)"
msgstr "B<_ISOC99_SOURCE> (начиная с glibc 2.1.3)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:248
msgid "Exposes declarations consistent with the ISO C99 standard."
msgstr ""
"Делает доступными объявления, удовлетворяющие требованиям стандарта ISO C99."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:254
msgid ""
"Earlier glibc 2.1.x versions recognized an equivalent macro named "
"B<_ISOC9X_SOURCE> (because the C99 standard had not then been finalized).  "
"Although the use of this macro is obsolete, glibc continues to recognize it "
"for backward compatibility."
msgstr ""
"Ранние версии glibc 2.1.x распознавали макрос-эквивалент B<_ISOC9X_SOURCE> "
"(так как стандарт C99 ещё не был утверждён). Хотя использование последнего "
"макроса не рекомендуется, glibc пока поддерживает его для обратной "
"совместимости."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:259
msgid ""
"Defining B<_ISOC99_SOURCE> also exposes ISO C (1990) Amendment 1 (\"C95\") "
"definitions.  (The primary change in C95 was support for international "
"character sets.)"
msgstr ""
"Делает доступными определения стандарта ISO C (1990) Amendment 1 («C95»). "
"Основным изменением в C95 была поддержка международных наборов символов."

#. type: TP
#: man-pages/man7/feature_test_macros.7:259
#, no-wrap
msgid "B<_ISOC11_SOURCE> (since glibc 2.16)"
msgstr "B<_ISOC11_SOURCE> (начиная с glibc 2.16)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:264
msgid ""
"Exposes declarations consistent with the ISO C11 standard.  Defining this "
"macro also enables C99 and C95 features (like B<_ISOC99_SOURCE>)."
msgstr ""
"Делает доступными объявления, удовлетворяющие требованиям стандарта ISO C11. "
"Определение этого макроса также включает свойства C99 и C95 (подобно B<"
"_ISOC99_SOURCE>)."

#. type: TP
#: man-pages/man7/feature_test_macros.7:264
#, no-wrap
msgid "B<_LARGEFILE64_SOURCE>"
msgstr "B<_LARGEFILE64_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:285
msgid ""
"Expose definitions for the alternative API specified by the LFS (Large File "
"Summit) as a \"transitional extension\" to the Single UNIX Specification.  "
"(See E<.UR http:\\:/\\:/opengroup.org\\:/platform\\:/lfs.html> E<.UE .)> The"
" alternative API consists of a set of new objects (i.e., functions and "
"types) whose names are suffixed with \"64\" (e.g., I<off64_t> versus "
"I<off_t>, B<lseek64>()  versus B<lseek>(), etc.).  New programs should not "
"employ this macro; instead I<_FILE_OFFSET_BITS=64> should be employed."
msgstr ""
"Делает доступными объявления альтернативного программного интерфейса, "
"определяемого в LFS (Large File Summit) как «переходного расширение» на "
"Single UNIX Specification (смотрите E<.UR "
"http:\\:/\\:/opengroup.org\\:/platform\\:/lfs.html> E<.UE)>. Альтернативный "
"программный интерфейс состоит из набора новых объектов (т. е., функций и "
"типов), чьи имена оканчиваются на «»64 (например, I<off64_t> и I<off_t>, B<"
"lseek64>() и B<lseek>(), и т. д.). В новых программах не нужно указывать этот "
"макрос; вместо него указывайте I<_FILE_OFFSET_BITS=64>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:285
#, no-wrap
msgid "B<_LARGEFILE_SOURCE>"
msgstr "B<_LARGEFILE_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:307
msgid ""
"This macro was historically used to expose certain functions (specifically "
"B<fseeko>(3)  and B<ftello>(3))  that address limitations of earlier APIs "
"(B<feek>(3)  and B<ftell>(3))  that use I<long int> for file offsets.  This "
"macro is implicitly defined if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 500.  New programs should not employ this macro; "
"defining B<_XOPEN_SOURCE> as just described or defining B<_FILE_OFFSET_BITS>"
" with the value 64 is the preferred mechanism to achieve the same result."
msgstr ""
"Данный макрос исторически используется для предоставления определённых "
"функций (в частности, B<fseeko>(3) и B<ftello>(3)), которые обходят адресные "
"ограничения раннего программного интерфейса (B<feek>(3) и B<ftell>(3)), в "
"котором для файловых смещений использовался I<long int>. Данный макрос неявно "
"определяется, если определён B<_XOPEN_SOURCE> со значением больше или равным "
"500. В новых программах не нужно определять данный макрос; определение B<"
"_XOPEN_SOURCE> или B<_FILE_OFFSET_BITS> со значением 64 является более "
"предпочтительным механизмом для достижения того же результата."

#. type: TP
#: man-pages/man7/feature_test_macros.7:307
#, no-wrap
msgid "B<_FILE_OFFSET_BITS>"
msgstr "B<_FILE_OFFSET_BITS>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:317
msgid ""
"Defining this macro with the value 64 automatically converts references to "
"32-bit functions and data types related to file I/O and filesystem "
"operations into references to their 64-bit counterparts.  This is useful for"
" performing I/O on large files (E<gt> 2 Gigabytes)  on 32-bit systems.  "
"(Defining this macro permits correctly written programs to use large files "
"with only a recompilation being required.)"
msgstr ""
"При определении данного макроса со значением 64 ссылки на 32-битные функции и "
"типы данных, относящиеся к файловому вводу-выводу и операциям с файловой "
"системой, автоматически преобразуются в их 64-битные прототипы. Это полезно "
"для выполнения ввода-вывода в огромные файлы (E<gt> 2 гигабайт) на 32-битных "
"системах (определение данного макроса позволяет корректно написанным "
"программам использовать огромные файлы, для чего требуется только "
"перекомпиляция)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:320
msgid ""
"64-bit systems naturally permit file sizes greater than 2 Gigabytes, and on "
"those systems this macro has no effect."
msgstr ""
"64-битные системы сразу позволяют работать с файлами размером больше 2 "
"гигабайт, и на этих системах данный макрос ничего не делает."

#. type: TP
#: man-pages/man7/feature_test_macros.7:320
#, no-wrap
msgid "B<_BSD_SOURCE> (deprecated since glibc 2.20)"
msgstr "B<_BSD_SOURCE> (устарел начиная с glibc 2.20)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:324
msgid ""
"Defining this macro with any value causes header files to expose BSD-derived"
" definitions."
msgstr ""
"Определение данного макроса с любым значением приводит к доступности из "
"заголовочных файлов определений BSD."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:339
msgid ""
"In glibc versions up to and including 2.18, defining this macro also causes "
"BSD definitions to be preferred in some situations where standards conflict,"
" unless one or more of B<_SVID_SOURCE>, B<_POSIX_SOURCE>, "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, or "
"B<_GNU_SOURCE> is defined, in which case BSD definitions are disfavored.  "
"Since glibc 2.19, B<_BSD_SOURCE> no longer causes BSD definitions to be "
"preferred in case of conflicts."
msgstr ""
"В glibc до версии 2.18 включительно при определении данного макроса также "
"отдаётся приоритет определениям BSD в ситуациях, когда имеется конфликт со "
"стандартами. Если определён один из макросов B<_SVID_SOURCE>, B<_POSIX_SOURCE>"
", B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED> или B<"
"_GNU_SOURCE>, то определения BSD не используются. Начиная с glibc 2.19 при "
"наличии макроса B<_BSD_SOURCE> определения BSD в случае конфликта приоритета "
"не имеют."

#.  commit c941736c92fa3a319221f65f6755659b2a5e0a20
#.  commit 498afc54dfee41d33ba519f496e96480badace8e
#.  commit acd7f096d79c181866d56d4aaf3b043e741f1e2c
#.  commit ade40b10ff5fa59a318cf55b9d8414b758e8df78
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:362
msgid ""
"Since glibc 2.20, this macro is deprecated.  It now has the same effect as "
"defining B<_DEFAULT_SOURCE>, but generates a compile-time warning (unless "
"B<_DEFAULT_SOURCE> is also defined).  Use B<_DEFAULT_SOURCE> instead.  To "
"allow code that requires B<_BSD_SOURCE> in glibc 2.19 and earlier and "
"B<_DEFAULT_SOURCE> in glibc 2.20 and later to compile without warnings, "
"define I<both> B<_BSD_SOURCE> and B<_DEFAULT_SOURCE>."
msgstr ""
"Начиная с glibc 2.20 этот макрос считается устаревшим. Теперь он действует "
"также как определение B<_DEFAULT_SOURCE>, но при компиляции генерируется "
"предупреждение (если также не определён B<_DEFAULT_SOURCE>). Используйте B<"
"_DEFAULT_SOURCE> вместо него. Чтобы для кода, которому требуется B<"
"_BSD_SOURCE> в glibc 2.19 и старее и B<_DEFAULT_SOURCE> в glibc 2.20 и новее, "
"не выдавалось предупреждение при компиляции определите B<_BSD_SOURCE> и B<"
"_DEFAULT_SOURCE> I<одновременно>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:362
#, no-wrap
msgid "B<_SVID_SOURCE> (deprecated since glibc 2.20)"
msgstr "B<_SVID_SOURCE> (устарел начиная с glibc 2.20)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:368
msgid ""
"Defining this macro with any value causes header files to expose System "
"V-derived definitions.  (SVID == System V Interface Definition; see "
"B<standards>(7).)"
msgstr ""
"При определении этого макроса с любым значением из заголовочных файлов "
"становятся доступны определения System V (SVID == System V Interface "
"Definition; смотрите B<standards>(7))."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:371
msgid ""
"Since glibc 2.20, this macro is deprecated in the same fashion as "
"B<_BSD_SOURCE>."
msgstr "Начиная с glibc 2.20 этот макрос устарел также как B<_BSD_SOURCE>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:371
#, no-wrap
msgid "B<_DEFAULT_SOURCE> (since glibc 2.19)"
msgstr "B<_DEFAULT_SOURCE> (начиная с glibc 2.19)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:383
msgid ""
"This macro can be defined to ensure that the \"default\" definitions are "
"provided even when the defaults would otherwise be disabled, as happens when"
" individual macros are explicitly defined, or the compiler is invoked in one"
" of its \"standard\" modes (e.g., I<cc\\ -std=c99>).  Defining "
"B<_DEFAULT_SOURCE> without defining other individual macros or invoking the "
"compiler in one of its \"standard\" modes has no effect."
msgstr ""
"Данный макрос можно определить, чтобы точно знать, что будут доступны "
"определения «по умолчанию» даже, если умолчательные макросы отключены, что "
"случается, когда отдельные макросы определяются явно, или компилятор "
"вызывается в одном из своих «стандартных» режимов (например, I<cc\\ -std=c99>"
"). Определение B<_DEFAULT_SOURCE> без определения отдельных макросов или "
"вызов компилятора в одном из его «стандартных» режимов не работают."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:388
msgid ""
"The \"default\" definitions comprise those required by POSIX.1-2008 as well "
"as various definitions derived from BSD and System V.  On glibc 2.19 and "
"earlier, these defaults were approximately equivalent to explicitly defining"
" the following:"
msgstr ""
"Определения «по умолчанию» охватывают все, которые требуются POSIX.1-2008, а "
"также различные определения из BSD и System V. В glibc 2.19 и старее эти "
"значения по умолчанию приблизительно эквивалентны явному определению "
"следующего:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:390
#, no-wrap
msgid "    cc -D_BSD_SOURCE -D_SVID_SOURCE -D_POSIX_C_SOURCE=200809\n"
msgstr "    cc -D_BSD_SOURCE -D_SVID_SOURCE -D_POSIX_C_SOURCE=200809\n"

#. type: TP
#: man-pages/man7/feature_test_macros.7:391
#, no-wrap
msgid "B<_ATFILE_SOURCE> (since glibc 2.4)"
msgstr "B<_ATFILE_SOURCE> (начиная с glibc 2.4)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:400
msgid ""
"Defining this macro with any value causes header files to expose "
"declarations of a range of functions with the suffix \"at\"; see "
"B<openat>(2).  Since glibc 2.10, this macro is also implicitly defined if "
"B<_POSIX_C_SOURCE> is defined with a value greater than or equal to 200809L."
msgstr ""
"При определении этого макроса с любым значением из заголовочных файлов "
"становятся доступны объявления набора функций с суффиксом «at»; смотрите B<"
"openat>(2). Начиная с glibc 2.10 данный макрос также неявно определяется, "
"если определён B<_POSIX_C_SOURCE> со значением 200809L или больше."

#. type: TP
#: man-pages/man7/feature_test_macros.7:400
#, no-wrap
msgid "B<_GNU_SOURCE>"
msgstr "B<_GNU_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:419
msgid ""
"Defining this macro (with any value) implicitly defines B<_ATFILE_SOURCE>, "
"B<_LARGEFILE64_SOURCE>, B<_ISOC99_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE> with the value 200809L (200112L in "
"glibc versions before 2.10; 199506L in glibc versions before 2.5; 199309L in"
" glibc versions before 2.1)  and B<_XOPEN_SOURCE> with the value 700 (600 in"
" glibc versions before 2.10; 500 in glibc versions before 2.2).  In "
"addition, various GNU-specific extensions are also exposed."
msgstr ""
"При определении этого макроса (с любым значением) неявно определяются B<"
"_ATFILE_SOURCE>, B<_LARGEFILE64_SOURCE>, B<_ISOC99_SOURCE>, B<"
"_XOPEN_SOURCE_EXTENDED>, B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE> со значением "
"200809L (200112L в версиях glibc до 2.10; 199506L в версиях glibc до 2.5; "
"199309L в версиях glibc до 2.1) и B<_XOPEN_SOURCE> со значением 700 (600 в "
"версиях glibc до 2.10; 500 в версиях glibc до 2.2). Также становятся доступны "
"различные расширения GNU."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:430
msgid ""
"Since glibc 2.19, defining B<_GNU_SOURCE> also has the effect of implicitly "
"defining B<_DEFAULT_SOURCE>.  In glibc versions before 2.20, defining "
"B<_GNU_SOURCE> also had the effect of implicitly defining B<_BSD_SOURCE> and"
" B<_SVID_SOURCE>."
msgstr ""
"Начиная с glibc 2.19 определение B<_GNU_SOURCE> также неявно определяет B<"
"_DEFAULT_SOURCE>. В glibc до 2.20 версии определение B<_GNU_SOURCE> также "
"неявно определяет B<_BSD_SOURCE> и B<_SVID_SOURCE>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:430
#, no-wrap
msgid "B<_REENTRANT>"
msgstr "B<_REENTRANT>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:436
msgid ""
"Defining this macro exposes definitions of certain reentrant functions.  For"
" multithreaded programs, use I<cc\\ -pthread> instead."
msgstr ""
"При определении этого макроса становятся доступны определённые "
"реентерабельные функции. Для многонитивых программ вместо него используйте I<"
"cc\\ -pthread>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:436
#, no-wrap
msgid "B<_THREAD_SAFE>"
msgstr "B<_THREAD_SAFE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:441
msgid ""
"Synonym for B<_REENTRANT>, provided for compatibility with some other "
"implementations."
msgstr ""
"Синоним B<_REENTRANT>, предоставляется для совместимости с некоторыми другими "
"реализациями."

#. type: TP
#: man-pages/man7/feature_test_macros.7:441
#, no-wrap
msgid "B<_FORTIFY_SOURCE> (since glibc 2.3.4)"
msgstr "B<_FORTIFY_SOURCE> (начиная с glibc 2.3.4)"

#.  For more detail, see:
#.  http://gcc.gnu.org/ml/gcc-patches/2004-09/msg02055.html
#.  [PATCH] Object size checking to prevent (some) buffer overflows
#.  * From: Jakub Jelinek <jakub at redhat dot com>
#.  * To: gcc-patches at gcc dot gnu dot org
#.  * Date: Tue, 21 Sep 2004 04:16:40 -0400
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:453
msgid ""
"Defining this macro causes some lightweight checks to be performed to detect"
" some buffer overflow errors when employing various string and memory "
"manipulation functions.  Not all buffer overflows are detected, just some "
"common cases."
msgstr ""
"Определение этого макроса вызывает выполнение нескольких простых проверок для "
"обнаружения ошибок переполнения буфера, которые возникают в различных "
"функциях работы со строками и памятью. Обнаруживаются не все переполнения "
"буфера, только несколько распространённых случаев."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:471
msgid ""
"In the current implementation, checks are added for calls to B<memcpy>(3), "
"B<mempcpy>(3), B<memmove>(3), B<memset>(3), B<stpcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<strcat>(3), B<strncat>(3), B<sprintf>(3), B<snprintf>(3), "
"B<vsprintf>(3), B<vsnprintf>(3), and B<gets>(3)."
msgstr ""
"В текущей реализации проверки добавляются к вызовам B<memcpy>(3), B<mempcpy>"
"(3), B<memmove>(3), B<memset>(3), B<stpcpy>(3), B<strcpy>(3), B<strncpy>(3), "
"B<strcat>(3), B<strncat>(3), B<sprintf>(3), B<snprintf>(3), B<vsprintf>(3), "
"B<vsnprintf>(3) и B<gets>(3)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:486
msgid ""
"If B<_FORTIFY_SOURCE> is set to 1, with compiler optimization level 1 "
"(I<gcc\\ -O1>)  and above, checks that shouldn't change the behavior of "
"conforming programs are performed.  With B<_FORTIFY_SOURCE> set to 2 some "
"more checking is added, but some conforming programs might fail.  Some of "
"the checks can be performed at compile time, and result in compiler "
"warnings; other checks take place at run time, and result in a run-time "
"error if the check fails."
msgstr ""
"Если значение B<_FORTIFY_SOURCE> равно 1 и уровень оптимизации компиляции "
"равен 1 (I<gcc\\ -O1>) и больше, то выполняются проверки,  которые не "
"изменяют поведение выверяемых программ. Если значение B<_FORTIFY_SOURCE> "
"равно 2, то добавляются дополнительные проверки, но некоторые выверяемые "
"программы могут завершаться с ошибкой. Некоторые проверки выполняются во "
"время компиляции и вызывают предупреждение компилятора; другие проверки "
"выполняются во время выполнения и приводят к ошибкам времени выполнения."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:490
msgid ""
"Use of this macro requires compiler support, available with B<gcc>(1)  since"
" version 4.0."
msgstr ""
"Для работы этого макроса требуется поддержка в компиляторе, доступная в B<gcc>"
"(1) начиная с версии 4.0."

#. type: SS
#: man-pages/man7/feature_test_macros.7:490
#, no-wrap
msgid "Default definitions, implicit definitions, and combining definitions"
msgstr ""
"Определения по умолчанию, неявные определения и объединяющие определения"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:506
msgid ""
"If no feature test macros are explicitly defined, then the following feature"
" test macros are defined by default: B<_BSD_SOURCE> (in glibc 2.19 and "
"earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), B<_DEFAULT_SOURCE> "
"(since glibc 2.19), B<_POSIX_SOURCE>, and B<_POSIX_C_SOURCE>=200809L "
"(200112L in glibc versions before 2.10; 199506L in glibc versions before "
"2.4; 199309L in glibc versions before 2.1)."
msgstr ""
"Если макросы тестирования свойств не указаны явно, то по умолчанию действуют "
"следующие макросы тестирования свойств: B<_BSD_SOURCE> (в glibc 2.19 и "
"старее), B<_SVID_SOURCE> (в glibc 2.19 и старее), B<_DEFAULT_SOURCE> (начиная "
"с glibc 2.19), B<_POSIX_SOURCE> и B<_POSIX_C_SOURCE>=200809L (200112L в "
"версиях glibc до 2.10; 199506L в версиях glibc до 2.4; 199309L в версиях "
"glibc до 2.1)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:525
msgid ""
"If any of B<__STRICT_ANSI__>, B<_ISOC99_SOURCE>, B<_POSIX_SOURCE>, "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, "
"B<_BSD_SOURCE> (in glibc 2.19 and earlier), or B<_SVID_SOURCE> (in glibc "
"2.19 and earlier)  is explicitly defined, then B<_BSD_SOURCE>, "
"B<_SVID_SOURCE>, and B<_DEFAULT_SOURCE> are not defined by default."
msgstr ""
"Если любой из макросов B<__STRICT_ANSI__>, B<_ISOC99_SOURCE>, B<_POSIX_SOURCE>"
", B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, B<"
"_BSD_SOURCE> (в glibc 2.19 и старее) или B<_SVID_SOURCE> (в glibc 2.19 и "
"старее) указан явно, то по умолчанию не определяются макросы B<_BSD_SOURCE>, "
"B<_SVID_SOURCE> и B<_DEFAULT_SOURCE>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:536
msgid ""
"If B<_POSIX_SOURCE> and B<_POSIX_C_SOURCE> are not explicitly defined, and "
"either B<__STRICT_ANSI__> is not defined or B<_XOPEN_SOURCE> is defined with"
" a value of 500 or more, then"
msgstr ""
"Если макросы B<_POSIX_SOURCE> и B<_POSIX_C_SOURCE> не указаны явно и не "
"определён B<__STRICT_ANSI__> или B<_XOPEN_SOURCE> определён со значением 500 "
"или более, то"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:539
msgid "B<_POSIX_SOURCE> is defined with the value 1; and"
msgstr "B<_POSIX_SOURCE> определяется со значением 1; и"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:542
msgid "B<_POSIX_C_SOURCE> is defined with one of the following values:"
msgstr "B<_POSIX_C_SOURCE> определяется с одним из следующих значений:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:548
msgid "2, if B<_XOPEN_SOURCE> is defined with a value less than 500;"
msgstr "2, если B<_XOPEN_SOURCE> определён со значением меньше 500;"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:554
msgid ""
"199506L, if B<_XOPEN_SOURCE> is defined with a value greater than or equal "
"to 500 and less than 600; or"
msgstr ""
"199506L, если B<_XOPEN_SOURCE> определён со значением 500 или более, но "
"меньше 600; или"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:559
msgid ""
"(since glibc 2.4) 200112L, if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 600 and less than 700."
msgstr ""
"(начиная с glibc 2.4) 200112L, если B<_XOPEN_SOURCE> определён со значением "
"600 или более, но меньше 700."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:565
msgid ""
"(Since glibc 2.10)  200809L, if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 700."
msgstr ""
"(начиная с glibc 2.10) 200809L, если B<_XOPEN_SOURCE> определён со значением "
"700 или более."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:570
msgid ""
"Older versions of glibc do not know about the values 200112L and 200809L for"
" B<_POSIX_C_SOURCE>, and the setting of this macro will depend on the glibc "
"version."
msgstr ""
"Старые версии glibc не знают о значениях 200112L и 200809L у  B<"
"_POSIX_C_SOURCE>, и значение этого макроса зависит от версии glibc."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:579
msgid ""
"If B<_XOPEN_SOURCE> is undefined, then the setting of B<_POSIX_C_SOURCE> "
"depends on the glibc version: 199506L, in glibc versions before 2.4; "
"200112L, in glibc 2.4 to 2.9; and 200809L, since glibc 2.10."
msgstr ""
"Если макрос B<_XOPEN_SOURCE> не определён, то значение B<_POSIX_C_SOURCE> "
"зависит от версии glibc: 199506L в версиях glibc до 2.4; 200112L в glibc от "
"2.4 до 2.9 и 200809L в glibc 2.10 и новее."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:582
msgid "Multiple macros can be defined; the results are additive."
msgstr "Можно определять несколько макросов; результат складывается."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:590
msgid ""
"POSIX.1 specifies B<_POSIX_C_SOURCE>, B<_POSIX_SOURCE>, and "
"B<_XOPEN_SOURCE>.  B<_XOPEN_SOURCE_EXTENDED> was specified by XPG4v2 (aka "
"SUSv1)."
msgstr ""
"В POSIX.1 описаны B<_POSIX_C_SOURCE>, B<_POSIX_SOURCE> и B<_XOPEN_SOURCE>. "
"Макрос B<_XOPEN_SOURCE_EXTENDED> указан в XPG4v2 (также называемом SUSv1)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:594
msgid ""
"B<_FILE_OFFSET_BITS> is not specified by any standard, but is employed on "
"some other implementations."
msgstr ""
"Макрос B<_FILE_OFFSET_BITS> отсутствует в стандартах, но используется в "
"некоторых других реализациях."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:605
msgid ""
"B<_BSD_SOURCE>, B<_SVID_SOURCE>, B<_DEFAULT_SOURCE>, B<_ATFILE_SOURCE>, "
"B<_GNU_SOURCE>, B<_FORTIFY_SOURCE>, B<_REENTRANT>, and B<_THREAD_SAFE> are "
"specific to Linux (glibc)."
msgstr ""
"Макросы B<_BSD_SOURCE>, B<_SVID_SOURCE>, B<_DEFAULT_SOURCE>, B<_ATFILE_SOURCE>"
", B<_GNU_SOURCE>, B<_FORTIFY_SOURCE>, B<_REENTRANT> и B<_THREAD_SAFE> есть "
"только в Linux (glibc)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:612
msgid ""
"I<E<lt>features.hE<gt>> is a Linux/glibc-specific header file.  Other "
"systems have an analogous file, but typically with a different name.  This "
"header file is automatically included by other header files as required: it "
"is not necessary to explicitly include it in order to employ feature test "
"macros."
msgstr ""
"Файл I<E<lt>features.hE<gt>> есть только в Linux/glibc. В других системах "
"есть аналогичный файл, но, обычно, с другим именем. Данный заголовочный файл, "
"если нужен, автоматически включается из других заголовочных файлов: его "
"необязательно явно указывать для использования макросов тестирования свойств."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:624
msgid ""
"According to which of the above feature test macros are defined, "
"I<E<lt>features.hE<gt>> internally defines various other macros that are "
"checked by other glibc header files.  These macros have names prefixed by "
"two underscores (e.g., B<__USE_MISC>).  Programs should I<never> define "
"these macros directly: instead, the appropriate feature test macro(s) from "
"the list above should be employed."
msgstr ""
"Согласно указанным макросам тестирования свойств раньше файла I<E<lt>"
"features.hE<gt>>, внутри него определяются другие различные макросы, которые "
"проверяются в других заголовочных файлах glibc. Эти макросы имеют имена, "
"начинающиеся с двух подчёркиваний (например, B<__USE_MISC>). Программы I<"
"никогда> не должны определять эти макросы самостоятельно: вместо этого нужно "
"задействовать соответствующий макрос тестирования свойств из перечисленных "
"ранее."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:630
msgid ""
"The program below can be used to explore how the various feature test macros"
" are set depending on the glibc version and what feature test macros are "
"explicitly set.  The following shell session, on a system with glibc 2.10, "
"shows some examples of what we would see:"
msgstr ""
"Представленную далее программу можно использовать для изучения какие значения "
"присваиваются макросам тестирования свойств в зависимости от версии glibc и "
"какие макросы тестирования свойств устанавливаются явно. В следующем сеансе "
"оболочки на системе с glibc 2.10 показаны несколько примеров того, что мы "
"увидели:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:657
#, no-wrap
msgid ""
"$ B<cc ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"$ B<cc -D_XOPEN_SOURCE=500 ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 199506L\n"
"_XOPEN_SOURCE defined: 500\n"
"$ B<cc -D_GNU_SOURCE ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_ISOC99_SOURCE defined\n"
"_XOPEN_SOURCE defined: 700\n"
"_XOPEN_SOURCE_EXTENDED defined\n"
"_LARGEFILE64_SOURCE defined\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"_GNU_SOURCE defined\n"
msgstr ""
"$ B<cc ftm.c>\n$ B<./a.out>\n_POSIX_SOURCE defined\n_POSIX_C_SOURCE defined: "
"200809L\n_BSD_SOURCE defined\n_SVID_SOURCE defined\n_ATFILE_SOURCE defined\n$ "
"B<cc -D_XOPEN_SOURCE=500 ftm.c>\n$ B<./a.out>\n_POSIX_SOURCE "
"defined\n_POSIX_C_SOURCE defined: 199506L\n_XOPEN_SOURCE defined: 500\n$ B<cc "
"-D_GNU_SOURCE ftm.c>\n$ B<./a.out>\n_POSIX_SOURCE defined\n_POSIX_C_SOURCE "
"defined: 200809L\n_ISOC99_SOURCE defined\n_XOPEN_SOURCE defined: "
"700\n_XOPEN_SOURCE_EXTENDED defined\n_LARGEFILE64_SOURCE defined\n_BSD_SOURCE "
"defined\n_SVID_SOURCE defined\n_ATFILE_SOURCE defined\n_GNU_SOURCE defined\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:663
#, no-wrap
msgid "/* ftm.c */\n"
msgstr "/* ftm.c */\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:667
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>"
"stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:674
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#ifdef _POSIX_SOURCE\n"
"    printf(\"_POSIX_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n#ifdef _POSIX_SOURCE\n    "
"printf(\"_POSIX_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:678
#, no-wrap
msgid ""
"#ifdef _POSIX_C_SOURCE\n"
"    printf(\"_POSIX_C_SOURCE defined: %ldL\\en\", (long) _POSIX_C_SOURCE);\n"
"#endif\n"
msgstr ""
"#ifdef _POSIX_C_SOURCE\n    printf(\"_POSIX_C_SOURCE defined: %ldL\\en\", "
"(long) _POSIX_C_SOURCE);\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:682
#, no-wrap
msgid ""
"#ifdef _ISOC99_SOURCE\n"
"    printf(\"_ISOC99_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _ISOC99_SOURCE\n    printf(\"_ISOC99_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:686
#, no-wrap
msgid ""
"#ifdef _ISOC11_SOURCE\n"
"    printf(\"_ISOC11_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _ISOC11_SOURCE\n    printf(\"_ISOC11_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:690
#, no-wrap
msgid ""
"#ifdef _XOPEN_SOURCE\n"
"    printf(\"_XOPEN_SOURCE defined: %d\\en\", _XOPEN_SOURCE);\n"
"#endif\n"
msgstr ""
"#ifdef _XOPEN_SOURCE\n    printf(\"_XOPEN_SOURCE defined: %d\\en\", "
"_XOPEN_SOURCE);\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:694
#, no-wrap
msgid ""
"#ifdef _XOPEN_SOURCE_EXTENDED\n"
"    printf(\"_XOPEN_SOURCE_EXTENDED defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _XOPEN_SOURCE_EXTENDED\n    printf(\"_XOPEN_SOURCE_EXTENDED "
"defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:698
#, no-wrap
msgid ""
"#ifdef _LARGEFILE64_SOURCE\n"
"    printf(\"_LARGEFILE64_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _LARGEFILE64_SOURCE\n    printf(\"_LARGEFILE64_SOURCE "
"defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:702
#, no-wrap
msgid ""
"#ifdef _FILE_OFFSET_BITS\n"
"    printf(\"_FILE_OFFSET_BITS defined: %d\\en\", _FILE_OFFSET_BITS);\n"
"#endif\n"
msgstr ""
"#ifdef _FILE_OFFSET_BITS\n    printf(\"_FILE_OFFSET_BITS defined: %d\\en\", "
"_FILE_OFFSET_BITS);\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:706
#, no-wrap
msgid ""
"#ifdef _BSD_SOURCE\n"
"    printf(\"_BSD_SOURCE defined\\en\");\n"
"#endif\n"
msgstr "#ifdef _BSD_SOURCE\n    printf(\"_BSD_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:710
#, no-wrap
msgid ""
"#ifdef _SVID_SOURCE\n"
"    printf(\"_SVID_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _SVID_SOURCE\n    printf(\"_SVID_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:714
#, no-wrap
msgid ""
"#ifdef _DEFAULT_SOURCE\n"
"    printf(\"_DEFAULT_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _DEFAULT_SOURCE\n    printf(\"_DEFAULT_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:718
#, no-wrap
msgid ""
"#ifdef _ATFILE_SOURCE\n"
"    printf(\"_ATFILE_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _ATFILE_SOURCE\n    printf(\"_ATFILE_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:722
#, no-wrap
msgid ""
"#ifdef _GNU_SOURCE\n"
"    printf(\"_GNU_SOURCE defined\\en\");\n"
"#endif\n"
msgstr "#ifdef _GNU_SOURCE\n    printf(\"_GNU_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:726
#, no-wrap
msgid ""
"#ifdef _REENTRANT\n"
"    printf(\"_REENTRANT defined\\en\");\n"
"#endif\n"
msgstr "#ifdef _REENTRANT\n    printf(\"_REENTRANT defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:730
#, no-wrap
msgid ""
"#ifdef _THREAD_SAFE\n"
"    printf(\"_THREAD_SAFE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _THREAD_SAFE\n    printf(\"_THREAD_SAFE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:734
#, no-wrap
msgid ""
"#ifdef _FORTIFY_SOURCE\n"
"    printf(\"_FORTIFY_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _FORTIFY_SOURCE\n    printf(\"_FORTIFY_SOURCE defined\\en\");\n#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:737
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:741
msgid "B<libc>(7), B<standards>(7)"
msgstr "B<libc>(7), B<standards>(7)"

#.  But beware: the info libc document is out of date (Jul 07, mtk)
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:745
msgid "The section \"Feature Test Macros\" under I<info libc>."
msgstr "Раздел «Макросы тестирования свойств» в I<info libc>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:746
msgid "I</usr/include/features.h>"
msgstr "I</usr/include/features.h>"

#. type: TH
#: man-pages/man7/fifo.7:13
#, no-wrap
msgid "FIFO"
msgstr "FIFO"

#. type: TH
#: man-pages/man7/fifo.7:13
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: man-pages/man7/fifo.7:16
msgid "fifo - first-in first-out special file, named pipe"
msgstr ""
"fifo - специальный файл, организующий очередь (first-in first-out), "
"именованный канал"

#. type: Plain text
#: man-pages/man7/fifo.7:28
msgid ""
"A FIFO special file (a named pipe) is similar to a pipe, except that it is "
"accessed as part of the filesystem.  It can be opened by multiple processes "
"for reading or writing.  When processes are exchanging data via the FIFO, "
"the kernel passes all data internally without writing it to the filesystem."
"  Thus, the FIFO special file has no contents on the filesystem; the "
"filesystem entry merely serves as a reference point so that processes can "
"access the pipe using a name in the filesystem."
msgstr ""
"Специальный файл FIFO (именованный канал) подобен каналу, за исключением "
"того, что доступен как часть файловой системы. Его можно открывать из "
"нескольких процессов на чтении или запись. Когда процессы обмениваются "
"данными через FIFO, ядро передаёт все данные без их записи в файловую "
"систему. То есть, специальный файл FIFO не хранит содержимое в файловой "
"системе; запись в файловой системе служит просто местом, посредством которого "
"процессы могут получить доступ к каналу, используя имя в файловой системе."

#. type: Plain text
#: man-pages/man7/fifo.7:35
msgid ""
"The kernel maintains exactly one pipe object for each FIFO special file that"
" is opened by at least one process.  The FIFO must be opened on both ends "
"(reading and writing)  before data can be passed.  Normally, opening the "
"FIFO blocks until the other end is opened also."
msgstr ""
"Ядро поддерживает один объект канала для каждого специального файла FIFO, "
"который открыт хотя бы одним процессом. Для того, чтобы пропускать данные, "
"FIFO должен быть открыт как для чтения, так и для записи. Обычно, при "
"открытии FIFO он блокируется до тех пор, пока вышеописанные условия не будут "
"выполнены."

#. type: Plain text
#: man-pages/man7/fifo.7:44
msgid ""
"A process can open a FIFO in nonblocking mode.  In this case, opening for "
"read-only will succeed even if no-one has opened on the write side yet, "
"opening for write-only will fail with B<ENXIO> (no such device or address) "
"unless the other end has already been opened."
msgstr ""
"Процесс может открыть FIFO в неблокирующем режиме. В этом случае специальный "
"файл открывается только для чтения, даже если никто не открывал его для "
"записи; если это произойдет, то вернётся сообщение об ошибке B<ENXIO> (нет "
"такого устройства или адреса), хотя файл открыт для чтения."

#. type: Plain text
#: man-pages/man7/fifo.7:54
msgid ""
"Under Linux, opening a FIFO for read and write will succeed both in blocking"
" and nonblocking mode.  POSIX leaves this behavior undefined.  This can be "
"used to open a FIFO for writing while there are no readers available.  A "
"process that uses both ends of the connection in order to communicate with "
"itself should be very careful to avoid deadlocks."
msgstr ""
"В Linux открытие FIFO для чтения и записи может быть осуществлено в "
"блокирующем и неблокирующем режимах. Так как POSIX не описывает эти "
"положения, это может быть использовано для открытия FIFO для чтения в "
"отсутствие считывающих процессов. Процесс, использующий этот файл для чтения "
"и записи (для связи с самим собой), не должен допустить возникновения "
"блокировок (deadlocks)."

#. type: Plain text
#: man-pages/man7/fifo.7:59
msgid ""
"When a process tries to write to a FIFO that is not opened for read on the "
"other side, the process is sent a B<SIGPIPE> signal."
msgstr ""
"Если процесс попытается записать данные в FIFO, который не открыт для чтения, "
"то ему посылается сигнал B<SIGPIPE>."

#. type: Plain text
#: man-pages/man7/fifo.7:65
msgid ""
"FIFO special files can be created by B<mkfifo>(3), and are indicated by I<ls"
" -l> with the file type \\(aqp\\(aq."
msgstr ""
"Специальные файлы FIFO могут быть созданы с помощью B<mkfifo>(3); при выводе "
"I<ls -l> они отображаются с типом файла «p»."

#. type: Plain text
#: man-pages/man7/fifo.7:73
msgid ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), "
"B<socketpair>(2), B<mkfifo>(3), B<pipe>(7)"
msgstr ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), B<"
"socketpair>(2), B<mkfifo>(3), B<pipe>(7)"

#. type: TH
#: man-pages/man7/futex.7:11
#, no-wrap
msgid "FUTEX"
msgstr "FUTEX"

#. type: TH
#: man-pages/man7/futex.7:11
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: man-pages/man7/futex.7:14
msgid "futex - fast user-space locking"
msgstr "futex - быстрая блокировка в пользовательском пространстве"

#. type: Plain text
#: man-pages/man7/futex.7:17
#, no-wrap
msgid "B<#include E<lt>linux/futex.hE<gt>>\n"
msgstr "B<#include E<lt>linux/futex.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/futex.7:25
msgid ""
"The Linux kernel provides futexes (\"Fast user-space mutexes\")  as a "
"building block for fast user-space locking and semaphores.  Futexes are very"
" basic and lend themselves well for building higher level locking "
"abstractions such as POSIX mutexes."
msgstr ""
"Ядро Linux предоставляет фьютексы (futexes, «быстрые мьютексы (mutexes, "
"взаимоисключающие блокировки) в пользовательском пространстве») в качестве "
"строительного блока для быстрой блокировки в пользовательском пространстве и "
"семафоров. Фьютексы очень просты и полезны для создания высокоуровневых "
"абстракций блокировок, таких как мьютексы POSIX."

#. type: Plain text
#: man-pages/man7/futex.7:32
msgid ""
"This page does not set out to document all design decisions but restricts "
"itself to issues relevant for application and library development.  Most "
"programmers will in fact not be using futexes directly but instead rely on "
"system libraries built on them, such as the NPTL pthreads implementation."
msgstr ""
"В эту страницу не поместились все проектные решения; здесь описано только "
"детали, относящиеся к использованию и разработке библиотек. Фактически, "
"большинству программистов не нужно использовать фьютексы напрямую, вместо них "
"лучше обратиться к системным библиотекам, построенным на их основе, например "
"NPTL — реализация pthreads."

#. type: Plain text
#: man-pages/man7/futex.7:39
msgid ""
"A futex is identified by a piece of memory which can be shared between "
"different processes.  In these different processes, it need not have "
"identical addresses.  In its bare form, a futex has semaphore semantics; it "
"is a counter that can be incremented and decremented atomically; processes "
"can wait for the value to become positive."
msgstr ""
"Фьютекс отождествляется с участком памяти, который может быть общим для "
"нескольких процессов. В этих процессах он может быть доступен по разным "
"адресам. В своей основе фьютекс имеет семантику семафора; это счётчик, "
"который можно увеличивать и уменьшать атомарно; процессы могут ждать пока "
"значение не станет положительным."

#. type: Plain text
#: man-pages/man7/futex.7:44
msgid ""
"Futex operation is entirely user space for the noncontended case.  The "
"kernel is involved only to arbitrate the contended case.  As any sane design"
" will strive for noncontention, futexes are also optimized for this "
"situation."
msgstr ""
"Работа с фьютексом происходит полностью в пользовательском пространстве при "
"отсутствии конфликта (noncontended case). Ядро привлекается только для "
"разрешения конфликтов. Так как все проектные решения стремятся к отсутствию "
"конфликтов, фьютексы также оптимизированы под эту ситуацию."

#. type: Plain text
#: man-pages/man7/futex.7:51
msgid ""
"In its bare form, a futex is an aligned integer which is touched only by "
"atomic assembler instructions.  Processes can share this integer using "
"B<mmap>(2), via shared memory segments or because they share memory space, "
"in which case the application is commonly called multithreaded."
msgstr ""
"В своей основе фьютекс — это целое число, которое изменяется только "
"атомарными инструкциями ассемблера. Процессы могут совместно использовать это "
"число посредством B<mmap>(2), сегментов общей памяти или общего пространства "
"памяти (share memory space, в этом случае приложение, обычно, называют "
"многонитивым)."

#. type: SS
#: man-pages/man7/futex.7:51
#, no-wrap
msgid "Semantics"
msgstr "Поведение"

#. type: Plain text
#: man-pages/man7/futex.7:57
msgid ""
"Any futex operation starts in user space, but it may be necessary to "
"communicate with the kernel using the B<futex>(2)  system call."
msgstr ""
"Любое действие с фьютексом начинается в пользовательском пространстве, но "
"может потребовать обращения к ядру через системный вызов B<futex>(2)."

#. type: Plain text
#: man-pages/man7/futex.7:63
msgid ""
"To \"up\" a futex, execute the proper assembler instructions that will cause"
" the host CPU to atomically increment the integer.  Afterward, check if it "
"has in fact changed from 0 to 1, in which case there were no waiters and the"
" operation is done.  This is the noncontended case which is fast and should "
"be common."
msgstr ""
"Для «установки» фьютекса выполняются соответствующие ассемблерные инструкции, "
"которые заставляют ЦП машины атомарно увеличить целое число. Далее "
"проверяется, было ли действительно изменено значение с 0 на 1, то есть не "
"было ожидающих и операция выполнена. Это бесконфликтный вариант, выполняется "
"быстро и должен возникать чаще всего."

#. type: Plain text
#: man-pages/man7/futex.7:71
msgid ""
"In the contended case, the atomic increment changed the counter from -1 (or "
"some other negative number).  If this is detected, there are waiters.  User "
"space should now set the counter to 1 and instruct the kernel to wake up any"
" waiters using the B<FUTEX_WAKE> operation."
msgstr ""
"При возникновении конфликта, атомарное увеличение изменяет счётчик с -1 (или "
"другого отрицательного числа). Это означает, что есть ожидающие. В "
"пользовательском пространстве теперь нужно присвоить счётчику 1 и дать "
"команду ядру пробудить всех ожидающих с помощью операции B<FUTEX_WAKE>."

#. type: Plain text
#: man-pages/man7/futex.7:80
msgid ""
"Waiting on a futex, to \"down\" it, is the reverse operation.  Atomically "
"decrement the counter and check if it changed to 0, in which case the "
"operation is done and the futex was uncontended.  In all other "
"circumstances, the process should set the counter to -1 and request that the"
" kernel wait for another process to up the futex.  This is done using the "
"B<FUTEX_WAIT> operation."
msgstr ""
"Ожидание фьютекса, его «сброс», является обратной операцией. Происходит "
"атомарное уменьшение счётчика и проверка того, стал ли он равен 0, то есть "
"операция выполнена и фьютекс был неконфликтным. Во всех других случаях, "
"процесс должен присвоить счётчику -1 и запросить ядро об ожидании другого "
"процесса, устанавливающего фьютекс. Это выполняется с помощью операции B<"
"FUTEX_WAIT>."

#. type: Plain text
#: man-pages/man7/futex.7:92
msgid ""
"The B<futex>(2)  system call can optionally be passed a timeout specifying "
"how long the kernel should wait for the futex to be upped.  In this case, "
"semantics are more complex and the programmer is referred to B<futex>(2)  "
"for more details.  The same holds for asynchronous futex waiting."
msgstr ""
"В системном вызове B<futex>(2) можно указать время ожидания, то есть как "
"долго ядро должно ждать установку фьютекса, В этом случае семантика более "
"сложна и программисту нужно обратиться к B<futex>(2). Это тоже самое что и "
"ожидания асинхронного фьютекса."

#. type: Plain text
#: man-pages/man7/futex.7:97
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics"
" from those described above.  Current semantics are available from Linux "
"2.5.40 onward."
msgstr ""
"Впервые поддержка фьютексов появилась в Linux 2.5.7, но с другой семантикой. "
"Текущая семантика используется в Linux с версии 2.5.40."

#. type: Plain text
#: man-pages/man7/futex.7:104
msgid ""
"To reiterate, bare futexes are not intended as an easy to use abstraction "
"for end-users.  Implementors are expected to be assembly literate and to "
"have read the sources of the futex user-space library referenced below."
msgstr ""
"Ещё раз повторим: в чистом виде фьютексы не являются лёгкой в использовании "
"абстракцией для конечных пользователей. Использующие их программисты должны "
"иметь хороший запас знаний об ассемблере и уметь читать исходный код "
"библиотеки фьютексов для пользовательского пространства, указанной далее."

#.  .SH "AUTHORS"
#.  .PP
#.  Futexes were designed and worked on by Hubertus Franke
#.  (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat) and
#.  Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: man-pages/man7/futex.7:115
msgid ""
"This man page illustrates the most common use of the B<futex>(2)  "
"primitives: it is by no means the only one."
msgstr ""
"В этой справочной странице показано самое распространённое использование "
"примитивов B<futex>(2), которое ни в коем случае не единственное."

#. type: Plain text
#: man-pages/man7/futex.7:117
msgid "B<futex>(2)"
msgstr "B<futex>(2)"

#. type: Plain text
#: man-pages/man7/futex.7:122
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), futex example library, futex-*.tar.bz2 "
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE .>"
msgstr ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (доклад с "
"Ottawa Linux Symposium 2002), пример в библиотеке futex, futex-*.tar.bz2 E<"
".UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<.UE "
".>"

#. type: TH
#: man-pages/man2/fork.2:39
#, no-wrap
msgid "FORK"
msgstr "FORK"

#. type: TH
#: man-pages/man2/fork.2:39
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man2/fork.2:42
msgid "fork - create a child process"
msgstr "fork - создаёт дочерний процесс"

#. type: Plain text
#: man-pages/man2/fork.2:46
msgid "B<pid_t fork(void);>"
msgstr "B<pid_t fork(void);>"

#. type: Plain text
#: man-pages/man2/fork.2:52
msgid ""
"B<fork>()  creates a new process by duplicating the calling process.  The "
"new process, referred to as the I<child>, is an exact duplicate of the "
"calling process, referred to as the I<parent>, except for the following "
"points:"
msgstr ""
"Вызов B<fork>() создает новый процесс посредством копирования вызывающего "
"процесса. Новый процесс, называемый I<потомком>, является точной копией "
"вызывающего процесса, который называется I<родительским>, за исключением "
"следующих моментов:"

#. type: Plain text
#: man-pages/man2/fork.2:56
msgid ""
"The child has its own unique process ID, and this PID does not match the ID "
"of any existing process group (B<setpgid>(2))."
msgstr ""
"Потомок имеет свой уникальный идентификатор процесса, и этот PID "
"(идентификатор процесса) не совпадает ни с одним существующим идентификатором "
"группы процессов (B<setpgid>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:58
msgid "The child's parent process ID is the same as the parent's process ID."
msgstr ""
"Идентификатор родительского процесса у потомка равен идентификатору "
"родительского процесса."

#. type: Plain text
#: man-pages/man2/fork.2:62
msgid ""
"The child does not inherit its parent's memory locks (B<mlock>(2), "
"B<mlockall>(2))."
msgstr ""
"Потомок не наследует блокировки памяти родителя (B<mlock>(2), B<mlockall>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:68
msgid ""
"Process resource utilizations (B<getrusage>(2))  and CPU time counters "
"(B<times>(2))  are reset to zero in the child."
msgstr ""
"Счётчики использования ресурсов (B<getrusage>(2)) и времени ЦП у потомка "
"сброшены в 0."

#. type: Plain text
#: man-pages/man2/fork.2:71
msgid ""
"The child's set of pending signals is initially empty (B<sigpending>(2))."
msgstr "Набор ожидающих сигналов потомка изначально пуст (B<sigpending>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:74
msgid ""
"The child does not inherit semaphore adjustments from its parent "
"(B<semop>(2))."
msgstr "Потомок не наследует значения семафоров родителя (B<semop>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:82
msgid ""
"The child does not inherit process-associated record locks from its parent "
"(B<fcntl>(2)).  (On the other hand, it does inherit B<fcntl>(2)  open file "
"description locks and B<flock>(2)  locks from its parent.)"
msgstr ""
"Потомок не наследует связанные с процессом блокировки родителя "
"(B<fcntl>(2)) (с другой стороны, он наследует блокировки файловых "
"описаний B<fcntl>(2) и блокировки B<flock>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:87
msgid ""
"The child does not inherit timers from its parent (B<setitimer>(2), "
"B<alarm>(2), B<timer_create>(2))."
msgstr ""
"Потомок не наследует таймеры родителя (B<setitimer>(2), B<alarm>(2), B<"
"timer_create>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:94
msgid ""
"The child does not inherit outstanding asynchronous I/O operations from its "
"parent (B<aio_read>(3), B<aio_write>(3)), nor does it inherit any "
"asynchronous I/O contexts from its parent (see B<io_setup>(2))."
msgstr ""
"Потомок не наследует ожидающие выполнения операции асинхронного ввода-вывода "
"(B<aio_read>(3), B<aio_write>(3)) и контексты асинхронного ввода-вывода "
"родителя (см. B<io_setup>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:99
msgid ""
"The process attributes in the preceding list are all specified in "
"POSIX.1-2001.  The parent and child also differ with respect to the "
"following Linux-specific process attributes:"
msgstr ""
"Все перечисленные атрибуты указаны в POSIX.1-2001. Родитель и потомок также "
"отличаются по следующим атрибутам процесса, которые есть только в Linux:"

#. type: Plain text
#: man-pages/man2/fork.2:106
msgid ""
"The child does not inherit directory change notifications (dnotify)  from "
"its parent (see the description of B<F_NOTIFY> in B<fcntl>(2))."
msgstr ""
"Потомок не наследует уведомления об изменении каталога (dnotify) родителя "
"(смотрите описание B<F_NOTIFY> в B<fcntl>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:112
msgid ""
"The B<prctl>(2)  B<PR_SET_PDEATHSIG> setting is reset so that the child does"
" not receive a signal when its parent terminates."
msgstr ""
"Настройка B<PR_SET_PDEATHSIG> у B<prctl>(2) сбрасывается, и поэтому потомок "
"не принимает сигнал о завершении работы родителя."

#. type: Plain text
#: man-pages/man2/fork.2:119
msgid ""
"The default timer slack value is set to the parent's current timer slack "
"value.  See the description of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""
"Резервное значение по умолчанию устанавливается равным родительскому текущему "
"резервному значению таймера. Смотрите описание B<PR_SET_TIMERSLACK> в B<prctl>"
"(2)."

#. type: Plain text
#: man-pages/man2/fork.2:125
msgid ""
"Memory mappings that have been marked with the B<madvise>(2)  "
"B<MADV_DONTFORK> flag are not inherited across a B<fork>()."
msgstr ""
"Отображение памяти, помеченное с помощью флага B<MADV_DONTFORK> через B<"
"madvise>(2), при B<fork>() не наследуется."

#. type: Plain text
#: man-pages/man2/fork.2:130
msgid ""
"The termination signal of the child is always B<SIGCHLD> (see B<clone>(2))."
msgstr "Сигнал завершения работы потомка всегда B<SIGCHLD> (см. B<clone>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:136
msgid ""
"The port access permission bits set by B<ioperm>(2)  are not inherited by "
"the child; the child must turn on any bits that it requires using "
"B<ioperm>(2)."
msgstr ""
"Биты прав доступа к порту, установленные с помощью B<ioperm>(2), не "
"наследуются потомком; потомок должен установить все нужные ему биты с помощью "
"B<ioperm>(2)."

#. type: Plain text
#: man-pages/man2/fork.2:138
msgid "Note the following further points:"
msgstr "Также стоит учитывать следующее:"

#. type: Plain text
#: man-pages/man2/fork.2:147
msgid ""
"The child process is created with a single thread\\(emthe one that called "
"B<fork>().  The entire virtual address space of the parent is replicated in "
"the child, including the states of mutexes, condition variables, and other "
"pthreads objects; the use of B<pthread_atfork>(3)  may be helpful for "
"dealing with problems that this can cause."
msgstr ""
"Процесс потомка создаётся с одиночной нитью — той, которая вызвала B<fork>(). "
"Всё виртуальное адресное пространство родителя копируется в потомок, включая "
"состояние мьютексов, условных переменных и других объектов pthreads; в случае "
"проблем с этим может помочь B<pthread_atfork>(3)."

#. type: Plain text
#: man-pages/man2/fork.2:161
msgid ""
"The child inherits copies of the parent's set of open file descriptors.  "
"Each file descriptor in the child refers to the same open file description "
"(see B<open>(2))  as the corresponding file descriptor in the parent.  This "
"means that the two descriptors share open file status flags, current file "
"offset, and signal-driven I/O attributes (see the description of B<F_SETOWN>"
" and B<F_SETSIG> in B<fcntl>(2))."
msgstr ""
"Потомок наследует копии набора открытых файловых дескрипторов родителя. "
"Каждый файловый дескриптор в потомке ссылается на то же описание файла что и "
"родитель (см. B<open>(2)). Это означает, что два дескриптора совместно "
"используют флаги состояния открытого файла, текущее смещение файла и атрибуты "
"ввода-вывода, управляемые сигналами (смотрите описание B<F_SETOWN> и B<"
"F_SETSIG> в B<fcntl>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:170
msgid ""
"The child inherits copies of the parent's set of open message queue "
"descriptors (see B<mq_overview>(7)).  Each descriptor in the child refers to"
" the same open message queue description as the corresponding descriptor in "
"the parent.  This means that the two descriptors share the same flags "
"(I<mq_flags>)."
msgstr ""
"Потомок наследует копии набора дескрипторов открытых очередей сообщений "
"родителя (см. B<mq_overview>(7)). Каждый дескриптор в потомке ссылается на то "
"же описание открытой очереди сообщений что и родитель. Это означает, что два "
"дескриптора совместно используют флаги (I<mq_flags>)."

#. type: Plain text
#: man-pages/man2/fork.2:178
msgid ""
"The child inherits copies of the parent's set of open directory streams (see"
" B<opendir>(3)).  POSIX.1-2001 says that the corresponding directory streams"
" in the parent and child I<may> share the directory stream positioning; on "
"Linux/glibc they do not."
msgstr ""
"Потомок наследует копии набора потоков открытых каталогов родителя (см. B<"
"opendir>(3)). В POSIX.1-2001 сказано, что соответствующие потоки каталогов в "
"родителе и потомке I<могут> совместно использовать позицию в потоке каталога; "
"в Linux/glibc они не могут этого делать."

#. type: SH
#: man-pages/man2/fork.2:178
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/fork.2:185
msgid ""
"On success, the PID of the child process is returned in the parent, and 0 is"
" returned in the child.  On failure, -1 is returned in the parent, no child "
"process is created, and I<errno> is set appropriately."
msgstr ""
"При успешном завершении родителю возвращается PID процесса-потомка, а "
"процессу-потомку возвращается 0. При ошибке родительскому процессу "
"возвращается -1, процесс-потомок не создаётся, а значение I<errno> "
"устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/fork.2:186 man-pages/man2/fork.2:191
#: man-pages/man2/fork.2:209
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/fork.2:191
msgid ""
"B<fork>()  cannot allocate sufficient memory to copy the parent's page "
"tables and allocate a task structure for the child."
msgstr ""
"Вызов B<fork>() завершился с ошибкой из-за невозможности выделить достаточно "
"памяти для копирования таблиц страниц родителя и для выделения структуры "
"описания процесса-потомка."

#.  NOTE! The following should match the description in pthread_create(3)
#. type: Plain text
#: man-pages/man2/fork.2:209
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error: the B<RLIMIT_NPROC> soft "
"resource limit (set via B<setrlimit>(2)), which limits the number of "
"processes and threads for a real user ID, was reached; the kernel's system-"
"wide limit on the number of processes and threads, I</proc/sys/kernel"
"/threads-max>, was reached (see B<proc>(5)); or the maximum number of PIDs, "
"I</proc/sys/kernel/pid_max>, was reached (see B<proc>(5))."
msgstr ""
"Возникло системного ограничение на количество нитей. Есть несколько "
"ограничений, которые могут вызвать эту ошибку: был достигнут мягкий "
"ограничитель B<RLIMIT_NPROC> (задаётся с помощью B<setrlimit>(2)), который "
"ограничивает количество процессов и ните для реального ID пользователя; был "
"достигнут ядерный системный ограничитель на количество процессов и нитей, I<"
"/proc/sys/kernel/threads-max> (смотрите B<proc>(5)); был достигнуто "
"максимальное количество PID, I</proc/sys/kernel/pid_max> (смотрите B<proc>"
"(5))."

#. type: Plain text
#: man-pages/man2/fork.2:216
msgid ""
"The caller is operating under the B<SCHED_DEADLINE> scheduling policy and "
"does not have the reset-on-fork flag set.  See B<sched>(7)."
msgstr ""
"Вызывающий работает по алгоритму планирования B<SCHED_DEADLINE> и у него не "
"установлен флаг сброса-при-fork (reset-on-fork). Смотрите B<sched>(7)."

#. type: TP
#: man-pages/man2/fork.2:216
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/fork.2:220
msgid ""
"B<fork>()  failed to allocate the necessary kernel structures because memory"
" is tight."
msgstr ""
"Вызов B<fork>() завершился с ошибкой из-за невозможности разместить "
"необходимые структуры ядра, потому что слишком мало памяти."

#. type: TP
#: man-pages/man2/fork.2:220
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#.  e.g., arm (optionally), blackfin, c6x, frv, h8300, microblaze, xtensa
#. type: Plain text
#: man-pages/man2/fork.2:226
msgid ""
"B<fork>()  is not supported on this platform (for example, hardware without "
"a Memory-Management Unit)."
msgstr ""
"Вызов B<fork>() не поддерживается на этой платформе (например, из-за того, "
"что аппаратное обеспечение не содержит блока управления памятью (MMU))."

#. type: Plain text
#: man-pages/man2/fork.2:228
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/fork.2:235
msgid ""
"Under Linux, B<fork>()  is implemented using copy-on-write pages, so the "
"only penalty that it incurs is the time and memory required to duplicate the"
" parent's page tables, and to create a unique task structure for the child."
msgstr ""
"В Linux, B<fork>() реализован с помощью «копирования страниц при записи» "
"(copy-on-write, COW), поэтому расходы на вызов состоят из времени и памяти, "
"требуемой на копирование страничных таблиц родителя и создания уникальной "
"структуры, описывающей задачу."

#.  nptl/sysdeps/unix/sysv/linux/fork.c
#.  and does some magic to ensure that getpid(2) returns the right value.
#. type: Plain text
#: man-pages/man2/fork.2:259
msgid ""
"Since version 2.3.3, rather than invoking the kernel's B<fork>()  system "
"call, the glibc B<fork>()  wrapper that is provided as part of the NPTL "
"threading implementation invokes B<clone>(2)  with flags that provide the "
"same effect as the traditional system call.  (A call to B<fork>()  is "
"equivalent to a call to B<clone>(2)  specifying I<flags> as just "
"B<SIGCHLD>.)  The glibc wrapper invokes any fork handlers that have been "
"established using B<pthread_atfork>(3)."
msgstr ""
"Начиная с версии 2.3.3, вместо того, чтобы вызывать системный вызов  B<fork>"
"(), обёрточная функция B<fork>() в glibc, как часть реализации нитей NPTL, "
"вызывает B<clone>(2) с флагами, которые обеспечивают поведение традиционного "
"системного вызова (вызов B<fork>() эквивалентен вызову B<clone>(2), если "
"значение равно I<flags> B<SIGCHLD>). Обёртка в glibc вызывает все обработчики "
"при ветвлении (fork), которые были зарегистрированы с помощью B<"
"pthread_atfork>(3)."

#. type: Plain text
#: man-pages/man2/fork.2:264
msgid "See B<pipe>(2)  and B<wait>(2)."
msgstr "Смотрите B<pipe>(2) и B<wait>(2)."

#. type: Plain text
#: man-pages/man2/fork.2:274
msgid ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<capabilities>(7), B<credentials>(7)"
msgstr ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), B<"
"vfork>(2), B<wait>(2), B<daemon>(3), B<capabilities>(7), B<credentials>(7)"

#. type: Plain text
#: man-pages/man2/futex.2:61
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/futex.hE<gt>>\nB<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/futex.2:64
#, no-wrap
msgid ""
"B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct "
"timespec *>I<timeout>B<,>\n"
msgstr ""
"B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct "
"timespec *>I<timeout>B<,>\n"

#.  int *? void *? u32 *?
#. type: Plain text
#: man-pages/man2/futex.2:67
#, no-wrap
msgid "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"

#. type: Plain text
#: man-pages/man2/futex.2:70
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>:В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/futex.2:86
msgid ""
"The B<futex>()  system call provides a method for a program to wait for a "
"value at a given address to change, and a method to wake up anyone waiting "
"on a particular address (while the addresses for the same memory in separate"
" processes may not be equal, the kernel maps them internally so the same "
"memory mapped in different locations will correspond for B<futex>()  calls)."
"  This system call is typically used to implement the contended case of a "
"lock in shared memory, as described in B<futex>(7)."
msgstr ""
"Системный вызов B<futex>() предоставляет программам метод для ожидания "
"изменения значения по указанному адресу памяти и метод для пробуждения всех "
"ожидающих изменения по определённому адресу (хотя адреса одного и того же "
"участка памяти в разных процессах могут быть не одинаковыми, ядро отображает "
"их внутренне так, что один участок памяти, отображённый в разные места, будет "
"одинаков для вызовов B<futex>()). Обычно, этот системный вызов используется "
"для реализации конкурентных (contended case) блокировок в общей памяти, как "
"это описано в B<futex>(7)."

#. type: Plain text
#: man-pages/man2/futex.2:93
msgid ""
"When a B<futex>(7)  operation did not finish uncontended in user space, a "
"call needs to be made to the kernel to arbitrate.  Arbitration can either "
"mean putting the calling process to sleep or, conversely, waking a waiting "
"process."
msgstr ""
"Когда операция B<futex>(7) оканчивается без завершения спора в пространстве "
"пользователя, должен быть сделан вызов к ядру для выноса решения. Решением "
"может быть как усыпление вызывающего процесса, так и наоборот — пробуждение "
"ожидающего процесса."

#. type: Plain text
#: man-pages/man2/futex.2:100
msgid ""
"Callers of this function are expected to adhere to the semantics as set out "
"in B<futex>(7).  As these semantics involve writing nonportable assembly "
"instructions, this in turn probably means that most users will in fact be "
"library authors and not general application developers."
msgstr ""
"Вызывающие эту функцию должны твердо придерживаться семантики, описанной в B<"
"futex>(7). Так как эта семантика приводит к созданию непереносимых инструкций "
"ассемблера, то фактически это приведёт к тому, что большинство использующих "
"их пользователей станут авторами библиотек, а не создателями программ."

#. type: Plain text
#: man-pages/man2/futex.2:108
msgid ""
"The I<uaddr> argument needs to point to an aligned integer which stores the "
"counter.  The operation to execute is passed via the I<op> argument, along "
"with a value I<val>."
msgstr ""
"Аргумент I<uaddr> должен указывать на выровненное целое, хранящее счетчик. "
"Тип операции для исполнения указывает в параметре I<op>, а её значение в I<"
"val>."

#. type: Plain text
#: man-pages/man2/futex.2:110
msgid "Five operations are currently defined:"
msgstr "В данный момент определены пять операций:"

#. type: TP
#: man-pages/man2/futex.2:110 man-pages/man2/futex.2:223
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr "B<FUTEX_WAIT>"

#. type: Plain text
#: man-pages/man2/futex.2:133
msgid ""
"This operation atomically verifies that the futex address I<uaddr> still "
"contains the value I<val>, and sleeps awaiting B<FUTEX_WAKE> on this futex "
"address.  If the I<timeout> argument is non-NULL, its contents specify the "
"duration of the wait.  (This interval will be rounded up to the system clock"
" granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.)  If I<timeout> is NULL, the call blocks "
"indefinitely.  The arguments I<uaddr2> and I<val3> are ignored."
msgstr ""
"Эта операция атомарно проверяет, что адрес futex I<uaddr> по прежнему "
"содержит значение I<val> и засыпает, ожидая B<FUTEX_WAKE> для этого адреса "
"futex. Если аргумент I<timeout> не равен NULL, то его значение задаёт "
"длительность ожидания (Этот интервал будет округлён до точности системных "
"часов, и задержка ядерного планирования приведёт к тому, что блокирующий "
"интервал может быть меньше). Если значение I<timeout> равно NULL, то вызов "
"блокируется навсегда. Аргументы I<uaddr2> и I<val3> игнорируются."

#. type: Plain text
#: man-pages/man2/futex.2:141
msgid ""
"For B<futex>(7), this call is executed if decrementing the count gave a "
"negative value (indicating contention), and will sleep until another process"
" releases the futex and executes the B<FUTEX_WAKE> operation."
msgstr ""
"По B<futex>(7) этот вызов исполняется, если уменьшение счетчика даёт "
"отрицательное значение (указывая на наличие спора), или будет спать, пока "
"другой процесс не освободит futex и не выполнит операцию B<FUTEX_WAKE>."

#. type: TP
#: man-pages/man2/futex.2:141 man-pages/man2/futex.2:229
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr "B<FUTEX_WAKE>"

#. type: Plain text
#: man-pages/man2/futex.2:152
msgid ""
"This operation wakes at most I<val> processes waiting on this futex address "
"(i.e., inside B<FUTEX_WAIT>).  The arguments I<timeout>, I<uaddr2> and "
"I<val3> are ignored."
msgstr ""
"Эта операция пробуждает не больше I<val> процессов, ожидающих на этом адресе "
"futex (т.е. внутри B<FUTEX_WAIT>). Аргументы I<timeout>, I<uaddr2> и I<val3> "
"игнорируются."

#. type: Plain text
#: man-pages/man2/futex.2:158
msgid ""
"For B<futex>(7), this is executed if incrementing the count showed that "
"there were waiters, once the futex value has been set to 1 (indicating that "
"it is available)."
msgstr ""
"По B<futex>(7) этот вызов исполняется, если увеличение счетчика показало, что "
"есть ожидающие, как только значение futex стало равным 1 (показывает, что "
"есть доступные ожидающие)."

#. type: TP
#: man-pages/man2/futex.2:158
#, no-wrap
msgid "B<FUTEX_FD> (present up to and including Linux 2.6.25)"
msgstr "B<FUTEX_FD> (существует до Linux 2.6.25 включительно)"

#.  , suitable for .BR poll (2).
#. type: Plain text
#: man-pages/man2/futex.2:174
msgid ""
"To support asynchronous wakeups, this operation associates a file descriptor"
" with a futex.  If another process executes a B<FUTEX_WAKE>, the process "
"will receive the signal number that was passed in I<val>.  The calling "
"process must close the returned file descriptor after use.  The arguments "
"I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""
"Для поддержки асинхронных пробуждений эта операция связывает дескриптор файла "
"с futex. Если другой процесс выполняет B<FUTEX_WAKE>, то процесс будет "
"получать номер сигнала, переданный в I<val>. Вызывающий процесс должен "
"закрыть возвращаемый дескриптор файла после использования. Аргументы I<"
"timeout>, I<uaddr2> и I<val3> игнорируются."

#. type: Plain text
#: man-pages/man2/futex.2:179
msgid ""
"To prevent race conditions, the caller should test if the futex has been "
"upped after B<FUTEX_FD> returns."
msgstr ""
"Для предотвращения состязательности, вызывающий после возврата при B<FUTEX_FD>"
" должен проверять, не был ли futex увеличен."

#. type: Plain text
#: man-pages/man2/futex.2:183
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""
"Так как по своей природе операция B<FUTEX_FD> приводит к состязательности, "
"она была удалена из Linux, начиная с версии 2.6.26."

#. type: TP
#: man-pages/man2/futex.2:183
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.5.70)"
msgstr "B<FUTEX_REQUEUE> (начиная с Linux 2.5.70)"

#. type: Plain text
#: man-pages/man2/futex.2:198
msgid ""
"This operation was introduced in order to avoid a \"thundering herd\" effect"
" when B<FUTEX_WAKE> is used and all processes woken up need to acquire "
"another futex.  This call wakes up I<val> processes, and requeues all other "
"waiters on the futex at address I<uaddr2>.  The arguments I<timeout> and "
"I<val3> are ignored."
msgstr ""
"Эта операция была введена для того, чтобы избежать эффекта \"громыхающего "
"стада (thundering herd)\", когда используется B<FUTEX_WAKE> и все процессы "
"просыпаются, чтобы захватить другой futex. Этот вызов пробуждает до I<val> "
"процессов и повторно ставит в очередь остальных ожидающих futex по адресу I<"
"uaddr2>. Аргументы I<timeout> и I<val3> игнорируются."

#. type: TP
#: man-pages/man2/futex.2:198
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr "B<FUTEX_CMP_REQUEUE> (начиная с Linux 2.6.7)"

#. type: Plain text
#: man-pages/man2/futex.2:216
msgid ""
"There was a race in the intended use of B<FUTEX_REQUEUE>, so "
"B<FUTEX_CMP_REQUEUE> was introduced.  This is similar to B<FUTEX_REQUEUE>, "
"but first checks whether the location I<uaddr> still contains the value "
"I<val3>.  If not, the operation fails with the error B<EAGAIN>.  The "
"argument I<timeout> is ignored."
msgstr ""
"Чтобы избежать состязательности при B<FUTEX_REQUEUE>, была введена B<"
"FUTEX_CMP_REQUEUE>. Она похожа на B<FUTEX_REQUEUE>, но сначала проверяет, что "
"расположенное по адресу I<uaddr> значение всё ещё равно I<val3>. Если нет, то "
"операция завершается с ошибкой B<EAGAIN>. Аргумент I<timeout> игнорируется."

#. type: Plain text
#: man-pages/man2/futex.2:223
msgid ""
"In the event of an error, all operations return -1, and set I<errno> to "
"indicate the error.  The return value on success depends on the operation, "
"as described in the following list:"
msgstr ""
"В случае ошибки все операции возвращают -1, а I<errno> устанавливается в "
"соответствующее значение. При успешном выполнении возвращаемое значение "
"зависит от операции:"

#. type: Plain text
#: man-pages/man2/futex.2:229
msgid ""
"Returns 0 if the process was woken by a B<FUTEX_WAKE> call.  See ERRORS for "
"the various possible error returns."
msgstr ""
"Возвращается 0, если процесс проснулся по сигналу B<FUTEX_WAKE>. Возможные "
"возвращаемые ошибки смотрите в разделе ОШИБКИ."

#. type: Plain text
#: man-pages/man2/futex.2:232 man-pages/man2/futex.2:238
#: man-pages/man2/futex.2:241
msgid "Returns the number of processes woken up."
msgstr "Возвращается количество разбуженных процессов."

#. type: TP
#: man-pages/man2/futex.2:232
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr "B<FUTEX_FD>"

#. type: Plain text
#: man-pages/man2/futex.2:235
msgid "Returns the new file descriptor associated with the futex."
msgstr "Возвращается новый файловый дескриптор, связанный с futex."

#. type: TP
#: man-pages/man2/futex.2:235
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr "B<FUTEX_REQUEUE>"

#. type: TP
#: man-pages/man2/futex.2:238
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr "B<FUTEX_CMP_REQUEUE>"

#. type: TP
#: man-pages/man2/futex.2:242
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/futex.2:245
msgid "No read access to futex memory."
msgstr "Нет доступа на чтение памяти futex."

#. type: Plain text
#: man-pages/man2/futex.2:256
msgid ""
"B<FUTEX_CMP_REQUEUE> detected that the value pointed to by I<uaddr> is not "
"equal to the expected value I<val3>.  (This probably indicates a race; use "
"the safe B<FUTEX_WAKE> now.)"
msgstr ""
"При B<FUTEX_CMP_REQUEUE> обнаружено, что значение, на которое указывает I<"
"uaddr>, не равно ожидаемому значению I<val3> (вероятно, это указывает на "
"состязательность; используйте теперь безопасный B<FUTEX_WAKE>)."

#. type: TP
#: man-pages/man2/futex.2:256
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/futex.2:261
msgid "Error retrieving I<timeout> information from user space."
msgstr ""
"Ошибка при получении информации о I<timeout> из пространства пользователя."

#. type: TP
#: man-pages/man2/futex.2:261
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/futex.2:268
msgid ""
"A B<FUTEX_WAIT> operation was interrupted by a signal (see B<signal>(7))  or"
" a spurious wakeup."
msgstr ""
"Операция B<FUTEX_WAIT> прервана сигналом (смотрите B<signal>(7)) или побочным "
"пробуждением."

#. type: Plain text
#: man-pages/man2/futex.2:271
msgid "Invalid argument."
msgstr "Неверный аргумент."

#. type: Plain text
#: man-pages/man2/futex.2:274
msgid "The system limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: Plain text
#: man-pages/man2/futex.2:278
msgid "Invalid operation specified in I<op>."
msgstr "В I<op> задана неверная операция."

#. type: TP
#: man-pages/man2/futex.2:278
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man2/futex.2:283
msgid "Timeout during the B<FUTEX_WAIT> operation."
msgstr "Превышено время ожидания в операции B<FUTEX_WAIT>."

#. type: TP
#: man-pages/man2/futex.2:283
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: man-pages/man2/futex.2:293
msgid ""
"I<op> was B<FUTEX_WAIT> and the value pointed to by I<uaddr> was not equal "
"to the expected value I<val> at the time of the call."
msgstr ""
"Значение I<op> равно B<FUTEX_WAIT> и значение, на которое указывает I<uaddr>, "
"не равно ожидаемому значению I<val> на момент вызова."

#. type: Plain text
#: man-pages/man2/futex.2:303
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics"
" from what was described above.  A 4-argument system call with the semantics"
" described in this page was introduced in Linux 2.5.40.  In Linux 2.5.70, "
"one argument was added.  In Linux 2.6.7, a sixth argument was "
"added\\(emmessy, especially on the s390 architecture."
msgstr ""
"Начальная поддержка futex была встроена в Linux 2.5.7, но с другой "
"семантикой, отличающейся от описанной выше. Семантика системного вызова с "
"четырьмя аргументами, описанная в этой странице, появилась в Linux 2.5.40. В "
"Linux 2.5.70 был добавлен ещё один аргумент. В Linux 2.6.7 был добавлен "
"шестой аргумент — захламлено, особенно для архитектуре s390."

#. type: Plain text
#: man-pages/man2/futex.2:305
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#.  .SH "AUTHORS"
#.  .PP
#.  Futexes were designed and worked on by
#.  Hubertus Franke (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat)
#.  and Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: man-pages/man2/futex.2:319
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end-users.  (There is no wrapper function for this system call in "
"glibc.)  Implementors are expected to be assembly literate and to have read "
"the sources of the futex user-space library referenced below."
msgstr ""
"Ещё раз повторим: в чистом виде futex не являются лёгкой в использовании "
"абстракцией для конечных пользователей (в glibc нет обёрточных функций для "
"данного системного вызова). Использующие их программисты должны иметь хороший "
"запас знаний об ассемблере и уметь читать исходный код библиотеки futex для "
"пользовательского пространства, указанной далее."

#. type: Plain text
#: man-pages/man2/futex.2:322
msgid "B<restart_syscall>(2), B<futex>(7)"
msgstr "B<restart_syscall>(2), B<futex>(7)"

#. type: Plain text
#: man-pages/man2/futex.2:325
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"
msgstr ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (доклад на "
"симпозиуме по Linux в Оттаве в 2002 году), доступен по адресу"

#. type: Plain text
#: man-pages/man2/futex.2:328
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"

#. type: Plain text
#: man-pages/man2/futex.2:330
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr "Пример библиотеки futex, futex-*.tar.bz2, доступен на"

#. type: Plain text
#: man-pages/man2/futex.2:332
msgid ""
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<"
".UE>"
msgstr ""
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<"
".UE>"

#. type: TH
#: man-pages/man2/futimesat.2:25
#, no-wrap
msgid "FUTIMESAT"
msgstr "FUTIMESAT"

#. type: TH
#: man-pages/man2/futimesat.2:25
#, no-wrap
msgid "2012-05-10"
msgstr "2012-05-10"

#. type: Plain text
#: man-pages/man2/futimesat.2:29
msgid ""
"futimesat - change timestamps of a file relative to a directory file "
"descriptor"
msgstr ""
"futimesat - изменяет временные отметки файла, определяемого относительно "
"файлового дескриптора каталога"

#. type: Plain text
#: man-pages/man2/futimesat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt> /* определения констант AT_* */>\nB<#include E<"
"lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/futimesat.2:36
#, no-wrap
msgid ""
"B<int futimesat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timeval >I<times>B<[2]);>\n"
msgstr ""
"B<int futimesat(int >I<dirfd>B<, const char *>I<pathname>B<,>\nB<             "
" const struct timeval >I<times>B<[2]);>\n"

#. type: Plain text
#: man-pages/man2/futimesat.2:41
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>"
"(7)):"

#. type: Plain text
#: man-pages/man2/futimesat.2:45
msgid "B<futimesat>(): _GNU_SOURCE"
msgstr "B<futimesat>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/futimesat.2:50
msgid "This system call is obsolete.  Use B<utimensat>(2)  instead."
msgstr ""
"Данный системный вызов устарел. Используйте вместо него B<utimensat>(2)."

#. type: Plain text
#: man-pages/man2/futimesat.2:56
msgid ""
"The B<futimesat>()  system call operates in exactly the same way as "
"B<utimes>(2), except for the differences described in this manual page."
msgstr ""
"Системный вызов B<futimesat>() работает также как системный вызов B<utimes>"
"(2), за исключением случаев, описанных в данной справочной странице."

#. type: Plain text
#: man-pages/man2/futimesat.2:66
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<utimes>(2)  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<utimes>(2))."

#. type: Plain text
#: man-pages/man2/futimesat.2:78
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<utimes>(2))."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<utimes>(2))."

#. type: Plain text
#: man-pages/man2/futimesat.2:84
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/futimesat.2:91
msgid ""
"On success, B<futimesat>()  returns a 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<futimesat>() возвращает 0; при ошибке \\(em -1, а в "
"I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/futimesat.2:98
msgid ""
"The same errors that occur for B<utimes>(2)  can also occur for "
"B<futimesat>().  The following additional errors can occur for "
"B<futimesat>():"
msgstr ""
"В B<futimesat>() могут возникнуть те же ошибки, что и в B<utimes>(2). Также, "
"в B<futimesat>() могут возникнуть следующие ошибки:"

#. type: TP
#: man-pages/man2/futimesat.2:98
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/futimesat.2:102
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: TP
#: man-pages/man2/futimesat.2:102
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/futimesat.2:108
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит файловый "
"дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/futimesat.2:112
msgid ""
"B<futimesat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Вызов B<futimesat>() был добавлен в ядро Linux версии 2.6.16; поддержка в "
"glibc доступна с версии 2.4."

#. type: Plain text
#: man-pages/man2/futimesat.2:117
msgid ""
"This system call is nonstandard.  It was implemented from a specification "
"that was proposed for POSIX.1, but that specification was replaced by the "
"one for B<utimensat>(2)."
msgstr ""
"Данный системный вызов не является стандартным. Он был реализован по "
"спецификации POSIX.1, но она была заменена на B<utimensat>(2)."

#. type: Plain text
#: man-pages/man2/futimesat.2:119
msgid "A similar system call exists on Solaris."
msgstr "Подобный системный вызов есть в Solaris."

#. type: SS
#: man-pages/man2/futimesat.2:120
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#.  The Solaris futimesat() also has this strangeness.
#. type: Plain text
#: man-pages/man2/futimesat.2:128
msgid ""
"If I<pathname> is NULL, then the glibc B<futimesat>()  wrapper function "
"updates the times for the file referred to by I<dirfd>."
msgstr ""
"Если I<pathname> равно NULL, то обёрточная функция glibc B<futimesat>() "
"обновляет временные метки файла, указанного в I<dirfd>."

#. type: Plain text
#: man-pages/man2/futimesat.2:133
msgid ""
"B<stat>(2), B<utimensat>(2), B<utimes>(2), B<futimes>(3), "
"B<path_resolution>(7)"
msgstr ""
"B<stat>(2), B<utimensat>(2), B<utimes>(2), B<futimes>(3), B<path_resolution>"
"(7)"

#. type: TH
#: man-pages/man2/flock.2:35
#, no-wrap
msgid "FLOCK"
msgstr "FLOCK"

#. type: TH
#: man-pages/man2/flock.2:35
#, no-wrap
msgid "2014-06-13"
msgstr "2014-06-13"

#. type: Plain text
#: man-pages/man2/flock.2:38
msgid "flock - apply or remove an advisory lock on an open file"
msgstr ""
"flock - установить или снять консультативную (advisory) блокировку на "
"открытый файл"

#. type: Plain text
#: man-pages/man2/flock.2:40
msgid "B<#include E<lt>sys/file.hE<gt>>"
msgstr "B<#include E<lt>sys/file.hE<gt>>"

#. type: Plain text
#: man-pages/man2/flock.2:42
msgid "B<int flock(int >I<fd>B<, int >I<operation>B<);>"
msgstr "B<int flock(int >I<fd>B<, int >I<operation>B<);>"

#. type: Plain text
#: man-pages/man2/flock.2:48
msgid ""
"Apply or remove an advisory lock on the open file specified by I<fd>.  The "
"argument I<operation> is one of the following:"
msgstr ""
"Устанавливает или снимает консультативную блокировку на открытом файле, "
"указанном в I<fd>. Аргумент I<operation> может содержать одно из следующих "
"значений:"

#. type: TP
#: man-pages/man2/flock.2:49
#, no-wrap
msgid "B<LOCK_SH>"
msgstr "B<LOCK_SH>"

#. type: Plain text
#: man-pages/man2/flock.2:54
msgid ""
"Place a shared lock.  More than one process may hold a shared lock for a "
"given file at a given time."
msgstr ""
"Установить общую (shared) блокировку. Общую блокировку на заданный файл может "
"удерживать более чем один процесс."

#. type: TP
#: man-pages/man2/flock.2:54
#, no-wrap
msgid "B<LOCK_EX>"
msgstr "B<LOCK_EX>"

#. type: Plain text
#: man-pages/man2/flock.2:59
msgid ""
"Place an exclusive lock.  Only one process may hold an exclusive lock for a "
"given file at a given time."
msgstr ""
"Установить эксклюзивную (exclusive) блокировку. Только один процесс может "
"удерживать эксклюзивную блокировку файла."

#. type: TP
#: man-pages/man2/flock.2:59
#, no-wrap
msgid "B<LOCK_UN>"
msgstr "B<LOCK_UN>"

#. type: Plain text
#: man-pages/man2/flock.2:62
msgid "Remove an existing lock held by this process."
msgstr "Удалить существующую блокировку, удерживаемую данным процессом."

#. type: Plain text
#: man-pages/man2/flock.2:71
msgid ""
"A call to B<flock>()  may block if an incompatible lock is held by another "
"process.  To make a nonblocking request, include B<LOCK_NB> (by ORing)  with"
" any of the above operations."
msgstr ""
"Вызов B<flock>() может быть блокирован, если несовместимый тип блокировки уже "
"удерживается другим процессом. Чтобы выполнить неблокирующий запрос, добавьте "
"B<LOCK_NB> (через операцию ИЛИ) к одному из вышеописанных значений."

#. type: Plain text
#: man-pages/man2/flock.2:73
msgid ""
"A single file may not simultaneously have both shared and exclusive locks."
msgstr ""
"Один файл не может иметь одновременно и общую и эксклюзивную блокировку."

#. type: Plain text
#: man-pages/man2/flock.2:88
msgid ""
"Locks created by B<flock>()  are associated with an open file description "
"(see B<open>(2)).  This means that duplicate file descriptors (created by, "
"for example, B<fork>(2)  or B<dup>(2))  refer to the same lock, and this "
"lock may be modified or released using any of these descriptors.  "
"Furthermore, the lock is released either by an explicit B<LOCK_UN> operation"
" on any of these duplicate descriptors, or when all such descriptors have "
"been closed."
msgstr ""
"Блокировки, созданные B<flock>(), ассоциируются с дескриптором открытого "
"файла (смотрите B<open>(2)). Это означает, что дублирующие файловые "
"дескрипторы (созданные, например, вызовами B<fork>(2) или B<dup>(2)) "
"указывают на одну блокировку, и эта блокировка может быть изменена или снята "
"при использовании любого из этих дескрипторов. Таким образом, блокировка "
"освобождается либо через явное выполнение операции B<LOCK_UN> на одном из "
"дублирующих дескрипторов, либо когда все такие дескрипторы будут закрыты."

#. type: Plain text
#: man-pages/man2/flock.2:97
msgid ""
"If a process uses B<open>(2)  (or similar) to obtain more than one "
"descriptor for the same file, these descriptors are treated independently by"
" B<flock>().  An attempt to lock the file using one of these file "
"descriptors may be denied by a lock that the calling process has already "
"placed via another descriptor."
msgstr ""
"Если процесс использует B<open>(2) (или подобный вызов) для получения более "
"одного дескриптора на один и тот же файл, то эти файловые дескрипторы "
"считаются B<flock>() независимыми. Попытка заблокировать файл с помощью "
"одного из этих файловых дескрипторов может быть пресечена из-за блокировки, "
"которую вызывающий процесс уже установил через другой файловый дескриптор."

#. type: Plain text
#: man-pages/man2/flock.2:104
msgid ""
"A process may hold only one type of lock (shared or exclusive)  on a file.  "
"Subsequent B<flock>()  calls on an already locked file will convert an "
"existing lock to the new lock mode."
msgstr ""
"Процесс может удерживать на файле только один из типов блокировки (общую или "
"эксклюзивную). Последующие вызовы B<flock>() на уже заблокированный файл "
"будут преобразовывать текущую блокировку к новому заданному режиму блокировки."

#. type: Plain text
#: man-pages/man2/flock.2:109
msgid "Locks created by B<flock>()  are preserved across an B<execve>(2)."
msgstr ""
"Блокировки, созданные B<flock>(), сохраняются при выполнении B<execve>(2)."

#. type: Plain text
#: man-pages/man2/flock.2:112
msgid ""
"A shared or exclusive lock can be placed on a file regardless of the mode in"
" which the file was opened."
msgstr ""
"Общая или эксклюзивная блокировка может быть установлена на файл вне "
"зависимости от режима, в котором этот файл был открыт."

#. type: Plain text
#: man-pages/man2/flock.2:117
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<"
"errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/flock.2:122
msgid "I<fd> is not an open file descriptor."
msgstr "I<fd> не является открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man2/flock.2:127
msgid ""
"While waiting to acquire a lock, the call was interrupted by delivery of a "
"signal caught by a handler; see B<signal>(7)."
msgstr ""
"При ожидании получения блокировки вызов был прерван сигналом, пришедшим в "
"обработчик; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/flock.2:131
msgid "I<operation> is invalid."
msgstr "Неверное значение I<operation>."

#. type: TP
#: man-pages/man2/flock.2:131
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
#: man-pages/man2/flock.2:134
msgid "The kernel ran out of memory for allocating lock records."
msgstr "Ядру не хватило памяти для создания записи блокировки."

#. type: Plain text
#: man-pages/man2/flock.2:139
msgid "The file is locked and the B<LOCK_NB> flag was selected."
msgstr "Файл блокирован и был указан флаг B<LOCK_NB>."

#. type: Plain text
#: man-pages/man2/flock.2:148
msgid ""
"4.4BSD (the B<flock>()  call first appeared in 4.2BSD).  A version of "
"B<flock>(), possibly implemented in terms of B<fcntl>(2), appears on most "
"UNIX systems."
msgstr ""
"4.4BSD (впервые вызов B<flock>() появился в 4.2BSD). Вызов B<flock>() есть в "
"большинстве систем UNIX, возможно реализованный с помощью B<fcntl>(2)."

#.  E.g., according to the flock(2) man page, FreeBSD since at least 5.3
#. type: Plain text
#: man-pages/man2/flock.2:171
msgid ""
"Since kernel 2.0, B<flock>()  is implemented as a system call in its own "
"right rather than being emulated in the GNU C library as a call to "
"B<fcntl>(2).  This yields classical BSD semantics: there is no interaction "
"between the types of lock placed by B<flock>()  and B<fcntl>(2), and "
"B<flock>()  does not detect deadlock.  (Note, however, that on some modern "
"BSDs, B<flock>()  and B<fcntl>(2)  locks I<do> interact with one another.)"
msgstr ""
"Начиная с версии ядра 2.0, B<flock>() реализован как самостоятельный "
"системный вызов, а не как эмуляция в библиотеке GNU C с помощью B<fcntl>(2). "
"Он повторяет классическую семантику BSD: не существует никакого "
"взаимодействия "
"между типами блокировок, устанавливаемыми B<flock>() и B<fcntl>(2), и "
"B<flock>() не обнаруживает взаимные блокировки "
"(заметим, что в некоторых современных BSD вызовы "
"B<flock>() и B<fcntl>(2) блокирующие, при взаимодействии друг с другом)."

#.  commit 5eebde23223aeb0ad2d9e3be6590ff8bbfab0fc2
#. type: Plain text
#: man-pages/man2/flock.2:202
msgid ""
"In Linux kernels up to 2.6.11, B<flock>()  does not lock files over NFS "
"(i.e., the scope of locks was limited to the local system).  Instead, one "
"could use B<fcntl>(2)  byte-range locking, which does work over NFS, given a"
" sufficiently recent version of Linux and a server which supports locking.  "
"Since Linux 2.6.12, NFS clients support B<flock>()  locks by emulating them "
"as byte-range locks on the entire file.  This means that B<fcntl>(2)  and "
"B<flock>()  locks I<do> interact with one another over NFS.  Since Linux "
"2.6.37, the kernel supports a compatibility mode that allows B<flock>()  "
"locks (and also B<fcntl>(2)  byte region locks) to be treated as local; see "
"the discussion of the I<local_lock> option in B<nfs>(5)."
msgstr ""
"В ядрах Linux до версии 2.6.11, B<flock>() не блокирует файлы по NFS "
"(т. е., охват блокировки ограничен локальной системой). Вместо него "
"можно использовать блокировку области байт B<fcntl>(2), "
"которая работает по NFS, но доступна в значительно поздней версии "
"Linux, и сервер также должен поддерживать блокировку. "
"Начиная с Linux 2.6.12, клиенты NFS поддерживают блокировки B<flock>(), "
"эмулируя их через блокировку области байт для всего файла. "
"Это означает, что блокировки B<fcntl>(2) и B<flock>() "
"I<взаимодействуют> друг с другом через NFS. Начиная с Linux "
"2.6.37, ядро поддерживает режим совместимости, который позволяет считать "
"блокировки B<flock>() "
"(а также блокировки области байт B<fcntl>(2)) локальными; смотрите "
"описание параметра I<local_lock> в B<nfs>(5)."

#. type: Plain text
#: man-pages/man2/flock.2:208
msgid ""
"B<flock>()  places advisory locks only; given suitable permissions on a "
"file, a process is free to ignore the use of B<flock>()  and perform I/O on "
"the file."
msgstr ""
"B<flock>() устанавливает только консультативные блокировки; имея "
"соответствующие права на файл, процесс может игнорировать использование B<"
"flock>() и выполнять над файлом операции ввода/вывода."

#. type: Plain text
#: man-pages/man2/flock.2:221
msgid ""
"B<flock>()  and B<fcntl>(2)  locks have different semantics with respect to "
"forked processes and B<dup>(2).  On systems that implement B<flock>()  using"
" B<fcntl>(2), the semantics of B<flock>()  will be different from those "
"described in this manual page."
msgstr ""
"B<flock>() и B<fcntl>(2) имеют разную семантику для порождённых процессов и "
"B<dup>(2). В системах, где реализован B<flock>() с помощью B<fcntl>(2), "
"семантика B<flock>() будет отличаться от описанной в данной справочной "
"странице."

#.  Kernel 2.5.21 changed things a little: during lock conversion
#.  it is now the highest priority process that will get the lock -- mtk
#. type: Plain text
#: man-pages/man2/flock.2:234
msgid ""
"Converting a lock (shared to exclusive, or vice versa) is not guaranteed to "
"be atomic: the existing lock is first removed, and then a new lock is "
"established.  Between these two steps, a pending lock request by another "
"process may be granted, with the result that the conversion either blocks, "
"or fails if B<LOCK_NB> was specified.  (This is the original BSD behavior, "
"and occurs on many other implementations.)"
msgstr ""
"При преобразовании блокировки (общую в эксклюзивную или наоборот) не "
"гарантируется атомарность операции: сначала существующая блокировка "
"удаляется, а затем устанавливается новая. Между этими двумя действиями другой "
"процесс, ожидающий запрос на блокировку,  может получить на неё разрешение, в "
"следствие чего преобразование или заблокируется, или завершится неудачно, "
"если был указан флаг B<LOCK_NB>. (Это оригинальное поведение BSD встречается "
"во многих других реализациях.)"

#. type: Plain text
#: man-pages/man2/flock.2:243
msgid ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3)"
msgstr ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3)"

#. type: Plain text
#: man-pages/man2/flock.2:247
msgid ""
"I<Documentation/filesystems/locks.txt> in the Linux kernel source tree "
"(I<Documentation/locks.txt> in older kernels)"
msgstr ""
"I<Documentation/filesystem/locks.txt> в исходном коде ядра Linux (в старых "
"ядрах — I<Documentation/locks.txt>)"

#. type: TH
#: man-pages/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr "FANOTIFY_MARK"

#. type: TH
#: man-pages/man2/fanotify_mark.2:24
#, no-wrap
msgid "2014-04-24"
msgstr "2014-04-24"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""
"fanotify_mark - добавляет, удаляет или изменяет метку fanotify для объекта "
"файловой системы"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr "B<#include E<lt>sys/fanotify.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<"
"pathname>B<);>\n"
msgstr ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\nB<     "
"             uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<pathname>B<"
");>\n"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr "Обзор программного интерфейса fanotify смотрите в B<fanotify>(7)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>(2)  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr ""
"Системный вызов B<fanotify_mark>(2) добавляет, удаляет или изменяет метку "
"fanotify для объекта файловой системы. Вызывающий должен иметь право на "
"чтение помеченного объекта файловой системы."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""
"Аргумент I<fanotify_fd> — файловый дескриптор, возвращаемый B<fanotify_init>"
"(2)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""
"Аргумент I<flags> — битовая маска, описывающая выполняемое изменение. Она "
"должна содержать только одно значение из:"

#. type: TP
#: man-pages/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr "B<FAN_MARK_ADD>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""
"События в I<mask> будут добавлены в маску меток (или в маску игнорирования). "
"Если значение I<mask> пусто, то возвращается ошибка B<EINVAL>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr "B<FAN_MARK_REMOVE>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""
"События в I<mask> будут удалены из маски меток (или маски игнорирования). "
"Если значение I<mask> пусто, то возвращается ошибка B<EINVAL>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr "B<FAN_MARK_FLUSH>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:86
msgid ""
"Remove either all mount or all non-mount marks from the fanotify group.  If "
"I<flag> contains B<FAN_MARK_MOUNT>, all marks for mounts are removed from "
"the group.  Otherwise, all marks for directories and files are removed.  No "
"flag other than B<FAN_MARK_MOUNT> can be used in conjunction with "
"B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgstr ""
"Будут удалены все метки для смонтированных или несмонтированных точек из "
"группы fanotify. Если I<flag> содержит B<FAN_MARK_MOUNT>, то все метки для "
"точек монтирования удаляются из группы. В противном случае удаляются все "
"метки для каталогов и файлов. Другие флаги, кроме B<FAN_MARK_MOUNT>, нельзя "
"использовать вместе с B<FAN_MARK_FLUSH>. Значение I<mask> игнорируется."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:90
msgid ""
"If none of the values above is specified, or more than one is specified, the"
" call fails with the error B<EINVAL>."
msgstr ""
"Если не задано ни одно из этих значений, или указано больше одного, то вызов "
"завершается с ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:94
msgid ""
"In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr "Кроме этого в I<flags> могут быть указаны (побитовым сложением):"

#. type: TP
#: man-pages/man2/fanotify_mark.2:94
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr "B<FAN_MARK_DONT_FOLLOW>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:105
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""
"Если I<pathname> — символьная ссылка, то помечается сама ссылка, а не файл, "
"на который она ссылается (по умолчанию B<fanotify_mark>() разыменовывает I<"
"pathname>, если это символьная ссылка)."

#. type: TP
#: man-pages/man2/fanotify_mark.2:105
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr "B<FAN_MARK_ONLYDIR>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:110
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""
"Если объект файловой системы для пометки не является каталогом, то "
"возвращается ошибка B<ENOTDIR>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:110
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr "B<FAN_MARK_MOUNT>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:121
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself"
" a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will"
" be monitored."
msgstr ""
"Пометить точку монтирования, заданную в I<pathname>. Если само значение I<"
"pathname> не является точкой монтирования, то будет помечена точка "
"монтирования, которая содержит I<pathname>. Будут отслеживаться все каталоги, "
"подкаталоги и содержащиеся в точке монтирования файлы."

#. type: TP
#: man-pages/man2/fanotify_mark.2:121
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr "B<FAN_MARK_IGNORED_MASK>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:126
msgid ""
"The events in I<mask> shall be added to or removed from the ignore mask."
msgstr ""
"События в I<mask> должны быть добавлены или удалены из маски игнорирования."

#. type: TP
#: man-pages/man2/fanotify_mark.2:126
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr "B<FAN_MARK_IGNORED_SURV_MODIFY>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:132
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""
"Маска игнорирования должна остаться неизменной при событиях изменения. Если "
"этот флаг не указан, то маска игнорирования очищается при появлении событий "
"изменения игнорируемого файла или каталога."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:136
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""
"В I<mask> указывается какие события должны прослушиваться (или "
"игнорироваться). Данная битовая маска состоит из следующих значений:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:139
msgid ""
"Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""
"Создать событие при доступе (для чтения) к файлу или каталогу (но смотрите "
"ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:142
msgid "Create an event when a file is modified (write)."
msgstr "Создать событие при изменении (при записи) файла."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:145
msgid "Create an event when a writable file is closed."
msgstr "Создать событие при закрытии файла, открытого на запись."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:148
msgid "Create an event when a read-only file or directory is closed."
msgstr ""
"Создать событие при закрытии файла или каталога, открытого только для чтения."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:151
msgid "Create an event when a file or directory is opened."
msgstr "Создать событие при открытии файла или каталога."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:159
msgid ""
"Create an event when a permission to open a file or directory is requested."
"  An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""
"Создать событие при запросе открытия файла или каталога. Требуется файловый "
"дескриптор fanotify, созданный с B<FAN_CLASS_PRE_CONTENT> или B<"
"FAN_CLASS_CONTENT>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:167
msgid ""
"Create an event when a permission to read a file or directory is requested."
"  An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""
"Создать событие при запросе чтения файла или каталога. Требуется файловый "
"дескриптор fanotify, созданный с B<FAN_CLASS_PRE_CONTENT> или B<"
"FAN_CLASS_CONTENT>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:167
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr "B<FAN_ONDIR>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:176
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(2), "
"B<readdir>(2)  (but see BUGS), and B<closedir>(2)  are called.  Without this"
" flag, only events for files are created."
msgstr ""
"Создать события для каталогов, например при вызове B<opendir>(2), B<readdir>"
"(2) (но смотрите ДЕФЕКТЫ) и B<closedir>(2). Без этого флага будут создаваться "
"события только для файлов."

#. type: TP
#: man-pages/man2/fanotify_mark.2:176
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr "B<FAN_EVENT_ON_CHILD>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:184
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts.  Note that events are not "
"generated for children of the subdirectories of marked directories.  To "
"monitor complete directory trees it is necessary to mark the relevant mount."
msgstr ""
"Должны создаваться события для прямых потомков помеченных каталогов. Флаг не "
"влияет на помеченные точки монтирования. Заметим, что события не генерируются "
"для потомков подкаталогов помеченных каталогов. Для слежения за всем деревом "
"каталогов нужно пометить соответствующую точку монтирования."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:186
msgid "The following composed value is defined:"
msgstr "Определены следующие составные значения:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:190
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr "Файл закрыт (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:195
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""
"Объект файловой системы для пометки задаётся файловым дескриптором I<dirfd> и "
"путём, указанным в I<pathname>:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:201
msgid ""
"If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""
"Если значение I<pathname> равно NULL, то в I<dirfd> указан объект файловой "
"системы для пометки."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:209
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""
"Если значение I<pathname> равно NULL и I<dirfd> равно специальному значению "
"B<AT_FDCWD>, то помечается текущий рабочий каталог."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:215
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""
"Если в I<pathname> задан абсолютный путь, то им определяется объект файловой "
"системы для пометки, а I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:226
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> не равно B<AT_FDCWD>, "
"то помечаемый объект файловой системы определяется из I<pathname> "
"относительно каталога, заданного в I<dirfd>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:236
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the"
" filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно B<AT_FDCWD>, то "
"помечаемый объект файловой системы определяется из I<pathname> относительно "
"текущего рабочего каталога."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:243
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fanotify_mark>() возвращает 0; при ошибке "
"возвращается -1, а в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:248
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr "В I<fanotify_fd> передан некорректный файловый дескриптор."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:257
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""
"В I<flags> или I<mask> указано некорректное значение, или в I<fanotify_fd> не "
"файловый дескриптор fanotify."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:265
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> and mask "
"contains a flag for permission events (B<FAN_OPEN_PERM> or "
"B<FAN_ACCESS_PERM>)."
msgstr ""
"Файловые дескриптор fanotify был открыт с B<FAN_CLASS_NOTIF> и маска содержит "
"флаг для событий доступа (B<FAN_OPEN_PERM> или B<FAN_ACCESS_PERM>)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:274
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist."
"  This error also occurs when trying to remove a mark from an object which "
"is not marked."
msgstr ""
"Объект файловой системы, указанный в I<dirfd> и I<pathname>, не существует. "
"Эта ошибка также возникает при попытке удаления метки с не помеченного "
"объекта."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:277
msgid "The necessary memory could not be allocated."
msgstr "Невозможно выделить необходимую память."

#. type: TP
#: man-pages/man2/fanotify_mark.2:277
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:283
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS>"
" flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""
"Количество меток превышает ограничение в 8192 и флаг B<FAN_UNLIMITED_MARKS> "
"не был указан при создании файлового дескриптора fanotify с помощью B<"
"fanotify_init>(2)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:289
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""
"В этом ядре не реализован B<fanotify_mark>(). Программный интерфейс fanotify "
"доступен только, если ядро было собрано с параметром B<CONFIG_FANOTIFY>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:299
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""
"В значении I<flags> содержится B<FAN_MARK_ONLYDIR>, а в I<dirfd> и I<pathname>"
" указан не каталог."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:303
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and"
" enabled in version 2.6.37."
msgstr ""
"Вызов B<fanotify_mark>() появился в версии 2.6.36 ядра Linux и был включён в "
"версии 2.6.37."

#.  FIXME: Patch is in next-20140424.
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:318
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd> and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""
"Если I<flags> содержит B<FAN_MARK_FLUSH>, то I<dirfd> и I<pathname> должны "
"задавать корректный объект файловой системы, даже если этот объект не "
"используется."

#.  FIXME: Patch is in next-20140424.
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:324
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr "Вызов B<readdir>(2) не генерирует событие B<FAN_ACCESS>."

#.  FIXME: Patch proposed.
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:332
msgid ""
"If B<fanotify_mark>(2)  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr ""
"Если B<fanotify_mark>(2) вызван с B<FAN_MARK_FLUSH>, то значение I<flags> не "
"проверяется на корректность."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:334
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr "B<fanotify_init>(2), B<fanotify>(7)"

#. type: TH
#: man-pages/man2/fcntl.2:62
#, no-wrap
msgid "FCNTL"
msgstr "FCNTL"

#. type: TH
#: man-pages/man2/fcntl.2:62
#, no-wrap
msgid "2014-07-08"
msgstr "2014-07-08"

#. type: Plain text
#: man-pages/man2/fcntl.2:65
msgid "fcntl - manipulate file descriptor"
msgstr "fcntl - работа с файловым дескриптором"

#. type: Plain text
#: man-pages/man2/fcntl.2:69
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\nB<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:71
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:78
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""
"B<fcntl>() позволяет выполнять различные команды над открытым файловым "
"дескриптором I<fd>. Команда определяется содержимым аргумента I<cmd>."

#. type: Plain text
#: man-pages/man2/fcntl.2:92
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is"
" indicated in parentheses after each I<cmd> name (in most cases, the "
"required type is I<int>, and we identify the argument using the name "
"I<arg>), or I<void> is specified if the argument is not required."
msgstr ""
"B<fcntl>() может принимать необязательный третий аргумент. Необходимость его "
"указания зависит от значения, указанного в I<cmd>. Тип необходимого аргумента "
"указан в скобках после каждого имени значения I<cmd> (в большинстве случаев "
"требуется тип I<int>, и мы определяем аргумент с помощью имени I<arg>), или "
"указывается I<void>, если аргумент не нужен."

#. type: Plain text
#: man-pages/man2/fcntl.2:103
msgid ""
"Certain of the operations below are supported only since a particular Linux "
"kernel version.  The preferred method of checking whether the host kernel "
"supports a particular operation is to invoke B<fcntl>()  with the desired "
"I<cmd> value and then test whether the call failed with B<EINVAL>, "
"indicating that the kernel does not recognize this value."
msgstr ""
"Некоторые операции, описанные далее, поддерживаются только начиная с "
"определённой "
"версии ядра Linux. "
"Корректным методом проверки доступности операции в ядре является "
"вызов B<fcntl>() с желаемой операцией в I<cmd> и "
"сравнение кода возврата вызов с B<EINVAL>, который указывает на "
"неподдерживаемость значения ядром."

#. type: SS
#: man-pages/man2/fcntl.2:103
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr "Создание дубликата файлового дескриптора"

#. type: TP
#: man-pages/man2/fcntl.2:104
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr "B<F_DUPFD> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:114
msgid ""
"Find the lowest numbered available file descriptor greater than or equal to "
"I<arg> and make it be a copy of I<fd>.  This is different from B<dup2>(2), "
"which uses exactly the descriptor specified."
msgstr ""
"Найти наименьший доступный номер файлового дескриптора, который больше или "
"равен I<arg>, и сделать из него копию дескриптора I<fd>. Отличие от B<dup2>"
"(2) в том, что там дескриптор задаётся явно."

#. type: Plain text
#: man-pages/man2/fcntl.2:116
msgid "On success, the new descriptor is returned."
msgstr ""
"При успешном выполнении этой команды, возвращается новый файловый дескриптор."

#. type: Plain text
#: man-pages/man2/fcntl.2:120
msgid "See B<dup>(2)  for further details."
msgstr "Дополнительную информацию смотрите в B<dup>(2)."

#. type: TP
#: man-pages/man2/fcntl.2:120
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr "B<F_DUPFD_CLOEXEC> (I<int>; начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man2/fcntl.2:137
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate descriptor.  Specifying this flag permits a program to avoid an "
"additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> flag.  "
"For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""
"Как B<F_DUPFD>, но на новом дескрипторе дополнительно устанавливается флаг "
"закрытия-при-exec. Установка этого флага позволяет программам не делать "
"дополнительный вызов B<fcntl>() с командой B<F_SETFD> для установки флага B<"
"FD_CLOEXEC>. О том, зачем нужен этот флаг, смотрите описание B<O_CLOEXEC> в "
"B<open>(2)."

#. type: SS
#: man-pages/man2/fcntl.2:137
#, no-wrap
msgid "File descriptor flags"
msgstr "Флаги файлового дескриптора"

#. type: Plain text
#: man-pages/man2/fcntl.2:148
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is 0, the file descriptor will"
" remain open across an B<execve>(2), otherwise it will be closed."
msgstr ""
"Следующие команды работают с флагами, связанными с файловым дескриптором. В "
"настоящее время определён только один флаг: B<FD_CLOEXEC>, флаг "
"закрытия-при-exec. Если бит B<FD_CLOEXEC> равен 0, то файловый дескриптор "
"останется открытым при вызове B<execve>(2), иначе он будет закрыт."

#. type: TP
#: man-pages/man2/fcntl.2:148
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr "B<F_GETFD> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:153
msgid "Read the file descriptor flags; I<arg> is ignored."
msgstr "Прочитать флаги файлового дескриптора; I<arg> игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:153
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr "B<F_SETFD> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:157
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr ""
"Установить флаги файлового дескриптора согласно значению, указанному в "
"аргументе I<arg>."

#. type: Plain text
#: man-pages/man2/fcntl.2:172
msgid ""
"In multithreaded programs, using B<fcntl>()  B<F_SETFD> to set the close-on-"
"exec flag at the same time as another thread performs a B<fork>(2)  plus "
"B<execve>(2)  is vulnerable to a race condition that may unintentionally "
"leak the file descriptor to the program executed in the child process.  See "
"the discussion of the B<O_CLOEXEC> flag in B<open>(2)  for details and a "
"remedy to the problem."
msgstr ""
"В многонитевых программах использование B<fcntl>() с B<F_SETFD> для установки "
"флага close-on-exec в то время как другая нить выполняет B<fork>(2) плюс B<"
"execve>(2) приводит к состязательности, что может вызвать передачу файлового "
"дескриптора программе, запущенной в дочернем процессе. Смотрите обсуждение "
"флага B<O_CLOEXEC> в B<open>(2) и решение проблемы."

#. type: SS
#: man-pages/man2/fcntl.2:172
#, no-wrap
msgid "File status flags"
msgstr "Флаги состояния файла"

#.  or
#.  .BR creat (2),
#. type: Plain text
#: man-pages/man2/fcntl.2:187
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer"
" to the same open file description, and thus share the same file status "
"flags."
msgstr ""
"Каждое описание открытого файла имеет несколько связанных с ним флагов "
"состояния, которые инициализируются вызовом B<open>(2) и, возможно, "
"изменяются затем вызовом B<fcntl>(). Эти флаги совместно используются копиями "
"файловых дескрипторов (сделанными с помощью B<dup>(2), B<fcntl>(F_DUPFD), B<"
"fork>(2) и т.д.), которые указывают на одно описание открытого файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:190
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr "Эти флаги состояния и их смысл описаны в B<open>(2)."

#. type: TP
#: man-pages/man2/fcntl.2:190
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr "B<F_GETFL> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:195
msgid "Get the file access mode and the file status flags; I<arg> is ignored."
msgstr ""
"Получить права доступа к файлу и флаги состояния файла; I<arg> игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:195
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr "B<F_SETFL> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:220
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux this command can change only the B<O_APPEND>, B<O_ASYNC>, B<O_DIRECT>,"
" B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to change the "
"B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""
"Установить флаги состояния файла согласно значению, указанному в аргументе I<"
"arg>. Режим доступа к файлу (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>) и флаги "
"создания файла (т. е. B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>) в I<arg>"
" игнорируются. В Linux эта команда может изменять только флаги B<O_APPEND>, "
"B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME> и B<O_NONBLOCK>. Невозможно изменить "
"флаги B<O_DSYNC> и B<O_SYNC>; смотрите ДЕФЕКТЫ далее."

#. type: SS
#: man-pages/man2/fcntl.2:220
#, no-wrap
msgid "Advisory record locking"
msgstr "Консультативная (advisory) блокировка"

#. type: Plain text
#: man-pages/man2/fcntl.2:225
msgid ""
"Linux implements traditional (\"process-associated\") UNIX record locks, as "
"standardized by POSIX.  For a Linux-specific alternative with better "
"semantics, see the discussion of open file description locks below."
msgstr ""
"В Linux реализована обычная («попроцессная») блокировка UNIX, "
"стандартизованная POSIX. Описание Linux-альтернативную блокировку "
"открытых файловых описаний с лучшей семантикой смотрите далее."

#. type: Plain text
#: man-pages/man2/fcntl.2:236
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as byte-range, file-"
"segment, or file-region locks).  The third argument, I<lock>, is a pointer "
"to a structure that has at least the following fields (in unspecified "
"order)."
msgstr ""
"Команды B<F_SETLK>, B<F_SETLKW> и B<F_GETLK> используются для установки, "
"снятия и тестирования существования блокировок записей (также известных как "
"блокировки байтового диапазона, сегмента или области файла). Третий аргумент, "
"I<lock>, является "
"указателем на структуру, которая имеет, по крайней мере, следующие поля (в "
"произвольном порядке):"

#. type: Plain text
#: man-pages/man2/fcntl.2:251
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"
msgstr ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Тип блокировки: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* Как интерпретировать l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Начальное смещение блокировки */\n"
"    off_t l_len;     /* Количество блокируемых байт */\n"
"    pid_t l_pid;     /* PID процесса, блокирующего нашу блокировку\n"
"                        (только для F_GETLK и F_OFD_GETLK) */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:259
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""
"Поля I<l_whence>, I<l_start> и I<l_len> этой структуры задают диапазон байт, "
"который мы хотим заблокировать. Могут блокироваться байты за концом файла, но "
"не перед началом файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:279
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""
"I<l_start> \\(em это начальное смещение для блокировки, которое "
"интерпретируется как начало файла (если значение I<l_whence> равно B<SEEK_SET>"
"); как текущая позиция в файле (если значение I<l_whence> равно B<SEEK_CUR>); "
"как конец файла (если значение I<l_whence> равно B<SEEK_END>). В последних "
"двух случаях, I<l_start> может иметь отрицательное значение, предоставляя "
"смещение, которого не может указать до начала файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:294
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""
"В I<l_len> задаётся количество байт, которые нужно заблокировать. Если I<"
"l_len> положительно, то диапазон блокировки начинается со I<l_start> и "
"кончается I<l_start>+I<l_len>-1 включительно. Если в I<l_len> указан 0, то "
"блокируются все байты начиная с места, указанного I<l_whence> и I<l_start> и "
"до конца файла, независимо от величины файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:307
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""
"POSIX.1-2001 позволяет (но не требует) реализации поддерживать отрицательное "
"значение I<l_len>; если I<l_len> отрицательно, то интервал, описываемый I<"
"lock>, имеет размер I<l_start>+I<l_len> до I<l_start>-1 включительно. Это "
"поддерживается в Linux начиная с ядер версии 2.4.21 и 2.5.49."

#. type: Plain text
#: man-pages/man2/fcntl.2:326
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""
"Поле I<l_type> может быть использовано для указания типа блокировки файла: "
"чтение (B<F_RDLCK>) или запись (B<F_WRLCK>). Любое количество процессов могут "
"удерживать блокировку на чтение (общая блокировка) области файла, но только "
"один процесс может удерживать блокировку на запись (эксклюзивная блокировка). "
"Эксклюзивная блокировка исключает все другие блокировки, как общие так и "
"эксклюзивные. Один процесс может удерживать только один тип блокировки "
"области файла; если происходит новая блокировка уже заблокированной области, "
"то существующая блокировка преобразуется в новый тип блокировки. (Такие "
"преобразования могут привести к разбиению, уменьшению или срастанию с "
"существующей блокировкой, если диапазон байт, заданный для новой блокировки, "
"неточно совпадает с диапазоном существующей блокировки.)"

#. type: TP
#: man-pages/man2/fcntl.2:326
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr "B<F_SETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:351
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>.  (The error returned in this case differs across "
"implementations, so POSIX requires a portable application to check for both "
"errors.)"
msgstr ""
"Установить блокировку (когда I<l_type> равен B<F_RDLCK> или B<F_WRLCK>) "
"или снять блокировку (когда  I<l_type>  равен  B<F_UNLCK>) байтов, "
"указанных полями I<l_whence>, I<l_start> и I<l_len> структуры I<lock>. "
"Если конфликтующая блокировка удерживается другим процессом, то "
"данный вызов вернёт -1 и установит значение I<errno> в B<EACCES> или "
"B<EAGAIN> (ошибка, возвращаемая в этом случае, в разных реализациях разная, "
"поэтому в POSIX для переносимых приложений требуется проверять оба значения)."

#. type: TP
#: man-pages/man2/fcntl.2:351
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr "B<F_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:365
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the"
" call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"Как B<F_SETLK>, но если конфликтующая блокировка удерживается на файле, то "
"выполняется ожидание снятия этой блокировки. Если во время ожидания поступил "
"сигнал, то данный вызов прерывается и (после возврата из обработчика сигнала) "
"из него происходит немедленный возврат (возвращается значение -1 и I<errno> "
"устанавливается в B<EINTR>; см. B<signal>(7))."

#. type: TP
#: man-pages/man2/fcntl.2:365
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr "B<F_GETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:379
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged."
msgstr ""
"При входе в этот вызов, I<lock> описывает блокировку, которую мы хотели бы "
"установить на файл. Если такая блокировка не может быть установлена, B<fcntl>"
"() не устанавливает её, но возвращает B<F_UNLCK> в поле I<l_type> структуры "
"I<lock> и оставляет другие поля структуры неизменёнными."

#. type: Plain text
#: man-pages/man2/fcntl.2:396
msgid ""
"If one or more incompatible locks would prevent this lock being placed, then"
" B<fcntl>()  returns details about one of those locks in the I<l_type>, "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If the conflicting"
" lock is a traditional (process-associated) record lock, then the I<l_pid> "
"field is set to the PID of the process holding that lock.  If the "
"conflicting lock is an open file description lock, then I<l_pid> is set to "
"-1.  Note that the returned information may already be out of date by the "
"time the caller inspects it."
msgstr ""
"Если одна или более несовместимых блокировок мешают установке этой "
"блокировки, то B<fcntl>() "
"возвращает подробности об одной из этих блокировок в полях I<l_type>, "
"I<l_whence>, I<l_start> и I<l_len> структуры I<lock>. Если конфликтующая "
"блокировка "
"является обычной (попроцессной), то в I<l_pid> записывается "
"значение PID того процесса, который удерживает блокировку. "
"Если конфликтующая блокировка является блокировку открытого файлового "
"описания, "
"в I<l_pid> записывается -1. Заметим, что возвращаемая информация может уже "
"устареть "
"в момент проверки вызывающим."

#. type: Plain text
#: man-pages/man2/fcntl.2:404
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""
"Для того, чтобы установить блокировку на чтение, I<fd> должен быть открыт на "
"чтение. Для того, чтобы установить блокировку на запись, I<fd> должен быть "
"открыт на запись. Чтобы установить оба типа блокировки, дескриптор должен "
"быть открыт на запись и на чтение."

#. type: Plain text
#: man-pages/man2/fcntl.2:427
msgid ""
"When placing locks with B<F_SETLKW>, the kernel detects I<deadlocks>, "
"whereby two or more processes have their lock requests mutually blocked by "
"locks held by the other processes.  For example, suppose process A holds a "
"write lock on byte 100 of a file, and process B holds a write lock on byte "
"200.  If each process then attempts to lock the byte already locked by the "
"other process using B<F_SETLKW>, then, without deadlock detection, both "
"processes would remain blocked indefinitely.  When the kernel detects such "
"deadlocks, it causes one of the blocking lock requests to immediately fail "
"with the error B<EDEADLK>; an application that encounters such an error "
"should release some of its locks to allow other applications to proceed "
"before attempting regain the locks that it requires.  Circular deadlocks "
"involving more than two processes are also detected.  Note, however, that "
"there are limitations to the kernel's deadlock-detection algorithm; see "
"BUGS."
msgstr ""
"При размещении блокировок с помощью B<F_SETLKW>, ядро "
"обнаруживает I<взаимные блокировки> (deadlocks), при которых два и более "
"процессов создают запросы на блокировку, блокируемые блокировками, "
"удерживаемые другими процессами. "
"Например, предположим, что процесс А удерживает блокировку на запись "
"файла в байт 100, а процесс Б удерживает блокировку на запись в байт "
"200. Если каждый процесс затем попытается заблокировать байт, "
"который уже заблокирован "
"другим процессом с помощью B<F_SETLKW>, то без обнаружения взаимных "
"блокировок оба процесса останутся заблокированными навсегда. "
"Когда ядро обнаруживает такие взаимные блокировки "
"оно сразу же завершает одну из блокирующих блокировок с ошибкой "
"B<EDEADLK>; приложение, встретившее такую ошибку, должно "
"освободить одну из своих блокировок перед попыткой восстановить блокировки, "
"которые "
"ему нужны, позволив другому приложению продолжить работу. "
"Зацикленные взаимные блокировки обнаруживаются и для более двух "
"процессов. Однако заметим, что есть ограничения в алгоритме обнаружения "
"взаимных блокировок; смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/fcntl.2:431
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates."
msgstr ""
"Также как и при снятии блокировки через явное указание B<F_UNLCK>, блокировка "
"автоматически снимается, когда процесс завершается."

#. type: Plain text
#: man-pages/man2/fcntl.2:436
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""
"Блокировки не наследуются потомком, созданным через B<fork>(2), но "
"сохраняются при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:445
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use "
"B<read>(2)  and B<write>(2)  instead."
msgstr ""
"Поскольку буферизация выполняется через библиотеку B<stdio>(3), использование "
"блокировок с функциями в этом пакете нужно избегать; вместо этих функций "
"используйте B<read>(2) и B<write>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:449
msgid ""
"The record locks described above are associated with the process (unlike the"
" open file description locks described below).  This has some unfortunate "
"consequences:"
msgstr ""
"Записи о блокировках, описанных выше, связаны с процессом (в отличие от "
"блокировках открытых файловых описаний, описанных далее). "
"Это приводит к некоторым печальным последствиям:"

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
#: man-pages/man2/fcntl.2:465
msgid ""
"If a process closes I<any> file descriptor referring to a file, then all of "
"the process's locks on that file are released, regardless of the file "
"descriptor(s) on which the locks were obtained.  This is bad: it means that "
"a process can lose its locks on a file such as I</etc/passwd> or "
"I</etc/mtab> when for some reason a library function decides to open, read, "
"and close the same file."
msgstr ""
"Если процесс закрывает I<любой> файловый дескриптор, ссылающийся на файл, "
"то освобождаются все блокировки процесса для этого файла, независимо от "
"файлового дескриптора(ов), на который получена блокировка. "
"Это плохо: это означает, что процесс может потерять свои блокировки на файл, "
"такой как I</etc/passwd> или I</etc/mtab>, когда какой-либо причине "
"библиотечная функция решает их открыть, прочитать и закрыть."

#. type: Plain text
#: man-pages/man2/fcntl.2:470
msgid ""
"The threads in a process share locks.  In other words, a multithreaded "
"program can't use record locking to ensure that threads don't simultaneously"
" access the same region of a file."
msgstr ""
"Нити процесса совместно используют блокировки процесса. "
"Другими словами многонитевая программа не может использовать блокировку "
"для разграничения доступа к одной области файла среди нитей."

#. type: Plain text
#: man-pages/man2/fcntl.2:472
msgid "Open file description locks solve both of these problems."
msgstr "Блокировки открытых файловых описаний решают обе эти проблемы."

#. type: SS
#: man-pages/man2/fcntl.2:472
#, no-wrap
msgid "Open file description locks (non-POSIX)"
msgstr "Блокировки открытых файловых описаний (не POSIX)"

#. type: Plain text
#: man-pages/man2/fcntl.2:479
msgid ""
"Open file description locks are advisory byte-range locks whose operation is"
" in most respects identical to the traditional record locks described above."
"  This lock type is Linux-specific, and available since Linux 3.15.  For an "
"explanation of open file descriptions, see B<open>(2)"
msgstr ""
"Блокировки открытых файловых описаний являются консультативными блокировками "
"диапазона байт, чьё действие почти идентично обычным блокировкам, "
"описанным выше. "
"Данный тип блокировок есть только в Linux и доступен с версии 3.15. "
"Описание открытых файловых описаний смотрите в B<open>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:497
msgid ""
"The principal difference between the two lock types is that whereas "
"traditional record locks are associated with a process, open file "
"description locks are associated with the open file description on which "
"they are acquired, much like locks acquired with B<flock>(2).  Consequently "
"(and unlike traditional advisory record locks), open file description locks "
"are inherited across B<fork>(2)  (and B<clone>(2)  with B<CLONE_FILES>), and"
" are only automatically released on the last close of the open file "
"description, instead of being released on any close of the file."
msgstr ""
"Принципиальное различие между двумя типами блокировок в том, что "
"обычные блокировки связаны с процессом, а блокировки открытых файловых "
"описаний "
"связаны с открытым файловым описанием, для которого они получены "
"(очень похоже на блокировки, получаемые с помощью B<flock>(2). "
"В следствие этого "
"(и в отличие от обычных консультативных блокировок), блокировки открытых "
"файловых описаний наследуются при "
"B<fork>(2) (и при B<clone>(2) с B<CLONE_FILES>), и "
"освобождаются только автоматически при последнем закрытии "
"открытого файлового описания, а не при любом закрытии файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:500
msgid ""
"Open file description locks always conflict with traditional record locks, "
"even when they are acquired by the same process on the same file descriptor."
msgstr ""
"Блокировки открытых файловых описаний всегда конфликтуют с "
"обычными блокировками, даже когда они запрашиваются одним "
"процессом для одного и того же файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fcntl.2:513
msgid ""
"Open file description locks placed via the same open file description (i.e.,"
" via the same file descriptor, or via a duplicate of the file descriptor "
"created by B<fork>(2), B<dup>(2), B<fcntl>(2)  B<F_DUPFD>, and so on) are "
"always compatible: if a new lock is placed on an already locked region, then"
" the existing lock is converted to the new lock type.  (Such conversions may"
" result in splitting, shrinking, or coalescing with an existing lock as "
"discussed above.)"
msgstr ""
"Блокировки открытых файловых описаний, полученные для одного "
"и того же файлового описания (т. е., для одного и того же файлового "
"дескриптора "
"или его копии, созданной в результате "
"B<fork>(2), B<dup>(2), B<fcntl>(2)  B<F_DUPFD> и т. п.), всегда совместимы: "
"если новая блокировка помещается на уже заблокированную область, то "
"существующая блокировка преобразуется в блокировку нового типа "
"(такие преобразования могут приводить к разделению, сокращению или "
"объединению существующей блокировки, как описывалось ранее)."

#. type: Plain text
#: man-pages/man2/fcntl.2:521
msgid ""
"On the other hand, open file description locks may conflict with each other "
"when they are acquired via different open file descriptions.  Thus, the "
"threads in a multithreaded program can use open file description locks to "
"synchronize access to a file region by having each thread perform its own "
"B<open>(2)  on the file and applying locks via the resulting file "
"descriptor."
msgstr ""
"С другой стороны, блокировки открытых файловых описаний "
"могут конфликтовать друг с другом, когда они запрашиваются "
"через разные открытые файловые описания. То есть, нити в многонитевых "
"программах могут использовать блокировки открытых файловых описаний  "
"для синхронизации доступа к области файла, если каждая нить выполняет "
"отдельный вызов B<open>(2) на файл и применяет блокировки для "
"получаемого файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fcntl.2:532
msgid ""
"As with traditional advisory locks, the third argument to B<fcntl>(), "
"I<lock>, is a pointer to an I<flock> structure.  By contrast with "
"traditional record locks, the I<l_pid> field of that structure must be set "
"to zero when using the commands described below."
msgstr ""
"Как и у обычных блокировок, третий аргумент B<fcntl>(), "
"I<lock>, является указателем на структуру I<flock>. "
"Но в отличие от обычных блокировок при "
"использовании команд, описанных далее, поле "
"I<l_pid> этой структуры должно иметь значение 0."

#. type: Plain text
#: man-pages/man2/fcntl.2:535
msgid ""
"The commands for working with open file description locks are analogous to "
"those used with traditional locks:"
msgstr ""
"Команды для работы с блокировками открытых файловых описаний "
"аналогичны используемым для обычных блокировок:"

#. type: TP
#: man-pages/man2/fcntl.2:535
#, no-wrap
msgid "B<F_OFD_SETLK> (I<struct flock *>)"
msgstr "B<F_OFD_SETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:556
msgid ""
"Acquire an open file description lock (when I<l_type> is B<F_RDLCK> or "
"B<F_WRLCK>)  or release an open file description lock (when I<l_type> is "
"B<F_UNLCK>)  on the bytes specified by the I<l_whence>, I<l_start>, and "
"I<l_len> fields of I<lock>.  If a conflicting lock is held by another "
"process, this call returns -1 and sets I<errno> to B<EAGAIN>."
msgstr ""
"Установить блокировку открытого файлового описания (когда I<l_type> равен B<"
"F_RDLCK> или B<F_WRLCK>) или "
"снять блокировку открытого файлового описания (когда I<l_type> равен B<"
"F_UNLCK>) байтов, указанных полями "
"I<l_whence>, I<l_start> и I<l_len> структуры I<lock>. Если конфликтующая "
"блокировка удерживается другим процессом, то данный вызов вернёт -1 и "
"установит значение I<errno> в B<EAGAIN>."

#. type: TP
#: man-pages/man2/fcntl.2:556
#, no-wrap
msgid "B<F_OFD_SETLKW> (I<struct flock *>)"
msgstr "B<F_OFD_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:570
msgid ""
"As for B<F_OFD_SETLK>, but if a conflicting lock is held on the file, then "
"wait for that lock to be released.  If a signal is caught while waiting, "
"then the call is interrupted and (after the signal handler has returned) "
"returns immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"Как B<F_OFD_SETLK>, но если конфликтующая блокировка удерживается на файле, "
"то "
"выполняется ожидание снятия этой блокировки. Если во время ожидания поступил "
"сигнал, то данный вызов прерывается и (после возврата из обработчика "
"сигнала) из него происходит немедленный возврат (возвращается значение -1 и "
"I<errno> устанавливается в B<EINTR>; см. B<signal>(7))."

#. type: TP
#: man-pages/man2/fcntl.2:570
#, no-wrap
msgid "B<F_OFD_GETLK> (I<struct flock *>)"
msgstr "B<F_OFD_GETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:589
msgid ""
"On input to this call, I<lock> describes an open file description lock we "
"would like to place on the file.  If the lock could be placed, B<fcntl>()  "
"does not actually place it, but returns B<F_UNLCK> in the I<l_type> field of"
" I<lock> and leaves the other fields of the structure unchanged.  If one or "
"more incompatible locks would prevent this lock being placed, then details "
"about one of these locks are returned via I<lock>, as described above for "
"B<F_GETLK>."
msgstr ""
"В начала данного вызова значение I<lock> описывает блокировку "
"открытого файлового описания, которую мы бы хотели создать на "
"файле. Если блокировка возможна, то в действительности B<fcntl>() её "
"не создаёт, а возвращает B<F_UNLCK> в поле I<l_type> у "
"I<lock>, оставляя остальные поля неизменными. Если есть одна или более "
"несовместимых блокировок, препятствующих получению, то в "
"I<lock> возвращается подробная информация об этих блокировках, "
"как описывалось выше для B<F_GETLK>."

#.  commit 57b65325fe34ec4c917bc4e555144b4a94d9e1f7
#. type: Plain text
#: man-pages/man2/fcntl.2:596
msgid ""
"In the current implementation, no deadlock detection is performed for open "
"file description locks.  (This contrasts with process-associated record "
"locks, for which the kernel does perform deadlock detection.)"
msgstr ""
"В текущей реализации для блокировок открытых файловых описаний "
"обнаружение взаимных блокировок не выполняется "
"(в этом отличие от попроцессных блокировок, для которых ядро "
"выполняет обнаружение взаимных блокировок)."

#. type: SS
#: man-pages/man2/fcntl.2:596 man-pages/man2/fcntl.2:1667
#, no-wrap
msgid "Mandatory locking"
msgstr "Обязательная (mandatory) блокировка"

#. type: Plain text
#: man-pages/man2/fcntl.2:600
msgid ""
"I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
"See BUGS below."
msgstr ""
"I<Предупреждение>: реализация обязательного блокирования в Linux ненадёжна. "
"Смотрите раздел "
"ДЕФЕКТЫ далее."

#. type: Plain text
#: man-pages/man2/fcntl.2:605
msgid ""
"By default, both traditional (process-associated) and open file description "
"record locks are advisory.  Advisory locks are not enforced and are useful "
"only between cooperating processes."
msgstr ""
"По умолчанию, обычные (связанные с процессом) блокировки и блокировки "
"открытого файлового описания являются консультативными. "
"Консультативные блокировки не обязательны к выполнению и полезны только в "
"сотрудничающих процессах."

#. type: Plain text
#: man-pages/man2/fcntl.2:625
msgid ""
"Both lock types can also be mandatory.  Mandatory locks are enforced for all"
" processes.  If a process tries to perform an incompatible access (e.g., "
"B<read>(2)  or B<write>(2))  on a file region that has an incompatible "
"mandatory lock, then the result depends upon whether the B<O_NONBLOCK> flag "
"is enabled for its open file description.  If the B<O_NONBLOCK> flag is not "
"enabled, then the system call is blocked until the lock is removed or "
"converted to a mode that is compatible with the access.  If the "
"B<O_NONBLOCK> flag is enabled, then the system call fails with the error "
"B<EAGAIN>."
msgstr ""
"Оба типа блокировки могут быть также обязательными. Если процесс пытается "
"получить несовместимый доступ (например, B<read>(2) и B<write>(2)) к области "
"файла, на которую установлена несовместимая обязательная блокировка, то "
"результат зависит от состояния флага B<O_NONBLOCK> в описании этого "
"открытого файла. Если флаг B<O_NONBLOCK> не установлен, то системный вызов "
"блокируется до удаления блокировки или преобразуется в режим, который "
"совместим с доступом. Если флаг B<O_NONBLOCK> установлен, то системный вызов "
"завершается с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/fcntl.2:642
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself."
"  Mandatory locking is enabled on a filesystem using the \"-o mand\" option "
"to B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory "
"locking is enabled on a file by disabling group execute permission on the "
"file and enabling the set-group-ID permission bit (see B<chmod>(1)  and "
"B<chmod>(2))."
msgstr ""
"Чтобы использовать обязательные блокировки, обязательное блокирование должно "
"быть включено в файловой системе, содержащей файл, и на самом файле. "
"Обязательное блокирование включается в файловой системе с помощью параметра "
"«-o mand» команды B<mount>(8) или с помощью флага B<MS_MANDLOCK> в B<mount>"
"(2). Обязательное блокирование включается на файле посредством отключения "
"права исполнения группе и установкой бита set-group-ID (см. B<chmod>(1) и B<"
"chmod>(2))."

#. type: Plain text
#: man-pages/man2/fcntl.2:646
msgid ""
"Mandatory locking is not specified by POSIX.  Some other systems also "
"support mandatory locking, although the details of how to enable it vary "
"across systems."
msgstr ""
"Обязательная блокировка не описана в POSIX. В некоторых других "
"системах обязательная блокировка также поддерживается, хотя "
"процесс её создания различен."

#. type: SS
#: man-pages/man2/fcntl.2:646
#, no-wrap
msgid "Managing signals"
msgstr "Управление сигналами"

#. type: Plain text
#: man-pages/man2/fcntl.2:655
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""
"Для управления сигналами доступности ввода/вывода используются команды B<"
"F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> и B<"
"F_SETSIG>:"

#. type: TP
#: man-pages/man2/fcntl.2:655
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr "B<F_GETOWN> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:668
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""
"Получить (как результат работы функции) идентификатор процесса или группы "
"процесса, который в текущий момент принимает сигналы B<SIGIO> и B<SIGURG> для "
"событий на файловом дескрипторе I<fd>. Идентификатор процесса возвращается "
"как положительное число; идентификатор группы возвращается как отрицательное "
"число (но см. раздел ДЕФЕКТЫ далее). Аргумент I<arg> игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:668
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr "B<F_SETOWN> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:685
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on file descriptor I<fd> to the ID given in "
"I<arg>.  A process ID is specified as a positive value; a process group ID "
"is specified as a negative value.  Most commonly, the calling process "
"specifies itself as the owner (that is, I<arg> is specified as "
"B<getpid>(2))."
msgstr ""
"Установить идентификатор процесса или группы процесса, которые будут "
"принимать сигналы B<SIGIO> и B<SIGURG> для событий на файловом дескрипторе I<"
"fd>; идентификатор задаётся в аргументе I<arg>. Идентификатор процесса "
"задаётся положительным числом, идентификатор группы задаётся отрицательным "
"числом. Обычно, вызывающий процесс указывает самого себя в качестве "
"принимающего (то есть в I<arg> указывается результат B<getpid>(2))."

#.  From glibc.info:
#. type: Plain text
#: man-pages/man2/fcntl.2:702
msgid ""
"If you set the B<O_ASYNC> status flag on a file descriptor by using the "
"B<F_SETFL> command of B<fcntl>(), a B<SIGIO> signal is sent whenever input "
"or output becomes possible on that file descriptor.  B<F_SETSIG> can be used"
" to obtain delivery of a signal other than B<SIGIO>.  If this permission "
"check fails, then the signal is silently discarded."
msgstr ""
"Если вы установили на файловый дескриптор флаг состояния B<O_ASYNC> с помощью "
"команды B<F_SETFL> в B<fcntl>(), то сигнал B<SIGIO> посылается всякий раз, "
"когда для данного файлового дескриптора становится возможным ввод или вывод. "
"B<F_SETSIG> можно использовать для включения доставки сигнала, отличного от "
"B<SIGIO>. Если такая проверка разрешения завершится неудачно, то сигнал "
"просто отбрасывается."

#. type: Plain text
#: man-pages/man2/fcntl.2:710
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below)."
msgstr ""
"Отправка сигнала процессу-владельцу (группе), указанному с помощью B<F_SETOWN>"
" \\(em такая же проверка прав, как описанная для B<kill>(2), где посылающий "
"процесс один из тех, который может пользоваться B<F_SETOWN> (но см. раздел "
"ДЕФЕКТЫ далее)."

#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
#: man-pages/man2/fcntl.2:734
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where "
"B<select>(2)  would report the socket as having an \"exceptional "
"condition\".)"
msgstr ""
"Если файловый дескриптор I<fd> указывает на сокет, то по команде B<F_SETOWN> "
"для него также выбирается получатель сигналов B<SIGURG>, которые "
"доставляются, когда на сокет поступают внеполосные данные. (B<SIGURG> "
"посылается во всех ситуациях, когда вызов B<select>(2) говорит, что сокет "
"находится в состоянии \"исключительной ситуации\".)"

#. type: Plain text
#: man-pages/man2/fcntl.2:737
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr "Следующее верно для ядер 2.6.x, до 2.6.11 включительно:"

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
#: man-pages/man2/fcntl.2:777
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current"
" Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""
"Если для B<F_SETSIG> передаётся ненулевое значение в многонитивой процесс, "
"работающий с библиотекой нитей (например, NPTL), которая обеспечивает "
"поддержку групп нитей, то положительное значение, переданное B<F_SETOWN>, "
"имеет другой смысл: вместо указания ID процесса, описывающего весь процесс, "
"она является ID нити, указывающим на определённую нить процесса. Поэтому "
"может понадобиться передать в B<F_SETOWN> результат B<gettid>(2), а не B<"
"getpid>(2), чтобы получить правильный результат при использовании B<F_SETSIG>"
". (В имеющихся реализациях Linux ID главной нити совпадает с ID процесса. Это "
"означает, что в программе с одной нитью можно использовать любой вызов, B<"
"gettid>(2) или B<getpid>(2), в этом случае.) Однако заметим, что утверждения "
"этого абзаца не применимы к сигналу B<SIGURG>, генерируемому для внеполосных "
"данных сокета: этот сигнал всегда посылается или процессу или группе "
"процессов, в зависимости от значения, указанного для B<F_SETOWN>."

#. type: Plain text
#: man-pages/man2/fcntl.2:788
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""
"Описанное выше поведение было случайно удалено из Linux 2.6.12, и так и не "
"восстановлено. Начиная с Linux 2.6.32 используйте B<F_SETOWN_EX> при "
"назначении сигналов B<SIGIO> и B<SIGURG> для определённой нити."

#. type: TP
#: man-pages/man2/fcntl.2:788
#, no-wrap
msgid "B<F_GETOWN_EX> (struct f_owner_ex *) (since Linux 2.6.32)"
msgstr "B<F_GETOWN_EX> (struct f_owner_ex *) (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/fcntl.2:797
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""
"Получить настройки владения текущим файловым дескриптором, установленные "
"предыдущей командой B<F_SETOWN_EX>. Информация возвращается в структуре, "
"указанной в I<arg>, которая имеет следующий вид:"

#. type: Plain text
#: man-pages/man2/fcntl.2:804
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr "struct f_owner_ex {\n    int   type;\n    pid_t pid;\n};\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:821
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""
"Поле I<type> будет равно: B<F_OWNER_TID>, B<F_OWNER_PID> или B<F_OWNER_PGRP>. "
"Значением поля I<pid> будет положительное целое, представляющее ID нити, ID "
"процесса или ID группы процессов. Подробности смотрите в описании B<"
"F_SETOWN_EX>."

#. type: TP
#: man-pages/man2/fcntl.2:821
#, no-wrap
msgid "B<F_SETOWN_EX> (struct f_owner_ex *) (since Linux 2.6.32)"
msgstr "B<F_SETOWN_EX> (struct f_owner_ex *) (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/fcntl.2:837
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller"
" to direct I/O availability signals to a specific thread, process, or "
"process group.  The caller specifies the target of signals via I<arg>, which"
" is a pointer to a I<f_owner_ex> structure.  The I<type> field has one of "
"the following values, which define how I<pid> is interpreted:"
msgstr ""
"Эта команда выполняет задачу, подобную B<F_SETOWN>. Она позволяет вызывающему "
"назначить сигналы доступности ввода-вывода определённой нити, процессу или "
"группе процессов. Вызывающий указывает приёмник сигналов в I<arg>, выражаемый "
"указателем на структуру I<f_owner_ex>. Поле I<type> имеет одно из следующих "
"значений, которое определяет чем считать I<pid>:"

#. type: TP
#: man-pages/man2/fcntl.2:838
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr "B<F_OWNER_TID>"

#. type: Plain text
#: man-pages/man2/fcntl.2:847
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""
"Посылать сигнал нити, чей ID (значение, возвращаемое вызовом B<clone>(2) или "
"B<gettid>(2)) указан в I<pid>."

#. type: TP
#: man-pages/man2/fcntl.2:847
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr "B<F_OWNER_PID>"

#. type: Plain text
#: man-pages/man2/fcntl.2:852
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr "Посылать сигнал процессу, чей ID указан в I<pid>."

#. type: TP
#: man-pages/man2/fcntl.2:852
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr "B<F_OWNER_PGRP>"

#. type: Plain text
#: man-pages/man2/fcntl.2:860
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note"
" that, unlike with B<F_SETOWN>, a process group ID is specified as a "
"positive value here.)"
msgstr ""
"Посылать сигнал группе процессов, чей ID указан в I<pid>. (Заметим, что в "
"отличие от B<F_SETOWN>, ID группы процессов здесь задаётся как положительное "
"значение.)"

#. type: TP
#: man-pages/man2/fcntl.2:861
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr "B<F_GETSIG> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:876
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""
"Получить (как результат функции) сигнал, посылаемый, когда становится "
"возможным ввод или вывод. Значение 0 означает сигнал B<SIGIO>. Любое другое "
"значение (включая B<SIGIO>) является другим сигналом, и в этом случае для "
"обработчика сигнала доступна дополнительная информация, если он был "
"установлен с B<SA_SIGINFO>. Аргумент I<arg> игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:876
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr "B<F_SETSIG> (I<int>)"

#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
#: man-pages/man2/fcntl.2:899
msgid ""
"Set the signal sent when input or output becomes possible to the value given"
" in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any"
" other value (including B<SIGIO>)  is the signal to send instead, and in "
"this case additional info is available to the signal handler if installed "
"with B<SA_SIGINFO>."
msgstr ""
"Установить сигнал, который будет посылаться когда станет возможен ввод или "
"вывод, в значение, указанное в I<arg>. Значение 0 означает сигнал по "
"умолчанию B<SIGIO>. Любое другое значение (включая B<SIGIO>) является другим "
"сигналом, и в этом случае, для обработчика сигнала доступна дополнительная "
"информация, если он был установлен с B<SA_SIGINFO>."

#. type: Plain text
#: man-pages/man2/fcntl.2:927
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the"
" signal handler (see B<sigaction>(2)), extra information about I/O events is"
" passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field"
" indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""
"В случае использования B<F_SETSIG> с ненулевым значением и установкой B<"
"SA_SIGINFO> для обработчика сигнала (см. B<sigaction>(2)) обработчику "
"передаётся дополнительная информация о событиях ввода/вывода в структуре I<"
"siginfo_t>. Если поле I<si_code> показывает, что источник \\(em B<SI_SIGIO>, "
"то поле I<si_fd> содержит файловый дескриптор, ассоциированный с событием. В "
"противном случае не существует никакого механизма, чтобы сообщить с каким "
"файловым дескриптором связан полученный сигнал, и вы должны использовать "
"обычные механизмы (B<select>(2), B<poll>(2), B<read>(2) с установленным B<"
"O_NONBLOCK> и т.д.), чтобы определить какой файловый дескриптор доступен для "
"ввода/вывода."

#. type: Plain text
#: man-pages/man2/fcntl.2:936
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory).  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""
"При выборе сигнала реального времени (значение E<gt>= B<SIGRTMIN>) в очередь "
"может добавляться несколько событий ввода-вывода с одинаковыми номерами "
"сигналов. (Размер очереди зависит от доступной памяти). Дополнительная "
"информация будет доступна как описано выше, если для обработчика сигнала "
"будет установлено B<SA_SIGINFO>."

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
#: man-pages/man2/fcntl.2:949
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""
"Заметим, что в Linux есть предел на количество сигналов реального времени, "
"которые могут находиться в очереди процесса (см. B<getrlimit>(2) и B<signal>"
"(7)), и если этот предел достигнут, то ядро изменяет пункт доставки B<SIGIO>, "
"и этот сигнал доставляется всему процессу, а не указанной нити."

#. type: Plain text
#: man-pages/man2/fcntl.2:956
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""
"Используя эти механизмы, программа может реализовать полностью асинхронный "
"ввод-вывод почти не используя в своей работе B<select>(2) или B<poll>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:980
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""
"Использование B<O_ASYNC>, является специфичным для BSD и Linux. В POSIX.1 "
"описано только использование B<F_GETOWN> и B<F_SETOWN> вместе с сигналом B<"
"SIGURG> для сокетов (в POSIX не определён сигнал B<SIGIO>). B<F_GETOWN_EX>, "
"B<F_SETOWN_EX>, B<F_GETSIG>, and B<F_SETSIG> есть только в Linux. В POSIX "
"описан асинхронный ввод-вывод и структура I<aio_sigevent>, используемая для "
"сходных действий; они также доступны в Linux как часть библиотеки GNU C "
"(Glibc)."

#. type: SS
#: man-pages/man2/fcntl.2:980
#, no-wrap
msgid "Leases"
msgstr "Аренда"

#. type: Plain text
#: man-pages/man2/fcntl.2:995
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used (respectively) "
"to establish a new lease, and retrieve the current lease, on the open file "
"description referred to by the file descriptor I<fd>.  A file lease provides"
" a mechanism whereby the process holding the lease (the \"lease holder\") is"
" notified (via delivery of a signal)  when a process (the \"lease breaker\")"
" tries to B<open>(2)  or B<truncate>(2)  the file referred to by that file "
"descriptor."
msgstr ""
"Команды B<F_SETLEASE> и B<F_GETLEASE> (в Linux 2.4 и выше) используются, "
"соответственно, для установки новой и получения текущей аренды открытого "
"описания файла, на который указывает файловый дескриптор I<fd>. Аренда файла "
"предоставляет механизм, посредством которого процесс, который удерживает "
"аренду («арендатор»), уведомляется (отправкой сигнала), когда процесс "
"(«нарушитель аренды») пытается выполнить вызов B<open>(2) или B<truncate>(2) "
"на файл, указанный в этом файловом дескрипторе."

#. type: TP
#: man-pages/man2/fcntl.2:995
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr "B<F_SETLEASE> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1000
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""
"Установить или удалить аренду файла, в соответствии со значениями, "
"указываемыми в I<arg>:"

#. type: TP
#: man-pages/man2/fcntl.2:1001
#, no-wrap
msgid "B<F_RDLCK>"
msgstr "B<F_RDLCK>"

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
#: man-pages/man2/fcntl.2:1010
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""
"Установить аренду чтения. Это приведёт к генерации уведомления вызывающего "
"процесса, когда файл открывается для записи или усечения. Аренда чтения может "
"быть выделена только на файловый дескриптор, открытый только на чтение."

#. type: TP
#: man-pages/man2/fcntl.2:1010
#, no-wrap
msgid "B<F_WRLCK>"
msgstr "B<F_WRLCK>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1017
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be"
" placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""
"Установить аренду записи. Это приведёт к генерации уведомления вызывающего "
"процесса, когда файл открывается для чтения или записи или выполняется его "
"усечение. Аренда записи может быть установлена на файл, только если этот файл "
"не имеет других открытых файловых дескрипторов."

#. type: TP
#: man-pages/man2/fcntl.2:1017
#, no-wrap
msgid "B<F_UNLCK>"
msgstr "B<F_UNLCK>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1020
msgid "Remove our lease from the file."
msgstr "Удалить аренду с указанного файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:1034
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released"
" by either an explicit B<F_UNLCK> operation on any of these duplicate "
"descriptors, or when all such descriptors have been closed."
msgstr ""
"Аренды ассоциируются с открытым файловым описанием (см. B<open>(2)). Это "
"значит, что дублированные файловые дескрипторы (созданные, например, B<fork>"
"(2) или B<dup>(2)) указывают на одну и ту же аренду, и эта аренда может "
"изменяться или освобождаться через любой из этих дескрипторов. Более того, "
"аренда освобождается или через явную команду B<F_UNLCK> на любом из этих "
"дублированных дескрипторов, или когда все эти дескрипторы будут закрыты."

#. type: Plain text
#: man-pages/man2/fcntl.2:1041
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID"
" of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""
"Аренды могут быть выданы только на обычные файлы. Непривилегированный процесс "
"может получить аренду только на файл, чей UID (владельца) совпадает с UID на "
"файловой системе процесса. Процесс с мандатом B<CAP_LEASE> может получить "
"аренду на любые файлы."

#. type: TP
#: man-pages/man2/fcntl.2:1041
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr "B<F_GETLEASE> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1050
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by"
" returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""
"Узнать какой тип аренды ассоциирован с файловым дескриптором I<fd>; "
"возвращается одно из значений B<F_RDLCK>, B<F_WRLCK> или B<F_UNLCK>, "
"соответственно означающих аренду на чтение, запись или что аренды нет. "
"Аргумент I<arg> игнорируется."

#. type: Plain text
#: man-pages/man2/fcntl.2:1081
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or "
"B<truncate>(2)  that conflicts with a lease established via B<F_SETLEASE>, "
"the system call is blocked by the kernel and the kernel notifies the lease "
"holder by sending it a signal (B<SIGIO> by default).  The lease holder "
"should respond to receipt of this signal by doing whatever cleanup is "
"required in preparation for the file to be accessed by another process "
"(e.g., flushing cached buffers) and then either remove or downgrade its "
"lease.  A lease is removed by performing an B<F_SETLEASE> command specifying"
" I<arg> as B<F_UNLCK>.  If the lease holder currently holds a write lease on"
" the file, and the lease breaker is opening the file for reading, then it is"
" sufficient for the lease holder to downgrade the lease to a read lease.  "
"This is done by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_RDLCK>."
msgstr ""
"Когда процесс («нарушителя аренды») выполняет вызов B<open>(2) или B<truncate>"
"(2), который конфликтует с арендой, установленной через B<F_SETLEASE>, то "
"системный вызов блокируется ядром и ядро уведомляет арендатора сигналом (по "
"умолчанию B<SIGIO>). Арендатор должен при получении этого сигнала выполнить "
"все необходимые действия по очистке для подготовки этого файла к "
"использованию другим процессом (например, сбросить буферы кэша) и затем "
"удалить или снизить условия аренды. Аренда удаляется по команде B<F_SETLEASE> "
"с аргументом I<arg>, установленным в B<F_UNLCK>. Если арендатор удерживает "
"аренду на запись в файл, и нарушитель аренды открывает файл на чтение, то "
"достаточно того, что арендатор понизит условия аренды до аренды на чтение. "
"Это выполняется командой B<F_SETLEASE> с аргументом I<arg>, установленным в "
"B<F_RDLCK>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1086
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number"
" of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""
"Если арендатор не освободит аренду или не снизит условия в течении "
"определённого количества секунд, указанного в файле I<"
"/proc/sys/fs/lease-break-time>, то ядро принудительно удалит или снизит "
"условия аренды для арендатора."

#. type: Plain text
#: man-pages/man2/fcntl.2:1096
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""
"После того, как был начат разрыв аренды, B<F_GETLEASE> возвращает тип "
"назначения аренды (или B<F_RDLCK> или B<F_UNLCK>, в зависимости от "
"необходимости совместимости с нарушителем аренды) до тех пор, пока держатель "
"аренды добровольно не отдаст или не удалит аренду или ядро принудительно не "
"сделает это после истечения таймера разрыва аренды."

#. type: Plain text
#: man-pages/man2/fcntl.2:1100
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""
"После того как аренда снята держателем аренды или принудительно удалена и "
"снижены условия, и предполагая, что нарушитель аренды не выполнял "
"неблокирующий системный вызов, ядро позволяет продолжить работу системного "
"вызова нарушителя аренды."

#. type: Plain text
#: man-pages/man2/fcntl.2:1121
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted"
" by a signal handler, then the system call fails with the error B<EINTR>, "
"but the other steps still occur as described above.  If the lease breaker is"
" killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the"
" other steps still occur as described above.  If the lease breaker specifies"
" the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""
"Если нарушитель аренды, заблокированный в B<open>(2) или B<truncate>(2), "
"прерывается обработчиком сигнала, то системный вызов завершается неудачно с "
"ошибкой B<EINTR>, но другие шаги по-прежнему выполняются как описано ранее. "
"Если нарушитель аренды завершается по сигналу будучи блокированным в B<open>"
"(2) или B<truncate>(2), то другие шаги по-прежнему выполняются как описано "
"ранее. Если нарушитель аренды указал флаг B<O_NONBLOCK> при вызове B<open>"
"(2), то вызов немедленно завершается неудачей с ошибкой B<EWOULDBLOCK>, но "
"другие шаги по-прежнему выполняются как описано ранее. "

#. type: Plain text
#: man-pages/man2/fcntl.2:1142
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can"
" be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files)."
msgstr ""
"По умолчанию, для уведомления арендатора используется сигнал B<SIGIO>, но его "
"можно изменить, используя команду B<F_SETSIG> для B<fcntl>(). Если "
"выполняется команда B<F_SETSIG> (даже назначая сигнал B<SIGIO>), и при этом "
"обработчик сигнала устанавливается с использованием B<SA_SIGINFO>, то "
"обработчик получит в качестве второго аргумента структуру I<siginfo_t>, в "
"которой поле I<si_fd> будет содержать дескриптор арендованного файла, к "
"которому пытается получить доступ другой процесс. (Это полезно, если "
"вызывающий процесс удерживает аренду на несколько файлов)."

#. type: SS
#: man-pages/man2/fcntl.2:1142
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr "Уведомления об изменении файла и каталога (dnotify)"

#. type: TP
#: man-pages/man2/fcntl.2:1143
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr "B<F_NOTIFY> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1153
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""
"(Начиная с Linux 2.4) Уведомлять при смене каталога, на который указывает I<"
"fd> или когда изменились файлы, которые в нём содержатся. События, о "
"наступлении которых делается уведомление, задаются в аргументе I<arg>, "
"который является битовой маской, получаемой сложением (OR) одного или более "
"следующих бит:"

#. type: TP
#: man-pages/man2/fcntl.2:1156
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr "B<DN_ACCESS>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1163
msgid "A file was accessed (B<read>(2), B<pread>(2), B<readv>(2), and similar)"
msgstr ""
"Был произведён доступ к файлу (B<read>(2), B<pread>(2), B<readv>(2) и "
"подобные)."

#. type: TP
#: man-pages/man2/fcntl.2:1163
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr "B<DN_MODIFY>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1172
msgid ""
"A file was modified (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2), and similar)."
msgstr ""
"Файл был изменён (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2) и подобные)."

#. type: TP
#: man-pages/man2/fcntl.2:1172
#, no-wrap
msgid "B<DN_CREATE>"
msgstr "B<DN_CREATE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1183
msgid ""
"A file was created (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2)  into this directory)."
msgstr ""
"Файл был создан (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2) в этом каталоге)."

#. type: TP
#: man-pages/man2/fcntl.2:1183
#, no-wrap
msgid "B<DN_DELETE>"
msgstr "B<DN_DELETE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1190
msgid ""
"A file was unlinked (B<unlink>(2), B<rename>(2)  to another directory, "
"B<rmdir>(2))."
msgstr ""
"Файл был удалён (B<unlink>(2), B<rename>(2) в другой каталог, B<rmdir>(2))."

#. type: TP
#: man-pages/man2/fcntl.2:1190
#, no-wrap
msgid "B<DN_RENAME>"
msgstr "B<DN_RENAME>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1194
msgid "A file was renamed within this directory (B<rename>(2))."
msgstr "Файл был переименован внутри каталога (B<rename>(2))."

#. type: TP
#: man-pages/man2/fcntl.2:1194
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr "B<DN_ATTRIB>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1202
msgid ""
"The attributes of a file were changed (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2), and similar)."
msgstr ""
"У файла были изменены атрибуты (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2) и подобные)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1210
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro"
" must be defined before including I<any> header files.)"
msgstr ""
"(Чтобы получить эти определения, нужно задать макрос тестирования свойств B<"
"_GNU_SOURCE> перед I<всеми> остальными заголовочными файлами.)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1218
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""
"Уведомления об изменении состояния каталога обычно однократные и приложение "
"должно перерегистрировать установку уведомлений, чтобы и дальше получать их. "
"Однако, если в аргумент I<arg>, добавить B<DN_MULTISHOT>, то уведомления "
"будут приходить до тех пор, пока не будут явно отменены."

#.  The following does seem a poor API-design choice...
#. type: Plain text
#: man-pages/man2/fcntl.2:1230
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""
"Серии запросов B<F_NOTIFY> добавляются к событиям в I<arg>, которые уже "
"установлены. Чтобы выключить уведомления всех событий, выполните вызов B<"
"F_NOTIFY>, указав 0 в I<arg>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1253
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to "
"B<fcntl>().  (Note that B<SIGIO> is one of the nonqueuing standard signals; "
"switching to the use of a real-time signal means that multiple notifications"
" can be queued to the process.)  In the latter case, the signal handler "
"receives a I<siginfo_t> structure as its second argument (if the handler was"
" established using B<SA_SIGINFO>)  and the I<si_fd> field of this structure "
"contains the file descriptor which generated the notification (useful when "
"establishing notification on multiple directories)."
msgstr ""
"Уведомление происходит посредством доставки сигнала. "
"Сигналом по умолчанию является B<SIGIO>, но это можно изменить с "
"помощью команды B<F_SETSIG> B<fcntl>() (заметим, что B<SIGIO> — один из "
"безочерёдных стандартных сигналов; "
"переход к использованию сигнала реального времени означает, что "
"многократные уведомления могут попасть в очередь процесса). "
"В последнем случае, обработчик сигнала принимает "
"структуру I<siginfo_t> в качестве второго аргумента (если обработчик был "
"установлен с помощью B<SA_SIGINFO>), в поле I<si_fd> этой структуры "
"содержится файловый описатель, для которого сгенерировано уведомление "
"(полезно при учёте уведомлений из нескольких каталогов)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1258
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for"
" notification, so that multiple notifications can be queued."
msgstr ""
"Кроме того, когда используется B<DN_MULTISHOT>, для уведомлений должен бы "
"быть использован сигнал реального времени, так что множественные уведомления "
"могут быть поставлены в очередь."

#. type: Plain text
#: man-pages/man2/fcntl.2:1267
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining"
" notifications of filesystem events.  See B<inotify>(7)."
msgstr ""
"B<ЗАМЕЧАНИЕ:> В новых приложениях нужно использовать интерфейс I<inotify> "
"(доступен начиная с ядра 2.6.13), который предоставляет намного лучший "
"интерфейс для получения уведомлений о событиях в файловой системе. Смотрите "
"B<inotify>(7)."

#. type: SS
#: man-pages/man2/fcntl.2:1267
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr "Изменение ёмкости канала"

#. type: TP
#: man-pages/man2/fcntl.2:1268
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr "B<F_SETPIPE_SZ> (I<int>; начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1297
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"max-size> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in "
"I</proc/sys/fs/pipe-max-size> yield the error B<EPERM>; a privileged process"
" (B<CAP_SYS_RESOURCE>)  can override the limit.  When allocating the buffer "
"for the pipe, the kernel may use a capacity larger than I<arg>, if that is "
"convenient for the implementation.  The actual capacity that is set is "
"returned as the function result.  Attempting to set the pipe capacity "
"smaller than the amount of buffer space currently used to store data "
"produces the error B<EBUSY>."
msgstr ""
"Изменяет ёмкость канала, на который указывает I<fd>; она становится равной не "
"менее I<arg> байт Непривилегированный процесс может подстроить ёмкость "
"канала до любого значения начиная с размера системной страницы до предела, "
"заданного в I</proc/sys/fs/pipe-max-size> (см. B<proc>(5)). При задании "
"ёмкости меньше размера страницы, она будет без ошибок округлена до размера "
"страницы. При задании непривилегированным процессом ёмкости канала больше "
"предела из I</proc/sys/fs/pipe-max-size> приведёт к ошибке B<EPERM>; "
"привилегированный процесс (с B<CAP_SYS_RESOURCE>) может превысить этот "
"ограничение. При выделении буфера под канал ядро может использовать ёмкость "
"больше чем указано в I<arg>, если это удобно в реализации. "
"Реальным размером считается возвращаемый результатом функции. Попытка "
"установить "
"ёмкость канала меньше чем количество пространства в буфере, в настоящее время "
"используемого для хранения данных, приведёт к ошибке B<EBUSY>."

#. type: TP
#: man-pages/man2/fcntl.2:1297
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr "B<F_GETPIPE_SZ> (I<void>; начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1301
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr "Возвращает (как результат функции) ёмкость канала, указываемого I<fd>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1303
msgid "For a successful call, the return value depends on the operation:"
msgstr ""
"При успешном выполнении возвращаемое значение зависит от используемой команды:"

#. type: TP
#: man-pages/man2/fcntl.2:1303
#, no-wrap
msgid "B<F_DUPFD>"
msgstr "B<F_DUPFD>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1306
msgid "The new descriptor."
msgstr "Новый дескриптор."

#. type: TP
#: man-pages/man2/fcntl.2:1306
#, no-wrap
msgid "B<F_GETFD>"
msgstr "B<F_GETFD>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1309
msgid "Value of file descriptor flags."
msgstr "Значение флагов файлового дескриптора."

#. type: TP
#: man-pages/man2/fcntl.2:1309
#, no-wrap
msgid "B<F_GETFL>"
msgstr "B<F_GETFL>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1312
msgid "Value of file status flags."
msgstr "Значение флагов состояния файла."

#. type: TP
#: man-pages/man2/fcntl.2:1312
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr "B<F_GETLEASE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1315
msgid "Type of lease held on file descriptor."
msgstr "Тип аренды, установленной на файлом дескрипторе."

#. type: TP
#: man-pages/man2/fcntl.2:1315
#, no-wrap
msgid "B<F_GETOWN>"
msgstr "B<F_GETOWN>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1318
msgid "Value of descriptor owner."
msgstr "Значение, представляющее собой владельца дескриптора."

#. type: TP
#: man-pages/man2/fcntl.2:1318
#, no-wrap
msgid "B<F_GETSIG>"
msgstr "B<F_GETSIG>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1324
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""
"Значение сигнала, посылаемого когда становится возможным чтение или запись "
"или ноль для традиционного поведения B<SIGIO>."

#. type: TP
#: man-pages/man2/fcntl.2:1324
#, no-wrap
msgid "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"
msgstr "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1327
msgid "The pipe capacity."
msgstr "Ёмкость канала."

#. type: TP
#: man-pages/man2/fcntl.2:1327
#, no-wrap
msgid "All other commands"
msgstr "Все остальные команды"

#. type: Plain text
#: man-pages/man2/fcntl.2:1330
msgid "Zero."
msgstr "Ноль."

#. type: Plain text
#: man-pages/man2/fcntl.2:1334
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"В случае ошибки возвращается -1 и значение I<errno> устанавливается "
"соответствующим образом."

#. type: TP
#: man-pages/man2/fcntl.2:1335
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr "B<EACCES> или B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1338
msgid "Operation is prohibited by locks held by other processes."
msgstr ""
"Операция запрещена блокировками, которые удерживаются другими процессами."

#. type: Plain text
#: man-pages/man2/fcntl.2:1342
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""
"Операция запрещена, потому что файл отображается в память другим процессом."

#. type: Plain text
#: man-pages/man2/fcntl.2:1351
msgid ""
"I<fd> is not an open file descriptor, or the command was B<F_SETLK> or "
"B<F_SETLKW> and the file descriptor open mode doesn't match with the type of"
" lock requested."
msgstr ""
"Значение I<fd> не является открытым файловым дескриптором или была указана "
"команда B<F_SETLK> или B<F_SETLKW>, но режим открытия файлового дескриптора "
"не совпадает с типом запрошенной блокировки."

#. type: TP
#: man-pages/man2/fcntl.2:1351
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1356
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""
"Было обнаружено, что указанная команда B<F_SETLKW> привела бы к взаимной "
"блокировке (deadlock)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1360
msgid "I<lock> is outside your accessible address space."
msgstr ""
"Значение I<lock> находится за пределами доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/fcntl.2:1372
msgid ""
"For B<F_SETLKW>, the command was interrupted by a signal; see B<signal>(7)."
"  For B<F_GETLK> and B<F_SETLK>, the command was interrupted by a signal "
"before the lock was checked or acquired.  Most likely when locking a remote "
"file (e.g., locking over NFS), but can sometimes happen locally."
msgstr ""
"Выполнение команды B<F_SETLKW> было прервана сигналом, см. B<signal>(7). "
"Выполнение команд B<F_GETLK> и B<F_SETLK> было прервано сигналом перед тем "
"как блокировка была проверена или установлена. Большинство таких ошибок "
"случается при блокировке удалённого файла (например, блокировка через NFS), "
"но иногда такое может случаться и локально."

#. type: Plain text
#: man-pages/man2/fcntl.2:1377
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr "Значение I<cmd> не распознано ядром."

#. type: Plain text
#: man-pages/man2/fcntl.2:1387
msgid ""
"For B<F_DUPFD>, I<arg> is negative or is greater than the maximum allowable "
"value.  For B<F_SETSIG>, I<arg> is not an allowable signal number."
msgstr ""
"При выполнении команды B<F_DUPFD> значение I<arg> отрицательное или больше "
"максимально возможного значения. При выполнении B<F_SETSIG> значение I<arg> "
"не содержит допустимый номер сигнала."

#. type: Plain text
#: man-pages/man2/fcntl.2:1398
msgid ""
"I<cmd> is B<F_OFD_SETLK>, B<F_OFD_SETLKW>, or B<F_OFD_GETLK>, and I<l_pid> "
"was not specified as zero."
msgstr ""
"Значение I<cmd> равно B<F_OFD_SETLK>, B<F_OFD_SETLKW> или B<F_OFD_GETLK>, но "
"значение I<l_pid> не равно нулю."

#. type: Plain text
#: man-pages/man2/fcntl.2:1403
msgid ""
"For B<F_DUPFD>, the process already has the maximum number of file "
"descriptors open."
msgstr ""
"При выполнении команды B<F_DUPFD> процесс достиг максимального количества "
"открытых файловых дескрипторов."

#. type: Plain text
#: man-pages/man2/fcntl.2:1407
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""
"Открыто слишком много блокировок сегментов, таблица блокировок заполнена или "
"ошибка протокола удалённой блокировки (например, при блокировке через NFS)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1415
msgid ""
"B<F_NOTIFY> was specified in I<cmd>, but I<fd> does not refer to a "
"directory."
msgstr "Значение I<cmd> равно B<F_NOTIFY>, I<fd> не ссылается на каталог."

#. type: TP
#: man-pages/man2/fcntl.2:1415
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1420
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""
"Попытка сбросить флаг B<O_APPEND> на файле, который открыт с атрибутом только "
"для добавления."

#. type: Plain text
#: man-pages/man2/fcntl.2:1433
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001. В POSIX.1-2001 указаны только команды B<F_DUPFD>, "
"B<F_GETFD>, B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK> и B<"
"F_SETLKW>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1445
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define either B<_BSD_SOURCE>, or B<_XOPEN_SOURCE> with the "
"value 500 or greater, or B<_POSIX_C_SOURCE> with the value 200809L or "
"greater.)"
msgstr ""
"Значения B<F_GETOWN> и B<F_SETOWN> определены в POSIX.1-2001. Для получения "
"их "
"определений, определите B<_BSD_SOURCE> или B<_XOPEN_SOURCE> со значением 500 "
"или больше, или определите B<_POSIX_C_SOURCE> со значением 200809L или больше."

#. type: Plain text
#: man-pages/man2/fcntl.2:1453
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""
"B<F_DUPFD_CLOEXEC> указана в POSIX.1-2008. Для получения определения, "
"определите B<_POSIX_C_SOURCE> со значением 200809L или больше, или B<"
"_XOPEN_SOURCE> со значением 700 или больше."

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
#: man-pages/man2/fcntl.2:1470
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""
"Команды B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, B<"
"F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE> и B<F_SETLEASE> есть "
"только в Linux. Для задействования этих определений определите макрос B<"
"_GNU_SOURCE>."

#.  FIXME Presumably, glibc will require _GNU_SOURCE
#. type: Plain text
#: man-pages/man2/fcntl.2:1478
msgid ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, and B<F_OFD_GETLK> are Linux-specific, but "
"work is being done to have them included in the next version of POSIX.1."
msgstr ""
"Значения B<F_OFD_SETLK>, B<F_OFD_SETLKW> и B<F_OFD_GETLK> есть только в "
"Linux, но ведётся работа по их включению в следующую версию POSIX.1."

#. type: Plain text
#: man-pages/man2/fcntl.2:1484 man-pages/man2/fcntl.2:1510
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr ""
"Ошибки, возвращаемые B<dup2>(2), отличаются от тех, что возвращаются при B<"
"F_DUPFD>."

#. type: SS
#: man-pages/man2/fcntl.2:1484
#, no-wrap
msgid "File locking"
msgstr "Файловая блокировка"

#. type: Plain text
#: man-pages/man2/fcntl.2:1505 man-pages/man2/fcntl.2:1549
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""
"Первоначальная версия системного вызова B<fcntl>() в Linux не умела работать "
"с большими файловыми смещениями (в структуре I<flock>). Позднее, в Linux 2.4 "
"был добавлен системный вызов B<fcntl64>(). Новый системный вызов использует "
"другую структуру для блокировки файлов — I<flock64> и соответствующие команды "
"— B<F_GETLK64>, B<F_SETLK64> и B<F_SETLKW64>. Однако, это различие может "
"игнорироваться приложениями, которые используют glibc, так как имеющаяся в "
"ней обёрточная функция B<fcntl>() самостоятельно задействует более новый "
"системный вызов, если он доступен."

#. type: SS
#: man-pages/man2/fcntl.2:1510
#, no-wrap
msgid "Record locks"
msgstr "Обычные блокировки (Record locks)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1516
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""
"Начиная с ядра 2.0, не существует разницы между типами блокировки, которые "
"осуществляют B<flock>(2) и B<fcntl>()."

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#.  Also, FreeBSD documents it (Apr 2014).
#. type: Plain text
#: man-pages/man2/fcntl.2:1528
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid>.  Clearly, I<l_pid> alone is not going to be very useful if the "
"process holding the lock may live on a different machine."
msgstr ""
"Некоторые системы имеют дополнительные поля в структуре I<struct flock>, "
"например, I<l_sysid>. Вообще-то, один I<l_pid> не очень полезен, если "
"процесс, удерживающий блокировку, может работать на другой машине."

#. type: SS
#: man-pages/man2/fcntl.2:1549
#, no-wrap
msgid "Record locking and NFS"
msgstr "Блокировка и NFS"

#.  Neil Brown: With NFSv3 the failure mode is the reverse.  If
#.      the server loses contact with a client then any lock stays in place
#.      indefinitely ("why can't I read my mail"... I remember it well).
#.  Jeff Layton:
#.      Note that this is not a firm timeout. The server runs a job
#.      periodically to clean out expired stateful objects, and it's likely
#.      that there is some time (maybe even up to another whole lease period)
#.      between when the timeout expires and the job actually runs. If the
#.      client gets a RENEW in there within that window, its lease will be
#.      renewed and its state preserved.
#. type: Plain text
#: man-pages/man2/fcntl.2:1577
msgid ""
"Before Linux 3.12, if an NFSv4 client loses contact with the server for a "
"period of time (defined as more than 90 seconds with no communication), it "
"might lose and regain a lock without ever being aware of the fact.  (The "
"period of time after which contact is assumed lost is known as the NFSv4 "
"leasetime.  On a Linux NFS server, this can be determined by looking at "
"I</proc/fs/nfsd/nfsv4leasetime>, which expresses the period in seconds.  The"
" default value for this file is 90.)  This scenario potentially risks data "
"corruption, since another process might acquire a lock in the intervening "
"period and perform file I/O."
msgstr ""
"До Linux 3.12, если клиент NFSv4 теряет связь с сервером на некоторый "
"период времени (более 90 секунд), то он может потерять и перезапросить "
"блокировки даже не зная об этом (период времени, после которого "
"контакт предполагается потерянным в NFSv4 называется "
"время аренды (leasetime). У Linux в сервере NFS его можно узнать по значению "
"в I</proc/fs/nfsd/nfsv4leasetime>, которое отражает период в секундах. "
"В этом файле значение по умолчанию равно 90). Данный сценарий "
"несёт потенциальный риск повреждения данных, так как в этот перерыв "
"другой процесс может установить блокировку и выполнить файловый ввод-вывод."

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#.  commit f6de7a39c181dfb8a2c534661a53c73afb3081cd
#. type: Plain text
#: man-pages/man2/fcntl.2:1591
msgid ""
"Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O "
"to the file by a process which \"thinks\" it holds a lock will fail until "
"that process closes and reopens the file.  A kernel parameter, "
"I<nfs.recover_lost_locks>, can be set to 1 to obtain the pre-3.12 behavior, "
"whereby the client will attempt to recover lost locks when contact is "
"reestablished with the server.  Because of the attendant risk of data "
"corruption, this parameter defaults to 0 (disabled)."
msgstr ""
"Начиная с Linux 3.12, если клиент NFSv4 теряет контакт с сервером, то любой "
"файловый ввод-вывод, выполняемый процессом, который «думает», что "
"имеет блокировку, будет завершаться с ошибкой до тех пор, пока этот "
"процесс не закроет и не переоткроет файл. "
"Чтобы вернуть поведение, которое было до версии pre-3.12, можно "
"параметру ядра I<nfs.recover_lost_locks> присвоить значение 1, "
"из-за чего клиент буде пытаться восстановить потерянные блокировки "
"при переустановлении связи с сервером. "
"Из-за наличия сопутствующего риска повреждения данных, значение данного "
"параметра по умолчанию равно 0 (отключено)."

#. type: SS
#: man-pages/man2/fcntl.2:1592
#, no-wrap
msgid "F_SETFL"
msgstr "F_SETFL"

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
#: man-pages/man2/fcntl.2:1604
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""
"Невозможно использовать B<F_SETFL> для смены состояния флагов B<O_DSYNC> и B<"
"O_SYNC>. Попытка изменить состояние этих флагов просто игнорируется."

#. type: SS
#: man-pages/man2/fcntl.2:1604
#, no-wrap
msgid "F_GETOWN"
msgstr "F_GETOWN"

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
#: man-pages/man2/fcntl.2:1630
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""
"Ограничение в соглашениях по системным вызовам Linux на некоторых "
"архитектурах (в частности i386) приводит к тому, что если значение ID группы "
"процесса (отрицательное), возвращаемое по команде B<F_GETOWN>, попадает в "
"диапазон от -1 до -4095, то оно неправильно интерпретируется glibc и "
"считается ошибкой в системном вызове; то есть возвращаемое значение B<fcntl>"
"() будет равно -1, а I<errno> будет содержать значение ID группы процесса "
"(положительное). Команда B<F_GETOWN_EX> (есть только в Linux) не подвержена "
"этой проблеме. Начиная с glibc версии 2.11, glibc делает проблему для B<"
"F_GETOWN> невидимой, реализовав B<F_GETOWN> с помощью B<F_GETOWN_EX>."

#. type: SS
#: man-pages/man2/fcntl.2:1630
#, no-wrap
msgid "F_SETOWN"
msgstr "F_SETOWN"

#. type: Plain text
#: man-pages/man2/fcntl.2:1648
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as"
" a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group)"
" is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""
"В Linux 2.4 и более раннем, есть ошибка, которая может произойти когда "
"непривилегированный процесс использует B<F_SETOWN> для задания владельца "
"дескриптора файла сокета как процесса (группу) отличного от вызывающего. В "
"этом случае B<fcntl>() может вернуть -1 с I<errno> равным B<EPERM>, даже "
"когда процесс (группа) владелец такая же как и вызывающий имеет право "
"посылать сигнал. Несмотря на возвращаемую ошибку, владелец файлового "
"дескриптора всё равно устанавливается и сигналы будут посылаться владельцу."

#. type: SS
#: man-pages/man2/fcntl.2:1648
#, no-wrap
msgid "Deadlock detection"
msgstr "Обнаружение взаимных блокировок (deadlock)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1667
msgid ""
"The deadlock-detection algorithm employed by the kernel when dealing with "
"B<F_SETLKW> requests can yield both false negatives (failures to detect "
"deadlocks, leaving a set of deadlocked processes blocked indefinitely)  and "
"false positives (B<EDEADLK> errors when there is no deadlock).  For example,"
" the kernel limits the lock depth of its dependency search to 10 steps, "
"meaning that circular deadlock chains that exceed that size will not be "
"detected.  In addition, the kernel may falsely indicate a deadlock when two "
"or more processes created using the B<clone>(2)  B<CLONE_FILES> flag place "
"locks that appear (to the kernel) to conflict."
msgstr ""
"Алгоритм обнаружения взаимных блокировок задействуется ядром "
"при работе с запросами "
"B<F_SETLKW> и может закончиться как ненахождением (не удалось "
"обнаружить взаимную блокировку и процессы блокируют друг "
"друга навсегда), так и ошибочным нахождением "
"(ошибка B<EDEADLK>, но взаимная блокировка отсутствует). "
"Например, ограничение ядра на вложенность зависимостей "
"блокировки при поиске равна 10, что означает, что цепочки циклических "
"зависимостей, превышающие этот размер, не будут обнаружены. "
"Также ядро может ошибочно посчитать за взаимную блокировку ситуацию, "
"когда два и более процесса, созданных с помощью "
"B<clone>(2) с флагом B<CLONE_FILES>, размещают блокировки, которые "
"похожи (для ядра) на конфликтующие."

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#.  Reconfirmed by Jeff Layton
#.      From: Jeff Layton <jlayton <at> redhat.com>
#.      Subject: Re: Status of fcntl() mandatory locking
#.      Newsgroups: gmane.linux.file-systems
#.      Date: 2014-04-28 10:07:57 GMT
#.      http://thread.gmane.org/gmane.linux.file-systems/84481/focus=84518
#. type: Plain text
#: man-pages/man2/fcntl.2:1689
msgid ""
"The Linux implementation of mandatory locking is subject to race conditions "
"which render it unreliable: a B<write>(2)  call that overlaps with a lock "
"may modify data after the mandatory lock is acquired; a B<read>(2)  call "
"that overlaps with a lock may detect changes to data that were made only "
"after a write lock was acquired.  Similar races exist between mandatory "
"locks and B<mmap>(2).  It is therefore inadvisable to rely on mandatory "
"locking."
msgstr ""
"Реализация обязательной блокировки в Linux проводит "
"к состязательности процессов, что делает её ненадёжной: вызов B<write>(2), "
"пересекающийся с блокировкой, может изменить данные после установления "
"обязательной блокировки; вызов B<read>(2), пересекающийся с блокировкой, "
"может обнаружить изменившиеся данные, которые были внесены уже установления "
"блокировки на запись. Подобная состязательность существует между "
"обязательными блокировками и B<mmap>(2). Поэтому нецелесообразно полагаться "
"на обязательную блокировку."

#. type: Plain text
#: man-pages/man2/fcntl.2:1697
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7)"
msgstr ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), B<"
"capabilities>(7), B<feature_test_macros>(7)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1709
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and I"
"<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""
"Файлы I<locks.txt>, I<mandatory-locking.txt> и I<dnotify.txt> из каталога I<"
"Documentation/filesystems.> исходного кода ядра Linux (в старых ядрах эти "
"файлы были в каталоге I<Documentation/>, а I<mandatory-locking.txt> назывался "
"I<mandatory.txt>)."

#. type: TH
#: man-pages/man2/fsync.2:38
#, no-wrap
msgid "FSYNC"
msgstr "FSYNC"

#. type: TH
#: man-pages/man2/fsync.2:38
#, no-wrap
msgid "2014-04-06"
msgstr "2014-04-06"

#. type: Plain text
#: man-pages/man2/fsync.2:41
msgid ""
"fsync, fdatasync - synchronize a file's in-core state with storage device"
msgstr ""
"fsync, fdatasync - синхронизирует состояние файла в памяти с состоянием на "
"устройстве хранения"

#. type: Plain text
#: man-pages/man2/fsync.2:45
msgid "B<int fsync(int >I<fd>B<);>"
msgstr "B<int fsync(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man2/fsync.2:47
msgid "B<int fdatasync(int >I<fd>B<);>"
msgstr "B<int fdatasync(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man2/fsync.2:55
msgid "B<fsync>(): _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "B<fsync>(): _BSD_SOURCE || _XOPEN_SOURCE"

#.  _POSIX_C_SOURCE\ >=\ 200112L only since glibc 2.8
#. type: Plain text
#: man-pages/man2/fsync.2:58
#, no-wrap
msgid "         || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""
"         || /* начиная с glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"

#. type: Plain text
#: man-pages/man2/fsync.2:61
msgid ""
"B<fdatasync>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 500"
msgstr ""
"B<fdatasync>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>"
"=\\ 500"

#. type: Plain text
#: man-pages/man2/fsync.2:74
msgid ""
"B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
"modified buffer cache pages for) the file referred to by the file descriptor"
" I<fd> to the disk device (or other permanent storage device) so that all "
"changed information can be retrieved even after the system crashed or was "
"rebooted.  This includes writing through or flushing a disk cache if "
"present.  The call blocks until the device reports that the transfer has "
"completed.  It also flushes metadata information associated with the file "
"(see B<stat>(2))."
msgstr ""
"Вызов B<fsync>() пересылает («сбрасывает») все изменённые в памяти (in-core) "
"данные (т.е., изменённые страницы буферного кэша) файла, на который указывает "
"файловый дескриптор I<fd>, на дисковое устройство (или другое устройство "
"постоянного хранения) таким образом, что вся изменённая информация может быть "
"получена даже после падения системы или внезапной перезагрузки. При этом "
"выполняется непосредственная запись или сброс дискового кэша (если он "
"есть).Вызов блокируется до тех пор, пока устройство не сообщит, что пересылка "
"завершена. Он также сбрасывает информацию о метаданных, связанную с файлом "
"(см. B<stat>(2))."

#. type: Plain text
#: man-pages/man2/fsync.2:82
msgid ""
"Calling B<fsync>()  does not necessarily ensure that the entry in the "
"directory containing the file has also reached disk.  For that an explicit "
"B<fsync>()  on a file descriptor for the directory is also needed."
msgstr ""
"Вызов B<fsync>() необязательно приводит к тому, что элемент каталога, "
"содержащий файл, также будет сброшен на диск. Для этого нужно явно выполнить "
"B<fsync>() для файлового дескриптора каталога."

#. type: Plain text
#: man-pages/man2/fsync.2:103
msgid ""
"B<fdatasync>()  is similar to B<fsync>(), but does not flush modified "
"metadata unless that metadata is needed in order to allow a subsequent data "
"retrieval to be correctly handled.  For example, changes to I<st_atime> or "
"I<st_mtime> (respectively, time of last access and time of last "
"modification; see B<stat>(2))  do not require flushing because they are not "
"necessary for a subsequent data read to be handled correctly.  On the other "
"hand, a change to the file size (I<st_size>, as made by say "
"B<ftruncate>(2)), would require a metadata flush."
msgstr ""
"Вызов B<fdatasync>() подобен B<fsync>(), но не записывает изменившиеся "
"метаданные, если эти метаданные не нужны для последующего получения данных. "
"Например, изменения I<st_atime> или I<st_mtime> (время последнего доступа и "
"последнего изменения, соответственно; см. B<stat>(2)) не нужно записывать, "
"так как они ненужны для чтения самих данных. С другой стороны, при изменении "
"размера файла (I<st_size>, изменяется, например, B<ftruncate>(2)) запись "
"метаданных будет нужна."

#. type: Plain text
#: man-pages/man2/fsync.2:108
msgid ""
"The aim of B<fdatasync>()  is to reduce disk activity for applications that "
"do not require all metadata to be synchronized with the disk."
msgstr ""
"Целью создания B<fdatasync>() является сокращение обменов с диском для "
"приложений, которым не нужна синхронизация метаданных с диском."

#. type: Plain text
#: man-pages/man2/fsync.2:113
msgid ""
"On success, these system calls return zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"В случае успеха данные системные вызовы возвращают ноль. Если произошла "
"ошибка возвращается -1 и I<errno> устанавливается должным образом."

#. type: Plain text
#: man-pages/man2/fsync.2:118
msgid "I<fd> is not a valid open file descriptor."
msgstr "I<fd> не является правильным открытым файловым дескриптором."

#. type: TP
#: man-pages/man2/fsync.2:118
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/fsync.2:121
msgid "An error occurred during synchronization."
msgstr "Во время синхронизации произошла ошибка."

#. type: TP
#: man-pages/man2/fsync.2:121
#, no-wrap
msgid "B<EROFS>, B<EINVAL>"
msgstr "B<EROFS>, B<EINVAL>"

#. type: Plain text
#: man-pages/man2/fsync.2:125
msgid ""
"I<fd> is bound to a special file which does not support synchronization."
msgstr ""
"I<fd> связан со специальным файлом, который не поддерживает синхронизацию."

#. type: Plain text
#: man-pages/man2/fsync.2:127
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: SH
#: man-pages/man2/fsync.2:127
#, no-wrap
msgid "AVAILABILITY"
msgstr "ДОСТУПНОСТЬ"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/fsync.2:140
msgid ""
"On POSIX systems on which B<fdatasync>()  is available, "
"B<_POSIX_SYNCHRONIZED_IO> is defined in I<E<lt>unistd.hE<gt>> to a value "
"greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"В системах POSIX, в которых есть B<fdatasync>(), в I<E<lt>unistd.hE<gt>> "
"определено значение для B<_POSIX_SYNCHRONIZED_IO> и оно больше 0 (см. также "
"B<sysconf>(3))."

#. type: Plain text
#: man-pages/man2/fsync.2:146
msgid ""
"On some UNIX systems (but not Linux), I<fd> must be a I<writable> file "
"descriptor."
msgstr ""
"В некоторых системах UNIX (но не в Linux), I<fd> должен быть файловым "
"дескриптором, I<доступным для записи>."

#. type: Plain text
#: man-pages/man2/fsync.2:152
msgid ""
"In Linux 2.2 and earlier, B<fdatasync>()  is equivalent to B<fsync>(), and "
"so has no performance advantage."
msgstr ""
"В Linux 2.2 и ранее, вызов B<fdatasync>() эквивалентен B<fsync>(), и поэтому "
"не даёт преимуществ в производительности."

#. type: Plain text
#: man-pages/man2/fsync.2:162
msgid ""
"The B<fsync>()  implementations in older kernels and lesser used filesystems"
" does not know how to flush disk caches.  In these cases disk caches need to"
" be disabled using B<hdparm>(8)  or B<sdparm>(8)  to guarantee safe "
"operation."
msgstr ""
"Реализации B<fsync>() в старых ядрах и ранее, использовавшиеся в файловых "
"системах, не знали как очищать (flush) дисковые кэши. В этих случаях дисковые "
"кэши требовалось заблокировать с помощью B<hdparm>(8) или B<sdparm>(8), чтобы "
"гарантировать безопасное выполнение."

#. type: Plain text
#: man-pages/man2/fsync.2:169
msgid ""
"B<bdflush>(2), B<open>(2), B<sync>(2), B<sync_file_range>(2), B<hdparm>(8), "
"B<mount>(8), B<sync>(8)"
msgstr ""
"B<bdflush>(2), B<open>(2), B<sync>(2), B<sync_file_range>(2), B<hdparm>(8), "
"B<mount>(8), B<sync>(8)"

#. type: TH
#: man-pages/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr "FANOTIFY_INIT"

#. type: TH
#: man-pages/man2/fanotify_init.2:24
#, no-wrap
msgid "2014-05-18"
msgstr "2014-05-18"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr "fanotify_init - создаёт и инициализирует группу fanotify"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr "B<#include E<lt>fcntl.hE<gt>>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr "B<#include E<lt>sys/fanotify.hE<gt>>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int >I<event_f_flags>"
"B<);>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""
"Вызов B<fanotify_init>() инициализирует новую группу fanotify и возвращает "
"файловый дескриптор очереди событий, связанной с группой."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, and mounts for which fanotify events shall be created.  "
"These events are received by reading from the file descriptor.  Some events "
"are only informative, indicating that a file has been accessed.  Other "
"events can be used to determine whether another application is permitted to "
"access a file or directory.  Permission to access filesystem objects is "
"granted by writing to the file descriptor."
msgstr ""
"В файловом дескрипторе, используемом в B<fanotify_mark>(2), задаются файлы, "
"каталоги и точки монтирования, для которых должны создаваться события "
"fanotify. Эти события можно получить с помощью чтения файлового дескриптора. "
"Одни события носят уведомительный характер, показывая что к файлу был получен "
"доступ. Другие события можно использовать для разрешения приложению доступа к "
"файлу или каталогу. Доступ к объектам файловой системы разрешается "
"посредством записи в файловый дескриптор."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""
"Несколько программ могут использовать интерфейс fanotify к одним и тем же "
"файлам одновременно."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""
"В текущей реализации количество групп fanotify ограничено 128 на "
"пользователя. Это значение нельзя изменить."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""
"Для вызова B<fanotify_init>() требуется мандат B<CAP_SYS_ADMIN>. Это "
"требование может быть облегчено в будущих версиях программного интерфейса. "
"Поэтому ниже показаны определённые дополнительные проверки возможностей, "
"которые были реализованы."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""
"Аргумент I<flags> содержит многобитовое поле, определяющее класс уведомления, "
"запрашиваемый приложением, а также однобитовые поля, задающие поведение "
"файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is"
" used to establish the sequence in which the listeners receive the events."
msgstr ""
"Если на события доступа зарегистрировалось несколько слушателей, то класс "
"уведомления используется для установления порядка слушателей при получении "
"событий."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:80
msgid ""
"Only one of the following notification classes may be specified in I<flags>:"
msgstr ""
"В I<flags> может быть указан только один из следующих классов уведомления:"

#. type: TP
#: man-pages/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr "B<FAN_CLASS_PRE_CONTENT>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""
"Это значение позволяет принимать уведомляющие события об обращении к файлу, и "
"события доступа, запрашивающие доступ к файлу. Он предназначен  для "
"слушателей событий, которым требуется доступ к файлам до того, как в них "
"будут содержаться окончательные данные. Этот класс уведомления может быть "
"использован, например, в программах управления иерархического хранения."

#. type: TP
#: man-pages/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr "B<FAN_CLASS_CONTENT>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""
"Это значение позволяет принимать уведомляющие события об обращении к файлу, и "
"события доступа, запрашивающие доступ к файлу. Он предназначен  для "
"слушателей событий, которым требуется доступ к файлам после того, как они "
"содержат окончательные данные. Этот класс уведомления может быть использован, "
"например, в программах обнаружения вредоносного кода."

#. type: TP
#: man-pages/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr "B<FAN_CLASS_NOTIF>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:103
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""
"Значение по умолчанию. Его не нужно указывать. Это значение позволяет "
"принимать только события о доступе к файлу. Право на доступ к файлу задать "
"невозможно."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:111
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""
"Слушатели с различными классами уведомлений будут принимать события в таком "
"порядке: B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>. "
"Порядок уведомления слушателей в этом классе уведомления не определён."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:114
msgid "The following bits can additionally be set in I<flags>:"
msgstr "Дополнительно в I<flags> могут быть установлены следующие биты:"

#. type: TP
#: man-pages/man2/fanotify_init.2:114
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr "B<FAN_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:123
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""
"Устанавливать флаг close-on-exec (B<FD_CLOEXEC>) для нового файлового "
"дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2)."

#. type: TP
#: man-pages/man2/fanotify_init.2:123
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr "B<FAN_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:133
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  will fail with the error B<EAGAIN>."
msgstr ""
"Включить неблокирующий флаг (B<O_NONBLOCK>) для файлового дескриптора. Чтение "
"из такого файлового дескриптора не вызовет блокирования. Если данные "
"отсутствуют, то B<read>(2) завершится с ошибкой B<EAGAIN>."

#. type: TP
#: man-pages/man2/fanotify_init.2:133
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr "B<FAN_UNLIMITED_QUEUE>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:139
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"Снять ограничение в 16384 события в очереди событий. Для использования этого "
"флага требуется мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/fanotify_init.2:139
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr "B<FAN_UNLIMITED_MARKS>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:145
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""
"Снять ограничение в 8192 метки. Для использования этого флага требуется "
"мандат B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:158
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set"
" on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""
"В аргументе I<event_f_flags> задаются флаги состояния файла, которые будут "
"установлены на открытые файловые описатели, создаваемые для событий fanotify. "
"Подробней об этих флагах смотрите описание значений I<flags> в B<open>(2). "
"Аргумент I<event_f_flags> включает мультибитовое поле для режима доступа. Это "
"поел может иметь следующие значения:"

#. type: TP
#: man-pages/man2/fanotify_init.2:158
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:161
msgid "This value allows only read access."
msgstr "Это значение разрешает доступ только на чтение."

#. type: TP
#: man-pages/man2/fanotify_init.2:161
#, no-wrap
msgid "B<O_WRONLY>"
msgstr "B<O_WRONLY>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:164
msgid "This value allows only write access."
msgstr "Это значение разрешает доступ только на запись."

#. type: TP
#: man-pages/man2/fanotify_init.2:164
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:167
msgid "This value allows read and write access."
msgstr "Это значение разрешает доступ на чтение и запись."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:171
msgid ""
"Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""
"В I<event_f_flags> могут быть установлены дополнительные биты. Наиболее "
"полезные значения:"

#. type: TP
#: man-pages/man2/fanotify_init.2:171
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr "B<O_LARGEFILE>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:178
msgid ""
"Enable support for files exceeding 2 GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr ""
"Включить поддержку файлов более 2 ГБ. Если не удастся установить этот флаг, "
"то при попытке открыть большой файл, отслеживаемый группой fanotify на "
"32-битной системе, возвращается ошибка B<EOVERFLOW>."

#. type: TP
#: man-pages/man2/fanotify_init.2:178
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:186
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"Включить флаг close-on-exec для нового открытого файлового дескриптора. "
"Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для того, чтобы узнать как "
"это может пригодиться."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:199
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags>"
" yields the error B<EINVAL> (but see BUGS)."
msgstr ""
"Также доступны следующие флаги: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, B<"
"O_NONBLOCK> и B<O_SYNC>. Указание любых других флагов в I<event_f_flags>"
"приводит к ошибке B<EINVAL> (но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:206
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1"
" is returned, and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fanotify_init>() возвращает новый файловый "
"дескриптор. При ошибке возвращается -1, и I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:216
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> defines all allowable bits for I<flags>."
msgstr ""
"В I<flags> или I<event_f_flags> указано некорректное значение. Значение B<"
"FAN_ALL_INIT_FLAGS> определяет все допустимые биты в I<flags>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:219
msgid "The number of fanotify groups for this user exceeds 128."
msgstr "Количество групп fanotify для этого пользователя превышает 128."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:222
msgid "The allocation of memory for the notification group failed."
msgstr "Не удалось выделить память для группы уведомления."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:228
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""
"В этом ядре не реализован B<fanotify_init>(). Программный интерфейс fanotify "
"доступен только, если ядро было собрано с параметром B<CONFIG_FANOTIFY>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:233
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN>"
" capability."
msgstr ""
"Операция запрещена, так как вызывающий не имеет мандата B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:237
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and"
" enabled in version 2.6.37."
msgstr ""
"Вызов B<fanotify_init>() появился в версии 2.6.36 ядра Linux и был включён в "
"версии 2.6.37."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:242
msgid "As of Linux 3.15, the following bug exists:"
msgstr "В Linux 3.15 существуют следующие дефекты:"

#.  FIXME: Patch accepted to mm tree.
#. type: Plain text
#: man-pages/man2/fanotify_init.2:252
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from"
" the fanotify file descriptor."
msgstr ""
"Значение аргумента I<event_f_flags> не проверяется на корректность флагов. "
"Могут быть установлены флаги, предназначенные только для внутреннего "
"использования, такие как B<FMODE_EXEC>, и в результате будут установлены для "
"файловых дескрипторов при чтении из файлового дескриптора fanotify."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:254
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr "B<fanotify_mark>(2), B<fanotify>(7)"

#. type: TH
#: man-pages/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr "FALLOCATE"

#. type: Plain text
#: man-pages/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr "fallocate - управление пространством файла"

#. type: Plain text
#: man-pages/man2/fallocate.2:18
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\nB<"
"#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/fallocate.2:21
#, no-wrap
msgid ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t "
">I<len>B<);>\n"
msgstr ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<"
"len>B<);>\n"

#. type: Plain text
#: man-pages/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see"
" B<posix_fallocate>(3)."
msgstr ""
"Это непереносимый системный вызов, существующий только в Linux. В POSIX.1 "
"есть переносимый метод, обеспечивающий выделение пространства под файл "
"(смотрите B<posix_fallocate>(3))."

#. type: Plain text
#: man-pages/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""
"Вызов B<fallocate>() позволяет вызывающему напрямую управлять выделением "
"дискового пространства под файл, на который указывает I<fd>, для байтового "
"диапазона, начинающегося с I<offset> и имеющего длину I<len> байт."

#. type: Plain text
#: man-pages/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""
"В аргументе I<mode> задаётся операция, выполняемая над указанным диапазоном. "
"Детали о поддерживаемых операциях представлены в подразделах далее."

#. type: SS
#: man-pages/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr "Выделение дискового пространства"

#. type: Plain text
#: man-pages/man2/fallocate.2:65
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"the disk space within the range specified by I<offset> and I<len>.  The file"
" size (as reported by B<stat>(2))  will be changed if I<offset>+I<len> is "
"greater than the file size.  Any subregion within the range specified by "
"I<offset> and I<len> that did not contain data before the call will be "
"initialized to zero.  This default behavior closely resembles the behavior "
"of the B<posix_fallocate>(3)  library function, and is intended as a method "
"of optimally implementing that function."
msgstr ""
"По умолчанию (т. е. значение I<mode> равно нулю) B<fallocate>() выделяет "
"место на диске в диапазоне, задаваемом I<offset> и I<len>. Размер файла "
"(получаемый через B<stat>(2)) будет изменён, если I<offset>+I<len> больше чем "
"размер файла. Любая подобласть внутри диапазона, заданного I<offset> и I<len>"
", которая не содержала данных до вызова, будет заполнена нулями. Такое "
"поведение по умолчанию очень напоминает поведение библиотечной функции B<"
"posix_fallocate>(3), и было введено для оптимальной реализации этой функции."

#. type: Plain text
#: man-pages/man2/fallocate.2:71
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""
"После успешного выполнения вызова последующие операции записи в диапазон, "
"указанный I<offset> и I<len>, гарантированно не завершатся с ошибкой из-за "
"нехватки места на диске."

#. type: Plain text
#: man-pages/man2/fallocate.2:82
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if "
"I<offset>+I<len> is greater than the file size.  Preallocating zeroed blocks"
" beyond the end of the file in this manner is useful for optimizing append "
"workloads."
msgstr ""
"Если в I<mode> указан флаг B<FALLOC_FL_KEEP_SIZE>, то поведение по умолчанию "
"почти то же, но размер файла не будет изменён даже, если I<offset>+I<len> "
"больше чем размер файла. Предварительно выделенные блоки с нулями за концом "
"файла в этом случае полезны для оптимизации добавления."

#. type: Plain text
#: man-pages/man2/fallocate.2:86
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""
"Так как выделение выполняется кусками размером с блок, B<fallocate>() может "
"выделить больший диапазон дискового пространства, чем было указано."

#. type: SS
#: man-pages/man2/fallocate.2:86
#, no-wrap
msgid "Deallocating file space"
msgstr "Освобождение файлового пространства"

#. type: Plain text
#: man-pages/man2/fallocate.2:101
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified"
" range, partial filesystem blocks are zeroed, and whole filesystem blocks "
"are removed from the file.  After a successful call, subsequent reads from "
"this range will return zeroes."
msgstr ""
"Указание флага B<FALLOC_FL_PUNCH_HOLE> (доступен, начиная с Linux 2.6.38) в "
"I<mode> освобождает пространство (т.е., создаёт дыру) в диапазоне начиная с "
"I<offset> и до I<len> байт. Внутри заданного диапазона неполные блоки "
"файловой системы заполняются нулями, а полные блоки файловой системы "
"удаляются из файла. После успешного выполнения вызова, последующие операции "
"чтения из этого диапазона вернут нули."

#. type: Plain text
#: man-pages/man2/fallocate.2:112
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in"
" I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""
"Флаг B<FALLOC_FL_PUNCH_HOLE> должен быть логически добавлен к флагу B<"
"FALLOC_FL_KEEP_SIZE> в I<mode>; другими словами, даже когда пробивание "
"(punching) выходит за конец файла, размер файла (получаемый с помощью B<stat>"
"(2)) остаётся неизменным."

#. type: Plain text
#: man-pages/man2/fallocate.2:117
msgid ""
"Not all filesystems support B<FALLOC_FL_PUNCH_HOLE>; if a filesystem doesn't"
" support the operation, an error is returned.  The operation is supported on"
" at least the following filesystems:"
msgstr ""
"Не все файловые системы поддерживают B<FALLOC_FL_PUNCH_HOLE>; если файловая "
"система не поддерживает эту операцию, то возвращается ошибка. Операция "
"поддерживается, как минимум, следующими файловыми системами:"

#. type: Plain text
#: man-pages/man2/fallocate.2:119
msgid "XFS (since Linux 2.6.38)"
msgstr "XFS (начиная с Linux 2.6.38)"

#.  commit a4bb6b64e39abc0e41ca077725f2a72c868e7622
#. type: Plain text
#: man-pages/man2/fallocate.2:122
msgid "ext4 (since Linux 3.0)"
msgstr "ext4 (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/fallocate.2:124
msgid "Btrfs (since Linux 3.7)"
msgstr "Btrfs (начиная с Linux 3.7)"

#.  commit 83e4fa9c16e4af7122e31be3eca5d57881d236fe
#. type: Plain text
#: man-pages/man2/fallocate.2:127
msgid "tmpfs (since Linux 3.5)"
msgstr "tmpfs (начиная с Linux 3.5)"

#. type: SS
#: man-pages/man2/fallocate.2:127
#, no-wrap
msgid "Collapsing file space"
msgstr "Сворачивание (Collapsing) файлового пространства"

#.  commit 00f5e61998dd17f5375d9dfc01331f104b83f841
#. type: Plain text
#: man-pages/man2/fallocate.2:147
msgid ""
"Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux 3.15)"
" in I<mode> removes a byte range from a file, without leaving a hole.  The "
"byte range to be collapsed starts at I<offset> and continues for I<len> "
"bytes.  At the completion of the operation, the contents of the file "
"starting at the location I<offset+len> will be appended at the location "
"I<offset>, and the file will be I<len> bytes smaller."
msgstr ""
"Задание флага B<FALLOC_FL_COLLAPSE_RANGE> (доступен, начиная с Linux 3.15) в "
"I<mode> приводит к удалению байтового диапазона из файла без создания дыры. "
"Сворачиваемый диапазон байт начинается с I<offset> и длится I<len> байт. По "
"завершению операции, содержимое файла, начиная с I<offset+len>, будет "
"добавлено в расположение I<offset>, и файл будет на I<len> байт меньше."

#. type: Plain text
#: man-pages/man2/fallocate.2:161
msgid ""
"A filesystem may place limitations on the granularity of the operation, in "
"order to ensure efficient implementation.  Typically, I<offset> and I<len> "
"must be a multiple of the filesystem logical block size, which varies "
"according to the filesystem type and configuration.  If a filesystem has "
"such a requirement, B<fallocate>()  will fail with the error B<EINVAL> if "
"this requirement is violated."
msgstr ""
"У файловой системы могут быть ограничения на детализацию операции, для "
"большей эффективности реализации. Обычно, значения I<offset> и I<len> должны "
"быть кратны размеру логического блока файловой системы, различающемуся в "
"разных файловых системах и зависящему от настроек. Если файловая система "
"содержит такое требование и оно нарушено, то B<fallocate>() завершится с "
"ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/fallocate.2:170
msgid ""
"If the region specified by I<offset> plus I<len> reaches or passes the end "
"of file, an error is returned; instead, use B<ftruncate>(2)  to truncate a "
"file."
msgstr ""
"Если область, заданная I<offset> плюс I<len> достигает или выходит за конец "
"файла, то возвращается ошибка; вместо этого используйте B<ftruncate>(2) для "
"обрезания файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:175
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""
"Вместе с B<FALLOC_FL_COLLAPSE_RANGE> другие флаги в I<mode> указывать нельзя."

#.  commit 9eb79482a97152930b113b51dff530aba9e28c8e
#.  commit e1d8fb88a64c1f8094b9f6c3b6d2d9e6719c970d
#. type: Plain text
#: man-pages/man2/fallocate.2:183
msgid ""
"As at Linux 3.15, B<FALLOC_FL_COLLAPSE_RANGE> is supported by ext4 (only for"
" extent-based files)  and XFS."
msgstr ""
"В Linux 3.15 флаг B<FALLOC_FL_COLLAPSE_RANGE> поддерживается в ext4 (только "
"для файлов на основе extent) и XFS."

#. type: SS
#: man-pages/man2/fallocate.2:183
#, no-wrap
msgid "Zeroing file space"
msgstr "Зануление файлового пространства"

#.  commit 409332b65d3ed8cfa7a8030f1e9d52f372219642
#. type: Plain text
#: man-pages/man2/fallocate.2:199
msgid ""
"Specifying the B<FALLOC_FL_ZERO_RANGE> flag (available since Linux 3.14)  in"
" I<mode> zeroes space in the byte range starting at I<offset> and continuing"
" for I<len> bytes.  Within the specified range, blocks are preallocated for "
"the regions that span the holes in the file.  After a successful call, "
"subsequent reads from this range will return zeroes."
msgstr ""
"Задание флага B<FALLOC_FL_ZERO_RANGE> (доступен, начиная с Linux 3.14) в I<"
"mode> приводит к обнулению байтового диапазона, начиная с I<offset> и "
"размером I<len> байт. Внутри указанного диапазона блоки выделяются заранее "
"для областей, которые попадают в дыры в файле. После успешного выполнения "
"вызова последующие операции чтения из этого диапазона будут возвращать нули."

#. type: Plain text
#: man-pages/man2/fallocate.2:205
msgid ""
"Zeroing is done within the filesystem preferably by converting the range "
"into unwritten extents.  This approach means that the specified range will "
"not be physically zeroed out on the device (except for partial blocks at the"
" either end of the range), and I/O is (otherwise) required only to update "
"metadata."
msgstr ""
"Зануление, желательно, выполнять внутри файловой системы, преобразуя диапазон "
"в незаписываемые extents. Этот подход означает, что указанный диапазон на "
"устройстве в действительности не будет содержать нули на физическом уровне "
"(за исключением неполных блоков в одном из концов диапазона), и ввод-вывод "
"требуется только для обновления метаданных."

#. type: Plain text
#: man-pages/man2/fallocate.2:217
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is additionally specified in I<mode>, the"
" behavior of the call is similar, but the file size will not be changed even"
" if I<offset>+I<len> is greater than the file size.  This behavior is the "
"same as when preallocating space with B<FALLOC_FL_KEEP_SIZE> specified."
msgstr ""
"Если в I<mode> также указан флаг B<FALLOC_FL_KEEP_SIZE>, то поведение вызова "
"похоже, но размер файла не будет изменён даже, если I<offset>+I<len> больше "
"размера файла. Такое поведение совпадает с предварительным выделением "
"пространства с помощью указания флага B<FALLOC_FL_KEEP_SIZE>."

#. type: Plain text
#: man-pages/man2/fallocate.2:222
msgid ""
"Not all filesystems support B<FALLOC_FL_ZERO_RANGE>; if a filesystem doesn't"
" support the operation, an error is returned.  The operation is supported on"
" at least the following filesystems:"
msgstr ""
"Не все файловые системы поддерживают B<FALLOC_FL_ZERO_RANGE>; если файловая "
"система не поддерживает эту операцию, то возвращается ошибка. Операция "
"поддерживается, как минимум, следующими файловыми системами:"

#.  commit 376ba313147b4172f3e8cf620b9fb591f3e8cdfa
#. type: Plain text
#: man-pages/man2/fallocate.2:225
msgid "XFS (since Linux 3.14)"
msgstr "XFS (начиная с Linux 3.14)"

#.  commit b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
#. type: Plain text
#: man-pages/man2/fallocate.2:228
msgid "ext4, for extent-based files (since Linux 3.14)"
msgstr "ext4, для файлов на основе extent (начиная с Linux 3.14)"

#. type: Plain text
#: man-pages/man2/fallocate.2:235
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fallocate>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/fallocate.2:240
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""
"Значение I<fd> не является допустимым файловым дескриптором или он не открыт "
"на запись."

#. type: TP
#: man-pages/man2/fallocate.2:240
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man2/fallocate.2:244
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr "Сумма I<offset>+I<len> превышает максимальный размер файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:247
msgid "A signal was caught during execution."
msgstr "При выполнении поступил сигнал."

#.  FIXME (raise a kernel bug) Probably the len==0 case should be
#.  a no-op, rather than an error. That would be consistent with
#.  similar APIs for the len==0 case.
#.  See "Re: [PATCH] fallocate.2: add FALLOC_FL_PUNCH_HOLE flag definition"
#.  21 Sep 2012
#.  http://thread.gmane.org/gmane.linux.file-systems/48331/focus=1193526
#. type: Plain text
#: man-pages/man2/fallocate.2:259
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr "Значение I<offset> меньше 0, или I<len> меньше или равно 0."

#. type: Plain text
#: man-pages/man2/fallocate.2:269
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by I<offset> "
"plus I<len> reaches or passes the end of the file."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE>, но диапазон, указанный в "
"I<offset> плюс I<len>, достиг или перешагнул за конец файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:279
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE>, but either I<offset> or I<len> is "
"not a multiple of the filesystem block size."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE>, но значение или I<offset>"
", или I<len> не кратно размеру блока файловой системы."

#. type: Plain text
#: man-pages/man2/fallocate.2:287
msgid ""
"I<mode> contains both B<FALLOC_FL_COLLAPSE_RANGE> and other flags; no other "
"flags are permitted with B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""
"Значение I<mode> содержит B<FALLOC_FL_COLLAPSE_RANGE> и другие флаги; другие "
"флаги нельзя указывать вместе с B<FALLOC_FL_COLLAPSE_RANGE>."

#.  There was a inconsistency in 3.15-rc1, that should be resolved so that all
#.  filesystems use this error for this case. (Tytso says ex4 will change.)
#.  http://thread.gmane.org/gmane.comp.file-
#. systems.xfs.general/60485/focus=5521
#.  From: Michael Kerrisk (man-pages <mtk.manpages@...>
#.  Subject: Re: [PATCH v5 10/10] manpage: update FALLOC_FL_COLLAPSE_RANGE
#. flag in fallocate
#.  Newsgroups: gmane.linux.man, gmane.linux.file-systems
#.  Date: 2014-04-17 13:40:05 GMT
#. type: Plain text
#: man-pages/man2/fallocate.2:304
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_ZERO_RANGE>, but the "
"file referred to by I<fd> is not a regular file."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE> или B<FALLOC_FL_ZERO_RANGE>"
", но файл, на который ссылается I<fd>, не является обычным."

#. type: Plain text
#: man-pages/man2/fallocate.2:307
msgid "An I/O error occurred while reading from or writing to a filesystem."
msgstr ""
"При чтении или записи в файловую систему произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/fallocate.2:307
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man2/fallocate.2:314
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""
"Значение I<fd> не указывает на обычный файл или каталог (если I<fd> — канал "
"или FIFO, то возникнет другая ошибка)."

#. type: Plain text
#: man-pages/man2/fallocate.2:319
msgid ""
"There is not enough space left on the device containing the file referred to"
" by I<fd>."
msgstr ""
"Недостаточно дискового пространства на устройстве, на котором расположен "
"файл, указанный в I<fd>."

#. type: Plain text
#: man-pages/man2/fallocate.2:323
msgid "This kernel does not implement B<fallocate>()."
msgstr "В данном ядре вызов B<fallocate>() не реализован."

#. type: TP
#: man-pages/man2/fallocate.2:323
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/fallocate.2:332
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the filesystem containing"
" the file referred to by I<fd>."
msgstr ""
"Файловая система с файлом, на который указывает I<fd>, не поддерживает данную "
"операцию; или значение I<mode> не поддерживается файловой системой, в которой "
"находится файл, на который указывает I<fd>."

#. type: Plain text
#: man-pages/man2/fallocate.2:350
msgid ""
"The file referred to by I<fd> is marked immutable (see B<chattr>(1)).  Or: "
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> or B<FALLOC_FL_COLLAPSE_RANGE> and"
" the file referred to by I<fd> is marked append-only (see B<chattr>(1))."
msgstr ""
"Файл, на который ссылается I<fd>, помечен как неизменяемый (immutable) "
"(смотрите B<chattr>(1)). Или: в I<mode> указан флаг B<FALLOC_FL_PUNCH_HOLE> "
"или B<FALLOC_FL_COLLAPSE_RANGE> и файл, на который ссылается I<fd>, помечен "
"как только для добавления (смотрите B<chattr>(1))."

#. type: TP
#: man-pages/man2/fallocate.2:350
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: man-pages/man2/fallocate.2:354
msgid "I<fd> refers to a pipe or FIFO."
msgstr "Значение I<fd> указывает на канал или FIFO."

#. type: Plain text
#: man-pages/man2/fallocate.2:362
msgid ""
"I<mode> specifies B<FALLOC_FL_COLLAPSE_RANGE>, but the file referred to by "
"I<fd> is currently being executed."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE>, но файл, на который "
"ссылается I<fd>, в данный момент выполняется."

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: man-pages/man2/fallocate.2:370
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""
"Вызов B<fallocate>() доступен в Linux начиная с ядра 2.6.23. Поддержка в "
"glibc добавлена в версии 2.10. Флаги B<FALLOC_FL_*> определены в заголовочных "
"файлах glibc только начиная с версии 2.18."

#. type: Plain text
#: man-pages/man2/fallocate.2:373
msgid "B<fallocate>()  is Linux-specific."
msgstr "Вызов B<fallocate>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/fallocate.2:377
msgid ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"

#. type: TH
#: man-pages/man5/ftpusers.5:19
#, no-wrap
msgid "FTPUSERS"
msgstr "FTPUSERS"

#. type: TH
#: man-pages/man5/ftpusers.5:19
#, no-wrap
msgid "2000-08-27"
msgstr "2000-08-27"

#. type: Plain text
#: man-pages/man5/ftpusers.5:22
msgid "ftpusers - list of users that may not log in via the FTP daemon"
msgstr "ftpusers - список пользователей, не имеющих доступа к демону FTP"

#. type: Plain text
#: man-pages/man5/ftpusers.5:41
msgid ""
"The text file B<ftpusers> contains a list of users that may not log in using"
" the File Transfer Protocol (FTP) server daemon.  This file is used not "
"merely for system administration purposes but for improving security within "
"a TCP/IP networked environment.  It will typically contain a list of the "
"users that either have no business using ftp or have too many privileges to "
"be allowed to log in through the FTP server daemon.  Such users usually "
"include root, daemon, bin, uucp, and news.  If your FTP server daemon "
"doesn't use B<ftpusers>, then it is suggested that you read its "
"documentation to find out how to block access for certain users.  Washington"
" University FTP server Daemon (wuftpd) and Professional FTP Daemon (proftpd)"
" are known to make use of B<ftpusers>."
msgstr ""
"Текстовый файл B<ftpusers> содержит список пользователей, которые не могут "
"войти по протоколу передачи файлов (FTP). Этот файл используется не только в "
"целях администрирования системы, но и для улучшения безопасности в сетевой "
"среде TCP/IP. Обычно, он содержит список пользователей, которые не пользуются "
"ftp или имеют слишком много прав, позволяющих войти на FTP-сервер. Такими "
"пользователями, обычно, являются root, daemon, bin, uucp и news. Если ваш "
"FTP-сервер не использует B<ftpusers>, то рекомендуется прочитать его "
"документацию, чтобы найти способ блокирования определённых пользователей. "
"Сервер Washington University FTP Daemon (wuftpd) и Professional FTP Daemon "
"(proftpd) умеют обращаться с B<ftpusers>."

#. type: SS
#: man-pages/man5/ftpusers.5:41
#, no-wrap
msgid "Format"
msgstr "Формат"

#. type: Plain text
#: man-pages/man5/ftpusers.5:47
msgid ""
"The format of B<ftpusers> is very simple.  There is one account name (or "
"username) per line.  Lines starting with a # are ignored."
msgstr ""
"Формат B<ftpusers> очень прост. Он содержит по одному имени учётной записи "
"(или имени пользователя) в каждой строке. Строки, начинающиеся с # "
"игнорируются."

#. type: Plain text
#: man-pages/man5/ftpusers.5:49
msgid "I</etc/ftpusers>"
msgstr "I</etc/ftpusers>"

#. type: Plain text
#: man-pages/man5/ftpusers.5:52
msgid "B<passwd>(5), B<proftpd>(8), B<wuftpd>(8)"
msgstr "B<passwd>(5), B<proftpd>(8), B<wuftpd>(8)"

#. type: TH
#: man-pages/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr "FILESYSTEMS"

#. type: TH
#: man-pages/man5/filesystems.5:26
#, no-wrap
msgid "2014-01-15"
msgstr "2014-01-15"

#. type: Plain text
#: man-pages/man5/filesystems.5:32
msgid ""
"filesystems - Linux filesystem types: minix, ext, ext2, ext3, ext4, "
"Reiserfs, XFS, JFS, xia, msdos, umsdos, vfat, ntfs, proc, nfs, iso9660, "
"hpfs, sysv, smb, ncpfs"
msgstr ""
"filesystems - типы файловых систем Linux: minix, ext, ext2, ext3, ext4, "
"Reiserfs, XFS, JFS, xia, msdos, umsdos, vfat, ntfs, proc, nfs, iso9660, hpfs, "
"sysv, smb, ncpfs"

#. type: Plain text
#: man-pages/man5/filesystems.5:45
msgid ""
"When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which filesystems your kernel "
"currently supports; see B<proc>(5)  for more details.  If you need a "
"currently unsupported filesystem, insert the corresponding module or "
"recompile the kernel."
msgstr ""
"Если, как обычно, файловая система B<proc> смонтирована в I</proc>, то в "
"файле I</proc/filesystems> можно найти список типов файловых систем, которые "
"поддерживаются ядром; подробности смотрите в B<proc>(5). Если вам требуется "
"не поддерживаемая файловая система, то загрузите соответствующий модуль или "
"пересоберите ядро."

#. type: Plain text
#: man-pages/man5/filesystems.5:50
msgid "In order to use a filesystem, you have to I<mount> it; see B<mount>(8)."
msgstr ""
"Чтобы использовать файловую систему, её нужно I<смонтировать>; смотрите B<"
"mount>(8)."

#. type: Plain text
#: man-pages/man5/filesystems.5:52
msgid "Below a short description of a few of the available filesystems."
msgstr ""
"Далее приводится краткое описание некоторых доступных типов файловых систем."

#. type: TP
#: man-pages/man5/filesystems.5:52
#, no-wrap
msgid "B<minix>"
msgstr "B<minix>"

#. type: Plain text
#: man-pages/man5/filesystems.5:59
msgid ""
"is the filesystem used in the Minix operating system, the first to run under"
" Linux.  It has a number of shortcomings, including a 64MB partition size "
"limit, short filenames, and a single timestamp.  It remains useful for "
"floppies and RAM disks."
msgstr ""
"Файловая система, использующаяся в операционной системе Minix, первая, на "
"которой заработал Linux. Имеет несколько недостатков: максимальный размер "
"раздела 64МБ, короткие имена файлов и одна временная метка. Осталась полезной "
"для дискет и RAM-дисков."

#. type: TP
#: man-pages/man5/filesystems.5:59
#, no-wrap
msgid "B<ext>"
msgstr "B<ext>"

#. type: Plain text
#: man-pages/man5/filesystems.5:68
msgid ""
"is an elaborate extension of the B<minix> filesystem.  It has been "
"completely superseded by the second version of the extended filesystem "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""
"Доработанное расширение файловой системы B<minix>. Полностью вытеснена второй "
"версией расширенной файловой системой (B<ext2>) и была удалена из ядра (в "
"2.1.21)."

#. type: TP
#: man-pages/man5/filesystems.5:68
#, no-wrap
msgid "B<ext2>"
msgstr "B<ext2>"

#. type: Plain text
#: man-pages/man5/filesystems.5:78
msgid ""
"is the high performance disk filesystem used by Linux for fixed disks as "
"well as removable media.  The second extended filesystem was designed as an "
"extension of the extended filesystem (B<ext>).  B<ext2> offers the best "
"performance (in terms of speed and CPU usage) of the filesystems supported "
"under Linux."
msgstr ""
"Высокопроизводительная дисковая файловая система Linux для жёстких дисков, а "
"также сменных носителей. Вторая версия расширенной файловой системы "
"разрабатывалась как расширение расширенной файловой системы (B<ext>). У B<"
"ext2> лучшая производительность (по скорости и использованию ЦП) среди "
"файловых систем, поддерживаемых Linux."

#. type: TP
#: man-pages/man5/filesystems.5:78
#, no-wrap
msgid "B<ext3>"
msgstr "B<ext3>"

#. type: Plain text
#: man-pages/man5/filesystems.5:83
msgid ""
"is a journaling version of the ext2 filesystem.  It is easy to switch back "
"and forth between ext2 and ext3."
msgstr ""
"Журналируемая версия файловой системы ext2. Очень легко переключиться с ext3 "
"обратно на работу с ext2."

#. type: TP
#: man-pages/man5/filesystems.5:83
#, no-wrap
msgid "B<ext4>"
msgstr "B<ext4>"

#. type: Plain text
#: man-pages/man5/filesystems.5:88
msgid ""
"is a set of upgrades to ext3 including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits."
msgstr ""
"Обновлённая версия ext3, включающая существенное увеличение "
"производительности и надёжности, размеров границ томов, файлов и каталогов."

#. type: TP
#: man-pages/man5/filesystems.5:88
#, no-wrap
msgid "B<Reiserfs>"
msgstr "B<Reiserfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:92
msgid ""
"is a journaling filesystem, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""
"Журналируемая файловая система, разработанная Гансом Рейзером (Hans Reiser), "
"была добавлена в Linux начиная с ядра версии 2.4.1."

#. type: TP
#: man-pages/man5/filesystems.5:92
#, no-wrap
msgid "B<XFS>"
msgstr "B<XFS>"

#. type: Plain text
#: man-pages/man5/filesystems.5:96
msgid ""
"is a journaling filesystem, developed by SGI, that was integrated into Linux"
" in kernel 2.4.20."
msgstr ""
"Журналируемая файловая система, разработанная SGI, была добавлена в Linux "
"начиная с ядра версии 2.4.20."

#. type: TP
#: man-pages/man5/filesystems.5:96
#, no-wrap
msgid "B<JFS>"
msgstr "B<JFS>"

#. type: Plain text
#: man-pages/man5/filesystems.5:100
msgid ""
"is a journaling filesystem, developed by IBM, that was integrated into Linux"
" in kernel 2.4.24."
msgstr ""
"Журналируемая файловая система, разработанная IBM, была добавлена в Linux "
"начиная с ядра версии 2.4.24."

#. type: TP
#: man-pages/man5/filesystems.5:100
#, no-wrap
msgid "B<xiafs>"
msgstr "B<xiafs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:110
msgid ""
"was designed and implemented to be a stable, safe filesystem by extending "
"the Minix filesystem code.  It provides the basic most requested features "
"without undue complexity.  The B<xia> filesystem is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr ""
"Разработана и реализована как стабильная надёжная файловая система "
"посредством расширения кода файловой системы Minix. Предоставляет основные "
"часто запрашиваемые возможности без неоправданной сложности. Файловая система "
"B<xia> больше активно не разрабатывается или сопровождается. Была удалена из "
"ядра 2.1.21."

#. type: TP
#: man-pages/man5/filesystems.5:110
#, no-wrap
msgid "B<msdos>"
msgstr "B<msdos>"

#. type: Plain text
#: man-pages/man5/filesystems.5:116
msgid ""
"is the filesystem used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period"
" and 3 character extension."
msgstr ""
"Файловая система, используемая в DOS, Windows и на некоторых компьютерах с "
"OS/2. Имена файлов в B<msdos> не могут быть более 8 символов с необязательным "
"расширением из 3 символов, отделённого точкой."

#. type: TP
#: man-pages/man5/filesystems.5:116
#, no-wrap
msgid "B<umsdos>"
msgstr "B<umsdos>"

#. type: Plain text
#: man-pages/man5/filesystems.5:123
msgid ""
"is an extended DOS filesystem used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.)  under the DOS filesystem, without sacrificing compatibility "
"with DOS."
msgstr ""
"Расширенная файловая система DOS, используемая в Linux. Была добавлена "
"поддержка длинных имён файлов, UID/GID, права доступа POSIX и специальные "
"файлы (устройства, именованные каналы и т.д.) без ухудшения совместимости с "
"DOS."

#. type: TP
#: man-pages/man5/filesystems.5:123
#, no-wrap
msgid "B<vfat>"
msgstr "B<vfat>"

#. type: Plain text
#: man-pages/man5/filesystems.5:127
msgid ""
"is an extended DOS filesystem used by Microsoft Windows95 and Windows NT.  "
"VFAT adds the capability to use long filenames under the MSDOS filesystem."
msgstr ""
"Расширенная файловая система DOS, используемая в Microsoft Windows95 и "
"Windows NT. В VFAT добавлена поддержка длинных имён файлов в файловую систему "
"MSDOS."

#. type: TP
#: man-pages/man5/filesystems.5:127
#, no-wrap
msgid "B<ntfs>"
msgstr "B<ntfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:132
msgid ""
"replaces Microsoft Window's FAT filesystems (VFAT, FAT32).  It has "
"reliability, performance, and space-utilization enhancements plus features "
"like ACLs, journaling, encryption, and so on."
msgstr ""
"Замена для файловых систем Microsoft Window FAT (VFAT, FAT32). Улучшена "
"надёжность, производительность и использование пространства и добавлены такие "
"возможности как списки контроля, журналирование, шифрование и т.д."

#. type: TP
#: man-pages/man5/filesystems.5:132
#, no-wrap
msgid "B<proc>"
msgstr "B<proc>"

#. type: Plain text
#: man-pages/man5/filesystems.5:140
msgid ""
"is a pseudo filesystem which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""
"Ненастоящая файловая система, используется как интерфейс к структурам данных "
"ядра вместо прямого чтения из I</dev/kmem>. В частности, её файлы не занимают "
"пространство на диске. Смотрите B<proc>(5)."

#. type: TP
#: man-pages/man5/filesystems.5:140
#, no-wrap
msgid "B<iso9660>"
msgstr "B<iso9660>"

#. type: Plain text
#: man-pages/man5/filesystems.5:143
msgid "is a CD-ROM filesystem type conforming to the ISO 9660 standard."
msgstr "Файловая система для CD-ROM, соответствующая стандарту ISO 9660."

#. type: TP
#: man-pages/man5/filesystems.5:144
#, no-wrap
msgid "B<High Sierra>"
msgstr "B<High Sierra>"

#. type: Plain text
#: man-pages/man5/filesystems.5:151
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for CD-"
"ROM filesystems.  It is automatically recognized within the B<iso9660> "
"filesystem support under Linux."
msgstr ""
"В Linux есть поддержка стандарта High Sierra, предшественника стандарта ISO "
"9660 для файловых систем CD-ROM. High Sierra автоматически распознается при "
"включении в Linux поддержки файловой системы B<iso9660>."

#. type: TP
#: man-pages/man5/filesystems.5:151
#, no-wrap
msgid "B<Rock Ridge>"
msgstr "B<Rock Ridge>"

#. type: Plain text
#: man-pages/man5/filesystems.5:162
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the"
" Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> filesystem to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> filesystem support under "
"Linux."
msgstr ""
"В Linux также есть поддержка записей System Use Sharing Protocol, которые "
"определены в протоколе обмена Rock Ridge. Они используются для подробного "
"описания файлов в файловой системе B<iso9660> для машин UNIX и предоставляют "
"информацию о длинных именах файлов, UID/GID, правах доступа к файлам по "
"стандарту POSIX и файлах устройств. Rock Ridge автоматически распознаётся при "
"включении в Linux поддержки файловой системы B<iso9660>."

#. type: TP
#: man-pages/man5/filesystems.5:163
#, no-wrap
msgid "B<hpfs>"
msgstr "B<hpfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:168
msgid ""
"is the High Performance Filesystem, used in OS/2.  This filesystem is read-"
"only under Linux due to the lack of available documentation."
msgstr ""
"Высокопроизводительная файловая система (High Performance Filesystem), "
"используемая в OS/2. Данная файловая система доступна под Linux только для "
"чтения из-за отсутствия документации."

#. type: TP
#: man-pages/man5/filesystems.5:168
#, no-wrap
msgid "B<sysv>"
msgstr "B<sysv>"

#. type: Plain text
#: man-pages/man5/filesystems.5:172
msgid ""
"is an implementation of the SystemV/Coherent filesystem for Linux.  It "
"implements all of Xenix FS, SystemV/386 FS, and Coherent FS."
msgstr ""
"Реализация файловой системы SystemV/Coherent для Linux. Поддерживает файловые "
"системы из Xenix, SystemV/386 и Coherent."

#. type: TP
#: man-pages/man5/filesystems.5:172
#, no-wrap
msgid "B<nfs>"
msgstr "B<nfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:175
msgid ""
"is the network filesystem used to access disks located on remote computers."
msgstr ""
"Сетевая файловая система, используемая для доступа к дискам, расположенным на "
"других компьютерах в сети."

#. type: TP
#: man-pages/man5/filesystems.5:175
#, no-wrap
msgid "B<smb>"
msgstr "B<smb>"

#. type: Plain text
#: man-pages/man5/filesystems.5:179
msgid ""
"is a network filesystem that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager."
msgstr ""
"Сетевая файловая система, которая поддерживает протокол SMB, используемый в "
"Windows for Workgroups, Windows NT и Lan Manager."

#. type: Plain text
#: man-pages/man5/filesystems.5:186
msgid ""
"To use B<smb> fs, you need a special mount program, which can be found in "
"the ksmbfs package, found at E<.UR "
"ftp://sunsite.unc.edu\\:/pub\\:/Linux\\:/system\\:/Filesystems\\:/smbfs> "
"E<.UE .>"
msgstr ""
"Для использования файловой системы B<smb> необходима специальная программа "
"mount, которую можно найти в пакете ksmbfs по адресу E<.UR "
"ftp://sunsite.unc.edu\\:/pub\\:/Linux\\:/system\\:/Filesystems\\:/smbfs> E<"
".UE .>"

#. type: TP
#: man-pages/man5/filesystems.5:186
#, no-wrap
msgid "B<ncpfs>"
msgstr "B<ncpfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:190
msgid ""
"is a network filesystem that supports the NCP protocol, used by Novell "
"NetWare."
msgstr ""
"Сетевая файловая система, которая поддерживает протокол NCP, используемый в "
"Novell NetWare."

#. type: Plain text
#: man-pages/man5/filesystems.5:196
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"
msgstr ""
"Для использования B<ncpfs> необходимы специальные программы, которые можно "
"найти по адресу E<.UR ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"

#. type: Plain text
#: man-pages/man5/filesystems.5:200
msgid "B<proc>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"
msgstr "B<proc>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"

#. type: TH
#: man-pages/man3/finite.3:25
#, no-wrap
msgid "FINITE"
msgstr "FINITE"

#. type: TH
#: man-pages/man3/finite.3:25
#, no-wrap
msgid "2013-07-22"
msgstr "2013-07-22"

#. type: Plain text
#: man-pages/man3/finite.3:29
msgid ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - BSD"
" floating-point classification functions"
msgstr ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - "
"функции BSD для классификации чисел с плавающей запятой"

#. type: Plain text
#: man-pages/man3/finite.3:32
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/finite.3:34
#, no-wrap
msgid "B<int finite(double >I<x>B<);>\n"
msgstr "B<int finite(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:36
#, no-wrap
msgid "B<int finitef(float >I<x>B<);>\n"
msgstr "B<int finitef(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:38
#, no-wrap
msgid "B<int finitel(long double >I<x>B<);>\n"
msgstr "B<int finitel(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:40
#, no-wrap
msgid "B<int isinf(double >I<x>B<);>\n"
msgstr "B<int isinf(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:42
#, no-wrap
msgid "B<int isinff(float >I<x>B<);>\n"
msgstr "B<int isinff(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:44
#, no-wrap
msgid "B<int isinfl(long double >I<x>B<);>\n"
msgstr "B<int isinfl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:46
#, no-wrap
msgid "B<int isnan(double >I<x>B<);>\n"
msgstr "B<int isnan(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:48
#, no-wrap
msgid "B<int isnanf(float >I<x>B<);>\n"
msgstr "B<int isnanf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:50
#, no-wrap
msgid "B<int isnanl(long double >I<x>B<);>\n"
msgstr "B<int isnanl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:61
msgid "B<finite>(), B<finitef>(), B<finitel>():"
msgstr "B<finite>(), B<finitef>(), B<finitel>():"

#. type: Plain text
#: man-pages/man3/finite.3:63 man-pages/man3/finite.3:76
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/finite.3:65
msgid "B<isinf>():"
msgstr "B<isinf>():"

#. type: Plain text
#: man-pages/man3/finite.3:67
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE;"

#. type: Plain text
#: man-pages/man3/finite.3:70 man-pages/man3/finite.3:83
msgid "or I<cc\\ -std=c99>"
msgstr "или I<cc\\ -std=c99>"

#. type: Plain text
#: man-pages/man3/finite.3:74
msgid "B<isinff>(), B<isinfl>():"
msgstr "B<isinff>(), B<isinfl>():"

#. type: Plain text
#: man-pages/man3/finite.3:78
msgid "B<isnan>():"
msgstr "B<isnan>():"

#. type: Plain text
#: man-pages/man3/finite.3:80
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE;"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE;"

#. type: Plain text
#: man-pages/man3/finite.3:86
msgid "B<isnanf>(), B<isnanl>():"
msgstr "B<isnanf>(), B<isnanl>():"

#. type: Plain text
#: man-pages/man3/finite.3:88
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/finite.3:100
msgid ""
"The B<finite>(), B<finitef>(), and B<finitel>()  functions return a nonzero "
"value if I<x> is neither infinite nor a \"not-a-number\" (NaN) value, and 0 "
"otherwise."
msgstr ""
"Функции B<finite>(), B<finitef>() и B<finitel>() возвращают ненулевое "
"значение, если I<x> не равно бесконечности или «не числу» (NaN), в противном "
"случае 0."

#. type: Plain text
#: man-pages/man3/finite.3:110
msgid ""
"The B<isnan>(), B<isnanf>(), and B<isnanl>()  functions return a nonzero "
"value if I<x> is a NaN value, and 0 otherwise."
msgstr ""
"Функции B<isnan>(), B<isnanf>() и B<isnanl>() возвращают ненулевое значение, "
"если I<x> равно NaN, в противном случае 0."

#. type: Plain text
#: man-pages/man3/finite.3:121
msgid ""
"The B<isinf>(), B<isinff>(), and B<isinfl>()  functions return 1 if I<x> is "
"positive infinity, -1 if I<x> is negative infinity, and 0 otherwise."
msgstr ""
"Функции B<isinf>(), B<isinff>() и B<isinfl>() возвращают 1, если I<x> равно "
"плюс бесконечности, -1, если I<x> равно минус бесконечности, в остальных "
"случаях 0."

#. type: SH
#: man-pages/man3/finite.3:121
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/finite.3:122
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/finite.3:135
msgid ""
"The B<finite>(), B<finitef>(), B<finitel>(), B<isinf>(), B<isinff>(), "
"B<isinfl>(), B<isnan>(), B<isnanf>(), and B<isnanl>()  functions are thread-"
"safe."
msgstr ""
"Функции B<finite>(), B<finitef>(), B<finitel>(), B<isinf>(), B<isinff>(), B<"
"isinfl>(), B<isnan>(), B<isnanf>() и B<isnanl>() можно использовать в "
"нескольких нитях одновременно."

#.  finite* not on HP-UX; they exist on Tru64.
#.  .SH HISTORY
#.  The
#.  .BR finite ()
#.  function occurs in 4.3BSD.
#.  see IEEE.3 in the 4.3BSD manual
#. type: Plain text
#: man-pages/man3/finite.3:155
msgid ""
"Note that these functions are obsolete.  C99 defines macros B<isfinite>(), "
"B<isinf>(), and B<isnan>()  (for all types) replacing them.  Further note "
"that the C99 B<isinf>()  has weaker guarantees on the return value.  See "
"B<fpclassify>(3)."
msgstr ""
"Заметим, что эти функции устарели. В C99 их заменили макросы B<isfinite>(), "
"B<isinf>() и B<isnan>() (для всех типов). Также заметим, что для B<isinf>() "
"C99 не гарантируется возвращаемого значения. Смотрите B<fpclassify>(3)."

#. type: Plain text
#: man-pages/man3/finite.3:156
msgid "B<fpclassify>(3)"
msgstr "B<fpclassify>(3)"

#. type: TH
#: man-pages/man3/fdim.3:9
#, no-wrap
msgid "FDIM"
msgstr "FDIM"

#. type: TH
#: man-pages/man3/fdim.3:9
#, no-wrap
msgid "2013-07-15"
msgstr "2013-07-15"

#. type: Plain text
#: man-pages/man3/fdim.3:12
msgid "fdim, fdimf, fdiml - positive difference"
msgstr "fdim, fdimf, fdiml - вычисление положительной разницы"

#. type: Plain text
#: man-pages/man3/fdim.3:14
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: man-pages/man3/fdim.3:16
msgid "B<double fdim(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fdim(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fdim.3:18
msgid "B<float fdimf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fdimf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fdim.3:20
msgid "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fdim.3:22
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/fdim.3:31
msgid "B<fdimf>(), B<fdiml>():"
msgstr "B<fdimf>(), B<fdiml>():"

#. type: Plain text
#: man-pages/man3/fdim.3:34
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\"
" 200112L;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"

#. type: Plain text
#: man-pages/man3/fdim.3:42
msgid ""
"These functions return the positive difference, max(I<x>-I<y>,0), between "
"their arguments."
msgstr ""
"Эти функции возвращают положительную разницу, max(I<x>-I<y>,0), между их "
"аргументами."

#. type: Plain text
#: man-pages/man3/fdim.3:44
msgid "On success, these functions return the positive difference."
msgstr ""
"При успешном выполнении данные функции возвращают положительную разницу."

#. type: Plain text
#: man-pages/man3/fdim.3:50
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr "Если I<x> или I<y> равно NaN, то будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fdim.3:59
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, соответственно."

#. type: Plain text
#: man-pages/man3/fdim.3:64
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать при "
"вызове этих функций."

#. type: Plain text
#: man-pages/man3/fdim.3:66
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/fdim.3:66
#, no-wrap
msgid "Range error: result overflow"
msgstr "Ошибка диапазона: результат превысил разрядность"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/fdim.3:74
msgid "An overflow floating-point exception (B<FE_OVERFLOW>)  is raised."
msgstr "Вызывается исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6796
#. type: Plain text
#: man-pages/man3/fdim.3:79
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: Plain text
#: man-pages/man3/fdim.3:81
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/fdim.3:89
msgid "The B<fdim>(), B<fdimf>(), and B<fdiml>()  functions are thread-safe."
msgstr ""
"Функции B<fdim>(), B<fdimf>() и B<fdiml>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/fdim.3:91
msgid "C99, POSIX.1-2001."
msgstr "C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fdim.3:92
msgid "B<fmax>(3)"
msgstr "B<fmax>(3)"

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "FNMATCH"
msgstr "FNMATCH"

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "2000-10-15"
msgstr "2000-10-15"

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/fnmatch.3:31
msgid "fnmatch - match filename or pathname"
msgstr "fnmatch - сравнивает имя файла или путь"

#. type: Plain text
#: man-pages/man3/fnmatch.3:34
#, no-wrap
msgid "B<#include E<lt>fnmatch.hE<gt>>\n"
msgstr "B<#include E<lt>fnmatch.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fnmatch.3:36
#, no-wrap
msgid ""
"B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int "
">I<flags>B<);>\n"
msgstr ""
"B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int >I<"
"flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/fnmatch.3:45
msgid ""
"The B<fnmatch>()  function checks whether the I<string> argument matches the"
" I<pattern> argument, which is a shell wildcard pattern."
msgstr ""
"Функция B<fnmatch>() проверяет, совпадает ли параметр I<string> с параметром "
"I<pattern>, который является шаблоном."

#. type: Plain text
#: man-pages/man3/fnmatch.3:50
msgid ""
"The I<flags> argument modifies the behavior; it is the bitwise OR of zero or"
" more of the following flags:"
msgstr ""
"Аргумент I<flags> изменяет поведение; он является битовой маской и может "
"содержать следующие флаги:"

#. type: TP
#: man-pages/man3/fnmatch.3:50
#, no-wrap
msgid "B<FNM_NOESCAPE>"
msgstr "B<FNM_NOESCAPE>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:54
msgid ""
"If this flag is set, treat backslash as an ordinary character, instead of an"
" escape character."
msgstr ""
"Если этот флаг установлен, то обратная косая черта воспринимается как простой "
"символ, а не специальный."

#. type: TP
#: man-pages/man3/fnmatch.3:54
#, no-wrap
msgid "B<FNM_PATHNAME>"
msgstr "B<FNM_PATHNAME>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:62
msgid ""
"If this flag is set, match a slash in I<string> only with a slash in "
"I<pattern> and not by an asterisk (*) or a question mark (?) metacharacter, "
"nor by a bracket expression ([]) containing a slash."
msgstr ""
"Если этот флаг установлен, то косая черта в строке I<string> будет совпадать "
"только с косой чертой в шаблоне I<pattern>, но не с метасимволом звёздочка "
"(*) или вопросительным знаком (?) и не последовательностью в квадратных "
"скобках ([]), содержащую косую черту."

#. type: TP
#: man-pages/man3/fnmatch.3:62
#, no-wrap
msgid "B<FNM_PERIOD>"
msgstr "B<FNM_PERIOD>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:73
msgid ""
"If this flag is set, a leading period in I<string> has to be matched exactly"
" by a period in I<pattern>.  A period is considered to be leading if it is "
"the first character in I<string>, or if both B<FNM_PATHNAME> is set and the "
"period immediately follows a slash."
msgstr ""
"Если этот флаг установлен, то начальная точка в строке I<string> должна "
"сравниваться именно с точкой в шаблоне I<pattern>. Точка считается начальной, "
"если она является первым символом в строке I<string>, или если установлен "
"флаг B<FNM_PATHNAME> и точка следует сразу за косой чертой."

#. type: TP
#: man-pages/man3/fnmatch.3:73
#, no-wrap
msgid "B<FNM_FILE_NAME>"
msgstr "B<FNM_FILE_NAME>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:77
msgid "This is a GNU synonym for B<FNM_PATHNAME>."
msgstr "Синоним B<FNM_PATHNAME> в GNU."

#. type: TP
#: man-pages/man3/fnmatch.3:77
#, no-wrap
msgid "B<FNM_LEADING_DIR>"
msgstr "B<FNM_LEADING_DIR>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:85
msgid ""
"If this flag (a GNU extension) is set, the pattern is considered to be "
"matched if it matches an initial segment of I<string> which is followed by a"
" slash.  This flag is mainly for the internal use of glibc and is "
"implemented only in certain cases."
msgstr ""
"Если этот флаг (расширение GNU) установлен, то строка считается совпавшей с "
"шаблоном, если совпадает начальный сегмент строки I<string>, который следует "
"сразу за косой чертой. Этот флаг для внутреннего использования glibc и не "
"всегда реализуется."

#. type: TP
#: man-pages/man3/fnmatch.3:85
#, no-wrap
msgid "B<FNM_CASEFOLD>"
msgstr "B<FNM_CASEFOLD>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:89
msgid ""
"If this flag (a GNU extension) is set, the pattern is matched case-"
"insensitively."
msgstr ""
"Если этот флаг (расширение GNU) установлен, то выражения сравниваются без "
"учёта регистра символов."

#. type: Plain text
#: man-pages/man3/fnmatch.3:96
msgid ""
"Zero if I<string> matches I<pattern>, B<FNM_NOMATCH> if there is no match or"
" another nonzero value if there is an error."
msgstr ""
"Возвращает ноль, если строка I<string> совпадает с шаблоном I<pattern>, "
"возвращает B<FNM_NOMATCH>, если строка и шаблон не совпадают, или другое "
"ненулевое значение, если произошла ошибка."

#. type: Plain text
#: man-pages/man3/fnmatch.3:101
msgid ""
"POSIX.2.  The B<FNM_FILE_NAME>, B<FNM_LEADING_DIR>, and B<FNM_CASEFOLD> "
"flags are GNU extensions."
msgstr ""
"POSIX.2. Флаги B<FNM_FILE_NAME>, B<FNM_LEADING_DIR> и B<FNM_CASEFOLD> "
"являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/fnmatch.3:106
msgid "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"
msgstr "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"

#. type: TH
#: man-pages/man3/fmtmsg.3:13
#, no-wrap
msgid "FMTMSG"
msgstr "FMTMSG"

#. type: TH
#: man-pages/man3/fmtmsg.3:13
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:16
msgid "fmtmsg - print formatted error messages"
msgstr "fmtmsg - выводит отформатированные сообщения об ошибках"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:19
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:21
#, no-wrap
msgid "B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
msgstr "B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:23
#, no-wrap
msgid "B<           int >I<severity>B<, const char *>I<text>B<,>\n"
msgstr "B<           int >I<severity>B<, const char *>I<text>B<,>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:25
#, no-wrap
msgid "B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr "B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:36
msgid ""
"This function displays a message described by its arguments on the device(s)"
"  specified in the I<classification> argument.  For messages written to "
"I<stderr>, the format depends on the B<MSGVERB> environment variable."
msgstr ""
"Эта функция выводит сообщение, описываемое аргументами, на устройство(а), "
"заданное в аргументе I<classification>. Для сообщений, записываемых в I<"
"stderr>, формат зависит от переменной окружения B<MSGVERB>."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:43
msgid ""
"The I<label> argument identifies the source of the message.  The string must"
" consist of two colon separated parts where the first part has not more than"
" 10 and the second part not more than 14 characters."
msgstr ""
"В аргументе I<label> задаётся источник сообщения. Строка должна состоять из "
"двух частей, разделённых двоеточиями; первая часть должна быть не более 10 "
"символов, а вторая часть — не более 14."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:47
msgid "The I<text> argument describes the condition of the error."
msgstr "В аргументе I<text> описывается условие ошибки."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:52
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""
"В аргументе I<action> описываются возможные шаги по исправлению ошибки. Если "
"они выводятся, то начинаются с «TO FIX: »."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:60
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique"
" identification number."
msgstr ""
"В аргументе I<tag> указывается ссылка на онлайн-документацию, в которой можно "
"найти дополнительную информацию. Он должен содержать значение I<label> и "
"уникальный идентификационный номер."

#. type: SS
#: man-pages/man3/fmtmsg.3:60
#, no-wrap
msgid "Dummy arguments"
msgstr "Фиктивные аргументы"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:79
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed."
"  The dummy severity value B<NO_SEV> (0) says that no severity is supplied."
"  The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char\\ *)\\ 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""
"Каждый аргумент может иметь фиктивное значение. Для фиктивного значения "
"классификации (classification) B<MM_NULLMC> (0L) ничего не выводится, то есть "
"ничего не печатается. Фиктивное значение важности (severity) B<NO_SEV> (0) "
"указывается, если важность не определена. Значения B<MM_NULLLBL>, B<"
"MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> являются синонимами I<((char\\ *)\\ "
"0)> — пустой строки, а B<MM_NULLSEV> — синоним B<NO_SEV>."

#. type: SS
#: man-pages/man3/fmtmsg.3:79
#, no-wrap
msgid "The classification argument"
msgstr "Аргумент классификации"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:83
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr ""
"Аргумент I<classification> — это сочетание значений, описывающих 4 типа "
"информации."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:86
msgid "The first value defines the output channel."
msgstr "Первое значение определяет канал вывода."

#. type: TP
#: man-pages/man3/fmtmsg.3:86
#, no-wrap
msgid "B<MM_PRINT>"
msgstr "B<MM_PRINT>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:90
msgid "Output to I<stderr>."
msgstr "Вывод в I<stderr>."

#. type: TP
#: man-pages/man3/fmtmsg.3:90
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr "B<MM_CONSOLE>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:93
msgid "Output to the system console."
msgstr "Вывод в системную консоль."

#. type: TP
#: man-pages/man3/fmtmsg.3:93
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr "B<MM_PRINT | MM_CONSOLE>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:96
msgid "Output to both."
msgstr "Вывод в оба места."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:98
msgid "The second value is the source of the error:"
msgstr "Вторым значением описывается источник ошибки."

#. type: TP
#: man-pages/man3/fmtmsg.3:98
#, no-wrap
msgid "B<MM_HARD>"
msgstr "B<MM_HARD>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:101
msgid "A hardware error occurred."
msgstr "Произошла аппаратная ошибка."

#. type: TP
#: man-pages/man3/fmtmsg.3:101
#, no-wrap
msgid "B<MM_FIRM>"
msgstr "B<MM_FIRM>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:104
msgid "A firmware error occurred."
msgstr "Произошла ошибка в микропрограмме."

#. type: TP
#: man-pages/man3/fmtmsg.3:104
#, no-wrap
msgid "B<MM_SOFT>"
msgstr "B<MM_SOFT>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:107
msgid "A software error occurred."
msgstr "Произошла ошибка в программном обеспечении."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:109
msgid "The third value encodes the detector of the problem:"
msgstr "В третьем значении кодируется выявитель проблемы."

#. type: TP
#: man-pages/man3/fmtmsg.3:109
#, no-wrap
msgid "B<MM_APPL>"
msgstr "B<MM_APPL>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:112
msgid "It is detected by an application."
msgstr "Обнаружено приложением."

#. type: TP
#: man-pages/man3/fmtmsg.3:112
#, no-wrap
msgid "B<MM_UTIL>"
msgstr "B<MM_UTIL>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:115
msgid "It is detected by a utility."
msgstr "Обнаружено утилитой."

#. type: TP
#: man-pages/man3/fmtmsg.3:115
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr "B<MM_OPSYS>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:118
msgid "It is detected by the operating system."
msgstr "Обнаружено операционной системой."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:120
msgid "The fourth value shows the severity of the incident:"
msgstr "В четвёртом значении показывается важность инцидента:"

#. type: TP
#: man-pages/man3/fmtmsg.3:120
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr "B<MM_RECOVER>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:123
msgid "It is a recoverable error."
msgstr "Это исправимая ошибка."

#. type: TP
#: man-pages/man3/fmtmsg.3:123
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr "B<MM_NRECOV>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:126
msgid "It is a nonrecoverable error."
msgstr "Это неисправимая ошибка."

#. type: SS
#: man-pages/man3/fmtmsg.3:126
#, no-wrap
msgid "The severity argument"
msgstr "Аргумент важности"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:130
msgid "The I<severity> argument can take one of the following values:"
msgstr "В аргументе I<severity> можно указать одно из следующих значений:"

#. type: TP
#: man-pages/man3/fmtmsg.3:130
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr "B<MM_NOSEV>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:133
msgid "No severity is printed."
msgstr "Важность не печатается."

#. type: TP
#: man-pages/man3/fmtmsg.3:133
#, no-wrap
msgid "B<MM_HALT>"
msgstr "B<MM_HALT>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:136
msgid "This value is printed as HALT."
msgstr "Это значение печатается как ОСТАНОВ."

#. type: TP
#: man-pages/man3/fmtmsg.3:136
#, no-wrap
msgid "B<MM_ERROR>"
msgstr "B<MM_ERROR>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:139
msgid "This value is printed as ERROR."
msgstr "Это значение печатается как ОШИБКА."

#. type: TP
#: man-pages/man3/fmtmsg.3:139
#, no-wrap
msgid "B<MM_WARNING>"
msgstr "B<MM_WARNING>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:142
msgid "This value is printed as WARNING."
msgstr "Это значение печатается как ПРЕДУПРЕЖДЕНИЕ."

#. type: TP
#: man-pages/man3/fmtmsg.3:142
#, no-wrap
msgid "B<MM_INFO>"
msgstr "B<MM_INFO>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:145
msgid "This value is printed as INFO."
msgstr "Это значение печатается как ИНФОРМАЦИОННОЕ."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:152
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""
"Числовые значения от 0 до 4. Используя функцию B<addseverity>(3) или "
"переменную окружения B<SEV_LEVEL> вы можете добавить дополнительные уровни и "
"строки для печати."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:154
msgid "The function can return 4 values:"
msgstr "Функция может возвращать 4 значения:"

#. type: TP
#: man-pages/man3/fmtmsg.3:154
#, no-wrap
msgid "B<MM_OK>"
msgstr "B<MM_OK>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:157
msgid "Everything went smooth."
msgstr "Всё хорошо."

#. type: TP
#: man-pages/man3/fmtmsg.3:157
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr "B<MM_NOTOK>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:160
msgid "Complete failure."
msgstr "Всё плохо."

#. type: TP
#: man-pages/man3/fmtmsg.3:160
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr "B<MM_NOMSG>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:164
msgid "Error writing to I<stderr>."
msgstr "Ошибка записи в I<stderr>."

#. type: TP
#: man-pages/man3/fmtmsg.3:164
#, no-wrap
msgid "B<MM_NOCON>"
msgstr "B<MM_NOCON>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:167
msgid "Error writing to the console."
msgstr "Ошибка записи в консоль."

#. type: SH
#: man-pages/man3/fmtmsg.3:167
#, no-wrap
msgid "ENVIRONMENT"
msgstr "ОКРУЖЕНИЕ"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:178
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to"
" the console.)  When this variable is defined, is non-NULL, and is a colon-"
"separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""
"Переменная окружения B<MSGVERB> (message verbosity — детальность сообщения) "
"может использоваться для отключения некоторых частей вывода в I<stderr> (она "
"не влияет на вывод на консоль). Если эта переменная определена, не равна NULL "
"и содержит список допустимых ключевых слов через двоеточие, то печатаются "
"только части сообщения, которые соответствуют этим ключевым словам. "
"Допустимые ключевые слова: «label», «severity», «text», «action» и «tag»."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:190
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""
"Переменная окружения B<SEV_LEVEL> может использоваться для ввода новых "
"уровней важности. По умолчанию, доступно только пять уровней важности, "
"описанных выше. Для любого другого числового значения B<fmtmsg>() ничего не "
"печатает. Если пользователь задал B<SEV_LEVEL> в формате"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:193
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr "SEV_LEVEL=[описание[:описание[:...]]]"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:198
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr ""
"в окружении процесса перед первым вызовом B<fmtmsg>() и каждое описание имеет "
"вид"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:201
msgid "severity-keyword,level,printstring"
msgstr "ключевое-слово-важности,уровень,печатаемая-строка"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:208
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0-4), and use the indicated printstring when"
" such a level occurs."
msgstr ""
"то B<fmtmsg>() также будет обрабатывать заданные значения уровней (в "
"дополнении к стандартным уровням 0-4), и использовать указанную строку "
"печати, когда встречается такой уровень."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:222
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the"
" string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""
"Часть «ключевое-слово-важности» не используется B<fmtmsg>(), но указывается. "
"Часть «уровень» — это строка, представляющая число. Числовое значение должно "
"быть числом более 4. Это значение должно использоваться в аргументе важности "
"B<fmtmsg>() для выбора этого класса. Невозможно заменить любой из "
"предопределённых классов. «Печатаемая-строка» — строка, которая печатается в "
"случае, когда сообщение этого класса обрабатывается B<fmtmsg>()."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:225
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr "Функция B<fmtmsg>() появилась в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:231
msgid ""
"Before glibc 2.16, the B<fmtmsg>()  function uses a static variable that is "
"not protected, so it is not thread-safe."
msgstr ""
"До glibc 2.16 функция B<fmtmsg>() использовала статическую незащищённую "
"переменную, поэтому функцию нельзя использовать в нескольких нитях "
"одновременно."

#.  Modified in commit 7724defcf8873116fe4efab256596861eef21a94
#. type: Plain text
#: man-pages/man3/fmtmsg.3:237
msgid ""
"Since glibc 2.16, the B<fmtmsg>()  function uses a lock to protect the "
"static variable, so it is thread-safe."
msgstr ""
"Начиная с glibc 2.16 функция B<fmtmsg>() использует блокировку для защиты "
"статической переменной, поэтому функцию можно использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:252
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V.  The function B<fmtmsg>()  "
"and the environment variable B<MSGVERB> are described in POSIX.1-2001."
msgstr ""
"Функции B<fmtmsg>() и B<addseverity>(3), и переменные окружения B<MSGVERB> и "
"B<SEV_LEVEL> впервые появились из System V. Функция B<fmtmsg>() и переменная "
"окружения B<MSGVERB> описана в POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:256
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""
"В справочных страницах System V и UnixWare указано, что эти функции были "
"заменены на «pfmt() и addsev()» или «pfmt(), vpfmt(), lfmt() и vlfmt()», и "
"будут впоследствии удалены."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:261
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"fmtmsg.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:267
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""
"int\nmain(void)\n{\n    long class = MM_PRINT | MM_SOFT | MM_OPSYS | "
"MM_RECOVER;\n    int err;\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:288
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n                "
"\"неизвестный параметр mount\", \"Смотрите mount(8).\",\n                "
"\"util-linux:mount:017\");\n    switch (err) {\n    case MM_OK:\n        "
"break;\n    case MM_NOTOK:\n        printf(\"Нечего печатать\\en\");\n        "
"break;\n    case MM_NOMSG:\n        printf(\"Нечего печатать в "
"stderr\\en\");\n        break;\n    case MM_NOCON:\n        printf(\"Нет "
"вывода на консоль\\en\");\n        break;\n    default:\n        "
"printf(\"Неизвестная ошибка fmtmsg()\\en\");\n    }\n    "
"exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:291
msgid "The output should be:"
msgstr "Вывод должен быть таким:"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:295
#, no-wrap
msgid ""
"    util-linux:mount: ERROR: unknown mount option\n"
"    TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""
"    util-linux:mount: ОШИБКА: неизвестный параметр mount\n    TO FIX: "
"Смотрите mount(8).  util-linux:mount:017\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:298
msgid "and after"
msgstr "а после"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:301
#, no-wrap
msgid "    MSGVERB=text:action; export MSGVERB\n"
msgstr "    MSGVERB=text:action; export MSGVERB\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:304
msgid "the output becomes:"
msgstr "вывод станет:"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:308
#, no-wrap
msgid ""
"    unknown mount option\n"
"    TO FIX: See mount(8).\n"
msgstr "    неизвестный параметр mount\n    TO FIX: Смотрите mount(8).\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:311
msgid "B<addseverity>(3), B<perror>(3)"
msgstr "B<addseverity>(3), B<perror>(3)"

#. type: TH
#: man-pages/man3/fmemopen.3:10
#, no-wrap
msgid "FMEMOPEN"
msgstr "FMEMOPEN"

#. type: Plain text
#: man-pages/man3/fmemopen.3:13
msgid "fmemopen, open_memstream, open_wmemstream - open memory as stream"
msgstr "fmemopen, open_memstream, open_wmemstream - открывает память как поток"

#. type: Plain text
#: man-pages/man3/fmemopen.3:16
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:18
#, no-wrap
msgid ""
"B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char "
"*>I<mode>B<);>\n"
msgstr ""
"B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>"
"\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:20
#, no-wrap
msgid "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:22
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:24
#, no-wrap
msgid "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr ""
"B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:34
msgid "B<fmemopen>(), B<open_memstream>(), B<open_wmemstream>():"
msgstr "B<fmemopen>(), B<open_memstream>(), B<open_wmemstream>():"

#. type: TP
#: man-pages/man3/fmemopen.3:37
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:40
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man3/fmemopen.3:40
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:43
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/fmemopen.3:57
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified"
" by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>.  This buffer must be at least I<size> bytes "
"long."
msgstr ""
"Функция B<fmemopen>() открывает поток, тип доступа указывается в I<mode>. "
"Поток позволяет выполнять операции ввода-вывода со строкой или буфером "
"памяти, указанным в I<buf>. Этот буфер должен быть не менее I<size> байт."

#. type: Plain text
#: man-pages/man3/fmemopen.3:77
msgid ""
"The argument I<mode> is the same as for B<fopen>(3).  If I<mode> specifies "
"an append mode, then the initial file position is set to the location of the"
" first null byte (\\(aq\\e0\\(aq) in the buffer; otherwise the initial file "
"position is set to the start of the buffer.  Since glibc 2.9, the letter "
"\\(aqb\\(aq may be specified as the second character in I<mode>.  This "
"provides \"binary\" mode: writes don't implicitly add a terminating null "
"byte, and B<fseek>(3)  B<SEEK_END> is relative to the end of the buffer "
"(i.e., the value specified by the I<size> argument), rather than the current"
" string length."
msgstr ""
"Значения аргумента I<mode> такие же как у B<fopen>(3). Если в I<mode> "
"указывается режим добавления, то начальной файловой позиции присваивается "
"расположение в буфере первого байта null («\\e0»); в противном случае "
"начальная файловая позиция равна началу буфера. Начиная с glibc 2.9, символ "
"«b» можно указать вторым символом в I<mode>. Это включает «двоичный» режим: "
"запись неявно не добавляет завершающий байт null, и B<fseek>(3) B<SEEK_END> "
"считается относительно конца буфера (т. е., значение, указанное в аргументе "
"I<size>), а не длины текущей строки."

#. type: Plain text
#: man-pages/man3/fmemopen.3:89
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or"
" closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in"
" the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""
"Когда поток, открытый на запись, сбрасывается (flushed) (B<fflush>(3)) или "
"закрывается (B<fclose>(3)), то в конец буфера записывается байт null, если "
"есть место. Вызывающий должен быть уверен, что в буфере есть место для "
"дополнительного байта (и в I<size> учитывается этот байт), чтобы это "
"произошло."

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1995
#.  and
#.  http://sources.redhat.com/ml/libc-alpha/2006-04/msg00064.html
#. type: Plain text
#: man-pages/man3/fmemopen.3:107
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error."
"  (By default, such errors will be visible only when the I<stdio> buffer is "
"flushed.  Disabling buffering with I<setbuf(fp,\\ NULL)> may be useful to "
"detect errors at the time of an output operation.  Alternatively, the caller"
" can explicitly set I<buf> as the stdio stream buffer, at the same time "
"informing stdio of the buffer's size, using I<setbuffer(fp, buf, size)>.)"
msgstr ""
"Попытка записать более I<size> байт в буфер приводит к ошибке (по умолчанию, "
"такие ошибки будут видимы только в момент сброса буфера I<stdio>. Отключение "
"буферизации с помощью I<setbuf(fp,\\ NULL)> может быть полезно для "
"обнаружения ошибок в момент операции вывода. Или же вызывающий может явно "
"задать I<buf> в качестве потокового буфера stdio, и проинформировав stdio о "
"размере буфера с помощью I<setbuffer(fp, buf, size)>)."

#. type: Plain text
#: man-pages/man3/fmemopen.3:115
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do"
" not cause read operations to return an end-of-file indication.  A read from"
" the buffer will only indicate end-of-file when the file pointer advances "
"I<size> bytes past the start of the buffer."
msgstr ""
"В потоке, открытом на чтение, при обнаружении байтов null («\\e0») в буфере "
"операции чтения не возвращают конец файла. Чтение из буфера будет возвращать "
"конец файла, только когда значение файлового указателя достигнет I<size> байт "
"от начала буфера."

#. type: Plain text
#: man-pages/man3/fmemopen.3:130
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  dynamically allocates a "
"buffer I<size> bytes long.  This is useful for an application that wants to "
"write data to a temporary buffer and then read it back again.  The buffer is"
" automatically freed when the stream is closed.  Note that the caller has no"
" way to obtain a pointer to the temporary buffer allocated by this call (but"
" see B<open_memstream>()  below)."
msgstr ""
"Если значение I<buf> равно NULL, то B<fmemopen>() динамически выделяет буфер "
"длиной I<size> байт. Это полезно для приложений, которым нужно записать "
"данные во временный буфер и причитать из него. Буфер автоматически "
"освобождается при закрытии потока. Заметим, что вызывающий никогда не получит "
"указатель на временный буфер, выделенный этим вызовом (но смотрите B<"
"open_memstream>() далее)."

#. type: Plain text
#: man-pages/man3/fmemopen.3:141
msgid ""
"The B<open_memstream>()  function opens a stream for writing to a buffer.  "
"The buffer is dynamically allocated (as with B<malloc>(3)), and "
"automatically grows as required.  After closing the stream, the caller "
"should B<free>(3)  this buffer."
msgstr ""
"Функция B<open_memstream>() открывает поток для записи в буфер. Буфер "
"динамически выделяется (с помощью B<malloc>(3)) и автоматически расширяется "
"при необходимости. После закрытия потока вызывающий должен освободить этот "
"буфер с помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/fmemopen.3:156
msgid ""
"When the stream is closed (B<fclose>(3))  or flushed (B<fflush>(3)), the "
"locations pointed to by I<ptr> and I<sizeloc> are updated to contain, "
"respectively, a pointer to the buffer and the current size of the buffer.  "
"These values remain valid only as long as the caller performs no further "
"output on the stream.  If further output is performed, then the stream must "
"again be flushed before trying to access these variables."
msgstr ""
"При закрытии потока (B<fclose>(3)) или сброса (B<fflush>(3)) значение "
"расположений I<ptr> и I<sizeloc> обновляются и содержат, соответственно, "
"указатель на буфер и текущий размер буфера. Эти значения остаются "
"корректными, пока вызывающий не произведёт вывод в поток. После выполнения "
"вывода, перед тем как обращаться к этим переменным, поток снова должен быть "
"сброшен."

#. type: Plain text
#: man-pages/man3/fmemopen.3:162
msgid ""
"A null byte is maintained at the end of the buffer.  This byte is I<not> "
"included in the size value stored at I<sizeloc>."
msgstr ""
"Байт null поддерживается в конце буфера. Этот байт I<не> учитывается в "
"значении размера, хранящемся в I<sizeloc>."

#. type: Plain text
#: man-pages/man3/fmemopen.3:170
msgid ""
"The stream's file position can be changed with B<fseek>(3)  or B<fseeko>(3)."
"  Moving the file position past the end of the data already written fills "
"the intervening space with zeros."
msgstr ""
"Файловая позиция в потоке может быть изменена с помощью B<fseek>(3) или B<"
"fseeko>(3). Перемещение файловой позиции за конец данных сразу приводит к "
"заполнению промежутка нулями."

#. type: Plain text
#: man-pages/man3/fmemopen.3:176
msgid ""
"The B<open_wmemstream>()  is similar to B<open_memstream>(), but operates on"
" wide characters instead of bytes."
msgstr ""
"Функция B<open_wmemstream>() похожа на B<open_memstream>(), но работает с "
"широкими символами, а не с байтами."

#. type: Plain text
#: man-pages/man3/fmemopen.3:188
msgid ""
"Upon successful completion B<fmemopen>(), B<open_memstream>()  and "
"B<open_wmemstream>()  return a I<FILE> pointer.  Otherwise, NULL is returned"
" and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fmemopen>(), B<open_memstream>() и B<"
"open_wmemstream>() возвращается указатель I<FILE>. В противном случае "
"возвращается NULL и I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/fmemopen.3:195
msgid ""
"B<fmemopen>()  and B<open_memstream>()  were already available in glibc "
"1.0.x.  B<open_wmemstream>()  is available since glibc 2.4."
msgstr ""
"Функции B<fmemopen>() и B<open_memstream>() были доступны уже в glibc 1.0.x. "
"Функция B<open_wmemstream>() доступна в glibc начиная с версии 2.4."

#. type: Plain text
#: man-pages/man3/fmemopen.3:199
msgid ""
"POSIX.1-2008.  These functions are not specified in POSIX.1-2001, and are "
"not widely available on other systems."
msgstr ""
"POSIX.1-2008. Эти функции не определены в POSIX.1-2001 и не широко "
"распространены в других системах."

#.  http://austingroupbugs.net/view.php?id=396
#. type: Plain text
#: man-pages/man3/fmemopen.3:207
msgid ""
"POSIX.1-2008 specifies that \\(aqb\\(aq in I<mode> shall be ignored.  "
"However, Technical Corrigendum 1 adjusts the standard to allow "
"implementation-specific treatment for this case, thus permitting the glibc "
"treatment of \\(aqb\\(aq."
msgstr ""
"В POSIX.1-2008 указано, что символ «b» в I<mode> должен игнорироваться. "
"Однако в Technical Corrigendum 1 изменили стандарт, позволив реализации "
"решать что делать; это позволяет glibc учитывать «b»."

#. type: Plain text
#: man-pages/man3/fmemopen.3:213
msgid ""
"There is no file descriptor associated with the file stream returned by "
"these functions (i.e., B<fileno>(3)  will return an error if called on the "
"returned stream)."
msgstr ""
"У файлового потока, возвращаемого этими  функциями, отсутствует файловый "
"дескриптор (т. е., если файловый поток передать в B<fileno>(3), то произойдёт "
"ошибка)."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=1996
#. type: Plain text
#: man-pages/man3/fmemopen.3:220
msgid ""
"In glibc before version 2.7, seeking past the end of a stream created by "
"B<open_memstream>()  does not enlarge the buffer; instead the B<fseek>(3)  "
"call fails, returning -1."
msgstr ""
"В glibc до версии 2.7 перемещение за конец потока, созданного B<"
"open_memstream>(), не приводило к увеличению буфера; вместо этого вызов B<"
"fseek>(3) завершался с ошибкой, возвращая -1."

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=11216
#. type: Plain text
#: man-pages/man3/fmemopen.3:231
msgid ""
"If I<size> is specified as zero, B<fmemopen>()  fails with the error "
"B<EINVAL>.  It would be more consistent if this case successfully created a "
"stream that then returned end of file on the first attempt at reading.  "
"Furthermore, POSIX.1-2008 does not specify a failure for this case."
msgstr ""
"Если указано значение I<size> равное нулю, то B<fmemopen>() завершится с "
"ошибкой B<EINVAL>. В этом случае было бы целесообразней создавать поток, "
"который затем возвращал бы конец файла при первой попытке чтения. Кроме того, "
"в POSIX.1-2008 ничего не сказано про ошибку в этом случае."

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=13152
#. type: Plain text
#: man-pages/man3/fmemopen.3:239
msgid ""
"Specifying append mode (\"a\" or \"a+\") for B<fmemopen>()  sets the initial"
" file position to the first null byte, but (if the file offset is reset to a"
" location other than the end of the stream)  does not force subsequent "
"writes to append at the end of the stream."
msgstr ""
"В режиме добавления («a» или «a+») B<fmemopen>() устанавливает начальную "
"файловую позицию на первый байт null, но (если файловое смещение сбрасывается "
"в расположение, отличное от конца потока) не заставляет последующие операции "
"записи выполнять добавление в конец потока."

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=13151
#. type: Plain text
#: man-pages/man3/fmemopen.3:255
msgid ""
"If the I<mode> argument to B<fmemopen>()  specifies append (\"a\" or "
"\"a+\"), and the I<size> argument does not cover a null byte in I<buf>, "
"then, according to POSIX.1-2008, the initial file position should be set to "
"the next byte after the end of the buffer.  However, in this case the glibc "
"B<fmemopen>()  sets the file position to -1."
msgstr ""
"Если в аргументе I<mode> в B<fmemopen>() включено добавление («a» или «a+») и "
"аргумент I<size> не учитывает байт null в I<buf>, то согласно POSIX.1-2008 "
"начальная файловая позиция должна указывать на следующий байт за концом "
"буфера. Однако, в этом случае glibc B<fmemopen>() присваивает файловой "
"позиции значение -1."

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12836
#. type: Plain text
#: man-pages/man3/fmemopen.3:268
msgid ""
"To specify binary mode for B<fmemopen>()  the \\(aqb\\(aq must be the "
"I<second> character in I<mode>.  Thus, for example, \"wb+\" has the desired "
"effect, but \"w+b\" does not.  This is inconsistent with the treatment of "
"I<mode> by B<fopen>(3)."
msgstr ""
"Для задания двоичного режима в B<fmemopen>() I<вторым> символом в I<mode> "
"должен быть «b». То есть, например, «wb+» сработает, а «w+b» — нет. Это не "
"совпадает с трактовкой I<mode> в B<fopen>(3)."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6544
#. type: Plain text
#: man-pages/man3/fmemopen.3:276
msgid ""
"The glibc 2.9 addition of \"binary\" mode for B<fmemopen>()  silently "
"changed the ABI: previously, B<fmemopen>()  ignored \\(aqb\\(aq in I<mode>."
msgstr ""
"При дополнении B<fmemopen>() в glibc 2.9 «двоичным» режимом было потихоньку "
"изменено ABI: раньше B<fmemopen>() игнорировала «b» в I<mode>."

#. type: Plain text
#: man-pages/man3/fmemopen.3:286
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>()  to open a dynamically sized output buffer.  The program"
" scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr ""
"Программа, показанная ниже, использует B<fmemopen>() для открытия входного "
"буфера и B<open_memstream>() для открытия выходного буфера с динамически "
"изменяющимся размером. Программа сканирует входную строку (первый аргумент "
"командной строки программы), читая целые числа, и записывает квадраты этих "
"чисел в выходной буфер. Пример результата работы программы:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:291
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr "$B< ./a.out \\(aq1 23 43\\(aq>\nsize=11; ptr=1 529 1849\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:300
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n#include E<lt>string.hE<gt>\n#include E<lt>stdio.hE<gt>"
"\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:303
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n    do { perror(msg); exit(EXIT_FAILURE); } "
"while (0)\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:311
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    FILE *out, *in;\n    int v, s;\n    "
"size_t size;\n    char *ptr;\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:316
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>файлE<"
"gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:320
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n    if (in == NULL)\n    "
"    handle_error(\"fmemopen\");\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:324
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""
"    out = open_memstream(&ptr, &size);\n    if (out == NULL)\n        "
"handle_error(\"open_memstream\");\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:329
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""
"    for (;;) {\n        s = fscanf(in, \"%d\", &v);\n        if (s E<lt>= "
"0)\n            break;\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:340
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
"    fclose(in);\n"
"    fclose(out);\n"
"    printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n"
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        s = fprintf(out, \"%d \", v * v);\n        if (s == -1)\n            "
"handle_error(\"fprintf\");\n    }\n    fclose(in);\n    fclose(out);\n    "
"printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n    free(ptr);\n    "
"exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:343
msgid "B<fopen>(3), B<fopencookie>(3)"
msgstr "B<fopen>(3), B<fopencookie>(3)"

#. type: TH
#: man-pages/man3/fseek.3:42
#, no-wrap
msgid "FSEEK"
msgstr "FSEEK"

#. type: Plain text
#: man-pages/man3/fseek.3:45
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr "fgetpos, fseek, fsetpos, ftell, rewind - меняют положение в потоке"

#. type: Plain text
#: man-pages/man3/fseek.3:47
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/fseek.3:49
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:51
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr "B<long ftell(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:53
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr "B<void rewind(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:55
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:57
msgid "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"
msgstr "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:81
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or end-"
"of-file, respectively.  A successful call to the B<fseek>()  function clears"
" the end-of-file indicator for the stream and undoes any effects of the "
"B<ungetc>(3)  function on the same stream."
msgstr ""
"Функция B<fseek>() устанавливает положение файлового индикатора в потоке, на "
"который указывает аргумент I<stream>. Новое положение (в байтах) получается "
"прибавлением I<offset> байтов к положению, которое задаётся параметром I<"
"whence>. Если значение I<whence> равно B<SEEK_SET>, B<SEEK_CUR> или B<"
"SEEK_END>, то смещение указывается относительно начала файла, текущего "
"положения указателя или конца файла, соответственно. Успешный вызов функции "
"B<fseek>() очищает (clear) индикатор конца файла потока и отменяет влияние "
"функции B<ungetc>(3) на этот же поток."

#. type: Plain text
#: man-pages/man3/fseek.3:87
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""
"Функция B<ftell>() возвращает текущее значение файлового индикатора положения "
"для потока, на который указывает I<stream>."

#. type: Plain text
#: man-pages/man3/fseek.3:94
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""
"Функция B<rewind>() устанавливает файловый индикатор положения для потока, на "
"который указывает I<stream>, равным началу файла. Эта функция эквивалентна "
"вызову:"

#. type: Plain text
#: man-pages/man3/fseek.3:97
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr "(void) fseek(stream, 0L, SEEK_SET)"

#. type: Plain text
#: man-pages/man3/fseek.3:101
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""
"хотя в этом случае также сбрасывается индикатор ошибок потока (смотрите B<"
"clearerr>(3))."

#. type: Plain text
#: man-pages/man3/fseek.3:121
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with I<whence> set to "
"B<SEEK_SET>), setting and storing the current value of the file offset into "
"or from the object referenced by I<pos>.  On some non-UNIX systems, an "
"I<fpos_t> object may be a complex object and these routines may be the only "
"way to portably reposition a text stream."
msgstr ""
"Функции B<fgetpos>() и B<fsetpos>() эквивалентны B<ftell>() и B<fseek>() (где "
"значение I<whence> равно B<SEEK_SET>); они сохраняют или устанавливают "
"текущее значение файлового смещения в объектах, определяемых I<pos>. В "
"некоторых не-UNIX системах объект I<fpos_t> может быть сложным объектом, а "
"данные функции могут быть единственным переносимым способом изменения "
"положения в текстовом потоке."

#. type: Plain text
#: man-pages/man3/fseek.3:136
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"Функция B<rewind>() не возвращает значений. При успешном выполнении функции "
"B<fgetpos>(), B<fseek>(), B<fsetpos>() возвращают 0, а B<ftell>() возвращает "
"значение текущего смещения. В противном случае возвращается -1, а в I<errno> "
"записывается соответствующий код ошибки."

#. type: Plain text
#: man-pages/man3/fseek.3:142
msgid "The I<stream> specified is not a seekable stream."
msgstr "В указанном потоке I<stream> невозможно изменять положение."

#. type: Plain text
#: man-pages/man3/fseek.3:154
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>.  Or: the resulting file offset would be negative."
msgstr ""
"Значение I<whence> в B<fseek>() не равно B<SEEK_SET>, B<SEEK_> или B<SEEK_CUR>"
". Или результирующее смещение файла получается отрицательным."

#. type: Plain text
#: man-pages/man3/fseek.3:169
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""
"При ошибках функции B<fgetpos>(), B<fseek>(), B<fsetpos>() и B<ftell>() "
"устанавливают значение I<errno> равным значению, определённому в функциях B<"
"fflush>(3), B<fstat>(2), B<lseek>(2) и B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/fseek.3:171
msgid "C89, C99."
msgstr "C89, C99."

#. type: Plain text
#: man-pages/man3/fseek.3:173
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr "B<lseek>(2), B<fseeko>(3)"

#. type: TH
#: man-pages/man3/frexp.3:33
#, no-wrap
msgid "FREXP"
msgstr "FREXP"

#. type: TH
#: man-pages/man3/frexp.3:33
#, no-wrap
msgid "2013-08-06"
msgstr "2013-08-06"

#. type: Plain text
#: man-pages/man3/frexp.3:37
msgid ""
"frexp, frexpf, frexpl - convert floating-point number to fractional and "
"integral components"
msgstr ""
"frexp, frexpf, frexpl - приводит число с плавающей точкой к виду "
"мантисса/степень"

#. type: Plain text
#: man-pages/man3/frexp.3:42
#, no-wrap
msgid "B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"
msgstr "B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: man-pages/man3/frexp.3:44
#, no-wrap
msgid "B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"
msgstr "B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: man-pages/man3/frexp.3:46
#, no-wrap
msgid "B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"
msgstr "B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: man-pages/man3/frexp.3:58
msgid "B<frexpf>(), B<frexpl>():"
msgstr "B<frexpf>(), B<frexpl>():"

#. type: Plain text
#: man-pages/man3/frexp.3:61
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE "
"|| _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/frexp.3:74
msgid ""
"The B<frexp>()  function is used to split the number I<x> into a normalized "
"fraction and an exponent which is stored in I<exp>."
msgstr ""
"Функция B<frexp>() используется для разделения числа I<x> на нормализованную "
"мантиссу и степень, которая сохраняется в I<exp>."

#. type: Plain text
#: man-pages/man3/frexp.3:86
msgid ""
"The B<frexp>()  function returns the normalized fraction.  If the argument "
"I<x> is not zero, the normalized fraction is I<x> times a power of two, and "
"its absolute value is always in the range 1/2 (inclusive) to 1 (exclusive), "
"that is, [0.5,1)."
msgstr ""
"Функция B<frexp>() возвращает нормализованную мантиссу. Если аргумент I<x> не "
"равен нулю, то нормализованная мантисса равна I<x> степеням двойки, а её "
"абсолютное значение всегда находится в диапазоне от 1/2 (включительно) до 1 "
"(не включая), то есть [0.5,1)."

#. type: Plain text
#: man-pages/man3/frexp.3:92
msgid ""
"If I<x> is zero, then the normalized fraction is zero and zero is stored in "
"I<exp>."
msgstr ""
"Если значение I<x> равно нулю, то нормализованная мантисса равна нулю, и ноль "
"сохраняется в I<exp>."

#. type: Plain text
#: man-pages/man3/frexp.3:99
msgid ""
"If I<x> is a NaN, a NaN is returned, and the value of I<*exp> is "
"unspecified."
msgstr ""
"Если значение I<x> равно NaN, то возвращается NaN, а значение I<*exp> не "
"определено."

#. type: Plain text
#: man-pages/man3/frexp.3:106
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned, and the value of I<*exp> is unspecified."
msgstr ""
"Если I<x> равно плюс или минус бесконечность, то будет возвращена плюс или "
"минус бесконечность, а значение I<*exp> не определено."

#. type: Plain text
#: man-pages/man3/frexp.3:108
msgid "No errors occur."
msgstr "Ошибки не возникают."

#. type: Plain text
#: man-pages/man3/frexp.3:116
msgid ""
"The B<frexp>(), B<frexpf>(), and B<frexpl>()  functions are thread-safe."
msgstr ""
"Функции B<frexp>(), B<frexpf>() и B<frexpl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/frexp.3:122
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD, C89."
msgstr ""
"C99, POSIX.1-2001. Вариант, возвращающий значение типа I<double>, также "
"соответствует SVr4, 4.3BSD и C89."

#. type: Plain text
#: man-pages/man3/frexp.3:124
msgid "The program below produces results such as the following:"
msgstr "Нижеследующая программа выдает такие результаты:"

#. type: Plain text
#: man-pages/man3/frexp.3:131
#, no-wrap
msgid ""
"$B< ./a.out 2560>\n"
"frexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n"
"$B< ./a.out -4>\n"
"frexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"
msgstr ""
"$B< ./a.out 2560>\nfrexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n$B< ./a.out "
"-4>\nfrexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"

#. type: Plain text
#: man-pages/man3/frexp.3:140
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>float.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>math.hE<gt>\n#include E<lt>float.hE<gt>\n#include E<lt>"
"stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/frexp.3:146
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x, r;\n"
"    int exp;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    double x, r;\n    int exp;\n"

#. type: Plain text
#: man-pages/man3/frexp.3:149
#, no-wrap
msgid ""
"    x = strtod(argv[1], NULL);\n"
"    r = frexp(x, &exp);\n"
msgstr "    x = strtod(argv[1], NULL);\n    r = frexp(x, &exp);\n"

#. type: Plain text
#: man-pages/man3/frexp.3:154
#, no-wrap
msgid ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n"
"           x, r, r, FLT_RADIX, exp, x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n           x, r, r, "
"FLT_RADIX, exp, x);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/frexp.3:157
msgid "B<ldexp>(3), B<modf>(3)"
msgstr "B<ldexp>(3), B<modf>(3)"

#. type: TH
#: man-pages/man3/fclose.3:44
#, no-wrap
msgid "FCLOSE"
msgstr "FCLOSE"

#. type: TH
#: man-pages/man3/fclose.3:44
#, no-wrap
msgid "2009-02-23"
msgstr "2009-02-23"

#. type: Plain text
#: man-pages/man3/fclose.3:47
msgid "fclose - close a stream"
msgstr "fclose - закрывает поток"

#. type: Plain text
#: man-pages/man3/fclose.3:51
msgid "B<int fclose(FILE *>I<fp>B<);>"
msgstr "B<int fclose(FILE *>I<fp>B<);>"

#. type: Plain text
#: man-pages/man3/fclose.3:59
msgid ""
"The B<fclose>()  function flushes the stream pointed to by I<fp> (writing "
"any buffered output data using B<fflush>(3))  and closes the underlying file"
" descriptor."
msgstr ""
"Функция B<fclose>() сбрасывает (flushes) поток, указанный в I<fp> (записывает "
"все буферизированные выходные данные с помощью B<fflush>(3)) и закрывает "
"связанный с ним файловый дескриптор."

#. type: Plain text
#: man-pages/man3/fclose.3:70
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and"
" I<errno> is set to indicate the error.  In either case any further access "
"(including another call to B<fclose>())  to the stream results in undefined "
"behavior."
msgstr ""
"При успешном выполнении возвращается нулевое значение. В противном случае "
"возвращается B<EOF> и I<errno> присваивается код ошибки. В любом случае, "
"дальнейшие попытки доступа (включая ещё один вызов B<fclose>()) к потоку "
"приведут к неопределенному результату."

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(fp)).
#. type: Plain text
#: man-pages/man3/fclose.3:80
msgid "The file descriptor underlying I<fp> is not valid."
msgstr "В I<fp> указан неверный дескриптор файла."

#. type: Plain text
#: man-pages/man3/fclose.3:90
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2)  or B<fflush>(3)."
msgstr ""
"Функция B<fclose>() при ошибках может установить I<errno> в значение, "
"соответствующее ошибкам функций B<close>(2), B<write>(2) или B<fflush>(3)."

#. type: Plain text
#: man-pages/man3/fclose.3:102
msgid ""
"Note that B<fclose>()  only flushes the user-space buffers provided by the C"
" library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"Заметим, что B<fclose>() сбрасывает буферы только пользовательского "
"пространства, заданные библиотекой Си. Чтобы гарантировать, что данные "
"действительно физически сохранены на диске, буферы ядра также должны быть "
"сохранены, например, с помощью вызова B<sync>(2) или B<fsync>(2)."

#. type: Plain text
#: man-pages/man3/fclose.3:107
msgid "B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: man-pages/man3/fwide.3:16
#, no-wrap
msgid "FWIDE"
msgstr "FWIDE"

#. type: TH
#: man-pages/man3/fwide.3:16
#, no-wrap
msgid "2014-03-19"
msgstr "2014-03-19"

#. type: Plain text
#: man-pages/man3/fwide.3:19
msgid "fwide - set and determine the orientation of a FILE stream"
msgstr "fwide - задаёт и определяет ориентацию потока FILE"

#. type: Plain text
#: man-pages/man3/fwide.3:24
#, no-wrap
msgid "B<int fwide(FILE *>I<stream>B<, int >I<mode>B<);>\n"
msgstr "B<int fwide(FILE *>I<stream>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fwide.3:33
msgid "B<fwide>():"
msgstr "B<fwide>():"

#. type: Plain text
#: man-pages/man3/fwide.3:35
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"

#. type: Plain text
#: man-pages/man3/fwide.3:37
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/fwide.3:57
msgid ""
"When I<mode> is zero, the B<fwide>()  function determines the current "
"orientation of I<stream>.  It returns a positive value if I<stream> is wide-"
"character oriented, that is, if wide-character I/O is permitted but char I/O"
" is disallowed.  It returns a negative value if I<stream> is byte "
"oriented\\(emthat is, if char I/O is permitted but wide-character I/O is "
"disallowed.  It returns zero if I<stream> has no orientation yet; in this "
"case the next I/O operation might change the orientation (to byte oriented "
"if it is a char I/O operation, or to wide-character oriented if it is a "
"wide-character I/O operation)."
msgstr ""
"Если значение I<mode> равно нулю, то функция B<fwide>() определяет текущую "
"ориентацию потока I<stream>. Возвращается положительное значение, если I<"
"stream> ориентирован на широкие символы, то есть ввод/вывод широких символов "
"разрешён, а ввод/вывод обычных символов запрещён. Возвращается отрицательное "
"значение, если I<stream> ориентирован на работу с байтами, то есть разрешён "
"ввод/вывод обычных символов (char), а ввод/вывод широких символов запрещён. "
"Возвращается ноль, если I<stream> пока не имеет ориентации; в этом случае "
"следующая операция ввода/вывода может поменять ориентацию (например, на "
"байтовую, если производится операция ввода/вывода символов, или на широкие "
"символы, если выполняется операция ввода/вывода широких символов)."

#. type: Plain text
#: man-pages/man3/fwide.3:60
msgid ""
"Once a stream has an orientation, it cannot be changed and persists until "
"the stream is closed."
msgstr ""
"После того, ориентация потока определена, она не сможет быть изменена и будет "
"действовать до тех пор, пока не закроется поток."

#. type: Plain text
#: man-pages/man3/fwide.3:69
msgid ""
"When I<mode> is nonzero, the B<fwide>()  function first attempts to set "
"I<stream>'s orientation (to wide-character oriented if I<mode> is greater "
"than 0, or to byte oriented if I<mode> is less than 0).  It then returns a "
"value denoting the current orientation, as above."
msgstr ""
"Если значение I<mode> не равно нулю, то функция B<fwide>() сначала попытается "
"установить ориентацию I<stream> (на широкие символы, если I<mode> больше 0, "
"или на байты, если I<mode> меньше 0). Затем возвращается значение, отражающее "
"текущую ориентацию, как указано выше."

#. type: Plain text
#: man-pages/man3/fwide.3:77
msgid ""
"The B<fwide>()  function returns the stream's orientation, after possibly "
"changing it.  A positive return value means wide-character oriented.  A "
"negative return value means byte oriented.  A return value of zero means "
"undecided."
msgstr ""
"Функция B<fwide>() возвращает ориентацию потока после возможного её "
"изменения. Возвращаемое положительное значение означает ориентацию на широкие "
"символы. Возвращаемое отрицательное значение означает ориентацию на байты. "
"Возвращаемое значение 0 означает неопределённость."

#. type: Plain text
#: man-pages/man3/fwide.3:87
msgid ""
"Wide-character output to a byte oriented stream can be performed through the"
" B<fprintf>(3)  function with the B<%lc> and B<%ls> directives."
msgstr ""
"Вывод широких символов в поток, ориентированный на байтовые операции, может "
"быть осуществлён с помощью функции B<fprintf>(3) с директивами B<%lc> и B<%ls>"
"."

#. type: Plain text
#: man-pages/man3/fwide.3:96
msgid ""
"Char oriented output to a wide-character oriented stream can be performed "
"through the B<fwprintf>(3)  function with the B<%c> and B<%s> directives."
msgstr ""
"Вывод символов в поток, ориентированный на операции с широкими символами, "
"может быть осуществлён с помощью функции B<fwprintf>(3) с директивами B<%c> и "
"B<%s>."

#. type: Plain text
#: man-pages/man3/fwide.3:98
msgid "B<fprintf>(3), B<fwprintf>(3)"
msgstr "B<fprintf>(3), B<fwprintf>(3)"

#. type: TH
#: man-pages/man3/fexecve.3:25
#, no-wrap
msgid "FEXECVE"
msgstr "FEXECVE"

#. type: TH
#: man-pages/man3/fexecve.3:25
#, no-wrap
msgid "2014-04-20"
msgstr "2014-04-20"

#. type: Plain text
#: man-pages/man3/fexecve.3:28
msgid "fexecve - execute program specified via file descriptor"
msgstr "fexecve - запускает программу, заданную файловым дескриптором"

#. type: Plain text
#: man-pages/man3/fexecve.3:31
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fexecve.3:33
#, no-wrap
msgid ""
"B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const "
">I<envp>B<[]);>\n"
msgstr ""
"B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<"
"[]);>\n"

#. type: Plain text
#: man-pages/man3/fexecve.3:41
msgid "B<fexecve>():"
msgstr "B<fexecve>():"

#.  POSIX.1-2008 specifies the O_EXEC flag for open as an alternative,
#.  but Linux doesn't support this flag yet.
#. type: Plain text
#: man-pages/man3/fexecve.3:67
msgid ""
"B<fexecve>()  performs the same task as B<execve>(2), with the difference "
"that the file to be executed is specified via a file descriptor, I<fd>, "
"rather than via a pathname.  The file descriptor I<fd> must be opened read-"
"only, and the caller must have permission to execute the file that it refers"
" to."
msgstr ""
"Функция B<fexecve>() выполняет ту же задачу, что и B<execve>(2), только "
"выполняемый файл указывается посредством файлового дескриптора I<fd>, а не "
"через путь к файлу. Файловый дескриптор I<fd> должен быть открыт только для "
"чтения и вызывающий должен иметь права на выполнение файла, на который "
"ссылается дескриптор."

#. type: Plain text
#: man-pages/man3/fexecve.3:74
msgid ""
"A successful call to B<fexecve>()  never returns.  On error, the function "
"does return, with a result value of -1, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<fexecve>() не возвращает управление. При ошибке "
"функция возвращает выполнение с результатом -1, а I<errno> устанавливает в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man3/fexecve.3:78
msgid "Errors are as for B<execve>(2), with the following additions:"
msgstr "Возникают те же ошибки что и для B<execve>(2), а также дополнительно:"

#. type: Plain text
#: man-pages/man3/fexecve.3:86
msgid ""
"I<fd> is not a valid file descriptor, or I<argv> is NULL, or I<envp> is "
"NULL."
msgstr ""
"Значение I<fd> не является правильным файловым дескриптором или I<argv> равно "
"NULL, или I<envp> равно NULL."

#. type: Plain text
#: man-pages/man3/fexecve.3:91
msgid "The I</proc> filesystem could not be accessed."
msgstr "Нет доступа к файловой системе I</proc>."

#. type: Plain text
#: man-pages/man3/fexecve.3:94
msgid "B<fexecve>()  is implemented since glibc 2.3.2."
msgstr "Функция B<fexecve>() появилась в glibc 2.3.2."

#. type: Plain text
#: man-pages/man3/fexecve.3:99
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems.  It is specified in POSIX.1-2008."
msgstr ""
"POSIX.1-2008. Эта функция не определена в POSIX.1-2001 и широко не "
"распространена среди других систем. Она определена в POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/fexecve.3:107
msgid ""
"On Linux, B<fexecve>()  is implemented using the B<proc>(5)  filesystem, so "
"I</proc> needs to be mounted and available at the time of the call."
msgstr ""
"В Linux, B<fexecve>() реализована с использованием файловой системы B<proc>"
"(5), поэтому I</proc> должна быть смонтирована и доступна на момент вызова."

#. type: Plain text
#: man-pages/man3/fexecve.3:120
msgid ""
"If I<fd> is a file descriptor that refers to an interpreter script and has "
"been marked as close-on-exec (see the discussion of the B<FD_CLOEXEC> in "
"B<fcntl>(2)), B<fexecve>()  will fail to execute the script, since, by the "
"time the script interpreter tries to access the script file, I<fd> has "
"already been closed."
msgstr ""
"Если I<fd> — файловый дескриптор, который ссылается на интерпретатор сценария "
"и был помечен как close-on-exec (смотрите описание B<FD_CLOEXEC> в B<fcntl>"
"(2)), то B<fexecve>() завершает с ошибкой выполнение сценария, так как на "
"момент, когда интерпретатор сценария пытается получить доступ к файлу "
"сценария, I<fd> уже был закрыт."

#. type: Plain text
#: man-pages/man3/fexecve.3:137
msgid ""
"The idea behind B<fexecve>()  is to allow the caller to verify (checksum) "
"the contents of an executable before executing it.  Simply opening the file,"
" checksumming the contents, and then doing an B<execve>(2)  would not "
"suffice, since, between the two steps, the filename, or a directory prefix "
"of the pathname, could have been exchanged (by, for example, modifying the "
"target of a symbolic link).  B<fexecve>()  does not mitigate the problem "
"that the I<contents> of a file could be changed between the checksumming and"
" the call to B<fexecve>(); for that, the solution is to ensure that the "
"permissions on the file prevent it from being modified by malicious users."
msgstr ""
"Предназначение B<fexecve>() — позволить вызывающему проверить содержимое "
"исполняемого файла (контрольную сумму) до запуска. Простого открытия файла, "
"вычисления контрольной суммы содержимого и выполнения B<execve>(2) "
"недостаточно, так как между двумя этими шагами может измениться имя файла или "
"каталог пути (например, посредством изменения цели символьной ссылки). "
"Функция B<fexecve>() не решает проблему возможного изменения I<содержимого> "
"файла между проверкой контрольной суммы и вызовом B<fexecve>() — для этого "
"есть права на файл, которые должны предотвращать его несанкционированное "
"изменение."

#. type: Plain text
#: man-pages/man3/fexecve.3:138
msgid "B<execve>(2)"
msgstr "B<execve>(2)"

#. type: TH
#: man-pages/man3/fgetws.3:18
#, no-wrap
msgid "FGETWS"
msgstr "FGETWS"

#. type: TH
#: man-pages/man3/fgetws.3:18
#, no-wrap
msgid "2011-09-28"
msgstr "2011-09-28"

#. type: Plain text
#: man-pages/man3/fgetws.3:21
msgid "fgetws - read a wide-character string from a FILE stream"
msgstr "fgetws - читает строку широких символов из потока FILE"

#. type: Plain text
#: man-pages/man3/fgetws.3:26
#, no-wrap
msgid ""
"B<wchar_t *fgetws(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wchar_t *fgetws(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetws.3:40
msgid ""
"The B<fgetws>()  function is the wide-character equivalent of the "
"B<fgets>(3)  function.  It reads a string of at most I<n-1> wide characters "
"into the wide-character array pointed to by I<ws>, and adds a terminating "
"null wide character (L\\(aq\\e0\\(aq).  It stops reading wide characters "
"after it has encountered and stored a newline wide character.  It also stops"
" when end of stream is reached."
msgstr ""
"Функция B<fgetws>() — это эквивалент B<fgets>(3), но работающий со строками "
"широких символов. Она читает строку из не более чем I<n-1> широких символов, "
"записывает её в массив широких символов I<ws> и добавляет завершающий широкий "
"символ null (L\\(aq\\e0\\(aq). Она прекращает чтение после обнаружения и "
"записи широкого символа новой строки. Это также происходит и в случае "
"достижения конца потока."

#. type: Plain text
#: man-pages/man3/fgetws.3:43
msgid ""
"The programmer must ensure that there is room for at least I<n> wide "
"characters at I<ws>."
msgstr ""
"Программист должен убедиться в том, что выделил для I<ws> память, достаточную "
"для записи не менее I<n> широких символов."

#. type: Plain text
#: man-pages/man3/fgetws.3:46
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr "Неблокирующий аналог смотрите в B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/fgetws.3:52
msgid ""
"The B<fgetws>()  function, if successful, returns I<ws>.  If end of stream "
"was already reached or if an error occurred, it returns NULL."
msgstr ""
"Функция B<fgetws>() в случае удачного выполнения возвращает I<ws>. Если "
"достигнут конец потока или возникает ошибка, то возвращается NULL."

#. type: Plain text
#: man-pages/man3/fgetws.3:61
msgid ""
"The behavior of B<fgetws>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fgetws>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fgetws.3:69
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fgetws>()  will actually read a multibyte "
"string from the stream and then convert it to a wide-character string."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fgetws>() на самом деле читает многобайтовую "
"строку из потока, а затем преобразует её в широкую строку."

#. type: Plain text
#: man-pages/man3/fgetws.3:73
msgid ""
"This function is unreliable, because it does not permit to deal properly "
"with null wide characters that may be present in the input."
msgstr ""
"Данная функция  ненадёжна, так как не позволяет правильно обработать "
"ситуацию, когда во входных данных появляется широкий символ null."

#. type: Plain text
#: man-pages/man3/fgetws.3:75
msgid "B<fgetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/flockfile.3:25
#, no-wrap
msgid "FLOCKFILE"
msgstr "FLOCKFILE"

#. type: TH
#: man-pages/man3/flockfile.3:25
#, no-wrap
msgid "2013-07-23"
msgstr "2013-07-23"

#. type: Plain text
#: man-pages/man3/flockfile.3:28
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr "flockfile, ftrylockfile, funlockfile - блокирует FILE для stdio"

#. type: Plain text
#: man-pages/man3/flockfile.3:33
#, no-wrap
msgid "B<void flockfile(FILE *>I<filehandle>B<);>\n"
msgstr "B<void flockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: man-pages/man3/flockfile.3:35
#, no-wrap
msgid "B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
msgstr "B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: man-pages/man3/flockfile.3:37
#, no-wrap
msgid "B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr "B<void funlockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: man-pages/man3/flockfile.3:46
msgid "All functions shown above:"
msgstr "Для всех функций, перечисленных выше:"

#. type: Plain text
#: man-pages/man3/flockfile.3:49
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"
" || _POSIX_SOURCE"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE "
"|| _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/flockfile.3:63
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""
"Функции stdio можно без опаски использовать в нитях. Это достигается "
"назначением каждому объекту I<FILE> счётчика блокировок и (если счётчик не "
"равен нулю) нити-владельца. При каждом библиотечном вызове эти функции ждут "
"разблокировки объекта I<FILE> другой нитью, блокируют его, а затем выполняют "
"заданную операцию ввода/вывода и разблокируют объект."

#. type: Plain text
#: man-pages/man3/flockfile.3:69
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""
"(Замечание: блокировка не учитывается, если блокировка файла осуществлялась "
"функциями типа B<flock>(2)  и B<lockf>(3).)"

#. type: Plain text
#: man-pages/man3/flockfile.3:77
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the"
" I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""
"Всё это прозрачно и незаметно для программиста на С, но всё же есть две "
"причины для более подробного изучения. Первая: возможны последовательности "
"операций ввода/вывода в одной нити, при этом другая нить не будет прерывать "
"ввод/вывод. Вторая: можно избежать чрезмерной нагрузки от блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:94
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming"
" in between.  If the reason for doing this was to achieve greater "
"efficiency, one does the I/O with the nonlocking versions of the stdio "
"functions: with B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of "
"B<getc>(3)  and B<putc>(3)."
msgstr ""
"С этой целью нить может явно блокировать объект I<FILE>, осуществить серию "
"операций ввода/вывода, а затем снять блокировку. При этом другие нити не "
"могут вклиниться между операциями. Если причиной для реализации всего этого "
"является повышение эффективности работы, то для ввода/вывод можно "
"использовать неблокирующие версии функций stdio: B<getc_unlocked>(3) и B<"
"putc_unlocked>(3) вместо B<getc>(3) и B<putc>(3)."

#. type: Plain text
#: man-pages/man3/flockfile.3:105
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked"
" by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""
"Функция B<flockfile>() ожидает, пока I<*filehandle> не разблокируется другой "
"нитью, затем делает текущую нить владельцем I<*filehandle> и увеличивает "
"счётчик блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:109
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr "Функция B<funlockfile>() уменьшает счётчик блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:120
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>()."
"  It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""
"Функция B<ftrylockfile>() является неблокирующей версией B<flockfile>(). Она "
"ничего не делает в том случае, если другая нить владеет I<*filehandle>, в "
"противном случае устанавливает статус владельца и увеличивает счётчик "
"блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:125
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""
"При успешном выполнении функция B<ftrylockfile>() возвращает ноль (была "
"получена блокировка) или ненулевое значение при ошибках."

#. type: Plain text
#: man-pages/man3/flockfile.3:127
msgid "None."
msgstr "Нет."

#. type: Plain text
#: man-pages/man3/flockfile.3:135
msgid ""
"The B<flockfile>(), B<ftrylockfile>(), and B<funlockfile>()  functions are "
"thread-safe."
msgstr ""
"Функции B<flockfile>(), B<ftrylockfile>() и B<funlockfile>() можно "
"использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/flockfile.3:137
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/flockfile.3:143
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined.  They are in libc since libc 5.1.1 and in glibc since glibc 2.0."
msgstr ""
"Эти функции доступны при определении B<_POSIX_THREAD_SAFE_FUNCTIONS>. Они "
"присутствуют в libc начиная с версии 5.1.1 и в glibc начиная с версии 2.0."

#. type: Plain text
#: man-pages/man3/flockfile.3:144
msgid "B<unlocked_stdio>(3)"
msgstr "B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fmin.3:9
#, no-wrap
msgid "FMIN"
msgstr "FMIN"

#. type: TH
#: man-pages/man3/fmin.3:9
#, no-wrap
msgid "2013-09-17"
msgstr "2013-09-17"

#. type: Plain text
#: man-pages/man3/fmin.3:12
msgid "fmin, fminf, fminl - determine minimum of two floating-point numbers"
msgstr ""
"fmin, fminf, fminl - определение минимального из двух чисел с плавающей "
"запятой"

#. type: Plain text
#: man-pages/man3/fmin.3:16
msgid "B<double fmin(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fmin(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmin.3:18
msgid "B<float fminf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fminf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmin.3:20
msgid "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmin.3:32
msgid "B<fmin>(), B<fminf>(), B<fminl>():"
msgstr "B<fmin>(), B<fminf>(), B<fminl>():"

#. type: Plain text
#: man-pages/man3/fmin.3:45
msgid "These functions return the lesser value of I<x> and I<y>."
msgstr "Данные функции возвращают меньшее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmin.3:50
msgid "These functions return the minimum of I<x> and I<y>."
msgstr "Данные функции возвращают меньшее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmin.3:52
msgid "If one argument is a NaN, the other argument is returned."
msgstr ""
"Если значение одного из аргументов равно NaN, то будет возвращено значение "
"другого аргумента."

#. type: Plain text
#: man-pages/man3/fmin.3:54
msgid "If both arguments are NaN, a NaN is returned."
msgstr "Если значение обоих аргументов равно NaN, то будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fmin.3:66
msgid "The B<fmin>(), B<fminf>(), and B<fminl>()  functions are thread-safe."
msgstr ""
"Функции B<fmin>(), B<fminf>() и B<fminl>() можно использовать в нескольких "
"нитях одновременно."

#. type: TH
#: man-pages/man3/fopencookie.3:26
#, no-wrap
msgid "FOPENCOOKIE"
msgstr "FOPENCOOKIE"

#. type: TH
#: man-pages/man3/fopencookie.3:26
#, no-wrap
msgid "2013-03-17"
msgstr "2013-03-17"

#. type: Plain text
#: man-pages/man3/fopencookie.3:29
msgid "fopencookie - opening a custom stream"
msgstr "fopencookie - открывает нестандартный поток"

#. type: Plain text
#: man-pages/man3/fopencookie.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include "
"E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:36
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\nB<          "
"        cookie_io_functions_t >I<io_funcs>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:49
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the"
" stream's data at a location of its own choosing; for example, "
"B<fopencookie>()  is used to implement B<fmemopen>(3), which provides a "
"stream interface to data that is stored in a buffer in memory."
msgstr ""
"Функция B<fopencookie>() позволяет программисту создать нестандартную "
"реализацию стандартного потока ввода-вывода. Эта реализация может хранить "
"данные потока в расположении по своему выбору; например, B<fopencookie>() "
"используется для реализации функции B<fmemopen>(3), которая предоставляет "
"потоковый интерфейс для данных, хранящихся в буфере в памяти."

#. type: Plain text
#: man-pages/man3/fopencookie.3:51
msgid "In order to create a custom stream the programmer must:"
msgstr "Для создания нестандартного потока программист должен:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:54
msgid ""
"Implement four \"hook\" functions that are used internally by the standard "
"I/O library when performing I/O on the stream."
msgstr ""
"Реализовать четыре «обрабатывающих» (hook) функции, которые используются "
"внутри стандартной библиотеки ввода-вывода при операциях ввода-вывода над "
"потоком."

#. type: Plain text
#: man-pages/man3/fopencookie.3:65
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to "
"B<fopencookie>()), but automatically supplies the cookie as the first "
"argument when calling the hook functions."
msgstr ""
"Определить тип данных «cookie» — структуру для учёта информации (например, "
"где хранятся данные), используемую вышеупомянутыми обрабатывающими функциями. "
"Стандартный пакет ввода-вывода ничего не знает о содержимом этого cookie (к "
"нему обращаются как к I<void\\ *> при передаче в B<fopencookie>()), но "
"автоматически передаёт cookie в первом аргументе при вызове обрабатывающих "
"функций."

#. type: Plain text
#: man-pages/man3/fopencookie.3:70
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""
"Вызвать B<fopencookie>() для открытия нового потока и связывания cookie и "
"обрабатывающими функциями с этим потоком."

#. type: Plain text
#: man-pages/man3/fopencookie.3:78
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to"
" operate on that stream."
msgstr ""
"Функция B<fopencookie>() подобна B<fopen>(3): она открывает новый поток и "
"возвращает указатель на объект I<FILE>, который используется для работы с "
"потоком."

#. type: Plain text
#: man-pages/man3/fopencookie.3:85
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is"
" to be associated with the new stream.  This pointer is supplied as the "
"first argument when the standard I/O library invokes any of the hook "
"functions described below."
msgstr ""
"Аргумент I<cookie> — это указатель на структуру cookie вызывающего, которая "
"связывается с новым потоком. Данный указатель передаётся в первом аргументе в "
"моменты, когда стандартная библиотека ввода-вывода вызывает одну из "
"обрабатывающих функций, описанных ниже."

#. type: Plain text
#: man-pages/man3/fopencookie.3:101
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""
"Аргумент I<mode> служит той же цели что и для B<fopen>(3). Поддерживаются "
"следующие режимы: I<r>, I<w>, I<a>, I<r+>, I<w+> и I<a+>. Подробности "
"смотрите в B<fopen>(3)."

#. type: Plain text
#: man-pages/man3/fopencookie.3:107
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""
"Аргумент I<io_funcs> — это структура, которая содержит четыре поля с "
"задаваемыми программистом обрабатывающими функциями, которые используются для "
"реализации этого потока. Структура определена как"

#. type: Plain text
#: man-pages/man3/fopencookie.3:116
#, no-wrap
msgid ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"
msgstr ""
"typedef struct {\n    cookie_read_function_t  *read;\n    "
"cookie_write_function_t *write;\n    cookie_seek_function_t  *seek;\n    "
"cookie_close_function_t *close;\n} cookie_io_functions_t;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:120
msgid "The four fields are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man3/fopencookie.3:120
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr "I<cookie_read_function_t *read>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:124
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""
"Эта функция реализует операции чтения из потока. Она вызывается с тремя "
"аргументами:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:126
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr "    ssize_t read(void *cookie, char *buf, size_t size);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:141
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""
"Аргументы I<buf> и I<size> — буфер для получаемых данных и его размер. В "
"качестве результата функция I<read> возвращает количество байт, скопированных "
"в I<buf>, 0 — при окончании файла и -1 при ошибке. Функция I<read> обновляет "
"смещение в потоке соответствующим образом."

#. type: Plain text
#: man-pages/man3/fopencookie.3:146
msgid ""
"If I<*read> is a null pointer, then reads from the custom stream always "
"return end of file."
msgstr ""
"Если значение I<*read> равно null, то при чтении из нестандартного потока "
"всегда возвращается конец файла."

#. type: TP
#: man-pages/man3/fopencookie.3:146
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr "I<cookie_write_function_t *write>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:150
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""
"Эта функция реализует операции записи в поток. Она вызывается с тремя "
"аргументами:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:152
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr "    ssize_t write(void *cookie, const char *buf, size_t size);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:168
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or 0 on error.  (The function must not return a negative value.)  The "
"I<write> function should update the stream offset appropriately."
msgstr ""
"Аргументы I<buf> и I<size> — буфер для выходных данных и его размер (данные, "
"записываемые в поток). В качестве результата функция I<write> возвращает "
"количество байт, скопированных из I<buf>, и 0 при ошибке (функция не должна "
"возвращать отрицательное значение). Функция I<write> обновляет смещение в "
"потоке соответствующим образом."

#. type: Plain text
#: man-pages/man3/fopencookie.3:173
msgid "If I<*write> is a null pointer, then output to the stream is discarded."
msgstr "Если значение I<*write> равно null, то вывод в поток отбрасывается."

#. type: TP
#: man-pages/man3/fopencookie.3:173
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr "I<cookie_seek_function_t *seek>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:177
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""
"Эта функция реализует операции смещения в потоке. Она вызывается с тремя "
"аргументами:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:179
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr "    int seek(void *cookie, off64_t *offset, int whence);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:185
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""
"В аргументе I<*offset> указывается новое файловое смещение, зависящее от "
"значения I<whence>:"

#. type: TP
#: man-pages/man3/fopencookie.3:186
#, no-wrap
msgid "B<SEEK_SET>"
msgstr "B<SEEK_SET>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:191
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr "Значение смещения приравнивается I<*offset> байт от начала потока."

#. type: TP
#: man-pages/man3/fopencookie.3:191
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr "B<SEEK_CUR>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:195
msgid "I<*offset> should be added to the current stream offset."
msgstr ""
"Значение I<*offset> должно быть добавлено к текущему смещению в потоке."

#. type: TP
#: man-pages/man3/fopencookie.3:195
#, no-wrap
msgid "B<SEEK_END>"
msgstr "B<SEEK_END>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:199
msgid ""
"The stream offset should be set to the size of the stream plus I<*offset>."
msgstr "Значение смещения приравнивается к размеру потока плюс I<*offset>."

#. type: Plain text
#: man-pages/man3/fopencookie.3:206
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""
"Перед возвратом функция I<seek> должна обновить I<*offset>, чтобы показать "
"новое смещение в потоке."

#. type: Plain text
#: man-pages/man3/fopencookie.3:210
msgid ""
"As its function result, the I<seek> function should return 0 on success, and"
" -1 on error."
msgstr ""
"В качестве результата функция I<seek> должна возвращать 0 при успешном "
"выполнении и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/fopencookie.3:215
msgid ""
"If I<*seek> is a null pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""
"Если значение I<*seek> равно null, то операции смещения в потоке выполнить "
"невозможно."

#. type: TP
#: man-pages/man3/fopencookie.3:215
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr "I<cookie_close_function_t *close>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:221
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""
"Эта функция закрывает поток. Обрабатывающая функция может выполнить такие "
"операции как освобождение буферов, выделенных для потока. При вызове она "
"принимает один аргумент:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:223
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr "    int close(void *cookie);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:228
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""
"Аргумент I<cookie> — это cookie, которую программист передал при вызове B<"
"fopencookie>()."

#. type: Plain text
#: man-pages/man3/fopencookie.3:234
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""
"В качестве результата функция I<close> должна возвращать 0 при успешном "
"выполнении и B<EOF> при ошибке."

#. type: Plain text
#: man-pages/man3/fopencookie.3:238
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is"
" closed."
msgstr ""
"Если значение I<*close> равно NULL, то при закрытии потока не выполняется "
"никаких действий."

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: man-pages/man3/fopencookie.3:245
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error,"
" NULL is returned."
msgstr ""
"При успешном выполнении B<fopencookie>() возвращает указатель на новый поток. "
"При ошибке возвращается NULL."

#. type: Plain text
#: man-pages/man3/fopencookie.3:247
msgid "This function is a nonstandard GNU extension."
msgstr "Эта функция является нестандартным расширением GNU."

#. type: Plain text
#: man-pages/man3/fopencookie.3:256
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""
"Программа, представленная ниже, реализует нестандартный поток, свойства "
"которого похожи (но не одинаковы) на свойство потока, получаемого от B<"
"fmemopen>(3). Она реализует поток, данные которого хранятся в буфере памяти. "
"Программа записывает свои аргументы командной строки в поток, а затем "
"перемещается по потоку, читая два из каждых пяти символов и записывая их в "
"стандартный вывод. Сеанс оболочки, демонстрирующий использование программы:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:264
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""
"$B< ./a.out \\(aqhello world\\(aq>\n/he/\n/ w/\n/d/\nДостигнут конец файла\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:271
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a"
" cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""
"Заметим, что представленную версию можно сильно улучшить, добавив обработку "
"ошибок (например, открытие потока с cookie, которая уже имеет открытый поток; "
"закрытие потока, который уже был закрыт)."

#. type: Plain text
#: man-pages/man3/fopencookie.3:280
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n#include E<lt>sys/types.hE<gt>\n#include E<lt>stdio.hE<"
"gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>"
"string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:282
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr "#define INIT_BUF_SIZE 4\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:289
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""
"struct memfile_cookie {\n    char   *buf;        /* динамически изменяемый "
"буфер для данных */\n    size_t  allocated;  /* размер буфера */\n    size_t  "
"endpos;     /* количество символов в буфере */\n    off_t   offset;     /* "
"текущее файловое смещение в буфере */\n};\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:295
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\nmemfile_write(void *c, const char *buf, size_t size)\n{\n    char "
"*new_buff;\n    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:297
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr "    /* Буфер мал? Удваиваем размер, пока не станет достаточным */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:307
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n        "
"new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n        if "
"(new_buff == NULL) {\n            return -1;\n        } else {\n            "
"cookie-E<gt>allocated *= 2;\n            cookie-E<gt>buf = new_buff;\n        "
"}\n    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:309
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:313
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""
"    cookie-E<gt>offset += size;\n    if (cookie-E<gt>offset E<gt> cookie-E<gt>"
"endpos)\n        cookie-E<gt>endpos = cookie-E<gt>offset;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:316
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr "    return size;\n}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:322
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\nmemfile_read(void *c, char *buf, size_t size)\n{\n    ssize_t "
"xbytes;\n    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:324
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr "    /* Выбираем минимум запрашиваемых и доступных байт */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:330
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""
"    xbytes = size;\n    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>"
"endpos)\n        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n    if "
"(xbytes E<lt> 0)     /* смещение может быть за endpos */\n       xbytes = 0;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:332
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:336
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr "    cookie-E<gt>offset += xbytes;\n    return xbytes;\n}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:342
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\nmemfile_seek(void *c, off64_t *offset, int whence)\n{\n    off64_t "
"new_offset;\n    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:351
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""
"    if (whence == SEEK_SET)\n        new_offset = *offset;\n    else if "
"(whence == SEEK_END)\n        new_offset = cookie-E<gt>endpos + *offset;\n    "
"else if (whence == SEEK_CUR)\n        new_offset = cookie-E<gt>offset + "
"*offset;\n    else\n        return -1;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:354
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr "    if (new_offset E<lt> 0)\n        return -1;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:359
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset = new_offset;\n    *offset = new_offset;\n    return "
"0;\n}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:364
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\nmemfile_close(void *c)\n{\n    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:368
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""
"    free(cookie-E<gt>buf);\n    cookie-E<gt>allocated = 0;\n    cookie-E<gt>"
"buf = NULL;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:371
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr "    return 0;\n}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:387
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *fp;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    cookie_io_functions_t  memfile_func "
"= {\n        .read  = memfile_read,\n        .write = memfile_write,\n        "
".seek  = memfile_seek,\n        .close = memfile_close\n    };\n    FILE "
"*fp;\n    struct memfile_cookie mycookie;\n    ssize_t nread;\n    long p;\n  "
"  int j;\n    char buf[1000];\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:389
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr "    /* Устанавливаем cookie перед вызовом fopencookie() */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:395
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n    if (mycookie.buf == NULL) {\n  "
"      perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:399
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""
"    mycookie.allocated = INIT_BUF_SIZE;\n    mycookie.offset = 0;\n    "
"mycookie.endpos = 0;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:405
#, no-wrap
msgid ""
"    fp = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (fp == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fp = fopencookie(&mycookie,\"w+\", memfile_func);\n    if (fp == NULL) "
"{\n        perror(\"fopencookie\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:407
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr "    /* Записываем аргументы командной строки в файл */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:413
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], fp) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    for (j = 1; j E<lt> argc; j++)\n        if (fputs(argv[j], fp) == EOF) "
"{\n            perror(\"fputs\");\n            exit(EXIT_FAILURE);\n        "
"}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:415
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr "    /* Читаем два байта из пяти пока не получим EOF */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:430
#, no-wrap
msgid ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(fp, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, fp);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (p = 0; ; p += 5) {\n        if (fseek(fp, p, SEEK_SET) == -1) {\n    "
"        perror(\"fseek\");\n            exit(EXIT_FAILURE);\n        }\n      "
"  nread = fread(buf, 1, 2, fp);\n        if (nread == -1) {\n            "
"perror(\"fread\");\n            exit(EXIT_FAILURE);\n        }\n        if "
"(nread == 0) {\n            printf(\"Достигнут конец файла\\en\");\n          "
"  break;\n        }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:433
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"
msgstr "        printf(\"/%.*s/\\en\", nread, buf);\n    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:441
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"

#. type: TH
#: man-pages/man3/fgetpwent.3:33
#, no-wrap
msgid "FGETPWENT"
msgstr "FGETPWENT"

#. type: TH
#: man-pages/man3/fgetpwent.3:33
#, no-wrap
msgid "2013-04-19"
msgstr "2013-04-19"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:36
msgid "fgetpwent - get password file entry"
msgstr "fgetpwent - получает записи из файла паролей"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:41
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\nB<#include E<lt>sys/types.hE<gt>>\nB<#include "
"E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:43
#, no-wrap
msgid "B<struct passwd *fgetpwent(FILE *>I<stream>B<);>\n"
msgstr "B<struct passwd *fgetpwent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:52
msgid "B<fgetpwent>(): _SVID_SOURCE"
msgstr "B<fgetpwent>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:65
msgid ""
"The B<fgetpwent>()  function returns a pointer to a structure containing the"
" broken out fields of a line in the file I<stream>.  The first time it is "
"called it returns the first entry; thereafter, it returns successive "
"entries.  The file referred to by I<stream> must have the same format as "
"I</etc/passwd> (see B<passwd>(5))."
msgstr ""
"Функция B<fgetpwent>() возвращает указатель на структуру, содержащую "
"отдельные поля строки файла I<stream>. Во время первого вызова функция "
"возвращает первую запись; в дальнейшем она возвращает все последующие записи. "
"Формат файла I<stream> должен быть таким же как у I</etc/passwd> (смотрите B<"
"passwd>(5))."

#. type: Plain text
#: man-pages/man3/fgetpwent.3:67
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr "Структура I<passwd> определена в I<E<lt>pwd.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:79
#, no-wrap
msgid ""
"struct passwd {\n"
"    char   *pw_name;       /* username */\n"
"    char   *pw_passwd;     /* user password */\n"
"    uid_t   pw_uid;        /* user ID */\n"
"    gid_t   pw_gid;        /* group ID */\n"
"    char   *pw_gecos;      /* real name */\n"
"    char   *pw_dir;        /* home directory */\n"
"    char   *pw_shell;      /* shell program */\n"
"};\n"
msgstr ""
"struct passwd {\n    char   *pw_name;       /* имя пользователя */\n    char  "
" *pw_passwd;     /* пароль пользователя */\n    uid_t   pw_uid;        /* "
"идентификатор пользователя */\n    gid_t   pw_gid;        /* идентификатор "
"группы */\n    char   *pw_gecos;      /* настоящее имя */\n    char   "
"*pw_dir;        /* домашний каталог */\n    char   *pw_shell;      /* "
"программная оболочка */\n};\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:91
msgid ""
"The B<fgetpwent>()  function returns a pointer to a I<passwd> structure, or "
"NULL if there are no more entries or an error occurs.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<fgetpwent>() возвращает указатель на структуру I<passwd> или NULL, "
"если больше паролей не найдено или произошла ошибка. При ошибке I<errno> "
"присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fgetpwent.3:97
msgid "Insufficient memory to allocate I<passwd> structure."
msgstr "Недостаточно памяти для структуры I<passwd>."

#. type: TP
#: man-pages/man3/fgetpwent.3:98
#, no-wrap
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:101
msgid "password database file"
msgstr "файл, содержащий базу паролей"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:103
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man3/fgetpwent.3:113
msgid ""
"B<endpwent>(3), B<fgetpwent_r>(3), B<fopen>(3), B<getpw>(3), B<getpwent>(3),"
" B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), "
"B<passwd>(5)"
msgstr ""
"B<endpwent>(3), B<fgetpwent_r>(3), B<fopen>(3), B<getpw>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/fcloseall.3:25
#, no-wrap
msgid "FCLOSEALL"
msgstr "FCLOSEALL"

#. type: Plain text
#: man-pages/man3/fcloseall.3:28
msgid "fcloseall - close all open streams"
msgstr "fcloseall - закрытие всех открытых потоков"

#. type: Plain text
#: man-pages/man3/fcloseall.3:34
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr "B<int fcloseall(void);>\n"

#. type: Plain text
#: man-pages/man3/fcloseall.3:43
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as"
" for B<fflush>(3)); buffered input is discarded."
msgstr ""
"Функция B<fcloseall>() закрывает все открытые потоки вызвавшего процесса. "
"Перед закрытием буферизированный вывод каждого потока записывается (как с B<"
"fflush>(3)), а буферизированный ввод отбрасывается."

#. type: Plain text
#: man-pages/man3/fcloseall.3:50
msgid ""
"The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr ""
"Стандартные потоки, I<stdin>, I<stdout> и I<stderr>, также закрываются."

#. type: Plain text
#: man-pages/man3/fcloseall.3:55
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""
"Данная функция возвращает 0, если все файлы успешно закрыты, и B<EOF> в "
"случае ошибки."

#. type: Plain text
#: man-pages/man3/fcloseall.3:60
msgid ""
"The B<fcloseall>()  function does not lock the streams, so it is not thread-"
"safe."
msgstr ""
"Функция B<fcloseall>() не блокирует потоки, поэтому её нельзя использовать в "
"нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/fcloseall.3:62
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/fcloseall.3:67
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: man-pages/man3/fread.3:45
#, no-wrap
msgid "FREAD"
msgstr "FREAD"

#. type: TH
#: man-pages/man3/fread.3:45
#, no-wrap
msgid "2012-03-30"
msgstr "2012-03-30"

#. type: Plain text
#: man-pages/man3/fread.3:48
msgid "fread, fwrite - binary stream input/output"
msgstr "fread, fwrite - ввод/вывод из двоичного потока"

#. type: Plain text
#: man-pages/man3/fread.3:54
#, no-wrap
msgid ""
"B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""
"B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>"
"I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fread.3:57
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>"
"\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>"
"\nB<              FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fread.3:69
msgid ""
"The function B<fread>()  reads I<nmemb> elements of data, each I<size> bytes"
" long, from the stream pointed to by I<stream>, storing them at the location"
" given by I<ptr>."
msgstr ""
"Функция B<fread>() считывает элементы данных I<nmemb> (размер каждого I<size> "
"байт) из потока, на который указывает I<stream>, и сохраняет их в "
"расположение, на которое указывает I<ptr>."

#. type: Plain text
#: man-pages/man3/fread.3:80
msgid ""
"The function B<fwrite>()  writes I<nmemb> elements of data, each I<size> "
"bytes long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""
"Функция B<fwrite>() записывает элементы данных I<nmemb> (размер каждого I<"
"size> байт) в поток, на который указывает I<stream>, получая их из "
"расположения, на которое указывает I<ptr>."

#. type: Plain text
#: man-pages/man3/fread.3:83
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr "Неблокирующие аналоги смотрите в B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/fread.3:96
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of I<items> read "
"or written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""
"При успешном выполнении функции B<fread>() и B<fwrite>() возвращают "
"количество считанных или записанных I<элементов>. Это количество равно "
"количеству переданных байт только, если значение I<size> равно 1. В случае "
"ошибки или по достижении конца файла возвращается меньшее значение элементов "
"(или ноль)."

#. type: Plain text
#: man-pages/man3/fread.3:103
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""
"Функция B<fread>() не отличает возникновение ошибки и достижения конца файла; "
"для точного определения необходимо вызывать функции B<feof>(3) и B<ferror>(3)."

#. type: Plain text
#: man-pages/man3/fread.3:105
msgid "C89, POSIX.1-2001."
msgstr "C89, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fread.3:110
msgid "B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""
"B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fabs.3:32
#, no-wrap
msgid "FABS"
msgstr "FABS"

#. type: TH
#: man-pages/man3/fabs.3:32
#, no-wrap
msgid "2013-07-10"
msgstr "2013-07-10"

#. type: Plain text
#: man-pages/man3/fabs.3:35
msgid "fabs, fabsf, fabsl - absolute value of floating-point number"
msgstr ""
"fabs, fabsf, fabsl - вычисление абсолютного значения числа с плавающей точкой"

#. type: Plain text
#: man-pages/man3/fabs.3:40
#, no-wrap
msgid "B<double fabs(double >I<x>B<);>\n"
msgstr "B<double fabs(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fabs.3:42
#, no-wrap
msgid "B<float fabsf(float >I<x>B<);>\n"
msgstr "B<float fabsf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fabs.3:44
#, no-wrap
msgid "B<long double fabsl(long double >I<x>B<);>\n"
msgstr "B<long double fabsl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fabs.3:56
msgid "B<fabsf>(), B<fabsl>():"
msgstr "B<fabsf>(), B<fabsl>():"

#. type: Plain text
#: man-pages/man3/fabs.3:68
msgid ""
"These functions return the absolute value of the floating-point number I<x>."
msgstr ""
"Эти функции возвращают абсолютное значение числа с плавающей точкой I<x>."

#. type: Plain text
#: man-pages/man3/fabs.3:71
msgid "These functions return the absolute value of I<x>."
msgstr "Данные функции возвращают абсолютное значение I<x>."

#. type: Plain text
#: man-pages/man3/fabs.3:75
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fabs.3:79
msgid "If I<x> is -0, +0 is returned."
msgstr "Если I<x> стремится к -0, будет возвращено +0."

#. type: Plain text
#: man-pages/man3/fabs.3:83
msgid ""
"If I<x> is negative infinity or positive infinity, positive infinity is "
"returned."
msgstr ""
"Если I<x> стремится к минус или плюс бесконечности, будет возвращена плюс "
"бесконечность."

#. type: Plain text
#: man-pages/man3/fabs.3:93
msgid "The B<fabs>(), B<fabsf>(), and B<fabsl>()  functions are thread-safe."
msgstr ""
"Функции B<fabs>(), B<fabsf>() и B<fabsl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/fabs.3:105
msgid "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"
msgstr "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"

#. type: TH
#: man-pages/man3/ferror.3:44
#, no-wrap
msgid "FERROR"
msgstr "FERROR"

#. type: Plain text
#: man-pages/man3/ferror.3:47
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr "clearerr, feof, ferror, fileno - проверка и сброс состояния потока"

#. type: Plain text
#: man-pages/man3/ferror.3:51
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr "B<void clearerr(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:53
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr "B<int feof(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:55
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr "B<int ferror(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:57
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr "B<int fileno(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:65
msgid ""
"B<fileno>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<fileno>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/ferror.3:70
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""
"Функция B<clearerr>() очищает индикаторы конца файла и ошибки потока, "
"указанного в I<stream>."

#. type: Plain text
#: man-pages/man3/ferror.3:78
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can be cleared only by the function B<clearerr>()."
msgstr ""
"Функция B<feof>() проверяет индикатор конца файла для потока, указанного в I<"
"stream>, возвращая при этом ненулевое значение, если индикатор установлен. "
"Индикатор конца файла может быть очищен только функцией B<clearerr>()."

#. type: Plain text
#: man-pages/man3/ferror.3:87
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can be"
" reset only by the B<clearerr>()  function."
msgstr ""
"Функция B<ferror>() проверяет индикатор ошибки для потока, указанного в I<"
"stream>, возвращая при этом ненулевое значение, если индикатор установлен. "
"Индикатор ошибки может быть очищен только функцией B<clearerr>()."

#. type: Plain text
#: man-pages/man3/ferror.3:93
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns its "
"integer descriptor."
msgstr ""
"Функция B<fileno>() возвращает соответствующий аргументу I<stream> "
"целочисленный дескриптор."

#. type: Plain text
#: man-pages/man3/ferror.3:106
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a"
" valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""
"Данные функции не должны завершаться с ошибкой и поэтому не устанавливают "
"значение внешней переменной I<errno> (тем не менее, в случае с B<fileno>(), "
"если аргумент не является корректным потоком, возвращается -1 и I<errno> "
"приравнивается значение B<EBADF>)."

#. type: Plain text
#: man-pages/man3/ferror.3:115
msgid ""
"The B<clearerr>(), B<feof>(), B<ferror>(), and B<fileno>()  functions are "
"thread-safe."
msgstr ""
"Функции B<clearerr>(), B<feof>(), B<ferror>() и B<fileno>() можно "
"использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/ferror.3:122
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89, "
"C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""
"Функции B<clearerr>(), B<feof>() и B<ferror>() соответствует стандартам C89, "
"C99, POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/ferror.3:126
msgid "The function B<fileno>()  conforms to POSIX.1-2001 and POSIX.1-2008."
msgstr "Функция B<fileno>() соответствует POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/ferror.3:130
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fgetc.3:27
#, no-wrap
msgid "FGETC"
msgstr "FGETC"

#. type: TH
#: man-pages/man3/fgetc.3:27
#, no-wrap
msgid "2013-12-31"
msgstr "2013-12-31"

#. type: Plain text
#: man-pages/man3/fgetc.3:30
msgid "fgetc, fgets, getc, getchar, ungetc - input of characters and strings"
msgstr ""
"fgetc, fgets, getc, getchar, ungetc - функции для ввода символов и строк"

#. type: Plain text
#: man-pages/man3/fgetc.3:35
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr "B<int fgetc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:37
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:39
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr "B<int getc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:41
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr "B<int getchar(void);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""
"Функция B<fgetc>() считывает очередной символ из потока I<stream> и "
"возвращает I<unsigned char> преобразованный в I<int>, или B<EOF> при "
"достижении конца файла или при возникновении ошибки."

#. type: Plain text
#: man-pages/man3/fgetc.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as"
" a macro which evaluates I<stream> more than once."
msgstr ""
"Функция B<getc>() похожа на B<fgetc>(), но она может быть реализована как "
"макрос, который определяет состояние I<stream> более одного раза."

#. type: Plain text
#: man-pages/man3/fgetc.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr "Функция B<getchar>() эквивалентна B<getc(>I<stdin>B<)>."

#. type: Plain text
#: man-pages/man3/fgetc.3:80
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream>"
" and stores them into the buffer pointed to by I<s>.  Reading stops after an"
" B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  "
"A terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character"
" in the buffer."
msgstr ""
"Функция B<fgets>() считывает максимум I<size> -1 символов из I<stream> и "
"записывает их в буфер, на который указывает I<s>. Чтение прерывается по "
"достижении B<EOF> или символа новой строки. Если получен символ новой строки, "
"то он заносится в буфер. В конец буфера после последнего символа добавляется "
"завершающий байт null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/fgetc.3:91
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will"
" be returned in reverse order; only one pushback is guaranteed."
msgstr ""
"Функция B<ungetc>() заносит I<c> обратно в I<stream>, преобразует в I<"
"unsigned char>, если это возможно для дальнейших операций чтения. Занесённые "
"обратно символы будут возвращаться в обратном порядке; гарантируется только "
"одно занесение символов."

#. type: Plain text
#: man-pages/man3/fgetc.3:96
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""
"Вызовы функций, описанные здесь, могут смешиваться друг с другом и с другими "
"функциями ввода из библиотеки I<stdio> для того же потока ввода."

#. type: Plain text
#: man-pages/man3/fgetc.3:111
msgid ""
"B<fgetc>(), B<getc>()  and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""
"Функции B<fgetc>(), B<getc>() и B<getchar>() возвращают символ, считанный как "
"I<unsigned char> и преобразованный в I<int>, или B<EOF> по достижении конца "
"файла или при возникновении ошибки."

#. type: Plain text
#: man-pages/man3/fgetc.3:117
msgid ""
"B<fgets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read."
msgstr ""
"Функция B<fgets>() возвращает I<s> при удачном выполнении и NULL при ошибке "
"или если достигнут конец файла, а символы остались несчитанными."

#. type: Plain text
#: man-pages/man3/fgetc.3:124
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr ""
"При успешном выполнении функция B<ungetc>() возвращает I<c> или B<EOF> при "
"ошибке."

#. type: Plain text
#: man-pages/man3/fgetc.3:126
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fgetc.3:133
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""
"Не рекомендуется чередовать вызовы функций ввода библиотеки I<stdio> с "
"низкоуровневыми вызовами B<read>(2) для дескриптора файла, связанного с "
"потоком ввода; результат этого будет неопределённым и, скорее всего, не тем, "
"который ожидается."

#. type: Plain text
#: man-pages/man3/fgetc.3:149
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), B<fopen>"
"(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), B<getwchar>(3), B<"
"puts>(3), B<scanf>(3), B<ungetwc>(3), B<unlocked_stdio>(3), B<"
"feature_test_macros>(7)"

#. type: TH
#: man-pages/man3/fflush.3:45
#, no-wrap
msgid "FFLUSH"
msgstr "FFLUSH"

#. type: Plain text
#: man-pages/man3/fflush.3:48
msgid "fflush - flush a stream"
msgstr "fflush - сбрасывает поток"

#. type: Plain text
#: man-pages/man3/fflush.3:52
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr "B<int fflush(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fflush.3:63
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function.  For input streams, B<fflush>()  discards any buffered data "
"that has been fetched from the underlying file, but has not been consumed by"
" the application.  The open status of the stream is unaffected."
msgstr ""
"Для потоков вывода функция B<fflush>() принудительно записывает все "
"буферизированные в пользовательском пространстве данные в устройство вывода "
"данных или корректирует I<stream> посредством определённой для него функции "
"записи. Для потоков ввода функция B<fflush>() отбрасывает все "
"буферизированные данные, которые были получены из соответствующего файла, но "
"не обработаны приложением. При этом поток остается открытым."

#. type: Plain text
#: man-pages/man3/fflush.3:71
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""
"Если аргумент I<stream> равен NULL, то B<fflush>() сбрасывает данные всех "
"открытых потоков вывода."

#. type: Plain text
#: man-pages/man3/fflush.3:81
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and"
" I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении возвращается нулевое значение. В противном случае "
"возвращается B<EOF> и I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/fflush.3:86
msgid "I<Stream> is not an open stream, or is not open for writing."
msgstr "Поток I<stream> не открыт или не открыт для записи."

#. type: Plain text
#: man-pages/man3/fflush.3:93
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""
"Функция I<fflush>() может завершиться с ошибкой и присвоить I<errno> любое "
"значение из определённых для B<write>(2)."

#. type: Plain text
#: man-pages/man3/fflush.3:98
msgid "The B<fflush>()  function is thread-safe."
msgstr ""
"Функцию B<fflush>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/fflush.3:100
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C89, C99, POSIX.1-2001, POSIX.1-2008."

#.  Verified on: Solaris 8.
#. type: Plain text
#: man-pages/man3/fflush.3:104
msgid ""
"The standards do not specify the behavior for input streams.  Most other "
"implementations behave the same as Linux."
msgstr ""
"В стандартах не описано поведение для потоков ввода. Большинство других "
"реализаций работают также как Linux."

#. type: Plain text
#: man-pages/man3/fflush.3:113
msgid ""
"Note that B<fflush>()  only flushes the user-space buffers provided by the C"
" library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"Заметим, что B<fflush>() сбрасывает буферы только пользовательского "
"пространства, заданные библиотекой Си. Чтобы гарантировать, что данные "
"действительно физически сохранены на диске, буферы ядра также должны быть "
"сохранены, например, с помощью вызова B<sync>(2) или B<fsync>(2)."

#. type: Plain text
#: man-pages/man3/fflush.3:120
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fopen>(3), "
"B<setbuf>(3), B<unlocked_stdio>(3)"
msgstr ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fopen>(3), B<setbuf>"
"(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fputws.3:16
#, no-wrap
msgid "FPUTWS"
msgstr "FPUTWS"

#. type: Plain text
#: man-pages/man3/fputws.3:19
msgid "fputws - write a wide-character string to a FILE stream"
msgstr "fputws - записывает строку широких символов в поток FILE"

#. type: Plain text
#: man-pages/man3/fputws.3:24
#, no-wrap
msgid "B<int fputws(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputws(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fputws.3:34
msgid ""
"The B<fputws>()  function is the wide-character equivalent of the "
"B<fputs>(3)  function.  It writes the wide-character string starting at "
"I<ws>, up to but not including the terminating null wide character "
"(L\\(aq\\e0\\(aq), to I<stream>."
msgstr ""
"Функция B<fputws>() — эквивалент B<fputs>(3) для строк широких символов. Она "
"записывает строку широких символов, начинающуюся с I<ws> до, но не включая, "
"завершающего широкого символа null (L\\(aq\\e0\\(aq), в I<stream>."

#. type: Plain text
#: man-pages/man3/fputws.3:43
msgid ""
"The B<fputws>()  function returns a nonnegative integer if the operation was"
" successful, or -1 to indicate an error."
msgstr ""
"Функция B<fputws>() возвращает неотрицательное целое число, если операция "
"завершилась успешно, или -1 для обозначения ошибки."

#. type: Plain text
#: man-pages/man3/fputws.3:52
msgid ""
"The behavior of B<fputws>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fputws>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fputws.3:60
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fputws>()  will actually write the multibyte"
" string corresponding to the wide-character string I<ws>."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fputws>() на самом деле пишет многобайтовую "
"строку, соответствующую строке широких символов I<ws>."

#. type: Plain text
#: man-pages/man3/fputws.3:62
msgid "B<fputwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fputwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/ffs.3:33
#, no-wrap
msgid "FFS"
msgstr "FFS"

#. type: TH
#: man-pages/man3/ffs.3:33
#, no-wrap
msgid "2014-04-14"
msgstr "2014-04-14"

#. type: Plain text
#: man-pages/man3/ffs.3:36
msgid "ffs, ffsl, ffsll - find first bit set in a word"
msgstr "ffs, ffsl, ffsll - ищет первый установленный бит в слове"

#. type: Plain text
#: man-pages/man3/ffs.3:39
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr "B<#include E<lt>strings.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:41
#, no-wrap
msgid "B<int ffs(int >I<i>B<);>\n"
msgstr "B<int ffs(int >I<i>B<);>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:43
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:45
#, no-wrap
msgid "B<int ffsl(long int >I<i>B<);>\n"
msgstr "B<int ffsl(long int >I<i>B<);>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:47
#, no-wrap
msgid "B<int ffsll(long long int >I<i>B<);>\n"
msgstr "B<int ffsll(long long int >I<i>B<);>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:57
msgid "B<ffs>():"
msgstr "B<ffs>():"

#. type: TP
#: man-pages/man3/ffs.3:58
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ffs.3:62
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 700 ||"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 700 ||"

#. type: TP
#: man-pages/man3/ffs.3:62
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ffs.3:65
msgid "none"
msgstr "ни одного"

#. type: Plain text
#: man-pages/man3/ffs.3:69
msgid "B<ffsl>(), B<ffsll>():"
msgstr "B<ffsl>(), B<ffsll>():"

#. type: Plain text
#: man-pages/man3/ffs.3:87
msgid ""
"The B<ffs>()  function returns the position of the first (least significant)"
" bit set in the word I<i>.  The least significant bit is position 1 and the "
"most significant position is, for example, 32 or 64.  The functions "
"B<ffsll>()  and B<ffsl>()  do the same but take arguments of possibly "
"different size."
msgstr ""
"Функция B<ffs>() возвращает позицию первого (считая с наименее значимого) "
"установленного бита в слове I<i>. Наименее значимый бит находится в позиции "
"номер 1, а наиболее значимый — в позиции (как пример) номер 32 или 64. "
"Функции B<ffsll>() и B<ffsl>() делают то же самое, но имеют аргументы "
"возможно других размеров."

#. type: Plain text
#: man-pages/man3/ffs.3:91
msgid ""
"These functions return the position of the first bit set, or 0 if no bits "
"are set in I<i>."
msgstr ""
"Эти функции возвращают положение первого установленного бита или 0, если в I<"
"i> не установлено ни одного бита."

#. type: Plain text
#: man-pages/man3/ffs.3:99
msgid "The B<ffs>(), B<ffsl>(), and B<ffsll>()  functions are thread-safe."
msgstr ""
"Функции B<ffs>(), B<ffsl>() и B<ffsll>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/ffs.3:102
msgid "B<ffs>(): 4.3BSD, POSIX.1-2001."
msgstr "B<ffs>(): 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/ffs.3:108
msgid "The B<ffsl>()  and B<ffsll>()  functions are glibc extensions."
msgstr "Функции B<ffsl>() и B<ffsll>() являются расширениями glibc."

#. type: Plain text
#: man-pages/man3/ffs.3:111
msgid "BSD systems have a prototype in I<E<lt>string.hE<gt>>."
msgstr "В системах BSD прототип указан в I<E<lt>string.hE<gt>>."

#. type: Plain text
#: man-pages/man3/ffs.3:112
msgid "B<memchr>(3)"
msgstr "B<memchr>(3)"

#. type: TH
#: man-pages/man3/fmod.3:35
#, no-wrap
msgid "FMOD"
msgstr "FMOD"

#. type: TH
#: man-pages/man3/fmod.3:35
#, no-wrap
msgid "2012-03-15"
msgstr "2012-03-15"

#. type: Plain text
#: man-pages/man3/fmod.3:38
msgid "fmod, fmodf, fmodl - floating-point remainder function"
msgstr ""
"fmod, fmodf, fmodl - функция получения остатка от деления числа с плавающей "
"запятой"

#. type: Plain text
#: man-pages/man3/fmod.3:43
#, no-wrap
msgid "B<double fmod(double >I<x>B<, double >I<y>B<);>\n"
msgstr "B<double fmod(double >I<x>B<, double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmod.3:45
#, no-wrap
msgid "B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"
msgstr "B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmod.3:47
#, no-wrap
msgid "B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr "B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmod.3:59
msgid "B<fmodf>(), B<fmodl>():"
msgstr "B<fmodf>(), B<fmodl>():"

#. type: Plain text
#: man-pages/man3/fmod.3:87
msgid ""
"The B<fmod>()  function computes the floating-point remainder of dividing "
"I<x> by I<y>.  The return value is I<x> - I<n> * I<y>, where I<n> is the "
"quotient of I<x> / I<y>, rounded toward zero to an integer."
msgstr ""
"Функция B<fmod>() вычисляет остаток деления числа с плавающей запятой I<x> на "
"I<y>. Возвращаемое значение: I<x> - I<n> * I<y>, где I<n> — частное I<x> / I<"
"y>, округлённое к нулю до ближайшего целого числа."

#. type: Plain text
#: man-pages/man3/fmod.3:96
msgid ""
"On success, these functions return the value I<x>\\ -\\ I<n>*I<y>, for some "
"integer I<n>, such that the returned value has the same sign as I<x> and a "
"magnitude less than the magnitude of I<y>."
msgstr ""
"При успешном выполнении функции возвращают значение I<x>\\ -\\ I<n>*I<y> для "
"некоторого целого I<n>; при этом возвращаемое значение имеет тот же знак что "
"и I<x>, а абсолютное значение меньше абсолютного значения I<y>."

#. type: Plain text
#: man-pages/man3/fmod.3:108
msgid "If I<x> is an infinity, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> стремится к бесконечности, то будет сгенерирована ошибка выхода за "
"пределы области, а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fmod.3:114
msgid "If I<y> is zero, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<y> равно 0, то будет сгенерирована ошибка выхода за пределы области, а "
"в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fmod.3:120
msgid "If I<x> is +0 (-0), and I<y> is not zero, +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0) и I<y> не равно, то возвращается +0 (-0)."

#. type: TP
#: man-pages/man3/fmod.3:127
#, no-wrap
msgid "Domain error: I<x> is an infinity"
msgstr "Ошибка области: I<x> стремится к бесконечности"

#. type: Plain text
#: man-pages/man3/fmod.3:136
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM> (но см. ДЕФЕКТЫ). Возникает исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#. type: TP
#: man-pages/man3/fmod.3:136
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr "Ошибка области: I<y> равно 0"

#.  POSIX.1 documents an optional underflow error, but AFAICT it doesn't
#.  (can't?) occur -- mtk, Jul 2008
#. type: Plain text
#: man-pages/man3/fmod.3:146
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM>. Вызывается исключение неправильной "
"плавающей точки (B<FE_INVALID>)."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6784
#. type: Plain text
#: man-pages/man3/fmod.3:160
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred for an infinite I<x>."
msgstr ""
"До версии 2.10 в реализации glibc при возникновении ошибки области переменная "
"I<errno> не устанавливалась в значение B<EDOM> для бесконечного I<x>."

#. type: Plain text
#: man-pages/man3/fmod.3:161
msgid "B<remainder>(3)"
msgstr "B<remainder>(3)"

#. type: TH
#: man-pages/man3/ftw.3:35
#, no-wrap
msgid "FTW"
msgstr "FTW"

#. type: TH
#: man-pages/man3/ftw.3:35
#, no-wrap
msgid "2014-01-11"
msgstr "2014-01-11"

#. type: Plain text
#: man-pages/man3/ftw.3:38
msgid "ftw, nftw - file tree walk"
msgstr "ftw, nftw - обход файлового дерева"

#. type: Plain text
#: man-pages/man3/ftw.3:41
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr "B<#include E<lt>ftw.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:46
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>"
"B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""
"B<int ftw(const char *>I<dirpath>B<,>\nB<        int (*>I<fn>B<) (const char "
"*>I<fpath>B<, const struct stat *>I<sb>B<,>\nB<                   int >I<"
"typeflag>B<),>\nB<        int >I<nopenfd>B<);>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:49
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE 500>   /* See feature_test_macros(7) */\n"
"B<#include E<lt>ftw.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE 500>   /* смотрите feature_test_macros(7) */\nB<"
"#include E<lt>ftw.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>"
"B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int nftw(const char *>I<dirpath>B<,>\nB<        int (*>I<fn>B<) (const char "
"*>I<fpath>B<, const struct stat *>I<sb>B<,>\nB<                   int >I<"
"typeflag>B<, struct FTW *>I<ftwbuf>B<),>\nB<        int >I<nopenfd>B<, int >"
"I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:62
msgid ""
"B<ftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By"
" default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""
"Функция B<ftw>() обходит дерево каталогов, начиная с указанного в I<dirpath>, "
"и для каждого элемента дерева однократно вызывает I<fn>(). По умолчанию "
"каталоги обрабатываются раньше файлов и подкаталогов, которые в них "
"содержатся (предварительный обход)."

#. type: Plain text
#: man-pages/man3/ftw.3:75
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<ftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<ftw>()  will become "
"slower because directories have to be closed and reopened.  B<ftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""
"Чтобы избежать использования всех файловых дескрипторов вызывающего процесса, "
"в I<nopenfd> задаётся максимальное количество одновременно открываемых B<ftw>"
"() каталогов. Когда это количество превышается, работа B<ftw>() немного "
"замедляется, так как каталоги будут закрываться и снова открываться. Функция "
"B<ftw>() использует не более одного файлового дескриптора для работы с каждым "
"уровнем дерева каталогов."

#. type: Plain text
#: man-pages/man3/ftw.3:104
msgid ""
"For each entry found in the tree, B<ftw>()  calls I<fn>() with three "
"arguments: I<fpath>, I<sb>, and I<typeflag>.  I<fpath> is the pathname of "
"the entry, and is expressed either as a pathname relative to the calling "
"process's current working directory at the time of the call to B<ftw>(), if "
"I<dirpath> was expressed as a relative pathname, or as an absolute pathname,"
" if I<dirpath> was expressed as an absolute pathname.  I<sb> is a pointer to"
" the I<stat> structure returned by a call to B<stat>(2)  for I<fpath>.  "
"I<typeflag> is an integer that has one of the following values:"
msgstr ""
"Для каждого найденного элемента дерева B<ftw>() вызывает функцию B<fn>() с "
"тремя аргументами: I<fpath>, I<sb> и I<typeflag>. В I<fpath> указывается "
"полное имя элемента или в виде пути относительно рабочего каталога "
"вызывающего процесса на момент вызова B<ftw>() (если I<dirpath> указан в виде "
"относительного пути), или в виде абсолютного пути (если I<dirpath> указан в "
"виде абсолютного пути). В I<sb> задаётся указатель на структуру I<stat>, "
"возвращаемую вызовом B<stat>(2) для I<fpath>. В I<typeflag> указывается целое "
"число, которое может быть одним из следующих:"

#. type: TP
#: man-pages/man3/ftw.3:104
#, no-wrap
msgid "B<FTW_F>"
msgstr "B<FTW_F>"

#. type: Plain text
#: man-pages/man3/ftw.3:108
msgid "I<fpath> is a regular file."
msgstr "I<fpath> обычный файл"

#. type: TP
#: man-pages/man3/ftw.3:108
#, no-wrap
msgid "B<FTW_D>"
msgstr "B<FTW_D>"

#. type: Plain text
#: man-pages/man3/ftw.3:112
msgid "I<fpath> is a directory."
msgstr "I<fpath> каталог"

#. type: TP
#: man-pages/man3/ftw.3:112
#, no-wrap
msgid "B<FTW_DNR>"
msgstr "B<FTW_DNR>"

#. type: Plain text
#: man-pages/man3/ftw.3:116
msgid "I<fpath> is a directory which can't be read."
msgstr "I<fpath> каталог, который не может быть прочитан"

#. type: TP
#: man-pages/man3/ftw.3:116
#, no-wrap
msgid "B<FTW_NS>"
msgstr "B<FTW_NS>"

#. type: Plain text
#: man-pages/man3/ftw.3:130
msgid ""
"The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  The "
"probable cause for this is that the caller had read permission on the parent"
" directory, so that the filename I<fpath> could be seen, but did not have "
"execute permission, so that the file could not be reached for B<stat>(2)."
msgstr ""
"Вызов B<stat>(2) завершился с ошибкой для I<fpath>, который не является "
"символьной ссылкой. Вероятно, проблема в том, что вызывающий имеет право на "
"чтение родительского каталога, и поэтому файл с именем I<fpath> доступен, но "
"не имеет права выполнения, и поэтому файл недоступен для B<stat>(2)."

#. type: Plain text
#: man-pages/man3/ftw.3:139
msgid ""
"If I<fpath> is a symbolic link and B<stat>(2)  failed, POSIX.1-2001 states "
"that it is undefined whether B<FTW_NS> or B<FTW_SL> (see below)  is passed "
"in I<typeflag>."
msgstr ""
"Если I<fpath> — символьная ссылка и B<stat>(2) завершается с ошибкой, то в "
"POSIX.1-2001 сказано, что это неопределённая ситуация, вне зависимости от "
"того, указан ли B<FTW_NS> или B<FTW_SL> в I<typeflag> или нет."

#. type: Plain text
#: man-pages/man3/ftw.3:150
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<ftw>().  As long as I<fn>() returns 0, B<ftw>()"
"  will continue either until it has traversed the entire tree, in which case"
" it will return zero, or until it encounters an error (such as a "
"B<malloc>(3)  failure), in which case it will return -1."
msgstr ""
"Для остановки обхода дерева I<fn>() возвращает ненулевое значение; оно станет "
"возвращаемым значением для B<ftw>(). Пока I<fn>() возвращает 0, B<ftw>() "
"будет продолжать свой поиск до полного обхода дерева (в этом случае она "
"возвратит ноль), или пока не возникнет ошибка (например, из-за B<malloc>(3)). "
"В этом случае функция возвратит значение -1."

#. type: Plain text
#: man-pages/man3/ftw.3:160
msgid ""
"Because B<ftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler"
" set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr ""
"Так как B<ftw>() использует динамические структуры данных, то единственным "
"безопасным способом для выхода из процесса обхода дерева будет возврат "
"ненулевого значения из I<fn>(). Для завершения обхода по сигналу без утечек "
"памяти в обработчике нужно устанавливать глобальный флаг, проверяемый I<fn>"
"(). I<Не> используйте B<longjmp>(3) кроме как для завершения программы."

#. type: SS
#: man-pages/man3/ftw.3:160
#, no-wrap
msgid "nftw()"
msgstr "nftw()"

#. type: Plain text
#: man-pages/man3/ftw.3:167
msgid ""
"The function B<nftw>()  is the same as B<ftw>(), except that it has one "
"additional argument, I<flags>, and calls I<fn>() with one more argument, "
"I<ftwbuf>."
msgstr ""
"Функция B<nftw>() выполняет то же самое, что и B<ftw>(), но имеет ещё один "
"параметр, I<flags>, и вызывает I<fn>() ещё с одним параметром — I<ftwbuf>."

#. type: Plain text
#: man-pages/man3/ftw.3:170
msgid ""
"This I<flags> argument is formed by ORing zero or more of the following "
"flags:"
msgstr ""
"Значение аргумента I<flags> составляется логическим сложением 0 или "
"нескольких следующих флагов:"

#. type: TP
#: man-pages/man3/ftw.3:170
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr "B<FTW_ACTIONRETVAL> (начиная с glibc 2.3.3)"

#. type: Plain text
#: man-pages/man3/ftw.3:179
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value"
" from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""
"Если этот флаг, имеющийся только в glibc, не задан, то B<nftw>() по другому "
"обрабатывает полученное от I<fn>() значение. Вызов I<fn>() должен возвращать "
"одно из следующих значений:"

#. type: TP
#: man-pages/man3/ftw.3:180
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr "B<FTW_CONTINUE>"

#. type: Plain text
#: man-pages/man3/ftw.3:185
msgid "Instructs B<nftw>()  to continue normally."
msgstr "Указывает B<nftw>() продолжать обычную работу."

#. type: TP
#: man-pages/man3/ftw.3:185
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr "B<FTW_SKIP_SIBLINGS>"

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: man-pages/man3/ftw.3:193
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""
"При возврате этого значения родственные элементы пропускаются и продолжается "
"обход родителя."

#. type: TP
#: man-pages/man3/ftw.3:193
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr "B<FTW_SKIP_SUBTREE>"

#. type: Plain text
#: man-pages/man3/ftw.3:201
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from"
" being passed as arguments to I<fn>().  B<nftw>()  continues processing with"
" the next sibling of the directory."
msgstr ""
"Если I<fn>() вызывается для элемента, являющегося каталогом (I<typeflag> "
"равно B<FTW_D>), то объекты внутри каталога не будут переданы I<fn>() в "
"качестве аргументов. B<nftw>() продолжит обход со следующего родственного "
"элемента каталога."

#. type: TP
#: man-pages/man3/ftw.3:201
#, no-wrap
msgid "B<FTW_STOP>"
msgstr "B<FTW_STOP>"

#. type: Plain text
#: man-pages/man3/ftw.3:207
msgid ""
"Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr ""
"Заставляет B<nftw>() немедленно завершить работу со значением B<FTW_STOP>."

#. type: Plain text
#: man-pages/man3/ftw.3:210
msgid ""
"Other return values could be associated with new actions in the future; "
"I<fn>() should not return values other than those listed above."
msgstr ""
"В будущем могут появиться другие возвращаемые значения для новых действий; I<"
"fn>() не должна возвращать значений, отличных от перечисленных выше."

#. type: Plain text
#: man-pages/man3/ftw.3:219
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""
"Чтобы получить определение B<FTW_ACTIONRETVAL> из I<E<lt>ftw.hE<gt>>, должен "
"быть определён макрос тестирования свойств B<_GNU_SOURCE>."

#. type: TP
#: man-pages/man3/ftw.3:220
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr "B<FTW_CHDIR>"

#. type: Plain text
#: man-pages/man3/ftw.3:227
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides."
msgstr ""
"Если установлен этот флаг, то будет выполняться B<chdir>(2) для каждого "
"каталога перед обработкой его содержимого. Это полезно, если программе "
"требуется выполнить какое-то действие в каталоге, в котором расположен I<"
"fpath>."

#. type: TP
#: man-pages/man3/ftw.3:227
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr "B<FTW_DEPTH>"

#. type: Plain text
#: man-pages/man3/ftw.3:233
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""
"Если установлен этот флаг, то производить обход в обратном порядке, т.е. "
"вызывать I<fn>() для обработки самого каталога I<после> обработки содержимого "
"его подкаталогов (по умолчанию каждый каталог обрабатывается I<раньше> своего "
"содержимого)."

#. type: TP
#: man-pages/man3/ftw.3:233
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr "B<FTW_MOUNT>"

#. type: Plain text
#: man-pages/man3/ftw.3:237
msgid ""
"If set, stay within the same filesystem (i.e., do not cross mount points)."
msgstr ""
"Если установлен этот флаг, то оставаться в пределах одной файловой системы "
"(т.е. не переходить в другую точку монтирования)."

#. type: TP
#: man-pages/man3/ftw.3:237
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr "B<FTW_PHYS>"

#. type: Plain text
#: man-pages/man3/ftw.3:242
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set,"
" symbolic links are followed, but no file is reported twice."
msgstr ""
"Если установлен этот флаг, то не следовать по символьным ссылкам (то, что "
"обычно нужно). Если флаг не задан, то выполняется переход по символьным "
"ссылкам, но ни один файл не будет обработан дважды."

#. type: Plain text
#: man-pages/man3/ftw.3:247
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function "
"I<fn>()  is never called for a directory that would be a descendant of "
"itself."
msgstr ""
"Если B<FTW_PHYS> не задан, но задан B<FTW_DEPTH>, то функция I<fn>() никогда "
"не будет вызвана для каталога, который является потомком самого себя."

#. type: Plain text
#: man-pages/man3/ftw.3:262
msgid ""
"For each entry in the directory tree, B<nftw>()  calls I<fn>()  with four "
"arguments.  I<fpath> and I<sb> are as for B<ftw>().  I<typeflag> may receive"
" any of the same values as with B<ftw>(), or any of the following values:"
msgstr ""
"Для каждого элемента дерева каталогов функция B<nftw>() вызывает I<fn>() с "
"четырьмя параметрами. Аргументы I<fpath> и I<sb> те же, что и у B<ftw>(). "
"Аргумент I<typeflag> может иметь те же значения что и у B<ftw>(), или любое "
"из следующих значений:"

#. type: TP
#: man-pages/man3/ftw.3:262
#, no-wrap
msgid "B<FTW_DP>"
msgstr "B<FTW_DP>"

#. type: Plain text
#: man-pages/man3/ftw.3:276
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  (If "
"B<FTW_DEPTH> was not specified in I<flags>, then directories will always be "
"visited with I<typeflag> set to B<FTW_D>.)  All of the files and "
"subdirectories within I<fpath> have been processed."
msgstr ""
"I<fpath> является каталогом, и в I<flags> установлен B<FTW_DEPTH> (если B<"
"FTW_DEPTH> отсутствует в I<flags>, то каталоги всегда будут просматриваться с "
"I<typeflag> равным B<FTW_D>). Обработаны все файлы и подкаталоги в I<fpath>."

#. type: TP
#: man-pages/man3/ftw.3:276
#, no-wrap
msgid "B<FTW_SL>"
msgstr "B<FTW_SL>"

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: man-pages/man3/ftw.3:287
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""
"I<fpath> является символьной ссылкой и в I<flags> установлен B<FTW_PHYS>."

#. type: TP
#: man-pages/man3/ftw.3:287
#, no-wrap
msgid "B<FTW_SLN>"
msgstr "B<FTW_SLN>"

#. type: Plain text
#: man-pages/man3/ftw.3:292
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)"
msgstr ""
"I<fpath> является символьной ссылкой, указывающей на несуществующий файл (это "
"может произойти, только если не установлен флаг B<FTW_PHYS>)."

#. type: Plain text
#: man-pages/man3/ftw.3:298
msgid ""
"The fourth argument that B<nftw>()  supplies when calling I<fn>()  is a "
"structure of type I<FTW>:"
msgstr ""
"Четвёртый аргумент, передаваемый B<nftw>() при вызове I<fn>(), является "
"структурой типа I<FTW>:"

#. type: Plain text
#: man-pages/man3/ftw.3:305
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr "struct FTW {\n    int base;\n    int level;\n};\n"

#. type: Plain text
#: man-pages/man3/ftw.3:318
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""
"I<base> — смещение на имя файла (т.е. базовая часть) в пути, заданном в I<"
"fpath>.  I<level> — глубина I<fpath> в дереве каталогов относительно корня "
"дерева (I<dirpath> имеет глубину 0)."

#. type: Plain text
#: man-pages/man3/ftw.3:320
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr "При успешном выполнении эти функции возвращают 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/ftw.3:327
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""
"Если I<fn>() возвращает ненулевое значение, то обход дерева прекращается и "
"значение, полученное от I<fn>(), возвращается в качестве результата B<ftw>() "
"или B<nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:335
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""
"Если B<nftw>() вызывается с флагом B<FTW_ACTIONRETVAL>, то для прекращения "
"обхода дерева I<fn>() должна вернуть ненулевое значение B<FTW_STOP>, и это "
"значение возвращается в качестве результата B<nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:340
msgid "POSIX.1-2001, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as obsolete."
msgstr ""
"POSIX.1-2001, SVr4, SUSv1. В POSIX.1-2008 функция B<ftw>() помечена как "
"устаревшая."

#. type: Plain text
#: man-pages/man3/ftw.3:344
msgid ""
"POSIX.1-2001 note that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""
"В POSIX.1-2001 отмечено, что результат непредсказуем, если I<fn> не сохраняет "
"текущий рабочий каталог."

#. type: Plain text
#: man-pages/man3/ftw.3:350
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""
"Функция B<nftw>() и использование B<FTW_SL> с B<ftw>() впервые появились в "
"SUSv1."

#. type: Plain text
#: man-pages/man3/ftw.3:360
msgid ""
"On some systems B<ftw>()  will never use B<FTW_SL>, on other systems "
"B<FTW_SL> occurs only for symbolic links that do not point to an existing "
"file, and again on other systems B<ftw>()  will use B<FTW_SL> for each "
"symbolic link.  For predictable control, use B<nftw>()."
msgstr ""
"В некоторых системах B<ftw>() никогда не использует B<FTW_SL>, в других B<"
"FTW_SL> используется только для символьных ссылок, которые не указывают на "
"существующий файл, а ещё есть системы, в которых B<ftw>() использует B<FTW_SL>"
" для каждой символьной ссылки. Для предсказуемого результата используйте B<"
"nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:364
msgid ""
"Under Linux, libc4 and libc5 and glibc 2.0.6 will use B<FTW_F> for all "
"objects (files, symbolic links, FIFOs, etc.)  that can be stat'ed but are "
"not a directory."
msgstr ""
"В Linux libc4, libc5 и glibc 2.0.6 значение B<FTW_F> используется при работе "
"со всеми объектами (файлами, символьными ссылками, FIFO и т.п.), для которых "
"можно вызвать stat, но которые не являются каталогами."

#. type: Plain text
#: man-pages/man3/ftw.3:368
msgid "The function B<nftw>()  is available since glibc 2.1."
msgstr "Функция B<nftw>() доступна в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/ftw.3:370
msgid "B<FTW_ACTIONRETVAL> is glibc-specific."
msgstr "Флаг B<FTW_ACTIONRETVAL> есть только в glibc."

#. type: Plain text
#: man-pages/man3/ftw.3:379
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The"
" second command-line argument can be used to specify characters that control"
" the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""
"Следующая программа обходит дерево каталогов начиная с пути, указанном в "
"первом аргументе командой строки или начиная с текущего каталога, если "
"аргумент не указан. Она отображает различную информацию о каждом файле. Во "
"втором параметре можно указать символы, которые управляют содержимым "
"аргумента I<flags> у B<nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:387
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE 500\n#include E<lt>ftw.hE<gt>\n#include E<lt>stdio.hE<"
"gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>"
"stdint.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:401
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d %7jd   %-40s %d %s\\en\",\n"
"        (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"        (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"        (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"        (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"        ftwbuf-E<gt>level, (intmax_t) sb-E<gt>st_size,\n"
"        fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""
"static int\ndisplay_info(const char *fpath, const struct stat *sb,\n          "
"   int tflag, struct FTW *ftwbuf)\n{\n    printf(\"%-3s %2d %7jd   %-40s %d %"
"s\\en\",\n        (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" "
":\n        (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n      "
"  (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n        "
"(tflag == FTW_SLN) ? \"sln\" : \"???\",\n        ftwbuf-E<gt>level, "
"(intmax_t) sb-E<gt>st_size,\n        fpath, ftwbuf-E<gt>base, fpath + "
"ftwbuf-E<gt>base);\n    return 0;           /* указать nftw() продолжать "
"*/\n}\n"

#. type: Plain text
#: man-pages/man3/ftw.3:406
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int flags = 0;\n"

#. type: Plain text
#: man-pages/man3/ftw.3:411
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n        flags "
"|= FTW_DEPTH;\n    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != "
"NULL)\n        flags |= FTW_PHYS;\n"

#. type: Plain text
#: man-pages/man3/ftw.3:419
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n     "
"       == -1) {\n        perror(\"nftw\");\n        exit(EXIT_FAILURE);\n    "
"}\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/ftw.3:423
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr "B<stat>(2), B<fts>(3), B<readdir>(3)"

#. type: TH
#: man-pages/man3/fseeko.3:25
#, no-wrap
msgid "FSEEKO"
msgstr "FSEEKO"

#. type: Plain text
#: man-pages/man3/fseeko.3:28
msgid "fseeko, ftello - seek to or report file position"
msgstr "fseeko, ftello - изменить или сообщить положение в файле"

#. type: Plain text
#: man-pages/man3/fseeko.3:33
#, no-wrap
msgid ""
"B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""
"B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: man-pages/man3/fseeko.3:36
#, no-wrap
msgid ""
"B<off_t ftello(FILE *>I<stream>B<);>\n"
"\n"
msgstr "B<off_t ftello(FILE *>I<stream>B<);>\n\n"

#. type: Plain text
#: man-pages/man3/fseeko.3:45
msgid "B<fseeko>(), B<ftello>():"
msgstr "B<fseeko>(), B<ftello>():"

#. type: Plain text
#: man-pages/man3/fseeko.3:50
msgid ""
"_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr ""
"_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/fseeko.3:52
msgid "(defining the obsolete _LARGEFILE_SOURCE macro also works)"
msgstr "(с определением устаревшего макроса _LARGEFILE_SOURCE также сработает)"

#. type: Plain text
#: man-pages/man3/fseeko.3:75
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""
"Функции B<fseeko>() и B<ftello>() идентичны функциям B<fseek>(3) и B<ftell>"
"(3) (смотрите B<fseek>(3)), соответственно, за исключением того, что аргумент "
"I<offset> функции B<fseeko>() и возвращаемое значение функции B<ftello>() "
"вместо типа I<long> имеют тип I<off_t>."

#. type: Plain text
#: man-pages/man3/fseeko.3:82
msgid ""
"On many architectures both I<off_t> and I<long> are 32-bit types, but "
"compilation with"
msgstr ""
"На многих архитектурах I<off_t> и I<long> являются 32-битным типами, но при "
"компиляции с"

#. type: Plain text
#: man-pages/man3/fseeko.3:86
#, no-wrap
msgid "#define _FILE_OFFSET_BITS 64\n"
msgstr "#define _FILE_OFFSET_BITS 64\n"

#. type: Plain text
#: man-pages/man3/fseeko.3:92
msgid "will turn I<off_t> into a 64-bit type."
msgstr "тип I<off_t> становится 64-битным."

#. type: Plain text
#: man-pages/man3/fseeko.3:101
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns"
" the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"При успешном выполнении B<fseeko>() возвращает 0, B<ftello>() возвращает "
"текущее смещение. При ошибке возвращается -1, а в I<errno> содержится код "
"ошибки."

#. type: Plain text
#: man-pages/man3/fseeko.3:104
msgid "See the ERRORS in B<fseek>(3)."
msgstr "Смотрите ОШИБКИ в B<fseek>(3)."

#. type: Plain text
#: man-pages/man3/fseeko.3:106
msgid "SUSv2, POSIX.1-2001."
msgstr "SUSv2, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fseeko.3:110
msgid ""
"These functions are found on System V-like systems.  They are not present in"
" libc4, libc5, glibc 2.0 but are available since glibc 2.1."
msgstr ""
"Эти функции можно найти на System V-подобных системах. Они отсутствуют в "
"libc4, libc5 и glibc 2.0, но появились в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/fseeko.3:111
msgid "B<fseek>(3)"
msgstr "B<fseek>(3)"

#. type: TH
#: man-pages/man3/fgetwc.3:18
#, no-wrap
msgid "FGETWC"
msgstr "FGETWC"

#. type: Plain text
#: man-pages/man3/fgetwc.3:21
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr "fgetwc, getwc - считывает широкий символ из потока FILE"

#. type: Plain text
#: man-pages/man3/fgetwc.3:29
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\nB<wint_t getwc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetwc.3:44
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the "
"B<fgetc>(3)  function.  It reads a wide character from I<stream> and returns"
" it.  If the end of stream is reached, or if I<ferror(stream)> becomes true,"
" it returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""
"Функция B<fgetwc>() — это эквивалент функции B<fgetc>(3), но для широких "
"символов. Она читает широкий символ из I<stream> и возвращает его. Если "
"достигнут конец потока или значение I<ferror(stream)> истинно, то функция "
"возвращает B<WEOF>. Если при преобразовании в широкий символ возникает "
"ошибка, то значение переменной I<errno> устанавливается равным B<EILSEQ> и "
"возвращается B<WEOF>."

#. type: Plain text
#: man-pages/man3/fgetwc.3:52
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than once."
"  There is no reason ever to use it."
msgstr ""
"Функция B<getwc>() — это функция, или макрос, идентичный B<fgetwc>(). Она "
"может быть реализована в виде макроса, и может вычислять свой аргумент более "
"одного раза. Вообще нет смысла использовать эту функцию."

#. type: Plain text
#: man-pages/man3/fgetwc.3:64
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>.  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr ""
"Функция B<fgetwc>() возвращает следующий широкий символ из потока или B<WEOF>"
". При ошибке в I<errno> записывается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fgetwc.3:66
msgid "Apart from the usual ones, there is"
msgstr "Кроме обычных могут возникать:"

#. type: TP
#: man-pages/man3/fgetwc.3:66
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: man-pages/man3/fgetwc.3:70
msgid ""
"The data obtained from the input stream does not form a valid character."
msgstr ""
"Данные, полученные из входного потока, не содержат корректного символа."

#. type: Plain text
#: man-pages/man3/fgetwc.3:79
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fgetwc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fgetwc.3:87
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fgetwc>() на самом деле читает многобайтовую "
"последовательность из потока, а затем преобразует её в широкий символ."

#. type: Plain text
#: man-pages/man3/fgetwc.3:91
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fpathconf.3:41
#, no-wrap
msgid "FPATHCONF"
msgstr "FPATHCONF"

#. type: Plain text
#: man-pages/man3/fpathconf.3:44
msgid "fpathconf, pathconf - get configuration values for files"
msgstr "fpathconf, pathconf - получают параметры настроек для файлов"

#. type: Plain text
#: man-pages/man3/fpathconf.3:49
#, no-wrap
msgid "B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
msgstr "B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpathconf.3:51
#, no-wrap
msgid "B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"
msgstr "B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpathconf.3:58
msgid ""
"B<fpathconf>()  gets a value for the configuration option I<name> for the "
"open file descriptor I<fd>."
msgstr ""
"B<fpathconf>() получает значение параметра настроек I<name> для открытого "
"дескриптора файла I<fd>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:64
msgid ""
"B<pathconf>()  gets a value for configuration option I<name> for the "
"filename I<path>."
msgstr ""
"B<pathconf>() получает значение параметра настроек I<name> для файла с именем "
"I<path>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:73
msgid ""
"The corresponding macros defined in I<E<lt>unistd.hE<gt>> are minimum "
"values; if an application wants to take advantage of values which may "
"change, a call to B<fpathconf>()  or B<pathconf>()  can be made, which may "
"yield more liberal results."
msgstr ""
"Соответствующие макросы, определённые в I<E<lt>unistd.hE<gt>>, выдают "
"минимальные значения; если приложение собирается использовать изменяющиеся "
"значения, то необходимо вызывать функции B<fpathconf>() или B<pathconf>(), "
"которые выдают более гибкий результат."

#. type: Plain text
#: man-pages/man3/fpathconf.3:78
msgid ""
"Setting I<name> equal to one of the following constants returns the "
"following configuration options:"
msgstr ""
"При установке значения I<name> в следующие константы возвращаются "
"соответствующие им параметры настройки:"

#. type: TP
#: man-pages/man3/fpathconf.3:78
#, no-wrap
msgid "B<_PC_LINK_MAX>"
msgstr "B<_PC_LINK_MAX>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:88
msgid ""
"returns the maximum number of links to the file.  If I<fd> or I<path> refer "
"to a directory, then the value applies to the whole directory.  The "
"corresponding macro is B<_POSIX_LINK_MAX>."
msgstr ""
"Возвращает максимальное количество ссылок на файл. Если I<fd> или I<path> "
"указывают на каталог, то значение применяется ко всему каталогу. "
"Соответствует макросу B<_POSIX_LINK_MAX>."

#. type: TP
#: man-pages/man3/fpathconf.3:88
#, no-wrap
msgid "B<_PC_MAX_CANON>"
msgstr "B<_PC_MAX_CANON>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:97
msgid ""
"returns the maximum length of a formatted input line, where I<fd> or I<path>"
" must refer to a terminal.  The corresponding macro is B<_POSIX_MAX_CANON>."
msgstr ""
"Возвращает максимальную длину отформатированной строки ввода, причём, I<fd> "
"или I<path> должны указывать на терминал. Соответствует макросу B<"
"_POSIX_MAX_CANON>."

#. type: TP
#: man-pages/man3/fpathconf.3:97
#, no-wrap
msgid "B<_PC_MAX_INPUT>"
msgstr "B<_PC_MAX_INPUT>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:106
msgid ""
"returns the maximum length of an input line, where I<fd> or I<path> must "
"refer to a terminal.  The corresponding macro is B<_POSIX_MAX_INPUT>."
msgstr ""
"Возвращает максимальную длину строки ввода, причём, I<fd> или I<path> должны "
"указывать на терминал. Соответствует макросу B<_POSIX_MAX_INPUT>."

#. type: TP
#: man-pages/man3/fpathconf.3:106
#, no-wrap
msgid "B<_PC_NAME_MAX>"
msgstr "B<_PC_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:115
msgid ""
"returns the maximum length of a filename in the directory I<path> or I<fd> "
"that the process is allowed to create.  The corresponding macro is "
"B<_POSIX_NAME_MAX>."
msgstr ""
"Возвращает максимальную длину имени файла в каталоге I<path> или I<fd>, "
"которую разрешено использовать процессу при создании файла. Соответствует "
"макросу B<_POSIX_NAME_MAX>."

#. type: TP
#: man-pages/man3/fpathconf.3:115
#, no-wrap
msgid "B<_PC_PATH_MAX>"
msgstr "B<_PC_PATH_MAX>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:124
msgid ""
"returns the maximum length of a relative pathname when I<path> or I<fd> is "
"the current working directory.  The corresponding macro is "
"B<_POSIX_PATH_MAX>."
msgstr ""
"Возвращает максимальную длину относительного имени файла, где I<path> или I<"
"fd> являются текущим рабочим каталогом. Соответствует макросу B<"
"_POSIX_PATH_MAX>."

#. type: TP
#: man-pages/man3/fpathconf.3:124
#, no-wrap
msgid "B<_PC_PIPE_BUF>"
msgstr "B<_PC_PIPE_BUF>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:133
msgid ""
"returns the size of the pipe buffer, where I<fd> must refer to a pipe or "
"FIFO and I<path> must refer to a FIFO.  The corresponding macro is "
"B<_POSIX_PIPE_BUF>."
msgstr ""
"Возвращает размер буфера канала, где значение I<fd> должно указывать на канал "
"или FIFO, и I<path> должно указывать на FIFO. Соответствует макросу B<"
"_POSIX_PIPE_BUF>."

#. type: TP
#: man-pages/man3/fpathconf.3:133
#, no-wrap
msgid "B<_PC_CHOWN_RESTRICTED>"
msgstr "B<_PC_CHOWN_RESTRICTED>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:146
msgid ""
"returns nonzero if the B<chown>(2)  call may not be used on this file.  If "
"I<fd> or I<path> refer to a directory, then this applies to all files in "
"that directory.  The corresponding macro is B<_POSIX_CHOWN_RESTRICTED>."
msgstr ""
"Возвращает ненулевое значение, если для этого файла невозможен вызов B<chown>"
"(2). Если I<fd> или I<path> указывают на каталог, то это относится ко всем "
"файлам в этом каталоге. Соответствует макросу B<_POSIX_CHOWN_RESTRICTED>."

#. type: TP
#: man-pages/man3/fpathconf.3:146
#, no-wrap
msgid "B<_PC_NO_TRUNC>"
msgstr "B<_PC_NO_TRUNC>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:153
msgid ""
"returns nonzero if accessing filenames longer than B<_POSIX_NAME_MAX> "
"generates an error.  The corresponding macro is B<_POSIX_NO_TRUNC>."
msgstr ""
"Возвращает ненулевое значение, если при доступе к файловым именам длиннее, "
"чем B<_POSIX_NAME_MAX>, возникает ошибка. Соответствует макросу B<"
"_POSIX_NO_TRUNC>."

#. type: TP
#: man-pages/man3/fpathconf.3:153
#, no-wrap
msgid "B<_PC_VDISABLE>"
msgstr "B<_PC_VDISABLE>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:160
msgid ""
"returns nonzero if special character processing can be disabled, where I<fd>"
" or I<path> must refer to a terminal."
msgstr ""
"Возвращает ненулевое значение, если обработка спецсимволов может быть "
"отключена, при этом I<fd> или I<path> должны указывать на терминал."

#. type: Plain text
#: man-pages/man3/fpathconf.3:169
msgid ""
"The limit is returned, if one exists.  If the system does not have a limit "
"for the requested resource, -1 is returned, and I<errno> is unchanged.  If "
"there is an error, -1 is returned, and I<errno> is set to reflect the nature"
" of the error."
msgstr ""
"Возвращается ограничение, если таковое существует. Если система не имеет "
"ограничения на запрашиваемый ресурс, то возвращается -1 и переменная I<errno> "
"не изменяется. Если есть ошибка, то возвращается -1, и в переменную I<errno> "
"записывается код ошибки."

#. type: Plain text
#: man-pages/man3/fpathconf.3:177
msgid ""
"Files with name lengths longer than the value returned for I<name> equal to "
"B<_PC_NAME_MAX> may exist in the given directory."
msgstr ""
"Файлы, имена которых длиннее, чем значение, возвращаемое для I<name> и равны "
"B<_PC_NAME_MAX>, могут существовать в заданном каталоге."

#. type: Plain text
#: man-pages/man3/fpathconf.3:180
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""
"Некоторые возвращаемые значения могут быть огромны; соответствующие им "
"объекты невозможно разместить в памяти."

#. type: Plain text
#: man-pages/man3/fpathconf.3:185
msgid "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"
msgstr "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"

#. type: TH
#: man-pages/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr "FTS"

#. type: TH
#: man-pages/man3/fts.3:40
#, no-wrap
msgid "2014-03-18"
msgstr "2014-03-18"

#. type: Plain text
#: man-pages/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - обход файловой "
"иерархии"

#. type: Plain text
#: man-pages/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/stat.hE<gt>>\nB<"
"#include E<lt>fts.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\nB<       "
"       int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"

#. type: Plain text
#: man-pages/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<options>B<);>\n"
msgstr "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<options>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<options>B<);>\n"
msgstr "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<options>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr "B<int fts_close(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:87
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" on a file "
"hierarchy, which is then supplied to the other fts functions.  The function "
"B<fts_read>()  returns a pointer to a structure describing one of the files "
"in the file hierarchy.  The function B<fts_children>()  returns a pointer to"
" a linked list of structures, each of which describes one of the files "
"contained in a directory in the hierarchy.  In general, directories are "
"visited two distinguishable times; in preorder (before any of their "
"descendants are visited) and in postorder (after all of their descendants "
"have been visited).  Files are visited once.  It is possible to walk the "
"hierarchy \"logically\" (visiting the files that symbolic links point to)  "
"or physically (visiting the symbolic links themselves), order the walk of "
"the hierarchy or prune and/or revisit portions of the hierarchy."
msgstr ""
"Функции fts созданы для обхода файловой иерархии. Обзорное описание: функция "
"B<fts_open>() возвращает «описатель» файловой иерархии, который затем "
"используется другими функциями fts. Функция B<fts_read>() возвращает "
"указатель на структуру, описывающую один из файлов в файловой иерархии. "
"Функция B<fts_children>() возвращает указатель на связанный список структур, "
"каждая из которых описывает один из файлов, содержащихся в каталоге иерархии. "
"В общем случае, каталоги обходятся двумя разными путями — в прямом порядке "
"(перед тем, как обработаны их потомки), и в обратном порядке (после того, как "
"обработаны все потомки). Файлы обрабатываются только один раз. Возможен "
"«логический» обход иерархии, когда игнорируются символьные ссылки, и "
"«физический», когда осуществляется следование по символьным ссылкам; также "
"следование можно упорядочить, или осуществлять перемещения беспорядочно, по "
"частям."

#. type: Plain text
#: man-pages/man3/fts.3:108
msgid ""
"Two structures are defined (and typedef'd) in the include file "
"I<E<lt>fts.hE<gt>>.  The first is I<FTS>, the structure that represents the "
"file hierarchy itself.  The second is I<FTSENT>, the structure that "
"represents a file in the file hierarchy.  Normally, an I<FTSENT> structure "
"is returned for every file in the file hierarchy.  In this manual page, "
"\"file\" and \"FTSENT structure\" are generally interchangeable.  The "
"I<FTSENT> structure contains at least the following fields, which are "
"described in greater detail below:"
msgstr ""
"В файле I<E<lt>fts.hE<gt>> определены две структуры (через typedef). Первая — "
"структура I<FTS>, представляющая саму иерархию файлов. Вторая — структура I<"
"FTSENT>, представляющая файл в иерархии файлов. Обычно, структура I<FTSENT> "
"возвращается для каждого файла в файловой иерархии. В этой справочной "
"странице понятия «файл» и «структура FTSENT» взаимозаменяемы. Структура I<"
"FTSENT> содержит, по меньшей мере, следующие поля (подробно описаны ниже):"

#. type: Plain text
#: man-pages/man3/fts.3:127
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short fts_info;     /* flags for FTSENT structure */\n"
"    char          *fts_accpath;  /* access path */\n"
"    char          *fts_path;     /* root path */\n"
"    short          fts_pathlen;  /* strlen(fts_path) */\n"
"    char          *fts_name;     /* filename */\n"
"    short          fts_namelen;  /* strlen(fts_name) */\n"
"    short          fts_level;    /* depth (-1 to N) */\n"
"    int            fts_errno;    /* file errno */\n"
"    long           fts_number;   /* local numeric value */\n"
"    void          *fts_pointer;  /* local address value */\n"
"    struct ftsent *fts_parent;   /* parent directory */\n"
"    struct ftsent *fts_link;     /* next file structure */\n"
"    struct ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat   *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""
"typedef struct _ftsent {\n    unsigned short fts_info;     /* флаги для "
"структуры FTSENT */\n    char          *fts_accpath;  /* путь доступа */\n    "
"char          *fts_path;     /* начальный путь */\n    short          "
"fts_pathlen;  /* strlen(fts_path) */\n    char          *fts_name;     /* имя "
"файла */\n    short          fts_namelen;  /* strlen(fts_name) */\n    short  "
"        fts_level;    /* глубина (от -1 до N) */\n    int            "
"fts_errno;    /* файловый errno */\n    long           fts_number;   /*  "
"локальное числовое значение */\n    void          *fts_pointer;  /* локальное "
"значение адреса */\n    struct ftsent *fts_parent;   /* родительский каталог "
"*/\n    struct ftsent *fts_link;     /* структура следующего файла */\n    "
"struct ftsent *fts_cycle;    /* циклическая структура */\n    struct stat   "
"*fts_statp;    /* информация stat(2) */\n} FTSENT;\n"

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: man-pages/man3/fts.3:132
msgid "These fields are defined as follows:"
msgstr "Эти поля определены следующим образом:"

#. type: TP
#: man-pages/man3/fts.3:132
#, no-wrap
msgid "I<fts_info>"
msgstr "I<fts_info>"

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: man-pages/man3/fts.3:144
msgid ""
"One of the following flags describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""
"Один из следующих флагов описывает возвращённое значение структуры I<FTSENT> "
"и файла, который она представляет. За исключением каталогов без ошибок (B<"
"FTS_D>), все эти элементы являются конечными, то есть они не будут повторно "
"обходиться, а их потомки не будут обходиться вообще."

#. type: TP
#: man-pages/man3/fts.3:145
#, no-wrap
msgid "B<FTS_D>"
msgstr "B<FTS_D>"

#. type: Plain text
#: man-pages/man3/fts.3:148
msgid "A directory being visited in preorder."
msgstr "Каталог, посещаемый в прямом порядке."

#. type: TP
#: man-pages/man3/fts.3:148
#, no-wrap
msgid "B<FTS_DC>"
msgstr "B<FTS_DC>"

#. type: Plain text
#: man-pages/man3/fts.3:156
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the"
" I<FTSENT> structure will be filled in as well.)"
msgstr ""
"Каталог, вызвавший зацикливание в дереве (также будет заполнено поле I<"
"fts_cycle> структуры I<FTSENT>)."

#. type: TP
#: man-pages/man3/fts.3:156
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr "B<FTS_DEFAULT>"

#. type: Plain text
#: man-pages/man3/fts.3:164
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described"
" by one of the other I<fts_info> values."
msgstr ""
"Любая структура I<FTSENT>, представляющая тип файла, неявно описываемый одним "
"из других значений I<fts_info>."

#. type: TP
#: man-pages/man3/fts.3:164
#, no-wrap
msgid "B<FTS_DNR>"
msgstr "B<FTS_DNR>"

#. type: Plain text
#: man-pages/man3/fts.3:170
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"Каталог, который не может быть прочитан. Это значение возвращается при "
"ошибке, и поле I<fts_errno> будет заполнено тем, что вызвало ошибку."

#. type: TP
#: man-pages/man3/fts.3:170
#, no-wrap
msgid "B<FTS_DOT>"
msgstr "B<FTS_DOT>"

#. type: Plain text
#: man-pages/man3/fts.3:180
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""
"Файл с именем «.» или «..», который не был указан в качестве имени файла в B<"
"fts_open>() (смотрите B<FTS_SEEDOT>)."

#. type: TP
#: man-pages/man3/fts.3:180
#, no-wrap
msgid "B<FTS_DP>"
msgstr "B<FTS_DP>"

#. type: Plain text
#: man-pages/man3/fts.3:190
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""
"Каталог, посещаемый в обратном порядке. Содержимое структуры I<FTSENT> будет "
"неизменно, как если бы он посещался в прямом порядке, то есть значение поля "
"I<fts_info> равно B<FTS_D>."

#. type: TP
#: man-pages/man3/fts.3:190
#, no-wrap
msgid "B<FTS_ERR>"
msgstr "B<FTS_ERR>"

#. type: Plain text
#: man-pages/man3/fts.3:195
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""
"Это значение возвращается при ошибке, и поле I<fts_errno> будет заполнено "
"тем, что вызвало ошибку."

#. type: TP
#: man-pages/man3/fts.3:195
#, no-wrap
msgid "B<FTS_F>"
msgstr "B<FTS_F>"

#. type: Plain text
#: man-pages/man3/fts.3:198
msgid "A regular file."
msgstr "Обычный файл."

#. type: TP
#: man-pages/man3/fts.3:198
#, no-wrap
msgid "B<FTS_NS>"
msgstr "B<FTS_NS>"

#. type: Plain text
#: man-pages/man3/fts.3:209
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"Файл, для которого нет доступной информации по B<stat>(2). Содержимое поля I<"
"fts_statp> не определено. Это значение возвращается при ошибке, и поле I<"
"fts_errno> будет заполнено тем, что вызвало ошибку."

#. type: TP
#: man-pages/man3/fts.3:209
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr "B<FTS_NSOK>"

#. type: Plain text
#: man-pages/man3/fts.3:217
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""
"Файл, для которого не запрашивалась информация с помощью B<stat>(2). "
"Содержимое поля I<fts_statp> не определено."

#. type: TP
#: man-pages/man3/fts.3:217
#, no-wrap
msgid "B<FTS_SL>"
msgstr "B<FTS_SL>"

#. type: Plain text
#: man-pages/man3/fts.3:220
msgid "A symbolic link."
msgstr "Символьная ссылка."

#. type: TP
#: man-pages/man3/fts.3:220
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr "B<FTS_SLNONE>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:228
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp>"
" field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""
"Символьная ссылка, указывающая на несуществующий объект. В поле I<fts_statp> "
"содержится ссылка на информацию о свойствах самой символьной ссылки."

#. type: TP
#: man-pages/man3/fts.3:229
#, no-wrap
msgid "I<fts_accpath>"
msgstr "I<fts_accpath>"

#. type: Plain text
#: man-pages/man3/fts.3:232
msgid "A path for accessing the file from the current directory."
msgstr "Путь к файлу относительно текущего каталога."

#. type: TP
#: man-pages/man3/fts.3:232
#, no-wrap
msgid "I<fts_path>"
msgstr "I<fts_path>"

#. type: Plain text
#: man-pages/man3/fts.3:238
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""
"Путь к файлу относительно начального каталога обхода. Этот путь содержит в "
"себе путь (как префикс), указанный в B<fts_open>()."

#. type: TP
#: man-pages/man3/fts.3:238
#, no-wrap
msgid "I<fts_pathlen>"
msgstr "I<fts_pathlen>"

#. type: Plain text
#: man-pages/man3/fts.3:242
msgid "The length of the string referenced by I<fts_path>."
msgstr "Длина строки, на которую ссылается I<fts_path>."

#. type: TP
#: man-pages/man3/fts.3:242
#, no-wrap
msgid "I<fts_name>"
msgstr "I<fts_name>"

#. type: Plain text
#: man-pages/man3/fts.3:245
msgid "The name of the file."
msgstr "Имя файла."

#. type: TP
#: man-pages/man3/fts.3:245
#, no-wrap
msgid "I<fts_namelen>"
msgstr "I<fts_namelen>"

#. type: Plain text
#: man-pages/man3/fts.3:249
msgid "The length of the string referenced by I<fts_name>."
msgstr "Длина строки, на которую ссылается I<fts_name>."

#. type: TP
#: man-pages/man3/fts.3:249
#, no-wrap
msgid "I<fts_level>"
msgstr "I<fts_level>"

#. type: Plain text
#: man-pages/man3/fts.3:260
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""
"Глубина погружения в дерево иерархии, от -1 до N, на которой был обнаружен "
"файл. Структура I<FTSENT>, представляющая родительский каталог обхода (или "
"начальный каталог), обозначена как -1, а структура I<FTSENT> для самой "
"начальной точки поиска обозначена как 0."

#. type: TP
#: man-pages/man3/fts.3:260
#, no-wrap
msgid "I<fts_errno>"
msgstr "I<fts_errno>"

#. type: Plain text
#: man-pages/man3/fts.3:283
msgid ""
"Upon return of a I<FTSENT> structure from the B<fts_children>()  or "
"B<fts_read>()  functions, with its I<fts_info> field set to B<FTS_DNR>, "
"B<FTS_ERR> or B<FTS_NS>, the I<fts_errno> field contains the value of the "
"external variable I<errno> specifying the cause of the error.  Otherwise, "
"the contents of the I<fts_errno> field are undefined."
msgstr ""
"Если при возврате структуры I<FTSENT> функцией B<fts_children>() или B<"
"fts_read>() её поле I<fts_info> равно B<FTS_DNR>, B<FTS_ERR> или B<FTS_NS>, "
"то в поле I<fts_errno> содержится значение внешней переменной I<errno>, "
"обозначающее причину ошибки. В других случаях, содержимое поля I<fts_errno> "
"не определено."

#. type: TP
#: man-pages/man3/fts.3:283
#, no-wrap
msgid "I<fts_number>"
msgstr "I<fts_number>"

#. type: Plain text
#: man-pages/man3/fts.3:289
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""
"Это поле создано для использования пользовательским приложением и не "
"изменяется функциями fts. При инициализации оно устанавливается в 0."

#. type: TP
#: man-pages/man3/fts.3:289
#, no-wrap
msgid "I<fts_pointer>"
msgstr "I<fts_pointer>"

#. type: Plain text
#: man-pages/man3/fts.3:296
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""
"Это поле создано для использования пользовательским приложением и не "
"изменяется функциями fts. При инициализации оно устанавливается в NULL."

#. type: TP
#: man-pages/man3/fts.3:296
#, no-wrap
msgid "I<fts_parent>"
msgstr "I<fts_parent>"

#. type: Plain text
#: man-pages/man3/fts.3:310
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number> and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""
"Указатель на структуру I<FTSENT>, которая ссылается на файл в иерархии "
"непосредственно над текущим файлом, то есть на каталог, членом которого "
"является текущий файл. Родительский каталог начальной точки поиска также "
"может быть доступен, однако инициализируются только  поля I<fts_level>, I<"
"fts_number> и I<fts_pointer>."

#. type: TP
#: man-pages/man3/fts.3:310
#, no-wrap
msgid "I<fts_link>"
msgstr "I<fts_link>"

#. type: Plain text
#: man-pages/man3/fts.3:321
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory"
" members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""
"При возврате функции B<fts_children>() поле I<fts_link> указывает на "
"следующую структуру в связанном списке (заканчивающемся NULL) содержимого "
"каталога. В другим случаях содержимое поля I<fts_link> не определено."

#. type: TP
#: man-pages/man3/fts.3:321
#, no-wrap
msgid "I<fts_cycle>"
msgstr "I<fts_cycle>"

#. type: Plain text
#: man-pages/man3/fts.3:337
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""
"Если каталог вызывает зацикливание иерархии (смотрите B<FTS_DC>), либо из-за "
"жёсткой ссылки между двумя каталогами, либо из-за символьной ссылки, "
"указывающей на каталог, то поле I<fts_cycle> будет указывать на структуру I<"
"FTSENT> в иерархии, которая ссылается на тот же файл, что и текущая структура "
"I<FTSENT>. В других случаях содержимое поля I<fts_cycle> не определено."

#. type: TP
#: man-pages/man3/fts.3:337
#, no-wrap
msgid "I<fts_statp>"
msgstr "I<fts_statp>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:343
msgid "A pointer to B<stat>(2)  information for the file."
msgstr "Указатель на информацию о файле, полученную с помощью B<stat>(2)."

#. type: Plain text
#: man-pages/man3/fts.3:370
msgid ""
"A single buffer is used for all of the paths of all of the files in the file"
" hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned"
" by B<fts_read>().  To use these fields to reference any files represented "
"by other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen>"
" field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always null-"
"terminated."
msgstr ""
"Для всех путей всех файлов в иерархии используется единый буфер. "
"Следовательно, поля I<fts_path> и I<fts_accpath> гарантировано завершаются "
"null I<только> для файла, который был возвращён B<fts_read>() последним. Для "
"использования этих полей для обращения к любым файлам, представленным другими "
"структурами I<FTSENT> необходимо, чтобы буфер пути был изменён в соответствии "
"с информацией, содержащейся в поле I<fts_pathlen> структуры I<FTSENT>. Любое "
"изменение должно быть обратно восстановлено перед дальнейшими попытками "
"вызова B<fts_read>(). Поле I<fts_name> всегда завершается null."

#. type: SS
#: man-pages/man3/fts.3:370
#, no-wrap
msgid "fts_open()"
msgstr "fts_open()"

#. type: Plain text
#: man-pages/man3/fts.3:377
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a null pointer."
msgstr ""
"Функция B<fts_open>() ожидает указатель на массив символьных указателей, "
"обозначающих один или несколько путей, образующих логическую файловую "
"иерархию, по которой будет проводиться обход. Массив должен заканчиваться "
"указателем null."

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: man-pages/man3/fts.3:387
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""
"Есть несколько флагов, должен быть указан хотя бы один (либо B<FTS_LOGICAL>, "
"либо B<FTS_PHYSICAL>). Флаги, выбираемые с помощью логического объединения, "
"имеют следующие значения:"

#. type: TP
#: man-pages/man3/fts.3:387
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr "B<FTS_COMFOLLOW>"

#. type: Plain text
#: man-pages/man3/fts.3:393
msgid ""
"This option causes any symbolic link specified as a root path to be followed"
" immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""
"Этот флаг принуждает перемещаться по любой символьной ссылке, определённой "
"как корневой путь, несмотря на то, определён или нет флаг B<FTS_LOGICAL>."

#. type: TP
#: man-pages/man3/fts.3:393
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr "B<FTS_LOGICAL>"

#. type: Plain text
#: man-pages/man3/fts.3:412
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this"
" option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either"
" B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()"
"  function."
msgstr ""
"Этот флаг принуждает функции fts возвращать структуры B<FTSENT> для целей "
"символьных ссылок вместо самих символьных ссылок. Если этот флаг включён, то "
"единственные символьные ссылки, для которых приложениям выдаются структуры I<"
"FTSENT> — это ссылки, указывающие на несуществующие файлы. Также для работы "
"функции B<fts_open>() I<должны> быть указаны B<FTS_LOGICAL> или B<"
"FTS_PHYSICAL>."

#. type: TP
#: man-pages/man3/fts.3:412
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr "B<FTS_NOCHDIR>"

#. type: Plain text
#: man-pages/man3/fts.3:428
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""
"С целью оптимизации производительности функции fts меняют каталоги, по "
"которым они следуют по файловой иерархии. Это имеет один побочный эффект — "
"приложения не могут точно определить, в каком каталоге они находятся во время "
"перемещения по дереву. Флаг B<FTS_NOCHDIR> выключает такую оптимизацию, и "
"функции fts не будут менять текущий каталог. Заметим, что приложения тоже не "
"должны изменять свой текущий каталог и пытаться получить доступ к файлам, "
"пока не указан флаг B<FTS_NOCHDIR> и функции B<fts_open>() не переданы "
"абсолютные пути в качестве параметров."

#. type: TP
#: man-pages/man3/fts.3:428
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr "B<FTS_NOSTAT>"

#. type: Plain text
#: man-pages/man3/fts.3:444
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes"
" that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""
"По умолчанию, возвращаемые структуры I<FTSENT> ссылаются на информацию о "
"файлах (поле I<statp>) в каждом просмотренном файле. Данный флаг снимает это "
"требование (для оптимизации производительности), позволяя функциям fts "
"присваивать полю I<fts_info> значение B<FTS_NSOK> и оставлять содержание поля "
"I<statp> неопределенным."

#. type: TP
#: man-pages/man3/fts.3:444
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr "B<FTS_PHYSICAL>"

#. type: Plain text
#: man-pages/man3/fts.3:463
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""
"Этот флаг заставляет функции fts выдавать структуру I<FTSENT> самих "
"символьных ссылок, а не файлов, на которые они указывают. Если этот флаг "
"установлен, то для всех символьных ссылок в файловой иерархии приложениям "
"возвращаются структуры I<FTSENT>. Для работы функции B<fts_open>() также I<"
"должны> присутствовать B<FTS_LOGICAL> или B<FTS_PHYSICAL>."

#. type: TP
#: man-pages/man3/fts.3:463
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr "B<FTS_SEEDOT>"

#. type: Plain text
#: man-pages/man3/fts.3:476
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures"
" for them."
msgstr ""
"По умолчанию, все файлы с именами «.» или «..», обнаруженные в файловой "
"иерархии, игнорируются, если они не указаны как параметры пути в B<fts_open>"
"(). Данный флаг принуждает функции fts для таких файлов возвращать структуры "
"I<FTSENT>."

#. type: TP
#: man-pages/man3/fts.3:476
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr "B<FTS_XDEV>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:482
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""
"Этот флаг предотвращает функции fts от вхождения в каталоги, которые имеют "
"номер устройства, отличный от файла, с которого начался обход."

#. type: Plain text
#: man-pages/man3/fts.3:521
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path> and"
" I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used in "
"this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""
"В параметре B<compar>() указывается определяемая пользователем функция, "
"которая может использоваться для упорядочивания обхода иерархии. В качестве "
"параметров ей требуется два указателя на указатели на структуры I<FTSENT>, и "
"она должна возвращать отрицательное значение, ноль или положительное значение "
"для того, чтобы показать, расположен ли файл, на который указывает первый "
"параметр, перед (относительно текущего упорядочивания), на одном уровне или "
"после файла, на который указывает второй параметр. Поля I<fts_accpath>, I<"
"fts_path> и I<fts_pathlen> структур I<FTSENT> могут быть I<никогда> не "
"использованы при таком сравнении. Если значение поля I<fts_info> равно B<"
"FTS_NS> или B<FTS_NSOK>, то поле I<fts_statp> может не использоваться. Если "
"значение параметра B<compar>() равно NULL, то порядок обхода каталогов "
"определяется параметрами, указанными в I<path_argv> для корневых путей, и в "
"порядке, перечисленном в каталоге, для всего остального."

#. type: SS
#: man-pages/man3/fts.3:521
#, no-wrap
msgid "fts_read()"
msgstr "fts_read()"

#. type: Plain text
#: man-pages/man3/fts.3:534
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may"
" cause files to be visited more than once, or directories more than twice.)"
msgstr ""
"Функция B<fts_read>() возвращает указатель на структуру I<FTSENT>, "
"описывающую файл в иерархии. Каталоги (корректно считанные и не образующие "
"зацикливаний), посещаются как минимум дважды — первый раз в прямом "
"прохождении и второй раз в обратном. Все остальные файлы посещаются минимум "
"один раз (жёсткие ссылки между каталогами, не образующие зацикливаний, или "
"символьные ссылки на символьные ссылки могут привести к тому, что файлы будут "
"посещаться более одного раза, а каталоги более двух раз)."

#. type: Plain text
#: man-pages/man3/fts.3:555
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and"
" sets I<errno> appropriately.  If an error related to a returned file "
"occurs, a pointer to an I<FTSENT> structure is returned, and I<errno> may or"
" may not have been set (see I<fts_info>)."
msgstr ""
"Когда все члены иерархии возвращены, B<fts_read>() возвращает NULL и "
"устанавливает внешнюю переменную I<errno> равной 0. Если происходит ошибка, "
"не имеющая отношения к файлу в иерархии, B<fts_read>() возвращает NULL и "
"устанавливает I<errno> в соответствующее значение. Если происходит ошибка, "
"связанная с возвращённым файлом, то возвращается указатель на структуру I<"
"FTSENT>, а I<errno> может быть установлена в какое-то значение (а может и не "
"быть, смотрите I<fts_info>)."

#. type: Plain text
#: man-pages/man3/fts.3:572
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after"
" a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""
"Структуры I<FTSENT>, возвращаемые B<fts_read>(), могут быть перезаписаны "
"после вызова B<fts_close>() в том же файловом потоке иерархии или после "
"вызова B<fts_read>() в том же файловом потоке иерархии, если они не "
"представляют файл типа «каталог»; в этом случае они не будут перезаписаны до "
"тех пор, пока функция B<fts_read>() не вернёт структуру I<FTSENT> при "
"выполнении обхода в обратном порядке."

#. type: SS
#: man-pages/man3/fts.3:572
#, no-wrap
msgid "fts_children()"
msgstr "fts_children()"

#. type: Plain text
#: man-pages/man3/fts.3:590
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will re-create this "
"linked list."
msgstr ""
"Функция B<fts_children>() возвращает указатель на структуру I<FTSENT>, "
"описывающую первый член связанного списка (оканчивающегося NULL) файлов в "
"каталоге, представленного структурой I<FTSENT>, возвращённой B<fts_read>() "
"последней. Список связан через поле I<fts_link> структуры I<FTSENT>, и "
"упорядочен определённой пользователем функцией сравнения, если таковая "
"существует. Повторные вызовы B<fts_children>() будут пересоздавать этот "
"связанный список."

#. type: Plain text
#: man-pages/man3/fts.3:618
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, "
"B<fts_children>()  returns NULL and sets I<errno> appropriately."
msgstr ""
"В особом случае, если B<fts_read>() ещё не вызывалась для иерархии, то B<"
"fts_children>() возвратит указатель на файлы в логическом каталоге, заданном "
"B<fts_open>(), т.е. параметры, переданные функции B<fts_open>(). В противном "
"случае, если последняя возвращённая B<fts_read>() структура I<FTSENT> не "
"является каталогом, просмотренном в прямом порядке, и не каталогом файлов, то "
"B<fts_children>() возвратит NULL и установит I<errno> равным 0. Если "
"произойдёт ошибка, то B<fts_children>() возвратит NULL и установит I<errno> в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man3/fts.3:629
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>()  or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""
"Структура I<FTSENT>, возвращаемая B<fts_children>(), может быть перезаписана "
"после вызова B<fts_children>(), B<fts_close>() или B<fts_read>() в том же "
"файловом потоке иерархии."

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: man-pages/man3/fts.3:633
msgid "I<Option> may be set to the following value:"
msgstr "Значениям I<option> могут быть:"

#. type: TP
#: man-pages/man3/fts.3:633
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr "B<FTS_NAMEONLY>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:643
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""
"Необходимы только имена файлов. Содержимое всех полей в возвращаемом "
"связанном списке структур не определено, за исключением полей I<fts_name> и "
"I<fts_namelen>."

#. type: SS
#: man-pages/man3/fts.3:643
#, no-wrap
msgid "fts_set()"
msgstr "fts_set()"

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: man-pages/man3/fts.3:658
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs.  I<Option> must be"
" set to one of the following values:"
msgstr ""
"Функция B<fts_set>() позволяет пользовательскому приложению определять "
"дальнейшую обработку файла I<f> в потоке I<ftsp>. При успешном выполнении "
"функция B<fts_set>() возвращает 0 и -1 при ошибке. Значение I<option> должно "
"быть одним из следующих значений:"

#. type: TP
#: man-pages/man3/fts.3:658
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr "B<FTS_AGAIN>"

#. type: Plain text
#: man-pages/man3/fts.3:676
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""
"Повторно посетить файл; файл любого типа может быть повторно посещён. "
"Последующий вызов B<fts_read>() возвратит файл, к которому идёт обращение. "
"Поля I<fts_stat> и I<fts_info> структуры будут переинициализированы в этот "
"момент, но никакие поля больше не будут изменены. Этот параметр значим только "
"для последнего возвращённого файла из B<fts_read>(). Обычно его используют "
"при посещении каталогов в обратном порядке; в этом случае каталог посещается "
"повторно (в прямом и обратном порядке), а также все его потомки."

#. type: TP
#: man-pages/man3/fts.3:676
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr "B<FTS_FOLLOW>"

#. type: Plain text
#: man-pages/man3/fts.3:704
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()"
"  returns the file with the I<fts_info> and I<fts_statp> fields "
"reinitialized to reflect the target of the symbolic link instead of the "
"symbolic link itself.  If the file is one of those most recently returned by"
" B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the "
"structure, when returned by B<fts_read>(), will reflect the target of the "
"symbolic link instead of the symbolic link itself.  In either case, if the "
"target of the symbolic link does not exist, the fields of the returned "
"structure will be unchanged and the I<fts_info> field will be set to "
"B<FTS_SLNONE>."
msgstr ""
"Рассматриваемый файл должен быть символьной ссылкой. Если рассматриваемый "
"файл — последний возвращённый B<fts_read>(), то следующий вызов B<fts_read>() "
"возвратит файл с изменёнными полями I<fts_info> и I<fts_statp>, в которых "
"будут отражать повторно инициализированные данные цели символьной ссылки, а "
"не самой символьной ссылки. Если рассматриваемый файл — последний "
"возвращённый B<fts_children>(), то поля I<fts_info> и I<fts_statp> структуры "
"при возврате из B<fts_read>() будут отражать данные цели символьной ссылки, а "
"не самой символьной ссылки. В любом случае, если цель символьной ссылки не "
"существует, то поля возвращаемой структуры не будут меняться, а поле I<"
"fts_info> будет равно B<FTS_SLNONE>."

#. type: Plain text
#: man-pages/man3/fts.3:708
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""
"Если цель ссылки — каталог, то выполняется возврат при прямом прохождении, "
"после него возврат всех его потомков, после чего выполняется возврат в "
"обратном порядке."

#. type: TP
#: man-pages/man3/fts.3:708
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr "B<FTS_SKIP>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:716
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""
"Не посещать потомков данного файла. Файл может быть одним из последних "
"возвращённых либо B<fts_children>(), либо B<fts_read>()."

#. type: SS
#: man-pages/man3/fts.3:716
#, no-wrap
msgid "fts_close()"
msgstr "fts_close()"

#. type: Plain text
#: man-pages/man3/fts.3:729
msgid ""
"The B<fts_close>()  function closes a file hierarchy stream I<ftsp> and "
"restores the current directory to the directory from which B<fts_open>()  "
"was called to open I<ftsp>.  The B<fts_close>()  function returns 0 on "
"success, and -1 if an error occurs."
msgstr ""
"Функция B<fts_close>() закрывает поток файловой иерархии I<ftsp> и делает "
"текущим каталог тот, который был до вызова B<fts_open>() для открытия I<ftsp>"
". При успешном выполнении функция B<fts_close>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/fts.3:738
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""
"Функция B<fts_open>() может завершиться с ошибкой и назначить переменной I<"
"errno> значения, перечисленные в B<open>(2) и B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/fts.3:747
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors"
" specified for B<chdir>(2)  and B<close>(2)."
msgstr ""
"Функция B<fts_close>() может завершиться с ошибкой и назначить переменной I<"
"errno> значения, перечисленные в B<chdir>(2) и B<close>(2)."

#. type: Plain text
#: man-pages/man3/fts.3:761
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3)  and B<stat>(2)."
msgstr ""
"Функции B<fts_read>() и B<fts_children>() могут завершиться с ошибкой и "
"назначить переменной I<errno> значения, перечисленные в B<chdir>(2), B<malloc>"
"(3), B<opendir>(3), B<readdir>(3) и B<stat>(2)."

#. type: Plain text
#: man-pages/man3/fts.3:770
msgid ""
"In addition, B<fts_children>(), B<fts_open>()  and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""
"Кроме того, функции B<fts_children>(), B<fts_open>() и B<fts_set>() могут "
"завершиться с ошибкой и назначить переменной I<errno> следующие значения:"

#. type: Plain text
#: man-pages/man3/fts.3:773
msgid "The options were invalid."
msgstr "Указаны неправильные параметры."

#. type: Plain text
#: man-pages/man3/fts.3:775
msgid "These functions are available in Linux since glibc2."
msgstr "Эти функции доступны в версиях Linux начиная с glibc2."

#. type: Plain text
#: man-pages/man3/fts.3:777
msgid "4.4BSD."
msgstr "4.4BSD."

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=15838
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11460
#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: man-pages/man3/fts.3:790
msgid ""
"All of the APIs described in this man page are not safe when compiling a "
"program using the LFS APIs (e.g., when compiling with "
"I<-D_FILE_OFFSET_BITS=64>)."
msgstr ""
"Весь описанный здесь программный интерфейс небезопасен, если компиляция "
"программы производится с программным интерфейсом LFS (например, когда "
"компиляция выполняется с I<-D_FILE_OFFSET_BITS=64>)."

#. type: Plain text
#: man-pages/man3/fts.3:795
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"

#. type: TH
#: man-pages/man3/floor.3:27
#, no-wrap
msgid "FLOOR"
msgstr "FLOOR"

#. type: Plain text
#: man-pages/man3/floor.3:30
msgid ""
"floor, floorf, floorl - largest integral value not greater than argument"
msgstr ""
"floor, floorf, floorl - поиск наибольшего целого значения не превышающего "
"заданный аргумент"

#. type: Plain text
#: man-pages/man3/floor.3:35
#, no-wrap
msgid "B<double floor(double >I<x>B<);>\n"
msgstr "B<double floor(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/floor.3:37
#, no-wrap
msgid "B<float floorf(float >I<x>B<);>\n"
msgstr "B<float floorf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/floor.3:39
#, no-wrap
msgid "B<long double floorl(long double >I<x>B<);>\n"
msgstr "B<long double floorl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/floor.3:51
msgid "B<floorf>(), B<floorl>():"
msgstr "B<floorf>(), B<floorl>():"

#. type: Plain text
#: man-pages/man3/floor.3:62
msgid ""
"These functions return the largest integral value that is not greater than "
"I<x>."
msgstr ""
"Данные функции возвращают наибольшее целое значение не превышающее I<x>."

#. type: Plain text
#: man-pages/man3/floor.3:68
msgid "For example, I<floor(0.5)> is 0.0, and I<floor(-0.5)> is -1.0."
msgstr ""
"Например, результатом I<floor(0.5)> будет 0.0, а I<floor(-0.5)> \\(em -1.0."

#. type: Plain text
#: man-pages/man3/floor.3:71
msgid "These functions return the floor of I<x>."
msgstr "Данные функции возвращают целую часть от I<x>."

#. type: Plain text
#: man-pages/man3/floor.3:77
msgid ""
"If I<x> is integral, +0, -0, NaN, or an infinity, I<x> itself is returned."
msgstr ""
"Если I<x> \\(em целое, +0, -0, NaN или стремится к бесконечности, то будет "
"возвращено значение I<x>."

#. type: Plain text
#: man-pages/man3/floor.3:80
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""
"Ошибки не возникают. В документах POSIX.1-2001 описывается ошибка диапазона "
"при переполнениях, однако см. ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man3/floor.3:88
msgid ""
"The B<floor>(), B<floorf>(), and B<floorl>()  functions are thread-safe."
msgstr ""
"Функции B<floor>(), B<floorf>() и B<floorl>() можно использовать в нескольких "
"нитях одновременно."

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: man-pages/man3/floor.3:110
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno>"
" to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of"
" mantissa bits is 24 (respectively, 53).)"
msgstr ""
"В SUSv2 и POSIX.1-2001 есть текст о переполнении (которое может установить I<"
"errno> в B<ERANGE> или вызвать исключение B<FE_OVERFLOW>). На практике, "
"результат не может выйти за диапазон ни на каком компьютере, поэтому "
"обработка этой ошибки не имеет смысла (точнее говоря, переполнение возможно "
"только в том случае, когда максимальное значение экспоненты меньше числа бит "
"мантиссы. В стандарте IEEE-754 для 32- и 64-битных чисел с плавающей точкой "
"максимальное значение экспоненты равно 128 и 1024 соответственно, а число бит "
"мантиссы — 24 и 53 соответственно)."

#. type: Plain text
#: man-pages/man3/floor.3:116
msgid ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), "
"B<trunc>(3)"
msgstr ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), B<trunc>(3)"

#. type: TH
#: man-pages/man3/fputwc.3:16
#, no-wrap
msgid "FPUTWC"
msgstr "FPUTWC"

#. type: Plain text
#: man-pages/man3/fputwc.3:19
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr "fputwc, putwc - записывает широкий символ в поток FILE"

#. type: Plain text
#: man-pages/man3/fputwc.3:27
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\nB<wint_t "
"putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fputwc.3:43
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the "
"B<fputc>(3)  function.  It writes the wide character I<wc> to I<stream>.  If"
" I<ferror(stream)> becomes true, it returns B<WEOF>.  If a wide-character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>."
"  Otherwise, it returns I<wc>."
msgstr ""
"Функция B<fputwc> — это эквивалент функции B<fputc>(3), но для широких "
"символов. Она записывает широкий символ I<wc> в поток I<stream>. Если "
"значение I<ferror(stream)> истинно, то возвращается B<WEOF>. Если при "
"преобразовании в широкий символ возникает ошибка, то значение переменной I<"
"errno> устанавливается равным B<EILSEQ> и возвращается B<WEOF>. В любом "
"другом случае возвращается I<wc>."

#. type: Plain text
#: man-pages/man3/fputwc.3:51
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than once."
"  There is no reason ever to use it."
msgstr ""
"Функция B<putwc>() — это функция, или макрос, идентичный B<fputwc>(). Она "
"может быть реализована в виде макроса, и может вычислять свой аргумент более "
"одного раза. Вообще нет смысла использовать эту функцию."

#. type: Plain text
#: man-pages/man3/fputwc.3:63
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error.  In the event of an error, I<errno> is set to indicate "
"the cause."
msgstr ""
"Функция B<fputwc>() возвращает I<wc>, если не было ошибок, или B<WEOF> в "
"противном случае. При ошибке в I<errno> записывается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fputwc.3:68
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr "Не удалось преобразовать I<wc> в кодировку потока."

#. type: Plain text
#: man-pages/man3/fputwc.3:77
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fputwc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fputwc.3:85
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it"
" is reasonable to expect that B<fputwc>()  will actually write the multibyte"
" sequence corresponding to the wide character I<wc>."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fputwc>() на самом деле пишет многобайтовую "
"последовательность, соответствующую широкому символу I<wc>."

#. type: Plain text
#: man-pages/man3/fputwc.3:88
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fmax.3:9
#, no-wrap
msgid "FMAX"
msgstr "FMAX"

#. type: Plain text
#: man-pages/man3/fmax.3:12
msgid "fmax, fmaxf, fmaxl - determine maximum of two floating-point numbers"
msgstr ""
"fmax, fmaxf, fmaxl - определение максимального из двух чисел с плавающей "
"запятой"

#. type: Plain text
#: man-pages/man3/fmax.3:16
msgid "B<double fmax(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fmax(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmax.3:18
msgid "B<float fmaxf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fmaxf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmax.3:20
msgid "B<long double fmaxl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fmaxl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmax.3:32
msgid "B<fmax>(), B<fmaxf>(), B<fmaxl>():"
msgstr "B<fmax>(), B<fmaxf>(), B<fmaxl>():"

#. type: Plain text
#: man-pages/man3/fmax.3:45
msgid "These functions return the larger value of I<x> and I<y>."
msgstr "Данные функции возвращают большее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmax.3:50
msgid "These functions return the maximum of I<x> and I<y>."
msgstr "Данные функции возвращают большее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmax.3:66
msgid "The B<fmax>(), B<fmaxf>(), and B<fmaxl>()  functions are thread-safe."
msgstr ""
"Функции B<fmax>(), B<fmaxf>() и B<fmaxl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/fmax.3:69
msgid "B<fmin>(3)"
msgstr "B<fmin>(3)"

#. type: TH
#: man-pages/man3/fma.3:12
#, no-wrap
msgid "FMA"
msgstr "FMA"

#. type: Plain text
#: man-pages/man3/fma.3:15
msgid "fma, fmaf, fmal - floating-point multiply and add"
msgstr "fma, fmaf, fmal - умножение и сложение чисел с плавающей запятой"

#. type: Plain text
#: man-pages/man3/fma.3:20
#, no-wrap
msgid "B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"
msgstr "B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"

#. type: Plain text
#: man-pages/man3/fma.3:22
#, no-wrap
msgid "B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"
msgstr "B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"

#. type: Plain text
#: man-pages/man3/fma.3:24
#, no-wrap
msgid ""
"B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double "
">I<z>B<);>\n"
msgstr ""
"B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double >I<z>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/fma.3:37
msgid "B<fma>(), B<fmaf>(), B<fmal>():"
msgstr "B<fma>(), B<fmaf>(), B<fmal>():"

#. type: Plain text
#: man-pages/man3/fma.3:53
msgid ""
"The B<fma>()  function computes I<x> * I<y> + I<z>.  The result is rounded "
"as one ternary operation according to the current rounding mode (see "
"B<fenv>(3))."
msgstr ""
"Функция B<fma>() вычисляет I<x> * I<y> + I<z>. Результат округляется как "
"единая тернарная операция согласно текущему режиму округления (смотрите B<"
"fenv>(3))."

#. type: Plain text
#: man-pages/man3/fma.3:57
msgid ""
"These functions return the value of I<x> * I<y> + I<z>, rounded as one "
"ternary operation."
msgstr ""
"Данные функции возвращают результат I<x> * I<y> + I<z>, округлённый как для "
"единой тернарной операции."

#. type: Plain text
#: man-pages/man3/fma.3:73
msgid ""
"If I<x> times I<y> is an exact infinity, and I<z> is an infinity with the "
"opposite sign, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> умноженное на I<y> стремится к бесконечности и значение I<z> равно "
"минус бесконечности, то будет сгенерирована ошибка выхода за пределы области, "
"а в качестве результата будет возвращено NaN."

#.  POSIX.1-2008 allows some possible differences for the following two
#.  domain error cases, but on Linux they are treated the same (AFAICS).
#.  Nevertheless, we'll mirror POSIX.1 and describe the two cases
#.  separately.
#.  POSIX.1 says that a NaN or an implementation-defined value shall
#.  be returned for this case.
#. type: Plain text
#: man-pages/man3/fma.3:89
msgid ""
"If one of I<x> or I<y> is an infinity, the other is 0, and I<z> is not a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> или I<y> равно бесконечности, не равно 0 и I<z> не равно NaN, то "
"будет сгенерирована ошибка выхода за пределы области, а в качестве результата "
"будет возвращено NaN."

#.  POSIX.1 makes the domain error optional for this case.
#. type: Plain text
#: man-pages/man3/fma.3:100
msgid ""
"If one of I<x> or I<y> is an infinity, and the other is 0, and I<z> is a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> или I<y> равно бесконечности, не равно 0, а I<z> равно NaN, то "
"будет сгенерирована ошибка выхода за пределы области, а в качестве результата "
"будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fma.3:109
msgid ""
"If I<x> times I<y> is not an infinity times zero (or vice versa), and I<z> "
"is a NaN, a NaN is returned."
msgstr ""
"Если I<x> умноженное на I<y> не равно бесконечности умноженной на 0 (или "
"наоборот) и значение I<z> равно NaN, то будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fma.3:113
msgid ""
"If the result overflows, a range error occurs, and an infinity with the "
"correct sign is returned."
msgstr ""
"Если происходит переполнение результата, возникает ошибка диапазона, и "
"возвращается бесконечность с математически правильным знаком."

#. type: Plain text
#: man-pages/man3/fma.3:117
msgid ""
"If the result underflows, a range error occurs, and a signed 0 is returned."
msgstr ""
"Если в результате исчезает порядок числа, возникает ошибка диапазона и "
"возвращается ноль со знаком."

#. type: TP
#: man-pages/man3/fma.3:124
#, no-wrap
msgid ""
"Domain error: I<x> * I<y> + I<z>, or I<x> * I<y> is invalid and I<z> is not "
"a NaN"
msgstr ""
"Ошибка области: I<x> * I<y> + I<z> или I<x> * I<y> некорректно и I<z> не "
"равно NaN"

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/fma.3:133
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "Возникает исключение неправильной плавающей запятой (B<FE_INVALID>)."

#. type: TP
#: man-pages/man3/fma.3:141
#, no-wrap
msgid "Range error: result underflow"
msgstr "Ошибка диапазона: результат потерял разрядность"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/fma.3:149
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Возникает исключение исчезновение порядка плавающей запятой (B<FE_UNDERFLOW>)."

#. type: Plain text
#: man-pages/man3/fma.3:164
msgid "The B<fma>(), B<fmaf>(), and B<fmal>()  functions are thread-safe."
msgstr ""
"Функции B<fma>(), B<fmaf>() и B<fmal>() можно использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/fma.3:168
msgid "B<remainder>(3), B<remquo>(3)"
msgstr "B<remainder>(3), B<remquo>(3)"

#. type: TH
#: man-pages/man3/fenv.3:27
#, no-wrap
msgid "FENV"
msgstr "FENV"

#. type: TH
#: man-pages/man3/fenv.3:27
#, no-wrap
msgid "2014-04-01"
msgstr "2014-04-01"

#. type: Plain text
#: man-pages/man3/fenv.3:33
msgid ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, "
"fetestexcept, fegetenv, fegetround, feholdexcept, fesetround, fesetenv, "
"feupdateenv, feenableexcept, fedisableexcept, fegetexcept - floating-point "
"rounding and exception handling"
msgstr ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, fetestexcept, "
"fegetenv, fegetround, feholdexcept, fesetround, fesetenv, feupdateenv, "
"feenableexcept, fedisableexcept, fegetexcept - округление и обработка ошибок "
"для чисел с плавающей запятой"

#. type: Plain text
#: man-pages/man3/fenv.3:36 man-pages/man3/fenv.3:311
#, no-wrap
msgid "B<#include E<lt>fenv.hE<gt>>\n"
msgstr "B<#include E<lt>fenv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:38
#, no-wrap
msgid "B<int feclearexcept(int >I<excepts>B<);>\n"
msgstr "B<int feclearexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:40
#, no-wrap
msgid "B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
msgstr "B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:42
#, no-wrap
msgid "B<int feraiseexcept(int >I<excepts>B<);>\n"
msgstr "B<int feraiseexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:44
#, no-wrap
msgid ""
"B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
msgstr ""
"B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:46
#, no-wrap
msgid "B<int fetestexcept(int >I<excepts>B<);>\n"
msgstr "B<int fetestexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:48
#, no-wrap
msgid "B<int fegetround(void);>\n"
msgstr "B<int fegetround(void);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:50
#, no-wrap
msgid "B<int fesetround(int >I<rounding_mode>B<);>\n"
msgstr "B<int fesetround(int >I<rounding_mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:52
#, no-wrap
msgid "B<int fegetenv(fenv_t *>I<envp>B<);>\n"
msgstr "B<int fegetenv(fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:54
#, no-wrap
msgid "B<int feholdexcept(fenv_t *>I<envp>B<);>\n"
msgstr "B<int feholdexcept(fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:56
#, no-wrap
msgid "B<int fesetenv(const fenv_t *>I<envp>B<);>\n"
msgstr "B<int fesetenv(const fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:58
#, no-wrap
msgid "B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"
msgstr "B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:64
msgid ""
"These eleven functions were defined in C99, and describe the handling of "
"floating-point rounding and exceptions (overflow, zero-divide, etc.)."
msgstr ""
"Эти одиннадцать функций определены в C99, и описывают обработку округление и "
"исключения (переполнение, деление на ноль и т. д.) при работе с числами с "
"плавающей запятой."

#. type: SS
#: man-pages/man3/fenv.3:64
#, no-wrap
msgid "Exceptions"
msgstr "Исключения"

#. type: Plain text
#: man-pages/man3/fenv.3:69
msgid ""
"The I<divide-by-zero> exception occurs when an operation on finite numbers "
"produces infinity as exact answer."
msgstr ""
"Исключение I<деление-на-ноль (divide-by-zero)> возникает, когда результатом "
"операции над конечными числами является бесконечность."

#. type: Plain text
#: man-pages/man3/fenv.3:75
msgid ""
"The I<overflow> exception occurs when a result has to be represented as a "
"floating-point number, but has (much) larger absolute value than the largest"
" (finite) floating-point number that is representable."
msgstr ""
"Исключение I<переполнение (overflow)> возникает, когда результат возможно "
"представить в виде числа с плавающей запятой, но он намного больше "
"абсолютного значения самого большого (конечного) представимого числа с "
"плавающей запятой."

#. type: Plain text
#: man-pages/man3/fenv.3:82
msgid ""
"The I<underflow> exception occurs when a result has to be represented as a "
"floating-point number, but has smaller absolute value than the smallest "
"positive normalized floating-point number (and would lose much accuracy when"
" represented as a denormalized number)."
msgstr ""
"Исключение I<потеря-значащего-разряда (underflow)> возникает, когда результат "
"можно представить в виде числа с плавающей запятой, но он меньше абсолютного "
"значения самого малого положительного нормализованного числа с плавающей "
"запятой (и возникает большая потеря точности, если представить его в виде "
"денормализованного числа)."

#. type: Plain text
#: man-pages/man3/fenv.3:92
msgid ""
"The I<inexact> exception occurs when the rounded result of an operation is "
"not equal to the infinite precision result.  It may occur whenever "
"I<overflow> or I<underflow> occurs."
msgstr ""
"Исключение I<inexact> возникает, когда округлённый результат операции не "
"равен бесконечной точности результата. Оно может произойти при исключении I<"
"overflow> или I<underflow>."

#. type: Plain text
#: man-pages/man3/fenv.3:97
msgid ""
"The I<invalid> exception occurs when there is no well-defined result for an "
"operation, as for 0/0 or infinity - infinity or sqrt(-1)."
msgstr ""
"Исключение I<invalid> возникает, когда при операции получается плохо "
"определённый результат (no well-defined result), например, при 0/0 или "
"бесконечность - бесконечность или sqrt(-1)."

#. type: SS
#: man-pages/man3/fenv.3:97
#, no-wrap
msgid "Exception handling"
msgstr "Обработка исключений"

#. type: Plain text
#: man-pages/man3/fenv.3:103
msgid ""
"Exceptions are represented in two ways: as a single bit (exception "
"present/absent), and these bits correspond in some implementation-defined "
"way with bit positions in an integer, and also as an opaque structure that "
"may contain more information about the exception (perhaps the code address "
"where it occurred)."
msgstr ""
"Исключения представляются двумя способами: в виде одного бита "
"(наличие/отсутствие исключения) и целого числа, где каждый бит соответствует "
"исключению (определяется реализацией), а также структуры закрытого формата, "
"которая может содержать дополнительную информацию об исключении (возможно, "
"адрес в коде, где оно возникло)."

#. type: Plain text
#: man-pages/man3/fenv.3:119
msgid ""
"Each of the macros B<FE_DIVBYZERO>, B<FE_INEXACT>, B<FE_INVALID>, "
"B<FE_OVERFLOW>, B<FE_UNDERFLOW> is defined when the implementation supports "
"handling of the corresponding exception, and if so then defines the "
"corresponding bit(s), so that one can call exception handling functions, for"
" example, using the integer argument B<FE_OVERFLOW>|B<FE_UNDERFLOW>.  Other "
"exceptions may be supported.  The macro B<FE_ALL_EXCEPT> is the bitwise OR "
"of all bits corresponding to supported exceptions."
msgstr ""
"Если реализацией поддерживается обработка определённого исключения, то "
"определён соответствующий макрос: B<FE_DIVBYZERO>, B<FE_INEXACT>, B<"
"FE_INVALID>, B<FE_OVERFLOW>, B<FE_UNDERFLOW>. Если таким способом определить "
"соответствующий бит(ы), например, с целочисленным аргументом B<FE_OVERFLOW>"
"|B<FE_UNDERFLOW>, то могут вызываться функции обработки исключений. Могут "
"поддерживаться и другие исключения. Макрос B<FE_ALL_EXCEPT> — это побитовый "
"OR всех бит, соответствующих поддерживаемым исключениям."

#. type: Plain text
#: man-pages/man3/fenv.3:124
msgid ""
"The B<feclearexcept>()  function clears the supported exceptions represented"
" by the bits in its argument."
msgstr ""
"Функция B<feclearexcept>() очищает поддерживаемые исключения, указанные "
"битами в аргументе."

#. type: Plain text
#: man-pages/man3/fenv.3:132
msgid ""
"The B<fegetexceptflag>()  function stores a representation of the state of "
"the exception flags represented by the argument I<excepts> in the opaque "
"object I<*flagp>."
msgstr ""
"Функция B<fegetexceptflag>() сохраняет представление состояния флагов "
"исключения, представленного аргументом I<excepts> в скрытом (opaque) объекте "
"I<*flagp>."

#. type: Plain text
#: man-pages/man3/fenv.3:137
msgid ""
"The B<feraiseexcept>()  function raises the supported exceptions represented"
" by the bits in I<excepts>."
msgstr ""
"Функция B<feraiseexcept>() возбуждает поддерживаемые исключения, заданные "
"битами в I<excepts>."

#. type: Plain text
#: man-pages/man3/fenv.3:148
msgid ""
"The B<fesetexceptflag>()  function sets the complete status for the "
"exceptions represented by I<excepts> to the value I<*flagp>.  This value "
"must have been obtained by an earlier call of B<fegetexceptflag>()  with a "
"last argument that contained all bits in I<excepts>."
msgstr ""
"Функция B<fesetexceptflag>() задаёт полное состояние для исключений, "
"представленных в I<excepts>, в значение I<*flagp>. Это значение должно быть "
"получено с помощью вызова B<fegetexceptflag>() с последним аргументом, "
"значение которого содержит все биты в I<excepts>."

#. type: Plain text
#: man-pages/man3/fenv.3:155
msgid ""
"The B<fetestexcept>()  function returns a word in which the bits are set "
"that were set in the argument I<excepts> and for which the corresponding "
"exception is currently set."
msgstr ""
"Функция B<fetestexcept>() возвращает слово, в котором биты устанавливаются в "
"соответствии с установленными битами в аргументе I<excepts> и для которых "
"установлено соответствующее исключение."

#. type: SS
#: man-pages/man3/fenv.3:155
#, no-wrap
msgid "Rounding mode"
msgstr "Режим округления"

#. type: Plain text
#: man-pages/man3/fenv.3:163
msgid ""
"The rounding mode determines how the result of floating-point operations is "
"treated when the result cannot be exactly represented in the significand.  "
"Various rounding modes may be provided: round to nearest (the default), "
"round up (toward positive infinity), round down (toward negative infinity), "
"and round toward zero."
msgstr ""
"Режим округления определяет трактовку результата операций с плавающей "
"запятой, если результат не может быть точно представлен в значащей части "
"числа(significand). Могут быть доступны различные режимы округления: "
"округление к ближайшему (по умолчанию), округление в сторону увеличения "
"(round up, к положительной бесконечности), округление в сторону уменьшения "
"(round down, к отрицательной бесконечности) и округление в сторону нуля."

#. type: Plain text
#: man-pages/man3/fenv.3:172
msgid ""
"Each of the macros B<FE_TONEAREST>, B<FE_UPWARD>, B<FE_DOWNWARD>, and "
"B<FE_TOWARDZERO> is defined when the implementation supports getting and "
"setting the corresponding rounding direction."
msgstr ""
"Если в реализации поддерживается получение и установка направления "
"округления, то для них определены соответствующие макросы: B<FE_TONEAREST>, "
"B<FE_UPWARD>, B<FE_DOWNWARD> и B<FE_TOWARDZERO>."

#. type: Plain text
#: man-pages/man3/fenv.3:177
msgid ""
"The B<fegetround>()  function returns the macro corresponding to the current"
" rounding mode."
msgstr ""
"Функция B<fegetround>() возвращает макрос, соответствующий текущему режиму "
"округления."

#. type: Plain text
#: man-pages/man3/fenv.3:182
msgid ""
"The B<fesetround>()  function sets the rounding mode as specified by its "
"argument and returns zero when it was successful."
msgstr ""
"Функция B<fesetround>() задаёт режим округления в соответствии со значением "
"аргумента и возвращает ноль при успешном выполнении."

#. type: Plain text
#: man-pages/man3/fenv.3:190
msgid ""
"C99 and POSIX.1-2008 specify an identifier, B<FLT_ROUNDS>, defined in "
"I<E<lt>float.hE<gt>>, which indicates the implementation-defined rounding "
"behavior for floating-point addition.  This identifier has one of the "
"following values:"
msgstr ""
"В C99 и POSIX.1-2008 в файле I<E<lt>float.hE<gt>> описан идентификатор B<"
"FLT_ROUNDS>, который определяет используемый реализацией режим поведения для "
"сложения чисел с плавающей запятой. Значениями идентификатора могут быть:"

#. type: IP
#: man-pages/man3/fenv.3:190
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: man-pages/man3/fenv.3:192
msgid "The rounding mode is not determinable."
msgstr "Режим округления не определён."

#. type: IP
#: man-pages/man3/fenv.3:192
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: man-pages/man3/fenv.3:194
msgid "Rounding is toward 0."
msgstr "Округление к нулю."

#. type: IP
#: man-pages/man3/fenv.3:194
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: man-pages/man3/fenv.3:196
msgid "Rounding is toward nearest number."
msgstr "Округление к ближайшему числу."

#. type: IP
#: man-pages/man3/fenv.3:196
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: man-pages/man3/fenv.3:198
msgid "Rounding is toward positive infinity."
msgstr "Округление в сторону положительной бесконечности."

#. type: IP
#: man-pages/man3/fenv.3:198
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: man-pages/man3/fenv.3:200
msgid "Rounding is toward negative infinity."
msgstr "Округление в сторону отрицательной бесконечности."

#. type: Plain text
#: man-pages/man3/fenv.3:202
msgid "Other values represent machine-dependent, nonstandard rounding modes."
msgstr ""
"Существуют другие значения для нестандартных режимов округления, зависящие от "
"архитектуры."

#. type: Plain text
#: man-pages/man3/fenv.3:208
msgid ""
"The value of B<FLT_ROUNDS> should reflect the current rounding mode as set "
"by B<fesetround>()  (but see BUGS)."
msgstr ""
"Значение B<FLT_ROUNDS> должно отражать текущий режим округления, который "
"задаётся с помощью B<fesetround>() (но смотрите ДЕФЕКТЫ)."

#. type: SS
#: man-pages/man3/fenv.3:208
#, no-wrap
msgid "Floating-point environment"
msgstr "Окружение плавающей запятой"

#. type: Plain text
#: man-pages/man3/fenv.3:220
msgid ""
"The entire floating-point environment, including control modes and status "
"flags, can be handled as one opaque object, of type I<fenv_t>.  The default "
"environment is denoted by B<FE_DFL_ENV> (of type I<const fenv_t\\ *>).  This"
" is the environment setup at program start and it is defined by ISO C to "
"have round to nearest, all exceptions cleared and a nonstop (continue on "
"exceptions) mode."
msgstr ""
"С полным окружением плавающей запятой, включая режимы управления и флаги "
"состояния, можно работать через скрытый объект с типом I<fenv_t>. Окружение "
"по умолчанию обозначается как B<FE_DFL_ENV> (с типом I<const fenv_t\\ *>). "
"Это окружение задаётся при запуске программы и определено в ISO C; в нём "
"включено округление к ближайшему числу, все исключения сброшены и задан "
"безостановочный режим (продолжать при возникновении исключений)."

#. type: Plain text
#: man-pages/man3/fenv.3:225
msgid ""
"The B<fegetenv>()  function saves the current floating-point environment in "
"the object I<*envp>."
msgstr ""
"Функция B<fegetenv>() сохраняет текущее окружение плавающей запятой в объект "
"I<*envp>."

#. type: Plain text
#: man-pages/man3/fenv.3:232
msgid ""
"The B<feholdexcept>()  function does the same, then clears all exception "
"flags, and sets a nonstop (continue on exceptions) mode, if available.  It "
"returns zero when successful."
msgstr ""
"Функция B<feholdexcept>() делает то же самое, затем очищает все флаги "
"исключений и включает безостановочный режим (продолжать при возникновении "
"исключений), если он доступен. При успешном выполнении возвращается ноль."

#. type: Plain text
#: man-pages/man3/fenv.3:245
msgid ""
"The B<fesetenv>()  function restores the floating-point environment from the"
" object I<*envp>.  This object must be known to be valid, for example, the "
"result of a call to B<fegetenv>()  or B<feholdexcept>()  or equal to "
"B<FE_DFL_ENV>.  This call does not raise exceptions."
msgstr ""
"Функция B<fesetenv>() восстанавливает окружение плавающей запятой из объекта "
"I<*envp>. Данный объект должен быть корректен, например, должен быть получен "
"из вызова B<fegetenv>() или B<feholdexcept>() или равен B<FE_DFL_ENV>. Данный "
"вызов не возбуждает исключения."

#. type: Plain text
#: man-pages/man3/fenv.3:258
msgid ""
"The B<feupdateenv>()  function installs the floating-point environment "
"represented by the object I<*envp>, except that currently raised exceptions "
"are not cleared.  After calling this function, the raised exceptions will be"
" a bitwise OR of those previously set with those in I<*envp>.  As before, "
"the object I<*envp> must be known to be valid."
msgstr ""
"Функция B<feupdateenv>() устанавливает окружение плавающей запятой, "
"представленное объектом I<*envp>, за исключением того, что уже возбуждённые "
"исключения не очищаются. После вызова этой функции, возбуждённые исключения "
"будут побитово сложены с установленными ранее в I<*envp>. Как и для "
"предыдущей функции, объект I<*envp> должен быть корректен."

#.  Earlier seven of these functions were listed as returning void.
#.  This was corrected in Corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001(E))
#.  of the C99 Standard.
#. type: Plain text
#: man-pages/man3/fenv.3:263
msgid ""
"These functions return zero on success and nonzero if an error occurred."
msgstr ""
"При успешном выполнении эти функции возвращают ноль и не ноль при ошибке."

#. type: Plain text
#: man-pages/man3/fenv.3:284
msgid ""
"The B<feclearexcept>(), B<fegetexceptflag>(), B<fegetexceptflag>(), "
"B<fesetexceptflag>(), B<fetestexcept>(), B<fegetround>(), B<fesetround>(), "
"B<fegetenv>(), B<feholdexcept>(), B<fesetenv>(), B<feupdateenv>(), "
"B<feenableexcept>(), B<fedisableexcept>(), and B<fegetexcept>()  functions "
"are thread-safe."
msgstr ""
"Функции B<feclearexcept>(), B<fegetexceptflag>(), B<fegetexceptflag>(), B<"
"fesetexceptflag>(), B<fetestexcept>(), B<fegetround>(), B<fesetround>(), B<"
"fegetenv>(), B<feholdexcept>(), B<fesetenv>(), B<feupdateenv>(), B<"
"feenableexcept>(), B<fedisableexcept>() и B<fegetexcept>() можно использовать "
"в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/fenv.3:286
msgid "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."
msgstr "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fenv.3:306
msgid ""
"If possible, the GNU C Library defines a macro B<FE_NOMASK_ENV> which "
"represents an environment where every exception raised causes a trap to "
"occur.  You can test for this macro using B<#ifdef>.  It is defined only if "
"B<_GNU_SOURCE> is defined.  The C99 standard does not define a way to set "
"individual bits in the floating-point mask, for example, to trap on specific"
" flags.  Since version 2.2, glibc supports the functions B<feenableexcept>()"
"  and B<fedisableexcept>()  to set individual floating-point traps, and "
"B<fegetexcept>()  to query the state."
msgstr ""
"Если возможно, библиотека GNU C определяет макрос B<FE_NOMASK_ENV>, "
"представляющий окружение, в котором при каждом возбуждении исключения "
"срабатывает ловушка (trap). Вы можете проверить этот макрос с помощью B<"
"#ifdef>. Он определён, только при определении B<_GNU_SOURCE>. В стандарте C99 "
"нет способа установить отдельные биты в маске плавающей запятой, например, "
"чтобы отловить определённые флаги. Начиная с версии 2.2, в glibc "
"поддерживаются функции B<feenableexcept>() и B<fedisableexcept>(), которые "
"устанавливают отдельные ловушки плавающей запятой, и B<fegetexcept>() для "
"получения состояния."

#. type: Plain text
#: man-pages/man3/fenv.3:309
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"

#. type: Plain text
#: man-pages/man3/fenv.3:313
#, no-wrap
msgid "B<int feenableexcept(int >I<excepts>B<);>\n"
msgstr "B<int feenableexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:315
#, no-wrap
msgid "B<int fedisableexcept(int >I<excepts>B<);>\n"
msgstr "B<int fedisableexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:317
#, no-wrap
msgid "B<int fegetexcept(void);>\n"
msgstr "B<int fegetexcept(void);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:331
msgid ""
"The B<feenableexcept>()  and B<fedisableexcept>()  functions enable "
"(disable) traps for each of the exceptions represented by I<excepts> and "
"return the previous set of enabled exceptions when successful, and -1 "
"otherwise.  The B<fegetexcept>()  function returns the set of all currently "
"enabled exceptions."
msgstr ""
"Функции B<feenableexcept>() и B<fedisableexcept>() включают (отключают) "
"ловушки для каждого исключения, представленного в I<excepts>, и при успешном "
"выполнении возвращают старый набор включённых исключений, и  -1 в противном "
"случае. Функция B<fegetexcept>() возвращает набор всех включённых в данных "
"момент исключений."

#.  Aug 08, glibc 2.8
#.  See http://gcc.gnu.org/ml/gcc/2002-02/msg01535.html
#. type: Plain text
#: man-pages/man3/fenv.3:342
msgid ""
"C99 specifies that the value of B<FLT_ROUNDS> should reflect changes to the "
"current rounding mode, as set by B<fesetround>().  Currently, this does not "
"occur: B<FLT_ROUNDS> always has the value 1."
msgstr ""
"В C99 указано, что значение B<FLT_ROUNDS> должно отражать изменения текущего "
"режима округления, устанавливаемого с помощью B<fesetround>(). В настоящее "
"время это не выполняется: значение B<FLT_ROUNDS> всегда равно 1."

#. type: Plain text
#: man-pages/man3/fenv.3:343
msgid "B<math_error>(7)"
msgstr "B<math_error>(7)"

#. type: TH
#: man-pages/man3/fpclassify.3:10
#, no-wrap
msgid "FPCLASSIFY"
msgstr "FPCLASSIFY"

#. type: Plain text
#: man-pages/man3/fpclassify.3:14
msgid ""
"fpclassify, isfinite, isnormal, isnan, isinf - floating-point classification"
" macros"
msgstr ""
"fpclassify, isfinite, isnormal, isnan, isinf - макросы классификации чисел с "
"плавающей запятой"

#. type: Plain text
#: man-pages/man3/fpclassify.3:19
#, no-wrap
msgid "B<int fpclassify(>I<x>B<);>\n"
msgstr "B<int fpclassify(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:21
#, no-wrap
msgid "B<int isfinite(>I<x>B<);>\n"
msgstr "B<int isfinite(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:23
#, no-wrap
msgid "B<int isnormal(>I<x>B<);>\n"
msgstr "B<int isnormal(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:25
#, no-wrap
msgid "B<int isnan(>I<x>B<);>\n"
msgstr "B<int isnan(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:27
#, no-wrap
msgid "B<int isinf(>I<x>B<);>\n"
msgstr "B<int isinf(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:42
msgid "B<fpclassify>(), B<isfinite>(), B<isnormal>():"
msgstr "B<fpclassify>(), B<isfinite>(), B<isnormal>():"

#. type: Plain text
#: man-pages/man3/fpclassify.3:53
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/fpclassify.3:76
msgid ""
"Floating point numbers can have special values, such as infinite or NaN.  "
"With the macro B<fpclassify(>I<x>B<)> you can find out what type I<x> is.  "
"The macro takes any floating-point expression as argument.  The result is "
"one of the following values:"
msgstr ""
"У чисел с плавающей запятой есть специальные значения, например для "
"бесконечности или NaN. С помощью макроса B<fpclassify(>I<x>B<)> вы можете "
"выяснить тип I<x>. В качестве аргумента макрос принимает любое выражение с "
"плавающей запятой. Результатом будет одно из следующих значений:"

#. type: TP
#: man-pages/man3/fpclassify.3:76
#, no-wrap
msgid "B<FP_NAN>"
msgstr "B<FP_NAN>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:80
msgid "I<x> is \"Not a Number\"."
msgstr "Значение I<x> не является числом («Not a Number»)."

#. type: TP
#: man-pages/man3/fpclassify.3:80
#, no-wrap
msgid "B<FP_INFINITE>"
msgstr "B<FP_INFINITE>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:84
msgid "I<x> is either positive infinity or negative infinity."
msgstr "Значение I<x> стремится к плюс или минус бесконечности."

#. type: TP
#: man-pages/man3/fpclassify.3:84
#, no-wrap
msgid "B<FP_ZERO>"
msgstr "B<FP_ZERO>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:88
msgid "I<x> is zero."
msgstr "Значение I<x> равно нулю."

#. type: TP
#: man-pages/man3/fpclassify.3:88
#, no-wrap
msgid "B<FP_SUBNORMAL>"
msgstr "B<FP_SUBNORMAL>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:92
msgid "I<x> is too small to be represented in normalized format."
msgstr ""
"Значение I<x> слишком мало для представления в нормализованном формате."

#. type: TP
#: man-pages/man3/fpclassify.3:92
#, no-wrap
msgid "B<FP_NORMAL>"
msgstr "B<FP_NORMAL>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:96
msgid ""
"if nothing of the above is correct then it must be a normal floating-point "
"number."
msgstr ""
"Если значение не равно ни одному из вышеперечисленных, то это обычное число с "
"плавающей запятой."

#. type: Plain text
#: man-pages/man3/fpclassify.3:98
msgid "The other macros provide a short answer to some standard questions."
msgstr ""
"Остальные макросы предоставляют короткие ответы на некоторые стандартные "
"вопросы."

#. type: TP
#: man-pages/man3/fpclassify.3:98
#, no-wrap
msgid "B<isfinite(>I<x>B<)>"
msgstr "B<isfinite(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:101
msgid "returns a nonzero value if"
msgstr "возвращает ненулевое значение, если"

#. type: Plain text
#: man-pages/man3/fpclassify.3:103
msgid "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"
msgstr "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"

#. type: TP
#: man-pages/man3/fpclassify.3:103
#, no-wrap
msgid "B<isnormal(>I<x>B<)>"
msgstr "B<isnormal(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:107
msgid "returns a nonzero value if (fpclassify(x) == FP_NORMAL)"
msgstr "возвращает ненулевое значение, если (fpclassify(x) == FP_NORMAL)"

#. type: TP
#: man-pages/man3/fpclassify.3:107
#, no-wrap
msgid "B<isnan(>I<x>B<)>"
msgstr "B<isnan(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:111
msgid "returns a nonzero value if (fpclassify(x) == FP_NAN)"
msgstr "возвращает ненулевое значение, если (fpclassify(x) == FP_NAN)"

#. type: TP
#: man-pages/man3/fpclassify.3:111
#, no-wrap
msgid "B<isinf(>I<x>B<)>"
msgstr "B<isinf(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:118
msgid ""
"returns 1 if I<x> is positive infinity, and -1 if I<x> is negative infinity."
msgstr ""
"возвращает 1, если I<x> равно положительной бесконечности и -1, если I<x> "
"равно отрицательной бесконечности."

#. type: Plain text
#: man-pages/man3/fpclassify.3:128
msgid ""
"The B<fpclassify>(), B<isfinite>(), B<isnormal>(), B<isnan>(), and "
"B<isinf>()  macros are thread-safe."
msgstr ""
"Макросы B<fpclassify>(), B<isfinite>(), B<isnormal>(), B<isnan>() и B<isinf>"
"() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/fpclassify.3:130
msgid "C99, POSIX.1."
msgstr "C99, POSIX.1."

#. type: Plain text
#: man-pages/man3/fpclassify.3:135
msgid ""
"For B<isinf>(), the standards merely say that the return value is nonzero if"
" and only if the argument has an infinite value."
msgstr ""
"Про B<isinf>() в стандартах лишь сказано, что этот макрос возвращает "
"ненулевое значение, если только аргумент равен бесконечности."

#. type: Plain text
#: man-pages/man3/fpclassify.3:142
msgid ""
"In glibc 2.01 and earlier, B<isinf>()  returns a nonzero value (actually: 1)"
" if I<x> is positive infinity or negative infinity.  (This is all that C99 "
"requires.)"
msgstr ""
"В glibc 2.01 и более ранних B<isinf>() возвращает ненулевое значение (а "
"именно 1), если I<x> равно положительной или отрицательной бесконечности (это "
"всё, что требует C99)."

#. type: Plain text
#: man-pages/man3/fpclassify.3:146
msgid "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"
msgstr "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"

#. type: TH
#: man-pages/man3/fpurge.3:25
#, no-wrap
msgid "FPURGE"
msgstr "FPURGE"

#. type: TH
#: man-pages/man3/fpurge.3:25
#, no-wrap
msgid "2001-12-15"
msgstr "2001-12-15"

#. type: Plain text
#: man-pages/man3/fpurge.3:28
msgid "fpurge, __fpurge - purge a stream"
msgstr "fpurge, __fpurge - вычищает поток"

#. type: Plain text
#: man-pages/man3/fpurge.3:32
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr "/* не поддерживается */\nB<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:34
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<int fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:37
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr "/* поддерживается */\nB<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:39
#, no-wrap
msgid "B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr "B<#include E<lt>stdio_ext.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:41
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<void  __fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:54
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""
"Функция B<fpurge>() очищает буферы указанного потока. При этом для потоков "
"вывода отбрасываются все незаписанные данные. Для потоков ввода отбрасывается "
"все данные, полученные от объекта, но ещё не выбранные B<getc>(3), в том "
"числе, любой текст, занесённый с помощью B<ungetc>(3). Смотрите также B<"
"fflush>(3)."

#. type: Plain text
#: man-pages/man3/fpurge.3:58
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a"
" value."
msgstr ""
"Функция B<__fpurge>() делает то же самое, но не возвращает никакого значения."

#. type: Plain text
#: man-pages/man3/fpurge.3:65
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""
"При успешном выполнении B<fpurge>() возвращает 0. При ошибке возвращается -1 "
"и переменная I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man3/fpurge.3:70
msgid "I<stream> is not an open stream."
msgstr "Значение I<stream> не является открытым потоком."

#. type: Plain text
#: man-pages/man3/fpurge.3:78
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()"
"  was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and"
" later."
msgstr ""
"Эти функции нестандартны и не являются переносимыми. Функция B<fpurge>() "
"появилась из BSD 4.4 и отсутствует в Linux. Функция B<__fpurge>() появилась "
"из Solaris и включена в glibc начиная с версии 2.1.95."

#. type: Plain text
#: man-pages/man3/fpurge.3:80
msgid "Usually it is a mistake to want to discard input buffers."
msgstr "Как правило, отбрасывать содержимое буферов ввода является ошибкой."

#.  .BR fclean (3),
#. type: Plain text
#: man-pages/man3/fpurge.3:84
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"

#. type: TH
#: man-pages/man3/futimes.3:25
#, no-wrap
msgid "FUTIMES"
msgstr "FUTIMES"

#. type: TH
#: man-pages/man3/futimes.3:25
#, no-wrap
msgid "2013-10-29"
msgstr "2013-10-29"

#. type: Plain text
#: man-pages/man3/futimes.3:28
msgid "futimes, lutimes - change file timestamps"
msgstr "futimes, lutimes - изменяют метки времени файла"

#. type: Plain text
#: man-pages/man3/futimes.3:31
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/futimes.3:33
#, no-wrap
msgid "B<int futimes(int >I<fd>B<, const struct timeval >I<tv>B<[2]);>\n"
msgstr "B<int futimes(int >I<fd>B<, const struct timeval >I<tv>B<[2]);>\n"

#. type: Plain text
#: man-pages/man3/futimes.3:35
#, no-wrap
msgid ""
"B<int lutimes(const char *>I<filename>B<, const struct timeval "
">I<tv>B<[2]);>\n"
msgstr ""
"B<int lutimes(const char *>I<filename>B<, const struct timeval >I<tv>B<[2]);>"
"\n"

#. type: Plain text
#: man-pages/man3/futimes.3:45
msgid "B<futimes>(), B<lutimes>(): _BSD_SOURCE"
msgstr "B<futimes>(), B<lutimes>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/futimes.3:53
msgid ""
"B<futimes>()  changes the access and modification times of a file in the "
"same way as B<utimes>(2), with the difference that the file whose timestamps"
" are to be changed is specified via a file descriptor, I<fd>, rather than "
"via a pathname."
msgstr ""
"Функция B<futimes>() изменяет время доступа и изменения файла также как это "
"делает B<utimes>(2); единственное отличие в том, что файл чьи временные метки "
"изменяются, указывается в виде файлового дескриптора, I<fd>, а не в виде пути."

#. type: Plain text
#: man-pages/man3/futimes.3:61
msgid ""
"B<lutimes>()  changes the access and modification times of a file in the "
"same way as B<utimes>(2), with the difference that if I<filename> refers to "
"a symbolic link, then the link is not dereferenced: instead, the timestamps "
"of the symbolic link are changed."
msgstr ""
"Функция B<lutimes>() изменяет время доступа и изменения файла также как это "
"делает B<utimes>(2); единственное отличие в том, что если I<filename> "
"является символьной ссылкой, то ссылка не разыменовывается — изменяются метки "
"времени самой ссылки."

#. type: Plain text
#: man-pages/man3/futimes.3:71
msgid ""
"Errors are as for B<utimes>(2), with the following additions for "
"B<futimes>():"
msgstr ""
"Возникают те же ошибки что и для B<utimes>(2), а также дополнительно для B<"
"futimes>():"

#. type: Plain text
#: man-pages/man3/futimes.3:75
msgid "I<fd> is not a valid file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man3/futimes.3:83
msgid "The following additional error may occur for B<lutimes>():"
msgstr "Для B<lutimes>() может возникать следующая дополнительная ошибка:"

#. type: Plain text
#: man-pages/man3/futimes.3:86
msgid ""
"The kernel does not support this call; Linux 2.6.22 or later is required."
msgstr ""
"Ядро не поддерживает этот вызов; требуется Linux версии 2.6.22 или новее."

#. type: Plain text
#: man-pages/man3/futimes.3:93
msgid ""
"B<futimes>()  is available since glibc 2.3.  B<lutimes>()  is available "
"since glibc 2.6, and is implemented using the B<utimensat>(2)  system call, "
"which is supported since kernel 2.6.22."
msgstr ""
"Функция B<futimes>() доступна в glibc начиная с версии 2.3. Функция B<lutimes>"
"() доступа в glibc начиная с версии 2.6, и реализована на основе системного "
"вызова B<utimensat>(2), который поддерживается в ядре начиная с версии 2.6.22."

#. type: Plain text
#: man-pages/man3/futimes.3:100
msgid "The B<futimes>()  and B<lutimes>()  functions are thread-safe."
msgstr ""
"Функции B<futimes>() и B<lutimes>() можно использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/futimes.3:103
msgid ""
"These functions are not specified in any standard.  Other than Linux, they "
"are available only on the BSDs."
msgstr ""
"Эти функции не определены ни в одном стандарте. Помимо Linux, они доступны "
"только в некоторых BSD."

#. type: Plain text
#: man-pages/man3/futimes.3:106
msgid "B<utime>(2), B<utimensat>(2), B<symlink>(7)"
msgstr "B<utime>(2), B<utimensat>(2), B<symlink>(7)"

#. type: TH
#: man-pages/man3/fgetgrent.3:30
#, no-wrap
msgid "FGETGRENT"
msgstr "FGETGRENT"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:33
msgid "fgetgrent - get group file entry"
msgstr "fgetgrent - возвращает запись из файла групп"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:38
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\nB<#include E<lt>sys/types.hE<gt>>\nB<#include "
"E<lt>grp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:40
#, no-wrap
msgid "B<struct group *fgetgrent(FILE *>I<stream>B<);>\n"
msgstr "B<struct group *fgetgrent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:49
msgid "B<fgetgrent>(): _SVID_SOURCE"
msgstr "B<fgetgrent>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:63
msgid ""
"The B<fgetgrent>()  function returns a pointer to a structure containing the"
" group information from the file referred to by I<stream>.  The first time "
"it is called it returns the first entry; thereafter, it returns successive "
"entries.  The file referred to by I<stream> must have the same format as "
"I</etc/group> (see B<group>(5))."
msgstr ""
"Функция B<fgetgrent>() возвращает указатель на структуру, содержащую "
"информацию о группах из файла, на который ссылается I<stream>. Во время "
"первого вызова функция возвращает первую запись; в дальнейшем она возвращает "
"все последующие записи. Формат файла, на который указывает I<stream>, должен "
"быть таким же как у I</etc/group> (смотрите B<group>(5))."

#. type: Plain text
#: man-pages/man3/fgetgrent.3:65
msgid "The I<group> structure is defined in I<E<lt>grp.hE<gt>> as follows:"
msgstr "Структура I<group> определена в I<E<lt>grp.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:75
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;        /* group name */\n"
"    char   *gr_passwd;      /* group password */\n"
"    gid_t   gr_gid;         /* group ID */\n"
"    char  **gr_mem;         /* NULL-terminated array of pointers\n"
"                               to names of group members */\n"
"};\n"
msgstr ""
"struct group {\n"
"    char   *gr_name;        /* имя группы */\n"
"    char   *gr_passwd;      /* пароль группы */\n"
"    gid_t   gr_gid;         /* ID группы */\n"
"    char  **gr_mem;         /* массив, указателей\n"
"                               имён членов группы, оканчивающийся NULL */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:87
msgid ""
"The B<fgetgrent>()  function returns a pointer to a I<group> structure, or "
"NULL if there are no more entries or an error occurs.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<fgetgrent>() возвращает указатель на структуру I<group> или NULL, "
"если больше записей не найдено или произошла ошибка. При ошибке I<errno> "
"присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fgetgrent.3:93
msgid "Insufficient memory to allocate I<group> structure."
msgstr "Недостаточно памяти для структуры I<group>."

#. type: Plain text
#: man-pages/man3/fgetgrent.3:104
msgid ""
"B<endgrent>(3), B<fgetgrent_r>(3), B<fopen>(3), B<getgrent>(3), "
"B<getgrgid>(3), B<getgrnam>(3), B<putgrent>(3), B<setgrent>(3), B<group>(5)"
msgstr ""
"B<endgrent>(3), B<fgetgrent_r>(3), B<fopen>(3), B<getgrent>(3), B<getgrgid>"
"(3), B<getgrnam>(3), B<putgrent>(3), B<setgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/ftok.3:29
#, no-wrap
msgid "FTOK"
msgstr "FTOK"

#. type: TH
#: man-pages/man3/ftok.3:29
#, no-wrap
msgid "2013-10-07"
msgstr "2013-10-07"

#. type: Plain text
#: man-pages/man3/ftok.3:32
msgid ""
"ftok - convert a pathname and a project identifier to a System V IPC key"
msgstr "ftok - преобразует путь и идентификатор проекта в ключ System V IPC"

#. type: Plain text
#: man-pages/man3/ftok.3:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/ipc.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ftok.3:39
msgid "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"
msgstr "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"

#. type: Plain text
#: man-pages/man3/ftok.3:54
msgid ""
"The B<ftok>()  function uses the identity of the file named by the given "
"I<pathname> (which must refer to an existing, accessible file)  and the "
"least significant 8 bits of I<proj_id> (which must be nonzero) to generate a"
" I<key_t> type System V IPC key, suitable for use with B<msgget>(2), "
"B<semget>(2), or B<shmget>(2)."
msgstr ""
"Функция B<ftok>() использует отличительные свойства (identity) файла с именем "
"I<pathname> (которое должно указывать на существующий и доступный файл) и "
"младшие 8 бит аргумента I<proj_id> (который должен быть не равен нулю) для "
"генерации ключа System V IPC I<key_t>, который пригоден для работы с B<msgget>"
"(2), B<semget>(2) или B<shmget>(2)."

#. type: Plain text
#: man-pages/man3/ftok.3:61
msgid ""
"The resulting value is the same for all pathnames that name the same file, "
"when the same value of I<proj_id> is used.  The value returned should be "
"different when the (simultaneously existing) files or the project IDs "
"differ."
msgstr ""
"Возвращаемое значение одинаково для всех имён, указывающих на один и тот же "
"файл при одинаковом значении I<proj_id>. Возвращаемое значение будет "
"отличаться, когда (одновременно существующие) файлы или идентификаторы "
"проекта различаются."

#. type: Plain text
#: man-pages/man3/ftok.3:70
msgid ""
"On success, the generated I<key_t> value is returned.  On failure -1 is "
"returned, with I<errno> indicating the error as for the B<stat>(2)  system "
"call."
msgstr ""
"При успешном выполнении возвращается сгенерированное значение I<key_t>. При "
"ошибке возвращается -1, а в переменную I<errno> записывается код ошибки "
"согласно системному вызову B<stat>(2)."

#. type: Plain text
#: man-pages/man3/ftok.3:75
msgid "The B<ftok>()  function is thread-safe."
msgstr "Функцию B<ftok>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/ftok.3:79
msgid "Under libc4 and libc5 (and under SunOS 4.x) the prototype was:"
msgstr "В libc4 и libc5 (а также в SunOS 4.x) прототип функции выглядел так:"

#. type: Plain text
#: man-pages/man3/ftok.3:82
msgid "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>"
msgstr "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>"

#. type: Plain text
#: man-pages/man3/ftok.3:94
msgid ""
"Today I<proj_id> is an I<int>, but still only 8 bits are used.  Typical "
"usage has an ASCII character I<proj_id>, that is why the behavior is said to"
" be undefined when I<proj_id> is zero."
msgstr ""
"В наши дни I<proj_id> имеет тип I<int>, хотя, как правило, по-прежнему из "
"него используется только 8 бит. Обычно, при вызове этой функции в качестве I<"
"proj_id> передаётся символ ASCII, именно поэтому поведение функции считается "
"не определённым, если I<proj_id> равен нулю."

#. type: Plain text
#: man-pages/man3/ftok.3:106
msgid ""
"Of course no guarantee can be given that the resulting I<key_t> is unique.  "
"Typically, a best effort attempt combines the given I<proj_id> byte, the "
"lower 16 bits of the inode number, and the lower 8 bits of the device number"
" into a 32-bit result.  Collisions may easily happen, for example between "
"files on I</dev/hda1> and files on I</dev/sda1>."
msgstr ""
"Естественно, не гарантируется, что возвращаемый I<key_t> уникален. Обычно, "
"производится объединение указанного байта I<proj_id> с младшими 16 битами "
"номера inode и младшими 8 битам номера устройства в 32-битный результат. "
"Легко могут возникать конфликты, например между файлами на I</dev/hda1> и "
"файлами на I</dev/sda1>."

#. type: Plain text
#: man-pages/man3/ftok.3:111
msgid "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<svipc>(7)"
msgstr "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<svipc>(7)"

#. type: TH
#: man-pages/man3/fopen.3:44
#, no-wrap
msgid "FOPEN"
msgstr "FOPEN"

#. type: TH
#: man-pages/man3/fopen.3:44
#, no-wrap
msgid "2012-04-22"
msgstr "2012-04-22"

#. type: Plain text
#: man-pages/man3/fopen.3:47
msgid "fopen, fdopen, freopen - stream open functions"
msgstr "fopen, fdopen, freopen - функции для открытия потоков"

#. type: Plain text
#: man-pages/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fopen(const char *>I<path>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fopen(const char *>I<path>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopen.3:54
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopen.3:56
#, no-wrap
msgid ""
"B<FILE *freopen(const char *>I<path>B<, const char *>I<mode>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""
"B<FILE *freopen(const char *>I<path>B<, const char *>I<mode>B<, FILE *>I<"
"stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopen.3:65
msgid ""
"B<fdopen>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<fdopen>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/fopen.3:71
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<path> and associates a stream with it."
msgstr ""
"Функция B<fopen>() открывает файл с именем, которое задано в виде строки в I<"
"path>, и связывает его с потоком."

#. type: Plain text
#: man-pages/man3/fopen.3:76
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (possibly followed by additional characters, as described below):"
msgstr ""
"Параметр I<mode> указывает на строку, начинающуюся с одной из следующих "
"последовательностей (за ними могут следовать дополнительные символы, "
"описанные далее):"

#. type: TP
#: man-pages/man3/fopen.3:76
#, no-wrap
msgid "B<r>"
msgstr "B<r>"

#. type: Plain text
#: man-pages/man3/fopen.3:80
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr "Открыть текстовый файл для чтения. Поток совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:80
#, no-wrap
msgid "B<r+>"
msgstr "B<r+>"

#. type: Plain text
#: man-pages/man3/fopen.3:84
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr "Открыть для чтения и записи. Поток совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:84
#, no-wrap
msgid "B<w>"
msgstr "B<w>"

#. type: Plain text
#: man-pages/man3/fopen.3:88
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is"
" positioned at the beginning of the file."
msgstr ""
"Обрезать файл до нулевой длины или создать текстовый файл для записи. Поток "
"совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:88
#, no-wrap
msgid "B<w+>"
msgstr "B<w+>"

#. type: Plain text
#: man-pages/man3/fopen.3:94
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the"
" file."
msgstr ""
"Открыть для чтения и записи. Файл создаётся, если его не существует, в "
"противном случае он обрезается. Поток совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:94
#, no-wrap
msgid "B<a>"
msgstr "B<a>"

#. type: Plain text
#: man-pages/man3/fopen.3:99
msgid ""
"Open for appending (writing at end of file).  The file is created if it does"
" not exist.  The stream is positioned at the end of the file."
msgstr ""
"Открыть для добавления (записи в конец файла). Файл создаётся, если его не "
"существует. Поток совмещается с концом файла."

#. type: TP
#: man-pages/man3/fopen.3:99
#, no-wrap
msgid "B<a+>"
msgstr "B<a+>"

#. type: Plain text
#: man-pages/man3/fopen.3:105
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  The initial file position for reading is at "
"the beginning of the file, but output is always appended to the end of the "
"file."
msgstr ""
"Открыть для чтения и добавления (записи в конец файла). Файл создаётся, если "
"не существует. Начальное положение в файле для чтения устанавливается в "
"начало файла, но вывод всегда добавляется в конец файла."

#. type: Plain text
#: man-pages/man3/fopen.3:118
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the two-"
"character strings described above.  This is strictly for compatibility with "
"C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX conforming "
"systems, including Linux.  (Other systems may treat text files and binary "
"files differently, and adding the \\(aqb\\(aq may be a good idea if you do "
"I/O to a binary file and expect that your program may be ported to non-UNIX "
"environments.)"
msgstr ""
"Строка I<mode> может также содержать символ «b» в качестве последнего символа "
"или символа между двумя символами в любых описанных выше двухсимвольных "
"комбинациях. Это требуется только для совместимости с C89 и не оказывает "
"никакого влияния; символ «b» игнорируется во всех POSIX-совместимых системах, "
"включая Linux. Другие системы могут по-разному обращаться с текстовыми и "
"двоичными файлами, и добавление «b» может оказаться полезным, если вы "
"осуществляете ввод-вывод в двоичный файл и ожидаете, что ваша программа может "
"быть перенесена в не UNIX окружение."

#. type: Plain text
#: man-pages/man3/fopen.3:121
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr "О имеющихся расширениях I<mode> в glibc смотрите ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man3/fopen.3:126
msgid ""
"Any created files will have mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""
"Любой созданный файл будет иметь атрибуты B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP>"
" | B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), как изменённые в соответствии "
"со значением umask процесса (смотрите B<umask>(2))."

#. type: Plain text
#: man-pages/man3/fopen.3:141
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note"
" that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or "
"B<fgetpos>(3)  operation between write and read operations on such a stream."
"  This operation may be an apparent no-op (as in I<fseek(..., 0L, SEEK_CUR)>"
" called for its synchronizing side effect)."
msgstr ""
"Чтение и запись могут перемешиваться друг с другом в потоке, открытом для "
"чтения/записи, в любом порядке). Заметим, что в ANSI C требуется, чтобы между "
"выводом и вводом использовались функции позиционирования в файле, если "
"операция ввода не встретила конец файла. Если это условие не выполняется, то "
"при чтении разрешается возвращать результат, не совпадающий с данными самой "
"последней записи. Поэтому рекомендуется (а иногда и действительно необходимо "
"в Linux) использовать функции B<fseek>(3) или B<fgetpos>(3) между операциями "
"чтения и записи в одном потоке. Эти операции могут фактически быть пустыми "
"(например, I<fseek(..., 0L, SEEK_CUR)>, вызванная для того, чтобы возник её "
"побочный эффект синхронизации)."

#. type: Plain text
#: man-pages/man3/fopen.3:146
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at end-of-"
"file, as if preceded the call:"
msgstr ""
"Открытие файла в режиме дописывания (B<a> в качестве первого символа I<mode>) "
"приводит к тому, что все последующие операции записи в этот поток "
"производятся в конец файла, как если бы перед ними была вызвана:"

#. type: Plain text
#: man-pages/man3/fopen.3:149
#, no-wrap
msgid "    fseek(stream, 0, SEEK_END);\n"
msgstr "    fseek(stream, 0, SEEK_END);\n"

#. type: Plain text
#: man-pages/man3/fopen.3:171
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", "
"\"r+\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of "
"the file descriptor.  The file position indicator of the new stream is set "
"to that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by"
" B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""
"Функция B<fdopen>() связывает поток с существующим дескриптором файла I<fd>. "
"Режим I<mode> потока (одно из следующих значений: «r», «r+», «w», ,w+», «a», "
"«a+») должен быть совместим с режимом дескриптора файла. Указатель положения "
"в файле в новом потоке принимает значение, равное значению у I<fd>, а "
"указатели ошибок и конца файла очищаются. Режимы «w» или «w+» не обрезают "
"файл. При этом не делается копия дескриптора файла и он будет закрыт "
"одновременно с закрытием потока, созданного B<fdopen>(). Результат применения "
"B<fdopen>() к общему объекту памяти не определён."

#. type: Plain text
#: man-pages/man3/fopen.3:189
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<path> and associates the stream pointed to by I<stream> with it.  "
"The original stream (if it exists) is closed.  The I<mode> argument is used "
"just as in the B<fopen>()  function.  The primary use of the B<freopen>()  "
"function is to change the file associated with a standard text stream "
"(I<stderr>, I<stdin>, or I<stdout>)."
msgstr ""
"Функция B<freopen>() открывает файл с именем I<path> и связывает его с "
"потоком I<stream>. Исходный поток (если такой существовал) закрывается. "
"Значение параметра I<mode> такое же как у функции B<fopen>(). Основной "
"задачей функции B<freopen>() является смена файла, связанного со стандартным "
"текстовым потоком (I<stderr>, I<stdin> или I<stdout>)."

#. type: Plain text
#: man-pages/man3/fopen.3:201
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>()  and B<freopen>()  return"
" a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"При успешном выполнении B<fopen>(), B<fdopen>() и B<freopen>() возвращается "
"указатель I<FILE>. В противном случае возвращается NULL и I<errno> "
"присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/fopen.3:212
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""
"Передано неверное значение I<mode> в B<fopen>(), B<fdopen>() или B<freopen>()."

#. type: Plain text
#: man-pages/man3/fopen.3:222
msgid ""
"The B<fopen>(), B<fdopen>()  and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""
"Функции B<fopen>(), B<fdopen>() и B<freopen>() могут также завершаться с "
"ошибками и устанавливают значение I<errno> равным какому-либо значению из "
"определённых в B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/fopen.3:229
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""
"Функция B<fopen>() при ошибках устанавливает значение I<errno> равным "
"какому-либо значению из определённых в B<open>(2)."

#. type: Plain text
#: man-pages/man3/fopen.3:236
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""
"Функция B<fdopen>() при ошибках устанавливает значение I<errno> равным "
"какому-либо значению из определённых в B<fcntl>(2)."

#. type: Plain text
#: man-pages/man3/fopen.3:246
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3)  and "
"B<fflush>(3)."
msgstr ""
"Функция B<freopen>() при ошибках устанавливает I<errno> равным какому-либо "
"значению из определённых в B<open>(2), B<fclose>(3) и B<fflush>(3)."

#. type: Plain text
#: man-pages/man3/fopen.3:255
msgid ""
"The B<fopen>()  and B<freopen>()  functions conform to C89.  The B<fdopen>()"
"  function conforms to POSIX.1-1990."
msgstr ""
"Функции B<fopen>() и B<freopen>() соответствуют стандарту C89. Функция B<"
"fdopen>() соответствует стандарту POSIX.1-1990."

#. type: Plain text
#: man-pages/man3/fopen.3:259
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr "Библиотека GNU C предоставляет следующие расширения строки в I<mode>:"

#. type: TP
#: man-pages/man3/fopen.3:259
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr "B<c> (начиная с glibc 2.3.3)"

#. type: Plain text
#: man-pages/man3/fopen.3:266
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points.  This flag is ignored for B<fdopen>()."
msgstr ""
"Не выполнять операцию открытия, последующие чтение и запись, точки отмены "
"нити (thread cancellation points). Этот флаг игнорируется для B<fdopen>()."

#. type: TP
#: man-pages/man3/fopen.3:266
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr "B<e> (начиная с glibc 2.7)"

#. type: Plain text
#: man-pages/man3/fopen.3:276
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information.  This flag is ignored for B<fdopen>()."
msgstr ""
"Открыть файл с флагом B<O_CLOEXEC>. Подробности смотрите в B<open>(2). Этот "
"флаг игнорируется для B<fdopen>()."

#. type: TP
#: man-pages/man3/fopen.3:276
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr "B<m> (начиная с glibc 2.3)"

#.  As at glibc 2.4:
#. type: Plain text
#: man-pages/man3/fopen.3:288
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is attempted only "
"for a file opened for reading."
msgstr ""
"Пытаться получить доступ к файлу с помощью B<mmap>(2), а не с помощью "
"системных операций ввода-вывода (B<read>(2), B<write>(2)). В настоящее время "
"B<mmap>(2) используется только для файла, открытого на чтение."

#. type: TP
#: man-pages/man3/fopen.3:288
#, no-wrap
msgid "B<x>"
msgstr "B<x>"

#.  Since glibc 2.0?
#.  FIXME C11 specifies this flag
#. type: Plain text
#: man-pages/man3/fopen.3:305
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""
"Открыть файл в монопольном режиме (как с флагом B<O_EXCL> у B<open>(2)). Если "
"файл уже существует, то B<fopen>() завершается с ошибкой и устанавливает "
"значение I<errno> равное B<EEXIST>. Этот флаг игнорируется для B<fdopen>()."

#. type: Plain text
#: man-pages/man3/fopen.3:313
msgid ""
"In addition to the above characters, B<fopen>()  and B<freopen>()  support "
"the following syntax in I<mode>:"
msgstr ""
"В дополнении к этим символам, для B<fopen>() и B<freopen>() поддерживается "
"следующий синтаксис в I<mode>:"

#. type: Plain text
#: man-pages/man3/fopen.3:315
msgid "B< ,ccs=>I<string>"
msgstr "B< ,ccs=>I<строка>"

#. type: Plain text
#: man-pages/man3/fopen.3:331
msgid ""
"The given I<string> is taken as the name of a coded character set and the "
"stream is marked as wide-oriented.  Thereafter, internal conversion "
"functions convert I/O to and from the character set I<string>.  If the "
"B<,ccs=>I<string> syntax is not specified, then the wide-orientation of the "
"stream is determined by the first file operation.  If that operation is a "
"wide-character operation, the stream is marked wide-oriented, and functions "
"to convert to the coded character set are loaded."
msgstr ""
"Передаваемая I<строка> используется как имя набора символов и поток "
"помечается как широкосимвольный. С того момента внутренние функции "
"преобразования перекодируют данные ввода-вывода в соответствии с набором "
"символов с именем I<строка>. Если синтаксис B<,ccs=>I<строка> не указан, то "
"широкосимвольность потока определяется по первой файловой операции. Если это "
"операция является широкосимвольной, то поток помечается как широкосимвольный "
"и загружаются функции для перекодировки."

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12685
#. type: Plain text
#: man-pages/man3/fopen.3:348
msgid ""
"When parsing for individual flag characters in I<mode> (i.e., the characters"
" preceding the \"ccs\" specification), the glibc implementation of "
"B<fopen>()  and B<freopen>()  limits the number of characters examined in "
"I<mode> to 7 (or, in glibc versions before 2.14, to 6, which was not enough "
"to include possible specifications such as \"rb+cmxe\").  The current "
"implementation of B<fdopen>()  parses at most 5 characters in I<mode>."
msgstr ""
"При анализе отдельных флагов в I<mode> (т. е., символов перед «ccs») "
"реализация glibc для B<fopen>() и B<freopen>() ограничивает количество "
"обрабатываемых в I<mode> символов 7-ю (или, в glibc до версии 2.14, 6-ю, что "
"было недостаточно для включения всех возможных флагов, например «rb+cmxe»). "
"Текущая реализация B<fdopen>() анализирует в I<mode> не более 5 символов."

#. type: Plain text
#: man-pages/man3/fopen.3:353
msgid ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3)"
msgstr ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3)"

#. type: TH
#: man-pages/man3/ftime.3:30
#, no-wrap
msgid "FTIME"
msgstr "FTIME"

#. type: TH
#: man-pages/man3/ftime.3:30
#, no-wrap
msgid "2013-09-26"
msgstr "2013-09-26"

#. type: Plain text
#: man-pages/man3/ftime.3:33
msgid "ftime - return date and time"
msgstr "ftime - возвращает дату и время"

#. type: Plain text
#: man-pages/man3/ftime.3:35
msgid "B<#include E<lt>sys/timeb.hE<gt>>"
msgstr "B<#include E<lt>sys/timeb.hE<gt>>"

#. type: Plain text
#: man-pages/man3/ftime.3:37
msgid "B<int ftime(struct timeb *>I<tp>B<);>"
msgstr "B<int ftime(struct timeb *>I<tp>B<);>"

#. type: Plain text
#: man-pages/man3/ftime.3:43
msgid ""
"This function returns the current time as seconds and milliseconds since the"
" Epoch, 1970-01-01 00:00:00 +0000 (UTC).  The time is returned in I<tp>, "
"which is declared as follows:"
msgstr ""
"Данная функция возвращает текущее время в секундах и миллисекундах, прошедших "
"начиная с эпохи (Epoch), 1970-01-01 00:00:00 +0000 (UTC). Время возвращается "
"в I<tp>, определённой следующим образом:"

#. type: Plain text
#: man-pages/man3/ftime.3:52
#, no-wrap
msgid ""
"struct timeb {\n"
"    time_t         time;\n"
"    unsigned short millitm;\n"
"    short          timezone;\n"
"    short          dstflag;\n"
"};\n"
msgstr ""
"struct timeb {\n    time_t         time;\n    unsigned short millitm;\n    "
"short          timezone;\n    short          dstflag;\n};\n"

#. type: Plain text
#: man-pages/man3/ftime.3:64
msgid ""
"Here I<time> is the number of seconds since the Epoch, and I<millitm> is the"
" number of milliseconds since I<time> seconds since the Epoch.  The "
"I<timezone> field is the local timezone measured in minutes of time west of "
"Greenwich (with a negative value indicating minutes east of Greenwich).  The"
" I<dstflag> field is a flag that, if nonzero, indicates that Daylight Saving"
" time applies locally during the appropriate part of the year."
msgstr ""
"В данной структуре I<time> — это количество секунд с начала эпохи; I<millitm> "
"— количество миллисекунд, прошедших после I<time> секунд с начала эпохи. Поле "
"I<timezone> — локальный часовой пояс, измеряемый в минутах западнее Гринвича "
"(отрицательные значения означают минуты восточнее Гринвича). Поле I<dstflag> "
"— флаг, ненулевое значение которого указывает, что в соответствующее время "
"года используется летнее время."

#. type: Plain text
#: man-pages/man3/ftime.3:67
msgid ""
"POSIX.1-2001 says that the contents of the I<timezone> and I<dstflag> fields"
" are unspecified; avoid relying on them."
msgstr ""
"В POSIX.1-2001 сказано, что содержимое полей I<timezone> и I<dstflag> не "
"определено; не используйте их."

#. type: Plain text
#: man-pages/man3/ftime.3:70
msgid ""
"This function always returns 0.  (POSIX.1-2001 specifies, and some systems "
"document, a -1 error return.)"
msgstr ""
"Эта функция всегда возвращает 0 (в POSIX.1-2001, а также в некоторых системах "
"возвращается -1 при ошибке)."

#. type: Plain text
#: man-pages/man3/ftime.3:75
msgid "The B<ftime>()  function is thread-safe."
msgstr "Функцию B<ftime>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/ftime.3:79
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of B<ftime>()."
msgstr "4.2BSD, POSIX.1-2001. В POSIX.1-2008 спецификация B<ftime>() удалена."

#. type: Plain text
#: man-pages/man3/ftime.3:90
msgid ""
"This function is obsolete.  Don't use it.  If the time in seconds suffices, "
"B<time>(2)  can be used; B<gettimeofday>(2)  gives microseconds; "
"B<clock_gettime>(2)  gives nanoseconds but is not as widely available."
msgstr ""
"Эта функция устарела. Не используйте её. В случаях, когда достаточно секунд, "
"можно использовать B<time>(2); B<gettimeofday>(2) позволяет работать с "
"микросекундами; функция B<clock_gettime>(3) позволяет работать с "
"наносекундами, однако она пока ещё не очень широко распространена."

#.  .SH HISTORY
#.  The
#.  .BR ftime ()
#.  function appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man3/ftime.3:99
msgid ""
"Under libc4 and libc5 the I<millitm> field is meaningful.  But early glibc2 "
"is buggy and returns 0 there; glibc 2.1.1 is correct again."
msgstr ""
"В libc4 и libc5 поле I<millitm> представляет для пользователя особый интерес. "
"Но ранние версии glibc2 работают некорректно и возвращают в этом поле нулевое "
"значение; начиная с glibc 2.1.1 эта ошибка исправлена."

#. type: Plain text
#: man-pages/man3/ftime.3:101
msgid "B<gettimeofday>(2), B<time>(2)"
msgstr "B<gettimeofday>(2), B<time>(2)"


