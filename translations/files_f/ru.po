# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2017.
# Dmitry Bolkhovskikh <d20052005@yandex.ru>, 2017.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019.
# Yuri Kozlov <yuray@komyakino.ru>, 2013.
# Иван Павлов <pavia00@gmail.com>, 2017.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:25+0300\n"
"PO-Revision-Date: 2019-09-27 19:31+0300\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "FULL"
msgstr "FULL"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/full.4:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/full.4:27
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/full.4:29
msgid "full - always full device"
msgstr "full - всегда полное устройство"

#. type: SH
#: man-pages/man4/full.4:29
#, no-wrap
msgid "CONFIGURATION"
msgstr "НАСТРОЙКА"

#. type: Plain text
#: man-pages/man4/full.4:34
msgid ""
"If your system does not have I</dev/full> created already, it can be created "
"with the following commands:"
msgstr ""
"Если в системе нет файла I</dev/full>, то его можно создать при помощи "
"следующих команд:"

#. type: Plain text
#: man-pages/man4/full.4:39
#, no-wrap
msgid ""
"mknod -m 666 /dev/full c 1 7\n"
"chown root:root /dev/full\n"
msgstr ""
"mknod -m 666 /dev/full c 1 7\n"
"chown root:root /dev/full\n"

#. type: SH
#: man-pages/man4/full.4:41
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/full.4:46
msgid ""
"The file I</dev/full> has major device number 1 and minor device number 7."
msgstr ""
"Файл I</dev/full> имеет основной номер устройства, равный 1, и "
"второстепенный, равный 7."

#. type: Plain text
#: man-pages/man4/full.4:53
msgid ""
"Writes to the I</dev/full> device fail with an B<ENOSPC> error.  This can be "
"used to test how a program handles disk-full errors."
msgstr ""
"При записи в устройство I</dev/full> возвращается ошибка B<ENOSPC>. Это "
"можно использовать для проверки обработки ошибки переполнения диска в "
"программе."

#. type: Plain text
#: man-pages/man4/full.4:57
msgid "Reads from the I</dev/full> device will return \\e0 characters."
msgstr "При попытке чтения файла I</dev/full> будут возвращаться символы \\e0."

#. type: Plain text
#: man-pages/man4/full.4:61
msgid "Seeks on I</dev/full> will always succeed."
msgstr "Перемещение по I</dev/full> всегда выполняется успешно."

#. type: SH
#: man-pages/man4/full.4:61
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/full.4:63
msgid "I</dev/full>"
msgstr "I</dev/full>"

#. type: SH
#: man-pages/man4/full.4:63
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/full.4:66
msgid "B<mknod>(1), B<null>(4), B<zero>(4)"
msgstr "B<mknod>(1), B<null>(4), B<zero>(4)"

#. type: TH
#: man-pages/man4/fd.4:28
#, no-wrap
msgid "FD"
msgstr "FD"

#. type: TH
#: man-pages/man4/fd.4:28
#, no-wrap
msgid "2014-05-10"
msgstr "2014-05-10"

#. type: Plain text
#: man-pages/man4/fd.4:31
msgid "fd - floppy disk device"
msgstr "fd - устройство для работы с дисководом"

#. type: Plain text
#: man-pages/man4/fd.4:48
msgid ""
"Floppy drives are block devices with major number 2.  Typically they are "
"owned by root:floppy (i.e., user root, group floppy) and have either mode "
"0660 (access checking via group membership) or mode 0666 (everybody has "
"access).  The minor numbers encode the device type, drive number, and "
"controller number.  For each device type (that is, combination of density "
"and track count)  there is a base minor number.  To this base number, add "
"the drive's number on its controller and 128 if the drive is on the "
"secondary controller.  In the following device tables, I<n> represents the "
"drive number."
msgstr ""
"Дисководы гибких дисков — блочные устройства со старшим номером 2. Обычно их "
"владельцем является root.floppy (т.е. пользователь root, группа floppy), а "
"права доступа к ним — 0660 (доступно членам группы) или 0666 (доступно "
"всем). Младший номер определяется типом устройства, номером устройства, и "
"номером контроллера. Для каждого типа устройства, то есть комбинации объёма "
"и количества дорожек, существует базовый младший номер. К этому базовому "
"номеру прибавьте номер устройства в пределах его контроллера и ещё 128, если "
"дисковод подключен к вторичному контроллеру. В нижеследующих таблицах I<n> "
"означает номер дисковода."

#. type: Plain text
#: man-pages/man4/fd.4:55
msgid ""
"B<Warning: if you use formats with more tracks than supported by your drive, "
"you may cause it mechanical damage.> Trying once if more tracks than the "
"usual 40/80 are supported should not damage it, but no warranty is given for "
"that.  If you are not sure, don't create device entries for those formats, "
"so as to prevent their usage."
msgstr ""
"B<Предупреждение: Если вы используете формат дискет с большим числом "
"дорожек, чем поддерживает ваш дисковод, вы можете вызвать механическое "
"повреждение.> Однократная попытка поработать с числом дорожек больше обычных "
"40/80, не должна его повредить, но нет гарантии, что этого не произойдет. "
"Если вы не уверены, не создавайте устройства для таких форматов, чтобы "
"предотвратить их использование."

#. type: Plain text
#: man-pages/man4/fd.4:58
msgid ""
"Drive-independent device files which automatically detect the media format "
"and capacity:"
msgstr ""
"Файлы устройств, не зависящие от дисковода, которые автоматически определяют "
"формат носителя и ёмкость диска:"

#. type: tbl table
#: man-pages/man4/fd.4:61 man-pages/man4/fd.4:71 man-pages/man4/fd.4:81
#: man-pages/man4/fd.4:100 man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Name"
msgstr "Имя"

#. type: tbl table
#: man-pages/man4/fd.4:61 man-pages/man4/fd.4:71 man-pages/man4/fd.4:81
#: man-pages/man4/fd.4:100 man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Base"
msgstr "Основной"

#. type: tbl table
#: man-pages/man4/fd.4:62 man-pages/man4/fd.4:72 man-pages/man4/fd.4:82
#: man-pages/man4/fd.4:101 man-pages/man4/fd.4:115 man-pages/man4/fd.4:136
#, no-wrap
msgid "minor #"
msgstr "младший №"

#. type: tbl table
#: man-pages/man4/fd.4:63 man-pages/man4/fd.4:73 man-pages/man4/fd.4:83
#: man-pages/man4/fd.4:102 man-pages/man4/fd.4:116 man-pages/man4/fd.4:137
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: man-pages/man4/fd.4:64
#, no-wrap
msgid "B<fd>I<n>"
msgstr "B<fd>I<n>"

#. type: tbl table
#: man-pages/man4/fd.4:64
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: man-pages/man4/fd.4:68
msgid "5.25 inch double-density device files:"
msgstr "Файлы устройств с носителями 5.25 дюймов с двойной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Capacity"
msgstr "Ёмкость"

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Cyl."
msgstr "Цил."

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Sect."
msgstr "Сект."

#. type: tbl table
#: man-pages/man4/fd.4:71 man-pages/man4/fd.4:81 man-pages/man4/fd.4:100
#: man-pages/man4/fd.4:114 man-pages/man4/fd.4:135
#, no-wrap
msgid "Heads"
msgstr "Головок"

#. type: tbl table
#: man-pages/man4/fd.4:72 man-pages/man4/fd.4:82 man-pages/man4/fd.4:101
#: man-pages/man4/fd.4:115 man-pages/man4/fd.4:136
#, no-wrap
msgid "KiB"
msgstr "КиБ"

#. type: tbl table
#: man-pages/man4/fd.4:74
#, no-wrap
msgid "B<fd>I<n>B<d360>"
msgstr "B<fd>I<n>B<d360>"

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:103
#: man-pages/man4/fd.4:117
#, no-wrap
msgid "360"
msgstr "360"

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:90
#: man-pages/man4/fd.4:117 man-pages/man4/fd.4:140
#, no-wrap
msgid "40"
msgstr "40"

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:87
#: man-pages/man4/fd.4:103 man-pages/man4/fd.4:104 man-pages/man4/fd.4:117
#: man-pages/man4/fd.4:118
#, no-wrap
msgid "9"
msgstr "9"

#. type: tbl table
#: man-pages/man4/fd.4:74 man-pages/man4/fd.4:84 man-pages/man4/fd.4:85
#: man-pages/man4/fd.4:86 man-pages/man4/fd.4:87 man-pages/man4/fd.4:88
#: man-pages/man4/fd.4:89 man-pages/man4/fd.4:90 man-pages/man4/fd.4:91
#: man-pages/man4/fd.4:92 man-pages/man4/fd.4:93 man-pages/man4/fd.4:104
#: man-pages/man4/fd.4:105 man-pages/man4/fd.4:106 man-pages/man4/fd.4:107
#: man-pages/man4/fd.4:117 man-pages/man4/fd.4:118 man-pages/man4/fd.4:119
#: man-pages/man4/fd.4:120 man-pages/man4/fd.4:121 man-pages/man4/fd.4:122
#: man-pages/man4/fd.4:123 man-pages/man4/fd.4:124 man-pages/man4/fd.4:125
#: man-pages/man4/fd.4:126 man-pages/man4/fd.4:127 man-pages/man4/fd.4:128
#: man-pages/man4/fd.4:138 man-pages/man4/fd.4:139 man-pages/man4/fd.4:140
#: man-pages/man4/fd.4:141 man-pages/man4/fd.4:142
#, no-wrap
msgid "2"
msgstr "2"

#. type: tbl table
#: man-pages/man4/fd.4:74
#, no-wrap
msgid "4"
msgstr "4"

#. type: Plain text
#: man-pages/man4/fd.4:78
msgid "5.25 inch high-density device files:"
msgstr "Файлы устройств с носителями 5.25 дюйма и повышенной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:84
#, no-wrap
msgid "B<fd>I<n>B<h360>"
msgstr "B<fd>I<n>B<h360>"

#. type: tbl table
#: man-pages/man4/fd.4:84 man-pages/man4/fd.4:93 man-pages/man4/fd.4:122
#, no-wrap
msgid "20"
msgstr "20"

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "B<fd>I<n>B<h410>"
msgstr "B<fd>I<n>B<h410>"

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "410"
msgstr "410"

#. type: tbl table
#: man-pages/man4/fd.4:85
#, no-wrap
msgid "41"
msgstr "41"

#. type: tbl table
#: man-pages/man4/fd.4:85 man-pages/man4/fd.4:86 man-pages/man4/fd.4:105
#: man-pages/man4/fd.4:119 man-pages/man4/fd.4:120
#, no-wrap
msgid "10"
msgstr "10"

#. type: tbl table
#: man-pages/man4/fd.4:85 man-pages/man4/fd.4:142
#, no-wrap
msgid "48"
msgstr "48"

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "B<fd>I<n>B<h420>"
msgstr "B<fd>I<n>B<h420>"

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "420"
msgstr "420"

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "42"
msgstr "42"

#. type: tbl table
#: man-pages/man4/fd.4:86
#, no-wrap
msgid "64"
msgstr "64"

#. type: tbl table
#: man-pages/man4/fd.4:87
#, no-wrap
msgid "B<fd>I<n>B<h720>"
msgstr "B<fd>I<n>B<h720>"

#. type: tbl table
#: man-pages/man4/fd.4:87 man-pages/man4/fd.4:104 man-pages/man4/fd.4:118
#, no-wrap
msgid "720"
msgstr "720"

#. type: tbl table
#: man-pages/man4/fd.4:87 man-pages/man4/fd.4:88 man-pages/man4/fd.4:89
#: man-pages/man4/fd.4:90 man-pages/man4/fd.4:93 man-pages/man4/fd.4:103
#: man-pages/man4/fd.4:104 man-pages/man4/fd.4:105 man-pages/man4/fd.4:106
#: man-pages/man4/fd.4:107 man-pages/man4/fd.4:118 man-pages/man4/fd.4:121
#: man-pages/man4/fd.4:122 man-pages/man4/fd.4:123 man-pages/man4/fd.4:126
#: man-pages/man4/fd.4:127 man-pages/man4/fd.4:128 man-pages/man4/fd.4:138
#: man-pages/man4/fd.4:139 man-pages/man4/fd.4:140 man-pages/man4/fd.4:141
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "80"
msgstr "80"

#. type: tbl table
#: man-pages/man4/fd.4:87 man-pages/man4/fd.4:128
#, no-wrap
msgid "24"
msgstr "24"

#. type: tbl table
#: man-pages/man4/fd.4:88
#, no-wrap
msgid "B<fd>I<n>B<h880>"
msgstr "B<fd>I<n>B<h880>"

#. type: tbl table
#: man-pages/man4/fd.4:88
#, no-wrap
msgid "880"
msgstr "880"

#. type: tbl table
#: man-pages/man4/fd.4:88
#, no-wrap
msgid "11"
msgstr "11"

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "B<fd>I<n>B<h1200>"
msgstr "B<fd>I<n>B<h1200>"

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "1200"
msgstr "1200"

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "15"
msgstr "15"

#. type: tbl table
#: man-pages/man4/fd.4:89
#, no-wrap
msgid "8"
msgstr "8"

#. type: tbl table
#: man-pages/man4/fd.4:90
#, no-wrap
msgid "B<fd>I<n>B<h1440>"
msgstr "B<fd>I<n>B<h1440>"

#. type: tbl table
#: man-pages/man4/fd.4:90 man-pages/man4/fd.4:121
#, no-wrap
msgid "1440"
msgstr "1440"

#. type: tbl table
#: man-pages/man4/fd.4:90 man-pages/man4/fd.4:91 man-pages/man4/fd.4:92
#: man-pages/man4/fd.4:121
#, no-wrap
msgid "18"
msgstr "18"

#. type: tbl table
#: man-pages/man4/fd.4:91
#, no-wrap
msgid "B<fd>I<n>B<h1476>"
msgstr "B<fd>I<n>B<h1476>"

#. type: tbl table
#: man-pages/man4/fd.4:91
#, no-wrap
msgid "1476"
msgstr "1476"

#. type: tbl table
#: man-pages/man4/fd.4:91 man-pages/man4/fd.4:119 man-pages/man4/fd.4:124
#, no-wrap
msgid "82"
msgstr "82"

#. type: tbl table
#: man-pages/man4/fd.4:91
#, no-wrap
msgid "56"
msgstr "56"

#. type: tbl table
#: man-pages/man4/fd.4:92
#, no-wrap
msgid "B<fd>I<n>B<h1494>"
msgstr "B<fd>I<n>B<h1494>"

#. type: tbl table
#: man-pages/man4/fd.4:92
#, no-wrap
msgid "1494"
msgstr "1494"

#. type: tbl table
#: man-pages/man4/fd.4:92 man-pages/man4/fd.4:120 man-pages/man4/fd.4:125
#, no-wrap
msgid "83"
msgstr "83"

#. type: tbl table
#: man-pages/man4/fd.4:92
#, no-wrap
msgid "72"
msgstr "72"

#. type: tbl table
#: man-pages/man4/fd.4:93
#, no-wrap
msgid "B<fd>I<n>B<h1600>"
msgstr "B<fd>I<n>B<h1600>"

#. type: tbl table
#: man-pages/man4/fd.4:93 man-pages/man4/fd.4:122
#, no-wrap
msgid "1600"
msgstr "1600"

#. type: tbl table
#: man-pages/man4/fd.4:93
#, no-wrap
msgid "92"
msgstr "92"

#. type: Plain text
#: man-pages/man4/fd.4:97
msgid "3.5 inch double-density device files:"
msgstr "Файлы устройств с носителями 3.5 дюйма и двойной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:103 man-pages/man4/fd.4:117
#, no-wrap
msgid "B<fd>I<n>B<u360>"
msgstr "B<fd>I<n>B<u360>"

#. type: tbl table
#: man-pages/man4/fd.4:103
#, no-wrap
msgid "1"
msgstr "1"

#. type: tbl table
#: man-pages/man4/fd.4:103 man-pages/man4/fd.4:117
#, no-wrap
msgid "12"
msgstr "12"

#. type: tbl table
#: man-pages/man4/fd.4:104 man-pages/man4/fd.4:118
#, no-wrap
msgid "B<fd>I<n>B<u720>"
msgstr "B<fd>I<n>B<u720>"

#. type: tbl table
#: man-pages/man4/fd.4:104 man-pages/man4/fd.4:118
#, no-wrap
msgid "16"
msgstr "16"

#. type: tbl table
#: man-pages/man4/fd.4:105
#, no-wrap
msgid "B<fd>I<n>B<u800>"
msgstr "B<fd>I<n>B<u800>"

#. type: tbl table
#: man-pages/man4/fd.4:105
#, no-wrap
msgid "800"
msgstr "800"

#. type: tbl table
#: man-pages/man4/fd.4:105
#, no-wrap
msgid "120"
msgstr "120"

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "B<fd>I<n>B<u1040>"
msgstr "B<fd>I<n>B<u1040>"

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "1040"
msgstr "1040"

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "13"
msgstr "13"

#. type: tbl table
#: man-pages/man4/fd.4:106
#, no-wrap
msgid "84"
msgstr "84"

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "B<fd>I<n>B<u1120>"
msgstr "B<fd>I<n>B<u1120>"

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "1120"
msgstr "1120"

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "14"
msgstr "14"

#. type: tbl table
#: man-pages/man4/fd.4:107
#, no-wrap
msgid "88"
msgstr "88"

#. type: Plain text
#: man-pages/man4/fd.4:111
msgid "3.5 inch high-density device files:"
msgstr "Файлы устройств с носителями 3.5 дюйма и повышенной плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:119
#, no-wrap
msgid "B<fd>I<n>B<u820>"
msgstr "B<fd>I<n>B<u820>"

#. type: tbl table
#: man-pages/man4/fd.4:119
#, no-wrap
msgid "820"
msgstr "820"

#. type: tbl table
#: man-pages/man4/fd.4:119
#, no-wrap
msgid "52"
msgstr "52"

#. type: tbl table
#: man-pages/man4/fd.4:120
#, no-wrap
msgid "B<fd>I<n>B<u830>"
msgstr "B<fd>I<n>B<u830>"

#. type: tbl table
#: man-pages/man4/fd.4:120
#, no-wrap
msgid "830"
msgstr "830"

#. type: tbl table
#: man-pages/man4/fd.4:120
#, no-wrap
msgid "68"
msgstr "68"

#. type: tbl table
#: man-pages/man4/fd.4:121
#, no-wrap
msgid "B<fd>I<n>B<u1440>"
msgstr "B<fd>I<n>B<u1440>"

#. type: tbl table
#: man-pages/man4/fd.4:121
#, no-wrap
msgid "28"
msgstr "28"

#. type: tbl table
#: man-pages/man4/fd.4:122
#, no-wrap
msgid "B<fd>I<n>B<u1600>"
msgstr "B<fd>I<n>B<u1600>"

#. type: tbl table
#: man-pages/man4/fd.4:122
#, no-wrap
msgid "124"
msgstr "124"

#. type: tbl table
#: man-pages/man4/fd.4:123
#, no-wrap
msgid "B<fd>I<n>B<u1680>"
msgstr "B<fd>I<n>B<u1680>"

#. type: tbl table
#: man-pages/man4/fd.4:123
#, no-wrap
msgid "1680"
msgstr "1680"

#. type: tbl table
#: man-pages/man4/fd.4:123 man-pages/man4/fd.4:124 man-pages/man4/fd.4:125
#, no-wrap
msgid "21"
msgstr "21"

#. type: tbl table
#: man-pages/man4/fd.4:123 man-pages/man4/fd.4:141
#, no-wrap
msgid "44"
msgstr "44"

#. type: tbl table
#: man-pages/man4/fd.4:124
#, no-wrap
msgid "B<fd>I<n>B<u1722>"
msgstr "B<fd>I<n>B<u1722>"

#. type: tbl table
#: man-pages/man4/fd.4:124
#, no-wrap
msgid "1722"
msgstr "1722"

#. type: tbl table
#: man-pages/man4/fd.4:124
#, no-wrap
msgid "60"
msgstr "60"

#. type: tbl table
#: man-pages/man4/fd.4:125
#, no-wrap
msgid "B<fd>I<n>B<u1743>"
msgstr "B<fd>I<n>B<u1743>"

#. type: tbl table
#: man-pages/man4/fd.4:125
#, no-wrap
msgid "1743"
msgstr "1743"

#. type: tbl table
#: man-pages/man4/fd.4:125
#, no-wrap
msgid "76"
msgstr "76"

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "B<fd>I<n>B<u1760>"
msgstr "B<fd>I<n>B<u1760>"

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "1760"
msgstr "1760"

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "22"
msgstr "22"

#. type: tbl table
#: man-pages/man4/fd.4:126
#, no-wrap
msgid "96"
msgstr "96"

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "B<fd>I<n>B<u1840>"
msgstr "B<fd>I<n>B<u1840>"

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "1840"
msgstr "1840"

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "23"
msgstr "23"

#. type: tbl table
#: man-pages/man4/fd.4:127
#, no-wrap
msgid "116"
msgstr "116"

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "B<fd>I<n>B<u1920>"
msgstr "B<fd>I<n>B<u1920>"

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "1920"
msgstr "1920"

#. type: tbl table
#: man-pages/man4/fd.4:128
#, no-wrap
msgid "100"
msgstr "100"

#. type: Plain text
#: man-pages/man4/fd.4:132
msgid "3.5 inch extra-density device files:"
msgstr "Файлы устройств с носителями 3.5 дюйма и сверх плотностью:"

#. type: tbl table
#: man-pages/man4/fd.4:138
#, no-wrap
msgid "B<fd>I<n>B<u2880>"
msgstr "B<fd>I<n>B<u2880>"

#. type: tbl table
#: man-pages/man4/fd.4:138 man-pages/man4/fd.4:139
#, no-wrap
msgid "2880"
msgstr "2880"

#. type: tbl table
#: man-pages/man4/fd.4:138 man-pages/man4/fd.4:139
#, no-wrap
msgid "36"
msgstr "36"

#. type: tbl table
#: man-pages/man4/fd.4:138
#, no-wrap
msgid "32"
msgstr "32"

#. type: tbl table
#: man-pages/man4/fd.4:139
#, no-wrap
msgid "B<fd>I<n>B<CompaQ>"
msgstr "B<fd>I<n>B<CompaQ>"

#. type: tbl table
#: man-pages/man4/fd.4:140
#, no-wrap
msgid "B<fd>I<n>B<u3200>"
msgstr "B<fd>I<n>B<u3200>"

#. type: tbl table
#: man-pages/man4/fd.4:140
#, no-wrap
msgid "3200"
msgstr "3200"

#. type: tbl table
#: man-pages/man4/fd.4:140
#, no-wrap
msgid "104"
msgstr "104"

#. type: tbl table
#: man-pages/man4/fd.4:141
#, no-wrap
msgid "B<fd>I<n>B<u3520>"
msgstr "B<fd>I<n>B<u3520>"

#. type: tbl table
#: man-pages/man4/fd.4:141
#, no-wrap
msgid "3520"
msgstr "3520"

#. type: tbl table
#: man-pages/man4/fd.4:141
#, no-wrap
msgid "108"
msgstr "108"

#. type: tbl table
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "B<fd>I<n>B<u3840>"
msgstr "B<fd>I<n>B<u3840>"

#. type: tbl table
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "3840"
msgstr "3840"

#. type: tbl table
#: man-pages/man4/fd.4:142
#, no-wrap
msgid "112"
msgstr "112"

#. type: Plain text
#: man-pages/man4/fd.4:149
msgid ""
"B<fd> special files access the floppy disk drives in raw mode.  The "
"following B<ioctl>(2)  calls are supported by B<fd> devices:"
msgstr ""
"Специальные файлы B<fd> обеспечивают доступ к дисководам в режиме без "
"обработки (raw mode). Устройства B<fd> поддерживают следующие вызовы "
"B<ioctl>(2):"

#. type: IP
#: man-pages/man4/fd.4:149
#, no-wrap
msgid "B<FDCLRPRM>"
msgstr "B<FDCLRPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:151
msgid "clears the media information of a drive (geometry of disk in drive)."
msgstr ""
"Очищает информацию о носителе в дисководе (геометрию диска в дисководе)."

#. type: IP
#: man-pages/man4/fd.4:151
#, no-wrap
msgid "B<FDSETPRM>"
msgstr "B<FDSETPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:155
msgid ""
"sets the media information of a drive.  The media information will be lost "
"when the media is changed."
msgstr ""
"Устанавливает информацию о носителе в дисководе. Информация о носителе "
"потеряется, когда носитель будет сменён."

#. type: IP
#: man-pages/man4/fd.4:155
#, no-wrap
msgid "B<FDDEFPRM>"
msgstr "B<FDDEFPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:161
msgid ""
"sets the media information of a drive (geometry of disk in drive).  The "
"media information will not be lost when the media is changed.  This will "
"disable autodetection.  In order to reenable autodetection, you have to "
"issue an B<FDCLRPRM>."
msgstr ""
"Устанавливает информацию о носителе в дисководе (геометрию диска в "
"дисководе). Информация о носителе не будет потеряна, когда носитель будет "
"сменён. При этом автоопределение носителя будет выключено. Чтобы снова его "
"включить, выполните B<FDCLRPRM>."

#. type: IP
#: man-pages/man4/fd.4:161 man-pages/man4/fd.4:173
#, no-wrap
msgid "B<FDGETDRVTYP>"
msgstr "B<FDGETDRVTYP>"

#. type: Plain text
#: man-pages/man4/fd.4:166
msgid ""
"returns the type of a drive (name parameter).  For formats which work in "
"several drive types, B<FDGETDRVTYP> returns a name which is appropriate for "
"the oldest drive type which supports this format."
msgstr ""
"Возвращает тип дисковода (параметр имени). Для форматов, работающих на "
"нескольких типах дисководов, B<FDGETDRVTYP> возвращает имя, соответствующее "
"самому старому типу дисковода, который поддерживает данный формат."

#. type: IP
#: man-pages/man4/fd.4:166
#, no-wrap
msgid "B<FDFLUSH>"
msgstr "B<FDFLUSH>"

#. type: Plain text
#: man-pages/man4/fd.4:168
msgid "invalidates the buffer cache for the given drive."
msgstr "Объявляет недействительными данные буферного кэша указанного привода."

#. type: IP
#: man-pages/man4/fd.4:168 man-pages/man4/fd.4:171
#, no-wrap
msgid "B<FDSETMAXERRS>"
msgstr "B<FDSETMAXERRS>"

#. type: Plain text
#: man-pages/man4/fd.4:171
msgid ""
"sets the error thresholds for reporting errors, aborting the operation, "
"recalibrating, resetting, and reading sector by sector."
msgstr ""
"Устанавливает пороговые значения для сообщения об ошибках, остановки "
"действий, перекалибровки, сброса в начальное состояние и посекторного чтения."

#. type: Plain text
#: man-pages/man4/fd.4:173
msgid "gets the current error thresholds."
msgstr "Возвращает текущие пороговые значения для ошибок."

#. type: Plain text
#: man-pages/man4/fd.4:175
msgid "gets the internal name of the drive."
msgstr "Возвращает внутреннее имя дисковода. "

#. type: IP
#: man-pages/man4/fd.4:175
#, no-wrap
msgid "B<FDWERRORCLR>"
msgstr "B<FDWERRORCLR>"

#. type: Plain text
#: man-pages/man4/fd.4:177
msgid "clears the write error statistics."
msgstr "Очищает статистику ошибок записи."

#. type: IP
#: man-pages/man4/fd.4:177
#, no-wrap
msgid "B<FDWERRORGET>"
msgstr "B<FDWERRORGET>"

#. type: Plain text
#: man-pages/man4/fd.4:184
msgid ""
"reads the write error statistics.  These include the total number of write "
"errors, the location and disk of the first write error, and the location and "
"disk of the last write error.  Disks are identified by a generation number "
"which is incremented at (almost) each disk change."
msgstr ""
"Читает статистику ошибок записи. Она включает общее число ошибок записи, "
"расположение и диск, на котором произошла первая ошибка записи, и "
"расположение и диск, на котором произошла последняя ошибка записи. Диски "
"обозначаются генерирующимся числом, которое увеличивается на единицу при "
"(почти) каждой смене диска."

#. type: IP
#: man-pages/man4/fd.4:184
#, no-wrap
msgid "B<FDTWADDLE>"
msgstr "B<FDTWADDLE>"

#. type: Plain text
#: man-pages/man4/fd.4:188
msgid ""
"Switch the drive motor off for a few microseconds.  This might be needed in "
"order to access a disk whose sectors are too close together."
msgstr ""
"Выключает на несколько микросекунд мотор привода. Это может быть необходимо "
"для получения доступа к диску, чьи сектора располагаются слишком близко друг "
"к другу."

#. type: IP
#: man-pages/man4/fd.4:188
#, no-wrap
msgid "B<FDSETDRVPRM>"
msgstr "B<FDSETDRVPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:190
msgid "sets various drive parameters."
msgstr "Устанавливает различные параметры дисковода."

#. type: IP
#: man-pages/man4/fd.4:190
#, no-wrap
msgid "B<FDGETDRVPRM>"
msgstr "B<FDGETDRVPRM>"

#. type: Plain text
#: man-pages/man4/fd.4:192
msgid "reads these parameters back."
msgstr "Возвращает различные параметры."

#. type: IP
#: man-pages/man4/fd.4:192
#, no-wrap
msgid "B<FDGETDRVSTAT>"
msgstr "B<FDGETDRVSTAT>"

#. type: Plain text
#: man-pages/man4/fd.4:194
msgid "gets the cached drive state (disk changed, write protected et al.)"
msgstr ""
"Возвращает кэшированное состояние дисковода (диск сменён, защищён от записи "
"и т. д.)"

#. type: IP
#: man-pages/man4/fd.4:194
#, no-wrap
msgid "B<FDPOLLDRVSTAT>"
msgstr "B<FDPOLLDRVSTAT>"

#. type: Plain text
#: man-pages/man4/fd.4:196
msgid "polls the drive and return its state."
msgstr "Обращается к дисководу и возвращает его состояние."

#. type: IP
#: man-pages/man4/fd.4:196
#, no-wrap
msgid "B<FDGETFDCSTAT>"
msgstr "B<FDGETFDCSTAT>"

#. type: Plain text
#: man-pages/man4/fd.4:198
msgid "gets the floppy controller state."
msgstr "Возвращает состояние контроллера дисководов."

#. type: IP
#: man-pages/man4/fd.4:198
#, no-wrap
msgid "B<FDRESET>"
msgstr "B<FDRESET>"

#. type: Plain text
#: man-pages/man4/fd.4:200
msgid "resets the floppy controller under certain conditions."
msgstr ""
"Сбрасывает в начальное состояние контроллер дисководов при определённых "
"условиях."

#. type: IP
#: man-pages/man4/fd.4:200
#, no-wrap
msgid "B<FDRAWCMD>"
msgstr "B<FDRAWCMD>"

#. type: Plain text
#: man-pages/man4/fd.4:202
msgid "sends a raw command to the floppy controller."
msgstr ""
"Посылает команду в необработанном виде (raw command) контроллеру дисководов."

#. type: Plain text
#: man-pages/man4/fd.4:207
msgid ""
"For more precise information, consult also the I<E<lt>linux/fd.hE<gt>> and "
"I<E<lt>linux/fdreg.hE<gt>> include files, as well as the "
"B<floppycontrol>(1)  manual page."
msgstr ""
"За более точной информацией обратитесь также к файлам  I<E<lt>linux/fd."
"hE<gt>> и I<E<lt>linux/fdreg.hE<gt>>, а также к справочной странице "
"B<floppycontrol>(1)."

#. type: Plain text
#: man-pages/man4/fd.4:209
msgid "I</dev/fd*>"
msgstr "I</dev/fd*>"

#. type: SH
#: man-pages/man4/fd.4:209
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/fd.4:215
msgid ""
"The various formats permit reading and writing many types of disks.  "
"However, if a floppy is formatted with an inter-sector gap that is too "
"small, performance may drop, to the point of needing a few seconds to access "
"an entire track.  To prevent this, use interleaved formats."
msgstr ""
"Разные форматы позволяют читать и записывать многие типы дисков. Однако, "
"если дискета отформатирована со слишком маленьким межсекторным промежутком, "
"производительность может снизиться вплоть до того, что для доступа к дорожке "
"может понадобиться несколько секунд. Во избежание этого, используйте "
"перемежающиеся (interleaved) форматы."

#. type: Plain text
#: man-pages/man4/fd.4:219
msgid ""
"It is not possible to read floppies which are formatted using GCR (group "
"code recording), which is used by Apple II and Macintosh computers (800k "
"disks)."
msgstr ""
"Невозможно прочитать дискеты, отформатированные с использованием GCR "
"(групповая запись кодов), которые используются компьютерами Apple II и "
"Macintosh (диски 800k)."

#.  .SH AUTHORS
#.  Alain Knaff (Alain.Knaff@imag.fr), David Niemi
#.  (niemidc@clark.net), Bill Broadhurst (bbroad@netcom.com).
#. type: Plain text
#: man-pages/man4/fd.4:226
msgid ""
"Reading floppies which are hard sectored (one hole per sector, with the "
"index hole being a little skewed) is not supported.  This used to be common "
"with older 8-inch floppies."
msgstr ""
"Чтение аппаратно размеченных на секторы дискет (с отверстием на каждый "
"сектор и слегка повернутым индексным отверстием) не поддерживается. Такими "
"были старые 8-дюймовые дискеты."

#. type: Plain text
#: man-pages/man4/fd.4:233
msgid ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), "
"B<superformat>(1), B<mount>(8), B<setfdprm>(8)"
msgstr ""
"B<chown>(1), B<floppycontrol>(1), B<getfdprm>(1), B<mknod>(1), "
"B<superformat>(1), B<mount>(8), B<setfdprm>(8)"

#. type: TH
#: man-pages/man4/fuse.4:26
#, no-wrap
msgid "FUSE"
msgstr "FUSE"

#. type: TH
#: man-pages/man4/fuse.4:26
#, no-wrap
msgid "2018-02-02"
msgstr "2018-02-02"

#. type: Plain text
#: man-pages/man4/fuse.4:29
msgid "fuse - Filesystem in Userspace (FUSE) device"
msgstr ""
"fuse - устройство файловой системы в пользовательском пространстве (FUSE)"

#. type: SH
#: man-pages/man4/fuse.4:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man4/fuse.4:32
#, no-wrap
msgid "B<#include E<lt>linux/fuse.hE<gt>>\n"
msgstr "B<#include E<lt>linux/fuse.hE<gt>>\n"

#. type: Plain text
#: man-pages/man4/fuse.4:45
msgid ""
"This device is the primary interface between the FUSE filesystem driver and "
"a user-space process wishing to provide the filesystem (referred to in the "
"rest of this manual page as the I<filesystem daemon>).  This manual page is "
"intended for those interested in understanding the kernel interface itself.  "
"Those implementing a FUSE filesystem may wish to make use of a user-space "
"library such as I<libfuse> that abstracts away the low-level interface."
msgstr ""
"Это устройство является основным интерфейсом между драйвером файловой "
"системы FUSE и процессом в пользовательском пространстве, который будет "
"предоставлять файловую систему (далее здесь называется I<службой файловой "
"системы> (filesystem daemon)). Данная справочная страница предназначена "
"тому, кто заинтересован в понимании интерфейса самого ядра. Тем, кто "
"реализует файловую систему FUSE, важнее описание библиотеки "
"пользовательского пространства такой как I<libfuse>, которая скрывает "
"низкоуровневый интерфейс."

#. type: Plain text
#: man-pages/man4/fuse.4:59
msgid ""
"At its core, FUSE is a simple client-server protocol, in which the Linux "
"kernel is the client and the daemon is the server.  After obtaining a file "
"descriptor for this device, the daemon may B<read>(2)  requests from that "
"file descriptor and is expected to B<write>(2)  back its replies.  It is "
"important to note that a file descriptor is associated with a unique FUSE "
"filesystem.  In particular, opening a second copy of this device, will not "
"allow access to resources created through the first file descriptor (and "
"vice versa)."
msgstr ""
"В основе FUSE лежит простой клиент-серверный протокол, в котором ядро Linux "
"является клиентом, а служба — сервером. После получения файлового "
"дескриптора этого устройства, служба может читать запросы с помощью "
"B<read>(2) из этого файлового дескриптора и писать ответы с помощью "
"B<write>(2). Важно отметить, что данный файловый дескриптор, связанный с "
"файловой системой FUSE, является индивидуальным. В частности, открытие "
"второй копии этого устройства не даст доступ к ресурсам, созданным через "
"первый файловый дескриптор (и наоборот)."

#. type: SS
#: man-pages/man4/fuse.4:59
#, no-wrap
msgid "The basic protocol"
msgstr "Основной протокол"

#. type: Plain text
#: man-pages/man4/fuse.4:62
msgid ""
"Every message that is read by the daemon begins with a header described by "
"the following structure:"
msgstr ""
"Каждое сообщение, читаемое службой, начинается с заголовка следующей "
"структуры:"

#. type: Plain text
#: man-pages/man4/fuse.4:77
#, no-wrap
msgid ""
"struct fuse_in_header {\n"
"    uint32_t len;       /* Total length of the data,\n"
"                           including this header */\n"
"    uint32_t opcode;    /* The kind of operation (see below) */\n"
"    uint64_t unique;    /* A unique identifier for this request */\n"
"    uint64_t nodeid;    /* ID of the filesystem object\n"
"                           being operated on */\n"
"    uint32_t uid;       /* UID of the requesting process */\n"
"    uint32_t gid;       /* GID of the requesting process */\n"
"    uint32_t pid;       /* PID of the requesting process */\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""
"struct fuse_in_header {\n"
"    uint32_t len;       /* общая длина данных,\n"
"                           включая этот заголовок */\n"
"    uint32_t opcode;    /* тип операции (смотрите ниже) */\n"
"    uint64_t unique;    /* уникальный идентификатор этого запроса */\n"
"    uint64_t nodeid;    /* ID объекта файловой системы, с\n"
"                           которым выполняется действие */\n"
"    uint32_t uid;       /* UID запрашивающего процесса */\n"
"    uint32_t gid;       /* GID запрашивающего процесса */\n"
"    uint32_t pid;       /* PID запрашивающего процесса */\n"
"    uint32_t padding;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:84
msgid ""
"The header is followed by a variable-length data portion (which may be "
"empty) specific to the requested operation (the requested operation is "
"indicated by I<opcode>)."
msgstr ""
"После заголовка располагаются данные произвольной длины (их может и не "
"быть), используемые вместе с запрашиваемой операцией (запрашиваемая операция "
"указывается в I<opcode>)."

#. type: Plain text
#: man-pages/man4/fuse.4:91
msgid ""
"The daemon should then process the request and if applicable send a reply "
"(almost all operations require a reply; if they do not, this is documented "
"below), by performing a B<write>(2)  to the file descriptor.  All replies "
"must start with the following header:"
msgstr ""
"Служба обрабатывает запрос и, если нужен ответ (почти все операции требуют "
"ответа; если нет, то это описано далее), выполняет запись с помощью "
"B<write>(2) в файловый дескриптор. Все ответы должны начинаться со "
"следующего заголовка:"

#. type: Plain text
#: man-pages/man4/fuse.4:101
#, no-wrap
msgid ""
"struct fuse_out_header {\n"
"    uint32_t len;       /* Total length of data written to\n"
"                           the file descriptor */\n"
"    int32_t  error;     /* Any error that occurred (0 if none) */\n"
"    uint64_t unique;    /* The value from the\n"
"                           corresponding request */\n"
"};\n"
msgstr ""
"struct fuse_out_header {\n"
"    uint32_t len;       /* общая длина данных, записываемых\n"
"                           в файловый дескриптор */\n"
"    int32_t  error;     /* возникшая ошибка (0, если нет) */\n"
"    uint64_t unique;    /* значение из \n"
"                           соответствующего запроса */\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:111
msgid ""
"This header is also followed by (potentially empty) variable-sized data "
"depending on the executed request.  However, if the reply is an error reply "
"(i.e., I<error> is set), then no further payload data should be sent, "
"independent of the request."
msgstr ""
"После этого заголовка также располагаются данные произвольной длины "
"(возможно их отсутствие), в зависимости от запроса. Однако, если ответ "
"является ответом, содержащим ошибку, (т. е., I<error> не равно нулю), то "
"дополнительных данных посылаться не должно, независимо от запроса."

#. type: SS
#: man-pages/man4/fuse.4:111
#, no-wrap
msgid "Exchanged messages"
msgstr "Расширенные сообщения"

#. type: Plain text
#: man-pages/man4/fuse.4:118
msgid ""
"This section should contain documentation for each of the messages in the "
"protocol.  This manual page is currently incomplete, so not all messages are "
"documented.  For each message, first the struct sent by the kernel is given, "
"followed by a description of the semantics of the message."
msgstr ""
"В этом разделе должна быть документация по каждому сообщению протокола. "
"Данная справочная страница не закончена, поэтому описаны не все сообщения. "
"Для каждого сообщения сначала приводится структура, посылаемая ядром, после "
"чего описывается семантика сообщения."

#. type: TP
#: man-pages/man4/fuse.4:118
#, no-wrap
msgid "B<FUSE_INIT>"
msgstr "B<FUSE_INIT>"

#. type: Plain text
#: man-pages/man4/fuse.4:129
#, no-wrap
msgid ""
"struct fuse_init_in {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead; /* Since protocol v7.6 */\n"
"    uint32_t flags;         /* Since protocol v7.6 */\n"
"};\n"
msgstr ""
"struct fuse_init_in {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead; /* начиная с протокола v7.6 */\n"
"    uint32_t flags;         /* начиная с протокола v7.6 */\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:141
msgid ""
"This is the first request sent by the kernel to the daemon.  It is used to "
"negotiate the protocol version and other filesystem parameters.  Note that "
"the protocol version may affect the layout of any structure in the protocol "
"(including this structure).  The daemon must thus remember the negotiated "
"version and flags for each session.  As of the writing of this man page, the "
"highest supported kernel protocol version is I<7.26>."
msgstr ""
"Это первый запрос, посылаемый ядром службе. Он используется для согласования "
"версии протокола и других параметров файловой системы. Заметим, что версия "
"протокола может влиять на любую структуру протокола (включая эту). Служба "
"должна запоминать согласованную версию и флаги для каждого сеанса. На момент "
"написания этой справочной страницы наибольшей версией поддерживаемого ядром "
"протокола была I<7.26>."

#. type: Plain text
#: man-pages/man4/fuse.4:144
msgid ""
"Users should be aware that the descriptions in this manual page may be "
"incomplete or incorrect for older or more recent protocol versions."
msgstr ""
"Пользователи должны учесть, что описания в этой справочной странице могут "
"быть неполны или некорректны по отношению к старым или более новым версиям "
"протокола."

#. type: Plain text
#: man-pages/man4/fuse.4:146
msgid "The reply for this request has the following format:"
msgstr "Ответ на этот запрос имеет следующий формат:"

#. type: Plain text
#: man-pages/man4/fuse.4:161
#, no-wrap
msgid ""
"struct fuse_init_out {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead;   /* Since v7.6 */\n"
"    uint32_t flags;           /* Since v7.6; some flags bits\n"
"                                 were introduced later */\n"
"    uint16_t max_background;  /* Since v7.13 */\n"
"    uint16_t congestion_threshold;  /* Since v7.13 */\n"
"    uint32_t max_write;       /* Since v7.5 */\n"
"    uint32_t time_gran;       /* Since v7.6 */\n"
"    uint32_t unused[9];\n"
"};\n"
msgstr ""
"struct fuse_init_out {\n"
"    uint32_t major;\n"
"    uint32_t minor;\n"
"    uint32_t max_readahead;   /* Начиная с v7.6 */\n"
"    uint32_t flags;           /* Начиная с v7.6; некоторые биты флагов были введены позднее */\n"
"    uint16_t max_background;  /* Начиная с v7.13 */\n"
"    uint16_t congestion_threshold;  /* Начиная с v7.13 */\n"
"    uint32_t max_write;       /* Начиная с v7.5 */\n"
"    uint32_t time_gran;       /* Начиная с v7.6 */\n"
"    uint32_t unused[9];\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:174
msgid ""
"If the major version supported by the kernel is larger than that supported "
"by the daemon, the reply shall consist of only I<uint32_t major> (following "
"the usual header), indicating the largest major version supported by the "
"daemon.  The kernel will then issue a new B<FUSE_INIT> request conforming to "
"the older version.  In the reverse case, the daemon should quietly fall back "
"to the kernel's major version."
msgstr ""
"Если главная (major) версия, поддерживаемая ядром, больше чем поддерживаемая "
"службой, то ответ должен содержать только I<uint32_t major> (как обычный "
"заголовок), показывающий наибольшую главную версию, поддерживаемую службой. "
"После этого ядро создаст новый запрос B<FUSE_INIT>, соответствующий более "
"старой версии. В противном случае (то есть, если версия службы новее), "
"служба должна переключиться на работу с главной версией ядра."

#. type: Plain text
#: man-pages/man4/fuse.4:178
msgid ""
"The negotiated minor version is considered to be the minimum of the minor "
"versions provided by the daemon and the kernel and both parties should use "
"the protocol corresponding to said minor version."
msgstr ""
"Согласованной вспомогательной (minor) версией считается минимальная из "
"вспомогательных версий, поддерживаемых службой и ядром, и обе стороны должны "
"использовать протокол, соответствующий указанной вспомогательной версии."

#. type: TP
#: man-pages/man4/fuse.4:178
#, no-wrap
msgid "B<FUSE_GETATTR>"
msgstr "B<FUSE_GETATTR>"

#. type: Plain text
#: man-pages/man4/fuse.4:189
#, no-wrap
msgid ""
"struct fuse_getattr_in {\n"
"    uint32_t getattr_flags;\n"
"    uint32_t dummy;\n"
"    uint64_t fh;      /* Set only if\n"
"                         (getattr_flags & FUSE_GETATTR_FH)\n"
"};\n"
msgstr ""
"struct fuse_getattr_in {\n"
"    uint32_t getattr_flags;\n"
"    uint32_t dummy;\n"
"    uint64_t fh;      /* задаётся, только если\n"
"                         (getattr_flags & FUSE_GETATTR_FH)\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:205
msgid ""
"The requested operation is to compute the attributes to be returned by "
"B<stat>(2)  and similar operations for the given file system object.  The "
"object for which the attributes should be computed is indicated either by "
"I<header-E<gt>nodeid> or, if the I<FUSE_GETATTR_FH> flag is set, by the file "
"handle I<fh>.  The latter case of operation is analogous to B<fstat>(2)."
msgstr ""
"Операция запроса вычисления атрибутов, возвращаемых B<stat>(2) и подобными "
"операциями для указанного объекта файловой системы. Объект, для которого "
"вычисляются атрибуты, задаётся в виде I<header-E<gt>nodeid> или, если указан "
"флаг I<FUSE_GETATTR_FH>, в виде файлового описателя (handle) I<fh>. Для "
"последнего случая операция аналогична B<fstat>(2)."

#. type: Plain text
#: man-pages/man4/fuse.4:212
msgid ""
"For performance reasons, these attributes may be cached in the kernel for a "
"specified duration of time.  While the cache timeout has not been exceeded, "
"the attributes will be served from the cache and will not cause additional "
"B<FUSE_GETATTR> requests."
msgstr ""
"С целью оптимизации производительности, эти атрибуты могут кэшироваться в "
"ядре на указанный период времени. Пока срок хранения кэша не истёк, атрибуты "
"будут браться из кэша и дополнительные запросы B<FUSE_GETATTR> выполняться "
"не будут."

#. type: Plain text
#: man-pages/man4/fuse.4:215
msgid ""
"The computed attributes and the requested cache timeout should then be "
"returned in the following structure:"
msgstr ""
"Вычисленные атрибуты и срок хранения в кэше возвращаются в следующей "
"структуре:"

#. type: Plain text
#: man-pages/man4/fuse.4:242
#, no-wrap
msgid ""
"struct fuse_attr_out {\n"
"    /* Attribute cache duration (seconds + nanoseconds) */\n"
"    uint64_t attr_valid;\n"
"    uint32_t attr_valid_nsec;\n"
"    uint32_t dummy;\n"
"    struct fuse_attr {\n"
"        uint64_t ino;\n"
"        uint64_t size;\n"
"        uint64_t blocks;\n"
"        uint64_t atime;\n"
"        uint64_t mtime;\n"
"        uint64_t ctime;\n"
"        uint32_t atimensec;\n"
"        uint32_t mtimensec;\n"
"        uint32_t ctimensec;\n"
"        uint32_t mode;\n"
"        uint32_t nlink;\n"
"        uint32_t uid;\n"
"        uint32_t gid;\n"
"        uint32_t rdev;\n"
"        uint32_t blksize;\n"
"        uint32_t padding;\n"
"    } attr;\n"
"};\n"
msgstr ""
"struct fuse_attr_out {\n"
"    /* срок хранения атрибута в кэше (секунды + наносекунды) */\n"
"    uint64_t attr_valid;\n"
"    uint32_t attr_valid_nsec;\n"
"    uint32_t dummy;\n"
"    struct fuse_attr {\n"
"        uint64_t ino;\n"
"        uint64_t size;\n"
"        uint64_t blocks;\n"
"        uint64_t atime;\n"
"        uint64_t mtime;\n"
"        uint64_t ctime;\n"
"        uint32_t atimensec;\n"
"        uint32_t mtimensec;\n"
"        uint32_t ctimensec;\n"
"        uint32_t mode;\n"
"        uint32_t nlink;\n"
"        uint32_t uid;\n"
"        uint32_t gid;\n"
"        uint32_t rdev;\n"
"        uint32_t blksize;\n"
"        uint32_t padding;\n"
"    } attr;\n"
"};\n"

#. type: TP
#: man-pages/man4/fuse.4:245
#, no-wrap
msgid "B<FUSE_ACCESS>"
msgstr "B<FUSE_ACCESS>"

#. type: Plain text
#: man-pages/man4/fuse.4:254
#, no-wrap
msgid ""
"struct fuse_access_in {\n"
"    uint32_t mask;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""
"struct fuse_access_in {\n"
"    uint32_t mask;\n"
"    uint32_t padding;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:266
msgid ""
"If the I<default_permissions> mount options is not used, this request may be "
"used for permissions checking.  No reply data is expected, but errors may be "
"indicated as usual by setting the I<error> field in the reply header (in "
"particular, access denied errors may be indicated by returning B<-EACCES>)."
msgstr ""
"Если не используется параметр монтирования I<default_permissions>, то этот "
"запрос можно использовать для проверки прав доступа. Данных в ответе не "
"ожидается, но могут возвращаться ошибки, как обычно в поле I<error> "
"заголовка ответа (в частности, при ошибках отказа в доступе может "
"возвращаться B<-EACCES>)."

#. type: TP
#: man-pages/man4/fuse.4:266
#, no-wrap
msgid "B<FUSE_OPEN> and B<FUSE_OPENDIR>"
msgstr "B<FUSE_OPEN> и B<FUSE_OPENDIR>"

#. type: Plain text
#: man-pages/man4/fuse.4:275
#, no-wrap
msgid ""
"struct fuse_open_in {\n"
"    uint32_t flags;     /* The flags that were passed\n"
"                           to the open(2) */\n"
"    uint32_t unused;\n"
"};\n"
msgstr ""
"struct fuse_open_in {\n"
"    uint32_t flags;     /* флаги, передаваемые\n"
"                           в open(2) */\n"
"    uint32_t unused;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:287
msgid ""
"The requested operation is to open the node indicated by I<header-"
"E<gt>nodeid>.  The exact semantics of what this means will depend on the "
"filesystem being implemented.  However, at the very least the filesystem "
"should validate that the requested I<flags> are valid for the indicated "
"resource and then send a reply with the following format:"
msgstr ""
"Этот запрос открывает ноду, указанную в I<header-E<gt>nodeid>. Точна "
"семантика будет зависеть от реализации в файловой системе. Однако, по "
"крайней мере, файловая система должна проверить что запрашиваемые I<flags> "
"корректны для указанного ресурса и затем послать ответ в следующем формате:"

#. type: Plain text
#: man-pages/man4/fuse.4:296
#, no-wrap
msgid ""
"struct fuse_open_out {\n"
"    uint64_t fh;\n"
"    uint32_t open_flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""
"struct fuse_open_out {\n"
"    uint64_t fh;\n"
"    uint32_t open_flags;\n"
"    uint32_t padding;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:308
msgid ""
"The I<fh> field is an opaque identifier that the kernel will use to refer to "
"this resource The I<open_flags> field is a bit mask of any number of the "
"flags that indicate properties of this file handle to the kernel:"
msgstr ""
"Поле I<fh> представляет собой закрытый (opaque) идентификатор, который ядро "
"будет использовать для ссылки на этот ресурс. Поле I<open_flags> "
"представляет собой битовую маску с набором флагов, которые определяют "
"свойства этого описателя в ядре:"

#. type: TP
#: man-pages/man4/fuse.4:309
#, no-wrap
msgid "B<FOPEN_DIRECT_IO>"
msgstr "B<FOPEN_DIRECT_IO>"

#. type: Plain text
#: man-pages/man4/fuse.4:312
msgid "Bypass page cache for this open file."
msgstr "Не использовать страничный кэш для этого открытого файла."

#. type: TP
#: man-pages/man4/fuse.4:312
#, no-wrap
msgid "B<FOPEN_KEEP_CACHE>"
msgstr "B<FOPEN_KEEP_CACHE>"

#. type: Plain text
#: man-pages/man4/fuse.4:315
msgid "Don't invalidate the data cache on open."
msgstr "Не делать недействительными данные кэша при открытии."

#. type: TP
#: man-pages/man4/fuse.4:315
#, no-wrap
msgid "B<FOPEN_NONSEEKABLE>"
msgstr "B<FOPEN_NONSEEKABLE>"

#. type: Plain text
#: man-pages/man4/fuse.4:318
msgid "The file is not seekable."
msgstr "Внутри файла не поддерживается смена положения."

#. type: TP
#: man-pages/man4/fuse.4:319
#, no-wrap
msgid "B<FUSE_READ> and B<FUSE_READDIR>"
msgstr "B<FUSE_READ> и B<FUSE_READDIR>"

#. type: Plain text
#: man-pages/man4/fuse.4:333
#, no-wrap
msgid ""
"struct fuse_read_in {\n"
"    uint64_t fh;\n"
"    uint64_t offset;\n"
"    uint32_t size;\n"
"    uint32_t read_flags;\n"
"    uint64_t lock_owner;\n"
"    uint32_t flags;\n"
"    uint32_t padding;\n"
"};\n"
msgstr ""
"struct fuse_read_in {\n"
"    uint64_t fh;\n"
"    uint64_t offset;\n"
"    uint32_t size;\n"
"    uint32_t read_flags;\n"
"    uint64_t lock_owner;\n"
"    uint32_t flags;\n"
"    uint32_t padding;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:342
msgid ""
"The requested action is to read up to I<size> bytes of the file or "
"directory, starting at I<offset>.  The bytes should be returned directly "
"following the usual reply header."
msgstr ""
"По этому запросу читается до I<size> байт файла или каталога, начиная с "
"I<offset>. Байты должны возвращаться сразу за обычным заголовком ответа."

#. type: TP
#: man-pages/man4/fuse.4:342
#, no-wrap
msgid "B<FUSE_INTERRUPT>"
msgstr "B<FUSE_INTERRUPT>"

#. type: Plain text
#: man-pages/man4/fuse.4:349
#, no-wrap
msgid ""
"struct fuse_interrupt_in {\n"
"    uint64_t unique;\n"
"};\n"
msgstr ""
"struct fuse_interrupt_in {\n"
"    uint64_t unique;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:365
msgid ""
"The requested action is to cancel the pending operation indicated by "
"I<unique>.  This request requires no response.  However, receipt of this "
"message does not by itself cancel the indicated operation.  The kernel will "
"still expect a reply to said operation (e.g., an I<EINTR> error or a short "
"read).  At most one B<FUSE_INTERRUPT> request will be issued for a given "
"operation.  After issuing said operation, the kernel will wait "
"uninterruptibly for completion of the indicated request."
msgstr ""
"По этому запросу отменяется ожидающая операция, указанная в I<unique>. По "
"запросу не формируется ответ. Однако, само получение сообщения не отменяет "
"указанную операцию. Ядро всё равно будет ждать ответа на указанную операцию "
"(например, ошибку I<EINTR> или короткое чтение). Для указанной операции "
"будет выдано не более одно запроса B<FUSE_INTERRUPT>. После выдачи указанной "
"операции ядро будет непрерывно ожидать завершения указанного запроса."

#. type: TP
#: man-pages/man4/fuse.4:365
#, no-wrap
msgid "B<FUSE_LOOKUP>"
msgstr "B<FUSE_LOOKUP>"

#. type: Plain text
#: man-pages/man4/fuse.4:371
msgid ""
"Directly following the header is a filename to be looked up in the directory "
"indicated by I<header-E<gt>nodeid>.  The expected reply is of the form:"
msgstr ""
"Непосредственно после заголовка указывается имя файла, которое будет "
"искаться в каталоге, указанном в I<header-E<gt>nodeid>. Ожидается ответ в "
"виде:"

#. type: Plain text
#: man-pages/man4/fuse.4:383
#, no-wrap
msgid ""
"struct fuse_entry_out {\n"
"    uint64_t nodeid;            /* Inode ID */\n"
"    uint64_t generation;        /* Inode generation */\n"
"    uint64_t entry_valid;\n"
"    uint64_t attr_valid;\n"
"    uint32_t entry_valid_nsec;\n"
"    uint32_t attr_valid_nsec;\n"
"    struct fuse_attr attr;\n"
"};\n"
msgstr ""
"struct fuse_entry_out {\n"
"    uint64_t nodeid;            /* идентификатор inode */\n"
"    uint64_t generation;        /* поколение inode */\n"
"    uint64_t entry_valid;\n"
"    uint64_t attr_valid;\n"
"    uint32_t entry_valid_nsec;\n"
"    uint32_t attr_valid_nsec;\n"
"    struct fuse_attr attr;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:391
msgid ""
"The combination of I<nodeid> and I<generation> must be unique for the "
"filesystem's lifetime."
msgstr ""
"Комбинация I<nodeid> и I<generation> должна быть уникальной на время "
"существования файловой системы."

#. type: Plain text
#: man-pages/man4/fuse.4:396
msgid "The interpretation of timeouts and I<attr> is as for B<FUSE_GETATTR>."
msgstr "Параметры сроков хранения и I<attr> такие же как в B<FUSE_GETATTR>."

#. type: TP
#: man-pages/man4/fuse.4:396
#, no-wrap
msgid "B<FUSE_FLUSH>"
msgstr "B<FUSE_FLUSH>"

#. type: Plain text
#: man-pages/man4/fuse.4:406
#, no-wrap
msgid ""
"struct fuse_flush_in {\n"
"    uint64_t fh;\n"
"    uint32_t unused;\n"
"    uint32_t padding;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""
"struct fuse_flush_in {\n"
"    uint64_t fh;\n"
"    uint32_t unused;\n"
"    uint32_t padding;\n"
"    uint64_t lock_owner;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:414
msgid ""
"The requested action is to flush any pending changes to the indicated file "
"handle.  No reply data is expected.  However, an empty reply message still "
"needs to be issued once the flush operation is complete."
msgstr ""
"По этому запросу сбрасываются (flush) все ожидающие изменения для указанного "
"файлового описателя. Данных в ответе не ожидается. Однако, всё равно "
"требуется ответное сообщения после завершения операции сброса."

#. type: TP
#: man-pages/man4/fuse.4:414
#, no-wrap
msgid "B<FUSE_RELEASE> and B<FUSE_RELEASEDIR>"
msgstr "B<FUSE_RELEASE> и B<FUSE_RELEASEDIR>"

#. type: Plain text
#: man-pages/man4/fuse.4:424
#, no-wrap
msgid ""
"struct fuse_release_in {\n"
"    uint64_t fh;\n"
"    uint32_t flags;\n"
"    uint32_t release_flags;\n"
"    uint64_t lock_owner;\n"
"};\n"
msgstr ""
"struct fuse_release_in {\n"
"    uint64_t fh;\n"
"    uint32_t flags;\n"
"    uint32_t release_flags;\n"
"    uint64_t lock_owner;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:439
msgid ""
"These are the converse of B<FUSE_OPEN> and B<FUSE_OPENDIR> respectively.  "
"The daemon may now free any resources associated with the file handle I<fh> "
"as the kernel will no longer refer to it.  There is no reply data associated "
"with this request, but a reply still needs to be issued once the request has "
"been completely processed."
msgstr ""
"Запросы, обратные B<FUSE_OPEN> и B<FUSE_OPENDIR>, соответственно. Служба "
"теперь может освободить ресурсы, связанные с файловым описателем I<fh>, так "
"как ядру он больше не нужен. Данных в ответе не посылается, но ответ нужно "
"отправить после обработки запроса."

#. type: TP
#: man-pages/man4/fuse.4:439
#, no-wrap
msgid "B<FUSE_STATFS>"
msgstr "B<FUSE_STATFS>"

#. type: Plain text
#: man-pages/man4/fuse.4:446
msgid ""
"This operation implements B<statfs>(2)  for this filesystem.  There is no "
"input data associated with this request.  The expected reply data has the "
"following structure:"
msgstr ""
"Данная операция реализует B<statfs>(2) для этой файловой системы. В запросе "
"нет данных. В ответе ожидаются данные следующей структуры:"

#. type: Plain text
#: man-pages/man4/fuse.4:461
#, no-wrap
msgid ""
"struct fuse_kstatfs {\n"
"    uint64_t blocks;\n"
"    uint64_t bfree;\n"
"    uint64_t bavail;\n"
"    uint64_t files;\n"
"    uint64_t ffree;\n"
"    uint32_t bsize;\n"
"    uint32_t namelen;\n"
"    uint32_t frsize;\n"
"    uint32_t padding;\n"
"    uint32_t spare[6];\n"
"};\n"
msgstr ""
"struct fuse_kstatfs {\n"
"    uint64_t blocks;\n"
"    uint64_t bfree;\n"
"    uint64_t bavail;\n"
"    uint64_t files;\n"
"    uint64_t ffree;\n"
"    uint32_t bsize;\n"
"    uint32_t namelen;\n"
"    uint32_t frsize;\n"
"    uint32_t padding;\n"
"    uint32_t spare[6];\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:465
#, no-wrap
msgid ""
"struct fuse_statfs_out {\n"
"    struct fuse_kstatfs st;\n"
"};\n"
msgstr ""
"struct fuse_statfs_out {\n"
"    struct fuse_kstatfs st;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/fuse.4:470
msgid "For the interpretation of these fields, see B<statfs>(2)."
msgstr "Информацию об этих полях смотрите в B<statfs>(2)."

#. type: SH
#: man-pages/man4/fuse.4:470
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man4/fuse.4:471
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man4/fuse.4:478
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer and the request was B<FUSE_SETXATTR>."
msgstr ""
"Возвращается из операций B<read>(2), когда запросы ядра слишком велики для "
"предоставляемого буфера и запросом является B<FUSE_SETXATTR>."

#. type: TP
#: man-pages/man4/fuse.4:478
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man4/fuse.4:487
msgid ""
"Returned from B<write>(2)  if validation of the reply failed.  Not all "
"mistakes in replies will be caught by this validation.  However, basic "
"mistakes, such as short replies or an incorrect I<unique> value, are "
"detected."
msgstr ""
"Возвращается из операции B<write>(2), если ответ не прошёл тест на "
"правильность. При этом не все ошибки в ответах будут пойманы. Однако "
"обнаруживаются простые ошибки, такие как короткие ответы или некорректное "
"значение I<unique>."

#. type: TP
#: man-pages/man4/fuse.4:487
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man4/fuse.4:492
msgid ""
"Returned from B<read>(2)  operations when the kernel's request is too large "
"for the provided buffer."
msgstr ""
"Возвращается из операции B<read>(2), когда запросы ядра слишком велики для "
"предоставляемого буфера."

#. type: Plain text
#: man-pages/man4/fuse.4:498
msgid ""
"I<Note>: There are various ways in which incorrect use of these interfaces "
"can cause operations on the provided filesystem's files and directories to "
"fail with B<EIO>.  Among the possible incorrect uses are:"
msgstr ""
"I<Замечание>: Есть несколько вариантов, в которых неправильное использование "
"этих интерфейсов с предоставляемыми файловой системой файлами и каталогами "
"может завершиться ошибкой B<EIO>. Например:"

#. type: IP
#: man-pages/man4/fuse.4:499 man-pages/man4/fuse.4:503
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man4/fuse.4:503
msgid ""
"changing I<mode & S_IFMT> for an inode that has previously been reported to "
"the kernel; or"
msgstr ""
"изменение I<mode & S_IFMT> для иноды, о которой ранее было сообщено ядру; или"

#. type: Plain text
#: man-pages/man4/fuse.4:505
msgid ""
"giving replies to the kernel that are shorter than what the kernel expected."
msgstr "выдача более коротких ответов ядру, чем оно ожидает."

#. type: TP
#: man-pages/man4/fuse.4:506
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man4/fuse.4:513
msgid ""
"Returned from B<read>(2)  and B<write>(2)  if the FUSE filesystem was "
"unmounted."
msgstr ""
"Возвращается из операций B<read>(2) и B<write>(2), если файловая система "
"FUSE была размонтирована."

#. type: TP
#: man-pages/man4/fuse.4:513
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man4/fuse.4:518
msgid ""
"Returned from operations on a I</dev/fuse> file descriptor that has not been "
"mounted."
msgstr ""
"Возвращается из операций над файловым дескриптором I</dev/fuse>, если он не "
"был смонтирован."

#. type: SH
#: man-pages/man4/fuse.4:518
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man4/fuse.4:520
msgid "The FUSE filesystem is Linux-specific."
msgstr "Файловая система FUSE есть только в Linux."

#. type: Plain text
#: man-pages/man4/fuse.4:522
msgid "The following messages are not yet documented in this manual page:"
msgstr ""
"Следующие сообщения пока не документированы в этой справочной странице:"

#. type: Plain text
#: man-pages/man4/fuse.4:556
#, no-wrap
msgid ""
"B<FUSE_BATCH_FORGET>\n"
"B<FUSE_BMAP>\n"
"B<FUSE_CREATE>\n"
"B<FUSE_DESTROY>\n"
"B<FUSE_FALLOCATE>\n"
"B<FUSE_FORGET>\n"
"B<FUSE_FSYNC>\n"
"B<FUSE_FSYNCDIR>\n"
"B<FUSE_GETLK>\n"
"B<FUSE_GETXATTR>\n"
"B<FUSE_IOCTL>\n"
"B<FUSE_LINK>\n"
"B<FUSE_LISTXATTR>\n"
"B<FUSE_LSEEK>\n"
"B<FUSE_MKDIR>\n"
"B<FUSE_MKNOD>\n"
"B<FUSE_NOTIFY_REPLY>\n"
"B<FUSE_POLL>\n"
"B<FUSE_READDIRPLUS>\n"
"B<FUSE_READLINK>\n"
"B<FUSE_REMOVEXATTR>\n"
"B<FUSE_RENAME>\n"
"B<FUSE_RENAME2>\n"
"B<FUSE_RMDIR>\n"
"B<FUSE_SETATTR>\n"
"B<FUSE_SETLK>\n"
"B<FUSE_SETLKW>\n"
"B<FUSE_SYMLINK>\n"
"B<FUSE_UNLINK>\n"
"B<FUSE_WRITE>\n"
msgstr ""
"B<FUSE_BATCH_FORGET>\n"
"B<FUSE_BMAP>\n"
"B<FUSE_CREATE>\n"
"B<FUSE_DESTROY>\n"
"B<FUSE_FALLOCATE>\n"
"B<FUSE_FORGET>\n"
"B<FUSE_FSYNC>\n"
"B<FUSE_FSYNCDIR>\n"
"B<FUSE_GETLK>\n"
"B<FUSE_GETXATTR>\n"
"B<FUSE_IOCTL>\n"
"B<FUSE_LINK>\n"
"B<FUSE_LISTXATTR>\n"
"B<FUSE_LSEEK>\n"
"B<FUSE_MKDIR>\n"
"B<FUSE_MKNOD>\n"
"B<FUSE_NOTIFY_REPLY>\n"
"B<FUSE_POLL>\n"
"B<FUSE_READDIRPLUS>\n"
"B<FUSE_READLINK>\n"
"B<FUSE_REMOVEXATTR>\n"
"B<FUSE_RENAME>\n"
"B<FUSE_RENAME2>\n"
"B<FUSE_RMDIR>\n"
"B<FUSE_SETATTR>\n"
"B<FUSE_SETLK>\n"
"B<FUSE_SETLKW>\n"
"B<FUSE_SYMLINK>\n"
"B<FUSE_UNLINK>\n"
"B<FUSE_WRITE>\n"

#. type: Plain text
#: man-pages/man4/fuse.4:560
msgid "B<fusermount>(1), B<mount.fuse>(8)"
msgstr "B<fusermount>(1), B<mount.fuse>(8)"

#. type: TH
#: man-pages/man7/fanotify.7:25
#, no-wrap
msgid "FANOTIFY"
msgstr "FANOTIFY"

#. type: TH
#: man-pages/man7/fanotify.7:25
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: man-pages/man7/fanotify.7:28
msgid "fanotify - monitoring filesystem events"
msgstr "fanotify - отслеживание событий в файловой системе"

#. type: Plain text
#: man-pages/man7/fanotify.7:37
msgid ""
"The fanotify API provides notification and interception of filesystem "
"events.  Use cases include virus scanning and hierarchical storage "
"management.  Currently, only a limited set of events is supported.  In "
"particular, there is no support for create, delete, and move events.  (See "
"B<inotify>(7)  for details of an API that does notify those events.)"
msgstr ""
"Программный интерфейс fanotify уведомляет о событиях в файловой системе и "
"перехватывает их. Например, его можно использовать для сканирования файлов "
"на вирусы и управления иерархическим хранилищем. В настоящее время, "
"поддерживается только ограниченный набор событий. В частности, не "
"поддерживаются события создания, удаления и перемещения (о программном "
"интерфейсе для этих событий смотрите в B<inotify>(7))."

#. type: Plain text
#: man-pages/man7/fanotify.7:44
msgid ""
"Additional capabilities compared to the B<inotify>(7)  API include the "
"ability to monitor all of the objects in a mounted filesystem, the ability "
"to make access permission decisions, and the possibility to read or modify "
"files before access by other applications."
msgstr ""
"Дополнительные возможности по сравнению с программным интерфейсом "
"B<inotify>(7): способность отслеживать все объекты в смонтированной файловой "
"системе, давать права на доступ и читать или изменять файлы перед тем как "
"доступ получат другие приложения."

#. type: Plain text
#: man-pages/man7/fanotify.7:52
msgid ""
"The following system calls are used with this API: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""
"В программный интерфейс входят следующие системные вызовы: "
"B<fanotify_init>(2), B<fanotify_mark>(2), B<read>(2), B<write>(2) и "
"B<close>(2)."

#. type: SS
#: man-pages/man7/fanotify.7:52
#, no-wrap
msgid "fanotify_init(), fanotify_mark(), and notification groups"
msgstr "Вызовы fanotify_init(), fanotify_mark() и группы уведомлений"

#. type: Plain text
#: man-pages/man7/fanotify.7:57
msgid ""
"The B<fanotify_init>(2)  system call creates and initializes an fanotify "
"notification group and returns a file descriptor referring to it."
msgstr ""
"Системный вызов B<fanotify_init>(2) создаёт и инициализирует группу "
"уведомления fanotify и возвращает указывающий на неё файловый дескриптор."

#. type: Plain text
#: man-pages/man7/fanotify.7:61
msgid ""
"An fanotify notification group is a kernel-internal object that holds a list "
"of files, directories, filesystems, and mount points for which events shall "
"be created."
msgstr ""
"Группа уведомления fanotify — это внутренний объект ядра, в котором хранится "
"список файлов, каталогов, файловых систем и точек монтирования, для которых "
"должны создаваться события."

#. type: Plain text
#: man-pages/man7/fanotify.7:72
msgid ""
"For each entry in an fanotify notification group, two bit masks exist: the "
"I<mark> mask and the I<ignore> mask.  The mark mask defines file activities "
"for which an event shall be created.  The ignore mask defines activities for "
"which no event shall be generated.  Having these two types of masks permits "
"a filesystem, mount point, or directory to be marked for receiving events, "
"while at the same time ignoring events for specific objects under a mount "
"point or directory."
msgstr ""
"У каждой записи в группе уведомления fanotify есть две битовые маски: "
"I<меток> и I<игнорирования>. В маске меток указывается для каких действий на "
"файлами должны создаваться события. В маске игнорирования указывается для "
"каких действий не должны создаваться события. Имея маски таких типов можно "
"пометить файловую систему, точку монтирования или каталог для получения "
"событий, и в тоже время игнорировать события для определённых объектов в "
"этой точке монтирования или каталоге."

#. type: Plain text
#: man-pages/man7/fanotify.7:78
msgid ""
"The B<fanotify_mark>(2)  system call adds a file, directory, filesystem or "
"mount point to a notification group and specifies which events shall be "
"reported (or ignored), or removes or modifies such an entry."
msgstr ""
"Системный вызов B<fanotify_mark>(2) добавляет файл, каталог, файловую "
"систему или точку монтирования в группу уведомления и задаёт какие события "
"должны отслеживаться (или игнорироваться), или удаляет или изменяет нужную "
"запись."

#. type: Plain text
#: man-pages/man7/fanotify.7:91
msgid ""
"A possible usage of the ignore mask is for a file cache.  Events of interest "
"for a file cache are modification of a file and closing of the same.  Hence, "
"the cached directory or mount point is to be marked to receive these "
"events.  After receiving the first event informing that a file has been "
"modified, the corresponding cache entry will be invalidated.  No further "
"modification events for this file are of interest until the file is closed.  "
"Hence, the modify event can be added to the ignore mask.  Upon receiving the "
"close event, the modify event can be removed from the ignore mask and the "
"file cache entry can be updated."
msgstr ""
"Возможное применение маски игнорирования — кэш файлов. Интересующие события "
"для файлового кэша — изменение файла и закрытие. Для этого добавляем "
"кэшируемый каталог или точку монтирования для приёма этих событий. После "
"получения первого события об изменении файла, соответствующая запись кэша "
"помечается как недействительная. Дальнейшие события об изменении файла нас "
"не интересуют, пока файл не будет закрыт. Для этого событие об изменении "
"можно добавить в маску игнорирования. При получении события о закрытии, "
"событие об изменении можно удалить из маски игнорирования и запись файлового "
"кэша можно обновить."

#. type: Plain text
#: man-pages/man7/fanotify.7:98
msgid ""
"The entries in the fanotify notification groups refer to files and "
"directories via their inode number and to mounts via their mount ID.  If "
"files or directories are renamed or moved within the same mount, the "
"respective entries survive.  If files or directories are deleted or moved to "
"another mount or if filesystems or mounts are unmounted, the corresponding "
"entries are deleted."
msgstr ""
"Записи в группе уведомления fanotify ссылаются на файл и каталог по номеру "
"иноды (inode), а на точку монтирования — через ID монтирования. При "
"переименовании или перемещении файла или каталога внутри той же точки "
"монтирования соответствующая запись остаётся. Если файл или каталог "
"удаляется или перемещается в другую точку монтирования, или если файловая "
"система или точка монтирования размонтируется, то соответствующая запись "
"удаляется."

#. type: SS
#: man-pages/man7/fanotify.7:98
#, no-wrap
msgid "The event queue"
msgstr "Очередь событий"

#. type: Plain text
#: man-pages/man7/fanotify.7:107
msgid ""
"As events occur on the filesystem objects monitored by a notification group, "
"the fanotify system generates events that are collected in a queue.  These "
"events can then be read (using B<read>(2)  or similar)  from the fanotify "
"file descriptor returned by B<fanotify_init>(2)."
msgstr ""
"Для возникающих событий с объектами файловой системы, которые отслеживаются "
"группой уведомления, система fanotify генерирует события и помещает их в "
"очередь. После этого события можно прочитать (с помощью B<read>(2) и "
"подобных) из файлового дескриптора fanotify, возвращённого "
"B<fanotify_init>(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:125
msgid ""
"Two types of events are generated: I<notification> events and I<permission> "
"events.  Notification events are merely informative and require no action to "
"be taken by the receiving application with the exception being that the file "
"descriptor provided within a generic event must be closed.  The closing of "
"file descriptors for each event applies only to applications that have "
"initialized fanotify without using B<FAN_REPORT_FID> (see below).  "
"Permission events are requests to the receiving application to decide "
"whether permission for a file access shall be granted.  For these events, "
"the recipient must write a response which decides whether access is granted "
"or not."
msgstr ""
"Генерируется два типа событий: события I<уведомления> и события I<доступа>. "
"Уведомляющие события просто информируют и не требуют действия от принявшего "
"приложения, за исключением того, что файловый дескриптор, передаваемый в "
"событии общего типа, должен быть закрыт. Закрытие файловых дескрипторов для "
"каждого события применяется только приложениями, которые инициализировали "
"fanotify без использования B<FAN_REPORT_FID> (смотрите ниже). События "
"доступа запрашивают получившее приложение о разрешении доступа к файлу. Для "
"этих событий получатель должен написать ответ, давать ли доступ или нет."

#. type: Plain text
#: man-pages/man7/fanotify.7:132
msgid ""
"An event is removed from the event queue of the fanotify group when it has "
"been read.  Permission events that have been read are kept in an internal "
"list of the fanotify group until either a permission decision has been taken "
"by writing to the fanotify file descriptor or the fanotify file descriptor "
"is closed."
msgstr ""
"Событие удаляется из очереди событий группы fanotify после прочтения. "
"События доступа, которые были прочитаны, остаются во внутреннем списке "
"группы fanotify до тех пор, пока решение о доступе не будет записано в "
"файловый дескриптор fanotify, или файловый дескриптор fanotify не будет "
"закрыт."

#. type: SS
#: man-pages/man7/fanotify.7:132
#, no-wrap
msgid "Reading fanotify events"
msgstr "Чтение событий fanotify"

#. type: Plain text
#: man-pages/man7/fanotify.7:144
msgid ""
"Calling B<read>(2)  for the file descriptor returned by B<fanotify_init>(2)  "
"blocks (if the flag B<FAN_NONBLOCK> is not specified in the call to "
"B<fanotify_init>(2))  until either a file event occurs or the call is "
"interrupted by a signal (see B<signal>(7))."
msgstr ""
"Вызов B<read>(2) с файловым дескриптором, полученным от B<fanotify_init>(2), "
"блокирует выполнение (если не указан флаг B<FAN_NONBLOCK> в вызове "
"B<fanotify_init>(2)) до тех пор, пока не произойдёт файловое событие или "
"вызов не будет прерван сигналом (смотрите B<signal>(7))."

#. type: Plain text
#: man-pages/man7/fanotify.7:154
msgid ""
"The use of the B<FAN_REPORT_FID> flag in B<fanotify_init>(2)  influences "
"what data structures are returned to the event listener for each event.  "
"After a successful B<read>(2), the read buffer contains one or more of the "
"following structures:"
msgstr ""
"При указании флага B<FAN_REPORT_FID> в B<fanotify_init>(2) структуры данных "
"возвращаются слушателю событий в каждом событии. После успешного выполнения "
"B<read>(2) буфер чтения содержит одну или более следующих структур:"

#. type: Plain text
#: man-pages/man7/fanotify.7:166
#, no-wrap
msgid ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"
msgstr ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:177
msgid ""
"In the case where B<FAN_REPORT_FID> is supplied as one of the flags to "
"B<fanotify_init>(2), you should also expect to receive the structure "
"detailed below following the generic I<fanotify_event_metadata> structure "
"within the read buffer:"
msgstr ""
"Если в B<fanotify_init>(2) среди флагов указан и B<FAN_REPORT_FID>, то вы "
"также должны ожидать структуру после общей структуры "
"I<fanotify_event_metadata> в буфере чтения:"

#. type: Plain text
#: man-pages/man7/fanotify.7:185
#, no-wrap
msgid ""
"struct fanotify_event_info_fid {\n"
"    struct fanotify_event_info_header hdr;\n"
"    __kernel_fsid_t fsid;\n"
"    unsigned char file_handle[0];\n"
"};\n"
msgstr ""
"struct fanotify_event_info_fid {\n"
"    struct fanotify_event_info_header hdr;\n"
"    __kernel_fsid_t fsid;\n"
"    unsigned char file_handle[0];\n"
"};\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:192
msgid ""
"For performance reasons, it is recommended to use a large buffer size (for "
"example, 4096 bytes), so that multiple events can be retrieved by a single "
"B<read>(2)."
msgstr ""
"Для увеличения производительности рекомендуется использовать буфер большого "
"размера (например, 4096 байт) для того, чтобы получить несколько событий за "
"один вызов B<read>(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:197
msgid ""
"The return value of B<read>(2)  is the number of bytes placed in the buffer, "
"or -1 in case of an error (but see BUGS)."
msgstr ""
"Возвращаемое B<read>(2) значение — количество байт помещённых в буфер, или "
"-1 в случае ошибки (но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man7/fanotify.7:201
msgid "The fields of the I<fanotify_event_metadata> structure are as follows:"
msgstr "Поля структуры I<fanotify_event_metadata>:"

#. type: TP
#: man-pages/man7/fanotify.7:201
#, no-wrap
msgid "I<event_len>"
msgstr "I<event_len>"

#. type: Plain text
#: man-pages/man7/fanotify.7:215
msgid ""
"This is the length of the data for the current event and the offset to the "
"next event in the buffer.  Without B<FAN_REPORT_FID>, the value of "
"I<event_len> is always B<FAN_EVENT_METADATA_LEN>.  With B<FAN_REPORT_FID>, "
"I<event_len> also includes the variable length file identifier."
msgstr ""
"Длина данных текущего события и смещение на следующее событие в буфере. Без "
"B<FAN_REPORT_FID> значение I<event_len> всегда равно "
"B<FAN_EVENT_METADATA_LEN>. С B<FAN_REPORT_FID> значение I<event_len> также "
"включает идентификатор файла переменной длины."

#. type: TP
#: man-pages/man7/fanotify.7:215
#, no-wrap
msgid "I<vers>"
msgstr "I<vers>"

#. type: Plain text
#: man-pages/man7/fanotify.7:224
msgid ""
"This field holds a version number for the structure.  It must be compared to "
"B<FANOTIFY_METADATA_VERSION> to verify that the structures returned at run "
"time match the structures defined at compile time.  In case of a mismatch, "
"the application should abandon trying to use the fanotify file descriptor."
msgstr ""
"Номер версии структуры. Он должен сравниваться с "
"B<FANOTIFY_METADATA_VERSION> для проверки того, что структуры, возвращаемые "
"во время выполнения, соответствуют структурам, определённым во время "
"компиляция. В случае несоответствия приложение должно прекратить попытки "
"использовать файловый дескриптор fanotify."

#. type: TP
#: man-pages/man7/fanotify.7:224
#, no-wrap
msgid "I<reserved>"
msgstr "I<reserved>"

#. type: Plain text
#: man-pages/man7/fanotify.7:227
msgid "This field is not used."
msgstr "Не используется."

#. type: TP
#: man-pages/man7/fanotify.7:227
#, no-wrap
msgid "I<metadata_len>"
msgstr "I<metadata_len>"

#. type: Plain text
#: man-pages/man7/fanotify.7:233
msgid ""
"This is the length of the structure.  The field was introduced to facilitate "
"the implementation of optional headers per event type.  No such optional "
"headers exist in the current implementation."
msgstr ""
"Длина структуры. Это поле было добавлено для облегчения реализации "
"необязательных заголовков разных типов событий. В текущей реализации такие "
"необязательные заголовки отсутствуют."

#. type: TP
#: man-pages/man7/fanotify.7:233
#, no-wrap
msgid "I<mask>"
msgstr "I<mask>"

#. type: Plain text
#: man-pages/man7/fanotify.7:236
msgid "This is a bit mask describing the event (see below)."
msgstr "Битовая маска, описывающая событие (смотрите далее)."

#. type: TP
#: man-pages/man7/fanotify.7:236 man-pages/man7/fanotify.7:510
#, no-wrap
msgid "I<fd>"
msgstr "I<fd>"

#. type: Plain text
#: man-pages/man7/fanotify.7:249
msgid ""
"This is an open file descriptor for the object being accessed, or "
"B<FAN_NOFD> if a queue overflow occurred.  If the fanotify file descriptor "
"has been initialized using B<FAN_REPORT_FID>, applications should expect "
"this value to be set to B<FAN_NOFD> for each event that is received.  The "
"file descriptor can be used to access the contents of the monitored file or "
"directory.  The reading application is responsible for closing this file "
"descriptor."
msgstr ""
"Открытый файловый дескриптор объекта доступа или B<FAN_NOFD>, если возникло "
"переполнение очереди. Если файловый дескриптор fanotify инициализирован с "
"использованием B<FAN_REPORT_FID>,то приложения должны ожидать, что это "
"значение равно B<FAN_NOFD> у каждого полученного события. Файловый "
"дескриптор можно использовать для доступа к содержимому отслеживаемого файла "
"или каталога. Читающее приложение ответственно за закрытие этого файлового "
"дескриптора."

#. type: Plain text
#: man-pages/man7/fanotify.7:262
msgid ""
"When calling B<fanotify_init>(2), the caller may specify (via the "
"I<event_f_flags> argument) various file status flags that are to be set on "
"the open file description that corresponds to this file descriptor.  In "
"addition, the (kernel-internal)  B<FMODE_NONOTIFY> file status flag is set "
"on the open file description.  This flag suppresses fanotify event "
"generation.  Hence, when the receiver of the fanotify event accesses the "
"notified file or directory using this file descriptor, no additional events "
"will be created."
msgstr ""
"Когда вызывается B<fanotify_init>(2) вызывающий может указать (в аргументе "
"I<event_f_flags>) различные флаги состояния файла, которые будут установлены "
"на открытом файловом дескрипторе, соответствующем этому файловому "
"дескриптору. Также, на отрываемом файловом дескрипторе устанавливается "
"(внутри ядра) флаг состояния файла B<FMODE_NONOTIFY>. Этот флаг подавляет "
"генерацию событий fanotify. Таким образом, когда получатель события fanotify "
"обратится к отслеживаемому файлу или каталогу через этот файловый "
"дескриптор, дополнительных событий создано не будет."

#. type: TP
#: man-pages/man7/fanotify.7:262
#, no-wrap
msgid "I<pid>"
msgstr "I<pid>"

#. type: Plain text
#: man-pages/man7/fanotify.7:270
msgid ""
"If flag B<FAN_REPORT_TID> was set in B<fanotify_init>(2), this is the TID of "
"the thread that caused the event.  Otherwise, this the PID of the process "
"that caused the event."
msgstr ""
"Если в B<fanotify_init>(2) установлен флаг B<FAN_REPORT_TID>, то это TID "
"нити, из-за которой возникло событие. В противном случае это PID процесса, "
"из-за которой возникло событие."

#. type: Plain text
#: man-pages/man7/fanotify.7:276
msgid ""
"A program listening to fanotify events can compare this PID to the PID "
"returned by B<getpid>(2), to determine whether the event is caused by the "
"listener itself, or is due to a file access by another process."
msgstr ""
"Программа, слушающая события fanotify, может сравнить этот PID с PID, "
"возвращаемым B<getpid>(2), для проверки, что событие не возникло из-за "
"самого слушающего, а из-за доступа к файлу другого процесса."

#. type: Plain text
#: man-pages/man7/fanotify.7:286
msgid ""
"The bit mask in I<mask> indicates which events have occurred for a single "
"filesystem object.  Multiple bits may be set in this mask, if more than one "
"event occurred for the monitored filesystem object.  In particular, "
"consecutive events for the same filesystem object and originating from the "
"same process may be merged into a single event, with the exception that two "
"permission events are never merged into one queue entry."
msgstr ""
"В битовой маске I<mask> указывают события, произошедшие с одиночным объектом "
"файловой системы. В маске может быть установлено несколько бит, если было "
"более одного события с отслеживаемым объектом файловой системы. В частности, "
"возникшие друг за другом события с одним объектом файловой системы и "
"произошедшие из-за одного процесса могут быть объединены в одно событие, за "
"исключением того, что два события доступа никогда не объединяются в одном "
"элементе очереди."

#. type: Plain text
#: man-pages/man7/fanotify.7:290
msgid "The bits that may appear in I<mask> are as follows:"
msgstr "Биты маски I<mask>:"

#. type: TP
#: man-pages/man7/fanotify.7:290
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr "B<FAN_ACCESS>"

#. type: Plain text
#: man-pages/man7/fanotify.7:293
msgid "A file or a directory (but see BUGS) was accessed (read)."
msgstr "Доступ (на чтение) к файлу или каталогу (но смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man7/fanotify.7:293
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr "B<FAN_OPEN>"

#. type: Plain text
#: man-pages/man7/fanotify.7:296
msgid "A file or a directory was opened."
msgstr "Файл или каталог открыт."

#. type: TP
#: man-pages/man7/fanotify.7:296
#, no-wrap
msgid "B<FAN_OPEN_EXEC>"
msgstr "B<FAN_OPEN_EXEC>"

#. type: Plain text
#: man-pages/man7/fanotify.7:302
msgid ""
"A file was opened with the intent to be executed.  See NOTES in "
"B<fanotify_mark>(2)  for additional details."
msgstr "Файл открыт для выполнения. Смотрите ЗАМЕЧАНИЯ в B<fanotify_mark>(2)."

#. type: TP
#: man-pages/man7/fanotify.7:302
#, no-wrap
msgid "B<FAN_ATTRIB>"
msgstr "B<FAN_ATTRIB>"

#. type: Plain text
#: man-pages/man7/fanotify.7:305
msgid "A file or directory metadata was changed."
msgstr "Метаданные файла или каталога изменены."

#. type: TP
#: man-pages/man7/fanotify.7:305
#, no-wrap
msgid "B<FAN_CREATE>"
msgstr "B<FAN_CREATE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:308
msgid "A child file or directory was created in a watched parent."
msgstr "Создан дочерний файл или каталог в отслеживаемом родителе."

#. type: TP
#: man-pages/man7/fanotify.7:308
#, no-wrap
msgid "B<FAN_DELETE>"
msgstr "B<FAN_DELETE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:311
msgid "A child file or directory was deleted in a watched parent."
msgstr "Удалён дочерний файл или каталог в отслеживаемом родителе."

#. type: TP
#: man-pages/man7/fanotify.7:311
#, no-wrap
msgid "B<FAN_DELETE_SELF>"
msgstr "B<FAN_DELETE_SELF>"

#. type: Plain text
#: man-pages/man7/fanotify.7:314
msgid "A watched file or directory was deleted."
msgstr "Отслеживаемый файл или каталог был удалён."

#. type: TP
#: man-pages/man7/fanotify.7:314
#, no-wrap
msgid "B<FAN_MOVED_FROM>"
msgstr "B<FAN_MOVED_FROM>"

#. type: Plain text
#: man-pages/man7/fanotify.7:317
msgid "A file or directory has been moved from a watched parent directory."
msgstr ""
"Дочерний файл или каталог был перемещён из отслеживаемого родительского "
"каталога."

#. type: TP
#: man-pages/man7/fanotify.7:317
#, no-wrap
msgid "B<FAN_MOVED_TO>"
msgstr "B<FAN_MOVED_TO>"

#. type: Plain text
#: man-pages/man7/fanotify.7:320
msgid "A file or directory has been moved to a watched parent directory."
msgstr ""
"Дочерний файл или каталог был помещён в отслеживаемый родительский каталог."

#. type: TP
#: man-pages/man7/fanotify.7:320
#, no-wrap
msgid "B<FAN_MOVE_SELF>"
msgstr "B<FAN_MOVE_SELF>"

#. type: Plain text
#: man-pages/man7/fanotify.7:323
msgid "A watched file or directory was moved."
msgstr "Отслеживаемый файл или каталог был перемещён."

#. type: TP
#: man-pages/man7/fanotify.7:323
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr "B<FAN_MODIFY>"

#. type: Plain text
#: man-pages/man7/fanotify.7:326
msgid "A file was modified."
msgstr "Файл изменён."

#. type: TP
#: man-pages/man7/fanotify.7:326
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr "B<FAN_CLOSE_WRITE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:333
msgid ""
"A file that was opened for writing (B<O_WRONLY> or B<O_RDWR>)  was closed."
msgstr "Файл, открытый на запись (B<O_WRONLY> или B<O_RDWR>), закрыт."

#. type: TP
#: man-pages/man7/fanotify.7:333
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr "B<FAN_CLOSE_NOWRITE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:338
msgid ""
"A file or directory that was opened read-only (B<O_RDONLY>)  was closed."
msgstr "Файл или каталог, открытый только для чтения (B<O_RDONLY>), закрыт."

#. type: TP
#: man-pages/man7/fanotify.7:338
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr "B<FAN_Q_OVERFLOW>"

#. type: Plain text
#: man-pages/man7/fanotify.7:345
msgid ""
"The event queue exceeded the limit of 16384 entries.  This limit can be "
"overridden by specifying the B<FAN_UNLIMITED_QUEUE> flag when calling "
"B<fanotify_init>(2)."
msgstr ""
"Очередь событий превысила ограничение в 16384 записи. Это ограничение можно "
"изменить, указав флаг B<FAN_UNLIMITED_QUEUE> при вызове B<fanotify_init>(2)."

#. type: TP
#: man-pages/man7/fanotify.7:345
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr "B<FAN_ACCESS_PERM>"

#. type: Plain text
#: man-pages/man7/fanotify.7:354
msgid ""
"An application wants to read a file or directory, for example using "
"B<read>(2)  or B<readdir>(2).  The reader must write a response (as "
"described below)  that determines whether the permission to access the "
"filesystem object shall be granted."
msgstr ""
"Приложение хочет прочитать файл или каталог, например, с помощью B<read>(2) "
"или B<readdir>(2). Читатель события должен написать ответ (описано далее) о "
"разрешении доступа к объекту файловой системы."

#. type: TP
#: man-pages/man7/fanotify.7:354
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr "B<FAN_OPEN_PERM>"

#. type: Plain text
#: man-pages/man7/fanotify.7:359
msgid ""
"An application wants to open a file or directory.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object shall be granted."
msgstr ""
"Приложение хочет открыть файл или каталог. Читатель события должен написать "
"ответ о разрешении открытия объекта файловой системы."

#. type: TP
#: man-pages/man7/fanotify.7:359
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM>"
msgstr "B<FAN_OPEN_EXEC_PERM>"

#. type: Plain text
#: man-pages/man7/fanotify.7:367
msgid ""
"An application wants to open a file for execution.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object for execution shall be granted.  See NOTES in B<fanotify_mark>(2)  "
"for additional details."
msgstr ""
"Приложение хочет открыть файл для выполнения. Читатель должен написать ответ "
"о разрешении открытия объекта файловой системы для выполнения. Смотрите "
"ЗАМЕЧАНИЯ в B<fanotify_mark>(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:369
msgid "To check for any close event, the following bit mask may be used:"
msgstr ""
"Для проверки любого события закрытия может использоваться следующая битовая "
"маска:"

#. type: TP
#: man-pages/man7/fanotify.7:369
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr "B<FAN_CLOSE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:373
msgid "A file was closed.  This is a synonym for:"
msgstr "Файл закрыт. Это синоним:"

#. type: Plain text
#: man-pages/man7/fanotify.7:375
#, no-wrap
msgid "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"
msgstr "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:377
msgid "To check for any move event, the following bit mask may be used:"
msgstr ""
"Для проверки любого события перемещения может использоваться следующая "
"битовая маска:"

#. type: TP
#: man-pages/man7/fanotify.7:377
#, no-wrap
msgid "B<FAN_MOVE>"
msgstr "B<FAN_MOVE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:381
msgid "A file or directory was moved.  This is a synonym for:"
msgstr "Файл или каталог был перемещён. Это синоним для:"

#. type: Plain text
#: man-pages/man7/fanotify.7:383
#, no-wrap
msgid "    FAN_MOVED_FROM | FAN_MOVED_TO\n"
msgstr "    FAN_MOVED_FROM | FAN_MOVED_TO\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:387
msgid "The fields of the I<fanotify_event_info_fid> structure are as follows:"
msgstr "Поля структуры I<fanotify_event_info_fid>:"

#. type: TP
#: man-pages/man7/fanotify.7:387
#, no-wrap
msgid "I<hdr>"
msgstr "I<hdr>"

#. type: Plain text
#: man-pages/man7/fanotify.7:409
msgid ""
"This is a structure of type I<fanotify_event_info_header>.  It is a generic "
"header that contains information used to describe additional information "
"attached to the event.  For example, when an fanotify file descriptor is "
"created using B<FAN_REPORT_FID>, the I<info_type> field of this header is "
"set to B<FAN_EVENT_INFO_TYPE_FID>.  Event listeners can use this field to "
"check that the additional information received for an event is of the "
"correct type.  Additionally, the I<fanotify_event_info_header> also contains "
"a I<len> field.  In the current implementation, the value of I<len> is "
"always (event_len - FAN_EVENT_METADATA_LEN)."
msgstr ""
"Структура типа I<fanotify_event_info_header>. Это общий заголовок, "
"содержащий информацию для описания дополнительной информации, присоединяемой "
"к событию. Например, когда файловый дескриптор fanotify создан с "
"использованием B<FAN_REPORT_FID>, поле I<info_type> этого заголовка равно "
"B<FAN_EVENT_INFO_TYPE_FID>. Слушатели события могут использовать это поле "
"для проверки того, что полученная дополнительная информация о событии имеет "
"правильный тип. Также I<fanotify_event_info_header> содержит поле I<len>.  В "
"текущей реализации значение I<len> всегда равно (event_len - "
"FAN_EVENT_METADATA_LEN)."

#. type: TP
#: man-pages/man7/fanotify.7:409
#, no-wrap
msgid "I<fsid>"
msgstr "I<fsid>"

#. type: Plain text
#: man-pages/man7/fanotify.7:419
msgid ""
"This is a unique identifier of the filesystem containing the object "
"associated with the event.  It is a structure of type I<__kernel_fsid_t> and "
"contains the same value as I<f_fsid> when calling B<statfs>(2)."
msgstr ""
"Уникальный идентификатор файловой системы, содержащей объект, связанный с "
"событием. Это структура имеет тип I<__kernel_fsid_t> и содержит те же "
"значения что и I<f_fsid> при вызове B<statfs>(2)."

#. type: TP
#: man-pages/man7/fanotify.7:419
#, no-wrap
msgid "I<file_handle>"
msgstr "I<file_handle>"

#. type: Plain text
#: man-pages/man7/fanotify.7:446
msgid ""
"This is a variable length structure of type I<file_handle>.  It is an opaque "
"handle that corresponds to a specified object on a filesystem as returned by "
"B<name_to_handle_at>(2).  It can be used to uniquely identify a file on a "
"filesystem and can be passed as an argument to B<open_by_handle_at>(2).  "
"Note that for directory entry events, such as B<FAN_CREATE>, B<FAN_DELETE>, "
"and B<FAN_MOVE>, the I<file_handle> describes the modified directory and not "
"the created/deleted/moved child object.  The events B<FAN_ATTRIB>, "
"B<FAN_DELETE_SELF>, and B<FAN_MOVE_SELF> will carry the I<file_handle> "
"information for the child object if the child object is being watched."
msgstr ""
"Структура переменной длины, имеет тип I<file_handle>. Это закрытый "
"описатель, который соответствует заданному объекту файловой системы, "
"возвращается B<name_to_handle_at>(2). Её можно использовать как уникально "
"определяемую файл в файловой системе и передавать аргументом в "
"B<open_by_handle_at>(2). Заметим, что для событий элементов каталога, таких "
"как B<FAN_CREATE>, B<FAN_DELETE>, и B<FAN_MOVE>, значение I<file_handle> "
"описывает изменяемый каталог, а не созданный/удалённый/перемещённый дочерний "
"объект. События B<FAN_ATTRIB>, B<FAN_DELETE_SELF> и B<FAN_MOVE_SELF> будут "
"содержать информацию I<file_handle> о дочернем объекте, если дочерний объект "
"отслеживается."

#. type: Plain text
#: man-pages/man7/fanotify.7:451
msgid ""
"The following macros are provided to iterate over a buffer containing "
"fanotify event metadata returned by a B<read>(2)  from an fanotify file "
"descriptor:"
msgstr ""
"Следующие макросы позволяют обходить буфер с метаданными событий fanotify, "
"возвращаемый B<read>(2) из файлового дескриптора fanotify:"

#. type: TP
#: man-pages/man7/fanotify.7:451
#, no-wrap
msgid "B<FAN_EVENT_OK(meta, len)>"
msgstr "B<FAN_EVENT_OK(meta, len)>"

#. type: Plain text
#: man-pages/man7/fanotify.7:460
msgid ""
"This macro checks the remaining length I<len> of the buffer I<meta> against "
"the length of the metadata structure and the I<event_len> field of the first "
"metadata structure in the buffer."
msgstr ""
"Этот макрос сверяет оставшуюся длину I<len> буфера I<meta> с длиной "
"структуры метаданных и полем I<event_len> из первой структуры метаданных в "
"буфере."

#. type: TP
#: man-pages/man7/fanotify.7:460
#, no-wrap
msgid "B<FAN_EVENT_NEXT(meta, len)>"
msgstr "B<FAN_EVENT_NEXT(meta, len)>"

#. type: Plain text
#: man-pages/man7/fanotify.7:479
msgid ""
"This macro uses the length indicated in the I<event_len> field of the "
"metadata structure pointed to by I<meta> to calculate the address of the "
"next metadata structure that follows I<meta>.  I<len> is the number of bytes "
"of metadata that currently remain in the buffer.  The macro returns a "
"pointer to the next metadata structure that follows I<meta>, and reduces "
"I<len> by the number of bytes in the metadata structure that has been "
"skipped over (i.e., it subtracts I<meta-E<gt>event_len> from I<len>)."
msgstr ""
"Этот макрос использует длину из поля I<event_len> структуры метаданных, на "
"которую указывает I<meta>, для вычисления адреса следующей структуры "
"метаданных, которая находится после I<meta>. В поле I<len> указано "
"количество байт метаданных, оставшихся в буфере. Макрос возвращает указатель "
"на следующую структуру метаданных после I<meta> и уменьшает I<len> на "
"количество байт в структуре метаданных, которая была пропущена (т. е., "
"вычитает I<meta-E<gt>event_len> из I<len>)."

#. type: Plain text
#: man-pages/man7/fanotify.7:481
msgid "In addition, there is:"
msgstr "Дополнительно есть:"

#. type: TP
#: man-pages/man7/fanotify.7:481
#, no-wrap
msgid "B<FAN_EVENT_METADATA_LEN>"
msgstr "B<FAN_EVENT_METADATA_LEN>"

#. type: Plain text
#: man-pages/man7/fanotify.7:487
msgid ""
"This macro returns the size (in bytes) of the structure "
"I<fanotify_event_metadata>.  This is the minimum size (and currently the "
"only size) of any event metadata."
msgstr ""
"Этот макрос возвращает размер (в байтах) структуры "
"I<fanotify_event_metadata>. Это минимальный размер (и, в настоящее время, "
"единственный) метаданных любого события."

#. type: SS
#: man-pages/man7/fanotify.7:487
#, no-wrap
msgid "Monitoring an fanotify file descriptor for events"
msgstr "Отслеживание событий через файловый дескриптор fanotify"

#. type: Plain text
#: man-pages/man7/fanotify.7:494
msgid ""
"When an fanotify event occurs, the fanotify file descriptor indicates as "
"readable when passed to B<epoll>(7), B<poll>(2), or B<select>(2)."
msgstr ""
"Когда возникает событие fanotify файловый дескриптор fanotify помечается как "
"доступный для чтения при его передаче в B<epoll>(7), B<poll>(2) или "
"B<select>(2)."

#. type: SS
#: man-pages/man7/fanotify.7:494
#, no-wrap
msgid "Dealing with permission events"
msgstr "Работа с событиями доступа"

#. type: Plain text
#: man-pages/man7/fanotify.7:499
msgid ""
"For permission events, the application must B<write>(2)  a structure of the "
"following form to the fanotify file descriptor:"
msgstr ""
"Для событий доступа приложение должно записать (B<write>(2)) в файловый "
"дескриптор fanotify следующую структуру:"

#. type: Plain text
#: man-pages/man7/fanotify.7:506
#, no-wrap
msgid ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"
msgstr ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:510
msgid "The fields of this structure are as follows:"
msgstr "Поля этой структуры имеют следующее назначение:"

#. type: Plain text
#: man-pages/man7/fanotify.7:514
msgid ""
"This is the file descriptor from the structure I<fanotify_event_metadata>."
msgstr "Файловый дескриптор из структуры I<fanotify_event_metadata>."

#. type: TP
#: man-pages/man7/fanotify.7:514
#, no-wrap
msgid "I<response>"
msgstr "I<response>"

#. type: Plain text
#: man-pages/man7/fanotify.7:522
msgid ""
"This field indicates whether or not the permission is to be granted.  Its "
"value must be either B<FAN_ALLOW> to allow the file operation or B<FAN_DENY> "
"to deny the file operation."
msgstr ""
"В этом поле указывает о разрешении доступа или запрещении. Данное значение "
"должно быть равно B<FAN_ALLOW>, чтобы разрешить операцию с файлом, или "
"B<FAN_DENY> для запрета."

#. type: Plain text
#: man-pages/man7/fanotify.7:526
msgid ""
"If access is denied, the requesting application call will receive an "
"B<EPERM> error."
msgstr ""
"Если доступ запрещается, то запрашивающее приложение получит ошибку B<EPERM>."

#. type: SS
#: man-pages/man7/fanotify.7:526
#, no-wrap
msgid "Closing the fanotify file descriptor"
msgstr "Закрытие файлового дескриптора fanotify"

#. type: Plain text
#: man-pages/man7/fanotify.7:534
msgid ""
"When all file descriptors referring to the fanotify notification group are "
"closed, the fanotify group is released and its resources are freed for reuse "
"by the kernel.  Upon B<close>(2), outstanding permission events will be set "
"to allowed."
msgstr ""
"Когда все файловые дескрипторы, указывающие на группу уведомления fanotify, "
"закрыты, группа fanotify освобождается и её ресурсы становятся доступны ядру "
"для повторного использования. После B<close>(2) все оставшиеся "
"непросмотренные события доступа будут разрешены."

#. type: SS
#: man-pages/man7/fanotify.7:534
#, no-wrap
msgid "/proc/[pid]/fdinfo"
msgstr "/proc/[pid]/fdinfo"

#. type: Plain text
#: man-pages/man7/fanotify.7:544
msgid ""
"The file I</proc/[pid]/fdinfo/[fd]> contains information about fanotify "
"marks for file descriptor I<fd> of process I<pid>.  See B<proc>(5)  for "
"details."
msgstr ""
"Файл I</proc/[pid]/fdinfo/[fd]> содержит информацию о метках fanotify для "
"файлового дескриптора I<fd> процесса I<pid> Подробности смотрите в "
"B<proc>(5)."

#. type: Plain text
#: man-pages/man7/fanotify.7:549
msgid ""
"In addition to the usual errors for B<read>(2), the following errors can "
"occur when reading from the fanotify file descriptor:"
msgstr ""
"Кроме обычных ошибок B<read>(2) при чтении из файлового дескриптора fanotify "
"могут возникать следующие ошибки:"

#. type: Plain text
#: man-pages/man7/fanotify.7:552
msgid "The buffer is too small to hold the event."
msgstr "Буфер слишком мал для хранения события."

#. type: TP
#: man-pages/man7/fanotify.7:552
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:559
msgid ""
"The per-process limit on the number of open files has been reached.  See the "
"description of B<RLIMIT_NOFILE> in B<getrlimit>(2)."
msgstr ""
"Достигнуто максимальное попроцессное количество открытых файлов. Смотрите "
"описание B<RLIMIT_NOFILE> в B<getrlimit>(2)."

#. type: TP
#: man-pages/man7/fanotify.7:559
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man7/fanotify.7:566
msgid ""
"The system-wide limit on the total number of open files has been reached.  "
"See I</proc/sys/fs/file-max> in B<proc>(5)."
msgstr ""
"Достигнут предел на общее количество открытых файлов в системе. Смотрите I</"
"proc/sys/fs/file-max> в B<proc>(5)."

#. type: TP
#: man-pages/man7/fanotify.7:566
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: man-pages/man7/fanotify.7:579
msgid ""
"This error is returned by B<read>(2)  if B<O_RDWR> or B<O_WRONLY> was "
"specified in the I<event_f_flags> argument when calling B<fanotify_init>(2)  "
"and an event occurred for a monitored file that is currently being executed."
msgstr ""
"Эта ошибка возвращается B<read>(2), если при вызове B<fanotify_init>(2) в "
"аргументе I<event_f_flags> был указан B<O_RDWR> или B<O_WRONLY> и произошло "
"событие с отслеживаемым файлом, который в данный момент выполняется."

#. type: Plain text
#: man-pages/man7/fanotify.7:583
msgid ""
"In addition to the usual errors for B<write>(2), the following errors can "
"occur when writing to the fanotify file descriptor:"
msgstr ""
"Кроме обычных ошибок B<write>(2) при записи в файловый дескриптор fanotify "
"могут возникать следующие ошибки:"

#. type: Plain text
#: man-pages/man7/fanotify.7:589
msgid ""
"Fanotify access permissions are not enabled in the kernel configuration or "
"the value of I<response> in the response structure is not valid."
msgstr ""
"Свойство для проверки прав доступа fanotify не включено в настройках ядра "
"или некорректное значение I<response> в структуре ответа."

#. type: TP
#: man-pages/man7/fanotify.7:589
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man7/fanotify.7:596
msgid ""
"The file descriptor I<fd> in the response structure is not valid.  This may "
"occur when a response for the permission event has already been written."
msgstr ""
"Некорректный файловый дескриптор I<fd> в структуре ответа. Это может "
"происходить, когда ответ на право доступа уже был записан."

#. type: SH
#: man-pages/man7/fanotify.7:596
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/fanotify.7:600
msgid ""
"The fanotify API was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37.  Fdinfo support was added in version 3.8."
msgstr ""
"Программный интерфейс fanotify представлен в версии 2.6.36 ядра Linux и "
"включён в версии 2.6.37. Поддержка fdinfo была добавлена в версии 3.8."

#. type: Plain text
#: man-pages/man7/fanotify.7:602
msgid "The fanotify API is Linux-specific."
msgstr "Программный интерфейс fanotify есть только в Linux."

#. type: Plain text
#: man-pages/man7/fanotify.7:609
msgid ""
"The fanotify API is available only if the kernel was built with the "
"B<CONFIG_FANOTIFY> configuration option enabled.  In addition, fanotify "
"permission handling is available only if the "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> configuration option is enabled."
msgstr ""
"Программный интерфейс fanotify доступен только, если ядро собрано с "
"включённым параметром настройки B<CONFIG_FANOTIFY>. Также, работа с доступом "
"в fanotify доступна только, если включён параметр настройки "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS>."

#. type: SS
#: man-pages/man7/fanotify.7:609
#, no-wrap
msgid "Limitations and caveats"
msgstr "Ограничения и подводные камни"

#. type: Plain text
#: man-pages/man7/fanotify.7:614
msgid ""
"Fanotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems."
msgstr ""
"Fanotify сообщает только о событиях, которые возникли при использовании "
"пользовательскими программами программного интерфейса файловой системы. "
"Поэтому события об обращении к файлам в сетевых файловых системах не "
"отлавливаются."

#. type: Plain text
#: man-pages/man7/fanotify.7:621
msgid ""
"The fanotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""
"Программный интерфейс fanotify не сообщает о доступе и изменениях, которые "
"могут произойти из-за B<mmap>(2), B<msync>(2) и B<munmap>(2)."

#. type: Plain text
#: man-pages/man7/fanotify.7:626
msgid ""
"Events for directories are created only if the directory itself is opened, "
"read, and closed.  Adding, removing, or changing children of a marked "
"directory does not create events for the monitored directory itself."
msgstr ""
"События для каталогов создаются только, если сам каталог открывается, "
"читается и закрывается. Добавление, удаление и изменение потомков "
"отслеживаемого каталога не приводит к возникновению событий."

#. type: Plain text
#: man-pages/man7/fanotify.7:636
msgid ""
"Fanotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional marks must be created.  (But "
"note that the fanotify API provides no way of detecting when a subdirectory "
"has been created under a marked directory, which makes recursive monitoring "
"difficult.)  Monitoring mounts offers the capability to monitor a whole "
"directory tree.  Monitoring filesystems offers the capability to monitor "
"changes made from any mount of a filesystem instance."
msgstr ""
"Fanotify не следит за каталогами рекурсивно: чтобы следить за подкаталогами "
"каталога, нужно их явно пометить (и, заметим, что программный интерфейс "
"fanotify не позволяет отслеживать создание подкаталога, что затрудняет "
"рекурсивное слежение). Отслеживание точек монтирования позволяет следить за "
"всем деревом каталогов. Отслеживание файловых систем позволяет следить за "
"изменениями, сделанными в любом смонтированном экземпляре файловой системы."

#. type: Plain text
#: man-pages/man7/fanotify.7:639
msgid "The event queue can overflow.  In this case, events are lost."
msgstr "Очередь событий может переполниться. В этом случае события теряются."

#. type: SH
#: man-pages/man7/fanotify.7:639
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  commit 820c12d5d6c0890bc93dd63893924a13041fdc35
#. type: Plain text
#: man-pages/man7/fanotify.7:650
msgid ""
"Before Linux 3.19, B<fallocate>(2)  did not generate fanotify events.  Since "
"Linux 3.19, calls to B<fallocate>(2)  generate B<FAN_MODIFY> events."
msgstr ""
"До Linux 3.19, B<fallocate>(2) не генерировал событий fanotify. Начиная с "
"Linux 3.19, вызовы B<fallocate>(2)  генерируют событие B<FAN_MODIFY>."

#. type: Plain text
#: man-pages/man7/fanotify.7:653
msgid "As of Linux 3.17, the following bugs exist:"
msgstr "В Linux 3.17 существуют следующие дефекты:"

#. type: Plain text
#: man-pages/man7/fanotify.7:662
msgid ""
"On Linux, a filesystem object may be accessible through multiple paths, for "
"example, a part of a filesystem may be remounted using the I<--bind> option "
"of B<mount>(8).  A listener that marked a mount will be notified only of "
"events that were triggered for a filesystem object using the same mount.  "
"Any other event will pass unnoticed."
msgstr ""
"В Linux объект файловой системы может быть доступен через несколько путей, "
"например, часть файловой системы может быть перемонтирована B<mount>(8) с "
"использованием параметра I<--bind>. Ожидающий слушатель получит уведомления "
"об объекте файловой системы только из запрошенной точки монтирования. О "
"событиях из других точек уведомлений не поступит."

#.  FIXME . A patch was proposed.
#. type: Plain text
#: man-pages/man7/fanotify.7:671
msgid ""
"When an event is generated, no check is made to see whether the user ID of "
"the receiving process has authorization to read or write the file before "
"passing a file descriptor for that file.  This poses a security risk, when "
"the B<CAP_SYS_ADMIN> capability is set for programs executed by unprivileged "
"users."
msgstr ""
"При генерации события не делается проверка, что пользовательскому ID "
"получающего процесса разрешено читать или писать в файл перед передачей "
"файлового дескриптора на этот файл. Это представляет некоторый риск "
"безопасности, когда у программ, выполняющихся непривилегированными "
"пользователями, есть мандат B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man7/fanotify.7:681
msgid ""
"If a call to B<read>(2)  processes multiple events from the fanotify queue "
"and an error occurs, the return value will be the total length of the events "
"successfully copied to the user-space buffer before the error occurred.  The "
"return value will not be -1, and I<errno> will not be set.  Thus, the "
"reading application has no way to detect the error."
msgstr ""
"Если вызов B<read>(2) получает несколько событий из очереди fanotify и "
"возникает ошибка, будет возвращена полная длина событий, которые были "
"успешно скопированы в буфер пользовательского пространства до ошибки. "
"Возвращаемое значение не будет равно -1, и в I<errno> не записывается код "
"ошибки. То есть читающее приложение не может обнаружить ошибку."

#. type: SH
#: man-pages/man7/fanotify.7:681
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man7/fanotify.7:683
msgid ""
"The two example programs below demonstrate the usage of the fanotify API."
msgstr ""
"Далее показано два примера программы, в которых "
"продемонстрированоиспользование программного интерфейса fanotify."

#. type: SS
#: man-pages/man7/fanotify.7:683
#, no-wrap
msgid "Example program: fanotify_example.c"
msgstr "Программа-пример: fanotify_example.c"

#. type: Plain text
#: man-pages/man7/fanotify.7:695
msgid ""
"The first program is an example of fanotify being used with its event object "
"information passed in the form of a file descriptor.  The program marks the "
"mount point passed as a command-line argument and waits for events of type "
"B<FAN_OPEN_PERM> and B<FAN_CLOSE_WRITE>.  When a permission event occurs, a "
"B<FAN_ALLOW> response is given."
msgstr ""
"В первой программе показано как использовать fanotify с информацией об "
"событийном объекте, передаваемом в виде файлового дескриптора. Программа "
"помечает точку монтирования, переданную в аргументе командной строки, и ждёт "
"событий с типом B<FAN_OPEN_PERM> и B<FAN_CLOSE_WRITE>. При возникновении "
"событий доступа выдаёт ответ B<FAN_ALLOW>."

#. type: Plain text
#: man-pages/man7/fanotify.7:707
msgid ""
"The following shell session shows an example of running this program.  This "
"session involved editing the file I</home/user/temp/notes>.  Before the file "
"was opened, a B<FAN_OPEN_PERM> event occurred.  After the file was closed, a "
"B<FAN_CLOSE_WRITE> event occurred.  Execution of the program ends when the "
"user presses the ENTER key."
msgstr ""
"В сеансе оболочки далее показан пример запуска программы. В сеансе "
"выполняется редактирование файла I</home/user/temp/notes>. Перед открытием "
"файла возникает событие B<FAN_OPEN_PERM>. После закрытия файла возникает "
"событие B<FAN_CLOSE_WRITE>. Выполнение программы заканчивается после нажатия "
"пользователем клавиши ENTER."

#. type: Plain text
#: man-pages/man7/fanotify.7:715
#, no-wrap
msgid ""
"# B<./fanotify_example /home>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"
msgstr ""
"# B<./fanotify_example /home>\n"
"Нажмите enter для завершения работы.\n"
"Ожидание событий.\n"
"FAN_OPEN_PERM: Файл /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: Файл /home/user/temp/notes\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:717
#, no-wrap
msgid "Listening for events stopped.\n"
msgstr "Ожидание событий прекращено.\n"

#. type: SS
#: man-pages/man7/fanotify.7:721
#, no-wrap
msgid "Program source: fanotify_example.c"
msgstr "Исходный код программы: fanotify_example.c"

#. type: Plain text
#: man-pages/man7/fanotify.7:733
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* для получения определения O_LARGEFILE */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:735
#, no-wrap
msgid "/* Read all available fanotify events from the file descriptor \\(aqfd\\(aq */\n"
msgstr "/* читаем все доступные события fanotify из файлового дескриптора «fd» */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:746
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"
msgstr ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:748
#, no-wrap
msgid "    /* Loop while events can be read from fanotify file descriptor */\n"
msgstr ""
"    /* проходим по всем событиям, которые можем прочитать\n"
"       из файлового дескриптора fanotify */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:750
#, no-wrap
msgid "    for (;;) {\n"
msgstr "    for (;;) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:752
#, no-wrap
msgid "        /* Read some events */\n"
msgstr "        /* читаем несколько событий */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:758
#, no-wrap
msgid ""
"        len = read(fd, (void *) &buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        len = read(fd, (void *) &buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:760
#, no-wrap
msgid "        /* Check if end of available data reached */\n"
msgstr "        /* проверяем, достигнут ли конец доступных данных */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:763
#, no-wrap
msgid ""
"        if (len E<lt>= 0)\n"
"            break;\n"
msgstr ""
"        if (len E<lt>= 0)\n"
"            break;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:765
#, no-wrap
msgid "        /* Point to the first event in the buffer */\n"
msgstr "        /* выбираем первое событие в буфере */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:767
#, no-wrap
msgid "        metadata = buf;\n"
msgstr "        metadata = buf;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:769
#, no-wrap
msgid "        /* Loop over all events in the buffer */\n"
msgstr "        /* проходим по всем событиям в буфере */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:771
#, no-wrap
msgid "        while (FAN_EVENT_OK(metadata, len)) {\n"
msgstr "        while (FAN_EVENT_OK(metadata, len)) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:773
#, no-wrap
msgid "            /* Check that run-time and compile-time structures match */\n"
msgstr ""
"            /* проверяем, что структуры, использовавшиеся при сборке,\n"
"               идентичны структурам при выполнении */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:779
#, no-wrap
msgid ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Версия метаданных fanotify не совпадает.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:783
#, no-wrap
msgid ""
"            /* metadata-E<gt>fd contains either FAN_NOFD, indicating a\n"
"               queue overflow, or a file descriptor (a nonnegative\n"
"               integer). Here, we simply ignore queue overflow. */\n"
msgstr ""
"            /* metadata-E<gt>fd содержит или FAN_NOFD, указывающее\n"
"               на переполнение очереди, или файловый дескриптор\n"
"               (неотрицательное целое). Здесь мы просто игнорируем\n"
"               переполнение очереди. */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:785
#, no-wrap
msgid "            if (metadata-E<gt>fd E<gt>= 0) {\n"
msgstr "            if (metadata-E<gt>fd E<gt>= 0) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:787
#, no-wrap
msgid "                /* Handle open permission event */\n"
msgstr "                /* обрабатываем событие на право открытия */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:790
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"
msgstr ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:792
#, no-wrap
msgid "                    /* Allow file to be opened */\n"
msgstr "                    /* разрешаем открыть файл */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:798
#, no-wrap
msgid ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response,\n"
"                          sizeof(struct fanotify_response));\n"
"                }\n"
msgstr ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response,\n"
"                          sizeof(struct fanotify_response));\n"
"                }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:800
#, no-wrap
msgid "                /* Handle closing of writable file event */\n"
msgstr "                /* обрабатываем событие закрытия записываемого файла */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:803
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"
msgstr ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:805
#, no-wrap
msgid "                /* Retrieve and print pathname of the accessed file */\n"
msgstr ""
"                /* получаем и выводим имя файла, к которому\n"
"                   отслеживается доступ */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:814
#, no-wrap
msgid ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
msgstr ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:817
#, no-wrap
msgid ""
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"                printf(\"File %s\\en\", path);\n"
msgstr ""
"                path[path_len] = \\(aq\\e0\\(aq;\n"
"                printf(\"Файл %s\\en\", path);\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:819
#, no-wrap
msgid "                /* Close the file descriptor of the event */\n"
msgstr "                /* закрываем файловый дескриптор из события */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:822
#, no-wrap
msgid ""
"                close(metadata-E<gt>fd);\n"
"            }\n"
msgstr ""
"                close(metadata-E<gt>fd);\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:824
#, no-wrap
msgid "            /* Advance to next event */\n"
msgstr "            /* переходим на следующее событие */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:829
#, no-wrap
msgid ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:837
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:839
#, no-wrap
msgid "    /* Check mount point is supplied */\n"
msgstr "    /* проверяем заданную точку монтирования */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:844
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s ТОЧКА_МОНТИРОВАНИЯ\\en\",\n"
"                                        argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:846
#, no-wrap
msgid "    printf(\"Press enter key to terminate.\\en\");\n"
msgstr "    printf(\"Нажмите enter для завершения работы.\\en\");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:848
#, no-wrap
msgid "    /* Create the file descriptor for accessing the fanotify API */\n"
msgstr "    /* Создаём файловый дескриптор для доступа к fanotify API */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:855
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:860
#, no-wrap
msgid ""
"    /* Mark the mount for:\n"
"       - permission events before opening files\n"
"       - notification events after closing a write-enabled\n"
"         file descriptor */\n"
msgstr ""
"    /* Помечаем точку монтирования для:\n"
"       - событий доступа перед открытием файлов\n"
"       - событий уведомления после закрытия файлового дескриптора\n"
"         для файла открытого для записи */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:867
#, no-wrap
msgid ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:869
#, no-wrap
msgid "    /* Prepare for polling */\n"
msgstr "    /* подготовка к опросу */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:871
#, no-wrap
msgid "    nfds = 2;\n"
msgstr "    nfds = 2;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:873
#, no-wrap
msgid "    /* Console input */\n"
msgstr "    /* ввод с консоли  */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:876
#, no-wrap
msgid ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"
msgstr ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:878
#, no-wrap
msgid "    /* Fanotify input */\n"
msgstr "    /* ввод из fanotify */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:881
#, no-wrap
msgid ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"
msgstr ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:883
#, no-wrap
msgid "    /* This is the loop to wait for incoming events */\n"
msgstr "    /* цикл ожидания входящих событий */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:885 man-pages/man7/fanotify.7:1035
#, no-wrap
msgid "    printf(\"Listening for events.\\en\");\n"
msgstr "    printf(\"Ожидание событий.\\en\");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:891
#, no-wrap
msgid ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* Interrupted by a signal */\n"
"                continue;           /* Restart poll() */\n"
msgstr ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* прервано сигналом */\n"
"                continue;           /* перезапуск poll() */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:895
#, no-wrap
msgid ""
"            perror(\"poll\");         /* Unexpected error */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"            perror(\"poll\");         /* неожиданная ошибка */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:898
#, no-wrap
msgid ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"
msgstr ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:900
#, no-wrap
msgid "                /* Console input is available: empty stdin and quit */\n"
msgstr "                /* доступен ввод с консоли: опустошаем stdin и выходим */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:905
#, no-wrap
msgid ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != \\(aq\\en\\(aq)\n"
"                    continue;\n"
"                break;\n"
"            }\n"
msgstr ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != \\(aq\\en\\(aq)\n"
"                    continue;\n"
"                break;\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:907
#, no-wrap
msgid "            if (fds[1].revents & POLLIN) {\n"
msgstr "            if (fds[1].revents & POLLIN) {\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:909
#, no-wrap
msgid "                /* Fanotify events are available */\n"
msgstr "                /* доступны события fanotify */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:914
#, no-wrap
msgid ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:918
#, no-wrap
msgid ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Ожидание событий прекращено.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SS
#: man-pages/man7/fanotify.7:920
#, no-wrap
msgid "Example program: fanotify_fid.c"
msgstr "Программа-пример: fanotify_fid.c"

#. type: Plain text
#: man-pages/man7/fanotify.7:933
msgid ""
"The second program is an example of fanotify being used with "
"B<FAN_REPORT_FID> enabled.  The program marks the filesystem object that is "
"passed as a command-line argument and waits until an event of type "
"B<FAN_CREATE> has occurred.  The event mask indicates which type of "
"filesystem object\\(emeither a file or a directory\\(emwas created.  Once "
"all events have been read from the buffer and processed accordingly, the "
"program simply terminates."
msgstr ""
"Во второй программе показано как использовать fanotify с включённым "
"B<FAN_REPORT_FID>. Программа помечает объект файловой системы, переданный в "
"аргументе командной строки, и ждёт возникновения события с типом "
"B<FAN_CREATE>. В маске событий задаётся какой тип объекта файловой системы "
"ждать — файл или каталог. После того как все события из буфера будут "
"прочитаны и правильно обработаны программа просто завершает работу."

#. type: Plain text
#: man-pages/man7/fanotify.7:936
msgid ""
"The following shell sessions show two different invocations of this program, "
"with different actions performed on a watched object."
msgstr ""
"В следующих сеансах показано два разных запуска программы с разными "
"выполняемыми действиями над наблюдаемым объектом."

#. type: Plain text
#: man-pages/man7/fanotify.7:949
msgid ""
"The first session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a regular file, I</home/user/testfile.txt>.  "
"This results in a B<FAN_CREATE> event being created and reported against the "
"file's parent watched directory object.  Program execution ends once all "
"events captured within the buffer have been processed.  Program execution "
"ends once all events captured within the buffer are processed."
msgstr ""
"В первом сеансе ставится отметка на I</home/user>. После этого создаётся "
"обычный файл I</home/user/testfile.txt>. В результате возникает событие "
"B<FAN_CREATE>, в котором передаётсяобъект отслеживаемого родительского "
"каталога файла. Программа завершает выполнение после обработки всех "
"захваченных и помещённых в буфер событий."

#. type: Plain text
#: man-pages/man7/fanotify.7:956
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE (file created): Directory /home/user has been modified.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""
"# B<./fanotify_fid /home/user>\n"
"Ожидание событий.\n"
"FAN_CREATE (создан файл): Каталог /home/user изменён.\n"
"Все события успешно обработаны. Завершение программы.\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:958
#, no-wrap
msgid "$ B<touch /home/user/testing>              # In another terminal\n"
msgstr "$ B<touch /home/user/testing>              # в другом терминале\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:970
msgid ""
"The second session shows a mark being placed on I</home/user>.  This is "
"followed by the creation of a directory, I</home/user/testdir>.  This "
"specific action results in the program producing a B<FAN_CREATE> and "
"B<FAN_ONDIR> event."
msgstr ""
"Во втором сеансе ставится отметка на I</home/user>. После этого создаётся "
"каталог I</home/user/testdir>. В результате такого специального действия в "
"программу передаются события B<FAN_CREATE> и B<FAN_ONDIR>."

#. type: Plain text
#: man-pages/man7/fanotify.7:978
#, no-wrap
msgid ""
"# B<./fanotify_fid /home/user>\n"
"Listening for events.\n"
"FAN_CREATE | FAN_ONDIR (subdirectory created):\n"
"        Directory /home/user has been modified.\n"
"All events processed successfully. Program exiting.\n"
msgstr ""
"# B<./fanotify_fid /home/user>\n"
"Ожидание событий.\n"
"FAN_CREATE | FAN_ONDIR (создан подкаталог):\n"
"        Каталог /home/user изменён.\n"
"Все события успешно обработаны. Завершение программы.\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:980
#, no-wrap
msgid "$ B<mkdir -p /home/user/testing>          # In another terminal\n"
msgstr "$ B<mkdir -p /home/user/testing>          # в другом терминале\n"

#. type: SS
#: man-pages/man7/fanotify.7:982
#, no-wrap
msgid "Program source: fanotify_fid.c"
msgstr "Исходный код программы: fanotify_fid.c"

#. type: Plain text
#: man-pages/man7/fanotify.7:995
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:997
#, no-wrap
msgid "#define BUF_SIZE 256\n"
msgstr "#define BUF_SIZE 256\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1009
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd, ret, event_fd;\n"
"    ssize_t len, path_len;\n"
"    char path[PATH_MAX];\n"
"    char procfd_path[PATH_MAX];\n"
"    char events_buf[BUF_SIZE];\n"
"    struct file_handle *file_handle;\n"
"    struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_info_fid *fid;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd, ret, event_fd;\n"
"    ssize_t len, path_len;\n"
"    char path[PATH_MAX];\n"
"    char procfd_path[PATH_MAX];\n"
"    char events_buf[BUF_SIZE];\n"
"    struct file_handle *file_handle;\n"
"    struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_info_fid *fid;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1014
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Invalid number of command line arguments.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Некорректное количество аргументов в командной строке.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1017
#, no-wrap
msgid ""
"    /* Create an fanotify file descriptor with FAN_REPORT_FID as a flag\n"
"       so that program can receive fid events. */\n"
msgstr ""
"    /* создаём файловый дескриптор fanotify с флагом FAN_REPORT_FID для\n"
"       того, чтобы программа могла принимать события fid. */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1023
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_FID, 0);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_FID, 0);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1025
#, no-wrap
msgid "    /* Place a mark on the filesystem object supplied in argv[1]. */\n"
msgstr "    /* ставим метку на объект файловой системы, заданный в argv[1]. */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1033
#, no-wrap
msgid ""
"    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,\n"
"                        FAN_CREATE | FAN_ONDIR,\n"
"                        AT_FDCWD, argv[1]);\n"
"    if (ret == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,\n"
"                        FAN_CREATE | FAN_ONDIR,\n"
"                        AT_FDCWD, argv[1]);\n"
"    if (ret == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1037
#, no-wrap
msgid "    /* Read events from the event queue into a buffer */\n"
msgstr "    /* читаем события из очереди событий в буфер */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1043
#, no-wrap
msgid ""
"    len = read(fd, (void *) &events_buf, sizeof(events_buf));\n"
"    if (len == -1 && errno != EAGAIN) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    len = read(fd, (void *) &events_buf, sizeof(events_buf));\n"
"    if (len == -1 && errno != EAGAIN) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1045
#, no-wrap
msgid "    /* Process all events within the buffer */\n"
msgstr "    /* обрабатываем все события в буфере */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1051
#, no-wrap
msgid ""
"    for (metadata = (struct fanotify_event_metadata *) events_buf;\n"
"            FAN_EVENT_OK(metadata, len);\n"
"            metadata = FAN_EVENT_NEXT(metadata, len)) {\n"
"        fid = (struct fanotify_event_info_fid *) (metadata + 1);\n"
"        file_handle = (struct file_handle *) fid-E<gt>handle;\n"
msgstr ""
"    for (metadata = (struct fanotify_event_metadata *) events_buf;\n"
"            FAN_EVENT_OK(metadata, len);\n"
"            metadata = FAN_EVENT_NEXT(metadata, len)) {\n"
"        fid = (struct fanotify_event_info_fid *) (metadata + 1);\n"
"        file_handle = (struct file_handle *) fid-E<gt>handle;\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1053
#, no-wrap
msgid "        /* Ensure that the event info is of the correct type */\n"
msgstr "        /* проверим, что информация о событии правильного типа */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1058
#, no-wrap
msgid ""
"        if (fid-E<gt>hdr.info_type != FAN_EVENT_INFO_TYPE_FID) {\n"
"            fprintf(stderr, \"Received unexpected event info type.\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (fid-E<gt>hdr.info_type != FAN_EVENT_INFO_TYPE_FID) {\n"
"            fprintf(stderr, \"Получена информация о событии неожидаемого типа.\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1061
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == FAN_CREATE)\n"
"            printf(\"FAN_CREATE (file created):\");\n"
msgstr ""
"        if (metadata-E<gt>mask == FAN_CREATE)\n"
"            printf(\"FAN_CREATE (создан файл):\");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1064
#, no-wrap
msgid ""
"        if (metadata-E<gt>mask == FAN_CREATE | FAN_ONDIR)\n"
"            printf(\"FAN_CREATE | FAN_ONDIR (subdirectory created):\");\n"
msgstr ""
"        if (metadata-E<gt>mask == FAN_CREATE | FAN_ONDIR)\n"
"            printf(\"FAN_CREATE | FAN_ONDIR (создан подкаталог):\");\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1072
#, no-wrap
msgid ""
"        /* metadata-E<gt>fd is set to FAN_NOFD when FAN_REPORT_FID is enabled.\n"
"           To obtain a file descriptor for the file object corresponding to\n"
"           an event you can use the struct file_handle that\\(aqs provided\n"
"           within the fanotify_event_info_fid in conjunction with the\n"
"           open_by_handle_at(2) system call. A check for ESTALE is done\n"
"           to accommodate for the situation where the file handle for the\n"
"           object was deleted prior to this system call. */\n"
msgstr ""
"        /* metadata-E<gt>fd присваивается FAN_NOFD, если включён\n"
"           FAN_REPORT_FID. Чтобы получить файловый дескриптор для\n"
"           файлового объекта, соответствующего событию, можно\n"
"           использовать struct file_handle, которая находится\n"
"           внутри fanotify_event_info_fid и системный вызов\n"
"           open_by_handle_at(2). Проверка на ESTALE нужна, чтобы\n"
"           учесть ситуацию, когда файловый описатель для объекта\n"
"           был удалён до этого системного вызова. */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1084
#, no-wrap
msgid ""
"        event_fd = open_by_handle_at(AT_FDCWD, file_handle, O_RDONLY);\n"
"        if (ret == -1) {\n"
"            if (errno == ESTALE) {\n"
"                printf(\"File handle is no longer valid. \"\n"
"                        \"File has been deleted\\en\");\n"
"                continue;\n"
"            } else {\n"
"                perror(\"open_by_handle_at\");\n"
"                exit(EXIT_FAILURE);\n"
"\t    }\n"
"        }\n"
msgstr ""
"        event_fd = open_by_handle_at(AT_FDCWD, file_handle, O_RDONLY);\n"
"        if (ret == -1) {\n"
"            if (errno == ESTALE) {\n"
"                printf(\"Обработчик файл более недействителен. \"\n"
"                        \"Файл был удалён\\en\");\n"
"                continue;\n"
"            } else {\n"
"                perror(\"open_by_handle_at\");\n"
"                exit(EXIT_FAILURE);\n"
"\t    }\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1087
#, no-wrap
msgid ""
"        snprintf(procfd_path, sizeof(procfd_path), \"/proc/self/fd/%d\",\n"
"                event_fd);\n"
msgstr ""
"        snprintf(procfd_path, sizeof(procfd_path), \"/proc/self/fd/%d\",\n"
"                event_fd);\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1089
#, no-wrap
msgid "        /* Retrieve and print the path of the modified dentry */\n"
msgstr "        /* получаем и выводим путь изменённой dentry */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1095
#, no-wrap
msgid ""
"        path_len = readlink(procfd_path, path, sizeof(path) - 1);\n"
"        if (path_len == -1) {\n"
"            perror(\"readlink\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        path_len = readlink(procfd_path, path, sizeof(path) - 1);\n"
"        if (path_len == -1) {\n"
"            perror(\"readlink\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1098
#, no-wrap
msgid ""
"        path[path_len] = \\(aq\\e0\\(aq;\n"
"        printf(\"\\etDirectory \\(aq%s\\(aq has been modified.\\en\", path);\n"
msgstr ""
"        path[path_len] = \\(aq\\e0\\(aq;\n"
"        printf(\"\\etКаталог \\(aq%s\\(aq изменён.\\en\", path);\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1100
#, no-wrap
msgid "        /* Close associated file descriptor for this event */\n"
msgstr "        /* закрываем связанный файловый дескриптор этого события */\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1103
#, no-wrap
msgid ""
"        close(event_fd);\n"
"    }\n"
msgstr ""
"        close(event_fd);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1107
#, no-wrap
msgid ""
"    printf(\"All events processed successfully. Program exiting.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Все события успешно обработаны. Завершение программы.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/fanotify.7:1112
msgid "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"
msgstr "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"

#. type: TH
#: man-pages/man7/feature_test_macros.7:25
#, no-wrap
msgid "FEATURE_TEST_MACROS"
msgstr "FEATURE_TEST_MACROS"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:28
msgid "feature_test_macros - feature test macros"
msgstr "feature_test_macros - макросы тестирования свойств"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:31
msgid ""
"Feature test macros allow the programmer to control the definitions that are "
"exposed by system header files when a program is compiled."
msgstr ""
"Макросы тестирования свойств позволяют программисту контролировать какие "
"определения будут доступны из системных заголовочных файлов при компиляции "
"программы."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:48
msgid ""
"B<NOTE:> In order to be effective, a feature test macro I<must be defined "
"before including any header files>.  This can be done either in the "
"compilation command (I<cc -DMACRO=value>)  or by defining the macro within "
"the source code before including any headers.  The requirement that the "
"macro must be defined before including any header file exists because header "
"files may freely include one another.  Thus, for example, in the following "
"lines, defining the B<_GNU_SOURCE> macro may have no effect because the "
"header I<E<lt>abc.hE<gt>> itself includes I<E<lt>xyz.hE<gt>> (POSIX "
"explicitly allows this):"
msgstr ""
"B<ЗАМЕЧАНИЕ:> В целях эффективности, макрос тестирования свойств I<должен "
"быть определён до включения всех заголовочных файлов>. Это можно сделать или "
"в команде компиляции (I<cc -DМАКРОС=значение>) или определив макрос в "
"исходном коде до включения заголовочных файлов. Требование включения макроса "
"раньше остальных заголовочных файлов возникло из-за того, что заголовочные "
"файлы могут включаться друг в друга в любой последовательности. Например, в "
"следующих строках определение макроса B<_GNU_SOURCE> может не сработать, так "
"как заголовок I<E<lt>abc.hE<gt>> сам включает I<E<lt>xyz.hE<gt>> (в POSIX "
"это разрешается явным образом):"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:54
#, no-wrap
msgid ""
"#include E<lt>abc.hE<gt>\n"
"#define _GNU_SOURCE\n"
"#include E<lt>xys.hE<gt>\n"
msgstr ""
"#include E<lt>abc.hE<gt>\n"
"#define _GNU_SOURCE\n"
"#include E<lt>xys.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:61
msgid ""
"Some feature test macros are useful for creating portable applications, by "
"preventing nonstandard definitions from being exposed.  Other macros can be "
"used to expose nonstandard definitions that are not exposed by default."
msgstr ""
"Некоторые макросы тестирования свойств полезны для создания переносимых "
"приложений; они позволяют блокировать нестандартные определения. Другие "
"макросы можно использовать для разблокировки нестандартных определений, "
"которые по умолчанию недоступны."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:73
msgid ""
"The precise effects of each of the feature test macros described below can "
"be ascertained by inspecting the I<E<lt>features.hE<gt>> header file.  "
"B<Note>: applications do I<not> need to directly include I<E<lt>features."
"hE<gt>>; indeed, doing so is actively discouraged.  See NOTES."
msgstr ""
"Действие каждого макроса тестирования свойств, описанного далее, можно "
"узнать из содержимого заголовочного файла I<E<lt>features.hE<gt>>. "
"B<Замечание>: в приложениях I<не> нужно явно включать I<E<lt>features."
"hE<gt>> — это не приветствуется. Смотрите ЗАМЕЧАНИЯ."

#. type: SS
#: man-pages/man7/feature_test_macros.7:73
#, no-wrap
msgid "Specification of feature test macro requirements in manual pages"
msgstr "Обозначение макросов тестирования свойств в справочных страницах"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:79
msgid ""
"When a function requires that a feature test macro is defined, the manual "
"page SYNOPSIS typically includes a note of the following form (this example "
"from the B<acct>(2)  manual page):"
msgstr ""
"Когда функции требуется определение макроса тестирования свойств в ОБЗОРЕ "
"справочной страницы, обычно, содержится упоминание в следующем виде (этот "
"пример взят из справочной страницы B<acct>(2)):"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:82
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:84
msgid "B<int acct(const char *>I<filename>B<);>"
msgstr "B<int acct(const char *>I<filename>B<);>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:89
#, no-wrap
msgid ""
"Feature Test Macro Requirements for glibc (see\n"
"B<feature_test_macros>(7)):\n"
msgstr ""
"Требования макроса тестирования свойств для glibc\n"
"(см. B<feature_test_macros>(7)):\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:94
msgid ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:105
msgid ""
"The B<||> means that in order to obtain the declaration of B<acct>(2)  from "
"I<E<lt>unistd.hE<gt>>, I<either> of the following macro definitions must be "
"made before including any header files:"
msgstr ""
"Символ B<||> означает, что для получения объявления B<acct>(2) из "
"I<E<lt>unistd.hE<gt>> нужно определить I<любой> из следующих макросов до "
"включения любых заголовочных файлов:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:110
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#define _XOPEN_SOURCE        /* or any value E<lt> 500 */\n"
msgstr ""
"#define _BSD_SOURCE\n"
"#define _XOPEN_SOURCE        /* или любое значение E<lt> 500 */\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:115
msgid ""
"Alternatively, equivalent definitions can be included in the compilation "
"command:"
msgstr ""
"Или же эквивалентные определения могут быть включены следующей командой "
"компиляции:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:120
#, no-wrap
msgid ""
"cc -D_BSD_SOURCE\n"
"cc -D_XOPEN_SOURCE           # Or any value E<lt> 500\n"
msgstr ""
"cc -D_BSD_SOURCE\n"
"cc -D_XOPEN_SOURCE           # или любое значение E<lt> 500\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:128
msgid ""
"Note that, as described below, B<some feature test macros are defined by "
"default>, so that it may not always be necessary to explicitly specify the "
"feature test macro(s) shown in the SYNOPSIS."
msgstr ""
"Как описывается далее, B<некоторые макросы тестирования свойств определяются "
"по умолчанию>, поэтому макрос не всегда нужно указывать явно даже, если он "
"приведён в ОБЗОРЕ."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:132
msgid ""
"In a few cases, manual pages use a shorthand for expressing the feature test "
"macro requirements (this example from B<readahead>(2)):"
msgstr ""
"В некоторых случаях в справочных страницах используется сокращённая запись "
"требований макросов тестирования свойств (пример из B<readahead>(2)):"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:137
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:139
#, no-wrap
msgid "B<ssize_t readahead(int >I<fd>B<, off64_t *>I<offset>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t readahead(int >I<fd>B<, off64_t *>I<offset>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:145
msgid ""
"This format is employed in cases where only a single feature test macro can "
"be used to expose the function declaration, and that macro is not defined by "
"default."
msgstr ""
"Такой формат употребляется в случаях, когда достаточно одного макроса для "
"получения объявления функции, и этот макрос не определён по умолчанию."

#. type: SS
#: man-pages/man7/feature_test_macros.7:145
#, no-wrap
msgid "Feature test macros understood by glibc"
msgstr "Макросы тестирования свойств, распознаваемые glibc"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:150
msgid ""
"The paragraphs below explain how feature test macros are handled in Linux "
"glibc 2.I<x>, I<x> E<gt> 0."
msgstr ""
"В следующих параграфах описаны макросы тестирования свойств, управляющие "
"Linux glibc 2.I<x>, где I<x> E<gt> 0."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:152
msgid "First, though a summary of a few details for the impatient:"
msgstr "Если кратко:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:162
msgid ""
"The macros that you most likely need to use in modern source code are "
"B<_POSIX_C_SOURCE> (for definitions from various versions of POSIX.1), "
"B<_XOPEN_SOURCE> (for definitions from various versions of SUS), "
"B<_GNU_SOURCE> (for GNU and/or Linux specific stuff), and B<_DEFAULT_SOURCE> "
"(to get definitions that would normally be provided by default)."
msgstr ""
"Макросы, которые вам, вероятно, понадобится использовать в современном коде: "
"B<_POSIX_C_SOURCE> (определения из различных версий POSIX.1), "
"B<_XOPEN_SOURCE> (определения из различных версий SUS), B<_GNU_SOURCE> "
"(специальные возможности GNU и/или Linux) и B<_DEFAULT_SOURCE> (определения, "
"которые, обычно, включены по умолчанию)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:168
msgid ""
"Certain macros are defined with default values.  Thus, although one or more "
"macros may be indicated as being required in the SYNOPSIS of a man page, it "
"may not be necessary to define them explicitly.  Full details of the "
"defaults are given later in this man page."
msgstr ""
"Некоторые макросы определяют значения по умолчанию. То есть, хотя один или "
"более макросов могут быть указаны как необходимые в ОБЗОР справочной "
"страницы, возможно необязательно определять их явно. Полное описание "
"значений по умолчанию приведены далее в этой справочной странице."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:175
msgid ""
"Defining B<_XOPEN_SOURCE> with a value of 600 or greater produces the same "
"effects as defining B<_POSIX_C_SOURCE> with a value of 200112L or greater.  "
"Where one sees"
msgstr ""
"Определение B<_XOPEN_SOURCE> со значением 600 и более даёт тот же эффект что "
"и определение B<_POSIX_C_SOURCE> со значением 200112L и больше. Если "
"требуется"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:179
#, no-wrap
msgid "_POSIX_C_SOURCE E<gt>= 200112L\n"
msgstr "_POSIX_C_SOURCE E<gt>= 200112L\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:184
#: man-pages/man7/feature_test_macros.7:206
msgid ""
"in the feature test macro requirements in the SYNOPSIS of a man page, it is "
"implicit that the following has the same effect:"
msgstr ""
"в макросах тестирования свойств ОБЗОРА справочной страницы, то это неявным "
"образом тоже что и:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:188
#, no-wrap
msgid "_XOPEN_SOURCE E<gt>= 600\n"
msgstr "_XOPEN_SOURCE E<gt>= 600\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:197
msgid ""
"Defining B<_XOPEN_SOURCE> with a value of 700 or greater produces the same "
"effects as defining B<_POSIX_C_SOURCE> with a value of 200809L or greater.  "
"Where one sees"
msgstr ""
"Определение B<_XOPEN_SOURCE> со значением 700 и более даёт тот же эффект что "
"и определение B<_POSIX_C_SOURCE> со значением 200809L и больше. Если "
"требуется"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:201
#, no-wrap
msgid "_POSIX_C_SOURCE E<gt>= 200809L\n"
msgstr "_POSIX_C_SOURCE E<gt>= 200809L\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:210
#, no-wrap
msgid "_XOPEN_SOURCE E<gt>= 700\n"
msgstr "_XOPEN_SOURCE E<gt>= 700\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:217
msgid "Linux glibc understands the following feature test macros:"
msgstr "В Linux glibc распознаются следующие макросы тестирования свойств:"

#. type: TP
#: man-pages/man7/feature_test_macros.7:217
#, no-wrap
msgid "B<__STRICT_ANSI__>"
msgstr "B<__STRICT_ANSI__>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:227
msgid ""
"ISO Standard C.  This macro is implicitly defined by B<gcc>(1)  when invoked "
"with, for example, the I<-std=c99> or I<-ansi> flag."
msgstr ""
"Стандарт ISO C. Этот макрос неявно определяется компилятором B<gcc>(1), если "
"он вызывается с флагом I<-std=c99> или I<-ansi>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:227
#, no-wrap
msgid "B<_POSIX_C_SOURCE>"
msgstr "B<_POSIX_C_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:230
#: man-pages/man7/feature_test_macros.7:269
msgid ""
"Defining this macro causes header files to expose definitions as follows:"
msgstr ""
"При определении этого макроса из заголовочных файлов становится доступно "
"следующее:"

#. type: IP
#: man-pages/man7/feature_test_macros.7:231
#: man-pages/man7/feature_test_macros.7:234
#: man-pages/man7/feature_test_macros.7:237
#: man-pages/man7/feature_test_macros.7:241
#: man-pages/man7/feature_test_macros.7:244
#: man-pages/man7/feature_test_macros.7:252
#: man-pages/man7/feature_test_macros.7:270
#: man-pages/man7/feature_test_macros.7:273
#: man-pages/man7/feature_test_macros.7:276
#: man-pages/man7/feature_test_macros.7:280
#: man-pages/man7/feature_test_macros.7:299
#: man-pages/man7/feature_test_macros.7:302
#: man-pages/man7/feature_test_macros.7:709
#: man-pages/man7/feature_test_macros.7:714
#: man-pages/man7/feature_test_macros.7:720
#: man-pages/man7/feature_test_macros.7:725
#: man-pages/man7/feature_test_macros.7:731
#: man-pages/man7/feature_test_macros.7:736
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:234
msgid ""
"The value 1 exposes definitions conforming to POSIX.1-1990 and ISO C (1990)."
msgstr ""
"При значении 1 доступны определения, удовлетворяющие POSIX.1-1990 и ISO C "
"(1990)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:237
msgid ""
"The value 2 or greater additionally exposes definitions for POSIX.2-1992."
msgstr ""
"При значении 2 и более дополнительно доступны определения, удовлетворяющие "
"POSIX.2-1992."

#.  199506L functionality is available only since glibc 2.1
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:241
msgid ""
"The value 199309L or greater additionally exposes definitions for POSIX.1b "
"(real-time extensions)."
msgstr ""
"При значении 199309L и более дополнительно доступны определения, "
"удовлетворяющие POSIX.1b (расширения для реального времени)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:244
msgid ""
"The value 199506L or greater additionally exposes definitions for POSIX.1c "
"(threads)."
msgstr ""
"При значении 199506L и более дополнительно доступны определения, "
"удовлетворяющие POSIX.1c (нити)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:252
msgid ""
"(Since glibc 2.3.3)  The value 200112L or greater additionally exposes "
"definitions corresponding to the POSIX.1-2001 base specification (excluding "
"the XSI extension).  This value also causes C95 (since glibc 2.12) and C99 "
"(since glibc 2.10) features to be exposed (in other words, the equivalent of "
"defining B<_ISOC99_SOURCE>)."
msgstr ""
"(начиная с glibc 2.3.3) При значении 200112L и более доступны определения, "
"удовлетворяющие базовой спецификации POSIX.1-2001 (за исключением расширения "
"XSI) а также свойства C95 (начиная с glibc 2.12) и C99 (начиная с glibc "
"2.10). Другими словами это эквивалент определения B<_ISOC99_SOURCE>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:256
msgid ""
"(Since glibc 2.10)  The value 200809L or greater additionally exposes "
"definitions corresponding to the POSIX.1-2008 base specification (excluding "
"the XSI extension)."
msgstr ""
"(начиная с glibc 2.10) При значении 200809L и более доступны определения, "
"удовлетворяющие базовой спецификации POSIX.1-2008 (за исключением расширения "
"XSI)."

#. type: TP
#: man-pages/man7/feature_test_macros.7:257
#, no-wrap
msgid "B<_POSIX_SOURCE>"
msgstr "B<_POSIX_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:262
msgid ""
"Defining this obsolete macro with any value is equivalent to defining "
"B<_POSIX_C_SOURCE> with the value 1."
msgstr ""
"Определение этого устаревшего макроса с любым значением эквивалентно "
"определению B<_POSIX_C_SOURCE> со значением 1."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:266
msgid ""
"Since this macro is obsolete, its usage is generally not documented when "
"discussing feature test macro requirements in the man pages."
msgstr ""
"Так как этот макрос устарел, его использование, обычно, не описывается при "
"обсуждении требований макросов тестирования свойств в справочной странице."

#. type: TP
#: man-pages/man7/feature_test_macros.7:266
#, no-wrap
msgid "B<_XOPEN_SOURCE>"
msgstr "B<_XOPEN_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:273
msgid ""
"Defining with any value exposes definitions conforming to POSIX.1, POSIX.2, "
"and XPG4."
msgstr ""
"Определение с любым значением делает доступным определения, удовлетворяющие "
"POSIX.1, POSIX.2 и XPG4."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:276
msgid ""
"The value 500 or greater additionally exposes definitions for SUSv2 (UNIX "
"98)."
msgstr ""
"При значении 500 и более дополнительно доступны определения, удовлетворяющие "
"SUSv2 (UNIX 98)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:280
msgid ""
"(Since glibc 2.2) The value 600 or greater additionally exposes definitions "
"for SUSv3 (UNIX 03; i.e., the POSIX.1-2001 base specification plus the XSI "
"extension) and C99 definitions."
msgstr ""
"(начиная с glibc 2.2) При значении 600L и более дополнительно доступны "
"определения, удовлетворяющие SUSv3 (UNIX 03; т. е., базовой спецификации "
"POSIX.1-2001 плюс расширение XSI), и определения C99."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:284
msgid ""
"(Since glibc 2.10) The value 700 or greater additionally exposes definitions "
"for SUSv4 (i.e., the POSIX.1-2008 base specification plus the XSI extension)."
msgstr ""
"(начиная с glibc 2.10) При значении 700 и более дополнительно доступны "
"определения, удовлетворяющие SUSv4 (т. е., базовой спецификации POSIX.1-2008 "
"плюс расширение XSI)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:298
msgid ""
"If B<__STRICT_ANSI__> is not defined, or B<_XOPEN_SOURCE> is defined with a "
"value greater than or equal to 500 I<and> neither B<_POSIX_SOURCE> nor "
"B<_POSIX_C_SOURCE> is explicitly defined, then the following macros are "
"implicitly defined:"
msgstr ""
"If B<__STRICT_ANSI__> не определено или определено B<_XOPEN_SOURCE> со "
"значением больше или равно 500 I<и> явно не определено B<_POSIX_SOURCE> или "
"B<_POSIX_C_SOURCE>, то неявно определяются следующие макросы:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:302
msgid "B<_POSIX_SOURCE> is defined with the value 1."
msgstr "B<_POSIX_SOURCE> определяется со значением 1."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:306
msgid ""
"B<_POSIX_C_SOURCE> is defined, according to the value of B<_XOPEN_SOURCE>:"
msgstr "B<_POSIX_C_SOURCE> определяется согласно значению B<_XOPEN_SOURCE>:"

#. type: TP
#: man-pages/man7/feature_test_macros.7:307
#, no-wrap
msgid "B<_XOPEN_SOURCE> E<lt> 500"
msgstr "B<_XOPEN_SOURCE> E<lt> 500"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:311
msgid "B<_POSIX_C_SOURCE> is defined with the value 2."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 2."

#. type: TP
#: man-pages/man7/feature_test_macros.7:311
#, no-wrap
msgid "500 E<lt>= B<_XOPEN_SOURCE> E<lt> 600"
msgstr "500 E<lt>= B<_XOPEN_SOURCE> E<lt> 600"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:315
msgid "B<_POSIX_C_SOURCE> is defined with the value 199506L."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 199506L."

#. type: TP
#: man-pages/man7/feature_test_macros.7:315
#, no-wrap
msgid "600 E<lt>= B<_XOPEN_SOURCE> E<lt> 700"
msgstr "600 E<lt>= B<_XOPEN_SOURCE> E<lt> 700"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:319
msgid "B<_POSIX_C_SOURCE> is defined with the value 200112L."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 200112L."

#. type: TP
#: man-pages/man7/feature_test_macros.7:319
#, no-wrap
msgid "700 E<lt>= B<_XOPEN_SOURCE> (since glibc 2.10)"
msgstr "700 E<lt>= B<_XOPEN_SOURCE> (начиная с glibc 2.10)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:323
msgid "B<_POSIX_C_SOURCE> is defined with the value 200809L."
msgstr "B<_POSIX_C_SOURCE> определяется со значением 200809L."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:330
msgid ""
"In addition, defining B<_XOPEN_SOURCE> with a value of 500 or greater "
"produces the same effects as defining B<_XOPEN_SOURCE_EXTENDED>."
msgstr ""
"Также, определение B<_XOPEN_SOURCE> со значением 500 и более даёт тот же "
"эффект что и определение B<_XOPEN_SOURCE_EXTENDED>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:330
#, no-wrap
msgid "B<_XOPEN_SOURCE_EXTENDED>"
msgstr "B<_XOPEN_SOURCE_EXTENDED>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:344
msgid ""
"If this macro is defined, I<and> B<_XOPEN_SOURCE> is defined, then expose "
"definitions corresponding to the XPG4v2 (SUSv1) UNIX extensions (UNIX 95).  "
"Defining B<_XOPEN_SOURCE> with a value of 500 or more also produces the same "
"effect as defining B<_XOPEN_SOURCE_EXTENDED>.  Use of "
"B<_XOPEN_SOURCE_EXTENDED> in new source code should be avoided."
msgstr ""
"Если этот макрос определён I<вместе> с B<_XOPEN_SOURCE>, то доступны "
"определения, соответствующие расширениям UNIX (UNIX 95) XPG4v2 (SUSv1). "
"Определение B<_XOPEN_SOURCE> со значением 500 и более также вызывает эффект, "
"подобный B<_XOPEN_SOURCE_EXTENDED>. Использование B<_XOPEN_SOURCE_EXTENDED> "
"в новом коде следует избегать."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:351
msgid ""
"Since defining B<_XOPEN_SOURCE> with a value of 500 or more has the same "
"effect as defining B<_XOPEN_SOURCE_EXTENDED>, the latter (obsolete) feature "
"test macro is generally not described in the SYNOPSIS in man pages."
msgstr ""
"Так как определение B<_XOPEN_SOURCE> со значением 500 и более даёт тот же "
"эффект, что и B<_XOPEN_SOURCE_EXTENDED>, последний (устаревший) макрос "
"тестирования свойств, обычно, не описывается в ОБЗОРЕ справочной страницы."

#. type: TP
#: man-pages/man7/feature_test_macros.7:351
#, no-wrap
msgid "B<_ISOC99_SOURCE> (since glibc 2.1.3)"
msgstr "B<_ISOC99_SOURCE> (начиная с glibc 2.1.3)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:354
msgid "Exposes declarations consistent with the ISO C99 standard."
msgstr ""
"Делает доступными объявления, удовлетворяющие требованиям стандарта ISO C99."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:360
msgid ""
"Earlier glibc 2.1.x versions recognized an equivalent macro named "
"B<_ISOC9X_SOURCE> (because the C99 standard had not then been finalized).  "
"Although the use of this macro is obsolete, glibc continues to recognize it "
"for backward compatibility."
msgstr ""
"Ранние версии glibc 2.1.x распознавали макрос-эквивалент B<_ISOC9X_SOURCE> "
"(так как стандарт C99 ещё не был утверждён). Хотя использование последнего "
"макроса не рекомендуется, glibc пока поддерживает его для обратной "
"совместимости."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:365
msgid ""
"Defining B<_ISOC99_SOURCE> also exposes ISO C (1990) Amendment 1 (\"C95\") "
"definitions.  (The primary change in C95 was support for international "
"character sets.)"
msgstr ""
"Делает доступными определения стандарта ISO C (1990) Amendment 1 («C95»). "
"Основным изменением в C95 была поддержка международных наборов символов."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:369
msgid ""
"Invoking the C compiler with the option I<-std=c99> produces the same "
"effects as defining this macro."
msgstr ""
"Вызов компилятора C с параметром I<-std=c99> работает также как если был бы "
"указан этот макрос."

#. type: TP
#: man-pages/man7/feature_test_macros.7:369
#, no-wrap
msgid "B<_ISOC11_SOURCE> (since glibc 2.16)"
msgstr "B<_ISOC11_SOURCE> (начиная с glibc 2.16)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:374
msgid ""
"Exposes declarations consistent with the ISO C11 standard.  Defining this "
"macro also enables C99 and C95 features (like B<_ISOC99_SOURCE>)."
msgstr ""
"Делает доступными объявления, удовлетворяющие требованиям стандарта ISO C11. "
"Определение этого макроса также включает свойства C99 и C95 (подобно "
"B<_ISOC99_SOURCE>)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:378
msgid ""
"Invoking the C compiler with the option I<-std=c11> produces the same "
"effects as defining this macro."
msgstr ""
"Вызов компилятора C с параметром I<-std=c11> работает также как если был бы "
"указан этот макрос."

#. type: TP
#: man-pages/man7/feature_test_macros.7:378
#, no-wrap
msgid "B<_LARGEFILE64_SOURCE>"
msgstr "B<_LARGEFILE64_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:399
msgid ""
"Expose definitions for the alternative API specified by the LFS (Large File "
"Summit) as a \"transitional extension\" to the Single UNIX Specification.  "
"(See E<.UR http:\\:/\\:/opengroup.org\\:/platform\\:/lfs.html> E<.UE .)> The "
"alternative API consists of a set of new objects (i.e., functions and types) "
"whose names are suffixed with \"64\" (e.g., I<off64_t> versus I<off_t>, "
"B<lseek64>()  versus B<lseek>(), etc.).  New programs should not employ this "
"macro; instead I<_FILE_OFFSET_BITS=64> should be employed."
msgstr ""
"Делает доступными объявления альтернативного программного интерфейса, "
"определяемого в LFS (Large File Summit) как «переходного расширение» на "
"Single UNIX Specification (смотрите E<.UR http:\\:/\\:/opengroup.org\\:/"
"platform\\:/lfs.html> E<.UE)>. Альтернативный программный интерфейс состоит "
"из набора новых объектов (т. е., функций и типов), чьи имена оканчиваются на "
"«»64 (например, I<off64_t> и I<off_t>, B<lseek64>() и B<lseek>(), и т. д.). "
"В новых программах не нужно указывать этот макрос; вместо него указывайте "
"I<_FILE_OFFSET_BITS=64>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:399
#, no-wrap
msgid "B<_LARGEFILE_SOURCE>"
msgstr "B<_LARGEFILE_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:421
msgid ""
"This macro was historically used to expose certain functions (specifically "
"B<fseeko>(3)  and B<ftello>(3))  that address limitations of earlier APIs "
"(B<fseek>(3)  and B<ftell>(3))  that use I<long int> for file offsets.  This "
"macro is implicitly defined if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 500.  New programs should not employ this macro; "
"defining B<_XOPEN_SOURCE> as just described or defining B<_FILE_OFFSET_BITS> "
"with the value 64 is the preferred mechanism to achieve the same result."
msgstr ""
"Данный макрос исторически используется для предоставления определённых "
"функций (в частности, B<fseeko>(3) и B<ftello>(3)), которые обходят адресные "
"ограничения раннего программного интерфейса (B<fseek>(3) и B<ftell>(3)), в "
"котором для файловых смещений использовался I<long int>. Данный макрос "
"неявно определяется, если определён B<_XOPEN_SOURCE> со значением больше или "
"равным 500. В новых программах не нужно определять данный макрос; "
"определение B<_XOPEN_SOURCE> или B<_FILE_OFFSET_BITS> со значением 64 "
"является более предпочтительным механизмом для достижения того же результата."

#. type: TP
#: man-pages/man7/feature_test_macros.7:421
#, no-wrap
msgid "B<_FILE_OFFSET_BITS>"
msgstr "B<_FILE_OFFSET_BITS>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:431
msgid ""
"Defining this macro with the value 64 automatically converts references to "
"32-bit functions and data types related to file I/O and filesystem "
"operations into references to their 64-bit counterparts.  This is useful for "
"performing I/O on large files (E<gt> 2 Gigabytes)  on 32-bit systems.  "
"(Defining this macro permits correctly written programs to use large files "
"with only a recompilation being required.)"
msgstr ""
"При определении данного макроса со значением 64 ссылки на 32-битные функции "
"и типы данных, относящиеся к файловому вводу-выводу и операциям с файловой "
"системой, автоматически преобразуются в их 64-битные прототипы. Это полезно "
"для выполнения ввода-вывода в огромные файлы (E<gt> 2 гигабайт) на 32-битных "
"системах (определение данного макроса позволяет корректно написанным "
"программам использовать огромные файлы, для чего требуется только "
"перекомпиляция)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:434
msgid ""
"64-bit systems naturally permit file sizes greater than 2 Gigabytes, and on "
"those systems this macro has no effect."
msgstr ""
"64-битные системы сразу позволяют работать с файлами размером больше 2 "
"гигабайт, и на этих системах данный макрос ничего не делает."

#. type: TP
#: man-pages/man7/feature_test_macros.7:434
#, no-wrap
msgid "B<_BSD_SOURCE> (deprecated since glibc 2.20)"
msgstr "B<_BSD_SOURCE> (устарел начиная с glibc 2.20)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:438
msgid ""
"Defining this macro with any value causes header files to expose BSD-derived "
"definitions."
msgstr ""
"Определение данного макроса с любым значением приводит к доступности из "
"заголовочных файлов определений BSD."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:453
msgid ""
"In glibc versions up to and including 2.18, defining this macro also causes "
"BSD definitions to be preferred in some situations where standards conflict, "
"unless one or more of B<_SVID_SOURCE>, B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, "
"B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, or B<_GNU_SOURCE> is defined, "
"in which case BSD definitions are disfavored.  Since glibc 2.19, "
"B<_BSD_SOURCE> no longer causes BSD definitions to be preferred in case of "
"conflicts."
msgstr ""
"В glibc до версии 2.18 включительно при определении данного макроса также "
"отдаётся приоритет определениям BSD в ситуациях, когда имеется конфликт со "
"стандартами. Если определён один из макросов B<_SVID_SOURCE>, "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_XOPEN_SOURCE_EXTENDED> или B<_GNU_SOURCE>, то определения BSD не "
"используются. Начиная с glibc 2.19 при наличии макроса B<_BSD_SOURCE> "
"определения BSD в случае конфликта приоритета не имеют."

#.  commit c941736c92fa3a319221f65f6755659b2a5e0a20
#.  commit 498afc54dfee41d33ba519f496e96480badace8e
#.  commit acd7f096d79c181866d56d4aaf3b043e741f1e2c
#.  commit ade40b10ff5fa59a318cf55b9d8414b758e8df78
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:476
msgid ""
"Since glibc 2.20, this macro is deprecated.  It now has the same effect as "
"defining B<_DEFAULT_SOURCE>, but generates a compile-time warning (unless "
"B<_DEFAULT_SOURCE> is also defined).  Use B<_DEFAULT_SOURCE> instead.  To "
"allow code that requires B<_BSD_SOURCE> in glibc 2.19 and earlier and "
"B<_DEFAULT_SOURCE> in glibc 2.20 and later to compile without warnings, "
"define I<both> B<_BSD_SOURCE> and B<_DEFAULT_SOURCE>."
msgstr ""
"Начиная с glibc 2.20 этот макрос считается устаревшим. Теперь он действует "
"также как определение B<_DEFAULT_SOURCE>, но при компиляции генерируется "
"предупреждение (если также не определён B<_DEFAULT_SOURCE>). Используйте "
"B<_DEFAULT_SOURCE> вместо него. Чтобы для кода, которому требуется "
"B<_BSD_SOURCE> в glibc 2.19 и старее и B<_DEFAULT_SOURCE> в glibc 2.20 и "
"новее, не выдавалось предупреждение при компиляции определите B<_BSD_SOURCE> "
"и B<_DEFAULT_SOURCE> I<одновременно>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:476
#, no-wrap
msgid "B<_SVID_SOURCE> (deprecated since glibc 2.20)"
msgstr "B<_SVID_SOURCE> (устарел начиная с glibc 2.20)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:482
msgid ""
"Defining this macro with any value causes header files to expose System V-"
"derived definitions.  (SVID == System V Interface Definition; see "
"B<standards>(7).)"
msgstr ""
"При определении этого макроса с любым значением из заголовочных файлов "
"становятся доступны определения System V (SVID == System V Interface "
"Definition; смотрите B<standards>(7))."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:485
msgid ""
"Since glibc 2.20, this macro is deprecated in the same fashion as "
"B<_BSD_SOURCE>."
msgstr "Начиная с glibc 2.20 этот макрос устарел также как B<_BSD_SOURCE>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:485
#, no-wrap
msgid "B<_DEFAULT_SOURCE> (since glibc 2.19)"
msgstr "B<_DEFAULT_SOURCE> (начиная с glibc 2.19)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:497
msgid ""
"This macro can be defined to ensure that the \"default\" definitions are "
"provided even when the defaults would otherwise be disabled, as happens when "
"individual macros are explicitly defined, or the compiler is invoked in one "
"of its \"standard\" modes (e.g., I<cc\\ -std=c99>).  Defining "
"B<_DEFAULT_SOURCE> without defining other individual macros or invoking the "
"compiler in one of its \"standard\" modes has no effect."
msgstr ""
"Данный макрос можно определить, чтобы точно знать, что будут доступны "
"определения «по умолчанию» даже, если умолчательные макросы отключены, что "
"случается, когда отдельные макросы определяются явно, или компилятор "
"вызывается в одном из своих «стандартных» режимов (например, I<cc\\ -"
"std=c99>). Определение B<_DEFAULT_SOURCE> без определения отдельных макросов "
"или вызов компилятора в одном из его «стандартных» режимов не работают."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:502
msgid ""
"The \"default\" definitions comprise those required by POSIX.1-2008 and ISO "
"C99, as well as various definitions originally derived from BSD and System "
"V.  On glibc 2.19 and earlier, these defaults were approximately equivalent "
"to explicitly defining the following:"
msgstr ""
"Определения «по умолчанию» охватывают все, которые требуются POSIX.1-2008 и "
"ISO C99, а также различные определения появившиеся из BSD и System V. В "
"glibc 2.19 и старее эти значения по умолчанию приблизительно эквивалентны "
"явному определению следующего:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:504
#, no-wrap
msgid "    cc -D_BSD_SOURCE -D_SVID_SOURCE -D_POSIX_C_SOURCE=200809\n"
msgstr "    cc -D_BSD_SOURCE -D_SVID_SOURCE -D_POSIX_C_SOURCE=200809\n"

#. type: TP
#: man-pages/man7/feature_test_macros.7:504
#, no-wrap
msgid "B<_ATFILE_SOURCE> (since glibc 2.4)"
msgstr "B<_ATFILE_SOURCE> (начиная с glibc 2.4)"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:513
msgid ""
"Defining this macro with any value causes header files to expose "
"declarations of a range of functions with the suffix \"at\"; see "
"B<openat>(2).  Since glibc 2.10, this macro is also implicitly defined if "
"B<_POSIX_C_SOURCE> is defined with a value greater than or equal to 200809L."
msgstr ""
"При определении этого макроса с любым значением из заголовочных файлов "
"становятся доступны объявления набора функций с суффиксом «at»; смотрите "
"B<openat>(2). Начиная с glibc 2.10 данный макрос также неявно определяется, "
"если определён B<_POSIX_C_SOURCE> со значением 200809L или больше."

#. type: TP
#: man-pages/man7/feature_test_macros.7:513
#, no-wrap
msgid "B<_GNU_SOURCE>"
msgstr "B<_GNU_SOURCE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:532
msgid ""
"Defining this macro (with any value) implicitly defines B<_ATFILE_SOURCE>, "
"B<_LARGEFILE64_SOURCE>, B<_ISOC99_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE> with the value 200809L (200112L in "
"glibc versions before 2.10; 199506L in glibc versions before 2.5; 199309L in "
"glibc versions before 2.1)  and B<_XOPEN_SOURCE> with the value 700 (600 in "
"glibc versions before 2.10; 500 in glibc versions before 2.2).  In addition, "
"various GNU-specific extensions are also exposed."
msgstr ""
"При определении этого макроса (с любым значением) неявно определяются "
"B<_ATFILE_SOURCE>, B<_LARGEFILE64_SOURCE>, B<_ISOC99_SOURCE>, "
"B<_XOPEN_SOURCE_EXTENDED>, B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE> со значением "
"200809L (200112L в версиях glibc до 2.10; 199506L в версиях glibc до 2.5; "
"199309L в версиях glibc до 2.1) и B<_XOPEN_SOURCE> со значением 700 (600 в "
"версиях glibc до 2.10; 500 в версиях glibc до 2.2). Также становятся "
"доступны различные расширения GNU."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:543
msgid ""
"Since glibc 2.19, defining B<_GNU_SOURCE> also has the effect of implicitly "
"defining B<_DEFAULT_SOURCE>.  In glibc versions before 2.20, defining "
"B<_GNU_SOURCE> also had the effect of implicitly defining B<_BSD_SOURCE> and "
"B<_SVID_SOURCE>."
msgstr ""
"Начиная с glibc 2.19 определение B<_GNU_SOURCE> также неявно определяет "
"B<_DEFAULT_SOURCE>. В glibc до 2.20 версии определение B<_GNU_SOURCE> также "
"неявно определяет B<_BSD_SOURCE> и B<_SVID_SOURCE>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:543
#, no-wrap
msgid "B<_REENTRANT>"
msgstr "B<_REENTRANT>"

#.  Zack Weinberg
#.      There did once exist C libraries where it was necessary. The ones
#.      I remember were proprietary Unix vendor libcs from the mid-1990s
#.      You would get completely unlocked stdio without _REENTRANT.
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:555
msgid ""
"Historically, on various C libraries it was necessary to define this macro "
"in all multithreaded code.  (Some C libraries may still require this.)  In "
"glibc, this macro also exposed definitions of certain reentrant functions."
msgstr ""
"В прошлом, этот макрос требовалось определять для различных библиотек C, "
"чтобы работал многонитевой код (некоторым библиотекам C это всё ещё "
"требуется). В glibc этот макрос также включает определения определённых "
"реентерабельных функций."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:563
msgid ""
"However, glibc has been thread-safe by default for many years; since glibc "
"2.3, the only effect of defining B<_REENTRANT> has been to enable one or two "
"of the same declarations that are also enabled by defining "
"B<_POSIX_C_SOURCE> with a value of 199606L or greater."
msgstr ""
"Однако glibc уже давно по умолчанию безопасна для нитей; начиная glibc 2.3 "
"единственным эффектом определения B<_REENTRANT> является включение одного "
"или двух определений, которые также включаются определением "
"B<_POSIX_C_SOURCE> со значением 199606L или больше."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:582
msgid ""
"B<_REENTRANT> is now obsolete.  In glibc 2.25 and later, defining "
"B<_REENTRANT> is equivalent to defining B<_POSIX_C_SOURCE> with the value "
"199606L.  If a higher POSIX conformance level is selected by any other means "
"(such as B<_POSIX_C_SOURCE> itself, B<_XOPEN_SOURCE>, B<_DEFAULT_SOURCE>, or "
"B<_GNU_SOURCE>), then defining B<_REENTRANT> has no effect."
msgstr ""
"В настоящий момент B<_REENTRANT> устарел. В glibc 2.25 и новее определение "
"B<_REENTRANT> эквивалентно определению B<_POSIX_C_SOURCE> со значением "
"199606L. Если выбирается более высокий уровень соответствия POSIX (например, "
"самим B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_DEFAULT_SOURCE> или "
"B<_GNU_SOURCE>), то определение не действует B<_REENTRANT>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:585
msgid ""
"This macro is automatically defined if one compiles with I<cc\\ -pthread>."
msgstr ""
"Данный макрос автоматически определяется, если выполняется компиляция I<cc\\ "
"-pthread>."

#. type: TP
#: man-pages/man7/feature_test_macros.7:585
#, no-wrap
msgid "B<_THREAD_SAFE>"
msgstr "B<_THREAD_SAFE>"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:590
msgid ""
"Synonym for the (deprecated)  B<_REENTRANT>, provided for compatibility with "
"some other implementations."
msgstr ""
"Синоним (устарел) B<_REENTRANT>, предоставляется для совместимости с "
"некоторыми другими реализациями."

#. type: TP
#: man-pages/man7/feature_test_macros.7:590
#, no-wrap
msgid "B<_FORTIFY_SOURCE> (since glibc 2.3.4)"
msgstr "B<_FORTIFY_SOURCE> (начиная с glibc 2.3.4)"

#.  For more detail, see:
#.  http://gcc.gnu.org/ml/gcc-patches/2004-09/msg02055.html
#.  [PATCH] Object size checking to prevent (some) buffer overflows
#.  * From: Jakub Jelinek <jakub at redhat dot com>
#.  * To: gcc-patches at gcc dot gnu dot org
#.  * Date: Tue, 21 Sep 2004 04:16:40 -0400
#.  Look for __USE_FORTIFY_LEVEL in the header files
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:623
msgid ""
"Defining this macro causes some lightweight checks to be performed to detect "
"some buffer overflow errors when employing various string and memory "
"manipulation functions (for example, B<memcpy>(3), B<memset>(3), "
"B<stpcpy>(3), B<strcpy>(3), B<strncpy>(3), B<strcat>(3), B<strncat>(3), "
"B<sprintf>(3), B<snprintf>(3), B<vsprintf>(3), B<vsnprintf>(3), B<gets>(3), "
"and wide character variants thereof).  For some functions, argument "
"consistency is checked; for example, a check is made that B<open>(2)  has "
"been supplied with a I<mode> argument when the specified flags include "
"B<O_CREAT>.  Not all problems are detected, just some common cases."
msgstr ""
"Определение этого макроса вызывает выполнение нескольких простых проверок "
"для обнаружения ошибок переполнения буфера, которые возникают в различных "
"функциях работы со строками и памятью (например, B<memcpy>(3), B<memset>(3), "
"B<stpcpy>(3), B<strcpy>(3), B<strncpy>(3), B<strcat>(3), B<strncat>(3), "
"B<sprintf>(3), B<snprintf>(3), B<vsprintf>(3), B<vsnprintf>(3), B<gets>(3) и "
"их варианты для работы с широкими символами). Для некоторых функций "
"проверяется целостность аргумента; например, проверяется, что B<open>(2) "
"передали в аргументе I<mode>, если указан флаг B<O_CREAT>. Обнаруживаются не "
"все проблемы, только самые распространённые."

#.  For example, given the following code
#.         int d;
#.         char buf[1000], buf[1000];
#.         strcpy(fmt, "Hello world
#. %n");
#.         snprintf(buf, sizeof(buf), fmt, &d);
#.  Compiling with "gcc -D_FORTIFY_SOURCE=2 -O1" and then running will
#.  cause the following diagnostic at run time at the snprintf() call
#.         *** %n in writable segment detected ***
#.         Aborted (core dumped)
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:646
msgid ""
"If B<_FORTIFY_SOURCE> is set to 1, with compiler optimization level 1 (I<gcc"
"\\ -O1>)  and above, checks that shouldn't change the behavior of conforming "
"programs are performed.  With B<_FORTIFY_SOURCE> set to 2, some more "
"checking is added, but some conforming programs might fail."
msgstr ""
"Если значение B<_FORTIFY_SOURCE> равно 1 и уровень оптимизации компиляции "
"равен 1 (I<gcc\\ -O1>) и больше, то выполняются проверки,  которые не "
"изменяют поведение выверяемых программ. Если значение B<_FORTIFY_SOURCE> "
"равно 2, то добавляются дополнительные проверки, но некоторые выверяемые "
"программы могут завершаться с ошибкой."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:652
msgid ""
"Some of the checks can be performed at compile time (via macros logic "
"implemented in header files), and result in compiler warnings; other checks "
"take place at run time, and result in a run-time error if the check fails."
msgstr ""
"Некоторые проверки выполняются во время компиляции (через макросы, "
"реализованных в заголовочных файлах) и вызывают предупреждение компилятора; "
"другие проверки выполняются во время выполнения и приводят к ошибкам времени "
"выполнения."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:656
msgid ""
"Use of this macro requires compiler support, available with B<gcc>(1)  since "
"version 4.0."
msgstr ""
"Для работы этого макроса требуется поддержка в компиляторе, доступная в "
"B<gcc>(1) начиная с версии 4.0."

#. type: SS
#: man-pages/man7/feature_test_macros.7:656
#, no-wrap
msgid "Default definitions, implicit definitions, and combining definitions"
msgstr "Определения по умолчанию, неявные определения и объединяющие определения"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:672
msgid ""
"If no feature test macros are explicitly defined, then the following feature "
"test macros are defined by default: B<_BSD_SOURCE> (in glibc 2.19 and "
"earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), B<_DEFAULT_SOURCE> "
"(since glibc 2.19), B<_POSIX_SOURCE>, and B<_POSIX_C_SOURCE>=200809L "
"(200112L in glibc versions before 2.10; 199506L in glibc versions before "
"2.4; 199309L in glibc versions before 2.1)."
msgstr ""
"Если макросы тестирования свойств не указаны явно, то по умолчанию действуют "
"следующие макросы тестирования свойств: B<_BSD_SOURCE> (в glibc 2.19 и "
"старее), B<_SVID_SOURCE> (в glibc 2.19 и старее), B<_DEFAULT_SOURCE> "
"(начиная с glibc 2.19), B<_POSIX_SOURCE> и B<_POSIX_C_SOURCE>=200809L "
"(200112L в версиях glibc до 2.10; 199506L в версиях glibc до 2.4; 199309L в "
"версиях glibc до 2.1)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:691
msgid ""
"If any of B<__STRICT_ANSI__>, B<_ISOC99_SOURCE>, B<_POSIX_SOURCE>, "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, "
"B<_BSD_SOURCE> (in glibc 2.19 and earlier), or B<_SVID_SOURCE> (in glibc "
"2.19 and earlier)  is explicitly defined, then B<_BSD_SOURCE>, "
"B<_SVID_SOURCE>, and B<_DEFAULT_SOURCE> are not defined by default."
msgstr ""
"Если любой из макросов B<__STRICT_ANSI__>, B<_ISOC99_SOURCE>, "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_XOPEN_SOURCE_EXTENDED>, B<_BSD_SOURCE> (в glibc 2.19 и старее) или "
"B<_SVID_SOURCE> (в glibc 2.19 и старее) указан явно, то по умолчанию не "
"определяются макросы B<_BSD_SOURCE>, B<_SVID_SOURCE> и B<_DEFAULT_SOURCE>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:702
msgid ""
"If B<_POSIX_SOURCE> and B<_POSIX_C_SOURCE> are not explicitly defined, and "
"either B<__STRICT_ANSI__> is not defined or B<_XOPEN_SOURCE> is defined with "
"a value of 500 or more, then"
msgstr ""
"Если макросы B<_POSIX_SOURCE> и B<_POSIX_C_SOURCE> не указаны явно и не "
"определён B<__STRICT_ANSI__> или B<_XOPEN_SOURCE> определён со значением 500 "
"или более, то"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:705
msgid "B<_POSIX_SOURCE> is defined with the value 1; and"
msgstr "B<_POSIX_SOURCE> определяется со значением 1; и"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:708
msgid "B<_POSIX_C_SOURCE> is defined with one of the following values:"
msgstr "B<_POSIX_C_SOURCE> определяется с одним из следующих значений:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:714
msgid "2, if B<_XOPEN_SOURCE> is defined with a value less than 500;"
msgstr "2, если B<_XOPEN_SOURCE> определён со значением меньше 500;"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:720
msgid ""
"199506L, if B<_XOPEN_SOURCE> is defined with a value greater than or equal "
"to 500 and less than 600; or"
msgstr ""
"199506L, если B<_XOPEN_SOURCE> определён со значением 500 или более, но "
"меньше 600; или"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:725
msgid ""
"(since glibc 2.4) 200112L, if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 600 and less than 700."
msgstr ""
"(начиная с glibc 2.4) 200112L, если B<_XOPEN_SOURCE> определён со значением "
"600 или более, но меньше 700."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:731
msgid ""
"(Since glibc 2.10)  200809L, if B<_XOPEN_SOURCE> is defined with a value "
"greater than or equal to 700."
msgstr ""
"(начиная с glibc 2.10) 200809L, если B<_XOPEN_SOURCE> определён со значением "
"700 или более."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:736
msgid ""
"Older versions of glibc do not know about the values 200112L and 200809L for "
"B<_POSIX_C_SOURCE>, and the setting of this macro will depend on the glibc "
"version."
msgstr ""
"Старые версии glibc не знают о значениях 200112L и 200809L у  "
"B<_POSIX_C_SOURCE>, и значение этого макроса зависит от версии glibc."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:745
msgid ""
"If B<_XOPEN_SOURCE> is undefined, then the setting of B<_POSIX_C_SOURCE> "
"depends on the glibc version: 199506L, in glibc versions before 2.4; "
"200112L, in glibc 2.4 to 2.9; and 200809L, since glibc 2.10."
msgstr ""
"Если макрос B<_XOPEN_SOURCE> не определён, то значение B<_POSIX_C_SOURCE> "
"зависит от версии glibc: 199506L в версиях glibc до 2.4; 200112L в glibc от "
"2.4 до 2.9 и 200809L в glibc 2.10 и новее."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:748
msgid "Multiple macros can be defined; the results are additive."
msgstr "Можно определять несколько макросов; результат складывается."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:754
msgid ""
"POSIX.1 specifies B<_POSIX_C_SOURCE>, B<_POSIX_SOURCE>, and B<_XOPEN_SOURCE>."
msgstr ""
"В POSIX.1 определены B<_POSIX_C_SOURCE>, B<_POSIX_SOURCE> и B<_XOPEN_SOURCE>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:760
msgid ""
"B<_XOPEN_SOURCE_EXTENDED> was specified by XPG4v2 (aka SUSv1), but is not "
"present in SUSv2 and later.  B<_FILE_OFFSET_BITS> is not specified by any "
"standard, but is employed on some other implementations."
msgstr ""
"Макрос B<_XOPEN_SOURCE_EXTENDED> был определён в XPG4v2 (также называемом "
"SUSv1), но отсутствует в SUSv2 и более новых версиях. Макрос "
"B<_FILE_OFFSET_BITS> отсутствует в стандартах, но используется в некоторых "
"других реализациях."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:771
msgid ""
"B<_BSD_SOURCE>, B<_SVID_SOURCE>, B<_DEFAULT_SOURCE>, B<_ATFILE_SOURCE>, "
"B<_GNU_SOURCE>, B<_FORTIFY_SOURCE>, B<_REENTRANT>, and B<_THREAD_SAFE> are "
"specific to Linux (glibc)."
msgstr ""
"Макросы B<_BSD_SOURCE>, B<_SVID_SOURCE>, B<_DEFAULT_SOURCE>, "
"B<_ATFILE_SOURCE>, B<_GNU_SOURCE>, B<_FORTIFY_SOURCE>, B<_REENTRANT> и "
"B<_THREAD_SAFE> есть только в Linux (glibc)."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:778
msgid ""
"I<E<lt>features.hE<gt>> is a Linux/glibc-specific header file.  Other "
"systems have an analogous file, but typically with a different name.  This "
"header file is automatically included by other header files as required: it "
"is not necessary to explicitly include it in order to employ feature test "
"macros."
msgstr ""
"Файл I<E<lt>features.hE<gt>> есть только в Linux/glibc. В других системах "
"есть аналогичный файл, но, обычно, с другим именем. Данный заголовочный "
"файл, если нужен, автоматически включается из других заголовочных файлов: "
"его необязательно явно указывать для использования макросов тестирования "
"свойств."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:790
msgid ""
"According to which of the above feature test macros are defined, "
"I<E<lt>features.hE<gt>> internally defines various other macros that are "
"checked by other glibc header files.  These macros have names prefixed by "
"two underscores (e.g., B<__USE_MISC>).  Programs should I<never> define "
"these macros directly: instead, the appropriate feature test macro(s) from "
"the list above should be employed."
msgstr ""
"Согласно указанным макросам тестирования свойств раньше файла "
"I<E<lt>features.hE<gt>>, внутри него определяются другие различные макросы, "
"которые проверяются в других заголовочных файлах glibc. Эти макросы имеют "
"имена, начинающиеся с двух подчёркиваний (например, B<__USE_MISC>). "
"Программы I<никогда> не должны определять эти макросы самостоятельно: вместо "
"этого нужно задействовать соответствующий макрос тестирования свойств из "
"перечисленных ранее."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:796
msgid ""
"The program below can be used to explore how the various feature test macros "
"are set depending on the glibc version and what feature test macros are "
"explicitly set.  The following shell session, on a system with glibc 2.10, "
"shows some examples of what we would see:"
msgstr ""
"Представленную далее программу можно использовать для изучения какие "
"значения присваиваются макросам тестирования свойств в зависимости от версии "
"glibc и какие макросы тестирования свойств устанавливаются явно. В следующем "
"сеансе оболочки на системе с glibc 2.10 показаны несколько примеров того, "
"что мы увидели:"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:823
#, no-wrap
msgid ""
"$ B<cc ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"$ B<cc -D_XOPEN_SOURCE=500 ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 199506L\n"
"_XOPEN_SOURCE defined: 500\n"
"$ B<cc -D_GNU_SOURCE ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_ISOC99_SOURCE defined\n"
"_XOPEN_SOURCE defined: 700\n"
"_XOPEN_SOURCE_EXTENDED defined\n"
"_LARGEFILE64_SOURCE defined\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"_GNU_SOURCE defined\n"
msgstr ""
"$ B<cc ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"$ B<cc -D_XOPEN_SOURCE=500 ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 199506L\n"
"_XOPEN_SOURCE defined: 500\n"
"$ B<cc -D_GNU_SOURCE ftm.c>\n"
"$ B<./a.out>\n"
"_POSIX_SOURCE defined\n"
"_POSIX_C_SOURCE defined: 200809L\n"
"_ISOC99_SOURCE defined\n"
"_XOPEN_SOURCE defined: 700\n"
"_XOPEN_SOURCE_EXTENDED defined\n"
"_LARGEFILE64_SOURCE defined\n"
"_BSD_SOURCE defined\n"
"_SVID_SOURCE defined\n"
"_ATFILE_SOURCE defined\n"
"_GNU_SOURCE defined\n"

#. type: SS
#: man-pages/man7/feature_test_macros.7:825
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:829
#, no-wrap
msgid "/* ftm.c */\n"
msgstr "/* ftm.c */\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:833
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:840
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#ifdef _POSIX_SOURCE\n"
"    printf(\"_POSIX_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#ifdef _POSIX_SOURCE\n"
"    printf(\"_POSIX_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:844
#, no-wrap
msgid ""
"#ifdef _POSIX_C_SOURCE\n"
"    printf(\"_POSIX_C_SOURCE defined: %ldL\\en\", (long) _POSIX_C_SOURCE);\n"
"#endif\n"
msgstr ""
"#ifdef _POSIX_C_SOURCE\n"
"    printf(\"_POSIX_C_SOURCE defined: %ldL\\en\", (long) _POSIX_C_SOURCE);\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:848
#, no-wrap
msgid ""
"#ifdef _ISOC99_SOURCE\n"
"    printf(\"_ISOC99_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _ISOC99_SOURCE\n"
"    printf(\"_ISOC99_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:852
#, no-wrap
msgid ""
"#ifdef _ISOC11_SOURCE\n"
"    printf(\"_ISOC11_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _ISOC11_SOURCE\n"
"    printf(\"_ISOC11_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:856
#, no-wrap
msgid ""
"#ifdef _XOPEN_SOURCE\n"
"    printf(\"_XOPEN_SOURCE defined: %d\\en\", _XOPEN_SOURCE);\n"
"#endif\n"
msgstr ""
"#ifdef _XOPEN_SOURCE\n"
"    printf(\"_XOPEN_SOURCE defined: %d\\en\", _XOPEN_SOURCE);\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:860
#, no-wrap
msgid ""
"#ifdef _XOPEN_SOURCE_EXTENDED\n"
"    printf(\"_XOPEN_SOURCE_EXTENDED defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _XOPEN_SOURCE_EXTENDED\n"
"    printf(\"_XOPEN_SOURCE_EXTENDED defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:864
#, no-wrap
msgid ""
"#ifdef _LARGEFILE64_SOURCE\n"
"    printf(\"_LARGEFILE64_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _LARGEFILE64_SOURCE\n"
"    printf(\"_LARGEFILE64_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:868
#, no-wrap
msgid ""
"#ifdef _FILE_OFFSET_BITS\n"
"    printf(\"_FILE_OFFSET_BITS defined: %d\\en\", _FILE_OFFSET_BITS);\n"
"#endif\n"
msgstr ""
"#ifdef _FILE_OFFSET_BITS\n"
"    printf(\"_FILE_OFFSET_BITS defined: %d\\en\", _FILE_OFFSET_BITS);\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:872
#, no-wrap
msgid ""
"#ifdef _BSD_SOURCE\n"
"    printf(\"_BSD_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _BSD_SOURCE\n"
"    printf(\"_BSD_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:876
#, no-wrap
msgid ""
"#ifdef _SVID_SOURCE\n"
"    printf(\"_SVID_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _SVID_SOURCE\n"
"    printf(\"_SVID_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:880
#, no-wrap
msgid ""
"#ifdef _DEFAULT_SOURCE\n"
"    printf(\"_DEFAULT_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _DEFAULT_SOURCE\n"
"    printf(\"_DEFAULT_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:884
#, no-wrap
msgid ""
"#ifdef _ATFILE_SOURCE\n"
"    printf(\"_ATFILE_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _ATFILE_SOURCE\n"
"    printf(\"_ATFILE_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:888
#, no-wrap
msgid ""
"#ifdef _GNU_SOURCE\n"
"    printf(\"_GNU_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _GNU_SOURCE\n"
"    printf(\"_GNU_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:892
#, no-wrap
msgid ""
"#ifdef _REENTRANT\n"
"    printf(\"_REENTRANT defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _REENTRANT\n"
"    printf(\"_REENTRANT defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:896
#, no-wrap
msgid ""
"#ifdef _THREAD_SAFE\n"
"    printf(\"_THREAD_SAFE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _THREAD_SAFE\n"
"    printf(\"_THREAD_SAFE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:900
#, no-wrap
msgid ""
"#ifdef _FORTIFY_SOURCE\n"
"    printf(\"_FORTIFY_SOURCE defined\\en\");\n"
"#endif\n"
msgstr ""
"#ifdef _FORTIFY_SOURCE\n"
"    printf(\"_FORTIFY_SOURCE defined\\en\");\n"
"#endif\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:903
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:907
msgid "B<libc>(7), B<standards>(7)"
msgstr "B<libc>(7), B<standards>(7)"

#.  But beware: the info libc document is out of date (Jul 07, mtk)
#. type: Plain text
#: man-pages/man7/feature_test_macros.7:911
msgid "The section \"Feature Test Macros\" under I<info libc>."
msgstr "Раздел «Макросы тестирования свойств» в I<info libc>."

#. type: Plain text
#: man-pages/man7/feature_test_macros.7:912
msgid "I</usr/include/features.h>"
msgstr "I</usr/include/features.h>"

#. type: TH
#: man-pages/man7/fifo.7:12
#, no-wrap
msgid "FIFO"
msgstr "FIFO"

#. type: TH
#: man-pages/man7/fifo.7:12
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: man-pages/man7/fifo.7:15
msgid "fifo - first-in first-out special file, named pipe"
msgstr ""
"fifo - специальный файл, организующий очередь (first-in first-out), "
"именованный канал"

#. type: Plain text
#: man-pages/man7/fifo.7:27
msgid ""
"A FIFO special file (a named pipe) is similar to a pipe, except that it is "
"accessed as part of the filesystem.  It can be opened by multiple processes "
"for reading or writing.  When processes are exchanging data via the FIFO, "
"the kernel passes all data internally without writing it to the filesystem.  "
"Thus, the FIFO special file has no contents on the filesystem; the "
"filesystem entry merely serves as a reference point so that processes can "
"access the pipe using a name in the filesystem."
msgstr ""
"Специальный файл FIFO (именованный канал) подобен каналу, за исключением "
"того, что доступен как часть файловой системы. Его можно открывать из "
"нескольких процессов на чтении или запись. Когда процессы обмениваются "
"данными через FIFO, ядро передаёт все данные без их записи в файловую "
"систему. То есть, специальный файл FIFO не хранит содержимое в файловой "
"системе; запись в файловой системе служит просто местом, посредством "
"которого процессы могут получить доступ к каналу, используя имя в файловой "
"системе."

#. type: Plain text
#: man-pages/man7/fifo.7:34
msgid ""
"The kernel maintains exactly one pipe object for each FIFO special file that "
"is opened by at least one process.  The FIFO must be opened on both ends "
"(reading and writing)  before data can be passed.  Normally, opening the "
"FIFO blocks until the other end is opened also."
msgstr ""
"Ядро поддерживает один объект канала для каждого специального файла FIFO, "
"который открыт хотя бы одним процессом. Для того, чтобы пропускать данные, "
"FIFO должен быть открыт как для чтения, так и для записи. Обычно, при "
"открытии FIFO он блокируется до тех пор, пока вышеописанные условия не будут "
"выполнены."

#. type: Plain text
#: man-pages/man7/fifo.7:43
msgid ""
"A process can open a FIFO in nonblocking mode.  In this case, opening for "
"read-only succeeds even if no one has opened on the write side yet and "
"opening for write-only fails with B<ENXIO> (no such device or address) "
"unless the other end has already been opened."
msgstr ""
"Процесс может открыть FIFO в неблокирующем режиме. В этом случае открытие "
"только для чтения выполняется без ошибки, даже если другая сторона ещё не "
"открыла его для записи, и открытие только на запись завершается ошибкой "
"B<ENXIO> (нет такого устройства или адреса), если другая сторона к этому "
"моменту не была открыта на чтение."

#. type: Plain text
#: man-pages/man7/fifo.7:53
msgid ""
"Under Linux, opening a FIFO for read and write will succeed both in blocking "
"and nonblocking mode.  POSIX leaves this behavior undefined.  This can be "
"used to open a FIFO for writing while there are no readers available.  A "
"process that uses both ends of the connection in order to communicate with "
"itself should be very careful to avoid deadlocks."
msgstr ""
"В Linux открытие FIFO для чтения и записи может быть осуществлено в "
"блокирующем и неблокирующем режимах. Так как POSIX не описывает эти "
"положения, это может быть использовано для открытия FIFO для чтения в "
"отсутствие считывающих процессов. Процесс, использующий этот файл для чтения "
"и записи (для связи с самим собой), не должен допустить возникновения "
"блокировок (deadlocks)."

#. type: Plain text
#: man-pages/man7/fifo.7:56
msgid "For details of the semantics of I/O on FIFOs, see B<pipe>(7)."
msgstr ""
"Подробную информацию о семантике ввода-вывода FIFO смотрите в B<pipe>(7)."

#. type: Plain text
#: man-pages/man7/fifo.7:61
msgid ""
"When a process tries to write to a FIFO that is not opened for read on the "
"other side, the process is sent a B<SIGPIPE> signal."
msgstr ""
"Если процесс попытается записать данные в FIFO, который не открыт для "
"чтения, то ему посылается сигнал B<SIGPIPE>."

#. type: Plain text
#: man-pages/man7/fifo.7:67
msgid ""
"FIFO special files can be created by B<mkfifo>(3), and are indicated by I<ls"
"\\ -l> with the file type \\(aqp\\(aq."
msgstr ""
"Специальные файлы FIFO могут быть созданы с помощью B<mkfifo>(3); при выводе "
"I<ls\\ -l> они отображаются с типом файла «p»."

#. type: Plain text
#: man-pages/man7/fifo.7:75
msgid ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), "
"B<socketpair>(2), B<mkfifo>(3), B<pipe>(7)"
msgstr ""
"B<mkfifo>(1), B<open>(2), B<pipe>(2), B<sigaction>(2), B<signal>(2), "
"B<socketpair>(2), B<mkfifo>(3), B<pipe>(7)"

#. type: TH
#: man-pages/man7/futex.7:11
#, no-wrap
msgid "FUTEX"
msgstr "FUTEX"

#. type: TH
#: man-pages/man7/futex.7:11
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man7/futex.7:14
msgid "futex - fast user-space locking"
msgstr "futex - быстрая блокировка в пользовательском пространстве"

#. type: Plain text
#: man-pages/man7/futex.7:17
#, no-wrap
msgid "B<#include E<lt>linux/futex.hE<gt>>\n"
msgstr "B<#include E<lt>linux/futex.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/futex.7:26
msgid ""
"The Linux kernel provides futexes (\"Fast user-space mutexes\")  as a "
"building block for fast user-space locking and semaphores.  Futexes are very "
"basic and lend themselves well for building higher-level locking "
"abstractions such as mutexes, condition variables, read-write locks, "
"barriers, and semaphores."
msgstr ""
"Ядро Linux предоставляет фьютексы (futexes, «быстрые мьютексы (mutexes, "
"взаимоисключающие блокировки) в пользовательском пространстве») в качестве "
"строительного блока для быстрой блокировки в пользовательском пространстве и "
"семафоров. Фьютексы очень просты и полезны для создания высокоуровневых "
"абстракций блокировок, таких как мьютексы, условных переменных, блокировок "
"чтения-записи, барьеров и семафоров."

#. type: Plain text
#: man-pages/man7/futex.7:31
msgid ""
"Most programmers will in fact not be using futexes directly but will instead "
"rely on system libraries built on them, such as the Native POSIX Thread "
"Library (NPTL) (see B<pthreads>(7))."
msgstr ""
"Большинство программистов, фактически, не используют фьютексы напрямую, а "
"полагаются на системные библиотеки, которые на них построены, такие как "
"Native POSIX Thread Library (NPTL) (смотрите B<pthreads>(7))."

#. type: Plain text
#: man-pages/man7/futex.7:38
msgid ""
"A futex is identified by a piece of memory which can be shared between "
"processes or threads.  In these different processes, the futex need not have "
"identical addresses.  In its bare form, a futex has semaphore semantics; it "
"is a counter that can be incremented and decremented atomically; processes "
"can wait for the value to become positive."
msgstr ""
"Фьютекс отождествляется с участком памяти, который может быть общим для "
"процессов или нитей. В этих процессах фьютекс может быть доступен по разным "
"адресам. В своей основе фьютекс имеет семантику семафора; это счётчик, "
"который можно увеличивать и уменьшать атомарно; процессы могут ждать пока "
"значение не станет положительным."

#. type: Plain text
#: man-pages/man7/futex.7:43
msgid ""
"Futex operation occurs entirely in user space for the noncontended case.  "
"The kernel is involved only to arbitrate the contended case.  As any sane "
"design will strive for noncontention, futexes are also optimized for this "
"situation."
msgstr ""
"Работа с фьютексом выполняется полностью в пользовательском пространстве при "
"отсутствии конфликта (noncontended case). Ядро привлекается только для "
"разрешения конфликтов. Так как все проектные решения стремятся к отсутствию "
"конфликтов, фьютексы также оптимизированы под эту ситуацию."

#. type: Plain text
#: man-pages/man7/futex.7:51
msgid ""
"In its bare form, a futex is an aligned integer which is touched only by "
"atomic assembler instructions.  This integer is four bytes long on all "
"platforms.  Processes can share this integer using B<mmap>(2), via shared "
"memory segments, or because they share memory space, in which case the "
"application is commonly called multithreaded."
msgstr ""
"В своей основе фьютекс — это целое число, которое изменяется только "
"атомарными инструкциями ассемблера. Это целое число размером 4 байта на всех "
"платформах. Процессы могут совместно использовать это число посредством "
"B<mmap>(2), сегментов общей памяти или общего пространства памяти (share "
"memory space, в этом случае приложение, обычно, называют многонитевым)."

#. type: SS
#: man-pages/man7/futex.7:51
#, no-wrap
msgid "Semantics"
msgstr "Поведение"

#. type: Plain text
#: man-pages/man7/futex.7:57
msgid ""
"Any futex operation starts in user space, but it may be necessary to "
"communicate with the kernel using the B<futex>(2)  system call."
msgstr ""
"Любое действие с фьютексом начинается в пользовательском пространстве, но "
"может потребовать обращения к ядру через системный вызов B<futex>(2)."

#. type: Plain text
#: man-pages/man7/futex.7:63
msgid ""
"To \"up\" a futex, execute the proper assembler instructions that will cause "
"the host CPU to atomically increment the integer.  Afterward, check if it "
"has in fact changed from 0 to 1, in which case there were no waiters and the "
"operation is done.  This is the noncontended case which is fast and should "
"be common."
msgstr ""
"Для «установки» фьютекса выполняются соответствующие ассемблерные "
"инструкции, которые заставляют ЦП машины атомарно увеличить целое число. "
"Далее проверяется, было ли действительно изменено значение с 0 на 1, то есть "
"не было ожидающих и операция выполнена. Это бесконфликтный вариант, "
"выполняется быстро и должен возникать чаще всего."

#. type: Plain text
#: man-pages/man7/futex.7:71
msgid ""
"In the contended case, the atomic increment changed the counter from -1 (or "
"some other negative number).  If this is detected, there are waiters.  User "
"space should now set the counter to 1 and instruct the kernel to wake up any "
"waiters using the B<FUTEX_WAKE> operation."
msgstr ""
"При возникновении конфликта, атомарное увеличение изменяет счётчик с -1 (или "
"другого отрицательного числа). Это означает, что есть ожидающие. В "
"пользовательском пространстве теперь нужно присвоить счётчику 1 и дать "
"команду ядру пробудить всех ожидающих с помощью операции B<FUTEX_WAKE>."

#. type: Plain text
#: man-pages/man7/futex.7:80
msgid ""
"Waiting on a futex, to \"down\" it, is the reverse operation.  Atomically "
"decrement the counter and check if it changed to 0, in which case the "
"operation is done and the futex was uncontended.  In all other "
"circumstances, the process should set the counter to -1 and request that the "
"kernel wait for another process to up the futex.  This is done using the "
"B<FUTEX_WAIT> operation."
msgstr ""
"Ожидание фьютекса, его «сброс», является обратной операцией. Происходит "
"атомарное уменьшение счётчика и проверка того, стал ли он равен 0, то есть "
"операция выполнена и фьютекс был неконфликтным. Во всех других случаях, "
"процесс должен присвоить счётчику -1 и запросить ядро об ожидании другого "
"процесса, устанавливающего фьютекс. Это выполняется с помощью операции "
"B<FUTEX_WAIT>."

#. type: Plain text
#: man-pages/man7/futex.7:92
msgid ""
"The B<futex>(2)  system call can optionally be passed a timeout specifying "
"how long the kernel should wait for the futex to be upped.  In this case, "
"semantics are more complex and the programmer is referred to B<futex>(2)  "
"for more details.  The same holds for asynchronous futex waiting."
msgstr ""
"В системном вызове B<futex>(2) можно указать время ожидания, то есть как "
"долго ядро должно ждать установку фьютекса, В этом случае семантика более "
"сложна и программисту нужно обратиться к B<futex>(2). Это тоже самое что и "
"ожидания асинхронного фьютекса."

#. type: Plain text
#: man-pages/man7/futex.7:97
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from those described above.  Current semantics are available from Linux "
"2.5.40 onward."
msgstr ""
"Впервые поддержка фьютексов появилась в Linux 2.5.7, но с другой семантикой. "
"Текущая семантика используется в Linux с версии 2.5.40."

#. type: Plain text
#: man-pages/man7/futex.7:104
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end users.  Implementors are expected to be assembly literate and to "
"have read the sources of the futex user-space library referenced below."
msgstr ""
"Ещё раз повторим: в чистом виде фьютексы не являются лёгкой в использовании "
"абстракцией для конечных пользователей. Использующие их программисты должны "
"иметь хороший запас знаний об ассемблере и уметь читать исходный код "
"библиотеки фьютексов для пользовательского пространства, указанной далее."

#.  .SH AUTHORS
#.  .PP
#.  Futexes were designed and worked on by Hubertus Franke
#.  (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat) and
#.  Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: man-pages/man7/futex.7:115
msgid ""
"This man page illustrates the most common use of the B<futex>(2)  "
"primitives; it is by no means the only one."
msgstr ""
"В этой справочной странице показано самое распространённое использование "
"примитивов B<futex>(2), которое ни в коем случае не единственное."

#. type: Plain text
#: man-pages/man7/futex.7:122
msgid ""
"B<clone>(2), B<futex>(2), B<get_robust_list>(2), B<set_robust_list>(2), "
"B<set_tid_address>(2), B<pthreads>(7)"
msgstr ""
"B<clone>(2), B<futex>(2), B<get_robust_list>(2), B<set_robust_list>(2), "
"B<set_tid_address>(2), B<pthreads>(7)"

#. type: Plain text
#: man-pages/man7/futex.7:127
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), futex example library, futex-*.tar.bz2 "
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<."
"UE .>"
msgstr ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (доклад с "
"Ottawa Linux Symposium 2002), пример в библиотеке futex, futex-*.tar.bz2 E<."
"UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<."
"UE .>"

#. type: TH
#: man-pages/man2/fork.2:39
#, no-wrap
msgid "FORK"
msgstr "FORK"

#. type: Plain text
#: man-pages/man2/fork.2:42
msgid "fork - create a child process"
msgstr "fork - создаёт дочерний процесс"

#. type: Plain text
#: man-pages/man2/fork.2:44
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/fork.2:48
msgid "B<pid_t fork(void);>"
msgstr "B<pid_t fork(void);>"

#. type: Plain text
#: man-pages/man2/fork.2:57
msgid ""
"B<fork>()  creates a new process by duplicating the calling process.  The "
"new process is referred to as the I<child> process.  The calling process is "
"referred to as the I<parent> process."
msgstr ""
"Вызов B<fork>() создаёт новый процесс посредством копирования вызывающего "
"процесса. Новый процесс считается I<дочерним> процессом. Вызывающий процесс "
"считается I<родительским> процессом."

#. type: Plain text
#: man-pages/man2/fork.2:67
msgid ""
"The child process and the parent process run in separate memory spaces.  At "
"the time of B<fork>()  both memory spaces have the same content.  Memory "
"writes, file mappings (B<mmap>(2)), and unmappings (B<munmap>(2))  performed "
"by one of the processes do not affect the other."
msgstr ""
"Дочерний и родительский процессы находятся в отдельных пространствах памяти. "
"Сразу после B<fork>() эти пространства имеют одинаковое содержимое. Запись в "
"память, отображение файлов (B<mmap>(2)) и снятие отображения (B<munmap>(2)), "
"выполненных в одном процессе, ничего не изменяет в другом."

#. type: Plain text
#: man-pages/man2/fork.2:70
msgid ""
"The child process is an exact duplicate of the parent process except for the "
"following points:"
msgstr ""
"Дочерний процесс является точной копией родительского процесса за "
"исключением следующих моментов:"

#. type: Plain text
#: man-pages/man2/fork.2:75
msgid ""
"The child has its own unique process ID, and this PID does not match the ID "
"of any existing process group (B<setpgid>(2))  or session."
msgstr ""
"Потомок имеет свой уникальный идентификатор процесса, и этот PID "
"(идентификатор процесса) не совпадает ни с одним существующим "
"идентификатором группы процессов (B<setpgid>(2)) или сеансов."

#. type: Plain text
#: man-pages/man2/fork.2:77
msgid "The child's parent process ID is the same as the parent's process ID."
msgstr ""
"Идентификатор родительского процесса у потомка равен идентификатору "
"родительского процесса."

#. type: Plain text
#: man-pages/man2/fork.2:81
msgid ""
"The child does not inherit its parent's memory locks (B<mlock>(2), "
"B<mlockall>(2))."
msgstr ""
"Потомок не наследует блокировки памяти родителя (B<mlock>(2), "
"B<mlockall>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:87
msgid ""
"Process resource utilizations (B<getrusage>(2))  and CPU time counters "
"(B<times>(2))  are reset to zero in the child."
msgstr ""
"Счётчики использования ресурсов (B<getrusage>(2)) и времени ЦП у потомка "
"сброшены в 0."

#. type: Plain text
#: man-pages/man2/fork.2:90
msgid ""
"The child's set of pending signals is initially empty (B<sigpending>(2))."
msgstr "Набор ожидающих сигналов потомка изначально пуст (B<sigpending>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:93
msgid ""
"The child does not inherit semaphore adjustments from its parent "
"(B<semop>(2))."
msgstr "Потомок не наследует значения семафоров родителя (B<semop>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:101
msgid ""
"The child does not inherit process-associated record locks from its parent "
"(B<fcntl>(2)).  (On the other hand, it does inherit B<fcntl>(2)  open file "
"description locks and B<flock>(2)  locks from its parent.)"
msgstr ""
"Потомок не наследует связанные с процессом блокировки родителя (B<fcntl>(2)) "
"(с другой стороны, он наследует блокировки файловых описаний B<fcntl>(2) и "
"блокировки B<flock>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:106
msgid ""
"The child does not inherit timers from its parent (B<setitimer>(2), "
"B<alarm>(2), B<timer_create>(2))."
msgstr ""
"Потомок не наследует таймеры родителя (B<setitimer>(2), B<alarm>(2), "
"B<timer_create>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:113
msgid ""
"The child does not inherit outstanding asynchronous I/O operations from its "
"parent (B<aio_read>(3), B<aio_write>(3)), nor does it inherit any "
"asynchronous I/O contexts from its parent (see B<io_setup>(2))."
msgstr ""
"Потомок не наследует ожидающие выполнения операции асинхронного ввода-вывода "
"(B<aio_read>(3), B<aio_write>(3)) и контексты асинхронного ввода-вывода "
"родителя (см. B<io_setup>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:118
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The parent and child also differ with respect to the following Linux-"
"specific process attributes:"
msgstr ""
"Все перечисленные атрибуты указаны в POSIX.1. Родитель и потомок также "
"отличаются по следующим атрибутам процесса, которые есть только в Linux:"

#. type: Plain text
#: man-pages/man2/fork.2:125
msgid ""
"The child does not inherit directory change notifications (dnotify)  from "
"its parent (see the description of B<F_NOTIFY> in B<fcntl>(2))."
msgstr ""
"Потомок не наследует уведомления об изменении каталога (dnotify) родителя "
"(смотрите описание B<F_NOTIFY> в B<fcntl>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:131
msgid ""
"The B<prctl>(2)  B<PR_SET_PDEATHSIG> setting is reset so that the child does "
"not receive a signal when its parent terminates."
msgstr ""
"Настройка B<PR_SET_PDEATHSIG> у B<prctl>(2) сбрасывается, и поэтому потомок "
"не принимает сигнал о завершении работы родителя."

#. type: Plain text
#: man-pages/man2/fork.2:138
msgid ""
"The default timer slack value is set to the parent's current timer slack "
"value.  See the description of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""
"Резервное значение по умолчанию устанавливается равным родительскому "
"текущему резервному значению таймера. Смотрите описание B<PR_SET_TIMERSLACK> "
"в B<prctl>(2)."

#. type: Plain text
#: man-pages/man2/fork.2:144
msgid ""
"Memory mappings that have been marked with the B<madvise>(2)  "
"B<MADV_DONTFORK> flag are not inherited across a B<fork>()."
msgstr ""
"Отображение памяти, помеченное с помощью флага B<MADV_DONTFORK> через "
"B<madvise>(2), при B<fork>() не наследуется."

#. type: Plain text
#: man-pages/man2/fork.2:153
msgid ""
"Memory in address ranges that have been marked with the B<madvise>(2)  "
"B<MADV_WIPEONFORK> flag is zeroed in the child after a B<fork>().  (The "
"B<MADV_WIPEONFORK> setting remains in place for those address ranges in the "
"child.)"
msgstr ""
"Память в диапазонах адресов, которые были помечены с помощью B<madvise>(2) "
"флагом B<MADV_WIPEONFORK>, обнуляются в потомке после B<fork>() (флаг "
"B<MADV_WIPEONFORK> остаётся в потомке у этих диапазонов адресов)."

#. type: Plain text
#: man-pages/man2/fork.2:158
msgid ""
"The termination signal of the child is always B<SIGCHLD> (see B<clone>(2))."
msgstr "Сигнал завершения работы потомка всегда B<SIGCHLD> (см. B<clone>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:164
msgid ""
"The port access permission bits set by B<ioperm>(2)  are not inherited by "
"the child; the child must turn on any bits that it requires using "
"B<ioperm>(2)."
msgstr ""
"Биты прав доступа к порту, установленные с помощью B<ioperm>(2), не "
"наследуются потомком; потомок должен установить все нужные ему биты с "
"помощью B<ioperm>(2)."

#. type: Plain text
#: man-pages/man2/fork.2:166
msgid "Note the following further points:"
msgstr "Также стоит учитывать следующее:"

#. type: Plain text
#: man-pages/man2/fork.2:175
msgid ""
"The child process is created with a single thread\\(emthe one that called "
"B<fork>().  The entire virtual address space of the parent is replicated in "
"the child, including the states of mutexes, condition variables, and other "
"pthreads objects; the use of B<pthread_atfork>(3)  may be helpful for "
"dealing with problems that this can cause."
msgstr ""
"Процесс потомка создаётся с одиночной нитью — той, которая вызвала "
"B<fork>(). Всё виртуальное адресное пространство родителя копируется в "
"потомок, включая состояние мьютексов, условных переменных и других объектов "
"pthreads; в случае проблем с этим может помочь B<pthread_atfork>(3)."

#. type: Plain text
#: man-pages/man2/fork.2:183
msgid ""
"After a B<fork>()  in a multithreaded program, the child can safely call "
"only async-signal-safe functions (see B<signal-safety>(7))  until such time "
"as it calls B<execve>(2)."
msgstr ""
"В многонитевой программе после B<fork>() потомок может безопасно вызывать "
"только безопасные-асинхронные-сигнальные функции (смотрите B<signal-"
"safety>(7)) до тех пор, пока не вызовет B<execve>(2)."

#. type: Plain text
#: man-pages/man2/fork.2:197
msgid ""
"The child inherits copies of the parent's set of open file descriptors.  "
"Each file descriptor in the child refers to the same open file description "
"(see B<open>(2))  as the corresponding file descriptor in the parent.  This "
"means that the two file descriptors share open file status flags, file "
"offset, and signal-driven I/O attributes (see the description of B<F_SETOWN> "
"and B<F_SETSIG> in B<fcntl>(2))."
msgstr ""
"Потомок наследует копии набора открытых файловых дескрипторов родителя. "
"Каждый файловый дескриптор в потомке ссылается на то же описание файла что и "
"родитель (смотрите B<open>(2)). Это означает, что два файловых дескриптора "
"совместно используют флаги состояния открытого файла, смещение файла и "
"атрибуты ввода-вывода, управляемые сигналами (смотрите описание B<F_SETOWN> "
"и B<F_SETSIG> в B<fcntl>(2))."

#. type: Plain text
#: man-pages/man2/fork.2:206
msgid ""
"The child inherits copies of the parent's set of open message queue "
"descriptors (see B<mq_overview>(7)).  Each file descriptor in the child "
"refers to the same open message queue description as the corresponding file "
"descriptor in the parent.  This means that the two file descriptors share "
"the same flags (I<mq_flags>)."
msgstr ""
"Потомок наследует копии набора файловых дескрипторов открытых очередей "
"сообщений родителя (смотрите B<mq_overview>(7)). Каждый файловый дескриптор "
"в потомке ссылается на то же описание открытой очереди сообщений что и "
"родитель. Это означает, что два файловых дескриптора совместно используют "
"флаги (I<mq_flags>)."

#. type: Plain text
#: man-pages/man2/fork.2:214
msgid ""
"The child inherits copies of the parent's set of open directory streams (see "
"B<opendir>(3)).  POSIX.1 says that the corresponding directory streams in "
"the parent and child I<may> share the directory stream positioning; on Linux/"
"glibc they do not."
msgstr ""
"Потомок наследует копии набора потоков открытых каталогов родителя (смотрите "
"B<opendir>(3)). В POSIX.1 сказано, что соответствующие потоки каталогов в "
"родителе и потомке I<могут> совместно использовать позицию в потоке "
"каталога; в Linux/glibc они не могут этого делать."

#. type: SH
#: man-pages/man2/fork.2:214
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/fork.2:221
msgid ""
"On success, the PID of the child process is returned in the parent, and 0 is "
"returned in the child.  On failure, -1 is returned in the parent, no child "
"process is created, and I<errno> is set appropriately."
msgstr ""
"При успешном завершении родителю возвращается PID процесса-потомка, а "
"процессу-потомку возвращается 0. При ошибке родительскому процессу "
"возвращается -1, процесс-потомок не создаётся, а значение I<errno> "
"устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/fork.2:222 man-pages/man2/fork.2:251
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#.  NOTE! The following should match the description in pthread_create(3)
#. type: Plain text
#: man-pages/man2/fork.2:227
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error:"
msgstr ""
"Возникло системного ограничение на количество нитей. Есть несколько "
"ограничений, которые могут вызвать эту ошибку:"

#. type: Plain text
#: man-pages/man2/fork.2:235
msgid ""
"the B<RLIMIT_NPROC> soft resource limit (set via B<setrlimit>(2)), which "
"limits the number of processes and threads for a real user ID, was reached;"
msgstr ""
"B<RLIMIT_NPROC> (задаётся с помощью B<setrlimit>(2)), который ограничивает "
"количество процессов и ните для реального ID пользователя;"

#. type: Plain text
#: man-pages/man2/fork.2:240
msgid ""
"the kernel's system-wide limit on the number of processes and threads, I</"
"proc/sys/kernel/threads-max>, was reached (see B<proc>(5));"
msgstr ""
"было достигнуто системное ограничение ядра на количество процессов и нитей, "
"I</proc/sys/kernel/threads-max> (смотрите B<proc>(5));"

#. type: Plain text
#: man-pages/man2/fork.2:246
msgid ""
"the maximum number of PIDs, I</proc/sys/kernel/pid_max>, was reached (see "
"B<proc>(5)); or"
msgstr ""
"достигнуто максимальное количество PID, I</proc/sys/kernel/pid_max> "
"(смотрите B<proc>(5)); или"

#. type: Plain text
#: man-pages/man2/fork.2:250
msgid ""
"the PID limit (I<pids.max>)  imposed by the cgroup \"process number\" (PIDs) "
"controller was reached."
msgstr ""
"достигнуто ограничение на PID (I<pids.max>), наложенное контроллером cgroup "
"на «номер процесса» (PID)."

#. type: Plain text
#: man-pages/man2/fork.2:258
msgid ""
"The caller is operating under the B<SCHED_DEADLINE> scheduling policy and "
"does not have the reset-on-fork flag set.  See B<sched>(7)."
msgstr ""
"Вызывающий работает по алгоритму планирования B<SCHED_DEADLINE> и у него не "
"установлен флаг сброса-при-fork (reset-on-fork). Смотрите B<sched>(7)."

#. type: TP
#: man-pages/man2/fork.2:258 man-pages/man2/fork.2:262
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/fork.2:262
msgid ""
"B<fork>()  failed to allocate the necessary kernel structures because memory "
"is tight."
msgstr ""
"Вызов B<fork>() завершился с ошибкой из-за невозможности разместить "
"необходимые структуры ядра, потому что слишком мало памяти."

#. type: Plain text
#: man-pages/man2/fork.2:268
msgid ""
"An attempt was made to create a child process in a PID namespace whose \"init"
"\" process has terminated.  See B<pid_namespaces>(7)."
msgstr ""
"Была попытка создания дочерний процесс в пространстве имён PID, чей процесс "
"«init» завершил работу. Смотрите B<pid_namespaces>(7)."

#. type: TP
#: man-pages/man2/fork.2:268
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#.  e.g., arm (optionally), blackfin, c6x, frv, h8300, microblaze, xtensa
#. type: Plain text
#: man-pages/man2/fork.2:274
msgid ""
"B<fork>()  is not supported on this platform (for example, hardware without "
"a Memory-Management Unit)."
msgstr ""
"Вызов B<fork>() не поддерживается на этой платформе (например, из-за того, "
"что аппаратное обеспечение не содержит блока управления памятью (MMU))."

#. type: TP
#: man-pages/man2/fork.2:274
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr "B<ERESTARTNOINTR> (начиная с Linux 2.6.17)"

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
#: man-pages/man2/fork.2:279
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be "
"seen only during a trace.)"
msgstr ""
"Системный вызов был прерван сигналом и перезапущен (может быть замечено "
"только при трассировке)."

#. type: Plain text
#: man-pages/man2/fork.2:281
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/fork.2:288
msgid ""
"Under Linux, B<fork>()  is implemented using copy-on-write pages, so the "
"only penalty that it incurs is the time and memory required to duplicate the "
"parent's page tables, and to create a unique task structure for the child."
msgstr ""
"В Linux, B<fork>() реализован с помощью «копирования страниц при "
"записи» (copy-on-write, COW), поэтому расходы на вызов состоят из времени и "
"памяти, требуемой на копирование страничных таблиц родителя и создания "
"уникальной структуры, описывающей задачу."

#. type: SS
#: man-pages/man2/fork.2:288
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#.  nptl/sysdeps/unix/sysv/linux/fork.c
#.  and does some magic to ensure that getpid(2) returns the right value.
#. type: Plain text
#: man-pages/man2/fork.2:312
msgid ""
"Since version 2.3.3, rather than invoking the kernel's B<fork>()  system "
"call, the glibc B<fork>()  wrapper that is provided as part of the NPTL "
"threading implementation invokes B<clone>(2)  with flags that provide the "
"same effect as the traditional system call.  (A call to B<fork>()  is "
"equivalent to a call to B<clone>(2)  specifying I<flags> as just "
"B<SIGCHLD>.)  The glibc wrapper invokes any fork handlers that have been "
"established using B<pthread_atfork>(3)."
msgstr ""
"Начиная с версии 2.3.3, вместо того, чтобы вызывать системный вызов  "
"B<fork>(), обёрточная функция B<fork>() в glibc, как часть реализации нитей "
"NPTL, вызывает B<clone>(2) с флагами, которые обеспечивают поведение "
"традиционного системного вызова (вызов B<fork>() эквивалентен вызову "
"B<clone>(2), если значение равно I<flags> B<SIGCHLD>). Обёртка в glibc "
"вызывает все обработчики при ветвлении (fork), которые были зарегистрированы "
"с помощью B<pthread_atfork>(3)."

#. type: Plain text
#: man-pages/man2/fork.2:317
msgid "See B<pipe>(2)  and B<wait>(2)."
msgstr "Смотрите B<pipe>(2) и B<wait>(2)."

#. type: Plain text
#: man-pages/man2/fork.2:328
msgid ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<pthread_atfork>(3), "
"B<capabilities>(7), B<credentials>(7)"
msgstr ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<pthread_atfork>(3), "
"B<capabilities>(7), B<credentials>(7)"

#. type: Plain text
#: man-pages/man2/futex.2:30
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/futex.2:35
#, no-wrap
msgid ""
"B<int futex(int *>I<uaddr>B<, int >I<futex_op>B<, int >I<val>B<,>\n"
"B<          const struct timespec *>I<timeout>B<,>I< >  /* or: B<uint32_t >I<val2>B< */>\n"
"B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr ""
"B<int futex(int *>I<uaddr>B<, int >I<futex_op>B<, int >I<val>B<,>\n"
"B<          const struct timespec *>I<timeout>B<,>I< >  /* or: B<uint32_t >I<val2>B< */>\n"
"B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"

#. type: Plain text
#: man-pages/man2/futex.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/futex.2:57
msgid ""
"The B<futex>()  system call provides a method for waiting until a certain "
"condition becomes true.  It is typically used as a blocking construct in the "
"context of shared-memory synchronization.  When using futexes, the majority "
"of the synchronization operations are performed in user space.  A user-space "
"program employs the B<futex>()  system call only when it is likely that the "
"program has to block for a longer time until the condition becomes true.  "
"Other B<futex>()  operations can be used to wake any processes or threads "
"waiting for a particular condition."
msgstr ""
"Системный вызов B<futex>() предоставляет программам метод для ожидания пока "
"определённое условие не станет истинным. Обычно, этот системный вызов "
"используется блокирующая конструкция в контексте синхронизации общей памяти. "
"При использовании фьютексов основные операции синхронизации выполняются в "
"пространстве пользователя. Программы пользовательского пространства "
"выполняются системный вызов B<futex>() только когда нужно, чтобы программа "
"вошла в режим ожидания на долгий срок, пока условие не станет истинным. "
"Также B<futex>() можно использовать для пробуждения процессов или нитей, "
"ожидающих определённого условия."

#. type: Plain text
#: man-pages/man2/futex.2:76
msgid ""
"A futex is a 32-bit value\\(emreferred to below as a I<futex word>\\(emwhose "
"address is supplied to the B<futex>()  system call.  (Futexes are 32 bits in "
"size on all platforms, including 64-bit systems.)  All futex operations are "
"governed by this value.  In order to share a futex between processes, the "
"futex is placed in a region of shared memory, created using (for example)  "
"B<mmap>(2)  or B<shmat>(2).  (Thus, the futex word may have different "
"virtual addresses in different processes, but these addresses all refer to "
"the same location in physical memory.)  In a multithreaded program, it is "
"sufficient to place the futex word in a global variable shared by all "
"threads."
msgstr ""
"Фьютекс это 32-битное значение — называемое далее I<словом фьютекса> — чей "
"адрес передаётся в системный вызов B<futex>() (фьютексы имеют размер в 32 "
"бита на всех платформах, включая 64-битные системы). Все операции с "
"фьютексами выполняются с этим значением. Чтобы сделать фьюетекс общим между "
"процессами, фьютекс помещается в область общем памяти, создаваемой с помощью "
"(например) B<mmap>(2) или B<shmat>(2) (то есть слово фьютекса может иметь "
"различающиеся виртуальные адреса в разных процессах, но эти адреса всё равно "
"указывают на одну область в физической памяти). В многонитевых программах "
"достаточно поместить слово фьютекса в глобальную переменную, доступную из "
"всех нитей."

#.  Notes from Darren Hart (Dec 2015):
#.      Totally ordered with respect futex operations refers to semantics
#.      of the ACQUIRE/RELEASE operations and how they impact ordering of
#.      memory reads and writes. The kernel futex operations are protected
#.      by spinlocks, which ensure that all operations are serialized
#.      with respect to one another.
#.      This is a lot to attempt to define in this document. Perhaps a
#.      reference to linux/Documentation/memory-barriers.txt as a footnote
#.      would be sufficient? Or perhaps for this manual, "serialized" would
#.      be sufficient, with a footnote regarding "totally ordered" and a
#.      pointer to the memory-barrier documentation?
#.  FIXME(Torvald Riegel):
#.  Eventually we want to have some text in NOTES to satisfy
#.  the reference in the following sentence
#.      See NOTES for a detailed specification of
#.      the synchronization semantics.
#. type: Plain text
#: man-pages/man2/futex.2:109
msgid ""
"When executing a futex operation that requests to block a thread, the kernel "
"will block only if the futex word has the value that the calling thread "
"supplied (as one of the arguments of the B<futex>()  call) as the expected "
"value of the futex word.  The loading of the futex word's value, the "
"comparison of that value with the expected value, and the actual blocking "
"will happen atomically and will be totally ordered with respect to "
"concurrent operations performed by other threads on the same futex word.  "
"Thus, the futex word is used to connect the synchronization in user space "
"with the implementation of blocking by the kernel.  Analogously to an atomic "
"compare-and-exchange operation that potentially changes shared memory, "
"blocking via a futex is an atomic compare-and-block operation."
msgstr ""
"Когда выполняется операция с фьютексом, запрашивается блокировка нити, "
"которую выполняет ядро только, если слово фьютекса имеет значение, которое "
"передаёт вызывающая нить (в одном из аргументов вызова B<futex>()) равное "
"ожидаемому значению слова фьютекса. Загрузка значения слова фьютекса, "
"сравнение этого значения с ожидаемым и реальная блокировка выполняется "
"автоматически и будет полностью упорядочена в соответствии с одновременными "
"операциями, выполняемыми другими нитями на тем же словом фьютекса. Таким "
"образом, слово фьютекса используется для обеспечения синхронизации в "
"пользовательском пространстве реализованной через блокировку ядром. По "
"аналогии с атомарной операцией сравнения-и-обмена, которая, потенциально, "
"изменяет общую память, блокировка через фьютекс является атомарной операцией "
"сравнения-и-блокировки."

#. type: Plain text
#: man-pages/man2/futex.2:136
msgid ""
"One use of futexes is for implementing locks.  The state of the lock (i.e., "
"acquired or not acquired)  can be represented as an atomically accessed flag "
"in shared memory.  In the uncontended case, a thread can access or modify "
"the lock state with atomic instructions, for example atomically changing it "
"from not acquired to acquired using an atomic compare-and-exchange "
"instruction.  (Such instructions are performed entirely in user mode, and "
"the kernel maintains no information about the lock state.)  On the other "
"hand, a thread may be unable to acquire a lock because it is already "
"acquired by another thread.  It then may pass the lock's flag as a futex "
"word and the value representing the acquired state as the expected value to "
"a B<futex>()  wait operation.  This B<futex>()  operation will block if and "
"only if the lock is still acquired (i.e., the value in the futex word still "
"matches the \"acquired state\").  When releasing the lock, a thread has to "
"first reset the lock state to not acquired and then execute a futex "
"operation that wakes threads blocked on the lock flag used as a futex word "
"(this can be further optimized to avoid unnecessary wake-ups).  See "
"B<futex>(7)  for more detail on how to use futexes."
msgstr ""
"Одним из применений фьютексов является реализация блокировок. Состояние "
"блокировки (т. е., получена или не получена) может быть представлено в виде "
"атомарно доступного флага в общей памяти. При отсутствии конкурентов, нить "
"может получить доступ или изменить состояние блокировки атомарными "
"инструкциями, например атомарно изменяя её значение с не полученной на "
"полученную с помощью атомарной инструкции сравнения-и-обмена (эти инструкции "
"целиком выполняются в пользовательском режим, и ядро с состоянием блокировки "
"ничего не делает). С другой стороны, нить может не получить блокировку, так "
"как она уже получена другой нитью. После этого она может передать флаг "
"блокировки в виде слова фьютекса, значением которого будет ожидаемое "
"значение состояния получения в операции ожидания B<futex>(). Операция "
"B<futex>() блокируется, только когда блокировка всё ещё имеется (т. е., "
"значение слова фьютекса совпадает с «состояния получения»). При освобождении "
"блокировки нить сначала сбрасывает состояние блокировки в не полученное, а "
"затем вызывает операцию фьютекса, которая пробуждает нить, заблокированную "
"флагом блокировки, используя его как слово фьютекса (в дальнейшем это может "
"быть оптимизировано для устранения ненужных пробуждений). О том, как "
"использовать фьютексы, смотрите B<futex>(7)."

#. type: Plain text
#: man-pages/man2/futex.2:139
msgid ""
"Besides the basic wait and wake-up futex functionality, there are further "
"futex operations aimed at supporting more complex use cases."
msgstr ""
"Кроме основных операций ожидания и пробуждения у фьютексов есть и другие "
"операции, для более сложных случаев применения."

#. type: Plain text
#: man-pages/man2/futex.2:148
msgid ""
"Note that no explicit initialization or destruction is necessary to use "
"futexes; the kernel maintains a futex (i.e., the kernel-internal "
"implementation artifact)  only while operations such as B<FUTEX_WAIT>, "
"described below, are being performed on a particular futex word."
msgstr ""
"Заметим, что для использования фьютексов не требуется явных действий по "
"инициализации и удалению; ядро поддерживает фьютексы (т. е., внутренняя "
"часть реализации ядра) только в операции B<FUTEX_WAIT>, описанной далее, "
"обрабатывая определённое слово фьютекса."

#. type: SS
#: man-pages/man2/futex.2:148
#, no-wrap
msgid "Arguments"
msgstr "Аргументы"

#. type: Plain text
#: man-pages/man2/futex.2:160
msgid ""
"The I<uaddr> argument points to the futex word.  On all platforms, futexes "
"are four-byte integers that must be aligned on a four-byte boundary.  The "
"operation to perform on the futex is specified in the I<futex_op> argument; "
"I<val> is a value whose meaning and purpose depends on I<futex_op>."
msgstr ""
"В аргументе I<uaddr> указывает слово фьютекса. На всех платформах фьютексы "
"это целые числа размером в четыре байта, которые должны быть выровнены по "
"четырёх байтовой границе. Операция, выполняемая с фьютексом, задаётся в "
"аргументе I<futex_op>; какое значение будет задаваться в I<val>, зависит от "
"I<futex_op>."

#. type: Plain text
#: man-pages/man2/futex.2:168
msgid ""
"The remaining arguments (I<timeout>, I<uaddr2>, and I<val3>)  are required "
"only for certain of the futex operations described below.  Where one of "
"these arguments is not required, it is ignored."
msgstr ""
"Остальные аргументы (I<timeout>, I<uaddr2> и I<val3>) требуются только для "
"определённых операций с фьютексами и описаны далее. Там, где эти аргументы "
"не нужны, они игнорируются."

#. type: Plain text
#: man-pages/man2/futex.2:186
msgid ""
"For several blocking operations, the I<timeout> argument is a pointer to a "
"I<timespec> structure that specifies a timeout for the operation.  However, "
"notwithstanding the prototype shown above, for some operations, the least "
"significant four bytes of this argument are instead used as an integer whose "
"meaning is determined by the operation.  For these operations, the kernel "
"casts the I<timeout> value first to I<unsigned long>, then to I<uint32_t>, "
"and in the remainder of this page, this argument is referred to as I<val2> "
"when interpreted in this fashion."
msgstr ""
"Для некоторых операций блокировки аргументом I<timeout> является указатель "
"на структуру I<timespec>, в которой задаётся время ожидания операции. "
"Однако, несмотря на прототип, показанный выше, для некоторых операций "
"используются только младшие четыре байта этого аргумента вместо целого "
"числа, назначение которого определяется операцией. Для этих операций ядро "
"преобразует значение I<timeout> сначала к I<unsigned long>, затем к "
"I<uint32_t>. Отсюда и до конца страницы этот аргумент будет называться "
"I<val2>, когда он интерпретируется в такой манере."

#. type: Plain text
#: man-pages/man2/futex.2:191
msgid ""
"Where it is required, the I<uaddr2> argument is a pointer to a second futex "
"word that is employed by the operation."
msgstr ""
"Там, где требуется, аргумент I<uaddr2> представляет собой указатель на "
"второе слово фьютекса, которое используется операцией."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:198
msgid ""
"The interpretation of the final integer argument, I<val3>, depends on the "
"operation."
msgstr ""
"Интерпретация последнего целочисленного аргумента, I<val3>, зависит от "
"операции."

#. type: SS
#: man-pages/man2/futex.2:198
#, no-wrap
msgid "Futex operations"
msgstr "Операции с фьютексами"

#. type: Plain text
#: man-pages/man2/futex.2:208
msgid ""
"The I<futex_op> argument consists of two parts: a command that specifies the "
"operation to be performed, bit-wise ORed with zero or more options that "
"modify the behaviour of the operation.  The options that may be included in "
"I<futex_op> are as follows:"
msgstr ""
"Аргумент I<futex_op> состоит из двух частей: команды, задающей выполняемую "
"операцию, и объединённые биты нуля или более параметров, которые изменяют "
"поведение операции. Параметры, которые можно включать в I<futex_op>:"

#. type: TP
#: man-pages/man2/futex.2:208
#, no-wrap
msgid "B<FUTEX_PRIVATE_FLAG> (since Linux 2.6.22)"
msgstr "B<FUTEX_PRIVATE_FLAG> (начиная с Linux 2.6.22)"

#.  commit 34f01cc1f512fa783302982776895c73714ebbc2
#.  I.e., It allows the kernel choose the fast path for validating
#.  the user-space address and avoids expensive VMA lookups,
#.  taking reference counts on file backing store, and so on.
#. type: Plain text
#: man-pages/man2/futex.2:219
msgid ""
"This option bit can be employed with all futex operations.  It tells the "
"kernel that the futex is process-private and not shared with another process "
"(i.e., it is being used for synchronization only between threads of the same "
"process).  This allows the kernel to make some additional performance "
"optimizations."
msgstr ""
"Этот параметр может быть использован для всех операций с фьютексами. Он "
"указывает ядру, что фьютекс доступен только для одного процесса и недоступен "
"другим процессам (т. е., используется для синхронизации только между нитями "
"одного процесса). Это позволяет ядру выполнять некоторые дополнительные "
"оптимизации для производительности."

#.  except the obsolete FUTEX_FD, for which the "private" flag was
#.  meaningless
#. type: Plain text
#: man-pages/man2/futex.2:234
msgid ""
"As a convenience, I<E<lt>linux/futex.hE<gt>> defines a set of constants with "
"the suffix B<_PRIVATE> that are equivalents of all of the operations listed "
"below, but with the B<FUTEX_PRIVATE_FLAG> ORed into the constant value.  "
"Thus, there are B<FUTEX_WAIT_PRIVATE>, B<FUTEX_WAKE_PRIVATE>, and so on."
msgstr ""
"Для удобства, в I<E<lt>linux/futex.hE<gt>> определён набор констант с "
"суффиксом B<_PRIVATE>, которые эквивалентны всем операциям, перечисленным "
"ниже, но с добавленным константным значением флага B<FUTEX_PRIVATE_FLAG>. То "
"есть, существуют B<FUTEX_WAIT_PRIVATE>, B<FUTEX_WAKE_PRIVATE> и т. д."

#. type: TP
#: man-pages/man2/futex.2:234
#, no-wrap
msgid "B<FUTEX_CLOCK_REALTIME> (since Linux 2.6.28)"
msgstr "B<FUTEX_CLOCK_REALTIME> (начиная с Linux 2.6.28)"

#.  commit 1acdac104668a0834cfa267de9946fac7764d486
#.  commit 337f13046ff03717a9e99675284a817527440a49
#. type: Plain text
#: man-pages/man2/futex.2:245
msgid ""
"This option bit can be employed only with the B<FUTEX_WAIT_BITSET>, "
"B<FUTEX_WAIT_REQUEUE_PI>, and (since Linux 4.5)  B<FUTEX_WAIT> operations."
msgstr ""
"Этот бит параметра может применяться только с операциями "
"B<FUTEX_WAIT_BITSET>, B<FUTEX_WAIT_REQUEUE_PI> и B<FUTEX_WAIT> (начиная с "
"Linux 4.5)."

#. type: Plain text
#: man-pages/man2/futex.2:251
msgid ""
"If this option is set, the kernel measures the I<timeout> against the "
"B<CLOCK_REALTIME> clock."
msgstr ""
"Если он указан, то ядро измеряет I<timeout> по часам B<CLOCK_REALTIME>."

#. type: Plain text
#: man-pages/man2/futex.2:257
msgid ""
"If this option is not set, the kernel measures the I<timeout> against the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""
"Если он не указан, то ядро измеряет I<timeout> по часам B<CLOCK_MONOTONIC>."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:264
msgid "The operation specified in I<futex_op> is one of the following:"
msgstr "Операцией в I<futex_op> может быть одно из:"

#. type: TP
#: man-pages/man2/futex.2:264
#, no-wrap
msgid "B<FUTEX_WAIT> (since Linux 2.6.0)"
msgstr "B<FUTEX_WAIT> (начиная с Linux 2.6.0)"

#.  Strictly speaking, since some time in 2.5.x
#.  FIXME: Torvald, I think we may need to add some explanation of
#.  "totally ordered" here.
#. type: Plain text
#: man-pages/man2/futex.2:290
msgid ""
"This operation tests that the value at the futex word pointed to by the "
"address I<uaddr> still contains the expected value I<val>, and if so, then "
"sleeps waiting for a B<FUTEX_WAKE> operation on the futex word.  The load of "
"the value of the futex word is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with the expected value, and starting to sleep are performed "
"atomically and totally ordered with respect to other futex operations on the "
"same futex word.  If the thread starts to sleep, it is considered a waiter "
"on this futex word.  If the futex value does not match I<val>, then the call "
"fails immediately with the error B<EAGAIN>."
msgstr ""
"Эта операция проверяет, что значение слова фьютекса, на которое указывает "
"адрес I<uaddr> по прежнему содержит ожидаемое значение I<val> и если это "
"так, то засыпает, ожидая операции B<FUTEX_WAKE> для этого слова фьютекса. "
"Загрузка значения слова фьютекса является атомарным доступом к памяти (т. "
"е., используются атомарные машинные инструкции соответствующей архитектуры). "
"Эта загрузка, сравнение с ожидаемым значением и запуск сна выполняются "
"атомарно и целиком упорядочены относительно других фьютекс-операций с этим "
"словом фьютекса. Если нить начала засыпать, то считается что она — ожидающий "
"этого слова фьютекса. Если значение фьютекса не совпадает с I<val>, то вызов "
"немедленно завершается с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/futex.2:301
msgid ""
"The purpose of the comparison with the expected value is to prevent lost "
"wake-ups.  If another thread changed the value of the futex word after the "
"calling thread decided to block based on the prior value, and if the other "
"thread executed a B<FUTEX_WAKE> operation (or similar wake-up) after the "
"value change and before this B<FUTEX_WAIT> operation, then the calling "
"thread will observe the value change and will not start to sleep."
msgstr ""
"Целью сравнения с ожидаемым значением является предотвращение потери "
"пробуждения. Если другая нить изменит значение слова фьютекса после того, "
"как вызывающая нить решила заблокироваться из-за предыдущего значения и если "
"другая нить выполнила операцию B<FUTEX_WAKE> (или подобное пробуждение) "
"после изменения значения и до этой операции B<FUTEX_WAIT>, то вызывающая "
"нить увидит эту смену значения и не станет впадать в сон."

#. type: Plain text
#: man-pages/man2/futex.2:319
msgid ""
"If the I<timeout> is not NULL, the structure it points to specifies a "
"timeout for the wait.  (This interval will be rounded up to the system clock "
"granularity, and is guaranteed not to expire early.)  The timeout is by "
"default measured according to the B<CLOCK_MONOTONIC> clock, but, since Linux "
"4.5, the B<CLOCK_REALTIME> clock can be selected by specifying "
"B<FUTEX_CLOCK_REALTIME> in I<futex_op>.  If I<timeout> is NULL, the call "
"blocks indefinitely."
msgstr ""
"Если значение I<timeout> не равно NULL, то структура, на которую он "
"указывает, определяет время ожидания (этот интервал будет округлён до "
"точности системных часов, и гарантируется, что он не наступит раньше "
"положенного). По умолчанию время ожидания измеряется по часам "
"B<CLOCK_MONOTONIC>, но начиная с Linux 4.5 можно выбрать часы "
"B<CLOCK_REALTIME>, указав B<FUTEX_CLOCK_REALTIME> в I<futex_op>. Если "
"I<timeout> равно NULL, то вызов блокируется бессрочно."

#. type: Plain text
#: man-pages/man2/futex.2:338
msgid ""
"I<Note>: for B<FUTEX_WAIT>, I<timeout> is interpreted as a I<relative> "
"value.  This differs from other futex operations, where I<timeout> is "
"interpreted as an absolute value.  To obtain the equivalent of B<FUTEX_WAIT> "
"with an absolute timeout, employ B<FUTEX_WAIT_BITSET> with I<val3> specified "
"as B<FUTEX_BITSET_MATCH_ANY>."
msgstr ""
"I<Замечание>: при B<FUTEX_WAIT> значение I<timeout> интерпретируется как "
"I<относительное>. В этом отличие от других операций над фьютексами, в "
"которых I<timeout> интерпретируется как абсолютное значение. Чтобы получить "
"эквивалент B<FUTEX_WAIT> с абсолютным временем ожидания укажите "
"B<FUTEX_WAIT_BITSET> в I<val3> вместе с B<FUTEX_BITSET_MATCH_ANY>."

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to a
#.  different example.
#.      For
#.      .BR futex (7),
#.      this call is executed if decrementing the count gave a negative value
#.      (indicating contention),
#.      and will sleep until another process or thread releases
#.      the futex and executes the
#.      .B FUTEX_WAKE
#.      operation.
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:358
msgid "The arguments I<uaddr2> and I<val3> are ignored."
msgstr "Аргументы I<uaddr2> и I<val3> игнорируются."

#. type: TP
#: man-pages/man2/futex.2:358
#, no-wrap
msgid "B<FUTEX_WAKE> (since Linux 2.6.0)"
msgstr "B<FUTEX_WAKE> (начиная с Linux 2.6.0)"

#.  Strictly speaking, since Linux 2.5.x
#. type: Plain text
#: man-pages/man2/futex.2:375
msgid ""
"This operation wakes at most I<val> of the waiters that are waiting (e.g., "
"inside B<FUTEX_WAIT>)  on the futex word at the address I<uaddr>.  Most "
"commonly, I<val> is specified as either 1 (wake up a single waiter) or "
"B<INT_MAX> (wake up all waiters).  No guarantee is provided about which "
"waiters are awoken (e.g., a waiter with a higher scheduling priority is not "
"guaranteed to be awoken in preference to a waiter with a lower priority)."
msgstr ""
"Эта операция пробуждает не больше I<val> процессов, ожидающих (например, "
"внутри B<FUTEX_WAIT>) слово фьютекса по адресу I<uaddr>. Чаще всего, I<val> "
"присваивают или 1 (пробудить одного ожидающего), или B<INT_MAX> (пробудить "
"всех ожидающих). Не гарантируется, что разбудят каких-то определённых "
"ожидающих (например, что ожидающий с большим приоритетом планировщика будет "
"разбужен раньше ожидающего, имеющего меньший приоритет)."

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to
#.  a different example.
#.      For
#.      .BR futex (7),
#.      this is executed if incrementing the count showed that
#.      there were waiters,
#.      once the futex value has been set to 1
#.      (indicating that it is available).
#.  How does "incrementing the count show that there were waiters"?
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:396
msgid "The arguments I<timeout>, I<uaddr2>, and I<val3> are ignored."
msgstr "Аргументы I<timeout>, I<uaddr2> и I<val3> игнорируются."

#. type: TP
#: man-pages/man2/futex.2:396
#, no-wrap
msgid "B<FUTEX_FD> (from Linux 2.6.0 up to and including Linux 2.6.25)"
msgstr "B<FUTEX_FD> (начиная с Linux 2.6.0 и по Linux 2.6.25 включительно)"

#.  Strictly speaking, from Linux 2.5.x to 2.6.25
#. type: Plain text
#: man-pages/man2/futex.2:410
msgid ""
"This operation creates a file descriptor that is associated with the futex "
"at I<uaddr>.  The caller must close the returned file descriptor after use.  "
"When another process or thread performs a B<FUTEX_WAKE> on the futex word, "
"the file descriptor indicates as being readable with B<select>(2), "
"B<poll>(2), and B<epoll>(7)"
msgstr ""
"Эта операция создаёт файловый дескриптор, который связан с фьютексом по "
"адресу I<uaddr>. Вызывающий должен закрыть возвращённый файловый дескриптор "
"после использования. Если другой процесс или нить выполняет операцию "
"B<FUTEX_WAKE> со словом фьютекса, то файловый дескриптор будет отмечен как "
"доступный для чтения в B<select>(2), B<poll>(2) и B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/futex.2:417
msgid ""
"The file descriptor can be used to obtain asynchronous notifications: if "
"I<val> is nonzero, then, when another process or thread executes a "
"B<FUTEX_WAKE>, the caller will receive the signal number that was passed in "
"I<val>."
msgstr ""
"Файловый дескриптор можно использовать для получения асинхронных "
"уведомлений: если I<val> не равно нулю, то когда другой процесс или нить "
"выполняют B<FUTEX_WAKE>, то вызывающий примет сигнал с номером, который был "
"указан в I<val>."

#. type: Plain text
#: man-pages/man2/futex.2:424
msgid "The arguments I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr "Аргументы I<timeout>, I<uaddr2> и I<val3> игнорируются."

#.  commit 82af7aca56c67061420d618cc5a30f0fd4106b80
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:433
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""
"Так как по своей природе операция B<FUTEX_FD> приводит к состязательности, "
"она была удалена из Linux, начиная с версии 2.6.26."

#. type: TP
#: man-pages/man2/futex.2:433
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.6.0)"
msgstr "B<FUTEX_REQUEUE> (начиная с Linux 2.6.0)"

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:445
msgid ""
"This operation performs the same task as B<FUTEX_CMP_REQUEUE> (see below), "
"except that no check is made using the value in I<val3>.  (The argument "
"I<val3> is ignored.)"
msgstr ""
"Эта операция выполняет ту же задачу, что и B<FUTEX_CMP_REQUEUE> (смотрите "
"далее), за исключением того, что она не проверяет используемое значение в "
"I<val3> (аргумент I<val3> игнорируется)."

#. type: TP
#: man-pages/man2/futex.2:445
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr "B<FUTEX_CMP_REQUEUE> (начиная с Linux 2.6.7)"

#. type: Plain text
#: man-pages/man2/futex.2:469
msgid ""
"This operation first checks whether the location I<uaddr> still contains the "
"value I<val3>.  If not, the operation fails with the error B<EAGAIN>.  "
"Otherwise, the operation wakes up a maximum of I<val> waiters that are "
"waiting on the futex at I<uaddr>.  If there are more than I<val> waiters, "
"then the remaining waiters are removed from the wait queue of the source "
"futex at I<uaddr> and added to the wait queue of the target futex at "
"I<uaddr2>.  The I<val2> argument specifies an upper limit on the number of "
"waiters that are requeued to the futex at I<uaddr2>."
msgstr ""
"Сначала эта операция проверяет, что по адресу I<uaddr> по прежнему "
"содержится значение I<val3>. Если нет, то операция завершается с ошибкой "
"B<EAGAIN>. В противном случае, операция пробуждает не более I<val> "
"ожидающих, которые ждут фьютекс по адресу I<uaddr>. Если существует более "
"I<val> ожидающих, то оставшиеся ожидающие удаляются из очереди ожидания "
"фьютекса-источника по адресу I<uaddr> и добавляются в очередь ожидания "
"фьютекса-назначения по адресу I<uaddr2>. В аргументе I<val2> задаётся "
"верхний предел количества ожидающих, которые перемещаются в очередь фьютекса "
"по адресу I<uaddr2>."

#.  FIXME(Torvald) Is the following correct?  Or is just the decision
#.  which threads to wake or requeue part of the atomic operation?
#.  Notes from a f2f conversation with Thomas Gleixner (Aug 2015): ###
#. 	The operation is serialized with respect to operations on both
#. 	source and target futex. No other waiter can enqueue itself
#. 	for waiting and no other waiter can dequeue itself because of
#. 	a timeout or signal.
#. type: Plain text
#: man-pages/man2/futex.2:485
msgid ""
"The load from I<uaddr> is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with I<val3>, and the requeueing of any waiters are performed "
"atomically and totally ordered with respect to other operations on the same "
"futex word."
msgstr ""
"Загрузка из I<uaddr> является атомарным доступом к памяти (т. е., "
"используются атомарные машинные инструкции соответствующей архитектуры). Эта "
"загрузка, сравнение с I<val3> и перестановка в очередь ожидающих выполняются "
"атомарно и целиком упорядочены относительно других фьютекс-операций с этим "
"словом фьютекса."

#. type: Plain text
#: man-pages/man2/futex.2:503
msgid ""
"Typical values to specify for I<val> are 0 or 1.  (Specifying B<INT_MAX> is "
"not useful, because it would make the B<FUTEX_CMP_REQUEUE> operation "
"equivalent to B<FUTEX_WAKE>.)  The limit value specified via I<val2> is "
"typically either 1 or B<INT_MAX>.  (Specifying the argument as 0 is not "
"useful, because it would make the B<FUTEX_CMP_REQUEUE> operation equivalent "
"to B<FUTEX_WAIT>.)"
msgstr ""
"Типичными значениями I<val> являются 0 или 1 (указание B<INT_MAX> "
"бесполезно, так как это сделало бы операцию B<FUTEX_CMP_REQUEUE> "
"эквивалентной B<FUTEX_WAKE>). Значение ограничения, указанное в I<val2>, "
"обычно, или 1 или B<INT_MAX> (указание 0 бесполезно, так как это сделало бы "
"операцию B<FUTEX_CMP_REQUEUE> эквивалентной B<FUTEX_WAIT>)."

#.  But, as Rich Felker points out, there remain valid use cases for
#.  FUTEX_REQUEUE, for example, when the calling thread is requeuing
#.  the target(s) to a lock that the calling thread owns
#.      From: Rich Felker <dalias@libc.org>
#.      Date: Wed, 29 Oct 2014 22:43:17 -0400
#.      To: Darren Hart <dvhart@infradead.org>
#.      CC: libc-alpha@sourceware.org, ...
#.      Subject: Re: Add futex wrapper to glibc?
#. type: Plain text
#: man-pages/man2/futex.2:520
msgid ""
"The B<FUTEX_CMP_REQUEUE> operation was added as a replacement for the "
"earlier B<FUTEX_REQUEUE>.  The difference is that the check of the value at "
"I<uaddr> can be used to ensure that requeueing happens only under certain "
"conditions, which allows race conditions to be avoided in certain use cases."
msgstr ""
"Операция B<FUTEX_CMP_REQUEUE> была добавлена в качестве замены имевшейся "
"B<FUTEX_REQUEUE>. Различие в том, что проверку значения по адресу I<uaddr> "
"можно использовать для гарантии того, что перестановка в очередь произойдёт "
"только при определённых условиях, что в определённых случаях позволит "
"избежать состязательности."

#. type: Plain text
#: man-pages/man2/futex.2:532
msgid ""
"Both B<FUTEX_REQUEUE> and B<FUTEX_CMP_REQUEUE> can be used to avoid "
"\"thundering herd\" wake-ups that could occur when using B<FUTEX_WAKE> in "
"cases where all of the waiters that are woken need to acquire another "
"futex.  Consider the following scenario, where multiple waiter threads are "
"waiting on B, a wait queue implemented using a futex:"
msgstr ""
"И B<FUTEX_REQUEUE> и B<FUTEX_CMP_REQUEUE> можно использовать для недопущения "
"«нашествия орды» из пробудившихся, которое может произойти при использовании "
"B<FUTEX_WAKE> в случаях, когда всем разбуженным ожидающим требуется "
"заблокировать другой фьютекс. Рассмотрим следующий сценарий, где несколько "
"ожидающих нитей ждут B, очередь ожидания реализована с помощью фьютекса:"

#. type: Plain text
#: man-pages/man2/futex.2:542
#, no-wrap
msgid ""
"lock(A)\n"
"while (!check_value(V)) {\n"
"    unlock(A);\n"
"    block_on(B);\n"
"    lock(A);\n"
"};\n"
"unlock(A);\n"
msgstr ""
"lock(A)\n"
"while (!check_value(V)) {\n"
"    unlock(A);\n"
"    block_on(B);\n"
"    lock(A);\n"
"};\n"
"unlock(A);\n"

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:557
msgid ""
"If a waker thread used B<FUTEX_WAKE>, then all waiters waiting on B would be "
"woken up, and they would all try to acquire lock A.  However, waking all of "
"the threads in this manner would be pointless because all except one of the "
"threads would immediately block on lock A again.  By contrast, a requeue "
"operation wakes just one waiter and moves the other waiters to lock A, and "
"when the woken waiter unlocks A then the next waiter can proceed."
msgstr ""
"Если пробуждающая нить использует B<FUTEX_WAKE>, то все ожидающие,ждущие B, "
"проснулись бы, и попытались получить блокировку A. Однако пробуждение всех "
"нитей таким образом было бы нецелесообразно, так как все кроме одной нити "
"снова немедленно бы заблокировались в ожидании A. В отличие от этого, "
"операция перестановки в очередь разбудит только одного ожидающего и "
"переместит остальных ожидающих в ожидание блокировки A, и когда разбуженный "
"ожидающий разблокирует A, то следующий ожидающий сможет продолжить работу."

#. type: TP
#: man-pages/man2/futex.2:557
#, no-wrap
msgid "B<FUTEX_WAKE_OP> (since Linux 2.6.14)"
msgstr "B<FUTEX_WAKE_OP> (начиная с Linux 2.6.14)"

#.  commit 4732efbeb997189d9f9b04708dc26bf8613ed721
#. 	Author: Jakub Jelinek <jakub@redhat.com>
#. 	Date:   Tue Sep 6 15:16:25 2005 -0700
#.  FIXME. (Torvald) The glibc condvar implementation is currently being
#.      revised (e.g., to not use an internal lock anymore).
#.      It is probably more future-proof to remove this paragraph.
#.  [Torvald, do you have an update here?]
#. type: Plain text
#: man-pages/man2/futex.2:576
msgid ""
"This operation was added to support some user-space use cases where more "
"than one futex must be handled at the same time.  The most notable example "
"is the implementation of B<pthread_cond_signal>(3), which requires "
"operations on two futexes, the one used to implement the mutex and the one "
"used in the implementation of the wait queue associated with the condition "
"variable.  B<FUTEX_WAKE_OP> allows such cases to be implemented without "
"leading to high rates of contention and context switching."
msgstr ""
"Эта операция была добавлена для работы в некоторых случаях из "
"пользовательского пространства, в которых нужно одновременно учитывать "
"несколько фьютексов. Самый известный пример — реализация "
"B<pthread_cond_signal>(3), которая требует операций для работы с двумя "
"фьютексами: один для реализации мьютекса, а другой для реализации очереди "
"ожидания, связанной с переменной условия. Операция B<FUTEX_WAKE_OP> "
"позволяет это реализовать без увеличения состязательности и контекстного "
"переключения."

#. type: Plain text
#: man-pages/man2/futex.2:582
msgid ""
"The B<FUTEX_WAKE_OP> operation is equivalent to executing the following code "
"atomically and totally ordered with respect to other futex operations on any "
"of the two supplied futex words:"
msgstr ""
"Операция B<FUTEX_WAKE_OP> эквивалентна выполнению следующего кода, при чём, "
"атомарно и полностью упорядочено в соответствии с другими фьютекс-"
"операциями, выполняемыми над двумя указанными словами фьютекса:"

#. type: Plain text
#: man-pages/man2/futex.2:590
#, no-wrap
msgid ""
"int oldval = *(int *) uaddr2;\n"
"*(int *) uaddr2 = oldval I<op> I<oparg>;\n"
"futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);\n"
"if (oldval I<cmp> I<cmparg>)\n"
"    futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);\n"
msgstr ""
"int oldval = *(int *) uaddr2;\n"
"*(int *) uaddr2 = oldval I<op> I<oparg>;\n"
"futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);\n"
"if (oldval I<cmp> I<cmparg>)\n"
"    futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);\n"

#. type: Plain text
#: man-pages/man2/futex.2:596
msgid "In other words, B<FUTEX_WAKE_OP> does the following:"
msgstr "Иначе говоря, B<FUTEX_WAKE_OP> делает следующее:"

#. type: Plain text
#: man-pages/man2/futex.2:604
msgid ""
"saves the original value of the futex word at I<uaddr2> and performs an "
"operation to modify the value of the futex at I<uaddr2>; this is an atomic "
"read-modify-write memory access (i.e., using atomic machine instructions of "
"the respective architecture)"
msgstr ""
"сохраняет первоначальное значение слова фьютекса по адресу I<uaddr2> и "
"выполняет операцию изменения значения фьютекса по адресу I<uaddr2>; это "
"атомарная операция с памятью по чтению-изменению-записи (т. е., используются "
"атомарные машинные инструкции на соответствующей архитектуре);"

#. type: Plain text
#: man-pages/man2/futex.2:610
msgid ""
"wakes up a maximum of I<val> waiters on the futex for the futex word at "
"I<uaddr>; and"
msgstr ""
"пробуждает не более I<val> ожидающих у фьютекса слова фьютекса по адресу "
"I<uaddr>; и"

#. type: Plain text
#: man-pages/man2/futex.2:618
msgid ""
"dependent on the results of a test of the original value of the futex word "
"at I<uaddr2>, wakes up a maximum of I<val2> waiters on the futex for the "
"futex word at I<uaddr2>."
msgstr ""
"в зависимости от результата проверки первоначального значения слова фьютекса "
"по адресу I<uaddr2>, пробуждает не более I<val2> ожидающих у фьютекса слова "
"фьютекса по адресу I<uaddr2>."

#. type: Plain text
#: man-pages/man2/futex.2:624
msgid ""
"The operation and comparison that are to be performed are encoded in the "
"bits of the argument I<val3>.  Pictorially, the encoding is:"
msgstr ""
"Операция и сравнение, которое будет выполнено, кодируется в битах аргумента "
"I<val3>. Графически, кодирование выглядит так:"

#. type: Plain text
#: man-pages/man2/futex.2:631
#, no-wrap
msgid ""
"+---+---+-----------+-----------+\n"
"|op |cmp|   oparg   |  cmparg   |\n"
"+---+---+-----------+-----------+\n"
"  4   4       12          12    E<lt>== # of bits\n"
msgstr ""
"+---+---+-----------+-----------+\n"
"|оп |сра|   аргоп   |  аргсра   |\n"
"+---+---+-----------+-----------+\n"
"  4   4       12          12    E<lt>== кол-во бит\n"

#. type: Plain text
#: man-pages/man2/futex.2:635
msgid "Expressed in code, the encoding is:"
msgstr "В виде кода это выглядит так:"

#. type: Plain text
#: man-pages/man2/futex.2:643
#, no-wrap
msgid ""
"#define FUTEX_OP(op, oparg, cmp, cmparg) \\e\n"
"                (((op & 0xf) E<lt>E<lt> 28) | \\e\n"
"                ((cmp & 0xf) E<lt>E<lt> 24) | \\e\n"
"                ((oparg & 0xfff) E<lt>E<lt> 12) | \\e\n"
"                (cmparg & 0xfff))\n"
msgstr ""
"#define FUTEX_OP(op, oparg, cmp, cmparg) \\e\n"
"                (((op & 0xf) E<lt>E<lt> 28) | \\e\n"
"                ((cmp & 0xf) E<lt>E<lt> 24) | \\e\n"
"                ((oparg & 0xfff) E<lt>E<lt> 12) | \\e\n"
"                (cmparg & 0xfff))\n"

#. type: Plain text
#: man-pages/man2/futex.2:656
msgid ""
"In the above, I<op> and I<cmp> are each one of the codes listed below.  The "
"I<oparg> and I<cmparg> components are literal numeric values, except as "
"noted below."
msgstr ""
"Указанные выше I<op> и I<cmp> могут содержат один из кодов, перечисленных "
"далее. Компоненты I<oparg> и I<cmparg> являются числовыми литералами, с "
"учётом замечаний далее."

#. type: Plain text
#: man-pages/man2/futex.2:660
msgid "The I<op> component has one of the following values:"
msgstr "Компонент I<op> может иметь одно из следующих значений:"

#. type: Plain text
#: man-pages/man2/futex.2:668
#, no-wrap
msgid ""
"FUTEX_OP_SET        0  /* uaddr2 = oparg; */\n"
"FUTEX_OP_ADD        1  /* uaddr2 += oparg; */\n"
"FUTEX_OP_OR         2  /* uaddr2 |= oparg; */\n"
"FUTEX_OP_ANDN       3  /* uaddr2 &= ~oparg; */\n"
"FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */\n"
msgstr ""
"FUTEX_OP_SET        0  /* uaddr2 = oparg; */\n"
"FUTEX_OP_ADD        1  /* uaddr2 += oparg; */\n"
"FUTEX_OP_OR         2  /* uaddr2 |= oparg; */\n"
"FUTEX_OP_ANDN       3  /* uaddr2 &= ~oparg; */\n"
"FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */\n"

#. type: Plain text
#: man-pages/man2/futex.2:676
msgid ""
"In addition, bit-wise ORing the following value into I<op> causes I<(1\\ "
"E<lt>E<lt>\\ oparg)> to be used as the operand:"
msgstr ""
"Также, битовое сложение следующего значения с I<op> приводит к использованию "
"I<(1\\ E<lt>E<lt>\\ oparg)> в качестве операнда:"

#. type: Plain text
#: man-pages/man2/futex.2:680
#, no-wrap
msgid "FUTEX_OP_ARG_SHIFT  8  /* Use (1 E<lt>E<lt> oparg) as operand */\n"
msgstr "FUTEX_OP_ARG_SHIFT  8  /* исп. (1 E<lt>E<lt> oparg) как операнд */\n"

#. type: Plain text
#: man-pages/man2/futex.2:686
msgid "The I<cmp> field is one of the following:"
msgstr "В поле I<cmp> может быть одно из:"

#. type: Plain text
#: man-pages/man2/futex.2:695
#, no-wrap
msgid ""
"FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */\n"
"FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */\n"
"FUTEX_OP_CMP_LT     2  /* if (oldval E<lt> cmparg) wake */\n"
"FUTEX_OP_CMP_LE     3  /* if (oldval E<lt>= cmparg) wake */\n"
"FUTEX_OP_CMP_GT     4  /* if (oldval E<gt> cmparg) wake */\n"
"FUTEX_OP_CMP_GE     5  /* if (oldval E<gt>= cmparg) wake */\n"
msgstr ""
"FUTEX_OP_CMP_EQ  0  /* если (oldval == cmparg) — пробудить */\n"
"FUTEX_OP_CMP_NE  1  /* если (oldval != cmparg) — пробудить */\n"
"FUTEX_OP_CMP_LT  2  /* если (oldval E<lt> cmparg) — пробудить */\n"
"FUTEX_OP_CMP_LE  3  /* если (oldval E<lt>= cmparg) — пробудить */\n"
"FUTEX_OP_CMP_GT  4  /* если (oldval E<gt> cmparg) — пробудить */\n"
"FUTEX_OP_CMP_GE  5  /* если (oldval E<gt>= cmparg) — пробудить */\n"

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:707
msgid ""
"The return value of B<FUTEX_WAKE_OP> is the sum of the number of waiters "
"woken on the futex I<uaddr> plus the number of waiters woken on the futex "
"I<uaddr2>."
msgstr ""
"Возвращаемое значение операции B<FUTEX_WAKE_OP> — сумма количества "
"разбуженных ожидающих фьютекса I<uaddr> и количества разбуженных ожидающих "
"фьютекса I<uaddr2>."

#. type: TP
#: man-pages/man2/futex.2:707
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET> (since Linux 2.6.25)"
msgstr "B<FUTEX_WAIT_BITSET> (начиная с Linux 2.6.25)"

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: man-pages/man2/futex.2:720
msgid ""
"This operation is like B<FUTEX_WAIT> except that I<val3> is used to provide "
"a 32-bit bit mask to the kernel.  This bit mask, in which at least one bit "
"must be set, is stored in the kernel-internal state of the waiter.  See the "
"description of B<FUTEX_WAKE_BITSET> for further details."
msgstr ""
"Эта операция подобна B<FUTEX_WAIT>, за исключением того, что I<val3> "
"используется для передачи 32-битной маски в ядро. Данная битовая маска, в "
"которой должен быть установлен хотя бы один бит, хранится в ядре во "
"внутреннем состоянии ожидающего. Подробности смотрите в описании "
"B<FUTEX_WAKE_BITSET>."

#. type: Plain text
#: man-pages/man2/futex.2:728 man-pages/man2/futex.2:1269
msgid ""
"If I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout for the wait operation.  If I<timeout> is NULL, the operation can "
"block indefinitely."
msgstr ""
"Если значение I<timeout> не равно NULL, то структура, на которую он "
"указывает, определяет абсолютное время ожидания. Если I<timeout> равно NULL, "
"то операция блокируется бессрочно."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:736
msgid "The I<uaddr2> argument is ignored."
msgstr "Аргумент I<uaddr2> игнорируется."

#. type: TP
#: man-pages/man2/futex.2:736
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET> (since Linux 2.6.25)"
msgstr "B<FUTEX_WAKE_BITSET> (начиная с Linux 2.6.25)"

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: man-pages/man2/futex.2:754
msgid ""
"This operation is the same as B<FUTEX_WAKE> except that the I<val3> argument "
"is used to provide a 32-bit bit mask to the kernel.  This bit mask, in which "
"at least one bit must be set, is used to select which waiters should be "
"woken up.  The selection is done by a bit-wise AND of the \"wake\" bit mask "
"(i.e., the value in I<val3>)  and the bit mask which is stored in the kernel-"
"internal state of the waiter (the \"wait\" bit mask that is set using "
"B<FUTEX_WAIT_BITSET>).  All of the waiters for which the result of the AND "
"is nonzero are woken up; the remaining waiters are left sleeping."
msgstr ""
"Данная операция подобна B<FUTEX_WAKE>, за исключением того, что I<val3> "
"используется для передачи 32-битной маски в ядро. Данная битовая маска, в "
"которой должен быть установлен хотя бы один бит, используется для выбора "
"ожидающих, которые должны быть разбужены. Выбор выполняется путём побитового "
"И битовой маски «wake» (т. е., значения I<val3>) и битовой маски, которая "
"хранится в  ядре во внутреннем состоянии ожидающего (битовая маска «wait», "
"устанавливающаяся с помощью B<FUTEX_WAIT_BITSET>). Все ожидающие, для "
"которых результат побитового И не равен нулю, пробуждаются; оставшиеся "
"ожидающие продолжают спать."

#.  According to http://locklessinc.com/articles/futex_cheat_sheet/:
#.     "The original reason for the addition of these extensions
#.      was to improve the performance of pthread read-write locks
#.      in glibc. However, the pthreads library no longer uses the
#.      same locking algorithm, and these extensions are not used
#.      without the bitset parameter being all ones.
#.  The page goes on to note that the FUTEX_WAIT_BITSET operation
#.  is nevertheless used (with a bit mask of all ones) in order to
#.  obtain the absolute timeout functionality that is useful
#.  for efficiently implementing Pthreads APIs (which use absolute
#.  timeouts); FUTEX_WAIT provides only relative timeouts.
#. type: Plain text
#: man-pages/man2/futex.2:781
msgid ""
"The effect of B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET> is to allow "
"selective wake-ups among multiple waiters that are blocked on the same "
"futex.  However, note that, depending on the use case, employing this bit-"
"mask multiplexing feature on a futex can be less efficient than simply using "
"multiple futexes, because employing bit-mask multiplexing requires the "
"kernel to check all waiters on a futex, including those that are not "
"interested in being woken up (i.e., they do not have the relevant bit set in "
"their \"wait\" bit mask)."
msgstr ""
"Влияние B<FUTEX_WAIT_BITSET> и B<FUTEX_WAKE_BITSET> позволяет выбирать "
"пробуждающихся из многих ожидающих, которые заблокированы на один фьютекс. "
"Однако заметим, что в зависимости от варианта применения, использование "
"данного свойства комбинирования битовой маски с фьютексом может быть менее "
"эффективно, чем простое использование нескольких фьютексов, так как "
"использование комбинирования битовой маски требует от ядра проверки всех "
"ожидающих фьютекса, включая тех, которые и не нужно было бы будить (т. е., у "
"них неподходящий набор бит в их битовой маске «wait»)."

#. type: Plain text
#: man-pages/man2/futex.2:810
msgid ""
"The constant B<FUTEX_BITSET_MATCH_ANY>, which corresponds to all 32 bits set "
"in the bit mask, can be used as the I<val3> argument for "
"B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET>.  Other than differences in "
"the handling of the I<timeout> argument, the B<FUTEX_WAIT> operation is "
"equivalent to B<FUTEX_WAIT_BITSET> with I<val3> specified as "
"B<FUTEX_BITSET_MATCH_ANY>; that is, allow a wake-up by any waker.  The "
"B<FUTEX_WAKE> operation is equivalent to B<FUTEX_WAKE_BITSET> with I<val3> "
"specified as B<FUTEX_BITSET_MATCH_ANY>; that is, wake up any waiter(s)."
msgstr ""
"Константу B<FUTEX_BITSET_MATCH_ANY>, которая соответствует всем "
"установленным битам в 32-битной маске, можно использовать в аргументе "
"I<val3> для B<FUTEX_WAIT_BITSET> и B<FUTEX_WAKE_BITSET>. Кроме различий в "
"обработке аргумента I<timeout>, операция B<FUTEX_WAIT> эквивалентна "
"B<FUTEX_WAIT_BITSET> с I<val3>, равным B<FUTEX_BITSET_MATCH_ANY>, то есть "
"разрешается будить любого пробуждающего. Операция B<FUTEX_WAKE> эквивалентна "
"B<FUTEX_WAKE_BITSET> с I<val3>, равным B<FUTEX_BITSET_MATCH_ANY>, то есть "
"пробуждается любой(ые) пробуждающий."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:819
msgid "The I<uaddr2> and I<timeout> arguments are ignored."
msgstr "Аргументы I<uaddr2> и I<timeout> игнорируются."

#. type: SS
#: man-pages/man2/futex.2:819
#, no-wrap
msgid "Priority-inheritance futexes"
msgstr "Наследование приоритета из-за фьютексов"

#. type: Plain text
#: man-pages/man2/futex.2:829
msgid ""
"Linux supports priority-inheritance (PI) futexes in order to handle priority-"
"inversion problems that can be encountered with normal futex locks.  "
"Priority inversion is the problem that occurs when a high-priority task is "
"blocked waiting to acquire a lock held by a low-priority task, while tasks "
"at an intermediate priority continuously preempt the low-priority task from "
"the CPU.  Consequently, the low-priority task makes no progress toward "
"releasing the lock, and the high-priority task remains blocked."
msgstr ""
"В Linux поддерживается наследование приоритета из-за фьютексов priority-"
"inheritance (PI), так как требуется решать проблему обратного приоритета, "
"которая встречается у обычных блокировок фьютексов. Проблема обратного "
"приоритета возникает, когда задача с высоким приоритетом блокируется в "
"ожидании получения блокировки, которую удерживает задача с низким "
"приоритетом, в то время как задачи со средним приоритетом постоянно "
"вытесняют задачу с низким приоритетом с ЦП. В следствии этого, выполнение "
"задачи с низким приоритетом никак не продвигается к освобождению блокировки, "
"и задача с высоким приоритетом остаётся заблокированной."

#. type: Plain text
#: man-pages/man2/futex.2:846
msgid ""
"Priority inheritance is a mechanism for dealing with the priority-inversion "
"problem.  With this mechanism, when a high-priority task becomes blocked by "
"a lock held by a low-priority task, the priority of the low-priority task is "
"temporarily raised to that of the high-priority task, so that it is not "
"preempted by any intermediate level tasks, and can thus make progress toward "
"releasing the lock.  To be effective, priority inheritance must be "
"transitive, meaning that if a high-priority task blocks on a lock held by a "
"lower-priority task that is itself blocked by a lock held by another "
"intermediate-priority task (and so on, for chains of arbitrary length), then "
"both of those tasks (or more generally, all of the tasks in a lock chain)  "
"have their priorities raised to be the same as the high-priority task."
msgstr ""
"Наследование приоритета — это механизм, который решает проблему обратного "
"приоритета. С его помощью, когда задача с высоким приоритетом блокируется из-"
"за удержания блокировки задачей с низким приоритетом, приоритет задачи с "
"низким приоритетом временно повышается до приоритета, имеющегося у "
"заблокированной задачи, и поэтому не происходит вытеснения задачами с "
"средним приоритетом, что способствует ускорению освобождения блокировки. "
"Чтобы это работало, наследование приоритета должно быть транзитивным, то "
"есть если задача с высоким приоритетом заблокирована, из-за удержания "
"блокировки задачей с низким приоритетом, которая сама заблокирована из-за "
"удержания блокировки другой задачей со средним приоритетом (и так далее, по "
"цепочке произвольной длины), то для обеих этих задач (или, шире, всех задач "
"в заблокированной цепочке) повышается приоритет, который равен приоритету "
"задачи с высоким приоритетом."

#.  Quoting Darren Hart:
#.      These opcodes paired with the PI futex value policy (described below)
#.      defines a "futex" as PI aware. These were created very specifically
#.      in support of PI pthread_mutexes, so it makes a lot more sense to
#.      talk about a PI aware pthread_mutex, than a PI aware futex, since
#.      there is a lot of policy and scaffolding that has to be built up
#.      around it to use it properly (this is what a PI pthread_mutex is).
#. type: Plain text
#: man-pages/man2/futex.2:862
msgid ""
"From a user-space perspective, what makes a futex PI-aware is a policy "
"agreement (described below)  between user space and the kernel about the "
"value of the futex word, coupled with the use of the PI-futex operations "
"described below.  (Unlike the other futex operations described above, the PI-"
"futex operations are designed for the implementation of very specific IPC "
"mechanisms.)"
msgstr ""
"Со стороны пользовательского пространства фьютекс является PI из-за "
"следования соглашениям (описанных далее) между пользовательским "
"пространством и ядром о значении слова фьютекса и применяемым операциям над "
"PI-фьютексами, описанным далее (в отличие от других операций с фьютексами, "
"описанных выше, операции с PI-фьютексами разработаны для реализации очень "
"специфичных механизмов IPC)."

#.        mtk: The following text is drawn from the Hart/Guniguntala paper
#.        (listed in SEE ALSO), but I have reworded some pieces
#.        significantly.
#. type: Plain text
#: man-pages/man2/futex.2:870
msgid ""
"The PI-futex operations described below differ from the other futex "
"operations in that they impose policy on the use of the value of the futex "
"word:"
msgstr ""
"Операции с PI-фьютексами, описанные далее, отличаются от других операций с "
"фьютексами в том, что они следуют политике использования значения слова "
"фьютекса:"

#. type: Plain text
#: man-pages/man2/futex.2:872
msgid "If the lock is not acquired, the futex word's value shall be 0."
msgstr ""
"Если блокировка не получена, то значение слова фьютекса должно быть равно 0."

#. type: Plain text
#: man-pages/man2/futex.2:878
msgid ""
"If the lock is acquired, the futex word's value shall be the thread ID (TID; "
"see B<gettid>(2))  of the owning thread."
msgstr ""
"Если блокировка получена, то значение слова фьютекса должно быть равно ID "
"нити (TID; смотрите B<gettid>(2)), которой оно принадлежит."

#. type: Plain text
#: man-pages/man2/futex.2:883
msgid ""
"If the lock is owned and there are threads contending for the lock, then the "
"B<FUTEX_WAITERS> bit shall be set in the futex word's value; in other words, "
"this value is:"
msgstr ""
"Если блокировка получена и есть претендующие на неё нити, то в значении "
"слова фьютекса должен быть установлен бит B<FUTEX_WAITERS>; иначе говоря, "
"это значение равно:"

#. type: Plain text
#: man-pages/man2/futex.2:885
#, no-wrap
msgid "    FUTEX_WAITERS | TID\n"
msgstr "    FUTEX_WAITERS | TID\n"

#. type: Plain text
#: man-pages/man2/futex.2:889
msgid ""
"(Note that is invalid for a PI futex word to have no owner and "
"B<FUTEX_WAITERS> set.)"
msgstr ""
"(заметим, что некорректное слово PI-фьютекса не имеет владельца и "
"B<FUTEX_WAITERS>)"

#. type: Plain text
#: man-pages/man2/futex.2:900
msgid ""
"With this policy in place, a user-space application can acquire an "
"unacquired lock or release a lock using atomic instructions executed in user "
"mode (e.g., a compare-and-swap operation such as I<cmpxchg> on the x86 "
"architecture).  Acquiring a lock simply consists of using compare-and-swap "
"to atomically set the futex word's value to the caller's TID if its previous "
"value was 0.  Releasing a lock requires using compare-and-swap to set the "
"futex word's value to 0 if the previous value was the expected TID."
msgstr ""
"С этой действующей политикой приложение пространства пользователя может "
"получить свободную блокировку или освободить блокировку с помощью атомарных "
"инструкций, выполняемых в пользовательском режиме (например, операцией "
"сравнение-и-обмен I<cmpxchg> на архитектуре x86). Получение блокировки "
"состоит просто из использования сравнения-и-обмена для атомарного изменения "
"значения слова фьютекса на TID вызывающего, если предыдущее значение было "
"равно 0. Для освобождения блокировки требуется использовать сравнение-и-"
"обмен для изменения значения слова фьютекса на 0, если предыдущее значение "
"равно ожидаемому TID."

#. type: Plain text
#: man-pages/man2/futex.2:911
msgid ""
"If a futex is already acquired (i.e., has a nonzero value), waiters must "
"employ the B<FUTEX_LOCK_PI> operation to acquire the lock.  If other threads "
"are waiting for the lock, then the B<FUTEX_WAITERS> bit is set in the futex "
"value; in this case, the lock owner must employ the B<FUTEX_UNLOCK_PI> "
"operation to release the lock."
msgstr ""
"Если фьютекс уже получен (т. е. имеет ненулевое значение), то ожидающие "
"должны применить операцию B<FUTEX_LOCK_PI> для получения блокировки. Если "
"другие нити ждут блокировку, то в значении фьютекса установлен бит "
"B<FUTEX_WAITERS>; в этом случае владелец блокировки должен применить "
"операцию B<FUTEX_UNLOCK_PI> для освобождения блокировки."

#. type: Plain text
#: man-pages/man2/futex.2:921
msgid ""
"In the cases where callers are forced into the kernel (i.e., required to "
"perform a B<futex>()  call), they then deal directly with a so-called RT-"
"mutex, a kernel locking mechanism which implements the required priority-"
"inheritance semantics.  After the RT-mutex is acquired, the futex value is "
"updated accordingly, before the calling thread returns to user space."
msgstr ""
"В случаях, когда вызывающие переходят в ядро (т. е., требуется выполнение "
"вызова B<futex>()), после этого они напрямую работают с так называемым RT-"
"мьютексом, механизмом блокировок ядра, которым реализована требуемая "
"семантика наследования приоритета. После получения RT-мьютекса, значение "
"фьютекса обновляется соответствующим образом, перед возврата вызывающей нити "
"в пространство пользователя."

#.  tglx (July 2015):
#.      If there are multiple waiters on a pi futex then a wake pi operation
#.      will wake the first waiter and hand over the lock to this waiter. This
#.      includes handing over the rtmutex which represents the futex in the
#.      kernel. The strict requirement is that the futex owner and the rtmutex
#.      owner must be the same, except for the update period which is
#.      serialized by the futex internal locking. That means the kernel must
#.      update the user-space value prior to returning to user space
#. type: Plain text
#: man-pages/man2/futex.2:938
msgid ""
"It is important to note that the kernel will update the futex word's value "
"prior to returning to user space.  (This prevents the possibility of the "
"futex word's value ending up in an invalid state, such as having an owner "
"but the value being 0, or having waiters but not having the B<FUTEX_WAITERS> "
"bit set.)"
msgstr ""
"Важно упомянуть, что ядро обновит значение слова фьютекса до возврата в "
"пространство пользователя (это предотвращает возможность попадания значения "
"слова фьютекса в некорректное состояние, такое, что имея владельца, значение "
"равно 0, или имея ожидающих, не установлен бит B<FUTEX_WAITERS>)."

#.  tglx (July 2015):
#.      The FUTEX_OWNER_DIED bit can also be set on uncontended futexes, where
#.      the kernel has no state associated. This happens via the robust futex
#.      mechanism. In that case the futex value will be set to
#.      FUTEX_OWNER_DIED. The robust futex mechanism is also available for non
#.      PI futexes.
#. type: Plain text
#: man-pages/man2/futex.2:957
msgid ""
"If a futex has an associated RT-mutex in the kernel (i.e., there are blocked "
"waiters)  and the owner of the futex/RT-mutex dies unexpectedly, then the "
"kernel cleans up the RT-mutex and hands it over to the next waiter.  This in "
"turn requires that the user-space value is updated accordingly.  To indicate "
"that this is required, the kernel sets the B<FUTEX_OWNER_DIED> bit in the "
"futex word along with the thread ID of the new owner.  User space can detect "
"this situation via the presence of the B<FUTEX_OWNER_DIED> bit and is then "
"responsible for cleaning up the stale state left over by the dead owner."
msgstr ""
"Если фьютекс связан с RT-мьютексом в ядре (т. е., есть заблокированные "
"ожидающие) и владелец фьютекса/RT-мьютекса неожиданно завершился, то ядро "
"очищает RT-мьютекс и передаёт его следующему ожидающему. Это, в свою "
"очередь, требует, чтобы значение в пользовательском пространстве было "
"изменено соответствующим образом. Для сообщения о необходимости этого ядро "
"изменяет бит B<FUTEX_OWNER_DIED> в слове фьютекса вместе со сменой ID нити "
"нового владельца. Пользовательское пространство может определить такую "
"ситуацию по установленному биту B<FUTEX_OWNER_DIED> и затем, соответствующим "
"образом, очистить устаревшее состояние, возникшее из-за закончившего работу "
"владельца."

#. type: Plain text
#: man-pages/man2/futex.2:962
msgid ""
"PI futexes are operated on by specifying one of the values listed below in "
"I<futex_op>.  Note that the PI futex operations must be used as paired "
"operations and are subject to some additional requirements:"
msgstr ""
"PI-фьютексы обрабатываются при указании в I<futex_op> одного из значений, "
"перечисленных далее. Заметим, что операции с PI-фьютексами должны "
"использовать попарно и учитывать некоторые дополнительные требования:"

#. type: Plain text
#: man-pages/man2/futex.2:973
msgid ""
"B<FUTEX_LOCK_PI> and B<FUTEX_TRYLOCK_PI> pair with B<FUTEX_UNLOCK_PI>.  "
"B<FUTEX_UNLOCK_PI> must be called only on a futex owned by the calling "
"thread, as defined by the value policy, otherwise the error B<EPERM> results."
msgstr ""
"Парой к операциям B<FUTEX_LOCK_PI> и B<FUTEX_TRYLOCK_PI> является "
"B<FUTEX_UNLOCK_PI>. Операция B<FUTEX_UNLOCK_PI> должна применяться только к "
"фьютексам, принадлежащим вызывающей нити, определённой значением политики, "
"или же возникнет ошибка B<EPERM>."

#. type: Plain text
#: man-pages/man2/futex.2:987
msgid ""
"B<FUTEX_WAIT_REQUEUE_PI> pairs with B<FUTEX_CMP_REQUEUE_PI>.  This must be "
"performed from a non-PI futex to a distinct PI futex (or the error B<EINVAL> "
"results).  Additionally, I<val> (the number of waiters to be woken) must be "
"1 (or the error B<EINVAL> results)."
msgstr ""
"Парой к операции B<FUTEX_WAIT_REQUEUE_PI> является B<FUTEX_CMP_REQUEUE_PI>. "
"Она должна применяться для перехода с не PI-фьютекса к PI-фьютексу (или "
"возникает ошибка B<EINVAL>). Также, I<val> (количество разбуживаемых "
"ожидающих) должно равняться 1 (или возникает ошибка B<EINVAL>)."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:992
msgid "The PI futex operations are as follows:"
msgstr "Операции с PI-фьютексами:"

#. type: TP
#: man-pages/man2/futex.2:992
#, no-wrap
msgid "B<FUTEX_LOCK_PI> (since Linux 2.6.18)"
msgstr "B<FUTEX_LOCK_PI> (начиная с Linux 2.6.18)"

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:999
msgid ""
"This operation is used after an attempt to acquire the lock via an atomic "
"user-mode instruction failed because the futex word has a nonzero value"
"\\(emspecifically, because it contained the (PID-namespace-specific) TID of "
"the lock owner."
msgstr ""
"Данная операция используется после  попытки получить блокировку через "
"атомарную инструкцию в пространстве пользователя, которая завершилась с "
"ошибкой из-за того, что слово фьютекса не равно нулю — содержит value"
"\\(emspecifically, because it contained the TID (PID в этом пространстве "
"имён) владельца блокировки."

#.  tglx (July 2015):
#.      The operation here is similar to the FUTEX_WAIT logic. When the user
#.      space atomic acquire does not succeed because the futex value was non
#.      zero, then the waiter goes into the kernel, takes the kernel internal
#.      lock and retries the acquisition under the lock. If the acquisition
#.      does not succeed either, then it sets the FUTEX_WAITERS bit, to signal
#.      the lock owner that it needs to go into the kernel. Here is the pseudo
#.      code:
#.      	lock(kernel_lock);
#.      retry:
#.      	/*
#.      	 * Owner might have unlocked in userspace before we
#.      	 * were able to set the waiter bit.
#.               */
#.              if (atomic_acquire(futex) == SUCCESS) {
#.      	   unlock(kernel_lock());
#.      	   return 0;
#.      	}
#.      	/*
#.      	 * Owner might have unlocked after the above atomic_acquire()
#.      	 * attempt.
#.      	 */
#.      	if (atomic_set_waiters_bit(futex) != SUCCESS)
#.      	   goto retry;
#.      	queue_waiter();
#.      	unlock(kernel_lock);
#.      	block();
#. type: Plain text
#: man-pages/man2/futex.2:1042
msgid ""
"The operation checks the value of the futex word at the address I<uaddr>.  "
"If the value is 0, then the kernel tries to atomically set the futex value "
"to the caller's TID.  If the futex word's value is nonzero, the kernel "
"atomically sets the B<FUTEX_WAITERS> bit, which signals the futex owner that "
"it cannot unlock the futex in user space atomically by setting the futex "
"value to 0.  After that, the kernel:"
msgstr ""
"Операция проверяет значение слова фьютекса по адресу I<uaddr>. Если значение "
"равно 0, то ядро пытается атомарно изменить слово фьютекса на TID "
"вызывающего. Если слово фьютекса не равно нулю, то ядро атомарно "
"устанавливает бит B<FUTEX_WAITERS>, который указывает владельцу фьютекса, "
"что он не может разблокировать фьютекс в пространстве пользователя атомарным "
"способом посредством установки значения фьюетекса в 0. После этого ядро:"

#. type: IP
#: man-pages/man2/futex.2:1043
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man2/futex.2:1045
msgid "Tries to find the thread which is associated with the owner TID."
msgstr "Пытается найти нить-владельца по TID."

#. type: IP
#: man-pages/man2/futex.2:1045
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man2/futex.2:1051
msgid ""
"Creates or reuses kernel state on behalf of the owner.  (If this is the "
"first waiter, there is no kernel state for this futex, so kernel state is "
"created by locking the RT-mutex and the futex owner is made the owner of the "
"RT-mutex.  If there are existing waiters, then the existing state is reused.)"
msgstr ""
"Создаёт или повторно использует состояние ядра от имени владельца (если это "
"первый ожидающий, то для этого фьютекса не состояния ядра, поэтому состояние "
"ядра создаётся блокировкой RT-мьютекса и владелец фьютекса становится "
"владельцем RT-мьютекса. Если ожидающие уже есть, то используется имеющееся "
"состояние)."

#. type: IP
#: man-pages/man2/futex.2:1051
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man2/futex.2:1054
msgid ""
"Attaches the waiter to the futex (i.e., the waiter is enqueued on the RT-"
"mutex waiter list)."
msgstr ""
"Присоединяет ожидающего к фьютексу (т. е., ожидающий ставится в очередь "
"списка ожидающих на основе RT-мьютекса)."

#.  August 2015:
#.      mtk: If the realm is restricted purely to SCHED_OTHER (SCHED_NORMAL)
#.           processes, does the nice value come into play also?
#.      tglx: No. SCHED_OTHER/NORMAL tasks are handled in FIFO order
#.  (i.e., task 1 blocks on lock A, held by task 2,
#.  while task 2 blocks on lock B, held by task 3)
#. type: Plain text
#: man-pages/man2/futex.2:1082
msgid ""
"If more than one waiter exists, the enqueueing of the waiter is in "
"descending priority order.  (For information on priority ordering, see the "
"discussion of the B<SCHED_DEADLINE>, B<SCHED_FIFO>, and B<SCHED_RR> "
"scheduling policies in B<sched>(7).)  The owner inherits either the waiter's "
"CPU bandwidth (if the waiter is scheduled under the B<SCHED_DEADLINE> "
"policy) or the waiter's priority (if the waiter is scheduled under the "
"B<SCHED_RR> or B<SCHED_FIFO> policy).  This inheritance follows the lock "
"chain in the case of nested locking and performs deadlock detection."
msgstr ""
"Если есть более одного ожидающего, то перестановка ожидающего в очередь "
"выполняется в порядке убывания приоритета (упорядочивание по приоритету "
"описано в разделе об алгоритмах планирования B<SCHED_DEADLINE>, "
"B<SCHED_FIFO> и B<SCHED_RR> в B<sched>(7)). Владелец наследует от ожидающего "
"пропускную способность ЦП (если ожидающий работает по алгоритму планирования "
"B<SCHED_DEADLINE>) или приоритет (если ожидающий работает по алгоритму "
"планирования B<SCHED_RR> или B<SCHED_FIFO>). При обнаружении вложенности "
"блокировки и клинча такое наследование распространяется по всей цепочке "
"блокировки."

#.  2016-07-07 response from Thomas Gleixner on LKML:
#.  From: Thomas Gleixner <tglx@linutronix.de>
#.  Date: 6 July 2016 at 20:57
#.  Subject: Re: futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op
#.  On Thu, 23 Jun 2016, Michael Kerrisk (man-pages) wrote:
#.  > On 06/23/2016 08:28 PM, Darren Hart wrote:
#.  > > And as a follow-on, what is the reason for FUTEX_LOCK_PI only using
#.  > > CLOCK_REALTIME? It seems reasonable to me that a user may want to wait a
#.  > > specific amount of time, regardless of wall time.
#.  >
#.  > Yes, that's another weird inconsistency.
#.  The reason is that phtread_mutex_timedlock() uses absolute timeouts based on
#.  CLOCK_REALTIME. glibc folks asked to make that the default behaviour back
#.  then when we added LOCK_PI.
#. type: Plain text
#: man-pages/man2/futex.2:1111
msgid ""
"The I<timeout> argument provides a timeout for the lock attempt.  If "
"I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout, measured against the B<CLOCK_REALTIME> clock.  If I<timeout> is "
"NULL, the operation will block indefinitely."
msgstr ""
"В аргументе I<timeout> задаётся время ожидания захвата блокировки. Если "
"I<timeout> равно NULL, то структура, на которую он указывает, определяет "
"абсолютное время ожидания, отсчитываемое по часам B<CLOCK_REALTIME>. Если "
"I<timeout> равно NULL, то операция может быть в блокировке неопределённо "
"долго."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1121
msgid "The I<uaddr2>, I<val>, and I<val3> arguments are ignored."
msgstr "Аргументы I<uaddr2>, I<val> и I<val3> игнорируются."

#. type: TP
#: man-pages/man2/futex.2:1121
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI> (since Linux 2.6.18)"
msgstr "B<FUTEX_TRYLOCK_PI> (начиная с Linux 2.6.18)"

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:1128
msgid ""
"This operation tries to acquire the lock at I<uaddr>.  It is invoked when a "
"user-space atomic acquire did not succeed because the futex word was not 0."
msgstr ""
"Эта операция пытается получить блокировку по адресу I<uaddr>. Она "
"вызывается, когда не удалось выполнить атомарное получение из "
"пользовательского пространства, так как слово фьютекса не равно 0."

#.  Paraphrasing a f2f conversation with Thomas Gleixner about the
#.  above point (Aug 2015): ###
#. 	There is a rare possibility of a race condition involving an
#. 	uncontended futex with no owner, but with waiters.  The
#. 	kernel-user-space contract is that if a futex is nonzero, you must
#. 	go into kernel.  The futex was owned by a task, and that task dies
#. 	but there are no waiters, so the futex value is non zero.
#. 	Therefore, the next locker has to go into the kernel,
#. 	so that the kernel has a chance to clean up. (CMXCH on zero
#. 	in user space would fail, so kernel has to clean up.)
#.  Darren Hart (Oct 2015):
#.      The trylock in the kernel has more state, so it can independently
#.      verify the  flags that userspace must trust implicitly.
#. type: Plain text
#: man-pages/man2/futex.2:1152
msgid ""
"Because the kernel has access to more state information than user space, "
"acquisition of the lock might succeed if performed by the kernel in cases "
"where the futex word (i.e., the state information accessible to use-space) "
"contains stale state (B<FUTEX_WAITERS> and/or B<FUTEX_OWNER_DIED>).  This "
"can happen when the owner of the futex died.  User space cannot handle this "
"condition in a race-free manner, but the kernel can fix this up and acquire "
"the futex."
msgstr ""
"Так как ядро имеет больший доступ к информации о состоянии, чем "
"пользовательское пространство, получение блокировки из ядра может "
"осуществиться, в случаях когда слово фьютекса (т. е., информация о состоянии "
"доступна из пользовательского пространства) устарело (B<FUTEX_WAITERS> и/или "
"B<FUTEX_OWNER_DIED>). Это может случиться, если владелец фьютекса неожиданно "
"завершился. Пользовательское пространство не может учесть это событие не "
"получив состязательности, но ядро может решить данную проблему и получить "
"блокировку."

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1163 man-pages/man2/futex.2:1186
msgid "The I<uaddr2>, I<val>, I<timeout>, and I<val3> arguments are ignored."
msgstr "Аргументы I<uaddr2>, I<val>, I<timeout> и I<val3> игнорируются."

#. type: TP
#: man-pages/man2/futex.2:1163
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI> (since Linux 2.6.18)"
msgstr "B<FUTEX_UNLOCK_PI> (начиная с Linux 2.6.18)"

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:1171
msgid ""
"This operation wakes the top priority waiter that is waiting in "
"B<FUTEX_LOCK_PI> on the futex address provided by the I<uaddr> argument."
msgstr ""
"Данная операция будит ожидающего с самым высоким приоритетом, который ждёт "
"фьютекс по адресу из I<uaddr> посредством операции B<FUTEX_LOCK_PI>."

#. type: Plain text
#: man-pages/man2/futex.2:1175
msgid ""
"This is called when the user-space value at I<uaddr> cannot be changed "
"atomically from a TID (of the owner) to 0."
msgstr ""
"Операция вызывается, когда значение по адресу I<uaddr> пользовательского "
"пространства невозможно изменить атомарно с TID (владельца) на 0."

#. type: TP
#: man-pages/man2/futex.2:1186
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI> (since Linux 2.6.31)"
msgstr "B<FUTEX_CMP_REQUEUE_PI> (начиная с Linux 2.6.31)"

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: man-pages/man2/futex.2:1199
msgid ""
"This operation is a PI-aware variant of B<FUTEX_CMP_REQUEUE>.  It requeues "
"waiters that are blocked via B<FUTEX_WAIT_REQUEUE_PI> on I<uaddr> from a non-"
"PI source futex (I<uaddr>)  to a PI target futex (I<uaddr2>)."
msgstr ""
"Данная операция является PI-аналогом операции B<FUTEX_CMP_REQUEUE>. Она "
"перестанавливает ожидающих, заблокированных с помощью "
"B<FUTEX_WAIT_REQUEUE_PI> для I<uaddr>, из очереди не PI-фьютекса источника "
"(I<uaddr>) в очередь PI-фьютекса назначения (I<uaddr2>)."

#. type: Plain text
#: man-pages/man2/futex.2:1215
msgid ""
"As with B<FUTEX_CMP_REQUEUE>, this operation wakes up a maximum of I<val> "
"waiters that are waiting on the futex at I<uaddr>.  However, for "
"B<FUTEX_CMP_REQUEUE_PI>, I<val> is required to be 1 (since the main point is "
"to avoid a thundering herd).  The remaining waiters are removed from the "
"wait queue of the source futex at I<uaddr> and added to the wait queue of "
"the target futex at I<uaddr2>."
msgstr ""
"Как и B<FUTEX_CMP_REQUEUE>, эта операция пробуждает не более I<val> "
"ожидающих, которые ждут фьютекса по адресу I<uaddr>. Однако у "
"B<FUTEX_CMP_REQUEUE_PI> значение I<val> должно быть равно 1 (чтобы избежать "
"«нашествия орды»). Оставшиеся ожидающие удаляются из очереди ожидания "
"фьютекса-источника по адресу I<uaddr> и добавляются в очередь ожидания "
"фьютекса-назначения по адресу I<uaddr2>."

#.  val2 is the cap on the number of requeued waiters.
#.  In the glibc pthread_cond_broadcast() implementation, this argument
#.  is specified as INT_MAX, and for pthread_cond_signal() it is 0.
#.        The page at http://locklessinc.com/articles/futex_cheat_sheet/
#.        notes that "priority-inheritance Futex to priority-inheritance
#.        Futex requeues are currently unsupported". However, probably
#.        the page does not need to say nothing about this, since
#.        Thomas Gleixner commented (July 2015): "they never will be
#.        supported because they make no sense at all"
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1235
msgid ""
"The I<val2> and I<val3> arguments serve the same purposes as for "
"B<FUTEX_CMP_REQUEUE>."
msgstr ""
"Аргументы I<val2> и I<val3> служат тем же целям, что и в "
"B<FUTEX_CMP_REQUEUE>."

#. type: TP
#: man-pages/man2/futex.2:1235
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI> (since Linux 2.6.31)"
msgstr "B<FUTEX_WAIT_REQUEUE_PI> (начиная с Linux 2.6.31)"

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: man-pages/man2/futex.2:1249
msgid ""
"Wait on a non-PI futex at I<uaddr> and potentially be requeued (via a "
"B<FUTEX_CMP_REQUEUE_PI> operation in another task) onto a PI futex at "
"I<uaddr2>.  The wait operation on I<uaddr> is the same as for B<FUTEX_WAIT>."
msgstr ""
"Ждать не PI-фьютекса по адресу I<uaddr> и, потенциально быть перемещённым в "
"очередь (при операции B<FUTEX_CMP_REQUEUE_PI> из другой задачи) PI-фьютекса "
"по адресу I<uaddr2>. Операция ожидания на адресе I<uaddr> такая же как для "
"B<FUTEX_WAIT>."

#. type: Plain text
#: man-pages/man2/futex.2:1261
msgid ""
"The waiter can be removed from the wait on I<uaddr> without requeueing on "
"I<uaddr2> via a B<FUTEX_WAKE> operation in another task.  In this case, the "
"B<FUTEX_WAIT_REQUEUE_PI> operation fails with the error B<EAGAIN>."
msgstr ""
"Ожидающий может быть удалён из ожидающих на адресе I<uaddr> перемещения в "
"очередь у I<uaddr2> при операции B<FUTEX_WAKE> из другой задачи. В этом "
"случае операция B<FUTEX_WAIT_REQUEUE_PI> завершается с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/futex.2:1273
msgid "The I<val3> argument is ignored."
msgstr "Аргумент I<val3> игнорируется."

#.  Darren Hart notes that a patch to allow glibc to fully support
#.  PI-aware pthreads condition variables has not yet been accepted into
#.  glibc. The story is complex, and can be found at
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11588
#.  Darren notes that in the meantime, the patch is shipped with various
#.  PREEMPT_RT-enabled Linux systems.
#.  Related to the preceding, Darren proposed that somewhere, man-pages
#.  should document the following point:
#.      While the Linux kernel, since 2.6.31, supports requeueing of
#.      priority-inheritance (PI) aware mutexes via the
#.      FUTEX_WAIT_REQUEUE_PI and FUTEX_CMP_REQUEUE_PI futex operations,
#.      the glibc implementation does not yet take full advantage of this.
#.      Specifically, the condvar internal data lock remains a non-PI aware
#.      mutex, regardless of the type of the pthread_mutex associated with
#.      the condvar. This can lead to an unbounded priority inversion on
#.      the internal data lock even when associating a PI aware
#.      pthread_mutex with a condvar during a pthread_cond*_wait
#.      operation. For this reason, it is not recommended to rely on
#.      priority inheritance when using pthread condition variables.
#.  The problem is that the obvious location for this text is
#.  the pthread_cond*wait(3) man page. However, such a man page
#.  does not currently exist.
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1317
msgid ""
"The B<FUTEX_WAIT_REQUEUE_PI> and B<FUTEX_CMP_REQUEUE_PI> were added to "
"support a fairly specific use case: support for priority-inheritance-aware "
"POSIX threads condition variables.  The idea is that these operations should "
"always be paired, in order to ensure that user space and the kernel remain "
"in sync.  Thus, in the B<FUTEX_WAIT_REQUEUE_PI> operation, the user-space "
"application pre-specifies the target of the requeue that takes place in the "
"B<FUTEX_CMP_REQUEUE_PI> operation."
msgstr ""
"Операции B<FUTEX_WAIT_REQUEUE_PI> и B<FUTEX_CMP_REQUEUE_PI> добавлены для "
"довольно узкого варианта применения — поддержки переменных условия нитей "
"POSIX с наследованием приоритета. Идея в том, что эти операции всегда должны "
"использоваться попарно, для поддержания синхронизации между пользовательским "
"пространством и ядром. То есть в операции B<FUTEX_WAIT_REQUEUE_PI> "
"приложение пользовательского пространства заранее задаёт назначение для "
"перемещения в очередь, которое проводится операцией B<FUTEX_CMP_REQUEUE_PI>."

#. type: Plain text
#: man-pages/man2/futex.2:1326
msgid ""
"In the event of an error (and assuming that B<futex>()  was invoked via "
"B<syscall>(2)), all operations return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr ""
"В случае ошибки (предполагается, что B<futex>() был вызван через "
"B<syscall>(2)), все операции возвращают -1 и присваивают I<errno> номер "
"ошибки."

#. type: Plain text
#: man-pages/man2/futex.2:1329
msgid ""
"The return value on success depends on the operation, as described in the "
"following list:"
msgstr "При успешном выполнении возвращаемое значение зависит от операции:"

#. type: TP
#: man-pages/man2/futex.2:1329
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr "B<FUTEX_WAIT>"

#. type: Plain text
#: man-pages/man2/futex.2:1340
msgid ""
"Returns 0 if the caller was woken up.  Note that a wake-up can also be "
"caused by common futex usage patterns in unrelated code that happened to "
"have previously used the futex word's memory location (e.g., typical futex-"
"based implementations of Pthreads mutexes can cause this under some "
"conditions).  Therefore, callers should always conservatively assume that a "
"return value of 0 can mean a spurious wake-up, and use the futex word's "
"value (i.e., the user-space synchronization scheme)  to decide whether to "
"continue to block or not."
msgstr ""
"Значение 0 возвращается, если вызывающий был разбужен. Заметим, что "
"пробуждение также может быть вызвано часто используемыми вариантами "
"использования фьютексов в не связанном коде, которое случается, если память "
"под слово фьютекса использовалась ранее (например, при типичной реализации "
"фьютексов на основе мьютексов Pthreads это может возникать при определённых "
"условиях). Поэтому вызывающий всегда должен консервативно предполагать, что "
"возвращаемое значение 0 может означать побочное пробуждение (spurious wake-"
"up), и учитывать значение слово фьютекса (т. е. схема с синхронизацией "
"пользовательского пространства) при принятии решения нужна дальнейшее "
"ожидание или нет."

#. type: TP
#: man-pages/man2/futex.2:1340
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr "B<FUTEX_WAKE>"

#. type: Plain text
#: man-pages/man2/futex.2:1343 man-pages/man2/futex.2:1349
#: man-pages/man2/futex.2:1376
msgid "Returns the number of waiters that were woken up."
msgstr "Возвращается количество разбуженных ожидающих."

#. type: TP
#: man-pages/man2/futex.2:1343
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr "B<FUTEX_FD>"

#. type: Plain text
#: man-pages/man2/futex.2:1346
msgid "Returns the new file descriptor associated with the futex."
msgstr "Возвращается новый файловый дескриптор, связанный с фьютексом."

#. type: TP
#: man-pages/man2/futex.2:1346
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr "B<FUTEX_REQUEUE>"

#. type: TP
#: man-pages/man2/futex.2:1349
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr "B<FUTEX_CMP_REQUEUE>"

#. type: Plain text
#: man-pages/man2/futex.2:1359
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then the difference is the number of waiters requeued to the futex "
"for the futex word at I<uaddr2>."
msgstr ""
"Возвращается общее количество ожидающих, которые будятся или перемещаются в "
"очередь фьютекса, у которого слово фьютекса задано по адресу I<uaddr2>. Если "
"это значение больше чем I<val>, то разница это количество ожидающих, "
"перемещённых в очередь фьютекса, у которого слово фьютекса задано по адресу "
"I<uaddr2>."

#. type: TP
#: man-pages/man2/futex.2:1359
#, no-wrap
msgid "B<FUTEX_WAKE_OP>"
msgstr "B<FUTEX_WAKE_OP>"

#. type: Plain text
#: man-pages/man2/futex.2:1367
msgid ""
"Returns the total number of waiters that were woken up.  This is the sum of "
"the woken waiters on the two futexes for the futex words at I<uaddr> and "
"I<uaddr2>."
msgstr ""
"Возвращается общее количество разбуженных ожидающих. Это сумма разбуженных "
"ожидающих у двух фьютексов для слов фьютексов по адресам I<uaddr> и "
"I<uaddr2>."

#. type: TP
#: man-pages/man2/futex.2:1367
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET>"
msgstr "B<FUTEX_WAIT_BITSET>"

#. type: Plain text
#: man-pages/man2/futex.2:1373
msgid ""
"Returns 0 if the caller was woken up.  See B<FUTEX_WAIT> for how to "
"interpret this correctly in practice."
msgstr ""
"Возвращается 0, если вызывающий был разбужен. Смотрите в описании "
"B<FUTEX_WAIT>, как это правильно учитывать на практике."

#. type: TP
#: man-pages/man2/futex.2:1373
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET>"
msgstr "B<FUTEX_WAKE_BITSET>"

#. type: TP
#: man-pages/man2/futex.2:1376
#, no-wrap
msgid "B<FUTEX_LOCK_PI>"
msgstr "B<FUTEX_LOCK_PI>"

#. type: Plain text
#: man-pages/man2/futex.2:1379 man-pages/man2/futex.2:1382
msgid "Returns 0 if the futex was successfully locked."
msgstr "Возвращается 0, если фьютекс был успешно заблокирован."

#. type: TP
#: man-pages/man2/futex.2:1379
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI>"
msgstr "B<FUTEX_TRYLOCK_PI>"

#. type: TP
#: man-pages/man2/futex.2:1382
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI>"
msgstr "B<FUTEX_UNLOCK_PI>"

#. type: Plain text
#: man-pages/man2/futex.2:1385
msgid "Returns 0 if the futex was successfully unlocked."
msgstr "Возвращается 0, если фьютекс был успешно разблокирован."

#. type: TP
#: man-pages/man2/futex.2:1385
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI>"
msgstr "B<FUTEX_CMP_REQUEUE_PI>"

#. type: Plain text
#: man-pages/man2/futex.2:1395
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then difference is the number of waiters requeued to the futex for "
"the futex word at I<uaddr2>."
msgstr ""
"Возвращается общее количество ожидающих, которые будятся или перемещаются в "
"очередь фьютекса, у которого слово фьютекса задано по адресу I<uaddr2>. Если "
"это значение больше чем I<val>, то разница это количество ожидающих, "
"перемещённых в очередь фьютекса, у которого слово фьютекса задано по адресу "
"I<uaddr2>."

#. type: TP
#: man-pages/man2/futex.2:1395
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI>"
msgstr "B<FUTEX_WAIT_REQUEUE_PI>"

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1403
msgid ""
"Returns 0 if the caller was successfully requeued to the futex for the futex "
"word at I<uaddr2>."
msgstr ""
"Возвращается 0, если вызывающий был успешно перемещён в очередь фьютекса со "
"словом фьютекса по адресу I<uaddr2>."

#. type: TP
#: man-pages/man2/futex.2:1404
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/futex.2:1407
msgid "No read access to the memory of a futex word."
msgstr "Нет доступа на чтение памяти слова фьютекса."

#. type: Plain text
#: man-pages/man2/futex.2:1417
msgid ""
"(B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, B<FUTEX_WAIT_REQUEUE_PI>)  The value "
"pointed to by I<uaddr> was not equal to the expected value I<val> at the "
"time of the call."
msgstr ""
"(B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, B<FUTEX_WAIT_REQUEUE_PI>) Значение, на "
"которое указывает I<uaddr>, не было равно ожидаемому значению I<val> на "
"момент вызова."

#. type: Plain text
#: man-pages/man2/futex.2:1425
msgid ""
"B<Note>: on Linux, the symbolic names B<EAGAIN> and B<EWOULDBLOCK> (both of "
"which appear in different parts of the kernel futex code)  have the same "
"value."
msgstr ""
"B<Замечание>: в Linux символические имена B<EAGAIN> и B<EWOULDBLOCK> (оба "
"есть в разных частях кода фьютекса ядра) имеют одинаковое значение."

#. type: Plain text
#: man-pages/man2/futex.2:1433
msgid ""
"(B<FUTEX_CMP_REQUEUE>, B<FUTEX_CMP_REQUEUE_PI>)  The value pointed to by "
"I<uaddr> is not equal to the expected value I<val3>."
msgstr ""
"(B<FUTEX_CMP_REQUEUE>, B<FUTEX_CMP_REQUEUE_PI>) Значение, на которое "
"указывает I<uaddr>, не равно ожидаемому значению I<val3>."

#. type: Plain text
#: man-pages/man2/futex.2:1446
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"owner thread ID of I<uaddr> (for B<FUTEX_CMP_REQUEUE_PI>: I<uaddr2>)  is "
"about to exit, but has not yet handled the internal state cleanup.  Try "
"again."
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>) ID нити "
"владельца фьютекса по адресу I<uaddr> (для B<FUTEX_CMP_REQUEUE_PI> — "
"I<uaddr2>) вскоре закончит работу, но не выполнил очистку внутреннего "
"состояния. Попробуйте ещё раз."

#. type: TP
#: man-pages/man2/futex.2:1446 man-pages/man2/futex.2:1454
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
#: man-pages/man2/futex.2:1454
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"word at I<uaddr> is already locked by the caller."
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>) Слово "
"фьютекса по адресу I<uaddr> уже заблокировано вызывающим."

#.  FIXME . I see that kernel/locking/rtmutex.c uses EDEADLK in some
#.        places, and EDEADLOCK in others. On almost all architectures
#.        these constants are synonymous. Is there a reason that both
#.        names are used?
#.        tglx (July 2015): "No. We should probably fix that."
#. type: Plain text
#: man-pages/man2/futex.2:1467
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  While requeueing a waiter to the PI futex for the "
"futex word at I<uaddr2>, the kernel detected a deadlock."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Во время перемещения в другую очередь ожидающего "
"PI-фьютекса со словом фьютекса по адресу I<uaddr2> ядро обнаружило тупиковую "
"блокировку (deadlock)."

#. type: TP
#: man-pages/man2/futex.2:1467
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/futex.2:1475
msgid ""
"A required pointer argument (i.e., I<uaddr>, I<uaddr2>, or I<timeout>)  did "
"not point to a valid user-space address."
msgstr ""
"Требуемый аргумент указателя (т. е., I<uaddr>, I<uaddr2> или I<timeout>) не "
"указывает на допустимый адрес пользовательского пространства."

#. type: TP
#: man-pages/man2/futex.2:1475
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/futex.2:1485
msgid ""
"A B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> operation was interrupted by a "
"signal (see B<signal>(7)).  In kernels before Linux 2.6.22, this error could "
"also be returned for a spurious wakeup; since Linux 2.6.22, this no longer "
"happens."
msgstr ""
"Операция B<FUTEX_WAIT> или B<FUTEX_WAIT_BITSET> была прервана сигналом "
"(смотрите B<signal>(7)). В ядрах до версии Linux 2.6.22 эта ошибка также "
"возвращалась при побочном пробуждении; начиная с Linux 2.6.22 этого больше "
"не происходит."

#. type: Plain text
#: man-pages/man2/futex.2:1496
msgid ""
"The operation in I<futex_op> is one of those that employs a timeout, but the "
"supplied I<timeout> argument was invalid (I<tv_sec> was less than zero, or "
"I<tv_nsec> was not less than 1,000,000,000)."
msgstr ""
"Операция в I<futex_op> является одной из тех, что используют ожидание "
"(timeout), но значение аргумента I<timeout> некорректно (I<tv_sec> меньше "
"нуля или I<tv_nsec> больше 1000000000)."

#. type: Plain text
#: man-pages/man2/futex.2:1506
msgid ""
"The operation specified in I<futex_op> employs one or both of the pointers "
"I<uaddr> and I<uaddr2>, but one of these does not point to a valid object"
"\\(emthat is, the address is not four-byte-aligned."
msgstr ""
"Операция, указанная в I<futex_op>, использует один или оба указателя "
"I<uaddr> и I<uaddr2>, но один из них не указывает на корректный объект, то "
"есть адрес не выровнен по четырёх байтовой границе."

#. type: Plain text
#: man-pages/man2/futex.2:1513
msgid ""
"(B<FUTEX_WAIT_BITSET>, B<FUTEX_WAKE_BITSET>)  The bit mask supplied in "
"I<val3> is zero."
msgstr ""
"(B<FUTEX_WAIT_BITSET>, B<FUTEX_WAKE_BITSET>) Битовая маска, указанная в "
"I<val3>, равна нулю."

#. type: Plain text
#: man-pages/man2/futex.2:1520
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  I<uaddr> equals I<uaddr2> (i.e., an attempt was "
"made to requeue to the same futex)."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Значение I<uaddr> равно I<uaddr2> (т. е., "
"предпринята попытка выполнить перемещение в одну и ту же очередь)."

#. type: Plain text
#: man-pages/man2/futex.2:1526
msgid "(B<FUTEX_FD>)  The signal number supplied in I<val> is invalid."
msgstr "(B<FUTEX_FD>) В I<val> указан некорректный номер сигнала."

#. type: Plain text
#: man-pages/man2/futex.2:1539
msgid ""
"(B<FUTEX_WAKE>, B<FUTEX_WAKE_OP>, B<FUTEX_WAKE_BITSET>, B<FUTEX_REQUEUE>, "
"B<FUTEX_CMP_REQUEUE>)  The kernel detected an inconsistency between the user-"
"space state at I<uaddr> and the kernel state\\(emthat is, it detected a "
"waiter which waits in B<FUTEX_LOCK_PI> on I<uaddr>."
msgstr ""
"(B<FUTEX_WAKE>, B<FUTEX_WAKE_OP>, B<FUTEX_WAKE_BITSET>, B<FUTEX_REQUEUE>, "
"B<FUTEX_CMP_REQUEUE>) Ядро обнаружило противоречие между состояние в "
"пользовательском пространстве по адресу I<uaddr> и состоянием в ядре, то "
"есть обнаружило, что ожидающий ждёт посредством операции B<FUTEX_LOCK_PI> на "
"адресе I<uaddr>."

#. type: Plain text
#: man-pages/man2/futex.2:1554
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>)  The kernel "
"detected an inconsistency between the user-space state at I<uaddr> and the "
"kernel state.  This indicates either state corruption or that the kernel "
"found a waiter on I<uaddr> which is waiting via B<FUTEX_WAIT> or "
"B<FUTEX_WAIT_BITSET>."
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>) Ядро обнаружило "
"противоречие между состояние в пользовательском пространстве по адресу "
"I<uaddr> и состоянием в ядре. Это указывает на поврежденное значение "
"состояния или что ядро обнаружило ожидающего на адресе I<uaddr>, который "
"делает это посредством операции B<FUTEX_WAIT> или B<FUTEX_WAIT_BITSET>."

#.  From a conversation with Thomas Gleixner (Aug 2015): ###
#. 	The kernel sees: I have non PI state for a futex you tried to
#.      tell me was PI
#. type: Plain text
#: man-pages/man2/futex.2:1569
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr2> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> on "
"I<uaddr2>."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Ядро обнаружило противоречие между состояние в "
"пользовательском пространстве по адресу I<uaddr2> и состоянием в ядре, то "
"есть обнаружило, что ожидающий ждёт посредством операции B<FUTEX_WAIT> или "
"B<FUTEX_WAIT_BITSET> на адресе I<uaddr2>."

#. type: Plain text
#: man-pages/man2/futex.2:1581
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITESET> on "
"I<uaddr>."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Ядро обнаружило противоречие между состояние в "
"пользовательском пространстве по адресу I<uaddr> и состоянием в ядре, то "
"есть обнаружило, что ожидающий ждёт посредством операции B<FUTEX_WAIT> или "
"B<FUTEX_WAIT_BITESET> на адресе I<uaddr>."

#. type: Plain text
#: man-pages/man2/futex.2:1593
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits on I<uaddr> via B<FUTEX_LOCK_PI> (instead of "
"B<FUTEX_WAIT_REQUEUE_PI>)."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Ядро обнаружило противоречие между состояние в "
"пользовательском пространстве по адресу I<uaddr> и состоянием в ядре, то "
"есть обнаружило, что ожидающий ждёт посредством операции B<FUTEX_LOCK_PI> на "
"адресе I<uaddr> (вместо B<FUTEX_WAIT_REQUEUE_PI>)."

#.  This deals with the case:
#.      wait_requeue_pi(A, B);
#.      requeue_pi(A, C);
#. type: Plain text
#: man-pages/man2/futex.2:1603
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  An attempt was made to requeue a waiter to a "
"futex other than that specified by the matching B<FUTEX_WAIT_REQUEUE_PI> "
"call for that waiter."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Предпринята попытка выполнить перемещение "
"ожидающего на фьютекс, отличный от указанного в соответствующем вызове "
"B<FUTEX_WAIT_REQUEUE_PI> для этого вызывающего."

#. type: Plain text
#: man-pages/man2/futex.2:1609
msgid "(B<FUTEX_CMP_REQUEUE_PI>)  The I<val> argument is not 1."
msgstr "(B<FUTEX_CMP_REQUEUE_PI>) Значение аргумента I<val> не равно 1."

#. type: Plain text
#: man-pages/man2/futex.2:1612
msgid "Invalid argument."
msgstr "Неверный аргумент."

#. type: Plain text
#: man-pages/man2/futex.2:1616
msgid ""
"(B<FUTEX_FD>)  The system-wide limit on the total number of open files has "
"been reached."
msgstr ""
"(B<FUTEX_FD>) Достигнуто ограничение на общее количество открытых файлов в "
"системе."

#. type: Plain text
#: man-pages/man2/futex.2:1622
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The kernel "
"could not allocate memory to hold state information."
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>) Ядро не "
"может выделить память для хранения информации о состоянии."

#. type: Plain text
#: man-pages/man2/futex.2:1626
msgid "Invalid operation specified in I<futex_op>."
msgstr "В I<futex_op> задана неверная операция."

#. type: Plain text
#: man-pages/man2/futex.2:1637
msgid ""
"The B<FUTEX_CLOCK_REALTIME> option was specified in I<futex_op>, but the "
"accompanying operation was neither B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, nor "
"B<FUTEX_WAIT_REQUEUE_PI>."
msgstr ""
"В I<futex_op> был указан параметр B<FUTEX_CLOCK_REALTIME>, но сопутствующая "
"операция не равна B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET> или "
"B<FUTEX_WAIT_REQUEUE_PI>."

#. type: Plain text
#: man-pages/man2/futex.2:1647
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>, "
"B<FUTEX_CMP_REQUEUE_PI>, B<FUTEX_WAIT_REQUEUE_PI>)  A run-time check "
"determined that the operation is not available.  The PI-futex operations are "
"not implemented on all architectures and are not supported on some CPU "
"variants."
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>, "
"B<FUTEX_CMP_REQUEUE_PI>, B<FUTEX_WAIT_REQUEUE_PI>) Проверка во время "
"выполнения обнаружила, что операция недоступна. Операции с PI-фьютексами "
"реализованы не на всех архитектурах и не поддерживаются на некоторых моделях "
"ЦП."

#. type: Plain text
#: man-pages/man2/futex.2:1659
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The caller "
"is not allowed to attach itself to the futex at I<uaddr> (for "
"B<FUTEX_CMP_REQUEUE_PI>: the futex at I<uaddr2>).  (This may be caused by a "
"state corruption in user space.)"
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>) Вызывающему "
"запрещено самостоятельно присоединяться к фьютексу по адресу I<uaddr> (для "
"B<FUTEX_CMP_REQUEUE_PI>: фьютексу по адресу I<uaddr2>) (это может быть "
"вызвано повреждением состояния в пользовательском пространстве)."

#. type: Plain text
#: man-pages/man2/futex.2:1663
msgid ""
"(B<FUTEX_UNLOCK_PI>)  The caller does not own the lock represented by the "
"futex word."
msgstr ""
"(B<FUTEX_UNLOCK_PI>) Вызывающему не принадлежит блокировка, представленная в "
"слове фьютекса."

#. type: TP
#: man-pages/man2/futex.2:1663 man-pages/man2/futex.2:1671
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/futex.2:1671
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The thread "
"ID in the futex word at I<uaddr> does not exist."
msgstr ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>) "
"Идентификатор нити из слова фьютекса по адресу I<uaddr> не существует."

#. type: Plain text
#: man-pages/man2/futex.2:1677
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The thread ID in the futex word at I<uaddr2> does "
"not exist."
msgstr ""
"(B<FUTEX_CMP_REQUEUE_PI>) Идентификатор нити из слова фьютекса по адресу "
"I<uaddr2> не существует."

#. type: TP
#: man-pages/man2/futex.2:1677
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1687
msgid ""
"The operation in I<futex_op> employed the timeout specified in I<timeout>, "
"and the timeout expired before the operation completed."
msgstr ""
"Операция в I<futex_op> использует время ожидания, указанное в I<timeout>, и "
"время истекло до завершения операции."

#. type: Plain text
#: man-pages/man2/futex.2:1691
msgid ""
"Futexes were first made available in a stable kernel release with Linux "
"2.6.0."
msgstr "Фьютексы появились в стабильном ядре Linux версии 2.6.0."

#. type: Plain text
#: man-pages/man2/futex.2:1698
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A four-argument system call with the "
"semantics described in this page was introduced in Linux 2.5.40.  A fifth "
"argument was added in Linux 2.5.70, and a sixth argument was added in Linux "
"2.6.7."
msgstr ""
"Начальная поддержка фьютексов была встроена в Linux 2.5.7, но с другой "
"семантикой, отличающейся от описанной выше. Семантика системного вызова с "
"четырьмя аргументами, описанная в этой странице, появилась в Linux 2.5.40. "
"Пятый аргумент была добавлен в Linux 2.5.70, а шестой аргумент был добавлен "
"в Linux 2.6.7."

#. type: Plain text
#: man-pages/man2/futex.2:1700
msgid "This system call is Linux-specific."
msgstr "Данный системный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/futex.2:1703
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2)."

#.  TODO FIXME(Torvald) Above, we cite this section and claim it contains
#.  details on the synchronization semantics; add the C11 equivalents
#.  here (or whatever we find consensus for).
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1714
msgid ""
"Several higher-level programming abstractions are implemented via futexes, "
"including POSIX semaphores and various POSIX threads synchronization "
"mechanisms (mutexes, condition variables, read-write locks, and barriers)."
msgstr ""
"На основе фьютексов было реализовано несколько высокоуровневых программных "
"абстракций, например, семафоры POSIX и различные механизмы синхронизации "
"нитей POSIX (мьютексы, переменные условий, блокировки чтения-записи и "
"барьеры)."

#. type: Plain text
#: man-pages/man2/futex.2:1725
msgid ""
"The program below demonstrates use of futexes in a program where a parent "
"process and a child process use a pair of futexes located inside a shared "
"anonymous mapping to synchronize access to a shared resource: the terminal.  "
"The two processes each write I<nloops> (a command-line argument that "
"defaults to 5 if omitted)  messages to the terminal and employ a "
"synchronization protocol that ensures that they alternate in writing "
"messages.  Upon running this program we see output such as the following:"
msgstr ""
"В программе, показанной далее, показано использование фьютексов: "
"родительский и дочерний процессы используют пару фьютексов, расположенных в "
"общем анонимном отображении, для синхронизации доступа к общему ресурсу: "
"терминалу. Каждый из процессов записывает I<nloops> (аргумент командной "
"строки, если отсутствует, то 5) сообщений на терминал и использует протокол "
"синхронизации, который гарантирует, что они записываются поочерёдно. "
"Результат работы программы:"

#. type: Plain text
#: man-pages/man2/futex.2:1739
#, no-wrap
msgid ""
"$ B<./futex_demo>\n"
"Parent (18534) 0\n"
"Child  (18535) 0\n"
"Parent (18534) 1\n"
"Child  (18535) 1\n"
"Parent (18534) 2\n"
"Child  (18535) 2\n"
"Parent (18534) 3\n"
"Child  (18535) 3\n"
"Parent (18534) 4\n"
"Child  (18535) 4\n"
msgstr ""
"$ B<./futex_demo>\n"
"Родитель (18534) 0\n"
"Потомок  (18535) 0\n"
"Родитель (18534) 1\n"
"Потомок  (18535) 1\n"
"Родитель (18534) 2\n"
"Потомок  (18535) 2\n"
"Родитель (18534) 3\n"
"Потомок  (18535) 3\n"
"Родитель (18534) 4\n"
"Потомок  (18535) 4\n"

#. type: Plain text
#: man-pages/man2/futex.2:1745
#, no-wrap
msgid "/* futex_demo.c\n"
msgstr "/* futex_demo.c\n"

#. type: Plain text
#: man-pages/man2/futex.2:1748
#, no-wrap
msgid ""
"   Usage: futex_demo [nloops]\n"
"                    (Default: 5)\n"
msgstr ""
"   Использование: futex_demo [nloops]\n"
"                    (по умолчанию: 5)\n"

#. type: Plain text
#: man-pages/man2/futex.2:1767
#, no-wrap
msgid ""
"   Demonstrate the use of futexes in a program where parent and child\n"
"   use a pair of futexes located inside a shared anonymous mapping to\n"
"   synchronize access to a shared resource: the terminal. The two\n"
"   processes each write \\(aqnum-loops\\(aq messages to the terminal and employ\n"
"   a synchronization protocol that ensures that they alternate in\n"
"   writing messages.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdatomic.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/futex.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
msgstr ""
"   Продемонстрировано использование фьютексов в программе, где родитель\n"
"   и потомок используют пару фьютексов, расположенных в общем анонимном\n"
"   отображении, для синхронизации доступа к общему ресурсу: терминалу.\n"
"   Каждый из процессов записывает I<num-loops> на терминал и использует\n"
"   протокол синхронизации, который гарантирует, что они выполняют запись\n"
"   поочерёдно.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdatomic.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/futex.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/futex.2:1770
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: man-pages/man2/futex.2:1772
#, no-wrap
msgid "static int *futex1, *futex2, *iaddr;\n"
msgstr "static int *futex1, *futex2, *iaddr;\n"

#. type: Plain text
#: man-pages/man2/futex.2:1780
#, no-wrap
msgid ""
"static int\n"
"futex(int *uaddr, int futex_op, int val,\n"
"      const struct timespec *timeout, int *uaddr2, int val3)\n"
"{\n"
"    return syscall(SYS_futex, uaddr, futex_op, val,\n"
"                   timeout, uaddr, val3);\n"
"}\n"
msgstr ""
"static int\n"
"futex(int *uaddr, int futex_op, int val,\n"
"      const struct timespec *timeout, int *uaddr2, int val3)\n"
"{\n"
"    return syscall(SYS_futex, uaddr, futex_op, val,\n"
"                   timeout, uaddr, val3);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/futex.2:1783
#, no-wrap
msgid ""
"/* Acquire the futex pointed to by \\(aqfutexp\\(aq: wait for its value to\n"
"   become 1, and then set the value to 0. */\n"
msgstr ""
"/* Получить фьютекс, указанный \\(aqfutexp\\(aq: подождать пока его\n"
"   значение не станет 1, и изменить значение на 0. */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1788
#, no-wrap
msgid ""
"static void\n"
"fwait(int *futexp)\n"
"{\n"
"    int s;\n"
msgstr ""
"static void\n"
"fwait(int *futexp)\n"
"{\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man2/futex.2:1791
#, no-wrap
msgid ""
"    /* atomic_compare_exchange_strong(ptr, oldval, newval)\n"
"       atomically performs the equivalent of:\n"
msgstr ""
"    /* atomic_compare_exchange_strong(ptr, oldval, newval)\n"
"       атомарно выполняет эквивалент кода:\n"

#. type: Plain text
#: man-pages/man2/futex.2:1794
#, no-wrap
msgid ""
"           if (*ptr == *oldval)\n"
"               *ptr = newval;\n"
msgstr ""
"           if (*ptr == *oldval)\n"
"               *ptr = newval;\n"

#. type: Plain text
#: man-pages/man2/futex.2:1796
#, no-wrap
msgid "       It returns true if the test yielded true and *ptr was updated. */\n"
msgstr "       Она возвращает true, если тест вернул true и было обновлено *ptr.\n"

#. type: Plain text
#: man-pages/man2/futex.2:1798
#, no-wrap
msgid "    while (1) {\n"
msgstr "    while (1) {\n"

#. type: Plain text
#: man-pages/man2/futex.2:1803
#, no-wrap
msgid ""
"        /* Is the futex available? */\n"
"        const int zero = 0;\n"
"        if (atomic_compare_exchange_strong(futexp, &zero, 1))\n"
"            break;      /* Yes */\n"
msgstr ""
"        /* фьютекс доступен? */\n"
"        const int zero = 0;\n"
"        if (atomic_compare_exchange_strong(futexp, &zero, 1))\n"
"            break;      /* да */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1805
#, no-wrap
msgid "        /* Futex is not available; wait */\n"
msgstr "        /* фьютекс недоступен, ждём */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1811
#, no-wrap
msgid ""
"        s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);\n"
"        if (s == -1 && errno != EAGAIN)\n"
"            errExit(\"futex-FUTEX_WAIT\");\n"
"    }\n"
"}\n"
msgstr ""
"        s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);\n"
"        if (s == -1 && errno != EAGAIN)\n"
"            errExit(\"futex-FUTEX_WAIT\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/futex.2:1815
#, no-wrap
msgid ""
"/* Release the futex pointed to by \\(aqfutexp\\(aq: if the futex currently\n"
"   has the value 0, set its value to 1 and the wake any futex waiters,\n"
"   so that if the peer is blocked in fpost(), it can proceed. */\n"
msgstr ""
"/* Освобождаем фьютекс, указанный в \\(aqfutexp\\(aq: если значение фьютекса\n"
"   сейчас равно 0, то присваиваем ему 1 и пробуждаем ожидающий фьютекса,\n"
"   то есть, если вторая сторона заблокирована в fpost(), то она может\n"
"   продолжить работу. */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1820
#, no-wrap
msgid ""
"static void\n"
"fpost(int *futexp)\n"
"{\n"
"    int s;\n"
msgstr ""
"static void\n"
"fpost(int *futexp)\n"
"{\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man2/futex.2:1822
#, no-wrap
msgid "    /* atomic_compare_exchange_strong() was described in comments above */\n"
msgstr "    /* atomic_compare_exchange_strong() описан в комментария выше */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1830
#, no-wrap
msgid ""
"    const int one = 1;\n"
"    if (atomic_compare_exchange_strong(futexp, &one, 0)) {\n"
"        s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
"        if (s  == -1)\n"
"            errExit(\"futex-FUTEX_WAKE\");\n"
"    }\n"
"}\n"
msgstr ""
"    const int one = 1;\n"
"    if (atomic_compare_exchange_strong(futexp, &one, 0)) {\n"
"        s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
"        if (s  == -1)\n"
"            errExit(\"futex-FUTEX_WAKE\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/futex.2:1836
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t childPid;\n"
"    int j, nloops;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t childPid;\n"
"    int j, nloops;\n"

#. type: Plain text
#: man-pages/man2/futex.2:1838
#, no-wrap
msgid "    setbuf(stdout, NULL);\n"
msgstr "    setbuf(stdout, NULL);\n"

#. type: Plain text
#: man-pages/man2/futex.2:1840
#, no-wrap
msgid "    nloops = (argc E<gt> 1) ? atoi(argv[1]) : 5;\n"
msgstr "    nloops = (argc E<gt> 1) ? atoi(argv[1]) : 5;\n"

#. type: Plain text
#: man-pages/man2/futex.2:1845
#, no-wrap
msgid ""
"    /* Create a shared anonymous mapping that will hold the futexes.\n"
"       Since the futexes are being shared between processes, we\n"
"       subsequently use the \"shared\" futex operations (i.e., not the\n"
"       ones suffixed \"_PRIVATE\") */\n"
msgstr ""
"    /* Создаём общее анонимное отображение, в котором будем хранить\n"
"       фьютексы. Так как фьютексы совместно используются процессами,\n"
"       воспользуемся операциями с «общими» фьютексами (т. е., без\n"
"       суффикса «_PRIVATE»). */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1850
#, no-wrap
msgid ""
"    iaddr = mmap(NULL, sizeof(int) * 2, PROT_READ | PROT_WRITE,\n"
"                MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n"
"    if (iaddr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""
"    iaddr = mmap(NULL, sizeof(int) * 2, PROT_READ | PROT_WRITE,\n"
"                MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n"
"    if (iaddr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"

#. type: Plain text
#: man-pages/man2/futex.2:1853
#, no-wrap
msgid ""
"    futex1 = &iaddr[0];\n"
"    futex2 = &iaddr[1];\n"
msgstr ""
"    futex1 = &iaddr[0];\n"
"    futex2 = &iaddr[1];\n"

#. type: Plain text
#: man-pages/man2/futex.2:1856
#, no-wrap
msgid ""
"    *futex1 = 0;        /* State: unavailable */\n"
"    *futex2 = 1;        /* State: available */\n"
msgstr ""
"    *futex1 = 0;        /* Состояние: недоступен */\n"
"    *futex2 = 1;        /* Состояние: доступен */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1859
#, no-wrap
msgid ""
"    /* Create a child process that inherits the shared anonymous\n"
"       mapping */\n"
msgstr ""
"    /* Создаём дочерний процесс, который наследует общее анонимное\n"
"       отображение. */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1863
#, no-wrap
msgid ""
"    childPid = fork();\n"
"    if (childPid == -1)\n"
"        errExit(\"fork\");\n"
msgstr ""
"    childPid = fork();\n"
"    if (childPid == -1)\n"
"        errExit(\"fork\");\n"

#. type: Plain text
#: man-pages/man2/futex.2:1870
#, no-wrap
msgid ""
"    if (childPid == 0) {        /* Child */\n"
"        for (j = 0; j E<lt> nloops; j++) {\n"
"            fwait(futex1);\n"
"            printf(\"Child  (%ld) %d\\en\", (long) getpid(), j);\n"
"            fpost(futex2);\n"
"        }\n"
msgstr ""
"    if (childPid == 0) {        /* Child */\n"
"        for (j = 0; j E<lt> nloops; j++) {\n"
"            fwait(futex1);\n"
"            printf(\"Потомок  (%ld) %d\\en\", (long) getpid(), j);\n"
"            fpost(futex2);\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/futex.2:1873
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""
"        exit(EXIT_SUCCESS);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/futex.2:1875
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr "    /* предок попадает сюда */\n"

#. type: Plain text
#: man-pages/man2/futex.2:1881
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        fwait(futex2);\n"
"        printf(\"Parent (%ld) %d\\en\", (long) getpid(), j);\n"
"        fpost(futex1);\n"
"    }\n"
msgstr ""
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        fwait(futex2);\n"
"        printf(\"Родитель (%ld) %d\\en\", (long) getpid(), j);\n"
"        fpost(futex1);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/futex.2:1883
#, no-wrap
msgid "    wait(NULL);\n"
msgstr "    wait(NULL);\n"

#. type: Plain text
#: man-pages/man2/futex.2:1894
msgid ""
"B<get_robust_list>(2), B<restart_syscall>(2), "
"B<pthread_mutexattr_getprotocol>(3), B<futex>(7), B<sched>(7)"
msgstr ""
"B<get_robust_list>(2), B<restart_syscall>(2), "
"B<pthread_mutexattr_getprotocol>(3), B<futex>(7), B<sched>(7)"

#. type: Plain text
#: man-pages/man2/futex.2:1896
msgid "The following kernel source files:"
msgstr "Файлы из дерева исходного кода ядра:"

#. type: Plain text
#: man-pages/man2/futex.2:1898
msgid "I<Documentation/pi-futex.txt>"
msgstr "I<Documentation/pi-futex.txt>"

#. type: Plain text
#: man-pages/man2/futex.2:1900
msgid "I<Documentation/futex-requeue-pi.txt>"
msgstr "I<Documentation/futex-requeue-pi.txt>"

#. type: Plain text
#: man-pages/man2/futex.2:1902
msgid "I<Documentation/locking/rt-mutex.txt>"
msgstr "I<Documentation/locking/rt-mutex.txt>"

#. type: Plain text
#: man-pages/man2/futex.2:1904
msgid "I<Documentation/locking/rt-mutex-design.txt>"
msgstr "I<Documentation/locking/rt-mutex-design.txt>"

#. type: Plain text
#: man-pages/man2/futex.2:1906
msgid "I<Documentation/robust-futex-ABI.txt>"
msgstr "I<Documentation/robust-futex-ABI.txt>"

#. type: Plain text
#: man-pages/man2/futex.2:1910
msgid ""
"Franke, H., Russell, R., and Kirwood, M., 2002.  I<Fuss, Futexes and "
"Furwocks: Fast Userlevel Locking in Linux> (from proceedings of the Ottawa "
"Linux Symposium 2002),"
msgstr ""
"Franke, H., Russell, R., and Kirwood, M., 2002.  I<Fuss, Futexes and "
"Furwocks: Fast Userlevel Locking in Linux> (доклад на симпозиуме по Linux в "
"2002 году),"

#. type: Plain text
#: man-pages/man2/futex.2:1913
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"

#. type: Plain text
#: man-pages/man2/futex.2:1917
msgid ""
"Hart, D., 2009. I<A futex overview and update>, E<.UR http://lwn.net/"
"Articles/360699/> E<.UE>"
msgstr ""
"Hart, D., 2009. I<A futex overview and update>, E<.UR http://lwn.net/"
"Articles/360699/> E<.UE>"

#. type: Plain text
#: man-pages/man2/futex.2:1923
msgid ""
"Hart, D.\\& and Guniguntala, D., 2009.  I<Requeue-PI: Making Glibc Condvars "
"PI-Aware> (from proceedings of the 2009 Real-Time Linux Workshop), E<.UR "
"http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf> E<.UE>"
msgstr ""
"Hart, D.\\& и Guniguntala, D., 2009.  I<Requeue-PI: Making Glibc Condvars PI-"
"Aware> (доклад на Real-Time Linux Workshop в 2009 году), E<.UR http://lwn."
"net/images/conf/rtlws11/papers/proc/p10.pdf> E<.UE>"

#. type: Plain text
#: man-pages/man2/futex.2:1927
msgid ""
"Drepper, U., 2011. I<Futexes Are Tricky>, E<.UR http://www.akkadia.org/"
"drepper/futex.pdf> E<.UE>"
msgstr ""
"Drepper, U., 2011. I<Futexes Are Tricky>, E<.UR http://www.akkadia.org/"
"drepper/futex.pdf> E<.UE>"

#. type: Plain text
#: man-pages/man2/futex.2:1929
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr "Пример библиотеки futex, futex-*.tar.bz2, доступен на"

#. type: Plain text
#: man-pages/man2/futex.2:1931
msgid ""
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<."
"UE>"
msgstr ""
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> E<."
"UE>"

#. type: TH
#: man-pages/man2/futimesat.2:25
#, no-wrap
msgid "FUTIMESAT"
msgstr "FUTIMESAT"

#. type: Plain text
#: man-pages/man2/futimesat.2:29
msgid ""
"futimesat - change timestamps of a file relative to a directory file "
"descriptor"
msgstr ""
"futimesat - изменяет временные отметки файла, определяемого относительно "
"файлового дескриптора каталога"

#. type: Plain text
#: man-pages/man2/futimesat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt> /* определения констант AT_* */>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/futimesat.2:36
#, no-wrap
msgid ""
"B<int futimesat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timeval >I<times>B<[2]);>\n"
msgstr ""
"B<int futimesat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timeval >I<times>B<[2]);>\n"

#. type: Plain text
#: man-pages/man2/futimesat.2:41
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/futimesat.2:45
msgid "B<futimesat>(): _GNU_SOURCE"
msgstr "B<futimesat>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/futimesat.2:50
msgid "This system call is obsolete.  Use B<utimensat>(2)  instead."
msgstr ""
"Данный системный вызов устарел. Используйте вместо него B<utimensat>(2)."

#. type: Plain text
#: man-pages/man2/futimesat.2:56
msgid ""
"The B<futimesat>()  system call operates in exactly the same way as "
"B<utimes>(2), except for the differences described in this manual page."
msgstr ""
"Системный вызов B<futimesat>() работает также как системный вызов "
"B<utimes>(2), за исключением случаев, описанных в данной справочной странице."

#. type: Plain text
#: man-pages/man2/futimesat.2:66
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<utimes>(2)  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<utimes>(2))."

#. type: Plain text
#: man-pages/man2/futimesat.2:78
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<utimes>(2))."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<utimes>(2))."

#. type: Plain text
#: man-pages/man2/futimesat.2:84
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/futimesat.2:91
msgid ""
"On success, B<futimesat>()  returns a 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<futimesat>() возвращает 0; при ошибке \\(em -1, а "
"в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/futimesat.2:98
msgid ""
"The same errors that occur for B<utimes>(2)  can also occur for "
"B<futimesat>().  The following additional errors can occur for "
"B<futimesat>():"
msgstr ""
"В B<futimesat>() могут возникнуть те же ошибки, что и в B<utimes>(2). Также, "
"в B<futimesat>() могут возникнуть следующие ошибки:"

#. type: TP
#: man-pages/man2/futimesat.2:98
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/futimesat.2:102
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: TP
#: man-pages/man2/futimesat.2:102
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/futimesat.2:108
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/futimesat.2:112
msgid ""
"B<futimesat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Вызов B<futimesat>() был добавлен в ядро Linux версии 2.6.16; поддержка в "
"glibc доступна с версии 2.4."

#. type: Plain text
#: man-pages/man2/futimesat.2:117
msgid ""
"This system call is nonstandard.  It was implemented from a specification "
"that was proposed for POSIX.1, but that specification was replaced by the "
"one for B<utimensat>(2)."
msgstr ""
"Данный системный вызов не является стандартным. Он был реализован по "
"спецификации POSIX.1, но она была заменена на B<utimensat>(2)."

#. type: Plain text
#: man-pages/man2/futimesat.2:119
msgid "A similar system call exists on Solaris."
msgstr "Подобный системный вызов есть в Solaris."

#. type: SS
#: man-pages/man2/futimesat.2:120
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#.  The Solaris futimesat() also has this strangeness.
#. type: Plain text
#: man-pages/man2/futimesat.2:128
msgid ""
"If I<pathname> is NULL, then the glibc B<futimesat>()  wrapper function "
"updates the times for the file referred to by I<dirfd>."
msgstr ""
"Если I<pathname> равно NULL, то обёрточная функция glibc B<futimesat>() "
"обновляет временные метки файла, указанного в I<dirfd>."

#. type: Plain text
#: man-pages/man2/futimesat.2:133
msgid ""
"B<stat>(2), B<utimensat>(2), B<utimes>(2), B<futimes>(3), "
"B<path_resolution>(7)"
msgstr ""
"B<stat>(2), B<utimensat>(2), B<utimes>(2), B<futimes>(3), "
"B<path_resolution>(7)"

#. type: TH
#: man-pages/man2/flock.2:35
#, no-wrap
msgid "FLOCK"
msgstr "FLOCK"

#. type: Plain text
#: man-pages/man2/flock.2:38
msgid "flock - apply or remove an advisory lock on an open file"
msgstr ""
"flock - устанавливает или снимает консультативную (advisory) блокировку на "
"открытом файле"

#. type: Plain text
#: man-pages/man2/flock.2:40
msgid "B<#include E<lt>sys/file.hE<gt>>"
msgstr "B<#include E<lt>sys/file.hE<gt>>"

#. type: Plain text
#: man-pages/man2/flock.2:42
msgid "B<int flock(int >I<fd>B<, int >I<operation>B<);>"
msgstr "B<int flock(int >I<fd>B<, int >I<operation>B<);>"

#. type: Plain text
#: man-pages/man2/flock.2:48
msgid ""
"Apply or remove an advisory lock on the open file specified by I<fd>.  The "
"argument I<operation> is one of the following:"
msgstr ""
"Устанавливает или снимает консультативную блокировку на открытом файле, "
"указанном в I<fd>. Аргумент I<operation> может содержать одно из следующих "
"значений:"

#. type: TP
#: man-pages/man2/flock.2:49
#, no-wrap
msgid "B<LOCK_SH>"
msgstr "B<LOCK_SH>"

#. type: Plain text
#: man-pages/man2/flock.2:54
msgid ""
"Place a shared lock.  More than one process may hold a shared lock for a "
"given file at a given time."
msgstr ""
"Установить общую (shared) блокировку. Общую блокировку на заданный файл "
"может удерживать более чем один процесс."

#. type: TP
#: man-pages/man2/flock.2:54
#, no-wrap
msgid "B<LOCK_EX>"
msgstr "B<LOCK_EX>"

#. type: Plain text
#: man-pages/man2/flock.2:59
msgid ""
"Place an exclusive lock.  Only one process may hold an exclusive lock for a "
"given file at a given time."
msgstr ""
"Установить эксклюзивную (exclusive) блокировку. Только один процесс может "
"удерживать эксклюзивную блокировку файла."

#. type: TP
#: man-pages/man2/flock.2:59
#, no-wrap
msgid "B<LOCK_UN>"
msgstr "B<LOCK_UN>"

#. type: Plain text
#: man-pages/man2/flock.2:62
msgid "Remove an existing lock held by this process."
msgstr "Удалить существующую блокировку, удерживаемую данным процессом."

#. type: Plain text
#: man-pages/man2/flock.2:71
msgid ""
"A call to B<flock>()  may block if an incompatible lock is held by another "
"process.  To make a nonblocking request, include B<LOCK_NB> (by ORing)  with "
"any of the above operations."
msgstr ""
"Вызов B<flock>() может быть блокирован, если несовместимый тип блокировки "
"уже удерживается другим процессом. Чтобы выполнить неблокирующий запрос, "
"добавьте B<LOCK_NB> (через операцию ИЛИ) к одному из вышеописанных значений."

#. type: Plain text
#: man-pages/man2/flock.2:73
msgid ""
"A single file may not simultaneously have both shared and exclusive locks."
msgstr ""
"Один файл не может иметь одновременно и общую и эксклюзивную блокировку."

#. type: Plain text
#: man-pages/man2/flock.2:88
msgid ""
"Locks created by B<flock>()  are associated with an open file description "
"(see B<open>(2)).  This means that duplicate file descriptors (created by, "
"for example, B<fork>(2)  or B<dup>(2))  refer to the same lock, and this "
"lock may be modified or released using any of these file descriptors.  "
"Furthermore, the lock is released either by an explicit B<LOCK_UN> operation "
"on any of these duplicate file descriptors, or when all such file "
"descriptors have been closed."
msgstr ""
"Блокировки, созданные B<flock>(), ассоциируются с дескриптором открытого "
"файла (смотрите B<open>(2)). Это означает, что дублирующие файловые "
"дескрипторы (созданные, например, вызовами B<fork>(2) или B<dup>(2)) "
"указывают на одну блокировку, и эта блокировка может быть изменена или снята "
"при использовании любого из этих файловых дескрипторов. Также, блокировка "
"освобождается либо через явное выполнение операции B<LOCK_UN> на одном из "
"дублирующих файловых дескрипторов, либо когда все такие файловые дескрипторы "
"будут закрыты."

#. type: Plain text
#: man-pages/man2/flock.2:97
msgid ""
"If a process uses B<open>(2)  (or similar) to obtain more than one file "
"descriptor for the same file, these file descriptors are treated "
"independently by B<flock>().  An attempt to lock the file using one of these "
"file descriptors may be denied by a lock that the calling process has "
"already placed via another file descriptor."
msgstr ""
"Если процесс использует B<open>(2) (или подобный вызов) для получения более "
"одного файлового дескриптора на один и тот же файл, то эти файловые "
"дескрипторы считаются B<flock>() независимыми. Попытка заблокировать файл с "
"помощью одного из этих файловых дескрипторов может быть пресечена из-за "
"блокировки, которую вызывающий процесс уже установил через другой файловый "
"дескриптор."

#. type: Plain text
#: man-pages/man2/flock.2:104
msgid ""
"A process may hold only one type of lock (shared or exclusive)  on a file.  "
"Subsequent B<flock>()  calls on an already locked file will convert an "
"existing lock to the new lock mode."
msgstr ""
"Процесс может удерживать на файле только один из типов блокировки (общую или "
"эксклюзивную). Последующие вызовы B<flock>() на уже заблокированный файл "
"будут преобразовывать текущую блокировку к новому заданному режиму "
"блокировки."

#. type: Plain text
#: man-pages/man2/flock.2:109
msgid "Locks created by B<flock>()  are preserved across an B<execve>(2)."
msgstr ""
"Блокировки, созданные B<flock>(), сохраняются при выполнении B<execve>(2)."

#. type: Plain text
#: man-pages/man2/flock.2:112
msgid ""
"A shared or exclusive lock can be placed on a file regardless of the mode in "
"which the file was opened."
msgstr ""
"Общая или эксклюзивная блокировка может быть установлена на файл вне "
"зависимости от режима, в котором этот файл был открыт."

#. type: Plain text
#: man-pages/man2/flock.2:117
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/flock.2:122
msgid "I<fd> is not an open file descriptor."
msgstr "I<fd> не является открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man2/flock.2:127
msgid ""
"While waiting to acquire a lock, the call was interrupted by delivery of a "
"signal caught by a handler; see B<signal>(7)."
msgstr ""
"При ожидании получения блокировки вызов был прерван сигналом, пришедшим в "
"обработчик; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/flock.2:131
msgid "I<operation> is invalid."
msgstr "Неверное значение I<operation>."

#. type: TP
#: man-pages/man2/flock.2:131
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
#: man-pages/man2/flock.2:134
msgid "The kernel ran out of memory for allocating lock records."
msgstr "Ядру не хватило памяти для создания записи блокировки."

#. type: TP
#: man-pages/man2/flock.2:134
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: man-pages/man2/flock.2:139
msgid "The file is locked and the B<LOCK_NB> flag was selected."
msgstr "Файл блокирован и был указан флаг B<LOCK_NB>."

#. type: Plain text
#: man-pages/man2/flock.2:148
msgid ""
"4.4BSD (the B<flock>()  call first appeared in 4.2BSD).  A version of "
"B<flock>(), possibly implemented in terms of B<fcntl>(2), appears on most "
"UNIX systems."
msgstr ""
"4.4BSD (впервые вызов B<flock>() появился в 4.2BSD). Вызов B<flock>() есть в "
"большинстве систем UNIX, возможно реализованный с помощью B<fcntl>(2)."

#.  E.g., according to the flock(2) man page, FreeBSD since at least 5.3
#. type: Plain text
#: man-pages/man2/flock.2:171
msgid ""
"Since kernel 2.0, B<flock>()  is implemented as a system call in its own "
"right rather than being emulated in the GNU C library as a call to "
"B<fcntl>(2).  With this implementation, there is no interaction between the "
"types of lock placed by B<flock>()  and B<fcntl>(2), and B<flock>()  does "
"not detect deadlock.  (Note, however, that on some systems, such as the "
"modern BSDs, B<flock>()  and B<fcntl>(2)  locks I<do> interact with one "
"another.)"
msgstr ""
"Начиная с версии ядра 2.0, B<flock>() реализован как самостоятельный "
"системный вызов, а не как эмуляция в библиотеке GNU C с помощью B<fcntl>(2). "
"В этой реализации не существует никакого взаимодействия между типами "
"блокировок, устанавливаемыми B<flock>() и B<fcntl>(2), и B<flock>() не "
"обнаруживает взаимные блокировки (заметим, что в некоторых системах, таких "
"как современные BSD, вызовы B<flock>() и B<fcntl>(2) блокирующие, при "
"взаимодействии друг с другом)."

#. type: Plain text
#: man-pages/man2/flock.2:177
msgid ""
"B<flock>()  places advisory locks only; given suitable permissions on a "
"file, a process is free to ignore the use of B<flock>()  and perform I/O on "
"the file."
msgstr ""
"B<flock>() устанавливает только консультативные блокировки; имея "
"соответствующие права на файл, процесс может игнорировать использование "
"B<flock>() и выполнять над файлом операции ввода/вывода."

#. type: Plain text
#: man-pages/man2/flock.2:190
msgid ""
"B<flock>()  and B<fcntl>(2)  locks have different semantics with respect to "
"forked processes and B<dup>(2).  On systems that implement B<flock>()  using "
"B<fcntl>(2), the semantics of B<flock>()  will be different from those "
"described in this manual page."
msgstr ""
"B<flock>() и B<fcntl>(2) имеют разную семантику для порождённых процессов и "
"B<dup>(2). В системах, где реализован B<flock>() с помощью B<fcntl>(2), "
"семантика B<flock>() будет отличаться от описанной в данной справочной "
"странице."

#.  Kernel 2.5.21 changed things a little: during lock conversion
#.  it is now the highest priority process that will get the lock -- mtk
#. type: Plain text
#: man-pages/man2/flock.2:203
msgid ""
"Converting a lock (shared to exclusive, or vice versa) is not guaranteed to "
"be atomic: the existing lock is first removed, and then a new lock is "
"established.  Between these two steps, a pending lock request by another "
"process may be granted, with the result that the conversion either blocks, "
"or fails if B<LOCK_NB> was specified.  (This is the original BSD behavior, "
"and occurs on many other implementations.)"
msgstr ""
"При преобразовании блокировки (общую в эксклюзивную или наоборот) не "
"гарантируется атомарность операции: сначала существующая блокировка "
"удаляется, а затем устанавливается новая. Между этими двумя действиями "
"другой процесс, ожидающий запрос на блокировку,  может получить на неё "
"разрешение, в следствие чего преобразование или заблокируется, или "
"завершится неудачно, если был указан флаг B<LOCK_NB> (это оригинальное "
"поведение BSD встречается во многих других реализациях)."

#. type: SS
#: man-pages/man2/flock.2:203
#, no-wrap
msgid "NFS details"
msgstr "Особенности NFS"

#. type: Plain text
#: man-pages/man2/flock.2:213
msgid ""
"In Linux kernels up to 2.6.11, B<flock>()  does not lock files over NFS (i."
"e., the scope of locks was limited to the local system).  Instead, one could "
"use B<fcntl>(2)  byte-range locking, which does work over NFS, given a "
"sufficiently recent version of Linux and a server which supports locking."
msgstr ""
"В ядрах Linux вплоть до 2.6.11, B<flock>() не блокирует файлы через NFS (т. "
"е., охват блокировки ограничен локальной системой). Вместо этого можно "
"использовать байтовой диапазон блокировки B<fcntl>(2), который работает "
"через NFS; появился в сравнительно новой версии Linux и серверах, "
"поддерживающих блокировку."

#. type: Plain text
#: man-pages/man2/flock.2:228
msgid ""
"Since Linux 2.6.12, NFS clients support B<flock>()  locks by emulating them "
"as B<fcntl>(2)  byte-range locks on the entire file.  This means that "
"B<fcntl>(2)  and B<flock>()  locks I<do> interact with one another over "
"NFS.  It also means that in order to place an exclusive lock, the file must "
"be opened for writing."
msgstr ""
"Начиная с Linux 2.6.12, клиенты NFS поддерживают блокировки B<flock>(), "
"посредством эмуляции через байтовые диапазоны блокировок B<fcntl>(2) на весь "
"файл. Это означает, что блокировки B<fcntl>(2) и B<flock>() "
"I<взаимодействуют> друг с другом через NFS. Также это означает, что для "
"выполнения эксклюзивной блокировки файл должен быть открыт на запись."

#.  commit 5eebde23223aeb0ad2d9e3be6590ff8bbfab0fc2
#. type: Plain text
#: man-pages/man2/flock.2:240
msgid ""
"Since Linux 2.6.37, the kernel supports a compatibility mode that allows "
"B<flock>()  locks (and also B<fcntl>(2)  byte region locks) to be treated as "
"local; see the discussion of the I<local_lock> option in B<nfs>(5)."
msgstr ""
"Начиная с Linux 2.6.37, ядро поддерживает режим совместимости, позволяющий "
"считать блокировки B<flock>() (а также байтовые диапазоны блокировки "
"B<fcntl>(2)) локальными; смотрите описание параметра I<local_lock> в "
"B<nfs>(5)."

#. type: Plain text
#: man-pages/man2/flock.2:250
msgid ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3), B<lslocks>(8)"
msgstr ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3), B<lslocks>(8)"

#. type: Plain text
#: man-pages/man2/flock.2:254
msgid ""
"I<Documentation/filesystems/locks.txt> in the Linux kernel source tree "
"(I<Documentation/locks.txt> in older kernels)"
msgstr ""
"I<Documentation/filesystem/locks.txt> в исходном коде ядра Linux (в старых "
"ядрах — I<Documentation/locks.txt>)"

#. type: TH
#: man-pages/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr "FANOTIFY_MARK"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""
"fanotify_mark - добавляет, удаляет или изменяет метку fanotify для объекта "
"файловой системы"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr "B<#include E<lt>sys/fanotify.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<pathname>B<);>\n"
msgstr ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char *>I<pathname>B<);>\n"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr "Обзор программного интерфейса fanotify смотрите в B<fanotify>(7)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>()  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr ""
"Системный вызов B<fanotify_mark>() добавляет, удаляет или изменяет метку "
"fanotify для объекта файловой системы. Вызывающий должен иметь право на "
"чтение помеченного объекта файловой системы."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""
"Аргумент I<fanotify_fd> — файловый дескриптор, возвращаемый "
"B<fanotify_init>(2)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""
"Аргумент I<flags> — битовая маска, описывающая выполняемое изменение. Она "
"должна содержать только одно значение из:"

#. type: TP
#: man-pages/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr "B<FAN_MARK_ADD>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""
"События в I<mask> будут добавлены в маску меток (или в маску игнорирования). "
"Если значение I<mask> пусто, то возвращается ошибка B<EINVAL>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr "B<FAN_MARK_REMOVE>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""
"События в I<mask> будут удалены из маски меток (или маски игнорирования). "
"Если значение I<mask> пусто, то возвращается ошибка B<EINVAL>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr "B<FAN_MARK_FLUSH>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:94
msgid ""
"Remove either all marks for filesystems, all marks for mounts, or all marks "
"for directories and files from the fanotify group.  If I<flags> contains "
"B<FAN_MARK_MOUNT>, all marks for mounts are removed from the group.  If "
"I<flags> contains B<FAN_MARK_FILESYSTEM>, all marks for filesystems are "
"removed from the group.  Otherwise, all marks for directories and files are "
"removed.  No flag other than and at most one of the flags B<FAN_MARK_MOUNT> "
"or B<FAN_MARK_FILESYSTEM> can be used in conjunction with "
"B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgstr ""
"Удалить все метки файловых систем, все метки монтирований или все метки "
"каталогов и файлов из группы fanotify. Если в I<flags> содержится "
"B<FAN_MARK_MOUNT>, то все метки монтирований удаляются из группы. Если в "
"I<flags> содержится B<FAN_MARK_FILESYSTEM>, то все метки файловых систем "
"удаляются из группы. В противном случае удаляются все метки и каталогов и "
"файлов. Вместе с B<FAN_MARK_FLUSH> может быть указан только либо "
"B<FAN_MARK_MOUNT>, либо B<FAN_MARK_FILESYSTEM>.Значение I<mask> игнорируется."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:98
msgid ""
"If none of the values above is specified, or more than one is specified, the "
"call fails with the error B<EINVAL>."
msgstr ""
"Если не задано ни одно из этих значений, или указано больше одного, то вызов "
"завершается с ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:102
msgid ""
"In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr "Кроме этого в I<flags> могут быть указаны (побитовым сложением):"

#. type: TP
#: man-pages/man2/fanotify_mark.2:102
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr "B<FAN_MARK_DONT_FOLLOW>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:113
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""
"Если I<pathname> — символьная ссылка, то помечается сама ссылка, а не файл, "
"на который она ссылается (по умолчанию B<fanotify_mark>() разыменовывает "
"I<pathname>, если это символьная ссылка)."

#. type: TP
#: man-pages/man2/fanotify_mark.2:113
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr "B<FAN_MARK_ONLYDIR>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:118
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""
"Если объект файловой системы для пометки не является каталогом, то "
"возвращается ошибка B<ENOTDIR>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:118
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr "B<FAN_MARK_MOUNT>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:138
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself "
"a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will "
"be monitored.  This value cannot be used if the I<fanotify_fd> file "
"descriptor has been initialized with the flag B<FAN_REPORT_FID> or if any of "
"the new directory modification events are provided as a I<mask>.  Attempting "
"to do so will result in the error B<EINVAL> being returned."
msgstr ""
"Пометить точку монтирования, заданную в I<pathname>. Если само значение "
"I<pathname> не является точкой монтирования, то будет помечена точка "
"монтирования, которая содержит I<pathname>. Будут отслеживаться все "
"каталоги, подкаталоги и содержащиеся в точке монтирования файлы. Это "
"значение нельзя использовать, если файловый дескриптор I<fanotify_fd> "
"инициализирован с флагом B<FAN_REPORT_FID> или если в качестве маски I<mask> "
"указано любое событие изменения нового каталога. Результатом попытки это "
"сделать будет возврат ошибки B<EINVAL>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:138
#, no-wrap
msgid "B<FAN_MARK_FILESYSTEM> (since Linux 4.20)"
msgstr "B<FAN_MARK_FILESYSTEM> (начиная с Linux 4.20)"

#.  commit d54f4fba889b205e9cd8239182ca5d27d0ac3bc2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:148
msgid ""
"Mark the filesystem specified by I<pathname>.  The filesystem containing "
"I<pathname> will be marked.  All the contained files and directories of the "
"filesystem from any mount point will be monitored."
msgstr ""
"Пометить файловую систему, заданную в I<pathname>. Будет помечена файловая "
"система, содержащая I<pathname>. Будут отслеживаться все файлы и каталоги "
"файловой системы любой точки монтирования."

#. type: TP
#: man-pages/man2/fanotify_mark.2:148
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr "B<FAN_MARK_IGNORED_MASK>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:153
msgid ""
"The events in I<mask> shall be added to or removed from the ignore mask."
msgstr ""
"События в I<mask> должны быть добавлены или удалены из маски игнорирования."

#. type: TP
#: man-pages/man2/fanotify_mark.2:153
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr "B<FAN_MARK_IGNORED_SURV_MODIFY>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:159
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""
"Маска игнорирования должна остаться неизменной при событиях изменения. Если "
"этот флаг не указан, то маска игнорирования очищается при появлении событий "
"изменения игнорируемого файла или каталога."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:163
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""
"В I<mask> указывается какие события должны прослушиваться (или "
"игнорироваться). Данная битовая маска состоит из следующих значений:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:166
msgid ""
"Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""
"Создать событие при доступе (для чтения) к файлу или каталогу (но смотрите "
"ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:169
msgid "Create an event when a file is modified (write)."
msgstr "Создать событие при изменении (при записи) файла."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:172
msgid "Create an event when a writable file is closed."
msgstr "Создать событие при закрытии файла, открытого на запись."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:175
msgid "Create an event when a read-only file or directory is closed."
msgstr ""
"Создать событие при закрытии файла или каталога, открытого только для чтения."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:178
msgid "Create an event when a file or directory is opened."
msgstr "Создать событие при открытии файла или каталога."

#. type: TP
#: man-pages/man2/fanotify_mark.2:178
#, no-wrap
msgid "B<FAN_OPEN_EXEC> (since Linux 5.0)"
msgstr "B<FAN_OPEN_EXEC> (начиная с Linux 5.0)"

#.  commit 9b076f1c0f4869b838a1b7aa0edb5664d47ec8aa
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:183
msgid ""
"Create an event when a file is opened with the intent to be executed.  See "
"NOTES for additional details."
msgstr ""
"Создать событие при открытии файла для начала выполнения. Подробней об этом "
"в ЗАМЕЧАНИЯХ."

#. type: TP
#: man-pages/man2/fanotify_mark.2:183
#, no-wrap
msgid "B<FAN_ATTRIB> (since Linux 5.1)"
msgstr "B<FAN_ATTRIB> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:187
msgid "Create an event when the metadata for a file or directory has changed."
msgstr "Создать событие при изменении метаданных файла или каталога."

#. type: TP
#: man-pages/man2/fanotify_mark.2:187
#, no-wrap
msgid "B<FAN_CREATE> (since Linux 5.1)"
msgstr "B<FAN_CREATE> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:192
msgid ""
"Create an event when a file or directory has been created in a marked parent "
"directory."
msgstr ""
"Создать событие при создании файла или каталога в помеченном родительском "
"каталоге."

#. type: TP
#: man-pages/man2/fanotify_mark.2:192
#, no-wrap
msgid "B<FAN_DELETE> (since Linux 5.1)"
msgstr "B<FAN_DELETE> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:197
msgid ""
"Create an event when a file or directory has been deleted in a marked parent "
"directory."
msgstr ""
"Создать событие при удалении файла или каталога в помеченном родительском "
"каталоге."

#. type: TP
#: man-pages/man2/fanotify_mark.2:197
#, no-wrap
msgid "B<FAN_DELETE_SELF> (since Linux 5.1)"
msgstr "B<FAN_DELETE_SELF> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:201
msgid "Create an event when a marked file or directory itself is deleted."
msgstr "Создать событие при удалении самого помеченного файла или каталога."

#. type: TP
#: man-pages/man2/fanotify_mark.2:201
#, no-wrap
msgid "B<FAN_MOVED_FROM> (since Linux 5.1)"
msgstr "B<FAN_MOVED_FROM> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:206
msgid ""
"Create an event when a file or directory has been moved from a marked parent "
"directory."
msgstr ""
"Создать событие при перемещении файла или каталога из помеченного "
"родительского каталога."

#. type: TP
#: man-pages/man2/fanotify_mark.2:206
#, no-wrap
msgid "B<FAN_MOVED_TO> (since Linux 5.1)"
msgstr "B<FAN_MOVED_TO> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:211
msgid ""
"Create an event when a file or directory has been moved to a marked parent "
"directory."
msgstr ""
"Создать событие при перемещении файла или каталога в помеченный родительский "
"каталог."

#. type: TP
#: man-pages/man2/fanotify_mark.2:211
#, no-wrap
msgid "B<FAN_MOVE_SELF> (since Linux 5.1)"
msgstr "B<FAN_MOVE_SELF> (начиная с Linux 5.1)"

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:215
msgid "Create an event when a marked file or directory itself has been moved."
msgstr "Создать событие при перемещении самого помеченного файла или каталога."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:222
msgid ""
"Create an event when an overflow of the event queue occurs.  The size of the "
"event queue is limited to 16384 entries if B<FAN_UNLIMITED_QUEUE> is not set "
"in B<fanotify_init>(2)."
msgstr ""
"Создать событие при переполнении очереди сообщений. Размер очереди сообщений "
"ограничен 16384 элементами, если в B<fanotify_init>(2) не указан "
"B<FAN_UNLIMITED_QUEUE>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:230
msgid ""
"Create an event when a permission to open a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""
"Создать событие при запросе открытия файла или каталога. Требуется файловый "
"дескриптор fanotify, созданный с B<FAN_CLASS_PRE_CONTENT> или "
"B<FAN_CLASS_CONTENT>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:230
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM> (since Linux 5.0)"
msgstr "B<FAN_OPEN_EXEC_PERM> (начиная с Linux 5.0)"

#.  commit 66917a3130f218dcef9eeab4fd11a71cd00cd7c9
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:241
msgid ""
"Create an event when a permission to open a file for execution is "
"requested.  An fanotify file descriptor created with "
"B<FAN_CLASS_PRE_CONTENT> or B<FAN_CLASS_CONTENT> is required.  See NOTES for "
"additional details."
msgstr ""
"Создать событие при запросе открытия файла или каталога на выполнение. "
"Требуется файловый дескриптор fanotify, созданный с B<FAN_CLASS_PRE_CONTENT> "
"или B<FAN_CLASS_CONTENT>. Дополнительная информация представлена в "
"ЗАМЕЧАНИЯХ."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:249
msgid ""
"Create an event when a permission to read a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""
"Создать событие при запросе чтения файла или каталога. Требуется файловый "
"дескриптор fanotify, созданный с B<FAN_CLASS_PRE_CONTENT> или "
"B<FAN_CLASS_CONTENT>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:249
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr "B<FAN_ONDIR>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:280
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(3), "
"B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without this "
"flag, only events for files are created.  The B<FAN_ONDIR> flag is reported "
"in an event mask only if the I<fanotify_fd> file descriptor has been "
"initialized with the flag B<FAN_REPORT_FID>.  In the context of directory "
"entry events, such as B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and "
"B<FAN_MOVED_TO> for example, specifying the flag B<FAN_ONDIR> is required in "
"order to create events when subdirectory entries are modified (i.e., "
"B<mkdir>(2)/ B<rmdir>(2)).  Subdirectory entry modification events will "
"never be merged with nonsubdirectory entry modification events.  This flag "
"is never reported individually within an event and is always supplied in "
"conjunction with another event type."
msgstr ""
"Создать события для каталогов, например, когда вызывается B<opendir>(3), "
"B<readdir>(3) (но смотрите ДЕФЕКТЫ) и B<closedir>(3). Без этого флага "
"события создаются только для файлов. Флаг B<FAN_ONDIR> возвращается в маске "
"событий только, если файловый дескриптор I<fanotify_fd> инициализирован с "
"флагом B<FAN_REPORT_FID>. В контексте события элементов каталога, например "
"таких как B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>и B<FAN_MOVED_TO>, "
"требуется задавать флаг B<FAN_ONDIR> для создания событий, когда изменяются "
"элементы подкаталогов (т. е., B<mkdir>(2)/ B<rmdir>(2)). События изменения "
"элемента подкаталога никогда не будут объединены с с событиями изменений "
"элементов не подкаталога. Этот флаг никогда не возвращается один в событии и "
"всегда задаётся вместе с другим типом события."

#. type: TP
#: man-pages/man2/fanotify_mark.2:280
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr "B<FAN_EVENT_ON_CHILD>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:288
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts and filesystems.  Note that "
"events are not generated for children of the subdirectories of marked "
"directories.  To monitor complete directory trees it is necessary to mark "
"the relevant mount."
msgstr ""
"Должны создаваться события для прямых потомков помеченных каталогов. Флаг не "
"влияет на помеченные точки монтирования и файловые системы. Заметим, что "
"события не генерируются для потомков подкаталогов помеченных каталогов. Для "
"слежения за всем деревом каталогов нужно пометить соответствующую точку "
"монтирования."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:290
msgid "The following composed values are defined:"
msgstr "Определены следующие составные значения:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:294
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr "Файл закрыт (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:298
msgid "A file or directory has been moved (B<FAN_MOVED_FROM>|B<FAN_MOVED_TO>)."
msgstr "Файл или каталог был перемещён (B<FAN_MOVED_FROM>|B<FAN_MOVED_TO>)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:303
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""
"Объект файловой системы для пометки задаётся файловым дескриптором I<dirfd> "
"и путём, указанным в I<pathname>:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:309
msgid ""
"If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""
"Если значение I<pathname> равно NULL, то в I<dirfd> указан объект файловой "
"системы для пометки."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:317
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""
"Если значение I<pathname> равно NULL и I<dirfd> равно специальному значению "
"B<AT_FDCWD>, то помечается текущий рабочий каталог."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:323
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""
"Если в I<pathname> задан абсолютный путь, то им определяется объект файловой "
"системы для пометки, а I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:334
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> не равно B<AT_FDCWD>, "
"то помечаемый объект файловой системы определяется из I<pathname> "
"относительно каталога, заданного в I<dirfd>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:344
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the "
"filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно B<AT_FDCWD>, то "
"помечаемый объект файловой системы определяется из I<pathname> относительно "
"текущего рабочего каталога."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:351
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fanotify_mark>() возвращает 0; при ошибке "
"возвращается -1, а в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:356
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr "В I<fanotify_fd> передан некорректный файловый дескриптор."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:365
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""
"В I<flags> или I<mask> указано некорректное значение, или в I<fanotify_fd> "
"не файловый дескриптор fanotify."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:375
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> or "
"B<FAN_REPORT_FID> and mask contains a flag for permission events "
"(B<FAN_OPEN_PERM> or B<FAN_ACCESS_PERM>)."
msgstr ""
"Файловый дескриптор fanotify был открыт с B<FAN_CLASS_NOTIF> или "
"B<FAN_REPORT_FID> и маска содержит флаг для событий доступа "
"(B<FAN_OPEN_PERM> или B<FAN_ACCESS_PERM>)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:384
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist.  "
"This error also occurs when trying to remove a mark from an object which is "
"not marked."
msgstr ""
"Объект файловой системы, указанный в I<dirfd> и I<pathname>, не существует. "
"Эта ошибка также возникает при попытке удаления метки с не помеченного "
"объекта."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:387
msgid "The necessary memory could not be allocated."
msgstr "Невозможно выделить необходимую память."

#. type: TP
#: man-pages/man2/fanotify_mark.2:387
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:393
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS> "
"flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""
"Количество меток превышает ограничение в 8192 и флаг B<FAN_UNLIMITED_MARKS> "
"не был указан при создании файлового дескриптора fanotify с помощью "
"B<fanotify_init>(2)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:399
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""
"В этом ядре не реализован B<fanotify_mark>(). Программный интерфейс fanotify "
"доступен только, если ядро было собрано с параметром B<CONFIG_FANOTIFY>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:409
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""
"В значении I<flags> содержится B<FAN_MARK_ONLYDIR>, а в I<dirfd> и "
"I<pathname> указан не каталог."

#. type: TP
#: man-pages/man2/fanotify_mark.2:409
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:423
msgid ""
"The filesystem object indicated by I<pathname> resides within a filesystem "
"subvolume (e.g., B<btrfs>(5))  which uses a different I<fsid> than its root "
"superblock.  This error can be returned only when an fanotify file "
"descriptor returned by B<fanotify_init>(2)  has been created with "
"B<FAN_REPORT_FID>."
msgstr ""
"Объект файловой системы, указанный в I<pathname>, располагается в подтоме "
"файловой системы (например, B<btrfs>(5)), которая использует I<fsid> "
"отличный от используемого в её корневом суперблоке. Эта ошибка может "
"вернуться только, когда файловый дескриптор fanotify, возвращаемый "
"B<fanotify_init>(2), был создан с  флагом B<FAN_REPORT_FID>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:436
msgid ""
"The filesystem object indicated by I<pathname> is not associated with a "
"filesystem that supports I<fsid> (e.g., B<tmpfs>(5)).  This error can be "
"returned only when an fanotify file descriptor returned by "
"B<fanotify_init>(2)  has been created with B<FAN_REPORT_FID>."
msgstr ""
"Объект файловой системы, указанный в I<pathname>, не связан с файловой "
"системой, которая поддерживает I<fsid> (например, B<tmpfs>(5)). Эта ошибка "
"может вернуться только, когда файловый дескриптор fanotify, возвращаемый "
"B<fanotify_init>(2), был создан с  флагом B<FAN_REPORT_FID>."

#. type: TP
#: man-pages/man2/fanotify_mark.2:436
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:447
msgid ""
"The object indicated by I<pathname> is associated with a filesystem that "
"does not support the encoding of file handles.  This error can be returned "
"only when an fanotify file descriptor returned by B<fanotify_init>(2)  has "
"been created with B<FAN_REPORT_FID>."
msgstr ""
"Объект, указанный в I<pathname>, связан с файловой системой, которая не "
"поддерживает кодирование файловых описателей. Эта ошибка может вернуться "
"только, когда файловый дескриптор fanotify, возвращаемый "
"B<fanotify_init>(2), был создан с  флагом B<FAN_REPORT_FID>."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:451
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""
"Вызов B<fanotify_mark>() появился в версии 2.6.36 ядра Linux и был включён в "
"версии 2.6.37."

#. type: SS
#: man-pages/man2/fanotify_mark.2:454
#, no-wrap
msgid "FAN_OPEN_EXEC and FAN_OPEN_EXEC_PERM"
msgstr "FAN_OPEN_EXEC и FAN_OPEN_EXEC_PERM"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:471
msgid ""
"When using either B<FAN_OPEN_EXEC> or B<FAN_OPEN_EXEC_PERM> within the "
"I<mask>, events of these types will be returned only when the direct "
"execution of a program occurs.  More specifically, this means that events of "
"these types will be generated for files that are opened using B<execve>(2), "
"B<execveat>(2), or B<uselib>(2).  Events of these types will not be raised "
"in the situation where an interpreter is passed (or reads) a script file for "
"interpretation."
msgstr ""
"При использовании B<FAN_OPEN_EXEC> или B<FAN_OPEN_EXEC_PERM> в I<mask> "
"события этих типов будут возвращаться только, когда происходит "
"непосредственное выполнение программы. Точнее говоря, события этих типов "
"будут сгенерированы для файлов, которые открываются с помощью B<execve>(2), "
"B<execveat>(2) или B<uselib>(2). События данных типов не будут возникать в "
"ситуации, когда интерпретатору передаётся (или он читает) файл "
"интерпретируемого сценария."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:478
msgid ""
"Additionally, if a mark has also been placed on the Linux dynamic linker, a "
"user should also expect to receive an event for it when an ELF object has "
"been successfully opened using B<execve>(2)  or B<execveat>(2)."
msgstr ""
"Также, если метка помещается на динамический компоновщик Linux, то "
"пользователь должен также ожидать приём сообщения, когда он открывает объект "
"ELF с помощью B<execve>(2) или B<execveat>(2)."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:482
msgid ""
"For example, if the following ELF binary were to be invoked and a "
"B<FAN_OPEN_EXEC> mark has been placed on /:"
msgstr ""
"Например, если вызывается следующий двоичный ELF и меткой B<FAN_OPEN_EXEC> "
"отмечен /:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:486
#, no-wrap
msgid "$ /bin/echo foo\n"
msgstr "$ /bin/echo foo\n"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:492
msgid ""
"The listening application in this case would receive B<FAN_OPEN_EXEC> events "
"for both the ELF binary and interpreter, respectively:"
msgstr ""
"Слушающее приложение в этом случае получило бы события B<FAN_OPEN_EXEC> для "
"исполняемого файла ELF и интерпретатора, соответственно:"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:497
#, no-wrap
msgid ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"
msgstr ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:501
msgid "The following bugs were present in Linux kernels before version 3.16:"
msgstr "В ядрах Linux до версии 3.16 существуют следующие дефекты:"

#.  Fixed by commit 0a8dd2db579f7a0ac7033d6b857c3d5dbaa77563
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:511
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd> and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""
"Если I<flags> содержит B<FAN_MARK_FLUSH>, то I<dirfd> и I<pathname> должны "
"задавать корректный объект файловой системы, даже если этот объект не "
"используется."

#.  Fixed by commit d4c7cf6cffb1bc711a833b5e304ba5bcfe76398b
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:517
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr "Вызов B<readdir>(2) не генерирует событие B<FAN_ACCESS>."

#.  Fixed by commit cc299a98eb13a9853675a9cbb90b30b4011e1406
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:525
msgid ""
"If B<fanotify_mark>()  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr ""
"Если B<fanotify_mark>() вызван с B<FAN_MARK_FLUSH>, то значение I<flags> не "
"проверяется на корректность."

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:527
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr "B<fanotify_init>(2), B<fanotify>(7)"

#. type: TH
#: man-pages/man2/fcntl.2:68
#, no-wrap
msgid "FCNTL"
msgstr "FCNTL"

#. type: Plain text
#: man-pages/man2/fcntl.2:71
msgid "fcntl - manipulate file descriptor"
msgstr "fcntl - работа с файловым дескриптором"

#. type: Plain text
#: man-pages/man2/fcntl.2:75
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:77
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:84
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""
"B<fcntl>() позволяет выполнять различные команды над открытым файловым "
"дескриптором I<fd>. Команда определяется содержимым аргумента I<cmd>."

#. type: Plain text
#: man-pages/man2/fcntl.2:98
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is "
"indicated in parentheses after each I<cmd> name (in most cases, the required "
"type is I<int>, and we identify the argument using the name I<arg>), or "
"I<void> is specified if the argument is not required."
msgstr ""
"B<fcntl>() может принимать необязательный третий аргумент. Необходимость его "
"указания зависит от значения, указанного в I<cmd>. Тип необходимого "
"аргумента указан в скобках после каждого имени значения I<cmd> (в "
"большинстве случаев требуется тип I<int>, и мы определяем аргумент с помощью "
"имени I<arg>), или указывается I<void>, если аргумент не нужен."

#. type: Plain text
#: man-pages/man2/fcntl.2:109
msgid ""
"Certain of the operations below are supported only since a particular Linux "
"kernel version.  The preferred method of checking whether the host kernel "
"supports a particular operation is to invoke B<fcntl>()  with the desired "
"I<cmd> value and then test whether the call failed with B<EINVAL>, "
"indicating that the kernel does not recognize this value."
msgstr ""
"Некоторые операции, описанные далее, поддерживаются только начиная с "
"определённой версии ядра Linux. Корректным методом проверки доступности "
"операции в ядре является вызов B<fcntl>() с желаемой операцией в I<cmd> и "
"сравнение кода возврата вызов с B<EINVAL>, который указывает на "
"неподдерживаемость значения ядром."

#. type: SS
#: man-pages/man2/fcntl.2:109
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr "Создание дубликата файлового дескриптора"

#. type: TP
#: man-pages/man2/fcntl.2:110
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr "B<F_DUPFD> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:119
msgid ""
"Duplicate the file descriptor I<fd> using the lowest-numbered available file "
"descriptor greater than or equal to I<arg>.  This is different from "
"B<dup2>(2), which uses exactly the file descriptor specified."
msgstr ""
"Создаёт копию файлового дескриптора I<fd>, используя и наименьший доступный "
"номер файлового дескриптора, который больше или равен I<arg>. Отличие от "
"B<dup2>(2) в том, что там файловый дескриптор задаётся явно."

#. type: Plain text
#: man-pages/man2/fcntl.2:121
msgid "On success, the new file descriptor is returned."
msgstr ""
"При успешном выполнении этой команды, возвращается новый файловый дескриптор."

#. type: Plain text
#: man-pages/man2/fcntl.2:125
msgid "See B<dup>(2)  for further details."
msgstr "Дополнительную информацию смотрите в B<dup>(2)."

#. type: TP
#: man-pages/man2/fcntl.2:125
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr "B<F_DUPFD_CLOEXEC> (I<int>; начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man2/fcntl.2:142
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate file descriptor.  Specifying this flag permits a program to avoid "
"an additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> "
"flag.  For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""
"Как B<F_DUPFD>, но на новом файловом дескрипторе дополнительно "
"устанавливается флаг закрытия-при-выполнении. Установка этого флага "
"позволяет программам не делать дополнительный вызов B<fcntl>() с командой "
"B<F_SETFD> для установки флага B<FD_CLOEXEC>. О том, зачем нужен этот флаг, "
"смотрите описание B<O_CLOEXEC> в B<open>(2)."

#. type: SS
#: man-pages/man2/fcntl.2:142
#, no-wrap
msgid "File descriptor flags"
msgstr "Флаги файлового дескриптора"

#. type: Plain text
#: man-pages/man2/fcntl.2:160
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is set, the file descriptor "
"will automatically be closed during a successful B<execve>(2).  (If the "
"B<execve>(2)  fails, the file descriptor is left open.)  If the "
"B<FD_CLOEXEC> bit is not set, the file descriptor will remain open across an "
"B<execve>(2)."
msgstr ""
"Следующие команды работают с флагами, связанными с файловым дескриптором. В "
"настоящее время определён только один флаг: B<FD_CLOEXEC>, флаг close-on-"
"exec. Если бит B<FD_CLOEXEC> равен 1, то файловый дескриптор будет "
"автоматически закрыт при успешном вызове B<execve>(2) (если B<execve>(2) "
"завершится с ошибкой, то файловый дескриптор останется открытым). Если бит "
"B<FD_CLOEXEC> равен 0, то файловый дескриптор останется открытым после "
"B<execve>(2)."

#. type: TP
#: man-pages/man2/fcntl.2:160
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr "B<F_GETFD> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:165
msgid ""
"Return (as the function result) the file descriptor flags; I<arg> is ignored."
msgstr ""
"Вернуть (как результат функции) флаги файлового дескриптора; значение I<arg> "
"игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:165
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr "B<F_SETFD> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:169
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr ""
"Установить флаги файлового дескриптора согласно значению, указанному в "
"аргументе I<arg>."

#. type: Plain text
#: man-pages/man2/fcntl.2:184
msgid ""
"In multithreaded programs, using B<fcntl>()  B<F_SETFD> to set the close-on-"
"exec flag at the same time as another thread performs a B<fork>(2)  plus "
"B<execve>(2)  is vulnerable to a race condition that may unintentionally "
"leak the file descriptor to the program executed in the child process.  See "
"the discussion of the B<O_CLOEXEC> flag in B<open>(2)  for details and a "
"remedy to the problem."
msgstr ""
"В многонитевых программах использование B<fcntl>() с B<F_SETFD> для "
"установки флага close-on-exec в то время как другая нить выполняет "
"B<fork>(2) плюс B<execve>(2) приводит к состязательности, что может вызвать "
"передачу файлового дескриптора программе, запущенной в дочернем процессе. "
"Смотрите обсуждение флага B<O_CLOEXEC> в B<open>(2) и решение проблемы."

#. type: SS
#: man-pages/man2/fcntl.2:184
#, no-wrap
msgid "File status flags"
msgstr "Флаги состояния файла"

#.  or
#.  .BR creat (2),
#. type: Plain text
#: man-pages/man2/fcntl.2:199
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer "
"to the same open file description, and thus share the same file status flags."
msgstr ""
"Каждое описание открытого файла имеет несколько связанных с ним флагов "
"состояния, которые инициализируются вызовом B<open>(2) и, возможно, "
"изменяются затем вызовом B<fcntl>(). Эти флаги совместно используются "
"копиями файловых дескрипторов (сделанными с помощью B<dup>(2), "
"B<fcntl>(F_DUPFD), B<fork>(2) и т.д.), которые указывают на одно описание "
"открытого файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:202
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr "Эти флаги состояния и их смысл описаны в B<open>(2)."

#. type: TP
#: man-pages/man2/fcntl.2:202
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr "B<F_GETFL> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:208
msgid ""
"Return (as the function result)  the file access mode and the file status "
"flags; I<arg> is ignored."
msgstr ""
"Вернуть (как результат функции) режим доступа к файлу и флаги состояния "
"файла; значение I<arg> игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:208
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr "B<F_SETFL> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:233
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux, this command can change only the B<O_APPEND>, B<O_ASYNC>, "
"B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to "
"change the B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""
"Установить флаги состояния файла согласно значению, указанному в аргументе "
"I<arg>. Режим доступа к файлу (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>) и флаги "
"создания файла (т. е., B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>) в "
"I<arg> игнорируются. В Linux эта команда может изменять только флаги "
"B<O_APPEND>, B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME> и B<O_NONBLOCK>. "
"Невозможно изменить флаги B<O_DSYNC> и B<O_SYNC>; смотрите ДЕФЕКТЫ далее."

#. type: SS
#: man-pages/man2/fcntl.2:233
#, no-wrap
msgid "Advisory record locking"
msgstr "Консультативная (advisory) блокировка"

#. type: Plain text
#: man-pages/man2/fcntl.2:238
msgid ""
"Linux implements traditional (\"process-associated\") UNIX record locks, as "
"standardized by POSIX.  For a Linux-specific alternative with better "
"semantics, see the discussion of open file description locks below."
msgstr ""
"В Linux реализована обычная («попроцессная») блокировка UNIX, "
"стандартизованная POSIX. Описание Linux-альтернативную блокировку открытых "
"файловых описаний с лучшей семантикой смотрите далее."

#. type: Plain text
#: man-pages/man2/fcntl.2:249
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as byte-range, file-"
"segment, or file-region locks).  The third argument, I<lock>, is a pointer "
"to a structure that has at least the following fields (in unspecified order)."
msgstr ""
"Команды B<F_SETLK>, B<F_SETLKW> и B<F_GETLK> используются для установки, "
"снятия и тестирования существования блокировок записей (также известных как "
"блокировки байтового диапазона, сегмента или области файла). Третий "
"аргумент, I<lock>, является указателем на структуру, которая имеет, по "
"крайней мере, следующие поля (в произвольном порядке):"

#. type: Plain text
#: man-pages/man2/fcntl.2:264
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"
msgstr ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Тип блокировки: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* Как интерпретировать l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Начальное смещение блокировки */\n"
"    off_t l_len;     /* Количество блокируемых байт */\n"
"    pid_t l_pid;     /* PID процесса, блокирующего нашу блокировку\n"
"                        (только для F_GETLK и F_OFD_GETLK) */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:272
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""
"Поля I<l_whence>, I<l_start> и I<l_len> этой структуры задают диапазон байт, "
"который мы хотим заблокировать. Могут блокироваться байты за концом файла, "
"но не перед началом файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:292
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""
"I<l_start> \\(em это начальное смещение для блокировки, которое "
"интерпретируется как начало файла (если значение I<l_whence> равно "
"B<SEEK_SET>); как текущая позиция в файле (если значение I<l_whence> равно "
"B<SEEK_CUR>); как конец файла (если значение I<l_whence> равно B<SEEK_END>). "
"В последних двух случаях, I<l_start> может иметь отрицательное значение, "
"предоставляя смещение, которого не может указать до начала файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:307
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""
"В I<l_len> задаётся количество байт, которые нужно заблокировать. Если "
"I<l_len> положительно, то диапазон блокировки начинается со I<l_start> и "
"кончается I<l_start>+I<l_len>-1 включительно. Если в I<l_len> указан 0, то "
"блокируются все байты начиная с места, указанного I<l_whence> и I<l_start> и "
"до конца файла, независимо от величины файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:320
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""
"POSIX.1-2001 позволяет (но не требует) реализации поддерживать отрицательное "
"значение I<l_len>; если I<l_len> отрицательно, то интервал, описываемый "
"I<lock>, имеет размер I<l_start>+I<l_len> до I<l_start>-1 включительно. Это "
"поддерживается в Linux начиная с ядер версии 2.4.21 и 2.5.49."

#. type: Plain text
#: man-pages/man2/fcntl.2:339
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""
"Поле I<l_type> может быть использовано для указания типа блокировки файла: "
"чтение (B<F_RDLCK>) или запись (B<F_WRLCK>). Любое количество процессов "
"могут удерживать блокировку на чтение (общая блокировка) области файла, но "
"только один процесс может удерживать блокировку на запись (эксклюзивная "
"блокировка). Эксклюзивная блокировка исключает все другие блокировки, как "
"общие так и эксклюзивные. Один процесс может удерживать только один тип "
"блокировки области файла; если происходит новая блокировка уже "
"заблокированной области, то существующая блокировка преобразуется в новый "
"тип блокировки. (Такие преобразования могут привести к разбиению, уменьшению "
"или срастанию с существующей блокировкой, если диапазон байт, заданный для "
"новой блокировки, неточно совпадает с диапазоном существующей блокировки.)"

#. type: TP
#: man-pages/man2/fcntl.2:339
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr "B<F_SETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:364
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>.  (The error returned in this case differs across "
"implementations, so POSIX requires a portable application to check for both "
"errors.)"
msgstr ""
"Установить блокировку (когда I<l_type> равен B<F_RDLCK> или B<F_WRLCK>) или "
"снять блокировку (когда  I<l_type>  равен  B<F_UNLCK>) байтов, указанных "
"полями I<l_whence>, I<l_start> и I<l_len> структуры I<lock>. Если "
"конфликтующая блокировка удерживается другим процессом, то данный вызов "
"вернёт -1 и установит значение I<errno> в B<EACCES> или B<EAGAIN> (ошибка, "
"возвращаемая в этом случае, в разных реализациях разная, поэтому в POSIX для "
"переносимых приложений требуется проверять оба значения)."

#. type: TP
#: man-pages/man2/fcntl.2:364
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr "B<F_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:378
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the "
"call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"Как B<F_SETLK>, но если конфликтующая блокировка удерживается на файле, то "
"выполняется ожидание снятия этой блокировки. Если во время ожидания поступил "
"сигнал, то данный вызов прерывается и (после возврата из обработчика "
"сигнала) из него происходит немедленный возврат (возвращается значение -1 и "
"I<errno> устанавливается в B<EINTR>; см. B<signal>(7))."

#. type: TP
#: man-pages/man2/fcntl.2:378
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr "B<F_GETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:392
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged."
msgstr ""
"При входе в этот вызов, I<lock> описывает блокировку, которую мы хотели бы "
"установить на файл. Если такая блокировка не может быть установлена, "
"B<fcntl>() не устанавливает её, но возвращает B<F_UNLCK> в поле I<l_type> "
"структуры I<lock> и оставляет другие поля структуры неизменёнными."

#. type: Plain text
#: man-pages/man2/fcntl.2:409
msgid ""
"If one or more incompatible locks would prevent this lock being placed, then "
"B<fcntl>()  returns details about one of those locks in the I<l_type>, "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If the conflicting "
"lock is a traditional (process-associated) record lock, then the I<l_pid> "
"field is set to the PID of the process holding that lock.  If the "
"conflicting lock is an open file description lock, then I<l_pid> is set to "
"-1.  Note that the returned information may already be out of date by the "
"time the caller inspects it."
msgstr ""
"Если одна или более несовместимых блокировок мешают установке этой "
"блокировки, то B<fcntl>() возвращает подробности об одной из этих блокировок "
"в полях I<l_type>, I<l_whence>, I<l_start> и I<l_len> структуры I<lock>. "
"Если конфликтующая блокировка является обычной (попроцессной), то в I<l_pid> "
"записывается значение PID того процесса, который удерживает блокировку. Если "
"конфликтующая блокировка является блокировку открытого файлового описания, в "
"I<l_pid> записывается -1. Заметим, что возвращаемая информация может уже "
"устареть в момент проверки вызывающим."

#. type: Plain text
#: man-pages/man2/fcntl.2:417
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""
"Для того, чтобы установить блокировку на чтение, I<fd> должен быть открыт на "
"чтение. Для того, чтобы установить блокировку на запись, I<fd> должен быть "
"открыт на запись. Чтобы установить оба типа блокировки, дескриптор должен "
"быть открыт на запись и на чтение."

#. type: Plain text
#: man-pages/man2/fcntl.2:440
msgid ""
"When placing locks with B<F_SETLKW>, the kernel detects I<deadlocks>, "
"whereby two or more processes have their lock requests mutually blocked by "
"locks held by the other processes.  For example, suppose process A holds a "
"write lock on byte 100 of a file, and process B holds a write lock on byte "
"200.  If each process then attempts to lock the byte already locked by the "
"other process using B<F_SETLKW>, then, without deadlock detection, both "
"processes would remain blocked indefinitely.  When the kernel detects such "
"deadlocks, it causes one of the blocking lock requests to immediately fail "
"with the error B<EDEADLK>; an application that encounters such an error "
"should release some of its locks to allow other applications to proceed "
"before attempting regain the locks that it requires.  Circular deadlocks "
"involving more than two processes are also detected.  Note, however, that "
"there are limitations to the kernel's deadlock-detection algorithm; see BUGS."
msgstr ""
"При размещении блокировок с помощью B<F_SETLKW>, ядро обнаруживает "
"I<взаимные блокировки> (deadlocks), при которых два и более процессов "
"создают запросы на блокировку, блокируемые блокировками, удерживаемые "
"другими процессами. Например, предположим, что процесс А удерживает "
"блокировку на запись файла в байт 100, а процесс Б удерживает блокировку на "
"запись в байт 200. Если каждый процесс затем попытается заблокировать байт, "
"который уже заблокирован другим процессом с помощью B<F_SETLKW>, то без "
"обнаружения взаимных блокировок оба процесса останутся заблокированными "
"навсегда. Когда ядро обнаруживает такие взаимные блокировки оно сразу же "
"завершает одну из блокирующих блокировок с ошибкой B<EDEADLK>; приложение, "
"встретившее такую ошибку, должно освободить одну из своих блокировок перед "
"попыткой восстановить блокировки, которые ему нужны, позволив другому "
"приложению продолжить работу. Зацикленные взаимные блокировки обнаруживаются "
"и для более двух процессов. Однако заметим, что есть ограничения в алгоритме "
"обнаружения взаимных блокировок; смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/fcntl.2:444
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates."
msgstr ""
"Также как и при снятии блокировки через явное указание B<F_UNLCK>, "
"блокировка автоматически снимается, когда процесс завершается."

#. type: Plain text
#: man-pages/man2/fcntl.2:449
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""
"Блокировки не наследуются потомком, созданным через B<fork>(2), но "
"сохраняются при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:458
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use "
"B<read>(2)  and B<write>(2)  instead."
msgstr ""
"Поскольку буферизация выполняется через библиотеку B<stdio>(3), "
"использование блокировок с функциями в этом пакете нужно избегать; вместо "
"этих функций используйте B<read>(2) и B<write>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:462
msgid ""
"The record locks described above are associated with the process (unlike the "
"open file description locks described below).  This has some unfortunate "
"consequences:"
msgstr ""
"Записи о блокировках, описанных выше, связаны с процессом (в отличие от "
"блокировках открытых файловых описаний, описанных далее). Это приводит к "
"некоторым печальным последствиям:"

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
#: man-pages/man2/fcntl.2:478
msgid ""
"If a process closes I<any> file descriptor referring to a file, then all of "
"the process's locks on that file are released, regardless of the file "
"descriptor(s) on which the locks were obtained.  This is bad: it means that "
"a process can lose its locks on a file such as I</etc/passwd> or I</etc/"
"mtab> when for some reason a library function decides to open, read, and "
"close the same file."
msgstr ""
"Если процесс закрывает I<любой> файловый дескриптор, ссылающийся на файл, то "
"освобождаются все блокировки процесса для этого файла, независимо от "
"файлового дескриптора(ов), на который получена блокировка. Это плохо: это "
"означает, что процесс может потерять свои блокировки на файл, такой как I</"
"etc/passwd> или I</etc/mtab>, когда какой-либо причине библиотечная функция "
"решает их открыть, прочитать и закрыть."

#. type: Plain text
#: man-pages/man2/fcntl.2:483
msgid ""
"The threads in a process share locks.  In other words, a multithreaded "
"program can't use record locking to ensure that threads don't simultaneously "
"access the same region of a file."
msgstr ""
"Нити процесса совместно используют блокировки процесса. Другими словами "
"многонитевая программа не может использовать блокировку для разграничения "
"доступа к одной области файла среди нитей."

#. type: Plain text
#: man-pages/man2/fcntl.2:485
msgid "Open file description locks solve both of these problems."
msgstr "Блокировки открытых файловых описаний решают обе эти проблемы."

#. type: SS
#: man-pages/man2/fcntl.2:485
#, no-wrap
msgid "Open file description locks (non-POSIX)"
msgstr "Блокировки открытых файловых описаний (не POSIX)"

#.  FIXME . Review progress into POSIX
#.  http://austingroupbugs.net/view.php?id=768
#. type: Plain text
#: man-pages/man2/fcntl.2:496
msgid ""
"Open file description locks are advisory byte-range locks whose operation is "
"in most respects identical to the traditional record locks described above.  "
"This lock type is Linux-specific, and available since Linux 3.15.  (There is "
"a proposal with the Austin Group to include this lock type in the next "
"revision of POSIX.1.)  For an explanation of open file descriptions, see "
"B<open>(2)."
msgstr ""
"Блокировки открытых файловых описаний являются консультативными блокировками "
"диапазона байт, чьё действие почти идентично обычным блокировкам, описанным "
"выше. Данный тип блокировок есть только в Linux и доступен с версии 3.15 "
"(есть предложение в Austin Group включить данный тип блокировки в следующую "
"версию POSIX.1). Описание открытых файловых описаний смотрите в B<open>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:514
msgid ""
"The principal difference between the two lock types is that whereas "
"traditional record locks are associated with a process, open file "
"description locks are associated with the open file description on which "
"they are acquired, much like locks acquired with B<flock>(2).  Consequently "
"(and unlike traditional advisory record locks), open file description locks "
"are inherited across B<fork>(2)  (and B<clone>(2)  with B<CLONE_FILES>), and "
"are only automatically released on the last close of the open file "
"description, instead of being released on any close of the file."
msgstr ""
"Принципиальное различие между двумя типами блокировок в том, что обычные "
"блокировки связаны с процессом, а блокировки открытых файловых описаний "
"связаны с открытым файловым описанием, для которого они получены (очень "
"похоже на блокировки, получаемые с помощью B<flock>(2). В следствие этого (и "
"в отличие от обычных консультативных блокировок), блокировки открытых "
"файловых описаний наследуются при B<fork>(2) (и при B<clone>(2) с "
"B<CLONE_FILES>), и освобождаются только автоматически при последнем закрытии "
"открытого файлового описания, а не при любом закрытии файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:520
msgid ""
"Conflicting lock combinations (i.e., a read lock and a write lock or two "
"write locks)  where one lock is an open file description lock and the other "
"is a traditional record lock conflict even when they are acquired by the "
"same process on the same file descriptor."
msgstr ""
"Конфликт комбинаций блокировок (блокировка чтения и блокировка записи или "
"две блокировки записи), при котором одна блокировка — открытое файловое "
"описание, а другая — обычная блокировка, конфликтуют даже когда они "
"запрашиваются одним процессом для одного и того же файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fcntl.2:533
msgid ""
"Open file description locks placed via the same open file description (i.e., "
"via the same file descriptor, or via a duplicate of the file descriptor "
"created by B<fork>(2), B<dup>(2), B<fcntl>()  B<F_DUPFD>, and so on) are "
"always compatible: if a new lock is placed on an already locked region, then "
"the existing lock is converted to the new lock type.  (Such conversions may "
"result in splitting, shrinking, or coalescing with an existing lock as "
"discussed above.)"
msgstr ""
"Блокировки открытых файловых описаний, полученные для одного и того же "
"файлового описания (т. е., для одного и того же файлового дескриптора или "
"его копии, созданной в результате B<fork>(2), B<dup>(2), B<fcntl>() "
"B<F_DUPFD> и т. п.), всегда совместимы: если новая блокировка помещается на "
"уже заблокированную область, то существующая блокировка преобразуется в "
"блокировку нового типа (такие преобразования могут приводить к разделению, "
"сокращению или объединению существующей блокировки, как описывалось ранее)."

#. type: Plain text
#: man-pages/man2/fcntl.2:541
msgid ""
"On the other hand, open file description locks may conflict with each other "
"when they are acquired via different open file descriptions.  Thus, the "
"threads in a multithreaded program can use open file description locks to "
"synchronize access to a file region by having each thread perform its own "
"B<open>(2)  on the file and applying locks via the resulting file descriptor."
msgstr ""
"С другой стороны, блокировки открытых файловых описаний могут конфликтовать "
"друг с другом, когда они запрашиваются через разные открытые файловые "
"описания. То есть, нити в многонитевых программах могут использовать "
"блокировки открытых файловых описаний  для синхронизации доступа к области "
"файла, если каждая нить выполняет отдельный вызов B<open>(2) на файл и "
"применяет блокировки для получаемого файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fcntl.2:552
msgid ""
"As with traditional advisory locks, the third argument to B<fcntl>(), "
"I<lock>, is a pointer to an I<flock> structure.  By contrast with "
"traditional record locks, the I<l_pid> field of that structure must be set "
"to zero when using the commands described below."
msgstr ""
"Как и у обычных блокировок, третий аргумент B<fcntl>(), I<lock>, является "
"указателем на структуру I<flock>. Но в отличие от обычных блокировок при "
"использовании команд, описанных далее, поле I<l_pid> этой структуры должно "
"иметь значение 0."

#. type: Plain text
#: man-pages/man2/fcntl.2:555
msgid ""
"The commands for working with open file description locks are analogous to "
"those used with traditional locks:"
msgstr ""
"Команды для работы с блокировками открытых файловых описаний аналогичны "
"используемым для обычных блокировок:"

#. type: TP
#: man-pages/man2/fcntl.2:555
#, no-wrap
msgid "B<F_OFD_SETLK> (I<struct flock *>)"
msgstr "B<F_OFD_SETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:576
msgid ""
"Acquire an open file description lock (when I<l_type> is B<F_RDLCK> or "
"B<F_WRLCK>)  or release an open file description lock (when I<l_type> is "
"B<F_UNLCK>)  on the bytes specified by the I<l_whence>, I<l_start>, and "
"I<l_len> fields of I<lock>.  If a conflicting lock is held by another "
"process, this call returns -1 and sets I<errno> to B<EAGAIN>."
msgstr ""
"Установить блокировку открытого файлового описания (когда I<l_type> равен "
"B<F_RDLCK> или B<F_WRLCK>) или снять блокировку открытого файлового описания "
"(когда I<l_type> равен B<F_UNLCK>) байтов, указанных полями I<l_whence>, "
"I<l_start> и I<l_len> структуры I<lock>. Если конфликтующая блокировка "
"удерживается другим процессом, то данный вызов вернёт -1 и установит "
"значение I<errno> в B<EAGAIN>."

#. type: TP
#: man-pages/man2/fcntl.2:576
#, no-wrap
msgid "B<F_OFD_SETLKW> (I<struct flock *>)"
msgstr "B<F_OFD_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:590
msgid ""
"As for B<F_OFD_SETLK>, but if a conflicting lock is held on the file, then "
"wait for that lock to be released.  If a signal is caught while waiting, "
"then the call is interrupted and (after the signal handler has returned) "
"returns immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"Как B<F_OFD_SETLK>, но если конфликтующая блокировка удерживается на файле, "
"то выполняется ожидание снятия этой блокировки. Если во время ожидания "
"поступил сигнал, то данный вызов прерывается и (после возврата из "
"обработчика сигнала) из него происходит немедленный возврат (возвращается "
"значение -1 и I<errno> устанавливается в B<EINTR>; см. B<signal>(7))."

#. type: TP
#: man-pages/man2/fcntl.2:590
#, no-wrap
msgid "B<F_OFD_GETLK> (I<struct flock *>)"
msgstr "B<F_OFD_GETLK> (I<struct flock *>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:609
msgid ""
"On input to this call, I<lock> describes an open file description lock we "
"would like to place on the file.  If the lock could be placed, B<fcntl>()  "
"does not actually place it, but returns B<F_UNLCK> in the I<l_type> field of "
"I<lock> and leaves the other fields of the structure unchanged.  If one or "
"more incompatible locks would prevent this lock being placed, then details "
"about one of these locks are returned via I<lock>, as described above for "
"B<F_GETLK>."
msgstr ""
"В начала данного вызова значение I<lock> описывает блокировку открытого "
"файлового описания, которую мы бы хотели создать на файле. Если блокировка "
"возможна, то в действительности B<fcntl>() её не создаёт, а возвращает "
"B<F_UNLCK> в поле I<l_type> у I<lock>, оставляя остальные поля неизменными. "
"Если есть одна или более несовместимых блокировок, препятствующих получению, "
"то в I<lock> возвращается подробная информация об этих блокировках, как "
"описывалось выше для B<F_GETLK>."

#.  commit 57b65325fe34ec4c917bc4e555144b4a94d9e1f7
#. type: Plain text
#: man-pages/man2/fcntl.2:616
msgid ""
"In the current implementation, no deadlock detection is performed for open "
"file description locks.  (This contrasts with process-associated record "
"locks, for which the kernel does perform deadlock detection.)"
msgstr ""
"В текущей реализации для блокировок открытых файловых описаний обнаружение "
"взаимных блокировок не выполняется (в этом отличие от попроцессных "
"блокировок, для которых ядро выполняет обнаружение взаимных блокировок)."

#. type: SS
#: man-pages/man2/fcntl.2:616 man-pages/man2/fcntl.2:2067
#, no-wrap
msgid "Mandatory locking"
msgstr "Обязательная (mandatory) блокировка"

#. type: Plain text
#: man-pages/man2/fcntl.2:626
msgid ""
"I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
"See BUGS below.  Because of these bugs, and the fact that the feature is "
"believed to be little used, since Linux 4.5, mandatory locking has been made "
"an optional feature, governed by a configuration option "
"(B<CONFIG_MANDATORY_FILE_LOCKING>).  This is an initial step toward removing "
"this feature completely."
msgstr ""
"I<Предупреждение>: реализация Linux обязательного блокирования ненадёжна. "
"Смотрите раздел ДЕФЕКТЫ далее. Из-за этих дефектов и того факта, что это "
"свойство, вероятно, мало где будет использоваться, начиная с Linux 4.5 "
"обязательная блокировка был сделана необязательной, и включается параметром "
"настройки (B<CONFIG_MANDATORY_FILE_LOCKING>). Это первый шаг последующего "
"полного удаления данного свойства."

#. type: Plain text
#: man-pages/man2/fcntl.2:631
msgid ""
"By default, both traditional (process-associated) and open file description "
"record locks are advisory.  Advisory locks are not enforced and are useful "
"only between cooperating processes."
msgstr ""
"По умолчанию, обычные (связанные с процессом) блокировки и блокировки "
"открытого файлового описания являются консультативными. Консультативные "
"блокировки не обязательны к выполнению и полезны только в сотрудничающих "
"процессах."

#. type: Plain text
#: man-pages/man2/fcntl.2:651
msgid ""
"Both lock types can also be mandatory.  Mandatory locks are enforced for all "
"processes.  If a process tries to perform an incompatible access (e.g., "
"B<read>(2)  or B<write>(2))  on a file region that has an incompatible "
"mandatory lock, then the result depends upon whether the B<O_NONBLOCK> flag "
"is enabled for its open file description.  If the B<O_NONBLOCK> flag is not "
"enabled, then the system call is blocked until the lock is removed or "
"converted to a mode that is compatible with the access.  If the "
"B<O_NONBLOCK> flag is enabled, then the system call fails with the error "
"B<EAGAIN>."
msgstr ""
"Оба типа блокировки могут быть также обязательными. Если процесс пытается "
"получить несовместимый доступ (например, B<read>(2) и B<write>(2)) к области "
"файла, на которую установлена несовместимая обязательная блокировка, то "
"результат зависит от состояния флага B<O_NONBLOCK> в описании этого "
"открытого файла. Если флаг B<O_NONBLOCK> не установлен, то системный вызов "
"блокируется до удаления блокировки или преобразуется в режим, который "
"совместим с доступом. Если флаг B<O_NONBLOCK> установлен, то системный вызов "
"завершается с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/fcntl.2:668
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself.  "
"Mandatory locking is enabled on a filesystem using the \"-o mand\" option to "
"B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory locking "
"is enabled on a file by disabling group execute permission on the file and "
"enabling the set-group-ID permission bit (see B<chmod>(1)  and B<chmod>(2))."
msgstr ""
"Чтобы использовать обязательные блокировки, обязательное блокирование должно "
"быть включено в файловой системе, содержащей файл, и на самом файле. "
"Обязательное блокирование включается в файловой системе с помощью параметра "
"«-o mand» команды B<mount>(8) или с помощью флага B<MS_MANDLOCK> в "
"B<mount>(2). Обязательное блокирование включается на файле посредством "
"отключения права исполнения группе и установкой бита set-group-ID (см. "
"B<chmod>(1) и B<chmod>(2))."

#. type: Plain text
#: man-pages/man2/fcntl.2:673
msgid ""
"Mandatory locking is not specified by POSIX.  Some other systems also "
"support mandatory locking, although the details of how to enable it vary "
"across systems."
msgstr ""
"Обязательная блокировка не описана в POSIX. В некоторых других системах "
"обязательная блокировка также поддерживается, хотя процесс её создания "
"различен."

#. type: SS
#: man-pages/man2/fcntl.2:673
#, no-wrap
msgid "Lost locks"
msgstr "Потерянные блокировки"

#. type: Plain text
#: man-pages/man2/fcntl.2:680
msgid ""
"When an advisory lock is obtained on a networked filesystem such as NFS it "
"is possible that the lock might get lost.  This may happen due to "
"administrative action on the server, or due to a network partition (i.e., "
"loss of network connectivity with the server)  which lasts long enough for "
"the server to assume that the client is no longer functioning."
msgstr ""
"При получении консультативной блокировки на сетевой файловой системе, "
"например NFS, возможна её потеря. Это может случиться из-за "
"административного действия или сетевой проблемы (т. е., потеря связи с "
"сервером), которая длится достаточно долго для того, чтобы сервер посчитал "
"клиента за неработающего."

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#. type: Plain text
#: man-pages/man2/fcntl.2:692
msgid ""
"When the filesystem determines that a lock has been lost, future B<read>(2)  "
"or B<write>(2)  requests may fail with the error B<EIO>.  This error will "
"persist until the lock is removed or the file descriptor is closed.  Since "
"Linux 3.12, this happens at least for NFSv4 (including all minor versions)."
msgstr ""
"Когда файловая система определяет, что блокировка потеряна, последующие "
"запросы B<read>(2) или B<write>(2) могут завершиться ошибкой B<EIO>. Эта "
"ошибка будет повторяться до тех пор, пока блокировка не удалится или не "
"закроется файловый дескриптор. Начиная с Linux 3.12, так работает, по "
"крайней мере, NFSv4 (включая все предыдущие версии)."

#. type: Plain text
#: man-pages/man2/fcntl.2:699
msgid ""
"Some versions of UNIX send a signal (B<SIGLOST>)  in this circumstance.  "
"Linux does not define this signal, and does not provide any asynchronous "
"notification of lost locks."
msgstr ""
"Некоторые версии UNIX при таких обстоятельствах посылают сигнал "
"(B<SIGLOST>). В Linux такой сигнал не определён и не существует какого-либо "
"асинхронного уведомления о потере блокировки."

#. type: SS
#: man-pages/man2/fcntl.2:699
#, no-wrap
msgid "Managing signals"
msgstr "Управление сигналами"

#. type: Plain text
#: man-pages/man2/fcntl.2:708
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""
"Для управления сигналами доступности ввода/вывода используются команды "
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> и "
"B<F_SETSIG>:"

#. type: TP
#: man-pages/man2/fcntl.2:708
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr "B<F_GETOWN> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:721
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""
"Получить (как результат работы функции) идентификатор процесса или группы "
"процесса, который в текущий момент принимает сигналы B<SIGIO> и B<SIGURG> "
"для событий на файловом дескрипторе I<fd>. Идентификатор процесса "
"возвращается как положительное число; идентификатор группы возвращается как "
"отрицательное число (но см. раздел ДЕФЕКТЫ далее). Аргумент I<arg> "
"игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:721
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr "B<F_SETOWN> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:738
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on the file descriptor I<fd>.  The target "
"process or process group ID is specified in I<arg>.  A process ID is "
"specified as a positive value; a process group ID is specified as a negative "
"value.  Most commonly, the calling process specifies itself as the owner "
"(that is, I<arg> is specified as B<getpid>(2))."
msgstr ""
"Установить идентификатор процесса или группы процесса, которые будут "
"принимать сигналы B<SIGIO> и B<SIGURG> для событий на файловом дескрипторе "
"I<fd>. Идентификатор целевого процесса или группы процессов задаётся в "
"аргументе I<arg>. Идентификатор процесса задаётся положительным числом, "
"идентификатор группы задаётся отрицательным числом. Обычно, вызывающий "
"процесс указывает самого себя в качестве владельца (то есть в I<arg> "
"указывается результат B<getpid>(2))."

#. type: Plain text
#: man-pages/man2/fcntl.2:756
msgid ""
"As well as setting the file descriptor owner, one must also enable "
"generation of signals on the file descriptor.  This is done by using the "
"B<fcntl>()  B<F_SETFL> command to set the B<O_ASYNC> file status flag on the "
"file descriptor.  Subsequently, a B<SIGIO> signal is sent whenever input or "
"output becomes possible on the file descriptor.  The B<fcntl>()  B<F_SETSIG> "
"command can be used to obtain delivery of a signal other than B<SIGIO>."
msgstr ""
"Помимо установки владельца дескриптора файла, также нужно включить генерацию "
"сигналов для файлового дескриптора. Это делается посредством установки флага "
"состояния B<O_ASYNC> в файловом дескрипторе с помощью B<fcntl>() с командой "
"B<F_SETFL>. После этого сигнал B<SIGIO> посылается всякий раз, когда для "
"данного файлового дескриптора становится возможным ввод или вывод. Для "
"включения доставки сигнала, отличного от B<SIGIO>, можно использовать  "
"команду B<F_SETSIG> вызова B<fcntl>()."

#. type: Plain text
#: man-pages/man2/fcntl.2:773
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below).  If this permission check fails, then the signal is silently "
"discarded.  I<Note>: The B<F_SETOWN> operation records the caller's "
"credentials at the time of the B<fcntl>()  call, and it is these saved "
"credentials that are used for the permission checks."
msgstr ""
"Отправка сигнала процессу-владельцу (группе), указанному с помощью "
"B<F_SETOWN> — такая же проверка прав, как описано в B<kill>(2), где "
"посылающий процесс один из тех, который может пользоваться B<F_SETOWN> (но "
"смотрите раздел ДЕФЕКТЫ далее). Если проверка не проходит, то сигнал просто "
"отбрасывается. I<Замечание>: операция B<F_SETOWN> сохраняет мандаты "
"вызывающего на момент вызова B<fcntl>(), и эти сохранённые мандаты затем "
"используются при проверке прав."

#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
#: man-pages/man2/fcntl.2:797
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where "
"B<select>(2)  would report the socket as having an \"exceptional condition"
"\".)"
msgstr ""
"Если файловый дескриптор I<fd> указывает на сокет, то по команде B<F_SETOWN> "
"для него также выбирается получатель сигналов B<SIGURG>, которые "
"доставляются, когда на сокет поступают внеполосные данные. (B<SIGURG> "
"посылается во всех ситуациях, когда вызов B<select>(2) говорит, что сокет "
"находится в состоянии \"исключительной ситуации\".)"

#. type: Plain text
#: man-pages/man2/fcntl.2:800
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr "Следующее верно для ядер 2.6.x, до 2.6.11 включительно:"

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
#: man-pages/man2/fcntl.2:840
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current "
"Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""
"Если для B<F_SETSIG> передаётся ненулевое значение в многонитевой процесс, "
"работающий с библиотекой нитей (например, NPTL), которая обеспечивает "
"поддержку групп нитей, то положительное значение, переданное B<F_SETOWN>, "
"имеет другой смысл: вместо указания ID процесса, описывающего весь процесс, "
"она является ID нити, указывающим на определённую нить процесса. Поэтому "
"может понадобиться передать в B<F_SETOWN> результат B<gettid>(2), а не "
"B<getpid>(2), чтобы получить правильный результат при использовании "
"B<F_SETSIG>. (В имеющихся реализациях Linux ID главной нити совпадает с ID "
"процесса. Это означает, что в программе с одной нитью можно использовать "
"любой вызов, B<gettid>(2) или B<getpid>(2), в этом случае.) Однако заметим, "
"что утверждения этого абзаца не применимы к сигналу B<SIGURG>, генерируемому "
"для внеполосных данных сокета: этот сигнал всегда посылается или процессу "
"или группе процессов, в зависимости от значения, указанного для B<F_SETOWN>."

#. type: Plain text
#: man-pages/man2/fcntl.2:851
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""
"Описанное выше поведение было случайно удалено из Linux 2.6.12, и так и не "
"восстановлено. Начиная с Linux 2.6.32 используйте B<F_SETOWN_EX> при "
"назначении сигналов B<SIGIO> и B<SIGURG> для определённой нити."

#. type: TP
#: man-pages/man2/fcntl.2:851
#, no-wrap
msgid "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/fcntl.2:860
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""
"Получить настройки владения текущим файловым дескриптором, установленные "
"предыдущей командой B<F_SETOWN_EX>. Информация возвращается в структуре, "
"указанной в I<arg>, которая имеет следующий вид:"

#. type: Plain text
#: man-pages/man2/fcntl.2:867
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/fcntl.2:884
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""
"Поле I<type> будет равно: B<F_OWNER_TID>, B<F_OWNER_PID> или "
"B<F_OWNER_PGRP>. Значением поля I<pid> будет положительное целое, "
"представляющее ID нити, ID процесса или ID группы процессов. Подробности "
"смотрите в описании B<F_SETOWN_EX>."

#. type: TP
#: man-pages/man2/fcntl.2:884
#, no-wrap
msgid "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/fcntl.2:900
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller "
"to direct I/O availability signals to a specific thread, process, or process "
"group.  The caller specifies the target of signals via I<arg>, which is a "
"pointer to a I<f_owner_ex> structure.  The I<type> field has one of the "
"following values, which define how I<pid> is interpreted:"
msgstr ""
"Эта команда выполняет задачу, подобную B<F_SETOWN>. Она позволяет "
"вызывающему назначить сигналы доступности ввода-вывода определённой нити, "
"процессу или группе процессов. Вызывающий указывает приёмник сигналов в "
"I<arg>, выражаемый указателем на структуру I<f_owner_ex>. Поле I<type> имеет "
"одно из следующих значений, которое определяет чем считать I<pid>:"

#. type: TP
#: man-pages/man2/fcntl.2:901
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr "B<F_OWNER_TID>"

#. type: Plain text
#: man-pages/man2/fcntl.2:910
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""
"Посылать сигнал нити, чей ID (значение, возвращаемое вызовом B<clone>(2) или "
"B<gettid>(2)) указан в I<pid>."

#. type: TP
#: man-pages/man2/fcntl.2:910
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr "B<F_OWNER_PID>"

#. type: Plain text
#: man-pages/man2/fcntl.2:915
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr "Посылать сигнал процессу, чей ID указан в I<pid>."

#. type: TP
#: man-pages/man2/fcntl.2:915
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr "B<F_OWNER_PGRP>"

#. type: Plain text
#: man-pages/man2/fcntl.2:923
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note "
"that, unlike with B<F_SETOWN>, a process group ID is specified as a positive "
"value here.)"
msgstr ""
"Посылать сигнал группе процессов, чей ID указан в I<pid>. (Заметим, что в "
"отличие от B<F_SETOWN>, ID группы процессов здесь задаётся как положительное "
"значение.)"

#. type: TP
#: man-pages/man2/fcntl.2:924
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr "B<F_GETSIG> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:939
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""
"Получить (как результат функции) сигнал, посылаемый, когда становится "
"возможным ввод или вывод. Значение 0 означает сигнал B<SIGIO>. Любое другое "
"значение (включая B<SIGIO>) является другим сигналом, и в этом случае для "
"обработчика сигнала доступна дополнительная информация, если он был "
"установлен с B<SA_SIGINFO>. Аргумент I<arg> игнорируется."

#. type: TP
#: man-pages/man2/fcntl.2:939
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr "B<F_SETSIG> (I<int>)"

#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
#: man-pages/man2/fcntl.2:962
msgid ""
"Set the signal sent when input or output becomes possible to the value given "
"in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any "
"other value (including B<SIGIO>)  is the signal to send instead, and in this "
"case additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>."
msgstr ""
"Установить сигнал, который будет посылаться когда станет возможен ввод или "
"вывод, в значение, указанное в I<arg>. Значение 0 означает сигнал по "
"умолчанию B<SIGIO>. Любое другое значение (включая B<SIGIO>) является другим "
"сигналом, и в этом случае, для обработчика сигнала доступна дополнительная "
"информация, если он был установлен с B<SA_SIGINFO>."

#. type: Plain text
#: man-pages/man2/fcntl.2:990
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the "
"signal handler (see B<sigaction>(2)), extra information about I/O events is "
"passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field "
"indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""
"В случае использования B<F_SETSIG> с ненулевым значением и установкой "
"B<SA_SIGINFO> для обработчика сигнала (см. B<sigaction>(2)) обработчику "
"передаётся дополнительная информация о событиях ввода/вывода в структуре "
"I<siginfo_t>. Если поле I<si_code> показывает, что источник \\(em "
"B<SI_SIGIO>, то поле I<si_fd> содержит файловый дескриптор, ассоциированный "
"с событием. В противном случае не существует никакого механизма, чтобы "
"сообщить с каким файловым дескриптором связан полученный сигнал, и вы должны "
"использовать обычные механизмы (B<select>(2), B<poll>(2), B<read>(2) с "
"установленным B<O_NONBLOCK> и т.д.), чтобы определить какой файловый "
"дескриптор доступен для ввода/вывода."

#. type: Plain text
#: man-pages/man2/fcntl.2:1003
msgid ""
"Note that the file descriptor provided in I<si_fd> is the one that was "
"specified during the B<F_SETSIG> operation.  This can lead to an unusual "
"corner case.  If the file descriptor is duplicated (B<dup>(2)  or similar), "
"and the original file descriptor is closed, then I/O events will continue to "
"be generated, but the I<si_fd> field will contain the number of the now "
"closed file descriptor."
msgstr ""
"Заметим, что файловый дескриптор, предоставляемый в I<si_fd>, тот же, что "
"указывался при операции B<F_SETSIG>. Это может привести к редкой  тупиковой "
"ситуации. Если с файлового дескриптора делался дубль (B<dup>(2) или подобным "
"вызовом), и оригинальный файловый дескриптор закрыт, то события ввода-вывода "
"будут продолжать генерироваться, но поле I<si_fd> будет содержать номер "
"теперь уже закрытого файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fcntl.2:1012
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory.)  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""
"При выборе сигнала реального времени (значение E<gt>= B<SIGRTMIN>) в очередь "
"может добавляться несколько событий ввода-вывода с одинаковыми номерами "
"сигналов (размер очереди зависит от доступной памяти). Дополнительная "
"информация будет доступна как описано выше, если для обработчика сигнала "
"будет установлено B<SA_SIGINFO>."

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
#: man-pages/man2/fcntl.2:1025
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""
"Заметим, что в Linux есть предел на количество сигналов реального времени, "
"которые могут находиться в очереди процесса (см. B<getrlimit>(2) и "
"B<signal>(7)), и если этот предел достигнут, то ядро изменяет пункт доставки "
"B<SIGIO>, и этот сигнал доставляется всему процессу, а не указанной нити."

#. type: Plain text
#: man-pages/man2/fcntl.2:1032
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""
"Используя эти механизмы, программа может реализовать полностью асинхронный "
"ввод-вывод почти не используя в своей работе B<select>(2) или B<poll>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1056
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""
"Использование B<O_ASYNC>, является специфичным для BSD и Linux. В POSIX.1 "
"описано только использование B<F_GETOWN> и B<F_SETOWN> вместе с сигналом "
"B<SIGURG> для сокетов (в POSIX не определён сигнал B<SIGIO>). "
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and B<F_SETSIG> есть только в "
"Linux. В POSIX описан асинхронный ввод-вывод и структура I<aio_sigevent>, "
"используемая для сходных действий; они также доступны в Linux как часть "
"библиотеки GNU C (Glibc)."

#. type: SS
#: man-pages/man2/fcntl.2:1056
#, no-wrap
msgid "Leases"
msgstr "Аренда"

#. type: Plain text
#: man-pages/man2/fcntl.2:1071
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used to establish a "
"new lease, and retrieve the current lease, on the open file description "
"referred to by the file descriptor I<fd>.  A file lease provides a mechanism "
"whereby the process holding the lease (the \"lease holder\") is notified "
"(via delivery of a signal)  when a process (the \"lease breaker\") tries to "
"B<open>(2)  or B<truncate>(2)  the file referred to by that file descriptor."
msgstr ""
"Команды B<F_SETLEASE> и B<F_GETLEASE> (в Linux 2.4 и выше) используются для "
"установки новой и получения текущей аренды открытого описания файла, на "
"который указывает файловый дескриптор I<fd>. Аренда файла предоставляет "
"механизм, посредством которого процесс, который удерживает аренду "
"(«арендатор»), уведомляется (отправкой сигнала), когда процесс («нарушитель "
"аренды») пытается выполнить вызов B<open>(2) или B<truncate>(2) на файл, "
"указанный в этом файловом дескрипторе."

#. type: TP
#: man-pages/man2/fcntl.2:1071
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr "B<F_SETLEASE> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1076
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""
"Установить или удалить аренду файла, в соответствии со значениями, "
"указываемыми в I<arg>:"

#. type: TP
#: man-pages/man2/fcntl.2:1077
#, no-wrap
msgid "B<F_RDLCK>"
msgstr "B<F_RDLCK>"

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
#: man-pages/man2/fcntl.2:1086
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""
"Установить аренду чтения. Это приведёт к генерации уведомления вызывающего "
"процесса, когда файл открывается для записи или усечения. Аренда чтения "
"может быть выделена только на файловый дескриптор, открытый только на чтение."

#. type: TP
#: man-pages/man2/fcntl.2:1086
#, no-wrap
msgid "B<F_WRLCK>"
msgstr "B<F_WRLCK>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1093
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be "
"placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""
"Установить аренду записи. Это приведёт к генерации уведомления вызывающего "
"процесса, когда файл открывается для чтения или записи или выполняется его "
"усечение. Аренда записи может быть установлена на файл, только если этот "
"файл не имеет других открытых файловых дескрипторов."

#. type: TP
#: man-pages/man2/fcntl.2:1093
#, no-wrap
msgid "B<F_UNLCK>"
msgstr "B<F_UNLCK>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1096
msgid "Remove our lease from the file."
msgstr "Удалить аренду с указанного файла."

#. type: Plain text
#: man-pages/man2/fcntl.2:1110
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released "
"by either an explicit B<F_UNLCK> operation on any of these duplicate file "
"descriptors, or when all such file descriptors have been closed."
msgstr ""
"Аренды ассоциируются с открытым файловым описанием (см. B<open>(2)). Это "
"значит, что дублированные файловые дескрипторы (созданные, например, "
"B<fork>(2) или B<dup>(2)) указывают на одну и ту же аренду, и эта аренда "
"может изменяться или освобождаться через любой из этих дескрипторов. Более "
"того, аренда освобождается или через явную команду B<F_UNLCK> на любом из "
"этих дублированных файловых дескрипторов, или когда все эти файловые "
"дескрипторы будут закрыты."

#. type: Plain text
#: man-pages/man2/fcntl.2:1117
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID "
"of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""
"Аренды могут быть выданы только на обычные файлы. Непривилегированный "
"процесс может получить аренду только на файл, чей UID (владельца) совпадает "
"с UID на файловой системе процесса. Процесс с мандатом B<CAP_LEASE> может "
"получить аренду на любые файлы."

#. type: TP
#: man-pages/man2/fcntl.2:1117
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr "B<F_GETLEASE> (I<void>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1126
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by "
"returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""
"Узнать какой тип аренды ассоциирован с файловым дескриптором I<fd>; "
"возвращается одно из значений B<F_RDLCK>, B<F_WRLCK> или B<F_UNLCK>, "
"соответственно означающих аренду на чтение, запись или что аренды нет. "
"Аргумент I<arg> игнорируется."

#. type: Plain text
#: man-pages/man2/fcntl.2:1157
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or "
"B<truncate>(2)  that conflicts with a lease established via B<F_SETLEASE>, "
"the system call is blocked by the kernel and the kernel notifies the lease "
"holder by sending it a signal (B<SIGIO> by default).  The lease holder "
"should respond to receipt of this signal by doing whatever cleanup is "
"required in preparation for the file to be accessed by another process (e."
"g., flushing cached buffers) and then either remove or downgrade its lease.  "
"A lease is removed by performing an B<F_SETLEASE> command specifying I<arg> "
"as B<F_UNLCK>.  If the lease holder currently holds a write lease on the "
"file, and the lease breaker is opening the file for reading, then it is "
"sufficient for the lease holder to downgrade the lease to a read lease.  "
"This is done by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_RDLCK>."
msgstr ""
"Когда процесс («нарушителя аренды») выполняет вызов B<open>(2) или "
"B<truncate>(2), который конфликтует с арендой, установленной через "
"B<F_SETLEASE>, то системный вызов блокируется ядром и ядро уведомляет "
"арендатора сигналом (по умолчанию B<SIGIO>). Арендатор должен при получении "
"этого сигнала выполнить все необходимые действия по очистке для подготовки "
"этого файла к использованию другим процессом (например, сбросить буферы "
"кэша) и затем удалить или снизить условия аренды. Аренда удаляется по "
"команде B<F_SETLEASE> с аргументом I<arg>, установленным в B<F_UNLCK>. Если "
"арендатор удерживает аренду на запись в файл, и нарушитель аренды открывает "
"файл на чтение, то достаточно того, что арендатор понизит условия аренды до "
"аренды на чтение. Это выполняется командой B<F_SETLEASE> с аргументом "
"I<arg>, установленным в B<F_RDLCK>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1162
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""
"Если арендатор не освободит аренду или не снизит условия в течении "
"определённого количества секунд, указанного в файле I</proc/sys/fs/lease-"
"break-time>, то ядро принудительно удалит или снизит условия аренды для "
"арендатора."

#. type: Plain text
#: man-pages/man2/fcntl.2:1172
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""
"После того, как был начат разрыв аренды, B<F_GETLEASE> возвращает тип "
"назначения аренды (или B<F_RDLCK> или B<F_UNLCK>, в зависимости от "
"необходимости совместимости с нарушителем аренды) до тех пор, пока держатель "
"аренды добровольно не отдаст или не удалит аренду или ядро принудительно не "
"сделает это после истечения таймера разрыва аренды."

#. type: Plain text
#: man-pages/man2/fcntl.2:1176
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""
"После того как аренда снята держателем аренды или принудительно удалена и "
"снижены условия, и предполагая, что нарушитель аренды не выполнял "
"неблокирующий системный вызов, ядро позволяет продолжить работу системного "
"вызова нарушителя аренды."

#. type: Plain text
#: man-pages/man2/fcntl.2:1197
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted "
"by a signal handler, then the system call fails with the error B<EINTR>, but "
"the other steps still occur as described above.  If the lease breaker is "
"killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the "
"other steps still occur as described above.  If the lease breaker specifies "
"the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""
"Если нарушитель аренды, заблокированный в B<open>(2) или B<truncate>(2), "
"прерывается обработчиком сигнала, то системный вызов завершается неудачно с "
"ошибкой B<EINTR>, но другие шаги по-прежнему выполняются как описано ранее. "
"Если нарушитель аренды завершается по сигналу будучи блокированным в "
"B<open>(2) или B<truncate>(2), то другие шаги по-прежнему выполняются как "
"описано ранее. Если нарушитель аренды указал флаг B<O_NONBLOCK> при вызове "
"B<open>(2), то вызов немедленно завершается неудачей с ошибкой "
"B<EWOULDBLOCK>, но другие шаги по-прежнему выполняются как описано ранее. "

#. type: Plain text
#: man-pages/man2/fcntl.2:1218
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can "
"be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the file descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files.)"
msgstr ""
"По умолчанию, для уведомления арендатора используется сигнал B<SIGIO>, но "
"его можно изменить, используя команду B<F_SETSIG> для B<fcntl>(). Если "
"выполняется команда B<F_SETSIG> (даже назначая сигнал B<SIGIO>), и при этом "
"обработчик сигнала устанавливается с использованием B<SA_SIGINFO>, то "
"обработчик получит в качестве второго аргумента структуру I<siginfo_t>, в "
"которой поле I<si_fd> будет содержать файловый дескриптор арендованного "
"файла, к которому пытается получить доступ другой процесс (это полезно, если "
"вызывающий процесс удерживает аренду на несколько файлов)."

#. type: SS
#: man-pages/man2/fcntl.2:1218
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr "Уведомления об изменении файла и каталога (dnotify)"

#. type: TP
#: man-pages/man2/fcntl.2:1219
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr "B<F_NOTIFY> (I<int>)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1229
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""
"(Начиная с Linux 2.4) Уведомлять при смене каталога, на который указывает "
"I<fd> или когда изменились файлы, которые в нём содержатся. События, о "
"наступлении которых делается уведомление, задаются в аргументе I<arg>, "
"который является битовой маской, получаемой сложением (OR) одного или более "
"следующих бит:"

#. type: TP
#: man-pages/man2/fcntl.2:1232
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr "B<DN_ACCESS>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1239
msgid "A file was accessed (B<read>(2), B<pread>(2), B<readv>(2), and similar)"
msgstr ""
"Был произведён доступ к файлу (B<read>(2), B<pread>(2), B<readv>(2) и "
"подобные)."

#. type: TP
#: man-pages/man2/fcntl.2:1239
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr "B<DN_MODIFY>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1248
msgid ""
"A file was modified (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2), and similar)."
msgstr ""
"Файл был изменён (B<write>(2), B<pwrite>(2), B<writev>(2), B<truncate>(2), "
"B<ftruncate>(2) и подобные)."

#. type: TP
#: man-pages/man2/fcntl.2:1248
#, no-wrap
msgid "B<DN_CREATE>"
msgstr "B<DN_CREATE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1259
msgid ""
"A file was created (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2)  into this directory)."
msgstr ""
"Файл был создан (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2) в этом каталоге)."

#. type: TP
#: man-pages/man2/fcntl.2:1259
#, no-wrap
msgid "B<DN_DELETE>"
msgstr "B<DN_DELETE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1266
msgid ""
"A file was unlinked (B<unlink>(2), B<rename>(2)  to another directory, "
"B<rmdir>(2))."
msgstr ""
"Файл был удалён (B<unlink>(2), B<rename>(2) в другой каталог, B<rmdir>(2))."

#. type: TP
#: man-pages/man2/fcntl.2:1266
#, no-wrap
msgid "B<DN_RENAME>"
msgstr "B<DN_RENAME>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1270
msgid "A file was renamed within this directory (B<rename>(2))."
msgstr "Файл был переименован внутри каталога (B<rename>(2))."

#. type: TP
#: man-pages/man2/fcntl.2:1270
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr "B<DN_ATTRIB>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1278
msgid ""
"The attributes of a file were changed (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2), and similar)."
msgstr ""
"У файла были изменены атрибуты (B<chown>(2), B<chmod>(2), B<utime>(2), "
"B<utimensat>(2) и подобные)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1286
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro "
"must be defined before including I<any> header files.)"
msgstr ""
"(Чтобы получить эти определения, нужно задать макрос тестирования свойств "
"B<_GNU_SOURCE> перед I<всеми> остальными заголовочными файлами.)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1294
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""
"Уведомления об изменении состояния каталога обычно однократные и приложение "
"должно перерегистрировать установку уведомлений, чтобы и дальше получать их. "
"Однако, если в аргумент I<arg>, добавить B<DN_MULTISHOT>, то уведомления "
"будут приходить до тех пор, пока не будут явно отменены."

#.  The following does seem a poor API-design choice...
#. type: Plain text
#: man-pages/man2/fcntl.2:1306
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""
"Серии запросов B<F_NOTIFY> добавляются к событиям в I<arg>, которые уже "
"установлены. Чтобы выключить уведомления всех событий, выполните вызов "
"B<F_NOTIFY>, указав 0 в I<arg>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1329
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to "
"B<fcntl>().  (Note that B<SIGIO> is one of the nonqueuing standard signals; "
"switching to the use of a real-time signal means that multiple notifications "
"can be queued to the process.)  In the latter case, the signal handler "
"receives a I<siginfo_t> structure as its second argument (if the handler was "
"established using B<SA_SIGINFO>)  and the I<si_fd> field of this structure "
"contains the file descriptor which generated the notification (useful when "
"establishing notification on multiple directories)."
msgstr ""
"Уведомление происходит посредством доставки сигнала. Сигналом по умолчанию "
"является B<SIGIO>, но это можно изменить с помощью команды B<F_SETSIG> "
"B<fcntl>() (заметим, что B<SIGIO> — один из безочерёдных стандартных "
"сигналов; переход к использованию сигнала реального времени означает, что "
"многократные уведомления могут попасть в очередь процесса). В последнем "
"случае, обработчик сигнала принимает структуру I<siginfo_t> в качестве "
"второго аргумента (если обработчик был установлен с помощью B<SA_SIGINFO>), "
"в поле I<si_fd> этой структуры содержится файловый описатель, для которого "
"сгенерировано уведомление (полезно при учёте уведомлений из нескольких "
"каталогов)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1334
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for "
"notification, so that multiple notifications can be queued."
msgstr ""
"Кроме того, когда используется B<DN_MULTISHOT>, для уведомлений должен бы "
"быть использован сигнал реального времени, так что множественные уведомления "
"могут быть поставлены в очередь."

#. type: Plain text
#: man-pages/man2/fcntl.2:1343
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining "
"notifications of filesystem events.  See B<inotify>(7)."
msgstr ""
"B<ЗАМЕЧАНИЕ:> В новых приложениях нужно использовать интерфейс I<inotify> "
"(доступен начиная с ядра 2.6.13), который предоставляет намного лучший "
"интерфейс для получения уведомлений о событиях в файловой системе. Смотрите "
"B<inotify>(7)."

#. type: SS
#: man-pages/man2/fcntl.2:1343
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr "Изменение ёмкости канала"

#. type: TP
#: man-pages/man2/fcntl.2:1344
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr "B<F_SETPIPE_SZ> (I<int>; начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1365
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"max-size> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in I</proc/sys/"
"fs/pipe-max-size> yield the error B<EPERM>; a privileged process "
"(B<CAP_SYS_RESOURCE>)  can override the limit."
msgstr ""
"Изменяет ёмкость канала, на который указывает I<fd>; она становится равной "
"не менее I<arg> байт. Непривилегированный процесс может задать ёмкость "
"канала любого значения, начиная с размера системной страницы до ограничения, "
"заданного в I</proc/sys/fs/pipe-max-size> (смотрите B<proc>(5)). При задании "
"ёмкости меньше размера страницы, она будет без ошибок округлена до размера "
"страницы. При задании непривилегированным процессом ёмкости канала больше "
"ограничения из I</proc/sys/fs/pipe-max-size> приведёт к ошибке B<EPERM>; "
"привилегированный процесс (с B<CAP_SYS_RESOURCE>) может превысить это "
"ограничение."

#. type: Plain text
#: man-pages/man2/fcntl.2:1374
msgid ""
"When allocating the buffer for the pipe, the kernel may use a capacity "
"larger than I<arg>, if that is convenient for the implementation.  (In the "
"current implementation, the allocation is the next higher power-of-two page-"
"size multiple of the requested size.)  The actual capacity (in bytes) that "
"is set is returned as the function result."
msgstr ""
"При выделении буфера под канал ядро может использовать большую ёмкость чем "
"указано в I<arg>, если это удобно для реализации (в текущей реализации "
"размером выделения является следующий кратный степени двойки размер страницы "
"больший запрашиваемого размера). Реальным размером (в байтах) считается "
"возвращаемый результат функции."

#. type: Plain text
#: man-pages/man2/fcntl.2:1378
msgid ""
"Attempting to set the pipe capacity smaller than the amount of buffer space "
"currently used to store data produces the error B<EBUSY>."
msgstr ""
"Попытка задать ёмкость канала меньшую размера буферного пространства, "
"используемого в данный момент для хранения данных в канале приводит к ошибке "
"B<EBUSY>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1383
msgid ""
"Note that because of the way the pages of the pipe buffer are employed when "
"data is written to the pipe, the number of bytes that can be written may be "
"less than the nominal size, depending on the size of the writes."
msgstr ""
"Заметим, что из-за способа использования страниц буфера канала при записи "
"данных количество байт, которые могут быть записаны, может быть меньше, чем "
"номинальный размер, в зависимости от размера записей."

#. type: TP
#: man-pages/man2/fcntl.2:1383
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr "B<F_GETPIPE_SZ> (I<void>; начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1388
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr "Возвращает (как результат функции) ёмкость канала, указываемого I<fd>."

#. type: SS
#: man-pages/man2/fcntl.2:1388
#, no-wrap
msgid "File Sealing"
msgstr "Опечатывание файла (file sealing)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1400
msgid ""
"File seals limit the set of allowed operations on a given file.  For each "
"seal that is set on a file, a specific set of operations will fail with "
"B<EPERM> on this file from now on.  The file is said to be sealed.  The "
"default set of seals depends on the type of the underlying file and "
"filesystem.  For an overview of file sealing, a discussion of its purpose, "
"and some code examples, see B<memfd_create>(2)."
msgstr ""
"Опечатывание файла позволяет ограничить набор выполняемых над файлом "
"операций. Любая операция с файлом, попавшая в набор опечатанных, завершается "
"с ошибкой B<EPERM>. Набор печатей по умолчанию зависит от типа файла, к "
"которому он применяется и файловой системы. Описание опечатывания файла, "
"предназначение и примеры кода смотрите в B<memfd_create>(2)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1411
msgid ""
"Currently, file seals can be applied only to a file descriptor returned by "
"B<memfd_create>(2)  (if the B<MFD_ALLOW_SEALING> was employed).  On other "
"filesystems, all B<fcntl>()  operations that operate on seals will return "
"B<EINVAL>."
msgstr ""
"В настоящее время опечатывание файла может применяться к файловому "
"дескриптору, возвращаемому B<memfd_create>(2) (если был указан "
"B<MFD_ALLOW_SEALING>). В других файловых системах все операции B<fcntl>(), "
"относящиеся к печатям, возвращают B<EINVAL>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1416
msgid ""
"Seals are a property of an inode.  Thus, all open file descriptors referring "
"to the same inode share the same set of seals.  Furthermore, seals can never "
"be removed, only added."
msgstr ""
"Печати (seals) — свойство inode. То есть все открытые файловые дескрипторы, "
"указывающие на один inode, имеют общий набор печатей. Кроме этого, печати "
"нельзя удалять, можно только добавлять."

#. type: TP
#: man-pages/man2/fcntl.2:1416
#, no-wrap
msgid "B<F_ADD_SEALS> (I<int>; since Linux 3.17)"
msgstr "B<F_ADD_SEALS> (I<int>; начиная с Linux 3.17)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1434
msgid ""
"Add the seals given in the bit-mask argument I<arg> to the set of seals of "
"the inode referred to by the file descriptor I<fd>.  Seals cannot be removed "
"again.  Once this call succeeds, the seals are enforced by the kernel "
"immediately.  If the current set of seals includes B<F_SEAL_SEAL> (see "
"below), then this call will be rejected with B<EPERM>.  Adding a seal that "
"is already set is a no-op, in case B<F_SEAL_SEAL> is not set already.  In "
"order to place a seal, the file descriptor I<fd> must be writable."
msgstr ""
"Добавляет печати из значения битовой маски I<arg> в набор печатей inode, на "
"которую ссылается файловый дескриптор I<fd>. Печати из набора нельзя "
"удалить. После успешного выполнения, печати сразу же учитываются ядром. Если "
"в текущий набор печатей входит B<F_SEAL_SEAL> (смотрите далее), то этот "
"вызов завершается с ошибкой B<EPERM>. Добавление уже установленной печати ни "
"к чему не приводит, если ещё не указана B<F_SEAL_SEAL>. Чтобы разместить "
"печать файловый дескриптор I<fd> должен быть доступен на запись."

#. type: TP
#: man-pages/man2/fcntl.2:1434
#, no-wrap
msgid "B<F_GET_SEALS> (I<void>; since Linux 3.17)"
msgstr "B<F_GET_SEALS> (I<void>; начиная с Linux 3.17)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1444
msgid ""
"Return (as the function result) the current set of seals of the inode "
"referred to by I<fd>.  If no seals are set, 0 is returned.  If the file does "
"not support sealing, -1 is returned and I<errno> is set to B<EINVAL>."
msgstr ""
"Возвращает (в виде результата функции) текущий набор печатей inode, на "
"которую указывает I<fd>. Если печатей нет, возвращается 0. Если файл не "
"поддерживает опечатывание, то возвращается -1 и I<errno> присваивается "
"B<EINVAL>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1446
msgid "The following seals are available:"
msgstr "Доступны следующие печати:"

#. type: TP
#: man-pages/man2/fcntl.2:1446
#, no-wrap
msgid "B<F_SEAL_SEAL>"
msgstr "B<F_SEAL_SEAL>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1458
msgid ""
"If this seal is set, any further call to B<fcntl>()  with B<F_ADD_SEALS> "
"fails with the error B<EPERM>.  Therefore, this seal prevents any "
"modifications to the set of seals itself.  If the initial set of seals of a "
"file includes B<F_SEAL_SEAL>, then this effectively causes the set of seals "
"to be constant and locked."
msgstr ""
"Если печать установлена, то последующий вызов B<fcntl>() с B<F_ADD_SEALS> "
"завершится ошибкой B<EPERM>. Таки образом, данная печать предотвращает "
"изменения самого набора печатей. Если начальный набор печатей файла содержит "
"B<F_SEAL_SEAL>, то он является постоянным и неизменяемым."

#. type: TP
#: man-pages/man2/fcntl.2:1458
#, no-wrap
msgid "B<F_SEAL_SHRINK>"
msgstr "B<F_SEAL_SHRINK>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1473
msgid ""
"If this seal is set, the file in question cannot be reduced in size.  This "
"affects B<open>(2)  with the B<O_TRUNC> flag as well as B<truncate>(2)  and "
"B<ftruncate>(2).  Those calls fail with B<EPERM> if you try to shrink the "
"file in question.  Increasing the file size is still possible."
msgstr ""
"Если эта печать установлена, то нельзя уменьшить размер файла. Она влияет на "
"B<open>(2) с флагом B<O_TRUNC>, а также на B<truncate>(2) и B<ftruncate>(2). "
"Эти вызовы завершаются ошибкой B<EPERM>, если пытаются уменьшить файл. "
"Увеличение размера файла по-прежнему возможно."

#. type: TP
#: man-pages/man2/fcntl.2:1473
#, no-wrap
msgid "B<F_SEAL_GROW>"
msgstr "B<F_SEAL_GROW>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1487
msgid ""
"If this seal is set, the size of the file in question cannot be increased.  "
"This affects B<write>(2)  beyond the end of the file, B<truncate>(2), "
"B<ftruncate>(2), and B<fallocate>(2).  These calls fail with B<EPERM> if you "
"use them to increase the file size.  If you keep the size or shrink it, "
"those calls still work as expected."
msgstr ""
"Если эта печать установлена, то нельзя увеличить размер файла. Она влияет на "
"B<write>(2) за концом файла, B<truncate>(2), B<ftruncate>(2) и "
"B<fallocate>(2). Эти вызовы завершаются ошибкой B<EPERM>, если пытаются "
"увеличить файл. Уменьшение размера файла по-прежнему возможно."

#. type: TP
#: man-pages/man2/fcntl.2:1487
#, no-wrap
msgid "B<F_SEAL_WRITE>"
msgstr "B<F_SEAL_WRITE>"

#.  One or more other seals are typically used with F_SEAL_WRITE
#.  because, given a file with the F_SEAL_WRITE seal set, then,
#.  while it would no longer be possible to (say) write zeros into
#.  the last 100 bytes of a file, it would still be possible
#.  to (say) shrink the file by 100 bytes using ftruncate(), and
#.  then increase the file size by 100 bytes, which would have
#.  the effect of replacing the last hundred bytes by zeros.
#. type: Plain text
#: man-pages/man2/fcntl.2:1515
msgid ""
"If this seal is set, you cannot modify the contents of the file.  Note that "
"shrinking or growing the size of the file is still possible and allowed.  "
"Thus, this seal is normally used in combination with one of the other "
"seals.  This seal affects B<write>(2)  and B<fallocate>(2)  (only in "
"combination with the B<FALLOC_FL_PUNCH_HOLE> flag).  Those calls fail with "
"B<EPERM> if this seal is set.  Furthermore, trying to create new shared, "
"writable memory-mappings via B<mmap>(2)  will also fail with B<EPERM>."
msgstr ""
"Если эта печать установлена, то нельзя изменить содержимое файла. Заметим, "
"что уменьшение или увеличение файла по-прежнему возможно. То есть данная "
"печать, обычно, используется в комбинации с одной из этих печатей. Данная "
"печать влияет на B<write>(2) и B<fallocate>(2) (только для флага "
"B<FALLOC_FL_PUNCH_HOLE>). Эти вызовы завершаются ошибкой B<EPERM>. Кроме "
"этого, попытка создать новое общее, доступное на запись отображение через "
"B<mmap>(2) также завершится ошибкой B<EPERM>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1529
msgid ""
"Using the B<F_ADD_SEALS> operation to set the B<F_SEAL_WRITE> seal fails "
"with B<EBUSY> if any writable, shared mapping exists.  Such mappings must be "
"unmapped before you can add this seal.  Furthermore, if there are any "
"asynchronous I/O operations (B<io_submit>(2))  pending on the file, all "
"outstanding writes will be discarded."
msgstr ""
"Использование операции B<F_ADD_SEALS> для установки B<F_SEAL_WRITE> "
"завершается ошибкой B<EBUSY>, если существует доступное на запись общее "
"отображение. Такие отображения должны быть удалены перед добавлением данной "
"печати. Кроме этого, если у файла есть асинхронные операции, ожидающие ввода-"
"вывода (B<io_submit>(2)), то все отложенные операции записи будут отброшены."

#. type: SS
#: man-pages/man2/fcntl.2:1529
#, no-wrap
msgid "File read/write hints"
msgstr "Подсказки чтения/записи файла"

#. type: Plain text
#: man-pages/man2/fcntl.2:1539
msgid ""
"Write lifetime hints can be used to inform the kernel about the relative "
"expected lifetime of writes on a given inode or via a particular open file "
"description.  (See B<open>(2)  for an explanation of open file "
"descriptions.)  In this context, the term \"write lifetime\" means the "
"expected time the data will live on media, before being overwritten or "
"erased."
msgstr ""
"Подсказки срока службы записи можно использовать для уведомления ядра об "
"относительно ожидаемом сроке службы записи заданной иноды и открытого "
"файлового описания (об открытых файловых описаниях читайте в B<open>(2)). В "
"этом контексте термин «срок службы записи» (write lifetime) означает "
"ожидаемое время, которое будут существовать данные на носителе до их "
"перезаписи или стирания."

#. type: Plain text
#: man-pages/man2/fcntl.2:1547
msgid ""
"An application may use the different hint values specified below to separate "
"writes into different write classes, so that multiple users or applications "
"running on a single storage back-end can aggregate their I/O patterns in a "
"consistent manner.  However, there are no functional semantics implied by "
"these flags, and different I/O classes can use the write lifetime hints in "
"arbitrary ways, so long as the hints are used consistently."
msgstr ""
"В приложении можно использовать различные значения подсказок, перечисленные "
"ниже, для разделения записей на различные классы, чтобы несколько "
"пользователей или приложений, работающие на одном аппаратном хранилище могли "
"объединить свои шаблоны ввода-вывода в непротиворечивую форму. Однако, для "
"флагов не подразумевается какая-то функциональная семантика, и для различных "
"классов ввода-вывода можно использовать подсказки срока службы записи "
"произвольным образом, пока подсказки не противоречат друг другу."

#. type: Plain text
#: man-pages/man2/fcntl.2:1550
msgid "The following operations can be applied to the file descriptor, I<fd>:"
msgstr "Следующие операции могут применяться к файловому дескриптору I<fd>:"

#. type: TP
#: man-pages/man2/fcntl.2:1550
#, no-wrap
msgid "B<F_GET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_GET_RW_HINT> (I<uint64_t *>; начиная с Linux 4.13)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1555
msgid ""
"Returns the value of the read/write hint associated with the underlying "
"inode referred to by I<fd>."
msgstr ""
"Возвращает значение подсказки чтения/записи, связанной с инодой, на которую "
"указывает I<fd>."

#. type: TP
#: man-pages/man2/fcntl.2:1555
#, no-wrap
msgid "B<F_SET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_SET_RW_HINT> (I<uint64_t *>; начиная с Linux 4.13)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1562
msgid ""
"Sets the read/write hint value associated with the underlying inode referred "
"to by I<fd>.  This hint persists until either it is explicitly modified or "
"the underlying filesystem is unmounted."
msgstr ""
"Изменяет значение подсказки чтения/записи, связанной с инодой, на которую "
"указывает I<fd>. Данная подсказка действует до тех пор, пока не будет явно "
"изменена или не будет размонтирована нижележащая файловая система."

#. type: TP
#: man-pages/man2/fcntl.2:1562
#, no-wrap
msgid "B<F_GET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_GET_FILE_RW_HINT> (I<uint64_t *>; начиная с Linux 4.13)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1567
msgid ""
"Returns the value of the read/write hint associated with the open file "
"description referred to by I<fd>."
msgstr ""
"Возвращает значение подсказки чтения/записи, связанной с открытым файловым "
"описанием, на которое указывает I<fd>."

#. type: TP
#: man-pages/man2/fcntl.2:1567
#, no-wrap
msgid "B<F_SET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr "B<F_SET_FILE_RW_HINT> (I<uint64_t *>; начиная с Linux 4.13)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1572
msgid ""
"Sets the read/write hint value associated with the open file description "
"referred to by I<fd>."
msgstr ""
"Изменяет значение подсказки чтения/записи, связанной с открытым файловым "
"описанием, на которое указывает I<fd>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1575
msgid ""
"If an open file description has not been assigned a read/write hint, then it "
"shall use the value assigned to the inode, if any."
msgstr ""
"Если открытому файловому описанию не была назначена подсказка чтения/записи, "
"то будет использоваться значение (если есть), назначенное иноде."

#. type: Plain text
#: man-pages/man2/fcntl.2:1578
msgid "The following read/write hints are valid since Linux 4.13:"
msgstr "Начиная с Linux 4.13, действуют следующие подсказки чтения/записи:"

#. type: TP
#: man-pages/man2/fcntl.2:1578
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NOT_SET>"
msgstr "B<RWH_WRITE_LIFE_NOT_SET>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1582
msgid "No specific hint has been set.  This is the default value."
msgstr "Подсказка не задана. Это значение по умолчанию."

#. type: TP
#: man-pages/man2/fcntl.2:1582
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NONE>"
msgstr "B<RWH_WRITE_LIFE_NONE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1585
msgid "No specific write lifetime is associated with this file or inode."
msgstr "Срока службы записи, связанного с этим файлом или инодой, не задано."

#. type: TP
#: man-pages/man2/fcntl.2:1585
#, no-wrap
msgid "B<RWH_WRITE_LIFE_SHORT>"
msgstr "B<RWH_WRITE_LIFE_SHORT>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1589
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a short lifetime."
msgstr ""
"Ожидается, что данные, записанные в эту иноду или через открытое файловое "
"описание, будут иметь короткий срок службы."

#. type: TP
#: man-pages/man2/fcntl.2:1589
#, no-wrap
msgid "B<RWH_WRITE_LIFE_MEDIUM>"
msgstr "B<RWH_WRITE_LIFE_MEDIUM>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1595
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_SHORT>."
msgstr ""
"Ожидается, что данные, записанные в эту иноду или через открытое файловое "
"описание, будут иметь срок службы длиннее, чем данные, записанные с "
"B<RWH_WRITE_LIFE_SHORT>."

#. type: TP
#: man-pages/man2/fcntl.2:1595
#, no-wrap
msgid "B<RWH_WRITE_LIFE_LONG>"
msgstr "B<RWH_WRITE_LIFE_LONG>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1601
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_MEDIUM>."
msgstr ""
"Ожидается, что данные, записанные в эту иноду или через открытое файловое "
"описание, будут иметь срок службы длиннее, чем данные, записанные с "
"B<RWH_WRITE_LIFE_MEDIUM>."

#. type: TP
#: man-pages/man2/fcntl.2:1601
#, no-wrap
msgid "B<RWH_WRITE_LIFE_EXTREME>"
msgstr "B<RWH_WRITE_LIFE_EXTREME>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1607
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_LONG>."
msgstr ""
"Ожидается, что данные, записанные в эту иноду или через открытое файловое "
"описание, будут иметь срок службы длиннее, чем данные, записанные с "
"B<RWH_WRITE_LIFE_LONG>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1610
msgid ""
"All the write-specific hints are relative to each other, and no individual "
"absolute meaning should be attributed to them."
msgstr ""
"Все подсказки записи соотносятся друг с другом и нет отдельного абсолютного "
"смысла им предписываемого."

#. type: Plain text
#: man-pages/man2/fcntl.2:1612
msgid "For a successful call, the return value depends on the operation:"
msgstr ""
"При успешном выполнении возвращаемое значение зависит от используемой "
"команды:"

#. type: TP
#: man-pages/man2/fcntl.2:1612
#, no-wrap
msgid "B<F_DUPFD>"
msgstr "B<F_DUPFD>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1615
msgid "The new file descriptor."
msgstr "Новый файловый дескриптор."

#. type: TP
#: man-pages/man2/fcntl.2:1615
#, no-wrap
msgid "B<F_GETFD>"
msgstr "B<F_GETFD>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1618
msgid "Value of file descriptor flags."
msgstr "Значение флагов файлового дескриптора."

#. type: TP
#: man-pages/man2/fcntl.2:1618
#, no-wrap
msgid "B<F_GETFL>"
msgstr "B<F_GETFL>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1621
msgid "Value of file status flags."
msgstr "Значение флагов состояния файла."

#. type: TP
#: man-pages/man2/fcntl.2:1621
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr "B<F_GETLEASE>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1624
msgid "Type of lease held on file descriptor."
msgstr "Тип аренды, установленной на файлом дескрипторе."

#. type: TP
#: man-pages/man2/fcntl.2:1624
#, no-wrap
msgid "B<F_GETOWN>"
msgstr "B<F_GETOWN>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1627
msgid "Value of file descriptor owner."
msgstr "Значение, представляющее собой владельца файлового дескриптора."

#. type: TP
#: man-pages/man2/fcntl.2:1627
#, no-wrap
msgid "B<F_GETSIG>"
msgstr "B<F_GETSIG>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1633
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""
"Значение сигнала, посылаемого когда становится возможным чтение или запись "
"или ноль для традиционного поведения B<SIGIO>."

#. type: TP
#: man-pages/man2/fcntl.2:1633
#, no-wrap
msgid "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"
msgstr "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1636
msgid "The pipe capacity."
msgstr "Ёмкость канала."

#. type: TP
#: man-pages/man2/fcntl.2:1636
#, no-wrap
msgid "B<F_GET_SEALS>"
msgstr "B<F_GET_SEALS>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1641
msgid ""
"A bit mask identifying the seals that have been set for the inode referred "
"to by I<fd>."
msgstr "Битовая маска, описывающая печати inode, на которую указывает I<fd>."

#. type: TP
#: man-pages/man2/fcntl.2:1641
#, no-wrap
msgid "All other commands"
msgstr "Все остальные команды"

#. type: Plain text
#: man-pages/man2/fcntl.2:1644
msgid "Zero."
msgstr "Ноль."

#. type: Plain text
#: man-pages/man2/fcntl.2:1648
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"В случае ошибки возвращается -1 и значение I<errno> устанавливается "
"соответствующим образом."

#. type: TP
#: man-pages/man2/fcntl.2:1649
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr "B<EACCES> или B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1652
msgid "Operation is prohibited by locks held by other processes."
msgstr ""
"Операция запрещена блокировками, которые удерживаются другими процессами."

#. type: Plain text
#: man-pages/man2/fcntl.2:1656
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""
"Операция запрещена, потому что файл отображается в память другим процессом."

#. type: Plain text
#: man-pages/man2/fcntl.2:1660
msgid "I<fd> is not an open file descriptor"
msgstr "Значение I<fd> не является открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man2/fcntl.2:1669
msgid ""
"I<cmd> is B<F_SETLK> or B<F_SETLKW> and the file descriptor open mode "
"doesn't match with the type of lock requested."
msgstr ""
"Значение I<cmd> равно B<F_SETLK> или B<F_SETLKW>, но режим открытия "
"файлового дескриптора не совпадает с типом запрошенной блокировки."

#. type: TP
#: man-pages/man2/fcntl.2:1669 man-pages/man2/fcntl.2:1678
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/fcntl.2:1678
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the new pipe capacity specified in I<arg> is "
"smaller than the amount of buffer space currently used to store data in the "
"pipe."
msgstr ""
"Значение I<cmd> равно B<F_SETPIPE_SZ> и новая ёмкость канала, указанная в "
"I<arg>, меньше размера буферного пространства, используемого в данный момент "
"для хранения данных в канале."

#. type: Plain text
#: man-pages/man2/fcntl.2:1688
msgid ""
"I<cmd> is B<F_ADD_SEALS>, I<arg> includes B<F_SEAL_WRITE>, and there exists "
"a writable, shared mapping on the file referred to by I<fd>."
msgstr ""
"Значение I<cmd> равно B<F_ADD_SEALS>, в I<arg> содержится B<F_SEAL_WRITE> и "
"существует доступное на запись, общее отображение файла, на который "
"указывает I<fd>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1693
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""
"Было обнаружено, что указанная команда B<F_SETLKW> привела бы к взаимной "
"блокировке (deadlock)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1697
msgid "I<lock> is outside your accessible address space."
msgstr ""
"Значение I<lock> находится за пределами доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/fcntl.2:1706
msgid ""
"I<cmd> is B<F_SETLKW> or B<F_OFD_SETLKW> and the operation was interrupted "
"by a signal; see B<signal>(7)."
msgstr ""
"Значение I<cmd> равно B<F_SETLKW> или B<F_OFD_SETLKW> и операция была "
"прервана сигналом; смотрите B<signal>(7))."

#. type: Plain text
#: man-pages/man2/fcntl.2:1719
msgid ""
"I<cmd> is B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK>, or B<F_OFD_SETLK>, and the "
"operation was interrupted by a signal before the lock was checked or "
"acquired.  Most likely when locking a remote file (e.g., locking over NFS), "
"but can sometimes happen locally."
msgstr ""
"Значение I<cmd> равно B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK> или "
"B<F_OFD_SETLK> и операция была прервана сигналом перед тем как блокировка "
"была проверена или установлена. Большинство таких ошибок случается при "
"блокировке удалённого файла (например, блокировка через NFS), но иногда "
"такое может случаться и с локальным файлом."

#. type: Plain text
#: man-pages/man2/fcntl.2:1724
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr "Значение I<cmd> не распознано ядром."

#. type: Plain text
#: man-pages/man2/fcntl.2:1732
msgid ""
"I<cmd> is B<F_ADD_SEALS> and I<arg> includes an unrecognized sealing bit."
msgstr ""
"Значение I<cmd> равно B<F_ADD_SEALS> и I<arg> содержит бит не распознанной "
"печати."

#. type: Plain text
#: man-pages/man2/fcntl.2:1742
msgid ""
"I<cmd> is B<F_ADD_SEALS> or B<F_GET_SEALS> and the filesystem containing the "
"inode referred to by I<fd> does not support sealing."
msgstr ""
"Значение I<cmd> равно B<F_ADD_SEALS> или B<F_GET_SEALS> и файловая система, "
"содержащая inode, на которую указывает I<fd>, не поддерживает опечатывание."

#. type: Plain text
#: man-pages/man2/fcntl.2:1754
msgid ""
"I<cmd> is B<F_DUPFD> and I<arg> is negative or is greater than the maximum "
"allowable value (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"Значение I<cmd> равно B<F_DUPFD> и значение I<arg> отрицательное или больше "
"максимально возможного значения (смотрите описание B<RLIMIT_NOFILE> в "
"B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man2/fcntl.2:1762
msgid "I<cmd> is B<F_SETSIG> and I<arg> is not an allowable signal number."
msgstr ""
"Значение I<cmd> равно B<F_SETSIG> и значение I<arg> не содержит допустимый "
"номер сигнала."

#. type: Plain text
#: man-pages/man2/fcntl.2:1773
msgid ""
"I<cmd> is B<F_OFD_SETLK>, B<F_OFD_SETLKW>, or B<F_OFD_GETLK>, and I<l_pid> "
"was not specified as zero."
msgstr ""
"Значение I<cmd> равно B<F_OFD_SETLK>, B<F_OFD_SETLKW> или B<F_OFD_GETLK>, но "
"значение I<l_pid> не равно нулю."

#. type: Plain text
#: man-pages/man2/fcntl.2:1780
msgid ""
"I<cmd> is B<F_DUPFD> and the per-process limit on the number of open file "
"descriptors has been reached."
msgstr ""
"Значение I<cmd> равно B<F_DUPFD> и было достигнуто ограничение по количеству "
"открытых файловых дескрипторов на процесс."

#. type: Plain text
#: man-pages/man2/fcntl.2:1784
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""
"Открыто слишком много блокировок сегментов, таблица блокировок заполнена или "
"ошибка протокола удалённой блокировки (например, при блокировке через NFS)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1792
msgid ""
"B<F_NOTIFY> was specified in I<cmd>, but I<fd> does not refer to a directory."
msgstr "Значение I<cmd> равно B<F_NOTIFY>, I<fd> не ссылается на каталог."

#. type: Plain text
#: man-pages/man2/fcntl.2:1799
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the soft or hard user pipe limit has been "
"reached; see B<pipe>(7)."
msgstr ""
"Значение I<cmd> равно B<F_SETPIPE_SZ> и достигнуто мягкое или жёсткое "
"ограничение канала пользователя; смотрите B<pipe>(7)."

#. type: Plain text
#: man-pages/man2/fcntl.2:1804
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""
"Попытка сбросить флаг B<O_APPEND> на файле, который открыт с атрибутом "
"только для добавления."

#. type: Plain text
#: man-pages/man2/fcntl.2:1814
msgid ""
"I<cmd> was B<F_ADD_SEALS>, but I<fd> was not open for writing or the current "
"set of seals on the file already includes B<F_SEAL_SEAL>."
msgstr ""
"Значение I<cmd> равно B<F_ADD_SEALS>, но I<fd> не открыт на запись или "
"текущий набор печатей файла уже содержит B<F_SEAL_SEAL>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1827
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001. В POSIX.1-2001 указаны только команды "
"B<F_DUPFD>, B<F_GETFD>, B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, "
"B<F_SETLK> и B<F_SETLKW>."

#.  .BR _BSD_SOURCE ,
#.  or
#. type: Plain text
#: man-pages/man2/fcntl.2:1839
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define either B<_XOPEN_SOURCE> with the value 500 or greater, "
"or B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr ""
"Значения B<F_GETOWN> и B<F_SETOWN> определены в POSIX.1-2001. Для получения "
"их определений, определите B<_XOPEN_SOURCE> со значением 500 или больше или "
"B<_POSIX_C_SOURCE> со значением 200809L или больше."

#. type: Plain text
#: man-pages/man2/fcntl.2:1847
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""
"B<F_DUPFD_CLOEXEC> указана в POSIX.1-2008. Для получения определения, "
"определите B<_POSIX_C_SOURCE> со значением 200809L или больше, или "
"B<_XOPEN_SOURCE> со значением 700 или больше."

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
#: man-pages/man2/fcntl.2:1864
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""
"Команды B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE> и B<F_SETLEASE> есть "
"только в Linux. Для задействования этих определений определите макрос "
"B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man2/fcntl.2:1873
msgid ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, and B<F_OFD_GETLK> are Linux-specific (and "
"one must define B<_GNU_SOURCE> to obtain their definitions), but work is "
"being done to have them included in the next version of POSIX.1."
msgstr ""
"Значения B<F_OFD_SETLK>, B<F_OFD_SETLKW> и B<F_OFD_GETLK> есть только в "
"Linux (и для получения их определений нужно определить B<_GNU_SOURCE>), но "
"ведётся работа по их включению в следующую версию POSIX.1."

#.  FIXME . Once glibc adds support, add a note about FTM requirements
#. type: Plain text
#: man-pages/man2/fcntl.2:1879
msgid "B<F_ADD_SEALS> and B<F_GET_SEALS> are Linux-specific."
msgstr "Значения B<F_ADD_SEALS> и B<F_GET_SEALS> есть только в Linux."

#. type: Plain text
#: man-pages/man2/fcntl.2:1885
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr ""
"Ошибки, возвращаемые B<dup2>(2), отличаются от тех, что возвращаются при "
"B<F_DUPFD>."

#. type: SS
#: man-pages/man2/fcntl.2:1885
#, no-wrap
msgid "File locking"
msgstr "Файловая блокировка"

#. type: Plain text
#: man-pages/man2/fcntl.2:1907 man-pages/man2/fcntl.2:1949
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""
"Первоначальная версия системного вызова B<fcntl>() в Linux не умела работать "
"с большими файловыми смещениями (в структуре I<flock>). Позднее, в Linux 2.4 "
"был добавлен системный вызов B<fcntl64>(). Новый системный вызов использует "
"другую структуру для блокировки файлов — I<flock64> и соответствующие "
"команды — B<F_GETLK64>, B<F_SETLK64> и B<F_SETLKW64>. Однако, это различие "
"может игнорироваться приложениями, которые используют glibc, так как "
"имеющаяся в ней обёрточная функция B<fcntl>() самостоятельно задействует "
"более новый системный вызов, если он доступен."

#. type: SS
#: man-pages/man2/fcntl.2:1907
#, no-wrap
msgid "Record locks"
msgstr "Обычные блокировки (Record locks)"

#. type: Plain text
#: man-pages/man2/fcntl.2:1913
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""
"Начиная с ядра 2.0, не существует разницы между типами блокировки, которые "
"осуществляют B<flock>(2) и B<fcntl>()."

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#.  Also, FreeBSD documents it (Apr 2014).
#. type: Plain text
#: man-pages/man2/fcntl.2:1928
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid> (to identify the machine where the lock is held).  Clearly, "
"I<l_pid> alone is not going to be very useful if the process holding the "
"lock may live on a different machine; on Linux, while present on some "
"architectures (such as MIPS32), this field is not used."
msgstr ""
"Некоторые системы имеют дополнительные поля в структуре I<struct flock>, "
"например, I<l_sysid> (признак машины, на которой удерживается блокировка). "
"Вообще говоря, один I<l_pid> не очень полезен, если процесс, удерживающий "
"блокировку, может работать на другой машине; в Linux, хотя это поле и есть "
"на некоторых архитектурах (например, MIPS32), но оно не используется."

#. type: SS
#: man-pages/man2/fcntl.2:1949
#, no-wrap
msgid "Record locking and NFS"
msgstr "Блокировка и NFS"

#.  Neil Brown: With NFSv3 the failure mode is the reverse.  If
#.      the server loses contact with a client then any lock stays in place
#.      indefinitely ("why can't I read my mail"... I remember it well).
#.  Jeff Layton:
#.      Note that this is not a firm timeout. The server runs a job
#.      periodically to clean out expired stateful objects, and it's likely
#.      that there is some time (maybe even up to another whole lease period)
#.      between when the timeout expires and the job actually runs. If the
#.      client gets a RENEW in there within that window, its lease will be
#.      renewed and its state preserved.
#. type: Plain text
#: man-pages/man2/fcntl.2:1977
msgid ""
"Before Linux 3.12, if an NFSv4 client loses contact with the server for a "
"period of time (defined as more than 90 seconds with no communication), it "
"might lose and regain a lock without ever being aware of the fact.  (The "
"period of time after which contact is assumed lost is known as the NFSv4 "
"leasetime.  On a Linux NFS server, this can be determined by looking at I</"
"proc/fs/nfsd/nfsv4leasetime>, which expresses the period in seconds.  The "
"default value for this file is 90.)  This scenario potentially risks data "
"corruption, since another process might acquire a lock in the intervening "
"period and perform file I/O."
msgstr ""
"До Linux 3.12, если клиент NFSv4 теряет связь с сервером на некоторый период "
"времени (более 90 секунд), то он может потерять и перезапросить блокировки "
"даже не зная об этом (период времени, после которого контакт предполагается "
"потерянным в NFSv4 называется время аренды (leasetime). У Linux в сервере "
"NFS его можно узнать по значению в I</proc/fs/nfsd/nfsv4leasetime>, которое "
"отражает период в секундах. В этом файле значение по умолчанию равно 90). "
"Данный сценарий несёт потенциальный риск повреждения данных, так как в этот "
"перерыв другой процесс может установить блокировку и выполнить файловый ввод-"
"вывод."

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#.  commit f6de7a39c181dfb8a2c534661a53c73afb3081cd
#. type: Plain text
#: man-pages/man2/fcntl.2:1991
msgid ""
"Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O "
"to the file by a process which \"thinks\" it holds a lock will fail until "
"that process closes and reopens the file.  A kernel parameter, I<nfs."
"recover_lost_locks>, can be set to 1 to obtain the pre-3.12 behavior, "
"whereby the client will attempt to recover lost locks when contact is "
"reestablished with the server.  Because of the attendant risk of data "
"corruption, this parameter defaults to 0 (disabled)."
msgstr ""
"Начиная с Linux 3.12, если клиент NFSv4 теряет контакт с сервером, то любой "
"файловый ввод-вывод, выполняемый процессом, который «думает», что имеет "
"блокировку, будет завершаться с ошибкой до тех пор, пока этот процесс не "
"закроет и не переоткроет файл. Чтобы вернуть поведение, которое было до "
"версии pre-3.12, можно параметру ядра I<nfs.recover_lost_locks> присвоить "
"значение 1, из-за чего клиент буде пытаться восстановить потерянные "
"блокировки при переустановлении связи с сервером. Из-за наличия "
"сопутствующего риска повреждения данных, значение данного параметра по "
"умолчанию равно 0 (отключено)."

#. type: SS
#: man-pages/man2/fcntl.2:1992
#, no-wrap
msgid "F_SETFL"
msgstr "F_SETFL"

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
#: man-pages/man2/fcntl.2:2004
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""
"Невозможно использовать B<F_SETFL> для смены состояния флагов B<O_DSYNC> и "
"B<O_SYNC>. Попытка изменить состояние этих флагов просто игнорируется."

#. type: SS
#: man-pages/man2/fcntl.2:2004
#, no-wrap
msgid "F_GETOWN"
msgstr "F_GETOWN"

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
#: man-pages/man2/fcntl.2:2030
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""
"Ограничение в соглашениях по системным вызовам Linux на некоторых "
"архитектурах (в частности i386) приводит к тому, что если значение ID группы "
"процесса (отрицательное), возвращаемое по команде B<F_GETOWN>, попадает в "
"диапазон от -1 до -4095, то оно неправильно интерпретируется glibc и "
"считается ошибкой в системном вызове; то есть возвращаемое значение "
"B<fcntl>() будет равно -1, а I<errno> будет содержать значение ID группы "
"процесса (положительное). Команда B<F_GETOWN_EX> (есть только в Linux) не "
"подвержена этой проблеме. Начиная с glibc версии 2.11, glibc делает проблему "
"для B<F_GETOWN> невидимой, реализовав B<F_GETOWN> с помощью B<F_GETOWN_EX>."

#. type: SS
#: man-pages/man2/fcntl.2:2030
#, no-wrap
msgid "F_SETOWN"
msgstr "F_SETOWN"

#. type: Plain text
#: man-pages/man2/fcntl.2:2048
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as "
"a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group) "
"is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""
"В Linux 2.4 и более раннем, есть ошибка, которая может произойти когда "
"непривилегированный процесс использует B<F_SETOWN> для задания владельца "
"дескриптора файла сокета как процесса (группу) отличного от вызывающего. В "
"этом случае B<fcntl>() может вернуть -1 с I<errno> равным B<EPERM>, даже "
"когда процесс (группа) владелец такая же как и вызывающий имеет право "
"посылать сигнал. Несмотря на возвращаемую ошибку, владелец файлового "
"дескриптора всё равно устанавливается и сигналы будут посылаться владельцу."

#. type: SS
#: man-pages/man2/fcntl.2:2048
#, no-wrap
msgid "Deadlock detection"
msgstr "Обнаружение взаимных блокировок (deadlock)"

#. type: Plain text
#: man-pages/man2/fcntl.2:2067
msgid ""
"The deadlock-detection algorithm employed by the kernel when dealing with "
"B<F_SETLKW> requests can yield both false negatives (failures to detect "
"deadlocks, leaving a set of deadlocked processes blocked indefinitely)  and "
"false positives (B<EDEADLK> errors when there is no deadlock).  For example, "
"the kernel limits the lock depth of its dependency search to 10 steps, "
"meaning that circular deadlock chains that exceed that size will not be "
"detected.  In addition, the kernel may falsely indicate a deadlock when two "
"or more processes created using the B<clone>(2)  B<CLONE_FILES> flag place "
"locks that appear (to the kernel) to conflict."
msgstr ""
"Алгоритм обнаружения взаимных блокировок задействуется ядром при работе с "
"запросами B<F_SETLKW> и может закончиться как ненахождением (не удалось "
"обнаружить взаимную блокировку и процессы блокируют друг друга навсегда), "
"так и ошибочным нахождением (ошибка B<EDEADLK>, но взаимная блокировка "
"отсутствует). Например, ограничение ядра на вложенность зависимостей "
"блокировки при поиске равна 10, что означает, что цепочки циклических "
"зависимостей, превышающие этот размер, не будут обнаружены. Также ядро может "
"ошибочно посчитать за взаимную блокировку ситуацию, когда два и более "
"процесса, созданных с помощью B<clone>(2) с флагом B<CLONE_FILES>, размещают "
"блокировки, которые похожи (для ядра) на конфликтующие."

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#.  Reconfirmed by Jeff Layton
#.      From: Jeff Layton <jlayton <at> redhat.com>
#.      Subject: Re: Status of fcntl() mandatory locking
#.      Newsgroups: gmane.linux.file-systems
#.      Date: 2014-04-28 10:07:57 GMT
#.      http://thread.gmane.org/gmane.linux.file-systems/84481/focus=84518
#. type: Plain text
#: man-pages/man2/fcntl.2:2089
msgid ""
"The Linux implementation of mandatory locking is subject to race conditions "
"which render it unreliable: a B<write>(2)  call that overlaps with a lock "
"may modify data after the mandatory lock is acquired; a B<read>(2)  call "
"that overlaps with a lock may detect changes to data that were made only "
"after a write lock was acquired.  Similar races exist between mandatory "
"locks and B<mmap>(2).  It is therefore inadvisable to rely on mandatory "
"locking."
msgstr ""
"Реализация обязательной блокировки в Linux проводит к состязательности "
"процессов, что делает её ненадёжной: вызов B<write>(2), пересекающийся с "
"блокировкой, может изменить данные после установления обязательной "
"блокировки; вызов B<read>(2), пересекающийся с блокировкой, может обнаружить "
"изменившиеся данные, которые были внесены уже установления блокировки на "
"запись. Подобная состязательность существует между обязательными "
"блокировками и B<mmap>(2). Поэтому нецелесообразно полагаться на "
"обязательную блокировку."

#. type: Plain text
#: man-pages/man2/fcntl.2:2098
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"
msgstr ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"

#. type: Plain text
#: man-pages/man2/fcntl.2:2110
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and "
"I<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""
"Файлы I<locks.txt>, I<mandatory-locking.txt> и I<dnotify.txt> из каталога "
"I<Documentation/filesystems.> исходного кода ядра Linux (в старых ядрах эти "
"файлы были в каталоге I<Documentation/>, а I<mandatory-locking.txt> "
"назывался I<mandatory.txt>)."

#. type: TH
#: man-pages/man2/fsync.2:38
#, no-wrap
msgid "FSYNC"
msgstr "FSYNC"

#. type: Plain text
#: man-pages/man2/fsync.2:41
msgid ""
"fsync, fdatasync - synchronize a file's in-core state with storage device"
msgstr ""
"fsync, fdatasync - синхронизирует состояние файла в памяти с состоянием на "
"устройстве хранения"

#. type: Plain text
#: man-pages/man2/fsync.2:45
msgid "B<int fsync(int >I<fd>B<);>"
msgstr "B<int fsync(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man2/fsync.2:47
msgid "B<int fdatasync(int >I<fd>B<);>"
msgstr "B<int fdatasync(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man2/fsync.2:59
#, no-wrap
msgid ""
"B<fsync>():\n"
"    Glibc 2.16 and later:\n"
"        No feature test macros need be defined\n"
"    Glibc up to and including 2.15:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\n"
"            || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""
"B<fsync>():\n"
"    в glibc 2.16 и новее:\n"
"        Не требуется определять макросы тестирования свойств\n"
"    до glibc 2.15 включительно:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\n"
"            || /* начиная с glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"

#. type: Plain text
#: man-pages/man2/fsync.2:62
#, no-wrap
msgid ""
"B<fdatasync>():\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""
"B<fdatasync>():\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"

#. type: Plain text
#: man-pages/man2/fsync.2:73
msgid ""
"B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
"modified buffer cache pages for) the file referred to by the file descriptor "
"I<fd> to the disk device (or other permanent storage device) so that all "
"changed information can be retrieved even if the system crashes or is "
"rebooted.  This includes writing through or flushing a disk cache if "
"present.  The call blocks until the device reports that the transfer has "
"completed."
msgstr ""
"Вызов B<fsync>() пересылает («сбрасывает») все изменённые в памяти (in-core) "
"данные (т. е., изменённые страницы буферного кэша) файла, на который "
"указывает файловый дескриптор I<fd>, на дисковое устройство (или другое "
"устройство постоянного хранения) таким образом, что вся изменённая "
"информация может быть получена даже после падения системы или внезапной "
"перезагрузки. При этом выполняется непосредственная запись или сброс "
"дискового кэша (если он есть). Вызов блокируется до тех пор, пока устройство "
"не сообщит, что пересылка завершена."

#. type: Plain text
#: man-pages/man2/fsync.2:78
msgid ""
"As well as flushing the file data, B<fsync>()  also flushes the metadata "
"information associated with the file (see B<inode>(7))."
msgstr ""
"Помимо сброса самих данных, также сбрасывается информация о метаданных, "
"связанная с файлом (смотрите B<inode>(7))."

#. type: Plain text
#: man-pages/man2/fsync.2:86
msgid ""
"Calling B<fsync>()  does not necessarily ensure that the entry in the "
"directory containing the file has also reached disk.  For that an explicit "
"B<fsync>()  on a file descriptor for the directory is also needed."
msgstr ""
"Вызов B<fsync>() необязательно приводит к тому, что элемент каталога, "
"содержащий файл, также будет сброшен на диск. Для этого нужно явно выполнить "
"B<fsync>() для файлового дескриптора каталога."

#. type: Plain text
#: man-pages/man2/fsync.2:107
msgid ""
"B<fdatasync>()  is similar to B<fsync>(), but does not flush modified "
"metadata unless that metadata is needed in order to allow a subsequent data "
"retrieval to be correctly handled.  For example, changes to I<st_atime> or "
"I<st_mtime> (respectively, time of last access and time of last "
"modification; see B<inode>(7))  do not require flushing because they are not "
"necessary for a subsequent data read to be handled correctly.  On the other "
"hand, a change to the file size (I<st_size>, as made by say "
"B<ftruncate>(2)), would require a metadata flush."
msgstr ""
"Вызов B<fdatasync>() подобен B<fsync>(), но не записывает изменившиеся "
"метаданные, если эти метаданные не нужны для последующего получения данных. "
"Например, изменения I<st_atime> или I<st_mtime> (время последнего доступа и "
"последнего изменения, соответственно; смотрите B<inode>(7)) не нужно "
"записывать, так как они ненужны для чтения самих данных. С другой стороны, "
"при изменении размера файла (I<st_size>, изменяется, например, "
"B<ftruncate>(2)) запись метаданных будет нужна."

#. type: Plain text
#: man-pages/man2/fsync.2:112
msgid ""
"The aim of B<fdatasync>()  is to reduce disk activity for applications that "
"do not require all metadata to be synchronized with the disk."
msgstr ""
"Целью создания B<fdatasync>() является сокращение обменов с диском для "
"приложений, которым не нужна синхронизация метаданных с диском."

#. type: Plain text
#: man-pages/man2/fsync.2:117
msgid ""
"On success, these system calls return zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"В случае успеха данные системные вызовы возвращают ноль. Если произошла "
"ошибка возвращается -1 и I<errno> устанавливается должным образом."

#. type: Plain text
#: man-pages/man2/fsync.2:122
msgid "I<fd> is not a valid open file descriptor."
msgstr "I<fd> не является правильным открытым файловым дескриптором."

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: man-pages/man2/fsync.2:136
msgid ""
"An error occurred during synchronization.  This error may relate to data "
"written to some other file descriptor on the same file.  Since Linux 4.13, "
"errors from write-back will be reported to all file descriptors that might "
"have written the data which triggered the error.  Some filesystems (e.g., "
"NFS) keep close track of which data came through which file descriptor, and "
"give more precise reporting.  Other filesystems (e.g., most local "
"filesystems) will report errors to all file descriptors that were open on "
"the file when the error was recorded."
msgstr ""
"Во время синхронизации произошла ошибка. Эта ошибка может относится к "
"данным, записанным в какой-то другой файловый дескриптор того же файла. "
"Начиная с Linux 4.13, об ошибках отложенной записи (write-back) будет "
"сообщено всем файловым дескрипторам, которые могли записывать данные при "
"возникновении ошибки. Некоторые файловые системы (например, NFS) следят за "
"тем какие данные поступили из файлового дескриптора и сообщают только там, "
"где нужно. Другие файловые системы (например, большинство локальных файловых "
"систем) сообщат об ошибках всем файловым дескрипторам, которые уже открыли "
"файл при возникновении ошибки."

#. type: Plain text
#: man-pages/man2/fsync.2:139
msgid "Disk space was exhausted while synchronizing."
msgstr "При синхронизации закончилось дисковое пространство."

#. type: TP
#: man-pages/man2/fsync.2:139
#, no-wrap
msgid "B<EROFS>, B<EINVAL>"
msgstr "B<EROFS>, B<EINVAL>"

#. type: Plain text
#: man-pages/man2/fsync.2:144
msgid ""
"I<fd> is bound to a special file (e.g., a pipe, FIFO, or socket)  which does "
"not support synchronization."
msgstr ""
"Значение I<fd> связано со специальным файлом (например, канал, FIFO или "
"сокет), который не поддерживает синхронизацию."

#. type: TP
#: man-pages/man2/fsync.2:144
#, no-wrap
msgid "B<ENOSPC>, B<EDQUOT>"
msgstr "B<ENOSPC>, B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/fsync.2:152
msgid ""
"I<fd> is bound to a file on NFS or another filesystem which does not "
"allocate space at the time of a B<write>(2)  system call, and some previous "
"write failed due to insufficient storage space."
msgstr ""
"Значение I<fd> указывает на файл в NFS или другой файловой системе, которая "
"не выделяет место во время системного вызова B<write>(2), и какая-то "
"предыдущая операция записи завершилась ошибкой из-за нехватки места."

#. type: Plain text
#: man-pages/man2/fsync.2:154
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: SH
#: man-pages/man2/fsync.2:154
#, no-wrap
msgid "AVAILABILITY"
msgstr "ДОСТУПНОСТЬ"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/fsync.2:167
msgid ""
"On POSIX systems on which B<fdatasync>()  is available, "
"B<_POSIX_SYNCHRONIZED_IO> is defined in I<E<lt>unistd.hE<gt>> to a value "
"greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"В системах POSIX, в которых есть B<fdatasync>(), в I<E<lt>unistd.hE<gt>> "
"определено значение для B<_POSIX_SYNCHRONIZED_IO> и оно больше 0 (см. также "
"B<sysconf>(3))."

#. type: Plain text
#: man-pages/man2/fsync.2:173
msgid ""
"On some UNIX systems (but not Linux), I<fd> must be a I<writable> file "
"descriptor."
msgstr ""
"В некоторых системах UNIX (но не в Linux), I<fd> должен быть файловым "
"дескриптором, I<доступным для записи>."

#. type: Plain text
#: man-pages/man2/fsync.2:179
msgid ""
"In Linux 2.2 and earlier, B<fdatasync>()  is equivalent to B<fsync>(), and "
"so has no performance advantage."
msgstr ""
"В Linux 2.2 и ранее, вызов B<fdatasync>() эквивалентен B<fsync>(), и поэтому "
"не даёт преимуществ в производительности."

#. type: Plain text
#: man-pages/man2/fsync.2:189
msgid ""
"The B<fsync>()  implementations in older kernels and lesser used filesystems "
"do not know how to flush disk caches.  In these cases disk caches need to be "
"disabled using B<hdparm>(8)  or B<sdparm>(8)  to guarantee safe operation."
msgstr ""
"Реализации B<fsync>() в старых ядрах и ранее, использовавшиеся в файловых "
"системах, не знают как очищать (flush) дисковые кэши. В этих случаях "
"дисковые кэши требуется заблокировать с помощью B<hdparm>(8) или "
"B<sdparm>(8), чтобы гарантировать безопасное выполнение."

#. type: Plain text
#: man-pages/man2/fsync.2:200
msgid ""
"B<sync>(1), B<bdflush>(2), B<open>(2), B<posix_fadvise>(2), B<pwritev>(2), "
"B<sync>(2), B<sync_file_range>(2), B<fflush>(3), B<fileno>(3), B<hdparm>(8), "
"B<mount>(8)"
msgstr ""
"B<sync>(1), B<bdflush>(2), B<open>(2), B<posix_fadvise>(2), B<pwritev>(2), "
"B<sync>(2), B<sync_file_range>(2), B<fflush>(3), B<fileno>(3), B<hdparm>(8), "
"B<mount>(8)"

#. type: TH
#: man-pages/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr "FANOTIFY_INIT"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr "fanotify_init - создаёт и инициализирует группу fanotify"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr "B<#include E<lt>fcntl.hE<gt>>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr "B<#include E<lt>sys/fanotify.hE<gt>>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""
"Вызов B<fanotify_init>() инициализирует новую группу fanotify и возвращает "
"файловый дескриптор очереди событий, связанной с группой."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, mounts or filesystems for which fanotify events shall be "
"created.  These events are received by reading from the file descriptor.  "
"Some events are only informative, indicating that a file has been accessed.  "
"Other events can be used to determine whether another application is "
"permitted to access a file or directory.  Permission to access filesystem "
"objects is granted by writing to the file descriptor."
msgstr ""
"В файловом дескрипторе, используемом в B<fanotify_mark>(2), задаются файлы, "
"каталоги, точки монтирования и файловые системы, для которых должны "
"создаваться события fanotify. Эти события можно получить с помощью чтения "
"файлового дескриптора. Одни события носят уведомительный характер, показывая "
"что к файлу был получен доступ. Другие события можно использовать для "
"разрешения приложению доступа к файлу или каталогу. Доступ к объектам "
"файловой системы разрешается посредством записи в файловый дескриптор."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""
"Несколько программ могут использовать интерфейс fanotify к одним и тем же "
"файлам одновременно."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""
"В текущей реализации количество групп fanotify ограничено 128 на "
"пользователя. Это значение нельзя изменить."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""
"Для вызова B<fanotify_init>() требуется мандат B<CAP_SYS_ADMIN>. Это "
"требование может быть облегчено в будущих версиях программного интерфейса. "
"Поэтому ниже показаны определённые дополнительные проверки возможностей, "
"которые были реализованы."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""
"Аргумент I<flags> содержит многобитовое поле, определяющее класс "
"уведомления, запрашиваемый приложением, а также однобитовые поля, задающие "
"поведение файлового дескриптора."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is "
"used to establish the sequence in which the listeners receive the events."
msgstr ""
"Если на события доступа зарегистрировалось несколько слушателей, то класс "
"уведомления используется для установления порядка слушателей при получении "
"событий."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:80
msgid ""
"Only one of the following notification classes may be specified in I<flags>:"
msgstr ""
"В I<flags> может быть указан только один из следующих классов уведомления:"

#. type: TP
#: man-pages/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr "B<FAN_CLASS_PRE_CONTENT>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""
"Это значение позволяет принимать уведомляющие события об обращении к файлу, "
"и события доступа, запрашивающие доступ к файлу. Он предназначен  для "
"слушателей событий, которым требуется доступ к файлам до того, как в них "
"будут содержаться окончательные данные. Этот класс уведомления может быть "
"использован, например, в программах управления иерархического хранения."

#. type: TP
#: man-pages/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr "B<FAN_CLASS_CONTENT>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""
"Это значение позволяет принимать уведомляющие события об обращении к файлу, "
"и события доступа, запрашивающие доступ к файлу. Он предназначен  для "
"слушателей событий, которым требуется доступ к файлам после того, как они "
"содержат окончательные данные. Этот класс уведомления может быть "
"использован, например, в программах обнаружения вредоносного кода."

#. type: TP
#: man-pages/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_REPORT_FID> (since Linux 5.1)"
msgstr "B<FAN_REPORT_FID> (начиная с Linux 5.1)"

#.  commit a8b13aa20afb69161b5123b4f1acc7ea0a03d360
#. type: Plain text
#: man-pages/man2/fanotify_init.2:126
msgid ""
"This value allows the receipt of events which contain additional information "
"about the underlying filesystem object correlated to an event.  An "
"additional structure encapsulates the information about the object and is "
"included alongside the generic event metadata structure.  The file "
"descriptor that is used to represent the object correlated to an event is "
"instead substituted with a file handle.  It is intended for applications "
"that may find the use of a file handle to identify an object more suitable "
"than a file descriptor.  Additionally, it may be used for applications that "
"are interested in directory entry events, such as B<FAN_CREATE>, "
"B<FAN_ATTRIB>, B<FAN_MOVE>, and B<FAN_DELETE> for example.  Note that the "
"use of directory modification events are not supported when monitoring a "
"mount point.  The use of B<FAN_CLASS_CONTENT> or B<FAN_CLASS_PRE_CONTENT> is "
"not permitted with this flag and will result in the error B<EINVAL>.  See "
"B<fanotify>(7)  for additional information."
msgstr ""
"Это значение позволяет получать события, которые содержат дополнительную "
"информацию о нижележащем объекте файловой системы, относящемся к событию. "
"Дополнительная структура содержит информацию об объекте, которая добавляется "
"к структуре общих метаданных событий. Файловый дескриптор, используемый для "
"представления объекта, заменяется в событии файловым описателем. Он "
"предназначен для приложений, которым для работы с файлами удобней "
"использовать файловый описатель, а не файловый дескриптор. Также, его можно "
"использовать в приложениях, которым интересны события об элементах каталога, "
"например таких как B<FAN_CREATE>, B<FAN_ATTRIB>, B<FAN_MOVE> и "
"B<FAN_DELETE>. Заметим, что использование событий изменения каталога не "
"поддерживается при слежении за точкой монтирования. Использование "
"B<FAN_CLASS_CONTENT> или B<FAN_CLASS_PRE_CONTENT> с этим флагом не "
"допускается и приводит к ошибке B<EINVAL>. Дополнительную информацию "
"смотрите в B<fanotify>(7)."

#. type: TP
#: man-pages/man2/fanotify_init.2:126
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr "B<FAN_CLASS_NOTIF>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:133
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""
"Значение по умолчанию. Его не нужно указывать. Это значение позволяет "
"принимать только события о доступе к файлу. Право на доступ к файлу задать "
"невозможно."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:141
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""
"Слушатели с различными классами уведомлений будут принимать события в таком "
"порядке: B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>. "
"Порядок уведомления слушателей в этом классе уведомления не определён."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:144
msgid "The following bits can additionally be set in I<flags>:"
msgstr "Дополнительно в I<flags> могут быть установлены следующие биты:"

#. type: TP
#: man-pages/man2/fanotify_init.2:144
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr "B<FAN_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:153
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""
"Устанавливать флаг close-on-exec (B<FD_CLOEXEC>) для нового файлового "
"дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2)."

#. type: TP
#: man-pages/man2/fanotify_init.2:153
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr "B<FAN_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:163
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  fails with the error B<EAGAIN>."
msgstr ""
"Включить неблокирующий флаг (B<O_NONBLOCK>) для файлового дескриптора. "
"Чтение из такого файлового дескриптора не вызовет блокирования. Если данные "
"отсутствуют, то B<read>(2) завершается ошибкой B<EAGAIN>."

#. type: TP
#: man-pages/man2/fanotify_init.2:163
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr "B<FAN_UNLIMITED_QUEUE>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:169
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"Снять ограничение в 16384 события в очереди событий. Для использования этого "
"флага требуется мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/fanotify_init.2:169
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr "B<FAN_UNLIMITED_MARKS>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:175
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""
"Снять ограничение в 8192 метки. Для использования этого флага требуется "
"мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/fanotify_init.2:175
#, no-wrap
msgid "B<FAN_REPORT_TID> (since Linux 4.20)"
msgstr "B<FAN_REPORT_TID> (начиная с Linux 4.20)"

#.  commit d0a6a87e40da49cfc7954c491d3065a25a641b29
#. type: Plain text
#: man-pages/man2/fanotify_init.2:187
msgid ""
"Report thread ID (TID) instead of process ID (PID)  in the I<pid> field of "
"the I<struct fanotify_event_metadata> supplied to B<read>(2)  (see "
"B<fanotify>(7))."
msgstr ""
"Хранить ID нити (TID) вместо ID процесса (PID) в поле I<pid> структуры "
"I<struct fanotify_event_metadata>, передаваемой в B<read>(2) (смотрите "
"B<fanotify>(7))."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:200
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set "
"on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""
"В аргументе I<event_f_flags> задаются флаги состояния файла, которые будут "
"установлены на открытые файловые описатели, создаваемые для событий "
"fanotify. Подробней об этих флагах смотрите описание значений I<flags> в "
"B<open>(2). Аргумент I<event_f_flags> включает многобитовое поле для режима "
"доступа. Это поел может иметь следующие значения:"

#. type: TP
#: man-pages/man2/fanotify_init.2:200
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:203
msgid "This value allows only read access."
msgstr "Это значение разрешает доступ только на чтение."

#. type: TP
#: man-pages/man2/fanotify_init.2:203
#, no-wrap
msgid "B<O_WRONLY>"
msgstr "B<O_WRONLY>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:206
msgid "This value allows only write access."
msgstr "Это значение разрешает доступ только на запись."

#. type: TP
#: man-pages/man2/fanotify_init.2:206
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:209
msgid "This value allows read and write access."
msgstr "Это значение разрешает доступ на чтение и запись."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:213
msgid ""
"Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""
"В I<event_f_flags> могут быть установлены дополнительные биты. Наиболее "
"полезные значения:"

#. type: TP
#: man-pages/man2/fanotify_init.2:213
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr "B<O_LARGEFILE>"

#. type: Plain text
#: man-pages/man2/fanotify_init.2:220
msgid ""
"Enable support for files exceeding 2\\ GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr ""
"Включить поддержку файлов более 2\\ ГБ. Если не удастся установить этот "
"флаг, то при попытке открыть большой файл, отслеживаемый группой fanotify на "
"32-битной системе, возвращается ошибка B<EOVERFLOW>."

#. type: TP
#: man-pages/man2/fanotify_init.2:220
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 3.18)"
msgstr "B<O_CLOEXEC> (начиная с Linux 3.18)"

#.  commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:229
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"Включить флаг close-on-exec для нового открытого файлового дескриптора. "
"Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для того, чтобы узнать как "
"это может пригодиться."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:242
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags> "
"yields the error B<EINVAL> (but see BUGS)."
msgstr ""
"Также доступны следующие флаги: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK> и B<O_SYNC>. Указание любых других флагов в "
"I<event_f_flags>приводит к ошибке B<EINVAL> (но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:249
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fanotify_init>() возвращает новый файловый "
"дескриптор. При ошибке возвращается -1, и I<errno> устанавливается в "
"соответствующее значение."

#.  commit 23c9deeb3285d34fd243abb3d6b9f07db60c3cf4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:261
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> (deprecated since Linux kernel version 4.20)  defines "
"all allowable bits for I<flags>."
msgstr ""
"В I<flags> или I<event_f_flags> указано некорректное значение. Значение "
"B<FAN_ALL_INIT_FLAGS> (устарело, начиная с версии ядра Linux 4.20) "
"определяет все допустимые биты в I<flags>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:264
msgid "The number of fanotify groups for this user exceeds 128."
msgstr "Количество групп fanotify для этого пользователя превышает 128."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:267
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""
"Было достигнуто ограничение по количеству открытых файловых дескрипторов на "
"процесс."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:270
msgid "The allocation of memory for the notification group failed."
msgstr "Не удалось выделить память для группы уведомления."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:276
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""
"В этом ядре не реализован B<fanotify_init>(). Программный интерфейс fanotify "
"доступен только, если ядро было собрано с параметром B<CONFIG_FANOTIFY>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:281
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""
"Операция запрещена, так как вызывающий не имеет мандата B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:285
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""
"Вызов B<fanotify_init>() появился в версии 2.6.36 ядра Linux и был включён в "
"версии 2.6.37."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:289
msgid "The following bug was present in Linux kernels before version 3.18:"
msgstr "В ядрах Linux до версии 3.18 существовали следующие дефекты:"

#.  Fixed by commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:295
msgid "The B<O_CLOEXEC> is ignored when passed in I<event_f_flags>."
msgstr "При передаче в I<event_f_flags> флаг B<O_CLOEXEC> игнорируется."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:297
msgid "The following bug was present in Linux kernels before version 3.14:"
msgstr "В ядрах Linux до версии 3.14 существовали следующие дефекты:"

#.  Fixed by commit 48149e9d3a7e924010a0daab30a6197b7d7b6580
#. type: Plain text
#: man-pages/man2/fanotify_init.2:307
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from "
"the fanotify file descriptor."
msgstr ""
"Значение аргумента I<event_f_flags> не проверяется на корректность флагов. "
"Могут быть установлены флаги, предназначенные только для внутреннего "
"использования, такие как B<FMODE_EXEC>, и в результате будут установлены для "
"файловых дескрипторов при чтении из файлового дескриптора fanotify."

#. type: Plain text
#: man-pages/man2/fanotify_init.2:309
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr "B<fanotify_mark>(2), B<fanotify>(7)"

#. type: TH
#: man-pages/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr "FALLOCATE"

#. type: TH
#: man-pages/man2/fallocate.2:11
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr "fallocate - управление пространством файла"

#. type: Plain text
#: man-pages/man2/fallocate.2:18
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/fallocate.2:21
#, no-wrap
msgid "B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr "B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""
"Это непереносимый системный вызов, существующий только в Linux. В POSIX.1 "
"есть переносимый метод, обеспечивающий выделение пространства под файл "
"(смотрите B<posix_fallocate>(3))."

#. type: Plain text
#: man-pages/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""
"Вызов B<fallocate>() позволяет вызывающему напрямую управлять выделением "
"дискового пространства под файл, на который указывает I<fd>, для байтового "
"диапазона, начинающегося с I<offset> и имеющего длину I<len> байт."

#. type: Plain text
#: man-pages/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""
"В аргументе I<mode> задаётся операция, выполняемая над указанным диапазоном. "
"Детали о поддерживаемых операциях представлены в подразделах далее."

#. type: SS
#: man-pages/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr "Выделение дискового пространства"

#. type: Plain text
#: man-pages/man2/fallocate.2:65
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"the disk space within the range specified by I<offset> and I<len>.  The file "
"size (as reported by B<stat>(2))  will be changed if I<offset>+I<len> is "
"greater than the file size.  Any subregion within the range specified by "
"I<offset> and I<len> that did not contain data before the call will be "
"initialized to zero.  This default behavior closely resembles the behavior "
"of the B<posix_fallocate>(3)  library function, and is intended as a method "
"of optimally implementing that function."
msgstr ""
"По умолчанию (т. е. значение I<mode> равно нулю) B<fallocate>() выделяет "
"место на диске в диапазоне, задаваемом I<offset> и I<len>. Размер файла "
"(получаемый через B<stat>(2)) будет изменён, если I<offset>+I<len> больше "
"чем размер файла. Любая подобласть внутри диапазона, заданного I<offset> и "
"I<len>, которая не содержала данных до вызова, будет заполнена нулями. Такое "
"поведение по умолчанию очень напоминает поведение библиотечной функции "
"B<posix_fallocate>(3), и было введено для оптимальной реализации этой "
"функции."

#. type: Plain text
#: man-pages/man2/fallocate.2:71
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""
"После успешного выполнения вызова последующие операции записи в диапазон, "
"указанный I<offset> и I<len>, гарантированно не завершатся с ошибкой из-за "
"нехватки места на диске."

#. type: Plain text
#: man-pages/man2/fallocate.2:82
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if I<offset>"
"+I<len> is greater than the file size.  Preallocating zeroed blocks beyond "
"the end of the file in this manner is useful for optimizing append workloads."
msgstr ""
"Если в I<mode> указан флаг B<FALLOC_FL_KEEP_SIZE>, то поведение по умолчанию "
"почти то же, но размер файла не будет изменён даже, если I<offset>+I<len> "
"больше чем размер файла. Это полезно для предварительного выделения блоков с "
"нулями за концом файла для оптимизации загруженности при добавлении."

#. type: Plain text
#: man-pages/man2/fallocate.2:92
msgid ""
"If the B<FALLOC_FL_UNSHARE> flag is specified in I<mode>, shared file data "
"extents will be made private to the file to guarantee that a subsequent "
"write will not fail due to lack of space.  Typically, this will be done by "
"performing a copy-on-write operation on all shared data in the file.  This "
"flag may not be supported by all filesystems."
msgstr ""
"Если в I<mode>указан флаг B<FALLOC_FL_UNSHARE>, то общие файловые extent-"
"данные будут сделаны частными для файла, чтобы гарантировать, что "
"последующая запись не завершится ошибкой из-за нехватки места. Обычно, это "
"выполняется с помощью операции копирования при записи для всех общих данных "
"файла. Данный флаг может поддерживаться не во всех файловых системах."

#. type: Plain text
#: man-pages/man2/fallocate.2:96
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""
"Так как выделение выполняется кусками размером с блок, B<fallocate>() может "
"выделить больший диапазон дискового пространства, чем было указано."

#. type: SS
#: man-pages/man2/fallocate.2:96
#, no-wrap
msgid "Deallocating file space"
msgstr "Освобождение файлового пространства"

#. type: Plain text
#: man-pages/man2/fallocate.2:111
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified "
"range, partial filesystem blocks are zeroed, and whole filesystem blocks are "
"removed from the file.  After a successful call, subsequent reads from this "
"range will return zeros."
msgstr ""
"Указание флага B<FALLOC_FL_PUNCH_HOLE> (доступен, начиная с Linux 2.6.38) в "
"I<mode> освобождает пространство (т.е., создаёт дыру) в диапазоне начиная с "
"I<offset> и до I<len> байт. Внутри заданного диапазона неполные блоки "
"файловой системы заполняются нулями, а полные блоки файловой системы "
"удаляются из файла. После успешного выполнения вызова, последующие операции "
"чтения из этого диапазона вернут нули."

#. type: Plain text
#: man-pages/man2/fallocate.2:122
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in "
"I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""
"Флаг B<FALLOC_FL_PUNCH_HOLE> должен быть логически добавлен к флагу "
"B<FALLOC_FL_KEEP_SIZE> в I<mode>; другими словами, даже когда пробивание "
"(punching) выходит за конец файла, размер файла (получаемый с помощью "
"B<stat>(2)) остаётся неизменным."

#. type: Plain text
#: man-pages/man2/fallocate.2:127
msgid ""
"Not all filesystems support B<FALLOC_FL_PUNCH_HOLE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""
"Не все файловые системы поддерживают B<FALLOC_FL_PUNCH_HOLE>; если файловая "
"система не поддерживает эту операцию, то возвращается ошибка. Операция "
"поддерживается, как минимум, следующими файловыми системами:"

#. type: Plain text
#: man-pages/man2/fallocate.2:129
msgid "XFS (since Linux 2.6.38)"
msgstr "XFS (начиная с Linux 2.6.38)"

#.  commit a4bb6b64e39abc0e41ca077725f2a72c868e7622
#. type: Plain text
#: man-pages/man2/fallocate.2:132
msgid "ext4 (since Linux 3.0)"
msgstr "ext4 (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/fallocate.2:134
msgid "Btrfs (since Linux 3.7)"
msgstr "Btrfs (начиная с Linux 3.7)"

#.  commit 83e4fa9c16e4af7122e31be3eca5d57881d236fe
#. type: Plain text
#: man-pages/man2/fallocate.2:138
msgid "B<tmpfs>(5)  (since Linux 3.5)\""
msgstr "B<tmpfs>(5)  (начиная с Linux 3.5)\""

#. type: SS
#: man-pages/man2/fallocate.2:138
#, no-wrap
msgid "Collapsing file space"
msgstr "Сворачивание (Collapsing) файлового пространства"

#.  commit 00f5e61998dd17f5375d9dfc01331f104b83f841
#. type: Plain text
#: man-pages/man2/fallocate.2:158
msgid ""
"Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux 3.15) "
"in I<mode> removes a byte range from a file, without leaving a hole.  The "
"byte range to be collapsed starts at I<offset> and continues for I<len> "
"bytes.  At the completion of the operation, the contents of the file "
"starting at the location I<offset+len> will be appended at the location "
"I<offset>, and the file will be I<len> bytes smaller."
msgstr ""
"Задание флага B<FALLOC_FL_COLLAPSE_RANGE> (доступен, начиная с Linux 3.15) в "
"I<mode> приводит к удалению байтового диапазона из файла без создания дыры. "
"Сворачиваемый диапазон байт начинается с I<offset> и длится I<len> байт. По "
"завершению операции, содержимое файла, начиная с I<offset+len>, будет "
"добавлено в расположение I<offset>, и файл будет на I<len> байт меньше."

#. type: Plain text
#: man-pages/man2/fallocate.2:172
msgid ""
"A filesystem may place limitations on the granularity of the operation, in "
"order to ensure efficient implementation.  Typically, I<offset> and I<len> "
"must be a multiple of the filesystem logical block size, which varies "
"according to the filesystem type and configuration.  If a filesystem has "
"such a requirement, B<fallocate>()  fails with the error B<EINVAL> if this "
"requirement is violated."
msgstr ""
"У файловой системы могут быть ограничения на детализацию операции, для "
"большей эффективности реализации. Обычно, значения I<offset> и I<len> должны "
"быть кратны размеру логического блока файловой системы, различающемуся в "
"разных файловых системах и зависящему от настроек. Если файловая система "
"содержит такое требование и оно нарушено, то B<fallocate>() завершается "
"ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/fallocate.2:181
msgid ""
"If the region specified by I<offset> plus I<len> reaches or passes the end "
"of file, an error is returned; instead, use B<ftruncate>(2)  to truncate a "
"file."
msgstr ""
"Если область, заданная I<offset> плюс I<len> достигает или выходит за конец "
"файла, то возвращается ошибка; вместо этого используйте B<ftruncate>(2) для "
"обрезания файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:186
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""
"Вместе с B<FALLOC_FL_COLLAPSE_RANGE> другие флаги в I<mode> указывать нельзя."

#.  commit 9eb79482a97152930b113b51dff530aba9e28c8e
#.  commit e1d8fb88a64c1f8094b9f6c3b6d2d9e6719c970d
#. type: Plain text
#: man-pages/man2/fallocate.2:194
msgid ""
"As at Linux 3.15, B<FALLOC_FL_COLLAPSE_RANGE> is supported by ext4 (only for "
"extent-based files)  and XFS."
msgstr ""
"В Linux 3.15 флаг B<FALLOC_FL_COLLAPSE_RANGE> поддерживается в ext4 (только "
"для файлов на основе extent) и XFS."

#. type: SS
#: man-pages/man2/fallocate.2:194
#, no-wrap
msgid "Zeroing file space"
msgstr "Зануление файлового пространства"

#.  commit 409332b65d3ed8cfa7a8030f1e9d52f372219642
#. type: Plain text
#: man-pages/man2/fallocate.2:210
msgid ""
"Specifying the B<FALLOC_FL_ZERO_RANGE> flag (available since Linux 3.15)  in "
"I<mode> zeros space in the byte range starting at I<offset> and continuing "
"for I<len> bytes.  Within the specified range, blocks are preallocated for "
"the regions that span the holes in the file.  After a successful call, "
"subsequent reads from this range will return zeros."
msgstr ""
"Задание флага B<FALLOC_FL_ZERO_RANGE> (доступен, начиная с Linux 3.15) в "
"I<mode> приводит к обнулению байтового диапазона, начиная с I<offset> и "
"размером I<len> байт. Внутри указанного диапазона блоки выделяются заранее "
"для областей, которые попадают в дыры в файле. После успешного выполнения "
"вызова последующие операции чтения из этого диапазона будут возвращать нули."

#. type: Plain text
#: man-pages/man2/fallocate.2:216
msgid ""
"Zeroing is done within the filesystem preferably by converting the range "
"into unwritten extents.  This approach means that the specified range will "
"not be physically zeroed out on the device (except for partial blocks at the "
"either end of the range), and I/O is (otherwise) required only to update "
"metadata."
msgstr ""
"Зануление, желательно, выполнять внутри файловой системы, преобразуя "
"диапазон в незаписываемые extents. Этот подход означает, что указанный "
"диапазон на устройстве в действительности не будет содержать нули на "
"физическом уровне (за исключением неполных блоков в одном из концов "
"диапазона), и ввод-вывод требуется только для обновления метаданных."

#. type: Plain text
#: man-pages/man2/fallocate.2:228
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is additionally specified in I<mode>, the "
"behavior of the call is similar, but the file size will not be changed even "
"if I<offset>+I<len> is greater than the file size.  This behavior is the "
"same as when preallocating space with B<FALLOC_FL_KEEP_SIZE> specified."
msgstr ""
"Если в I<mode> также указан флаг B<FALLOC_FL_KEEP_SIZE>, то поведение вызова "
"похоже, но размер файла не будет изменён даже, если I<offset>+I<len> больше "
"размера файла. Такое поведение совпадает с предварительным выделением "
"пространства с помощью указания флага B<FALLOC_FL_KEEP_SIZE>."

#. type: Plain text
#: man-pages/man2/fallocate.2:233
msgid ""
"Not all filesystems support B<FALLOC_FL_ZERO_RANGE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""
"Не все файловые системы поддерживают B<FALLOC_FL_ZERO_RANGE>; если файловая "
"система не поддерживает эту операцию, то возвращается ошибка. Операция "
"поддерживается, как минимум, следующими файловыми системами:"

#.  commit 376ba313147b4172f3e8cf620b9fb591f3e8cdfa
#. type: Plain text
#: man-pages/man2/fallocate.2:236
msgid "XFS (since Linux 3.15)"
msgstr "XFS (начиная с Linux 3.15)"

#.  commit b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
#. type: Plain text
#: man-pages/man2/fallocate.2:239
msgid "ext4, for extent-based files (since Linux 3.15)"
msgstr "ext4, для файлов на основе extent (начиная с Linux 3.15)"

#.  commit 30175628bf7f521e9ee31ac98fa6d6fe7441a556
#. type: Plain text
#: man-pages/man2/fallocate.2:242
msgid "SMB3 (since Linux 3.17)"
msgstr "SMB3 (начиная с Linux 3.17)"

#.  commit f27451f229966874a8793995b8e6b74326d125df
#. type: Plain text
#: man-pages/man2/fallocate.2:245
msgid "Btrfs (since Linux 4.16)"
msgstr "Btrfs (начиная с Linux 4.16)"

#. type: SS
#: man-pages/man2/fallocate.2:245
#, no-wrap
msgid "Increasing file space"
msgstr "Увеличение файлового пространства"

#.  commit dd46c787788d5bf5b974729d43e4c405814a4c7d
#. type: Plain text
#: man-pages/man2/fallocate.2:268
msgid ""
"Specifying the B<FALLOC_FL_INSERT_RANGE> flag (available since Linux 4.1)  "
"in I<mode> increases the file space by inserting a hole within the file size "
"without overwriting any existing data.  The hole will start at I<offset> and "
"continue for I<len> bytes.  When inserting the hole inside file, the "
"contents of the file starting at I<offset> will be shifted upward (i.e., to "
"a higher file offset) by I<len> bytes.  Inserting a hole inside a file "
"increases the file size by I<len> bytes."
msgstr ""
"Задание флага B<FALLOC_FL_INSERT_RANGE> (доступен начиная с Linux 4.1) в "
"I<mode> увеличивает файловое пространство посредством вставки дыры (hole) в "
"размер файла без перезаписывания существующих данных. Дыра начинается с "
"I<offset> и продолжается I<len> байт. При вставки дыры внутрь файла "
"содержимое файла, начинающееся с I<offset>, будет сдвинуто вперёд (т. е., "
"станет доступно по большему смещению в файле) на I<len> байт. Вставка дыры "
"внутрь файла увеличивает размер файла на I<len> байт."

#. type: Plain text
#: man-pages/man2/fallocate.2:282
msgid ""
"This mode has the same limitations as B<FALLOC_FL_COLLAPSE_RANGE> regarding "
"the granularity of the operation.  If the granularity requirements are not "
"met, B<fallocate>()  fails with the error B<EINVAL>.  If the I<offset> is "
"equal to or greater than the end of file, an error is returned.  For such "
"operations (i.e., inserting a hole at the end of file), B<ftruncate>(2)  "
"should be used."
msgstr ""
"Данный режим имеет те же ограничения что и B<FALLOC_FL_COLLAPSE_RANGE>, "
"независимо от детализации операции Если требования детализации не "
"удовлетворяются, то B<fallocate>() завершается ошибкой B<EINVAL>. Если "
"I<offset> больше или равно концу файла, то возвращается ошибка. Для таких "
"операций (т. е., вставка дыры в конец файла) нужно использовать "
"B<ftruncate>(2)."

#. type: Plain text
#: man-pages/man2/fallocate.2:287
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_INSERT_RANGE>."
msgstr ""
"Вместе с B<FALLOC_FL_INSERT_RANGE> другие флаги в I<mode> указывать нельзя."

#.  commit a904b1ca5751faf5ece8600e18cd3b674afcca1b
#.  commit 331573febb6a224bc50322e3670da326cb7f4cfc
#.  f2fs also has support since Linux 4.2
#.      commit f62185d0e283e9d311e3ac1020f159d95f0aab39
#. type: Plain text
#: man-pages/man2/fallocate.2:297
msgid ""
"B<FALLOC_FL_INSERT_RANGE> requires filesystem support.  Filesystems that "
"support this operation include XFS (since Linux 4.1)  and ext4 (since Linux "
"4.2)."
msgstr ""
"Для работы B<FALLOC_FL_INSERT_RANGE> требуется поддержка в файловой системе; "
"сейчас это XFS (начиная с Linux 4.1)  и ext4 (начиная с Linux 4.2)."

#. type: Plain text
#: man-pages/man2/fallocate.2:304
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fallocate>() возвращается 0; при ошибке "
"возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/fallocate.2:309
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""
"Значение I<fd> не является допустимым файловым дескриптором или он не открыт "
"на запись."

#. type: TP
#: man-pages/man2/fallocate.2:309 man-pages/man2/fallocate.2:313
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man2/fallocate.2:313
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr "Сумма I<offset>+I<len> превышает максимальный размер файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:319
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE>, and the current file size+I<len> "
"exceeds the maximum file size."
msgstr ""
"В I<mode> указан B<FALLOC_FL_INSERT_RANGE>, и текущий размер файла+I<len> "
"превышает максимальный файловый размер."

#. type: Plain text
#: man-pages/man2/fallocate.2:323
msgid "A signal was caught during execution; see B<signal>(7)."
msgstr "При выполнении поступил сигнал; смотрите B<signal>(7)."

#.  FIXME . (raise a kernel bug) Probably the len==0 case should be
#.  a no-op, rather than an error. That would be consistent with
#.  similar APIs for the len==0 case.
#.  See "Re: [PATCH] fallocate.2: add FALLOC_FL_PUNCH_HOLE flag definition"
#.  21 Sep 2012
#.  http://thread.gmane.org/gmane.linux.file-systems/48331/focus=1193526
#. type: Plain text
#: man-pages/man2/fallocate.2:335
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr "Значение I<offset> меньше 0, или I<len> меньше или равно 0."

#. type: Plain text
#: man-pages/man2/fallocate.2:345
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by I<offset> "
"plus I<len> reaches or passes the end of the file."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE>, но диапазон, указанный в "
"I<offset> плюс I<len>, достиг или перешагнул за конец файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:353
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE> and the range specified by I<offset> "
"reaches or passes the end of the file."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_INSERT_RANGE>, но диапазон, указанный в "
"I<offset>, достиг или перешагнул за конец файла."

#. type: Plain text
#: man-pages/man2/fallocate.2:365
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, but "
"either I<offset> or I<len> is not a multiple of the filesystem block size."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE> или "
"B<FALLOC_FL_INSERT_RANGE>, но значение I<offset> или I<len> не кратно "
"размеру блока файловой системы."

#. type: Plain text
#: man-pages/man2/fallocate.2:377
msgid ""
"I<mode> contains one of B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and also other flags; no other flags are permitted "
"with B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>."
msgstr ""
"Значение I<mode> содержит B<FALLOC_FL_COLLAPSE_RANGE> или "
"B<FALLOC_FL_INSERT_RANGE>, а также другие флаги; но с "
"B<FALLOC_FL_COLLAPSE_RANGE> или B<FALLOC_FL_INSERT_RANGE> другие флаги "
"указывать нельзя."

#.  There was an inconsistency in 3.15-rc1, that should be resolved so that all
#.  filesystems use this error for this case. (Tytso says ex4 will change.)
#.  http://thread.gmane.org/gmane.comp.file-systems.xfs.general/60485/focus=5521
#.  From: Michael Kerrisk (man-pages <mtk.manpages@...>
#.  Subject: Re: [PATCH v5 10/10] manpage: update FALLOC_FL_COLLAPSE_RANGE flag in fallocate
#.  Newsgroups: gmane.linux.man, gmane.linux.file-systems
#.  Date: 2014-04-17 13:40:05 GMT
#. type: Plain text
#: man-pages/man2/fallocate.2:396
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_ZERO_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE>, but the file referred to by I<fd> is not a "
"regular file."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE>, B<FALLOC_FL_ZERO_RANGE> "
"или B<FALLOC_FL_INSERT_RANGE>, но файл, на который указывает I<fd>, не "
"является обычным файлом."

#. type: Plain text
#: man-pages/man2/fallocate.2:399
msgid "An I/O error occurred while reading from or writing to a filesystem."
msgstr ""
"При чтении или записи в файловую систему произошла ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/fallocate.2:406
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""
"Значение I<fd> не указывает на обычный файл или каталог (если I<fd> — канал "
"или FIFO, то возникнет другая ошибка)."

#. type: Plain text
#: man-pages/man2/fallocate.2:411
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr ""
"Недостаточно дискового пространства на устройстве, на котором расположен "
"файл, указанный в I<fd>."

#. type: Plain text
#: man-pages/man2/fallocate.2:415
msgid "This kernel does not implement B<fallocate>()."
msgstr "В данном ядре вызов B<fallocate>() не реализован."

#. type: Plain text
#: man-pages/man2/fallocate.2:424
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the filesystem containing "
"the file referred to by I<fd>."
msgstr ""
"Файловая система с файлом, на который указывает I<fd>, не поддерживает "
"данную операцию; или значение I<mode> не поддерживается файловой системой, в "
"которой находится файл, на который указывает I<fd>."

#. type: Plain text
#: man-pages/man2/fallocate.2:430
msgid "The file referred to by I<fd> is marked immutable (see B<chattr>(1))."
msgstr ""
"Файл, на который указывает I<fd>, помечен как неизменяемый (immutable) "
"(смотрите B<chattr>(1))."

#. type: Plain text
#: man-pages/man2/fallocate.2:445
msgid ""
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> or B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and the file referred to by I<fd> is marked append-"
"only (see B<chattr>(1))."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_PUNCH_HOLE>, B<FALLOC_FL_COLLAPSE_RANGE> "
"или B<FALLOC_FL_INSERT_RANGE> и файл, на который указывает I<fd>, помечен "
"как только для добавления (смотрите B<chattr>(1))."

#. type: Plain text
#: man-pages/man2/fallocate.2:449
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""
"Выполнение операции предотвращено опечатыванием (file seal); смотрите "
"B<fcntl>(2)."

#. type: TP
#: man-pages/man2/fallocate.2:449
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: man-pages/man2/fallocate.2:453
msgid "I<fd> refers to a pipe or FIFO."
msgstr "Значение I<fd> указывает на канал или FIFO."

#. type: Plain text
#: man-pages/man2/fallocate.2:463
msgid ""
"I<mode> specifies B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, "
"but the file referred to by I<fd> is currently being executed."
msgstr ""
"Значение I<mode> равно B<FALLOC_FL_COLLAPSE_RANGE> или "
"B<FALLOC_FL_INSERT_RANGE>, но файл, на который указывает I<fd>, в данный "
"момент выполняется."

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: man-pages/man2/fallocate.2:471
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""
"Вызов B<fallocate>() доступен в Linux начиная с ядра 2.6.23. Поддержка в "
"glibc добавлена в версии 2.10. Флаги B<FALLOC_FL_*> определены в "
"заголовочных файлах glibc только начиная с версии 2.18."

#. type: Plain text
#: man-pages/man2/fallocate.2:474
msgid "B<fallocate>()  is Linux-specific."
msgstr "Вызов B<fallocate>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/fallocate.2:478
msgid ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"

#. type: TH
#: man-pages/man5/ftpusers.5:19
#, no-wrap
msgid "FTPUSERS"
msgstr "FTPUSERS"

#. type: TH
#: man-pages/man5/ftpusers.5:19
#, no-wrap
msgid "2000-08-27"
msgstr "2000-08-27"

#. type: Plain text
#: man-pages/man5/ftpusers.5:22
msgid "ftpusers - list of users that may not log in via the FTP daemon"
msgstr "ftpusers - список пользователей, не имеющих доступа к службе FTP"

#. type: Plain text
#: man-pages/man5/ftpusers.5:30
msgid ""
"The text file B<ftpusers> contains a list of users that may not log in using "
"the File Transfer Protocol (FTP) server daemon.  This file is used not "
"merely for system administration purposes but also for improving security "
"within a TCP/IP networked environment."
msgstr ""
"Текстовый файл B<ftpusers> содержит список пользователей, которые не могут "
"войти на сервер по протоколу передачи файлов (FTP). Этот файл используется "
"не только в целях администрирования системы, но и для улучшения безопасности "
"в сетевой среде TCP/IP."

#. type: Plain text
#: man-pages/man5/ftpusers.5:37
msgid ""
"The B<ftpusers> file will typically contain a list of the users that either "
"have no business using ftp or have too many privileges to be allowed to log "
"in through the FTP server daemon.  Such users usually include root, daemon, "
"bin, uucp, and news."
msgstr ""
"Обычно, файл B<ftpusers> содержит список пользователей, которые не "
"пользуются ftp или имеют слишком много прав, позволяющих получить доступ "
"через службу сервера FTP. Такими пользователями, обычно, являются root, "
"daemon, bin, uucp и news."

#. type: Plain text
#: man-pages/man5/ftpusers.5:45
msgid ""
"If your FTP server daemon doesn't use B<ftpusers>, then it is suggested that "
"you read its documentation to find out how to block access for certain "
"users.  Washington University FTP server Daemon (wuftpd) and Professional "
"FTP Daemon (proftpd) are known to make use of B<ftpusers>."
msgstr ""
"Если сервер FTP не использует B<ftpusers>, то рекомендуется прочитать его "
"документацию, чтобы найти способ блокирования определённых пользователей. "
"Сервер Washington University FTP Daemon (wuftpd) и Professional FTP Daemon "
"(proftpd) умеют обращаться с B<ftpusers>."

#. type: SS
#: man-pages/man5/ftpusers.5:45
#, no-wrap
msgid "Format"
msgstr "Формат"

#. type: Plain text
#: man-pages/man5/ftpusers.5:51
msgid ""
"The format of B<ftpusers> is very simple.  There is one account name (or "
"username) per line.  Lines starting with a # are ignored."
msgstr ""
"Формат B<ftpusers> очень прост. Он содержит по одному имени учётной записи "
"(или имени пользователя) в каждой строке. Строки, начинающиеся с # "
"игнорируются."

#. type: Plain text
#: man-pages/man5/ftpusers.5:53
msgid "I</etc/ftpusers>"
msgstr "I</etc/ftpusers>"

#. type: Plain text
#: man-pages/man5/ftpusers.5:56
msgid "B<passwd>(5), B<proftpd>(8), B<wuftpd>(8)"
msgstr "B<passwd>(5), B<proftpd>(8), B<wuftpd>(8)"

#. type: TH
#: man-pages/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr "FILESYSTEMS"

#. type: Plain text
#: man-pages/man5/filesystems.5:32
msgid ""
"filesystems - Linux filesystem types: ext, ext2, ext3, ext4, hpfs, iso9660, "
"JFS, minix, msdos, ncpfs nfs, ntfs, proc, Reiserfs, smb, sysv, umsdos, vfat, "
"XFS, xiafs,"
msgstr ""
"filesystems - типы файловых систем Linux: ext, ext2, ext3, ext4, hpfs, "
"iso9660, JFS, minix, msdos, ncpfs nfs, ntfs, proc, Reiserfs, smb, sysv, "
"umsdos, vfat, XFS, xiafs,"

#.  commit: 6af9f7bf3c399e0ab1eee048e13572c6d4e15fe9
#. type: Plain text
#: man-pages/man5/filesystems.5:53
msgid ""
"When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which filesystems your kernel "
"currently supports; see B<proc>(5)  for more details.  There is also a "
"legacy B<sysfs>(2)  system call (whose availability is controlled by the "
"B<CONFIG_SYSFS_SYSCALL> kernel build configuration option since Linux 3.15)  "
"that enables enumeration of the currently available filesystem types "
"regardless of I</proc> availability and/or sanity."
msgstr ""
"Если, как обычно, файловая система B<proc> смонтирована в I</proc>, то в "
"файле I</proc/filesystems> можно найти список типов файловых систем, которые "
"в текущий момент поддерживаются ядром; подробности смотрите в B<proc>(5). "
"Также есть устаревший системный вызов B<sysfs>(2) (доступен, если ядро "
"собрано с параметром настойки B<CONFIG_SYSFS_SYSCALL>, начиная с Linux "
"3.15), который содержи перечисление доступных типов файловых систем "
"независимо от того, смонтировано ли что-то в I</proc> или нет."

#. type: Plain text
#: man-pages/man5/filesystems.5:56
msgid ""
"If you need a currently unsupported filesystem, insert the corresponding "
"kernel module or recompile the kernel."
msgstr ""
"Если требуется пока не поддерживаемая файловая система, то загрузите "
"соответствующий модуль или пересоберите ядро."

#. type: Plain text
#: man-pages/man5/filesystems.5:63
msgid ""
"In order to use a filesystem, you have to I<mount> it; see B<mount>(2)  and "
"B<mount>(8)."
msgstr ""
"Чтобы использовать файловую систему, её нужно I<смонтировать>; смотрите "
"B<mount>(2) и B<mount>(8)."

#. type: Plain text
#: man-pages/man5/filesystems.5:69
msgid ""
"iThe following list provides a short description of the available or "
"historically available filesystems in the Linux kernel.  See the kernel "
"documentation for a comprehensive description of all options and limitations."
msgstr ""
"В списке далее приводится краткое описание доступных или доступных ранее "
"файловых систем в ядре Linux. Полное описание, все параметры и ограничения "
"описаны в документации к ядру."

#. type: TP
#: man-pages/man5/filesystems.5:69
#, no-wrap
msgid "B<ext>"
msgstr "B<ext>"

#. type: Plain text
#: man-pages/man5/filesystems.5:78
msgid ""
"is an elaborate extension of the B<minix> filesystem.  It has been "
"completely superseded by the second version of the extended filesystem "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""
"Доработанное расширение файловой системы B<minix>. Полностью вытеснена "
"второй версией расширенной файловой системой (B<ext2>) и была удалена из "
"ядра (в 2.1.21)."

#. type: TP
#: man-pages/man5/filesystems.5:78
#, no-wrap
msgid "B<ext2>"
msgstr "B<ext2>"

#. type: Plain text
#: man-pages/man5/filesystems.5:87
msgid ""
"is the high performance disk filesystem used by Linux for fixed disks as "
"well as removable media.  The second extended filesystem was designed as an "
"extension of the extended filesystem (B<ext>).  See B<ext2>(5)."
msgstr ""
"Высокопроизводительная дисковая файловая система Linux для жёстких дисков, а "
"также сменных носителей. Вторая версия расширенной файловой системы "
"разрабатывалась как расширение расширенной файловой системы (B<ext>). "
"Смотрите B<ext2>(5)."

#. type: TP
#: man-pages/man5/filesystems.5:87
#, no-wrap
msgid "B<ext3>"
msgstr "B<ext3>"

#. type: Plain text
#: man-pages/man5/filesystems.5:99
msgid ""
"is a journaling version of the B<ext2> filesystem.  It is easy to switch "
"back and forth between B<ext2> and B<ext3>.  See B<ext3>(5)."
msgstr ""
"Журналируемая версия файловой системы B<ext2>. Очень легко переключаться с "
"B<ext2> на B<ext3> и обратно. Смотрите B<ext3>(5)."

#. type: TP
#: man-pages/man5/filesystems.5:99
#, no-wrap
msgid "B<ext4>"
msgstr "B<ext4>"

#. type: Plain text
#: man-pages/man5/filesystems.5:108
msgid ""
"is a set of upgrades to B<ext3> including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits.  See B<ext4>(5)."
msgstr ""
"Обновлённая версия B<ext3>, включающая существенное увеличение "
"производительности и надёжности, размеров границ томов, файлов и каталогов. "
"Смотрите B<ext4>(5)."

#. type: TP
#: man-pages/man5/filesystems.5:108
#, no-wrap
msgid "B<hpfs>"
msgstr "B<hpfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:113
msgid ""
"is the High Performance Filesystem, used in OS/2.  This filesystem is read-"
"only under Linux due to the lack of available documentation."
msgstr ""
"Высокопроизводительная файловая система (High Performance Filesystem), "
"используемая в OS/2. Данная файловая система доступна под Linux только для "
"чтения из-за отсутствия документации."

#. type: TP
#: man-pages/man5/filesystems.5:113
#, no-wrap
msgid "B<iso9660>"
msgstr "B<iso9660>"

#. type: Plain text
#: man-pages/man5/filesystems.5:116
msgid "is a CD-ROM filesystem type conforming to the ISO 9660 standard."
msgstr "Файловая система для CD-ROM, соответствующая стандарту ISO 9660."

#. type: TP
#: man-pages/man5/filesystems.5:117
#, no-wrap
msgid "B<High Sierra>"
msgstr "B<High Sierra>"

#. type: Plain text
#: man-pages/man5/filesystems.5:124
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for CD-"
"ROM filesystems.  It is automatically recognized within the B<iso9660> "
"filesystem support under Linux."
msgstr ""
"В Linux есть поддержка стандарта High Sierra, предшественника стандарта ISO "
"9660 для файловых систем CD-ROM. High Sierra автоматически распознается при "
"включении в Linux поддержки файловой системы B<iso9660>."

#. type: TP
#: man-pages/man5/filesystems.5:124
#, no-wrap
msgid "B<Rock Ridge>"
msgstr "B<Rock Ridge>"

#. type: Plain text
#: man-pages/man5/filesystems.5:135
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the "
"Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> filesystem to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> filesystem support under "
"Linux."
msgstr ""
"В Linux также есть поддержка записей System Use Sharing Protocol, которые "
"определены в протоколе обмена Rock Ridge. Они используются для подробного "
"описания файлов в файловой системе B<iso9660> для машин UNIX и предоставляют "
"информацию о длинных именах файлов, UID/GID, правах доступа к файлам по "
"стандарту POSIX и файлах устройств. Rock Ridge автоматически распознаётся "
"при включении в Linux поддержки файловой системы B<iso9660>."

#. type: TP
#: man-pages/man5/filesystems.5:136
#, no-wrap
msgid "B<JFS>"
msgstr "B<JFS>"

#. type: Plain text
#: man-pages/man5/filesystems.5:140
msgid ""
"is a journaling filesystem, developed by IBM, that was integrated into Linux "
"in kernel 2.4.24."
msgstr ""
"Журналируемая файловая система, разработанная IBM, была добавлена в Linux "
"начиная с ядра версии 2.4.24."

#. type: TP
#: man-pages/man5/filesystems.5:140
#, no-wrap
msgid "B<minix>"
msgstr "B<minix>"

#. type: Plain text
#: man-pages/man5/filesystems.5:147
msgid ""
"is the filesystem used in the Minix operating system, the first to run under "
"Linux.  It has a number of shortcomings, including a 64\\ MB partition size "
"limit, short filenames, and a single timestamp.  It remains useful for "
"floppies and RAM disks."
msgstr ""
"Файловая система, использующаяся в операционной системе Minix, первая, на "
"которой заработал Linux. Имеет несколько недостатков: максимальный размер "
"раздела 64\\ МБ, короткие имена файлов и одна временная метка. Осталась "
"полезной для дискет и RAM-дисков."

#. type: TP
#: man-pages/man5/filesystems.5:147
#, no-wrap
msgid "B<msdos>"
msgstr "B<msdos>"

#. type: Plain text
#: man-pages/man5/filesystems.5:153
msgid ""
"is the filesystem used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period "
"and 3 character extension."
msgstr ""
"Файловая система, используемая в DOS, Windows и на некоторых компьютерах с "
"OS/2. Имена файлов в B<msdos> не могут быть более 8 символов с "
"необязательным расширением из 3 символов, отделённого точкой."

#. type: TP
#: man-pages/man5/filesystems.5:153
#, no-wrap
msgid "B<ncpfs>"
msgstr "B<ncpfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:157
msgid ""
"is a network filesystem that supports the NCP protocol, used by Novell "
"NetWare."
msgstr ""
"Сетевая файловая система, которая поддерживает протокол NCP, используемый в "
"Novell NetWare."

#. type: Plain text
#: man-pages/man5/filesystems.5:163
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"
msgstr ""
"Для использования B<ncpfs> необходимы специальные программы, которые можно "
"найти по адресу E<.UR ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"

#. type: TP
#: man-pages/man5/filesystems.5:163
#, no-wrap
msgid "B<nfs>"
msgstr "B<nfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:166
msgid ""
"is the network filesystem used to access disks located on remote computers."
msgstr ""
"Сетевая файловая система, используемая для доступа к дискам, расположенным "
"на других компьютерах в сети."

#. type: TP
#: man-pages/man5/filesystems.5:166
#, no-wrap
msgid "B<ntfs>"
msgstr "B<ntfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:171
msgid ""
"replaces Microsoft Window's FAT filesystems (VFAT, FAT32).  It has "
"reliability, performance, and space-utilization enhancements plus features "
"like ACLs, journaling, encryption, and so on."
msgstr ""
"Замена для файловых систем Microsoft Window FAT (VFAT, FAT32). Улучшена "
"надёжность, производительность и использование пространства и добавлены "
"такие возможности как списки контроля, журналирование, шифрование и т.д."

#. type: TP
#: man-pages/man5/filesystems.5:171
#, no-wrap
msgid "B<proc>"
msgstr "B<proc>"

#. type: Plain text
#: man-pages/man5/filesystems.5:179
msgid ""
"is a pseudo filesystem which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""
"Ненастоящая файловая система, используется как интерфейс к структурам данных "
"ядра вместо прямого чтения из I</dev/kmem>. В частности, её файлы не "
"занимают пространство на диске. Смотрите B<proc>(5)."

#. type: TP
#: man-pages/man5/filesystems.5:179
#, no-wrap
msgid "B<Reiserfs>"
msgstr "B<Reiserfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:183
msgid ""
"is a journaling filesystem, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""
"Журналируемая файловая система, разработанная Гансом Рейзером (Hans Reiser), "
"была добавлена в Linux начиная с ядра версии 2.4.1."

#. type: TP
#: man-pages/man5/filesystems.5:183
#, no-wrap
msgid "B<smb>"
msgstr "B<smb>"

#. type: Plain text
#: man-pages/man5/filesystems.5:190
msgid ""
"is a network filesystem that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager.  See E<.UR https://www.samba.org\\:/"
"samba\\:/smbfs/> E<.UE .>"
msgstr ""
"Сетевая файловая система, которая поддерживает протокол SMB, используемый в "
"Windows for Workgroups, Windows NT и Lan Manager. Смотрите E<.UR https://www."
"samba.org\\:/samba\\:/smbfs/> E<.UE .>"

#. type: TP
#: man-pages/man5/filesystems.5:190
#, no-wrap
msgid "B<sysv>"
msgstr "B<sysv>"

#. type: Plain text
#: man-pages/man5/filesystems.5:194
msgid ""
"is an implementation of the SystemV/Coherent filesystem for Linux.  It "
"implements all of Xenix FS, SystemV/386 FS, and Coherent FS."
msgstr ""
"Реализация файловой системы SystemV/Coherent для Linux. Поддерживает "
"файловые системы из Xenix, SystemV/386 и Coherent."

#. type: TP
#: man-pages/man5/filesystems.5:194
#, no-wrap
msgid "B<umsdos>"
msgstr "B<umsdos>"

#. type: Plain text
#: man-pages/man5/filesystems.5:201
msgid ""
"is an extended DOS filesystem used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.) under the DOS filesystem, without sacrificing compatibility "
"with DOS."
msgstr ""
"Расширенная файловая система DOS, используемая в Linux. Была добавлена "
"поддержка длинных имён файлов, UID/GID, права доступа POSIX и специальные "
"файлы (устройства, именованные каналы и т.д.) без ухудшения совместимости с "
"DOS."

#. type: TP
#: man-pages/man5/filesystems.5:201
#, no-wrap
msgid "B<tmpfs>"
msgstr "B<tmpfs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:208
msgid ""
"is a filesystem whose contents reside in virtual memory.  Since the files on "
"such filesystems typically reside in RAM, file access is extremely fast.  "
"See B<tmpfs>(5)."
msgstr ""
"Файловая система, чьё содержимое находится в виртуальной памяти. Так как "
"файлы в таких файловых системах, обычно, располагаются в оперативной памяти, "
"то доступ к файлах очень быстр. Смотрите B<tmpfs>(5)."

#. type: TP
#: man-pages/man5/filesystems.5:208
#, no-wrap
msgid "B<vfat>"
msgstr "B<vfat>"

#. type: Plain text
#: man-pages/man5/filesystems.5:213
msgid ""
"is an extended FAT filesystem used by Microsoft Windows95 and Windows NT.  "
"B<vfat> adds the capability to use long filenames under the MSDOS filesystem."
msgstr ""
"Расширенная файловая система FAT, используемая в Microsoft Windows95 и "
"Windows NT. В B<vfat> добавлена поддержка длинных имён файлов из файловой "
"системы MSDOS."

#. type: TP
#: man-pages/man5/filesystems.5:213
#, no-wrap
msgid "B<XFS>"
msgstr "B<XFS>"

#. type: Plain text
#: man-pages/man5/filesystems.5:217
msgid ""
"is a journaling filesystem, developed by SGI, that was integrated into Linux "
"in kernel 2.4.20."
msgstr ""
"Журналируемая файловая система, разработанная SGI, была добавлена в Linux "
"начиная с ядра версии 2.4.20."

#. type: TP
#: man-pages/man5/filesystems.5:217
#, no-wrap
msgid "B<xiafs>"
msgstr "B<xiafs>"

#. type: Plain text
#: man-pages/man5/filesystems.5:227
msgid ""
"was designed and implemented to be a stable, safe filesystem by extending "
"the Minix filesystem code.  It provides the basic most requested features "
"without undue complexity.  The B<xiafs> filesystem is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr ""
"Разработана и реализована как стабильная надёжная файловая система "
"посредством расширения кода файловой системы Minix. Предоставляет основные "
"часто запрашиваемые возможности без неоправданной сложности. Файловая "
"система B<xiafs> больше активно не разрабатывается или сопровождается. Была "
"удалена из ядра 2.1.21."

#. type: Plain text
#: man-pages/man5/filesystems.5:238
msgid ""
"B<fuse>(4), B<btrfs>(5), B<ext2>(5), B<ext3>(5), B<ext4>(5), B<nfs>(5), "
"B<proc>(5), B<tmpfs>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"
msgstr ""
"B<fuse>(4), B<btrfs>(5), B<ext2>(5), B<ext3>(5), B<ext4>(5), B<nfs>(5), "
"B<proc>(5), B<tmpfs>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"

#. type: TH
#: man-pages/man3/finite.3:25
#, no-wrap
msgid "FINITE"
msgstr "FINITE"

#. type: Plain text
#: man-pages/man3/finite.3:29
msgid ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - BSD "
"floating-point classification functions"
msgstr ""
"finite, finitef, finitel, isinf, isinff, isinfl, isnan, isnanf, isnanl - "
"функции BSD для классификации чисел с плавающей запятой"

#. type: Plain text
#: man-pages/man3/finite.3:32
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/finite.3:36
#, no-wrap
msgid ""
"B<int finite(double >I<x>B<);>\n"
"B<int finitef(float >I<x>B<);>\n"
"B<int finitel(long double >I<x>B<);>\n"
msgstr ""
"B<int finite(double >I<x>B<);>\n"
"B<int finitef(float >I<x>B<);>\n"
"B<int finitel(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:40
#, no-wrap
msgid ""
"B<int isinf(double >I<x>B<);>\n"
"B<int isinff(float >I<x>B<);>\n"
"B<int isinfl(long double >I<x>B<);>\n"
msgstr ""
"B<int isinf(double >I<x>B<);>\n"
"B<int isinff(float >I<x>B<);>\n"
"B<int isinfl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:44
#, no-wrap
msgid ""
"B<int isnan(double >I<x>B<);>\n"
"B<int isnanf(float >I<x>B<);>\n"
"B<int isnanl(long double >I<x>B<);>\n"
msgstr ""
"B<int isnan(double >I<x>B<);>\n"
"B<int isnanf(float >I<x>B<);>\n"
"B<int isnanl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/finite.3:55
msgid "B<finite>(), B<finitef>(), B<finitel>():"
msgstr "B<finite>(), B<finitef>(), B<finitel>():"

#. type: Plain text
#: man-pages/man3/finite.3:58 man-pages/man3/finite.3:71
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/finite.3:60
msgid "B<isinf>():"
msgstr "B<isinf>():"

#. type: Plain text
#: man-pages/man3/finite.3:64
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/finite.3:68
msgid "B<isinff>(), B<isinfl>():"
msgstr "B<isinff>(), B<isinfl>():"

#. type: Plain text
#: man-pages/man3/finite.3:73
msgid "B<isnan>():"
msgstr "B<isnan>():"

#. type: Plain text
#: man-pages/man3/finite.3:77
#, no-wrap
msgid ""
"_XOPEN_SOURCE || _ISOC99_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE || _ISOC99_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/finite.3:80
msgid "B<isnanf>(), B<isnanl>():"
msgstr "B<isnanf>(), B<isnanl>():"

#. type: Plain text
#: man-pages/man3/finite.3:84
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии gibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/finite.3:96
msgid ""
"The B<finite>(), B<finitef>(), and B<finitel>()  functions return a nonzero "
"value if I<x> is neither infinite nor a \"not-a-number\" (NaN) value, and 0 "
"otherwise."
msgstr ""
"Функции B<finite>(), B<finitef>() и B<finitel>() возвращают ненулевое "
"значение, если I<x> не равно бесконечности или «не числу» (NaN), в противном "
"случае 0."

#. type: Plain text
#: man-pages/man3/finite.3:106
msgid ""
"The B<isnan>(), B<isnanf>(), and B<isnanl>()  functions return a nonzero "
"value if I<x> is a NaN value, and 0 otherwise."
msgstr ""
"Функции B<isnan>(), B<isnanf>() и B<isnanl>() возвращают ненулевое значение, "
"если I<x> равно NaN, в противном случае 0."

#. type: Plain text
#: man-pages/man3/finite.3:117
msgid ""
"The B<isinf>(), B<isinff>(), and B<isinfl>()  functions return 1 if I<x> is "
"positive infinity, -1 if I<x> is negative infinity, and 0 otherwise."
msgstr ""
"Функции B<isinf>(), B<isinff>() и B<isinfl>() возвращают 1, если I<x> равно "
"плюс бесконечности, -1, если I<x> равно минус бесконечности, в остальных "
"случаях 0."

#. type: SH
#: man-pages/man3/finite.3:117
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man3/finite.3:120
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man3/finite.3:124
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man3/finite.3:124
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man3/finite.3:124
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man3/finite.3:129
#, no-wrap
msgid ""
"B<finite>(),\n"
"B<finitef>(),\n"
"B<finitel>(),\n"
msgstr ""
"B<finite>(),\n"
"B<finitef>(),\n"
"B<finitel>(),\n"

#. type: tbl table
#: man-pages/man3/finite.3:129 man-pages/man3/finite.3:133
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/finite.3:133
#, no-wrap
msgid ""
"B<isinf>(),\n"
"B<isinff>(),\n"
"B<isinfl>(),\n"
msgstr ""
"B<isinf>(),\n"
"B<isinff>(),\n"
"B<isinfl>(),\n"

#. type: tbl table
#: man-pages/man3/finite.3:137
#, no-wrap
msgid ""
"B<isnan>(),\n"
"B<isnanf>(),\n"
"B<isnanl>()"
msgstr ""
"B<isnan>(),\n"
"B<isnanf>(),\n"
"B<isnanl>()"

#. type: tbl table
#: man-pages/man3/finite.3:137
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man3/finite.3:137
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#.  finite* not on HP-UX; they exist on Tru64.
#.  .SH HISTORY
#.  The
#.  .BR finite ()
#.  function occurs in 4.3BSD.
#.  see IEEE.3 in the 4.3BSD manual
#. type: Plain text
#: man-pages/man3/finite.3:159
msgid ""
"Note that these functions are obsolete.  C99 defines macros B<isfinite>(), "
"B<isinf>(), and B<isnan>()  (for all types) replacing them.  Further note "
"that the C99 B<isinf>()  has weaker guarantees on the return value.  See "
"B<fpclassify>(3)."
msgstr ""
"Заметим, что эти функции устарели. В C99 их заменили макросы B<isfinite>(), "
"B<isinf>() и B<isnan>() (для всех типов). Также заметим, что для B<isinf>() "
"C99 не гарантируется возвращаемого значения. Смотрите B<fpclassify>(3)."

#. type: Plain text
#: man-pages/man3/finite.3:160
msgid "B<fpclassify>(3)"
msgstr "B<fpclassify>(3)"

#. type: TH
#: man-pages/man3/fdim.3:9
#, no-wrap
msgid "FDIM"
msgstr "FDIM"

#. type: Plain text
#: man-pages/man3/fdim.3:12
msgid "fdim, fdimf, fdiml - positive difference"
msgstr "fdim, fdimf, fdiml - вычисление положительной разницы"

#. type: Plain text
#: man-pages/man3/fdim.3:14
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: man-pages/man3/fdim.3:16
msgid "B<double fdim(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fdim(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fdim.3:18
msgid "B<float fdimf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fdimf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fdim.3:20
msgid "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fdiml(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fdim.3:22
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/fdim.3:31
msgid "B<fdimf>(), B<fdiml>():"
msgstr "B<fdimf>(), B<fdiml>():"

#. type: Plain text
#: man-pages/man3/fdim.3:33
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/fdim.3:38
msgid ""
"These functions return the positive difference, max(I<x>-I<y>,0), between "
"their arguments."
msgstr ""
"Эти функции возвращают положительную разницу, max(I<x>-I<y>,0), между их "
"аргументами."

#. type: Plain text
#: man-pages/man3/fdim.3:40
msgid "On success, these functions return the positive difference."
msgstr ""
"При успешном выполнении данные функции возвращают положительную разницу."

#. type: Plain text
#: man-pages/man3/fdim.3:46
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr "Если I<x> или I<y> равно NaN, то будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fdim.3:55
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, "
"соответственно."

#. type: Plain text
#: man-pages/man3/fdim.3:60
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать "
"при вызове этих функций."

#. type: Plain text
#: man-pages/man3/fdim.3:62
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/fdim.3:62
#, no-wrap
msgid "Range error: result overflow"
msgstr "Ошибка диапазона: результат превысил разрядность"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/fdim.3:70
msgid "An overflow floating-point exception (B<FE_OVERFLOW>)  is raised."
msgstr "Вызывается исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6796
#. type: Plain text
#: man-pages/man3/fdim.3:75
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: Plain text
#: man-pages/man3/fdim.3:77
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: tbl table
#: man-pages/man3/fdim.3:89
#, no-wrap
msgid ""
"B<fdim>(),\n"
"B<fdimf>(),\n"
"B<fdiml>()"
msgstr ""
"B<fdim>(),\n"
"B<fdimf>(),\n"
"B<fdiml>()"

#. type: Plain text
#: man-pages/man3/fdim.3:93
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/fdim.3:94
msgid "B<fmax>(3)"
msgstr "B<fmax>(3)"

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "FNMATCH"
msgstr "FNMATCH"

#. type: TH
#: man-pages/man3/fnmatch.3:28
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/fnmatch.3:31
msgid "fnmatch - match filename or pathname"
msgstr "fnmatch - сравнивает имя файла или путь"

#. type: Plain text
#: man-pages/man3/fnmatch.3:34
#, no-wrap
msgid "B<#include E<lt>fnmatch.hE<gt>>\n"
msgstr "B<#include E<lt>fnmatch.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fnmatch.3:36
#, no-wrap
msgid "B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int >I<flags>B<);>\n"
msgstr "B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/fnmatch.3:46
msgid ""
"The B<fnmatch>()  function checks whether the I<string> argument matches the "
"I<pattern> argument, which is a shell wildcard pattern (see B<glob>(7))."
msgstr ""
"Функция B<fnmatch>() проверяет, совпадает ли параметр I<string> с параметром "
"I<pattern>, который является подстановочным шаблоном оболочки (смотрите "
"B<glob>(7))."

#. type: Plain text
#: man-pages/man3/fnmatch.3:51
msgid ""
"The I<flags> argument modifies the behavior; it is the bitwise OR of zero or "
"more of the following flags:"
msgstr ""
"Аргумент I<flags> изменяет поведение; он является битовой маской и может "
"содержать следующие флаги:"

#. type: TP
#: man-pages/man3/fnmatch.3:51
#, no-wrap
msgid "B<FNM_NOESCAPE>"
msgstr "B<FNM_NOESCAPE>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:55
msgid ""
"If this flag is set, treat backslash as an ordinary character, instead of an "
"escape character."
msgstr ""
"Если этот флаг установлен, то обратная косая черта воспринимается как "
"простой символ, а не специальный."

#. type: TP
#: man-pages/man3/fnmatch.3:55
#, no-wrap
msgid "B<FNM_PATHNAME>"
msgstr "B<FNM_PATHNAME>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:63
msgid ""
"If this flag is set, match a slash in I<string> only with a slash in "
"I<pattern> and not by an asterisk (*) or a question mark (?) metacharacter, "
"nor by a bracket expression ([]) containing a slash."
msgstr ""
"Если этот флаг установлен, то косая черта в строке I<string> будет совпадать "
"только с косой чертой в шаблоне I<pattern>, но не с метасимволом звёздочка "
"(*) или вопросительным знаком (?) и не последовательностью в квадратных "
"скобках ([]), содержащую косую черту."

#. type: TP
#: man-pages/man3/fnmatch.3:63
#, no-wrap
msgid "B<FNM_PERIOD>"
msgstr "B<FNM_PERIOD>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:74
msgid ""
"If this flag is set, a leading period in I<string> has to be matched exactly "
"by a period in I<pattern>.  A period is considered to be leading if it is "
"the first character in I<string>, or if both B<FNM_PATHNAME> is set and the "
"period immediately follows a slash."
msgstr ""
"Если этот флаг установлен, то начальная точка в строке I<string> должна "
"сравниваться именно с точкой в шаблоне I<pattern>. Точка считается "
"начальной, если она является первым символом в строке I<string>, или если "
"установлен флаг B<FNM_PATHNAME> и точка следует сразу за косой чертой."

#. type: TP
#: man-pages/man3/fnmatch.3:74
#, no-wrap
msgid "B<FNM_FILE_NAME>"
msgstr "B<FNM_FILE_NAME>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:78
msgid "This is a GNU synonym for B<FNM_PATHNAME>."
msgstr "Синоним B<FNM_PATHNAME> в GNU."

#. type: TP
#: man-pages/man3/fnmatch.3:78
#, no-wrap
msgid "B<FNM_LEADING_DIR>"
msgstr "B<FNM_LEADING_DIR>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:86
msgid ""
"If this flag (a GNU extension) is set, the pattern is considered to be "
"matched if it matches an initial segment of I<string> which is followed by a "
"slash.  This flag is mainly for the internal use of glibc and is implemented "
"only in certain cases."
msgstr ""
"Если этот флаг (расширение GNU) установлен, то строка считается совпавшей с "
"шаблоном, если совпадает начальный сегмент строки I<string>, который следует "
"сразу за косой чертой. Этот флаг для внутреннего использования glibc и не "
"всегда реализуется."

#. type: TP
#: man-pages/man3/fnmatch.3:86
#, no-wrap
msgid "B<FNM_CASEFOLD>"
msgstr "B<FNM_CASEFOLD>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:90
msgid ""
"If this flag (a GNU extension) is set, the pattern is matched case-"
"insensitively."
msgstr ""
"Если этот флаг (расширение GNU) установлен, то выражения сравниваются без "
"учёта регистра символов."

#. type: TP
#: man-pages/man3/fnmatch.3:90
#, no-wrap
msgid "B<FNM_EXTMATCH>"
msgstr "B<FNM_EXTMATCH>"

#. type: Plain text
#: man-pages/man3/fnmatch.3:96
msgid ""
"If this flag (a GNU extension) is set, extended patterns are supported, as "
"introduced by \\&'ksh' and now supported by other shells.  The extended "
"format is as follows, with I<pattern-list> being a \\&'|' separated list of "
"patterns."
msgstr ""
"Если этот флаг (расширение GNU) установлен, то поддерживаются расширенные "
"шаблоны из \\&'ksh' и теперь поддерживаемые другими оболочками. В "
"расширенном формате I<pattern-list> предоставляет собой список шаблонов, "
"разделённых \\&'|', входит следующее:"

#. type: TP
#: man-pages/man3/fnmatch.3:96
#, no-wrap
msgid "\\&'?(I<pattern-list>)'"
msgstr "\\&'?(I<pattern-list>)'"

#. type: Plain text
#: man-pages/man3/fnmatch.3:100
msgid ""
"The pattern matches if zero or one occurrences of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""
"Шаблон совпадает, если ноль или одно вхождение любого шаблона в I<pattern-"
"list> совпадает с входной строкой I<string>."

#. type: TP
#: man-pages/man3/fnmatch.3:100
#, no-wrap
msgid "\\&'*(I<pattern-list>)'"
msgstr "\\&'*(I<pattern-list>)'"

#. type: Plain text
#: man-pages/man3/fnmatch.3:104
msgid ""
"The pattern matches if zero or more occurrences of any of the patterns in "
"the I<pattern-list> match the input I<string>."
msgstr ""
"Шаблон совпадает, если ноль или более вхождений любых шаблонов в I<pattern-"
"list> совпадает с входной строкой I<string>."

#. type: TP
#: man-pages/man3/fnmatch.3:104
#, no-wrap
msgid "\\&'+(I<pattern-list>)'"
msgstr "\\&'+(I<pattern-list>)'"

#. type: Plain text
#: man-pages/man3/fnmatch.3:108
msgid ""
"The pattern matches if one or more occurrences of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""
"Шаблон совпадает, если одно или более вхождений любых шаблонов в I<pattern-"
"list> совпадает с входной строкой I<string>."

#. type: TP
#: man-pages/man3/fnmatch.3:108
#, no-wrap
msgid "\\&'@(I<pattern-list>)'"
msgstr "\\&'@(I<pattern-list>)'"

#. type: Plain text
#: man-pages/man3/fnmatch.3:112
msgid ""
"The pattern matches if exactly one occurrence of any of the patterns in the "
"I<pattern-list> match the input I<string>."
msgstr ""
"Шаблон совпадает, если только одно вхождение любого шаблона в I<pattern-"
"list> совпадает с входной строкой I<string>."

#. type: TP
#: man-pages/man3/fnmatch.3:112
#, no-wrap
msgid "\\&'!(I<pattern-list>)'"
msgstr "\\&'!(I<pattern-list>)'"

#. type: Plain text
#: man-pages/man3/fnmatch.3:116
msgid ""
"The pattern matches if the input I<string> cannot be matched with any of the "
"patterns in the I<pattern-list>."
msgstr ""
"Шаблон совпадает, если входная строка I<string> не совпадает с каким-либо "
"шаблоном в I<pattern-list>."

#. type: Plain text
#: man-pages/man3/fnmatch.3:123
msgid ""
"Zero if I<string> matches I<pattern>, B<FNM_NOMATCH> if there is no match or "
"another nonzero value if there is an error."
msgstr ""
"Возвращает ноль, если строка I<string> совпадает с шаблоном I<pattern>, "
"возвращает B<FNM_NOMATCH>, если строка и шаблон не совпадают, или другое "
"ненулевое значение, если произошла ошибка."

#. type: tbl table
#: man-pages/man3/fnmatch.3:133
#, no-wrap
msgid "B<fnmatch>()"
msgstr "B<fnmatch>()"

#. type: tbl table
#: man-pages/man3/fnmatch.3:133
#, no-wrap
msgid "MT-Safe env locale"
msgstr "MT-Safe env locale"

#. type: Plain text
#: man-pages/man3/fnmatch.3:140
msgid ""
"POSIX.1-2001, POSIX.1-2008, POSIX.2.  The B<FNM_FILE_NAME>, "
"B<FNM_LEADING_DIR>, and B<FNM_CASEFOLD> flags are GNU extensions."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, POSIX.2. Флаги B<FNM_FILE_NAME>, "
"B<FNM_LEADING_DIR> и B<FNM_CASEFOLD> являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/fnmatch.3:145
msgid "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"
msgstr "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"

#. type: TH
#: man-pages/man3/fmtmsg.3:13
#, no-wrap
msgid "FMTMSG"
msgstr "FMTMSG"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:16
msgid "fmtmsg - print formatted error messages"
msgstr "fmtmsg - выводит отформатированные сообщения об ошибках"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:19
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:23
#, no-wrap
msgid ""
"B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
"B<           int >I<severity>B<, const char *>I<text>B<,>\n"
"B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr ""
"B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
"B<           int >I<severity>B<, const char *>I<text>B<,>\n"
"B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:34
msgid ""
"This function displays a message described by its arguments on the "
"device(s)  specified in the I<classification> argument.  For messages "
"written to I<stderr>, the format depends on the B<MSGVERB> environment "
"variable."
msgstr ""
"Эта функция выводит сообщение, описываемое аргументами, на устройство(а), "
"заданное в аргументе I<classification>. Для сообщений, записываемых в "
"I<stderr>, формат зависит от переменной окружения B<MSGVERB>."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:41
msgid ""
"The I<label> argument identifies the source of the message.  The string must "
"consist of two colon separated parts where the first part has not more than "
"10 and the second part not more than 14 characters."
msgstr ""
"В аргументе I<label> задаётся источник сообщения. Строка должна состоять из "
"двух частей, разделённых двоеточиями; первая часть должна быть не более 10 "
"символов, а вторая часть — не более 14."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:45
msgid "The I<text> argument describes the condition of the error."
msgstr "В аргументе I<text> описывается условие ошибки."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:50
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""
"В аргументе I<action> описываются возможные шаги по исправлению ошибки. Если "
"они выводятся, то начинаются с «TO FIX: »."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:58
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique "
"identification number."
msgstr ""
"В аргументе I<tag> указывается ссылка на онлайн-документацию, в которой "
"можно найти дополнительную информацию. Он должен содержать значение I<label> "
"и уникальный идентификационный номер."

#. type: SS
#: man-pages/man3/fmtmsg.3:58
#, no-wrap
msgid "Dummy arguments"
msgstr "Фиктивные аргументы"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:77
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed.  "
"The dummy severity value B<NO_SEV> (0) says that no severity is supplied.  "
"The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char\\ *)\\ 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""
"Каждый аргумент может иметь фиктивное значение. Для фиктивного значения "
"классификации (classification) B<MM_NULLMC> (0L) ничего не выводится, то "
"есть ничего не печатается. Фиктивное значение важности (severity) B<NO_SEV> "
"(0) указывается, если важность не определена. Значения B<MM_NULLLBL>, "
"B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> являются синонимами I<((char\\ "
"*)\\ 0)> — пустой строки, а B<MM_NULLSEV> — синоним B<NO_SEV>."

#. type: SS
#: man-pages/man3/fmtmsg.3:77
#, no-wrap
msgid "The classification argument"
msgstr "Аргумент классификации"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:81
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr ""
"Аргумент I<classification> — это сочетание значений, описывающих 4 типа "
"информации."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:83
msgid "The first value defines the output channel."
msgstr "Первое значение определяет канал вывода."

#. type: TP
#: man-pages/man3/fmtmsg.3:83
#, no-wrap
msgid "B<MM_PRINT>"
msgstr "B<MM_PRINT>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:87
msgid "Output to I<stderr>."
msgstr "Вывод в I<stderr>."

#. type: TP
#: man-pages/man3/fmtmsg.3:87
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr "B<MM_CONSOLE>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:90
msgid "Output to the system console."
msgstr "Вывод в системную консоль."

#. type: TP
#: man-pages/man3/fmtmsg.3:90
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr "B<MM_PRINT | MM_CONSOLE>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:93
msgid "Output to both."
msgstr "Вывод в оба места."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:95
msgid "The second value is the source of the error:"
msgstr "Вторым значением описывается источник ошибки."

#. type: TP
#: man-pages/man3/fmtmsg.3:95
#, no-wrap
msgid "B<MM_HARD>"
msgstr "B<MM_HARD>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:98
msgid "A hardware error occurred."
msgstr "Произошла аппаратная ошибка."

#. type: TP
#: man-pages/man3/fmtmsg.3:98
#, no-wrap
msgid "B<MM_FIRM>"
msgstr "B<MM_FIRM>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:101
msgid "A firmware error occurred."
msgstr "Произошла ошибка в микропрограмме."

#. type: TP
#: man-pages/man3/fmtmsg.3:101
#, no-wrap
msgid "B<MM_SOFT>"
msgstr "B<MM_SOFT>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:104
msgid "A software error occurred."
msgstr "Произошла ошибка в программном обеспечении."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:106
msgid "The third value encodes the detector of the problem:"
msgstr "В третьем значении кодируется выявитель проблемы."

#. type: TP
#: man-pages/man3/fmtmsg.3:106
#, no-wrap
msgid "B<MM_APPL>"
msgstr "B<MM_APPL>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:109
msgid "It is detected by an application."
msgstr "Обнаружено приложением."

#. type: TP
#: man-pages/man3/fmtmsg.3:109
#, no-wrap
msgid "B<MM_UTIL>"
msgstr "B<MM_UTIL>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:112
msgid "It is detected by a utility."
msgstr "Обнаружено утилитой."

#. type: TP
#: man-pages/man3/fmtmsg.3:112
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr "B<MM_OPSYS>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:115
msgid "It is detected by the operating system."
msgstr "Обнаружено операционной системой."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:117
msgid "The fourth value shows the severity of the incident:"
msgstr "В четвёртом значении показывается важность инцидента:"

#. type: TP
#: man-pages/man3/fmtmsg.3:117
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr "B<MM_RECOVER>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:120
msgid "It is a recoverable error."
msgstr "Это исправимая ошибка."

#. type: TP
#: man-pages/man3/fmtmsg.3:120
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr "B<MM_NRECOV>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:123
msgid "It is a nonrecoverable error."
msgstr "Это неисправимая ошибка."

#. type: SS
#: man-pages/man3/fmtmsg.3:123
#, no-wrap
msgid "The severity argument"
msgstr "Аргумент важности"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:127
msgid "The I<severity> argument can take one of the following values:"
msgstr "В аргументе I<severity> можно указать одно из следующих значений:"

#. type: TP
#: man-pages/man3/fmtmsg.3:127
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr "B<MM_NOSEV>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:130
msgid "No severity is printed."
msgstr "Важность не печатается."

#. type: TP
#: man-pages/man3/fmtmsg.3:130
#, no-wrap
msgid "B<MM_HALT>"
msgstr "B<MM_HALT>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:133
msgid "This value is printed as HALT."
msgstr "Это значение печатается как ОСТАНОВ."

#. type: TP
#: man-pages/man3/fmtmsg.3:133
#, no-wrap
msgid "B<MM_ERROR>"
msgstr "B<MM_ERROR>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:136
msgid "This value is printed as ERROR."
msgstr "Это значение печатается как ОШИБКА."

#. type: TP
#: man-pages/man3/fmtmsg.3:136
#, no-wrap
msgid "B<MM_WARNING>"
msgstr "B<MM_WARNING>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:139
msgid "This value is printed as WARNING."
msgstr "Это значение печатается как ПРЕДУПРЕЖДЕНИЕ."

#. type: TP
#: man-pages/man3/fmtmsg.3:139
#, no-wrap
msgid "B<MM_INFO>"
msgstr "B<MM_INFO>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:142
msgid "This value is printed as INFO."
msgstr "Это значение печатается как ИНФОРМАЦИОННОЕ."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:149
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""
"Числовые значения от 0 до 4. Используя функцию B<addseverity>(3) или "
"переменную окружения B<SEV_LEVEL> вы можете добавить дополнительные уровни и "
"строки для печати."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:151
msgid "The function can return 4 values:"
msgstr "Функция может возвращать 4 значения:"

#. type: TP
#: man-pages/man3/fmtmsg.3:151
#, no-wrap
msgid "B<MM_OK>"
msgstr "B<MM_OK>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:154
msgid "Everything went smooth."
msgstr "Всё хорошо."

#. type: TP
#: man-pages/man3/fmtmsg.3:154
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr "B<MM_NOTOK>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:157
msgid "Complete failure."
msgstr "Всё плохо."

#. type: TP
#: man-pages/man3/fmtmsg.3:157
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr "B<MM_NOMSG>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:161
msgid "Error writing to I<stderr>."
msgstr "Ошибка записи в I<stderr>."

#. type: TP
#: man-pages/man3/fmtmsg.3:161
#, no-wrap
msgid "B<MM_NOCON>"
msgstr "B<MM_NOCON>"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:164
msgid "Error writing to the console."
msgstr "Ошибка записи в консоль."

#. type: SH
#: man-pages/man3/fmtmsg.3:164
#, no-wrap
msgid "ENVIRONMENT"
msgstr "ОКРУЖЕНИЕ"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:175
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to "
"the console.)  When this variable is defined, is non-NULL, and is a colon-"
"separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""
"Переменная окружения B<MSGVERB> (message verbosity — детальность сообщения) "
"может использоваться для отключения некоторых частей вывода в I<stderr> (она "
"не влияет на вывод на консоль). Если эта переменная определена, не равна "
"NULL и содержит список допустимых ключевых слов через двоеточие, то "
"печатаются только части сообщения, которые соответствуют этим ключевым "
"словам. Допустимые ключевые слова: «label», «severity», «text», «action» и "
"«tag»."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:187
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""
"Переменная окружения B<SEV_LEVEL> может использоваться для ввода новых "
"уровней важности. По умолчанию, доступно только пять уровней важности, "
"описанных выше. Для любого другого числового значения B<fmtmsg>() ничего не "
"печатает. Если пользователь задал B<SEV_LEVEL> в формате"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:190
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr "SEV_LEVEL=[описание[:описание[:...]]]"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:195
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr ""
"в окружении процесса перед первым вызовом B<fmtmsg>() и каждое описание "
"имеет вид"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:198
msgid "severity-keyword,level,printstring"
msgstr "ключевое-слово-важности,уровень,печатаемая-строка"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:205
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0\\(en4), and use the indicated printstring "
"when such a level occurs."
msgstr ""
"то B<fmtmsg>() также будет обрабатывать заданные значения уровней (в "
"дополнении к стандартным уровням 0\\(en4), и использовать указанную строку "
"печати, когда встречается такой уровень."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:219
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the "
"string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""
"Часть «ключевое-слово-важности» не используется B<fmtmsg>(), но указывается. "
"Часть «уровень» — это строка, представляющая число. Числовое значение должно "
"быть числом более 4. Это значение должно использоваться в аргументе важности "
"B<fmtmsg>() для выбора этого класса. Невозможно заменить любой из "
"предопределённых классов. «Печатаемая-строка» — строка, которая печатается в "
"случае, когда сообщение этого класса обрабатывается B<fmtmsg>()."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:222
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr "Функция B<fmtmsg>() появилась в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/fmtmsg.3:232
#, no-wrap
msgid "B<fmtmsg>()"
msgstr "B<fmtmsg>()"

#. type: tbl table
#: man-pages/man3/fmtmsg.3:234
#, no-wrap
msgid "glibc E<gt>= 2.16: MT-Safe\n"
msgstr "glibc E<gt>= 2.16: MT-Safe\n"

#. type: tbl table
#: man-pages/man3/fmtmsg.3:236
#, no-wrap
msgid "glibc E<lt> 2.16: MT-Unsafe"
msgstr "glibc E<lt> 2.16: MT-Unsafe"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:243
msgid ""
"Before glibc 2.16, the B<fmtmsg>()  function uses a static variable that is "
"not protected, so it is not thread-safe."
msgstr ""
"До glibc 2.16 функция B<fmtmsg>() использовала статическую незащищённую "
"переменную, поэтому функцию нельзя использовать в нескольких нитях "
"одновременно."

#.  Modified in commit 7724defcf8873116fe4efab256596861eef21a94
#. type: Plain text
#: man-pages/man3/fmtmsg.3:249
msgid ""
"Since glibc 2.16, the B<fmtmsg>()  function uses a lock to protect the "
"static variable, so it is thread-safe."
msgstr ""
"Начиная с glibc 2.16 функция B<fmtmsg>() использует блокировку для защиты "
"статической переменной, поэтому функцию можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:259
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V."
msgstr ""
"Функции B<fmtmsg>() и B<addseverity>(3), и переменные окружения B<MSGVERB> и "
"B<SEV_LEVEL> впервые появились в System V."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:265
msgid ""
"The function B<fmtmsg>()  and the environment variable B<MSGVERB> are "
"described in POSIX.1-2001 and POSIX.1-2008."
msgstr ""
"Функция B<fmtmsg>() и переменная окружения B<MSGVERB> описана в POSIX.1-2001 "
"и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:269
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""
"В справочных страницах System V и UnixWare указано, что эти функции были "
"заменены на «pfmt() и addsev()» или «pfmt(), vpfmt(), lfmt() и vlfmt()», и "
"будут впоследствии удалены."

#. type: Plain text
#: man-pages/man3/fmtmsg.3:274
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:280
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:301
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"неизвестный параметр mount\", \"Смотрите mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Нечего печатать\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Нечего печатать в stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"Нет вывода на консоль\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Неизвестная ошибка fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:304
msgid "The output should be:"
msgstr "Вывод должен быть таким:"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:309
#, no-wrap
msgid ""
"util-linux:mount: ERROR: unknown mount option\n"
"TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""
"util-linux:mount: ERROR: unknown mount option\n"
"TO FIX: Смотрите mount(8).  util-linux:mount:017\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:313
msgid "and after"
msgstr "а после"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:317
#, no-wrap
msgid "MSGVERB=text:action; export MSGVERB\n"
msgstr "MSGVERB=text:action; export MSGVERB\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:321
msgid "the output becomes:"
msgstr "вывод станет:"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:326
#, no-wrap
msgid ""
"unknown mount option\n"
"TO FIX: See mount(8).\n"
msgstr ""
"неизвестный параметр mount\n"
"    TO FIX: Смотрите mount(8).\n"

#. type: Plain text
#: man-pages/man3/fmtmsg.3:331
msgid "B<addseverity>(3), B<perror>(3)"
msgstr "B<addseverity>(3), B<perror>(3)"

#. type: TH
#: man-pages/man3/fmemopen.3:7
#, no-wrap
msgid "FMEMOPEN"
msgstr "FMEMOPEN"

#. type: Plain text
#: man-pages/man3/fmemopen.3:10
msgid "fmemopen - open memory as stream"
msgstr "fmemopen - открывает память как поток"

#. type: Plain text
#: man-pages/man3/fmemopen.3:13
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:15
#, no-wrap
msgid "B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:23
msgid "B<fmemopen>():"
msgstr "B<fmemopen>():"

#. type: TP
#: man-pages/man3/fmemopen.3:26
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:29
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man3/fmemopen.3:29
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:32
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/fmemopen.3:43
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified "
"by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>."
msgstr ""
"Функция B<fmemopen>() открывает поток, тип доступа указывается в I<mode>. "
"Поток позволяет выполнять операции ввода-вывода со строкой или буфером "
"памяти, указанным в I<buf>."

#. type: Plain text
#: man-pages/man3/fmemopen.3:48
msgid ""
"The I<mode> argument specifies the semantics of I/O on the stream, and is "
"one of the following:"
msgstr ""
"В аргументе I<mode> задаётся семантика ввода-вывода потока и может "
"указываться одно из следующих значений:"

#. type: TP
#: man-pages/man3/fmemopen.3:48
#, no-wrap
msgid "I<r>"
msgstr "I<r>"

#. type: Plain text
#: man-pages/man3/fmemopen.3:51
msgid "The stream is opened for reading."
msgstr "Поток открывается для чтения."

#. type: TP
#: man-pages/man3/fmemopen.3:51
#, no-wrap
msgid "I<w>"
msgstr "I<w>"

#. type: Plain text
#: man-pages/man3/fmemopen.3:54
msgid "The stream is opened for writing."
msgstr "Поток открывается для записи."

#. type: TP
#: man-pages/man3/fmemopen.3:54
#, no-wrap
msgid "I<a>"
msgstr "I<a>"

#. type: Plain text
#: man-pages/man3/fmemopen.3:58
msgid ""
"Append; open the stream for writing, with the initial buffer position set to "
"the first null byte."
msgstr ""
"Добавление; поток открывается для записи, начальное положение в буфере "
"указывает на первый байт null."

#. type: TP
#: man-pages/man3/fmemopen.3:58
#, no-wrap
msgid "I<r+>"
msgstr "I<r+>"

#. type: Plain text
#: man-pages/man3/fmemopen.3:61
msgid "Open the stream for reading and writing."
msgstr "Поток открывается для чтения и записи."

#. type: TP
#: man-pages/man3/fmemopen.3:61
#, no-wrap
msgid "I<w+>"
msgstr "I<w+>"

#. type: Plain text
#: man-pages/man3/fmemopen.3:66
msgid ""
"Open the stream for reading and writing.  The buffer contents are truncated "
"(i.e., \\(aq\\e0\\(aq is placed in the first byte of the buffer)."
msgstr ""
"Поток открывается для чтения и записи. Содержимое буфера обрезается (то "
"есть, в первый байт буфера помещается \\(aq\\e0\\(aq)."

#. type: TP
#: man-pages/man3/fmemopen.3:66
#, no-wrap
msgid "I<a+>"
msgstr "I<a+>"

#. type: Plain text
#: man-pages/man3/fmemopen.3:70
msgid ""
"Append; open the stream for reading and writing, with the initial buffer "
"position set to the first null byte."
msgstr ""
"Добавление; поток открывается для чтения и записи, начальное положение в "
"буфере указывает на первый байт null."

#. type: Plain text
#: man-pages/man3/fmemopen.3:83
msgid ""
"The stream maintains the notion of a current position, the location where "
"the next I/O operation will be performed.  The current position is "
"implicitly updated by I/O operations.  It can be explicitly updated using "
"B<fseek>(3), and determined using B<ftell>(3).  In all modes other than "
"append, the initial position is set to the start of the buffer.  In append "
"mode, if no null byte is found within the buffer, then the initial position "
"is I<size+1>."
msgstr ""
"Для потока поддерживается понятие текущего положения — место, откуда будет "
"выполнена следующая операция ввода-вывода. Текущее положение неявно "
"обновляется операциями ввода-вывода. Оно может быть изменено явным образом с "
"помощью B<fseek>(3) и получено с помощью B<ftell>(3). Во всех режимах кроме "
"добавления, начальное положение указывает на начало буфера. В режиме "
"добавления, если в буфере нет байта null, то начальное положение равно I<size"
"+1>."

#. type: Plain text
#: man-pages/man3/fmemopen.3:98
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  allocates a buffer of "
"I<size> bytes.  This is useful for an application that wants to write data "
"to a temporary buffer and then read it back again.  The initial position is "
"set to the start of the buffer.  The buffer is automatically freed when the "
"stream is closed.  Note that the caller has no way to obtain a pointer to "
"the temporary buffer allocated by this call (but see B<open_memstream>(3))."
msgstr ""
"Если значение I<buf> равно NULL, то B<fmemopen>() выделяет буфер длиной "
"I<size> байт. Это полезно для приложений, которым нужно записать данные во "
"временный буфер и прочитать из него. Начальное положение указывает на начало "
"буфера. Буфер автоматически освобождается при закрытии потока. Заметим, что "
"вызывающий никогда не получит указатель на временный буфер, выделенный этим "
"вызовом (но смотрите B<open_memstream>(3))."

#. type: Plain text
#: man-pages/man3/fmemopen.3:104
msgid ""
"If I<buf> is not NULL, then it should point to a buffer of at least I<len> "
"bytes allocated by the caller."
msgstr ""
"Если I<buf> не равно NULL, то значение должно указывать на  буфер длиной не "
"менее I<len> байт, выделенный вызывающим."

#. type: Plain text
#: man-pages/man3/fmemopen.3:116
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or "
"closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in "
"the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""
"Когда поток, открытый на запись, сбрасывается (flushed) (B<fflush>(3)) или "
"закрывается (B<fclose>(3)), то в конец буфера записывается байт null, если "
"есть место. Вызывающий должен быть уверен, что в буфере есть место для "
"дополнительного байта (и в I<size> учитывается этот байт), чтобы это "
"произошло."

#. type: Plain text
#: man-pages/man3/fmemopen.3:124
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do "
"not cause read operations to return an end-of-file indication.  A read from "
"the buffer will indicate end-of-file only when the current buffer position "
"advances I<size> bytes past the start of the buffer."
msgstr ""
"В потоке, открытом на чтение, при обнаружении байтов null («\\e0») в буфере "
"операции чтения не возвращают конец файла. Чтение из буфера будет возвращать "
"конец файла, только когда текущее положение в буфере достигнет I<size> байт "
"от начала буфера."

#. type: Plain text
#: man-pages/man3/fmemopen.3:128
msgid ""
"Write operations take place either at the current position (for modes other "
"than append), or at the current size of the stream (for append modes)."
msgstr ""
"Операции записи выполняются, или по текущему положению (для всех режимов, "
"кроме добавления), или по текущему размеру потока (в режимах добавления)."

#. type: Plain text
#: man-pages/man3/fmemopen.3:138
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error.  "
"By default, such errors will be visible (by the absence of data) only when "
"the I<stdio> buffer is flushed.  Disabling buffering with the following call "
"may be useful to detect errors at the time of an output operation:"
msgstr ""
"Попытка записать более I<size> байт в буфер приводит к ошибке. По умолчанию, "
"такие ошибки будут видимы (по отсутствию данных) только в момент сброса "
"буфера I<stdio>. Следующий вызов отключает буферизацию, что может быть "
"полезно для обнаружения ошибок в момент операции вывода:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:140
#, no-wrap
msgid "    setbuf(stream, NULL);\n"
msgstr "    setbuf(stream, NULL);\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:149
msgid ""
"Upon successful completion, B<fmemopen>()  returns a I<FILE> pointer.  "
"Otherwise, NULL is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<fmemopen>() возвращается указатель I<FILE>. В "
"противном случае возвращается NULL и I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/fmemopen.3:152
msgid "B<fmemopen>()  was already available in glibc 1.0.x."
msgstr "Функция B<fmemopen>() была доступна уже в glibc 1.0.x."

#. type: tbl table
#: man-pages/man3/fmemopen.3:162
#, no-wrap
msgid "B<fmemopen>(),"
msgstr "B<fmemopen>(),"

#. type: Plain text
#: man-pages/man3/fmemopen.3:169
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems."
msgstr ""
"POSIX.1-2008. Эта функция не определена в POSIX.1-2001 и широко не "
"распространена среди других систем."

#.  http://austingroupbugs.net/view.php?id=396
#. type: Plain text
#: man-pages/man3/fmemopen.3:177
msgid ""
"POSIX.1-2008 specifies that \\(aqb\\(aq in I<mode> shall be ignored.  "
"However, Technical Corrigendum 1 adjusts the standard to allow "
"implementation-specific treatment for this case, thus permitting the glibc "
"treatment of \\(aqb\\(aq."
msgstr ""
"В POSIX.1-2008 указано, что символ «b» в I<mode> должен игнорироваться. "
"Однако в Technical Corrigendum 1 изменили стандарт, позволив реализации "
"решать что делать; это позволяет glibc учитывать «b»."

#. type: Plain text
#: man-pages/man3/fmemopen.3:183
msgid ""
"There is no file descriptor associated with the file stream returned by this "
"function (i.e., B<fileno>(3)  will return an error if called on the returned "
"stream)."
msgstr ""
"У файлового потока, возвращаемого этой  функцией, отсутствует файловый "
"дескриптор (т. е., если файловый поток передать в B<fileno>(3), то "
"произойдёт ошибка)."

#. type: Plain text
#: man-pages/man3/fmemopen.3:189
msgid ""
"With version 2.22, binary mode (see below) was removed, many longstanding "
"bugs in the implementation of B<fmemopen>()  were fixed, and a new versioned "
"symbol was created for this interface."
msgstr ""
"Начиная с версии 2.22 двоичный режим (смотрите ниже) был удалён, было "
"исправлено много дефектов в реализации B<fmemopen>() и для этого интерфейса "
"был создан новый символ с версией."

#. type: SS
#: man-pages/man3/fmemopen.3:189
#, no-wrap
msgid "Binary mode"
msgstr "Двоичный режим"

#. type: Plain text
#: man-pages/man3/fmemopen.3:202
msgid ""
"From version 2.9 to 2.21, the glibc implementation of B<fmemopen>()  "
"supported a \"binary\" mode, enabled by specifying the letter \\(aqb\\(aq as "
"the second character in I<mode>.  In this mode, writes don't implicitly add "
"a terminating null byte, and B<fseek>(3)  B<SEEK_END> is relative to the end "
"of the buffer (i.e., the value specified by the I<size> argument), rather "
"than the current string length."
msgstr ""
"В версиях с 2.9 по 2.21  реализация B<fmemopen>() в glibc поддерживает "
"«двоичный» режим, включаемый в I<mode> указанием вторым символа \\(aqb\\(aq. "
"В этом режиме при записи не выполняется неявное добавление конечного байта "
"null и B<fseek>(3)  B<SEEK_END> считается относительно конца буфера (т. е., "
"значения, указанного в аргументе I<size>), а не длины текущей строки."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12836
#. type: Plain text
#: man-pages/man3/fmemopen.3:214
msgid ""
"An API bug afflicted the implementation of binary mode: to specify binary "
"mode, the \\(aqb\\(aq must be the I<second> character in I<mode>.  Thus, for "
"example, \"wb+\" has the desired effect, but \"w+b\" does not.  This is "
"inconsistent with the treatment of I<mode> by B<fopen>(3)."
msgstr ""
"Дефект программного интерфейса перешёл и в реализацию двоичного режима: для "
"задания двоичного режима \\(aqb\\(aq должен указываться I<вторым> символом в "
"I<mode>. То есть, например, «wb+» сработает, а «w+b» — нет. Это не совпадает "
"с трактовкой I<mode> в B<fopen>(3)."

#. type: Plain text
#: man-pages/man3/fmemopen.3:218
msgid ""
"Binary mode was removed in glibc 2.22; a \\(aqb\\(aq specified in I<mode> "
"has no effect."
msgstr ""
"Двоичный режим удалён в glibc 2.22; указание \\(aqb\\(aq в I<mode> "
"игнорируется."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=11216
#. type: Plain text
#: man-pages/man3/fmemopen.3:229
msgid ""
"In versions of glibc before 2.22, if I<size> is specified as zero, "
"B<fmemopen>()  fails with the error B<EINVAL>.  It would be more consistent "
"if this case successfully created a stream that then returned end-of-file on "
"the first attempt at reading; since version 2.22, the glibc implementation "
"provides that behavior."
msgstr ""
"В glibc до версии 2.22, если I<size> равно нулю, то B<fmemopen>() "
"завершается с ошибкой B<EINVAL>. Было бы логичней, если бы в этом случае "
"успешно создавался поток, который затем бы возвращал конец файла при первой "
"попытке его чтения; начиная с версии 2.22 реализация glibc поступает именно "
"так."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13152
#. type: Plain text
#: man-pages/man3/fmemopen.3:239
msgid ""
"In versions of glibc before 2.22, specifying append mode (\"a\" or \"a+\") "
"for B<fmemopen>()  sets the initial buffer position to the first null byte, "
"but (if the current position is reset to a location other than the end of "
"the stream)  does not force subsequent writes to append at the end of the "
"stream.  This bug is fixed in glibc 2.22."
msgstr ""
"В glibc до версии 2.22 указание в B<fmemopen>() режима добавления («a» или «a"
"+») устанавливает начальное положение в буфере на первый байт null, но (если "
"положение сбрасывается в расположение, отличное от конца потока) не "
"заставляет последующие операции записи выполнять добавление в конец потока. "
"Этот дефект исправлен в glibc 2.22."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=13151
#. type: Plain text
#: man-pages/man3/fmemopen.3:256
msgid ""
"In versions of glibc before 2.22, if the I<mode> argument to B<fmemopen>()  "
"specifies append (\"a\" or \"a+\"), and the I<size> argument does not cover "
"a null byte in I<buf>, then, according to POSIX.1-2008, the initial buffer "
"position should be set to the next byte after the end of the buffer.  "
"However, in this case the glibc B<fmemopen>()  sets the buffer position to "
"-1.  This bug is fixed in glibc 2.22."
msgstr ""
"В glibc до версии 2.22, если в аргументе I<mode> в B<fmemopen>() включено "
"добавление («a» или «a+») и аргумент I<size> не учитывает байт null в "
"I<buf>, то согласно POSIX.1-2008 начальное положение буфера должно указывать "
"на следующий байт за концом буфера. Однако, в этом случае glibc "
"B<fmemopen>() присваивает положению буфера значение -1. Этот дефект "
"исправлен в glibc 2.22."

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14292
#. type: Plain text
#: man-pages/man3/fmemopen.3:273
msgid ""
"In versions of glibc before 2.22, when a call to B<fseek>(3)  with a "
"I<whence> value of B<SEEK_END> was performed on a stream created by "
"B<fmemopen>(), the I<offset> was I<subtracted> from the end-of-stream "
"position, instead of being added.  This bug is fixed in glibc 2.22."
msgstr ""
"В glibc до версии 2.22 при вызове B<fseek>(3) со значением I<whence>, равным "
"B<SEEK_END>, и для потока, созданного B<fmemopen>(), значение I<offset> "
"I<вычитается> из положения конца потока, а не добавляется. Этот дефект "
"исправлен в glibc 2.22."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6544
#. type: Plain text
#: man-pages/man3/fmemopen.3:281
msgid ""
"The glibc 2.9 addition of \"binary\" mode for B<fmemopen>()  silently "
"changed the ABI: previously, B<fmemopen>()  ignored \\(aqb\\(aq in I<mode>."
msgstr ""
"При дополнении B<fmemopen>() в glibc 2.9 «двоичным» режимом было потихоньку "
"изменено ABI: раньше B<fmemopen>() игнорировала «b» в I<mode>."

#. type: Plain text
#: man-pages/man3/fmemopen.3:291
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>(3)  to open a dynamically sized output buffer.  The "
"program scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr ""
"Программа, показанная ниже, использует B<fmemopen>() для открытия входного "
"буфера и B<open_memstream>(3) для открытия выходного буфера с динамически "
"изменяющимся размером. Программа сканирует входную строку (первый аргумент "
"командной строки программы), читая целые числа, и записывает квадраты этих "
"чисел в выходной буфер. Пример результата работы программы:"

#. type: Plain text
#: man-pages/man3/fmemopen.3:296
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"размер=11; ptr=1 529 1849\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:305
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:308
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:321
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s \\(aqE<lt>numE<gt>...\\(aq\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s \\(aqE<lt>numE<gt>...\\(aq\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:325
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:329
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:334
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:339
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
msgstr ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:342
#, no-wrap
msgid ""
"    fclose(in);\n"
"    fclose(out);\n"
msgstr ""
"    fclose(in);\n"
"    fclose(out);\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:344
#, no-wrap
msgid "    printf(\"size=%zu; ptr=%s\\en\", size, ptr);\n"
msgstr "    printf(\"размер=%zu; ptr=%s\\en\", size, ptr);\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:348
#, no-wrap
msgid ""
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/fmemopen.3:352
msgid "B<fopen>(3), B<fopencookie>(3), B<open_memstream>(3)"
msgstr "B<fopen>(3), B<fopencookie>(3), B<open_memstream>(3)"

#. type: TH
#: man-pages/man3/fseek.3:42
#, no-wrap
msgid "FSEEK"
msgstr "FSEEK"

#. type: Plain text
#: man-pages/man3/fseek.3:45
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr "fgetpos, fseek, fsetpos, ftell, rewind - меняют положение в потоке"

#. type: Plain text
#: man-pages/man3/fseek.3:47
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/fseek.3:49
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:51
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr "B<long ftell(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:53
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr "B<void rewind(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:55
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:57
msgid "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"
msgstr "B<int fsetpos(FILE *>I<stream>B<, const fpos_t *>I<pos>B<);>"

#. type: Plain text
#: man-pages/man3/fseek.3:81
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or end-of-"
"file, respectively.  A successful call to the B<fseek>()  function clears "
"the end-of-file indicator for the stream and undoes any effects of the "
"B<ungetc>(3)  function on the same stream."
msgstr ""
"Функция B<fseek>() устанавливает положение файлового индикатора в потоке, на "
"который указывает аргумент I<stream>. Новое положение (в байтах) получается "
"прибавлением I<offset> байтов к положению, которое задаётся параметром "
"I<whence>. Если значение I<whence> равно B<SEEK_SET>, B<SEEK_CUR> или "
"B<SEEK_END>, то смещение указывается относительно начала файла, текущего "
"положения указателя или конца файла, соответственно. Успешный вызов функции "
"B<fseek>() очищает (clear) индикатор конца файла потока и отменяет влияние "
"функции B<ungetc>(3) на этот же поток."

#. type: Plain text
#: man-pages/man3/fseek.3:87
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""
"Функция B<ftell>() возвращает текущее значение файлового индикатора "
"положения для потока, на который указывает I<stream>."

#. type: Plain text
#: man-pages/man3/fseek.3:94
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""
"Функция B<rewind>() устанавливает файловый индикатор положения для потока, "
"на который указывает I<stream>, равным началу файла. Эта функция "
"эквивалентна вызову:"

#. type: Plain text
#: man-pages/man3/fseek.3:97
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr "(void) fseek(stream, 0L, SEEK_SET)"

#. type: Plain text
#: man-pages/man3/fseek.3:101
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""
"хотя в этом случае также сбрасывается индикатор ошибок потока (смотрите "
"B<clearerr>(3))."

#. type: Plain text
#: man-pages/man3/fseek.3:121
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with I<whence> set to "
"B<SEEK_SET>), setting and storing the current value of the file offset into "
"or from the object referenced by I<pos>.  On some non-UNIX systems, an "
"I<fpos_t> object may be a complex object and these routines may be the only "
"way to portably reposition a text stream."
msgstr ""
"Функции B<fgetpos>() и B<fsetpos>() эквивалентны B<ftell>() и B<fseek>() "
"(где значение I<whence> равно B<SEEK_SET>); они сохраняют или устанавливают "
"текущее значение файлового смещения в объектах, определяемых I<pos>. В "
"некоторых не-UNIX системах объект I<fpos_t> может быть сложным объектом, а "
"данные функции могут быть единственным переносимым способом изменения "
"положения в текстовом потоке."

#. type: Plain text
#: man-pages/man3/fseek.3:136
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"Функция B<rewind>() не возвращает значений. При успешном выполнении функции "
"B<fgetpos>(), B<fseek>(), B<fsetpos>() возвращают 0, а B<ftell>() возвращает "
"значение текущего смещения. В противном случае возвращается -1, а в I<errno> "
"записывается соответствующий код ошибки."

#. type: Plain text
#: man-pages/man3/fseek.3:149
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>.  Or: the resulting file offset would be negative."
msgstr ""
"Значение I<whence> в B<fseek>() не равно B<SEEK_SET>, B<SEEK_> или "
"B<SEEK_CUR>. Или результирующее смещение файла получается отрицательным."

#. type: Plain text
#: man-pages/man3/fseek.3:154
msgid ""
"The file descriptor underlying I<stream> is not seekable (e.g., it refers to "
"a pipe, FIFO, or socket)."
msgstr ""
"Связанный со I<stream> файловый дескриптор не допускает перемоток (верно для "
"каналов, FIFO или сокетов)."

#. type: Plain text
#: man-pages/man3/fseek.3:169
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""
"При ошибках функции B<fgetpos>(), B<fseek>(), B<fsetpos>() и B<ftell>() "
"устанавливают значение I<errno> равным значению, определённому в функциях "
"B<fflush>(3), B<fstat>(2), B<lseek>(2) и B<malloc>(3)."

#. type: tbl table
#: man-pages/man3/fseek.3:181
#, no-wrap
msgid ""
"B<fseek>(),\n"
"B<ftell>(),\n"
"B<rewind>(),\n"
msgstr ""
"B<fseek>(),\n"
"B<ftell>(),\n"
"B<rewind>(),\n"

#. type: tbl table
#: man-pages/man3/fseek.3:184
#, no-wrap
msgid ""
"B<fgetpos>(),\n"
"B<fsetpos>()"
msgstr ""
"B<fgetpos>(),\n"
"B<fsetpos>()"

#. type: Plain text
#: man-pages/man3/fseek.3:189
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man3/fseek.3:191
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr "B<lseek>(2), B<fseeko>(3)"

#. type: TH
#: man-pages/man3/frexp.3:33
#, no-wrap
msgid "FREXP"
msgstr "FREXP"

#. type: Plain text
#: man-pages/man3/frexp.3:37
msgid ""
"frexp, frexpf, frexpl - convert floating-point number to fractional and "
"integral components"
msgstr ""
"frexp, frexpf, frexpl - приводит число с плавающей точкой к виду мантисса/"
"степень"

#. type: Plain text
#: man-pages/man3/frexp.3:44
#, no-wrap
msgid ""
"B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"
"B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"
"B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"
msgstr ""
"B<double frexp(double >I<x>B<, int *>I<exp>B<);>\n"
"B<float frexpf(float >I<x>B<, int *>I<exp>B<);>\n"
"B<long double frexpl(long double >I<x>B<, int *>I<exp>B<);>\n"

#. type: Plain text
#: man-pages/man3/frexp.3:56
msgid "B<frexpf>(), B<frexpl>():"
msgstr "B<frexpf>(), B<frexpl>():"

#. type: Plain text
#: man-pages/man3/frexp.3:60
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/frexp.3:68
msgid ""
"These functions are used to split the number I<x> into a normalized fraction "
"and an exponent which is stored in I<exp>."
msgstr ""
"Эти функции используются для разделения числа I<x> на нормализованную "
"мантиссу и степень, которая сохраняется в I<exp>."

#. type: Plain text
#: man-pages/man3/frexp.3:78
msgid ""
"These functions return the normalized fraction.  If the argument I<x> is not "
"zero, the normalized fraction is I<x> times a power of two, and its absolute "
"value is always in the range 1/2 (inclusive) to 1 (exclusive), that is, "
"[0.5,1)."
msgstr ""
"Эти функции возвращают нормализованную мантиссу. Если аргумент I<x> не равен "
"нулю, то нормализованная мантисса равна I<x> степеням двойки, а её "
"абсолютное значение всегда находится в диапазоне от 1/2 (включительно) до 1 "
"(не включая), то есть [0.5,1)."

#. type: Plain text
#: man-pages/man3/frexp.3:84
msgid ""
"If I<x> is zero, then the normalized fraction is zero and zero is stored in "
"I<exp>."
msgstr ""
"Если значение I<x> равно нулю, то нормализованная мантисса равна нулю, и "
"ноль сохраняется в I<exp>."

#. type: Plain text
#: man-pages/man3/frexp.3:91
msgid ""
"If I<x> is a NaN, a NaN is returned, and the value of I<*exp> is unspecified."
msgstr ""
"Если значение I<x> равно NaN, то возвращается NaN, а значение I<*exp> не "
"определено."

#. type: Plain text
#: man-pages/man3/frexp.3:98
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned, and the value of I<*exp> is unspecified."
msgstr ""
"Если I<x> равно плюс или минус бесконечность, то будет возвращена плюс или "
"минус бесконечность, а значение I<*exp> не определено."

#. type: Plain text
#: man-pages/man3/frexp.3:100
msgid "No errors occur."
msgstr "Ошибки не возникают."

#. type: tbl table
#: man-pages/man3/frexp.3:112
#, no-wrap
msgid ""
"B<frexp>(),\n"
"B<frexpf>(),\n"
"B<frexpl>()"
msgstr ""
"B<frexp>(),\n"
"B<frexpf>(),\n"
"B<frexpl>()"

#. type: Plain text
#: man-pages/man3/frexp.3:121
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""
"Вариант, возвращающий значение типа I<double>, также соответствует SVr4, "
"4.3BSD, C89."

#. type: Plain text
#: man-pages/man3/frexp.3:123
msgid "The program below produces results such as the following:"
msgstr "Нижеследующая программа выдает такие результаты:"

#. type: Plain text
#: man-pages/man3/frexp.3:130
#, no-wrap
msgid ""
"$B< ./a.out 2560>\n"
"frexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n"
"$B< ./a.out -4>\n"
"frexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"
msgstr ""
"$B< ./a.out 2560>\n"
"frexp(2560, &e) = 0.625: 0.625 * 2^12 = 2560\n"
"$B< ./a.out -4>\n"
"frexp(-4, &e) = -0.5: -0.5 * 2^3 = -4\n"

#. type: Plain text
#: man-pages/man3/frexp.3:139
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>float.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>float.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/frexp.3:145
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x, r;\n"
"    int exp;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x, r;\n"
"    int exp;\n"

#. type: Plain text
#: man-pages/man3/frexp.3:148
#, no-wrap
msgid ""
"    x = strtod(argv[1], NULL);\n"
"    r = frexp(x, &exp);\n"
msgstr ""
"    x = strtod(argv[1], NULL);\n"
"    r = frexp(x, &exp);\n"

#. type: Plain text
#: man-pages/man3/frexp.3:153
#, no-wrap
msgid ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n"
"           x, r, r, FLT_RADIX, exp, x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"frexp(%g, &e) = %g: %g * %d^%d = %g\\en\",\n"
"           x, r, r, FLT_RADIX, exp, x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/frexp.3:156
msgid "B<ldexp>(3), B<modf>(3)"
msgstr "B<ldexp>(3), B<modf>(3)"

#. type: TH
#: man-pages/man3/fclose.3:44
#, no-wrap
msgid "FCLOSE"
msgstr "FCLOSE"

#. type: TH
#: man-pages/man3/fclose.3:44
#, no-wrap
msgid "2016-12-12"
msgstr "2016-12-12"

#. type: Plain text
#: man-pages/man3/fclose.3:47
msgid "fclose - close a stream"
msgstr "fclose - закрывает поток"

#. type: Plain text
#: man-pages/man3/fclose.3:51
msgid "B<int fclose(FILE *>I<stream>B<);>"
msgstr "B<int fclose(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fclose.3:59
msgid ""
"The B<fclose>()  function flushes the stream pointed to by I<stream> "
"(writing any buffered output data using B<fflush>(3))  and closes the "
"underlying file descriptor."
msgstr ""
"Функция B<fclose>() сбрасывает (flushes) поток, указанный в I<stream> "
"(записывает все буферизированные выходные данные с помощью B<fflush>(3)) и "
"закрывает связанный с ним файловый дескриптор."

#. type: Plain text
#: man-pages/man3/fclose.3:70
msgid ""
"Upon successful completion, 0 is returned.  Otherwise, B<EOF> is returned "
"and I<errno> is set to indicate the error.  In either case, any further "
"access (including another call to B<fclose>())  to the stream results in "
"undefined behavior."
msgstr ""
"При успешном выполнении возвращается нулевое значение. В противном случае "
"возвращается B<EOF> и I<errno> присваивается код ошибки. В любом случае, "
"дальнейшие попытки доступа (включая ещё один вызов B<fclose>()) к потоку "
"приведут к неопределенному результату."

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(stream)).
#. type: Plain text
#: man-pages/man3/fclose.3:80
msgid "The file descriptor underlying I<stream> is not valid."
msgstr "В I<stream> указан неверный дескриптор файла."

#. type: Plain text
#: man-pages/man3/fclose.3:90
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2), or B<fflush>(3)."
msgstr ""
"Функция B<fclose>() при ошибках может установить I<errno> в значение, "
"соответствующее ошибкам функций B<close>(2), B<write>(2) или B<fflush>(3)."

#. type: tbl table
#: man-pages/man3/fclose.3:100
#, no-wrap
msgid "B<fclose>()"
msgstr "B<fclose>()"

#. type: Plain text
#: man-pages/man3/fclose.3:114
msgid ""
"Note that B<fclose>()  flushes only the user-space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"Заметим, что B<fclose>() сбрасывает буферы только пользовательского "
"пространства, заданные библиотекой Си. Чтобы гарантировать, что данные "
"действительно физически сохранены на диске, буферы ядра также должны быть "
"сохранены, например, с помощью вызова B<sync>(2) или B<fsync>(2)."

#. type: Plain text
#: man-pages/man3/fclose.3:120
msgid ""
"B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fileno>(3), B<fopen>(3), "
"B<setbuf>(3)"
msgstr ""
"B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fileno>(3), B<fopen>(3), "
"B<setbuf>(3)"

#. type: TH
#: man-pages/man3/fwide.3:16
#, no-wrap
msgid "FWIDE"
msgstr "FWIDE"

#. type: TH
#: man-pages/man3/fwide.3:16
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: man-pages/man3/fwide.3:19
msgid "fwide - set and determine the orientation of a FILE stream"
msgstr "fwide - задаёт и определяет ориентацию потока FILE"

#. type: Plain text
#: man-pages/man3/fwide.3:22
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fwide.3:24
#, no-wrap
msgid "B<int fwide(FILE *>I<stream>B<, int >I<mode>B<);>\n"
msgstr "B<int fwide(FILE *>I<stream>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fwide.3:33
msgid "B<fwide>():"
msgstr "B<fwide>():"

#. type: Plain text
#: man-pages/man3/fwide.3:35
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"

#. type: Plain text
#: man-pages/man3/fwide.3:37
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/fwide.3:54
msgid ""
"When I<mode> is zero, the B<fwide>()  function determines the current "
"orientation of I<stream>.  It returns a positive value if I<stream> is wide-"
"character oriented, that is, if wide-character I/O is permitted but char I/O "
"is disallowed.  It returns a negative value if I<stream> is byte oriented"
"\\(emthat is, if char I/O is permitted but wide-character I/O is "
"disallowed.  It returns zero if I<stream> has no orientation yet; in this "
"case the next I/O operation might change the orientation (to byte oriented "
"if it is a char I/O operation, or to wide-character oriented if it is a wide-"
"character I/O operation)."
msgstr ""
"Если значение I<mode> равно нулю, то функция B<fwide>() определяет текущую "
"ориентацию потока I<stream>. Возвращается положительное значение, если "
"I<stream> ориентирован на широкие символы, то есть ввод/вывод широких "
"символов разрешён, а ввод/вывод обычных символов запрещён. Возвращается "
"отрицательное значение, если I<stream> ориентирован на работу с байтами, то "
"есть разрешён ввод/вывод обычных символов (char), а ввод/вывод широких "
"символов запрещён. Возвращается ноль, если I<stream> пока не имеет "
"ориентации; в этом случае следующая операция ввода/вывода может поменять "
"ориентацию (например, на байтовую, если производится операция ввода/вывода "
"символов, или на широкие символы, если выполняется операция ввода/вывода "
"широких символов)."

#. type: Plain text
#: man-pages/man3/fwide.3:57
msgid ""
"Once a stream has an orientation, it cannot be changed and persists until "
"the stream is closed."
msgstr ""
"После того, ориентация потока определена, она не сможет быть изменена и "
"будет действовать до тех пор, пока не закроется поток."

#. type: Plain text
#: man-pages/man3/fwide.3:66
msgid ""
"When I<mode> is nonzero, the B<fwide>()  function first attempts to set "
"I<stream>'s orientation (to wide-character oriented if I<mode> is greater "
"than 0, or to byte oriented if I<mode> is less than 0).  It then returns a "
"value denoting the current orientation, as above."
msgstr ""
"Если значение I<mode> не равно нулю, то функция B<fwide>() сначала "
"попытается установить ориентацию I<stream> (на широкие символы, если I<mode> "
"больше 0, или на байты, если I<mode> меньше 0). Затем возвращается значение, "
"отражающее текущую ориентацию, как указано выше."

#. type: Plain text
#: man-pages/man3/fwide.3:74
msgid ""
"The B<fwide>()  function returns the stream's orientation, after possibly "
"changing it.  A positive return value means wide-character oriented.  A "
"negative return value means byte oriented.  A return value of zero means "
"undecided."
msgstr ""
"Функция B<fwide>() возвращает ориентацию потока после возможного её "
"изменения. Возвращаемое положительное значение означает ориентацию на "
"широкие символы. Возвращаемое отрицательное значение означает ориентацию на "
"байты. Возвращаемое значение 0 означает неопределённость."

#. type: Plain text
#: man-pages/man3/fwide.3:76
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/fwide.3:84
msgid ""
"Wide-character output to a byte oriented stream can be performed through the "
"B<fprintf>(3)  function with the B<%lc> and B<%ls> directives."
msgstr ""
"Вывод широких символов в поток, ориентированный на байтовые операции, может "
"быть осуществлён с помощью функции B<fprintf>(3) с директивами B<%lc> и B<"
"%ls>."

#. type: Plain text
#: man-pages/man3/fwide.3:93
msgid ""
"Char oriented output to a wide-character oriented stream can be performed "
"through the B<fwprintf>(3)  function with the B<%c> and B<%s> directives."
msgstr ""
"Вывод символов в поток, ориентированный на операции с широкими символами, "
"может быть осуществлён с помощью функции B<fwprintf>(3) с директивами B<%c> "
"и B<%s>."

#. type: Plain text
#: man-pages/man3/fwide.3:95
msgid "B<fprintf>(3), B<fwprintf>(3)"
msgstr "B<fprintf>(3), B<fwprintf>(3)"

#. type: TH
#: man-pages/man3/fexecve.3:25
#, no-wrap
msgid "FEXECVE"
msgstr "FEXECVE"

#. type: Plain text
#: man-pages/man3/fexecve.3:28
msgid "fexecve - execute program specified via file descriptor"
msgstr "fexecve - запускает программу, заданную файловым дескриптором"

#. type: Plain text
#: man-pages/man3/fexecve.3:31
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fexecve.3:33
#, no-wrap
msgid "B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<[]);>\n"
msgstr "B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<[]);>\n"

#. type: Plain text
#: man-pages/man3/fexecve.3:41
msgid "B<fexecve>():"
msgstr "B<fexecve>():"

#. type: Plain text
#: man-pages/man3/fexecve.3:69
msgid ""
"B<fexecve>()  performs the same task as B<execve>(2), with the difference "
"that the file to be executed is specified via a file descriptor, I<fd>, "
"rather than via a pathname.  The file descriptor I<fd> must be opened read-"
"only (B<O_RDONLY>)  or with the B<O_PATH> flag and the caller must have "
"permission to execute the file that it refers to."
msgstr ""
"Функция B<fexecve>() выполняет ту же задачу, что и B<execve>(2), только "
"выполняемый файл указывается посредством файлового дескриптора I<fd>, а не "
"через путь к файлу. Файловый дескриптор I<fd> должен быть открыт только для "
"чтения (B<O_RDONLY>) или иметь флаг B<O_PATH> и вызывающий должен иметь "
"право на выполнение файла, на который ссылается дескриптор."

#. type: Plain text
#: man-pages/man3/fexecve.3:76
msgid ""
"A successful call to B<fexecve>()  never returns.  On error, the function "
"does return, with a result value of -1, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<fexecve>() не возвращает управление. При ошибке "
"функция возвращает выполнение с результатом -1, а I<errno> устанавливает в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man3/fexecve.3:80
msgid "Errors are as for B<execve>(2), with the following additions:"
msgstr "Возникают те же ошибки что и для B<execve>(2), а также дополнительно:"

#. type: Plain text
#: man-pages/man3/fexecve.3:88
msgid ""
"I<fd> is not a valid file descriptor, or I<argv> is NULL, or I<envp> is NULL."
msgstr ""
"Значение I<fd> не является правильным файловым дескриптором или I<argv> "
"равно NULL, или I<envp> равно NULL."

#. type: Plain text
#: man-pages/man3/fexecve.3:96
msgid ""
"The close-on-exec flag is set on I<fd>, and I<fd> refers to a script.  See "
"BUGS."
msgstr ""
"На I<fd> установлен флаг close-on-exec и  I<fd> ссылается на сценарий. "
"Смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man3/fexecve.3:103
msgid ""
"The kernel does not provide the B<execveat>(2)  system call, and the I</"
"proc> filesystem could not be accessed."
msgstr ""
"Ядро не предоставляет системный вызов B<execveat>(2) и файловая система I</"
"proc> недоступна."

#. type: Plain text
#: man-pages/man3/fexecve.3:106
msgid "B<fexecve>()  is implemented since glibc 2.3.2."
msgstr "Функция B<fexecve>() появилась в glibc 2.3.2."

#. type: tbl table
#: man-pages/man3/fexecve.3:116
#, no-wrap
msgid "B<fexecve>()"
msgstr "B<fexecve>()"

#. type: Plain text
#: man-pages/man3/fexecve.3:124
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems.  It is specified in POSIX.1-2008."
msgstr ""
"POSIX.1-2008. Эта функция не определена в POSIX.1-2001 и широко не "
"распространена среди других систем. Она определена в POSIX.1-2008."

#.  glibc commit 43ffc53a352a67672210c9dd4959f6c6b7407e60
#. type: Plain text
#: man-pages/man3/fexecve.3:141
msgid ""
"On Linux with glibc versions 2.26 and earlier, B<fexecve>()  is implemented "
"using the B<proc>(5)  filesystem, so I</proc> needs to be mounted and "
"available at the time of the call.  Since glibc 2.27, if the underlying "
"kernel supports the B<execveat>(2)  system call, then B<fexecve>()  is "
"implemented using that system call, with the benefit that I</proc> does not "
"need to be mounted."
msgstr ""
"В Linux c glibc с версией 2.26 и старее функция B<fexecve>() реализована с "
"использованием файловой системы B<proc>(5), поэтому I</proc> должна быть "
"смонтирована и доступна на момент вызова. Начиная с glibc 2.27, если "
"используемое ядро поддерживает системный вызов B<execveat>(2), то "
"B<fexecve>() реализуется через этот системный вызов и I</proc> монтировать "
"уже не нужно."

#. type: Plain text
#: man-pages/man3/fexecve.3:158
msgid ""
"The idea behind B<fexecve>()  is to allow the caller to verify (checksum) "
"the contents of an executable before executing it.  Simply opening the file, "
"checksumming the contents, and then doing an B<execve>(2)  would not "
"suffice, since, between the two steps, the filename, or a directory prefix "
"of the pathname, could have been exchanged (by, for example, modifying the "
"target of a symbolic link).  B<fexecve>()  does not mitigate the problem "
"that the I<contents> of a file could be changed between the checksumming and "
"the call to B<fexecve>(); for that, the solution is to ensure that the "
"permissions on the file prevent it from being modified by malicious users."
msgstr ""
"Предназначение B<fexecve>() — позволить вызывающему проверить содержимое "
"исполняемого файла (контрольную сумму) до запуска. Простого открытия файла, "
"вычисления контрольной суммы содержимого и выполнения B<execve>(2) "
"недостаточно, так как между двумя этими шагами может измениться имя файла "
"или каталог пути (например, посредством изменения цели символьной ссылки). "
"Функция B<fexecve>() не решает проблему возможного изменения I<содержимого> "
"файла между проверкой контрольной суммы и вызовом B<fexecve>() — для этого "
"есть права на файл, которые должны предотвращать его несанкционированное "
"изменение."

#. type: Plain text
#: man-pages/man3/fexecve.3:176
msgid ""
"The natural idiom when using B<fexecve>()  is to set the close-on-exec flag "
"on I<fd>, so that the file descriptor does not leak through to the program "
"that is executed.  This approach is natural for two reasons.  First, it "
"prevents file descriptors being consumed unnecessarily.  (The executed "
"program normally has no need of a file descriptor that refers to the program "
"itself.)  Second, if B<fexecve>()  is used recursively, employing the close-"
"on-exec flag prevents the file descriptor exhaustion that would result from "
"the fact that each step in the recursion would cause one more file "
"descriptor to be passed to the new program.  (But see BUGS.)"
msgstr ""
"Естественная идиома при использовании B<fexecve>() — установить флаг "
"закрытия-при-выполнении на I<fd> для того, чтобы дескриптор файла не утекал "
"выполняемой программе. Этот подход естественен по двум причинам. Во-первых, "
"это предотвращает трату дескрипторов файлов без надобности (выполняемой "
"программе, обычно, не нужен дескриптор файла, который ссылается на саму "
"программу). Во-вторых, если B<fexecve>() использовать рекурсивно, то "
"применение флага закрытия-при-выполнении предотвращает исчерпание "
"дескрипторов файлов, которое произошло бы, так как каждый шаг в рекурсии "
"вызывает передачу ещё одного дескриптора файла новой программе (но смотрите "
"ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man3/fexecve.3:195
msgid ""
"If I<fd> refers to a script (i.e., it is an executable text file that names "
"a script interpreter with a first line that begins with the characters I<#!"
">)  and the close-on-exec flag has been set for I<fd>, then B<fexecve>()  "
"fails with the error B<ENOENT>.  This error occurs because, by the time the "
"script interpreter is executed, I<fd> has already been closed because of the "
"close-on-exec flag.  Thus, the close-on-exec flag can't be set on I<fd> if "
"it refers to a script, leading to the problems described in NOTES."
msgstr ""
"Если I<fd> ссылается на сценарий (т. е., это исполняемый текстовый файл, у "
"которого в первой строке (начинается с I<#!>) указан интерпретатор сценария "
"и флаг закрытия-при-выполнении установлен на I<fd>, то B<fexecve>() "
"завершается с ошибкой B<ENOENT>. Эта ошибка возникает потому, что на момент "
"выполнения интерпретатора сценария I<fd> уже закрыт, так как указан флаг "
"закрытия-при-выполнении. Таким образом флаг закрытия-при-выполнении не может "
"быть установлен I<fd>, если он указывает на сценарий, так как это приводит к "
"проблемам, описанным в ЗАМЕЧАНИЯХ."

#. type: Plain text
#: man-pages/man3/fexecve.3:197
msgid "B<execve>(2), B<execveat>(2)"
msgstr "B<execve>(2), B<execveat>(2)"

#. type: TH
#: man-pages/man3/fgetws.3:18
#, no-wrap
msgid "FGETWS"
msgstr "FGETWS"

#. type: Plain text
#: man-pages/man3/fgetws.3:21
msgid "fgetws - read a wide-character string from a FILE stream"
msgstr "fgetws - читает строку широких символов из потока FILE"

#. type: Plain text
#: man-pages/man3/fgetws.3:26
#, no-wrap
msgid "B<wchar_t *fgetws(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
msgstr "B<wchar_t *fgetws(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetws.3:40
msgid ""
"The B<fgetws>()  function is the wide-character equivalent of the "
"B<fgets>(3)  function.  It reads a string of at most I<n-1> wide characters "
"into the wide-character array pointed to by I<ws>, and adds a terminating "
"null wide character (L\\(aq\\e0\\(aq).  It stops reading wide characters "
"after it has encountered and stored a newline wide character.  It also stops "
"when end of stream is reached."
msgstr ""
"Функция B<fgetws>() — это эквивалент B<fgets>(3), но работающий со строками "
"широких символов. Она читает строку из не более чем I<n-1> широких символов, "
"записывает её в массив широких символов I<ws> и добавляет завершающий "
"широкий символ null (L\\(aq\\e0\\(aq). Она прекращает чтение после "
"обнаружения и записи широкого символа новой строки. Это также происходит и в "
"случае достижения конца потока."

#. type: Plain text
#: man-pages/man3/fgetws.3:43
msgid ""
"The programmer must ensure that there is room for at least I<n> wide "
"characters at I<ws>."
msgstr ""
"Программист должен убедиться в том, что выделил для I<ws> память, "
"достаточную для записи не менее I<n> широких символов."

#. type: Plain text
#: man-pages/man3/fgetws.3:46
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr "Неблокирующий аналог смотрите в B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/fgetws.3:52
msgid ""
"The B<fgetws>()  function, if successful, returns I<ws>.  If end of stream "
"was already reached or if an error occurred, it returns NULL."
msgstr ""
"Функция B<fgetws>() в случае удачного выполнения возвращает I<ws>. Если "
"достигнут конец потока или возникает ошибка, то возвращается NULL."

#. type: tbl table
#: man-pages/man3/fgetws.3:62
#, no-wrap
msgid "B<fgetws>()"
msgstr "B<fgetws>()"

#. type: Plain text
#: man-pages/man3/fgetws.3:73
msgid ""
"The behavior of B<fgetws>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fgetws>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fgetws.3:81
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fgetws>()  will actually read a multibyte "
"string from the stream and then convert it to a wide-character string."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fgetws>() на самом деле читает многобайтовую "
"строку из потока, а затем преобразует её в широкую строку."

#. type: Plain text
#: man-pages/man3/fgetws.3:85
msgid ""
"This function is unreliable, because it does not permit to deal properly "
"with null wide characters that may be present in the input."
msgstr ""
"Данная функция  ненадёжна, так как не позволяет правильно обработать "
"ситуацию, когда во входных данных появляется широкий символ null."

#. type: Plain text
#: man-pages/man3/fgetws.3:87
msgid "B<fgetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/flockfile.3:25
#, no-wrap
msgid "FLOCKFILE"
msgstr "FLOCKFILE"

#. type: TH
#: man-pages/man3/flockfile.3:25
#, no-wrap
msgid "2017-07-13"
msgstr "2017-07-13"

#. type: Plain text
#: man-pages/man3/flockfile.3:28
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr "flockfile, ftrylockfile, funlockfile - блокирует FILE для stdio"

#. type: Plain text
#: man-pages/man3/flockfile.3:35
#, no-wrap
msgid ""
"B<void flockfile(FILE *>I<filehandle>B<);>\n"
"B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
"B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""
"B<void flockfile(FILE *>I<filehandle>B<);>\n"
"B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
"B<void funlockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: man-pages/man3/flockfile.3:44
msgid "All functions shown above:"
msgstr "Для всех функций, перечисленных выше:"

#. type: Plain text
#: man-pages/man3/flockfile.3:48
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/flockfile.3:62
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""
"Функции stdio можно без опаски использовать в нитях. Это достигается "
"назначением каждому объекту I<FILE> счётчика блокировок и (если счётчик не "
"равен нулю) нити-владельца. При каждом библиотечном вызове эти функции ждут "
"разблокировки объекта I<FILE> другой нитью, блокируют его, а затем выполняют "
"заданную операцию ввода/вывода и разблокируют объект."

#. type: Plain text
#: man-pages/man3/flockfile.3:68
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""
"(Замечание: блокировка не учитывается, если блокировка файла осуществлялась "
"функциями типа B<flock>(2)  и B<lockf>(3).)"

#. type: Plain text
#: man-pages/man3/flockfile.3:76
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the "
"I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""
"Всё это прозрачно и незаметно для программиста на С, но всё же есть две "
"причины для более подробного изучения. Первая: возможны последовательности "
"операций ввода/вывода в одной нити, при этом другая нить не будет прерывать "
"ввод/вывод. Вторая: можно избежать чрезмерной нагрузки от блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:93
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming "
"in between.  If the reason for doing this was to achieve greater efficiency, "
"one does the I/O with the nonlocking versions of the stdio functions: with "
"B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of B<getc>(3)  and "
"B<putc>(3)."
msgstr ""
"С этой целью нить может явно блокировать объект I<FILE>, осуществить серию "
"операций ввода/вывода, а затем снять блокировку. При этом другие нити не "
"могут вклиниться между операциями. Если причиной для реализации всего этого "
"является повышение эффективности работы, то для ввода/вывод можно "
"использовать неблокирующие версии функций stdio: B<getc_unlocked>(3) и "
"B<putc_unlocked>(3) вместо B<getc>(3) и B<putc>(3)."

#. type: Plain text
#: man-pages/man3/flockfile.3:104
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked "
"by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""
"Функция B<flockfile>() ожидает, пока I<*filehandle> не разблокируется другой "
"нитью, затем делает текущую нить владельцем I<*filehandle> и увеличивает "
"счётчик блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:108
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr "Функция B<funlockfile>() уменьшает счётчик блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:119
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>().  "
"It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""
"Функция B<ftrylockfile>() является неблокирующей версией B<flockfile>(). Она "
"ничего не делает в том случае, если другая нить владеет I<*filehandle>, в "
"противном случае устанавливает статус владельца и увеличивает счётчик "
"блокировок."

#. type: Plain text
#: man-pages/man3/flockfile.3:124
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""
"При успешном выполнении функция B<ftrylockfile>() возвращает ноль (была "
"получена блокировка) или ненулевое значение при ошибках."

#. type: Plain text
#: man-pages/man3/flockfile.3:126
msgid "None."
msgstr "Нет."

#. type: tbl table
#: man-pages/man3/flockfile.3:138
#, no-wrap
msgid ""
"B<flockfile>(),\n"
"B<ftrylockfile>(),\n"
"B<funlockfile>()"
msgstr ""
"B<flockfile>(),\n"
"B<ftrylockfile>(),\n"
"B<funlockfile>()"

#. type: Plain text
#: man-pages/man3/flockfile.3:142
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/flockfile.3:146
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr "Эти функции доступны, если определено B<_POSIX_THREAD_SAFE_FUNCTIONS>."

#. type: Plain text
#: man-pages/man3/flockfile.3:147
msgid "B<unlocked_stdio>(3)"
msgstr "B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fmin.3:9
#, no-wrap
msgid "FMIN"
msgstr "FMIN"

#. type: Plain text
#: man-pages/man3/fmin.3:12
msgid "fmin, fminf, fminl - determine minimum of two floating-point numbers"
msgstr ""
"fmin, fminf, fminl - определение минимального из двух чисел с плавающей "
"запятой"

#. type: Plain text
#: man-pages/man3/fmin.3:16
msgid "B<double fmin(double >I<x>B<, double >I<y>B<);>"
msgstr "B<double fmin(double >I<x>B<, double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmin.3:18
msgid "B<float fminf(float >I<x>B<, float >I<y>B<);>"
msgstr "B<float fminf(float >I<x>B<, float >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmin.3:20
msgid "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"
msgstr "B<long double fminl(long double >I<x>B<, long double >I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmin.3:32
msgid "B<fmin>(), B<fminf>(), B<fminl>():"
msgstr "B<fmin>(), B<fminf>(), B<fminl>():"

#. type: Plain text
#: man-pages/man3/fmin.3:41
msgid "These functions return the lesser value of I<x> and I<y>."
msgstr "Данные функции возвращают меньшее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmin.3:46
msgid "These functions return the minimum of I<x> and I<y>."
msgstr "Данные функции возвращают меньшее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmin.3:48
msgid "If one argument is a NaN, the other argument is returned."
msgstr ""
"Если значение одного из аргументов равно NaN, то будет возвращено значение "
"другого аргумента."

#. type: Plain text
#: man-pages/man3/fmin.3:50
msgid "If both arguments are NaN, a NaN is returned."
msgstr "Если значение обоих аргументов равно NaN, то будет возвращено NaN."

#. type: tbl table
#: man-pages/man3/fmin.3:66
#, no-wrap
msgid ""
"B<fmin>(),\n"
"B<fminf>(),\n"
"B<fminl>()"
msgstr ""
"B<fmin>(),\n"
"B<fminf>(),\n"
"B<fminl>()"

#. type: Plain text
#: man-pages/man3/fmin.3:72
msgid "B<fdim>(3), B<fmax>(3)"
msgstr "B<fdim>(3), B<fmax>(3)"

#. type: TH
#: man-pages/man3/fopencookie.3:26
#, no-wrap
msgid "FOPENCOOKIE"
msgstr "FOPENCOOKIE"

#. type: Plain text
#: man-pages/man3/fopencookie.3:29
msgid "fopencookie - opening a custom stream"
msgstr "fopencookie - открывает нестандартный поток"

#. type: Plain text
#: man-pages/man3/fopencookie.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:36
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:49
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the "
"stream's data at a location of its own choosing; for example, "
"B<fopencookie>()  is used to implement B<fmemopen>(3), which provides a "
"stream interface to data that is stored in a buffer in memory."
msgstr ""
"Функция B<fopencookie>() позволяет программисту создать нестандартную "
"реализацию стандартного потока ввода-вывода. Эта реализация может хранить "
"данные потока в расположении по своему выбору; например, B<fopencookie>() "
"используется для реализации функции B<fmemopen>(3), которая предоставляет "
"потоковый интерфейс для данных, хранящихся в буфере в памяти."

#. type: Plain text
#: man-pages/man3/fopencookie.3:51
msgid "In order to create a custom stream the programmer must:"
msgstr "Для создания нестандартного потока программист должен:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:54
msgid ""
"Implement four \"hook\" functions that are used internally by the standard I/"
"O library when performing I/O on the stream."
msgstr ""
"Реализовать четыре «обрабатывающих» (hook) функции, которые используются "
"внутри стандартной библиотеки ввода-вывода при операциях ввода-вывода над "
"потоком."

#. type: Plain text
#: man-pages/man3/fopencookie.3:65
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to "
"B<fopencookie>()), but automatically supplies the cookie as the first "
"argument when calling the hook functions."
msgstr ""
"Определить тип данных «cookie» — структуру для учёта информации (например, "
"где хранятся данные), используемую вышеупомянутыми обрабатывающими "
"функциями. Стандартный пакет ввода-вывода ничего не знает о содержимом этого "
"cookie (к нему обращаются как к I<void\\ *> при передаче в "
"B<fopencookie>()), но автоматически передаёт cookie в первом аргументе при "
"вызове обрабатывающих функций."

#. type: Plain text
#: man-pages/man3/fopencookie.3:70
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""
"Вызвать B<fopencookie>() для открытия нового потока и связывания cookie и "
"обрабатывающими функциями с этим потоком."

#. type: Plain text
#: man-pages/man3/fopencookie.3:78
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to "
"operate on that stream."
msgstr ""
"Функция B<fopencookie>() подобна B<fopen>(3): она открывает новый поток и "
"возвращает указатель на объект I<FILE>, который используется для работы с "
"потоком."

#. type: Plain text
#: man-pages/man3/fopencookie.3:85
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is "
"to be associated with the new stream.  This pointer is supplied as the first "
"argument when the standard I/O library invokes any of the hook functions "
"described below."
msgstr ""
"Аргумент I<cookie> — это указатель на структуру cookie вызывающего, которая "
"связывается с новым потоком. Данный указатель передаётся в первом аргументе "
"в моменты, когда стандартная библиотека ввода-вывода вызывает одну из "
"обрабатывающих функций, описанных ниже."

#. type: Plain text
#: man-pages/man3/fopencookie.3:101
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""
"Аргумент I<mode> служит той же цели что и для B<fopen>(3). Поддерживаются "
"следующие режимы: I<r>, I<w>, I<a>, I<r+>, I<w+> и I<a+>. Подробности "
"смотрите в B<fopen>(3)."

#. type: Plain text
#: man-pages/man3/fopencookie.3:107
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""
"Аргумент I<io_funcs> — это структура, которая содержит четыре поля с "
"задаваемыми программистом обрабатывающими функциями, которые используются "
"для реализации этого потока. Структура определена как"

#. type: Plain text
#: man-pages/man3/fopencookie.3:116
#, no-wrap
msgid ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"
msgstr ""
"typedef struct {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"} cookie_io_functions_t;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:120
msgid "The four fields are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man3/fopencookie.3:120
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr "I<cookie_read_function_t *read>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:124
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""
"Эта функция реализует операции чтения из потока. Она вызывается с тремя "
"аргументами:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:126
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr "    ssize_t read(void *cookie, char *buf, size_t size);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:141
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""
"Аргументы I<buf> и I<size> — буфер для получаемых данных и его размер. В "
"качестве результата функция I<read> возвращает количество байт, "
"скопированных в I<buf>, 0 — при окончании файла и -1 при ошибке. Функция "
"I<read> обновляет смещение в потоке соответствующим образом."

#. type: Plain text
#: man-pages/man3/fopencookie.3:146
msgid ""
"If I<*read> is a null pointer, then reads from the custom stream always "
"return end of file."
msgstr ""
"Если значение I<*read> равно null, то при чтении из нестандартного потока "
"всегда возвращается конец файла."

#. type: TP
#: man-pages/man3/fopencookie.3:146
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr "I<cookie_write_function_t *write>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:150
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""
"Эта функция реализует операции записи в поток. Она вызывается с тремя "
"аргументами:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:152
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr "    ssize_t write(void *cookie, const char *buf, size_t size);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:168
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or 0 on error.  (The function must not return a negative value.)  The "
"I<write> function should update the stream offset appropriately."
msgstr ""
"Аргументы I<buf> и I<size> — буфер для выходных данных и его размер (данные, "
"записываемые в поток). В качестве результата функция I<write> возвращает "
"количество байт, скопированных из I<buf>, и 0 при ошибке (функция не должна "
"возвращать отрицательное значение). Функция I<write> обновляет смещение в "
"потоке соответствующим образом."

#. type: Plain text
#: man-pages/man3/fopencookie.3:173
msgid "If I<*write> is a null pointer, then output to the stream is discarded."
msgstr "Если значение I<*write> равно null, то вывод в поток отбрасывается."

#. type: TP
#: man-pages/man3/fopencookie.3:173
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr "I<cookie_seek_function_t *seek>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:177
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""
"Эта функция реализует операции смещения в потоке. Она вызывается с тремя "
"аргументами:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:179
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr "    int seek(void *cookie, off64_t *offset, int whence);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:185
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""
"В аргументе I<*offset> указывается новое файловое смещение, зависящее от "
"значения I<whence>:"

#. type: TP
#: man-pages/man3/fopencookie.3:186
#, no-wrap
msgid "B<SEEK_SET>"
msgstr "B<SEEK_SET>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:191
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr "Значение смещения приравнивается I<*offset> байт от начала потока."

#. type: TP
#: man-pages/man3/fopencookie.3:191
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr "B<SEEK_CUR>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:195
msgid "I<*offset> should be added to the current stream offset."
msgstr ""
"Значение I<*offset> должно быть добавлено к текущему смещению в потоке."

#. type: TP
#: man-pages/man3/fopencookie.3:195
#, no-wrap
msgid "B<SEEK_END>"
msgstr "B<SEEK_END>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:199
msgid ""
"The stream offset should be set to the size of the stream plus I<*offset>."
msgstr "Значение смещения приравнивается к размеру потока плюс I<*offset>."

#. type: Plain text
#: man-pages/man3/fopencookie.3:206
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""
"Перед возвратом функция I<seek> должна обновить I<*offset>, чтобы показать "
"новое смещение в потоке."

#. type: Plain text
#: man-pages/man3/fopencookie.3:210
msgid ""
"As its function result, the I<seek> function should return 0 on success, and "
"-1 on error."
msgstr ""
"В качестве результата функция I<seek> должна возвращать 0 при успешном "
"выполнении и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/fopencookie.3:215
msgid ""
"If I<*seek> is a null pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""
"Если значение I<*seek> равно null, то операции смещения в потоке выполнить "
"невозможно."

#. type: TP
#: man-pages/man3/fopencookie.3:215
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr "I<cookie_close_function_t *close>"

#. type: Plain text
#: man-pages/man3/fopencookie.3:221
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""
"Эта функция закрывает поток. Обрабатывающая функция может выполнить такие "
"операции как освобождение буферов, выделенных для потока. При вызове она "
"принимает один аргумент:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:223
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr "    int close(void *cookie);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:228
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""
"Аргумент I<cookie> — это cookie, которую программист передал при вызове "
"B<fopencookie>()."

#. type: Plain text
#: man-pages/man3/fopencookie.3:234
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""
"В качестве результата функция I<close> должна возвращать 0 при успешном "
"выполнении и B<EOF> при ошибке."

#. type: Plain text
#: man-pages/man3/fopencookie.3:238
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is "
"closed."
msgstr ""
"Если значение I<*close> равно NULL, то при закрытии потока не выполняется "
"никаких действий."

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: man-pages/man3/fopencookie.3:245
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error, "
"NULL is returned."
msgstr ""
"При успешном выполнении B<fopencookie>() возвращает указатель на новый "
"поток. При ошибке возвращается NULL."

#. type: tbl table
#: man-pages/man3/fopencookie.3:255
#, no-wrap
msgid "B<fopencookie>()"
msgstr "B<fopencookie>()"

#. type: Plain text
#: man-pages/man3/fopencookie.3:259
msgid "This function is a nonstandard GNU extension."
msgstr "Эта функция является нестандартным расширением GNU."

#. type: Plain text
#: man-pages/man3/fopencookie.3:268
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""
"Программа, представленная ниже, реализует нестандартный поток, свойства "
"которого похожи (но не одинаковы) на свойство потока, получаемого от "
"B<fmemopen>(3). Она реализует поток, данные которого хранятся в буфере "
"памяти. Программа записывает свои аргументы командной строки в поток, а "
"затем перемещается по потоку, читая два из каждых пяти символов и записывая "
"их в стандартный вывод. Сеанс оболочки, демонстрирующий использование "
"программы:"

#. type: Plain text
#: man-pages/man3/fopencookie.3:276
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Достигнут конец файла\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:283
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a "
"cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""
"Заметим, что представленную версию можно сильно улучшить, добавив обработку "
"ошибок (например, открытие потока с cookie, которая уже имеет открытый "
"поток; закрытие потока, который уже был закрыт)."

#. type: Plain text
#: man-pages/man3/fopencookie.3:292
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:294
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr "#define INIT_BUF_SIZE 4\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:301
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""
"struct memfile_cookie {\n"
"    char   *buf;        /* динамически изменяемый буфер для данных */\n"
"    size_t  allocated;  /* размер буфера */\n"
"    size_t  endpos;     /* количество символов в буфере */\n"
"    off_t   offset;     /* текущее файловое смещение в буфере */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:307
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:309
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr "    /* Буфер мал? Удваиваем размер, пока не станет достаточным */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:319
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:321
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:325
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:328
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr ""
"    return size;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:334
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:336
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr "    /* Выбираем минимум запрашиваемых и доступных байт */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:342
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* смещение может быть за endpos */\n"
"       xbytes = 0;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:344
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:348
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:354
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:363
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:366
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:371
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:376
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:380
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:383
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:399
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *stream;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *stream;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:401
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr "    /* Устанавливаем cookie перед вызовом fopencookie() */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:407
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:411
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:417
#, no-wrap
msgid ""
"    stream = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (stream == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    stream = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (stream == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:419
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr "    /* Записываем аргументы командной строки в файл */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:425
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], stream) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], stream) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:427
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr "    /* Читаем два байта из пяти пока не получим EOF */\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:442
#, no-wrap
msgid ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(stream, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, stream);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(stream, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, stream);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Достигнут конец файла\\en\");\n"
"            break;\n"
"        }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:445
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"
msgstr ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/fopencookie.3:453
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"

#. type: TH
#: man-pages/man3/fgetpwent.3:33
#, no-wrap
msgid "FGETPWENT"
msgstr "FGETPWENT"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:36
msgid "fgetpwent - get password file entry"
msgstr "fgetpwent - получает записи из файла паролей"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:41
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:43
#, no-wrap
msgid "B<struct passwd *fgetpwent(FILE *>I<stream>B<);>\n"
msgstr "B<struct passwd *fgetpwent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:55
#, no-wrap
msgid ""
"B<fgetpwent>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""
"B<fgetpwent>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:68
msgid ""
"The B<fgetpwent>()  function returns a pointer to a structure containing the "
"broken out fields of a line in the file I<stream>.  The first time it is "
"called it returns the first entry; thereafter, it returns successive "
"entries.  The file referred to by I<stream> must have the same format as I</"
"etc/passwd> (see B<passwd>(5))."
msgstr ""
"Функция B<fgetpwent>() возвращает указатель на структуру, содержащую "
"отдельные поля строки файла I<stream>. Во время первого вызова функция "
"возвращает первую запись; в дальнейшем она возвращает все последующие "
"записи. Формат файла I<stream> должен быть таким же как у I</etc/passwd> "
"(смотрите B<passwd>(5))."

#. type: Plain text
#: man-pages/man3/fgetpwent.3:70
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr "Структура I<passwd> определена в I<E<lt>pwd.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:82
#, no-wrap
msgid ""
"struct passwd {\n"
"    char   *pw_name;       /* username */\n"
"    char   *pw_passwd;     /* user password */\n"
"    uid_t   pw_uid;        /* user ID */\n"
"    gid_t   pw_gid;        /* group ID */\n"
"    char   *pw_gecos;      /* real name */\n"
"    char   *pw_dir;        /* home directory */\n"
"    char   *pw_shell;      /* shell program */\n"
"};\n"
msgstr ""
"struct passwd {\n"
"    char   *pw_name;       /* имя пользователя */\n"
"    char   *pw_passwd;     /* пароль пользователя */\n"
"    uid_t   pw_uid;        /* идентификатор пользователя */\n"
"    gid_t   pw_gid;        /* идентификатор группы */\n"
"    char   *pw_gecos;      /* настоящее имя */\n"
"    char   *pw_dir;        /* домашний каталог */\n"
"    char   *pw_shell;      /* программная оболочка */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:94
msgid ""
"The B<fgetpwent>()  function returns a pointer to a I<passwd> structure, or "
"NULL if there are no more entries or an error occurs.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<fgetpwent>() возвращает указатель на структуру I<passwd> или NULL, "
"если больше паролей не найдено или произошла ошибка. При ошибке I<errno> "
"присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fgetpwent.3:100
msgid "Insufficient memory to allocate I<passwd> structure."
msgstr "Недостаточно памяти для структуры I<passwd>."

#. type: TP
#: man-pages/man3/fgetpwent.3:101
#, no-wrap
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:104
msgid "password database file"
msgstr "файл, содержащий базу паролей"

#. type: tbl table
#: man-pages/man3/fgetpwent.3:114
#, no-wrap
msgid "B<fgetpwent>()"
msgstr "B<fgetpwent>()"

#. type: tbl table
#: man-pages/man3/fgetpwent.3:114
#, no-wrap
msgid "MT-Unsafe race:fgetpwent"
msgstr "MT-Unsafe race:fgetpwent"

#. type: Plain text
#: man-pages/man3/fgetpwent.3:127
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man3/fgetpwent.3:137
msgid ""
"B<endpwent>(3), B<fgetpwent_r>(3), B<fopen>(3), B<getpw>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr ""
"B<endpwent>(3), B<fgetpwent_r>(3), B<fopen>(3), B<getpw>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/fcloseall.3:25
#, no-wrap
msgid "FCLOSEALL"
msgstr "FCLOSEALL"

#. type: Plain text
#: man-pages/man3/fcloseall.3:28
msgid "fcloseall - close all open streams"
msgstr "fcloseall - закрытие всех открытых потоков"

#. type: Plain text
#: man-pages/man3/fcloseall.3:34
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr "B<int fcloseall(void);>\n"

#. type: Plain text
#: man-pages/man3/fcloseall.3:43
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as "
"for B<fflush>(3)); buffered input is discarded."
msgstr ""
"Функция B<fcloseall>() закрывает все открытые потоки вызвавшего процесса. "
"Перед закрытием буферизированный вывод каждого потока записывается (как с "
"B<fflush>(3)), а буферизированный ввод отбрасывается."

#. type: Plain text
#: man-pages/man3/fcloseall.3:50
msgid ""
"The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr ""
"Стандартные потоки, I<stdin>, I<stdout> и I<stderr>, также закрываются."

#. type: Plain text
#: man-pages/man3/fcloseall.3:55
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""
"Данная функция возвращает 0, если все файлы успешно закрыты, и B<EOF> в "
"случае ошибки."

#. type: tbl table
#: man-pages/man3/fcloseall.3:65
#, no-wrap
msgid "B<fcloseall>()"
msgstr "B<fcloseall>()"

#. type: tbl table
#: man-pages/man3/fcloseall.3:65
#, no-wrap
msgid "MT-Unsafe race:streams"
msgstr "MT-Unsafe race:streams"

#. type: Plain text
#: man-pages/man3/fcloseall.3:71
msgid ""
"The B<fcloseall>()  function does not lock the streams, so it is not thread-"
"safe."
msgstr ""
"Функция B<fcloseall>() не блокирует потоки, поэтому её нельзя использовать в "
"нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/fcloseall.3:73
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/fcloseall.3:78
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: man-pages/man3/fread.3:45
#, no-wrap
msgid "FREAD"
msgstr "FREAD"

#. type: TH
#: man-pages/man3/fread.3:45
#, no-wrap
msgid "2015-07-23"
msgstr "2015-07-23"

#. type: Plain text
#: man-pages/man3/fread.3:48
msgid "fread, fwrite - binary stream input/output"
msgstr "fread, fwrite - ввод/вывод из двоичного потока"

#. type: Plain text
#: man-pages/man3/fread.3:54
#, no-wrap
msgid "B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>I<stream>B<);>\n"
msgstr "B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fread.3:57
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fread.3:69
msgid ""
"The function B<fread>()  reads I<nmemb> items of data, each I<size> bytes "
"long, from the stream pointed to by I<stream>, storing them at the location "
"given by I<ptr>."
msgstr ""
"Функция B<fread>() считывает I<nmemb> единиц данных (размер каждого I<size> "
"байт) из потока, на который указывает I<stream>, и сохраняет их в "
"расположение, на которое указывает I<ptr>."

#. type: Plain text
#: man-pages/man3/fread.3:80
msgid ""
"The function B<fwrite>()  writes I<nmemb> items of data, each I<size> bytes "
"long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""
"Функция B<fwrite>() записывает I<nmemb> единиц данных (размер каждого "
"I<size> байт) в поток, на который указывает I<stream>, получая их из "
"расположения, на которое указывает I<ptr>."

#. type: Plain text
#: man-pages/man3/fread.3:83
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr "Неблокирующие аналоги смотрите в B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/fread.3:94
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of items read or "
"written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""
"При успешном выполнении функции B<fread>() и B<fwrite>() возвращают "
"количество считанных или записанных единиц. Это количество равно количеству "
"переданных байт только, если значение I<size> равно 1. В случае ошибки или "
"по достижении конца файла возвращается меньшее количество единиц (или ноль)."

#. type: Plain text
#: man-pages/man3/fread.3:101
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""
"Функция B<fread>() не отличает возникновение ошибки и достижения конца "
"файла; для точного определения необходимо вызывать функции B<feof>(3) и "
"B<ferror>(3)."

#. type: tbl table
#: man-pages/man3/fread.3:112
#, no-wrap
msgid ""
"B<fread>(),\n"
"B<fwrite>()"
msgstr ""
"B<fread>(),\n"
"B<fwrite>()"

#. type: Plain text
#: man-pages/man3/fread.3:116
msgid "POSIX.1-2001, POSIX.1-2008, C89."
msgstr "POSIX.1-2001, POSIX.1-2008, C89."

#. type: Plain text
#: man-pages/man3/fread.3:121
msgid "B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""
"B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fabs.3:32
#, no-wrap
msgid "FABS"
msgstr "FABS"

#. type: Plain text
#: man-pages/man3/fabs.3:35
msgid "fabs, fabsf, fabsl - absolute value of floating-point number"
msgstr ""
"fabs, fabsf, fabsl - вычисление абсолютного значения числа с плавающей точкой"

#. type: Plain text
#: man-pages/man3/fabs.3:42
#, no-wrap
msgid ""
"B<double fabs(double >I<x>B<);>\n"
"B<float fabsf(float >I<x>B<);>\n"
"B<long double fabsl(long double >I<x>B<);>\n"
msgstr ""
"B<double fabs(double >I<x>B<);>\n"
"B<float fabsf(float >I<x>B<);>\n"
"B<long double fabsl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fabs.3:54
msgid "B<fabsf>(), B<fabsl>():"
msgstr "B<fabsf>(), B<fabsl>():"

#. type: Plain text
#: man-pages/man3/fabs.3:64
msgid ""
"These functions return the absolute value of the floating-point number I<x>."
msgstr ""
"Эти функции возвращают абсолютное значение числа с плавающей точкой I<x>."

#. type: Plain text
#: man-pages/man3/fabs.3:67
msgid "These functions return the absolute value of I<x>."
msgstr "Данные функции возвращают абсолютное значение I<x>."

#. type: Plain text
#: man-pages/man3/fabs.3:71
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fabs.3:75
msgid "If I<x> is -0, +0 is returned."
msgstr "Если I<x> стремится к -0, будет возвращено +0."

#. type: Plain text
#: man-pages/man3/fabs.3:79
msgid ""
"If I<x> is negative infinity or positive infinity, positive infinity is "
"returned."
msgstr ""
"Если I<x> стремится к минус или плюс бесконечности, будет возвращена плюс "
"бесконечность."

#. type: tbl table
#: man-pages/man3/fabs.3:93
#, no-wrap
msgid ""
"B<fabs>(),\n"
"B<fabsf>(),\n"
"B<fabsl>()"
msgstr ""
"B<fabs>(),\n"
"B<fabsf>(),\n"
"B<fabsl>()"

#. type: Plain text
#: man-pages/man3/fabs.3:108
msgid "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"
msgstr "B<abs>(3), B<cabs>(3), B<ceil>(3), B<floor>(3), B<labs>(3), B<rint>(3)"

#. type: TH
#: man-pages/man3/ferror.3:44
#, no-wrap
msgid "FERROR"
msgstr "FERROR"

#. type: Plain text
#: man-pages/man3/ferror.3:47
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr "clearerr, feof, ferror, fileno - проверка и сброс состояния потока"

#. type: Plain text
#: man-pages/man3/ferror.3:51
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr "B<void clearerr(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:53
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr "B<int feof(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:55
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr "B<int ferror(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:57
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr "B<int fileno(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/ferror.3:65
msgid "B<fileno>(): _POSIX_C_SOURCE"
msgstr "B<fileno>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man3/ferror.3:70
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""
"Функция B<clearerr>() очищает индикаторы конца файла и ошибки потока, "
"указанного в I<stream>."

#. type: Plain text
#: man-pages/man3/ferror.3:78
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can be cleared only by the function B<clearerr>()."
msgstr ""
"Функция B<feof>() проверяет индикатор конца файла для потока, указанного в "
"I<stream>, возвращая при этом ненулевое значение, если индикатор установлен. "
"Индикатор конца файла может быть очищен только функцией B<clearerr>()."

#. type: Plain text
#: man-pages/man3/ferror.3:87
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can be "
"reset only by the B<clearerr>()  function."
msgstr ""
"Функция B<ferror>() проверяет индикатор ошибки для потока, указанного в "
"I<stream>, возвращая при этом ненулевое значение, если индикатор установлен. "
"Индикатор ошибки может быть очищен только функцией B<clearerr>()."

#. type: Plain text
#: man-pages/man3/ferror.3:101
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns the "
"integer file descriptor used to implement this stream.  The file descriptor "
"is still owned by I<stream> and will be closed when B<fclose>(3)  is "
"called.  Duplicate the file descriptor with B<dup>(2)  before passing it to "
"code that might close it."
msgstr ""
"Функция B<fileno>() исследует параметр I<stream> и возвращает целочисленный "
"файловый дескриптор, который используется для реализации этого потока. "
"Файловый дескриптор продолжает принадлежать I<stream> и будет закрыт при "
"вызове B<fclose>(3). Сделайте копию файлового дескриптора с помощью "
"B<dup>(2) перед передачей его коду, который может его закрыть."

#. type: Plain text
#: man-pages/man3/ferror.3:114
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a "
"valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""
"Данные функции не должны завершаться с ошибкой и поэтому не устанавливают "
"значение внешней переменной I<errno> (тем не менее, в случае с B<fileno>(), "
"если аргумент не является корректным потоком, возвращается -1 и I<errno> "
"приравнивается значение B<EBADF>)."

#. type: tbl table
#: man-pages/man3/ferror.3:125
#, no-wrap
msgid ""
"B<clearerr>(),\n"
"B<feof>(),\n"
msgstr ""
"B<clearerr>(),\n"
"B<feof>(),\n"

#. type: tbl table
#: man-pages/man3/ferror.3:128
#, no-wrap
msgid ""
"B<ferror>(),\n"
"B<fileno>()"
msgstr ""
"B<ferror>(),\n"
"B<fileno>()"

#. type: Plain text
#: man-pages/man3/ferror.3:137
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89, "
"C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""
"Функции B<clearerr>(), B<feof>() и B<ferror>() соответствует стандартам C89, "
"C99, POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/ferror.3:141
msgid "The function B<fileno>()  conforms to POSIX.1-2001 and POSIX.1-2008."
msgstr "Функция B<fileno>() соответствует POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/ferror.3:145
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fgetc.3:27
#, no-wrap
msgid "FGETC"
msgstr "FGETC"

#. type: Plain text
#: man-pages/man3/fgetc.3:30
msgid "fgetc, fgets, getc, getchar, ungetc - input of characters and strings"
msgstr ""
"fgetc, fgets, getc, getchar, ungetc - функции для ввода символов и строк"

#. type: Plain text
#: man-pages/man3/fgetc.3:35
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr "B<int fgetc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:37
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:39
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr "B<int getc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:41
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr "B<int getchar(void);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetc.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""
"Функция B<fgetc>() считывает очередной символ из потока I<stream> и "
"возвращает I<unsigned char> преобразованный в I<int>, или B<EOF> при "
"достижении конца файла или при возникновении ошибки."

#. type: Plain text
#: man-pages/man3/fgetc.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""
"Функция B<getc>() похожа на B<fgetc>(), но она может быть реализована как "
"макрос, который определяет состояние I<stream> более одного раза."

#. type: Plain text
#: man-pages/man3/fgetc.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr "Функция B<getchar>() эквивалентна B<getc(>I<stdin>B<)>."

#. type: Plain text
#: man-pages/man3/fgetc.3:80
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream> "
"and stores them into the buffer pointed to by I<s>.  Reading stops after an "
"B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  A "
"terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character "
"in the buffer."
msgstr ""
"Функция B<fgets>() считывает максимум I<size> -1 символов из I<stream> и "
"записывает их в буфер, на который указывает I<s>. Чтение прерывается по "
"достижении B<EOF> или символа новой строки. Если получен символ новой "
"строки, то он заносится в буфер. В конец буфера после последнего символа "
"добавляется завершающий байт null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/fgetc.3:91
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will "
"be returned in reverse order; only one pushback is guaranteed."
msgstr ""
"Функция B<ungetc>() заносит I<c> обратно в I<stream>, преобразует в "
"I<unsigned char>, если это возможно для дальнейших операций чтения. "
"Занесённые обратно символы будут возвращаться в обратном порядке; "
"гарантируется только одно занесение символов."

#. type: Plain text
#: man-pages/man3/fgetc.3:96
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""
"Вызовы функций, описанные здесь, могут смешиваться друг с другом и с другими "
"функциями ввода из библиотеки I<stdio> для того же потока ввода."

#. type: Plain text
#: man-pages/man3/fgetc.3:111
msgid ""
"B<fgetc>(), B<getc>()  and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""
"Функции B<fgetc>(), B<getc>() и B<getchar>() возвращают символ, считанный "
"как I<unsigned char> и преобразованный в I<int>, или B<EOF> по достижении "
"конца файла или при возникновении ошибки."

#. type: Plain text
#: man-pages/man3/fgetc.3:117
msgid ""
"B<fgets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read."
msgstr ""
"Функция B<fgets>() возвращает I<s> при удачном выполнении и NULL при ошибке "
"или если достигнут конец файла, а символы остались несчитанными."

#. type: Plain text
#: man-pages/man3/fgetc.3:124
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr ""
"При успешном выполнении функция B<ungetc>() возвращает I<c> или B<EOF> при "
"ошибке."

#. type: tbl table
#: man-pages/man3/fgetc.3:136
#, no-wrap
msgid ""
"B<fgetc>(),\n"
"B<fgets>(),\n"
"B<getc>(),\n"
msgstr ""
"B<fgetc>(),\n"
"B<fgets>(),\n"
"B<getc>(),\n"

#. type: tbl table
#: man-pages/man3/fgetc.3:139
#, no-wrap
msgid ""
"B<getchar>(),\n"
"B<ungetc>()"
msgstr ""
"B<getchar>(),\n"
"B<ungetc>()"

#. type: Plain text
#: man-pages/man3/fgetc.3:151
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""
"Не рекомендуется чередовать вызовы функций ввода библиотеки I<stdio> с "
"низкоуровневыми вызовами B<read>(2) для дескриптора файла, связанного с "
"потоком ввода; результат этого будет неопределённым и, скорее всего, не тем, "
"который ожидается."

#. type: Plain text
#: man-pages/man3/fgetc.3:167
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<gets>(3), "
"B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"

#. type: TH
#: man-pages/man3/fflush.3:45
#, no-wrap
msgid "FFLUSH"
msgstr "FFLUSH"

#. type: Plain text
#: man-pages/man3/fflush.3:48
msgid "fflush - flush a stream"
msgstr "fflush - сбрасывает поток"

#. type: Plain text
#: man-pages/man3/fflush.3:52
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr "B<int fflush(FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/fflush.3:58
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function."
msgstr ""
"Для потоков вывода функция B<fflush>() принудительно записывает все "
"буферизированные в пользовательском пространстве данные в устройство вывода "
"данных или корректирует I<stream> посредством определённой для него функции "
"записи."

#. type: Plain text
#: man-pages/man3/fflush.3:64
msgid ""
"For input streams associated with seekable files (e.g., disk files, but not "
"pipes or terminals), B<fflush>()  discards any buffered data that has been "
"fetched from the underlying file, but has not been consumed by the "
"application."
msgstr ""
"Для потоков ввода, связанных с файлами, в которых возможно позиционирование "
"(например, дисковые файлы, но не каналы или терминалы), функция B<fflush>() "
"отбрасывает все буферизированные данные, которые были получены из "
"соответствующего файла, но не обработаны приложением."

#. type: Plain text
#: man-pages/man3/fflush.3:66
msgid "The open status of the stream is unaffected."
msgstr "При этом поток остается открытым."

#.  mtk: POSIX specifies that only output streams are flushed for this case.
#.  Also verified for glibc by experiment.
#. type: Plain text
#: man-pages/man3/fflush.3:76
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""
"Если аргумент I<stream> равен NULL, то B<fflush>() сбрасывает данные всех "
"открытых потоков вывода."

#. type: Plain text
#: man-pages/man3/fflush.3:86
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении возвращается нулевое значение. В противном случае "
"возвращается B<EOF> и I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/fflush.3:91
msgid "I<stream> is not an open stream, or is not open for writing."
msgstr "Поток I<stream> не открыт или не открыт для записи."

#. type: Plain text
#: man-pages/man3/fflush.3:98
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""
"Функция I<fflush>() может завершиться с ошибкой и присвоить I<errno> любое "
"значение из определённых для B<write>(2)."

#. type: tbl table
#: man-pages/man3/fflush.3:108
#, no-wrap
msgid "B<fflush>()"
msgstr "B<fflush>()"

#. type: Plain text
#: man-pages/man3/fflush.3:112
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C89, C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/fflush.3:115
msgid ""
"POSIX.1-2001 did not specify the behavior for flushing of input streams, but "
"the behavior is specified in POSIX.1-2008."
msgstr ""
"В POSIX.1-2001 не определено поведение для сброса потоков ввода, но но это "
"описано в POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/fflush.3:124
msgid ""
"Note that B<fflush>()  flushes only the user-space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"Заметим, что B<fflush>() сбрасывает буферы только пользовательского "
"пространства, заданные библиотекой Си. Чтобы гарантировать, что данные "
"действительно физически сохранены на диске, буферы ядра также должны быть "
"сохранены, например, с помощью вызова B<sync>(2) или B<fsync>(2)."

#. type: Plain text
#: man-pages/man3/fflush.3:132
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fileno>(3), "
"B<fopen>(3), B<setbuf>(3), B<unlocked_stdio>(3)"
msgstr ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fileno>(3), "
"B<fopen>(3), B<setbuf>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fputws.3:16
#, no-wrap
msgid "FPUTWS"
msgstr "FPUTWS"

#. type: Plain text
#: man-pages/man3/fputws.3:19
msgid "fputws - write a wide-character string to a FILE stream"
msgstr "fputws - записывает строку широких символов в поток FILE"

#. type: Plain text
#: man-pages/man3/fputws.3:24
#, no-wrap
msgid "B<int fputws(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputws(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fputws.3:34
msgid ""
"The B<fputws>()  function is the wide-character equivalent of the "
"B<fputs>(3)  function.  It writes the wide-character string starting at "
"I<ws>, up to but not including the terminating null wide character (L\\(aq"
"\\e0\\(aq), to I<stream>."
msgstr ""
"Функция B<fputws>() — эквивалент B<fputs>(3) для строк широких символов. Она "
"записывает строку широких символов, начинающуюся с I<ws> до, но не включая, "
"завершающего широкого символа null (L\\(aq\\e0\\(aq), в I<stream>."

#. type: Plain text
#: man-pages/man3/fputws.3:43
msgid ""
"The B<fputws>()  function returns a nonnegative integer if the operation was "
"successful, or -1 to indicate an error."
msgstr ""
"Функция B<fputws>() возвращает неотрицательное целое число, если операция "
"завершилась успешно, или -1 для обозначения ошибки."

#. type: tbl table
#: man-pages/man3/fputws.3:53
#, no-wrap
msgid "B<fputws>()"
msgstr "B<fputws>()"

#. type: Plain text
#: man-pages/man3/fputws.3:65
msgid ""
"The behavior of B<fputws>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fputws>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fputws.3:73
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fputws>()  will actually write the multibyte "
"string corresponding to the wide-character string I<ws>."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fputws>() на самом деле пишет многобайтовую "
"строку, соответствующую строке широких символов I<ws>."

#. type: Plain text
#: man-pages/man3/fputws.3:75
msgid "B<fputwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fputwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/ffs.3:33
#, no-wrap
msgid "FFS"
msgstr "FFS"

#. type: Plain text
#: man-pages/man3/ffs.3:36
msgid "ffs, ffsl, ffsll - find first bit set in a word"
msgstr "ffs, ffsl, ffsll - ищет первый установленный бит в слове"

#. type: Plain text
#: man-pages/man3/ffs.3:39
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr "B<#include E<lt>strings.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:41
#, no-wrap
msgid "B<int ffs(int >I<i>B<);>\n"
msgstr "B<int ffs(int >I<i>B<);>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:43
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:45
#, no-wrap
msgid "B<int ffsl(long int >I<i>B<);>\n"
msgstr "B<int ffsl(long int >I<i>B<);>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:47
#, no-wrap
msgid "B<int ffsll(long long int >I<i>B<);>\n"
msgstr "B<int ffsll(long long int >I<i>B<);>\n"

#. type: Plain text
#: man-pages/man3/ffs.3:57
msgid "B<ffs>():"
msgstr "B<ffs>():"

#. type: TP
#: man-pages/man3/ffs.3:58
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ffs.3:64
#, no-wrap
msgid ""
"    _XOPEN_SOURCE E<gt>= 700\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"    _XOPEN_SOURCE E<gt>= 700\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: TP
#: man-pages/man3/ffs.3:64
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ffs.3:67
msgid "none"
msgstr "ни одного"

#. type: Plain text
#: man-pages/man3/ffs.3:71
msgid "B<ffsl>(), B<ffsll>():"
msgstr "B<ffsl>(), B<ffsll>():"

#. type: TP
#: man-pages/man3/ffs.3:73
#, no-wrap
msgid "Since glibc 2.27:"
msgstr "Начиная с glibc 2.27:"

#.  glibc commit 68fe16dd327c895c08b9ee443b234c49c13b36e9
#. type: Plain text
#: man-pages/man3/ffs.3:77
#, no-wrap
msgid "    _DEFAULT_SOURCE\n"
msgstr "    _DEFAULT_SOURCE\n"

#. type: TP
#: man-pages/man3/ffs.3:77
#, no-wrap
msgid "Before glibc 2.27:"
msgstr "До glibc 2.27:"

#. type: Plain text
#: man-pages/man3/ffs.3:80
#, no-wrap
msgid "    _GNU_SOURCE\n"
msgstr "    _GNU_SOURCE\n"

#. type: Plain text
#: man-pages/man3/ffs.3:97
msgid ""
"The B<ffs>()  function returns the position of the first (least significant) "
"bit set in the word I<i>.  The least significant bit is position 1 and the "
"most significant position is, for example, 32 or 64.  The functions "
"B<ffsll>()  and B<ffsl>()  do the same but take arguments of possibly "
"different size."
msgstr ""
"Функция B<ffs>() возвращает позицию первого (считая с наименее значимого) "
"установленного бита в слове I<i>. Наименее значимый бит находится в позиции "
"номер 1, а наиболее значимый — в позиции (как пример) номер 32 или 64. "
"Функции B<ffsll>() и B<ffsl>() делают то же самое, но имеют аргументы "
"возможно других размеров."

#. type: Plain text
#: man-pages/man3/ffs.3:101
msgid ""
"These functions return the position of the first bit set, or 0 if no bits "
"are set in I<i>."
msgstr ""
"Эти функции возвращают положение первого установленного бита или 0, если в "
"I<i> не установлено ни одного бита."

#. type: tbl table
#: man-pages/man3/ffs.3:113
#, no-wrap
msgid ""
"B<ffs>(),\n"
"B<ffsl>(),\n"
"B<ffsll>()"
msgstr ""
"B<ffs>(),\n"
"B<ffsl>(),\n"
"B<ffsll>()"

#. type: Plain text
#: man-pages/man3/ffs.3:118
msgid "B<ffs>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "B<ffs>(): POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: man-pages/man3/ffs.3:124
msgid "The B<ffsl>()  and B<ffsll>()  functions are glibc extensions."
msgstr "Функции B<ffsl>() и B<ffsll>() являются расширениями glibc."

#. type: Plain text
#: man-pages/man3/ffs.3:127
msgid "BSD systems have a prototype in I<E<lt>string.hE<gt>>."
msgstr "В системах BSD прототип указан в I<E<lt>string.hE<gt>>."

#. type: Plain text
#: man-pages/man3/ffs.3:128
msgid "B<memchr>(3)"
msgstr "B<memchr>(3)"

#. type: TH
#: man-pages/man3/fmod.3:35
#, no-wrap
msgid "FMOD"
msgstr "FMOD"

#. type: Plain text
#: man-pages/man3/fmod.3:38
msgid "fmod, fmodf, fmodl - floating-point remainder function"
msgstr ""
"fmod, fmodf, fmodl - функция получения остатка от деления числа с плавающей "
"запятой"

#. type: Plain text
#: man-pages/man3/fmod.3:45
#, no-wrap
msgid ""
"B<double fmod(double >I<x>B<, double >I<y>B<);>\n"
"B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"B<double fmod(double >I<x>B<, double >I<y>B<);>\n"
"B<float fmodf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double fmodl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/fmod.3:57
msgid "B<fmodf>(), B<fmodl>():"
msgstr "B<fmodf>(), B<fmodl>():"

#. type: Plain text
#: man-pages/man3/fmod.3:81
msgid ""
"These functions compute the floating-point remainder of dividing I<x> by "
"I<y>.  The return value is I<x> - I<n> * I<y>, where I<n> is the quotient of "
"I<x> / I<y>, rounded toward zero to an integer."
msgstr ""
"Эти функции вычисляют остаток деления числа с плавающей запятой I<x> на "
"I<y>. Возвращаемое значение: I<x> - I<n> * I<y>, где I<n> — частное I<x> / "
"I<y>, округлённое к нулю до ближайшего целого числа."

#. type: Plain text
#: man-pages/man3/fmod.3:90
msgid ""
"On success, these functions return the value I<x>\\ -\\ I<n>*I<y>, for some "
"integer I<n>, such that the returned value has the same sign as I<x> and a "
"magnitude less than the magnitude of I<y>."
msgstr ""
"При успешном выполнении функции возвращают значение I<x>\\ -\\ I<n>*I<y> для "
"некоторого целого I<n>; при этом возвращаемое значение имеет тот же знак что "
"и I<x>, а абсолютное значение меньше абсолютного значения I<y>."

#. type: Plain text
#: man-pages/man3/fmod.3:102
msgid "If I<x> is an infinity, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> стремится к бесконечности, то будет сгенерирована ошибка выхода за "
"пределы области, а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fmod.3:108
msgid "If I<y> is zero, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<y> равно 0, то будет сгенерирована ошибка выхода за пределы области, "
"а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fmod.3:114
msgid "If I<x> is +0 (-0), and I<y> is not zero, +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0) и I<y> не равно, то возвращается +0 (-0)."

#. type: TP
#: man-pages/man3/fmod.3:121
#, no-wrap
msgid "Domain error: I<x> is an infinity"
msgstr "Ошибка области: I<x> стремится к бесконечности"

#. type: Plain text
#: man-pages/man3/fmod.3:130
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM> (но см. ДЕФЕКТЫ). Возникает исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#. type: TP
#: man-pages/man3/fmod.3:130
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr "Ошибка области: I<y> равно 0"

#.  POSIX.1 documents an optional underflow error, but AFAICT it doesn't
#.  (can't?) occur -- mtk, Jul 2008
#. type: Plain text
#: man-pages/man3/fmod.3:140
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM>. Вызывается исключение неправильной "
"плавающей точки (B<FE_INVALID>)."

#. type: tbl table
#: man-pages/man3/fmod.3:152
#, no-wrap
msgid ""
"B<fmod>(),\n"
"B<fmodf>(),\n"
"B<fmodl>()"
msgstr ""
"B<fmod>(),\n"
"B<fmodf>(),\n"
"B<fmodl>()"

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6784
#. type: Plain text
#: man-pages/man3/fmod.3:169
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred for an infinite I<x>."
msgstr ""
"До версии 2.10 в реализации glibc при возникновении ошибки области "
"переменная I<errno> не устанавливалась в значение B<EDOM> для бесконечного "
"I<x>."

#. type: Plain text
#: man-pages/man3/fmod.3:170
msgid "B<remainder>(3)"
msgstr "B<remainder>(3)"

#. type: TH
#: man-pages/man3/ftw.3:36
#, no-wrap
msgid "FTW"
msgstr "FTW"

#. type: Plain text
#: man-pages/man3/ftw.3:39
msgid "ftw, nftw - file tree walk"
msgstr "ftw, nftw - обход файлового дерева"

#. type: Plain text
#: man-pages/man3/ftw.3:42 man-pages/man3/ftw.3:49
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr "B<#include E<lt>ftw.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:47
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:63
msgid "B<nftw>(): _XOPEN_SOURCE E<gt>= 500"
msgstr "B<nftw>(): _XOPEN_SOURCE E<gt>= 500"

#. type: Plain text
#: man-pages/man3/ftw.3:70
msgid ""
"B<nftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By "
"default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""
"Функция B<nftw>() обходит дерево каталогов, начиная с указанного в "
"I<dirpath>, и для каждого элемента дерева однократно вызывает I<fn>(). По "
"умолчанию каталоги обрабатываются раньше файлов и подкаталогов, которые в "
"них содержатся (предварительный обход)."

#. type: Plain text
#: man-pages/man3/ftw.3:83
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<nftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<nftw>()  will become "
"slower because directories have to be closed and reopened.  B<nftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""
"Чтобы избежать использования всех файловых дескрипторов вызывающего "
"процесса, в I<nopenfd> задаётся максимальное количество одновременно "
"открываемых B<nftw>() каталогов. Когда это количество превышается, работа "
"B<nftw>() немного замедляется, так как каталоги будут закрываться и снова "
"открываться. Функция B<nftw>() использует не более одного файлового "
"дескриптора для работы с каждым уровнем дерева каталогов."

#. type: Plain text
#: man-pages/man3/ftw.3:111
msgid ""
"For each entry found in the tree, B<nftw>()  calls I<fn>() with four "
"arguments: I<fpath>, I<sb>, I<typeflag>, and I<ftwbuf>.  I<fpath> is the "
"pathname of the entry, and is expressed either as a pathname relative to the "
"calling process's current working directory at the time of the call to "
"B<nftw>(), if I<dirpath> was expressed as a relative pathname, or as an "
"absolute pathname, if I<dirpath> was expressed as an absolute pathname.  "
"I<sb> is a pointer to the I<stat> structure returned by a call to "
"B<stat>(2)  for I<fpath>."
msgstr ""
"Для каждого найденного элемента дерева B<nftw>() вызывает функцию B<fn>() с "
"четырьмя аргументами: I<fpath>, I<sb>, I<fpath> и I<ftwbuf>. В I<fpath> "
"указывается полное имя элемента в виде, или пути относительно рабочего "
"каталога вызывающего процесса на момент вызова B<nftw>() (если I<dirpath> "
"указан в виде относительного пути), или абсолютного пути (если I<dirpath> "
"указан в виде абсолютного пути). В I<sb> задаётся указатель на структуру "
"I<stat>, возвращаемую вызовом B<stat>(2) для I<fpath>."

#. type: Plain text
#: man-pages/man3/ftw.3:117
msgid ""
"The I<typeflag> argument passed to I<fn>()  is an integer that has one of "
"the following values:"
msgstr ""
"Аргумент I<typeflag>, передаваемый в I<fn>(), представляет собой целое "
"число, которое может быть одним из следующих значений:"

#. type: TP
#: man-pages/man3/ftw.3:117
#, no-wrap
msgid "B<FTW_F>"
msgstr "B<FTW_F>"

#. type: Plain text
#: man-pages/man3/ftw.3:121
msgid "I<fpath> is a regular file."
msgstr "I<fpath> обычный файл"

#. type: TP
#: man-pages/man3/ftw.3:121
#, no-wrap
msgid "B<FTW_D>"
msgstr "B<FTW_D>"

#. type: Plain text
#: man-pages/man3/ftw.3:125
msgid "I<fpath> is a directory."
msgstr "I<fpath> каталог"

#. type: TP
#: man-pages/man3/ftw.3:125
#, no-wrap
msgid "B<FTW_DNR>"
msgstr "B<FTW_DNR>"

#. type: Plain text
#: man-pages/man3/ftw.3:129
msgid "I<fpath> is a directory which can't be read."
msgstr "I<fpath> каталог, который не может быть прочитан"

#. type: TP
#: man-pages/man3/ftw.3:129
#, no-wrap
msgid "B<FTW_DP>"
msgstr "B<FTW_DP>"

#. type: Plain text
#: man-pages/man3/ftw.3:143
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  (If "
"B<FTW_DEPTH> was not specified in I<flags>, then directories will always be "
"visited with I<typeflag> set to B<FTW_D>.)  All of the files and "
"subdirectories within I<fpath> have been processed."
msgstr ""
"I<fpath> является каталогом, и в I<flags> установлен B<FTW_DEPTH> (если "
"B<FTW_DEPTH> отсутствует в I<flags>, то каталоги всегда будут "
"просматриваться с I<typeflag> равным B<FTW_D>). Обработаны все файлы и "
"подкаталоги в I<fpath>."

#. type: TP
#: man-pages/man3/ftw.3:143
#, no-wrap
msgid "B<FTW_NS>"
msgstr "B<FTW_NS>"

#. type: Plain text
#: man-pages/man3/ftw.3:160
msgid ""
"The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  The "
"probable cause for this is that the caller had read permission on the parent "
"directory, so that the filename I<fpath> could be seen, but did not have "
"execute permission, so that the file could not be reached for B<stat>(2).  "
"The contents of the buffer pointed to by I<sb> are undefined."
msgstr ""
"Вызов B<stat>(2) завершился с ошибкой для I<fpath>, который не является "
"символьной ссылкой. Вероятно, проблема в том, что вызывающий имеет право на "
"чтение родительского каталога, и поэтому файл с именем I<fpath> доступен, но "
"не имеет права выполнения, и поэтому файл недоступен для B<stat>(2). "
"Содержимое буфера, указываемого I<sb>, не определено."

#. type: TP
#: man-pages/man3/ftw.3:160
#, no-wrap
msgid "B<FTW_SL>"
msgstr "B<FTW_SL>"

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: man-pages/man3/ftw.3:171
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""
"I<fpath> является символьной ссылкой и в I<flags> установлен B<FTW_PHYS>."

#. type: TP
#: man-pages/man3/ftw.3:171
#, no-wrap
msgid "B<FTW_SLN>"
msgstr "B<FTW_SLN>"

#. type: Plain text
#: man-pages/man3/ftw.3:184
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)  On most implementations, in this case the "
"I<sb> argument passed to I<fn>()  contains information returned by "
"performing B<lstat>(2)  on the symbolic link.  For the details on Linux, see "
"BUGS."
msgstr ""
"Значение I<fpath> является символьной ссылкой, указывающей на несуществующий "
"файл (это может произойти, только если не установлен флаг B<FTW_PHYS>). В "
"большинстве реализаций в этом случае аргумент I<sb>, переданный I<fn>(), "
"содержит информацию, возвращаемую вызовом B<lstat>(2) для символьной ссылки. "
"Подробней для Linux смотрите в разделе ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man3/ftw.3:192
msgid ""
"The fourth argument (I<ftwbuf>)  that B<nftw>()  supplies when calling "
"I<fn>()  is a pointer to a structure of type I<FTW>:"
msgstr ""
"Четвёртый аргумент (I<ftwbuf>), передаваемый B<nftw>() при вызове I<fn>(), "
"является структурой типа I<FTW>:"

#. type: Plain text
#: man-pages/man3/ftw.3:199
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"

#. type: Plain text
#: man-pages/man3/ftw.3:212
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""
"I<base> — смещение на имя файла (т.е. базовая часть) в пути, заданном в "
"I<fpath>.  I<level> — глубина I<fpath> в дереве каталогов относительно корня "
"дерева (I<dirpath> имеет глубину 0)."

#. type: Plain text
#: man-pages/man3/ftw.3:223
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<nftw>().  As long as I<fn>() returns 0, "
"B<nftw>()  will continue either until it has traversed the entire tree, in "
"which case it will return zero, or until it encounters an error (such as a "
"B<malloc>(3)  failure), in which case it will return -1."
msgstr ""
"Для остановки обхода дерева I<fn>() возвращает ненулевое значение; оно "
"станет возвращаемым значением для B<nftw>(). Пока I<fn>() возвращает 0, "
"B<nftw>() будет продолжать свой поиск до полного обхода дерева (в этом "
"случае она возвратит ноль), или пока не возникнет ошибка (например, из-за "
"B<malloc>(3)). В этом случае функция возвратит значение -1."

#. type: Plain text
#: man-pages/man3/ftw.3:233
msgid ""
"Because B<nftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler "
"set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr ""
"Так как B<nftw>() использует динамические структуры данных, то единственным "
"безопасным способом для выхода из процесса обхода дерева будет возврат "
"ненулевого значения из I<fn>(). Для завершения обхода по сигналу без утечек "
"памяти в обработчике нужно устанавливать глобальный флаг, проверяемый "
"I<fn>(). I<Не> используйте B<longjmp>(3) кроме как для завершения программы."

#. type: Plain text
#: man-pages/man3/ftw.3:238
msgid ""
"The I<flags> argument of B<nftw>()  is formed by ORing zero or more of the "
"following flags:"
msgstr ""
"Значение аргумента I<flags> в B<nftw>() составляется логическим сложением 0 "
"или нескольких следующих флагов:"

#. type: TP
#: man-pages/man3/ftw.3:238
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr "B<FTW_ACTIONRETVAL> (начиная с glibc 2.3.3)"

#. type: Plain text
#: man-pages/man3/ftw.3:247
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value "
"from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""
"Если этот флаг, имеющийся только в glibc, не задан, то B<nftw>() по другому "
"обрабатывает полученное от I<fn>() значение. Вызов I<fn>() должен возвращать "
"одно из следующих значений:"

#. type: TP
#: man-pages/man3/ftw.3:248
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr "B<FTW_CONTINUE>"

#. type: Plain text
#: man-pages/man3/ftw.3:253
msgid "Instructs B<nftw>()  to continue normally."
msgstr "Указывает B<nftw>() продолжать обычную работу."

#. type: TP
#: man-pages/man3/ftw.3:253
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr "B<FTW_SKIP_SIBLINGS>"

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: man-pages/man3/ftw.3:261
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""
"При возврате этого значения родственные элементы пропускаются и продолжается "
"обход родителя."

#. type: TP
#: man-pages/man3/ftw.3:261
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr "B<FTW_SKIP_SUBTREE>"

#. type: Plain text
#: man-pages/man3/ftw.3:269
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from "
"being passed as arguments to I<fn>().  B<nftw>()  continues processing with "
"the next sibling of the directory."
msgstr ""
"Если I<fn>() вызывается для элемента, являющегося каталогом (I<typeflag> "
"равно B<FTW_D>), то объекты внутри каталога не будут переданы I<fn>() в "
"качестве аргументов. B<nftw>() продолжит обход со следующего родственного "
"элемента каталога."

#. type: TP
#: man-pages/man3/ftw.3:269
#, no-wrap
msgid "B<FTW_STOP>"
msgstr "B<FTW_STOP>"

#. type: Plain text
#: man-pages/man3/ftw.3:275
msgid ""
"Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr ""
"Заставляет B<nftw>() немедленно завершить работу со значением B<FTW_STOP>."

#. type: Plain text
#: man-pages/man3/ftw.3:278
msgid ""
"Other return values could be associated with new actions in the future; "
"I<fn>() should not return values other than those listed above."
msgstr ""
"В будущем могут появиться другие возвращаемые значения для новых действий; "
"I<fn>() не должна возвращать значений, отличных от перечисленных выше."

#. type: Plain text
#: man-pages/man3/ftw.3:287
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""
"Чтобы получить определение B<FTW_ACTIONRETVAL> из I<E<lt>ftw.hE<gt>>, должен "
"быть определён макрос тестирования свойств B<_GNU_SOURCE>."

#. type: TP
#: man-pages/man3/ftw.3:288
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr "B<FTW_CHDIR>"

#. type: Plain text
#: man-pages/man3/ftw.3:299
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides.  (Specifying this flag has no effect on the "
"pathname that is passed in the I<fpath> argument of I<fn>.)"
msgstr ""
"Если установлен этот флаг, то будет выполняться B<chdir>(2) для каждого "
"каталога перед обработкой его содержимого. Это полезно, если программе "
"требуется выполнить какое-то действие в каталоге, в котором расположен "
"I<fpath> (наличие данного флага не влияет на путь, который передаётся в "
"I<fpath> аргумента I<fn>)."

#. type: TP
#: man-pages/man3/ftw.3:299
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr "B<FTW_DEPTH>"

#. type: Plain text
#: man-pages/man3/ftw.3:305
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""
"Если установлен этот флаг, то производить обход в обратном порядке, т.е. "
"вызывать I<fn>() для обработки самого каталога I<после> обработки "
"содержимого его подкаталогов (по умолчанию каждый каталог обрабатывается "
"I<раньше> своего содержимого)."

#. type: TP
#: man-pages/man3/ftw.3:305
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr "B<FTW_MOUNT>"

#. type: Plain text
#: man-pages/man3/ftw.3:309
msgid ""
"If set, stay within the same filesystem (i.e., do not cross mount points)."
msgstr ""
"Если установлен этот флаг, то оставаться в пределах одной файловой системы "
"(т.е. не переходить в другую точку монтирования)."

#. type: TP
#: man-pages/man3/ftw.3:309
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr "B<FTW_PHYS>"

#. type: Plain text
#: man-pages/man3/ftw.3:314
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set, "
"symbolic links are followed, but no file is reported twice."
msgstr ""
"Если установлен этот флаг, то не следовать по символьным ссылкам (то, что "
"обычно нужно). Если флаг не задан, то выполняется переход по символьным "
"ссылкам, но ни один файл не будет обработан дважды."

#. type: Plain text
#: man-pages/man3/ftw.3:319
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function "
"I<fn>()  is never called for a directory that would be a descendant of "
"itself."
msgstr ""
"Если B<FTW_PHYS> не задан, но задан B<FTW_DEPTH>, то функция I<fn>() никогда "
"не будет вызвана для каталога, который является потомком самого себя."

#. type: SS
#: man-pages/man3/ftw.3:319
#, no-wrap
msgid "ftw()"
msgstr "ftw()"

#. type: Plain text
#: man-pages/man3/ftw.3:324
msgid ""
"B<ftw>()  is an older function that offers a subset of the functionality of "
"B<nftw>().  The notable differences are as follows:"
msgstr ""
"Функция B<ftw>() является устаревшей и предоставляет только часть "
"возможностей B<nftw>(). Основные отличия:"

#. type: Plain text
#: man-pages/man3/ftw.3:334
msgid ""
"B<ftw>()  has no I<flags> argument.  It behaves the same as when B<nftw>()  "
"is called with I<flags> specified as zero."
msgstr ""
"В B<ftw>() нет аргумента I<flags>. Она действует также, как если бы "
"B<nftw>() вызвали со значением I<flags> равным нулю."

#. type: Plain text
#: man-pages/man3/ftw.3:338
msgid "The callback function, I<fn>(), is not supplied with a fourth argument."
msgstr "Функции обратного вызова I<fn>() не передаётся четвёртый аргумент."

#. type: Plain text
#: man-pages/man3/ftw.3:350
msgid ""
"The range of values that is passed via the I<typeflag> argument supplied to "
"I<fn>()  is smaller: just B<FTW_F>, B<FTW_D>, B<FTW_DNR>, B<FTW_NS>, and "
"(possibly)  B<FTW_SL>."
msgstr ""
"Диапазон значений, передаваемый в аргументе I<typeflag> для I<fn>() меньше: "
"B<FTW_F>, B<FTW_D>, B<FTW_DNR>, B<FTW_NS> и (возможно) B<FTW_SL>."

#. type: Plain text
#: man-pages/man3/ftw.3:352
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr "При успешном выполнении эти функции возвращают 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/ftw.3:359
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""
"Если I<fn>() возвращает ненулевое значение, то обход дерева прекращается и "
"значение, полученное от I<fn>(), возвращается в качестве результата B<ftw>() "
"или B<nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:367
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""
"Если B<nftw>() вызывается с флагом B<FTW_ACTIONRETVAL>, то для прекращения "
"обхода дерева I<fn>() должна вернуть ненулевое значение B<FTW_STOP>, и это "
"значение возвращается в качестве результата B<nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:370
msgid "B<nftw>()  is available under glibc since version 2.1."
msgstr "Функция B<nftw>() доступна в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/ftw.3:380
#, no-wrap
msgid "B<nftw>()"
msgstr "B<nftw>()"

#. type: tbl table
#: man-pages/man3/ftw.3:380
#, no-wrap
msgid "MT-Safe cwd"
msgstr "MT-Safe cwd"

#. type: tbl table
#: man-pages/man3/ftw.3:383
#, no-wrap
msgid "B<ftw>()"
msgstr "B<ftw>()"

#. type: Plain text
#: man-pages/man3/ftw.3:391
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as "
"obsolete."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, SVr4, SUSv1. В POSIX.1-2008 функция B<ftw>() "
"помечена как устаревшая."

#. type: Plain text
#: man-pages/man3/ftw.3:395
msgid ""
"POSIX.1-2008 notes that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""
"В POSIX.1-2008 отмечено, что результат непредсказуем, если I<fn> не "
"сохраняет текущий рабочий каталог."

#. type: Plain text
#: man-pages/man3/ftw.3:401
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""
"Функция B<nftw>() и использование B<FTW_SL> с B<ftw>() впервые появились в "
"SUSv1."

#. type: Plain text
#: man-pages/man3/ftw.3:419
msgid ""
"In some implementations (e.g., glibc), B<ftw>()  will never use B<FTW_SL>, "
"on other systems B<FTW_SL> occurs only for symbolic links that do not point "
"to an existing file, and again on other systems B<ftw>()  will use B<FTW_SL> "
"for each symbolic link.  If I<fpath> is a symbolic link and B<stat>(2)  "
"failed, POSIX.1-2008 states that it is undefined whether B<FTW_NS> or "
"B<FTW_SL> is passed in I<typeflag>.  For predictable results, use B<nftw>()."
msgstr ""
"В некоторых реализациях (например, glibc), B<ftw>() никогда не использует "
"B<FTW_SL>, в других системах B<FTW_SL> возникает только для символьных "
"ссылок, которые не указывают на существующий файл, или даже B<ftw>() будет "
"использовать B<FTW_SL> для каждой символьной ссылки. Если I<fpath> — "
"символьная ссылка и B<stat>(2) завершается с ошибкой, то следуя POSIX.1-2008 "
"нельзя понять что передаётся в I<typeflag>: B<FTW_NS> или B<FTW_SL>. Для "
"предсказуемости результатов используйте B<nftw>()."

#.  FIXME .
#.  https://bugzilla.redhat.com/show_bug.cgi?id=1422736
#.  http://austingroupbugs.net/view.php?id=1121
#. type: Plain text
#: man-pages/man3/ftw.3:458
msgid ""
"In the specification of B<nftw>(), POSIX.1 notes that when B<FTW_NS> is "
"passed as the I<typeflag> argument of I<fn>(), then the contents of the "
"buffer pointed to by the I<sb> argument are undefined.  The standard makes "
"no such statement for the case where B<FTW_SLN> is passed in I<typeflag>, "
"with the implication that the contents of the buffer pointed to by I<sb> are "
"defined.  And indeed this is the case on most implementations: the buffer "
"pointed to by I<sb> contains the results produced by applying B<lstat>(2)  "
"to the symbolic link.  In early glibc, the behavior was the same.  However, "
"since glibc 2.4, the contents of the buffer pointed to by I<sb> are "
"undefined when B<FTW_SLN> is passed in I<typeflag>.  This change I<appears> "
"to be an unintended regression, but it is not (yet) clear if the behavior "
"will be restored to that provided in the original glibc implementation (and "
"on other implementations)."
msgstr ""
"В спецификации POSIX.1 на B<nftw>() отмечено, что при передаче B<FTW_NS> в "
"аргументе I<typeflag> для I<fn>(), содержимое буфера, на который указывает "
"аргумент I<sb>, не определено. Стандарт не утверждает это для случая, когда "
"в I<typeflag> передаётся B<FTW_SLN> и подразумевается, что содержимое "
"буфера, на который указывает I<sb>, является определённым. И действительно, "
"этот так для большинства реализаций: буфер, на который указывает I<sb>, "
"содержит результаты работы B<lstat>(2) для символьной ссылки. В ранних glibc "
"поведение было тем же самым. Однако начиная с glibc 2.4 содержимое буфера, "
"на который указывает I<sb>, не определено при передаче B<FTW_SLN> в "
"I<typeflag>. Это изменение, I<вероятно>, вызовет непреднамеренную регрессию, "
"но (пока) не ясно,  будет ли восстановлено поведение, предоставляемое "
"первоначальной реализацией glibc (и другими реализациями)."

#. type: Plain text
#: man-pages/man3/ftw.3:467
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The "
"second command-line argument can be used to specify characters that control "
"the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""
"Следующая программа обходит дерево каталогов начиная с пути, указанном в "
"первом аргументе командой строки или начиная с текущего каталога, если "
"аргумент не указан. Она отображает различную информацию о каждом файле. Во "
"втором параметре можно указать символы, которые управляют содержимым "
"аргумента I<flags> у B<nftw>()."

#. type: Plain text
#: man-pages/man3/ftw.3:476
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/ftw.3:487
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d \",\n"
"            (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"            (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"            (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"            (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"            ftwbuf-E<gt>level);\n"
msgstr ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d \",\n"
"            (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"            (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"            (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"            (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"            ftwbuf-E<gt>level);\n"

#. type: Plain text
#: man-pages/man3/ftw.3:492
#, no-wrap
msgid ""
"    if (tflag == FTW_NS)\n"
"        printf(\"-------\");\n"
"    else\n"
"        printf(\"%7jd\", (intmax_t) sb-E<gt>st_size);\n"
msgstr ""
"    if (tflag == FTW_NS)\n"
"        printf(\"-------\");\n"
"    else\n"
"        printf(\"%7jd\", (intmax_t) sb-E<gt>st_size);\n"

#. type: Plain text
#: man-pages/man3/ftw.3:495
#, no-wrap
msgid ""
"    printf(\"   %-40s %d %s\\en\",\n"
"            fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
msgstr ""
"    printf(\"   %-40s %d %s\\en\",\n"
"            fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"

#. type: Plain text
#: man-pages/man3/ftw.3:498
#, no-wrap
msgid ""
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""
"    return 0;           /* говорит nftw() продолжать */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/ftw.3:503
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"

#. type: Plain text
#: man-pages/man3/ftw.3:508
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"

#. type: Plain text
#: man-pages/man3/ftw.3:514
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/ftw.3:521
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr "B<stat>(2), B<fts>(3), B<readdir>(3)"

#. type: TH
#: man-pages/man3/fseeko.3:25
#, no-wrap
msgid "FSEEKO"
msgstr "FSEEKO"

#. type: Plain text
#: man-pages/man3/fseeko.3:28
msgid "fseeko, ftello - seek to or report file position"
msgstr "fseeko, ftello - изменить или сообщить положение в файле"

#. type: Plain text
#: man-pages/man3/fseeko.3:33
#, no-wrap
msgid "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: man-pages/man3/fseeko.3:35
#, no-wrap
msgid "B<off_t ftello(FILE *>I<stream>B<);>\n"
msgstr "B<off_t ftello(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fseeko.3:44
msgid "B<fseeko>(), B<ftello>():"
msgstr "B<fseeko>(), B<ftello>():"

#. type: Plain text
#: man-pages/man3/fseeko.3:48
msgid "_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_FILE_OFFSET_BITS\\ ==\\ 64 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/fseeko.3:50
msgid "(defining the obsolete _LARGEFILE_SOURCE macro also works)"
msgstr "(с определением устаревшего макроса _LARGEFILE_SOURCE также сработает)"

#. type: Plain text
#: man-pages/man3/fseeko.3:73
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""
"Функции B<fseeko>() и B<ftello>() идентичны функциям B<fseek>(3) и "
"B<ftell>(3) (смотрите B<fseek>(3)), соответственно, за исключением того, что "
"аргумент I<offset> функции B<fseeko>() и возвращаемое значение функции "
"B<ftello>() вместо типа I<long> имеют тип I<off_t>."

#. type: Plain text
#: man-pages/man3/fseeko.3:86
msgid ""
"On some architectures, both I<off_t> and I<long> are 32-bit types, but "
"defining B<_FILE_OFFSET_BITS> with the value 64 (before including I<any> "
"header files)  will turn I<off_t> into a 64-bit type."
msgstr ""
"На некоторых архитектурах аргументы I<off_t> и I<long> являются 32-битными "
"типами, но если определить B<_FILE_OFFSET_BITS> со значением 64 (до "
"включения I<каких-либо> заголовочных файлов), то I<off_t> станет 64-битным "
"типом."

#. type: Plain text
#: man-pages/man3/fseeko.3:95
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"При успешном выполнении B<fseeko>() возвращает 0, B<ftello>() возвращает "
"текущее смещение. При ошибке возвращается -1, а в I<errno> содержится код "
"ошибки."

#. type: Plain text
#: man-pages/man3/fseeko.3:98
msgid "See the ERRORS in B<fseek>(3)."
msgstr "Смотрите ОШИБКИ в B<fseek>(3)."

#. type: Plain text
#: man-pages/man3/fseeko.3:100
msgid "These functions are available under glibc since version 2.1."
msgstr "Эти функции доступны в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/fseeko.3:111
#, no-wrap
msgid ""
"B<fseeko>(),\n"
"B<ftello>()"
msgstr ""
"B<fseeko>(),\n"
"B<ftello>()"

#. type: Plain text
#: man-pages/man3/fseeko.3:116
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2."
msgstr "POSIX.1-2001, POSIX.1-2008, SUSv2."

#. type: Plain text
#: man-pages/man3/fseeko.3:117
msgid "B<fseek>(3)"
msgstr "B<fseek>(3)"

#. type: TH
#: man-pages/man3/fgetwc.3:18
#, no-wrap
msgid "FGETWC"
msgstr "FGETWC"

#. type: TH
#: man-pages/man3/fgetwc.3:18
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man3/fgetwc.3:21
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr "fgetwc, getwc - считывает широкий символ из потока FILE"

#. type: Plain text
#: man-pages/man3/fgetwc.3:25
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fgetwc.3:28
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetwc.3:43
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the "
"B<fgetc>(3)  function.  It reads a wide character from I<stream> and returns "
"it.  If the end of stream is reached, or if I<ferror(stream)> becomes true, "
"it returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""
"Функция B<fgetwc>() — это эквивалент функции B<fgetc>(3), но для широких "
"символов. Она читает широкий символ из I<stream> и возвращает его. Если "
"достигнут конец потока или значение I<ferror(stream)> истинно, то функция "
"возвращает B<WEOF>. Если при преобразовании в широкий символ возникает "
"ошибка, то значение переменной I<errno> устанавливается равным B<EILSEQ> и "
"возвращается B<WEOF>."

#. type: Plain text
#: man-pages/man3/fgetwc.3:51
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""
"Функция B<getwc>() — это функция, или макрос, идентичный B<fgetwc>(). Она "
"может быть реализована в виде макроса, и может вычислять свой аргумент более "
"одного раза. Вообще нет смысла использовать эту функцию."

#. type: Plain text
#: man-pages/man3/fgetwc.3:63
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<fgetwc>() возвращает следующий широкий символ из потока или "
"B<WEOF>. При ошибке в I<errno> записывается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fgetwc.3:65
msgid "Apart from the usual ones, there is"
msgstr "Кроме обычных могут возникать:"

#. type: TP
#: man-pages/man3/fgetwc.3:65
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: man-pages/man3/fgetwc.3:69
msgid ""
"The data obtained from the input stream does not form a valid character."
msgstr ""
"Данные, полученные из входного потока, не содержат корректного символа."

#. type: tbl table
#: man-pages/man3/fgetwc.3:80
#, no-wrap
msgid ""
"B<fgetwc>(),\n"
"B<getwc>()"
msgstr ""
"B<fgetwc>(),\n"
"B<getwc>()"

#. type: Plain text
#: man-pages/man3/fgetwc.3:91
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fgetwc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fgetwc.3:99
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fgetwc>() на самом деле читает многобайтовую "
"последовательность из потока, а затем преобразует её в широкий символ."

#. type: Plain text
#: man-pages/man3/fgetwc.3:103
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fpathconf.3:42
#, no-wrap
msgid "FPATHCONF"
msgstr "FPATHCONF"

#. type: Plain text
#: man-pages/man3/fpathconf.3:45
msgid "fpathconf, pathconf - get configuration values for files"
msgstr "fpathconf, pathconf - получают параметры настроек для файлов"

#. type: Plain text
#: man-pages/man3/fpathconf.3:51
#, no-wrap
msgid ""
"B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
"B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"
msgstr ""
"B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
"B<long pathconf(const char *>I<path>B<, int >I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpathconf.3:58
msgid ""
"B<fpathconf>()  gets a value for the configuration option I<name> for the "
"open file descriptor I<fd>."
msgstr ""
"B<fpathconf>() получает значение параметра настроек I<name> для открытого "
"дескриптора файла I<fd>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:64
msgid ""
"B<pathconf>()  gets a value for configuration option I<name> for the "
"filename I<path>."
msgstr ""
"B<pathconf>() получает значение параметра настроек I<name> для файла с "
"именем I<path>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:73
msgid ""
"The corresponding macros defined in I<E<lt>unistd.hE<gt>> are minimum "
"values; if an application wants to take advantage of values which may "
"change, a call to B<fpathconf>()  or B<pathconf>()  can be made, which may "
"yield more liberal results."
msgstr ""
"Соответствующие макросы, определённые в I<E<lt>unistd.hE<gt>>, выдают "
"минимальные значения; если приложение собирается использовать изменяющиеся "
"значения, то необходимо вызывать функции B<fpathconf>() или B<pathconf>(), "
"которые выдают более гибкий результат."

#. type: Plain text
#: man-pages/man3/fpathconf.3:78
msgid ""
"Setting I<name> equal to one of the following constants returns the "
"following configuration options:"
msgstr ""
"При установке значения I<name> в следующие константы возвращаются "
"соответствующие им параметры настройки:"

#. type: TP
#: man-pages/man3/fpathconf.3:78
#, no-wrap
msgid "B<_PC_LINK_MAX>"
msgstr "B<_PC_LINK_MAX>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:88
msgid ""
"The maximum number of links to the file.  If I<fd> or I<path> refer to a "
"directory, then the value applies to the whole directory.  The corresponding "
"macro is B<_POSIX_LINK_MAX>."
msgstr ""
"Максимальное количество ссылок на файл. Если I<fd> или I<path> указывают на "
"каталог, то значение применяется ко всему каталогу. Соответствует макросу "
"B<_POSIX_LINK_MAX>."

#. type: TP
#: man-pages/man3/fpathconf.3:88
#, no-wrap
msgid "B<_PC_MAX_CANON>"
msgstr "B<_PC_MAX_CANON>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:97
msgid ""
"The maximum length of a formatted input line, where I<fd> or I<path> must "
"refer to a terminal.  The corresponding macro is B<_POSIX_MAX_CANON>."
msgstr ""
"Максимальная длина отформатированной строки ввода, причём, I<fd> или I<path> "
"должны указывать на терминал. Соответствует макросу B<_POSIX_MAX_CANON>."

#. type: TP
#: man-pages/man3/fpathconf.3:97
#, no-wrap
msgid "B<_PC_MAX_INPUT>"
msgstr "B<_PC_MAX_INPUT>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:106
msgid ""
"The maximum length of an input line, where I<fd> or I<path> must refer to a "
"terminal.  The corresponding macro is B<_POSIX_MAX_INPUT>."
msgstr ""
"Максимальная длина строки ввода, причём, I<fd> или I<path> должны указывать "
"на терминал. Соответствует макросу B<_POSIX_MAX_INPUT>."

#. type: TP
#: man-pages/man3/fpathconf.3:106
#, no-wrap
msgid "B<_PC_NAME_MAX>"
msgstr "B<_PC_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:115
msgid ""
"The maximum length of a filename in the directory I<path> or I<fd> that the "
"process is allowed to create.  The corresponding macro is B<_POSIX_NAME_MAX>."
msgstr ""
"Максимальная длина имени файла в каталоге I<path> или I<fd>, которую "
"разрешено использовать процессу при создании файла. Соответствует макросу "
"B<_POSIX_NAME_MAX>."

#. type: TP
#: man-pages/man3/fpathconf.3:115
#, no-wrap
msgid "B<_PC_PATH_MAX>"
msgstr "B<_PC_PATH_MAX>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:124
msgid ""
"The maximum length of a relative pathname when I<path> or I<fd> is the "
"current working directory.  The corresponding macro is B<_POSIX_PATH_MAX>."
msgstr ""
"Максимальная длина относительного имени файла, где I<path> или I<fd> "
"являются текущим рабочим каталогом. Соответствует макросу B<_POSIX_PATH_MAX>."

#. type: TP
#: man-pages/man3/fpathconf.3:124
#, no-wrap
msgid "B<_PC_PIPE_BUF>"
msgstr "B<_PC_PIPE_BUF>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:138
msgid ""
"The maximum number of bytes that can be written atomically to a pipe of "
"FIFO.  For B<fpathconf>(), I<fd> should refer to a pipe or FIFO.  For "
"B<fpathconf>(), I<path> should refer to a FIFO or a directory; in the latter "
"case, the returned value corresponds to FIFOs created in that directory.  "
"The corresponding macro is B<_POSIX_PIPE_BUF>."
msgstr ""
"Максимальное количество байт, которое может быть атомарно записано в канал "
"FIFO. Для B<fpathconf>() значение I<fd> должно указывать на канал или FIFO. "
"Для B<fpathconf>() значение I<path> должно указывать на FIFO или каталог; в "
"последнем случае возвращаемое значение соответствует FIFO, созданному в этом "
"каталоге. Соответствует макросу B<_POSIX_PIPE_BUF>."

#. type: TP
#: man-pages/man3/fpathconf.3:138
#, no-wrap
msgid "B<_PC_CHOWN_RESTRICTED>"
msgstr "B<_PC_CHOWN_RESTRICTED>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:153
msgid ""
"This returns a positive value if the use of B<chown>(2)  and B<fchown>(2)  "
"for changing a file's user ID is restricted to a process with appropriate "
"privileges, and changing a file's group ID to a value other than the "
"process's effective group ID or one of its supplementary group IDs is "
"restricted to a process with appropriate privileges.  According to POSIX.1, "
"this variable shall always be defined with a value other than -1.  The "
"corresponding macro is B<_POSIX_CHOWN_RESTRICTED>."
msgstr ""
"Возвращает положительное значение, если использование B<chown>(2) и "
"B<fchown>(2) для изменения идентификатора пользователя файла ограничено для "
"процесса с соответствующими правами и изменение идентификатора группы файла "
"на значение, отличающееся от идентификатора эффективной группы процесса или "
"его вспомогательных идентификаторов групп, ограничено для процесса с "
"соответствующими правами. Согласно POSIX.1, эта переменная всегда должна "
"быть определена со значением не равным -1. Соответствует макросу "
"B<_POSIX_CHOWN_RESTRICTED>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:160
msgid ""
"If I<fd> or I<path> refers to a directory, then the return value applies to "
"all files in that directory."
msgstr ""
"Если I<fd> или I<path> указывают на каталог, то возвращаемое значение "
"относится ко всем файлам в этом каталоге."

#. type: TP
#: man-pages/man3/fpathconf.3:160
#, no-wrap
msgid "B<_PC_NO_TRUNC>"
msgstr "B<_PC_NO_TRUNC>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:167
msgid ""
"This returns nonzero if accessing filenames longer than B<_POSIX_NAME_MAX> "
"generates an error.  The corresponding macro is B<_POSIX_NO_TRUNC>."
msgstr ""
"Возвращает ненулевое значение, если при доступе к файловым именам длиннее, "
"чем B<_POSIX_NAME_MAX>, возникает ошибка. Соответствует макросу "
"B<_POSIX_NO_TRUNC>."

#. type: TP
#: man-pages/man3/fpathconf.3:167
#, no-wrap
msgid "B<_PC_VDISABLE>"
msgstr "B<_PC_VDISABLE>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:174
msgid ""
"This returns nonzero if special character processing can be disabled, where "
"I<fd> or I<path> must refer to a terminal."
msgstr ""
"Возвращает ненулевое значение, если обработка спецсимволов может быть "
"отключена, при этом I<fd> или I<path> должны указывать на терминал."

#. type: Plain text
#: man-pages/man3/fpathconf.3:176
msgid "The return value of these functions is one of the following:"
msgstr "Возвращаемым значением этих функций может быть одно из:"

#. type: Plain text
#: man-pages/man3/fpathconf.3:185
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error (for example, B<EINVAL>, indicating that I<name> is invalid)."
msgstr ""
"При ошибке возвращается -1, а в I<errno> содержится код ошибки (например, "
"B<EINVAL> означает, что некорректно I<name>)."

#. type: Plain text
#: man-pages/man3/fpathconf.3:197
msgid ""
"If I<name> corresponds to a maximum or minimum limit, and that limit is "
"indeterminate, -1 is returned and I<errno> is not changed.  (To distinguish "
"an indeterminate limit from an error, set I<errno> to zero before the call, "
"and then check whether I<errno> is nonzero when -1 is returned.)"
msgstr ""
"Если I<name> соответствует максимальному или минимальному ограничителю и "
"этот ограничитель не определён, то возвращается -1 и I<errno> не изменяется "
"(чтобы отличать  неопределённый ограничитель от ошибки, сбросьте I<errno> в "
"ноль пере вызовом, а затем проверьте, что I<errno> не равно нулю, если "
"возвращается -1)."

#. type: Plain text
#: man-pages/man3/fpathconf.3:203
msgid ""
"If I<name> corresponds to an option, a positive value is returned if the "
"option is supported, and -1 is returned if the option is not supported."
msgstr ""
"Если I<name> соответствует параметру, то возвращается положительное "
"значение, если параметр поддерживается и -1, если параметр не поддерживается."

#. type: Plain text
#: man-pages/man3/fpathconf.3:212
msgid ""
"Otherwise, the current value of the option or limit is returned.  This value "
"will not be more restrictive than the corresponding value that was described "
"to the application in I<E<lt>unistd.hE<gt>> or I<E<lt>limits.hE<gt>> when "
"the application was compiled."
msgstr ""
"В противном случае возвращается текущее значение параметра или ограничителя. "
"Это значение будет не более ограничивающем чем соответствующее значение, "
"которое было показано приложению в I<E<lt>unistd.hE<gt>> или I<E<lt>limits."
"hE<gt>> при компиляции."

#. type: Plain text
#: man-pages/man3/fpathconf.3:218
msgid ""
"(B<pathconf>())  Search permission is denied for one of the directories in "
"the path prefix of I<path>."
msgstr "(B<pathconf>()) Запрещён поиск в одном из каталогов пути I<path>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:223
msgid "(B<fpathconf>())  I<fd> is not a valid file descriptor."
msgstr ""
"(B<fpathconf>()) Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man3/fpathconf.3:227
msgid "I<name> is invalid."
msgstr "Неверное значение I<name>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:232
msgid ""
"The implementation does not support an association of I<name> with the "
"specified file."
msgstr "Реализация не поддерживает связь I<name> с указанным файлом."

#. type: TP
#: man-pages/man3/fpathconf.3:232
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:237
msgid ""
"(B<pathconf>())  Too many symbolic links were encountered while resolving "
"I<path>."
msgstr ""
"(B<pathconf>()) Во время определения I<path> встретилось слишком много "
"символьных ссылок."

#. type: TP
#: man-pages/man3/fpathconf.3:237
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man3/fpathconf.3:242
msgid "(B<pathconf>())  I<path> is too long."
msgstr "(B<pathconf>()) Слишком длинное значение аргумента I<path>."

#. type: Plain text
#: man-pages/man3/fpathconf.3:250
msgid ""
"(B<pathconf>())  A component of I<path> does not exist, or I<path> is an "
"empty string."
msgstr ""
"(B<pathconf>()) Компонент пути I<path> не существует или в I<path> указана "
"пустая строка."

#. type: Plain text
#: man-pages/man3/fpathconf.3:256
msgid ""
"(B<pathconf>())  A component used as a directory in I<path> is not in fact a "
"directory."
msgstr ""
"(B<pathconf>()) Компонент пути, использованный как каталог в I<path>, в "
"действительности таковым не является."

#. type: tbl table
#: man-pages/man3/fpathconf.3:267
#, no-wrap
msgid ""
"B<fpathconf>(),\n"
"B<pathconf>()"
msgstr ""
"B<fpathconf>(),\n"
"B<pathconf>()"

#. type: Plain text
#: man-pages/man3/fpathconf.3:277
msgid ""
"Files with name lengths longer than the value returned for I<name> equal to "
"B<_PC_NAME_MAX> may exist in the given directory."
msgstr ""
"Файлы, имена которых длиннее, чем значение, возвращаемое для I<name> и равны "
"B<_PC_NAME_MAX>, могут существовать в заданном каталоге."

#. type: Plain text
#: man-pages/man3/fpathconf.3:280
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""
"Некоторые возвращаемые значения могут быть огромны; соответствующие им "
"объекты невозможно разместить в памяти."

#. type: Plain text
#: man-pages/man3/fpathconf.3:285
msgid "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"
msgstr "B<getconf>(1), B<open>(2), B<statfs>(2), B<confstr>(3), B<sysconf>(3)"

#. type: TH
#: man-pages/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr "FTS"

#. type: Plain text
#: man-pages/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - обход файловой "
"иерархии"

#. type: Plain text
#: man-pages/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"

#. type: Plain text
#: man-pages/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<instr>B<);>\n"
msgstr "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<instr>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<instr>B<);>\n"
msgstr "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<instr>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr "B<int fts_close(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fts.3:80
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" (of type "
"I<FTS\\ *>)  that refers to a file hierarchy \"stream\".  This handle is "
"then supplied to the other fts functions.  The function B<fts_read>()  "
"returns a pointer to a structure describing one of the files in the file "
"hierarchy.  The function B<fts_children>()  returns a pointer to a linked "
"list of structures, each of which describes one of the files contained in a "
"directory in the hierarchy."
msgstr ""
"Функции fts созданы для обхода файловой иерархии. Обзорное описание: функция "
"B<fts_open>() возвращает «описатель» (с типом I<FTS\\ *>), который указывает "
"на «поток» файловой иерархии. Далее он используется другими функциями fts. "
"Функция B<fts_read>() возвращает указатель на структуру, описывающую один из "
"файлов в файловой иерархии. Функция B<fts_children>() возвращает указатель "
"на связанный список структур, каждая из которых описывает один из файлов, "
"содержащихся в каталоге иерархии."

#. type: Plain text
#: man-pages/man3/fts.3:90
msgid ""
"In general, directories are visited two distinguishable times; in preorder "
"(before any of their descendants are visited) and in postorder (after all of "
"their descendants have been visited).  Files are visited once.  It is "
"possible to walk the hierarchy \"logically\" (visiting the files that "
"symbolic links point to)  or physically (visiting the symbolic links "
"themselves), order the walk of the hierarchy or prune and/or revisit "
"portions of the hierarchy."
msgstr ""
"В общем случае, каталоги обходятся двумя разными путями — в прямом порядке "
"(перед тем, как обработаны их потомки) и в обратном порядке (после того, как "
"обработаны все потомки). Файлы обрабатываются только один раз. Возможен "
"«логический» обход иерархии (обрабатываются файлы, на которые указывают "
"символьные ссылки) и «физический» (обрабатываются сами символьные ссылки), "
"то есть обход иерархии сократится или какая-то часть будет пройдена повторно."

#. type: Plain text
#: man-pages/man3/fts.3:107
msgid ""
"Two structures (and associated types) are defined in the include file "
"I<E<lt>fts.hE<gt>>.  The first type is I<FTS>, the structure that represents "
"the file hierarchy itself.  The second type is I<FTSENT>, the structure that "
"represents a file in the file hierarchy.  Normally, an I<FTSENT> structure "
"is returned for every file in the file hierarchy.  In this manual page, "
"\"file\" and \"FTSENT structure\" are generally interchangeable."
msgstr ""
"В файле I<E<lt>fts.hE<gt>> определены две структуры (связанные с ними типы). "
"Первая — структура I<FTS>, представляющая саму иерархию файлов. Вторая — "
"структура I<FTSENT>, представляющая файл в иерархии файлов. Обычно, "
"структура I<FTSENT> возвращается для каждого файла в файловой иерархии. В "
"этой справочной странице понятия «файл» и «структура FTSENT» взаимозаменяемы."

#. type: Plain text
#: man-pages/man3/fts.3:114
msgid ""
"The I<FTSENT> structure contains fields describing a file.  The structure "
"contains at least the following fields (there are additional fields that "
"should be considered private to the implementation):"
msgstr ""
"Структура I<FTSENT> содержит поля, описывающие файл. На имеет, по меньшей "
"мере, следующие поля (есть и дополнительные поля, но для реализации они "
"должны считаться скрытыми):"

#.  Also:
#.      ino_t fts_ino;                  /* inode (only for directories)*/
#.      dev_t fts_dev;                  /* device (only for directories)*/
#.      nlink_t fts_nlink;              /* link count (only for directories)*/
#.      u_short fts_flags;              /* private flags for FTSENT structure */
#.      u_short fts_instr;              /* fts_set() instructions */
#. type: Plain text
#: man-pages/man3/fts.3:140
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short  fts_info;     /* flags for FTSENT structure */\n"
"    char           *fts_accpath;  /* access path */\n"
"    char           *fts_path;     /* root path */\n"
"    short           fts_pathlen;  /* strlen(fts_path) +\n"
"                                     strlen(fts_name) */\n"
"    char           *fts_name;     /* filename */\n"
"    short           fts_namelen;  /* strlen(fts_name) */\n"
"    short           fts_level;    /* depth (-1 to N) */\n"
"    int             fts_errno;    /* file errno */\n"
"    long            fts_number;   /* local numeric value */\n"
"    void           *fts_pointer;  /* local address value */\n"
"    struct _ftsent *fts_parent;   /* parent directory */\n"
"    struct _ftsent *fts_link;     /* next file structure */\n"
"    struct _ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat    *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""
"typedef struct _ftsent {\n"
"    unsigned short  fts_info;     /* флаги для структуры FTSENT */\n"
"    char           *fts_accpath;  /* путь доступа */\n"
"    char           *fts_path;     /* начальный путь */\n"
"    short           fts_pathlen;  /* strlen(fts_path) +\n"
"                                     strlen(fts_name) */\n"
"    char           *fts_name;     /* имя файла */\n"
"    short           fts_namelen;  /* strlen(fts_name) */\n"
"    short           fts_level;    /* глубина (от -1 до N) */\n"
"    int             fts_errno;    /* файловый errno */\n"
"    long            fts_number;   /* локальное числовое значение */\n"
"    void           *fts_pointer;  /* локальное значение адреса */\n"
"    struct _ftsent *fts_parent;   /* родительский каталог */\n"
"    struct _ftsent *fts_link;     /* структура следующего файла */\n"
"    struct _ftsent *fts_cycle;    /* циклическая структура */\n"
"    struct stat    *fts_statp;    /* информация stat(2) */\n"
"} FTSENT;\n"

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: man-pages/man3/fts.3:145
msgid "These fields are defined as follows:"
msgstr "Эти поля определены следующим образом:"

#. type: TP
#: man-pages/man3/fts.3:145
#, no-wrap
msgid "I<fts_info>"
msgstr "I<fts_info>"

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: man-pages/man3/fts.3:157
msgid ""
"One of the following values describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""
"Одно из следующих значений описывает возвращённую структуру I<FTSENT> и "
"файл, который она представляет. За исключением каталогов без ошибок "
"(B<FTS_D>), все эти элементы являются конечными, то есть они не будут "
"повторно обходиться, а их потомки не будут обходиться вообще."

#. type: TP
#: man-pages/man3/fts.3:158
#, no-wrap
msgid "B<FTS_D>"
msgstr "B<FTS_D>"

#. type: Plain text
#: man-pages/man3/fts.3:161
msgid "A directory being visited in preorder."
msgstr "Каталог, посещаемый в прямом порядке."

#. type: TP
#: man-pages/man3/fts.3:161
#, no-wrap
msgid "B<FTS_DC>"
msgstr "B<FTS_DC>"

#. type: Plain text
#: man-pages/man3/fts.3:169
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the "
"I<FTSENT> structure will be filled in as well.)"
msgstr ""
"Каталог, вызвавший зацикливание в дереве (также будет заполнено поле "
"I<fts_cycle> структуры I<FTSENT>)."

#. type: TP
#: man-pages/man3/fts.3:169
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr "B<FTS_DEFAULT>"

#. type: Plain text
#: man-pages/man3/fts.3:177
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described "
"by one of the other I<fts_info> values."
msgstr ""
"Любая структура I<FTSENT>, представляющая тип файла, неявно описываемый "
"одним из других значений I<fts_info>."

#. type: TP
#: man-pages/man3/fts.3:177
#, no-wrap
msgid "B<FTS_DNR>"
msgstr "B<FTS_DNR>"

#. type: Plain text
#: man-pages/man3/fts.3:183
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"Каталог, который не может быть прочитан. Это значение возвращается при "
"ошибке, и поле I<fts_errno> будет заполнено тем, что вызвало ошибку."

#. type: TP
#: man-pages/man3/fts.3:183
#, no-wrap
msgid "B<FTS_DOT>"
msgstr "B<FTS_DOT>"

#. type: Plain text
#: man-pages/man3/fts.3:193
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""
"Файл с именем «.» или «..», который не был указан в качестве имени файла в "
"B<fts_open>() (смотрите B<FTS_SEEDOT>)."

#. type: TP
#: man-pages/man3/fts.3:193
#, no-wrap
msgid "B<FTS_DP>"
msgstr "B<FTS_DP>"

#. type: Plain text
#: man-pages/man3/fts.3:203
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""
"Каталог, посещаемый в обратном порядке. Содержимое структуры I<FTSENT> будет "
"неизменно, как если бы он посещался в прямом порядке, то есть значение поля "
"I<fts_info> равно B<FTS_D>."

#. type: TP
#: man-pages/man3/fts.3:203
#, no-wrap
msgid "B<FTS_ERR>"
msgstr "B<FTS_ERR>"

#. type: Plain text
#: man-pages/man3/fts.3:208
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""
"Это значение возвращается при ошибке, и поле I<fts_errno> будет заполнено "
"тем, что вызвало ошибку."

#. type: TP
#: man-pages/man3/fts.3:208
#, no-wrap
msgid "B<FTS_F>"
msgstr "B<FTS_F>"

#. type: Plain text
#: man-pages/man3/fts.3:211
msgid "A regular file."
msgstr "Обычный файл."

#. type: TP
#: man-pages/man3/fts.3:211
#, no-wrap
msgid "B<FTS_NS>"
msgstr "B<FTS_NS>"

#. type: Plain text
#: man-pages/man3/fts.3:222
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"Файл, для которого нет доступной информации по B<stat>(2). Содержимое поля "
"I<fts_statp> не определено. Это значение возвращается при ошибке, и поле "
"I<fts_errno> будет заполнено тем, что вызвало ошибку."

#. type: TP
#: man-pages/man3/fts.3:222
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr "B<FTS_NSOK>"

#. type: Plain text
#: man-pages/man3/fts.3:230
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""
"Файл, для которого не запрашивалась информация с помощью B<stat>(2). "
"Содержимое поля I<fts_statp> не определено."

#. type: TP
#: man-pages/man3/fts.3:230
#, no-wrap
msgid "B<FTS_SL>"
msgstr "B<FTS_SL>"

#. type: Plain text
#: man-pages/man3/fts.3:233
msgid "A symbolic link."
msgstr "Символьная ссылка."

#. type: TP
#: man-pages/man3/fts.3:233
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr "B<FTS_SLNONE>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:241
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp> "
"field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""
"Символьная ссылка, указывающая на несуществующий объект. В поле I<fts_statp> "
"содержится ссылка на информацию о свойствах самой символьной ссылки."

#. type: TP
#: man-pages/man3/fts.3:242
#, no-wrap
msgid "I<fts_accpath>"
msgstr "I<fts_accpath>"

#. type: Plain text
#: man-pages/man3/fts.3:245
msgid "A path for accessing the file from the current directory."
msgstr "Путь к файлу относительно текущего каталога."

#. type: TP
#: man-pages/man3/fts.3:245
#, no-wrap
msgid "I<fts_path>"
msgstr "I<fts_path>"

#. type: Plain text
#: man-pages/man3/fts.3:251
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""
"Путь к файлу относительно начального каталога обхода. Этот путь содержит в "
"себе путь (как префикс), указанный в B<fts_open>()."

#. type: TP
#: man-pages/man3/fts.3:251
#, no-wrap
msgid "I<fts_pathlen>"
msgstr "I<fts_pathlen>"

#. type: Plain text
#: man-pages/man3/fts.3:257
msgid ""
"The sum of the lengths of the strings referenced by I<fts_path> and "
"I<fts_name>."
msgstr "Сумма длин строк, на которые ссылается I<fts_path> и I<fts_name>."

#. type: TP
#: man-pages/man3/fts.3:257
#, no-wrap
msgid "I<fts_name>"
msgstr "I<fts_name>"

#. type: Plain text
#: man-pages/man3/fts.3:260
msgid "The name of the file."
msgstr "Имя файла."

#. type: TP
#: man-pages/man3/fts.3:260
#, no-wrap
msgid "I<fts_namelen>"
msgstr "I<fts_namelen>"

#. type: Plain text
#: man-pages/man3/fts.3:264
msgid "The length of the string referenced by I<fts_name>."
msgstr "Длина строки, на которую ссылается I<fts_name>."

#. type: TP
#: man-pages/man3/fts.3:264
#, no-wrap
msgid "I<fts_level>"
msgstr "I<fts_level>"

#. type: Plain text
#: man-pages/man3/fts.3:275
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""
"Глубина погружения в дерево иерархии, от -1 до N, на которой был обнаружен "
"файл. Структура I<FTSENT>, представляющая родительский каталог обхода (или "
"начальный каталог), обозначена как -1, а структура I<FTSENT> для самой "
"начальной точки поиска обозначена как 0."

#. type: TP
#: man-pages/man3/fts.3:275
#, no-wrap
msgid "I<fts_errno>"
msgstr "I<fts_errno>"

#. type: Plain text
#: man-pages/man3/fts.3:299
msgid ""
"If B<fts_children>()  or B<fts_read>()  returns an I<FTSENT> structure whose "
"I<fts_info> field is set to B<FTS_DNR>, B<FTS_ERR>, or B<FTS_NS>, the "
"I<fts_errno> field contains the error number (i.e., the I<errno> value)  "
"specifying the cause of the error.  Otherwise, the contents of the "
"I<fts_errno> field are undefined."
msgstr ""
"Если при возврате структуры I<FTSENT> функцией B<fts_children>() или "
"B<fts_read>() её поле I<fts_info> равно B<FTS_DNR>, B<FTS_ERR> или "
"B<FTS_NS>, то в поле I<fts_errno> содержится номер ошибки (то есть значение "
"I<errno>), обозначающее причину ошибки. В других случаях, содержимое поля "
"I<fts_errno> не определено."

#. type: TP
#: man-pages/man3/fts.3:299
#, no-wrap
msgid "I<fts_number>"
msgstr "I<fts_number>"

#. type: Plain text
#: man-pages/man3/fts.3:305
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""
"Это поле создано для использования пользовательским приложением и не "
"изменяется функциями fts. При инициализации оно устанавливается в 0."

#. type: TP
#: man-pages/man3/fts.3:305
#, no-wrap
msgid "I<fts_pointer>"
msgstr "I<fts_pointer>"

#. type: Plain text
#: man-pages/man3/fts.3:312
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""
"Это поле создано для использования пользовательским приложением и не "
"изменяется функциями fts. При инициализации оно устанавливается в NULL."

#. type: TP
#: man-pages/man3/fts.3:312
#, no-wrap
msgid "I<fts_parent>"
msgstr "I<fts_parent>"

#. type: Plain text
#: man-pages/man3/fts.3:326
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number>, and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""
"Указатель на структуру I<FTSENT>, которая ссылается на файл в иерархии "
"непосредственно над текущим файлом, то есть на каталог, членом которого "
"является текущий файл. Родительский каталог начальной точки поиска также "
"может быть доступен, однако инициализируются только поля I<fts_level>, "
"I<fts_number> и I<fts_pointer>."

#. type: TP
#: man-pages/man3/fts.3:326
#, no-wrap
msgid "I<fts_link>"
msgstr "I<fts_link>"

#. type: Plain text
#: man-pages/man3/fts.3:337
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory "
"members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""
"При возврате функции B<fts_children>() поле I<fts_link> указывает на "
"следующую структуру в связанном списке (заканчивающемся NULL) содержимого "
"каталога. В другим случаях содержимое поля I<fts_link> не определено."

#. type: TP
#: man-pages/man3/fts.3:337
#, no-wrap
msgid "I<fts_cycle>"
msgstr "I<fts_cycle>"

#. type: Plain text
#: man-pages/man3/fts.3:353
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""
"Если каталог вызывает зацикливание иерархии (смотрите B<FTS_DC>), либо из-за "
"жёсткой ссылки между двумя каталогами, либо из-за символьной ссылки, "
"указывающей на каталог, то поле I<fts_cycle> будет указывать на структуру "
"I<FTSENT> в иерархии, которая ссылается на тот же файл, что и текущая "
"структура I<FTSENT>. В других случаях содержимое поля I<fts_cycle> не "
"определено."

#. type: TP
#: man-pages/man3/fts.3:353
#, no-wrap
msgid "I<fts_statp>"
msgstr "I<fts_statp>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:359
msgid "A pointer to B<stat>(2)  information for the file."
msgstr "Указатель на информацию о файле, полученную с помощью B<stat>(2)."

#. type: Plain text
#: man-pages/man3/fts.3:386
msgid ""
"A single buffer is used for all of the paths of all of the files in the file "
"hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned "
"by B<fts_read>().  To use these fields to reference any files represented by "
"other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen> "
"field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always null-"
"terminated."
msgstr ""
"Для всех путей всех файлов в иерархии используется единый буфер. "
"Следовательно, поля I<fts_path> и I<fts_accpath> гарантировано завершаются "
"null I<только> для файла, который был возвращён B<fts_read>() последним. Для "
"использования этих полей для обращения к любым файлам, представленным "
"другими структурами I<FTSENT> необходимо, чтобы буфер пути был изменён в "
"соответствии с информацией, содержащейся в поле I<fts_pathlen> структуры "
"I<FTSENT>. Любое изменение должно быть обратно восстановлено перед "
"дальнейшими попытками вызова B<fts_read>(). Поле I<fts_name> всегда "
"завершается null."

#. type: SS
#: man-pages/man3/fts.3:386
#, no-wrap
msgid "fts_open()"
msgstr "fts_open()"

#. type: Plain text
#: man-pages/man3/fts.3:393
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a null pointer."
msgstr ""
"Функция B<fts_open>() ожидает указатель на массив символьных указателей, "
"обозначающих один или несколько путей, образующих логическую файловую "
"иерархию, по которой будет проводиться обход. Массив должен заканчиваться "
"указателем null."

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: man-pages/man3/fts.3:403
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""
"Есть несколько флагов, должен быть указан хотя бы один (либо B<FTS_LOGICAL>, "
"либо B<FTS_PHYSICAL>). Флаги, выбираемые с помощью логического объединения, "
"имеют следующие значения:"

#. type: TP
#: man-pages/man3/fts.3:403
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr "B<FTS_COMFOLLOW>"

#. type: Plain text
#: man-pages/man3/fts.3:409
msgid ""
"This option causes any symbolic link specified as a root path to be followed "
"immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""
"Этот флаг принуждает перемещаться по любой символьной ссылке, определённой "
"как корневой путь, несмотря на то, определён или нет флаг B<FTS_LOGICAL>."

#. type: TP
#: man-pages/man3/fts.3:409
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr "B<FTS_LOGICAL>"

#. type: Plain text
#: man-pages/man3/fts.3:428
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this "
"option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either "
"B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  "
"function."
msgstr ""
"Этот флаг принуждает функции fts возвращать структуры B<FTSENT> для целей "
"символьных ссылок вместо самих символьных ссылок. Если этот флаг включён, то "
"единственные символьные ссылки, для которых приложениям выдаются структуры "
"I<FTSENT> — это ссылки, указывающие на несуществующие файлы. Также для "
"работы функции B<fts_open>() I<должны> быть указаны B<FTS_LOGICAL> или "
"B<FTS_PHYSICAL>."

#. type: TP
#: man-pages/man3/fts.3:428
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr "B<FTS_NOCHDIR>"

#. type: Plain text
#: man-pages/man3/fts.3:444
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""
"С целью оптимизации производительности функции fts меняют каталоги, по "
"которым они следуют по файловой иерархии. Это имеет один побочный эффект — "
"приложения не могут точно определить, в каком каталоге они находятся во "
"время перемещения по дереву. Флаг B<FTS_NOCHDIR> выключает такую "
"оптимизацию, и функции fts не будут менять текущий каталог. Заметим, что "
"приложения тоже не должны изменять свой текущий каталог и пытаться получить "
"доступ к файлам, пока не указан флаг B<FTS_NOCHDIR> и функции B<fts_open>() "
"не переданы абсолютные пути в качестве параметров."

#. type: TP
#: man-pages/man3/fts.3:444
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr "B<FTS_NOSTAT>"

#. type: Plain text
#: man-pages/man3/fts.3:460
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes "
"that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""
"По умолчанию, возвращаемые структуры I<FTSENT> ссылаются на информацию о "
"файлах (поле I<statp>) в каждом просмотренном файле. Данный флаг снимает это "
"требование (для оптимизации производительности), позволяя функциям fts "
"присваивать полю I<fts_info> значение B<FTS_NSOK> и оставлять содержание "
"поля I<statp> неопределенным."

#. type: TP
#: man-pages/man3/fts.3:460
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr "B<FTS_PHYSICAL>"

#. type: Plain text
#: man-pages/man3/fts.3:479
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""
"Этот флаг заставляет функции fts выдавать структуру I<FTSENT> самих "
"символьных ссылок, а не файлов, на которые они указывают. Если этот флаг "
"установлен, то для всех символьных ссылок в файловой иерархии приложениям "
"возвращаются структуры I<FTSENT>. Для работы функции B<fts_open>() также "
"I<должны> присутствовать B<FTS_LOGICAL> или B<FTS_PHYSICAL>."

#. type: TP
#: man-pages/man3/fts.3:479
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr "B<FTS_SEEDOT>"

#. type: Plain text
#: man-pages/man3/fts.3:492
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures "
"for them."
msgstr ""
"По умолчанию, все файлы с именами «.» или «..», обнаруженные в файловой "
"иерархии, игнорируются, если они не указаны как параметры пути в "
"B<fts_open>(). Данный флаг принуждает функции fts для таких файлов "
"возвращать структуры I<FTSENT>."

#. type: TP
#: man-pages/man3/fts.3:492
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr "B<FTS_XDEV>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:498
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""
"Этот флаг предотвращает функции fts от вхождения в каталоги, которые имеют "
"номер устройства, отличный от файла, с которого начался обход."

#. type: Plain text
#: man-pages/man3/fts.3:537
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path>, "
"and I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used "
"in this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""
"В параметре B<compar>() указывается определяемая пользователем функция, "
"которая может использоваться для упорядочивания обхода иерархии. В качестве "
"параметров ей требуется два указателя на указатели на структуры I<FTSENT>, и "
"она должна возвращать отрицательное значение, ноль или положительное "
"значение для того, чтобы показать, расположен ли файл, на который указывает "
"первый параметр, перед (относительно текущего упорядочивания), на одном "
"уровне или после файла, на который указывает второй параметр. Поля "
"I<fts_accpath>, I<fts_path> и I<fts_pathlen> структур I<FTSENT> могут быть "
"I<никогда> не использованы при таком сравнении. Если значение поля "
"I<fts_info> равно B<FTS_NS> или B<FTS_NSOK>, то поле I<fts_statp> может не "
"использоваться. Если значение параметра B<compar>() равно NULL, то порядок "
"обхода каталогов определяется параметрами, указанными в I<path_argv> для "
"корневых путей, и в порядке, перечисленном в каталоге, для всего остального."

#. type: SS
#: man-pages/man3/fts.3:537
#, no-wrap
msgid "fts_read()"
msgstr "fts_read()"

#. type: Plain text
#: man-pages/man3/fts.3:550
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may "
"cause files to be visited more than once, or directories more than twice.)"
msgstr ""
"Функция B<fts_read>() возвращает указатель на структуру I<FTSENT>, "
"описывающую файл в иерархии. Каталоги (корректно считанные и не образующие "
"зацикливаний), посещаются как минимум дважды — первый раз в прямом "
"прохождении и второй раз в обратном. Все остальные файлы посещаются минимум "
"один раз (жёсткие ссылки между каталогами, не образующие зацикливаний, или "
"символьные ссылки на символьные ссылки могут привести к тому, что файлы "
"будут посещаться более одного раза, а каталоги более двух раз)."

#. type: Plain text
#: man-pages/man3/fts.3:571
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and "
"sets I<errno> appropriately.  If an error related to a returned file occurs, "
"a pointer to an I<FTSENT> structure is returned, and I<errno> may or may not "
"have been set (see I<fts_info>)."
msgstr ""
"Когда все члены иерархии возвращены, B<fts_read>() возвращает NULL и "
"устанавливает внешнюю переменную I<errno> равной 0. Если происходит ошибка, "
"не имеющая отношения к файлу в иерархии, B<fts_read>() возвращает NULL и "
"устанавливает I<errno> в соответствующее значение. Если происходит ошибка, "
"связанная с возвращённым файлом, то возвращается указатель на структуру "
"I<FTSENT>, а I<errno> может быть установлена в какое-то значение (а может и "
"не быть, смотрите I<fts_info>)."

#. type: Plain text
#: man-pages/man3/fts.3:588
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after "
"a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""
"Структуры I<FTSENT>, возвращаемые B<fts_read>(), могут быть перезаписаны "
"после вызова B<fts_close>() в том же файловом потоке иерархии или после "
"вызова B<fts_read>() в том же файловом потоке иерархии, если они не "
"представляют файл типа «каталог»; в этом случае они не будут перезаписаны до "
"тех пор, пока функция B<fts_read>() не вернёт структуру I<FTSENT> при "
"выполнении обхода в обратном порядке."

#. type: SS
#: man-pages/man3/fts.3:588
#, no-wrap
msgid "fts_children()"
msgstr "fts_children()"

#. type: Plain text
#: man-pages/man3/fts.3:606
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will re-create this "
"linked list."
msgstr ""
"Функция B<fts_children>() возвращает указатель на структуру I<FTSENT>, "
"описывающую первый член связанного списка (оканчивающегося NULL) файлов в "
"каталоге, представленного структурой I<FTSENT>, возвращённой B<fts_read>() "
"последней. Список связан через поле I<fts_link> структуры I<FTSENT>, и "
"упорядочен определённой пользователем функцией сравнения, если таковая "
"существует. Повторные вызовы B<fts_children>() будут пересоздавать этот "
"связанный список."

#. type: Plain text
#: man-pages/man3/fts.3:634
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, "
"B<fts_children>()  returns NULL and sets I<errno> appropriately."
msgstr ""
"В особом случае, если B<fts_read>() ещё не вызывалась для иерархии, то "
"B<fts_children>() возвратит указатель на файлы в логическом каталоге, "
"заданном B<fts_open>(), т.е. параметры, переданные функции B<fts_open>(). В "
"противном случае, если последняя возвращённая B<fts_read>() структура "
"I<FTSENT> не является каталогом, просмотренном в прямом порядке, и не "
"каталогом файлов, то B<fts_children>() возвратит NULL и установит I<errno> "
"равным 0. Если произойдёт ошибка, то B<fts_children>() возвратит NULL и "
"установит I<errno> в соответствующее значение."

#. type: Plain text
#: man-pages/man3/fts.3:645
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>(), or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""
"Структура I<FTSENT>, возвращаемая B<fts_children>(), может быть перезаписана "
"после вызова B<fts_children>(), B<fts_close>() или B<fts_read>() в том же "
"файловом потоке иерархии."

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: man-pages/man3/fts.3:650
msgid "The I<instr> argument is either zero or the following value:"
msgstr ""
"Параметр I<instr> может принимать значение нуля или одного из следующих "
"значений:"

#. type: TP
#: man-pages/man3/fts.3:650
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr "B<FTS_NAMEONLY>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:660
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""
"Необходимы только имена файлов. Содержимое всех полей в возвращаемом "
"связанном списке структур не определено, за исключением полей I<fts_name> и "
"I<fts_namelen>."

#. type: SS
#: man-pages/man3/fts.3:660
#, no-wrap
msgid "fts_set()"
msgstr "fts_set()"

#. type: Plain text
#: man-pages/man3/fts.3:672
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs."
msgstr ""
"Функция B<fts_set>() позволяет пользовательскому приложению определять "
"дальнейшую обработку файла I<f> в потоке I<ftsp>. При успешном выполнении "
"функция B<fts_set>() возвращает 0 и -1 при ошибке."

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: man-pages/man3/fts.3:677
msgid ""
"The I<instr> argument is either 0 (meaning \"do nothing\") or one of the "
"following values:"
msgstr ""
"Значением аргумента I<instr> может быть 0 («ничего не делать») или одно из "
"следующих значений:"

#. type: TP
#: man-pages/man3/fts.3:677
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr "B<FTS_AGAIN>"

#. type: Plain text
#: man-pages/man3/fts.3:695
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""
"Повторно посетить файл; файл любого типа может быть повторно посещён. "
"Последующий вызов B<fts_read>() возвратит файл, к которому идёт обращение. "
"Поля I<fts_stat> и I<fts_info> структуры будут переинициализированы в этот "
"момент, но никакие поля больше не будут изменены. Этот параметр значим "
"только для последнего возвращённого файла из B<fts_read>(). Обычно его "
"используют при посещении каталогов в обратном порядке; в этом случае каталог "
"посещается повторно (в прямом и обратном порядке), а также все его потомки."

#. type: TP
#: man-pages/man3/fts.3:695
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr "B<FTS_FOLLOW>"

#. type: Plain text
#: man-pages/man3/fts.3:723
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()  "
"returns the file with the I<fts_info> and I<fts_statp> fields reinitialized "
"to reflect the target of the symbolic link instead of the symbolic link "
"itself.  If the file is one of those most recently returned by "
"B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the structure, "
"when returned by B<fts_read>(), will reflect the target of the symbolic link "
"instead of the symbolic link itself.  In either case, if the target of the "
"symbolic link does not exist, the fields of the returned structure will be "
"unchanged and the I<fts_info> field will be set to B<FTS_SLNONE>."
msgstr ""
"Рассматриваемый файл должен быть символьной ссылкой. Если рассматриваемый "
"файл — последний возвращённый B<fts_read>(), то следующий вызов "
"B<fts_read>() возвратит файл с изменёнными полями I<fts_info> и "
"I<fts_statp>, в которых будут отражать повторно инициализированные данные "
"цели символьной ссылки, а не самой символьной ссылки. Если рассматриваемый "
"файл — последний возвращённый B<fts_children>(), то поля I<fts_info> и "
"I<fts_statp> структуры при возврате из B<fts_read>() будут отражать данные "
"цели символьной ссылки, а не самой символьной ссылки. В любом случае, если "
"цель символьной ссылки не существует, то поля возвращаемой структуры не "
"будут меняться, а поле I<fts_info> будет равно B<FTS_SLNONE>."

#. type: Plain text
#: man-pages/man3/fts.3:727
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""
"Если цель ссылки — каталог, то выполняется возврат при прямом прохождении, "
"после него возврат всех его потомков, после чего выполняется возврат в "
"обратном порядке."

#. type: TP
#: man-pages/man3/fts.3:727
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr "B<FTS_SKIP>"

#.  .El
#. type: Plain text
#: man-pages/man3/fts.3:735
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""
"Не посещать потомков данного файла. Файл может быть одним из последних "
"возвращённых либо B<fts_children>(), либо B<fts_read>()."

#. type: SS
#: man-pages/man3/fts.3:735
#, no-wrap
msgid "fts_close()"
msgstr "fts_close()"

#. type: Plain text
#: man-pages/man3/fts.3:748
msgid ""
"The B<fts_close>()  function closes the file hierarchy stream referred to by "
"I<ftsp> and restores the current directory to the directory from which "
"B<fts_open>()  was called to open I<ftsp>.  The B<fts_close>()  function "
"returns 0 on success, and -1 if an error occurs."
msgstr ""
"Функция B<fts_close>() закрывает поток файловой иерархии, на который "
"указывает I<ftsp>, и делает текущим каталогом тот, который был до вызова "
"B<fts_open>() для открытия I<ftsp>. При успешном выполнении функция "
"B<fts_close>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/fts.3:757
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""
"Функция B<fts_open>() может завершиться с ошибкой и назначить переменной "
"I<errno> значения, перечисленные в B<open>(2) и B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/fts.3:766
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors "
"specified for B<chdir>(2)  and B<close>(2)."
msgstr ""
"Функция B<fts_close>() может завершиться с ошибкой и назначить переменной "
"I<errno> значения, перечисленные в B<chdir>(2) и B<close>(2)."

#. type: Plain text
#: man-pages/man3/fts.3:780
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), and B<stat>(2)."
msgstr ""
"Функции B<fts_read>() и B<fts_children>() могут завершиться с ошибкой и "
"назначить переменной I<errno> значения, перечисленные в B<chdir>(2), "
"B<malloc>(3), B<opendir>(3), B<readdir>(3) и B<stat>(2)."

#. type: Plain text
#: man-pages/man3/fts.3:789
msgid ""
"In addition, B<fts_children>(), B<fts_open>(), and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""
"Кроме того, функции B<fts_children>(), B<fts_open>() и B<fts_set>() могут "
"завершиться с ошибкой и назначить переменной I<errno> следующие значения:"

#. type: Plain text
#: man-pages/man3/fts.3:795
msgid "I<options> or I<instr> was invalid."
msgstr "Некорректное значение I<options> или I<instr>."

#. type: Plain text
#: man-pages/man3/fts.3:797
msgid "These functions are available in Linux since glibc2."
msgstr "Эти функции доступны в версиях Linux начиная с glibc2."

#. type: tbl table
#: man-pages/man3/fts.3:809
#, no-wrap
msgid ""
"B<fts_open>(),\n"
"B<fts_set>(),\n"
"B<fts_close>()"
msgstr ""
"B<fts_open>(),\n"
"B<fts_set>(),\n"
"B<fts_close>()"

#. type: tbl table
#: man-pages/man3/fts.3:813
#, no-wrap
msgid ""
"B<fts_read>(),\n"
"B<fts_children>()"
msgstr ""
"B<fts_read>(),\n"
"B<fts_children>()"

#. type: tbl table
#: man-pages/man3/fts.3:813
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: man-pages/man3/fts.3:818
msgid "4.4BSD."
msgstr "4.4BSD."

#.  Fixed by commit 8b7b7f75d91f7bac323dd6a370aeb3e9c5c4a7d5
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=15838
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11460
#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: man-pages/man3/fts.3:834
msgid ""
"In versions of glibc before 2.23, all of the APIs described in this man page "
"are not safe when compiling a program using the LFS APIs (e.g., when "
"compiling with I<-D_FILE_OFFSET_BITS=64>)."
msgstr ""
"В версиях glibc до 2.23 весь описанный здесь программный интерфейс "
"небезопасен, если компиляция программы производится с программным "
"интерфейсом LFS (например, когда компиляция выполняется с I<-"
"D_FILE_OFFSET_BITS=64>)."

#. type: Plain text
#: man-pages/man3/fts.3:839
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"

#. type: TH
#: man-pages/man3/floor.3:27
#, no-wrap
msgid "FLOOR"
msgstr "FLOOR"

#. type: Plain text
#: man-pages/man3/floor.3:30
msgid ""
"floor, floorf, floorl - largest integral value not greater than argument"
msgstr ""
"floor, floorf, floorl - поиск наибольшего целого значения не превышающего "
"заданный аргумент"

#. type: Plain text
#: man-pages/man3/floor.3:37
#, no-wrap
msgid ""
"B<double floor(double >I<x>B<);>\n"
"B<float floorf(float >I<x>B<);>\n"
"B<long double floorl(long double >I<x>B<);>\n"
msgstr ""
"B<double floor(double >I<x>B<);>\n"
"B<float floorf(float >I<x>B<);>\n"
"B<long double floorl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/floor.3:49
msgid "B<floorf>(), B<floorl>():"
msgstr "B<floorf>(), B<floorl>():"

#. type: Plain text
#: man-pages/man3/floor.3:58
msgid ""
"These functions return the largest integral value that is not greater than "
"I<x>."
msgstr ""
"Данные функции возвращают наибольшее целое значение не превышающее I<x>."

#. type: Plain text
#: man-pages/man3/floor.3:64
msgid "For example, I<floor(0.5)> is 0.0, and I<floor(-0.5)> is -1.0."
msgstr ""
"Например, результатом I<floor(0.5)> будет 0.0, а I<floor(-0.5)> \\(em -1.0."

#. type: Plain text
#: man-pages/man3/floor.3:67
msgid "These functions return the floor of I<x>."
msgstr "Данные функции возвращают целую часть от I<x>."

#. type: Plain text
#: man-pages/man3/floor.3:73
msgid ""
"If I<x> is integral, +0, -0, NaN, or an infinity, I<x> itself is returned."
msgstr ""
"Если I<x> \\(em целое, +0, -0, NaN или стремится к бесконечности, то будет "
"возвращено значение I<x>."

#. type: Plain text
#: man-pages/man3/floor.3:76
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""
"Ошибки не возникают. В документах POSIX.1-2001 описывается ошибка диапазона "
"при переполнениях, однако см. ЗАМЕЧАНИЯ."

#. type: tbl table
#: man-pages/man3/floor.3:88
#, no-wrap
msgid ""
"B<floor>(),\n"
"B<floorf>(),\n"
"B<floorl>()"
msgstr ""
"B<floor>(),\n"
"B<floorf>(),\n"
"B<floorl>()"

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: man-pages/man3/floor.3:113
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno> "
"to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of "
"mantissa bits is 24 (respectively, 53).)"
msgstr ""
"В SUSv2 и POSIX.1-2001 есть текст о переполнении (которое может установить "
"I<errno> в B<ERANGE> или вызвать исключение B<FE_OVERFLOW>). На практике, "
"результат не может выйти за диапазон ни на каком компьютере, поэтому "
"обработка этой ошибки не имеет смысла (точнее говоря, переполнение возможно "
"только в том случае, когда максимальное значение экспоненты меньше числа бит "
"мантиссы. В стандарте IEEE-754 для 32- и 64-битных чисел с плавающей точкой "
"максимальное значение экспоненты равно 128 и 1024 соответственно, а число "
"бит мантиссы — 24 и 53 соответственно)."

#. type: Plain text
#: man-pages/man3/floor.3:119
msgid ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), "
"B<trunc>(3)"
msgstr ""
"B<ceil>(3), B<lrint>(3), B<nearbyint>(3), B<rint>(3), B<round>(3), "
"B<trunc>(3)"

#. type: TH
#: man-pages/man3/fputwc.3:16
#, no-wrap
msgid "FPUTWC"
msgstr "FPUTWC"

#. type: Plain text
#: man-pages/man3/fputwc.3:19
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr "fputwc, putwc - записывает широкий символ в поток FILE"

#. type: Plain text
#: man-pages/man3/fputwc.3:26
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fputwc.3:42
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the "
"B<fputc>(3)  function.  It writes the wide character I<wc> to I<stream>.  If "
"I<ferror(stream)> becomes true, it returns B<WEOF>.  If a wide-character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>.  "
"Otherwise, it returns I<wc>."
msgstr ""
"Функция B<fputwc> — это эквивалент функции B<fputc>(3), но для широких "
"символов. Она записывает широкий символ I<wc> в поток I<stream>. Если "
"значение I<ferror(stream)> истинно, то возвращается B<WEOF>. Если при "
"преобразовании в широкий символ возникает ошибка, то значение переменной "
"I<errno> устанавливается равным B<EILSEQ> и возвращается B<WEOF>. В любом "
"другом случае возвращается I<wc>."

#. type: Plain text
#: man-pages/man3/fputwc.3:50
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""
"Функция B<putwc>() — это функция, или макрос, идентичный B<fputwc>(). Она "
"может быть реализована в виде макроса, и может вычислять свой аргумент более "
"одного раза. Вообще нет смысла использовать эту функцию."

#. type: Plain text
#: man-pages/man3/fputwc.3:62
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error.  In the event of an error, I<errno> is set to indicate "
"the cause."
msgstr ""
"Функция B<fputwc>() возвращает I<wc>, если не было ошибок, или B<WEOF> в "
"противном случае. При ошибке в I<errno> записывается соответствующее "
"значение."

#. type: Plain text
#: man-pages/man3/fputwc.3:67
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr "Не удалось преобразовать I<wc> в кодировку потока."

#. type: tbl table
#: man-pages/man3/fputwc.3:78
#, no-wrap
msgid ""
"B<fputwc>(),\n"
"B<putwc>()"
msgstr ""
"B<fputwc>(),\n"
"B<putwc>()"

#. type: Plain text
#: man-pages/man3/fputwc.3:90
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<fputwc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/fputwc.3:98
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fputwc>()  will actually write the multibyte "
"sequence corresponding to the wide character I<wc>."
msgstr ""
"Из-за отсутствия дополнительной информации, передаваемой в B<fopen>(3), "
"закономерно ожидать, что B<fputwc>() на самом деле пишет многобайтовую "
"последовательность, соответствующую широкому символу I<wc>."

#. type: Plain text
#: man-pages/man3/fputwc.3:101
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/fmax.3:9
#, no-wrap
msgid "FMAX"
msgstr "FMAX"

#. type: Plain text
#: man-pages/man3/fmax.3:12
msgid "fmax, fmaxf, fmaxl - determine maximum of two floating-point numbers"
msgstr ""
"fmax, fmaxf, fmaxl - определение максимального из двух чисел с плавающей "
"запятой"

#. type: Plain text
#: man-pages/man3/fmax.3:18
msgid ""
"B<double fmax(double >I<x>B<, double >I<y>B<);> B<float fmaxf(float >I<x>B<, "
"float >I<y>B<);> B<long double fmaxl(long double >I<x>B<, long double "
">I<y>B<);>"
msgstr ""
"B<double fmax(double >I<x>B<, double >I<y>B<);> B<float fmaxf(float >I<x>B<, "
"float >I<y>B<);> B<long double fmaxl(long double >I<x>B<, long double "
">I<y>B<);>"

#. type: Plain text
#: man-pages/man3/fmax.3:30
msgid "B<fmax>(), B<fmaxf>(), B<fmaxl>():"
msgstr "B<fmax>(), B<fmaxf>(), B<fmaxl>():"

#. type: Plain text
#: man-pages/man3/fmax.3:39
msgid "These functions return the larger value of I<x> and I<y>."
msgstr "Данные функции возвращают большее значение из I<x> и I<y>."

#. type: Plain text
#: man-pages/man3/fmax.3:44
msgid "These functions return the maximum of I<x> and I<y>."
msgstr "Данные функции возвращают большее значение из I<x> и I<y>."

#. type: tbl table
#: man-pages/man3/fmax.3:64
#, no-wrap
msgid ""
"B<fmax>(),\n"
"B<fmaxf>(),\n"
"B<fmaxl>()"
msgstr ""
"B<fmax>(),\n"
"B<fmaxf>(),\n"
"B<fmaxl>()"

#. type: Plain text
#: man-pages/man3/fmax.3:70
msgid "B<fdim>(3), B<fmin>(3)"
msgstr "B<fdim>(3), B<fmin>(3)"

#. type: TH
#: man-pages/man3/fma.3:12
#, no-wrap
msgid "FMA"
msgstr "FMA"

#. type: Plain text
#: man-pages/man3/fma.3:15
msgid "fma, fmaf, fmal - floating-point multiply and add"
msgstr "fma, fmaf, fmal - умножение и сложение чисел с плавающей запятой"

#. type: Plain text
#: man-pages/man3/fma.3:22
#, no-wrap
msgid ""
"B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"
"B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"
"B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double >I<z>B<);>\n"
msgstr ""
"B<double fma(double >I<x>B<, double >I<y>B<, double >I<z>B<);>\n"
"B<float fmaf(float >I<x>B<, float >I<y>B<, float >I<z>B<);>\n"
"B<long double fmal(long double >I<x>B<, long double >I<y>B<, long double >I<z>B<);>\n"

#. type: Plain text
#: man-pages/man3/fma.3:35
msgid "B<fma>(), B<fmaf>(), B<fmal>():"
msgstr "B<fma>(), B<fmaf>(), B<fmal>():"

#. type: Plain text
#: man-pages/man3/fma.3:45
msgid ""
"These functions compute I<x> * I<y> + I<z>.  The result is rounded as one "
"ternary operation according to the current rounding mode (see B<fenv>(3))."
msgstr ""
"Эти функции вычисляют I<x> * I<y> + I<z>. Результат округляется как единая "
"тернарная операция согласно текущему режиму округления (смотрите B<fenv>(3))."

#. type: Plain text
#: man-pages/man3/fma.3:49
msgid ""
"These functions return the value of I<x> * I<y> + I<z>, rounded as one "
"ternary operation."
msgstr ""
"Данные функции возвращают результат I<x> * I<y> + I<z>, округлённый как для "
"единой тернарной операции."

#. type: Plain text
#: man-pages/man3/fma.3:65
msgid ""
"If I<x> times I<y> is an exact infinity, and I<z> is an infinity with the "
"opposite sign, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> умноженное на I<y> стремится к бесконечности и значение I<z> равно "
"минус бесконечности, то будет сгенерирована ошибка выхода за пределы "
"области, а в качестве результата будет возвращено NaN."

#.  POSIX.1-2008 allows some possible differences for the following two
#.  domain error cases, but on Linux they are treated the same (AFAICS).
#.  Nevertheless, we'll mirror POSIX.1 and describe the two cases
#.  separately.
#.  POSIX.1 says that a NaN or an implementation-defined value shall
#.  be returned for this case.
#. type: Plain text
#: man-pages/man3/fma.3:81
msgid ""
"If one of I<x> or I<y> is an infinity, the other is 0, and I<z> is not a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> или I<y> равно бесконечности, не равно 0 и I<z> не равно NaN, то "
"будет сгенерирована ошибка выхода за пределы области, а в качестве "
"результата будет возвращено NaN."

#.  POSIX.1 makes the domain error optional for this case.
#. type: Plain text
#: man-pages/man3/fma.3:92
msgid ""
"If one of I<x> or I<y> is an infinity, and the other is 0, and I<z> is a "
"NaN, a domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> или I<y> равно бесконечности, не равно 0, а I<z> равно NaN, то "
"будет сгенерирована ошибка выхода за пределы области, а в качестве "
"результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fma.3:101
msgid ""
"If I<x> times I<y> is not an infinity times zero (or vice versa), and I<z> "
"is a NaN, a NaN is returned."
msgstr ""
"Если I<x> умноженное на I<y> не равно бесконечности умноженной на 0 (или "
"наоборот) и значение I<z> равно NaN, то будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/fma.3:105
msgid ""
"If the result overflows, a range error occurs, and an infinity with the "
"correct sign is returned."
msgstr ""
"Если происходит переполнение результата, возникает ошибка диапазона, и "
"возвращается бесконечность с математически правильным знаком."

#. type: Plain text
#: man-pages/man3/fma.3:109
msgid ""
"If the result underflows, a range error occurs, and a signed 0 is returned."
msgstr ""
"Если в результате исчерпана степень числа, возникает ошибка диапазона и "
"возвращается 0 со знаком."

#. type: TP
#: man-pages/man3/fma.3:116
#, no-wrap
msgid "Domain error: I<x> * I<y> + I<z>, or I<x> * I<y> is invalid and I<z> is not a NaN"
msgstr "Ошибка области: I<x> * I<y> + I<z> или I<x> * I<y> некорректно и I<z> не равно NaN"

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/fma.3:125
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "Возникает исключение неправильной плавающей запятой (B<FE_INVALID>)."

#. type: TP
#: man-pages/man3/fma.3:133
#, no-wrap
msgid "Range error: result underflow"
msgstr "Ошибка диапазона: результат исчерпал степень"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/fma.3:141
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Возникает исключение исчерпания степени чисел с плавающей запятой "
"(B<FE_UNDERFLOW>)."

#. type: tbl table
#: man-pages/man3/fma.3:160
#, no-wrap
msgid ""
"B<fma>(),\n"
"B<fmaf>(),\n"
"B<fmal>()"
msgstr ""
"B<fma>(),\n"
"B<fmaf>(),\n"
"B<fmal>()"

#. type: Plain text
#: man-pages/man3/fma.3:166
msgid "B<remainder>(3), B<remquo>(3)"
msgstr "B<remainder>(3), B<remquo>(3)"

#. type: TH
#: man-pages/man3/fenv.3:27
#, no-wrap
msgid "FENV"
msgstr "FENV"

#. type: Plain text
#: man-pages/man3/fenv.3:33
msgid ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, "
"fetestexcept, fegetenv, fegetround, feholdexcept, fesetround, fesetenv, "
"feupdateenv, feenableexcept, fedisableexcept, fegetexcept - floating-point "
"rounding and exception handling"
msgstr ""
"feclearexcept, fegetexceptflag, feraiseexcept, fesetexceptflag, "
"fetestexcept, fegetenv, fegetround, feholdexcept, fesetround, fesetenv, "
"feupdateenv, feenableexcept, fedisableexcept, fegetexcept - округление и "
"обработка ошибок для чисел с плавающей запятой"

#. type: Plain text
#: man-pages/man3/fenv.3:36
#, no-wrap
msgid "B<#include E<lt>fenv.hE<gt>>\n"
msgstr "B<#include E<lt>fenv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:42
#, no-wrap
msgid ""
"B<int feclearexcept(int >I<excepts>B<);>\n"
"B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
"B<int feraiseexcept(int >I<excepts>B<);>\n"
"B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
"B<int fetestexcept(int >I<excepts>B<);>\n"
msgstr ""
"B<int feclearexcept(int >I<excepts>B<);>\n"
"B<int fegetexceptflag(fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
"B<int feraiseexcept(int >I<excepts>B<);>\n"
"B<int fesetexceptflag(const fexcept_t *>I<flagp>B<, int >I<excepts>B<);>\n"
"B<int fetestexcept(int >I<excepts>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:45
#, no-wrap
msgid ""
"B<int fegetround(void);>\n"
"B<int fesetround(int >I<rounding_mode>B<);>\n"
msgstr ""
"B<int fegetround(void);>\n"
"B<int fesetround(int >I<rounding_mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:50
#, no-wrap
msgid ""
"B<int fegetenv(fenv_t *>I<envp>B<);>\n"
"B<int feholdexcept(fenv_t *>I<envp>B<);>\n"
"B<int fesetenv(const fenv_t *>I<envp>B<);>\n"
"B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"
msgstr ""
"B<int fegetenv(fenv_t *>I<envp>B<);>\n"
"B<int feholdexcept(fenv_t *>I<envp>B<);>\n"
"B<int fesetenv(const fenv_t *>I<envp>B<);>\n"
"B<int feupdateenv(const fenv_t *>I<envp>B<);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:56
msgid ""
"These eleven functions were defined in C99, and describe the handling of "
"floating-point rounding and exceptions (overflow, zero-divide, etc.)."
msgstr ""
"Эти одиннадцать функций определены в C99, и описывают обработку округления и "
"исключения (переполнение, деление на ноль и т. д.) при работе с числами с "
"плавающей запятой."

#. type: SS
#: man-pages/man3/fenv.3:56
#, no-wrap
msgid "Exceptions"
msgstr "Исключения"

#. type: Plain text
#: man-pages/man3/fenv.3:61
msgid ""
"The I<divide-by-zero> exception occurs when an operation on finite numbers "
"produces infinity as exact answer."
msgstr ""
"Исключение I<деление-на-ноль (divide-by-zero)> возникает, когда результатом "
"операции над конечными числами является бесконечность."

#. type: Plain text
#: man-pages/man3/fenv.3:67
msgid ""
"The I<overflow> exception occurs when a result has to be represented as a "
"floating-point number, but has (much) larger absolute value than the largest "
"(finite) floating-point number that is representable."
msgstr ""
"Исключение I<переполнение (overflow)> возникает, когда результат возможно "
"представить в виде числа с плавающей запятой, но он намного больше "
"абсолютного значения самого большого (конечного) представимого числа с "
"плавающей запятой."

#. type: Plain text
#: man-pages/man3/fenv.3:74
msgid ""
"The I<underflow> exception occurs when a result has to be represented as a "
"floating-point number, but has smaller absolute value than the smallest "
"positive normalized floating-point number (and would lose much accuracy when "
"represented as a denormalized number)."
msgstr ""
"Исключение I<исчерпания(underflow)> возникает, когда результат можно "
"представить в виде числа с плавающей запятой, но он меньше абсолютного "
"значения самого малого положительного нормализованного числа с плавающей "
"запятой (и возникает большая потеря точности, если представить его в виде "
"денормализованного числа)."

#. type: Plain text
#: man-pages/man3/fenv.3:84
msgid ""
"The I<inexact> exception occurs when the rounded result of an operation is "
"not equal to the infinite precision result.  It may occur whenever "
"I<overflow> or I<underflow> occurs."
msgstr ""
"Исключение I<inexact> возникает, когда округлённый результат операции не "
"равен бесконечной точности результата. Оно может произойти при исключении "
"I<переполнении> или I<исчерпании>."

#. type: Plain text
#: man-pages/man3/fenv.3:89
msgid ""
"The I<invalid> exception occurs when there is no well-defined result for an "
"operation, as for 0/0 or infinity - infinity or sqrt(-1)."
msgstr ""
"Исключение I<invalid> возникает, когда при операции получается плохо "
"определённый результат (no well-defined result), например, при 0/0 или "
"бесконечность - бесконечность или sqrt(-1)."

#. type: SS
#: man-pages/man3/fenv.3:89
#, no-wrap
msgid "Exception handling"
msgstr "Обработка исключений"

#. type: Plain text
#: man-pages/man3/fenv.3:95
msgid ""
"Exceptions are represented in two ways: as a single bit (exception present/"
"absent), and these bits correspond in some implementation-defined way with "
"bit positions in an integer, and also as an opaque structure that may "
"contain more information about the exception (perhaps the code address where "
"it occurred)."
msgstr ""
"Исключения представляются двумя способами: в виде одного бита (наличие/"
"отсутствие исключения) и целого числа, где каждый бит соответствует "
"исключению (определяется реализацией), а также структуры скрытого формата, "
"которая может содержать дополнительную информацию об исключении (возможно, "
"адрес в коде, где оно возникло)."

#. type: Plain text
#: man-pages/man3/fenv.3:111
msgid ""
"Each of the macros B<FE_DIVBYZERO>, B<FE_INEXACT>, B<FE_INVALID>, "
"B<FE_OVERFLOW>, B<FE_UNDERFLOW> is defined when the implementation supports "
"handling of the corresponding exception, and if so then defines the "
"corresponding bit(s), so that one can call exception handling functions, for "
"example, using the integer argument B<FE_OVERFLOW>|B<FE_UNDERFLOW>.  Other "
"exceptions may be supported.  The macro B<FE_ALL_EXCEPT> is the bitwise OR "
"of all bits corresponding to supported exceptions."
msgstr ""
"Если реализацией поддерживается обработка определённого исключения, то "
"определён соответствующий макрос: B<FE_DIVBYZERO>, B<FE_INEXACT>, "
"B<FE_INVALID>, B<FE_OVERFLOW>, B<FE_UNDERFLOW>. Если таким способом "
"определить соответствующий бит(ы), например, с целочисленным аргументом "
"B<FE_OVERFLOW>|B<FE_UNDERFLOW>, то могут вызываться функции обработки "
"исключений. Могут поддерживаться и другие исключения. Макрос "
"B<FE_ALL_EXCEPT> — это побитовый OR всех бит, соответствующих поддерживаемым "
"исключениям."

#. type: Plain text
#: man-pages/man3/fenv.3:116
msgid ""
"The B<feclearexcept>()  function clears the supported exceptions represented "
"by the bits in its argument."
msgstr ""
"Функция B<feclearexcept>() очищает поддерживаемые исключения, указанные "
"битами в аргументе."

#. type: Plain text
#: man-pages/man3/fenv.3:124
msgid ""
"The B<fegetexceptflag>()  function stores a representation of the state of "
"the exception flags represented by the argument I<excepts> in the opaque "
"object I<*flagp>."
msgstr ""
"Функция B<fegetexceptflag>() сохраняет представление состояния флагов "
"исключения, представленного аргументом I<excepts> в чёрном ящике I<*flagp>."

#. type: Plain text
#: man-pages/man3/fenv.3:129
msgid ""
"The B<feraiseexcept>()  function raises the supported exceptions represented "
"by the bits in I<excepts>."
msgstr ""
"Функция B<feraiseexcept>() возбуждает поддерживаемые исключения, заданные "
"битами в I<excepts>."

#. type: Plain text
#: man-pages/man3/fenv.3:140
msgid ""
"The B<fesetexceptflag>()  function sets the complete status for the "
"exceptions represented by I<excepts> to the value I<*flagp>.  This value "
"must have been obtained by an earlier call of B<fegetexceptflag>()  with a "
"last argument that contained all bits in I<excepts>."
msgstr ""
"Функция B<fesetexceptflag>() задаёт полное состояние для исключений, "
"представленных в I<excepts>, в значение I<*flagp>. Это значение должно быть "
"получено с помощью вызова B<fegetexceptflag>() с последним аргументом, "
"значение которого содержит все биты в I<excepts>."

#. type: Plain text
#: man-pages/man3/fenv.3:147
msgid ""
"The B<fetestexcept>()  function returns a word in which the bits are set "
"that were set in the argument I<excepts> and for which the corresponding "
"exception is currently set."
msgstr ""
"Функция B<fetestexcept>() возвращает слово, в котором биты устанавливаются в "
"соответствии с установленными битами в аргументе I<excepts> и для которых "
"установлено соответствующее исключение."

#. type: SS
#: man-pages/man3/fenv.3:147
#, no-wrap
msgid "Rounding mode"
msgstr "Режим округления"

#. type: Plain text
#: man-pages/man3/fenv.3:155
msgid ""
"The rounding mode determines how the result of floating-point operations is "
"treated when the result cannot be exactly represented in the significand.  "
"Various rounding modes may be provided: round to nearest (the default), "
"round up (toward positive infinity), round down (toward negative infinity), "
"and round toward zero."
msgstr ""
"Режим округления определяет трактовку результата операций с плавающей "
"запятой, если результат не может быть точно представлен в значащей части "
"числа(significand). Могут быть доступны различные режимы округления: "
"округление к ближайшему (по умолчанию), округление в сторону увеличения "
"(round up, к положительной бесконечности), округление в сторону уменьшения "
"(round down, к отрицательной бесконечности) и округление в сторону нуля."

#. type: Plain text
#: man-pages/man3/fenv.3:164
msgid ""
"Each of the macros B<FE_TONEAREST>, B<FE_UPWARD>, B<FE_DOWNWARD>, and "
"B<FE_TOWARDZERO> is defined when the implementation supports getting and "
"setting the corresponding rounding direction."
msgstr ""
"Если в реализации поддерживается получение и установка направления "
"округления, то для них определены соответствующие макросы: B<FE_TONEAREST>, "
"B<FE_UPWARD>, B<FE_DOWNWARD> и B<FE_TOWARDZERO>."

#. type: Plain text
#: man-pages/man3/fenv.3:169
msgid ""
"The B<fegetround>()  function returns the macro corresponding to the current "
"rounding mode."
msgstr ""
"Функция B<fegetround>() возвращает макрос, соответствующий текущему режиму "
"округления."

#. type: Plain text
#: man-pages/man3/fenv.3:174
msgid ""
"The B<fesetround>()  function sets the rounding mode as specified by its "
"argument and returns zero when it was successful."
msgstr ""
"Функция B<fesetround>() задаёт режим округления в соответствии со значением "
"аргумента и возвращает ноль при успешном выполнении."

#. type: Plain text
#: man-pages/man3/fenv.3:182
msgid ""
"C99 and POSIX.1-2008 specify an identifier, B<FLT_ROUNDS>, defined in "
"I<E<lt>float.hE<gt>>, which indicates the implementation-defined rounding "
"behavior for floating-point addition.  This identifier has one of the "
"following values:"
msgstr ""
"В C99 и POSIX.1-2008 в файле I<E<lt>float.hE<gt>> описан идентификатор "
"B<FLT_ROUNDS>, который определяет используемый реализацией режим поведения "
"для сложения чисел с плавающей запятой. Значениями идентификатора могут быть:"

#. type: IP
#: man-pages/man3/fenv.3:182
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: man-pages/man3/fenv.3:184
msgid "The rounding mode is not determinable."
msgstr "Режим округления не определён."

#. type: Plain text
#: man-pages/man3/fenv.3:186
msgid "Rounding is toward 0."
msgstr "Округление к нулю."

#. type: Plain text
#: man-pages/man3/fenv.3:188
msgid "Rounding is toward nearest number."
msgstr "Округление к ближайшему числу."

#. type: Plain text
#: man-pages/man3/fenv.3:190
msgid "Rounding is toward positive infinity."
msgstr "Округление в сторону положительной бесконечности."

#. type: IP
#: man-pages/man3/fenv.3:190
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: man-pages/man3/fenv.3:192
msgid "Rounding is toward negative infinity."
msgstr "Округление в сторону отрицательной бесконечности."

#. type: Plain text
#: man-pages/man3/fenv.3:194
msgid "Other values represent machine-dependent, nonstandard rounding modes."
msgstr ""
"Существуют другие значения для нестандартных режимов округления, зависящие "
"от архитектуры."

#. type: Plain text
#: man-pages/man3/fenv.3:200
msgid ""
"The value of B<FLT_ROUNDS> should reflect the current rounding mode as set "
"by B<fesetround>()  (but see BUGS)."
msgstr ""
"Значение B<FLT_ROUNDS> должно отражать текущий режим округления, который "
"задаётся с помощью B<fesetround>() (но смотрите ДЕФЕКТЫ)."

#. type: SS
#: man-pages/man3/fenv.3:200
#, no-wrap
msgid "Floating-point environment"
msgstr "Окружение плавающей запятой"

#. type: Plain text
#: man-pages/man3/fenv.3:212
msgid ""
"The entire floating-point environment, including control modes and status "
"flags, can be handled as one opaque object, of type I<fenv_t>.  The default "
"environment is denoted by B<FE_DFL_ENV> (of type I<const fenv_t\\ *>).  This "
"is the environment setup at program start and it is defined by ISO C to have "
"round to nearest, all exceptions cleared and a nonstop (continue on "
"exceptions) mode."
msgstr ""
"С полным окружением плавающей запятой, включая режимы управления и флаги "
"состояния, можно работать через скрытый объект с типом I<fenv_t>. Окружение "
"по умолчанию обозначается как B<FE_DFL_ENV> (с типом I<const fenv_t\\ *>). "
"Это окружение задаётся при запуске программы и определено в ISO C; в нём "
"включено округление к ближайшему числу, все исключения сброшены и задан "
"безостановочный режим (продолжать при возникновении исключений)."

#. type: Plain text
#: man-pages/man3/fenv.3:217
msgid ""
"The B<fegetenv>()  function saves the current floating-point environment in "
"the object I<*envp>."
msgstr ""
"Функция B<fegetenv>() сохраняет текущее окружение плавающей запятой в объект "
"I<*envp>."

#. type: Plain text
#: man-pages/man3/fenv.3:224
msgid ""
"The B<feholdexcept>()  function does the same, then clears all exception "
"flags, and sets a nonstop (continue on exceptions) mode, if available.  It "
"returns zero when successful."
msgstr ""
"Функция B<feholdexcept>() делает то же самое, затем очищает все флаги "
"исключений и включает безостановочный режим (продолжать при возникновении "
"исключений), если он доступен. При успешном выполнении возвращается ноль."

#. type: Plain text
#: man-pages/man3/fenv.3:237
msgid ""
"The B<fesetenv>()  function restores the floating-point environment from the "
"object I<*envp>.  This object must be known to be valid, for example, the "
"result of a call to B<fegetenv>()  or B<feholdexcept>()  or equal to "
"B<FE_DFL_ENV>.  This call does not raise exceptions."
msgstr ""
"Функция B<fesetenv>() восстанавливает окружение плавающей запятой из объекта "
"I<*envp>. Данный объект должен быть корректен, например, должен быть получен "
"из вызова B<fegetenv>() или B<feholdexcept>() или равен B<FE_DFL_ENV>. "
"Данный вызов не возбуждает исключения."

#. type: Plain text
#: man-pages/man3/fenv.3:250
msgid ""
"The B<feupdateenv>()  function installs the floating-point environment "
"represented by the object I<*envp>, except that currently raised exceptions "
"are not cleared.  After calling this function, the raised exceptions will be "
"a bitwise OR of those previously set with those in I<*envp>.  As before, the "
"object I<*envp> must be known to be valid."
msgstr ""
"Функция B<feupdateenv>() устанавливает окружение плавающей запятой, "
"представленное объектом I<*envp>, за исключением того, что уже возбуждённые "
"исключения не очищаются. После вызова этой функции, возбуждённые исключения "
"будут побитово сложены с установленными ранее в I<*envp>. Как и для "
"предыдущей функции, объект I<*envp> должен быть корректен."

#.  Earlier seven of these functions were listed as returning void.
#.  This was corrected in Corrigendum 1 (ISO/IEC 9899:1999/Cor.1:2001(E))
#.  of the C99 Standard.
#. type: Plain text
#: man-pages/man3/fenv.3:255
msgid ""
"These functions return zero on success and nonzero if an error occurred."
msgstr ""
"При успешном выполнении эти функции возвращают ноль и не ноль при ошибке."

#. type: tbl table
#: man-pages/man3/fenv.3:282
#, no-wrap
msgid ""
"B<feclearexcept>(),\n"
"B<fegetexceptflag>(),\n"
"B<feraiseexcept>(),\n"
"B<fesetexceptflag>(),\n"
"B<fetestexcept>(),\n"
"B<fegetround>(),\n"
"B<fesetround>(),\n"
"B<fegetenv>(),\n"
"B<feholdexcept>(),\n"
"B<fesetenv>(),\n"
"B<feupdateenv>(),\n"
"B<feenableexcept>(),\n"
"B<fedisableexcept>(),\n"
"B<fegetexcept>()"
msgstr ""
"B<feclearexcept>(),\n"
"B<fegetexceptflag>(),\n"
"B<feraiseexcept>(),\n"
"B<fesetexceptflag>(),\n"
"B<fetestexcept>(),\n"
"B<fegetround>(),\n"
"B<fesetround>(),\n"
"B<fegetenv>(),\n"
"B<feholdexcept>(),\n"
"B<fesetenv>(),\n"
"B<feupdateenv>(),\n"
"B<feenableexcept>(),\n"
"B<fedisableexcept>(),\n"
"B<fegetexcept>()"

#. type: Plain text
#: man-pages/man3/fenv.3:290
msgid "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."
msgstr "IEC 60559 (IEC 559:1989), ANSI/IEEE 854, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/fenv.3:310
msgid ""
"If possible, the GNU C Library defines a macro B<FE_NOMASK_ENV> which "
"represents an environment where every exception raised causes a trap to "
"occur.  You can test for this macro using B<#ifdef>.  It is defined only if "
"B<_GNU_SOURCE> is defined.  The C99 standard does not define a way to set "
"individual bits in the floating-point mask, for example, to trap on specific "
"flags.  Since version 2.2, glibc supports the functions B<feenableexcept>()  "
"and B<fedisableexcept>()  to set individual floating-point traps, and "
"B<fegetexcept>()  to query the state."
msgstr ""
"Если возможно, библиотека GNU C определяет макрос B<FE_NOMASK_ENV>, "
"представляющий окружение, в котором при каждом возбуждении исключения "
"срабатывает ловушка (trap). Вы можете проверить этот макрос с помощью "
"B<#ifdef>. Он определён, только при определении B<_GNU_SOURCE>. В стандарте "
"C99 нет способа установить отдельные биты в маске плавающей запятой, "
"например, чтобы отловить определённые флаги. Начиная с версии 2.2, в glibc "
"поддерживаются функции B<feenableexcept>() и B<fedisableexcept>(), которые "
"устанавливают отдельные ловушки плавающей запятой, и B<fegetexcept>() для "
"получения состояния."

#. type: Plain text
#: man-pages/man3/fenv.3:314
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fenv.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>fenv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:318
#, no-wrap
msgid ""
"B<int feenableexcept(int >I<excepts>B<);>\n"
"B<int fedisableexcept(int >I<excepts>B<);>\n"
"B<int fegetexcept(void);>\n"
msgstr ""
"B<int feenableexcept(int >I<excepts>B<);>\n"
"B<int fedisableexcept(int >I<excepts>B<);>\n"
"B<int fegetexcept(void);>\n"

#. type: Plain text
#: man-pages/man3/fenv.3:331
msgid ""
"The B<feenableexcept>()  and B<fedisableexcept>()  functions enable "
"(disable) traps for each of the exceptions represented by I<excepts> and "
"return the previous set of enabled exceptions when successful, and -1 "
"otherwise.  The B<fegetexcept>()  function returns the set of all currently "
"enabled exceptions."
msgstr ""
"Функции B<feenableexcept>() и B<fedisableexcept>() включают (отключают) "
"ловушки для каждого исключения, представленного в I<excepts>, и при успешном "
"выполнении возвращают старый набор включённых исключений, и  -1 в противном "
"случае. Функция B<fegetexcept>() возвращает набор всех включённых в данных "
"момент исключений."

#.  Aug 08, glibc 2.8
#.  See http://gcc.gnu.org/ml/gcc/2002-02/msg01535.html
#. type: Plain text
#: man-pages/man3/fenv.3:342
msgid ""
"C99 specifies that the value of B<FLT_ROUNDS> should reflect changes to the "
"current rounding mode, as set by B<fesetround>().  Currently, this does not "
"occur: B<FLT_ROUNDS> always has the value 1."
msgstr ""
"В C99 указано, что значение B<FLT_ROUNDS> должно отражать изменения текущего "
"режима округления, устанавливаемого с помощью B<fesetround>(). В настоящее "
"время это не выполняется: значение B<FLT_ROUNDS> всегда равно 1."

#. type: Plain text
#: man-pages/man3/fenv.3:343
msgid "B<math_error>(7)"
msgstr "B<math_error>(7)"

#. type: TH
#: man-pages/man3/fpclassify.3:10
#, no-wrap
msgid "FPCLASSIFY"
msgstr "FPCLASSIFY"

#. type: Plain text
#: man-pages/man3/fpclassify.3:14
msgid ""
"fpclassify, isfinite, isnormal, isnan, isinf - floating-point classification "
"macros"
msgstr ""
"fpclassify, isfinite, isnormal, isnan, isinf - макросы классификации чисел с "
"плавающей запятой"

#. type: Plain text
#: man-pages/man3/fpclassify.3:19
#, no-wrap
msgid "B<int fpclassify(>I<x>B<);>\n"
msgstr "B<int fpclassify(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:21
#, no-wrap
msgid "B<int isfinite(>I<x>B<);>\n"
msgstr "B<int isfinite(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:23
#, no-wrap
msgid "B<int isnormal(>I<x>B<);>\n"
msgstr "B<int isnormal(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:25
#, no-wrap
msgid "B<int isnan(>I<x>B<);>\n"
msgstr "B<int isnan(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:27
#, no-wrap
msgid "B<int isinf(>I<x>B<);>\n"
msgstr "B<int isinf(>I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:42
msgid "B<fpclassify>(), B<isfinite>(), B<isnormal>():"
msgstr "B<fpclassify>(), B<isfinite>(), B<isnormal>():"

#. type: Plain text
#: man-pages/man3/fpclassify.3:51
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/fpclassify.3:69
msgid ""
"Floating point numbers can have special values, such as infinite or NaN.  "
"With the macro B<fpclassify(>I<x>B<)> you can find out what type I<x> is.  "
"The macro takes any floating-point expression as argument.  The result is "
"one of the following values:"
msgstr ""
"У чисел с плавающей запятой есть специальные значения, например для "
"бесконечности или NaN. С помощью макроса B<fpclassify(>I<x>B<)> вы можете "
"выяснить тип I<x>. В качестве аргумента макрос принимает любое выражение с "
"плавающей запятой. Результатом будет одно из следующих значений:"

#. type: TP
#: man-pages/man3/fpclassify.3:69
#, no-wrap
msgid "B<FP_NAN>"
msgstr "B<FP_NAN>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:73
msgid "I<x> is \"Not a Number\"."
msgstr "Значение I<x> не является числом («Not a Number»)."

#. type: TP
#: man-pages/man3/fpclassify.3:73
#, no-wrap
msgid "B<FP_INFINITE>"
msgstr "B<FP_INFINITE>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:77
msgid "I<x> is either positive infinity or negative infinity."
msgstr "Значение I<x> стремится к плюс или минус бесконечности."

#. type: TP
#: man-pages/man3/fpclassify.3:77
#, no-wrap
msgid "B<FP_ZERO>"
msgstr "B<FP_ZERO>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:81
msgid "I<x> is zero."
msgstr "Значение I<x> равно нулю."

#. type: TP
#: man-pages/man3/fpclassify.3:81
#, no-wrap
msgid "B<FP_SUBNORMAL>"
msgstr "B<FP_SUBNORMAL>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:85
msgid "I<x> is too small to be represented in normalized format."
msgstr ""
"Значение I<x> слишком мало для представления в нормализованном формате."

#. type: TP
#: man-pages/man3/fpclassify.3:85
#, no-wrap
msgid "B<FP_NORMAL>"
msgstr "B<FP_NORMAL>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:89
msgid ""
"if nothing of the above is correct then it must be a normal floating-point "
"number."
msgstr ""
"Если значение не равно ни одному из вышеперечисленных, то это обычное число "
"с плавающей запятой."

#. type: Plain text
#: man-pages/man3/fpclassify.3:91
msgid "The other macros provide a short answer to some standard questions."
msgstr ""
"Остальные макросы предоставляют короткие ответы на некоторые стандартные "
"вопросы."

#. type: TP
#: man-pages/man3/fpclassify.3:91
#, no-wrap
msgid "B<isfinite(>I<x>B<)>"
msgstr "B<isfinite(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:94
msgid "returns a nonzero value if"
msgstr "возвращает ненулевое значение, если"

#. type: Plain text
#: man-pages/man3/fpclassify.3:96
msgid "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"
msgstr "(fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE)"

#. type: TP
#: man-pages/man3/fpclassify.3:96
#, no-wrap
msgid "B<isnormal(>I<x>B<)>"
msgstr "B<isnormal(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:100
msgid "returns a nonzero value if (fpclassify(x) == FP_NORMAL)"
msgstr "возвращает ненулевое значение, если (fpclassify(x) == FP_NORMAL)"

#. type: TP
#: man-pages/man3/fpclassify.3:100
#, no-wrap
msgid "B<isnan(>I<x>B<)>"
msgstr "B<isnan(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:104
msgid "returns a nonzero value if (fpclassify(x) == FP_NAN)"
msgstr "возвращает ненулевое значение, если (fpclassify(x) == FP_NAN)"

#. type: TP
#: man-pages/man3/fpclassify.3:104
#, no-wrap
msgid "B<isinf(>I<x>B<)>"
msgstr "B<isinf(>I<x>B<)>"

#. type: Plain text
#: man-pages/man3/fpclassify.3:111
msgid ""
"returns 1 if I<x> is positive infinity, and -1 if I<x> is negative infinity."
msgstr ""
"возвращает 1, если I<x> равно положительной бесконечности и -1, если I<x> "
"равно отрицательной бесконечности."

#. type: tbl table
#: man-pages/man3/fpclassify.3:126
#, no-wrap
msgid ""
"B<fpclassify>(),\n"
"B<isfinite>(),\n"
"B<isnormal>(),\n"
"B<isnan>(),\n"
"B<isinf>()"
msgstr ""
"B<fpclassify>(),\n"
"B<isfinite>(),\n"
"B<isnormal>(),\n"
"B<isnan>(),\n"
"B<isinf>()"

#. type: Plain text
#: man-pages/man3/fpclassify.3:136
msgid ""
"For B<isinf>(), the standards merely say that the return value is nonzero if "
"and only if the argument has an infinite value."
msgstr ""
"Про B<isinf>() в стандартах лишь сказано, что этот макрос возвращает "
"ненулевое значение, если только аргумент равен бесконечности."

#. type: Plain text
#: man-pages/man3/fpclassify.3:143
msgid ""
"In glibc 2.01 and earlier, B<isinf>()  returns a nonzero value (actually: 1) "
"if I<x> is positive infinity or negative infinity.  (This is all that C99 "
"requires.)"
msgstr ""
"В glibc 2.01 и более ранних B<isinf>() возвращает ненулевое значение (а "
"именно 1), если I<x> равно положительной или отрицательной бесконечности "
"(это всё, что требует C99)."

#. type: Plain text
#: man-pages/man3/fpclassify.3:147
msgid "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"
msgstr "B<finite>(3), B<INFINITY>(3), B<isgreater>(3), B<signbit>(3)"

#. type: TH
#: man-pages/man3/fpurge.3:25
#, no-wrap
msgid "FPURGE"
msgstr "FPURGE"

#. type: Plain text
#: man-pages/man3/fpurge.3:28
msgid "fpurge, __fpurge - purge a stream"
msgstr "fpurge, __fpurge - вычищает поток"

#. type: Plain text
#: man-pages/man3/fpurge.3:32
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"/* не поддерживается */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:34
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<int fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:38
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""
"/* поддерживается */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>stdio_ext.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:40
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<void  __fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fpurge.3:53
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""
"Функция B<fpurge>() очищает буферы указанного потока. При этом для потоков "
"вывода отбрасываются все незаписанные данные. Для потоков ввода "
"отбрасывается все данные, полученные от объекта, но ещё не выбранные "
"B<getc>(3), в том числе, любой текст, занесённый с помощью B<ungetc>(3). "
"Смотрите также B<fflush>(3)."

#. type: Plain text
#: man-pages/man3/fpurge.3:57
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a "
"value."
msgstr ""
"Функция B<__fpurge>() делает то же самое, но не возвращает никакого значения."

#. type: Plain text
#: man-pages/man3/fpurge.3:64
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""
"При успешном выполнении B<fpurge>() возвращает 0. При ошибке возвращается -1 "
"и переменная I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man3/fpurge.3:69
msgid "I<stream> is not an open stream."
msgstr "Значение I<stream> не является открытым потоком."

#. type: tbl table
#: man-pages/man3/fpurge.3:79
#, no-wrap
msgid "B<__fpurge>()"
msgstr "B<__fpurge>()"

#. type: tbl table
#: man-pages/man3/fpurge.3:79
#, no-wrap
msgid "MT-Safe race:stream"
msgstr "MT-Safe race:stream"

#. type: Plain text
#: man-pages/man3/fpurge.3:90
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()  "
"was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and "
"later."
msgstr ""
"Эти функции нестандартны и не являются переносимыми. Функция B<fpurge>() "
"появилась из BSD 4.4 и отсутствует в Linux. Функция B<__fpurge>() появилась "
"из Solaris и включена в glibc начиная с версии 2.1.95."

#. type: Plain text
#: man-pages/man3/fpurge.3:92
msgid "Usually it is a mistake to want to discard input buffers."
msgstr "Как правило, отбрасывать содержимое буферов ввода является ошибкой."

#.  .BR fclean (3),
#. type: Plain text
#: man-pages/man3/fpurge.3:96
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"

#. type: TH
#: man-pages/man3/futimes.3:25
#, no-wrap
msgid "FUTIMES"
msgstr "FUTIMES"

#. type: Plain text
#: man-pages/man3/futimes.3:28
msgid "futimes, lutimes - change file timestamps"
msgstr "futimes, lutimes - изменяют метки времени файла"

#. type: Plain text
#: man-pages/man3/futimes.3:31
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/futimes.3:33
#, no-wrap
msgid "B<int futimes(int >I<fd>B<, const struct timeval >I<tv>B<[2]);>\n"
msgstr "B<int futimes(int >I<fd>B<, const struct timeval >I<tv>B<[2]);>\n"

#. type: Plain text
#: man-pages/man3/futimes.3:35
#, no-wrap
msgid "B<int lutimes(const char *>I<filename>B<, const struct timeval >I<tv>B<[2]);>\n"
msgstr "B<int lutimes(const char *>I<filename>B<, const struct timeval >I<tv>B<[2]);>\n"

#. type: Plain text
#: man-pages/man3/futimes.3:48
#, no-wrap
msgid ""
"B<futimes>(),\n"
"B<lutimes>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<futimes>(),\n"
"B<lutimes>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/futimes.3:56
msgid ""
"B<futimes>()  changes the access and modification times of a file in the "
"same way as B<utimes>(2), with the difference that the file whose timestamps "
"are to be changed is specified via a file descriptor, I<fd>, rather than via "
"a pathname."
msgstr ""
"Функция B<futimes>() изменяет время доступа и изменения файла также как это "
"делает B<utimes>(2); единственное отличие в том, что файл чьи временные "
"метки изменяются, указывается в виде файлового дескриптора, I<fd>, а не в "
"виде пути."

#. type: Plain text
#: man-pages/man3/futimes.3:64
msgid ""
"B<lutimes>()  changes the access and modification times of a file in the "
"same way as B<utimes>(2), with the difference that if I<filename> refers to "
"a symbolic link, then the link is not dereferenced: instead, the timestamps "
"of the symbolic link are changed."
msgstr ""
"Функция B<lutimes>() изменяет время доступа и изменения файла также как это "
"делает B<utimes>(2); единственное отличие в том, что если I<filename> "
"является символьной ссылкой, то ссылка не разыменовывается — изменяются "
"метки времени самой ссылки."

#. type: Plain text
#: man-pages/man3/futimes.3:74
msgid ""
"Errors are as for B<utimes>(2), with the following additions for "
"B<futimes>():"
msgstr ""
"Возникают те же ошибки что и для B<utimes>(2), а также дополнительно для "
"B<futimes>():"

#. type: Plain text
#: man-pages/man3/futimes.3:78
msgid "I<fd> is not a valid file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man3/futimes.3:83
msgid "The I</proc> filesystem could not be accessed."
msgstr "Нет доступа к файловой системе I</proc>."

#. type: Plain text
#: man-pages/man3/futimes.3:86
msgid "The following additional error may occur for B<lutimes>():"
msgstr "Для B<lutimes>() может возникать следующая дополнительная ошибка:"

#. type: Plain text
#: man-pages/man3/futimes.3:89
msgid ""
"The kernel does not support this call; Linux 2.6.22 or later is required."
msgstr ""
"Ядро не поддерживает этот вызов; требуется Linux версии 2.6.22 или новее."

#. type: Plain text
#: man-pages/man3/futimes.3:96
msgid ""
"B<futimes>()  is available since glibc 2.3.  B<lutimes>()  is available "
"since glibc 2.6, and is implemented using the B<utimensat>(2)  system call, "
"which is supported since kernel 2.6.22."
msgstr ""
"Функция B<futimes>() доступна в glibc начиная с версии 2.3. Функция "
"B<lutimes>() доступа в glibc начиная с версии 2.6, и реализована на основе "
"системного вызова B<utimensat>(2), который поддерживается в ядре начиная с "
"версии 2.6.22."

#. type: tbl table
#: man-pages/man3/futimes.3:107
#, no-wrap
msgid ""
"B<futimes>(),\n"
"B<lutimes>()"
msgstr ""
"B<futimes>(),\n"
"B<lutimes>()"

#. type: Plain text
#: man-pages/man3/futimes.3:112
msgid ""
"These functions are not specified in any standard.  Other than Linux, they "
"are available only on the BSDs."
msgstr ""
"Эти функции не определены ни в одном стандарте. Помимо Linux, они доступны "
"только в некоторых BSD."

#. type: Plain text
#: man-pages/man3/futimes.3:115
msgid "B<utime>(2), B<utimensat>(2), B<symlink>(7)"
msgstr "B<utime>(2), B<utimensat>(2), B<symlink>(7)"

#. type: TH
#: man-pages/man3/fgetgrent.3:30
#, no-wrap
msgid "FGETGRENT"
msgstr "FGETGRENT"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:33
msgid "fgetgrent - get group file entry"
msgstr "fgetgrent - возвращает запись из файла групп"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:38
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:40
#, no-wrap
msgid "B<struct group *fgetgrent(FILE *>I<stream>B<);>\n"
msgstr "B<struct group *fgetgrent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:52
#, no-wrap
msgid ""
"B<fgetgrent>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""
"B<fgetgrent>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:66
msgid ""
"The B<fgetgrent>()  function returns a pointer to a structure containing the "
"group information from the file referred to by I<stream>.  The first time it "
"is called it returns the first entry; thereafter, it returns successive "
"entries.  The file referred to by I<stream> must have the same format as I</"
"etc/group> (see B<group>(5))."
msgstr ""
"Функция B<fgetgrent>() возвращает указатель на структуру, содержащую "
"информацию о группах из файла, на который ссылается I<stream>. Во время "
"первого вызова функция возвращает первую запись; в дальнейшем она возвращает "
"все последующие записи. Формат файла, на который указывает I<stream>, должен "
"быть таким же как у I</etc/group> (смотрите B<group>(5))."

#. type: Plain text
#: man-pages/man3/fgetgrent.3:68
msgid "The I<group> structure is defined in I<E<lt>grp.hE<gt>> as follows:"
msgstr "Структура I<group> определена в I<E<lt>grp.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:78
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;        /* group name */\n"
"    char   *gr_passwd;      /* group password */\n"
"    gid_t   gr_gid;         /* group ID */\n"
"    char  **gr_mem;         /* NULL-terminated array of pointers\n"
"                               to names of group members */\n"
"};\n"
msgstr ""
"struct group {\n"
"    char   *gr_name;        /* имя группы */\n"
"    char   *gr_passwd;      /* пароль группы */\n"
"    gid_t   gr_gid;         /* ID группы */\n"
"    char  **gr_mem;         /* массив, указателей\n"
"                               имён членов группы, оканчивающийся NULL */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:90
msgid ""
"The B<fgetgrent>()  function returns a pointer to a I<group> structure, or "
"NULL if there are no more entries or an error occurs.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<fgetgrent>() возвращает указатель на структуру I<group> или NULL, "
"если больше записей не найдено или произошла ошибка. При ошибке I<errno> "
"присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man3/fgetgrent.3:96
msgid "Insufficient memory to allocate I<group> structure."
msgstr "Недостаточно памяти для структуры I<group>."

#. type: tbl table
#: man-pages/man3/fgetgrent.3:106
#, no-wrap
msgid "B<fgetgrent>()"
msgstr "B<fgetgrent>()"

#. type: tbl table
#: man-pages/man3/fgetgrent.3:106
#, no-wrap
msgid "MT-Unsafe race:fgetgrent"
msgstr "MT-Unsafe race:fgetgrent"

#. type: Plain text
#: man-pages/man3/fgetgrent.3:128
msgid ""
"B<endgrent>(3), B<fgetgrent_r>(3), B<fopen>(3), B<getgrent>(3), "
"B<getgrgid>(3), B<getgrnam>(3), B<putgrent>(3), B<setgrent>(3), B<group>(5)"
msgstr ""
"B<endgrent>(3), B<fgetgrent_r>(3), B<fopen>(3), B<getgrent>(3), "
"B<getgrgid>(3), B<getgrnam>(3), B<putgrent>(3), B<setgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/ftok.3:29
#, no-wrap
msgid "FTOK"
msgstr "FTOK"

#. type: Plain text
#: man-pages/man3/ftok.3:32
msgid ""
"ftok - convert a pathname and a project identifier to a System V IPC key"
msgstr "ftok - преобразует путь и идентификатор проекта в ключ System V IPC"

#. type: Plain text
#: man-pages/man3/ftok.3:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ftok.3:39
msgid "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"
msgstr "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"

#. type: Plain text
#: man-pages/man3/ftok.3:54
msgid ""
"The B<ftok>()  function uses the identity of the file named by the given "
"I<pathname> (which must refer to an existing, accessible file)  and the "
"least significant 8 bits of I<proj_id> (which must be nonzero) to generate a "
"I<key_t> type System V IPC key, suitable for use with B<msgget>(2), "
"B<semget>(2), or B<shmget>(2)."
msgstr ""
"Функция B<ftok>() использует отличительные свойства (identity) файла с "
"именем I<pathname> (которое должно указывать на существующий и доступный "
"файл) и младшие 8 бит аргумента I<proj_id> (который должен быть не равен "
"нулю) для генерации ключа System V IPC I<key_t>, который пригоден для работы "
"с B<msgget>(2), B<semget>(2) или B<shmget>(2)."

#. type: Plain text
#: man-pages/man3/ftok.3:61
msgid ""
"The resulting value is the same for all pathnames that name the same file, "
"when the same value of I<proj_id> is used.  The value returned should be "
"different when the (simultaneously existing) files or the project IDs differ."
msgstr ""
"Возвращаемое значение одинаково для всех имён, указывающих на один и тот же "
"файл при одинаковом значении I<proj_id>. Возвращаемое значение будет "
"отличаться, когда (одновременно существующие) файлы или идентификаторы "
"проекта различаются."

#. type: Plain text
#: man-pages/man3/ftok.3:70
msgid ""
"On success, the generated I<key_t> value is returned.  On failure -1 is "
"returned, with I<errno> indicating the error as for the B<stat>(2)  system "
"call."
msgstr ""
"При успешном выполнении возвращается сгенерированное значение I<key_t>. При "
"ошибке возвращается -1, а в переменную I<errno> записывается код ошибки "
"согласно системному вызову B<stat>(2)."

#. type: tbl table
#: man-pages/man3/ftok.3:80
#, no-wrap
msgid "B<ftok>()"
msgstr "B<ftok>()"

#. type: Plain text
#: man-pages/man3/ftok.3:86
msgid "On some ancient systems, the prototype was:"
msgstr "В некоторых старых системах прототип выглядел как:"

#. type: Plain text
#: man-pages/man3/ftok.3:90
#, no-wrap
msgid "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>\n"
msgstr "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>\n"

#. type: Plain text
#: man-pages/man3/ftok.3:103
msgid ""
"Today, I<proj_id> is an I<int>, but still only 8 bits are used.  Typical "
"usage has an ASCII character I<proj_id>, that is why the behavior is said to "
"be undefined when I<proj_id> is zero."
msgstr ""
"В наши дни I<proj_id> имеет тип I<int>, хотя, как правило, по-прежнему из "
"него используется только 8 бит. Обычно, при вызове этой функции в качестве "
"I<proj_id> передаётся символ ASCII, именно поэтому поведение функции "
"считается не определённым, если I<proj_id> равен нулю."

#. type: Plain text
#: man-pages/man3/ftok.3:115
msgid ""
"Of course, no guarantee can be given that the resulting I<key_t> is unique.  "
"Typically, a best-effort attempt combines the given I<proj_id> byte, the "
"lower 16 bits of the inode number, and the lower 8 bits of the device number "
"into a 32-bit result.  Collisions may easily happen, for example between "
"files on I</dev/hda1> and files on I</dev/sda1>."
msgstr ""
"Естественно, не гарантируется, что возвращаемый I<key_t> уникален. Обычно "
"производится объединение указанного байта I<proj_id> с младшими 16 битами "
"номера inode и младшими 8 битам номера устройства в 32-битный результат. "
"Легко могут возникать повторения, например между файлами на I</dev/hda1> и "
"файлами на I</dev/sda1>."

#. type: Plain text
#: man-pages/man3/ftok.3:120
msgid "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<sysvipc>(7)"
msgstr "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<sysvipc>(7)"

#. type: TH
#: man-pages/man3/fopen.3:44
#, no-wrap
msgid "FOPEN"
msgstr "FOPEN"

#. type: TH
#: man-pages/man3/fopen.3:44
#, no-wrap
msgid "2019-05-09"
msgstr "2019-05-09"

#. type: Plain text
#: man-pages/man3/fopen.3:47
msgid "fopen, fdopen, freopen - stream open functions"
msgstr "fopen, fdopen, freopen - функции для открытия потоков"

#. type: Plain text
#: man-pages/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fopen(const char *>I<pathname>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fopen(const char *>I<pathname>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopen.3:54
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopen.3:56
#, no-wrap
msgid "B<FILE *freopen(const char *>I<pathname>B<, const char *>I<mode>B<, FILE *>I<stream>B<);>\n"
msgstr "B<FILE *freopen(const char *>I<pathname>B<, const char *>I<mode>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/fopen.3:65
msgid "B<fdopen>(): _POSIX_C_SOURCE"
msgstr "B<fdopen>(): _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man3/fopen.3:71
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<pathname> and associates a stream with it."
msgstr ""
"Функция B<fopen>() открывает файл с именем, которое задано в виде строки в "
"I<pathname>, и связывает его с потоком."

#. type: Plain text
#: man-pages/man3/fopen.3:76
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (possibly followed by additional characters, as described below):"
msgstr ""
"Параметр I<mode> указывает на строку, начинающуюся с одной из следующих "
"последовательностей (за ними могут следовать дополнительные символы, "
"описанные далее):"

#. type: TP
#: man-pages/man3/fopen.3:76
#, no-wrap
msgid "B<r>"
msgstr "B<r>"

#. type: Plain text
#: man-pages/man3/fopen.3:80
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr "Открыть текстовый файл для чтения. Поток совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:80
#, no-wrap
msgid "B<r+>"
msgstr "B<r+>"

#. type: Plain text
#: man-pages/man3/fopen.3:84
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr "Открыть для чтения и записи. Поток совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:84
#, no-wrap
msgid "B<w>"
msgstr "B<w>"

#. type: Plain text
#: man-pages/man3/fopen.3:88
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is "
"positioned at the beginning of the file."
msgstr ""
"Обрезать файл до нулевой длины или создать текстовый файл для записи. Поток "
"совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:88
#, no-wrap
msgid "B<w+>"
msgstr "B<w+>"

#. type: Plain text
#: man-pages/man3/fopen.3:94
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the "
"file."
msgstr ""
"Открыть для чтения и записи. Файл создаётся, если его не существует, в "
"противном случае он обрезается. Поток совмещается с началом файла."

#. type: TP
#: man-pages/man3/fopen.3:94
#, no-wrap
msgid "B<a>"
msgstr "B<a>"

#. type: Plain text
#: man-pages/man3/fopen.3:99
msgid ""
"Open for appending (writing at end of file).  The file is created if it does "
"not exist.  The stream is positioned at the end of the file."
msgstr ""
"Открыть для добавления (записи в конец файла). Файл создаётся, если его не "
"существует. Поток совмещается с концом файла."

#. type: TP
#: man-pages/man3/fopen.3:99
#, no-wrap
msgid "B<a+>"
msgstr "B<a+>"

#. type: Plain text
#: man-pages/man3/fopen.3:108
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  Output is always appended to the end of the "
"file.  POSIX is silent on what the initial read position is when using this "
"mode.  For glibc, the initial file position for reading is at the beginning "
"of the file, but for Android/BSD/MacOS, the initial file position for "
"reading is at the end of the file."
msgstr ""
"Открыть для чтения и добавления (записи в конец файла). Файл создаётся, если "
"не существует. Вывод всегда добавляется в конец файла. В POSIX ничего не "
"упоминается о начальном положении при чтении, когда используется данный "
"режим. В glibc начальное положение в файле для чтения устанавливается в "
"начало файла, но в Android/BSD/MacOS начальное положение в файле для чтения "
"устанавливается в конец файла."

#. type: Plain text
#: man-pages/man3/fopen.3:121
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the two-"
"character strings described above.  This is strictly for compatibility with "
"C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX conforming "
"systems, including Linux.  (Other systems may treat text files and binary "
"files differently, and adding the \\(aqb\\(aq may be a good idea if you do I/"
"O to a binary file and expect that your program may be ported to non-UNIX "
"environments.)"
msgstr ""
"Строка I<mode> может также содержать символ «b» в качестве последнего "
"символа или символа между двумя символами в любых описанных выше "
"двухсимвольных комбинациях. Это требуется только для совместимости с C89 и "
"не оказывает никакого влияния; символ «b» игнорируется во всех POSIX-"
"совместимых системах, включая Linux. Другие системы могут по-разному "
"обращаться с текстовыми и двоичными файлами, и добавление «b» может "
"оказаться полезным, если вы осуществляете ввод-вывод в двоичный файл и "
"ожидаете, что ваша программа может быть перенесена в не UNIX окружение."

#. type: Plain text
#: man-pages/man3/fopen.3:124
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr "О имеющихся расширениях I<mode> в glibc смотрите ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man3/fopen.3:129
msgid ""
"Any created file will have the mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""
"Любой созданный файл будет иметь атрибуты B<S_IRUSR> | B<S_IWUSR> | "
"B<S_IRGRP> | B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), как изменённые в "
"соответствии со значением umask процесса (смотрите B<umask>(2))."

#. type: Plain text
#: man-pages/man3/fopen.3:144
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note "
"that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or "
"B<fgetpos>(3)  operation between write and read operations on such a "
"stream.  This operation may be an apparent no-op (as in I<fseek(..., 0L, "
"SEEK_CUR)> called for its synchronizing side effect)."
msgstr ""
"Чтение и запись могут перемешиваться друг с другом в потоке, открытом для "
"чтения/записи, в любом порядке). Заметим, что в ANSI C требуется, чтобы "
"между выводом и вводом использовались функции позиционирования в файле, если "
"операция ввода не встретила конец файла. Если это условие не выполняется, то "
"при чтении разрешается возвращать результат, не совпадающий с данными самой "
"последней записи. Поэтому рекомендуется (а иногда и действительно необходимо "
"в Linux) использовать функции B<fseek>(3) или B<fgetpos>(3) между операциями "
"чтения и записи в одном потоке. Эти операции могут фактически быть пустыми "
"(например, I<fseek(..., 0L, SEEK_CUR)>, вызванная для того, чтобы возник её "
"побочный эффект синхронизации)."

#. type: Plain text
#: man-pages/man3/fopen.3:149
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at end-of-"
"file, as if preceded the call:"
msgstr ""
"Открытие файла в режиме дописывания (B<a> в качестве первого символа "
"I<mode>) приводит к тому, что все последующие операции записи в этот поток "
"производятся в конец файла, как если бы перед ними была вызвана:"

#. type: Plain text
#: man-pages/man3/fopen.3:153
#, no-wrap
msgid "fseek(stream, 0, SEEK_END);\n"
msgstr "fseek(stream, 0, SEEK_END);\n"

#. type: Plain text
#: man-pages/man3/fopen.3:159
msgid ""
"The file descriptor associated with the stream is opened as if by a call to "
"B<open>(2)  with the following flags:"
msgstr ""
"Файловый дескриптор, связанный с потоком, открывается как при вызове "
"B<open>(2) со следующими флагами:"

#. type: tbl table
#: man-pages/man3/fopen.3:164
#, no-wrap
msgid "fopen() mode"
msgstr "режим fopen()"

#. type: tbl table
#: man-pages/man3/fopen.3:164
#, no-wrap
msgid "open() flags"
msgstr "флаги open()"

#. type: tbl table
#: man-pages/man3/fopen.3:165
#, no-wrap
msgid "O_RDONLY"
msgstr "O_RDONLY"

#. type: tbl table
#: man-pages/man3/fopen.3:166
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_TRUNC"
msgstr "O_WRONLY | O_CREAT | O_TRUNC"

#. type: tbl table
#: man-pages/man3/fopen.3:167
#, no-wrap
msgid "O_WRONLY | O_CREAT | O_APPEND"
msgstr "O_WRONLY | O_CREAT | O_APPEND"

#. type: tbl table
#: man-pages/man3/fopen.3:168
#, no-wrap
msgid "O_RDWR"
msgstr "O_RDWR"

#. type: tbl table
#: man-pages/man3/fopen.3:169
#, no-wrap
msgid "O_RDWR | O_CREAT | O_TRUNC"
msgstr "O_RDWR | O_CREAT | O_TRUNC"

#. type: tbl table
#: man-pages/man3/fopen.3:170
#, no-wrap
msgid "O_RDWR | O_CREAT | O_APPEND"
msgstr "O_RDWR | O_CREAT | O_APPEND"

#. type: SS
#: man-pages/man3/fopen.3:174
#, no-wrap
msgid "fdopen()"
msgstr "fdopen()"

#. type: Plain text
#: man-pages/man3/fopen.3:196
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", \"r+"
"\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of the "
"file descriptor.  The file position indicator of the new stream is set to "
"that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by "
"B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""
"Функция B<fdopen>() связывает поток с существующим дескриптором файла I<fd>. "
"Режим I<mode> потока (одно из следующих значений: «r», «r+», «w», ,w+», «a», "
"«a+») должен быть совместим с режимом дескриптора файла. Указатель положения "
"в файле в новом потоке принимает значение, равное значению у I<fd>, а "
"указатели ошибок и конца файла очищаются. Режимы «w» или «w+» не обрезают "
"файл. При этом не делается копия дескриптора файла и он будет закрыт "
"одновременно с закрытием потока, созданного B<fdopen>(). Результат "
"применения B<fdopen>() к общему объекту памяти не определён."

#. type: SS
#: man-pages/man3/fopen.3:196
#, no-wrap
msgid "freopen()"
msgstr "freopen()"

#. type: Plain text
#: man-pages/man3/fopen.3:210
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<pathname> and associates the stream pointed to by I<stream> with "
"it.  The original stream (if it exists) is closed.  The I<mode> argument is "
"used just as in the B<fopen>()  function."
msgstr ""
"Функция B<freopen>() открывает файл с именем I<pathname> и связывает его с "
"потоком, указанным в I<stream>. Исходный поток (если такой существовал) "
"закрывается. Значение параметра I<mode> такое же как для функции B<fopen>()."

#. type: Plain text
#: man-pages/man3/fopen.3:221
msgid ""
"If the I<pathname> argument is a null pointer, B<freopen>()  changes the "
"mode of the stream to that specified in I<mode>; that is, B<freopen>()  "
"reopens the pathname that is associated with the stream.  The specification "
"for this behavior was added in the C99 standard, which says:"
msgstr ""
"Если значение I<pathname> равно указателю null, то B<freopen>() изменяет "
"режим потока на указанный в I<mode>; то есть, B<freopen>() переоткрывает "
"pathname, связанный с потоком. Описание этого поведения было добавлено в "
"стандарт C99, где сказано:"

#. type: Plain text
#: man-pages/man3/fopen.3:230
msgid ""
"In this case, the file descriptor associated with the stream need not be "
"closed if the call to B<freopen>()  succeeds.  It is implementation-defined "
"which changes of mode are permitted (if any), and under what circumstances."
msgstr ""
"В этом случае файловый дескриптор, связанный с потоком, не нужно закрывать, "
"если вызов B<freopen>() завершился без ошибок. Допустимость изменения режима "
"и при каких условиях определяется реализацией."

#. type: Plain text
#: man-pages/man3/fopen.3:236
msgid ""
"The primary use of the B<freopen>()  function is to change the file "
"associated with a standard text stream (I<stderr>, I<stdin>, or I<stdout>)."
msgstr ""
"Основной задачей функции B<freopen>() является смена файла, связанного со "
"стандартным текстовым потоком (I<stderr>, I<stdin> или I<stdout>)."

#. type: Plain text
#: man-pages/man3/fopen.3:248
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>()  and B<freopen>()  return "
"a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"При успешном выполнении B<fopen>(), B<fdopen>() и B<freopen>() возвращается "
"указатель I<FILE>. В противном случае возвращается NULL и I<errno> "
"присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/fopen.3:259
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""
"Передано неверное значение I<mode> в B<fopen>(), B<fdopen>() или "
"B<freopen>()."

#. type: Plain text
#: man-pages/man3/fopen.3:269
msgid ""
"The B<fopen>(), B<fdopen>()  and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""
"Функции B<fopen>(), B<fdopen>() и B<freopen>() могут также завершаться с "
"ошибками и устанавливают значение I<errno> равным какому-либо значению из "
"определённых в B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/fopen.3:276
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""
"Функция B<fopen>() при ошибках устанавливает значение I<errno> равным какому-"
"либо значению из определённых в B<open>(2)."

#. type: Plain text
#: man-pages/man3/fopen.3:283
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""
"Функция B<fdopen>() при ошибках устанавливает значение I<errno> равным "
"какому-либо значению из определённых в B<fcntl>(2)."

#. type: Plain text
#: man-pages/man3/fopen.3:293
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3), and B<fflush>(3)."
msgstr ""
"Функция B<freopen>() при ошибках устанавливает I<errno> равным какому-либо "
"значению из определённых в B<open>(2), B<fclose>(3) и B<fflush>(3)."

#. type: tbl table
#: man-pages/man3/fopen.3:305
#, no-wrap
msgid ""
"B<fopen>(),\n"
"B<fdopen>(),\n"
"B<freopen>()"
msgstr ""
"B<fopen>(),\n"
"B<fdopen>(),\n"
"B<freopen>()"

#. type: Plain text
#: man-pages/man3/fopen.3:311
msgid "B<fopen>(), B<freopen>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "B<fopen>(), B<freopen>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man3/fopen.3:314
msgid "B<fdopen>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<fdopen>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/fopen.3:318
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr "Библиотека GNU C предоставляет следующие расширения строки в I<mode>:"

#. type: TP
#: man-pages/man3/fopen.3:318
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr "B<c> (начиная с glibc 2.3.3)"

#. type: Plain text
#: man-pages/man3/fopen.3:325
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points.  This flag is ignored for B<fdopen>()."
msgstr ""
"Не выполнять операцию открытия, последующие чтение и запись, точки отмены "
"нити (thread cancellation points). Этот флаг игнорируется для B<fdopen>()."

#. type: TP
#: man-pages/man3/fopen.3:325
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr "B<e> (начиная с glibc 2.7)"

#. type: Plain text
#: man-pages/man3/fopen.3:335
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information.  This flag is ignored for B<fdopen>()."
msgstr ""
"Открыть файл с флагом B<O_CLOEXEC>. Подробности смотрите в B<open>(2). Этот "
"флаг игнорируется для B<fdopen>()."

#. type: TP
#: man-pages/man3/fopen.3:335
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr "B<m> (начиная с glibc 2.3)"

#.  As at glibc 2.4:
#. type: Plain text
#: man-pages/man3/fopen.3:347
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is attempted only "
"for a file opened for reading."
msgstr ""
"Пытаться получить доступ к файлу с помощью B<mmap>(2), а не с помощью "
"системных операций ввода-вывода (B<read>(2), B<write>(2)). В настоящее время "
"B<mmap>(2) используется только для файла, открытого на чтение."

#. type: TP
#: man-pages/man3/fopen.3:347
#, no-wrap
msgid "B<x>"
msgstr "B<x>"

#.  Since glibc 2.0?
#.  FIXME . C11 specifies this flag
#. type: Plain text
#: man-pages/man3/fopen.3:364
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""
"Открыть файл в монопольном режиме (как с флагом B<O_EXCL> у B<open>(2)). "
"Если файл уже существует, то B<fopen>() завершается с ошибкой и "
"устанавливает значение I<errno> равное B<EEXIST>. Этот флаг игнорируется для "
"B<fdopen>()."

#. type: Plain text
#: man-pages/man3/fopen.3:372
msgid ""
"In addition to the above characters, B<fopen>()  and B<freopen>()  support "
"the following syntax in I<mode>:"
msgstr ""
"В дополнении к этим символам, для B<fopen>() и B<freopen>() поддерживается "
"следующий синтаксис в I<mode>:"

#. type: Plain text
#: man-pages/man3/fopen.3:374
msgid "B< ,ccs=>I<string>"
msgstr "B< ,ccs=>I<строка>"

#. type: Plain text
#: man-pages/man3/fopen.3:390
msgid ""
"The given I<string> is taken as the name of a coded character set and the "
"stream is marked as wide-oriented.  Thereafter, internal conversion "
"functions convert I/O to and from the character set I<string>.  If the B<,"
"ccs=>I<string> syntax is not specified, then the wide-orientation of the "
"stream is determined by the first file operation.  If that operation is a "
"wide-character operation, the stream is marked wide-oriented, and functions "
"to convert to the coded character set are loaded."
msgstr ""
"Передаваемая I<строка> используется как имя набора символов и поток "
"помечается как широкосимвольный. С того момента внутренние функции "
"преобразования перекодируют данные ввода-вывода в соответствии с набором "
"символов с именем I<строка>. Если синтаксис B<,ccs=>I<строка> не указан, то "
"широкосимвольность потока определяется по первой файловой операции. Если это "
"операция является широкосимвольной, то поток помечается как широкосимвольный "
"и загружаются функции для перекодировки."

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12685
#. type: Plain text
#: man-pages/man3/fopen.3:407
msgid ""
"When parsing for individual flag characters in I<mode> (i.e., the characters "
"preceding the \"ccs\" specification), the glibc implementation of "
"B<fopen>()  and B<freopen>()  limits the number of characters examined in "
"I<mode> to 7 (or, in glibc versions before 2.14, to 6, which was not enough "
"to include possible specifications such as \"rb+cmxe\").  The current "
"implementation of B<fdopen>()  parses at most 5 characters in I<mode>."
msgstr ""
"При анализе отдельных флагов в I<mode> (т. е., символов перед «ccs») "
"реализация glibc для B<fopen>() и B<freopen>() ограничивает количество "
"обрабатываемых в I<mode> символов 7-ю (или, в glibc до версии 2.14, 6-ю, что "
"было недостаточно для включения всех возможных флагов, например «rb+cmxe»). "
"Текущая реализация B<fdopen>() анализирует в I<mode> не более 5 символов."

#. type: Plain text
#: man-pages/man3/fopen.3:413
msgid ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3), "
"B<open_memstream>(3)"
msgstr ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3), "
"B<open_memstream>(3)"

#. type: TH
#: man-pages/man3/ftime.3:30
#, no-wrap
msgid "FTIME"
msgstr "FTIME"

#. type: Plain text
#: man-pages/man3/ftime.3:33
msgid "ftime - return date and time"
msgstr "ftime - возвращает дату и время"

#. type: Plain text
#: man-pages/man3/ftime.3:35
msgid "B<#include E<lt>sys/timeb.hE<gt>>"
msgstr "B<#include E<lt>sys/timeb.hE<gt>>"

#. type: Plain text
#: man-pages/man3/ftime.3:37
msgid "B<int ftime(struct timeb *>I<tp>B<);>"
msgstr "B<int ftime(struct timeb *>I<tp>B<);>"

#. type: Plain text
#: man-pages/man3/ftime.3:43
msgid ""
"This function returns the current time as seconds and milliseconds since the "
"Epoch, 1970-01-01 00:00:00 +0000 (UTC).  The time is returned in I<tp>, "
"which is declared as follows:"
msgstr ""
"Данная функция возвращает текущее время в секундах и миллисекундах, "
"прошедших начиная с эпохи (Epoch), 1970-01-01 00:00:00 +0000 (UTC). Время "
"возвращается в I<tp>, определённой следующим образом:"

#. type: Plain text
#: man-pages/man3/ftime.3:52
#, no-wrap
msgid ""
"struct timeb {\n"
"    time_t         time;\n"
"    unsigned short millitm;\n"
"    short          timezone;\n"
"    short          dstflag;\n"
"};\n"
msgstr ""
"struct timeb {\n"
"    time_t         time;\n"
"    unsigned short millitm;\n"
"    short          timezone;\n"
"    short          dstflag;\n"
"};\n"

#. type: Plain text
#: man-pages/man3/ftime.3:64
msgid ""
"Here I<time> is the number of seconds since the Epoch, and I<millitm> is the "
"number of milliseconds since I<time> seconds since the Epoch.  The "
"I<timezone> field is the local timezone measured in minutes of time west of "
"Greenwich (with a negative value indicating minutes east of Greenwich).  The "
"I<dstflag> field is a flag that, if nonzero, indicates that Daylight Saving "
"time applies locally during the appropriate part of the year."
msgstr ""
"В данной структуре I<time> — это количество секунд с начала эпохи; "
"I<millitm> — количество миллисекунд, прошедших после I<time> секунд с начала "
"эпохи. Поле I<timezone> — локальный часовой пояс, измеряемый в минутах "
"западнее Гринвича (отрицательные значения означают минуты восточнее "
"Гринвича). Поле I<dstflag> — флаг, ненулевое значение которого указывает, "
"что в соответствующее время года используется летнее время."

#. type: Plain text
#: man-pages/man3/ftime.3:67
msgid ""
"POSIX.1-2001 says that the contents of the I<timezone> and I<dstflag> fields "
"are unspecified; avoid relying on them."
msgstr ""
"В POSIX.1-2001 сказано, что содержимое полей I<timezone> и I<dstflag> не "
"определено; не используйте их."

#. type: Plain text
#: man-pages/man3/ftime.3:70
msgid ""
"This function always returns 0.  (POSIX.1-2001 specifies, and some systems "
"document, a -1 error return.)"
msgstr ""
"Эта функция всегда возвращает 0 (в POSIX.1-2001, а также в некоторых "
"системах возвращается -1 при ошибке)."

#. type: tbl table
#: man-pages/man3/ftime.3:80
#, no-wrap
msgid "B<ftime>()"
msgstr "B<ftime>()"

#. type: Plain text
#: man-pages/man3/ftime.3:86
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of B<ftime>()."
msgstr "4.2BSD, POSIX.1-2001. В POSIX.1-2008 спецификация B<ftime>() удалена."

#. type: Plain text
#: man-pages/man3/ftime.3:97
msgid ""
"This function is obsolete.  Don't use it.  If the time in seconds suffices, "
"B<time>(2)  can be used; B<gettimeofday>(2)  gives microseconds; "
"B<clock_gettime>(2)  gives nanoseconds but is not as widely available."
msgstr ""
"Эта функция устарела. Не используйте её. В случаях, когда достаточно секунд, "
"можно использовать B<time>(2); B<gettimeofday>(2) позволяет работать с "
"микросекундами; функция B<clock_gettime>(3) позволяет работать с "
"наносекундами, однако она пока ещё не очень широко распространена."

#.  .SH HISTORY
#.  The
#.  .BR ftime ()
#.  function appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man3/ftime.3:107
msgid ""
"Early glibc2 is buggy and returns 0 in the I<millitm> field; glibc 2.1.1 is "
"correct again."
msgstr ""
"Ранние версии glibc2 работают некорректно и возвращают 0 в поле I<millitm>; "
"начиная с glibc 2.1.1 эта ошибка исправлена."

#. type: Plain text
#: man-pages/man3/ftime.3:109
msgid "B<gettimeofday>(2), B<time>(2)"
msgstr "B<gettimeofday>(2), B<time>(2)"
