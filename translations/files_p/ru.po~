# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2014
# Kogan, Darima <silverdk99@gmail.com>, 2014
# Kogan, Darima <silverdk99@gmail.com>, 2014
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2014
# Yuri Kozlov <yuray@komyakino.ru>, 2013
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2012-04-29 11:34+0400\n"
"PO-Revision-Date: 2014-08-17 04:31+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/projects/p/man-pages/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "PTS"
msgstr "PTS"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "2002-10-09"
msgstr "2002-10-09"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/pts.4:9
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/pts.4:11
msgid "ptmx, pts - pseudoterminal master and slave"
msgstr "ptmx, pts - основной и подчинённый псевдо-терминал"

#. type: SH
#: man-pages/man4/pts.4:11
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/pts.4:17
msgid ""
"The file I</dev/ptmx> is a character file with major number 5 and minor "
"number 2, usually of mode 0666 and owner.group of root.root.  It is used to "
"create a pseudoterminal master and slave pair."
msgstr "Файл I</dev/ptmx> является символьным файлом со старшим номером 5 и младшим номером 2, обычно имеет права доступа 0666 и принадлежит root.root. Используется для создания пары основного и подчинённого псевдо-терминала."

#. type: Plain text
#: man-pages/man4/pts.4:30
msgid ""
"When a process opens I</dev/ptmx>, it gets a file descriptor for a "
"pseudoterminal master (PTM), and a pseudoterminal slave (PTS) device is "
"created in the I</dev/pts> directory.  Each file descriptor obtained by "
"opening I</dev/ptmx> is an independent PTM with its own associated PTS, "
"whose path can be found by passing the descriptor to B<ptsname>(3)."
msgstr "Когда процесс открывает I</dev/ptmx>, то он получает дескриптор файла основного псевдо-терминала (PTM, pseudoterminal master), а в каталоге I</dev/pts> создаётся устройство подчинённого псевдо-терминала (PTS, pseudoterminal slave). Каждый дескриптор файла, полученный открытием I</dev/ptmx>, является независимым PTM со своим отдельным, связанным с ним PTS, чей путь можно определить, передав дескриптор B<ptsname>(3)."

#. type: Plain text
#: man-pages/man4/pts.4:36
msgid ""
"Before opening the pseudoterminal slave, you must pass the master's file "
"descriptor to B<grantpt>(3)  and B<unlockpt>(3)."
msgstr "Перед открытием подчинённого псевдо-терминала вы должны передать дескриптор файла основного терминала в B<grantpt>(3) и B<unlockpt>(3)."

#. type: Plain text
#: man-pages/man4/pts.4:39
msgid ""
"Once both the pseudoterminal master and slave are open, the slave provides "
"processes with an interface that is identical to that of a real terminal."
msgstr "Когда основной и подчинённый псевдо-терминалы будут открыты, подчинённый предоставляет процессам интерфейс, идентичный обычному терминалу."

#. type: Plain text
#: man-pages/man4/pts.4:42
msgid ""
"Data written to the slave is presented on the master descriptor as input.  "
"Data written to the master is presented to the slave as input."
msgstr "Данные, записываемые на подчинённый терминал, появляются у дескриптора основного терминала как входные данные. Данные, записываемые на основной терминал, появляются на подчинённом терминале в виде входных данных."

#. type: Plain text
#: man-pages/man4/pts.4:53
msgid ""
"In practice, pseudoterminals are used for implementing terminal emulators "
"such as B<xterm>(1), in which data read from the pseudoterminal master is "
"interpreted by the application in the same way a real terminal would "
"interpret the data, and for implementing remote-login programs such as "
"B<sshd>(8), in which data read from the pseudoterminal master is sent across"
" the network to a client program that is connected to a terminal or terminal"
" emulator."
msgstr "На практике, псевдо-терминалы используются для реализации эмуляторов терминала, таких как B<xterm>(1), где данные, считываемые с основного псевдо-терминала, интерпретируются приложениями в том же виде, как и данные с обычного терминала, а также в программах, реализующих удалённый доступ, таких как B<sshd>(8), где данные, считываемые с основного псевдо-терминала, отправляются по сети в программу-клиент, подключённую к терминалу или эмулятору терминала."

#. type: Plain text
#: man-pages/man4/pts.4:59
msgid ""
"Pseudoterminals can also be used to send input to programs that normally "
"refuse to read input from pipes (such as B<su>(1), and B<passwd>(1))."
msgstr "Псевдо-терминалы также могут использоваться для отправки вводимых данных в программы, не желающих принимать обычный ввод из канала (например B<su>(1) и B<passwd>(1))."

#. type: SH
#: man-pages/man4/pts.4:59
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/pts.4:62
msgid "I</dev/ptmx>, I</dev/pts/*>"
msgstr "I</dev/ptmx>, I</dev/pts/*>"

#. type: SH
#: man-pages/man4/pts.4:62
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/pts.4:68
msgid ""
"The Linux support for the above (known as UNIX 98 pseudoterminal naming)  is"
" done using the I<devpts> filesystem, that should be mounted on I</dev/pts>."
msgstr "Поддержка в Linux для всего вышеперечисленного (т.н. именование псевдо-терминалов UNIX 98) осуществляется через файловую систему I<devpts>, которая монтируется к I</dev/pts>."

#. type: Plain text
#: man-pages/man4/pts.4:74
msgid ""
"Before this UNIX 98 scheme, master pseudoterminals were called "
"I</dev/ptyp0>, ...  and slave pseudoterminals I</dev/ttyp0>, ...  and one "
"needed lots of preallocated device nodes."
msgstr "До схемы UNIX 98, основные псевдо-терминалы назывались I</dev/ptyp0>, ..., а подчинённые псевдо-терминалы \\(em I</dev/ttyp0>, …, и для них требовалось очень много предварительно размещённых нод устройств."

#. type: SH
#: man-pages/man4/pts.4:74
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/pts.4:79
msgid "B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pty>(7)"
msgstr "B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pty>(7)"

#. type: TH
#: man-pages/man7/path_resolution.7:25
#, no-wrap
msgid "PATH_RESOLUTION"
msgstr "PATH_RESOLUTION"

#. type: TH
#: man-pages/man7/path_resolution.7:25
#, no-wrap
msgid "2009-12-05"
msgstr "2009-12-05"

#. type: Plain text
#: man-pages/man7/path_resolution.7:28
msgid "path_resolution - how a pathname is resolved to a file"
msgstr "path_resolution - как имя пути преобразуется в файл"

#. type: Plain text
#: man-pages/man7/path_resolution.7:31
msgid ""
"Some UNIX/Linux system calls have as parameter one or more filenames.  A "
"filename (or pathname) is resolved as follows."
msgstr "У некоторых системных вызовов UNIX/Linux есть параметр, принимающий один или несколько имен файлов. Имя файла (или имя пути) преобразуется следующим образом."

#. type: SS
#: man-pages/man7/path_resolution.7:31
#, no-wrap
msgid "Step 1: start of the resolution process"
msgstr "Шаг 1: Начнем с анализа процесса"

#. type: Plain text
#: man-pages/man7/path_resolution.7:50
msgid ""
"If the pathname starts with the \\(aq/\\(aq character, the starting lookup "
"directory is the root directory of the calling process.  (A process inherits"
" its root directory from its parent.  Usually this will be the root "
"directory of the file hierarchy.  A process may get a different root "
"directory by use of the B<chroot>(2)  system call.  A process may get an "
"entirely private mount namespace in case it\\(emor one of its "
"ancestors\\(emwas started by an invocation of the B<clone>(2)  system call "
"that had the B<CLONE_NEWNS> flag set.)  This handles the \\(aq/\\(aq part of"
" the pathname."
msgstr "Если имя файла начинается  с символов \\(ag/\\(ag, то начальный справочный директорий и есть корневой каталог так называемого процесса. ( Процесс получает свой корневой каталог от своего оригинального предшественника. Обычно это корневой каталог файловой иерархии. Процесс  может иметь другой корневой каталог, используя B<chroot>(2) cистемного вызова. Процесс может иметь полностью закрытое монтированное пространство имен в этом случае\\(длинное тире или одно из его аналогов\\ (длинное тире было начато обращением к B<clone>(2) системного вызова, который имел  флаг B CLONE_NEWNS. ) Это обрабатывает часть \\(aq/\\(aq имени файла."

#. type: Plain text
#: man-pages/man7/path_resolution.7:58
msgid ""
"If the pathname does not start with the \\(aq/\\(aq character, the starting "
"lookup directory of the resolution process is the current working directory "
"of the process.  (This is also inherited from the parent.  It can be changed"
" by use of the B<chdir>(2)  system call.)"
msgstr "Если имя пути не начинается символом \\(aq/\\(aq, то каталогом, с которого начинается преобразование, выбирается текущий рабочий каталог процесса (также наследуемый от родителя; может быть изменен путем использования системного вызова  B<chdir>(2))."

#. type: Plain text
#: man-pages/man7/path_resolution.7:61
msgid ""
"Pathnames starting with a \\(aq/\\(aq character are called absolute "
"pathnames.  Pathnames not starting with a \\(aq/\\(aq are called relative "
"pathnames."
msgstr "Имя пути, начинающийся с символа \\(aq/\\(aq, называется абсолютным именем пути. Имя пути, не начинающийся с символа \\(aq/\\(aq, называется относительными именем пути."

#. type: SS
#: man-pages/man7/path_resolution.7:61
#, no-wrap
msgid "Step 2: walk along the path"
msgstr "Шаг 2: Идем дальше"

#. type: Plain text
#: man-pages/man7/path_resolution.7:66
msgid ""
"Set the current lookup directory to the starting lookup directory.  Now, for"
" each nonfinal component of the pathname, where a component is a substring "
"delimited by \\(aq/\\(aq characters, this component is looked up in the "
"current lookup directory."
msgstr "Установка текущего каталога просмотра в качестве начального. Теперь для каждого не конечного компонента имени пути (где компонентом является подстрока, разделенная символами \\(aq/\\(aq) будет производиться просмотр в текущем каталоге просмотра."

#. type: Plain text
#: man-pages/man7/path_resolution.7:72
msgid ""
"If the process does not have search permission on the current lookup "
"directory, an B<EACCES> error is returned (\"Permission denied\")."
msgstr "Если у процесса нет права поиска для текущего каталога просмотра, будет возвращена ошибка B<EACCES> (\"Доступ запрещен\")."

#. type: Plain text
#: man-pages/man7/path_resolution.7:77
msgid ""
"If the component is not found, an B<ENOENT> error is returned (\"No such "
"file or directory\")."
msgstr "Если компонент не найдет, будет возвращена ошибка B<ENOENT> (\"Нет такого файла или каталога\")."

#. type: Plain text
#: man-pages/man7/path_resolution.7:82
msgid ""
"If the component is found, but is neither a directory nor a symbolic link, "
"an B<ENOTDIR> error is returned (\"Not a directory\")."
msgstr "Если компонент найден, но не является ни каталогом, ни символической ссылкой, будет возвращена ошибка B<ENOTDIR> (\"Не является каталогом\")."

#. type: Plain text
#: man-pages/man7/path_resolution.7:86
msgid ""
"If the component is found and is a directory, we set the current lookup "
"directory to that directory, and go to the next component."
msgstr "Если компонент найден и является каталогом, значение текущего каталога просмотра устанавливается в этот каталог, после чего осуществляется проход для следующего компонента."

#.  presently: max recursion depth during symlink resolution: 5
#.  max total number of symbolic links followed: 40
#.  _POSIX_SYMLOOP_MAX is 8
#. type: Plain text
#: man-pages/man7/path_resolution.7:110
msgid ""
"If the component is found and is a symbolic link (symlink), we first resolve"
" this symbolic link (with the current lookup directory as starting lookup "
"directory).  Upon error, that error is returned.  If the result is not a "
"directory, an B<ENOTDIR> error is returned.  If the resolution of the "
"symlink is successful and returns a directory, we set the current lookup "
"directory to that directory, and go to the next component.  Note that the "
"resolution process here involves recursion.  In order to protect the kernel "
"against stack overflow, and also to protect against denial of service, there"
" are limits on the maximum recursion depth, and on the maximum number of "
"symbolic links followed.  An B<ELOOP> error is returned when the maximum is "
"exceeded (\"Too many levels of symbolic links\")."
msgstr "Если составляющие найдены и символическая ссылка (Симлинк), то мы сначала разрешаем символическую ссылку ( с текущим каталогом, как начальным справочным директорием)ю/ Что касается ошибки, то ошибка возвращена. Если результат не привел к каталогу, то случается ошибка <ENOTDIR>. Если решение символической ссылки неуспешно и возращает к оригинальному каталогу, то мы назначаем текущий справочный директорий к оригиналу, затем переходим к следующему компоненту. Заметим, что процесс решения  здесь включает повторение алгоритма вызова. Для защиты ядра от переполнения хранилища, а также от отказа сервиса, существуют ограничения на максимальную глубину рекурсии и следует максимальное количество символических ссылок. Ошибка B<ELOOP> происходит в том случае, когда максимум переполнен. (\"Слишком много уровней символических ссылок\")."

#. type: SS
#: man-pages/man7/path_resolution.7:110
#, no-wrap
msgid "Step 3: find the final entry"
msgstr "Шаг 3: Найти финальную запись"

#. type: Plain text
#: man-pages/man7/path_resolution.7:122
msgid ""
"The lookup of the final component of the pathname goes just like that of all"
" other components, as described in the previous step, with two differences: "
"(i) the final component need not be a directory (at least as far as the path"
" resolution process is concerned\\(emit may have to be a directory, or a "
"nondirectory, because of the requirements of the specific system call), and "
"(ii) it is not necessarily an error if the component is not found\\(emmaybe "
"we are just creating it.  The details on the treatment of the final entry "
"are described in the manual pages of the specific system calls."
msgstr "Поиск конечного компонентата имени файла  происходит таким же образом, как и у всех других компонентов, как было описано в предыдущем шаге, но с двумя различиями: (i) конечному компоненту не надлежит быть директорием (по крайней мере, настолько, насколько путь решения процесса обеспокоен/ (Длинное тире может быть директорием, или не директорием в зависимости от требований определенного системного вызова), и (ii) ошибка необязательна, если  компрнент не найден\\ (длинное тире может быть создано нами сейчас. Детали обработки финальной записи описаны на страницах инструкции определенных системных вызовов."

#. type: SS
#: man-pages/man7/path_resolution.7:122
#, no-wrap
msgid ". and .."
msgstr ". и .."

#. type: Plain text
#: man-pages/man7/path_resolution.7:126
msgid ""
"By convention, every directory has the entries \".\" and \"..\", which refer"
" to the directory itself and to its parent directory, respectively."
msgstr "Условно, каждый директорий имеет записи \".\"и \"..\", которые относятся к самой директории и его родительскому каталог, соответственно."

#. type: Plain text
#: man-pages/man7/path_resolution.7:130
msgid ""
"The path resolution process will assume that these entries have their "
"conventional meanings, regardless of whether they are actually present in "
"the physical filesystem."
msgstr "Путь разрешения процесса предпологает, что эти записи имеют свои общепринятые значения, независимо от того, присутствуют ли они на самом деле в физической файловой системе."

#. type: Plain text
#: man-pages/man7/path_resolution.7:132
msgid "One cannot walk down past the root: \"/..\" is the same as \"/\"."
msgstr " Один не может пройти мимо корня: \"/..\"такой же, как \"/\""

#. type: SS
#: man-pages/man7/path_resolution.7:132
#, no-wrap
msgid "Mount points"
msgstr "Точки монтирования"

#. type: Plain text
#: man-pages/man7/path_resolution.7:136
msgid ""
"After a \"mount dev path\" command, the pathname \"path\" refers to the root"
" of the filesystem hierarchy on the device \"dev\", and no longer to "
"whatever it referred to earlier."
msgstr "После команды  монтирования раздела \"path\", имя файла \"path\" отсылает к корню иерархии файловой системы раздела \"dev\", и больше не направляет к тому, к чему отсылало раньше."

#. type: Plain text
#: man-pages/man7/path_resolution.7:140
msgid ""
"One can walk out of a mounted filesystem: \"path/..\" refers to the parent "
"directory of \"path\", outside of the filesystem hierarchy on \"dev\"."
msgstr "Один может покинуть монтированную файловую систему: \"path/..\" отсылает к родительскому директорию \"path\", вне иерархии файловой системы \"dev\"."

#. type: SS
#: man-pages/man7/path_resolution.7:140
#, no-wrap
msgid "Trailing slashes"
msgstr "Конечные косые"

#. type: Plain text
#: man-pages/man7/path_resolution.7:146
msgid ""
"If a pathname ends in a \\(aq/\\(aq, that forces resolution of the preceding"
" component as in Step 2: it has to exist and resolve to a directory.  "
"Otherwise, a trailing \\(aq/\\(aq is ignored.  (Or, equivalently, a pathname"
" with a trailing \\(aq/\\(aq is equivalent to the pathname obtained by "
"appending \\(aq.\\(aq to it.)"
msgstr "Если имя файла заканчивается на \\(aq/\\(aq, то принуждает разрешение предыдущего компонента, как в шаге 2: он должен быть и решен в директории. В противном случае, конечное \\(aq/\\(aq будет игнорировано. ( Или, тоже самое имя файла с конечной косой чертой \\(aq/\\(aq  будет равноценно имени файла, полученному добавлением к концу этого \\(aq/\\ ( aq к нему.)"

#. type: SS
#: man-pages/man7/path_resolution.7:146
#, no-wrap
msgid "Final symlink"
msgstr "Закпючительный симлинк"

#. type: Plain text
#: man-pages/man7/path_resolution.7:155
msgid ""
"If the last component of a pathname is a symbolic link, then it depends on "
"the system call whether the file referred to will be the symbolic link or "
"the result of path resolution on its contents.  For example, the system call"
" B<lstat>(2)  will operate on the symlink, while B<stat>(2)  operates on the"
" file pointed to by the symlink."
msgstr "Если последнее составляющее имени файла является символической ссылкой, то это зависит от системного вызова, будет ли файл символической ссылкой, или результатом пути решения своих содержаний. Например, системный вызов B<lstat>(2) будет работать на симлинк в то время, как B <stat> (2) направляет к файлу, на который указывает символическая ссылка."

#. type: SS
#: man-pages/man7/path_resolution.7:155
#, no-wrap
msgid "Length limit"
msgstr "Ограничение длины"

#. type: Plain text
#: man-pages/man7/path_resolution.7:162
msgid ""
"There is a maximum length for pathnames.  If the pathname (or some "
"intermediate pathname obtained while resolving symbolic links)  is too long,"
" an B<ENAMETOOLONG> error is returned (\"Filename too long\")."
msgstr "Существует максимально допустимая длина имени файла.  Если имя файла( или какое-нибудь вспомогательное имя файла, полученного при решении символических ссылок) очень длинное, то  ошибка B<ENAMETOOLONG> повторяется ( \"Имя файла очень длинное\")."

#. type: SS
#: man-pages/man7/path_resolution.7:162
#, no-wrap
msgid "Empty pathname"
msgstr "Пустое имя файла"

#. type: Plain text
#: man-pages/man7/path_resolution.7:169
msgid ""
"In the original UNIX, the empty pathname referred to the current directory."
"  Nowadays POSIX decrees that an empty pathname must not be resolved "
"successfully.  Linux returns B<ENOENT> in this case."
msgstr "В оригинальном UNIX, пустое имя файла направляет к текущему каталогу. В наши дни POSIX предписывает, что пустое имя файла не может быть решенным успешно. Linux возвращает B<ENOENT>  в этом случае. "

#. type: SS
#: man-pages/man7/path_resolution.7:169
#, no-wrap
msgid "Permissions"
msgstr "Разрешения"

#. type: Plain text
#: man-pages/man7/path_resolution.7:182
msgid ""
"The permission bits of a file consist of three groups of three bits, cf.\\& "
"B<chmod>(1)  and B<stat>(2).  The first group of three is used when the "
"effective user ID of the calling process equals the owner ID of the file.  "
"The second group of three is used when the group ID of the file either "
"equals the effective group ID of the calling process, or is one of the "
"supplementary group IDs of the calling process (as set by B<setgroups>(2))."
"  When neither holds, the third group is used."
msgstr "Максимальный размер файла содержит три группы по три байта, cf.\\& B<chmod>(1) и B<stat>(2). Первая группа используется тогда, когда эффективный идентификатор пользователя процесса вызова равен идентификатору владельца файла. Вторая группа используется в то время, когда групповой идентификатор либо равен эффективному идентификатору группы процесса вызова, или является одним из дополнительных групп процесса вызова (как установленый B <setgroups> (2)). Когда никто не держит, используется третья группа."

#. type: Plain text
#: man-pages/man7/path_resolution.7:186
msgid ""
"Of the three bits used, the first bit determines read permission, the second"
" write permission, and the last execute permission in case of ordinary "
"files, or search permission in case of directories."
msgstr "Три байта используются следующим образом: первый байт разрешает чтение, второй дает разрешение на запись, и последний выполняет разрешение в случае обычных файлов, или разрешение поиска в случае каталогов. "

#. type: Plain text
#: man-pages/man7/path_resolution.7:191
msgid ""
"Linux uses the fsuid instead of the effective user ID in permission checks."
"  Ordinarily the fsuid will equal the effective user ID, but the fsuid can "
"be changed by the system call B<setfsuid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/path_resolution.7:199
msgid ""
"(Here \"fsuid\" stands for something like \"filesystem user ID\".  The "
"concept was required for the implementation of a user space NFS server at a "
"time when processes could send a signal to a process with the same effective"
" user ID.  It is obsolete now.  Nobody should use B<setfsuid>(2).)"
msgstr ""

#.  FIXME say something about filesystem mounted read-only ?
#. type: Plain text
#: man-pages/man7/path_resolution.7:205
msgid ""
"Similarly, Linux uses the fsgid (\"filesystem group ID\")  instead of the "
"effective group ID.  See B<setfsgid>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/path_resolution.7:205
#, no-wrap
msgid "Bypassing permission checks: superuser and capabilities"
msgstr ""

#.  (but for exec at least one x bit must be set) -- AEB
#.  but there is variation across systems on this point: for
#.  example, HP-UX and Tru64 are as described by AEB.  However,
#.  on some implementations (e.g., Solaris, FreeBSD),
#.  access(X_OK) by superuser will report success, regardless
#.  of the file's execute permission bits. -- MTK (Oct 05)
#. type: Plain text
#: man-pages/man7/path_resolution.7:216
msgid ""
"On a traditional UNIX system, the superuser (I<root>, user ID 0) is all-"
"powerful, and bypasses all permissions restrictions when accessing files."
msgstr ""

#. type: Plain text
#: man-pages/man7/path_resolution.7:224
msgid ""
"On Linux, superuser privileges are divided into capabilities (see "
"B<capabilities>(7)).  Two capabilities are relevant for file permissions "
"checks: B<CAP_DAC_OVERRIDE> and B<CAP_DAC_READ_SEARCH>.  (A process has "
"these capabilities if its fsuid is 0.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/path_resolution.7:230
msgid ""
"The B<CAP_DAC_OVERRIDE> capability overrides all permission checking, but "
"grants execute permission only when at least one of the file's three execute"
" permission bits is set."
msgstr ""

#.  FIXME say something about immutable files
#.  FIXME say something about ACLs
#. type: Plain text
#: man-pages/man7/path_resolution.7:237
msgid ""
"The B<CAP_DAC_READ_SEARCH> capability grants read and search permission on "
"directories, and read permission on ordinary files."
msgstr ""

#. type: Plain text
#: man-pages/man7/path_resolution.7:241
msgid "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"
msgstr "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man7/pty.7:25
#, no-wrap
msgid "PTY"
msgstr "PTY"

#. type: TH
#: man-pages/man7/pty.7:25
#, no-wrap
msgid "2005-10-10"
msgstr "2005-10-10"

#. type: Plain text
#: man-pages/man7/pty.7:28
msgid "pty - pseudoterminal interfaces"
msgstr "pty - интерфейсы псевдо-териминалов"

#. type: Plain text
#: man-pages/man7/pty.7:58
msgid ""
"A pseudoterminal (sometimes abbreviated \"pty\")  is a pair of virtual "
"character devices that provide a bidirectional communication channel.  One "
"end of the channel is called the I<master>; the other end is called the "
"I<slave>.  The slave end of the pseudoterminal provides an interface that "
"behaves exactly like a classical terminal.  A process that expects to be "
"connected to a terminal, can open the slave end of a pseudoterminal and then"
" be driven by a program that has opened the master end.  Anything that is "
"written on the master end is provided to the process on the slave end as "
"though it was input typed on a terminal.  For example, writing the interrupt"
" character (usually control-C)  to the master device would cause an "
"interrupt signal (B<SIGINT>)  to be generated for the foreground process "
"group that is connected to the slave.  Conversely, anything that is written "
"to the slave end of the pseudoterminal can be read by the process that is "
"connected to the master end.  Pseudoterminals are used by applications such "
"as network login services (B<ssh>(1), B<rlogin>(1), B<telnet>(1)), terminal "
"emulators, B<script>(1), B<screen>(1), and B<expect>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:63
msgid ""
"Historically, two pseudoterminal APIs have evolved: BSD and System V.  SUSv1"
" standardized a pseudoterminal API based on the System V API, and this API "
"should be employed in all new programs that use pseudoterminals."
msgstr "Исторически существует два API для взаимодействия с псевдо-терминалами: BSD и System V. SUSv1 стандартизировал API, основанный на System V API, который должен применяться во всех новых программах, использующих псевдо-терминалы."

#. type: Plain text
#: man-pages/man7/pty.7:71
msgid ""
"Linux provides both BSD-style and (standardized) System V-style "
"pseudoterminals.  System V-style terminals are commonly called UNIX 98 "
"pseudoterminals on Linux systems.  Since kernel 2.6.4, BSD-style "
"pseudoterminals are considered deprecated (they can be disabled when "
"configuring the kernel); UNIX 98 pseudoterminals should be used in new "
"applications."
msgstr "В Linux есть оба типа псевдо-терминалов - BSD и (стандартизированный) System V. В системах Linux терминалы System V часто называют псевдо-терминалами UNIX 98. Начиная с ядра версии 2.6.4 псевдо-терминалы BSD признаны устаревшими (они могут быть отключены во время конфигурирования ядра). В новых программах следует использовать псевдо-терминалы UNIX 98."

#. type: SS
#: man-pages/man7/pty.7:71
#, no-wrap
msgid "UNIX 98 pseudoterminals"
msgstr "Псевдо-терминалы UNIX 98"

#. type: Plain text
#: man-pages/man7/pty.7:88
msgid ""
"An unused UNIX 98 pseudoterminal master is opened by calling "
"B<posix_openpt>(3).  (This function opens the master clone device, "
"I</dev/ptmx>; see B<pts>(4).)  After performing any program-specific "
"initializations, changing the ownership and permissions of the slave device "
"using B<grantpt>(3), and unlocking the slave using B<unlockpt>(3)), the "
"corresponding slave device can be opened by passing the name returned by "
"B<ptsname>(3)  in a call to B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:103
msgid ""
"The Linux kernel imposes a limit on the number of available UNIX 98 "
"pseudoterminals.  In kernels up to and including 2.6.3, this limit is "
"configured at kernel compilation time (B<CONFIG_UNIX98_PTYS>), and the "
"permitted number of pseudoterminals can be up to 2048, with a default "
"setting of 256.  Since kernel 2.6.4, the limit is dynamically adjustable via"
" I</proc/sys/kernel/pty/max>, and a corresponding file, "
"I</proc/sys/kernel/pty/nr>, indicates how many pseudoterminals are currently"
" in use.  For further details on these two files, see B<proc>(5)."
msgstr ""

#. type: SS
#: man-pages/man7/pty.7:103
#, no-wrap
msgid "BSD pseudoterminals"
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:124
msgid ""
"BSD-style pseudoterminals are provided as precreated pairs, with names of "
"the form I</dev/ptyXY> (master) and I</dev/ttyXY> (slave), where X is a "
"letter from the 16-character set [p-za-e], and Y is a letter from the "
"16-character set [0-9a-f].  (The precise range of letters in these two sets "
"varies across UNIX implementations.)  For example, I</dev/ptyp1> and "
"I</dev/ttyp1> constitute a BSD pseudoterminal pair.  A process finds an "
"unused pseudoterminal pair by trying to B<open>(2)  each pseudoterminal "
"master until an open succeeds.  The corresponding pseudoterminal slave "
"(substitute \"tty\" for \"pty\" in the name of the master) can then be "
"opened."
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:127
msgid "I</dev/ptmx> (UNIX 98 master clone device)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:130
msgid "I</dev/pts/*> (UNIX 98 slave devices)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:133
msgid "I</dev/pty[p-za-e][0-9a-f]> (BSD master devices)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:136
msgid "I</dev/tty[p-za-e][0-9a-f]> (BSD slave devices)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:142
msgid ""
"A description of the B<TIOCPKT> B<ioctl>(2), which controls packet mode "
"operation, can be found in B<tty_ioctl>(4)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:152
msgid ""
"The BSD B<ioctl>(2)  operations B<TIOCSTOP>, B<TIOCSTART>, B<TIOCUCNTL>, and"
" B<TIOCREMOTE> have not been implemented under Linux."
msgstr ""

#. type: Plain text
#: man-pages/man7/pty.7:160
msgid ""
"B<select>(2), B<setsid>(2), B<forkpty>(3), B<openpty>(3), B<termios>(3), "
"B<pts>(4), B<tty>(4), B<tty_ioctl>(4)"
msgstr "B<select>(2), B<setsid>(2), B<forkpty>(3), B<openpty>(3), B<termios>(3), B<pts>(4), B<tty>(4), B<tty_ioctl>(4)"

#. type: TH
#: man-pages/man7/posixoptions.7:24
#, no-wrap
msgid "POSIXOPTIONS"
msgstr "POSIXOPTIONS"

#. type: TH
#: man-pages/man7/posixoptions.7:24
#, no-wrap
msgid "2007-12-21"
msgstr "2007-12-21"

#. type: Plain text
#: man-pages/man7/posixoptions.7:27
msgid "posixoptions - optional parts of the POSIX standard"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:41
msgid ""
"The POSIX standard (the information below is from POSIX.1-2001)  describes a"
" set of behaviors and interfaces for a compliant system.  However, many "
"interfaces are optional and there are feature test macros to test the "
"availability of interfaces at compile time, and functions B<sysconf>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<confstr>(3)  to do this at run time.  "
"From shell scripts one can use B<getconf>(1).  For more detail, see "
"B<sysconf>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:48
msgid ""
"We give the name of the POSIX abbreviation, the option, the name of the "
"B<sysconf>(3)  parameter used to inquire about the option, and possibly a "
"very short description.  Much more precise detail can be found in the POSIX "
"standard itself, versions of which can nowadays be accessed freely on the "
"web."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:48
#, no-wrap
msgid "ADV - _POSIX_ADVISORY_INFO - _SC_ADVISORY_INFO"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:50
msgid "The following advisory functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:58
#, no-wrap
msgid ""
"I<posix_fadvise>(),\n"
"I<posix_fallocate>(),\n"
"I<posix_memalign>(),\n"
"I<posix_madvise>().\n"
msgstr "I<posix_fadvise>(),\nI<posix_fallocate>(),\nI<posix_memalign>(),\nI<posix_madvise>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:61
#, no-wrap
msgid "AIO - _POSIX_ASYNCHRONOUS_IO - _SC_ASYNCHRONOUS_IO"
msgstr "AIO - _POSIX_ASYNCHRONOUS_IO - _SC_ASYNCHRONOUS_IO"

#. type: Plain text
#: man-pages/man7/posixoptions.7:66
msgid ""
"The header I<E<lt>aio.hE<gt>> is present.  The following functions are "
"present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:78
#, no-wrap
msgid ""
"I<aio_cancel>(),\n"
"I<aio_error>(),\n"
"I<aio_fsync>(),\n"
"I<aio_read>(),\n"
"I<aio_return>(),\n"
"I<aio_suspend>(),\n"
"I<aio_write>(),\n"
"I<lio_listio>().\n"
msgstr "I<aio_cancel>(),\nI<aio_error>(),\nI<aio_fsync>(),\nI<aio_read>(),\nI<aio_return>(),\nI<aio_suspend>(),\nI<aio_write>(),\nI<lio_listio>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:81
#, no-wrap
msgid "BAR - _POSIX_BARRIERS - _SC_BARRIERS"
msgstr "BAR - _POSIX_BARRIERS - _SC_BARRIERS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:88 man-pages/man7/posixoptions.7:458
msgid ""
"This option implies the B<_POSIX_THREADS> and "
"B<_POSIX_THREAD_SAFE_FUNCTIONS> options.  The following functions are "
"present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:97
#, no-wrap
msgid ""
"I<pthread_barrier_destroy>(),\n"
"I<pthread_barrier_init>(),\n"
"I<pthread_barrier_wait>(),\n"
"I<pthread_barrierattr_destroy>(),\n"
"I<pthread_barrierattr_init>().\n"
msgstr "I<pthread_barrier_destroy>(),\nI<pthread_barrier_init>(),\nI<pthread_barrier_wait>(),\nI<pthread_barrierattr_destroy>(),\nI<pthread_barrierattr_init>().\n"

#.  .SS "BE"
#.  Batch environment.
#.  .SS "CD"
#.  C development.
#. type: SS
#: man-pages/man7/posixoptions.7:104
#, no-wrap
msgid "--- - POSIX_CHOWN_RESTRICTED"
msgstr "--- - POSIX_CHOWN_RESTRICTED"

#.  What about lchown() ?
#. type: Plain text
#: man-pages/man7/posixoptions.7:112
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then only "
"root may change the owner of a file, and nonroot can set the group of a file"
" only to one of the groups it belongs to.  This affects the functions "
"I<chown>(), I<fchown>()."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:112
#, no-wrap
msgid "CS - _POSIX_CLOCK_SELECTION - _SC_CLOCK_SELECTION"
msgstr "CS - _POSIX_CLOCK_SELECTION - _SC_CLOCK_SELECTION"

#. type: Plain text
#: man-pages/man7/posixoptions.7:117
msgid ""
"This option implies the B<_POSIX_TIMERS> option.  The following functions "
"are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:124
#, no-wrap
msgid ""
"I<pthread_condattr_getclock>(),\n"
"I<pthread_condattr_setclock>(),\n"
"I<clock_nanosleep>().\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:132
msgid ""
"If B<CLOCK_REALTIME> is changed by the function I<clock_settime>(), then "
"this affects all timers set for an absolute time."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:132
#, no-wrap
msgid "CPT - _POSIX_CPUTIME - _SC_CPUTIME"
msgstr ""

#.  .SS "FD"
#.  Fortran development
#.  .SS "FR"
#.  Fortran runtime
#. type: Plain text
#: man-pages/man7/posixoptions.7:145
msgid ""
"The clockID CLOCK_PROCESS_CPUTIME_ID is supported.  The initial value of "
"this clock is 0 for each process.  This option implies the B<_POSIX_TIMERS> "
"option.  The function I<clock_getcpuclockid>()  is present."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:145
#, no-wrap
msgid "--- - _POSIX_FILE_LOCKING - _SC_FILE_LOCKING"
msgstr "--- - _POSIX_FILE_LOCKING - _SC_FILE_LOCKING"

#.  .SS "MX"
#.  IEC 60559 Floating-Point Option.
#. type: Plain text
#: man-pages/man7/posixoptions.7:148 man-pages/man7/posixoptions.7:238
msgid "This option has been deleted.  Not in final XPG6."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:148
#, no-wrap
msgid "FSC - _POSIX_FSYNC - _SC_FSYNC"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:152
msgid "The function I<fsync>()  is present."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:152
#, no-wrap
msgid "IP6 - _POSIX_IPV6 - _SC_IPV6"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:154
msgid "Internet Protocol Version 6 is supported."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:154
#, no-wrap
msgid "--- - _POSIX_JOB_CONTROL - _SC_JOB_CONTROL"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:158
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then the "
"system implements POSIX-style job control, and the following functions are "
"present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:169
#, no-wrap
msgid ""
"I<setpgid>(),\n"
"I<tcdrain>(),\n"
"I<tcflush>(),\n"
"I<tcgetpgrp>(),\n"
"I<tcsendbreak>(),\n"
"I<tcsetattr>(),\n"
"I<tcsetpgrp>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:171
#, no-wrap
msgid "MF - _POSIX_MAPPED_FILES - _SC_MAPPED_FILES"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:180
msgid ""
"Shared memory is supported.  The include file I<E<lt>sys/mman.hE<gt>> is "
"present.  The following functions are present: I<mmap>(), I<msync>(), "
"I<munmap>()."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:180
#, no-wrap
msgid "ML - _POSIX_MEMLOCK - _SC_MEMLOCK"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:186
msgid ""
"Shared memory can be locked into core.  The functions I<mlockall>(), "
"I<munlockall>()  are present."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:186
#, no-wrap
msgid "MR/MLR - _POSIX_MEMLOCK_RANGE - _SC_MEMLOCK_RANGE"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:192
msgid ""
"More precisely, ranges can be locked into core.  The functions I<mlock>(), "
"I<munlock>()  are present."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:192
#, no-wrap
msgid "MPR - _POSIX_MEMORY_PROTECTION - _SC_MEMORY_PROTECTION"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:196
msgid "The function I<mprotect>()  is present."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:196
#, no-wrap
msgid "MSG - _POSIX_MESSAGE_PASSING - _SC_MESSAGE_PASSING"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:201
msgid ""
"The include file I<E<lt>mqueue.hE<gt>> is present.  The following functions "
"are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:213
#, no-wrap
msgid ""
"I<mq_close>(),\n"
"I<mq_getattr>(),\n"
"I<mq_notify>(),\n"
"I<mq_open>(),\n"
"I<mq_receive>(),\n"
"I<mq_send>(),\n"
"I<mq_setattr>(),\n"
"I<mq_unlink>().\n"
msgstr "I<mq_close>(),\nI<mq_getattr>(),\nI<mq_notify>(),\nI<mq_open>(),\nI<mq_receive>(),\nI<mq_send>(),\nI<mq_setattr>(),\nI<mq_unlink>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:216
#, no-wrap
msgid "MON - _POSIX_MONOTONIC_CLOCK - _SC_MONOTONIC_CLOCK"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:223
msgid ""
"B<CLOCK_MONOTONIC> is supported.  This option implies the B<_POSIX_TIMERS> "
"option.  Affected functions are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:231
#, no-wrap
msgid ""
"I<aio_suspend>(),\n"
"I<clock_getres>(),\n"
"I<clock_gettime>(),\n"
"I<clock_settime>(),\n"
"I<timer_create>().\n"
msgstr "I<aio_suspend>(),\nI<clock_getres>(),\nI<clock_gettime>(),\nI<clock_settime>(),\nI<timer_create>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:233
#, no-wrap
msgid "--- - _POSIX_MULTI_PROCESS - _SC_MULTI_PROCESS"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:238
#, no-wrap
msgid "--- - _POSIX_NO_TRUNC"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:245
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001)  then "
"pathname components longer than B<NAME_MAX> are not truncated, but give an "
"error.  This property may be dependent on the path prefix of the component."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:245
#, no-wrap
msgid "PIO - _POSIX_PRIORITIZED_IO - _SC_PRIORITIZED_IO"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:248
msgid ""
"This option says that one can specify priorities for asynchronous I/O.  This"
" affects the functions"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:254
#, no-wrap
msgid ""
"I<aio_read>(),\n"
"I<aio_write>().\n"
msgstr "I<aio_read>(),\nI<aio_write>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:256
#, no-wrap
msgid "PS - _POSIX_PRIORITY_SCHEDULING - _SC_PRIORITY_SCHEDULING"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:261
msgid ""
"The include file I<E<lt>sched.hE<gt>> is present.  The following functions "
"are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:273
#, no-wrap
msgid ""
"I<sched_get_priority_max>(),\n"
"I<sched_get_priority_min>(),\n"
"I<sched_getparam>(),\n"
"I<sched_getscheduler>(),\n"
"I<sched_rr_get_interval>(),\n"
"I<sched_setparam>(),\n"
"I<sched_setscheduler>(),\n"
"I<sched_yield>().\n"
msgstr "I<sched_get_priority_max>(),\nI<sched_get_priority_min>(),\nI<sched_getparam>(),\nI<sched_getscheduler>(),\nI<sched_rr_get_interval>(),\nI<sched_setparam>(),\nI<sched_setscheduler>(),\nI<sched_yield>().\n"

#. type: Plain text
#: man-pages/man7/posixoptions.7:279
msgid ""
"If also B<_POSIX_SPAWN> is in effect, then the following functions are "
"present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:287 man-pages/man7/posixoptions.7:449
#, no-wrap
msgid ""
"I<posix_spawnattr_getschedparam>(),\n"
"I<posix_spawnattr_getschedpolicy>(),\n"
"I<posix_spawnattr_setschedparam>(),\n"
"I<posix_spawnattr_setschedpolicy>().\n"
msgstr "I<posix_spawnattr_getschedparam>(),\nI<posix_spawnattr_getschedpolicy>(),\nI<posix_spawnattr_setschedparam>(),\nI<posix_spawnattr_setschedpolicy>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:289
#, no-wrap
msgid "RS - _POSIX_RAW_SOCKETS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:294
msgid ""
"Raw sockets are supported.  Affected functions are I<getsockopt>(), "
"I<setsockopt>()."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:294
#, no-wrap
msgid "--- - _POSIX_READER_WRITER_LOCKS - _SC_READER_WRITER_LOCKS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:302
msgid ""
"This option implies the B<_POSIX_THREADS> option.  Conversely, under "
"POSIX.1-2001 the B<_POSIX_THREADS> option implies this option."
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:304
#, no-wrap
msgid "The following functions are present:\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:315
#, no-wrap
msgid ""
"I<pthread_rwlock_destroy>(),\n"
"I<pthread_rwlock_init>(),\n"
"I<pthread_rwlock_rdlock>(),\n"
"I<pthread_rwlock_tryrdlock>(),\n"
"I<pthread_rwlock_trywrlock>(),\n"
"I<pthread_rwlock_unlock>(),\n"
"I<pthread_rwlock_wrlock>(),\n"
"I<pthread_rwlockattr_destroy>(),\n"
"I<pthread_rwlockattr_init>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:317
#, no-wrap
msgid "RTS - _POSIX_REALTIME_SIGNALS - _SC_REALTIME_SIGNALS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:320
msgid "Realtime signals are supported.  The following functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:327
#, no-wrap
msgid ""
"I<sigqueue>(),\n"
"I<sigtimedwait>(),\n"
"I<sigwaitinfo>().\n"
msgstr "I<sigqueue>(),\nI<sigtimedwait>(),\nI<sigwaitinfo>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:330
#, no-wrap
msgid "--- - _POSIX_REGEXP - _SC_REGEXP"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:334
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001)  then POSIX"
" regular expressions are supported and the following functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:342
#, no-wrap
msgid ""
"I<regcomp>(),\n"
"I<regerror>(),\n"
"I<regexec>(),\n"
"I<regfree>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:345
#, no-wrap
msgid "--- - _POSIX_SAVED_IDS - _SC_SAVED_IDS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:349
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then a "
"process has a saved set-user-ID and a saved set-group-ID.  Affected "
"functions are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:359
#, no-wrap
msgid ""
"I<exec>(),\n"
"I<kill>(),\n"
"I<seteuid>(),\n"
"I<setegid>(),\n"
"I<setgid>(),\n"
"I<setuid>().\n"
msgstr "I<exec>(),\nI<kill>(),\nI<seteuid>(),\nI<setegid>(),\nI<setgid>(),\nI<setuid>().\n"

#.  .SS "SD"
#.  Software development
#. type: SS
#: man-pages/man7/posixoptions.7:364
#, no-wrap
msgid "SEM - _POSIX_SEMAPHORES - _SC_SEMAPHORES"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:369
msgid ""
"The include file I<E<lt>semaphore.hE<gt>> is present.  The following "
"functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:382
#, no-wrap
msgid ""
"I<sem_close>(),\n"
"I<sem_destroy>(),\n"
"I<sem_getvalue>(),\n"
"I<sem_init>(),\n"
"I<sem_open>(),\n"
"I<sem_post>(),\n"
"I<sem_trywait>(),\n"
"I<sem_unlink>(),\n"
"I<sem_wait>().\n"
msgstr "I<sem_close>(),\nI<sem_destroy>(),\nI<sem_getvalue>(),\nI<sem_init>(),\nI<sem_open>(),\nI<sem_post>(),\nI<sem_trywait>(),\nI<sem_unlink>(),\nI<sem_wait>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:385
#, no-wrap
msgid "SHM - _POSIX_SHARED_MEMORY_OBJECTS - _SC_SHARED_MEMORY_OBJECTS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:387 man-pages/man7/posixoptions.7:703
#: man-pages/man7/posixoptions.7:719 man-pages/man7/posixoptions.7:833
msgid "The following functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:395
#, no-wrap
msgid ""
"I<mmap>(),\n"
"I<munmap>(),\n"
"I<shm_open>(),\n"
"I<shm_unlink>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:398
#, no-wrap
msgid "--- - _POSIX_SHELL - _SC_SHELL"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:403
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), the "
"function I<system>()  is present."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:403
#, no-wrap
msgid "SPN - _POSIX_SPAWN - _SC_SPAWN"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:413
msgid ""
"This option describes support for process creation in a context where it is "
"difficult or impossible to use I<fork>(), for example, because no MMU is "
"present.  If B<_POSIX_SPAWN> is in effect, then the include file "
"I<E<lt>spawn.hE<gt>> and the following functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:434
#, no-wrap
msgid ""
"I<posix_spawn>(),\n"
"I<posix_spawn_file_actions_addclose>(),\n"
"I<posix_spawn_file_actions_adddup2>(),\n"
"I<posix_spawn_file_actions_addopen>(),\n"
"I<posix_spawn_file_actions_destroy>(),\n"
"I<posix_spawn_file_actions_init>(),\n"
"I<posix_spawnattr_destroy>(),\n"
"I<posix_spawnattr_getsigdefault>(),\n"
"I<posix_spawnattr_getflags>(),\n"
"I<posix_spawnattr_getpgroup>(),\n"
"I<posix_spawnattr_getsigmask>(),\n"
"I<posix_spawnattr_init>(),\n"
"I<posix_spawnattr_setsigdefault>(),\n"
"I<posix_spawnattr_setflags>(),\n"
"I<posix_spawnattr_setpgroup>(),\n"
"I<posix_spawnattr_setsigmask>(),\n"
"I<posix_spawnp>().\n"
msgstr "I<posix_spawn>(),\nI<posix_spawn_file_actions_addclose>(),\nI<posix_spawn_file_actions_adddup2>(),\nI<posix_spawn_file_actions_addopen>(),\nI<posix_spawn_file_actions_destroy>(),\nI<posix_spawn_file_actions_init>(),\nI<posix_spawnattr_destroy>(),\nI<posix_spawnattr_getsigdefault>(),\nI<posix_spawnattr_getflags>(),\nI<posix_spawnattr_getpgroup>(),\nI<posix_spawnattr_getsigmask>(),\nI<posix_spawnattr_init>(),\nI<posix_spawnattr_setsigdefault>(),\nI<posix_spawnattr_setflags>(),\nI<posix_spawnattr_setpgroup>(),\nI<posix_spawnattr_setsigmask>(),\nI<posix_spawnp>().\n"

#. type: Plain text
#: man-pages/man7/posixoptions.7:441
msgid ""
"If also B<_POSIX_PRIORITY_SCHEDULING> is in effect, then the following "
"functions are present:"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:451
#, no-wrap
msgid "SPI - _POSIX_SPIN_LOCKS - _SC_SPIN_LOCKS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:467
#, no-wrap
msgid ""
"I<pthread_spin_destroy>(),\n"
"I<pthread_spin_init>(),\n"
"I<pthread_spin_lock>(),\n"
"I<pthread_spin_trylock>(),\n"
"I<pthread_spin_unlock>().\n"
msgstr "I<pthread_spin_destroy>(),\nI<pthread_spin_init>(),\nI<pthread_spin_lock>(),\nI<pthread_spin_trylock>(),\nI<pthread_spin_unlock>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:470
#, no-wrap
msgid "SS - _POSIX_SPORADIC_SERVER - _SC_SPORADIC_SERVER"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:478
msgid ""
"The scheduling policy B<SCHED_SPORADIC> is supported.  This option implies "
"the B<_POSIX_PRIORITY_SCHEDULING> option.  Affected functions are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:484
#, no-wrap
msgid ""
"I<sched_setparam>(),\n"
"I<sched_setscheduler>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:487
#, no-wrap
msgid "SIO - _POSIX_SYNCHRONIZED_IO - _SC_SYNCHRONIZED_IO"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:493
msgid ""
"Affected functions are I<open>(), I<msync>(), I<fsync>(), I<fdatasync>()."
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:493
#, no-wrap
msgid "TSA - _POSIX_THREAD_ATTR_STACKADDR - _SC_THREAD_ATTR_STACKADDR"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:495 man-pages/man7/posixoptions.7:508
#: man-pages/man7/posixoptions.7:539 man-pages/man7/posixoptions.7:550
#: man-pages/man7/posixoptions.7:585 man-pages/man7/posixoptions.7:602
msgid "Affected functions are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:503
#, no-wrap
msgid ""
"I<pthread_attr_getstack>(),\n"
"I<pthread_attr_getstackaddr>(),\n"
"I<pthread_attr_setstack>(),\n"
"I<pthread_attr_setstackaddr>().\n"
msgstr "I<pthread_attr_getstack>(),\nI<pthread_attr_getstackaddr>(),\nI<pthread_attr_setstack>(),\nI<pthread_attr_setstackaddr>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:506
#, no-wrap
msgid "TSS - _POSIX_THREAD_ATTR_STACKSIZE - _SC_THREAD_ATTR_STACKSIZE"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:516
#, no-wrap
msgid ""
"I<pthread_attr_getstack>(),\n"
"I<pthread_attr_getstacksize>(),\n"
"I<pthread_attr_setstack>(),\n"
"I<pthread_attr_setstacksize>().\n"
msgstr "I<pthread_attr_getstack>(),\nI<pthread_attr_getstacksize>(),\nI<pthread_attr_setstack>(),\nI<pthread_attr_setstacksize>().\n"

#. type: SS
#: man-pages/man7/posixoptions.7:519
#, no-wrap
msgid "TCT - _POSIX_THREAD_CPUTIME - _SC_THREAD_CPUTIME"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:525
msgid ""
"The clockID CLOCK_THREAD_CPUTIME_ID is supported.  This option implies the "
"B<_POSIX_TIMERS> option.  Affected functions are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:534
#, no-wrap
msgid ""
"I<pthread_getcpuclockid>(),\n"
"I<clock_getres>(),\n"
"I<clock_gettime>(),\n"
"I<clock_settime>(),\n"
"I<timer_create>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:537
#, no-wrap
msgid "TPI - _POSIX_THREAD_PRIO_INHERIT - _SC_THREAD_PRIO_INHERIT"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:545
#, no-wrap
msgid ""
"I<pthread_mutexattr_getprotocol>(),\n"
"I<pthread_mutexattr_setprotocol>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:548
#, no-wrap
msgid "TPP - _POSIX_THREAD_PRIO_PROTECT - _SC_THREAD_PRIO_PROTECT"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:560
#, no-wrap
msgid ""
"I<pthread_mutex_getprioceiling>(),\n"
"I<pthread_mutex_setprioceiling>(),\n"
"I<pthread_mutexattr_getprioceiling>(),\n"
"I<pthread_mutexattr_getprotocol>(),\n"
"I<pthread_mutexattr_setprioceiling>(),\n"
"I<pthread_mutexattr_setprotocol>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:563
#, no-wrap
msgid ""
"TPS - _POSIX_THREAD_PRIORITY_SCHEDULING - _SC_THREAD_PRIORITY_SCHEDULING"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:567
msgid ""
"If this option is in effect, the different threads inside a process can run "
"with different priorities and/or different schedulers.  Affected functions "
"are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:580
#, no-wrap
msgid ""
"I<pthread_attr_getinheritsched>(),\n"
"I<pthread_attr_getschedpolicy>(),\n"
"I<pthread_attr_getscope>(),\n"
"I<pthread_attr_setinheritsched>(),\n"
"I<pthread_attr_setschedpolicy>(),\n"
"I<pthread_attr_setscope>(),\n"
"I<pthread_getschedparam>(),\n"
"I<pthread_setschedparam>(),\n"
"I<pthread_setschedprio>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:583
#, no-wrap
msgid "TSH - _POSIX_THREAD_PROCESS_SHARED - _SC_THREAD_PROCESS_SHARED"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:597
#, no-wrap
msgid ""
"I<pthread_barrierattr_getpshared>(),\n"
"I<pthread_barrierattr_setpshared>(),\n"
"I<pthread_condattr_getpshared>(),\n"
"I<pthread_condattr_setpshared>(),\n"
"I<pthread_mutexattr_getpshared>(),\n"
"I<pthread_mutexattr_setpshared>(),\n"
"I<pthread_rwlockattr_getpshared>(),\n"
"I<pthread_rwlockattr_setpshared>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:600
#, no-wrap
msgid "TSF - _POSIX_THREAD_SAFE_FUNCTIONS - _SC_THREAD_SAFE_FUNCTIONS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:625
#, no-wrap
msgid ""
"I<readdir_r>(),\n"
"I<getgrgid_r>(),\n"
"I<getgrnam_r>(),\n"
"I<getpwnam_r>(),\n"
"I<getpwuid_r>(),\n"
"I<flockfile>(),\n"
"I<ftrylockfile>(),\n"
"I<funlockfile>(),\n"
"I<getc_unlocked>(),\n"
"I<getchar_unlocked>(),\n"
"I<putc_unlocked>(),\n"
"I<putchar_unlocked>(),\n"
"I<rand_r>(),\n"
"I<strerror_r>(),\n"
"I<strtok_r>(),\n"
"I<asctime_r>(),\n"
"I<ctime_r>(),\n"
"I<gmtime_r>(),\n"
"I<localtime_r>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:628
#, no-wrap
msgid "TSP - _POSIX_THREAD_SPORADIC_SERVER - _SC_THREAD_SPORADIC_SERVER"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:633
msgid ""
"This option implies the B<_POSIX_THREAD_PRIORITY_SCHEDULING> option.  "
"Affected functions are"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:640
#, no-wrap
msgid ""
"I<sched_getparam>(),\n"
"I<sched_setparam>(),\n"
"I<sched_setscheduler>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:643
#, no-wrap
msgid "THR - _POSIX_THREADS - _SC_THREADS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:646
msgid ""
"Basic support for POSIX threads is available.  The following functions are "
"present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:698
#, no-wrap
msgid ""
"I<pthread_atfork>(),\n"
"I<pthread_attr_destroy>(),\n"
"I<pthread_attr_getdetachstate>(),\n"
"I<pthread_attr_getschedparam>(),\n"
"I<pthread_attr_init>(),\n"
"I<pthread_attr_setdetachstate>(),\n"
"I<pthread_attr_setschedparam>(),\n"
"I<pthread_cancel>(),\n"
"I<pthread_cleanup_push>(),\n"
"I<pthread_cleanup_pop>(),\n"
"I<pthread_cond_broadcast>(),\n"
"I<pthread_cond_destroy>(),\n"
"I<pthread_cond_init>(),\n"
"I<pthread_cond_signal>(),\n"
"I<pthread_cond_timedwait>(),\n"
"I<pthread_cond_wait>(),\n"
"I<pthread_condattr_destroy>(),\n"
"I<pthread_condattr_init>(),\n"
"I<pthread_create>(),\n"
"I<pthread_detach>(),\n"
"I<pthread_equal>(),\n"
"I<pthread_exit>(),\n"
"I<pthread_getspecific>(),\n"
"I<pthread_join>(),\n"
"I<pthread_key_create>(),\n"
"I<pthread_key_delete>(),\n"
"I<pthread_mutex_destroy>(),\n"
"I<pthread_mutex_init>(),\n"
"I<pthread_mutex_lock>(),\n"
"I<pthread_mutex_trylock>(),\n"
"I<pthread_mutex_unlock>(),\n"
"I<pthread_mutexattr_destroy>(),\n"
"I<pthread_mutexattr_init>(),\n"
"I<pthread_once>(),\n"
"I<pthread_rwlock_destroy>(),\n"
"I<pthread_rwlock_init>(),\n"
"I<pthread_rwlock_rdlock>(),\n"
"I<pthread_rwlock_tryrdlock>(),\n"
"I<pthread_rwlock_trywrlock>(),\n"
"I<pthread_rwlock_unlock>(),\n"
"I<pthread_rwlock_wrlock>(),\n"
"I<pthread_rwlockattr_destroy>(),\n"
"I<pthread_rwlockattr_init>(),\n"
"I<pthread_self>(),\n"
"I<pthread_setcancelstate>(),\n"
"I<pthread_setcanceltype>(),\n"
"I<pthread_setspecific>(),\n"
"I<pthread_testcancel>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:701
#, no-wrap
msgid "TMO - _POSIX_TIMEOUTS - _SC_TIMEOUTS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:714
#, no-wrap
msgid ""
"I<mq_timedreceive>(),\n"
"I<mq_timedsend>(),\n"
"I<pthread_mutex_timedlock>(),\n"
"I<pthread_rwlock_timedrdlock>(),\n"
"I<pthread_rwlock_timedwrlock>(),\n"
"I<sem_timedwait>(),\n"
"I<posix_trace_timedgetnext_event>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:717
#, no-wrap
msgid "TMR - _POSIX_TIMERS - _SC_TIMERS"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:732
#, no-wrap
msgid ""
"I<clock_getres>(),\n"
"I<clock_gettime>(),\n"
"I<clock_settime>(),\n"
"I<nanosleep>(),\n"
"I<timer_create>(),\n"
"I<timer_delete>(),\n"
"I<timer_gettime>(),\n"
"I<timer_getoverrun>(),\n"
"I<timer_settime>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:735
#, no-wrap
msgid "TRC - _POSIX_TRACE - _SC_TRACE"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:738
msgid "POSIX tracing is available.  The following functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:773
#, no-wrap
msgid ""
"I<posix_trace_attr_destroy>(),\n"
"I<posix_trace_attr_getclockres>(),\n"
"I<posix_trace_attr_getcreatetime>(),\n"
"I<posix_trace_attr_getgenversion>(),\n"
"I<posix_trace_attr_getmaxdatasize>(),\n"
"I<posix_trace_attr_getmaxsystemeventsize>(),\n"
"I<posix_trace_attr_getmaxusereventsize>(),\n"
"I<posix_trace_attr_getname>(),\n"
"I<posix_trace_attr_getstreamfullpolicy>(),\n"
"I<posix_trace_attr_getstreamsize>(),\n"
"I<posix_trace_attr_init>(),\n"
"I<posix_trace_attr_setmaxdatasize>(),\n"
"I<posix_trace_attr_setname>(),\n"
"I<posix_trace_attr_setstreamsize>(),\n"
"I<posix_trace_attr_setstreamfullpolicy>(),\n"
"I<posix_trace_clear>(),\n"
"I<posix_trace_create>(),\n"
"I<posix_trace_event>(),\n"
"I<posix_trace_eventid_equal>(),\n"
"I<posix_trace_eventid_get_name>(),\n"
"I<posix_trace_eventid_open>(),\n"
"I<posix_trace_eventtypelist_getnext_id>(),\n"
"I<posix_trace_eventtypelist_rewind>(),\n"
"I<posix_trace_flush>(),\n"
"I<posix_trace_get_attr>(),\n"
"I<posix_trace_get_status>(),\n"
"I<posix_trace_getnext_event>(),\n"
"I<posix_trace_shutdown>(),\n"
"I<posix_trace_start>(),\n"
"I<posix_trace_stop>(),\n"
"I<posix_trace_trygetnext_event>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:776
#, no-wrap
msgid "TEF - _POSIX_TRACE_EVENT_FILTER - _SC_TRACE_EVENT_FILTER"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:781 man-pages/man7/posixoptions.7:816
msgid ""
"This option implies the B<_POSIX_TRACE> option.  The following functions are"
" present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:793
#, no-wrap
msgid ""
"I<posix_trace_eventset_add>(),\n"
"I<posix_trace_eventset_del>(),\n"
"I<posix_trace_eventset_empty>(),\n"
"I<posix_trace_eventset_fill>(),\n"
"I<posix_trace_eventset_ismember>(),\n"
"I<posix_trace_get_filter>(),\n"
"I<posix_trace_set_filter>(),\n"
"I<posix_trace_trid_eventid_open>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:796
#, no-wrap
msgid "TRI - _POSIX_TRACE_INHERIT - _SC_TRACE_INHERIT"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:802
msgid ""
"Tracing children of the traced process is supported.  This option implies "
"the B<_POSIX_TRACE> option.  The following functions are present:"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:808
#, no-wrap
msgid ""
"I<posix_trace_attr_getinherited>(),\n"
"I<posix_trace_attr_setinherited>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:811
#, no-wrap
msgid "TRL - _POSIX_TRACE_LOG - _SC_TRACE_LOG"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:828
#, no-wrap
msgid ""
"I<posix_trace_attr_getlogfullpolicy>(),\n"
"I<posix_trace_attr_getlogsize>(),\n"
"I<posix_trace_attr_setlogfullpolicy>(),\n"
"I<posix_trace_attr_setlogsize>(),\n"
"I<posix_trace_close>(),\n"
"I<posix_trace_create_withlog>(),\n"
"I<posix_trace_open>(),\n"
"I<posix_trace_rewind>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:831
#, no-wrap
msgid "TYM - _POSIX_TYPED_MEMORY_OBJECTS - _SC_TYPED_MEMORY_OBJECT"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:840
#, no-wrap
msgid ""
"I<posix_mem_offset>(),\n"
"I<posix_typed_mem_get_info>(),\n"
"I<posix_typed_mem_open>().\n"
msgstr ""

#. type: SS
#: man-pages/man7/posixoptions.7:843
#, no-wrap
msgid "--- - _POSIX_VDISABLE"
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:847
msgid ""
"Always present (probably 0).  Value to set a changeable special control "
"character to indicate that it is disabled."
msgstr ""

#. type: SH
#: man-pages/man7/posixoptions.7:847
#, no-wrap
msgid "XOPEN EXTENSIONS"
msgstr ""

#.  To be described.
#. type: Plain text
#: man-pages/man7/posixoptions.7:854
msgid ""
"B<_XOPEN_CRYPT>, B<_XOPEN_LEGACY>, B<_XOPEN_REALTIME>, "
"B<_XOPEN_REALTIME_THREADS>, B<_XOPEN_UNIX>."
msgstr ""

#. type: Plain text
#: man-pages/man7/posixoptions.7:856
msgid "B<sysconf>(3), B<standards>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/pipe.7:25
#, no-wrap
msgid "PIPE"
msgstr "PIPE"

#. type: TH
#: man-pages/man7/pipe.7:25
#, no-wrap
msgid "2014-07-08"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:28
msgid "pipe - overview of pipes and FIFOs"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:37
msgid ""
"Pipes and FIFOs (also known as named pipes)  provide a unidirectional "
"interprocess communication channel.  A pipe has a I<read end> and a I<write "
"end>.  Data written to the write end of a pipe can be read from the read end"
" of the pipe."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:47
msgid ""
"A pipe is created using B<pipe>(2), which creates a new pipe and returns two"
" file descriptors, one referring to the read end of the pipe, the other "
"referring to the write end.  Pipes can be used to create a communication "
"channel between related processes; see B<pipe>(2)  for an example."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:66
msgid ""
"A FIFO (short for First In First Out) has a name within the filesystem "
"(created using B<mkfifo>(3)), and is opened using B<open>(2).  Any process "
"may open a FIFO, assuming the file permissions allow it.  The read end is "
"opened using the B<O_RDONLY> flag; the write end is opened using the "
"B<O_WRONLY> flag.  See B<fifo>(7)  for further details.  I<Note>: although "
"FIFOs have a pathname in the filesystem, I/O on FIFOs does not involve "
"operations on the underlying device (if there is one)."
msgstr ""

#. type: SS
#: man-pages/man7/pipe.7:66
#, no-wrap
msgid "I/O on pipes and FIFOs"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:71
msgid ""
"The only difference between pipes and FIFOs is the manner in which they are "
"created and opened.  Once these tasks have been accomplished, I/O on pipes "
"and FIFOs has exactly the same semantics."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:85
msgid ""
"If a process attempts to read from an empty pipe, then B<read>(2)  will "
"block until data is available.  If a process attempts to write to a full "
"pipe (see below), then B<write>(2)  blocks until sufficient data has been "
"read from the pipe to allow the write to complete.  Nonblocking I/O is "
"possible by using the B<fcntl>(2)  B<F_SETFL> operation to enable the "
"B<O_NONBLOCK> open file status flag."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:89
msgid ""
"The communication channel provided by a pipe is a I<byte stream>: there is "
"no concept of message boundaries."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:116
msgid ""
"If all file descriptors referring to the write end of a pipe have been "
"closed, then an attempt to B<read>(2)  from the pipe will see end-of-file "
"(B<read>(2)  will return 0).  If all file descriptors referring to the read "
"end of a pipe have been closed, then a B<write>(2)  will cause a B<SIGPIPE> "
"signal to be generated for the calling process.  If the calling process is "
"ignoring this signal, then B<write>(2)  fails with the error B<EPIPE>.  An "
"application that uses B<pipe>(2)  and B<fork>(2)  should use suitable "
"B<close>(2)  calls to close unnecessary duplicate file descriptors; this "
"ensures that end-of-file and B<SIGPIPE>/B<EPIPE> are delivered when "
"appropriate."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:120
msgid "It is not possible to apply B<lseek>(2)  to a pipe."
msgstr ""

#. type: SS
#: man-pages/man7/pipe.7:120
#, no-wrap
msgid "Pipe capacity"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:132
msgid ""
"A pipe has a limited capacity.  If the pipe is full, then a B<write>(2)  "
"will block or fail, depending on whether the B<O_NONBLOCK> flag is set (see "
"below).  Different implementations have different limits for the pipe "
"capacity.  Applications should not rely on a particular capacity: an "
"application should be designed so that a reading process consumes data as "
"soon as it is available, so that a writing process does not remain blocked."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:146
msgid ""
"In Linux versions before 2.6.11, the capacity of a pipe was the same as the "
"system page size (e.g., 4096 bytes on i386).  Since Linux 2.6.11, the pipe "
"capacity is 65536 bytes.  Since Linux 2.6.35, the default pipe capacity is "
"65536 bytes, but the capacity can be queried and set using the B<fcntl>(2)  "
"B<F_GETPIPE_SZ> and B<F_SETPIPE_SZ> operations.  See B<fcntl>(2)  for more "
"information."
msgstr ""

#. type: SS
#: man-pages/man7/pipe.7:147
#, no-wrap
msgid "PIPE_BUF"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:169
msgid ""
"POSIX.1-2001 says that B<write>(2)s of less than B<PIPE_BUF> bytes must be "
"atomic: the output data is written to the pipe as a contiguous sequence.  "
"Writes of more than B<PIPE_BUF> bytes may be nonatomic: the kernel may "
"interleave the data with data written by other processes.  POSIX.1-2001 "
"requires B<PIPE_BUF> to be at least 512 bytes.  (On Linux, B<PIPE_BUF> is "
"4096 bytes.)  The precise semantics depend on whether the file descriptor is"
" nonblocking (B<O_NONBLOCK>), whether there are multiple writers to the "
"pipe, and on I<n>, the number of bytes to be written:"
msgstr ""

#. type: TP
#: man-pages/man7/pipe.7:169
#, no-wrap
msgid "B<O_NONBLOCK> disabled, I<n> E<lt>= B<PIPE_BUF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:178
msgid ""
"All I<n> bytes are written atomically; B<write>(2)  may block if there is "
"not room for I<n> bytes to be written immediately"
msgstr ""

#. type: TP
#: man-pages/man7/pipe.7:178
#, no-wrap
msgid "B<O_NONBLOCK> enabled, I<n> E<lt>= B<PIPE_BUF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:192
msgid ""
"If there is room to write I<n> bytes to the pipe, then B<write>(2)  succeeds"
" immediately, writing all I<n> bytes; otherwise B<write>(2)  fails, with "
"I<errno> set to B<EAGAIN>."
msgstr ""

#. type: TP
#: man-pages/man7/pipe.7:192
#, no-wrap
msgid "B<O_NONBLOCK> disabled, I<n> E<gt> B<PIPE_BUF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:204
msgid ""
"The write is nonatomic: the data given to B<write>(2)  may be interleaved "
"with B<write>(2)s by other process; the B<write>(2)  blocks until I<n> bytes"
" have been written."
msgstr ""

#. type: TP
#: man-pages/man7/pipe.7:204
#, no-wrap
msgid "B<O_NONBLOCK> enabled, I<n> E<gt> B<PIPE_BUF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:219
msgid ""
"If the pipe is full, then B<write>(2)  fails, with I<errno> set to "
"B<EAGAIN>.  Otherwise, from 1 to I<n> bytes may be written (i.e., a "
"\"partial write\" may occur; the caller should check the return value from "
"B<write>(2)  to see how many bytes were actually written), and these bytes "
"may be interleaved with writes by other processes."
msgstr ""

#. type: SS
#: man-pages/man7/pipe.7:219
#, no-wrap
msgid "Open file status flags"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:225
msgid ""
"The only open file status flags that can be meaningfully applied to a pipe "
"or FIFO are B<O_NONBLOCK> and B<O_ASYNC>."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:237
msgid ""
"Setting the B<O_ASYNC> flag for the read end of a pipe causes a signal "
"(B<SIGIO> by default) to be generated when new input becomes available on "
"the pipe (see B<fcntl>(2)  for details).  On Linux, B<O_ASYNC> is supported "
"for pipes and FIFOs only since kernel 2.6."
msgstr ""

#. type: SS
#: man-pages/man7/pipe.7:237
#, no-wrap
msgid "Portability notes"
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:243
msgid ""
"On some systems (but not Linux), pipes are bidirectional: data can be "
"transmitted in both directions between the pipe ends.  According to "
"POSIX.1-2001, pipes only need to be unidirectional.  Portable applications "
"should avoid reliance on bidirectional pipe semantics."
msgstr ""

#. type: Plain text
#: man-pages/man7/pipe.7:254
msgid ""
"B<dup>(2), B<fcntl>(2), B<open>(2), B<pipe>(2), B<poll>(2), B<select>(2), "
"B<socketpair>(2), B<stat>(2), B<mkfifo>(3), B<epoll>(7), B<fifo>(7)"
msgstr "B<dup>(2), B<fcntl>(2), B<open>(2), B<pipe>(2), B<poll>(2), B<select>(2), B<socketpair>(2), B<stat>(2), B<mkfifo>(3), B<epoll>(7), B<fifo>(7)"

#. type: TH
#: man-pages/man7/packet.7:12
#, no-wrap
msgid "PACKET"
msgstr "PACKET"

#. type: TH
#: man-pages/man7/packet.7:12
#, no-wrap
msgid "2014-04-28"
msgstr "2014-04-28"

#. type: Plain text
#: man-pages/man7/packet.7:15
msgid "packet - packet interface on device level"
msgstr ""

#. type: SH
#: man-pages/man7/packet.7:15
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/packet.7:18
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/packet.7:20
#, no-wrap
msgid "B<#include E<lt>netpacket/packet.hE<gt>>\n"
msgstr "B<#include E<lt>netpacket/packet.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/packet.7:22
#, no-wrap
msgid "B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:24
#, no-wrap
msgid ""
"B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int "
">I<protocol>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:30
msgid ""
"Packet sockets are used to receive or send raw packets at the device driver "
"(OSI Layer 2) level.  They allow the user to implement protocol modules in "
"user space on top of the physical layer."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:51
msgid ""
"The I<socket_type> is either B<SOCK_RAW> for raw packets including the link-"
"level header or B<SOCK_DGRAM> for cooked packets with the link-level header "
"removed.  The link-level header information is available in a common format "
"in a I<sockaddr_ll>.  I<protocol> is the IEEE 802.3 protocol number in "
"network byte order.  See the I<E<lt>linux/if_ether.hE<gt>> include file for "
"a list of allowed protocols.  When protocol is set to B<htons(ETH_P_ALL)> "
"then all protocols are received.  All incoming packets of that protocol type"
" will be passed to the packet socket before they are passed to the protocols"
" implemented in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:55
msgid ""
"Only processes with effective UID 0 or the B<CAP_NET_RAW> capability may "
"open packet sockets."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:73
msgid ""
"B<SOCK_RAW> packets are passed to and from the device driver without any "
"changes in the packet data.  When receiving a packet, the address is still "
"parsed and passed in a standard I<sockaddr_ll> address structure.  When "
"transmitting a packet, the user supplied buffer should contain the physical "
"layer header.  That packet is then queued unmodified to the network driver "
"of the interface defined by the destination address.  Some device drivers "
"always add other headers.  B<SOCK_RAW> is similar to but not compatible with"
" the obsolete B<AF_INET/SOCK_PACKET> of Linux 2.0."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:83
msgid ""
"B<SOCK_DGRAM> operates on a slightly higher level.  The physical header is "
"removed before the packet is passed to the user.  Packets sent through a "
"B<SOCK_DGRAM> packet socket get a suitable physical layer header based on "
"the information in the I<sockaddr_ll> destination address before they are "
"queued."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:96
msgid ""
"By default all packets of the specified protocol type are passed to a packet"
" socket.  To get packets only from a specific interface use B<bind>(2)  "
"specifying an address in a I<struct sockaddr_ll> to bind the packet socket "
"to an interface.  Only the I<sll_protocol> and the I<sll_ifindex> address "
"fields are used for purposes of binding."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:100
msgid "The B<connect>(2)  operation is not supported on packet sockets."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:109
msgid ""
"When the B<MSG_TRUNC> flag is passed to B<recvmsg>(2), B<recv>(2), "
"B<recvfrom>(2)  the real length of the packet on the wire is always "
"returned, even when it is longer than the buffer."
msgstr ""

#. type: SS
#: man-pages/man7/packet.7:109
#, no-wrap
msgid "Address types"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:113
msgid "The I<sockaddr_ll> is a device independent physical layer address."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:125
#, no-wrap
msgid ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* Always AF_PACKET */\n"
"    unsigned short sll_protocol; /* Physical layer protocol */\n"
"    int            sll_ifindex;  /* Interface number */\n"
"    unsigned short sll_hatype;   /* ARP hardware type */\n"
"    unsigned char  sll_pkttype;  /* Packet type */\n"
"    unsigned char  sll_halen;    /* Length of address */\n"
"    unsigned char  sll_addr[8];  /* Physical layer address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:164
msgid ""
"I<sll_protocol> is the standard ethernet protocol type in network byte order"
" as defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It defaults "
"to the socket's protocol.  I<sll_ifindex> is the interface index of the "
"interface (see B<netdevice>(7)); 0 matches any interface (only permitted for"
" binding).  I<sll_hatype> is an ARP type as defined in the "
"I<E<lt>linux/if_arp.hE<gt>> include file.  I<sll_pkttype> contains the "
"packet type.  Valid types are B<PACKET_HOST> for a packet addressed to the "
"local host, B<PACKET_BROADCAST> for a physical layer broadcast packet, "
"B<PACKET_MULTICAST> for a packet sent to a physical layer multicast address,"
" B<PACKET_OTHERHOST> for a packet to some other host that has been caught by"
" a device driver in promiscuous mode, and B<PACKET_OUTGOING> for a packet "
"originated from the local host that is looped back to a packet socket.  "
"These types make sense only for receiving.  I<sll_addr> and I<sll_halen> "
"contain the physical layer (e.g., IEEE 802.3) address and its length.  The "
"exact interpretation depends on the device."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:180
msgid ""
"When you send packets it is enough to specify I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex>.  The other fields should be 0.  I<sll_hatype> "
"and I<sll_pkttype> are set on received packets for your information.  For "
"bind only I<sll_protocol> and I<sll_ifindex> are used."
msgstr ""

#. type: SS
#: man-pages/man7/packet.7:180
#, no-wrap
msgid "Socket options"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:185
msgid ""
"Packet socket options are configured by calling B<setsockopt>(2)  with level"
" B<SOL_PACKET>."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:185
#, no-wrap
msgid "B<PACKET_ADD_MEMBERSHIP>"
msgstr "B<PACKET_ADD_MEMBERSHIP>"

#. type: TP
#: man-pages/man7/packet.7:188
#, no-wrap
msgid "B<PACKET_DROP_MEMBERSHIP>"
msgstr "B<PACKET_DROP_MEMBERSHIP>"

#. type: Plain text
#: man-pages/man7/packet.7:200
msgid ""
"Packet sockets can be used to configure physical layer multicasting and "
"promiscuous mode.  B<PACKET_ADD_MEMBERSHIP> adds a binding and "
"B<PACKET_DROP_MEMBERSHIP> drops it.  They both expect a I<packet_mreq> "
"structure as argument:"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:209
#, no-wrap
msgid ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* interface index */\n"
"    unsigned short mr_type;       /* action */\n"
"    unsigned short mr_alen;       /* address length */\n"
"    unsigned char  mr_address[8]; /* physical layer address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:230
msgid ""
"B<mr_ifindex> contains the interface index for the interface whose status "
"should be changed.  The B<mr_type> parameter specifies which action to "
"perform.  B<PACKET_MR_PROMISC> enables receiving all packets on a shared "
"medium (often known as \"promiscuous mode\"), B<PACKET_MR_MULTICAST> binds "
"the socket to the physical layer multicast group specified in B<mr_address> "
"and B<mr_alen>, and B<PACKET_MR_ALLMULTI> sets the socket up to receive all "
"multicast packets arriving at the interface."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:236
msgid ""
"In addition, the traditional ioctls B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> can be used for the same purpose."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:236
#, no-wrap
msgid "B<PACKET_AUXDATA> (since Linux 2.6.21)"
msgstr "B<PACKET_AUXDATA> (начиная с Linux 2.6.21)"

#.  commit 8dc4194474159660d7f37c495e3fc3f10d0db8cc
#. type: Plain text
#: man-pages/man7/packet.7:246
msgid ""
"If this binary option is enabled, the packet socket passes a metadata "
"structure along with each packet in the B<recvmsg>(2)  control field.  The "
"structure can be read with B<cmsg>(3).  It is defined as"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:258
#, no-wrap
msgid ""
"struct tpacket_auxdata {\n"
"    __u32 tp_status;\n"
"    __u32 tp_len;      /* packet length */\n"
"    __u32 tp_snaplen;  /* captured length */\n"
"    __u16 tp_mac;\n"
"    __u16 tp_net;\n"
"    __u16 tp_vlan_tci;\n"
"    __u16 tp_padding;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:260
#, no-wrap
msgid "B<PACKET_FANOUT> (since Linux 3.1)"
msgstr "B<PACKET_FANOUT> (начиная с Linux 3.1)"

#.  commit dc99f600698dcac69b8f56dda9a8a00d645c5ffc
#. type: Plain text
#: man-pages/man7/packet.7:282
msgid ""
"To scale processing across threads, packet sockets can form a fanout group."
"  In this mode, each matching packet is enqueued onto only one socket in the"
" group.  A socket joins a fanout group by calling B<setsockopt>(2)  with "
"level B<SOL_PACKET> and option B<PACKET_FANOUT>.  Each network namespace can"
" have up to 65536 independent groups.  A socket selects a group by encoding "
"the ID in the first 16 bits of the integer option value.  The first packet "
"socket to join a group implicitly creates it.  To successfully join an "
"existing group, subsequent packet sockets must have the same protocol, "
"device settings, fanout mode and flags (see below).  Packet sockets can "
"leave a fanout group only by closing the socket.  The group is deleted when "
"the last socket is closed."
msgstr ""

#.  commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
#. type: Plain text
#: man-pages/man7/packet.7:305
msgid ""
"Fanout supports multiple algorithms to spread traffic between sockets.  The "
"default mode, B<PACKET_FANOUT_HASH>, sends packets from the same flow to the"
" same socket to maintain per-flow ordering.  For each packet, it chooses a "
"socket by taking the packet flow hash modulo the number of sockets in the "
"group, where a flow hash is a hash over network-layer address and optional "
"transport-layer port fields.  The load-balance mode B<PACKET_FANOUT_LB> "
"implements a round-robin algorithm.  B<PACKET_FANOUT_CPU> selects the socket"
" based on the CPU that the packet arrived on.  B<PACKET_FANOUT_ROLLOVER> "
"processes all data on a single socket, moves to the next when one becomes "
"backlogged.  B<PACKET_FANOUT_RND> selects the socket using a pseudo-random "
"number generator.  B<PACKET_FANOUT_QM> (available since Linux 3.14)  selects"
" the socket using the recorded queue_mapping of the received skb."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:320
msgid ""
"Fanout modes can take additional options.  IP fragmentation causes packets "
"from the same flow to have different flow hashes.  The flag "
"B<PACKET_FANOUT_FLAG_DEFRAG>, if set, causes packet to be defragmented "
"before fanout is applied, to preserve order even in this case.  Fanout mode "
"and options are communicated in the second 16 bits of the integer option "
"value.  The flag B<PACKET_FANOUT_FLAG_ROLLOVER> enables the roll over "
"mechanism as a backup strategy: if the original fanout algorithm selects a "
"backlogged socket, the packet rolls over to the next available one."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:320
#, no-wrap
msgid "B<PACKET_LOSS> (with B<PACKET_TX_RING>)"
msgstr "B<PACKET_LOSS> (с B<PACKET_TX_RING>)"

#. type: Plain text
#: man-pages/man7/packet.7:343
msgid ""
"When a malformed packet is encountered on a transmit ring, the default is to"
" reset its I<tp_status> to B<TP_STATUS_WRONG_FORMAT> and abort the "
"transmission immediately.  The malformed packet blocks itself and "
"subsequently enqueued packets from being sent.  The format error must be "
"fixed, the associated I<tp_status> reset to B<TP_STATUS_SEND_REQUEST>, and "
"the transmission process restarted via B<send>(2).  However, if "
"B<PACKET_LOSS> is set, any malformed packet will be skipped, its "
"I<tp_status> reset to B<TP_STATUS_AVAILABLE>, and the transmission process "
"continued."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:343
#, no-wrap
msgid "B<PACKET_RESERVE> (with B<PACKET_RX_RING>)"
msgstr "B<PACKET_RESERVE> (с B<PACKET_RX_RING>)"

#. type: Plain text
#: man-pages/man7/packet.7:348
msgid ""
"By default, a packet receive ring writes packets immediately following the "
"metadata structure and alignment padding.  This integer option reserves "
"additional headroom."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:348
#, no-wrap
msgid "B<PACKET_RX_RING>"
msgstr "B<PACKET_RX_RING>"

#. type: Plain text
#: man-pages/man7/packet.7:394
msgid ""
"Create a memory-mapped ring buffer for asynchronous packet reception.  The "
"packet socket reserves a contiguous region of application address space, "
"lays it out into an array of packet slots and copies packets (up to "
"I<tp_snaplen>)  into subsequent slots.  Each packet is preceded by a "
"metadata structure similar to I<tpacket_auxdata>.  The protocol fields "
"encode the offset to the data from the start of the metadata header.  "
"I<tp_net> stores the offset to the network layer.  If the packet socket is "
"of type B<SOCK_DGRAM>, then I<tp_mac> is the same.  If it is of type "
"B<SOCK_RAW>, then that field stores the offset to the link-layer frame.  "
"Packet socket and application communicate the head and tail of the ring "
"through the I<tp_status> field.  The packet socket owns all slots with "
"I<tp_status> equal to B<TP_STATUS_KERNEL>.  After filling a slot, it changes"
" the status of the slot to transfer ownership to the application.  During "
"normal operation, the new I<tp_status> value has at least the "
"B<TP_STATUS_USER> bit set to signal that a received packet has been stored."
"  When the application has finished processing a packet, it transfers "
"ownership of the slot back to the socket by setting I<tp_status> equal to "
"B<TP_STATUS_KERNEL>.  Packet sockets implement multiple variants of the "
"packet ring.  The implementation details are described in "
"I<Documentation/networking/packet_mmap.txt> in the Linux kernel source tree."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:394
#, no-wrap
msgid "B<PACKET_STATISTICS>"
msgstr "B<PACKET_STATISTICS>"

#. type: Plain text
#: man-pages/man7/packet.7:397
msgid "Retrieve packet socket statistics in the form of a structure"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:404
#, no-wrap
msgid ""
"struct tpacket_stats {\n"
"    unsigned int tp_packets;  /* Total packet count */\n"
"    unsigned int tp_drops;    /* Dropped packet count */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:410
msgid ""
"Receiving statistics resets the internal counters.  The statistics structure"
" differs when using a ring of variant B<TPACKET_V3>."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:410
#, no-wrap
msgid "B<PACKET_TIMESTAMP> (with B<PACKET_RX_RING>; since Linux 2.6.36)"
msgstr "B<PACKET_TIMESTAMP> (с B<PACKET_RX_RING>; начиная с Linux 2.6.36)"

#.  commit 614f60fa9d73a9e8fdff3df83381907fea7c5649
#. type: Plain text
#: man-pages/man7/packet.7:420
msgid ""
"The packet receive ring always stores a timestamp in the metadata header.  "
"By default, this is a software generated timestamp generated when the packet"
" is copied into the ring.  This integer option selects the type of "
"timestamp.  Besides the default, it support the two hardware formats "
"described in I<Documentation/networking/timestamping.txt> in the Linux "
"kernel source tree."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:420
#, no-wrap
msgid "B<PACKET_TX_RING> (since Linux 2.6.31)"
msgstr "B<PACKET_TX_RING> (начиная с Linux 2.6.31)"

#.  commit 69e3c75f4d541a6eb151b3ef91f34033cb3ad6e1
#. type: Plain text
#: man-pages/man7/packet.7:455
msgid ""
"Create a memory-mapped ring buffer for packet transmission.  This option is "
"similar to B<PACKET_RX_RING> and takes the same arguments.  The application "
"writes packets into slots with I<tp_status> equal to B<TP_STATUS_AVAILABLE> "
"and schedules them for transmission by changing I<tp_status> to "
"B<TP_STATUS_SEND_REQUEST>.  When packets are ready to be transmitted, the "
"application calls B<send>(2)  or a variant thereof.  The I<buf> and I<len> "
"fields of this call are ignored.  If an address is passed using B<sendto>(2)"
"  or B<sendmsg>(2), then that overrides the socket default.  On successful "
"transmission, the socket resets I<tp_status> to B<TP_STATUS_AVAILABLE>.  It "
"immediately aborts the transmission on error unless B<PACKET_LOSS> is set."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:455
#, no-wrap
msgid "B<PACKET_VERSION> (with B<PACKET_RX_RING>; since Linux 2.6.27)"
msgstr ""

#.  commit bbd6ef87c544d88c30e4b762b1b61ef267a7d279
#. type: Plain text
#: man-pages/man7/packet.7:464
msgid ""
"By default, B<PACKET_RX_RING> creates a packet receive ring of variant "
"B<TPACKET_V1>.  To create another variant, configure the desired variant by "
"setting this integer option before creating the ring."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:464
#, no-wrap
msgid "B<PACKET_QDISC_BYPASS> (since Linux 3.14)"
msgstr ""

#.  commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
#. type: Plain text
#: man-pages/man7/packet.7:479
msgid ""
"By default, packets sent through packet sockets pass through the kernel's "
"qdisc (traffic control) layer, which is fine for the vast majority of use "
"cases.  For traffic generator appliances using packet sockets that intend to"
" brute-force flood the network\\(emfor example, to test devices under load "
"in a similar fashion to pktgen\\(emthis layer can be bypassed by setting "
"this integer option to 1.  A side effect is that packet buffering in the "
"qdisc layer is avoided, which will lead to increased drops when network "
"device transmit queues are busy; therefore, use at your own risk."
msgstr ""

#. type: SS
#: man-pages/man7/packet.7:479
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#.  FIXME Document SIOCGSTAMPNS
#. type: Plain text
#: man-pages/man7/packet.7:486
msgid ""
"B<SIOCGSTAMP> can be used to receive the timestamp of the last received "
"packet.  Argument is a I<struct timeval> variable."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:492
msgid ""
"In addition, all standard ioctls defined in B<netdevice>(7)  and "
"B<socket>(7)  are valid on packet sockets."
msgstr ""

#. type: SS
#: man-pages/man7/packet.7:492
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:496
msgid ""
"Packet sockets do no error handling other than errors occurred while passing"
" the packet to the device driver.  They don't have the concept of a pending "
"error."
msgstr ""

#. type: SH
#: man-pages/man7/packet.7:496
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/packet.7:497
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: man-pages/man7/packet.7:500
msgid "Unknown multicast group address passed."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:500
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man7/packet.7:503
msgid "User passed invalid memory address."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:503
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/packet.7:506
msgid "Invalid argument."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:506
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man7/packet.7:509
msgid "Packet is bigger than interface MTU."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:509
#, no-wrap
msgid "B<ENETDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:512
msgid "Interface is not up."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:512
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: man-pages/man7/packet.7:515
msgid "Not enough memory to allocate the packet."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:515
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man7/packet.7:518
msgid "Unknown device name or interface index specified in interface address."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:518
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man7/packet.7:521
msgid "No packet received."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:521
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man7/packet.7:524
msgid "No interface address passed."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:524
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man7/packet.7:527
msgid "Interface address contained an invalid interface index."
msgstr ""

#. type: TP
#: man-pages/man7/packet.7:527
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man7/packet.7:530
msgid "User has insufficient privileges to carry out this operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:532
msgid "In addition, other errors may be generated by the low-level driver."
msgstr ""

#. type: SH
#: man-pages/man7/packet.7:532
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/packet.7:537
msgid ""
"B<AF_PACKET> is a new feature in Linux 2.2.  Earlier Linux versions "
"supported only B<SOCK_PACKET>."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:542
msgid ""
"The include file I<E<lt>netpacket/packet.hE<gt>> is present since glibc 2.1."
"  Older systems need:"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:548
#, no-wrap
msgid ""
"#include E<lt>asm/types.hE<gt>\n"
"#include E<lt>linux/if_packet.hE<gt>\n"
"#include E<lt>linux/if_ether.hE<gt>  /* The L2 protocols */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:558
msgid ""
"For portable programs it is suggested to use B<AF_PACKET> via B<pcap>(3); "
"although this covers only a subset of the B<AF_PACKET> features."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:579
msgid ""
"The B<SOCK_DGRAM> packet sockets make no attempt to create or parse the IEEE"
" 802.2 LLC header for a IEEE 802.3 frame.  When B<ETH_P_802_3> is specified "
"as protocol for sending the kernel creates the 802.3 frame and fills out the"
" length field; the user has to supply the LLC header to get a fully "
"conforming packet.  Incoming 802.3 packets are not multiplexed on the "
"DSAP/SSAP protocol fields; instead they are supplied to the user as protocol"
" B<ETH_P_802_2> with the LLC header prefixed.  It is thus not possible to "
"bind to B<ETH_P_802_3>; bind to B<ETH_P_802_2> instead and do the protocol "
"multiplex yourself.  The default for sending is the standard Ethernet DIX "
"encapsulation with the protocol filled in."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:581
msgid "Packet sockets are not subject to the input or output firewall chains."
msgstr ""

#. type: SS
#: man-pages/man7/packet.7:581
#, no-wrap
msgid "Compatibility"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:591
msgid ""
"In Linux 2.0, the only way to get a packet socket was by calling "
"B<socket(AF_INET, SOCK_PACKET, >I<protocol>B<)>.  This is still supported "
"but strongly deprecated.  The main difference between the two methods is "
"that B<SOCK_PACKET> uses the old I<struct sockaddr_pkt> to specify an "
"interface, which doesn't provide physical layer independence."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:599
#, no-wrap
msgid ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:611
msgid ""
"I<spkt_family> contains the device type, I<spkt_protocol> is the IEEE 802.3 "
"protocol type as defined in I<E<lt>sys/if_ether.hE<gt>> and I<spkt_device> "
"is the device name as a null-terminated string, for example, eth0."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:613
msgid "This structure is obsolete and should not be used in new code."
msgstr ""

#. type: SH
#: man-pages/man7/packet.7:613
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/packet.7:617
msgid ""
"glibc 2.1 does not have a define for B<SOL_PACKET>.  The suggested "
"workaround is to use:"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:623
#, no-wrap
msgid ""
"#ifndef SOL_PACKET\n"
"#define SOL_PACKET 263\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:628
msgid ""
"This is fixed in later glibc versions and also does not occur on libc5 "
"systems."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:630
msgid "The IEEE 802.2/803.3 LLC handling could be considered as a bug."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:632
msgid "Socket filters are not documented."
msgstr ""

#.  .SH CREDITS
#.  This man page was written by Andi Kleen with help from Matthew Wilcox.
#.  AF_PACKET in Linux 2.2 was implemented
#.  by Alexey Kuznetsov, based on code by Alan Cox and others.
#. type: Plain text
#: man-pages/man7/packet.7:644
msgid ""
"The B<MSG_TRUNC> B<recvmsg>(2)  extension is an ugly hack and should be "
"replaced by a control message.  There is currently no way to get the "
"original destination address of packets via B<SOCK_DGRAM>."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:651
msgid ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:654
msgid ""
"RFC\\ 894 for the standard IP Ethernet encapsulation.  RFC\\ 1700 for the "
"IEEE 802.3 IP encapsulation."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:658
msgid ""
"The I<E<lt>linux/if_ether.hE<gt>> include file for physical layer protocols."
msgstr ""

#. type: Plain text
#: man-pages/man7/packet.7:666
msgid ""
"The Linux kernel source tree.  I</Documentation/networking/filter.txt> "
"describes how to apply Berkeley Packet Filters to packet sockets.  "
"I</tools/testing/selftests/net/psock_tpacket.c> contains example source code"
" for all available versions of B<PACKET_RX_RING> and B<PACKET_TX_RING>."
msgstr ""

#. type: TH
#: man-pages/man7/pthreads.7:26
#, no-wrap
msgid "PTHREADS"
msgstr "PTHREADS"

#. type: TH
#: man-pages/man7/pthreads.7:26
#, no-wrap
msgid "2014-05-21"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:29
msgid "pthreads - POSIX threads"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:36
msgid ""
"POSIX.1 specifies a set of interfaces (functions, header files) for threaded"
" programming commonly known as POSIX threads, or Pthreads.  A single process"
" can contain multiple threads, all of which are executing the same program."
"  These threads share the same global memory (data and heap segments), but "
"each thread has its own stack (automatic variables)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:39
msgid ""
"POSIX.1 also requires that threads share a range of other attributes (i.e., "
"these attributes are process-wide rather than per-thread):"
msgstr ""

#. type: IP
#: man-pages/man7/pthreads.7:39 man-pages/man7/pthreads.7:41
#: man-pages/man7/pthreads.7:43 man-pages/man7/pthreads.7:45
#: man-pages/man7/pthreads.7:47 man-pages/man7/pthreads.7:49
#: man-pages/man7/pthreads.7:51 man-pages/man7/pthreads.7:54
#: man-pages/man7/pthreads.7:56 man-pages/man7/pthreads.7:59
#: man-pages/man7/pthreads.7:65 man-pages/man7/pthreads.7:70
#: man-pages/man7/pthreads.7:73 man-pages/man7/pthreads.7:76
#: man-pages/man7/pthreads.7:84 man-pages/man7/pthreads.7:88
#: man-pages/man7/pthreads.7:91 man-pages/man7/pthreads.7:95
#: man-pages/man7/pthreads.7:98 man-pages/man7/pthreads.7:103
#: man-pages/man7/pthreads.7:106 man-pages/man7/pthreads.7:683
#: man-pages/man7/pthreads.7:690 man-pages/man7/pthreads.7:702
#: man-pages/man7/pthreads.7:712 man-pages/man7/pthreads.7:716
#: man-pages/man7/pthreads.7:725 man-pages/man7/pthreads.7:735
#: man-pages/man7/pthreads.7:742 man-pages/man7/pthreads.7:749
#: man-pages/man7/pthreads.7:751 man-pages/man7/pthreads.7:754
#: man-pages/man7/pthreads.7:760 man-pages/man7/pthreads.7:763
#: man-pages/man7/pthreads.7:765 man-pages/man7/pthreads.7:767
#: man-pages/man7/pthreads.7:777 man-pages/man7/pthreads.7:797
#: man-pages/man7/pthreads.7:806 man-pages/man7/pthreads.7:812
#: man-pages/man7/pthreads.7:814 man-pages/man7/pthreads.7:816
#: man-pages/man7/pthreads.7:820 man-pages/man7/pthreads.7:825
#: man-pages/man7/pthreads.7:833
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: man-pages/man7/pthreads.7:41
msgid "process ID"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:43
msgid "parent process ID"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:45
msgid "process group ID and session ID"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:47
msgid "controlling terminal"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:49
msgid "user and group IDs"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:51
msgid "open file descriptors"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:54
msgid "record locks (see B<fcntl>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:56
msgid "signal dispositions"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:59
msgid "file mode creation mask (B<umask>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:65
msgid "current directory (B<chdir>(2))  and root directory (B<chroot>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:70
msgid ""
"interval timers (B<setitimer>(2))  and POSIX timers (B<timer_create>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:73
msgid "nice value (B<setpriority>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:76
msgid "resource limits (B<setrlimit>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:81
msgid ""
"measurements of the consumption of CPU time (B<times>(2))  and resources "
"(B<getrusage>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:84
msgid ""
"As well as the stack, POSIX.1 specifies that various other attributes are "
"distinct for each thread, including:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:88
msgid "thread ID (the I<pthread_t> data type)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:91
msgid "signal mask (B<pthread_sigmask>(3))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:95
msgid "the I<errno> variable"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:98
msgid "alternate signal stack (B<sigaltstack>(2))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:101
msgid "real-time scheduling policy and priority (B<sched>(7))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:103
msgid "The following Linux-specific features are also per-thread:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:106
msgid "capabilities (see B<capabilities>(7))"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:109
msgid "CPU affinity (B<sched_setaffinity>(2))"
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:109
#, no-wrap
msgid "Pthreads function return values"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:116
msgid ""
"Most pthreads functions return 0 on success, and an error number of failure."
"  Note that the pthreads functions do not set I<errno>.  For each of the "
"pthreads functions that can return an error, POSIX.1-2001 specifies that the"
" function can never fail with the error B<EINTR>."
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:116
#, no-wrap
msgid "Thread IDs"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:130
msgid ""
"Each of the threads in a process has a unique thread identifier (stored in "
"the type I<pthread_t>).  This identifier is returned to the caller of "
"B<pthread_create>(3), and a thread can obtain its own thread identifier "
"using B<pthread_self>(3).  Thread IDs are guaranteed to be unique only "
"within a process.  A thread ID may be reused after a terminated thread has "
"been joined, or a detached thread has terminated.  In all pthreads functions"
" that accept a thread ID as an argument, that ID by definition refers to a "
"thread in the same process as the caller."
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:130
#, no-wrap
msgid "Thread-safe functions"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:134
msgid ""
"A thread-safe function is one that can be safely (i.e., it will deliver the "
"same results regardless of whether it is)  called from multiple threads at "
"the same time."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:138
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that all functions specified in the "
"standard shall be thread-safe, except for the following functions:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:232
#, no-wrap
msgid ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() if passed a non-NULL argument\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [Added in POSIX.1-2008]\n"
"strtok()\n"
"system() [Added in POSIX.1-2008]\n"
"tmpnam() if passed a non-NULL argument\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() if its final argument is NULL\n"
"wcsrtombs() if its final argument is NULL\n"
"wcstombs()\n"
"wctomb()\n"
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:234
#, no-wrap
msgid "Async-cancel-safe functions"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:238
msgid ""
"An async-cancel-safe function is one that can be safely called in an "
"application where asynchronous cancelability is enabled (see "
"B<pthread_setcancelstate>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:241
msgid ""
"Only the following functions are required to be async-cancel-safe by "
"POSIX.1-2001 and POSIX.1-2008:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:247
#, no-wrap
msgid ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:249
#, no-wrap
msgid "Cancellation points"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:256
msgid ""
"POSIX.1 specifies that certain functions must, and certain other functions "
"may, be cancellation points.  If a thread is cancelable, its cancelability "
"type is deferred, and a cancellation request is pending for the thread, then"
" the thread is canceled when it calls a function that is a cancellation "
"point."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:259
msgid ""
"The following functions are required to be cancellation points by "
"POSIX.1-2001 and/or POSIX.1-2008:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:322
#, no-wrap
msgid ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [Added in POSIX.1-2008]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"
msgstr "accept()\naio_suspend()\nclock_nanosleep()\nclose()\nconnect()\ncreat()\nfcntl() F_SETLKW\nfdatasync()\nfsync()\ngetmsg()\ngetpmsg()\nlockf() F_LOCK\nmq_receive()\nmq_send()\nmq_timedreceive()\nmq_timedsend()\nmsgrcv()\nmsgsnd()\nmsync()\nnanosleep()\nopen()\nopenat() [добавлена в POSIX.1-2008]\npause()\npoll()\npread()\npselect()\npthread_cond_timedwait()\npthread_cond_wait()\npthread_join()\npthread_testcancel()\nputmsg()\nputpmsg()\npwrite()\nread()\nreadv()\nrecv()\nrecvfrom()\nrecvmsg()\nselect()\nsem_timedwait()\nsem_wait()\nsend()\nsendmsg()\nsendto()\nsigpause() [только POSIX.1-2001 (перемещена в список «может» в POSIX.1-2008)]\nsigsuspend()\nsigtimedwait()\nsigwait()\nsigwaitinfo()\nsleep()\nsystem()\ntcdrain()\nusleep() [только POSIX.1-2001 (функция удалена в POSIX.1-2008)]\nwait()\nwaitid()\nwaitpid()\nwrite()\nwritev()\n"

#. type: Plain text
#: man-pages/man7/pthreads.7:327
msgid ""
"The following functions may be cancellation points according to POSIX.1-2001"
" and/or POSIX.1-2008:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:555
#, no-wrap
msgid ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [Added in POSIX.1-2008]\n"
"chown() [Added in POSIX.1-2008]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [Added in POSIX.1-2008]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [Added in POSIX.1-2008]\n"
"fchmod() [Added in POSIX.1-2008]\n"
"fchmodat() [Added in POSIX.1-2008]\n"
"fchown() [Added in POSIX.1-2008]\n"
"fchownat() [Added in POSIX.1-2008]\n"
"fclose()\n"
"fcntl() (for any value of cmd argument)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [Added in POSIX.1-2008]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [Added in POSIX.1-2008]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [Added in POSIX.1-2008]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"gethostbyname() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [Added in POSIX.1-2008]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (if opterr is nonzero)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [Added in POSIX.1-2008]\n"
"lio_listio() [Added in POSIX.1-2008]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [Added in POSIX.1-2008]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [Added in POSIX.1-2008]\n"
"mkdirat() [Added in POSIX.1-2008]\n"
"mkdtemp() [Added in POSIX.1-2008]\n"
"mkfifo() [Added in POSIX.1-2008]\n"
"mkfifoat() [Added in POSIX.1-2008]\n"
"mknod() [Added in POSIX.1-2008]\n"
"mknodat() [Added in POSIX.1-2008]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [Added in POSIX.1-2008]\n"
"psignal() [Added in POSIX.1-2008]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [Added in POSIX.1-2008]\n"
"readlinkat() [Added in POSIX.1-2008]\n"
"remove()\n"
"rename()\n"
"renameat() [Added in POSIX.1-2008]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [Added in POSIX.1-2008]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [Added in POSIX.1-2008]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [Added in POSIX.1-2008]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [Added in POSIX.1-2008]\n"
"utime() [Added in POSIX.1-2008]\n"
"utimensat() [Added in POSIX.1-2008]\n"
"utimes() [Added in POSIX.1-2008]\n"
"vdprintf() [Added in POSIX.1-2008]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"
msgstr ""

#.  So, scanning "cancellation point" comments in the glibc 2.8 header
#.  files, it looks as though at least the following nonstandard
#.  functions are cancellation points:
#.  endnetgrent
#.  endspent
#.  epoll_pwait
#.  epoll_wait
#.  fcloseall
#.  fdopendir
#.  fflush_unlocked
#.  fgetc_unlocked
#.  fgetgrent
#.  fgetgrent_r
#.  fgetpwent
#.  fgetpwent_r
#.  fgets_unlocked
#.  fgetspent
#.  fgetspent_r
#.  fgetwc_unlocked
#.  fgetws_unlocked
#.  fputc_unlocked
#.  fputs_unlocked
#.  fputwc_unlocked
#.  fputws_unlocked
#.  fread_unlocked
#.  fwrite_unlocked
#.  gai_suspend
#.  getaddrinfo_a
#.  getdate_r
#.  getgrent_r
#.  getgrouplist
#.  gethostbyaddr_r
#.  gethostbyname2
#.  gethostbyname2_r
#.  gethostbyname_r
#.  gethostent_r
#.  getnetbyaddr_r
#.  getnetbyname_r
#.  getnetent_r
#.  getnetgrent
#.  getnetgrent_r
#.  getprotobyname_r
#.  getprotobynumber_r
#.  getprotoent_r
#.  getpw
#.  getpwent_r
#.  getservbyname_r
#.  getservbyport_r
#.  getservent_r
#.  getspent
#.  getspent_r
#.  getspnam
#.  getspnam_r
#.  getutmp
#.  getutmpx
#.  getw
#.  getwc_unlocked
#.  getwchar_unlocked
#.  initgroups
#.  innetgr
#.  mkostemp
#.  mkostemp64
#.  mkstemp64
#.  ppoll
#.  pthread_timedjoin_np
#.  putgrent
#.  putpwent
#.  putspent
#.  putw
#.  putwc_unlocked
#.  putwchar_unlocked
#.  rcmd
#.  rcmd_af
#.  rexec
#.  rexec_af
#.  rresvport
#.  rresvport_af
#.  ruserok
#.  ruserok_af
#.  setnetgrent
#.  setspent
#.  sgetspent
#.  sgetspent_r
#.  updwtmpx
#.  utmpxname
#.  vfscanf
#.  vfwscanf
#.  vscanf
#.  vsyslog
#.  vwscanf
#. type: Plain text
#: man-pages/man7/pthreads.7:653
msgid ""
"An implementation may also mark other functions not specified in the "
"standard as cancellation points.  In particular, an implementation is likely"
" to mark any nonstandard function that may block as a cancellation point.  "
"(This includes most functions that can touch files.)"
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:653
#, no-wrap
msgid "Compiling on Linux"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:656
msgid ""
"On Linux, programs that use the Pthreads API should be compiled using I<cc "
"-pthread>."
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:656
#, no-wrap
msgid "Linux implementations of POSIX threads"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:659
msgid ""
"Over time, two threading implementations have been provided by the GNU C "
"library on Linux:"
msgstr ""

#. type: TP
#: man-pages/man7/pthreads.7:659
#, no-wrap
msgid "B<LinuxThreads>"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:663
msgid ""
"This is the original Pthreads implementation.  Since glibc 2.4, this "
"implementation is no longer supported."
msgstr ""

#. type: TP
#: man-pages/man7/pthreads.7:663
#, no-wrap
msgid "B<NPTL> (Native POSIX Threads Library)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:671
msgid ""
"This is the modern Pthreads implementation.  By comparison with "
"LinuxThreads, NPTL provides closer conformance to the requirements of the "
"POSIX.1 specification and better performance when creating large numbers of "
"threads.  NPTL is available since glibc 2.3.2, and requires features that "
"are present in the Linux 2.6 kernel."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:681
msgid ""
"Both of these are so-called 1:1 implementations, meaning that each thread "
"maps to a kernel scheduling entity.  Both threading implementations employ "
"the Linux B<clone>(2)  system call.  In NPTL, thread synchronization "
"primitives (mutexes, thread joining, and so on) are implemented using the "
"Linux B<futex>(2)  system call."
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:681
#, no-wrap
msgid "LinuxThreads"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:683
msgid "The notable features of this implementation are the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:690
msgid ""
"In addition to the main (initial) thread, and the threads that the program "
"creates using B<pthread_create>(3), the implementation creates a \"manager\""
" thread.  This thread handles thread creation and termination.  (Problems "
"can result if this thread is inadvertently killed.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:702
msgid ""
"Signals are used internally by the implementation.  On Linux 2.2 and later, "
"the first three real-time signals are used (see also B<signal>(7)).  On "
"older Linux kernels, B<SIGUSR1> and B<SIGUSR2> are used.  Applications must "
"avoid the use of whichever set of signals is employed by the implementation."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:709
msgid ""
"Threads do not share process IDs.  (In effect, LinuxThreads threads are "
"implemented as processes which share more information than usual, but which "
"do not share a common process ID.)  LinuxThreads threads (including the "
"manager thread)  are visible as separate processes using B<ps>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:712
msgid ""
"The LinuxThreads implementation deviates from the POSIX.1 specification in a"
" number of ways, including the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:716
msgid "Calls to B<getpid>(2)  return a different value in each thread."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:725
msgid ""
"Calls to B<getppid>(2)  in threads other than the main thread return the "
"process ID of the manager thread; instead B<getppid>(2)  in these threads "
"should return the same value as B<getppid>(2)  in the main thread."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:735
msgid ""
"When one thread creates a new child process using B<fork>(2), any thread "
"should be able to B<wait>(2)  on the child.  However, the implementation "
"only allows the thread that created the child to B<wait>(2)  on it."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:742
msgid ""
"When a thread calls B<execve>(2), all other threads are terminated (as "
"required by POSIX.1).  However, the resulting process has the same PID as "
"the thread that called B<execve>(2): it should have the same PID as the main"
" thread."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:749
msgid ""
"Threads do not share user and group IDs.  This can cause complications with "
"set-user-ID programs and can cause failures in Pthreads functions if an "
"application changes its credentials using B<seteuid>(2)  or similar."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:751
msgid "Threads do not share a common session ID and process group ID."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:754
msgid "Threads do not share record locks created using B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:760
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:763
msgid "Threads do not share semaphore undo values (see B<semop>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:765
msgid "Threads do not share interval timers."
msgstr ""

#.  FIXME . bug report filed for NPTL nice nonconformance
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6258
#.  Sep 08: there is a patch by Denys Vlasenko to address this
#.  "make setpriority POSIX compliant; introduce PRIO_THREAD extension"
#.  Monitor this to see if it makes it into mainline.
#. type: Plain text
#: man-pages/man7/pthreads.7:767 man-pages/man7/pthreads.7:804
msgid "Threads do not share a common nice value."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:777
msgid ""
"POSIX.1 distinguishes the notions of signals that are directed to the "
"process as a whole and signals that are directed to individual threads.  "
"According to POSIX.1, a process-directed signal (sent using B<kill>(2), for "
"example) should be handled by a single, arbitrarily selected thread within "
"the process.  LinuxThreads does not support the notion of process-directed "
"signals: signals may be sent only to specific threads."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:786
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack.  "
"(A new thread should start with no alternate signal stack defined.  If two "
"threads handle signals on their shared alternate signal stack at the same "
"time, unpredictable program failures are likely to occur.)"
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:786
#, no-wrap
msgid "NPTL"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:795
msgid ""
"With NPTL, all of the threads in a process are placed in the same thread "
"group; all members of a thread group share the same PID.  NPTL does not "
"employ a manager thread.  NPTL makes internal use of the first two real-time"
" signals (see also B<signal>(7)); these signals cannot be used in "
"applications."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:797
msgid "NPTL still has at least one nonconformance with POSIX.1:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:806
msgid "Some NPTL nonconformances occur only with older kernels:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:812
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide (fixed in kernel 2.6.9)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:814
msgid "Threads do not share resource limits (fixed in kernel 2.6.10)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:816
msgid "Threads do not share interval timers (fixed in kernel 2.6.12)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:820
msgid ""
"Only the main thread is permitted to start a new session using B<setsid>(2)"
"  (fixed in kernel 2.6.16)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:825
msgid ""
"Only the main thread is permitted to make the process into a process group "
"leader using B<setpgid>(2)  (fixed in kernel 2.6.16)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:831
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack "
"(fixed in kernel 2.6.16)."
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:833
msgid "Note the following further points about the NPTL implementation:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:847
msgid ""
"If the stack size soft resource limit (see the description of "
"B<RLIMIT_STACK> in B<setrlimit>(2))  is set to a value other than "
"I<unlimited>, then this value defines the default stack size for new "
"threads.  To be effective, this limit must be set before the program is "
"executed, perhaps using the I<ulimit -s> shell built-in command (I<limit "
"stacksize> in the C shell)."
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:847
#, no-wrap
msgid "Determining the threading implementation"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:852
msgid ""
"Since glibc 2.3.2, the B<getconf>(1)  command can be used to determine the "
"system's threading implementation, for example:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:857
#, no-wrap
msgid ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:862
msgid ""
"With older glibc versions, a command such as the following should be "
"sufficient to determine the default threading implementation:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:868
#, no-wrap
msgid ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|nptl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"
msgstr ""

#. type: SS
#: man-pages/man7/pthreads.7:870
#, no-wrap
msgid "Selecting the threading implementation: LD_ASSUME_KERNEL"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:885
msgid ""
"On systems with a glibc that supports both LinuxThreads and NPTL (i.e., "
"glibc 2.3.I<x>), the B<LD_ASSUME_KERNEL> environment variable can be used to"
" override the dynamic linker's default choice of threading implementation.  "
"This variable tells the dynamic linker to assume that it is running on top "
"of a particular kernel version.  By specifying a kernel version that does "
"not provide the support required by NPTL, we can force the use of "
"LinuxThreads.  (The most likely reason for doing this is to run a (broken) "
"application that depends on some nonconformant behavior in LinuxThreads.)  "
"For example:"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:891
#, no-wrap
msgid ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|ntpl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:903
msgid ""
"B<clone>(2), B<futex>(2), B<gettid>(2), B<proc>(5), B<futex>(7), "
"B<sigevent>(7), B<signal>(7),"
msgstr ""

#. type: Plain text
#: man-pages/man7/pthreads.7:926
msgid ""
"Various Pthreads manual pages, for example: B<pthread_attr_init>(3), "
"B<pthread_atfork>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<pthread_once>(3), "
"B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3), "
"and B<pthread_testcancel>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/process_vm_readv.2:29
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr ""

#. type: TH
#: man-pages/man2/process_vm_readv.2:29
#, no-wrap
msgid "2014-05-05"
msgstr "2014-05-05"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:32
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:35
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:42
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:49
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:54
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:58
msgid "B<process_vm_readv>(), B<process_vm_write>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:62
msgid "B<_GNU_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:73
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:98
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:112
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:122
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:129
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:145
msgid ""
"Buffers are processed in array order.  This means that B<process_vm_readv>()"
"  completely fills I<local_iov[0]> before proceeding to I<local_iov[1]>, and"
" so on.  Likewise, I<remote_iov[0]> is completely read before proceeding to "
"I<remote_iov[1]>, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:156
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:164
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:168
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr ""

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: man-pages/man2/process_vm_readv.2:181
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less"
" than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible"
" via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:191
msgid ""
"The count arguments and I<local_iov> are checked before doing any transfers."
"  If the counts are too big, or I<local_iov> is invalid, or the addresses "
"refer to regions that are inaccessible to the local process, none of the "
"vectors will be processed and an error will be returned immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:211
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep"
" this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4KiB) in a single remote I<iovec> element."
"  (Instead, split the remote read into two I<remote_iov> elements and have "
"them merge back into a single write I<local_iov> entry.  The first read "
"entry goes up to the page boundary, while the second starts on the next page"
" boundary.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:225
msgid ""
"In order to read from or write to another process, either the caller must "
"have the capability B<CAP_SYS_PTRACE>, or the real user ID, effective user "
"ID, and saved set-user-ID of the remote process must match the real user ID "
"of the caller I<and> the real group ID, effective group ID, and saved set-"
"group-ID of the remote process must match the real group ID of the caller.  "
"(The permission required is exactly the same as that required to perform a "
"B<ptrace>(2)  B<PTRACE_ATTACH> on the remote process.)"
msgstr ""

#. type: SH
#: man-pages/man2/process_vm_readv.2:225
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:241
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that"
" splits a single I<iovec> element.)  The caller should check the return "
"value to determine whether a partial read/write occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:245
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:257
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:261
msgid "I<flags> is not 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:267
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:272
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:278
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""

#. type: TP
#: man-pages/man2/process_vm_readv.2:278
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:283
msgid ""
"Could not allocate memory for internal copies of the I<iovec> structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:287
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""

#. type: TP
#: man-pages/man2/process_vm_readv.2:287
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:292
msgid "No process with ID I<pid> exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:295
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""

#. type: SH
#: man-pages/man2/process_vm_readv.2:295
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:297
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:303
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: man-pages/man2/process_vm_readv.2:311
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or"
" pipes)."
msgstr ""

#. type: SH
#: man-pages/man2/process_vm_readv.2:311
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:319
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It"
" reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:322
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:332
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:339
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[1].iov_len = 20;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:346
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:349
msgid "B<readv>(2), B<writev>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/poll.2:31
#, no-wrap
msgid "POLL"
msgstr "POLL"

#. type: Plain text
#: man-pages/man2/poll.2:34
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr "poll, ppoll - ожидает некоторое событие над файловым дескриптором"

#. type: Plain text
#: man-pages/man2/poll.2:37
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr "B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/poll.2:39
#, no-wrap
msgid ""
"B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int "
">I<timeout>B<);>\n"
msgstr "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/poll.2:43
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\nB<#include E<lt>signal.hE<gt>>\nB<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/poll.2:46
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<timeout_ts>B<, const sigset_t *>I<sigmask>B<);>\n"
msgstr "B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\nB<        const struct timespec *>I<timeout_ts>B<, const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/poll.2:53
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O."
msgstr "Вызов B<poll>() выполняет сходную с B<select>(2) задачу: он ждёт пока один дескриптор из набора файловых дескрипторов не станет готов выполнить операцию ввода-вывода."

#. type: Plain text
#: man-pages/man2/poll.2:57
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr "Отслеживаемый набор файловых дескрипторов задаётся в аргументе I<fds>, который представляет собой массив структур:"

#. type: Plain text
#: man-pages/man2/poll.2:65
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr "struct pollfd {\n    int   fd;         /* файловый дескриптор */\n    short events;     /* запрашиваемые события */\n    short revents;    /* возвращённые события */\n};\n"

#. type: Plain text
#: man-pages/man2/poll.2:72
msgid ""
"The caller should specify the number of items in the I<fds> array in "
"I<nfds>."
msgstr "Вызывающий должен указать количество элементов в массиве I<fds> в аргументе I<nfds>."

#. type: Plain text
#: man-pages/man2/poll.2:88
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> field."
"  Note, however, that this technique can't be used to ignore file descriptor"
" 0.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:103
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned"
" in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr "Поле I<events> представляет собой входной параметр — битовую маску, указывающую на события, происходящие с файловым дескриптором I<fd>, которые важны для приложения. Если это поле равно нулю, то возвращаемыми событиями в I<revents> могут быть B<POLLHUP>, B<POLLERR> и B<POLLNVAL> (смотрите ниже)."

#. type: Plain text
#: man-pages/man2/poll.2:122
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr "Поле I<revents> представляет собой параметр-результат, в который ядро помещает информацию о произошедших событиях. В I<revents> могут содержаться любые битовые флаги из задаваемых в I<events>, или там может быть одно из значений: B<POLLERR>, B<POLLHUP> или B<POLLNVAL>. Эти три битовых флага не имеют смысла в поле I<events>, но будут установлены в поле I<revents>, если соответствующее условие истинно."

#. type: Plain text
#: man-pages/man2/poll.2:127
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr "Если ни одно из запрошенных событий с файловыми дескрипторами не произошло или не возникло ошибок, то B<poll>() блокируется до их появления."

#. type: Plain text
#: man-pages/man2/poll.2:134
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()"
"  should block waiting for a file descriptor to become ready.  The call will"
" block until either:"
msgstr "В аргументе I<timeout> указывается количество миллисекунд, на которые будет блокироваться B<poll>() в ожидании готовности файлового дескриптора. Вызов будет заблокирован пока:"

#. type: IP
#: man-pages/man2/poll.2:134 man-pages/man2/poll.2:136
#: man-pages/man2/poll.2:138
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man2/poll.2:136
msgid "a file descriptor becomes ready;"
msgstr "файловый дескриптор не станет готов;"

#. type: Plain text
#: man-pages/man2/poll.2:138
msgid "the call is interrupted by a signal handler; or"
msgstr "вызов не прервётся обработчиком сигнала;"

#. type: Plain text
#: man-pages/man2/poll.2:140
msgid "the timeout expires."
msgstr "не истечёт время ожидания."

#. type: Plain text
#: man-pages/man2/poll.2:154
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes B<poll>()"
"  to return immediately, even if no file descriptors are ready."
msgstr "Заметим, что интервал I<timeout> будет округлён с точностью системных часов, а из-за задержки при планировании в ядре блокирующий интервал будет немного больше. Отрицательное значение в I<timeout> означает бесконечное ожидание. Значение I<timeout>, равное нулю, приводит к немедленному завершению B<poll>(), даже если ни один файловый дескриптор не готов."

#. type: Plain text
#: man-pages/man2/poll.2:160
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in"
" I<E<lt>poll.hE<gt>>:"
msgstr "Вот возможные биты, описанные в I<E<lt>poll.hE<gt>>, которые могут быть установлены/получены в I<events> и I<revents>:"

#. type: TP
#: man-pages/man2/poll.2:161
#, no-wrap
msgid "B<POLLIN>"
msgstr "B<POLLIN>"

#. type: Plain text
#: man-pages/man2/poll.2:164
msgid "There is data to read."
msgstr "Есть данные для чтения."

#. type: TP
#: man-pages/man2/poll.2:164
#, no-wrap
msgid "B<POLLPRI>"
msgstr "B<POLLPRI>"

#. type: Plain text
#: man-pages/man2/poll.2:168
msgid ""
"There is urgent data to read (e.g., out-of-band data on TCP socket; "
"pseudoterminal master in packet mode has seen state change in slave)."
msgstr "Есть срочные данные для чтения (например, внеполосные данные в сокете TCP; мастер псевдотерминала в пакетном режиме увидел изменение состояния подчинённого терминала)."

#. type: TP
#: man-pages/man2/poll.2:168
#, no-wrap
msgid "B<POLLOUT>"
msgstr "B<POLLOUT>"

#. type: Plain text
#: man-pages/man2/poll.2:171
msgid "Writing now will not block."
msgstr "Теперь запись не приведёт к блокировке."

#. type: TP
#: man-pages/man2/poll.2:171
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr "B<POLLRDHUP> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man2/poll.2:182
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr "Удалённая сторона потокового сокета закрыла соединение, или отключила запись в одну сторону. Для использования данного определения должен быть определён макрос тестирования свойств B<_GNU_SOURCE> (до включения I<каких-либо> заголовочных файлов)."

#. type: TP
#: man-pages/man2/poll.2:182
#, no-wrap
msgid "B<POLLERR>"
msgstr "B<POLLERR>"

#. type: Plain text
#: man-pages/man2/poll.2:185
msgid "Error condition (output only)."
msgstr "Состояние ошибки (указывается только как результат)."

#. type: TP
#: man-pages/man2/poll.2:185
#, no-wrap
msgid "B<POLLHUP>"
msgstr "B<POLLHUP>"

#. type: Plain text
#: man-pages/man2/poll.2:188
msgid "Hang up (output only)."
msgstr "Повесили трубку (hang up) (указывается только как результат)."

#. type: TP
#: man-pages/man2/poll.2:188
#, no-wrap
msgid "B<POLLNVAL>"
msgstr "B<POLLNVAL>"

#. type: Plain text
#: man-pages/man2/poll.2:193
msgid "Invalid request: I<fd> not open (output only)."
msgstr "Неверный запрос: дескриптор I<fd> не открыт (указывается только как результат)."

#. type: Plain text
#: man-pages/man2/poll.2:199
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr "При компилировании с установленным B<_XOPEN_SOURCE> также определены следующие значения, которые не передают дополнительной информации вне упомянутых выше битов:"

#. type: TP
#: man-pages/man2/poll.2:200
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr "B<POLLRDNORM>"

#. type: Plain text
#: man-pages/man2/poll.2:204
msgid "Equivalent to B<POLLIN>."
msgstr "Эквивалентно B<POLLIN>."

#. type: TP
#: man-pages/man2/poll.2:204
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr "B<POLLRDBAND>"

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: man-pages/man2/poll.2:208
msgid "Priority band data can be read (generally unused on Linux)."
msgstr "Доступны для чтения приоритетные внутриполосные данные (в Linux, обычно, не используется)."

#. type: TP
#: man-pages/man2/poll.2:208
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr "B<POLLWRNORM>"

#. type: Plain text
#: man-pages/man2/poll.2:212
msgid "Equivalent to B<POLLOUT>."
msgstr "Эквивалентно B<POLLOUT>."

#. type: TP
#: man-pages/man2/poll.2:212
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr "B<POLLWRBAND>"

#. type: Plain text
#: man-pages/man2/poll.2:215
msgid "Priority data may be written."
msgstr "Можно писать приоритетные данные."

#. type: Plain text
#: man-pages/man2/poll.2:219
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr "В Linux также есть B<POLLMSG>, но он не используется."

#. type: SS
#: man-pages/man2/poll.2:219
#, no-wrap
msgid "ppoll()"
msgstr "ppoll()"

#. type: Plain text
#: man-pages/man2/poll.2:233
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr "Отношения между B<poll>() и B<ppoll>() аналогичны родству B<select>(2) и B<pselect>(2): как B<pselect>(2), B<ppoll>() позволяет приложению безопасно ждать, пока файловый дескриптор не станет готов или пока не будет получен сигнал."

#. type: Plain text
#: man-pages/man2/poll.2:239
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr "Кроме различия в точности аргумента I<timeout> вызов B<ppoll>()"

#. type: Plain text
#: man-pages/man2/poll.2:242
#, no-wrap
msgid "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"
msgstr "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"

#. type: Plain text
#: man-pages/man2/poll.2:247
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "эквивалентен I<атомарному> выполнению следующих вызовов:"

#. type: Plain text
#: man-pages/man2/poll.2:251
#, no-wrap
msgid ""
"    sigset_t origmask;\n"
"    int timeout;\n"
msgstr "    sigset_t origmask;\n    int timeout;\n"

#. type: Plain text
#: man-pages/man2/poll.2:257
#, no-wrap
msgid ""
"    timeout = (timeout_ts == NULL) ? -1 :\n"
"              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n"
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = poll(&fds, nfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr "    timeout = (timeout_ts == NULL) ? -1 :\n              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n    ready = poll(&fds, nfds, timeout);\n    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: man-pages/man2/poll.2:264
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr "Смотрите в B<pselect>(2) пояснения о необходимости B<ppoll>()."

#. type: Plain text
#: man-pages/man2/poll.2:276
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only"
" in the precision of the I<timeout> argument)."
msgstr "Если значение аргумента I<sigmask> равно NULL, то изменение маски сигналов не происходит (и поэтому B<ppoll>() отличается от B<poll>() только в точности аргумента I<timeout>)."

#. type: Plain text
#: man-pages/man2/poll.2:283
msgid ""
"The I<timeout_ts> argument specifies an upper limit on the amount of time "
"that B<ppoll>()  will block.  This argument is a pointer to a structure of "
"the following form:"
msgstr "В аргументе I<timeout_ts> указывается верхняя граница промежутка времени, на который будет заблокирован B<ppoll>(). Этот аргумент представляет собой указатель на структуру следующего вида:"

#. type: Plain text
#: man-pages/man2/poll.2:290
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr "struct timespec {\n    long    tv_sec;         /* секунды */\n    long    tv_nsec;        /* наносекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/poll.2:298
msgid ""
"If I<timeout_ts> is specified as NULL, then B<ppoll>()  can block "
"indefinitely."
msgstr "Если значение I<timeout_ts> равно NULL, то B<ppoll>() может оставаться заблокированным бесконечно."

#. type: Plain text
#: man-pages/man2/poll.2:308
msgid ""
"On success, a positive number is returned; this is the number of structures "
"which have nonzero I<revents> fields (in other words, those descriptors with"
" events or errors reported).  A value of 0 indicates that the call timed out"
" and no file descriptors were ready.  On error, -1 is returned, and I<errno>"
" is set appropriately."
msgstr "При успешном выполнении возвращается положительное значение; оно означает количество структур, в которых поля I<revents> имеют ненулевое значение (другими словами, тех дескрипторов, для которых возникли события или ошибки). Значение 0 означает, что время ожидания истекло, и нет готовых файловых дескрипторов. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/poll.2:313
msgid ""
"The array given as argument was not contained in the calling program's "
"address space."
msgstr "Указанный аргументом массив содержится вне адресного пространства вызывающей программы."

#. type: TP
#: man-pages/man2/poll.2:313
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/poll.2:317
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr "Получен сигнал раньше какого-либо запрашиваемого события; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/poll.2:324
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr "Значение I<nfds> превышает значение B<RLIMIT_NOFILE>."

#. type: Plain text
#: man-pages/man2/poll.2:327
msgid "There was no space to allocate file descriptor tables."
msgstr "Нет места под таблицы файловых дескрипторов."

#.  library call was introduced in libc 5.4.28
#. type: Plain text
#: man-pages/man2/poll.2:337
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels"
" that lack this system call, the glibc (and the old Linux libc)  B<poll>()  "
"wrapper function provides emulation using B<select>(2)."
msgstr "Системный вызов B<poll>() появился в Linux 2.1.23. Для старых ядер, в которых этот вызов отсутствует, glibc (и старая Linux libc) предоставляет обёрточную функцию B<poll>(), которая эмулируется с помощью B<select>(2)."

#. type: Plain text
#: man-pages/man2/poll.2:344
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr "Системный вызов B<ppoll>() был добавлен в ядро Linux в версии 2.6.16. Библиотечный вызов B<ppoll>() был добавлен в glibc 2.4."

#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: man-pages/man2/poll.2:350
msgid "B<poll>()  conforms to POSIX.1-2001.  B<ppoll>()  is Linux-specific."
msgstr "Вызов B<poll>() соответствует POSIX.1-2001. Вызов B<ppoll>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/poll.2:358
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr "В некоторых реализациях определена нестандартная константа B<INFTIM> со значением -1 для использования в качестве значения I<timeout> в B<poll>(). Эта константа отсутствует в glibc."

#. type: Plain text
#: man-pages/man2/poll.2:363
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr "Обсуждение того, что может случиться, если файловый дескриптор отслеживается B<poll>() и при этом закрывается в другой нити, смотрите в B<select>(2)."

#. type: SS
#: man-pages/man2/poll.2:363
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#. type: Plain text
#: man-pages/man2/poll.2:377
msgid ""
"The Linux B<ppoll>()  system call modifies its I<timeout_ts> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<ppoll>()  function does not modify its I<timeout_ts> argument."
msgstr "В Linux системный вызов B<ppoll>() изменяет свой аргумент I<timeout_ts>. Однако, обёрточная функция glibc скрывает это поведение с помощью локальной переменной для аргумента timeout, которая передаётся в системный вызов. Поэтому glibc функция B<ppoll>() не изменяет свой аргумент I<timeout_ts>."

#. type: Plain text
#: man-pages/man2/poll.2:381
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr "Смотрите описание ложных уведомлений о готовности в разделе ДЕФЕКТЫ справочной страницы B<select>(2)."

#. type: Plain text
#: man-pages/man2/poll.2:385
msgid "B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<time>(7)"
msgstr "B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<time>(7)"

#. type: TH
#: man-pages/man2/pivot_root.2:10
#, no-wrap
msgid "PIVOT_ROOT"
msgstr "PIVOT_ROOT"

#. type: TH
#: man-pages/man2/pivot_root.2:10
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: Plain text
#: man-pages/man2/pivot_root.2:13
msgid "pivot_root - change the root filesystem"
msgstr "pivot_root - изменяет корневую файловую систему"

#. type: Plain text
#: man-pages/man2/pivot_root.2:15
msgid ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr "B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"

#. type: Plain text
#: man-pages/man2/pivot_root.2:18
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr "I<Замечание>:В glibc нет обёрточной функции для данного системного вызова; смотрите ЗАМЕЧАНИЯ."

#.  The
#.  .B CAP_SYS_ADMIN
#.  capability is required.
#. type: Plain text
#: man-pages/man2/pivot_root.2:27
msgid ""
"B<pivot_root>()  moves the root filesystem of the calling process to the "
"directory I<put_old> and makes I<new_root> the new root filesystem of the "
"calling process."
msgstr "Вызов B<pivot_root>() перемещает корневую систему вызывающего процесса в каталог I<put_old> и делает каталог I<new_root> новой корневой файловой системой у вызывающего процесса."

#. type: Plain text
#: man-pages/man2/pivot_root.2:34
msgid ""
"The typical use of B<pivot_root>()  is during system startup, when the "
"system mounts a temporary root filesystem (e.g., an B<initrd>), then mounts "
"the real root filesystem, and eventually turns the latter into the current "
"root of all relevant processes or threads."
msgstr "Обычно, B<pivot_root>() используется при загрузке, когда система монтирует временную корневую файловую систему (например, B<initrd>), а затем монтирует настоящую корневую файловую систему, делая, тем самым, её корневой для всех последующих процессов или нитей."

#. type: Plain text
#: man-pages/man2/pivot_root.2:46
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current"
" working directory to I<new_root> before invoking B<pivot_root>()."
msgstr "Вызов B<pivot_root>() может изменить (или не изменить) текущий корневой и текущий рабочий каталоги во всех процессах или нитях, использующих старый корневой каталог. Вызывающий B<pivot_root>() должен быть уверен в том, что процессы у которых корневой или текущий рабочий каталог равен старому корневому каталогу, работают нормально в каждом случае. Самый простой способ достичь этого — сменить их корневой и текущий рабочий каталог на I<new_root> до вызова B<pivot_root>()."

#. type: Plain text
#: man-pages/man2/pivot_root.2:64
msgid ""
"The paragraph above is intentionally vague because the implementation of "
"B<pivot_root>()  may change in the future.  At the time of writing, "
"B<pivot_root>()  changes root and current working directory of each process "
"or thread to I<new_root> if they point to the old root directory.  This is "
"necessary in order to prevent kernel threads from keeping the old root "
"directory busy with their root and current working directory, even if they "
"never access the filesystem in any way.  In the future, there may be a "
"mechanism for kernel threads to explicitly relinquish any access to the "
"filesystem, such that this fairly intrusive mechanism can be removed from "
"B<pivot_root>()."
msgstr "Содержимое предыдущего абзаца, на самом деле, является не совсем определённым, потому что реализация B<pivot_root>() может измениться в будущем. На момент написания этого документа B<pivot_root>() изменяет корневой и текущий рабочий каталоги каждого процесса или нити на I<new_root>, если они указывают на старый корневой каталог. Это необходимо для того, чтобы нити ядра не занимали старый корневой и текущий рабочий каталог, даже если они вообще не обращались к файловой системе. В будущем, возможно, будет создан механизм, заставляющий нити ядра отказаться от доступа к файловой системе, что позволит удалить этот довольно навязчивый механизм из B<pivot_root>()."

#. type: Plain text
#: man-pages/man2/pivot_root.2:72
msgid ""
"Note that this also applies to the calling process: B<pivot_root>()  may or "
"may not affect its current working directory.  It is therefore recommended "
"to call B<chdir(\"/\")> immediately after B<pivot_root>()."
msgstr "Заметим, что всё это относится и к вызывающему процессу: B<pivot_root>() может изменить (а может и не изменить) его текущий рабочий каталог. По этой причине рекомендуется вызывать B<chdir(\"/\")> сразу после вызова B<pivot_root>()."

#. type: Plain text
#: man-pages/man2/pivot_root.2:74
msgid "The following restrictions apply to I<new_root> and I<put_old>:"
msgstr "На значения I<new_root> и I<put_old> накладываются следующие ограничения:"

#. type: Plain text
#: man-pages/man2/pivot_root.2:76
msgid "They must be directories."
msgstr "Они должны быть каталогами."

#. type: Plain text
#: man-pages/man2/pivot_root.2:79
msgid ""
"I<new_root> and I<put_old> must not be on the same filesystem as the current"
" root."
msgstr "Аргументы I<new_root> и I<put_old> не могут быть в одной файловой системе с текущим корневым каталогом."

#. type: Plain text
#: man-pages/man2/pivot_root.2:83
msgid ""
"I<put_old> must be underneath I<new_root>, that is, adding a nonzero number "
"of I</..> to the string pointed to by I<put_old> must yield the same "
"directory as I<new_root>."
msgstr "Аргумент I<put_old> должен быть в дереве каталогов I<new_root>, т.е., путём добавления ненулевого количества I</..> в строке, на которую указывает I<put_old>, можно получить каталог, равный I<new_root>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:85
msgid "No other filesystem may be mounted on I<put_old>."
msgstr "К I<put_old> не должны быть подмонтированы файловые системы."

#. type: Plain text
#: man-pages/man2/pivot_root.2:89
msgid "See also B<pivot_root>(8)  for additional usage examples."
msgstr "См. также страницу B<pivot_root>(8), в которой приведены примеры возможного использования."

#. type: Plain text
#: man-pages/man2/pivot_root.2:96
msgid ""
"If the current root is not a mount point (e.g., after B<chroot>(2)  or "
"B<pivot_root>(), see also below), not the old root directory, but the mount "
"point of that filesystem is mounted on I<put_old>."
msgstr "Если текущий корневой каталог не является точкой монтирования (например, после B<chroot>(2) или B<pivot_root>(), см. ниже), то к I<put_old> подключается не старый корневой каталог, а точка монтирования этой файловой системы."

#. type: Plain text
#: man-pages/man2/pivot_root.2:101
msgid ""
"I<new_root> does not have to be a mount point.  In this case, "
"I</proc/mounts> will show the mount point of the filesystem containing "
"I<new_root> as root (I</>)."
msgstr "Аргумент I<new_root> может и не быть точкой монтирования. В этом случае в I</proc/mounts> будет указана точка монтирования файловой системы, содержащей новый I<new_root> как корневой каталог (I</>)."

#. type: Plain text
#: man-pages/man2/pivot_root.2:105
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/pivot_root.2:110
msgid ""
"B<pivot_root>()  may return (in I<errno>) any of the errors returned by "
"B<stat>(2).  Additionally, it may return:"
msgstr "Вызов B<pivot_root>() может возвращать (в I<errno>) любые ошибки, которые возвращаются B<stat>(2). Также он может вернуть:"

#. type: TP
#: man-pages/man2/pivot_root.2:110
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/pivot_root.2:114
msgid ""
"I<new_root> or I<put_old> are on the current root filesystem, or a "
"filesystem is already mounted on I<put_old>."
msgstr "Аргумент I<new_root> или I<put_old> находится в текущей корневой файловой системе, или какая-то файловая система уже смонтирована в I<put_old>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:117
msgid "I<put_old> is not underneath I<new_root>."
msgstr "Аргумент I<put_old> не находится в дереве каталогов I<new_root>."

#. type: TP
#: man-pages/man2/pivot_root.2:117
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/pivot_root.2:120
msgid "I<new_root> or I<put_old> is not a directory."
msgstr "Аргумент I<new_root> или I<put_old> не является каталогом."

#. type: Plain text
#: man-pages/man2/pivot_root.2:125
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr "Вызывающий процесс не имеет мандата B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:128
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr "Вызов B<pivot_root>() появился в Linux 2.3.41."

#. type: Plain text
#: man-pages/man2/pivot_root.2:131
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr "Вызов B<pivot_root>() есть только в Linux и поэтому его использование не переносимо."

#. type: Plain text
#: man-pages/man2/pivot_root.2:134
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr "В glibc нет обёртки для данного системного вызова; запускайте его с помощью B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/pivot_root.2:138
msgid ""
"B<pivot_root>()  should not have to change root and current working "
"directory of all other processes in the system."
msgstr "Вызов B<pivot_root>() не должен изменять корневой и рабочий каталоги других процессов в системе."

#. type: Plain text
#: man-pages/man2/pivot_root.2:143
msgid ""
"Some of the more obscure uses of B<pivot_root>()  may quickly lead to "
"insanity."
msgstr "Некорректное использование B<pivot_root>() может привести к непредсказуемым последствиям."

#. type: Plain text
#: man-pages/man2/pivot_root.2:148
msgid "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"
msgstr "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"

#. type: TH
#: man-pages/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr "PAUSE"

#. type: TH
#: man-pages/man2/pause.2:30
#, no-wrap
msgid "2008-10-06"
msgstr "2008-10-06"

#. type: Plain text
#: man-pages/man2/pause.2:33
msgid "pause - wait for signal"
msgstr "pause - ждать сигнала"

#. type: Plain text
#: man-pages/man2/pause.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr "B<int pause(void);>"

#. type: Plain text
#: man-pages/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr "B<pause>() заставляет вызвавший процесс (или нить) уснуть до тех пор, пока не поступит сигнал, который или завершит процесс, или приведёт к запуску функции, обрабатывающей сигнал."

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: man-pages/man2/pause.2:53
msgid ""
"B<pause>()  returns only when a signal was caught and the signal-catching "
"function returned.  In this case, B<pause>()  returns -1, and I<errno> is "
"set to B<EINTR>."
msgstr "B<pause>() возвращает значение, только когда был пойман сигнал и завершилась функция его обработки. В этом случае B<pause>() возвращает -1, а I<errno> устанавливается равной B<EINTR>."

#. type: Plain text
#: man-pages/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr "пойман сигнал и завершилась функция его обработки."

#. type: Plain text
#: man-pages/man2/pause.2:59
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/pause.2:63
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"

#. type: Plain text
#: man-pages/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr "pipe, pipe2 - создаёт канал"

#. type: Plain text
#: man-pages/man2/pipe.2:42
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:44
#, no-wrap
msgid "B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr "B<int pipe(int >I<pipefd>B<[2]);>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:48
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\nB<#include E<lt>fcntl.hE<gt>>              /* Определение констант O_* */\nB<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:50
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:66
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the pipe."
"  Data written to the write end of the pipe is buffered by the kernel until "
"it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr "B<pipe>() создаёт однонаправленный канал данных, который можно использовать для взаимодействия между процессами. Массив I<pipefd> используется для возврата двух файловых описателей, указывающих на концы канала. I<pipefd[0]> указывает на конец канала для чтения. I<pipefd[1]> указывает на конец канала для записи. Данные, записанные в конец канала, буферизируются ядром до тех пор, пока не будут прочитаны из конца канала для чтения. Подробней см. B<pipe>(7)."

#. type: Plain text
#: man-pages/man2/pipe.2:76
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr "Если I<flags> равно 0, то B<pipe2>() выполняет то же что и B<pipe>(). Следующие значения могут быть побитово сложены в I<flags> для получения различного поведения:"

#. type: TP
#: man-pages/man2/pipe.2:76
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/pipe.2:84
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file descriptors."
"  See the description of the same flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr "Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для двух новых открытых файловых дескрипторов. Смотрите описание того же флага в B<open>(2) для того, чтобы узнать как это может пригодиться."

#. type: TP
#: man-pages/man2/pipe.2:84
#, no-wrap
msgid "B<O_DIRECT> (since Linux 3.4)"
msgstr "B<O_DIRECT> (начиная с Linux 3.4)"

#.  commit 9883035ae7edef3ec62ad215611cb8e17d6a1a5d
#. type: Plain text
#: man-pages/man2/pipe.2:94
msgid ""
"Create a pipe that performs I/O in \"packet\" mode.  Each B<write>(2)  to "
"the pipe is dealt with as a separate packet, and B<read>(2)s from the pipe "
"will read one packet at a time.  Note the following points:"
msgstr "Создаёт канал, в котором ввод-вывод выполняется в «пакетном» режиме. Каждый B<write>(2) в канал рассматривается как отдельный пакет, а B<read>(2) из канала читает один пакет за раз. Заметим следующее:"

#. type: Plain text
#: man-pages/man2/pipe.2:105
msgid ""
"Writes of greater than B<PIPE_BUF> bytes (see B<pipe>(7))  will be split "
"into multiple packets.  The constant B<PIPE_BUF> is defined in "
"I<E<lt>limits.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:115
msgid ""
"If a B<read>(2)  specifies a buffer size that is smaller than the next "
"packet, then the requested number of bytes are read, and the excess bytes in"
" the packet are discarded.  Specifying a buffer size of B<PIPE_BUF> will be "
"sufficient to read the largest possible packets (see the previous point)."
msgstr "Если в B<read>(2) указан размер буфера меньше чем следующий пакет, то читается запрашиваемое количество байт, а лишние байты пакета отбрасываются. Указание B<PIPE_BUF> в качестве размера буфера будет достаточно для чтения самых больших пакетов (смотрите предыдущее примечание)."

#. type: Plain text
#: man-pages/man2/pipe.2:120
msgid ""
"Zero-length packets are not supported.  (A B<read>(2)  that specifies a "
"buffer size of zero is a no-op, and returns 0.)"
msgstr "Пакеты нулевой длины не поддерживаются (вызов B<read>(2) с нулевым размером буфера ничего не делает и возвращает 0)."

#. type: Plain text
#: man-pages/man2/pipe.2:125
msgid ""
"Older kernels that do not support this flag will indicate this via an "
"B<EINVAL> error."
msgstr "Старые ядра, которые не поддерживают этот флаг, возвращают ошибку B<EINVAL>."

#. type: TP
#: man-pages/man2/pipe.2:125
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/pipe.2:133
msgid ""
"Set the B<O_NONBLOCK> file status flag on the two new open file "
"descriptions.  Using this flag saves extra calls to B<fcntl>(2)  to achieve "
"the same result."
msgstr "Устанавливает флаг состояния файла B<O_NONBLOCK> для двух новых открытых файловых дескрипторов. Использование данного флага заменяет дополнительные вызовы B<fcntl>(2) для достижения того же результата."

#. type: Plain text
#: man-pages/man2/pipe.2:143
msgid "I<pipefd> is not valid."
msgstr "I<pipefd> задан некорректно."

#. type: Plain text
#: man-pages/man2/pipe.2:148
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr "(B<pipe2>())  Некорректное значение I<flags>."

#. type: TP
#: man-pages/man2/pipe.2:148
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/pipe.2:151
msgid "Too many file descriptors are in use by the process."
msgstr "Процесс открыл слишком много файловых дескрипторов."

#. type: TP
#: man-pages/man2/pipe.2:151
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man2/pipe.2:154
msgid "The system limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: Plain text
#: man-pages/man2/pipe.2:159
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available"
" starting with version 2.9."
msgstr "Вызов B<pipe2>() был добавлен в Linux начиная с версии 2.6.27; поддержка в glibc появилась начиная с версии 2.9."

#. type: Plain text
#: man-pages/man2/pipe.2:162
msgid "B<pipe>(): POSIX.1-2001."
msgstr "B<pipe>(): POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/pipe.2:165
msgid "B<pipe2>()  is Linux-specific."
msgstr "Вызов B<pipe2>() есть только в Linux."

#.  fork.2 refers to this example program.
#. type: Plain text
#: man-pages/man2/pipe.2:181
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child"
" process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the descriptors"
" that it doesn't need for the pipe (see B<pipe>(7)).  The parent then writes"
" the string contained in the program's command-line argument to the pipe, "
"and the child reads this string a byte at a time from the pipe and echoes it"
" on standard output."
msgstr "Следующая программа создаёт канал, и затем выполняет B<fork>(2) для создания потомка; потомок наследует скопированный набор файловых дескрипторов, которые указывают на тот же канал. После B<fork>(2) каждый процесс закрывает дескрипторы, которые ненужны каналу (см. B<pipe>(7)). Затем родитель записывает строку, переданную в качестве аргумента командной строки, в канал, а потомок читает эту строку из канала по байту за раз, и выводит её на стандартный вывод."

#. type: SS
#: man-pages/man2/pipe.2:181
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/pipe.2:189
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/wait.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:196
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int pipefd[2];\n    pid_t cpid;\n    char buf;\n"

#. type: Plain text
#: man-pages/man2/pipe.2:201
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>stringE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/pipe.2:206
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/pipe.2:212
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    cpid = fork();\n    if (cpid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/pipe.2:215
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr "    if (cpid == 0) {    /* Потомок читает из канала */\n        close(pipefd[1]);          /* Закрывает неиспользуемый конец для записи */\n"

#. type: Plain text
#: man-pages/man2/pipe.2:218
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr "        while (read(pipefd[0], &buf, 1) E<gt> 0)\n            write(STDOUT_FILENO, &buf, 1);\n"

#. type: Plain text
#: man-pages/man2/pipe.2:222
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr "        write(STDOUT_FILENO, \"\\en\", 1);\n        close(pipefd[0]);\n        _exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/pipe.2:231
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr "    } else {            /* Родитель пишет значение argv[1] в канал */\n        close(pipefd[0]);          /* Закрывает неиспользуемый конец для чтения */\n        write(pipefd[1], argv[1], strlen(argv[1]));\n        close(pipefd[1]);          /* Читатель видит EOF */\n        wait(NULL);                /* Ожидание потомка */\n        exit(EXIT_SUCCESS);\n    }\n}\n"

#. type: Plain text
#: man-pages/man2/pipe.2:238
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<write>(2), B<popen>(3), "
"B<pipe>(7)"
msgstr "B<fork>(2), B<read>(2), B<socketpair>(2), B<write>(2), B<popen>(3), B<pipe>(7)"

#. type: TH
#: man-pages/man2/perfmonctl.2:27
#, no-wrap
msgid "PERFMONCTL"
msgstr "PERFMONCTL"

#. type: TH
#: man-pages/man2/perfmonctl.2:27
#, no-wrap
msgid "2013-02-13"
msgstr "2013-02-13"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:30
msgid "perfmonctl - interface to IA-64 performance monitoring unit"
msgstr "perfmonctl - интерфейс к perfomance monitoring unit IA-64"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"
msgstr "B<#include E<lt>syscall.hE<gt>>\nB<#include E<lt>perfmon.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:36
#, no-wrap
msgid ""
"B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int "
">I<narg>B<);>\n"
msgstr "B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int >I<narg>B<);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:47
msgid ""
"The IA-64-specific B<perfmonctl>()  system call provides an interface to the"
" PMU (performance monitoring unit).  The PMU consists of PMD (performance "
"monitoring data) registers and PMC (performance monitoring control) "
"registers, which gather hardware statistics."
msgstr "Специфичный для IA-64 системный вызов B<perfmonctl>() предоставляет интерфейс к PMU (perfomance monitoring unit). PMU содержит регистры PMD (performance monitoring data) и PMC (performance monitoring control), которые собирают статистику аппаратного обеспечения."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:57
msgid ""
"B<perfmonctl>()  applies the operation I<cmd> to the input arguments "
"specified by I<arg>.  The number of arguments is defined by I<narg>.  The "
"I<fd> argument specifies the perfmon context to operate on."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:61
msgid "Supported values for I<cmd> are:"
msgstr "Поддерживаемые значения I<cmd>:"

#. type: TP
#: man-pages/man2/perfmonctl.2:61
#, no-wrap
msgid "B<PFM_CREATE_CONTEXT>"
msgstr "B<PFM_CREATE_CONTEXT>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:65
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, "
"1);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, 1);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:67
msgid "Set up a context."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:74
msgid ""
"The I<fd> parameter is ignored.  A new perfmon context is created as "
"specified in I<ctxt> and its file descriptor is returned in "
"I<ctxt-E<gt>ctx_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:86
msgid ""
"The file descriptor can be used in subsequent calls to B<perfmonctl>()  and "
"can be used to read event notifications (type I<pfm_msg_t>)  using "
"B<read>(2).  The file descriptor is pollable using B<select>(2), B<poll>(2),"
" and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:90
msgid ""
"The context can be destroyed by calling B<close>(2)  on the file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:90
#, no-wrap
msgid "B<PFM_WRITE_PMCS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:95
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:97
msgid "Set PMC registers."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:97
#, no-wrap
msgid "B<PFM_WRITE_PMDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:101
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#.  pfm_write_pmds()
#. type: Plain text
#: man-pages/man2/perfmonctl.2:104
msgid "Set PMD registers."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:104
#, no-wrap
msgid "B<PFM_READ_PMDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:109
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:111
msgid "Read PMD registers."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:111
#, no-wrap
msgid "B<PFM_START>"
msgstr ""

#.  .BI  "perfmonctl(int " fd ", PFM_START, arg, 1);
#. type: Plain text
#: man-pages/man2/perfmonctl.2:117
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:119
msgid "Start monitoring."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:119
#, no-wrap
msgid "B<PFM_STOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:124
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:126
msgid "Stop monitoring."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:126
#, no-wrap
msgid "B<PFM_LOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:131
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:133
msgid "Attach the context to a thread."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:133
#, no-wrap
msgid "B<PFM_UNLOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:138
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:140
msgid "Detach the context from a thread."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:140
#, no-wrap
msgid "B<PFM_RESTART>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:145
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:147
msgid "Restart monitoring after receiving an overflow notification."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:147
#, no-wrap
msgid "B<PFM_GET_FEATURES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:152
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_FEARURES, pfarg_features_t *>I<arg>B<, "
"1);>\n"
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:153
#, no-wrap
msgid "B<PFM_DEBUG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:158
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:162
msgid "If I<val> is nonzero, enable debugging mode, otherwise disable."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:162
#, no-wrap
msgid "B<PFM_GET_PMC_RESET_VAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:167
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t * >I<req>B<, "
"n);>\n"
msgstr ""

#.  .TP
#.  .B PFM_CREATE_EVTSETS
#.  create or modify event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_CREATE_EVTSETS, pfarg_setdesc_t *desc ,
#. n);
#.  .fi
#.  .TP
#.  .B PFM_DELETE_EVTSETS
#.  delete event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_DELETE_EVTSET, pfarg_setdesc_t *desc ,
#. n);
#.  .fi
#.  .TP
#.  .B PFM_GETINFO_EVTSETS
#.  get information about event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_GETINFO_EVTSETS, pfarg_setinfo_t *info,
#. n);
#.  .fi
#. type: Plain text
#: man-pages/man2/perfmonctl.2:190
msgid "Reset PMC registers to default values."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:196
msgid ""
"B<perfmonctl>()  returns zero when the operation is successful.  On error, "
"-1 is returned and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:199
msgid "B<perfmonctl>()  is available since Linux 2.4."
msgstr "B<perfmonctl>() доступна в Linux начиная с 2.4."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:202
msgid ""
"B<perfmonctl>()  is Linux-specific and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:207
msgid "B<gprof>(1)"
msgstr "B<gprof>(1)"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:208
msgid "The perfmon2 interface specification"
msgstr ""

#. type: TH
#: man-pages/man2/pciconfig_read.2:8
#, no-wrap
msgid "PCICONFIG_READ"
msgstr "PCICONFIG_READ"

#. type: TH
#: man-pages/man2/pciconfig_read.2:8
#, no-wrap
msgid "2003-07-14"
msgstr "2003-07-14"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:11
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr "pciconfig_read, pciconfig_write, pciconfig_iobase - работа с информацией устройства PCI"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:14
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr "B<#include E<lt>pci.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:21
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr "B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\nB<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\nB<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\nB<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\nB<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\nB<          unsigned long >I<devfn>B<);>\n"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:27
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from"
" user space."
msgstr "Всё взаимодействие с устройствами PCI, в основном, уже выполнено в ядре на уровне PCI, и поэтому данные вызовы, обычно, ненужны при вызове из пользовательского пространства."

#. type: TP
#: man-pages/man2/pciconfig_read.2:27 man-pages/man2/pciconfig_read.2:51
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr "B<pciconfig_read>()"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:36
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr "Выполняет чтение в буфер I<buf> из устройства I<dev> со смещением I<off>."

#. type: TP
#: man-pages/man2/pciconfig_read.2:36 man-pages/man2/pciconfig_read.2:57
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr "B<pciconfig_write>()"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:45
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr "Выполняет запись буфера I<buf> в устройство I<dev> со смещением I<off>."

#. type: TP
#: man-pages/man2/pciconfig_read.2:45 man-pages/man2/pciconfig_read.2:63
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr "B<pciconfig_iobase>()"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:50
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr "Принимает пару шина/функция_устройства и возвращает физический адрес или смещения в памяти (для таких вещей как prep, это 0xc0000000), базы ввода-вывода для циклов PIO, или промежутки (holes) ISA, если они есть."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:57 man-pages/man2/pciconfig_read.2:63
msgid ""
"On success zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr "При успешном выполнении возвращает 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:77
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr "Возвращает информацию о расположении различных областей ввода-вывода в физической памяти согласно значению I<which>. Значениями I<which> могут быть: B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, B<IOBASE_ISA_MEM>."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:84
msgid ""
"I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr "Неправильное значение I<len>. Не применимо к B<pciconfig_iobase>()."

#. type: TP
#: man-pages/man2/pciconfig_read.2:84
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:87
msgid "I/O error."
msgstr "Ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:93
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr "Для B<pciconfig_iobase>() значение «рукава (hose)» равно NULL. Для других вызовов не удаётся найти слот."

#. type: TP
#: man-pages/man2/pciconfig_read.2:93
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:98
msgid ""
"The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr "Данные вызовы в системе не реализованы (не определён макрос B<CONFIG_PCI>)."

#. type: TP
#: man-pages/man2/pciconfig_read.2:98
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:105
msgid ""
"This return value is valid only for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr "Данное значение верно только для B<pciconfig_iobase>(). Возвращается, если указано неверное значение I<which>."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:112
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr "Пользователь не имеет мандата B<CAP_SYS_ADMIN>. Не применимо к B<pciconfig_iobase>()."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:114
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr "Данные вызовы есть только в Linux, они доступны начиная с версии 2.0.26/2.1.11."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:115
msgid "B<capabilities>(7)"
msgstr "B<capabilities>(7)"

#. type: TH
#: man-pages/man2/perf_event_open.2:27
#, no-wrap
msgid "PERF_EVENT_OPEN"
msgstr "PERF_EVENT_OPEN"

#. type: TH
#: man-pages/man2/perf_event_open.2:27
#, no-wrap
msgid "2014-04-17"
msgstr "2014-04-17"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:30
msgid "perf_event_open - set up performance monitoring"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"
msgstr "B<#include E<lt>linux/perf_event.hE<gt>>\nB<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:38
#, no-wrap
msgid ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr "B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\nB<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\nB<                    unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:47
msgid ""
"Given a list of parameters, B<perf_event_open>()  returns a file descriptor,"
" for use in subsequent system calls (B<read>(2), B<mmap>(2), B<prctl>(2), "
"B<fcntl>(2), etc.)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:55
msgid ""
"A call to B<perf_event_open>()  creates a file descriptor that allows "
"measuring performance information.  Each file descriptor corresponds to one "
"event that is measured; these can be grouped together to measure multiple "
"events simultaneously."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:62
msgid ""
"Events can be enabled and disabled in two ways: via B<ioctl>(2)  and via "
"B<prctl>(2).  When an event is disabled it does not count or generate "
"overflows but does continue to exist and maintain its count value."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:76
msgid ""
"Events come in two flavors: counting and sampled.  A I<counting> event is "
"one that is used for counting the aggregate number of events that occur.  In"
" general, counting event results are gathered with a B<read>(2)  call.  A "
"I<sampling> event periodically writes measurements to a buffer that can then"
" be accessed via B<mmap>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:76
#, no-wrap
msgid "Arguments"
msgstr "Аргументы"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:83
msgid ""
"The I<pid> and I<cpu> arguments allow specifying which process and CPU to "
"monitor:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:83
#, no-wrap
msgid "B<pid == 0> and B<cpu == -1>"
msgstr "B<pid == 0> и B<cpu == -1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:86
msgid "This measures the calling process/thread on any CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:86
#, no-wrap
msgid "B<pid == 0> and B<cpu E<gt>= 0>"
msgstr "B<pid == 0> и B<cpu E<gt>= 0>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:90
msgid ""
"This measures the calling process/thread only when running on the specified "
"CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:90
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu == -1>"
msgstr "B<pid E<gt> 0> и B<cpu == -1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:93
msgid "This measures the specified process/thread on any CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:93
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu E<gt>= 0>"
msgstr "B<pid E<gt> 0> и B<cpu E<gt>= 0>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:97
msgid ""
"This measures the specified process/thread only when running on the "
"specified CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:97
#, no-wrap
msgid "B<pid == -1> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:105
msgid ""
"This measures all processes/threads on the specified CPU.  This requires "
"B<CAP_SYS_ADMIN> capability or a I</proc/sys/kernel/perf_event_paranoid> "
"value of less than 1."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:105
#, no-wrap
msgid "B<pid == -1> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:108
msgid "This setting is invalid and will return an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:130
msgid ""
"The I<group_fd> argument allows event groups to be created.  An event group "
"has one event which is the group leader.  The leader is created first, with "
"I<group_fd> = -1.  The rest of the group members are created with subsequent"
" B<perf_event_open>()  calls with I<group_fd> being set to the file "
"descriptor of the group leader.  (A single event on its own is created with "
"I<group_fd> = -1 and is considered to be a group with only 1 member.)  An "
"event group is scheduled onto the CPU as a unit: it will be put onto the CPU"
" only if all of the events in the group can be put onto the CPU.  This means"
" that the values of the member events can be meaningfully "
"compared\\(emadded, divided (to get ratios), and so on\\(emwith each other, "
"since they have counted events for the same set of executed instructions."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:134
msgid ""
"The I<flags> argument is formed by ORing together zero or more of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:134
#, no-wrap
msgid "B<PERF_FLAG_FD_CLOEXEC> (since Linux 3.14)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:150
msgid ""
"This flag enables the close-on-exec flag for the created event file "
"descriptor, so that the file descriptor is automatically closed on "
"B<execve>(2).  Setting the close-on-exec flags at creation time, rather than"
" later with B<fcntl>(2), avoids potential race conditions where the calling "
"thread invokes B<perf_event_open>()  and B<fcntl>(2)  at the same time as "
"another thread calls B<fork>(2)  then B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:150
#, no-wrap
msgid "B<PERF_FLAG_FD_NO_GROUP>"
msgstr ""

#.  FIXME The following sentence is unclear
#.  FIXME So, why is it useful?
#. type: Plain text
#: man-pages/man2/perf_event_open.2:157
msgid ""
"This flag allows creating an event as part of an event group but having no "
"group leader.  It is unclear why this is useful."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:157
#, no-wrap
msgid "B<PERF_FLAG_FD_OUTPUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:160
msgid "This flag reroutes the output from an event to the group leader."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:160
#, no-wrap
msgid "B<PERF_FLAG_PID_CGROUP> (since Linux 2.6.39)."
msgstr "B<PERF_FLAG_PID_CGROUP> (начиная с Linux 2.6.39)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:183
msgid ""
"This flag activates per-container system-wide monitoring.  A container is an"
" abstraction that isolates a set of resources for finer-grained control "
"(CPUs, memory, etc.).  In this mode, the event is measured only if the "
"thread running on the monitored CPU belongs to the designated container "
"(cgroup).  The cgroup is identified by passing a file descriptor opened on "
"its directory in the cgroupfs filesystem.  For instance, if the cgroup to "
"monitor is called I<test>, then a file descriptor opened on "
"I</dev/cgroup/test> (assuming cgroupfs is mounted on I</dev/cgroup>)  must "
"be passed as the I<pid> parameter.  cgroup monitoring is available only for "
"system-wide events and may therefore require extra permissions."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:188
msgid ""
"The I<perf_event_attr> structure provides detailed configuration information"
" for the event being created."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:195
#, no-wrap
msgid ""
"struct perf_event_attr {\n"
"    __u32 type;         /* Type of event */\n"
"    __u32 size;         /* Size of attribute structure */\n"
"    __u64 config;       /* Type-specific configuration */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:200
#, no-wrap
msgid ""
"    union {\n"
"        __u64 sample_period;    /* Period of sampling */\n"
"        __u64 sample_freq;      /* Frequency of sampling */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:203
#, no-wrap
msgid ""
"    __u64 sample_type;  /* Specifies values included in sample */\n"
"    __u64 read_format;  /* Specifies values returned in read */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:229
#, no-wrap
msgid ""
"    __u64 disabled       : 1,   /* off by default */\n"
"          inherit        : 1,   /* children inherit it */\n"
"          pinned         : 1,   /* must always be on PMU */\n"
"          exclusive      : 1,   /* only group on PMU */\n"
"          exclude_user   : 1,   /* don't count user */\n"
"          exclude_kernel : 1,   /* don't count kernel */\n"
"          exclude_hv     : 1,   /* don't count hypervisor */\n"
"          exclude_idle   : 1,   /* don't count when idle */\n"
"          mmap           : 1,   /* include mmap data */\n"
"          comm           : 1,   /* include comm data */\n"
"          freq           : 1,   /* use freq, not period */\n"
"          inherit_stat   : 1,   /* per task counts */\n"
"          enable_on_exec : 1,   /* next exec enables */\n"
"          task           : 1,   /* trace fork/exit */\n"
"          watermark      : 1,   /* wakeup_watermark */\n"
"          precise_ip     : 2,   /* skid constraint */\n"
"          mmap_data      : 1,   /* non-exec mmap data */\n"
"          sample_id_all  : 1,   /* sample_type all events */\n"
"          exclude_host   : 1,   /* don't count in host */\n"
"          exclude_guest  : 1,   /* don't count in guest */\n"
"          exclude_callchain_kernel : 1,\n"
"                                /* exclude kernel callchains */\n"
"          exclude_callchain_user   : 1,\n"
"                                /* exclude user callchains */\n"
"          __reserved_1   : 41;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:234
#, no-wrap
msgid ""
"    union {\n"
"        __u32 wakeup_events;    /* wakeup every n events */\n"
"        __u32 wakeup_watermark; /* bytes before wakeup */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:236
#, no-wrap
msgid "    __u32     bp_type;          /* breakpoint type */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:241
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_addr;          /* breakpoint address */\n"
"        __u64 config1;          /* extension of config */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:251
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_len;           /* breakpoint length */\n"
"        __u64 config2;          /* extension of config1 */\n"
"    };\n"
"    __u64 branch_sample_type;   /* enum perf_branch_sample_type */\n"
"    __u64 sample_regs_user;     /* user regs to dump on samples */\n"
"    __u32 sample_stack_user;    /* size of stack to dump on\n"
"                                   samples */\n"
"    __u32 __reserved_2;         /* Align to u64 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:253
#, no-wrap
msgid "};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:259
msgid ""
"The fields of the I<perf_event_attr> structure are described in more detail "
"below:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:259 man-pages/man2/perf_event_open.2:1556
#, no-wrap
msgid "I<type>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:263
msgid ""
"This field specifies the overall event type.  It has one of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:264
#, no-wrap
msgid "B<PERF_TYPE_HARDWARE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:271
msgid ""
"This indicates one of the \"generalized\" hardware events provided by the "
"kernel.  See the I<config> field definition for more details."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:271
#, no-wrap
msgid "B<PERF_TYPE_SOFTWARE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:275
msgid ""
"This indicates one of the software-defined events provided by the kernel "
"(even if no hardware support is available)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:275
#, no-wrap
msgid "B<PERF_TYPE_TRACEPOINT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:279
msgid ""
"This indicates a tracepoint provided by the kernel tracepoint "
"infrastructure."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:279
#, no-wrap
msgid "B<PERF_TYPE_HW_CACHE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:285
msgid ""
"This indicates a hardware cache event.  This has a special encoding, "
"described in the I<config> field definition."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:285
#, no-wrap
msgid "B<PERF_TYPE_RAW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:289
msgid ""
"This indicates a \"raw\" implementation-specific event in the I<config> "
"field."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:289
#, no-wrap
msgid "B<PERF_TYPE_BREAKPOINT> (since Linux 2.6.33)"
msgstr "B<PERF_TYPE_BREAKPOINT> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:294
msgid ""
"This indicates a hardware breakpoint as provided by the CPU.  Breakpoints "
"can be read/write accesses to an address as well as execution of an "
"instruction address."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:294
#, no-wrap
msgid "dynamic PMU"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:313
msgid ""
"Since Linux 2.6.39, B<perf_event_open>()  can support multiple PMUs.  To "
"enable this, a value exported by the kernel can be used in the I<type> field"
" to indicate which PMU to use.  The value to use can be found in the sysfs "
"filesystem: there is a subdirectory per PMU instance under "
"I</sys/bus/event_source/devices>.  In each subdirectory there is a I<type> "
"file whose content is an integer that can be used in the I<type> field.  For"
" instance, I</sys/bus/event_source/devices/cpu/type> contains the value for "
"the core CPU PMU, which is usually 4."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:314 man-pages/man2/perf_event_open.2:1504
#, no-wrap
msgid "I<size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:323
msgid ""
"The size of the I<perf_event_attr> structure for forward/backward "
"compatibility.  Set this using I<sizeof(struct perf_event_attr)> to allow "
"the kernel to see the struct size at the time of compilation."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:338
msgid ""
"The related define B<PERF_ATTR_SIZE_VER0> is set to 64; this was the size of"
" the first published struct.  B<PERF_ATTR_SIZE_VER1> is 72, corresponding to"
" the addition of breakpoints in Linux 2.6.33.  B<PERF_ATTR_SIZE_VER2> is 80 "
"corresponding to the addition of branch sampling in Linux 3.4.  "
"B<PERF_ATR_SIZE_VER3> is 96 corresponding to the addition of "
"I<sample_regs_user> and I<sample_stack_user> in Linux 3.7."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:338
#, no-wrap
msgid "I<config>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:349
msgid ""
"This specifies which event you want, in conjunction with the I<type> field."
"  The I<config1> and I<config2> fields are also taken into account in cases "
"where 64 bits is not enough to fully specify the event.  The encoding of "
"these fields are event dependent."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:355
msgid ""
"The most significant bit (bit 63) of I<config> signifies CPU-specific (raw) "
"counter configuration data; if the most significant bit is unset, the next 7"
" bits are an event type and the rest of the bits are the event identifier."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:366
msgid ""
"There are various ways to set the I<config> field that are dependent on the "
"value of the previously described I<type> field.  What follows are various "
"possible settings for I<config> separated out by I<type>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:376
msgid ""
"If I<type> is B<PERF_TYPE_HARDWARE>, we are measuring one of the generalized"
" hardware CPU events.  Not all of these are available on all platforms.  Set"
" I<config> to one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:377
#, no-wrap
msgid "B<PERF_COUNT_HW_CPU_CYCLES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:381
msgid "Total cycles.  Be wary of what happens during CPU frequency scaling."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:381
#, no-wrap
msgid "B<PERF_COUNT_HW_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:386
msgid ""
"Retired instructions.  Be careful, these can be affected by various issues, "
"most notably hardware interrupt counts."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:386
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_REFERENCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:393
msgid ""
"Cache accesses.  Usually this indicates Last Level Cache accesses but this "
"may vary depending on your CPU.  This may include prefetches and coherency "
"messages; again this depends on the design of your CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:393
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_MISSES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:400
msgid ""
"Cache misses.  Usually this indicates Last Level Cache misses; this is "
"intended to be used in conjunction with the "
"B<PERF_COUNT_HW_CACHE_REFERENCES> event to calculate cache miss rates."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:400
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:405
msgid ""
"Retired branch instructions.  Prior to Linux 2.6.34, this used the wrong "
"event on AMD processors."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:405
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_MISSES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:408
msgid "Mispredicted branch instructions."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:408
#, no-wrap
msgid "B<PERF_COUNT_HW_BUS_CYCLES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:411
msgid "Bus cycles, which can be different from total cycles."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:411
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (since Linux 3.0)"
msgstr "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:414
msgid "Stalled cycles during issue."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:414
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (since Linux 3.0)"
msgstr "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:417
msgid "Stalled cycles during retirement."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:417
#, no-wrap
msgid "B<PERF_COUNT_HW_REF_CPU_CYCLES> (since Linux 3.3)"
msgstr "B<PERF_COUNT_HW_REF_CPU_CYCLES> (начиная с Linux 3.3)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:420
msgid "Total cycles; not affected by CPU frequency scaling."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:430
msgid ""
"If I<type> is B<PERF_TYPE_SOFTWARE>, we are measuring software events "
"provided by the kernel.  Set I<config> to one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:431
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_CLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:434
msgid "This reports the CPU clock, a high-resolution per-CPU timer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:434
#, no-wrap
msgid "B<PERF_COUNT_SW_TASK_CLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:437
msgid "This reports a clock count specific to the task that is running."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:437
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:440
msgid "This reports the number of page faults."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:440
#, no-wrap
msgid "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:445
msgid ""
"This counts context switches.  Until Linux 2.6.34, these were all reported "
"as user-space events, after that they are reported as happening in the "
"kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:445
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_MIGRATIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:449
msgid ""
"This reports the number of times the process has migrated to a new CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:449
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:453
msgid ""
"This counts the number of minor page faults.  These did not require disk I/O"
" to handle."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:453
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:457
msgid ""
"This counts the number of major page faults.  These required disk I/O to "
"handle."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:457
#, no-wrap
msgid "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (since Linux 2.6.33)"
msgstr "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:463
msgid ""
"This counts the number of alignment faults.  These happen when unaligned "
"memory accesses happen; the kernel can handle these but it reduces "
"performance.  This happens only on some architectures (never on x86)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:463
#, no-wrap
msgid "B<PERF_COUNT_SW_EMULATION_FAULTS> (since Linux 2.6.33)"
msgstr "B<PERF_COUNT_SW_EMULATION_FAULTS> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:469
msgid ""
"This counts the number of emulation faults.  The kernel sometimes traps on "
"unimplemented instructions and emulates them for user space.  This can "
"negatively impact performance."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:469
#, no-wrap
msgid "B<PERF_COUNT_SW_DUMMY> (since Linux 3.12)"
msgstr "B<PERF_COUNT_SW_DUMMY> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:476
msgid ""
"This is a placeholder event that counts nothing.  Informational sample "
"record types such as mmap or comm must be associated with an active event.  "
"This dummy event allows gathering such records without requiring a counting "
"event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:489
msgid ""
"If I<type> is B<PERF_TYPE_TRACEPOINT>, then we are measuring kernel "
"tracepoints.  The value to use in I<config> can be obtained from under "
"debugfs I<tracing/events/*/*/id> if ftrace is enabled in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:500
msgid ""
"If I<type> is B<PERF_TYPE_HW_CACHE>, then we are measuring a hardware CPU "
"cache event.  To calculate the appropriate I<config> value use the following"
" equation:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:505
#, no-wrap
msgid ""
"    (perf_hw_cache_id) | (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"    (perf_hw_cache_op_result_id E<lt>E<lt> 16)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:510
msgid "where I<perf_hw_cache_id> is one of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:511
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1D>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:514
msgid "for measuring Level 1 Data Cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:514
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1I>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:517
msgid "for measuring Level 1 Instruction Cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:517
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_LL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:520
msgid "for measuring Last-Level Cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:520
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_DTLB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:523
msgid "for measuring the Data TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:523
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_ITLB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:526
msgid "for measuring the Instruction TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:526
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_BPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:529
msgid "for measuring the branch prediction unit"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:529
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_NODE> (since Linux 3.0)"
msgstr "B<PERF_COUNT_HW_CACHE_NODE> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:532
msgid "for measuring local memory accesses"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:537
msgid "and I<perf_hw_cache_op_id> is one of"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:538
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:541
msgid "for read accesses"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:541
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:544
msgid "for write accesses"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:544
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:547
msgid "for prefetch accesses"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:552
msgid "and I<perf_hw_cache_op_result_id> is one of"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:553
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:556
msgid "to measure accesses"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:556
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:559
msgid "to measure misses"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:577
msgid ""
"If I<type> is B<PERF_TYPE_RAW>, then a custom \"raw\" I<config> value is "
"needed.  Most CPUs support events that are not covered by the "
"\"generalized\" events.  These are implementation defined; see your CPU "
"manual (for example the Intel Volume 3B documentation or the AMD BIOS and "
"Kernel Developer Guide).  The libpfm4 library can be used to translate from "
"the name in the architectural manuals to the raw hex value "
"B<perf_event_open>()  expects in this field."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:586
msgid ""
"If I<type> is B<PERF_TYPE_BREAKPOINT>, then leave I<config> set to zero.  "
"Its parameters are set in other places."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:587
#, no-wrap
msgid "I<sample_period>, I<sample_freq>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:599
msgid ""
"A \"sampling\" counter is one that generates an interrupt every N events, "
"where N is given by I<sample_period>.  A sampling counter has "
"I<sample_period> E<gt> 0.  When an overflow interrupt occurs, requested data"
" is recorded in the mmap buffer.  The I<sample_type> field controls what "
"data is recorded on each interrupt."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:609
msgid ""
"I<sample_freq> can be used if you wish to use frequency rather than period."
"  In this case, you set the I<freq> flag.  The kernel will adjust the "
"sampling period to try and achieve the desired rate.  The rate of adjustment"
" is a timer tick."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:609
#, no-wrap
msgid "I<sample_type>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:621
msgid ""
"The various bits in this field specify which values to include in the "
"sample.  They will be recorded in a ring-buffer, which is available to user "
"space using B<mmap>(2).  The order in which the values are saved in the "
"sample are documented in the MMAP Layout subsection below; it is not the "
"I<enum perf_event_sample_format> order."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:622
#, no-wrap
msgid "B<PERF_SAMPLE_IP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:625
msgid "Records instruction pointer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:625
#, no-wrap
msgid "B<PERF_SAMPLE_TID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:628
msgid "Records the process and thread IDs."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:628
#, no-wrap
msgid "B<PERF_SAMPLE_TIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:631
msgid "Records a timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:631
#, no-wrap
msgid "B<PERF_SAMPLE_ADDR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:634
msgid "Records an address, if applicable."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:634
#, no-wrap
msgid "B<PERF_SAMPLE_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:637
msgid ""
"Record counter values for all events in a group, not just the group leader."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:637
#, no-wrap
msgid "B<PERF_SAMPLE_CALLCHAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:640
msgid "Records the callchain (stack backtrace)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:640
#, no-wrap
msgid "B<PERF_SAMPLE_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:643
msgid "Records a unique ID for the opened event's group leader."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:643
#, no-wrap
msgid "B<PERF_SAMPLE_CPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:646
msgid "Records CPU number."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:646
#, no-wrap
msgid "B<PERF_SAMPLE_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:649
msgid "Records the current sampling period."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:649
#, no-wrap
msgid "B<PERF_SAMPLE_STREAM_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:657
msgid ""
"Records a unique ID for the opened event.  Unlike B<PERF_SAMPLE_ID> the "
"actual ID is returned, not the group leader.  This ID is the same as the one"
" returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:657
#, no-wrap
msgid "B<PERF_SAMPLE_RAW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:661
msgid ""
"Records additional data, if applicable.  Usually returned by tracepoint "
"events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:661
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_STACK> (since Linux 3.4)"
msgstr "B<PERF_SAMPLE_BRANCH_STACK> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:666
msgid ""
"This provides a record of recent branches, as provided by CPU branch "
"sampling hardware (such as Intel Last Branch Record).  Not all hardware "
"supports this feature."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:670
msgid ""
"See the I<branch_sample_type> field for how to filter which branches are "
"reported."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:670
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_USER> (since Linux 3.7)"
msgstr "B<PERF_SAMPLE_REGS_USER> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:674
msgid ""
"Records the current user-level CPU register state (the values in the process"
" before the kernel was called)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:674
#, no-wrap
msgid "B<PERF_SAMPLE_STACK_USER> (since Linux 3.7)"
msgstr "B<PERF_SAMPLE_STACK_USER> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:677
msgid "Records the user level stack, allowing stack unwinding."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:677
#, no-wrap
msgid "B<PERF_SAMPLE_WEIGHT> (since Linux 3.10)"
msgstr "B<PERF_SAMPLE_WEIGHT> (начиная с Linux 3.10)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:683
msgid ""
"Records a hardware provided weight value that expresses how costly the "
"sampled event was.  This allows the hardware to highlight expensive events "
"in a profile."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:683
#, no-wrap
msgid "B<PERF_SAMPLE_DATA_SRC> (since Linux 3.10)"
msgstr "B<PERF_SAMPLE_DATA_SRC> (начиная с Linux 3.10)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:689
msgid ""
"Records the data source: where in the memory hierarchy the data associated "
"with the sampled instruction came from.  This is only available if the "
"underlying hardware supports this feature."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:689
#, no-wrap
msgid "B<PERF_SAMPLE_IDENTIFIER> (since Linux 3.12)"
msgstr "B<PERF_SAMPLE_IDENTIFIER> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:696
msgid ""
"Places the B<SAMPLE_ID> value in a fixed position in the record, either at "
"the beginning (for sample events) or at the end (if a non-sample event)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:708
msgid ""
"This was necessary because a sample stream may have records from various "
"different event sources with different I<sample_type> settings.  Parsing the"
" event stream properly was not possible because the format of the record was"
" needed to find B<SAMPLE_ID>, but the format could not be found without "
"knowing what event the sample belonged to (causing a circular dependency)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:718
msgid ""
"This new B<PERF_SAMPLE_IDENTIFIER> setting makes the event stream always "
"parsable by putting B<SAMPLE_ID> in a fixed location, even though it means "
"having duplicate B<SAMPLE_ID> values in records."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:718
#, no-wrap
msgid "B<PERF_SAMPLE_TRANSACTION> (Since Linux 3.13)"
msgstr "B<PERF_SAMPLE_TRANSACTION> (начиная с Linux 3.13)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:722
msgid ""
"Records reasons for transactional memory abort events (for example, from "
"Intel TSX transactional memory support)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:730
msgid ""
"The I<precise_ip> setting must be greater than 0 and a transactional memory "
"abort event must be measured or no values will be recorded.  Also note that "
"some perf_event measurements, such as sampled cycle counting, may cause "
"extraneous aborts (by causing an interrupt during a transaction)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:731
#, no-wrap
msgid "I<read_format>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:738
msgid ""
"This field specifies the format of the data returned by B<read>(2)  on a "
"B<perf_event_open>()  file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:739
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:746
msgid ""
"Adds the 64-bit I<time_enabled> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:746
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:753
msgid ""
"Adds the 64-bit I<time_running> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:753
#, no-wrap
msgid "B<PERF_FORMAT_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:756
msgid "Adds a 64-bit unique value that corresponds to the event group."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:756
#, no-wrap
msgid "B<PERF_FORMAT_GROUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:759
msgid "Allows all counter values in an event group to be read with one read."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:760
#, no-wrap
msgid "I<disabled>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:770
msgid ""
"The I<disabled> bit specifies whether the counter starts out disabled or "
"enabled.  If disabled, the event can later be enabled by B<ioctl>(2), "
"B<prctl>(2), or I<enable_on_exec>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:781
msgid ""
"When creating an event group, typically the group leader is initialized with"
" I<disabled> set to 1 and any child events are initialized with I<disabled> "
"set to 0.  Despite I<disabled> being 0, the child events will not start "
"until the group leader is enabled."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:781
#, no-wrap
msgid "I<inherit>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:790
msgid ""
"The I<inherit> bit specifies that this counter should count events of child "
"tasks as well as the task specified.  This applies only to new children, not"
" to any existing children at the time the counter is created (nor to any new"
" children of existing children)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:795
msgid ""
"Inherit does not work for some combinations of I<read_format>s, such as "
"B<PERF_FORMAT_GROUP>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:795
#, no-wrap
msgid "I<pinned>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:808
msgid ""
"The I<pinned> bit specifies that the counter should always be on the CPU if "
"at all possible.  It applies only to hardware counters and only to group "
"leaders.  If a pinned counter cannot be put onto the CPU (e.g., because "
"there are not enough hardware counters or because of a conflict with some "
"other event), then the counter goes into an 'error' state, where reads "
"return end-of-file (i.e., B<read>(2)  returns 0) until the counter is "
"subsequently enabled or disabled."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:808
#, no-wrap
msgid "I<exclusive>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:817
msgid ""
"The I<exclusive> bit specifies that when this counter's group is on the CPU,"
" it should be the only group using the CPU's counters.  In the future this "
"may allow monitoring programs to support PMU features that need to run alone"
" so that they do not disrupt other hardware counters."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:824
msgid ""
"Note that many unexpected situations may prevent events with the "
"I<exclusive> bit set from ever running.  This includes any users running a "
"system-wide measurement as well as any kernel use of the performance "
"counters (including the commonly enabled NMI Watchdog Timer interface)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:824
#, no-wrap
msgid "I<exclude_user>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:827
msgid ""
"If this bit is set, the count excludes events that happen in user space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:827
#, no-wrap
msgid "I<exclude_kernel>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:830
msgid ""
"If this bit is set, the count excludes events that happen in kernel-space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:830
#, no-wrap
msgid "I<exclude_hv>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:838
msgid ""
"If this bit is set, the count excludes events that happen in the hypervisor."
"  This is mainly for PMUs that have built-in support for handling this (such"
" as POWER).  Extra support is needed for handling hypervisor measurements on"
" most machines."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:838
#, no-wrap
msgid "I<exclude_idle>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:841
msgid "If set, don't count when the CPU is idle."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:841
#, no-wrap
msgid "I<mmap>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:855
msgid ""
"The I<mmap> bit enables generation of B<PERF_RECORD_MMAP> samples for every "
"B<mmap>(2)  call that has B<PROT_EXEC> set.  This allows tools to notice new"
" executable code being mapped into a program (dynamic shared libraries for "
"example)  so that addresses can be mapped back to the original code."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:855
#, no-wrap
msgid "I<comm>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:866
msgid ""
"The I<comm> bit enables tracking of process command name as modified by the "
"B<exec>(2)  and B<prctl>(PR_SET_NAME)  system calls.  Unfortunately for "
"tools, there is no way to distinguish one system call versus the other."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:866
#, no-wrap
msgid "I<freq>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:873
msgid ""
"If this bit is set, then I<sample_frequency> not I<sample_period> is used "
"when setting up the sampling interval."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:873
#, no-wrap
msgid "I<inherit_stat>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:880
msgid ""
"This bit enables saving of event counts on context switch for inherited "
"tasks.  This is meaningful only if the I<inherit> field is set."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:880
#, no-wrap
msgid "I<enable_on_exec>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:885
msgid ""
"If this bit is set, a counter is automatically enabled after a call to "
"B<exec>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:885
#, no-wrap
msgid "I<task>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:889
msgid ""
"If this bit is set, then fork/exit notifications are included in the ring "
"buffer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:889
#, no-wrap
msgid "I<watermark>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:897
msgid ""
"If set, have a sampling interrupt happen when we cross the "
"I<wakeup_watermark> boundary.  Otherwise, interrupts happen after "
"I<wakeup_events> samples."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:897
#, no-wrap
msgid "I<precise_ip> (since Linux 2.6.35)"
msgstr "I<precise_ip> (начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:907
msgid ""
"This controls the amount of skid.  Skid is how many instructions execute "
"between an event of interest happening and the kernel being able to stop and"
" record the event.  Smaller skid is better and allows more accurate "
"reporting of which events correspond to which instructions, but hardware is "
"often limited with how small this can be."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:909
msgid "The values of this are the following:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:910
#, no-wrap
msgid "0 -"
msgstr "0 -"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:914
msgid "B<SAMPLE_IP> can have arbitrary skid."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:914
#, no-wrap
msgid "1 -"
msgstr "1 -"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:918
msgid "B<SAMPLE_IP> must have constant skid."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:918
#, no-wrap
msgid "2 -"
msgstr "2 -"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:922
msgid "B<SAMPLE_IP> requested to have 0 skid."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:922
#, no-wrap
msgid "3 -"
msgstr "3 -"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:928
msgid "B<SAMPLE_IP> must have 0 skid.  See also B<PERF_RECORD_MISC_EXACT_IP>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:929
#, no-wrap
msgid "I<mmap_data> (since Linux 2.6.36)"
msgstr "I<mmap_data> (начиная с Linux 2.6.36)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:941
msgid ""
"The counterpart of the I<mmap> field.  This enables generation of "
"B<PERF_RECORD_MMAP> samples for B<mmap>(2)  calls that do not have "
"B<PROT_EXEC> set (for example data and SysV shared memory)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:941
#, no-wrap
msgid "I<sample_id_all> (since Linux 2.6.38)"
msgstr "I<sample_id_all> (начиная с Linux 2.6.38)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:949
msgid ""
"If set, then TID, TIME, ID, STREAM_ID, and CPU can additionally be included "
"in non-B<PERF_RECORD_SAMPLE>s if the corresponding I<sample_type> is "
"selected."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:957
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is specified, then an additional ID value is "
"included as the last value to ease parsing the record stream.  This may lead"
" to the I<id> value appearing twice."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:959
msgid "The layout is described by this pseudo-structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:969
#, no-wrap
msgid ""
"struct sample_id {\n"
"    { u32 pid, tid; } /* if PERF_SAMPLE_TID set        */\n"
"    { u64 time;     } /* if PERF_SAMPLE_TIME set       */\n"
"    { u64 id;       } /* if PERF_SAMPLE_ID set         */\n"
"    { u64 stream_id;} /* if PERF_SAMPLE_STREAM_ID set  */\n"
"    { u32 cpu, res; } /* if PERF_SAMPLE_CPU set        */\n"
"    { u64 id;       } /* if PERF_SAMPLE_IDENTIFIER set */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:970
#, no-wrap
msgid "I<exclude_host> (since Linux 3.2)"
msgstr "I<exclude_host> (начиная с Linux 3.2)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:973
msgid "Do not measure time spent in VM host."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:973
#, no-wrap
msgid "I<exclude_guest> (since Linux 3.2)"
msgstr "I<exclude_guest> (начиная с Linux 3.2)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:976
msgid "Do not measure time spent in VM guest."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:976
#, no-wrap
msgid "I<exclude_callchain_kernel> (since Linux 3.7)"
msgstr "I<exclude_callchain_kernel> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:979
msgid "Do not include kernel callchains."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:979
#, no-wrap
msgid "I<exclude_callchain_user> (since Linux 3.7)"
msgstr "I<exclude_callchain_user> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:982
msgid "Do not include user callchains."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:982
#, no-wrap
msgid "I<wakeup_events>, I<wakeup_watermark>"
msgstr "I<wakeup_events>, I<wakeup_watermark>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:992
msgid ""
"This union sets how many samples (I<wakeup_events>)  or bytes "
"(I<wakeup_watermark>)  happen before an overflow signal happens.  Which one "
"is used is selected by the I<watermark> bit flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1002
msgid ""
"I<wakeup_events> only counts B<PERF_RECORD_SAMPLE> record types.  To receive"
" a signal for every incoming B<PERF_RECORD> type set I<wakeup_watermark> to "
"1."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1002
#, no-wrap
msgid "I<bp_type> (since Linux 2.6.33)"
msgstr "I<bp_type> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1006
msgid "This chooses the breakpoint type.  It is one of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1007
#, no-wrap
msgid "B<HW_BREAKPOINT_EMPTY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1010
msgid "No breakpoint."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1010
#, no-wrap
msgid "B<HW_BREAKPOINT_R>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1013
msgid "Count when we read the memory location."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1013
#, no-wrap
msgid "B<HW_BREAKPOINT_W>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1016
msgid "Count when we write the memory location."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1016
#, no-wrap
msgid "B<HW_BREAKPOINT_RW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1019
msgid "Count when we read or write the memory location."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1019
#, no-wrap
msgid "B<HW_BREAKPOINT_X>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1022
msgid "Count when we execute code at the memory location."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1031
msgid ""
"The values can be combined via a bitwise or, but the combination of "
"B<HW_BREAKPOINT_R> or B<HW_BREAKPOINT_W> with B<HW_BREAKPOINT_X> is not "
"allowed."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1032
#, no-wrap
msgid "I<bp_addr> (since Linux 2.6.33)"
msgstr "I<bp_addr> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1039
msgid ""
"I<bp_addr> address of the breakpoint.  For execution breakpoints this is the"
" memory address of the instruction of interest; for read and write "
"breakpoints it is the memory address of the memory location of interest."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1039
#, no-wrap
msgid "I<config1> (since Linux 2.6.39)"
msgstr "I<config1> (начиная с Linux 2.6.39)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1046
msgid ""
"I<config1> is used for setting events that need an extra register or "
"otherwise do not fit in the regular config field.  Raw OFFCORE_EVENTS on "
"Nehalem/Westmere/SandyBridge use this field on 3.3 and later kernels."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1046
#, no-wrap
msgid "I<bp_len> (since Linux 2.6.33)"
msgstr "I<bp_len> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1060
msgid ""
"I<bp_len> is the length of the breakpoint being measured if I<type> is "
"B<PERF_TYPE_BREAKPOINT>.  Options are B<HW_BREAKPOINT_LEN_1>, "
"B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4>, B<HW_BREAKPOINT_LEN_8>.  For"
" an execution breakpoint, set this to I<sizeof(long)>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1060
#, no-wrap
msgid "I<config2> (since Linux 2.6.39)"
msgstr "I<config2> (начиная с Linux 2.6.39)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1067
msgid "I<config2> is a further extension of the I<config1> field."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1067
#, no-wrap
msgid "I<branch_sample_type> (since Linux 3.4)"
msgstr "I<branch_sample_type> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1073
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then this specifies what branches"
" to include in the branch record."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1079
msgid ""
"The first part of the value is the privilege level, which is a combination "
"of one of the following values.  If the user does not set privilege level "
"explicitly, the kernel will use the event's privilege level.  Event and "
"branch privilege levels do not have to match."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1080
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_USER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1083
msgid "Branch target is in user space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1083
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_KERNEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1086
msgid "Branch target is in kernel space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1086
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_HV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1089
msgid "Branch target is in hypervisor."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1089
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_PLM_ALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1092
msgid "A convenience value that is the three preceding values ORed together."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1096
msgid ""
"In addition to the privilege value, at least one or more of the following "
"bits must be set."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1097
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1100
msgid "Any branch type."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1100
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_CALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1103
msgid "Any call branch."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1103
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1106
msgid "Any return branch."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1106
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_CALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1109
msgid "Indirect calls."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1109
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ABORT_TX> (since Linux 3.11)"
msgstr "B<PERF_SAMPLE_BRANCH_ABORT_TX> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1112
msgid "Transactional memory aborts."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1112
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IN_TX> (since Linux 3.11)"
msgstr "B<PERF_SAMPLE_BRANCH_IN_TX> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1115
msgid "Branch in transactional memory transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1115
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_NO_TX> (since Linux 3.11)"
msgstr "B<PERF_SAMPLE_BRANCH_NO_TX> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1118
msgid "Branch not in transactional memory transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1120
#, no-wrap
msgid "I<sample_regs_user> (since Linux 3.7)"
msgstr "I<sample_regs_user> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1126
msgid ""
"This bit mask defines the set of user CPU registers to dump on samples.  The"
" layout of the register mask is architecture-specific and described in the "
"kernel header I<arch/ARCH/include/uapi/asm/perf_regs.h>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1126
#, no-wrap
msgid "I<sample_stack_user> (since Linux 3.7)"
msgstr "I<sample_stack_user> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1131
msgid ""
"This defines the size of the user stack to dump if B<PERF_SAMPLE_STACK_USER>"
" is specified."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:1131
#, no-wrap
msgid "Reading results"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1141
msgid ""
"Once a B<perf_event_open>()  file descriptor has been opened, the values of "
"the events can be read from the file descriptor.  The values that are there "
"are specified by the I<read_format> field in the I<attr> structure at open "
"time."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1146
msgid ""
"If you attempt to read into a buffer that is not big enough to hold the data"
" B<ENOSPC> is returned"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1148
msgid "Here is the layout of the data returned by a read:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1152
msgid ""
"If B<PERF_FORMAT_GROUP> was specified to allow reading all events in a group"
" at once:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1164
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 nr;            /* The number of events */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct\n"
"        u64 value;     /* The value of the event */\n"
"        u64 id;        /* if PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1172
msgid "If B<PERF_FORMAT_GROUP> was I<not> specified:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1181
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 value;         /* The value of the event */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* if PERF_FORMAT_ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1185
msgid "The values read are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1185
#, no-wrap
msgid "I<nr>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1191
msgid ""
"The number of events in this file descriptor.  Only available if "
"B<PERF_FORMAT_GROUP> was specified."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1191
#, no-wrap
msgid "I<time_enabled>, I<time_running>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1203
msgid ""
"Total time the event was enabled and running.  Normally these are the same."
"  If more events are started, then available counter slots on the PMU, then "
"multiplexing happens and events run only part of the time.  In that case, "
"the I<time_enabled> and I<time running> values can be used to scale an "
"estimated value for the count."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1203
#, no-wrap
msgid "I<value>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1206
msgid "An unsigned 64-bit value containing the counter result."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1206 man-pages/man2/perf_event_open.2:1602
#: man-pages/man2/perf_event_open.2:1756
#, no-wrap
msgid "I<id>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1212
msgid ""
"A globally unique value for this particular event, only there if "
"B<PERF_FORMAT_ID> was specified in I<read_format>."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:1212
#, no-wrap
msgid "MMAP layout"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1222
msgid ""
"When using B<perf_event_open>()  in sampled mode, asynchronous events (like "
"counter overflow or B<PROT_EXEC> mmap tracking)  are logged into a ring-"
"buffer.  This ring-buffer is created and accessed through B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1228
msgid ""
"The mmap size should be 1+2^n pages, where the first page is a metadata page"
" (I<struct perf_event_mmap_page>)  that contains various bits of information"
" such as where the ring-buffer head is."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1231
msgid ""
"Before kernel 2.6.39, there is a bug that means you must allocate a mmap "
"ring buffer when sampling even if you do not plan to access it."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1233
msgid "The structure of the first metadata mmap page is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1262
#, no-wrap
msgid ""
"struct perf_event_mmap_page {\n"
"    __u32 version;        /* version number of this structure */\n"
"    __u32 compat_version; /* lowest version this is compat with */\n"
"    __u32 lock;           /* seqlock for synchronization */\n"
"    __u32 index;          /* hardware counter identifier */\n"
"    __s64 offset;         /* add to hardware counter value */\n"
"    __u64 time_enabled;   /* time event active */\n"
"    __u64 time_running;   /* time event on CPU */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        struct {\n"
"            __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,\n"
"                  cap_bit0_is_deprecated : 1,\n"
"                  cap_user_rdpmc         : 1,\n"
"                  cap_user_time          : 1,\n"
"                  cap_user_time_zero     : 1,\n"
"        };\n"
"    };\n"
"    __u16 pmc_width;\n"
"    __u16 time_shift;\n"
"    __u32 time_mult;\n"
"    __u64 time_offset;\n"
"    __u64 __reserved[120];   /* Pad to 1k */\n"
"    __u64 data_head;         /* head in the data section */\n"
"    __u64 data_tail;         /* user-space written tail */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1268
msgid ""
"The following list describes the fields in the I<perf_event_mmap_page> "
"structure in more detail:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1268
#, no-wrap
msgid "I<version>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1271
msgid "Version number of this structure."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1271
#, no-wrap
msgid "I<compat_version>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1274
msgid "The lowest version this is compatible with."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1274
#, no-wrap
msgid "I<lock>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1277
msgid "A seqlock for synchronization."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1277
#, no-wrap
msgid "I<index>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1280
msgid "A unique hardware counter identifier."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1280
#, no-wrap
msgid "I<offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1285
msgid ""
"When using rdpmc for reads this offset value must be added to the one "
"returned by rdpmc to get the current total event count."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1285
#, no-wrap
msgid "I<time_enabled>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1288
msgid "Time the event was active."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1288
#, no-wrap
msgid "I<time_running>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1291
msgid "Time the event was running."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1291
#, no-wrap
msgid "I<cap_usr_time> / I<cap_usr_rdpmc> / I<cap_bit0> (since Linux 3.4)"
msgstr "I<cap_usr_time> / I<cap_usr_rdpmc> / I<cap_bit0> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1304
msgid ""
"There was a bug in the definition of I<cap_usr_time> and I<cap_usr_rdpmc> "
"from Linux 3.4 until Linux 3.11.  Both bits were defined to point to the "
"same location, so it was impossible to know if I<cap_usr_time> or "
"I<cap_usr_rdpmc> were actually set."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1312
msgid ""
"Starting with 3.12 these are renamed to I<cap_bit0> and you should use the "
"new I<cap_user_time> and I<cap_user_rdpmc> fields instead."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1313
#, no-wrap
msgid "I<cap_bit0_is_deprecated> (since Linux 3.12)"
msgstr "I<cap_bit0_is_deprecated> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1321
msgid ""
"If set, this bit indicates that the kernel supports the properly separated "
"I<cap_user_time> and I<cap_user_rdpmc> bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1328
msgid ""
"If not-set, it indicates an older kernel where I<cap_usr_time> and "
"I<cap_usr_rdpmc> map to the same bit and thus both features should be used "
"with caution."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1329
#, no-wrap
msgid "I<cap_user_rdpmc> (since Linux 3.12)"
msgstr "I<cap_user_rdpmc> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1334
msgid ""
"If the hardware supports user-space read of performance counters without "
"syscall (this is the \"rdpmc\" instruction on x86), then the following code "
"can be used to do a read:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1340
#, no-wrap
msgid ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"
msgstr "u32 seq, time_mult, time_shift, idx, width;\nu64 count, enabled, running;\nu64 cyc, time_offset;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1346
#, no-wrap
msgid ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1353
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1356
#, no-wrap
msgid ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1361
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        count += rdpmc(idx - 1);\n"
"    }\n"
msgstr "    if (pc-E<gt>cap_usr_rdpmc && idx) {\n        width = pc-E<gt>pmc_width;\n        count += rdpmc(idx - 1);\n    }\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1364
#, no-wrap
msgid ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1366
#, no-wrap
msgid "I<cap_user_time  (since Linux 3.12)>"
msgstr "I<cap_user_time> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1370
msgid ""
"This bit indicates the hardware has a constant, nonstop timestamp counter "
"(TSC on x86)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1370
#, no-wrap
msgid "I<cap_user_time_zero> (since Linux 3.12)"
msgstr "I<cap_user_time_zero> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1376
msgid ""
"Indicates the presence of I<time_zero> which allows mapping timestamp values"
" to the hardware clock."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1376
#, no-wrap
msgid "I<pmc_width>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1383
msgid ""
"If I<cap_usr_rdpmc>, this field provides the bit-width of the value read "
"using the rdpmc or equivalent instruction.  This can be used to sign extend "
"the result like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1389
#, no-wrap
msgid ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // signed shift right\n"
"count += pmc;\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1391
#, no-wrap
msgid "I<time_shift>, I<time_mult>, I<time_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1398
msgid ""
"If I<cap_usr_time>, these fields can be used to compute the time delta since"
" time_enabled (in nanoseconds) using rdtsc or similar."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1406
#, no-wrap
msgid ""
"    u64 quot, rem;\n"
"    u64 delta;\n"
"    quot = (cyc E<gt>E<gt> time_shift);\n"
"    rem = cyc & ((1 E<lt>E<lt> time_shift) - 1);\n"
"    delta = time_offset + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1418
msgid ""
"Where I<time_offset>, I<time_mult>, I<time_shift>, and I<cyc> are read in "
"the seqcount loop described above.  This delta can then be added to enabled "
"and possible running (if idx), improving the scaling:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1426
#, no-wrap
msgid ""
"    enabled += delta;\n"
"    if (idx)\n"
"        running += delta;\n"
"    quot = count / running;\n"
"    rem  = count % running;\n"
"    count = quot * enabled + (rem * enabled) / running;\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1427
#, no-wrap
msgid "I<time_zero> (since Linux 3.12)"
msgstr "I<time_zero> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1435
msgid ""
"If I<cap_usr_time_zero> is set, then the hardware clock (the TSC timestamp "
"counter on x86)  can be calculated from the I<time_zero>, I<time_mult>, and "
"I<time_shift> values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1441
#, no-wrap
msgid ""
"    time = timestamp - time_zero;\n"
"    quot = time / time_mult;\n"
"    rem  = time % time_mult;\n"
"    cyc = (quot E<lt>E<lt> time_shift) + (rem E<lt>E<lt> time_shift) / time_mult;\n"
msgstr "    time = timestamp - time_zero;\n    quot = time / time_mult;\n    rem  = time % time_mult;\n    cyc = (quot E<lt>E<lt> time_shift) + (rem E<lt>E<lt> time_shift) / time_mult;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1444
msgid "And vice versa:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1450
#, no-wrap
msgid ""
"    quot = cyc E<gt>E<gt> time_shift;\n"
"    rem  = cyc & ((1 E<lt>E<lt> time_shift) - 1);\n"
"    timestamp = time_zero + quot * time_mult +\n"
"        ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr "    quot = cyc E<gt>E<gt> time_shift;\n    rem  = cyc & ((1 E<lt>E<lt> time_shift) - 1);\n    timestamp = time_zero + quot * time_mult +\n        ((rem * time_mult) E<gt>E<gt> time_shift);\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1451
#, no-wrap
msgid "I<data_head>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1457
msgid ""
"This points to the head of the data section.  The value continuously "
"increases, it does not wrap.  The value needs to be manually wrapped by the "
"size of the mmap buffer before accessing the samples."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1462
msgid ""
"On SMP-capable platforms, after reading the I<data_head> value, user space "
"should issue an rmb()."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1462
#, no-wrap
msgid "I<data_tail>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1470
msgid ""
"When the mapping is B<PROT_WRITE>, the I<data_tail> value should be written "
"by user space to reflect the last read data.  In this case, the kernel will "
"not overwrite unread data."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1472
msgid "The following 2^n ring-buffer pages have the layout described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1486
msgid ""
"If I<perf_event_attr.sample_id_all> is set, then all event types will have "
"the sample_type selected fields related to where/when (identity)  an event "
"took place (TID, TIME, ID, CPU, STREAM_ID) described in "
"B<PERF_RECORD_SAMPLE> below, it will be stashed just after the "
"I<perf_event_header> and the fields already present for the existing fields,"
" that is, at the end of the payload.  That way a newer perf.data file will "
"be supported by older perf tools, with these new optional fields being "
"ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1488
msgid "The mmap values start with a header:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1496
#, no-wrap
msgid ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1504
msgid ""
"Below, we describe the I<perf_event_header> fields in more detail.  For ease"
" of reading, the fields with shorter descriptions are presented first."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1507
msgid "This indicates the size of the record."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1507
#, no-wrap
msgid "I<misc>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1512
msgid "The I<misc> field contains additional information about the sample."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1517
msgid ""
"The CPU mode can be determined from this value by masking with "
"B<PERF_RECORD_MISC_CPUMODE_MASK> and looking for one of the following (note "
"these are not bit masks, only one can be set at a time):"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1518
#, no-wrap
msgid "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1521
msgid "Unknown CPU mode."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1521
#, no-wrap
msgid "B<PERF_RECORD_MISC_KERNEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1524
msgid "Sample happened in the kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1524
#, no-wrap
msgid "B<PERF_RECORD_MISC_USER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1527
msgid "Sample happened in user code."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1527
#, no-wrap
msgid "B<PERF_RECORD_MISC_HYPERVISOR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1530
msgid "Sample happened in the hypervisor."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1530
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_KERNEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1533
msgid "Sample happened in the guest kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1533
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_USER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1536
msgid "Sample happened in guest user code."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1540
msgid "In addition, one of the following bits can be set:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1540
#, no-wrap
msgid "B<PERF_RECORD_MISC_MMAP_DATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1544
msgid ""
"This is set when the mapping is not executable; otherwise the mapping is "
"executable."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1544
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXACT_IP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1552
msgid ""
"This indicates that the content of B<PERF_SAMPLE_IP> points to the actual "
"instruction that triggered the event.  See also "
"I<perf_event_attr.precise_ip>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1552
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXT_RESERVED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1555
msgid "This indicates there is extended data available (currently not used)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1565
msgid ""
"The I<type> value is one of the below.  The values in the corresponding "
"record (that follows the header)  depend on the I<type> selected as shown."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1567
#, no-wrap
msgid "B<PERF_RECORD_MMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1574
msgid ""
"The MMAP events record the B<PROT_EXEC> mappings so that we can correlate "
"user-space IPs to code.  They have the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1585
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1587
#, no-wrap
msgid "B<PERF_RECORD_LOST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1590
msgid "This record indicates when events are lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1599
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64 id;\n"
"    u64 lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr "struct {\n    struct perf_event_header header;\n    u64 id;\n    u64 lost;\n    struct sample_id sample_id;\n};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1605
msgid "is the unique event ID for the samples that were lost."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1605
#, no-wrap
msgid "I<lost>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1608
msgid "is the number of events that were lost."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1609
#, no-wrap
msgid "B<PERF_RECORD_COMM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1612
msgid "This record indicates a change in the process name."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1621
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, tid;\n"
"    char comm[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr "struct {\n    struct perf_event_header header;\n    u32 pid, tid;\n    char comm[];\n    struct sample_id sample_id;\n};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1623
#, no-wrap
msgid "B<PERF_RECORD_EXIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1626
msgid "This record indicates a process exit event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1636 man-pages/man2/perf_event_open.2:1666
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, ppid;\n"
"    u32 tid, ptid;\n"
"    u64 time;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr "struct {\n    struct perf_event_header header;\n    u32 pid, ppid;\n    u32 tid, ptid;\n    u64 time;\n    struct sample_id sample_id;\n};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1638
#, no-wrap
msgid "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1641
msgid "This record indicates a throttle/unthrottle event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1651
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64 time;\n"
"    u64 id;\n"
"    u64 stream_id;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr "struct {\n    struct perf_event_header header;\n    u64 time;\n    u64 id;\n    u64 stream_id;\n    struct sample_id sample_id;\n};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1653
#, no-wrap
msgid "B<PERF_RECORD_FORK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1656
msgid "This record indicates a fork event."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1668
#, no-wrap
msgid "B<PERF_RECORD_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1671
msgid "This record indicates a read event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1680
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, tid;\n"
"    struct read_format values;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr "struct {\n    struct perf_event_header header;\n    u32 pid, tid;\n    struct read_format values;\n    struct sample_id sample_id;\n};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1682
#, no-wrap
msgid "B<PERF_RECORD_SAMPLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1685
msgid "This record indicates a sample."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1717
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64   sample_id;  /* if PERF_SAMPLE_IDENTIFIER */\n"
"    u64   ip;         /* if PERF_SAMPLE_IP */\n"
"    u32   pid, tid;   /* if PERF_SAMPLE_TID */\n"
"    u64   time;       /* if PERF_SAMPLE_TIME */\n"
"    u64   addr;       /* if PERF_SAMPLE_ADDR */\n"
"    u64   id;         /* if PERF_SAMPLE_ID */\n"
"    u64   stream_id;  /* if PERF_SAMPLE_STREAM_ID */\n"
"    u32   cpu, res;   /* if PERF_SAMPLE_CPU */\n"
"    u64   period;     /* if PERF_SAMPLE_PERIOD */\n"
"    struct read_format v; /* if PERF_SAMPLE_READ */\n"
"    u64   nr;         /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u64   ips[nr];    /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u32   size;       /* if PERF_SAMPLE_RAW */\n"
"    char  data[size]; /* if PERF_SAMPLE_RAW */\n"
"    u64   bnr;        /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                      /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    u64   abi;        /* if PERF_SAMPLE_REGS_USER */\n"
"    u64   regs[weight(mask)];\n"
"                      /* if PERF_SAMPLE_REGS_USER */\n"
"    u64   size;       /* if PERF_SAMPLE_STACK_USER */\n"
"    char  data[size]; /* if PERF_SAMPLE_STACK_USER */\n"
"    u64   dyn_size;   /* if PERF_SAMPLE_STACK_USER */\n"
"    u64   weight;     /* if PERF_SAMPLE_WEIGHT */\n"
"    u64   data_src;   /* if PERF_SAMPLE_DATA_SRC */\n"
"    u64   transaction;/* if PERF_SAMPLE_TRANSACTION */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1719
#, no-wrap
msgid "I<sample_id>"
msgstr "I<sample_id>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1729
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is enabled, a 64-bit unique ID is included.  "
"This is a duplication of the B<PERF_SAMPLE_ID> I<id> value, but included at "
"the beginning of the sample so parsers can easily obtain the value."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1729
#, no-wrap
msgid "I<ip>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1735
msgid ""
"If B<PERF_SAMPLE_IP> is enabled, then a 64-bit instruction pointer value is "
"included."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1735
#, no-wrap
msgid "I<pid>, I<tid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1741
msgid ""
"If B<PERF_SAMPLE_TID> is enabled, then a 32-bit process ID and 32-bit thread"
" ID are included."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1741
#, no-wrap
msgid "I<time>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1749
msgid ""
"If B<PERF_SAMPLE_TIME> is enabled, then a 64-bit timestamp is included.  "
"This is obtained via local_clock() which is a hardware timestamp if "
"available and the jiffies value if not."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1749
#, no-wrap
msgid "I<addr>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1756
msgid ""
"If B<PERF_SAMPLE_ADDR> is enabled, then a 64-bit address is included.  This "
"is usually the address of a tracepoint, breakpoint, or software event; "
"otherwise the value is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1764
msgid ""
"If B<PERF_SAMPLE_ID> is enabled, a 64-bit unique ID is included.  If the "
"event is a member of an event group, the group leader ID is returned.  This "
"ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1764
#, no-wrap
msgid "I<stream_id>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1774
msgid ""
"If B<PERF_SAMPLE_STREAM_ID> is enabled, a 64-bit unique ID is included.  "
"Unlike B<PERF_SAMPLE_ID> the actual ID is returned, not the group leader.  "
"This ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1774
#, no-wrap
msgid "I<cpu>, I<res>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1781
msgid ""
"If B<PERF_SAMPLE_CPU> is enabled, this is a 32-bit value indicating which "
"CPU was being used, in addition to a reserved (unused)  32-bit value."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1781
#, no-wrap
msgid "I<period>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1787
msgid ""
"If B<PERF_SAMPLE_PERIOD> is enabled, a 64-bit value indicating the current "
"sampling period is written."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1787
#, no-wrap
msgid "I<v>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1798
msgid ""
"If B<PERF_SAMPLE_READ> is enabled, a structure of type read_format is "
"included which has values for all events in the event group.  The values "
"included depend on the I<read_format> value used at B<perf_event_open>()  "
"time."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1798
#, no-wrap
msgid "I<nr>, I<ips[nr]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1806
msgid ""
"If B<PERF_SAMPLE_CALLCHAIN> is enabled, then a 64-bit number is included "
"which indicates how many following 64-bit instruction pointers will follow."
"  This is the current callchain."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1806
#, no-wrap
msgid "I<size>, I<data[size]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1813
msgid ""
"If B<PERF_SAMPLE_RAW> is enabled, then a 32-bit value indicating size is "
"included followed by an array of 8-bit values of length size.  The values "
"are padded with 0 to have 64-bit alignment."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1818
msgid ""
"This RAW record data is opaque with respect to the ABI.  The ABI doesn't "
"make any promises with respect to the stability of its content, it may vary "
"depending on event, hardware, and kernel version."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1818
#, no-wrap
msgid "I<bnr>, I<lbr[bnr]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1827
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then a 64-bit value indicating "
"the number of records is included, followed by I<bnr> I<perf_branch_entry> "
"structures which each include the fields:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1828
#, no-wrap
msgid "I<from>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1831
msgid "This indicates the source instruction (may not be a branch)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1831
#, no-wrap
msgid "I<to>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1834
msgid "The branch target."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1834
#, no-wrap
msgid "I<mispred>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1837
msgid "The branch target was mispredicted."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1837
#, no-wrap
msgid "I<predicted>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1840
msgid "The branch target was predicted."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1840
#, no-wrap
msgid "I<in_tx> (since Linux 3.11)"
msgstr "I<in_tx> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1843
msgid "The branch was in a transactional memory transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1843
#, no-wrap
msgid "I<abort> (since Linux 3.11)"
msgstr "I<abort> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1846
msgid "The branch was in an aborted transactional memory transaction."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1850
msgid ""
"The entries are from most to least recent, so the first entry has the most "
"recent branch."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1857
msgid ""
"Support for I<mispred> and I<predicted> is optional; if not supported, both "
"values will be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1861
msgid ""
"The type of branches recorded is specified by the I<branch_sample_type> "
"field."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1863
#, no-wrap
msgid "I<abi>, I<regs[weight(mask)]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1868
msgid ""
"If B<PERF_SAMPLE_REGS_USER> is enabled, then the user CPU registers are "
"recorded."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1874
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1884
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_user> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_user> bit mask."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1884
#, no-wrap
msgid "I<size>, I<data[size]>, I<dyn_size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1900
msgid ""
"If B<PERF_SAMPLE_STACK_USER> is enabled, then the user stack is recorded.  "
"This can be used to generate stack backtraces.  I<size> is the size "
"requested by the user in I<sample_stack_user> or else the maximum record "
"size.  I<data> is the stack data (a raw dump of the memory pointed to by the"
" stack pointer at the time of sampling).  I<dyn_size> is the amount of data "
"actually dumped (can be less than I<size>)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1900
#, no-wrap
msgid "I<weight>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1908
msgid ""
"If B<PERF_SAMPLE_WEIGHT> is enabled, then a 64-bit value provided by the "
"hardware is recorded that indicates how costly the event was.  This allows "
"expensive events to stand out more clearly in profiles."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1908
#, no-wrap
msgid "I<data_src>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1914
msgid ""
"If B<PERF_SAMPLE_DATA_SRC> is enabled, then a 64-bit value is recorded that "
"is made up of the following fields:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1915
#, no-wrap
msgid "I<mem_op>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1918
msgid "Type of opcode, a bitwise combination of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1921
#, no-wrap
msgid "B<PERF_MEM_OP_NA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1924 man-pages/man2/perf_event_open.2:1949
#: man-pages/man2/perf_event_open.2:2000 man-pages/man2/perf_event_open.2:2024
#: man-pages/man2/perf_event_open.2:2040
msgid "Not available"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1924
#, no-wrap
msgid "B<PERF_MEM_OP_LOAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1927
msgid "Load instruction"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1927
#, no-wrap
msgid "B<PERF_MEM_OP_STORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1930
msgid "Store instruction"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1930
#, no-wrap
msgid "B<PERF_MEM_OP_PFETCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1933
msgid "Prefetch"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1933
#, no-wrap
msgid "B<PERF_MEM_OP_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1936
msgid "Executable code"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1938
#, no-wrap
msgid "I<mem_lvl>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1943
msgid ""
"Memory hierarchy level hit or miss, a bitwise combination of the following, "
"shifted left by B<PERF_MEM_LVL_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1946
#, no-wrap
msgid "B<PERF_MEM_LVL_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1949
#, no-wrap
msgid "B<PERF_MEM_LVL_HIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1952 man-pages/man2/perf_event_open.2:2043
msgid "Hit"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1952
#, no-wrap
msgid "B<PERF_MEM_LVL_MISS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1955 man-pages/man2/perf_event_open.2:2046
msgid "Miss"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1955
#, no-wrap
msgid "B<PERF_MEM_LVL_L1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1958
msgid "Level 1 cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1958
#, no-wrap
msgid "B<PERF_MEM_LVL_LFB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1961
msgid "Line fill buffer"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1961
#, no-wrap
msgid "B<PERF_MEM_LVL_L2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1964
msgid "Level 2 cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1964
#, no-wrap
msgid "B<PERF_MEM_LVL_L3>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1967
msgid "Level 3 cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1967
#, no-wrap
msgid "B<PERF_MEM_LVL_LOC_RAM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1970
msgid "Local DRAM"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1970
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1973
msgid "Remote DRAM 1 hop"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1973
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1976
msgid "Remote DRAM 2 hops"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1976
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1979
msgid "Remote cache 1 hop"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1979
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1982
msgid "Remote cache 2 hops"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1982
#, no-wrap
msgid "B<PERF_MEM_LVL_IO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1985
msgid "I/O memory"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1985
#, no-wrap
msgid "B<PERF_MEM_LVL_UNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1988
msgid "Uncached memory"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1990
#, no-wrap
msgid "I<mem_snoop>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1994
msgid ""
"Snoop mode, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_SNOOP_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1997
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2000
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2003
msgid "No snoop"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2003
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2006
msgid "Snoop hit"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2006
#, no-wrap
msgid "B<PERF_MEM_SNOOP_MISS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2009
msgid "Snoop miss"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2009
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HITM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2012
msgid "Snoop hit modified"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2014
#, no-wrap
msgid "I<mem_lock>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2018
msgid ""
"Lock instruction, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_LOCK_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2021
#, no-wrap
msgid "B<PERF_MEM_LOCK_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2024
#, no-wrap
msgid "B<PERF_MEM_LOCK_LOCKED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2027
msgid "Locked transaction"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2029
#, no-wrap
msgid "I<mem_dtlb>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2034
msgid ""
"TLB access hit or miss, a bitwise combination of the following, shifted left"
" by B<PERF_MEM_TLB_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2037
#, no-wrap
msgid "B<PERF_MEM_TLB_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2040
#, no-wrap
msgid "B<PERF_MEM_TLB_HIT>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2043
#, no-wrap
msgid "B<PERF_MEM_TLB_MISS>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2046
#, no-wrap
msgid "B<PERF_MEM_TLB_L1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2049
msgid "Level 1 TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2049
#, no-wrap
msgid "B<PERF_MEM_TLB_L2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2052
msgid "Level 2 TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2052
#, no-wrap
msgid "B<PERF_MEM_TLB_WK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2055
msgid "Hardware walker"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2055
#, no-wrap
msgid "B<PERF_MEM_TLB_OS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2058
msgid "OS fault handler"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2061
#, no-wrap
msgid "I<transaction>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2067
msgid ""
"If the B<PERF_SAMPLE_TRANSACTION> flag is set, then a 64-bit field is "
"recorded describing the sources of any transactional memory aborts."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2069
msgid "The field is a bitwise combination of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2070
#, no-wrap
msgid "B<PERF_TXN_ELISION>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2073
msgid "Abort from an elision type transaction (Intel-CPU-specific)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2073
#, no-wrap
msgid "B<PERF_TXN_TRANSACTION>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2076
msgid "Abort from a generic transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2076
#, no-wrap
msgid "B<PERF_TXN_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2079
msgid "Synchronous abort (related to the reported instruction)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2079
#, no-wrap
msgid "B<PERF_TXN_ASYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2082
msgid "Asynchronous abort (not related to the reported instruction)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2082
#, no-wrap
msgid "B<PERF_TXN_RETRY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2085
msgid "Retryable abort (retrying the transaction may have succeeded)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2085
#, no-wrap
msgid "B<PERF_TXN_CONFLICT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2088
msgid "Abort due to memory conflicts with other threads."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2088
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2091
msgid "Abort due to write capacity overflow."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2091
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2094
msgid "Abort due to read capacity overflow."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2101
msgid ""
"In addition, a user-specified abort code can be obtained from the high 32 "
"bits of the field by shifting right by B<PERF_TXN_ABORT_SHIFT> and masking "
"with B<PERF_TXN_ABORT_MASK>."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2103
#, no-wrap
msgid "Signal overflow"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2112
msgid ""
"Events can be set to deliver a signal when a threshold is crossed.  The "
"signal handler is set up using the B<poll>(2), B<select>(2), B<epoll>(2)  "
"and B<fcntl>(2), system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2116
msgid ""
"To generate signals, sampling must be enabled (I<sample_period> must have a "
"nonzero value)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2118
msgid "There are two ways to generate signals."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2128
msgid ""
"The first is to set a I<wakeup_events> or I<wakeup_watermark> value that "
"will generate a signal if a certain number of samples or bytes have been "
"written to the mmap ring buffer.  In this case, a signal of type B<POLL_IN> "
"is sent."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2140
msgid ""
"The other way is by use of the B<PERF_EVENT_IOC_REFRESH> ioctl.  This ioctl "
"adds to a counter that decrements each time the event overflows.  When "
"nonzero, a B<POLL_IN> signal is sent on overflow, but once the value reaches"
" 0, a signal is sent of type B<POLL_HUP> and the underlying event is "
"disabled."
msgstr ""

#.  FIXME(Vince) : Find out when this was introduced
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2146
msgid ""
"Note: on newer kernels (definitely noticed with 3.2)  a signal is provided "
"for every overflow, even if I<wakeup_events> is not set."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2146
#, no-wrap
msgid "rdpmc instruction"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2153
msgid ""
"Starting with Linux 3.4 on x86, you can use the I<rdpmc> instruction to get "
"low-latency reads without having to enter the kernel.  Note that using "
"I<rdpmc> is not necessarily faster than other methods for reading event "
"values."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2158
msgid ""
"Support for this can be detected with the I<cap_usr_rdpmc> field in the mmap"
" page; documentation on how to calculate event values can be found in that "
"section."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2158
#, no-wrap
msgid "perf_event ioctl calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2163
msgid "Various ioctls act on B<perf_event_open>()  file descriptors:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2163
#, no-wrap
msgid "B<PERF_EVENT_IOC_ENABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2167
msgid ""
"This enables the individual event or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2173
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are enabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2173
#, no-wrap
msgid "B<PERF_EVENT_IOC_DISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2177
msgid ""
"This disables the individual counter or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2184
msgid ""
"Enabling or disabling the leader of a group enables or disables the entire "
"group; that is, while the group leader is disabled, none of the counters in "
"the group will count.  Enabling or disabling a member of a group other than "
"the leader affects only that counter; disabling a non-leader stops that "
"counter from counting but doesn't affect any other counter."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2190
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are disabled, even if the event specified is not the group"
" leader (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2190
#, no-wrap
msgid "B<PERF_EVENT_IOC_REFRESH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2204
msgid ""
"Non-inherited overflow counters can use this to enable a counter for a "
"number of overflows specified by the argument, after which it is disabled.  "
"Subsequent calls of this ioctl add the argument value to the current count."
"  A signal with B<POLL_IN> set will happen on each overflow until the count "
"reaches 0; when that happens a signal with POLL_HUP set is sent and the "
"event is disabled.  Using an argument of 0 is considered undefined behavior."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2204
#, no-wrap
msgid "B<PERF_EVENT_IOC_RESET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2214
msgid ""
"Reset the event count specified by the file descriptor argument to zero.  "
"This resets only the counts; there is no way to reset the multiplexing "
"I<time_enabled> or I<time_running> values."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2220
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are reset, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2220
#, no-wrap
msgid "B<PERF_EVENT_IOC_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2223
msgid "This updates the overflow period for the event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2228
msgid ""
"Since Linux 3.7 (on ARM) and Linux 3.14 (all other architectures), the new "
"period takes effect immediately.  On older kernels, the new period did not "
"take effect until after the next overflow."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2231
msgid ""
"The argument is a pointer to a 64-bit value containing the desired new "
"period."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2234
msgid ""
"Prior to Linux 2.6.36 this ioctl always failed due to a bug in the kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2235
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_OUTPUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2240
msgid ""
"This tells the kernel to report event notifications to the specified file "
"descriptor rather than the default one.  The file descriptors must all be on"
" the same CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2243
msgid ""
"The argument specifies the desired file descriptor, or -1 if output should "
"be ignored."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2243
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_FILTER> (since Linux 2.6.33)"
msgstr "B<PERF_EVENT_IOC_SET_FILTER> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2246
msgid "This adds an ftrace filter to this event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2248
msgid "The argument is a pointer to the desired ftrace filter."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2248
#, no-wrap
msgid "B<PERF_EVENT_IOC_ID> (since Linux 3.12)"
msgstr "B<PERF_EVENT_IOC_ID> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2251
msgid "This returns the event ID value for the given event file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2254
msgid ""
"The argument is a pointer to a 64-bit unsigned integer to hold the result."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2254
#, no-wrap
msgid "Using prctl"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2267
msgid ""
"A process can enable or disable all the event groups that are attached to it"
" using the B<prctl>(2)  B<PR_TASK_PERF_EVENTS_ENABLE> and "
"B<PR_TASK_PERF_EVENTS_DISABLE> operations.  This applies to all counters on "
"the calling process, whether created by this process or by another, and does"
" not affect any counters that this process has created on other processes.  "
"It enables or disables only the group leaders, not any other members in the "
"groups."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2267
#, no-wrap
msgid "perf_event related configuration files"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2270
msgid "Files in I</proc/sys/kernel/>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2271
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_paranoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2277
msgid ""
"The I<perf_event_paranoid> file can be set to restrict access to the "
"performance counters."
msgstr ""

#. type: IP
#: man-pages/man2/perf_event_open.2:2278
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2280
msgid "only allow user-space measurements."
msgstr ""

#. type: IP
#: man-pages/man2/perf_event_open.2:2280
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2282
msgid "allow both kernel and user measurements (default)."
msgstr ""

#. type: IP
#: man-pages/man2/perf_event_open.2:2282
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2284
msgid "allow access to CPU-specific data but not raw tracepoint samples."
msgstr ""

#. type: IP
#: man-pages/man2/perf_event_open.2:2284
#, no-wrap
msgid "-1"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2286
msgid "no restrictions."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2292
msgid ""
"The existence of the I<perf_event_paranoid> file is the official method for "
"determining if a kernel supports B<perf_event_open>()."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2292
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_sample_rate>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2301
msgid ""
"This sets the maximum sample rate.  Setting this too high can allow users to"
" sample at a rate that impacts overall machine performance and potentially "
"lock up the machine.  The default value is 100000 (samples per second)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2301
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_mlock_kb>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2307
msgid ""
"Maximum number of pages an unprivileged user can B<mlock>(2).  The default "
"is 516 (kB)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2311
msgid "Files in I</sys/bus/event_source/devices/>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2317
msgid ""
"Since Linux 2.6.34, the kernel supports having multiple PMUs available for "
"monitoring.  Information on how to program these PMUs can be found under "
"I</sys/bus/event_source/devices/>.  Each subdirectory corresponds to a "
"different PMU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2317
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/type> (since Linux 2.6.38)"
msgstr "I</sys/bus/event_source/devices/*/type> (начиная с Linux 2.6.38)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2324
msgid ""
"This contains an integer that can be used in the I<type> field of "
"I<perf_event_attr> to indicate that you wish to use this PMU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2324
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/rdpmc> (since Linux 3.4)"
msgstr "I</sys/bus/event_source/devices/*/rdpmc> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2329
msgid ""
"If this file is 1, then direct user-space access to the performance counter "
"registers is allowed via the rdpmc instruction.  This can be disabled by "
"echoing 0 to the file."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2329
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/format/> (since Linux 3.4)"
msgstr "I</sys/bus/event_source/devices/*/format/> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2337
msgid ""
"This subdirectory contains information on the architecture-specific "
"subfields available for programming the various I<config> fields in the "
"I<perf_event_attr> struct."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2348
msgid ""
"The content of each file is the name of the config field, followed by a "
"colon, followed by a series of integer bit ranges separated by commas.  For "
"example, the file I<event> may contain the value I<config1:1,6-10,44> which "
"indicates that event is an attribute that occupies bits 1,6-10, and 44 of "
"I<perf_event_attr::config1>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2348
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/events/> (since Linux 3.4)"
msgstr "I</sys/bus/event_source/devices/*/events/> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2357
msgid ""
"This subdirectory contains files with predefined events.  The contents are "
"strings describing the event settings expressed in terms of the fields found"
" in the previously mentioned I<./format/> directory.  These are not "
"necessarily complete lists of all events supported by a PMU, but usually a "
"subset of events deemed useful or interesting."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2365
msgid ""
"The content of each file is a list of attribute names separated by commas.  "
"Each entry has an optional value (either hex or decimal).  If no value is "
"specified, then it is assumed to be a single-bit field with a value of 1.  "
"An example entry may look like this: I<event=0x2,inv,ldlat=3>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2365
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/uevent>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2369
msgid ""
"This file is the standard kernel device interface for injecting hotplug "
"events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2369
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/cpumask> (since Linux 3.7)"
msgstr "I</sys/bus/event_source/devices/*/cpumask> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2378
msgid ""
"The I<cpumask> file contains a comma-separated list of integers that "
"indicate a representative CPU number for each socket (package)  on the "
"motherboard.  This is needed when setting up uncore or northbridge events, "
"as those PMUs present socket-wide events."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2385
msgid ""
"B<perf_event_open>()  returns the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2390
msgid ""
"The errors returned by B<perf_event_open>()  can be inconsistent, and may "
"vary across processor architectures and performance monitoring units."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2390
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2407
msgid ""
"Returned if the I<perf_event_attr> I<size> value is too small (smaller than "
"B<PERF_ATTR_SIZE_VER0>), too big (larger than the page size), or larger than"
" the kernel supports and the extra bytes are not zero.  When B<E2BIG> is "
"returned, the I<perf_event_attr> I<size> field is overwritten by the kernel "
"to be the size of the structure it was expecting."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2407
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2421
msgid ""
"Returned when the requested event requires B<CAP_SYS_ADMIN> permissions (or "
"a more permissive perf_event paranoid setting).  Some common cases where an "
"unprivileged process may encounter this error: attaching to a process owned "
"by a different user; monitoring all processes on a given CPU (i.e., "
"specifying the I<pid> argument as -1); and not setting I<exclude_kernel> "
"when the paranoid setting requires it."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2421
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2431
msgid ""
"Returned if the I<group_fd> file descriptor is not valid, or, if "
"B<PERF_FLAG_PID_CGROUP> is set, the cgroup file descriptor in I<pid> is not "
"valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2436
msgid "Returned if the I<attr> pointer points at an invalid memory address."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2462
msgid ""
"Returned if the specified event is invalid.  There are many possible reasons"
" for this.  A not-exhaustive list: I<sample_freq> is higher than the maximum"
" setting; the I<cpu> to monitor does not exist; I<read_format> is out of "
"range; I<sample_type> is out of range; the I<flags> value is out of range; "
"I<exclusive> or I<pinned> set and the event is not a group leader; the event"
" I<config> values are out of range or set reserved bits; the generic event "
"selected is not supported; or there is not enough room to add the selected "
"event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2468
msgid ""
"Each opened event uses one file descriptor.  If a large number of events are"
" opened the per-user file descriptor limit (often 1024) will be hit and no "
"more events can be created."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2472
msgid ""
"Returned when the event involves a feature not supported by the current CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2479
msgid ""
"Returned if the I<type> setting is not valid.  This error is also returned "
"for some unsupported generic events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2479
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2489
msgid ""
"Prior to Linux 3.3, if there was not enough room for the event, B<ENOSPC> "
"was returned.  In Linux 3.3, this was changed to B<EINVAL>.  B<ENOSPC> is "
"still returned if you try to add more breakpoint events than supported by "
"the hardware."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2496
msgid ""
"Returned if B<PERF_SAMPLE_STACK_USER> is set in I<sample_type> and it is not"
" supported by hardware."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2503
msgid ""
"Returned if an event requiring a specific hardware feature is requested but "
"there is no hardware support.  This includes requesting low-skid events if "
"not supported, branch tracing if it is not available, sampling if no PMU "
"interrupt is available, and branch stacks for software events."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2508
msgid ""
"Returned on many (but not all) architectures when an unsupported "
"I<exclude_hv>, I<exclude_idle>, I<exclude_user>, or I<exclude_kernel> "
"setting is specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2516
msgid ""
"It can also happen, as with B<EACCES>, when the requested event requires "
"B<CAP_SYS_ADMIN> permissions (or a more permissive perf_event paranoid "
"setting).  This includes setting a breakpoint on a kernel address, and "
"(since Linux 3.13) setting a kernel function-trace tracepoint."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2519
msgid "Returned if attempting to attach to a process that does not exist."
msgstr ""

#. type: SH
#: man-pages/man2/perf_event_open.2:2519
#, no-wrap
msgid "VERSION"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2524
msgid ""
"B<perf_event_open>()  was introduced in Linux 2.6.31 but was called "
"B<perf_counter_open>().  It was renamed in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2529
msgid ""
"This B<perf_event_open>()  system call Linux- specific and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2533
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  See the example below."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2539
msgid ""
"The official way of knowing if B<perf_event_open>()  support is enabled is "
"checking for the existence of the file "
"I</proc/sys/kernel/perf_event_paranoid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2546
msgid ""
"The B<F_SETOWN_EX> option to B<fcntl>(2)  is needed to properly get overflow"
" signals in threads.  This was introduced in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2554
msgid ""
"Prior to Linux 2.6.33 (at least for x86), the kernel did not check if events"
" could be scheduled together until read time.  The same happens on all known"
" kernels if the NMI watchdog is enabled.  This means to see if a given set "
"of events works you have to B<perf_event_open>(), start, then read before "
"you know for sure you can get valid measurements."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2558
msgid ""
"Prior to Linux 2.6.34, event constraints were not enforced by the kernel.  "
"In that case, some events would silently return \"0\" if the kernel "
"scheduled them in an improper counter slot."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2561
msgid ""
"Prior to Linux 2.6.34, there was a bug when multiplexing where the wrong "
"results could be returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2564
msgid ""
"Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "
"\"inherit\" is enabled and many threads are started."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2568
msgid ""
"Prior to Linux 2.6.35, B<PERF_FORMAT_GROUP> did not work with attached "
"processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2573
msgid ""
"In older Linux 2.6 versions, refreshing an event group leader refreshed all "
"siblings, and refreshing with a parameter of 0 enabled infinite refresh.  "
"This behavior is unsupported and should not be relied on."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2579
msgid ""
"There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that "
"ignores the \"watermark\" field and acts as if a wakeup_event was chosen if "
"the union has a nonzero value in it."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2585
msgid ""
"From Linux 2.6.31 to Linux 3.4, the B<PERF_IOC_FLAG_GROUP> ioctl argument "
"was broken and would repeatedly operate on the event specified rather than "
"iterating across all sibling events in a group."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2596
msgid ""
"From Linux 3.4 to Linux 3.11, the mmap I<cap_usr_rdpmc> and I<cap_usr_time> "
"bits mapped to the same location.  Code should migrate to the new "
"I<cap_user_rdpmc> and I<cap_user_time> fields instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2601
msgid ""
"Always double-check your results! Various generalized events have had wrong "
"values.  For example, retired branches measured the wrong thing on AMD "
"machines until Linux 2.6.35."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2605
msgid ""
"The following is a short example that measures the total instruction count "
"of a call to B<printf>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2614
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>sys/ioctl.hE<gt>\n#include E<lt>linux/perf_event.hE<gt>\n#include E<lt>asm/unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2620
#, no-wrap
msgid ""
"static long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2625
#, no-wrap
msgid ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"
msgstr "    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n                   group_fd, flags);\n    return ret;\n}\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2632
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"
msgstr "int\nmain(int argc, char **argv)\n{\n    struct perf_event_attr pe;\n    long long count;\n    int fd;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2640
#, no-wrap
msgid ""
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
msgstr "    memset(&pe, 0, sizeof(struct perf_event_attr));\n    pe.type = PERF_TYPE_HARDWARE;\n    pe.size = sizeof(struct perf_event_attr);\n    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n    pe.disabled = 1;\n    pe.exclude_kernel = 1;\n    pe.exclude_hv = 1;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2646
#, no-wrap
msgid ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2649
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"
msgstr "    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2651
#, no-wrap
msgid "    printf(\"Measuring instruction count for this printf\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2654
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(long long));\n"
msgstr "    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n    read(fd, &count, sizeof(long long));\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2656
#, no-wrap
msgid "    printf(\"Used %lld instructions\\en\", count);\n"
msgstr "    printf(\"Использовано %lld инструкций\\en\", count);\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2659
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr "    close(fd);\n}\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2665
msgid "B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"
msgstr "B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"

#. type: TH
#: man-pages/man2/personality.2:32
#, no-wrap
msgid "PERSONALITY"
msgstr "PERSONALITY"

#. type: TH
#: man-pages/man2/personality.2:32
#, no-wrap
msgid "2014-04-15"
msgstr "2014-04-15"

#. type: Plain text
#: man-pages/man2/personality.2:35
msgid "personality - set the process execution domain"
msgstr "personality - устанавливает домен исполнения процесса"

#. type: Plain text
#: man-pages/man2/personality.2:37
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr "B<#include E<lt>sys/personality.hE<gt>>"

#. type: Plain text
#: man-pages/man2/personality.2:39
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr "B<int personality(unsigned long >I<persona>B<);>"

#. type: Plain text
#: man-pages/man2/personality.2:47
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal"
" numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr "Linux поддерживает несколько видов доменов исполнения процессов или специализаций (personalities) для каждого процесса. Среди прочего, домены исполнения указывают Linux как связывать номера сигналов с обработчиками сигналов. Система доменов исполнения позволяет Linux частично поддерживать программы, собранные в других ОС, подобных UNIX."

#. type: Plain text
#: man-pages/man2/personality.2:59
msgid ""
"If I<persona> is not 0xffffffff, then B<personality>()  sets the caller's "
"execution domain to the value specified by I<persona>.  Specifying "
"I<persona> as 0xffffffff provides a way of retrieving the current persona "
"without changing it."
msgstr "Если значение I<persona> не равно 0xffffffff, то B<personality>() установит домен исполнения вызывающего равным значению I<persona>. Если значение I<persona> равно 0xffffffff, то возвращается текущую специализацию (persona) не изменяя её."

#. type: Plain text
#: man-pages/man2/personality.2:62
msgid ""
"A list of the available execution domains can be found in "
"I<E<lt>sys/personality.hE<gt>>."
msgstr "Список доступных доменов исполнения можно найти в I<E<lt>sys/personality.hE<gt>>."

#. type: Plain text
#: man-pages/man2/personality.2:69
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr "При нормальном завершении работы возвращается предыдущее значение I<persona>. При ошибке возвращается -1, а переменная I<errno>, устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/personality.2:73
msgid "The kernel was unable to change the personality."
msgstr "Ядру не удалось изменить специализацию."

#. type: Plain text
#: man-pages/man2/personality.2:76
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr "Вызов B<personality>() есть только в Linux, и он не должен использоваться в переносимых программах."

#. type: TH
#: man-pages/man2/pread.2:25
#, no-wrap
msgid "PREAD"
msgstr "PREAD"

#. type: TH
#: man-pages/man2/pread.2:25
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: man-pages/man2/pread.2:28
msgid ""
"pread, pwrite - read from or write to a file descriptor at a given offset"
msgstr "pread, pwrite - чтение или запись информации из файлового дескриптора согласно заданному смещению"

#. type: Plain text
#: man-pages/man2/pread.2:33
msgid ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"
msgstr "B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t >I<offset>B<);>"

#. type: Plain text
#: man-pages/man2/pread.2:36
msgid ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"
msgstr "B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, off_t >I<offset>B<);>"

#. type: Plain text
#: man-pages/man2/pread.2:46
msgid "B<pread>(), B<pwrite>():"
msgstr "B<pread>(), B<pwrite>():"

#. type: Plain text
#: man-pages/man2/pread.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man2/pread.2:50
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man2/pread.2:64
msgid ""
"B<pread>()  reads up to I<count> bytes from file descriptor I<fd> at offset "
"I<offset> (from the start of the file) into the buffer starting at I<buf>.  "
"The file offset is not changed."
msgstr "B<pread>() читает максимум I<count> байтов из файлового дескриптора I<fd>, начиная со смещения I<offset> (от начала файла), в буфер, начиная с I<buf>. Текущая позиция файла не изменяется."

#. type: Plain text
#: man-pages/man2/pread.2:75
msgid ""
"B<pwrite>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file descriptor I<fd> at offset I<offset>.  The file offset is not "
"changed."
msgstr "B<pwrite>() записывает максимум I<count> байтов из буфера I<buf> в файловый дескриптор I<fd> , начиная со смещения I<offset>. Текущая позиция файла не изменяется."

#. type: Plain text
#: man-pages/man2/pread.2:79
msgid "The file referenced by I<fd> must be capable of seeking."
msgstr "Файл, заданный в I<fd>, должен позволять изменение смещения."

#. type: Plain text
#: man-pages/man2/pread.2:89
msgid ""
"On success, the number of bytes read or written is returned (zero indicates "
"that nothing was written, in the case of B<pwrite>(), or end of file, in the"
" case of B<pread>()), or -1 on error, in which case I<errno> is set to "
"indicate the error."
msgstr "При удачном завершении вызова возвращается количество прочитанных или записанных байтов (0 в случае выполнения функции B<pwrite>() означает, что никакой информации не было записано, а в случае выполнения функции B<pread>() означает конец файла). При ошибке возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/pread.2:104
msgid ""
"B<pread>()  can fail and set I<errno> to any error specified for B<read>(2)"
"  or B<lseek>(2).  B<pwrite>()  can fail and set I<errno> to any error "
"specified for B<write>(2)  or B<lseek>(2)."
msgstr "Вызов B<pread>() может завершиться неудачно и записать в I<errno> один из кодов ошибки, определённых для B<read>(2) или B<lseek>(2). Вызов B<pwrite>() может завершиться неудачно и записать в I<errno> один из кодов ошибки, определённых для B<write>(2) или B<lseek>(2)."

#. type: Plain text
#: man-pages/man2/pread.2:115
msgid ""
"The B<pread>()  and B<pwrite>()  system calls were added to Linux in version"
" 2.1.60; the entries in the i386 system call table were added in 2.1.69.  C "
"library support (including emulation using B<lseek>(2)  on older kernels "
"without the system calls) was added in glibc 2.1."
msgstr "Системные вызовы B<pread>() и B<pwrite>() были внесены в ядро Linux, начиная с версии 2.1.60; как элементы таблицы системных вызовов i386 были добавлены в ядро версии 2.1.69. Поддержка в библиотеке С (включая эмуляцию с помощью B<lseek>(2) в старых ядрах, не имеющих соответствующих системных вызовов) была добавлена в glibc 2.1."

#. type: Plain text
#: man-pages/man2/pread.2:117
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/pread.2:125
msgid ""
"The B<pread>()  and B<pwrite>()  system calls are especially useful in "
"multithreaded applications.  They allow multiple threads to perform I/O on "
"the same file descriptor without being affected by changes to the file "
"offset by other threads."
msgstr "Системные вызовы B<pread>() и B<pwrite>()  особенно полезны в многонитиевых приложениях. Они позволяют нескольким нитям выполнять ввод-вывод в один файловый дескриптор не учитывая изменений файлового смещения, сделанного другими нитями."

#. type: Plain text
#: man-pages/man2/pread.2:141
msgid ""
"On Linux, the underlying system calls were renamed in kernel 2.6: B<pread>()"
"  became B<pread64>(), and B<pwrite>()  became B<pwrite64>().  The system "
"call numbers remained the same.  The glibc B<pread>()  and B<pwrite>()  "
"wrapper functions transparently deal with the change."
msgstr "В Linux нижележащие системные вызовы переименованы в ядре версии 2.6: B<pread>() стал называться B<pread64>(), а B<pwrite>() \\(em B<pwrite64>(). Номера системных вызовов остались прежними. Обёрточные функции B<pread>() и B<pwrite>() в glibc скрывают данные переименование."

#. type: Plain text
#: man-pages/man2/pread.2:146
msgid ""
"On some 32-bit architectures, the calling signature for these system calls "
"differ, for the reasons described in B<syscall>(2)."
msgstr "На некоторых 32-битных архитектурах интерфейс этих системных вызовов отличается от описанного выше, по причинам указанным в B<syscall>(2)."

#.  FIXME https://bugzilla.kernel.org/show_bug.cgi?id=43178
#. type: Plain text
#: man-pages/man2/pread.2:158
msgid ""
"POSIX requires that opening a file with the B<O_APPEND> flag should have no "
"affect on the location at which B<pwrite>()  writes data.  However, on "
"Linux, if a file is opened with B<O_APPEND>, B<pwrite>()  appends data to "
"the end of the file, regardless of the value of I<offset>."
msgstr "Согласно POSIX требуется, чтобы открытие файла с флагом B<O_APPEND> не влияло на расположение, по которому B<pwrite>() записывает данные. Однако в Linux, если файл открывается с флагом B<O_APPEND>, B<pwrite>() добавляет данные в конец файла, независимо от значения I<offset>."

#. type: Plain text
#: man-pages/man2/pread.2:162
msgid "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"
msgstr "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"

#. type: TH
#: man-pages/man2/prctl.2:52
#, no-wrap
msgid "PRCTL"
msgstr "PRCTL"

#. type: TH
#: man-pages/man2/prctl.2:52
#, no-wrap
msgid "2014-04-14"
msgstr "2014-04-14"

#. type: Plain text
#: man-pages/man2/prctl.2:55
msgid "prctl - operations on a process"
msgstr "prctl - операции над процессом"

#. type: Plain text
#: man-pages/man2/prctl.2:58
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/prctl.2:61
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr "B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\nB<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"

#. type: Plain text
#: man-pages/man2/prctl.2:68
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr "Первый аргумент B<prctl>() задаёт тип операции (типы определены в I<E<lt>linux/prctl.hE<gt>>, значения остальных аргументов зависят от указываемого типа. Первый аргумент может принимать следующие значения:"

#. type: TP
#: man-pages/man2/prctl.2:68
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_READ> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man2/prctl.2:80
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to"
" B<execve>(2)."
msgstr "Возвращает 1 (как результат функции), если мандат, указанный в I<arg2>, есть в списке мандатов вызывающей нити (capability bounding set), или 0, если нет. Константы мандатов определены в I<E<lt>linux/capability.hE<gt>>. Значениями списка мандатов определяется, может ли процесс получить мандат через установку набора файловых прав при последующем вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:85
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr "Если мандат, указанный в I<arg2>, некорректен, то вызов завершится с ошибкой B<EINVAL>."

#. type: TP
#: man-pages/man2/prctl.2:85
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_DROP> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man2/prctl.2:94
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability, then drop the "
"capability specified by I<arg2> from the calling thread's capability "
"bounding set.  Any children of the calling thread will inherit the newly "
"reduced bounding set."
msgstr "Если вызывающая нить имеет мандат B<CAP_SETPCAP>, то мандат, указанный в I<arg2>, удаляется из списка мандатов вызывающей нити. Любой потомок вызывающей нити унаследует новый сокращённый список мандатов."

#. type: Plain text
#: man-pages/man2/prctl.2:106
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel,"
" in which case bounding sets are not supported."
msgstr "Вызов завершается с ошибками: B<EPERM>, если вызывающая нить не имеет мандата B<CAP_SETPCAP>; B<EINVAL>, если в I<arg2> указан недопустимый мандат; B<EINVAL>, если файловые мандаты не включены в ядре, в этом случае списки мандатов не поддерживаются."

#. type: TP
#: man-pages/man2/prctl.2:106
#, no-wrap
msgid "B<PR_SET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr "B<PR_SET_CHILD_SUBREAPER> (начиная с Linux 3.4)"

#.  commit ebec18a6d3aa1e7d84aab16225e87fd25170ec2b
#. type: Plain text
#: man-pages/man2/prctl.2:131
msgid ""
"If I<arg2> is nonzero, set the \"child subreaper\" attribute of the calling "
"process; if I<arg2> is zero, unset the attribute.  When a process is marked "
"as a child subreaper, all of the children that it creates, and their "
"descendants, will be marked as having a subreaper.  In effect, a subreaper "
"fulfills the role of B<init>(1)  for its descendant processes.  Upon "
"termination of a process that is orphaned (i.e., its immediate parent has "
"already terminated)  and marked as having a subreaper, the nearest still "
"living ancestor subreaper will receive a B<SIGCHLD> signal and be able to "
"B<wait>(2)  on the process to discover its termination status."
msgstr "Если значение I<arg2> не равно 0, устанавливает атрибут «сборщика потомков» (child subreaper) в вызвавшем процессе; если значение I<arg2> равно 0, то удаляет атрибут. Если процесс помечен как сборщик потомков, то все его потомки и их потомки, будут помечены как имеющие сборщик. Фактически, сборщик выполняет роль B<init>(1) для этих потомков. При завершении осиротевшего процесса (т.е. прямой предок уже завершил выполнение), который был помечен как имеющий сборщика, ближайший действующий сборщик-предок получит сигнал B<SIGCHLD> и может запустить B<wait>(2) для получения состояния завершения потомка."

#. type: TP
#: man-pages/man2/prctl.2:131
#, no-wrap
msgid "B<PR_GET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr "B<PR_GET_CHILD_SUBREAPER> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/prctl.2:136
msgid ""
"Return the \"child subreaper\" setting of the caller, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr "Возвращает значение атрибута «сборщика потомков» вызывающего в расположение, указанное I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:136
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_SET_DUMPABLE> (начиная с Linux 2.3.20)"

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: man-pages/man2/prctl.2:162
msgid ""
"Set the state of the flag determining whether core dumps are produced for "
"the calling process upon delivery of a signal whose default behavior is to "
"produce a core dump.  (Normally, this flag is set for a process by default, "
"but it is cleared when a set-user-ID or set-group-ID program is executed and"
" also by various system calls that manipulate process UIDs and GIDs).  In "
"kernels up to and including 2.6.12, I<arg2> must be either 0 (process is not"
" dumpable) or 1 (process is dumpable).  Between kernels 2.6.13 and 2.6.17, "
"the value 2 was also permitted, which caused any binary which normally would"
" not be dumped to be dumped readable by root only; for security reasons, "
"this feature has been removed.  (See also the description of "
"I</proc/sys/fs/suid_dumpable> in B<proc>(5).)  Processes that are not "
"dumpable can not be attached via B<ptrace>(2)  B<PTRACE_ATTACH>."
msgstr "Устанавливает флаг, определяющий, будет ли создан файл core для вызывающего процесса после доставки сигнала, при появлении которого по умолчанию создаётся файл core. Обычно, этот флаг устанавливается для процесса по умолчанию, но он очищается выполнении программ с set-UID или set-GID битами, а также разными системными вызовами, изменяющими идентификаторы UID и GID. В ядрах до версии 2.6.12 включительно значение I<arg2> должно быть или 0 (для процесса невозможен дамп) или 1 (для процесс возможен дамп). В ядрах с версии 2.6.13 до 2.6.17 допустимо также значение 2, которое означает, что для любого исполняемого файла, для которого обычно дамп невозможен, будет выполняться дамп, доступный на чтение только root; для повышения безопасности эта возможность была удалена (смотрите также описание I</proc/sys/fs/suid_dumpable> в B<proc>(5)). К процессам, для которых сделать дамп невозможно, с помощью B<ptrace>(2) B<PTRACE_ATTACH> подключиться нельзя."

#. type: TP
#: man-pages/man2/prctl.2:162
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_GET_DUMPABLE> (начиная с Linux 2.3.20)"

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#. type: Plain text
#: man-pages/man2/prctl.2:169
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable flag."
msgstr "Возвращает (как результат функции) текущее состояние флага дампа вызывающего процесса."

#. type: TP
#: man-pages/man2/prctl.2:169
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_SET_ENDIAN> (начиная с Linux 2.6.18, только для PowerPC)"

#.  Respectively 0, 1, 2
#. type: Plain text
#: man-pages/man2/prctl.2:179
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>,"
" or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr "Устанавливает порядок байт вызывающего процесса равным значению I<arg2>, которое может быть одним из: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE> или B<PR_ENDIAN_PPC_LITTLE> (для PowerPC псевдо обратный порядок (pseudo little endian))."

#. type: TP
#: man-pages/man2/prctl.2:179
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_GET_ENDIAN> (начиная с Linux 2.6.18, только для PowerPC)"

#. type: Plain text
#: man-pages/man2/prctl.2:184
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by"
" I<(int\\ *) arg2>."
msgstr "Записывает значение порядка байт вызывающего процесса по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:184
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_SET_FPEMU> (начиная с Linux 2.4.18, 2.5.9, только для ia64)"

#. type: Plain text
#: man-pages/man2/prctl.2:191
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate fp operations accesses, or "
"B<PR_FPEMU_SIGFPE> to not emulate fp operations and send B<SIGFPE> instead."
msgstr "Устанавливает значение управляющих эмуляцией плавающей точки бит равным значению I<arg2>. Для негласной (silently) эмуляции операций с плавающей точкой передайте B<PR_FPEMU_NOPRINT> или B<PR_FPEMU_SIGFPE>, чтобы операции с плавающей точкой не эмулировались, а посылался сигнал B<SIGFPE>."

#. type: TP
#: man-pages/man2/prctl.2:191
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_GET_FPEMU> (начиная с Linux 2.4.18, 2.5.9, только для ia64)"

#. type: Plain text
#: man-pages/man2/prctl.2:196
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr "Записывает значение управляющих бит эмуляции плавающей точки по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:196
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_SET_FPEXC> (начиная с Linux 2.4.21, 2.5.32, только для PowerPC)"

#. type: Plain text
#: man-pages/man2/prctl.2:209
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for "
"floating-point inexact result, B<PR_FP_EXC_INV> for floating-point invalid "
"operation, B<PR_FP_EXC_DISABLED> for FP exceptions disabled, "
"B<PR_FP_EXC_NONRECOV> for async nonrecoverable exception mode, "
"B<PR_FP_EXC_ASYNC> for async recoverable exception mode, "
"B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr "Устанавливает режим исключений плавающей точки равным I<arg2>. Значение B<PR_FP_EXC_SW_ENABLE> включает использование FPEXC для исключений плавающей точки, B<PR_FP_EXC_DIV> \\(em исключение деления на ноль, B<PR_FP_EXC_OVF> \\(em исключение переполнения, B<PR_FP_EXC_UND> \\(em исключение переполнение минимального значения, B<PR_FP_EXC_RES> \\(em исключение неточного результата, B<PR_FP_EXC_INV> \\(em исключение недопустимой операции, B<PR_FP_EXC_DISABLED> отключает исключения плавающей точки, B<PR_FP_EXC_NONRECOV> включает режим асинхронного невосстанавливаемого исключения, B<PR_FP_EXC_ASYNC> включает режим асинхронного восстанавливаемого исключения, B<PR_FP_EXC_PRECISE> включает режим исключения точности."

#. type: TP
#: man-pages/man2/prctl.2:209
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_GET_FPEXC> (начиная с Linux 2.4.21, 2.5.32, только для PowerPC)"

#. type: Plain text
#: man-pages/man2/prctl.2:214
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\"
" *) arg2>."
msgstr "Записывает значение режима исключений плавающей точки по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:214
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_SET_KEEPCAPS> (начиная с Linux 2.2.18)"

#. type: Plain text
#: man-pages/man2/prctl.2:232
msgid ""
"Set the state of the thread's \"keep capabilities\" flag, which determines "
"whether the threads's permitted capability set is cleared when a change is "
"made to the threads's user IDs such that the threads's real UID, effective "
"UID, and saved set-user-ID all become nonzero when at least one of them "
"previously had the value 0.  By default, the permitted capability set is "
"cleared when such a change is made; setting the \"keep capabilities\" flag "
"prevents it from being cleared.  I<arg2> must be either 0 (permitted "
"capabilities are cleared)  or 1 (permitted capabilities are kept).  (A "
"thread's I<effective> capability set is always cleared when such a "
"credential change is made, regardless of the setting of the \"keep "
"capabilities\" flag.)  The \"keep capabilities\" value will be reset to 0 on"
" subsequent calls to B<execve>(2)."
msgstr "Устанавливает флаг нити «оставить мандаты», который определяет, будет ли список разрешённых мандатов нити очищен при изменении пользовательского идентификатора нити таким образом, что сохранённый, действующий и действительный идентификаторы станут ненулевыми, если при этом хотя бы один из них ранее был равен нулю. По умолчанию, список разрешённых мандатов очищается, когда происходит такое изменение; установка флага «оставить мандаты» отменяет очистку. Значение I<arg2> должно быть или 0 (мандаты очищаются) или 1 (мандаты сохраняются). (I<Эффективный> список мандатов всегда очищается при таких изменениях данных, независимо от значения флага «оставить мандаты».) Значение флага «оставить мандаты» будет сброшено в 0 при последующих вызовах B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:232
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_GET_KEEPCAPS> (начиная с Linux 2.2.18)"

#. type: Plain text
#: man-pages/man2/prctl.2:236
msgid ""
"Return (as the function result) the current state of the calling threads's "
"\"keep capabilities\" flag."
msgstr "Возвращает (как результат функции) текущее состояние флага «оставить мандаты» вызывающего процесса."

#. type: TP
#: man-pages/man2/prctl.2:236
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr "B<PR_SET_NAME> (начиная с Linux 2.6.9)"

#.  TASK_COMM_LEN in include/linux/sched.h
#. type: Plain text
#: man-pages/man2/prctl.2:253
msgid ""
"Set the name of the calling thread, using the value in the location pointed "
"to by I<(char\\ *) arg2>.  The name can be up to 16 bytes long, and should "
"be null-terminated if it contains fewer bytes.  This is the same attribute "
"that can be set via B<pthread_setname_np>(3)  and retrieved using "
"B<pthread_getname_np>(3).  The attribute is likewise accessible via "
"I</proc/self/task/[tid]/comm>, where I<tid> is the name of the calling "
"thread."
msgstr "Устанавливает имя вызывающей нити, используя значение, на которое указывает I<(char\\ *) arg2>. Длина имени может быть до 16 байт и имя должно завершаться null, если содержит меньшее количество байт. Этот же атрибут может быть задан с помощью B<pthread_setname_np>(3) и получен с помощью B<pthread_getname_np>(3). Также атрибут доступен через I</proc/self/task/[tid]/comm>, где I<tid> — имя вызывающей нити."

#. type: TP
#: man-pages/man2/prctl.2:253
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr "B<PR_GET_NAME> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man2/prctl.2:260
msgid ""
"Return the name of the calling thread, in the buffer pointed to by I<(char\\"
" *) arg2>.  The buffer should allow space for up to 16 bytes; the returned "
"string will be null-terminated if it is shorter than that."
msgstr "Записывает имя вызывающей нити в буфер, указанный в I<(char\\ *) arg2>. Буфер должен быть не менее 16 байт; полученная строка будет завершаться null, если она короче данного размера."

#. type: TP
#: man-pages/man2/prctl.2:260
#, no-wrap
msgid "B<PR_SET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr "B<PR_SET_NO_NEW_PRIVS> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/prctl.2:283
msgid ""
"Set the calling process's I<no_new_privs> bit to the value in I<arg2>.  With"
" I<no_new_privs> set to 1, B<execve>(2)  promises not to grant privileges to"
" do anything that could not have been done without the B<execve>(2)  call "
"(for example, rendering the set-user-ID and set-group-ID permission bits, "
"and file capabilities non-functional).  Once set, this bit cannot be unset."
"  The setting of this bit is inherited by children created by B<fork>(2)  "
"and B<clone>(2), and preserved across B<execve>(2)."
msgstr "Устанавливает в вызывающем процессе бит I<no_new_privs> равным I<arg2>. Если значение I<no_new_privs> равно 1, то B<execve>(2) не выдаст прав никому, кто бы не мог это сделать без вызова B<execve>(2) (например, без битов прав выполнения set-user-ID и set-group-ID и файловых мандатов). После того, как бит установлен, сбросить его нельзя. Значение бита наследуется потомками, созданными с помощью B<fork>(2) и B<clone>(2), и сохраняется при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:286
msgid ""
"For more information, see the kernel source file "
"I<Documentation/prctl/no_new_privs.txt>."
msgstr "Дополнительную информацию смотрите в файле исходного кода ядра I<Documentation/prctl/no_new_privs.txt>."

#. type: TP
#: man-pages/man2/prctl.2:286
#, no-wrap
msgid "B<PR_GET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr "B<PR_GET_NO_NEW_PRIVS> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/prctl.2:297
msgid ""
"Return (as the function result) the value of the I<no_new_privs> bit for the"
" current process.  A value of 0 indicates the regular B<execve>(2)  "
"behavior.  A value of 1 indicates B<execve>(2)  will operate in the "
"privilege-restricting mode described above."
msgstr "Возвращает значение (как результат функции) бита I<no_new_privs> в текущем процессе. Значение 0 соответствует обычному поведению B<execve>(2). Значение 1 показывает, что B<execve>(2) будет работать в ограничивающем права режиме, как описано ранее."

#. type: TP
#: man-pages/man2/prctl.2:297
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr "B<PR_SET_PDEATHSIG> (начиная с Linux 2.1.57)"

#. type: Plain text
#: man-pages/man2/prctl.2:310
msgid ""
"Set the parent process death signal of the calling process to I<arg2> "
"(either a signal value in the range 1..maxsig, or 0 to clear).  This is the "
"signal that the calling process will get when its parent dies.  This value "
"is cleared for the child of a B<fork>(2)  and (since Linux 2.4.36 / 2.6.23)"
"  when executing a set-user-ID or set-group-ID binary.  This value is "
"preserved across B<execve>(2)."
msgstr "Устанавливает значение сигнала, приходящего процессу при завершении работы родительского процесса, равным I<arg2> (это значение может быть от 1..maxsig или 0 для снятия). Этот сигнал получит вызывающий процесс, когда его родитель завершится. Это значение очищается у потомка при выполнении B<fork>(2) и (начиная с Linux 2.4.36 / 2.6.23), если выполняется файл с установленным битом set-user-ID или set-group-ID. Это значение сохраняется после вызова B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:310
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr "B<PR_GET_PDEATHSIG> (начиная с Linux 2.3.15)"

#. type: Plain text
#: man-pages/man2/prctl.2:315
msgid ""
"Return the current value of the parent process death signal, in the location"
" pointed to by I<(int\\ *) arg2>."
msgstr "Записывает текущее значение сигнала о завершении работы родительского процесса по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:315
#, no-wrap
msgid "B<PR_SET_PTRACER> (since Linux 3.4)"
msgstr "B<PR_SET_PTRACER> (начиная с Linux 3.4)"

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#.  commit bf06189e4d14641c0148bea16e9dd24943862215
#. type: Plain text
#: man-pages/man2/prctl.2:340
msgid ""
"This is meaningful only when the Yama LSM is enabled and in mode 1 "
"(\"restricted ptrace\", visible via I</proc/sys/kernel/yama/ptrace_scope>)."
"  When a \"ptracer process ID\" is passed in I<arg2>, the caller is "
"declaring that the ptracer process can B<ptrace>(2)  the calling process as "
"if it were a direct process ancestor.  Each B<PR_SET_PTRACER> operation "
"replaces the previous \"ptracer process ID\".  Employing B<PR_SET_PTRACER> "
"with I<arg2> set to 0 clears the caller's \"ptracer process ID\".  If "
"I<arg2> is B<PR_SET_PTRACER_ANY>, the ptrace restrictions introduced by Yama"
" are effectively disabled for the calling process."
msgstr "Имеет смысл, только если включён Yama LSM и в режиме 1 («ограниченный ptrace», значение доступно в I</proc/sys/kernel/yama/ptrace_scope>). Когда «идентификатор процесса ptracer» передаётся в I<arg2>, вызывающий объявляет, что процесс ptracer может выполнить B<ptrace>(2), как если бы он был прямым предком процесса. Каждая операция B<PR_SET_PTRACER> заменяет предыдущий «идентификатор процесса ptracer». Применение B<PR_SET_PTRACER> с значением I<arg2> равным 0 очищает «идентификатор процесса ptracer» вызывающего. Если I<arg2> равно B<PR_SET_PTRACER_ANY>, то ограничения ptrace, предоставленные Yama отключаются для вызывающего процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:343
msgid ""
"For further information, see the kernel source file "
"I<Documentation/security/Yama.txt>."
msgstr "Дополнительную информацию смотрите в файле исходного кода ядра I<Documentation/security/Yama.txt>."

#. type: TP
#: man-pages/man2/prctl.2:343
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_SET_SECCOMP> (начиная с Linux 2.6.23)"

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: man-pages/man2/prctl.2:354
msgid ""
"Set the secure computing (seccomp) mode for the calling thread, to limit the"
" available system calls.  The seccomp mode is selected via I<arg2>.  (The "
"seccomp constants are defined in I<E<lt>linux/seccomp.hE<gt>>.)"
msgstr "Устанавливает режим безопасных вычислений (seccomp) в вызывающей нити, в котором ограничен список доступных системных вызовов. Режим seccomp выбирается из I<arg2> (константы seccomp определены в I<E<lt>linux/seccomp.hE<gt>>)."

#. type: Plain text
#: man-pages/man2/prctl.2:375
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_STRICT> the only system calls that the "
"thread is permitted to make are B<read>(2), B<write>(2), B<_exit>(2), and "
"B<sigreturn>(2).  Other system calls result in the delivery of a B<SIGKILL> "
"signal.  Strict secure computing mode is useful for number-crunching "
"applications that may need to execute untrusted byte code, perhaps obtained "
"by reading from a pipe or socket.  This operation is available only if the "
"kernel is configured with B<CONFIG_SECCOMP> enabled."
msgstr "Если значение I<arg2> равно B<SECCOMP_MODE_STRICT>, то в нити доступны только системные вызовы B<read>(2), B<write>(2), B<_exit>(2) и B<sigreturn>(2). При запуске других системных вызовов генерируется сигнал B<SIGKILL>. Режим безопасных вычислений полезен для вычислительных приложений, которым может потребоваться выполнить недоверительный байт-код, возможно полученный при чтении из канала или сокета. Эта операция доступна только, если в ядре включён параметр B<CONFIG_SECCOMP>."

#. type: Plain text
#: man-pages/man2/prctl.2:390
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_FILTER> (since Linux 3.5)  the system "
"calls allowed are defined by a pointer to a Berkeley Packet Filter passed in"
" I<arg3>.  This argument is a pointer to I<struct sock_fprog>; it can be "
"designed to filter arbitrary system calls and system call arguments.  This "
"mode is available only if the kernel is configured with "
"B<CONFIG_SECCOMP_FILTER> enabled."
msgstr "Если значение I<arg2> равно B<SECCOMP_MODE_FILTER> (начиная с Linux 3.5), то список разрешённых системных вызовов определяется указателем (I<arg3>) на пакетный фильтр Berkeley. Аргумент указывает на I<struct sock_fprog>; в структуре можно описать фильтр и произвольных системных вызовов и их аргументов. Этот режим доступен только, если ядро собрано с параметром B<CONFIG_SECCOMP_FILTER>."

#. type: Plain text
#: man-pages/man2/prctl.2:405
msgid ""
"If B<SECCOMP_MODE_FILTER> filters permit B<fork>(2), then the seccomp mode "
"is inherited by children created by B<fork>(2); if B<execve>(2)  is "
"permitted, then the seccomp mode is preserved across B<execve>(2).  If the "
"filters permit B<prctl>()  calls, then additional filters can be added; they"
" are run in order until the first non-allow result is seen."
msgstr "Если в фильтрах B<SECCOMP_MODE_FILTER> разрешён B<fork>(2), то режим seccomp наследуется потомками, создаваемыми B<fork>(2); если разрешён B<execve>(2), то режим seccomp сохраняется при B<execve>(2). Если в фильтрах разрешены B<prctl>(), то могут быть добавлены дополнительные фильтры; они применяются до тех пор пока не будет найдено запрещение."

#. type: Plain text
#: man-pages/man2/prctl.2:408
msgid ""
"For further information, see the kernel source file "
"I<Documentation/prctl/seccomp_filter.txt>."
msgstr "Дополнительную информацию смотрите в файле исходного кода ядра I<Documentation/prctl/seccomp_filter.txt>."

#. type: TP
#: man-pages/man2/prctl.2:408
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_GET_SECCOMP> (начиная с Linux 2.6.23)"

#. type: Plain text
#: man-pages/man2/prctl.2:424
msgid ""
"Return (as the function result)  the secure computing mode of the calling "
"thread.  If the caller is not in secure computing mode, this operation "
"returns 0; if the caller is in strict secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"If the caller is in filter mode, and this system call is allowed by the "
"seccomp filters, it returns 2.  This operation is available only if the "
"kernel is configured with B<CONFIG_SECCOMP> enabled."
msgstr "Возвращает значение (как результат функции) режима безопасных вычислений вызвавшей нити. Если вызывающий не работает в режиме безопасных вычислений, то возвращается 0; если вызывающий находится в режиме ограниченных безопасных вычислений, то вызов B<prctl>() приведёт к отправке процессу сигнала B<SIGKILL>. Если вызывающий работает в режиме фильтрации и данный системный вызов разрешён в фильтрах seccomp, то возвращается 2. Эта операция доступна только, если ядро собрано с параметром B<CONFIG_SECCOMP>."

#. type: TP
#: man-pages/man2/prctl.2:424
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_SET_SECUREBITS> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/prctl.2:430
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr "Устанавливает значение флагов «securebits» вызывающей нити равным значению I<arg2>. Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man2/prctl.2:430
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_GET_SECUREBITS> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/prctl.2:436
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr "Возвращает (как результат функции) флаги «securebits» вызывающей нити. Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man2/prctl.2:436
#, no-wrap
msgid "B<PR_SET_THP_DISABLE> (since Linux 3.15)"
msgstr "B<PR_SET_THP_DISABLE> (начиная с Linux 3.15)"

#.  commit a0715cc22601e8830ace98366c0c2bd8da52af52
#. type: Plain text
#: man-pages/man2/prctl.2:452
msgid ""
"Set the state of the \"THP disable\" flag for the calling thread.  If "
"I<arg2> has a nonzero value, the flag is set, otherwise it is cleared.  "
"Setting this flag provides a method for disabling transparent huge pages for"
" jobs where the code cannot be modified, and using a malloc hook with "
"B<madvise>(2)  is not an option (i.e., statically allocated data).  The "
"setting of the \"THP disable\" flag is inherited by a child created via "
"B<fork>(2)  and is preserved across B<execve>(2)."
msgstr "Задать состояние флага «THP disable» вызывающей нити. Если I<arg2> не равно нулю, то флаг устанавливается, иначе очищается. Установка этого флага предоставляет метод отключения прозрачных огромных страниц для заданий, код которых нельзя изменить и использование обработчика malloc с B<madvise>(2) невозможно (т. е., место под данные выделено статически). Значение флага «THP disable» наследуется потомком, создаваемым B<fork>(2) и сохраняется после B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:452
#, no-wrap
msgid "B<PR_GET_THP_DISABLE> (since Linux 3.15)"
msgstr "B<PR_GET_THP_DISABLE> (начиная с Linux 3.15)"

#. type: Plain text
#: man-pages/man2/prctl.2:457
msgid ""
"Return (via the function result) the current setting of the \"THP disable\" "
"flag for the calling thread: either 1, if the flag is set, or 0, if it is "
"not."
msgstr "Возвращает текущее значение (как результат функции) флага «THP disable» вызывающей нити: 1 — флаг установлен; 0 — нет."

#. type: TP
#: man-pages/man2/prctl.2:457
#, no-wrap
msgid "B<PR_GET_TID_ADDRESS> (since Linux 3.5)"
msgstr "B<PR_GET_TID_ADDRESS> (начиная с Linux 3.5)"

#.  commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
#. type: Plain text
#: man-pages/man2/prctl.2:472
msgid ""
"Retrieve the I<clear_child_tid> address set by B<set_tid_address>(2)  and "
"the B<clone>(2)  B<CLONE_CHILD_CLEARTID> flag, in the location pointed to by"
" I<(int\\ **)\\ arg2>.  This feature is available only if the kernel is "
"built with the B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr "Возвращает адрес I<clear_child_tid>, заданный B<set_tid_address>(2) и B<clone>(2) с флагом B<CLONE_CHILD_CLEARTID>, в расположение, указанное в I<(int\\ **)\\ arg2>. Эта возможность доступна только, если ядро собрано с параметром B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man2/prctl.2:472
#, no-wrap
msgid "B<PR_SET_TIMERSLACK> (since Linux 2.6.28)"
msgstr "B<PR_SET_TIMERSLACK> (начиная с Linux 2.6.28)"

#.  See https://lwn.net/Articles/369549/
#.  commit 6976675d94042fbd446231d1bd8b7de71a980ada
#.  It seems that it's not possible to set the timer slack to zero;
#.  The minimum value is 1? Seems a little strange.
#. type: Plain text
#: man-pages/man2/prctl.2:491
msgid ""
"Set the current timer slack for the calling thread to the nanosecond value "
"supplied in I<arg2>.  If I<arg2> is less than or equal to zero, reset the "
"current timer slack to the thread's default timer slack value.  The timer "
"slack is used by the kernel to group timer expirations for the calling "
"thread that are close to one another; as a consequence, timer expirations "
"for the thread may be up to the specified number of nanoseconds late (but "
"will never expire early).  Grouping timer expirations can help reduce system"
" power consumption by minimizing CPU wake-ups."
msgstr "Устанавливает допуск текущего таймера вызывающей нити в наносекундное значение из I<arg2>. Если I<arg2> меньше или равно 0, то допуск допуск текущего таймера нити сбрасывается в значение допуска таймера по умолчанию. Допуск таймера используется ядром для группировки таймерных окончаний при вызовах нити, которые происходят очень часто; как следствие, таймерные окончания нити могут быть равны до указанной наносекундной задержки (но никогда не будут истекать ранее). Группировка таймерных окончаний может помочь сократить потребление энергии системой, в следствии сокращения количества пробуждений ЦП."

#.  List obtained by grepping for futex usage in glibc source
#. type: Plain text
#: man-pages/man2/prctl.2:511
msgid ""
"The timer expirations affected by timer slack are those set by B<select>(2),"
" B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<clock_nanosleep>(2), B<nanosleep>(2), and B<futex>(2)  "
"(and thus the library functions implemented via futexes, including "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3), and "
"B<sem_timedwait>(3))."
msgstr "Таймерные окончания, на которые влияет допуск таймера, устанавливаются B<select>(2), B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), B<epoll_pwait>(2), B<clock_nanosleep>(2), B<nanosleep>(2) и B<futex>(2) (и, следовательно, все библиотечными функциями, реализованными через futex: B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3) и B<sem_timedwait>(3))."

#. type: Plain text
#: man-pages/man2/prctl.2:515
msgid ""
"Timer slack is not applied to threads that are scheduled under a real-time "
"scheduling policy (see B<sched_setscheduler>(2))."
msgstr "Допуск таймера не применяется к нитям, которые планируются в соответствии с политикой реального времени (смотрите B<sched_setscheduler>(2))."

#. type: Plain text
#: man-pages/man2/prctl.2:532
msgid ""
"Each thread has two associated timer slack values: a \"default\" value, and "
"a \"current\" value.  The current value is the one that governs grouping of "
"timer expirations.  When a new thread is created, the two timer slack values"
" are made the same as the current value of the creating thread.  Thereafter,"
" a thread can adjust its current timer slack value via B<PR_SET_TIMERSLACK> "
"(the default value can't be changed).  The timer slack values of I<init> "
"(PID 1), the ancestor of all processes, are 50,000 nanoseconds (50 "
"microseconds).  The timer slack values are preserved across B<execve>(2)."
msgstr "Для каждой нити есть два значения допуска таймера: значение «по умолчанию» и «текущее» значение. Текущим значением регулируется группировка таймерных окончаний. При создании новой нити этим двум значениям присваивается текущее значение создающей нити. are made the same as the current value of the creating thread. После этого нить может подстроить своё текущее значение допуска таймера с помощью B<PR_SET_TIMERSLACK> (значение по умолчанию не может быть изменено). Значения допуска таймера для I<init> (PID 1), предка всех процессов, равно 50000 наносекунд (50 микросекунд). Значения допуска таймера сохраняются при вызове B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:532
#, no-wrap
msgid "B<PR_GET_TIMERSLACK> (since Linux 2.6.28)"
msgstr "B<PR_GET_TIMERSLACK> (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man2/prctl.2:536
msgid ""
"Return (as the function result)  the current timer slack value of the "
"calling thread."
msgstr "Возвращает текущее значение (как результат функции) допуска таймера вызывающей нити."

#. type: TP
#: man-pages/man2/prctl.2:536
#, no-wrap
msgid "B<PR_SET_TIMING> (since Linux 2.6.0-test4)"
msgstr "B<PR_SET_TIMING> (начиная с Linux 2.6.0-test4)"

#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#. type: Plain text
#: man-pages/man2/prctl.2:553
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL>"
" or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr "Включает использование обычного статистического временного режима выполнения процесса (process timing) или точного режима на основе меток времени (timestamp-based process timing), при передаче B<PR_TIMING_STATISTICAL> или B<PR_TIMING_TIMESTAMP> в I<arg2>. Действия для B<PR_TIMING_TIMESTAMP> пока не реализованы (попытка установить этот режим приведёт к ошибке B<EINVAL>)."

#. type: TP
#: man-pages/man2/prctl.2:553
#, no-wrap
msgid "B<PR_GET_TIMING> (since Linux 2.6.0-test4)"
msgstr "B<PR_GET_TIMING> (начиная с Linux 2.6.0-test4)"

#. type: Plain text
#: man-pages/man2/prctl.2:557
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr "Возвращает (как результат функции) тип используемого в данный момент временного режима выполнения процесса."

#. type: TP
#: man-pages/man2/prctl.2:557
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_DISABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_DISABLE> (начиная с Linux 2.6.31)"

#. type: Plain text
#: man-pages/man2/prctl.2:566
msgid ""
"Disable all performance counters attached to the calling process, regardless"
" of whether the counters were created by this process or another process.  "
"Performance counters created by the calling process for other processes are "
"unaffected.  For more information on performance counters, see the Linux "
"kernel source file I<tools/perf/design.txt>."
msgstr "Отключает все счётчики производительности, прикреплённые к вызывающему процессу, не учитывая, были ли они созданы этим процессом или каким-то другим. Счётчики производительности, созданные вызывающим процессом для других процессов, не отключаются. Подробности о счётчиках производительности приведены в файле ядра Linux I<tools/perf/design.txt>."

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#. type: Plain text
#: man-pages/man2/prctl.2:572
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (with same "
"numerical value)  in Linux 2.6.32."
msgstr "Сначала назывался B<PR_TASK_PERF_COUNTERS_DISABLE>; переименован (с тем же числовым значением ) в Linux 2.6.32."

#. type: TP
#: man-pages/man2/prctl.2:572
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_ENABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_ENABLE> (начиная с Linux 2.6.31)"

#. type: Plain text
#: man-pages/man2/prctl.2:577
msgid ""
"The converse of B<PR_TASK_PERF_EVENTS_DISABLE>; enable performance counters "
"attached to the calling process."
msgstr "Противоположное действие B<PR_TASK_PERF_EVENTS_DISABLE>; включает счётчики производительности, прикреплённые к вызывающему процессу."

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: man-pages/man2/prctl.2:584
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_ENABLE>; renamed in Linux 2.6.32."
msgstr "Сначала назывался B<PR_TASK_PERF_COUNTERS_ENABLE>; переименован в Linux 2.6.32."

#. type: TP
#: man-pages/man2/prctl.2:584
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_SET_TSC> (начиная с Linux 2.6.26, только для x86)"

#. type: Plain text
#: man-pages/man2/prctl.2:597
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr "Устанавливает состояние флага, определяющего может ли процесс прочитать счётчик метки времени (timestamp counter). Значение B<PR_TSC_ENABLE> в I<arg2> разрешает чтение, B<PR_TSC_SIGSEGV> включает генерацию B<SIGSEGV>, если процесс пытается прочитать счётчик метки времени."

#. type: TP
#: man-pages/man2/prctl.2:597
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_GET_TSC> (начиная с Linux 2.6.26, только для x86)"

#. type: Plain text
#: man-pages/man2/prctl.2:603
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr "Записывает значение флага, определяющего может ли быть прочитан счётчик метки времени (timestamp counter), по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:603
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr "B<PR_SET_UNALIGN>"

#. type: Plain text
#: man-pages/man2/prctl.2:613
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22)  Set unaligned access control"
" bits to I<arg2>.  Pass B<PR_UNALIGN_NOPRINT> to silently fix up unaligned "
"user accesses, or B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned "
"user access."
msgstr "(только для: ia64, начиная с Linux 2.3.48; parisc, начиная с Linux 2.6.15; PowerPC, начиная с Linux 2.6.18; Alpha, начиная с Linux 2.6.22) Устанавливает значение битов контроля доступа выравнивания равным значению I<arg2>. При значении B<PR_UNALIGN_NOPRINT> пользовательский доступ без выравнивания негласно (silently) исправляется, а при B<PR_UNALIGN_SIGBUS> генерируется сигнал B<SIGBUS>."

#. type: TP
#: man-pages/man2/prctl.2:613
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr "B<PR_GET_UNALIGN>"

#. type: Plain text
#: man-pages/man2/prctl.2:620
msgid ""
"(see B<PR_SET_UNALIGN> for information on versions and architectures)  "
"Return unaligned access control bits, in the location pointed to by I<(int\\"
" *) arg2>."
msgstr "(информацию о версиях и архитектурах смотрите в B<PR_SET_UNALIGN>) Записывает значение битов контроля доступа выравнивания по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:620
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/prctl.2:660
msgid ""
"Set the machine check memory corruption kill policy for the current thread."
"  If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption "
"kill policy and use the system-wide default.  (The system-wide default is "
"defined by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If "
"I<arg2> is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill "
"policy.  In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the system-"
"wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the thread "
"receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is killed"
" only when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr "Устанавливает политику удаления (kill) при обнаружении повреждения памяти машинной проверкой для текущей нити. Если значение I<arg> равно B<PR_MCE_KILL_CLEAR>, то политика удаления (kill) сбрасывается и используется системная установка по умолчанию. (Значение системной установки по умолчанию определено в I</proc/sys/vm/memory_failure_early_kill>; смотрите B<proc>(5).) Значение I<arg2>, равное B<PR_MCE_KILL_SET>, указывает использовать политику удаления, заданную в нити. В этом случае значение I<arg3> определяет политику: I<раннее удаление> (B<PR_MCE_KILL_EARLY>), I<позднее удаление> (B<PR_MCE_KILL_LATE>) или системная установка по умолчанию (B<PR_MCE_KILL_DEFAULT>). При раннем удалении нить получает сигнал B<SIGBUS> сразу же при аппаратном обнаружении повреждения памяти в её адресном пространстве. В режиме позднего удаления процесс будет удалён только когда обратится к повреждённой странице. Более подробную информацию о сигнале B<SIGBUS> смотрите в I<sigaction(2)>. Политика наследуется потомками. Значения остальных неиспользуемых аргументов B<prctl>() должны быть равны нулю для совместимости в будущем."

#. type: TP
#: man-pages/man2/prctl.2:660
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL_GET> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/prctl.2:666
msgid ""
"Return the current per-process machine check kill policy.  All unused "
"B<prctl>()  arguments must be zero."
msgstr "Возвращает значение политики удаления при машинной проверке для текущего процесса. Значения всех неиспользуемых аргументов B<prctl>() должны быть равны нулю."

#. type: TP
#: man-pages/man2/prctl.2:666
#, no-wrap
msgid "B<PR_SET_MM> (since Linux 3.3)"
msgstr "B<PR_SET_MM> (начиная с Linux 3.3)"

#.  commit 028ee4be34a09a6d48bdf30ab991ae933a7bc036
#. type: Plain text
#: man-pages/man2/prctl.2:687
msgid ""
"Modify certain kernel memory map descriptor fields of the calling process.  "
"Usually these fields are set by the kernel and dynamic loader (see "
"B<ld.so>(8)  for more information) and a regular application should not use "
"this feature.  However, there are cases, such as self-modifying programs, "
"where a program might find it useful to change its own memory map.  This "
"feature is available only if the kernel is built with the "
"B<CONFIG_CHECKPOINT_RESTORE> option enabled.  The calling process must have "
"the B<CAP_SYS_RESOURCE> capability.  The value in I<arg2> is one of the "
"options below, while I<arg3> provides a new value for the option."
msgstr "Изменяет определённые поля дескриптора карты памяти ядра вызывающего процесса. Обычно, значения этих полей задаются ядром или динамическим загрузчиком (подробней см. B<ld.so>(8)), и обычные приложения не должны использовать эту возможность. Однако, есть случаи (самоизменяющиеся программы), где для программы может оказаться полезным изменение своей карты памяти. Данная возможность доступна только, если ядро собрано с параметром B<CONFIG_CHECKPOINT_RESTORE>. Вызывающий процесс должен иметь мандат B<CAP_SYS_RESOURCE>. Значения аргумента I<arg2> описаны далее, а в I<arg3> задаётся новое значение."

#. type: TP
#: man-pages/man2/prctl.2:688
#, no-wrap
msgid "B<PR_SET_MM_START_CODE>"
msgstr "B<PR_SET_MM_START_CODE>"

#. type: Plain text
#: man-pages/man2/prctl.2:697
msgid ""
"Set the address above which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or sharable "
"(see B<mprotect>(2)  and B<mmap>(2)  for more information)."
msgstr "Устанавливает адрес памяти, выше которого располагается код программы, который может выполняться. Соответствующая область памяти должна быть доступна на чтение и выполнение, но не на запись или быть общедоступной (подробности смотрите в B<mprotect>(2) и B<mmap>(2))."

#. type: TP
#: man-pages/man2/prctl.2:697
#, no-wrap
msgid "B<PR_SET_MM_END_CODE>"
msgstr "B<PR_SET_MM_END_CODE>"

#. type: Plain text
#: man-pages/man2/prctl.2:702
msgid ""
"Set the address below which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or sharable."
msgstr "Устанавливает адрес памяти, ниже которого располагается код программы, который может выполняться. Соответствующая область памяти должна быть доступна на чтение и выполнение, но не на запись или быть общедоступной."

#. type: TP
#: man-pages/man2/prctl.2:702
#, no-wrap
msgid "B<PR_SET_MM_START_DATA>"
msgstr "B<PR_SET_MM_START_DATA>"

#. type: Plain text
#: man-pages/man2/prctl.2:708
msgid ""
"Set the address above which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or sharable."
msgstr "Устанавливает адрес памяти, выше которого располагаются инициализированные и не инициализированные (bss) данные. Соответствующая область памяти должна быть доступна на чтение и запись, но не на выполнение или быть в общем доступе."

#. type: TP
#: man-pages/man2/prctl.2:708
#, no-wrap
msgid "B<PR_SET_MM_END_DATA>"
msgstr "B<PR_SET_MM_END_DATA>"

#. type: Plain text
#: man-pages/man2/prctl.2:714
msgid ""
"Set the address below which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or sharable."
msgstr "Устанавливает адрес памяти, ниже которого располагаются инициализированные и не инициализированные (bss) данные. Соответствующая область памяти должна быть доступна на чтение и запись, но не на выполнение или быть в общем доступе."

#. type: TP
#: man-pages/man2/prctl.2:714
#, no-wrap
msgid "B<PR_SET_MM_START_STACK>"
msgstr "B<PR_SET_MM_START_STACK>"

#. type: Plain text
#: man-pages/man2/prctl.2:718
msgid ""
"Set the start address of the stack.  The corresponding memory area must be "
"readable and writable."
msgstr "Устанавливает начальный адрес стека. Соответствующая область памяти должна быть доступна на чтение и запись."

#. type: TP
#: man-pages/man2/prctl.2:718
#, no-wrap
msgid "B<PR_SET_MM_START_BRK>"
msgstr "B<PR_SET_MM_START_BRK>"

#. type: Plain text
#: man-pages/man2/prctl.2:730
msgid ""
"Set the address above which the program heap can be expanded with B<brk>(2)"
"  call.  The address must be greater than the ending address of the current "
"program data segment.  In addition, the combined size of the resulting heap "
"and the size of the data segment can't exceed the B<RLIMIT_DATA> resource "
"limit (see B<setrlimit>(2))."
msgstr "Устанавливает адрес памяти, выше которого можно расширять программную кучу с помощью вызова B<brk>(2). Адрес должен быть больше конечного адреса текущего программного сегмента данных. Также, суммарный размер полученной кучи и сегмента данных не может превышать ограничитель ресурса B<RLIMIT_DATA> (смотрите B<setrlimit>(2))."

#. type: TP
#: man-pages/man2/prctl.2:730
#, no-wrap
msgid "B<PR_SET_MM_BRK>"
msgstr "B<PR_SET_MM_BRK>"

#. type: Plain text
#: man-pages/man2/prctl.2:738
msgid ""
"Set the current B<brk>(2)  value.  The requirements for the address are the "
"same as for the B<PR_SET_MM_START_BRK> option."
msgstr "Устанавливает текущее значение B<brk>(2). Требования к адресу те же, что и в параметре B<PR_SET_MM_START_BRK>."

#.  commit fe8c7f5cbf91124987106faa3bdf0c8b955c4cf7
#. type: Plain text
#: man-pages/man2/prctl.2:741
msgid "The following options are available since Linux 3.5."
msgstr "Начиная с Linux 3.5 доступны следующие параметры:"

#. type: TP
#: man-pages/man2/prctl.2:741
#, no-wrap
msgid "B<PR_SET_MM_ARG_START>"
msgstr "B<PR_SET_MM_ARG_START>"

#. type: Plain text
#: man-pages/man2/prctl.2:744
msgid "Set the address above which the program command line is placed."
msgstr "Задаёт адрес, выше которого размещена командная строка программы."

#. type: TP
#: man-pages/man2/prctl.2:744
#, no-wrap
msgid "B<PR_SET_MM_ARG_END>"
msgstr "B<PR_SET_MM_ARG_END>"

#. type: Plain text
#: man-pages/man2/prctl.2:747
msgid "Set the address below which the program command line is placed."
msgstr "Задаёт адрес, ниже которого размещена командная строка программы."

#. type: TP
#: man-pages/man2/prctl.2:747
#, no-wrap
msgid "B<PR_SET_MM_ENV_START>"
msgstr "B<PR_SET_MM_ENV_START>"

#. type: Plain text
#: man-pages/man2/prctl.2:750
msgid "Set the address above which the program environment is placed."
msgstr "Задаёт адрес, выше которого размещено окружение программы."

#. type: TP
#: man-pages/man2/prctl.2:750
#, no-wrap
msgid "B<PR_SET_MM_ENV_END>"
msgstr "B<PR_SET_MM_ENV_END>"

#. type: Plain text
#: man-pages/man2/prctl.2:753
msgid "Set the address below which the program environment is placed."
msgstr "Задаёт адрес, ниже которого размещено окружение программы."

#. type: Plain text
#: man-pages/man2/prctl.2:766
msgid ""
"The address passed with B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, "
"B<PR_SET_MM_ENV_START>, and B<PR_SET_MM_ENV_END> should belong to a process "
"stack area.  Thus, the corresponding memory area must be readable, writable,"
" and (depending on the kernel configuration) have the B<MAP_GROWSDOWN> "
"attribute set (see B<mmap>(2))."
msgstr "Адрес, передаваемый с B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, B<PR_SET_MM_ENV_START> и B<PR_SET_MM_ENV_END>, должен принадлежать области стека процесса. То есть, соответствующая память должна быть доступна на чтение, запись и (в зависимости от настройки ядра) у неё должен быть установлен атрибут B<MAP_GROWSDOWN> (смотрите B<mmap>(2))."

#. type: TP
#: man-pages/man2/prctl.2:766
#, no-wrap
msgid "B<PR_SET_MM_AUXV>"
msgstr "B<PR_SET_MM_AUXV>"

#. type: Plain text
#: man-pages/man2/prctl.2:775
msgid ""
"Set a new auxiliary vector.  The I<arg3> argument should provide the address"
" of the vector.  The I<arg4> is the size of the vector."
msgstr "Задаёт новый вспомогательный вектор (auxiliary vector). В аргументе I<arg3> должен передаваться адрес вектора. В аргументе I<arg4> — размер вектора."

#. type: TP
#: man-pages/man2/prctl.2:775
#, no-wrap
msgid "B<PR_SET_MM_EXE_FILE>"
msgstr "B<PR_SET_MM_EXE_FILE>"

#.  commit b32dfe377102ce668775f8b6b1461f7ad428f8b6
#. type: Plain text
#: man-pages/man2/prctl.2:787
msgid ""
"Supersede the I</proc/pid/exe> symbolic link with a new one pointing to a "
"new executable file identified by the file descriptor provided in I<arg3> "
"argument.  The file descriptor should be obtained with a regular B<open>(2)"
"  call."
msgstr "Заменяет символьную ссылку I</proc/pid/exe> новой, указывающей на новый исполняемый файл, задаваемый файловым дескриптором в аргументе I<arg3>. Файловый дескриптор должен быть получен с помощью обычного вызова B<open>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:794
msgid ""
"To change the symbolic link, one needs to unmap all existing executable "
"memory areas, including those created by the kernel itself (for example the "
"kernel usually creates at least one executable memory area for the ELF "
"I<.text> section)."
msgstr "Для изменения символьной ссылки необходимо отключить (unmap) все существующие исполняемые области памяти, включая созданные самим ядром (например, ядро, обычно, создаёт, как минимум, исполняемую область памяти для раздела ELF I<.text>)."

#. type: Plain text
#: man-pages/man2/prctl.2:800
msgid ""
"The second limitation is that such transitions can be done only once in a "
"process life time.  Any further attempts will be rejected.  This should help"
" system administrators monitor unusual symbolic-link transitions over all "
"processes running on a system."
msgstr "Второе ограничение в том, что такие переходы можно выполнить только один раз за время существования процесса. Дальнейшие попытки будут отброшены. Это должно помочь системным администраторам отследить необычные переходы символьных ссылок во всех работающих процессах системы."

#. type: Plain text
#: man-pages/man2/prctl.2:822
msgid ""
"On success, B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, B<PR_GET_NO_NEW_PRIVS>, "
"B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, B<PR_GET_TIMING>, "
"B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, B<PR_MCE_KILL_GET>, and (if it "
"returns)  B<PR_GET_SECCOMP> return the nonnegative values described above.  "
"All other I<option> values return 0 on success.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr "При успешном выполнении для операций B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, B<PR_GET_NO_NEW_PRIVS>, B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, B<PR_GET_TIMING>, B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, B<PR_MCE_KILL_GET> и (если возвращается) B<PR_GET_SECCOMP> возвращаются неотрицательные значения, описанные ранее. При успешном выполнении для остальных значений I<option> возвращается 0. При ошибке возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/prctl.2:827
msgid "I<arg2> is an invalid address."
msgstr "В I<arg2> указан неправильный адрес."

#. type: Plain text
#: man-pages/man2/prctl.2:832
msgid "The value of I<option> is not recognized."
msgstr "Не распознано значение I<option>."

#. type: Plain text
#: man-pages/man2/prctl.2:844
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET> or B<PR_SET_MM>, and "
"unused B<prctl>()  arguments were not specified as zero."
msgstr "Значение I<option> равно B<PR_MCE_KILL>, B<PR_MCE_KILL_GET> или B<PR_SET_MM>, и неиспользуемые аргументы B<prctl>() не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:849
msgid "I<arg2> is not valid value for this I<option>."
msgstr "Неверное значение I<arg2> для указанной в I<option> операции."

#. type: Plain text
#: man-pages/man2/prctl.2:858
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_GET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr "Значение I<option> равно B<PR_SET_SECCOMP> или B<PR_GET_SECCOMP>, и ядро не собрано с параметром B<CONFIG_SECCOMP>."

#. type: Plain text
#: man-pages/man2/prctl.2:864
msgid "I<option> is B<PR_SET_MM>, and one of the following is true"
msgstr "Значение I<option> равно B<PR_SET_MM> и одно из следующего является истиной:"

#. type: Plain text
#: man-pages/man2/prctl.2:870
msgid "I<arg4> or I<arg5> is nonzero;"
msgstr "Значение I<arg4> или I<arg5> не равно нулю;"

#. type: Plain text
#: man-pages/man2/prctl.2:875
msgid ""
"I<arg3> is greater than B<TASK_SIZE> (the limit on the size of the user "
"address space for this architecture);"
msgstr "Значение I<arg3> больше B<TASK_SIZE> (ограничение на размер пользовательского адресного пространства для этой архитектуры);"

#. type: Plain text
#: man-pages/man2/prctl.2:885
msgid ""
"I<arg2> is B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, or B<PR_SET_MM_START_STACK>,"
" and the permissions of the corresponding memory area are not as required;"
msgstr "Значение I<arg2> равно B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA> или B<PR_SET_MM_START_STACK>, и права на соответствующую область памяти не удовлетворяют требованиям;"

#. type: Plain text
#: man-pages/man2/prctl.2:897
msgid ""
"I<arg2> is B<PR_SET_MM_START_BRK> or B<PR_SET_MM_BRK>, and I<arg3> is less "
"than or equal to the end of the data segment or specifies a value that would"
" cause the B<RLIMIT_DATA> resource limit to be exceeded."
msgstr "Значение I<arg2> равно B<PR_SET_MM_START_BRK> или B<PR_SET_MM_BRK>, и значение I<arg3> меньше или равно концу сегмента данных, или было бы превышено ограничение ресурса B<RLIMIT_DATA>."

#. type: Plain text
#: man-pages/man2/prctl.2:908
msgid ""
"I<option> is B<PR_SET_PTRACER> and I<arg2> is not 0, B<PR_SET_PTRACER_ANY>, "
"or the PID of an existing process."
msgstr "Значение I<option> равно B<PR_SET_PTRACER> и значение I<arg2> не равно 0, B<PR_SET_PTRACER_ANY> или PID существующего процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:916
msgid ""
"I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgstr "Значение I<option> равно B<PR_SET_PDEATHSIG> и значение I<arg2> не является корректным номером сигнала."

#. type: Plain text
#: man-pages/man2/prctl.2:927
msgid ""
"I<option> is B<PR_SET_DUMPABLE> and I<arg2> is neither B<SUID_DUMP_DISABLE> "
"nor B<SUID_DUMP_USER>."
msgstr "Значение I<option> равно B<PR_SET_DUMPABLE> и значение I<arg2> не равно B<SUID_DUMP_DISABLE> или B<SUID_DUMP_USER>."

#. type: Plain text
#: man-pages/man2/prctl.2:936
msgid ""
"I<option> is B<PR_SET_TIMING> and I<arg2> is not B<PR_TIMING_STATISTICAL>."
msgstr "Значение I<option> равно B<PR_SET_TIMING> и значение I<arg2> не равно B<PR_TIMING_STATISTICAL>."

#. type: Plain text
#: man-pages/man2/prctl.2:950
msgid ""
"I<option> is B<PR_SET_NO_NEW_PRIVS> and I<arg2> is not equal to 1 or "
"I<arg3>, I<arg4>, or I<arg5> is nonzero."
msgstr "Значение I<option> равно B<PR_SET_NO_NEW_PRIVS> и значение I<arg2> не равно 1 или I<arg3>, I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:962
msgid ""
"I<option> is B<PR_GET_NO_NEW_PRIVS> and I<arg2>, I<arg3>, I<arg4>, or "
"I<arg5> is nonzero."
msgstr "Значение I<option> равно B<PR_GET_NO_NEW_PRIVS> и значения I<arg2>, I<arg3>, I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:973
msgid ""
"I<option> is B<PR_SET_THP_DISABLE> and I<arg3>, I<arg4>, or I<arg5> is "
"nonzero."
msgstr "Значение I<option> равно B<PR_SET_THP_DISABLE> и I<arg3>, I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:985
msgid ""
"I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or I<arg5>"
" is nonzero."
msgstr "Значение I<option> равно B<PR_GET_THP_DISABLE> и значения I<arg2>, I<arg3>, I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:997
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr "Значение I<option> равно B<PR_SET_SECUREBITS>, и вызывающий не имеет мандата B<CAP_SETPCAP>, или пытается сбросить «заблокированный» флаг, или пытается установить флаг, для которого установлен соответствующий заблокированный флаг (смотрите B<capabilities>(7))."

#. type: Plain text
#: man-pages/man2/prctl.2:1007
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the callers's "
"B<SECURE_KEEP_CAPS_LOCKED> flag is set (see B<capabilities>(7))."
msgstr "Значение I<option> равно B<PR_SET_KEEPCAPS>, и у вызывающего установлен флаг B<SECURE_KEEP_CAPS_LOCKED> (смотрите B<capabilities>(7))."

#. type: Plain text
#: man-pages/man2/prctl.2:1015
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr "Значение I<option> равно B<PR_CAPBSET_DROP>, и вызывающий не имеет мандата B<CAP_SETPCAP>."

#. type: Plain text
#: man-pages/man2/prctl.2:1023
msgid ""
"I<option> is B<PR_SET_MM>, and the caller does not have the "
"B<CAP_SYS_RESOURCE> capability."
msgstr "Значение I<option> равно B<PR_SET_MM>, и вызывающий не имеет мандата B<CAP_SYS_RESOURCE>."

#. type: Plain text
#: man-pages/man2/prctl.2:1033
msgid ""
"I<option> is B<PR_SET_MM>, and I<arg3> is B<PR_SET_MM_EXE_FILE>, the file is"
" not executable."
msgstr "Значение I<option> равно B<PR_SET_MM>, а I<arg3> — B<PR_SET_MM_EXE_FILE>, файл не является исполняемым."

#. type: Plain text
#: man-pages/man2/prctl.2:1044
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and this the "
"second attempt to change the I</proc/pid/exe> symbolic link, which is "
"prohibited."
msgstr "Значение I<option> равно B<PR_SET_MM>, I<arg3> — B<PR_SET_MM_EXE_FILE>, и это вторая попытка изменить символьную ссылку I</proc/pid/exe>, что запрещено."

#.  The following can't actually happen, because prctl() in
#.  seccomp mode will cause SIGKILL.
#.  .TP
#.  .B EPERM
#.  .I option
#.  is
#.  .BR PR_SET_SECCOMP ,
#.  and secure computing mode is already 1.
#. type: Plain text
#: man-pages/man2/prctl.2:1063
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and the file "
"descriptor passed in I<arg4> is not valid."
msgstr "Значение I<option> равно B<PR_SET_MM>, I<arg3> — B<PR_SET_MM_EXE_FILE>, и файловый дескриптор, переданный в I<arg4>, некорректен."

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: man-pages/man2/prctl.2:1068
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr "Системный вызов B<prctl>() впервые появился в Linux 2.1.57."

#. type: Plain text
#: man-pages/man2/prctl.2:1075
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr "Данный вызов существует только в Linux. В IRIX есть системный вызов B<prctl>() (также представленный в Linux 2.1.44 как irix_prctl на архитектуре MIPS) объявленный как"

#. type: Plain text
#: man-pages/man2/prctl.2:1077
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>"
msgstr "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>"

#. type: Plain text
#: man-pages/man2/prctl.2:1082
msgid ""
"and options to get the maximum number of processes per user, get the maximum"
" number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"and so on."
msgstr "а также операции, позволяющие получить максимальное количество процессов для каждого пользователя, максимальное количество процессоров, которое может использовать вызывающий процесс; определить, блокирован ли заданный процесс; получить или установить максимальный размер стека и т. д."

#. type: Plain text
#: man-pages/man2/prctl.2:1084
msgid "B<signal>(2), B<core>(5)"
msgstr "B<signal>(2), B<core>(5)"

#. type: TH
#: man-pages/man2/posix_fadvise.2:28
#, no-wrap
msgid "POSIX_FADVISE"
msgstr "POSIX_FADVISE"

#. type: TH
#: man-pages/man2/posix_fadvise.2:28
#, no-wrap
msgid "2014-05-03"
msgstr "2014-05-03"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:31
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr "posix_fadvise - предварительно декларирует вариант доступа для данных файла"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:34
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:37
#, no-wrap
msgid ""
"B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int "
">I<advice>B<);>\n"
msgstr "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:46
msgid "B<posix_fadvise>():"
msgstr "B<posix_fadvise>():"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:56
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file"
" data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr "Программы могут использовать B<posix_fadvise>() для объявления намерений осуществить доступ к файлу данных в скором будущем определённым образом, тем самым позволяя ядру выполнить некоторые операции по оптимизации."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:63
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr "Аргумент I<advice> применяется к (не обязательно существующей) области, начинающейся с I<offset>, длиной I<len> байт (или до конца файла, если I<len> равно 0) внутри файла, на который ссылается I<fd>. Аргумент I<advice> не является привязкой; он всего лишь выражает ожидание приложения."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:65
msgid "Permissible values for I<advice> include:"
msgstr "Допустимые значения I<advice>:"

#. type: TP
#: man-pages/man2/posix_fadvise.2:65
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr "B<POSIX_FADV_NORMAL>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:71
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr "Указывает, что приложение не может подсказать тип доступа для указанных данных. Если не указано предположение для открываемого файла, то используется предположение по умолчанию."

#. type: TP
#: man-pages/man2/posix_fadvise.2:71
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr "B<POSIX_FADV_SEQUENTIAL>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:75
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr "Приложение ожидает последовательный доступ к указанным данным (чтение выполняется начиная с младших адресов)."

#. type: TP
#: man-pages/man2/posix_fadvise.2:75
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr "B<POSIX_FADV_RANDOM>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:78
msgid "The specified data will be accessed in random order."
msgstr "Указанные данные будут запрашиваться в случайном порядке."

#. type: TP
#: man-pages/man2/posix_fadvise.2:78
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr "B<POSIX_FADV_NOREUSE>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:81
msgid "The specified data will be accessed only once."
msgstr "Указанные данные будут запрошены только один раз."

#. type: TP
#: man-pages/man2/posix_fadvise.2:81
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr "B<POSIX_FADV_WILLNEED>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:84
msgid "The specified data will be accessed in the near future."
msgstr "Указанные данные будут запрошены в скором будущем."

#. type: TP
#: man-pages/man2/posix_fadvise.2:84
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr "B<POSIX_FADV_DONTNEED>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:87
msgid "The specified data will not be accessed in the near future."
msgstr "Указанные данные не будут запрошены в скором будущем."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:90
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается номер ошибки."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:94
msgid "The I<fd> argument was not a valid file descriptor."
msgstr "Аргумент I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:97
msgid "An invalid value was specified for I<advice>."
msgstr "Неверное значение I<advice>."

#. type: TP
#: man-pages/man2/posix_fadvise.2:97
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:104
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (Linux actually "
"returns B<EINVAL> in this case.)"
msgstr "Указанный файловый дескриптор ссылается на канал (pipe) или FIFO. В этом случае в Linux, на самом деле, возвращается B<EINVAL>."

#.  of fadvise64_64()
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:112
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is"
" called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr "Поддержка в ядре впервые появилась в Linux 2.5.60; используемый системный вызов называется B<fadvise64>(). Поддержка в библиотеке glibc появилась в версии 2.2; обёрточная функция называется B<posix_fadvise>()."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:121
msgid ""
"POSIX.1-2001.  Note that the type of the I<len> argument was changed from "
"I<size_t> to I<off_t> in POSIX.1-2003 TC1."
msgstr "POSIX.1-2001. Заметим, что в POSIX.1-2003 TC1 тип аргумента I<len> был изменён с I<size_t> на I<off_t>."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:127
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and"
" B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes "
"affect the entire file, not just the specified region (but other open file "
"handles to the same file are unaffected)."
msgstr "В Linux B<POSIX_FADV_NORMAL> устанавливает окно упреждающего чтения согласно используемому размеру по умолчанию для ниже лежащего устройства; B<POSIX_FADV_SEQUENTIAL> удваивает этот размер, а B<POSIX_FADV_RANDOM> отменяет упреждающее чтение вообще. Эти изменения влияют на весь файл, а не только на указанную его область (но другие открытые обработчики файлов на этом файле не изменяются)."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:134
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel"
" depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr "При B<POSIX_FADV_WILLNEED> запускается неблокировочное чтение указанной области в страницу кэша. Число неблокированных данных может быть уменьшено ядром в зависимости от загрузки виртуальной памяти (несколько мегабайт памяти наверняка будут выделены, а больше, обычно, и не бывает нужно)."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:138
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr "В ядрах до версии 2.6.18, для B<POSIX_FADV_NOREUSE> использовалась такая же семантика что и у B<POSIX_FADV_WILLNEED>. Это, вероятно, было дефектом; начиная с ядра 2.6.18 для этого флага нет операции."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:146
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large files."
"  A program may periodically request the kernel to free cached data that has"
" already been used, so that more useful cached pages are not discarded "
"instead."
msgstr "При указании B<POSIX_FADV_DONTNEED> вызов пытается высвободить кэшированные страницы, связанные с указанной областью. Это полезно, например, при потоковой обработке больших файлов. Программа может периодически запрашивать ядро об освобождении уже использованных кэшированных данных, так что полезные кэшированные страницы не будут освобождаться."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:154
msgid ""
"Pages that have not yet been written out will be unaffected, so if the "
"application wishes to guarantee that pages will be released, it should call "
"B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr "Не записанные страницы останутся нетронутыми, так что если приложение захочет гарантированно высвободить страницу, то оно должно вызвать сначала B<fsync>(2) или B<fdatasync>(2)."

#. type: SS
#: man-pages/man2/posix_fadvise.2:154
#, no-wrap
msgid "Architecture-specific variants"
msgstr "Варианты, зависящие от архитектуры"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:171
msgid ""
"Some architectures require 64-bit arguments to be aligned in a suitable pair"
" of registers (see B<syscall>(2)  for further detail).  On such "
"architectures, the call signature of B<posix_fadvise>()  shown in the "
"SYNOPSIS would force a register to be wasted as padding between the I<fd> "
"and I<offset> arguments.  Therefore, these architectures define a version of"
" the system call that orders the arguments suitably, but otherwise is "
"otherwise exactly the same as B<posix_fadvise>()."
msgstr "Для некоторых архитектур требуется, чтобы 64-битные аргументы были выровнены в подходящей паре регистров. На таких архитектурах семантика вызова B<posix_fadvise>(), показанная в ОБЗОРе, заставляет тратить впустую регистр между аргументами I<fd> и I<offset>. Поэтому для таких архитектур определена другая версия системного вызова, в которой аргументы расставлены в более подходящем порядке. В остальных случаях используется описанная версия B<posix_fadvise>()."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:173
msgid "For example, since Linux 2.6.14, ARM has the following system call:"
msgstr "Например, начиная с Linux 2.6.14, в ARM есть следующий системный вызов:"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:178
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr "B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\nB<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:186
msgid ""
"These architecture-specific details are generally hidden from applications "
"by the glibc B<posix_fadvise>()  wrapper function, which invokes the "
"appropriate architecture-specific system call."
msgstr "Данные, зависящие от архитектуры, детали, обычно, скрываются от приложений в обёрточной функции glibc B<posix_fadvise>(), которая использует соответствующий архитектуре системный вызов."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:191
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr "В ядрах до версии 2.6.6, если значение I<len> равнялось 0, то это воспринималось дословно как «ноль байт», а не как «все байты до конца файла»."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:195
msgid ""
"B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3), "
"B<posix_madvise>(3)"
msgstr "B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3), B<posix_madvise>(3)"

#. type: TH
#: man-pages/man2/ptrace.2:44
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: TH
#: man-pages/man2/ptrace.2:44
#, no-wrap
msgid "2014-02-20"
msgstr "2014-02-20"

#. type: Plain text
#: man-pages/man2/ptrace.2:47
msgid "ptrace - process trace"
msgstr "ptrace - трассировка процесса"

#. type: Plain text
#: man-pages/man2/ptrace.2:50
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:53
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr "B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\nB<            void *>I<addr>B<, void *>I<data>B<);>\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:62
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr "Системный вызов B<ptrace>() позволяет указать какому процессу («трассировщику») можно наблюдать и контролировать выполнение другого процесса («трассироемого»), просматривать и изменять его память и регистры. Обычно, он используется для реализации отладочных точек прерывания и для отслеживания системных вызовов."

#. type: Plain text
#: man-pages/man2/ptrace.2:73
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread"
" can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr "Сначала, трассировщик должен присоединиться к трассируемой нити. Присоединение и последующие команды выполняются для нитей: в многонитиевом процессе трассировщик может подключаться как к каждой нити (трассировщики могут быть у разных нитей разными), так и не подключаться к некоторым нитям вовсе. Поэтому на самом деле «трассируемая нить»  всегда означает «(одну) нить», а не «процесс в целом (возможно многонитиевый)». Команды ptrace всегда посылаются определённой трассируемой нити с помощью вызова"

#. type: Plain text
#: man-pages/man2/ptrace.2:75
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr "    ptrace(PTRACE_foo, pid, …)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:79
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr "где I<pid> — идентификатор соответствующей нити Linux."

#. type: Plain text
#: man-pages/man2/ptrace.2:85
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr "Заметим, что в этой странице «многонитиевый процесс» означает группу нитей, состоящую из нитей, созданных с помощью B<clone>(2) с флагом B<CLONE_THREAD>."

#. type: Plain text
#: man-pages/man2/ptrace.2:96
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an "
"B<execve>(2).  Alternatively, one process may commence tracing another "
"process using B<PTRACE_ATTACH> or B<PTRACE_SEIZE>."
msgstr "Процесс может начать трассировку с вызова B<fork>(2), в получившемся дочернем процессе выполнить действие B<PTRACE_TRACEME>, после чего (обычно) выполнить B<execve>(2). Или же один процесс может начать отладку другого процесса при помощи B<PTRACE_ATTACH> или B<PTRACE_SEIZE>."

#. type: Plain text
#: man-pages/man2/ptrace.2:113
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has"
" its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will"
" return a I<status> value containing information that indicates the cause of"
" the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr "При трассировке трассируемая нить останавливается каждый раз при получении сигнала, даже если этот сигнал игнорируется (исключением является B<SIGKILL>, работающий обычным образом). Трассировщик будет уведомлён об этом при следующем вызове B<waitpid>(2) (или подобном «ожидающем» системном вызове); этот вызов вернёт значение I<status>, в котором содержится информация, указывающая на причину остановки трассируемой нити. Так как трассируемая нить остановлена, трассировщик может использовать различные запросы ptrace для обследования и изменения трассируемой нити. По окончании трассировщик разрешает трассируемой нити продолжить работу, возможно подавляя посылаемый ему сигнал (или даже отправляя вместо него другой сигнал)."

#. type: Plain text
#: man-pages/man2/ptrace.2:123
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP>"
" signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr "Если флаг B<PTRACE_O_TRACEEXEC> не действует, то все успешные вызовы B<execve>(2) трассируемой нитью будут приводить к отправки сигнала B<SIGTRAP>, давая таким образом родителю шанс перехватить управление до того, как начнёт выполняться новая программа."

#. type: Plain text
#: man-pages/man2/ptrace.2:127
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr "По окончании трассировки трассировщик может заставить трассируемую нить продолжить свою работу в обычном нетрассируемом режиме с помощью B<PTRACE_DETACH>."

#. type: Plain text
#: man-pages/man2/ptrace.2:131
msgid "The value of I<request> determines the action to be performed:"
msgstr "Значение аргумента I<request> определяет выполняемое действие:"

#. type: TP
#: man-pages/man2/ptrace.2:131
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "B<PTRACE_TRACEME>"

#. type: Plain text
#: man-pages/man2/ptrace.2:141
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr "Указывает, что этот процесс будет трассирован своим родительским процессом. Вероятно, процессу не следует посылать этот запрос, если родительский процесс не готов к трассировке (аргументы I<pid>, I<addr> и I<data> игнорируются)."

#. type: Plain text
#: man-pages/man2/ptrace.2:156
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT>, and "
"B<PTRACE_KILL>, the tracee must be stopped."
msgstr "Действие B<PTRACE_TRACEME> используется только в трассируемой нити; остальные действия предназначены только для трассировщика. Для значений, описанных ниже, в параметре I<pid> задаётся идентификатор трассируемой нити, над которой будет производиться действие. Перед выполнением действий (кроме B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT> и B<PTRACE_KILL>) трассируемая нить должна быть остановлена."

#. type: TP
#: man-pages/man2/ptrace.2:156
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"

#. type: Plain text
#: man-pages/man2/ptrace.2:167
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored; but see NOTES.)"
msgstr "Читает слово по адресу I<addr>, находящееся в памяти трассируемой нити, возвращая это слово как результат вызова B<ptrace>() Linux не разделяет адресные пространства текста и данных, поэтому оба вызова абсолютно идентичны (значение I<data> игнорируется; но смотрите ЗАМЕЧАНИЯ)."

#. type: TP
#: man-pages/man2/ptrace.2:167
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "B<PTRACE_PEEKUSER>"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: man-pages/man2/ptrace.2:185
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see "
"I<E<lt>sys/user.hE<gt>>).  The word is returned as the result of the "
"B<ptrace>()  call.  Typically, the offset must be word-aligned, though this "
"might vary by architecture.  See NOTES.  (I<data> is ignored; but see "
"NOTES.)"
msgstr "Читает слово по смещению I<addr> из области USER трассируемой нити, которая содержит информацию о регистрах и процессе (смотрите I<E<lt>sys/userhE<gt>>). Слово возвращается в качестве результата вызова B<ptrace>(). Обычно, смещение должно быть выровнено по границе слова, хотя это может зависеть от архитектуры системы. Смотрите ЗАМЕЧАНИЯ (значение I<data> игнорируется; но смотрите ЗАМЕЧАНИЯ)."

#. type: TP
#: man-pages/man2/ptrace.2:185
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"

#. type: Plain text
#: man-pages/man2/ptrace.2:197
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for"
" B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently"
" equivalent."
msgstr "Копирует слово I<data> в память трассируемой нити по адресу I<addr>. В настоящее время, как и для B<PTRACE_PEEKTEXT> и B<PTRACE_PEEKDATA>, эти два действия одинаковы."

#. type: TP
#: man-pages/man2/ptrace.2:197
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "B<PTRACE_POKEUSER>"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: man-pages/man2/ptrace.2:213
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr "Копирует слово I<data> по смещению I<addr> в область USER трассирумой нити. Как и для B<PTRACE_PEEKUSER>, смещение должно быть выровнено по границе слова. Для того, чтобы сохранить целостность ядра, некоторые изменения в область USER вносить запрещено."

#. type: TP
#: man-pages/man2/ptrace.2:213
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:236
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively,"
" to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>.  "
"B<PTRACE_GETREGS> and B<PTRACE_GETFPREGS> are not present on all "
"architectures."
msgstr "Копирует, соответственно, регистры общего назначения или регистры сопроцессора трассируемой нити в память трассировщика по адресу I<data>. Формат передаваемой структуры описан в файле I<E<lt>sys/user.hE<gt>> (значение I<addr> игнорируется). Заметим, что в системах SPARC предназначение I<data> и I<addr> поменяны местами; то есть I<data> игнорируется, а регистры копируются по адресу I<addr>. B<PTRACE_GETREGS> и B<PTRACE_GETFPREGS> есть не на всех архитектурах."

#. type: TP
#: man-pages/man2/ptrace.2:236
#, no-wrap
msgid "B<PTRACE_GETREGSET> (since Linux 2.6.34)"
msgstr "B<PTRACE_GETREGSET> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/ptrace.2:257
msgid ""
"Read the tracee's registers.  I<addr> specifies, in an architecture-"
"dependent way, the type of registers to be read.  B<NT_PRSTATUS> (with "
"numerical value 1)  usually results in reading of general-purpose registers."
"  If the CPU has, for example, floating-point and/or vector registers, they "
"can be retrieved by setting I<addr> to the corresponding B<NT_foo> constant."
"  I<data> points to a B<struct iovec>, which describes the destination "
"buffer's location and length.  On return, the kernel modifies B<iov.len> to "
"indicate the actual number of bytes returned."
msgstr "Читает регистры трассируемой нити. В I<addr> указывается, в зависящей от архитектуры форме, тип читаемых регистров. Значение B<NT_PRSTATUS> (равно 1) обычно служит для чтения регистров общего назначения. Если в ЦП есть, например, векторные регистры и для плавающей запятой, то их можно получить назначив I<addr> соответствующую константу B<NT_foo>. Значение I<data> указывает на B<struct iovec>, которая описывает расположение буфера назначения и длину. При возврате ядро изменяет B<iov.len>, возвращая реальное количество возвращаемых байт."

#. type: TP
#: man-pages/man2/ptrace.2:257
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"

#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: man-pages/man2/ptrace.2:282
msgid ""
"Modify the tracee's general-purpose or floating-point registers, "
"respectively, from the address I<data> in the tracer.  As for "
"B<PTRACE_POKEUSER>, some general-purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)  Note that SPARC systems have the meaning"
" of I<data> and I<addr> reversed; that is, I<data> is ignored and the "
"registers are copied from the address I<addr>.  B<PTRACE_SETREGS> and "
"B<PTRACE_SETFPREGS> are not present on all architectures."
msgstr "Копирует, соответственно, регистры общего назначения или регистры для плавающей запятой трассируемой нити из памяти трассировщика по адресу I<data>. Как и в случае c B<PTRACE_POKEUSER>, изменения некоторых регистров общего назначения запрещены (значение I<addr> игнорируется). Заметим, что в системах SPARC предназначение I<data> и I<addr> переставлены местами; то есть I<data> игнорируется, а регистры копируются из памяти, на которую указывает адрес I<addr>. B<PTRACE_SETREGS> и B<PTRACE_SETFPREGS> есть не для всех архитектур."

#. type: TP
#: man-pages/man2/ptrace.2:282
#, no-wrap
msgid "B<PTRACE_SETREGSET> (since Linux 2.6.34)"
msgstr "B<PTRACE_SETREGSET> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/ptrace.2:291
msgid ""
"Modify the tracee's registers.  The meaning of I<addr> and I<data> is "
"analogous to B<PTRACE_GETREGSET>."
msgstr "Изменяет регистры трассируемой нити. Значение I<addr> и I<data> аналогичны B<PTRACE_GETREGSET>."

#. type: TP
#: man-pages/man2/ptrace.2:291
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_GETSIGINFO> (начиная с Linux 2.3.99-pre6)"

#. type: Plain text
#: man-pages/man2/ptrace.2:303
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address"
" I<data> in the tracer.  (I<addr> is ignored.)"
msgstr "Получает информацию о сигнале, который вызвал остановку. Копирует структуру I<siginfo_t> (смотрите B<sigaction>(2)) из трассируемой нити в память трассировщика по адресу I<data> (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:303
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_SETSIGINFO> (начиная с Linux 2.3.99-pre6)"

#. type: Plain text
#: man-pages/man2/ptrace.2:319
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It"
" may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr "Устанавливает информацию о сигнале. Копирует структуру I<siginfo_t>, расположенную по адресу I<data> трассировщика, в память трассируемой нити. Влияет только на сигналы, которые обычно были бы доставлены трассируемой нити и были пойманы трассировщиком. Затруднительно отличить обычные сигналы от созданных самим B<ptrace>() (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:319
#, no-wrap
msgid "B<PTRACE_PEEKSIGINFO> (since Linux 3.10)"
msgstr "B<PTRACE_PEEKSIGINFO> (начиная с Linux 3.10)"

#.  commit 84c751bd4aebbaae995fe32279d3dba48327bad4
#. type: Plain text
#: man-pages/man2/ptrace.2:345
msgid ""
"Retrieve I<siginfo_t> structures without removing signals from a queue.  "
"I<addr> points to a I<ptrace_peeksiginfo_args> structure that specifies the "
"ordinal position from which copying of signals should start, and the number "
"of signals to copy.  I<siginfo_t> structures are copied into the buffer "
"pointed to by I<data>.  The return value contains the number of copied "
"signals (zero indicates that there is no signal corresponding to the "
"specified ordinal position).  Within the returned I<siginfo> structures, the"
" I<si_code> field includes information (B<__SI_CHLD>, B<__SI_FAULT>, etc.) "
"that are not otherwise exposed to user space."
msgstr "Получает структуры I<siginfo_t> не удаляя сигналы из очереди. Значение I<addr> указывает на структуру I<ptrace_peeksiginfo_args>, которая задаёт начальную позицию, из которой нужно начать копирование сигналов, а также их количество. Структуры I<siginfo_t> копируются в буфер, указываемый в I<data>. Возвращаемое значение содержит количество скопированных сигналов (ноль означает, что сигналов в указанной позиции нет). Внутри возвращаемых структур I<siginfo> в поле I<si_code> включается информация (B<__SI_CHLD>, B<__SI_FAULT> и т. д.), которая по-другому никак не выдаётся в пользовательское пространство."

#. type: Plain text
#: man-pages/man2/ptrace.2:354
#, no-wrap
msgid ""
"struct ptrace_peeksiginfo_args {\n"
"    u64 off;    /* Ordinal position in queue at which\n"
"                   to start copying signals */\n"
"    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */\n"
"    s32 nr;     /* Number of signals to copy */\n"
"};\n"
msgstr "struct ptrace_peeksiginfo_args {\n    u64 off;    /* начальная позиция в очереди, с которой\n                   начинается копирование сигналов */\n    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED или 0 */\n    s32 nr;     /* количество копируемых сигналов */\n};\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:361
msgid ""
"Currently, there is only one flag, B<PTRACE_PEEKSIGINFO_SHARED>, for dumping"
" signals from the process-wide signal queue.  If this flag is not set, "
"signals are read from the per-thread queue of the specified thread."
msgstr "В настоящее время определён только один флаг, B<PTRACE_PEEKSIGINFO_SHARED>, служащий для выборки сигналов из общей очереди сигналов процессов. Если этот флаг не указан, то сигналы читаются из очереди указанной нити."

#. type: TP
#: man-pages/man2/ptrace.2:363
#, no-wrap
msgid "B<PTRACE_GETSIGMASK> (since Linux 3.11)"
msgstr "B<PTRACE_GETSIGMASK> (начиная с Linux 3.11)"

#.  commit 29000caecbe87b6b66f144f72111f0d02fbbf0c1
#. type: Plain text
#: man-pages/man2/ptrace.2:378
msgid ""
"Place a copy of the mask of blocked signals (see B<sigprocmask>(2))  in the "
"buffer pointed to by I<data>, which should be a pointer to a buffer of type "
"I<sigset_t>.  The I<addr> argument contains the size of the buffer pointed "
"to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr "Помещает копию маски блокированных сигналов (смотрите B<sigprocmask>(2)) в буфер, указанный в I<data> (должен быть указателем на буфер с типом I<sigset_t>). Аргумент I<addr> содержит размер буфера, указанного в I<data> (т. е. I<sizeof(sigset_t)>)."

#. type: TP
#: man-pages/man2/ptrace.2:378
#, no-wrap
msgid "B<PTRACE_SETSIGMASK> (since Linux 3.11)"
msgstr "B<PTRACE_SETSIGMASK> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/ptrace.2:392
msgid ""
"Change the mask of blocked signals (see B<sigprocmask>(2))  to the value "
"specified in the buffer pointed to by I<data>, which should be a pointer to "
"a buffer of type I<sigset_t>.  The I<addr> argument contains the size of the"
" buffer pointed to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr "Изменяет маску блокированных сигналов (смотрите B<sigprocmask>(2)) на значение из буфера, указанного в I<data> (должен быть указателем на буфер с типом I<sigset_t>). Аргумент I<addr> содержит размер буфера, указанного в I<data> (т. е. I<sizeof(sigset_t)>)."

#. type: TP
#: man-pages/man2/ptrace.2:392
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr "B<PTRACE_SETOPTIONS> (начиная с Linux 2.4.6; см. предостережения в разделе ДЕФЕКТЫ)"

#. type: Plain text
#: man-pages/man2/ptrace.2:401
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr "Устанавливает флаги ptrace из I<data> (значение I<addr> игнорируется). Значение I<data> воспринимается как битовая маска, в которой задаются следующие флаги:"

#. type: TP
#: man-pages/man2/ptrace.2:402
#, no-wrap
msgid "B<PTRACE_O_EXITKILL> (since Linux 3.8)"
msgstr "B<PTRACE_O_EXITKILL> (начиная с Linux 3.8)"

#.  commit 992fb6e170639b0849bace8e49bf31bd37c4123
#. type: Plain text
#: man-pages/man2/ptrace.2:410
msgid ""
"If a tracer sets this flag, a B<SIGKILL> signal will be sent to every tracee"
" if the tracer exits.  This option is useful for ptrace jailers that want to"
" ensure that tracees can never escape the tracer's control."
msgstr "Если трассировщик устанавливает этот флаг, то сигнал B<SIGKILL> будет послан каждой трассируемой нити, если трассировщик существует. Этот параметр полезен для надзирателей ptrace, которые хотят убедиться, что трассируемые никогда не выйдут из-под контроля трассировщика."

#. type: TP
#: man-pages/man2/ptrace.2:410
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACECLONE> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:427
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the"
" newly cloned process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr "Останавливать трассируемую нить при следующем вызове B<clone>(2) и автоматически запускать трассировку только что склонированного процесса, который начнёт выполнение с обработки сигнала B<SIGSTOP> или B<PTRACE_EVENT_STOP>, если используется B<PTRACE_SEIZE>. Вызов B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:430
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:434 man-pages/man2/ptrace.2:520
#: man-pages/man2/ptrace.2:553
msgid ""
"The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr "Значение PID нового процесса можно получить с помощью B<PTRACE_GETEVENTMSG>."

#. type: Plain text
#: man-pages/man2/ptrace.2:455
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr "В некоторых случаях вызовы B<clone>(2) могут быть не пойманы. Если трассируемая нить вызывает B<clone>(2) с флагом B<CLONE_VFORK>, то будет доставлен B<PTRACE_EVENT_VFORK>, если установлен B<PTRACE_O_TRACEVFORK>; в противном случае, если трассируемая нить вызывает B<clone>(2) с установленным сигналом выхода равным B<SIGCHLD>, то будет доставлен B<PTRACE_EVENT_FORK>, если установлен B<PTRACE_O_TRACEFORK>."

#. type: TP
#: man-pages/man2/ptrace.2:455
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEEXEC> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:464
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr "Останавливать трассируемую нить при следующем вызове B<execve>(). Вызов B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:467
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:473
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr "Если исполняемая нить не является лидером группы нитей, то идентификатор нити сбрасывается в значение идентификатора лидера группы нитей перед его остановкой. Начиная с Linux 3.0, предыдущий идентификатор нити может быть получен с помощью B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:473
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEEXIT> (начиная с Linux 2.5.60)"

#. type: Plain text
#: man-pages/man2/ptrace.2:481
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr "Останавливать трассируемую нить при его завершении (exit). Вызов B<waitpid>() вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:484
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:488
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr "Значение кода завершения трассируемой нити можно получить с помощью B<PTRACE_GETEVENTMSG>."

#. type: Plain text
#: man-pages/man2/ptrace.2:496
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr "Остановка трассируемой нити будет выполнена в начальный момент завершения, когда ещё доступны регистры, что позволяет трассировщику увидеть откуда выполнялось завершение (обычное уведомление о завершении выполняется после того как процесс уже завершил работу). Хотя в этот момент ещё доступен контекст, трассировщик уже не может предотвратить завершение."

#. type: TP
#: man-pages/man2/ptrace.2:496
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEFORK> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:513
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr "Останавливать трассируемую нить при следующем вызове B<fork>(2) и автоматически запускать трассировку только что созданного с помощью fork процесса, который начнёт выполнение с обработки сигнала B<SIGSTOP> или B<PTRACE_EVENT_STOP>, если используется B<PTRACE_SEIZE>. Вызов B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:516
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"

#. type: TP
#: man-pages/man2/ptrace.2:520
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr "B<PTRACE_O_TRACESYSGOOD> (начиная с Linux 2.4.6)"

#. type: Plain text
#: man-pages/man2/ptrace.2:529
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call.  (B<PTRACE_O_TRACESYSGOOD> "
"may not work on all architectures.)"
msgstr "При доставке сигналов ловушек системных вызовов, устанавливать бит 7 в номере сигнала (т. е., доставляется I<SIGTRAP|0x80>). Это позволяет трассировщику легко отличить обычные ловушки от тех, которые были вызваны системным вызовом (B<PTRACE_O_TRACESYSGOOD> может не работать на некоторых архитектурах)."

#. type: TP
#: man-pages/man2/ptrace.2:529
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEVFORK> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:546
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the"
" newly vforked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr "Останавливать трассируемую нить при следующем вызове B<vfork>(2) и автоматически запускать трассировку только что созданного с помощью vfork процесса, который начнёт выполнение с обработки сигнала B<SIGSTOP> или B<PTRACE_EVENT_STOP>, если используется B<PTRACE_SEIZE>. Вызов B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:549
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"

#. type: TP
#: man-pages/man2/ptrace.2:553
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (начиная с Linux 2.5.60)"

#. type: Plain text
#: man-pages/man2/ptrace.2:562
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)"
"  by the tracer will return a I<status> value such that"
msgstr "Останавливать трассируемую нить при следующем вызове B<vfork>(2). Вызов B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:565
#, no-wrap
msgid ""
"  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:569
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr "Значение PID нового процесса можно получить (начиная с Linux 2.6.18) с помощью B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:570
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr "B<PTRACE_GETEVENTMSG> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:590
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and"
" B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  (I<addr> is "
"ignored.)"
msgstr "Включает получение сообщения (с типом I<unsigned long>) о событии ptrace, которое только что произошло, помещая его по адресу I<data> в памяти трассировщика. Для B<PTRACE_EVENT_EXIT> это код завершения трассируемой нити. Для B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> и B<PTRACE_EVENT_CLONE> это PID нового процесса (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:590
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: man-pages/man2/ptrace.2:602
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr "Возобновляет работу остановленной трассируемой нити. Если значение I<data> не равно нулю, то оно считается номером сигнала, который надо доставить трассируемой нити; в противном случае сигнал не передаётся. Таким образом, например, трассировщик может контролировать передачу сигнала трассируемой нити (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:602
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"

#. type: Plain text
#: man-pages/man2/ptrace.2:626
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee"
" to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective,"
" the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  "
"So, for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments"
" to the system call at the first stop, then do another B<PTRACE_SYSCALL> and"
" inspect the return value of the system call at the second stop.  The "
"I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr "Аналогично B<PTRACE_CONT> они перезапускают остановленную трассируемую нить, но указывают, что процесс должен быть остановлен перед входом/выходом из системного вызова, или после исполнения одной инструкции, соответственно (трассируемая нить также, как обычно, будет остановлена при получении сигнала). С точки зрения трассировщика кажется, что трассируемая нить остановлена из-за получения сигнала B<SIGTRAP>. Так, B<PTRACE_SYSCALL> например, позволяет изучить содержимое аргументов перед системным вызовом, а при следующем B<PTRACE_SYSCALL> можно просмотреть результат исполнения системного вызова. Аргумент I<data> используется как в B<PTRACE_CONT> (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:626
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (начиная с Linux 2.6.14)"

#.  As at 3.7
#. type: Plain text
#: man-pages/man2/ptrace.2:647
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
"but also singlestep if not a system call.  This call is used by programs "
"like User Mode Linux that want to emulate all the tracee's system calls.  "
"The I<data> argument is treated as for B<PTRACE_CONT>.  The I<addr> argument"
" is ignored.  These requests are currently supported only on x86."
msgstr "Действие B<PTRACE_SYSEMU> приводит к продолжению и остановке на входе в следующий системный вызов, который не будет выполнен Действие B<PTRACE_SYSEMU_SINGLESTEP> выполняет тоже самое, но для одиночной инструкции, если это не системный вызов. Это действие используется программами, подобными User Mode Linux, которым нужно эмулировать все системные вызовы трассируемых нитей. Аргумент I<data> используется также как у B<PTRACE_CONT>.  Аргумент I<addr> игнорируется. Эти запросы поддерживаются только на x86."

#. type: TP
#: man-pages/man2/ptrace.2:647
#, no-wrap
msgid "B<PTRACE_LISTEN> (since Linux 3.4)"
msgstr "B<PTRACE_LISTEN> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/ptrace.2:658
msgid ""
"Restart the stopped tracee, but prevent it from executing.  The resulting "
"state of the tracee is similar to a process which has been stopped by a "
"B<SIGSTOP> (or other stopping signal).  See the \"group-stop\" subsection "
"for additional information.  B<PTRACE_LISTEN> works only on tracees attached"
" by B<PTRACE_SEIZE>."
msgstr "Перезапускает остановленную трассируемую нить, но её выполнение не начинается. Полученное состояние трассируемой нити подобно процессу, который был остановлен по B<SIGSTOP> (или другим останавливающим сигналом). Дополнительную информацию смотрите в подразделе «group-stop». B<PTRACE_LISTEN> работает только для трассируемых нитей, присоединённых с помощью B<PTRACE_SEIZE>."

#. type: TP
#: man-pages/man2/ptrace.2:658
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "B<PTRACE_KILL>"

#. type: Plain text
#: man-pages/man2/ptrace.2:667
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr "Посылает трассируемой нити сигнал B<SIGKILL> для его уничтожения (значения I<addr> и I<data> игнорируются)."

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: man-pages/man2/ptrace.2:686
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL>"
" is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr "I<Это действие устарело; не используйте его!> Вместо него отправляйте B<SIGKILL> напрямую с помощью B<kill>(2) или B<tgkill>(2). Проблема с действием B<PTRACE_KILL> в том, что оно требует, чтобы трассируемая нить была режиме signal-delivery-stop, в противном случае оно может не сработать (т. е., может завершиться без ошибок, но трассируемая нить не будет уничтожена). В отличие от него, отправка B<SIGKILL> напрямую не имеет данного ограничения."

#. type: TP
#: man-pages/man2/ptrace.2:686
#, no-wrap
msgid "B<PTRACE_INTERRUPT> (since Linux 3.4)"
msgstr "B<PTRACE_INTERRUPT> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/ptrace.2:714
msgid ""
"Stop a tracee.  If the tracee is running or sleeping in kernel space and "
"B<PTRACE_SYSCALL> is in effect, the system call is interrupted and syscall-"
"exit-stop is reported.  (The interrupted system call is restarted when the "
"tracee is restarted.)  If the tracee was already stopped by a signal and "
"B<PTRACE_LISTEN> was sent to it, the tracee stops with B<PTRACE_EVENT_STOP> "
"and I<WSTOPSIG(status)> returns the stop signal.  If any other ptrace-stop "
"is generated at the same time (for example, if a signal is sent to the "
"tracee), this ptrace-stop happens.  If none of the above applies (for "
"example, if the tracee is running in user space), it stops with "
"B<PTRACE_EVENT_STOP> with I<WSTOPSIG(status)> == B<SIGTRAP>.  "
"B<PTRACE_INTERRUPT> only works on tracees attached by B<PTRACE_SEIZE>."
msgstr "Остановить трассируемый объект. Если трассируемый объект выполняется или спит в пространстве ядра и действует B<PTRACE_SYSCALL>, то системный вызов прерывается и сообщается о syscall-exit-stop (прерванный системный вызов перезапускается при перезапуске трассируемого объекта). Если трассируемый объект был уже остановлен по сигналу и ему был послан B<PTRACE_LISTEN>, то трассируемый объект останавливается с B<PTRACE_EVENT_STOP> и I<WSTOPSIG(status)> возвращает сигнал остановки. Если в этот же момент генерируется любое другое событие ptrace-stop (например, если трассируемому посылается сигнал), то возникает ptrace-stop. Если ничего из вышеперечисленного не происходит (например, если трассируемый выполняется в пространстве пользователя), то он останавливается с B<PTRACE_EVENT_STOP> и I<WSTOPSIG(status)> == B<SIGTRAP>. B<PTRACE_INTERRUPT> работает только для трассируемых объектов, к которым подключились с помощью B<PTRACE_SEIZE>."

#. type: TP
#: man-pages/man2/ptrace.2:714
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "B<PTRACE_ATTACH>"

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: man-pages/man2/ptrace.2:742
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling"
" process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr "Выполняет присоединение к процессу с указанным I<pid>, делая его трассируемым для вызывающего процесса. Трассируемой нити посылается B<SIGSTOP>, но нет жёсткого правила, что она будет остановлен по завершению этого вызова; используйте B<waitpid>(2) для ожидания остановки трассируемой нити. Дополнительную информацию смотрите в подразделе «Присоединение и отсоединение» (значения I<addr> и I<data> игнорируются)."

#. type: TP
#: man-pages/man2/ptrace.2:742
#, no-wrap
msgid "B<PTRACE_SEIZE> (since Linux 3.4)"
msgstr "B<PTRACE_SEIZE> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/ptrace.2:762
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling"
" process.  Unlike B<PTRACE_ATTACH>, B<PTRACE_SEIZE> does not stop the "
"process.  Only a B<PTRACE_SEIZE>d process can accept B<PTRACE_INTERRUPT> and"
" B<PTRACE_LISTEN> commands.  I<addr> must be zero.  I<data> contains a bit "
"mask of ptrace options to activate immediately."
msgstr "Выполняет присоединение к процессу, указанному в I<pid>, делая его трассируемым вызвавшим процессом. В отличие от B<PTRACE_ATTACH>, B<PTRACE_SEIZE> не останавливает процесс. Только процессы, присоединённые с помощью B<PTRACE_SEIZE>, могут принимать команды B<PTRACE_INTERRUPT> и B<PTRACE_LISTEN>. Значение I<addr> должно быть 0. В I<data> содержится битовая маска параметров ptrace для немедленного применения."

#. type: TP
#: man-pages/man2/ptrace.2:762
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "B<PTRACE_DETACH>"

#. type: Plain text
#: man-pages/man2/ptrace.2:771
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it."
"  Under Linux, a tracee can be detached in this way regardless of which "
"method was used to initiate tracing.  (I<addr> is ignored.)"
msgstr "Возобновляет работу остановленной трассируемой нити, аналогично B<PTRACE_CONT>, но сначала отсоединяется от него. В Linux при помощи этого вызова трассируемая нить может быть отсоединёна независимо от того, каким методом была запущена трассировка (значение I<addr> игнорируется)."

#. type: SS
#: man-pages/man2/ptrace.2:771
#, no-wrap
msgid "Death under ptrace"
msgstr "Смерть в момент ptrace"

#. type: Plain text
#: man-pages/man2/ptrace.2:780
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose"
" disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s)."
"  Notification of this event is delivered via B<waitpid>(2)."
msgstr "Когда (возможно, многонитиевой) процесс получает уничтожающий сигнал (из-за того, что обработчик равен B<SIG_DFL> и что действием по умолчанию является уничтожение процесса), все нити завершают работу (exit). Трассируемые нити сообщают о своей смерти своим трассировщикам. Уведомления об этом событии доставляется с помощью B<waitpid>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:789
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term "
"\"signal-delivery-stop\" is explained below.)"
msgstr "Заметим, что уничтожающий сигнал сначала вызовет вхождение в режим signal-delivery-stop (только для одной трассируемой нити), и только после этого будет внедрён трассировщиком (или после того, как был отослан нити, которая не является трассируемой), затем I<все> трассируемые нити в многонитиевом процессе завершаются по сигналу (термин «signal-delivery-stop» объяснён далее)."

#. type: Plain text
#: man-pages/man2/ptrace.2:801
msgid ""
"B<SIGKILL> does not generate signal-delivery-stop and therefore the tracer "
"can't suppress it.  B<SIGKILL> kills even within system calls (syscall-exit-"
"stop is not generated prior to death by B<SIGKILL>).  The net effect is that"
" B<SIGKILL> always kills the process (all its threads), even if some threads"
" of the process are ptraced."
msgstr "Сигнал B<SIGKILL> не генерирует режим signal-delivery-stop и поэтому трассировщик не может подавить его. Сигнал B<SIGKILL> уничтожает даже внутри системных вызовов (syscall-exit-stop не генерируется перед уничтожением по B<SIGKILL>). Конечным результатом B<SIGKILL> всегда является уничтожение процесса (всех его нитей), даже если для некоторых нитей процесса выполняется трассировка."

#. type: Plain text
#: man-pages/man2/ptrace.2:806
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr "Когда трассируемая нить вызывает B<_exit>(2), он сообщает о своём уничтожении своему трассировщику. На оставшиеся нити ни какого влияния не оказывается."

#. type: Plain text
#: man-pages/man2/ptrace.2:810
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr "Если какая-нибудь нить вызывает B<exit_group>(2), то каждая трассируемая нить в этой группе нитей сообщает о своём уничтожении своему трассировщику."

#. type: Plain text
#: man-pages/man2/ptrace.2:824
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), "
"B<exit_group>(2), and signal deaths (except B<SIGKILL>), and when threads "
"are torn down on B<execve>(2)  in a multithreaded process."
msgstr "Если установлен флаг B<PTRACE_O_TRACEEXIT>, то перед непосредственным уничтожением возникает B<PTRACE_EVENT_EXIT>. Это случается при выходе посредством B<exit>(2), B<exit_group>(2) и из-за уничтожения по сигналу (за исключением B<SIGKILL>), и когда нити многонитиевого процесса разрушаются при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:849
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace call."
"  The tracer needs to keep track of the stopped/running state of the tracee,"
" and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it knows "
"that the tracee has been observed to enter ptrace-stop.  Note that there is "
"no guarantee that I<waitpid(WNOHANG)> will reliably report the tracee's "
"death status if a ptrace operation returned B<ESRCH>.  I<waitpid(WNOHANG)> "
"may return 0 instead.  In other words, the tracee may be \"not yet fully "
"dead\", but already refusing ptrace requests."
msgstr "Трассировщик не может предполагать, что трассируемая нить, остановленная по ptrace, существует. Если много случаев, когда трассируемая нить может быть уничтожена будучи в остановленном состоянии (например, по B<SIGKILL>). Поэтому, трассировщик должен быть готов обработать ошибку B<ESRCH> при любом действии ptrace. К сожалению, эта же ошибка возвращается, если трассируемая нить существует, но не остановлена по ptrace (для действий, которые требуют остановленной трассируемой нити), или если она не трассируется процессом, который вызвал ptrace. Трассировщику необходимо отслеживать состояние остановки/работы трассируемой нити и воспринимать B<ESRCH> как «трассируемая нить была неожиданно уничтожена» только, если он знает, что трассируемая нить была в состоянии ptrace-stop. Заметим, что нет гарантии того, что I<waitpid(WNOHANG)> всегда сообщит о состоянии уничтожения трассируемой нити, если действие ptrace вернуло B<ESRCH>. Вызов I<waitpid(WNOHANG)> вместо этого может вернуть 0. Другими словами, трассируемая нить может быть «ещё не полностью уничтожена», но уже отклонять действия ptrace."

#. type: Plain text
#: man-pages/man2/ptrace.2:863
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting"
" I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's"
" PID."
msgstr "Трассировщик не может предполагать, что I<всегда> поймает завершение существования трассируемой нити с помощью I<WIFEXITED(status)> или I<WIFSIGNALED(status)>; есть несколько случаев, когда этого не происходит. Например, если нить — не лидер группы нитей — вызывает B<execve>(2) и исчезает; её PID больше не появится снова, и все последующие остановки по ptrace будут приходить от PID лидера группы нитей."

#. type: SS
#: man-pages/man2/ptrace.2:863
#, no-wrap
msgid "Stopped states"
msgstr "Состояния останова"

#. type: Plain text
#: man-pages/man2/ptrace.2:885
msgid ""
"A tracee can be in two states: running or stopped.  For the purposes of "
"ptrace, a tracee which is blocked in a system call (such as B<read>(2), "
"B<pause>(2), etc.)  is nevertheless considered to be running, even if the "
"tracee is blocked for a long time.  The state of the tracee after "
"B<PTRACE_LISTEN> is somewhat of a gray area: it is not in any ptrace-stop "
"(ptrace commands won't work on it, and it will deliver B<waitpid>(2)  "
"notifications), but it also may be considered \"stopped\" because it is not "
"executing instructions (is not scheduled), and if it was in group-stop "
"before B<PTRACE_LISTEN>, it will not respond to signals until B<SIGCONT> is "
"received."
msgstr "Трассируемый может находиться в двух состояниях: выполнения или остановки. В целях ptrace, трассируемый, заблокированный в системном вызове (например, B<read>(2), B<pause>(2) и т.д.), считается выполняющимся, даже если он заблокирован уже долго. Состояние трассируемого после B<PTRACE_LISTEN> находится, отчасти, в «сумеречной зоне»: не не в каком-либо из ptrace-stop (команды ptrace не будут с ним работать и он будет посылать уведомления B<waitpid>(2)), но он также может считаться за «остановленный», так как он не выполняет инструкций (не планируется для этого), и если он был в group-stop до B<PTRACE_LISTEN>, он не будет отвечать на сигналы до тех пор, пока не получит B<SIGCONT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:889
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr "Есть много разновидностей останова, и в обсуждении ptrace они часто объединены. Поэтому очень важно использовать точную терминологию."

#. type: Plain text
#: man-pages/man2/ptrace.2:900
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  Ptrace-"
"stops can be further subdivided into I<signal-delivery-stop>, I<group-stop>,"
" I<syscall-stop>, and so on.  These stopped states are described in detail "
"below."
msgstr "В этой справочной странице любое состояние останова, в котором трассируемая нить готова выполнить действия ptrace трассировщика, называется I<ptrace-stop>. В свою очередь, ptrace-stop можно разделить на I<signal-delivery-stop>, I<group-stop>, I<syscall-stop> и так далее. Далее эти состояния останова будут описаны подробней."

#. type: Plain text
#: man-pages/man2/ptrace.2:905
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr "Когда выполняющаяся трассируемая нить входит в ptrace-stop, это видит трассировщик с помощью B<waitpid>(2) (или через другой системный вызов «wait»). В большей части текста данной справочной страницы предполагается, что трассировщик ждёт с помощью:"

#. type: Plain text
#: man-pages/man2/ptrace.2:907
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr "    pid = waitpid(pid_или_минус_1, &состояние, __WALL);\n"

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: man-pages/man2/ptrace.2:919
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr "О трассируемой нити в состоянии ptrace-stop сообщается возвратом I<pid> большим 0 и значением истины по I<WIFSTOPPED(status)>."

#. type: Plain text
#: man-pages/man2/ptrace.2:927
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr "Флаг B<__WALL> не содержит флагов B<WSTOPPED> и B<WEXITED>, но подразумевает их назначение."

#. type: Plain text
#: man-pages/man2/ptrace.2:934
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr "Устанавливать флаг B<WCONTINUED> при вызове B<waitpid>(2) не рекомендуется: состояние «continued» относится к определённому процессу и его поглощение может запутать реального родителя трассируемой нити."

#. type: Plain text
#: man-pages/man2/ptrace.2:942
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr "Использование флага B<WNOHANG> может привести к тому, что B<waitpid>(2) вернёт 0 («не ждать результатов, если они не готовы»), даже если трассировщик знает, что должно быть уведомление. Пример:"

#. type: Plain text
#: man-pages/man2/ptrace.2:951
#, no-wrap
msgid ""
"    errno = 0;\n"
"    ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"    if (errno == ESRCH) {\n"
"        /* tracee is dead */\n"
"        r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"        /* r can still be 0 here! */\n"
"    }\n"
msgstr "    errno = 0;\n    ptrace(PTRACE_CONT, pid, 0L, 0L);\n    if (errno == ESRCH) {\n        /* трассируемая нить мертва */\n        r = waitpid(tracee, &status, __WALL | WNOHANG);\n        /* r может быть 0 ! */\n    }\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:974
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, group-"
"stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the "
"I<WSTOPSIG(status)> macro can't be used to perform this examination, because"
" it returns the value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr "Существуют следующие разновидности ptrace-stop: signal-delivery-stop, group-stop, остановки B<PTRACE_EVENT>, syscall-stop. Все они могут быть получены по B<waitpid>(2) с значением истинным по I<WIFSTOPPED(status)>. Их можно различить, если проверить значение I<statusE<gt>E<gt>8>, и, если есть неоднозначность этого значения, то запросив B<PTRACE_GETSIGINFO> (замечание: для выполнения этой проверки не может использоваться макрос I<WSTOPSIG(status)>, так как он возвращает значение I<(statusE<gt>E<gt>8)\\ &\\ 0xff>)."

#. type: SS
#: man-pages/man2/ptrace.2:974
#, no-wrap
msgid "Signal-delivery-stop"
msgstr "Signal-delivery-stop"

#. type: Plain text
#: man-pages/man2/ptrace.2:994
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the signal."
"  (If the signal is generated with B<tgkill>(2), the target thread can be "
"explicitly selected by the caller.)  If the selected thread is traced, it "
"enters signal-delivery-stop.  At this point, the signal is not yet delivered"
" to the process, and can be suppressed by the tracer.  If the tracer doesn't"
" suppress the signal, it passes the signal to the tracee in the next ptrace "
"restart request.  This second step of signal delivery is called I<signal "
"injection> in this manual page.  Note that if the signal is blocked, signal-"
"delivery-stop doesn't happen until the signal is unblocked, with the usual "
"exception that B<SIGSTOP> can't be blocked."
msgstr "Когда процесс (возможно, многонитиевой) принимает какой-либо сигнал кроме B<SIGKILL>, ядро выбирает произвольную нить для его обработки (если сигнал генерируется с помощью B<tgkill>(2), то назначаемая нить может быть явно выбрана вызывающим). Если над выбранной нитью выполняется трассировка, то она попадает в режим signal-delivery-stop. В этот момент сигнал ещё не доставлен процессу и может быть отменён трассировщиком. Если трассировщик не отменил сигнал, то он передаётся трассируемой нити при следующем запросе перезапуска ptrace. Этот второй этап доставки сигнала называется в этой справочной странице I<внедрением сигнала>. Заметим, что если сигнал блокируется, то signal-delivery-stop не происходит пока сигнал не будет разблокирован (исключением, как обычно, является B<SIGSTOP>, который нельзя заблокировать)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1008
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by "
"I<WSTOPSIG(status)>.  If the signal is B<SIGTRAP>, this may be a different "
"kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below"
" for details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be"
" a group-stop; see below."
msgstr "Signal-delivery-stop наблюдается трассировщиком посредством B<waitpid>(2), возвращающим истинное значения для I<WIFSTOPPED(status)> с сигналом, который возвращается по I<WSTOPSIG(status)>. Если возвращается сигнал B<SIGTRAP>, то он может быть разновидностью ptrace-stop; смотрите разделы «Syscall-stops» и «execve» далее. Если I<WSTOPSIG(status)> возвращает останавливающий сигнал, то это может быть group-stop, смотрите далее."

#. type: SS
#: man-pages/man2/ptrace.2:1008
#, no-wrap
msgid "Signal injection and suppression"
msgstr "Внедрение и подавление сигнала"

#. type: Plain text
#: man-pages/man2/ptrace.2:1011
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr "После обнаружения трассировщиком signal-delivery-stop, он должен перезапустить трассируемую нить вызовом"

#. type: Plain text
#: man-pages/man2/ptrace.2:1013
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr "    ptrace(PTRACE_restart, pid, 0, sig)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1026
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig>"
" is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr "где B<PTRACE_restart> — одно из перезапускающих действий ptrace. Если значение I<sig> равно 0, то сигнал не доставляется. В противном случае, доставляется сигнал I<sig>. Данная операция в справочной странице называется I<внедрением сигнала> для того, чтобы можно отличить её от signal-delivery-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1032
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr "Значение I<sig> может отличаться от значения I<WSTOPSIG(status)>: трассировщик может поменять внедряемый сигнал."

#. type: Plain text
#: man-pages/man2/ptrace.2:1048
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case, system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few system calls which use a "
"different mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  "
"Even system calls (such as B<poll>(2))  which are not restartable after "
"signal are restarted after signal is suppressed; however, kernel bugs exist "
"which cause some system calls to fail with B<EINTR> even though no "
"observable signal is injected to the tracee."
msgstr "Заметим, что подавленный сигнал всё равно заставит системные вызовы завершиться как можно скорее. В этом случае системные вызовы будут перезапущены: если трассировщик использует B<PTRACE_SYSCALL>, то обнаружит, когда трассируемая нить повторно выполнила прерванный системный вызов (или системный вызов B<restart_syscall>(2) для некоторых системных вызовов, которые используют другой механизм перезапуска). Даже системные вызовы (такие как B<poll>(2)), которые не перезапускаются по сигналу, будут перезапущены после подавления сигнала; однако, в ядре существуют дефекты, из-за которых некоторые системные вызовы завершаются с ошибкой B<EINTR>, даже если наблюдаемый сигнал не был внедрён в трассируемую нить."

#. type: Plain text
#: man-pages/man2/ptrace.2:1059
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than signal-"
"delivery-stop are not guaranteed to inject a signal, even if I<sig> is "
"nonzero.  No error is reported; a nonzero I<sig> may simply be ignored.  "
"Ptrace users should not try to \"create a new signal\" this way: use "
"B<tgkill>(2)  instead."
msgstr "Перезапускающие действия ptrace, выдаваемые в ptrace-stops, отличные от signal-delivery-stop, не гарантируют внедрения сигнала, даже если значение I<sig> не равно нулю. Об ошибках не сообщается; ненулевое значение I<sig> может быть просто проигнорировано. Пользователи ptrace не должны пытаться «создать новый сигнал» таким способом — используйте вместо этого B<tgkill>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1066
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr "Тот факт, что запросы внедрения сигнала могут игнорироваться при перезапуске трассируемой нити после остановок ptrace не из signal-delivery-stops, вызывает путаницу у пользователей ptrace. Типичный сценарий: трассировщик обнаруживает group-stop, принимает его за signal-delivery-stop, перезапускает трассируемую нить с помощью"

#. type: Plain text
#: man-pages/man2/ptrace.2:1068
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"
msgstr "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1074
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr "пытаясь внедрить I<stopsig>, но I<stopsig> игнорируется и трассируемая нить продолжает выполняться."

#. type: Plain text
#: man-pages/man2/ptrace.2:1094
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before signal-delivery-"
"stop.  The tracer can't suppress this side effect (it can only suppress "
"signal injection, which only causes the B<SIGCONT> handler to not be "
"executed in the tracee, if such a handler is installed).  In fact, waking up"
" from group-stop may be followed by signal-delivery-stop for signal(s)  "
"I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> was "
"delivered.  In other words, B<SIGCONT> may be not the first signal observed "
"by the tracee after it was sent."
msgstr "Сигнал B<SIGCONT> имеет побочный эффект — пробуждает (все нити) процесс, находящийся в group-stop. Это случается перед signal-delivery-stop. Трассировщик не может повлиять на это побочное действие (он может только подавить внедрение сигнала, что приводит к тому, что обработчик B<SIGCONT> не будет выполнен в трассируемой нити, если он установлен). Фактически, пробуждение из group-stop может следовать после signal-delivery-stop для сигнала(ов) I<отличных от> B<SIGCONT>, если они ожидают момента доставки B<SIGCONT>. Другими словами, B<SIGCONT> может быть не первым сигналом, который обнаруживает трассируемую нить после её посылки."

#. type: Plain text
#: man-pages/man2/ptrace.2:1098
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This"
" side effect happens after signal injection, and therefore can be suppressed"
" by the tracer."
msgstr "Останавливающие сигналы заставляют процесс (все его нити) войти в group-stop. Данный побочный эффект возникает после внедрения сигнала, и поэтому может быть отменён трассировщиком."

#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: man-pages/man2/ptrace.2:1108
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr "В Linux 2.4 и более ранних версиях, сигнал B<SIGSTOP> не может быть внедрён."

#. type: Plain text
#: man-pages/man2/ptrace.2:1125
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the"
" I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr "Действие B<PTRACE_GETSIGINFO> может использоваться для получения структуры I<siginfo_t>, которая соответствует доставленному сигналу. Для её изменения можно использовать B<PTRACE_SETSIGINFO>. Если B<PTRACE_SETSIGINFO> использовалась для изменения I<siginfo_t>, то поле I<si_signo> и параметр I<sig> в перезапускающем действии должны совпадать, иначе результат непредсказуем."

#. type: SS
#: man-pages/man2/ptrace.2:1125
#, no-wrap
msgid "Group-stop"
msgstr "Group-stop"

#. type: Plain text
#: man-pages/man2/ptrace.2:1137
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr "Когда (возможно многонитиевой) процесс получает останавливающий сигнал, все нити останавливаются. Если для какой-то нити выполняется трассировка, то она входит в режим group-stop. Заметим, что останавливающий сигнал сначала приведёт к signal-delivery-stop (только в одной трассируемой нити) и только затем будет внедрён трассировщиком (или после того, как будет отправлен нити, над которой не выполняется трассировка), будет начат group-stop в I<всех> трассируемых нитях многонитиевого процесса. Как обычно, каждая трассируемая нить сообщает о group-stop соответствующему трассировщику."

#. type: Plain text
#: man-pages/man2/ptrace.2:1146
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via "
"I<WSTOPSIG(status)>.  The same result is returned by some other classes of "
"ptrace-stops, therefore the recommended practice is to perform the call"
msgstr "Group-stop обнаруживается трассировщиком с помощью B<waitpid>(2), который возвращается с истинным значением I<WIFSTOPPED(status)> и останавливающим сигналом из I<WSTOPSIG(status)>. Тот же результат возвращается другими классами ptrace-stops, поэтому рекомендуется выполнять вызов"

#. type: Plain text
#: man-pages/man2/ptrace.2:1148
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1169
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If"
" the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr "Вызова можно избежать, если сигнал не равен B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN> или B<SIGTTOU>; только эти четыре сигнала являются останавливающими. Если трассировщик видит что-то другое, то это не может быть group-stop. В противном случае, трассировщику нужно вызвать B<PTRACE_GETSIGINFO>. Если B<PTRACE_GETSIGINFO> завершается с ошибкой B<EINVAL>, то это определённо group-stop (возможны другие коды ошибок, например, B<ESRCH> («нет такого процесса»), если трассируемая нить уничтожена по B<SIGKILL>)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1179
msgid ""
"If tracee was attached using B<PTRACE_SEIZE>, group-stop is indicated by "
"B<PTRACE_EVENT_STOP>: I<statusE<gt>E<gt>16 == PTRACE_EVENT_STOP>.  This "
"allows detection of group-stops without requiring an extra "
"B<PTRACE_GETSIGINFO> call."
msgstr "Если подключение к трассируемому было сделано с помощью B<PTRACE_SEIZE>, то group-stop указывается B<PTRACE_EVENT_STOP>: I<statusE<gt>E<gt>16 == PTRACE_EVENT_STOP>. Это позволяет обнаружить group-stop без дополнительного вызова B<PTRACE_GETSIGINFO>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1188
msgid ""
"As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr "Начиная с Linux 2.6.38, после того как трассировщик увидит ptrace-stop трассируемой нити и пока он не перезапустит или завершит её, трассируемая нить не будет выполняться, и не будет посылать уведомления (за исключением уничтожения по B<SIGKILL>) трассировщику, даже если трассировщик войдёт в другой вызов B<waitpid>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1202
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr "Поведение ядра, описанное в предыдущем параграфе, вызывает проблемы с прозрачностью обработки останавливающих сигналов. Если трассировщик перезапускает трассируемую нить после group-stop, то останавливающий сигнал просто игнорируется — трассируемая нить продолжает выполняться. Если трассировщик не перезапускает трассируемую нить перед входом в следующий B<waitpid>(2), то о будущих сигналах B<SIGCONT> не будет сообщено трассировщику; это привело бы к тому, что сигналы B<SIGCONT> не повлияли бы на трассируемую нить."

#. type: Plain text
#: man-pages/man2/ptrace.2:1213
msgid ""
"Since Linux 3.4, there is a method to overcome this problem: instead of "
"B<PTRACE_CONT>, a B<PTRACE_LISTEN> command can be used to restart a tracee "
"in a way where it does not execute, but waits for a new event which it can "
"report via B<waitpid>(2)  (such as when it is restarted by a B<SIGCONT>)."
msgstr "Начиная с Linux 3.4, появился способ преодоления этой проблемы: вместо B<PTRACE_CONT> для перезапуска трассируемой нити можно использовать B<PTRACE_LISTEN>, при которой она не выполняется, а ждёт нового события, и это можно прочитать с помощью B<waitpid>(2) (например, когда был перезапуск по B<SIGCONT>)."

#. type: SS
#: man-pages/man2/ptrace.2:1213
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr "Остановки PTRACE_EVENT"

#. type: Plain text
#: man-pages/man2/ptrace.2:1219
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter "
"ptrace-stops called B<PTRACE_EVENT> stops."
msgstr "Если трассировщик устанавливает флаги B<PTRACE_O_TRACE_*>, то трассируемая нить будет входить в ptrace-stop-ы, называемые остановками B<PTRACE_EVENT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1233
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning"
" with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An"
" additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr "Остановки B<PTRACE_EVENT> обнаруживаются трассировщиком когда B<waitpid>(2)  возвращается с I<WIFSTOPPED(status)> и I<WSTOPSIG(status)> возвращает B<SIGTRAP>. В старшем байте слова состояния устанавливается дополнительный бит: значение I<statusE<gt>E<gt>8> будет равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:1235
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1237
msgid "The following events exist:"
msgstr "Могут происходить следующие события:"

#. type: TP
#: man-pages/man2/ptrace.2:1237
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr "B<PTRACE_EVENT_VFORK>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1250
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK>"
" flag.  When the tracee is continued after this stop, it will wait for child"
" to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr "Остановка перед возвратом из B<vfork>(2) или B<clone>(2) с флагом B<CLONE_VFORK>. Когда трассируемая нить продолжает выполняться после этой остановки, она будет ждать выхода/exec потомка перед продолжением своего исполнения (другими словами, обычное поведение при B<vfork>(2))."

#. type: TP
#: man-pages/man2/ptrace.2:1250
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1258
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set"
" to B<SIGCHLD>."
msgstr "Остановка перед возвратом из B<fork>(2) или B<clone>(2) с установленным сигналом выхода B<SIGCHLD>."

#. type: TP
#: man-pages/man2/ptrace.2:1258
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr "B<PTRACE_EVENT_CLONE>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1262
msgid "Stop before return from B<clone>(2)."
msgstr "Остановка перед возвратом из B<clone>(2)."

#. type: TP
#: man-pages/man2/ptrace.2:1262
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr "B<PTRACE_EVENT_VFORK_DONE>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1272
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK>"
" flag, but after the child unblocked this tracee by exiting or execing."
msgstr "Остановка перед возвратом из B<vfork>(2) или B<clone>(2) с установленным флагом B<CLONE_VFORK>, но после того, как потомок разблокирует эту трассируемую нить, завершив работу или выполнив exec."

#. type: Plain text
#: man-pages/man2/ptrace.2:1278
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the"
" tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be "
"used to retrieve the new thread's ID."
msgstr "Для всех четырёх остановок, описанных выше, остановка происходит в родителе (т. е., трассируемой нити), а не в только что созданной нити. Для получения ID новой нити может использовать B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:1278
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr "B<PTRACE_EVENT_EXEC>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1285
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr "Остановка перед возвратом из B<execve>(2). Начиная с Linux 3.0, B<PTRACE_GETEVENTMSG> возвращает ID бывшей нити."

#. type: TP
#: man-pages/man2/ptrace.2:1285
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr "B<PTRACE_EVENT_EXIT>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1301
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to"
" be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr "Остановка перед выходом (включая уничтожение из B<exit_group>(2)), уничтожение от сигнала или выход, вызванный B<execve>(2) в многонитиевом процессе. B<PTRACE_GETEVENTMSG> возвращает код выхода. Можно прочитать значения регистров (в отличие от случая, когда происходит «реальный» выход). Трассируемая нить всё ещё существует; для завершения выхода должно быть выполнено отсоединение с помощью B<PTRACE_CONT> или B<PTRACE_DETACH>."

#. type: TP
#: man-pages/man2/ptrace.2:1301
#, no-wrap
msgid "B<PTRACE_EVENT_STOP>"
msgstr "B<PTRACE_EVENT_STOP>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1313
msgid ""
"Stop induced by B<PTRACE_INTERRUPT> command, or group-stop, or initial "
"ptrace-stop when a new child is attached (only if attached using "
"B<PTRACE_SEIZE>), or B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used."
msgstr "Остановка вызвана командой B<PTRACE_INTERRUPT>, или group-stop, или начальным ptrace-stop при присоединении к новому потомку (только если для присоединения использовалась B<PTRACE_SEIZE>), или B<PTRACE_EVENT_STOP>, если использовалась B<PTRACE_SEIZE>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1325
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr "B<PTRACE_GETSIGINFO> при остановке B<PTRACE_EVENT> возвращает B<SIGTRAP> в I<si_signo>, а значение I<si_code> устанавливается в I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."

#. type: SS
#: man-pages/man2/ptrace.2:1325
#, no-wrap
msgid "Syscall-stops"
msgstr "Syscall-stop"

#. type: Plain text
#: man-pages/man2/ptrace.2:1338
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL>, the tracee enters syscall-"
"enter-stop just prior to entering any system call.  If the tracer restarts "
"the tracee with B<PTRACE_SYSCALL>, the tracee enters syscall-exit-stop when "
"the system call is finished, or if it is interrupted by a signal.  (That is,"
" signal-delivery-stop never happens between syscall-enter-stop and syscall-"
"exit-stop; it happens I<after> syscall-exit-stop.)"
msgstr "Если трассируемая нить была перезапущена по B<PTRACE_SYSCALL>, то она входит в режим syscall-enter-stop сразу перед тем как войти в какой-либо системный вызов. Если трассировщик перезапускает трассируемую нить с помощью B<PTRACE_SYSCALL>, то трассируемая нить входит в syscall-exit-stop при окончании системного вызова, или если она прерывается сигналом (то есть, signal-delivery-stop никогда не возникает между syscall-enter-stop и syscall-exit-stop; он возникает I<после> syscall-exit-stop)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1352
msgid ""
"Other possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop, "
"exit (if it entered B<_exit>(2)  or B<exit_group>(2)), be killed by "
"B<SIGKILL>, or die silently (if it is a thread group leader, the "
"B<execve>(2)  happened in another thread, and that thread is not traced by "
"the same tracer; this situation is discussed later)."
msgstr "Также, трассируемая нить может остановиться в остановке B<PTRACE_EVENT>, при выходе (если он вошёл в B<_exit>(2) или B<exit_group>(2)), уничтожении по сигналу B<SIGKILL>, или тихом уничтожении (если он является лидером группы нитей, возникает B<execve>(2) в другой нити, и эта нить не трассируется тем же трассировщиком; эта ситуация описана далее)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1367
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and "
"I<WSTOPSIG(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> "
"option was set by the tracer, then I<WSTOPSIG(status)> will give the value "
"I<(SIGTRAP\\ |\\ 0x80)>."
msgstr "Syscall-enter-stop и syscall-exit-stop обнаруживаются трассировщиком из B<waitpid>(2), возвращающем истинное значение I<WIFSTOPPED(status)> и I<WSTOPSIG(status)> выдающем B<SIGTRAP>. Если трассировщиком был установлен флаг B<PTRACE_O_TRACESYSGOOD>, то I<WSTOPSIG(status)> выдаст значение I<(SIGTRAP\\ |\\ 0x80)>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1373
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP>"
" by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr "Syscall-stop можно отличить от signal-delivery-stop по B<SIGTRAP>, запросив B<PTRACE_GETSIGINFO> в следующих случаях:"

#. type: TP
#: man-pages/man2/ptrace.2:1373
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr "I<si_code> E<lt>= 0"

#. type: Plain text
#: man-pages/man2/ptrace.2:1385
msgid ""
"B<SIGTRAP> was delivered as a result of a user-space action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an"
" asynchronous I/O request."
msgstr "B<SIGTRAP> был доставлен в результате действия из пространства пользователя, например, системного вызова (B<tgkill>(2), B<kill>(2), B<sigqueue>(3) и т. д.), истечении таймера POSIX, изменении состояния очереди сообщений POSIX или выполнении асинхронного запроса ввода/вывода."

#. type: TP
#: man-pages/man2/ptrace.2:1385
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr "I<si_code> == SI_KERNEL (0x80)"

#. type: Plain text
#: man-pages/man2/ptrace.2:1389
msgid "B<SIGTRAP> was sent by the kernel."
msgstr "B<SIGTRAP> был послан ядром."

#. type: TP
#: man-pages/man2/ptrace.2:1389
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr "I<si_code> == SIGTRAP или I<si_code> == (SIGTRAP|0x80)"

#. type: Plain text
#: man-pages/man2/ptrace.2:1392
msgid "This is a syscall-stop."
msgstr "Это syscall-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1397
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr "Однако, syscall-stop происходят очень часто (дважды за системный вызов), и выполнение B<PTRACE_GETSIGINFO> для каждого syscall-stop может быть отчасти накладно."

#. type: Plain text
#: man-pages/man2/ptrace.2:1420
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in syscall-enter-stop."
"  Since B<SIGTRAP> (like any other signal) always happens I<after> syscall-"
"exit-stop, and at this point I<rax> almost never contains -B<ENOSYS>, the "
"B<SIGTRAP> looks like \"syscall-stop which is not syscall-enter-stop\"; in "
"other words, it looks like a \"stray syscall-exit-stop\" and can be detected"
" this way.  But such detection is fragile and is best avoided."
msgstr "Некоторые архитектуры позволяют отличать эти случаи по значениям регистров. Например, на x86, при syscall-enter-stop I<rax> == -B<ENOSYS>. Так как B<SIGTRAP> (как и любой сигнал) всегда возникает I<после> syscall-exit-stop, и в этот момент I<rax> почти никогда не содержит B<ENOSYS>, B<SIGTRAP> выглядит как «syscall-stop, который не syscall-enter-stop»; другими словами, это выглядит как «блуждающий syscall-exit-stop» и таким способом может быть обнаружен. Но определение этим способом очень ненадёжно и лучше его не использовать."

#. type: Plain text
#: man-pages/man2/ptrace.2:1426
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr "Использование флага B<PTRACE_O_TRACESYSGOOD> — рекомендуемый метод различения syscall-stop от похожих на них других ptrace-stop, так как это надёжно и не приводит к ухудшению производительности."

#. type: Plain text
#: man-pages/man2/ptrace.2:1437
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-"
"exit-stop or vice versa.  The rule is that syscall-enter-stop is always "
"followed by syscall-exit-stop, B<PTRACE_EVENT> stop or the tracee's death; "
"no other kinds of ptrace-stop can occur in between."
msgstr "Syscall-enter-stop и syscall-exit-stop неотличимы друг от друга трассировщиком. Трассировщику требуется отслеживать последовательность ptrace-stop, чтобы правильно истолковать syscall-enter-stop как syscall-exit-stop или наоборот. Правило: за syscall-enter-stop всегда следует syscall-exit-stop, B<PTRACE_EVENT> остановка или уничтожение процесса; никаких других ptrace-stop не может возникнуть между ними."

#. type: Plain text
#: man-pages/man2/ptrace.2:1442
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than"
" B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr "Если после syscall-enter-stop трассировщик использует перезапускающее действие, отличное от B<PTRACE_SYSCALL>, то syscall-exit-stop не генерируется."

#. type: Plain text
#: man-pages/man2/ptrace.2:1454
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr "B<PTRACE_GETSIGINFO> при syscall-stop возвращает B<SIGTRAP> в I<si_signo>, значение I<si_code> устанавливается в B<SIGTRAP> или I<(SIGTRAP|0x80)>."

#. type: SS
#: man-pages/man2/ptrace.2:1454
#, no-wrap
msgid "PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops"
msgstr "Остановки PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP"

#.  FIXME
#.  document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
#.  PTRACE_SYSEMU_SINGLESTEP
#. type: Plain text
#: man-pages/man2/ptrace.2:1460
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr "[Пока не описаны.]"

#. type: SS
#: man-pages/man2/ptrace.2:1460
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr "Информационные и перезапускающие действия ptrace"

#. type: Plain text
#: man-pages/man2/ptrace.2:1470
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, "
"B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT>, and B<PTRACE_KILL>)  require the "
"tracee to be in a ptrace-stop, otherwise they fail with B<ESRCH>."
msgstr "Для большинства действий ptrace (все, за исключением B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT> и B<PTRACE_KILL>) требуется, чтобы трассируемая нить была в режиме ptrace-stop, в противном случае они завершаются с ошибкой B<ESRCH>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1475
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the"
" tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr "Когда трассируемая нить в ptrace-stop, трассировщик может читать и записывать данные в трассируемую нить с помощью информационных действий. Эти действия оставляют трассируемую нить в состоянии ptrace-stop:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1487
#, no-wrap
msgid ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"    ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr "    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n    ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n    ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1499
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr "Заметим, что о некоторых ошибках не сообщается. Например, установка информации о сигнале (I<siginfo>) может никак не отразиться в некоторых ptrace-stop, при этом вызов может завершиться без ошибок (возвращается 0 и значение I<errno> не устанавливается); действие B<PTRACE_GETEVENTMSG> может выполниться без ошибок и вернуть произвольное значение, если текущий ptrace-stop не описан как возвращающий какое-то осмысленное сообщение о событии."

#. type: Plain text
#: man-pages/man2/ptrace.2:1501
msgid "The call"
msgstr "Вызов"

#. type: Plain text
#: man-pages/man2/ptrace.2:1503
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1512
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr "затрагивает одну трассируемую нить. Текущие флаги трассируемой нити заменяются. Флаги, наследуемые новой трассируемой нитью, создаются и «автоматически присоединяются» через активные флаги B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK> или B<PTRACE_O_TRACECLONE>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1515
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr "Другая группа действий заставляет трассируемую нить, находящуюся в ptrace-stop, выполняться. Они могут иметь вид:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1517
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr "    ptrace(cmd, pid, 0, sig);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1538
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, "
"B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or "
"B<PTRACE_SYSEMU_SINGLESTEP>.  If the tracee is in signal-delivery-stop, "
"I<sig> is the signal to be injected (if it is nonzero).  Otherwise, I<sig> "
"may be ignored.  (When restarting a tracee from a ptrace-stop other than "
"signal-delivery-stop, recommended practice is to always pass 0 in I<sig>.)"
msgstr "где значение I<cmd> равно B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU> или B<PTRACE_SYSEMU_SINGLESTEP>. Если трассируемая нить в signal-delivery-stop, то в I<sig> указывается сигнал, который будет внедрён (если не равен нулю). В противном случае, I<sig> может игнорироваться (при перезапуске трассируемой нити из ptrace-stop в отличный от signal-delivery-stop, рекомендуется передавать в I<sig> значение 0)."

#. type: SS
#: man-pages/man2/ptrace.2:1538
#, no-wrap
msgid "Attaching and detaching"
msgstr "Присоединение и отсоединение"

#. type: Plain text
#: man-pages/man2/ptrace.2:1540
msgid "A thread can be attached to the tracer using the call"
msgstr "Нить можно присоединить к трассировщику с помощью вызова"

#. type: Plain text
#: man-pages/man2/ptrace.2:1542
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1544 man-pages/man2/ptrace.2:2047
msgid "or"
msgstr "или"

#. type: Plain text
#: man-pages/man2/ptrace.2:1546
#, no-wrap
msgid "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"
msgstr "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"

#.  FIXME: Describe how to attach to a thread which is already
#.         group-stopped.
#. type: Plain text
#: man-pages/man2/ptrace.2:1571
msgid ""
"B<PTRACE_ATTACH> sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr "B<PTRACE_ATTACH> посылает в нить B<SIGSTOP>. Если трассировщик хочет отменить действие B<SIGSTOP>, ему нужно его подавить. Заметим, что если при присоединении в эту нить в тоже время посылаются другие сигналы, то трассировщик может увидеть, что трассируемая нить сначала вошла в signal-delivery-stop из этих сигналов! Обычной практикой является повторное внедрение этих сигналов до тех пор, пока не будет обнаружен B<SIGSTOP>, а затем подавление внедрения B<SIGSTOP>. Здесь есть ошибка в проектировании в том, что присоединение ptrace и одновременно доставляемый B<SIGSTOP> могут состязаться и одновременный B<SIGSTOP> может быть утерян."

#. type: Plain text
#: man-pages/man2/ptrace.2:1578
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr "Так как при присоединении посылается B<SIGSTOP> и трассировщик обычно подавляет его, то это может привести к блуждающему возврату B<EINTR> из в данный момент выполняемого системного вызова в трассируемой нити, как описано в разделе «Внедрение и отмена сигнала»."

#. type: Plain text
#: man-pages/man2/ptrace.2:1590
msgid ""
"Since Linux 3.4, B<PTRACE_SEIZE> can be used instead of B<PTRACE_ATTACH>.  "
"B<PTRACE_SEIZE> does not stop the attached process.  If you need to stop it "
"after attach (or at any other time) without sending it any signals, use "
"B<PTRACE_INTERRUPT> command."
msgstr "Начиная с Linux 3.4, вместо B<PTRACE_ATTACH> можно использовать B<PTRACE_SEIZE>. B<PTRACE_SEIZE> не останавливает присоединённый. Если вам нужно остановить его после присоединения (или в любое другое время) без отправки каких-либо, используйте действие B<PTRACE_INTERRUPT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1592
msgid "The request"
msgstr "Запрос"

#. type: Plain text
#: man-pages/man2/ptrace.2:1594
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1600
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr "включает трассировку вызвавшей нити. Нить продолжает выполняться (не входит в ptrace-stop). Обычно, за B<PTRACE_TRACEME> следует"

#. type: Plain text
#: man-pages/man2/ptrace.2:1602
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr "    raise(SIGSTOP);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1605
msgid ""
"and allow the parent (which is our tracer now) to observe our signal-"
"delivery-stop."
msgstr "и это позволяет родителю (который теперь трассировщик) отследить signal-delivery-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1629
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing"
" them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr "Если включены флаги B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK> или B<PTRACE_O_TRACECLONE>, то потомок, создаваемый, соответственно, B<vfork>(2) или B<clone>(2) с флагом B<CLONE_VFORK>, B<fork>(2) или B<clone>(2) с установленным выходным сигналом равным B<SIGCHLD>, и другими видами B<clone>(2), автоматически присоединяется к тому же трассировщику, которой трассирует их родителя. Сигнал B<SIGSTOP> доставляется потомку, заставляя его войти в signal-delivery-stop после завершения системного вызова, который его создал."

#. type: Plain text
#: man-pages/man2/ptrace.2:1631
msgid "Detaching of the tracee is performed by:"
msgstr "Отсоединение от трассируемой нити выполняется с помощью:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1633
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1641
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee"
" to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr "B<PTRACE_DETACH> является перезапускающей операцией, поэтому она требует, чтобы трассируемая нить была в ptrace-stop. Если трассируемая нить в signal-delivery-stop, то может быть внедрён сигнал. В противном случае параметр I<sig> может быть проигнорирован."

#.  FIXME: Describe how to detach from a group-stopped tracee so that it
#.         doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: man-pages/man2/ptrace.2:1665
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for"
" B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design"
" bug is that this can race with concurrent B<SIGSTOP>s.  Another "
"complication is that the tracee may enter other ptrace-stops and needs to be"
" restarted and waited for again, until B<SIGSTOP> is seen.  Yet another "
"complication is to be sure that the tracee is not already ptrace-stopped, "
"because no signal delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr "Если трассировщик хочет отсоединиться,а трассируемая нить выполняется, то решением является посылка сигнала B<SIGSTOP> (с помощью B<tgkill>(2), чтобы точно достичь текущей нити), ожидание пока трассируемая нить не войдёт в signal-delivery-stop для доставки B<SIGSTOP> и затем отсоединение от неё (подавив внедрение B<SIGSTOP>). Ошибкой проектирования является возможность гонок с параллельно отправленными B<SIGSTOP>. Другая трудность в том, что трассируемая нить может войти в другой ptrace-stop и потребуется его перезапуск и повторное ожидание появления B<SIGSTOP>. Ещё одной сложностью является в проверки, что трассируемая нить уже не в ptrace-stop, так как в этом случае доставки сигнала не происходит — даже B<SIGSTOP>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1673
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from signal-"
"delivery-stop, the pending signal is injected."
msgstr "Если трассировщик завершает работу, то все трассируемые нити автоматически отсоединяются и перезапускаются, если они не в group-stop. Выполнение перезапуска из group-stop в настоящее время содержит ошибки, но «плановым» поведением считается оставить трассируемую нить остановленной и подождать B<SIGCONT>. Если трассируемая нить перезапускается из signal-delivery-stop, то внедряется ожидающий сигнал."

#. type: SS
#: man-pages/man2/ptrace.2:1673
#, no-wrap
msgid "execve(2) under ptrace"
msgstr "Выполнение execve(2) во время ptrace"

#.  clone(2) CLONE_THREAD says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: man-pages/man2/ptrace.2:1692
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr "Когда одна нить многонитиевого процесса вызывает B<execve>(2), то ядро уничтожает все остальные нити процесса и сбрасывает ID выполняющейся нити в значение ID группы нитей (ID процесса. Или, говоря иначе, когда многонитиевой процесс выполняет B<execve>(2), то по завершению вызова это выглядит как если бы B<execve>(2) произошёл в лидере группе нитей, независимо от того, какая нить вызвала B<execve>(2)). Такой сброс ID нити запутывает трассировщиков:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1702
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with"
" exit code 0."
msgstr "Все остальные нити останавливаются в останове B<PTRACE_EVENT_EXIT>, если включён флаг B<PTRACE_O_TRACEEXIT>. Затем все остальные нити, за исключением лидера группы нитей, сообщают о завершении, как если бы они кончили работу с помощью B<_exit>(2) с кодом выхода 0."

#. type: Plain text
#: man-pages/man2/ptrace.2:1710
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread"
" ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr "У исполняемой трассируемой нити изменяется ID, так как она выполняет B<execve>(2) (помните, что в ptrace «pid», возвращаемый из B<waitpid>(2) или подаваемый в вызовы ptrace, это ID трассируемой нити). То есть ID трассируемой нити сбрасывается в значение ID своего процесса, который равен ID лидера группы нитей."

#. type: Plain text
#: man-pages/man2/ptrace.2:1716
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr "Затем происходит остановка B<PTRACE_EVENT_EXEC>, если включён флаг B<PTRACE_O_TRACEEXEC>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1737
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call"
" than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was"
" traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr "Если в это время лидер группы нитей сообщил о своей остановке B<PTRACE_EVENT_EXIT> в это время, то трассировщику кажется, что завершившийся лидер группы «возник из ниоткуда» (замечание: лидер группы нитей не сообщает о завершении через I<WIFEXITED(status)> до тех пор, пока есть одна работающая нить. Это не даёт возможности трассировщику увидеть его завершение и повторное появление). Если лидер группы нитей всё ещё выполнялся, то для трассировщика может казаться, что лидер группы нитей вернулся из другого системного вызова в который входил, или даже «вернулся из системного вызова, хотя не был ни в каком системном вызове». Если лидер группы нитей не трассируется (или трассируется другим трассировщиком), то во время B<execve>(2) он выглядит так, как если бы стал трассируемым трассировщиком выполняющейся трассируемой нити."

#. type: Plain text
#: man-pages/man2/ptrace.2:1740
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr "Все перечисленные выше эффекты происходят из-за смены ID трассируемой нити."

#. type: Plain text
#: man-pages/man2/ptrace.2:1760
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0).  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr "В этой ситуации рекомендуется использовать флаг B<PTRACE_O_TRACEEXEC>. Во-первых, он включает остановку B<PTRACE_EVENT_EXEC>, которая происходит перед возвратом из B<execve>(2). В этой остановке трассировщик может использовать B<PTRACE_GETEVENTMSG> для получения предыдущего ID трассируемой нити (эта возможность появилась в Linux 3.0). Во-вторых, флаг B<PTRACE_O_TRACEEXEC> отключает устаревшую генерацию B<SIGTRAP> при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1766
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr "Когда трассировщик получает уведомление об остановке B<PTRACE_EVENT_EXEC>, гарантируется, что за исключением этой трассируемой нити и лидера группы нитей, больше живых нитей в этом процессе нет."

#. type: Plain text
#: man-pages/man2/ptrace.2:1774
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr "По получению уведомления об остановке B<PTRACE_EVENT_EXEC> трассировщик должен очистить все свои внутренние структуры данных, описывающие нити этого процесса, и оставить только одну структуру данных, которая описывает одну ещё выполняющуюся трассируемую нить, у которой"

#. type: Plain text
#: man-pages/man2/ptrace.2:1776
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr "    ID нити == ID группы нитей == ID процесса.\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1780
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr "Пример: две нити вызывают B<execve>(2) одновременно:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1791
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr "*** мы получаем syscall-enter-stop в нити 1: **\nPID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n*** мы выдаём PTRACE_SYSCALL для нити 1 **\n*** мы получаем syscall-enter-stop в нити 2: **\nPID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n*** мы выдаём PTRACE_SYSCALL для нити 2 **\n*** мы получаем PTRACE_EVENT_EXEC for PID0, мы выдаём PTRACE_SYSCALL **\n*** мы получаем syscall-exit-stop для PID0: **\nPID0 E<lt>... execve resumedE<gt> )             = 0\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1814
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, the kernel delivers an extra B<SIGTRAP> to the tracee after "
"B<execve>(2)  returns.  This is an ordinary signal (similar to one which can"
" be generated by I<kill -TRAP>), not a special kind of ptrace-stop.  "
"Employing B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set to 0 "
"(I<SI_USER>).  This signal may be blocked by signal mask, and thus may be "
"delivered (much) later."
msgstr "Если флаг B<PTRACE_O_TRACEEXEC> I<не> действует на выполняющуюся трассируемую нить, то ядро доставляет ей дополнительный B<SIGTRAP> после возврата из B<execve>(2). Это обычный сигнал (похожий на тот, который генерируется с помощью I<kill -TRAP>), а не какая-то специальная разновидность ptrace-stop. Выдача B<PTRACE_GETSIGINFO> для этого сигнала возвращает I<si_code> равный 0 (I<SI_USER>). Этот сигнал может быть блокирован маской сигналов и поэтому может быть доставлен (намного) позже."

#. type: Plain text
#: man-pages/man2/ptrace.2:1833
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this"
" extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy."
"  Setting the B<PTRACE_O_TRACEEXEC> option and thus suppressing this extra "
"B<SIGTRAP> is the recommended approach."
msgstr "Обычно, трассировщик (например, B<strace>(1)) не хотел бы показывать этот дополнительный пост-execve B<SIGTRAP> сигнал пользователю, и хотел бы подавить его доставку в трассируемую нить (если обработчик B<SIGTRAP> равен B<SIG_DFL>, то это уничтожающий сигнал). Однако, определить I<какой> B<SIGTRAP> подавлять, нелегко. Рекомендуется установить флаг B<PTRACE_O_TRACEEXEC> и затем подавить этот дополнительный B<SIGTRAP>."

#. type: SS
#: man-pages/man2/ptrace.2:1833
#, no-wrap
msgid "Real parent"
msgstr "Настоящий родитель"

#. type: Plain text
#: man-pages/man2/ptrace.2:1840
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr "Программный интерфейс ptrace использует стандартный обмен сигналами UNIX между родителем и потомком через B<waitpid>(2). Это приводит к тому, что настоящий родитель процесса перестаёт получать некоторые виды уведомлений B<waitpid>(2), когда дочерний процесс трассируется другим процессом."

#. type: Plain text
#: man-pages/man2/ptrace.2:1843
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr "Многие из этих дефектов были исправлены, но на момент версии Linux 2.6.38 некоторые из них всё ещё существуют; смотрите ДЕФЕКТЫ далее."

#. type: Plain text
#: man-pages/man2/ptrace.2:1845
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr "На момент версии Linux 2.6.38 работает правильно:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1853
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr "при выходе/уничтожении по сигналу об этом сначала сообщается трассировщику, а затем,когда трассировщик подтвердит результат B<waitpid>(2), настоящему родителю (настоящему родителю только когда завершается многонитиевой процесс целиком). Если трассировщик и реальный родитель — один и тот же процесс, то сообщение приходит лишь однажды."

#. type: Plain text
#: man-pages/man2/ptrace.2:1858
msgid ""
"On success, the B<PTRACE_PEEK*> requests return the requested data (but see "
"NOTES), while other requests return zero."
msgstr "При успешном выполнении запросы B<PTRACE_PEEK*> возвращают запрашиваемые данные (но смотрите ЗАМЕЧАНИЯ), другие запросы возвращают ноль."

#. type: Plain text
#: man-pages/man2/ptrace.2:1868
msgid ""
"On error, all requests return -1, and I<errno> is set appropriately.  Since "
"the value returned by a successful B<PTRACE_PEEK*> request may be -1, the "
"caller must clear I<errno> before the call, and then check it afterward to "
"determine whether or not an error occurred."
msgstr "При ошибке для всех действий возвращается -1, а переменной I<errno> присваивается номер ошибки. Так как значение, возвращаемое при удачном выполнении B<PTRACE_PEEK*>, может равняться -1, перед вызовом вызывающий должен очистить содержимое I<errno>, чтобы узнать, возникала ошибка или нет."

#. type: Plain text
#: man-pages/man2/ptrace.2:1872
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr "(только для i386) Произошла ошибка при размещении или освобождении отладочного регистра."

#. type: Plain text
#: man-pages/man2/ptrace.2:1883
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr "Была сделана попытка чтения или записи информации в область памяти трассируемой нити или трассировщика, но, скорее всего, эта память не отображена или недоступна. К сожалению, в Linux в разных ситуациях в результате этой ошибки возвращаются значения B<EIO> или B<EFAULT>, что не всегда поддается объяснению."

#. type: Plain text
#: man-pages/man2/ptrace.2:1886
msgid "An attempt was made to set an invalid option."
msgstr "Попытка установить недопустимое значение."

#. type: Plain text
#: man-pages/man2/ptrace.2:1893
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr "Задано неверное значение I<request>, или была попытка чтения или записи информации в неподходящую область памяти трассируемой нити или трассировщика; ошибка выравнивания слов по границе, или при запросе возобновления работы дочернего процесса был задан неверно номер сигнала."

#. type: Plain text
#: man-pages/man2/ptrace.2:1906
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons."
"  Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(8)  (PID 1)."
msgstr "Указанный процесс не может быть трассирован. Это может произойти потому, что трассировщик не имеет прав на трассировку (требуется мандат B<CAP_SYS_PTRACE>); непривилегированные процессы не могут трассировать процессы, так как они не могут посылать сигналы, или если у них установлен set-user-ID/set-group-ID бит. Также, процесс может уже трассироваться или (на ядрах до версии 2.6.26) быть B<init>(8) (PID 1)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1911
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr "Указанный процесс не существует, в данный момент не трассируется вызывающим процессом, или не остановлен (для выполнения действий, которые требуют остановки трассируемой нити)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1913
msgid "SVr4, 4.3BSD."
msgstr "SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/ptrace.2:1928
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  It is recommended to "
"always supply four arguments, even if the requested operation does not use "
"them, setting unused/ignored arguments to I<0L> or I<(void\\ *)\\ 0>."
msgstr "Хотя параметры B<ptrace>() воспринимаются согласно заданному прототипу, в настоящее время в glibc B<ptrace>() объявлена как функция с переменным числом параметров, в которой фиксирован только параметр I<request>. Рекомендуется всегда передавать четыре параметра, даже если в запрашиваемом действии они не используются (неиспользуемые аргументы указывайте как I<0L> или I<(void\\ *)\\ 0>)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1940
msgid ""
"At the system call level, the B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>, and "
"B<PTRACE_PEEKUSER> requests have a different API: they store the result at "
"the address specified by the I<data> parameter, and the return value is the "
"error flag.  The glibc wrapper function provides the API given in "
"DESCRIPTION above, with the result being returned via the function return "
"value."
msgstr "На уровне системных вызовов запросы B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA> и B<PTRACE_PEEKUSER> имеют разный программный интерфейс: они сохраняют результат по адресу, указанному в параметре I<data>, а возвращаемое значение является индикатором ошибки. Обёрточная функция glibc предоставляет программный интерфейс, описанные ОПИСАНИЕ выше, а результат возвращается в виде возвращаемого значения функции."

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: man-pages/man2/ptrace.2:1945
msgid ""
"In Linux kernels before 2.6.26, B<init>(8), the process with PID 1, may not "
"be traced."
msgstr "В ядрах Linux до версии 2.6.26, процесс B<init>(8) с PID 1 не может быть трассирован."

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: man-pages/man2/ptrace.2:1952
msgid ""
"The layout of the contents of memory and the USER area are quite operating-"
"system- and architecture-specific.  The offset supplied, and the data "
"returned, might not entirely match with the definition of I<struct user>."
msgstr "Структура памяти и области USER зависят от ОС и архитектуры системы. Указываемое смещение и возвращаемые данные могут не полностью соответствовать определению I<struct user>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1955
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr "Размер «слова» определяется вариантом ОС (например, для 32-битного варианта Linux слово будет 32-битным)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1963
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux."
"  Its behavior differs significantly on other flavors of UNIX.  In any case,"
" use of B<ptrace>()  is highly specific to the operating system and "
"architecture."
msgstr "Эта страница описывает работу системного вызова B<ptrace>() в Linux. Его работа значительно отличается от поведения в других системах UNIX. В любом случае, использование B<ptrace>() очень сильно зависит от ОС и архитектуры."

#. type: Plain text
#: man-pages/man2/ptrace.2:1974
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked"
" around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr "На машинах с заголовочными файлами ядра 2.6 значение B<PTRACE_SETOPTIONS> отличается от использованного в версии 2.4. Это приводит к тому, что приложения, скомпилированные с такими заголовочными файлами, не работают при использовании ядер 2.4. Этого можно избежать сделав B<PTRACE_SETOPTIONS> равным B<PTRACE_OLDSETOPTIONS>, если данная константа определена."

#. type: Plain text
#: man-pages/man2/ptrace.2:1977
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr "Уведомления group-stop посылаются трассировщику, но не реальному родителю. Последнее подтверждение в версии 2.6.38.6."

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME: ^^^ need to test/verify this scenario
#. type: Plain text
#: man-pages/man2/ptrace.2:2008
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls "
"B<execve>(2), the death of the thread group leader will I<never> be "
"reported.  If the execed thread is not traced by this tracer, the tracer "
"will never know that B<execve>(2)  happened.  One possible workaround is to "
"B<PTRACE_DETACH> the thread group leader instead of restarting it in this "
"case.  Last confirmed on 2.6.38.6."
msgstr "Если трассируется лидер группы нитей и завершается с помощью вызова B<_exit>(2), то происходит его останов B<PTRACE_EVENT_EXIT> (если это запрашивалось), но последующее уведомление B<WIFEXITED> не будет доставлено пока все остальные нити не завершат работу. Как объяснялось выше, если одна из остальных нитей вызывает B<execve>(2), то о завершении лидера группы I<никогда> не будет сообщено. Если исполняемая нить не трассируется этим трассировщиком, то трассировщик никогда не узнает, что происходил B<execve>(2). Одним из обходных вариантов решения  в этом случае является выполнение B<PTRACE_DETACH> для лидера группы вместо перезапуска. Последнее подтверждение в версии 2.6.38.6."

#. type: Plain text
#: man-pages/man2/ptrace.2:2018
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant"
" to always immediately kill tasks even under ptrace.  Last confirmed on "
"2.6.38.6."
msgstr "Сигнал B<SIGKILL> всё ещё может вызвать остановку B<PTRACE_EVENT_EXIT> перед настоящем завершении процесса. Это поведение может измениться в будущем; B<SIGKILL> всегда подразумевает немедленное завершение задач даже под ptrace. Последнее подтверждение в версии 2.6.38.6."

#. type: Plain text
#: man-pages/man2/ptrace.2:2036
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but"
" delivery was suppressed by the tracer.  (This is very typical operation: it"
" is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)"
"  from an B<inotify>(7)  file descriptor.  The usual symptom of this bug is "
"that when you attach to a quiescent process with the command"
msgstr "Некоторые системные вызовы возвращаются с B<EINTR>, если сигнал был послан трассируемой нити, но доставка была подавлена трассировщиком (это очень распространённая операция: она обычно выполняется отладчиками при каждом присоединении, чтобы не вызывать ненужный B<SIGSTOP>). Начиная с Linux 3.2.9, подвержены следующие системные вызовы (вероятно, это не полный список): B<epoll_wait>(2) и B<read>(2) из файлового дескриптора B<inotify>(7). Обычный симптом этой ошибки: когда вы присоединяетесь к неактивному процессу с помощью команды"

#. type: Plain text
#: man-pages/man2/ptrace.2:2038
#, no-wrap
msgid "    strace -p E<lt>process-IDE<gt>\n"
msgstr "    strace -p E<lt>process-IDE<gt>\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2041
msgid "then, instead of the usual and expected one-line output such as"
msgstr "то вместо обычного и ожидаемого вывода одной строки"

#. type: Plain text
#: man-pages/man2/ptrace.2:2044
#, no-wrap
msgid "    restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"
msgstr "    restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2050
#, no-wrap
msgid "    select(6, [5], NULL, [5], NULL_\n"
msgstr "    select(6, [5], NULL, [5], NULL_\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2054
msgid ""
"('_' denotes the cursor position), you observe more than one line.  For "
"example:"
msgstr "(«_» означает позицию курсора), вы видите несколько строк. Пример:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2058
#, no-wrap
msgid ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"
msgstr "    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n    epoll_wait(4,_\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2079
msgid ""
"What is not visible here is that the process was blocked in B<epoll_wait>(2)"
"  before B<strace>(1)  has attached to it.  Attaching caused "
"B<epoll_wait>(2)  to return to user space with the error B<EINTR>.  In this "
"particular case, the program reacted to B<EINTR> by checking the current "
"time, and then executing B<epoll_wait>(2)  again.  (Programs which do not "
"expect such \"stray\" B<EINTR> errors may behave in an unintended way upon "
"an B<strace>(1)  attach.)"
msgstr "Здесь не видно, что процесс был заблокирован в B<epoll_wait>(2) до того, как B<strace>(1) присоединился к нему. Присоединение заставляет B<epoll_wait>(2) вернуться в пользовательское пространство с ошибкой B<EINTR>. В этом частном случае, программа отвечает на B<EINTR> проверкой текущего времени и затем вызывает B<epoll_wait>(2) снова (программы, которые не ожидают таких «побочных» ошибок B<EINTR>, при присоединении B<strace>(1) могут повести себя непредсказуемо)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2092
msgid ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), "
"B<gettid>(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), "
"B<exec>(3), B<capabilities>(7), B<signal>(7)"
msgstr "B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), B<gettid>(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), B<capabilities>(7), B<signal>(7)"

#. type: TH
#: man-pages/man5/protocols.5:29
#, no-wrap
msgid "PROTOCOLS"
msgstr "PROTOCOLS"

#. type: TH
#: man-pages/man5/protocols.5:29
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: man-pages/man5/protocols.5:32
msgid "protocols - protocols definition file"
msgstr "protocols - файл определения протоколов"

#. type: Plain text
#: man-pages/man5/protocols.5:40
msgid ""
"This file is a plain ASCII file, describing the various DARPA internet "
"protocols that are available from the TCP/IP subsystem.  It should be "
"consulted instead of using the numbers in the ARPA include files, or, even "
"worse, just guessing them.  These numbers will occur in the protocol field "
"of any IP header."
msgstr "Данный файл является простым файлом в кодировке ASCII и описывает различные протоколы DARPA internet, которые доступны через подсистему TCP/IP. Вместо того, чтобы использовать номера протоколов из заголовочных (include) файлов ARPA или, ещё хуже, строить догадки относительно номеров протоколов, нужно использовать данный файл. Номера протоколов присутствуют в поле протокола в любом IP-заголовке."

#.  .. by the DDN Network Information Center.
#. type: Plain text
#: man-pages/man5/protocols.5:46
msgid ""
"Keep this file untouched since changes would result in incorrect IP "
"packages.  Protocol numbers and names are specified by the IANA (Internet "
"Assigned Numbers Authority)."
msgstr "Не изменяйте этот файл, так как изменения могут привести к некорректному формированию IP-пакетов. Номера протоколов и их имена определяются Центром Сетевой Информации (DDN Network Information Center)."

#. type: Plain text
#: man-pages/man5/protocols.5:48
msgid "Each line is of the following format:"
msgstr "Каждая строка файла имеет следующий формат:"

#. type: Plain text
#: man-pages/man5/protocols.5:51
msgid "I<protocol number aliases ...>"
msgstr "I<протокол номер псевдоним ...>"

#. type: Plain text
#: man-pages/man5/protocols.5:57
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored."
"  If a line contains a hash mark (#), the hash mark and the part of the line"
" following it are ignored."
msgstr "Поля отделяются друг от друга пробелами или символами табуляции. Пустые строки игнорируются. Если строка содержит символ решётки (#), то он сам и часть строки, которая следует за этим символом, игнорируется."

#. type: Plain text
#: man-pages/man5/protocols.5:59
msgid "The field descriptions are:"
msgstr "Описание полей:"

#. type: TP
#: man-pages/man5/protocols.5:59
#, no-wrap
msgid "I<protocol>"
msgstr "I<протокол>"

#. type: Plain text
#: man-pages/man5/protocols.5:67
msgid ""
"the native name for the protocol.  For example I<ip>, I<tcp>, or I<udp>."
msgstr "Имя протокола. Например, I<ip>, I<tcp> или I<udp>."

#. type: TP
#: man-pages/man5/protocols.5:67
#, no-wrap
msgid "I<number>"
msgstr "I<номер>"

#. type: Plain text
#: man-pages/man5/protocols.5:71
msgid ""
"the official number for this protocol as it will appear within the IP "
"header."
msgstr "Официальный номер этого протокола, который будет помещаться в IP-заголовок."

#. type: TP
#: man-pages/man5/protocols.5:71
#, no-wrap
msgid "I<aliases>"
msgstr "I<псевдонимы>"

#. type: Plain text
#: man-pages/man5/protocols.5:74
msgid "optional aliases for the protocol."
msgstr "Необязательные псевдонимы этого протокола."

#. type: Plain text
#: man-pages/man5/protocols.5:77
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr "Данный файл может распространяться по сети с помощью сетевых служб имён, таких как Yellow Pages/NIS или BIND/Hesiod."

#. type: TP
#: man-pages/man5/protocols.5:78
#, no-wrap
msgid "I</etc/protocols>"
msgstr "I</etc/protocols>"

#. type: Plain text
#: man-pages/man5/protocols.5:81
msgid "The protocols definition file."
msgstr "Файл определения протоколов."

#. type: Plain text
#: man-pages/man5/protocols.5:83
msgid "B<getprotoent>(3)"
msgstr "B<getprotoent>(3)"

#. type: Plain text
#: man-pages/man5/protocols.5:85
msgid "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"
msgstr "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"

#. type: TH
#: man-pages/man5/proc.5:55
#, no-wrap
msgid "PROC"
msgstr "PROC"

#. type: Plain text
#: man-pages/man5/proc.5:58
msgid "proc - process information pseudo-filesystem"
msgstr "proc - псевдо-файловая система с информацией о процессах"

#. type: Plain text
#: man-pages/man5/proc.5:67
msgid ""
"The I<proc> filesystem is a pseudo-filesystem which provides an interface to"
" kernel data structures.  It is commonly mounted at I</proc>.  Most of it is"
" read-only, but some files allow kernel variables to be changed."
msgstr "Файловая система I<proc> — это псевдо-файловая система, которая используется в качестве интерфейса к структурам данных ядра. Обычно она монтируется в I</proc>. Её большая часть доступна только для чтения, однако некоторые файлы позволяют изменять значения переменных ядра."

#. type: Plain text
#: man-pages/man5/proc.5:71
msgid ""
"The following list describes many of the files and directories under the "
"I</proc> hierarchy."
msgstr "В следующем списке описаны многие файлы и каталоги в иерархии I</proc>."

#. type: TP
#: man-pages/man5/proc.5:72
#, no-wrap
msgid "I</proc/[pid]>"
msgstr "I</proc/[pid]>"

#.  FIXME Describe /proc/[pid]/attr and
#.      /proc/[pid]/task/[tid]/attr
#. 	This is a directory
#.      Added in 2.6.0
#. 	CONFIG_SECURITY
#. 	https://lwn.net/Articles/28222/
#. 	http://www.nsa.gov/research/_files/selinux/papers/module/x362.shtml
#. 	fscreate, current, prev, and exec present in Linux 2.6.0
#. 	keycreate added in Linux 2.6.18
#. 		commit 4eb582cf1fbd7b9e5f466e3718a59c957e75254e
#. 		/Documentation/keys.txt
#. 	sockcreate added in Linux 2.6.18
#. 		commit 42c3e03ef6b298813557cdb997bd6db619cd65a2
#.  FIXME Describe /proc/[pid]/autogroup
#. 	2.6.38
#. 	commit 5091faa449ee0b7d73bc296a93bca9540fc51d0a
#.  	CONFIG_SCHED_AUTOGROUP
#. type: Plain text
#: man-pages/man5/proc.5:98
msgid ""
"There is a numerical subdirectory for each running process; the subdirectory"
" is named by the process ID.  Each such subdirectory contains the following "
"pseudo-files and directories."
msgstr "Эти числовые подкаталоги соответствуют работающим процессам; имя подкаталога соответствует идентификатору процесса. Каждый подкаталог содержит следующие псевдо-файлы и каталоги."

#. type: TP
#: man-pages/man5/proc.5:98
#, no-wrap
msgid "I</proc/[pid]/auxv> (since 2.6.0-test7)"
msgstr "I</proc/[pid]/auxv> (начиная с версии 2.6.0-test7)"

#. type: Plain text
#: man-pages/man5/proc.5:107
msgid ""
"This contains the contents of the ELF interpreter information passed to the "
"process at exec time.  The format is one I<unsigned long> ID plus one "
"I<unsigned long> value for each entry.  The last entry contains two zeros.  "
"See also B<getauxval>(3)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:107
#, no-wrap
msgid "I</proc/[pid]/cgroup> (since Linux 2.6.24)"
msgstr "I</proc/[pid]/cgroup> (начиная с Linux 2.6.24)"

#.  	  Info in Documentation/cgroups/cgroups.txt
#. type: Plain text
#: man-pages/man5/proc.5:113
msgid ""
"This file describes control groups to which the process/task belongs.  For "
"each cgroup hierarchy there is one entry containing colon-separated fields "
"of the form:"
msgstr "В этом файле описаны группы управления, которым принадлежит процесс/задача. Каждая иерархия cgroup описывается одним элементом, состоящим из следующих полей (через двоеточие):"

#. type: Plain text
#: man-pages/man5/proc.5:117
#, no-wrap
msgid "CW<    5:cpuacct,cpu,cpuset:/daemons>\n"
msgstr "CW<    5:cpuacct,cpu,cpuset:/daemons>\n"

#. type: Plain text
#: man-pages/man5/proc.5:121
msgid "The colon-separated fields are, from left to right:"
msgstr "Поля, разделяемые двоеточием, слева направо:"

#. type: IP
#: man-pages/man5/proc.5:122
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man5/proc.5:124
msgid "hierarchy ID number"
msgstr "идентификационный номер иерархии"

#. type: IP
#: man-pages/man5/proc.5:124
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man5/proc.5:126
msgid "set of subsystems bound to the hierarchy"
msgstr "список подсистем, привязанных к иерархии"

#. type: IP
#: man-pages/man5/proc.5:126
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man5/proc.5:128
msgid "control group in the hierarchy to which the process belongs"
msgstr "управляющая группа в иерархии, которой принадлежит процесс"

#. type: Plain text
#: man-pages/man5/proc.5:133
msgid ""
"This file is present only if the B<CONFIG_CGROUPS> kernel configuration "
"option is enabled."
msgstr "Этот файл существует только, если включён параметр настройки ядра B<CONFIG_CGROUPS>."

#. type: TP
#: man-pages/man5/proc.5:133
#, no-wrap
msgid "I</proc/[pid]/clear_refs> (since Linux 2.6.22)"
msgstr "I</proc/[pid]/clear_refs> (начиная с Linux 2.6.22)"

#.  commit b813e931b4c8235bb42e301096ea97dbdee3e8fe (2.6.22)
#.  commit 398499d5f3613c47f2143b8c54a04efb5d7a6da9 (2.6.32)
#.  commit 040fa02077de01c7e08fa75be6125e4ca5636011 (3.11)
#.        "Clears page referenced bits shown in smaps output"
#.        write-only, writable only by the owner of the process
#. type: Plain text
#: man-pages/man5/proc.5:143
msgid "This is a write-only file, writable only by owner of the process."
msgstr "Данный файл доступен только для записи и только владельцу процесса."

#. type: Plain text
#: man-pages/man5/proc.5:145
msgid "The following values may be written to the file:"
msgstr "В файл могут быть записаны следующие значения:"

#. type: TP
#: man-pages/man5/proc.5:146
#, no-wrap
msgid "1 (since Linux 2.6.22)"
msgstr "1 (начиная с Linux 2.6.22)"

#.  Internally: CLEAR_REFS_ALL
#. type: Plain text
#: man-pages/man5/proc.5:153
msgid ""
"Reset the PG_Referenced and ACCESSED/YOUNG bits for all the pages associated"
" with the process.  (Before kernel 2.6.32, writing any nonzero value to this"
" file had this effect.)"
msgstr "Сбросить биты PG_Referenced и ACCESSED/YOUNG для всех страниц, связанных с процессом (до ядра версии 2.6.32, такое действие происходило при записи любого ненулевого значения в этот файл)."

#. type: TP
#: man-pages/man5/proc.5:153
#, no-wrap
msgid "2 (since Linux 2.6.32)"
msgstr "2 (начиная с Linux 2.6.32)"

#.  Internally: CLEAR_REFS_ANON
#. type: Plain text
#: man-pages/man5/proc.5:158
msgid ""
"Reset the PG_Referenced and ACCESSED/YOUNG bits for all anonymous pages "
"associated with the process."
msgstr "Сбросить биты PG_Referenced и ACCESSED/YOUNG для всех анонимных страниц, связанных с процессом."

#. type: TP
#: man-pages/man5/proc.5:158
#, no-wrap
msgid "3 (since Linux 2.6.32)"
msgstr "3 (начиная с Linux 2.6.32)"

#.  Internally: CLEAR_REFS_MAPPED
#. type: Plain text
#: man-pages/man5/proc.5:163
msgid ""
"Reset the PG_Referenced and ACCESSED/YOUNG bits for all file-mapped pages "
"associated with the process."
msgstr "Сбросить биты PG_Referenced и ACCESSED/YOUNG для всех страниц отображения файлов, связанных с процессом."

#. type: Plain text
#: man-pages/man5/proc.5:179
msgid ""
"Clearing the PG_Referenced and ACCESSED/YOUNG bits provides a method to "
"measure approximately how much memory a process is using.  One first "
"inspects the values in the \"Referenced\" fields for the VMAs shown in "
"I</proc/[pid]/smaps> to get an idea of the memory footprint of the process."
"  One then clears the PG_Referenced and ACCESSED/YOUNG bits and, after some "
"measured time interval, once again inspects the values in the \"Referenced\""
" fields to get an idea of the change in memory footprint of the process "
"during the measured interval.  If one is interested only in inspecting the "
"selected mapping types, then the value 2 or 3 can be used instead of 1."
msgstr "Очистка бит PG_Referenced и ACCESSED/YOUNG предоставляет метод приблизительного измерения количества памяти, используемой процессом. Во-первых, нужно прочитать значения в полях «Referenced» для VMA, показанных в I</proc/[pid]/smaps>, и получить объём используемой процессом памяти. Во-вторых, очистить биты PG_Referenced и ACCESSED/YOUNG и после некоторого известного временного интервала ещё раз прочитать значения в полях «Referenced», чтобы получить размер используемой процессом памяти за известный интервал. Если это интересно только для изучения выбранных типов отображения, то вместо значение 1 можно использовать 2 или 3."

#. type: Plain text
#: man-pages/man5/proc.5:181
msgid "A further value can be written to affect a different bit:"
msgstr "Ещё одно значение может записано, чтобы изменить другой бит:"

#. type: TP
#: man-pages/man5/proc.5:182
#, no-wrap
msgid "4 (since Linux 3.11)"
msgstr "4 (начиная с Linux 3.11)"

#.  Internally: CLEAR_REFS_SOFT_DIRTY
#. type: Plain text
#: man-pages/man5/proc.5:192
msgid ""
"Clear the soft-dirty bit for all the pages associated with the process.  "
"This is used (in conjunction with I</proc/[pid]/pagemap>)  by the check-"
"point restore system to discover which pages of a process have been dirtied "
"since the file I</proc/[pid]/clear_refs> was written to."
msgstr "Очистить бит несильного загрязнения (soft-dirty) для всех страниц, связанных с процессом. Это используется (вместе с I</proc/[pid]/pagemap>) системой восстановления контрольной точки для обнаружения какие страницы процесса были испачканы (dirtied) из-за записи в файл I</proc/[pid]/clear_refs>."

#. type: Plain text
#: man-pages/man5/proc.5:197
msgid ""
"Writing any value to I</proc/[pid]/clear_refs> other than those listed above"
" has no effect."
msgstr "Запись любого значения в I</proc/[pid]/clear_refs>, отличного от перечисленных выше, ничего не меняет."

#. type: Plain text
#: man-pages/man5/proc.5:203
msgid ""
"The I</proc/[pid]/clear_refs> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr "Файл I</proc/[pid]/clear_refs> существует только, если если включён параметр настройки ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:203
#, no-wrap
msgid "I</proc/[pid]/cmdline>"
msgstr "I</proc/[pid]/cmdline>"

#.  In 2.3.26, this also used to be true if the process was swapped out.
#. type: Plain text
#: man-pages/man5/proc.5:213
msgid ""
"This read-only file holds the complete command line for the process, unless "
"the process is a zombie.  In the latter case, there is nothing in this file:"
" that is, a read on this file will return 0 characters.  The command-line "
"arguments appear in this file as a set of strings separated by null bytes "
"(\\(aq\\e0\\(aq), with a further null byte after the last string."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:213
#, no-wrap
msgid "I</proc/[pid]/comm> (since Linux 2.6.33)"
msgstr ""

#.  commit 4614a696bd1c3a9af3a08f0e5874830a85b889d4
#. type: Plain text
#: man-pages/man5/proc.5:235
msgid ""
"This file exposes the process's I<comm> value\\(emthat is, the command name "
"associated with the process.  Different threads in the same process may have"
" different I<comm> values, accessible via I</proc/[pid]/task/[tid]/comm>.  A"
" thread may modify its I<comm> value, or that of any of other thread in the "
"same thread group (see the discussion of B<CLONE_THREAD> in B<clone>(2)), by"
" writing to the file I</proc/self/task/[tid]/comm>.  Strings longer than "
"B<TASK_COMM_LEN> (16) characters are silently truncated."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:244
msgid ""
"This file provides a superset of the B<prctl>(2)  B<PR_SET_NAME> and "
"B<PR_GET_NAME> operations, and is employed by B<pthread_setname_np>(3)  when"
" used to rename threads other than the caller."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:244
#, no-wrap
msgid "I</proc/[pid]/coredump_filter> (since kernel 2.6.23)"
msgstr "I</proc/[pid]/coredump_filter> (начиная с версии 2.6.23)"

#. type: Plain text
#: man-pages/man5/proc.5:248 man-pages/man5/proc.5:3274
#: man-pages/man5/proc.5:3278
msgid "See B<core>(5)."
msgstr "Смотрите B<core>(5)."

#. type: TP
#: man-pages/man5/proc.5:248
#, no-wrap
msgid "I</proc/[pid]/cpuset> (since kernel 2.6.12)"
msgstr "I</proc/[pid]/cpuset> (начиная с версии 2.6.12)"

#.  and /proc/[pid]/task/[tid]/cpuset
#. type: Plain text
#: man-pages/man5/proc.5:253
msgid "See B<cpuset>(7)."
msgstr "Смотрите B<cpuset>(7)."

#. type: TP
#: man-pages/man5/proc.5:253
#, no-wrap
msgid "I</proc/[pid]/cwd>"
msgstr "I</proc/[pid]/cwd>"

#. type: Plain text
#: man-pages/man5/proc.5:258
msgid ""
"This is a symbolic link to the current working directory of the process.  To"
" find out the current working directory of process 20, for instance, you can"
" do this:"
msgstr "Это символьная ссылка на текущий рабочий каталог процесса. Например, чтобы узнать текущий каталог процесса 20, вы должны проделать следующее:"

#. type: Plain text
#: man-pages/man5/proc.5:262
#, no-wrap
msgid "$B< cd /proc/20/cwd; /bin/pwd>\n"
msgstr "$B< cd /proc/20/cwd; /bin/pwd>\n"

#. type: Plain text
#: man-pages/man5/proc.5:273
msgid ""
"Note that the I<pwd> command is often a shell built-in, and might not work "
"properly.  In B<bash>(1), you may use I<pwd\\ -P>."
msgstr "Отметим, что команда I<pwd> часто является встроенной в оболочку, и поэтому может работать не корректно. В B<bash>(1) вы можете воспользоваться I<pwd\\ -P>."

#.  The following was still true as at kernel 2.6.13
#.  FIXME Describe /proc/[pid]/seccomp
#.        Added in 2.6.12
#.  FIXME Describe /proc/[pid]/sessionid
#.        Added in 2.6.25; read-only; only readable by real UID
#. 	  commit 1e0bd7550ea9cf474b1ad4c6ff5729a507f75fdc
#.        CONFIG_AUDITSYSCALL
#.  FIXME Describe /proc/[pid]/sched
#.        Added in 2.6.23
#.        CONFIG_SCHED_DEBUG, and additional fields if CONFIG_SCHEDSTATS
#.        Displays various scheduling parameters
#.        This file can be written, to reset stats
#.        The set of fields exposed by this file have changed
#. 	  significantly over time.
#.        commit 43ae34cb4cd650d1eb4460a8253a8e747ba052ac
#.  FIXME Describe /proc/[pid]/schedstats and
#.        /proc/[pid]/task/[tid]/schedstats
#.        Added in 2.6.9
#.        CONFIG_SCHEDSTATS
#. type: Plain text
#: man-pages/man5/proc.5:279 man-pages/man5/proc.5:1133
msgid ""
"In a multithreaded process, the contents of this symbolic link are not "
"available if the main thread has already terminated (typically by calling "
"B<pthread_exit>(3))."
msgstr "В многонитиевых процессах, содержимое этой символьной ссылки недоступно, если головная нить уже завершила работу (обычно с помощью вызова B<pthread_exit>(3))."

#. type: TP
#: man-pages/man5/proc.5:279
#, no-wrap
msgid "I</proc/[pid]/environ>"
msgstr "I</proc/[pid]/environ>"

#. type: Plain text
#: man-pages/man5/proc.5:285
msgid ""
"This file contains the environment for the process.  The entries are "
"separated by null bytes (\\(aq\\e0\\(aq), and there may be a null byte at "
"the end.  Thus, to print out the environment of process 1, you would do:"
msgstr "Этот файл содержит переменные окружения процесса. Элементы разделяются нулевыми байтами (\\(aq\\e0\\(aq), а также может быть нулевой байт в конце. Так, чтобы вывести переменные окружения процесса 1, вы можете сделать следующее:"

#. type: Plain text
#: man-pages/man5/proc.5:290
#, no-wrap
msgid "$B< strings /proc/1/environ>\n"
msgstr "$B< strings /proc/1/environ>\n"

#. type: TP
#: man-pages/man5/proc.5:293
#, no-wrap
msgid "I</proc/[pid]/exe>"
msgstr "I</proc/[pid]/exe>"

#.  The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:308
msgid ""
"Under Linux 2.2 and later, this file is a symbolic link containing the "
"actual pathname of the executed command.  This symbolic link can be "
"dereferenced normally; attempting to open it will open the executable.  You "
"can even type I</proc/[pid]/exe> to run another copy of the same executable "
"as is being run by process [pid].  In a multithreaded process, the contents "
"of this symbolic link are not available if the main thread has already "
"terminated (typically by calling B<pthread_exit>(3))."
msgstr "В ядрах Linux 2.2 и более поздних, этот файл является символьной ссылкой, содержащей полное имя файла выполняемой команды. Эта символьная ссылка обычно может быть разыменована; при попытке открыть её откроется выполняемый файл. Вы можете ввести I</proc/[pid]/exe>, чтобы запустить другую копию того же выполняемого файла, что выполняется системой в качестве процесса [pid]. В многонитиевых процессах содержимое этой символьной ссылки недоступно, если главная нить уже завершила работу (обычно с помощью вызова B<pthread_exit>(3))."

#. type: Plain text
#: man-pages/man5/proc.5:316
msgid ""
"Under Linux 2.0 and earlier, I</proc/[pid]/exe> is a pointer to the binary "
"which was executed, and appears as a symbolic link.  A B<readlink>(2)  call "
"on this file under Linux 2.0 returns a string in the format:"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:318
#, no-wrap
msgid "    [device]:inode\n"
msgstr "    [device]:inode\n"

#. type: Plain text
#: man-pages/man5/proc.5:321
msgid ""
"For example, [0301]:1502 would be inode 1502 on device major 03 (IDE, MFM, "
"etc. drives) minor 01 (first partition on the first drive)."
msgstr "Например, [0301]:1502 указывает на inode 1502 на устройстве со старшим номером устройства 03 (IDE, MFM, и т.п. диски), младшим номером 01 (первый раздел на первом диске)."

#. type: Plain text
#: man-pages/man5/proc.5:326
msgid "B<find>(1)  with the I<-inum> option can be used to locate the file."
msgstr "Для поиска файла можно воспользоваться B<find>(1) с параметром I<-inum>."

#. type: TP
#: man-pages/man5/proc.5:326
#, no-wrap
msgid "I</proc/[pid]/fd/>"
msgstr "I</proc/[pid]/fd/>"

#. type: Plain text
#: man-pages/man5/proc.5:332
msgid ""
"This is a subdirectory containing one entry for each file which the process "
"has open, named by its file descriptor, and which is a symbolic link to the "
"actual file.  Thus, 0 is standard input, 1 standard output, 2 standard "
"error, and so on."
msgstr "Этот подкаталог содержит одну запись для каждого файла, открытого процессом, именем является номер его файлового дескриптора, и которая является символьной ссылкой на настоящий файл. Так, 0 — это стандартный поток ввода, 1 — стандартный поток вывода, 2 — стандартный поток ошибок и т.п."

#. type: Plain text
#: man-pages/man5/proc.5:339
msgid ""
"For file descriptors for pipes and sockets, the entries will be symbolic "
"links whose content is the file type with the inode.  A B<readlink>(2)  call"
" on this file returns a string in the format:"
msgstr "Для файловых дескрипторов каналов и сокетов записи будут символьными ссылками, содержимое которых — тип файла и inode. Вызов B<readlink>(2) для такого файла вернёт строку в формате:"

#. type: Plain text
#: man-pages/man5/proc.5:341
#, no-wrap
msgid "    type:[inode]\n"
msgstr "    тип:[inode]\n"

#. type: Plain text
#: man-pages/man5/proc.5:348
msgid ""
"For example, I<socket:[2248868]> will be a socket and its inode is 2248868."
"  For sockets, that inode can be used to find more information in one of the"
" files under I</proc/net/>."
msgstr "Например, I<socket:[2248868]> — для сокета с inode 2248868. Для сокетов эту inode можно использовать для поиска дополнительной информации в одном из файлов в I</proc/net/>."

#. type: Plain text
#: man-pages/man5/proc.5:358
msgid ""
"For file descriptors that have no corresponding inode (e.g., file "
"descriptors produced by B<epoll_create>(2), B<eventfd>(2), "
"B<inotify_init>(2), B<signalfd>(2), and B<timerfd>(2)), the entry will be a "
"symbolic link with contents of the form"
msgstr "Для файловых дескриптор без соответствующей inode (например, файловые дескрипторы, создаваемые B<epoll_create>(2), B<eventfd>(2), B<inotify_init>(2), B<signalfd>(2) и B<timerfd>(2)), запись будет символьной ссылкой с содержимым в виде"

#. type: Plain text
#: man-pages/man5/proc.5:360
#, no-wrap
msgid "    anon_inode:E<lt>file-typeE<gt>\n"
msgstr "    anon_inode:E<lt>тип-файлаE<gt>\n"

#. type: Plain text
#: man-pages/man5/proc.5:364
msgid "In some cases, the I<file-type> is surrounded by square brackets."
msgstr "В некоторых случаях I<file-type> заключается в квадратные скобки."

#. type: Plain text
#: man-pages/man5/proc.5:368
msgid ""
"For example, an epoll file descriptor will have a symbolic link whose "
"content is the string I<anon_inode:[eventpoll]>."
msgstr "Например, файловый дескриптор epoll будет иметь символьную ссылку с содержимым в виде строки I<anon_inode:[eventpoll]>."

#. The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:374
msgid ""
"In a multithreaded process, the contents of this directory are not available"
" if the main thread has already terminated (typically by calling "
"B<pthread_exit>(3))."
msgstr "В многонитиевых процессах, содержимое этого каталога недоступно, если главная нить уже завершила работу (обычно при помощи вызова B<pthread_exit>(3))."

#. type: Plain text
#: man-pages/man5/proc.5:387
msgid ""
"Programs that will take a filename as a command-line argument, but will not "
"take input from standard input if no argument is supplied, or that write to "
"a file named as a command-line argument, but will not send their output to "
"standard output if no argument is supplied, can nevertheless be made to use "
"standard input or standard out using I</proc/[pid]/fd>.  For example, "
"assuming that I<-i> is the flag designating an input file and I<-o> is the "
"flag designating an output file:"
msgstr "Программы, использующие указанные в аргументах файлы в качестве стандартного потока ввода или стандартного потока вывода, но не использующие свои настоящие стандартный поток ввода или стандартный поток вывода, тем не менее могут использоваться для работы с настоящими стандартным потоком ввода или стандартным потоком вывода, если воспользоваться для этого I</proc/[pid]/fd>. Например, подразумевая что I<-i> является флагом, обозначающим входной файл и I<-o> является флагом, обозначающим выходной файл, вы можете указать:"

#. type: Plain text
#: man-pages/man5/proc.5:391
#, no-wrap
msgid "$B< foobar -i /proc/self/fd/0 -o /proc/self/fd/1 ...>\n"
msgstr "$B< foobar -i /proc/self/fd/0 -o /proc/self/fd/1 ...>\n"

#.  The following is not true in my tests (MTK):
#.  Note that this will not work for
#.  programs that seek on their files, as the files in the fd directory
#.  are not seekable.
#. type: Plain text
#: man-pages/man5/proc.5:399
msgid "and you have a working filter."
msgstr "и вы получите работающий фильтр."

#. type: Plain text
#: man-pages/man5/proc.5:409
msgid ""
"I</proc/self/fd/N> is approximately the same as I</dev/fd/N> in some UNIX "
"and UNIX-like systems.  Most Linux MAKEDEV scripts symbolically link "
"I</dev/fd> to I</proc/self/fd>, in fact."
msgstr "I</proc/self/fd/N> \\(em это примерно то же, что и I</dev/fd/N> на некоторых системах UNIX и подобных им. Фактически, большинство сценариев MAKEDEV в Linux создают символьную ссылку с именем I</dev/fd> на файл I</proc/self/fd>."

#. type: Plain text
#: man-pages/man5/proc.5:423
msgid ""
"Most systems provide symbolic links I</dev/stdin>, I</dev/stdout>, and "
"I</dev/stderr>, which respectively link to the files I<0>, I<1>, and I<2> in"
" I</proc/self/fd>.  Thus the example command above could be written as:"
msgstr "Большинство систем предоставляют символьные ссылки I</dev/stdin>, I</dev/stdout> и I</dev/stderr>, которые соответствуют ссылкам на файлы I<0>, I<1> и I<2> в I</proc/self/fd>. Так, пример указанной выше команды может быть переписан в следующем виде:"

#. type: Plain text
#: man-pages/man5/proc.5:427
#, no-wrap
msgid "$B< foobar -i /dev/stdin -o /dev/stdout ...>\n"
msgstr "$B< foobar -i /dev/stdin -o /dev/stdout ...>\n"

#. type: TP
#: man-pages/man5/proc.5:432
#, no-wrap
msgid "I</proc/[pid]/fdinfo/> (since kernel 2.6.22)"
msgstr "I</proc/[pid]/fdinfo/> (начиная с версии 2.6.22)"

#. type: Plain text
#: man-pages/man5/proc.5:438
msgid ""
"This is a subdirectory containing one entry for each file which the process "
"has open, named by its file descriptor.  The contents of each file can be "
"read to obtain information about the corresponding file descriptor, for "
"example:"
msgstr "Это подкаталог, содержащий по одной записи для каждого файла, открытого процессом, называемой его файловым дескриптором. Содержимое каждого файла может быть прочитано для получения информации о соответствующем файловом дескрипторе, например:"

#. type: Plain text
#: man-pages/man5/proc.5:444
#, no-wrap
msgid ""
"$B< cat /proc/12015/fdinfo/4>\n"
"pos:    1000\n"
"flags:  01002002\n"
msgstr "$B< cat /proc/12015/fdinfo/4>\npos:    1000\nflags:  01002002\n"

#. type: Plain text
#: man-pages/man5/proc.5:455
msgid ""
"The I<pos> field is a decimal number showing the current file offset.  The "
"I<flags> field is an octal number that displays the file access mode and "
"file status flags (see B<open>(2))."
msgstr "Поле I<pos> содержит десятичное число, показывающее текущее смещение в файле. Поле I<flags> содержит восьмеричное число, отображающее режим доступа к файлу и флаги состояния файла (см. B<open>(2))."

#.  FIXME
#.  Certain file types include additional info; see
#.  Documentation/filesystems/proc.txt
#.  Especially interesting is this:
#.      commit ab49bdecc3ebb46ab661f5f05d5c5ea9606406c6
#.      Author: Cyrill Gorcunov <gorcunov@openvz.org>
#.      Date:   Mon Dec 17 16:05:06 2012 -0800
#.  Basically, the /proc/PID/fdinfo/ entry for an inotify FD
#.  includes the file handles for all watched FDs
#. type: Plain text
#: man-pages/man5/proc.5:470
msgid ""
"The files in this directory are readable only by the owner of the process."
msgstr "Файлы в этом каталоге доступны на чтение только владельцу процесса."

#. type: TP
#: man-pages/man5/proc.5:470
#, no-wrap
msgid "I</proc/[pid]/io> (since kernel 2.6.20)"
msgstr "I</proc/[pid]/io> (начиная с версии ядра 2.6.20)"

#.  commit 7c3ab7381e79dfc7db14a67c6f4f3285664e1ec2
#. type: Plain text
#: man-pages/man5/proc.5:474
msgid "This file contains I/O statistics for the process, for example:"
msgstr "Этот файл содержит статистику ввода-вывода процесса, например:"

#. type: Plain text
#: man-pages/man5/proc.5:485
#, no-wrap
msgid ""
"#B< cat /proc/3828/io>\n"
"rchar: 323934931\n"
"wchar: 323929600\n"
"syscr: 632687\n"
"syscw: 632675\n"
"read_bytes: 0\n"
"write_bytes: 323932160\n"
"cancelled_write_bytes: 0\n"
msgstr "#B< cat /proc/3828/io>\nrchar: 323934931\nwchar: 323929600\nsyscr: 632687\nsyscw: 632675\nread_bytes: 0\nwrite_bytes: 323932160\ncancelled_write_bytes: 0\n"

#. type: Plain text
#: man-pages/man5/proc.5:489 man-pages/man5/proc.5:1641
msgid "The fields are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man5/proc.5:490
#, no-wrap
msgid "I<rchar>: characters read"
msgstr "I<rchar>: прочитано символов"

#. type: Plain text
#: man-pages/man5/proc.5:500
msgid ""
"The number of bytes which this task has caused to be read from storage.  "
"This is simply the sum of bytes which this process passed to B<read>(2)  and"
" similar system calls.  It includes things such as terminal I/O and is "
"unaffected by whether or not actual physical disk I/O was required (the read"
" might have been satisfied from pagecache)."
msgstr "Количество байт, которое было прочитано данной задачей из хранилища. Это просто сумма байт, которую процесс передал в B<read>(2) и подобные системные вызовы. Здесь учитываются такие вещи как ввод-вывод с терминалом и не учитывается, происходил ли ввод-вывод действительно с физического диска (для чтения могло оказаться достаточно страничного кэша)."

#. type: TP
#: man-pages/man5/proc.5:500
#, no-wrap
msgid "I<wchar>: characters written"
msgstr "I<wchar>: записано символов"

#. type: Plain text
#: man-pages/man5/proc.5:506
msgid ""
"The number of bytes which this task has caused, or shall cause to be written"
" to disk.  Similar caveats apply here as with I<rchar>."
msgstr "Количество байт, которые были или должны быть записаны задачей на диск. Применимы те же оговорки, что и для I<rchar>."

#. type: TP
#: man-pages/man5/proc.5:506
#, no-wrap
msgid "I<syscr>: read syscalls"
msgstr "I<syscr>: количество системных вызовов чтения"

#. type: Plain text
#: man-pages/man5/proc.5:513
msgid ""
"Attempt to count the number of read I/O operations\\(emthat is, system calls"
" such as B<read>(2)  and B<pread>(2)."
msgstr "Попытка подсчитать количество операций чтения — то есть системных вызовов B<read>(2) и B<pread>(2)."

#. type: TP
#: man-pages/man5/proc.5:513
#, no-wrap
msgid "I<syscw>: write syscalls"
msgstr "I<syscw>: количество системных вызовов записи"

#. type: Plain text
#: man-pages/man5/proc.5:520
msgid ""
"Attempt to count the number of write I/O operations\\(emthat is, system "
"calls such as B<write>(2)  and B<pwrite>(2)."
msgstr "Попытка подсчитать количество операций записи — то есть системных вызовов B<write>(2) и B<pwrite>(2)."

#. type: TP
#: man-pages/man5/proc.5:520
#, no-wrap
msgid "I<read_bytes>: bytes read"
msgstr "I<read_bytes>: прочитано байт"

#. type: Plain text
#: man-pages/man5/proc.5:525
msgid ""
"Attempt to count the number of bytes which this process really did cause to "
"be fetched from the storage layer.  This is accurate for block-backed "
"filesystems."
msgstr "Попытка подсчитать количество байт, которое процесс действительно получил с уровня хранилища. Является точным для файловых систем блочного хранения."

#. type: TP
#: man-pages/man5/proc.5:525
#, no-wrap
msgid "I<write_bytes>: bytes written"
msgstr "I<write_bytes>: записано байт"

#. type: Plain text
#: man-pages/man5/proc.5:529
msgid ""
"Attempt to count the number of bytes which this process caused to be sent to"
" the storage layer."
msgstr "Попытка подсчитать количество байт, которое процесс действительно послал на уровень хранилища."

#. type: TP
#: man-pages/man5/proc.5:529
#, no-wrap
msgid "I<cancelled_write_bytes>:"
msgstr "I<cancelled_write_bytes>:"

#. type: Plain text
#: man-pages/man5/proc.5:543
msgid ""
"The big inaccuracy here is truncate.  If a process writes 1MB to a file and "
"then deletes the file, it will in fact perform no writeout.  But it will "
"have been accounted as having caused 1MB of write.  In other words: this "
"field represents the number of bytes which this process caused to not "
"happen, by truncating pagecache.  A task can cause \"negative\" I/O too.  If"
" this task truncates some dirty pagecache, some I/O which another task has "
"been accounted for (in its I<write_bytes>)  will not be happening."
msgstr "Есть большая погрешность при усечении. Если процесс записывает 1МБ в файл, а затем удаляет файл, то, фактически, он ничего не запишет. Но это будет подсчитано как запись 1МБ. Другими словами: это поле представляет количество байт, для которых процесс отменил запись посредством усечения страничного кэша. Задача также может вызвать «отрицательный» ввод-вывод. Если задача усекает часть устаревшего страничного кэша, то некоторый ввод-вывод, который был учтён в другой задаче (в её I<write_bytes>), не произойдёт."

#. type: Plain text
#: man-pages/man5/proc.5:551
msgid ""
"I<Note>: In the current implementation, things are a bit racy on 32-bit "
"systems: if process A reads process B's I</proc/[pid]/io> while process B is"
" updating one of these 64-bit counters, process A could see an intermediate "
"result."
msgstr "I<Замечание>: В текущей реализации существует большая состязательность в 32-битных системах: если процесс A читает I</proc/[pid]/io> процесса B в момент обновления 64-битных счётчиков процесса B, то процесс A может увидеть промежуточный результат."

#. type: TP
#: man-pages/man5/proc.5:551
#, no-wrap
msgid "I</proc/[pid]/limits> (since kernel 2.6.24)"
msgstr "I</proc/[pid]/limits> (начиная версии ядра 2.6.24)"

#.  commit 3036e7b490bf7878c6dae952eec5fb87b1106589
#. type: Plain text
#: man-pages/man5/proc.5:561
msgid ""
"This file displays the soft limit, hard limit, and units of measurement for "
"each of the process's resource limits (see B<getrlimit>(2)).  Up to and "
"including Linux 2.6.35, this file is protected to allow reading only by the "
"real UID of the process.  Since Linux 2.6.36, this file is readable by all "
"users on the system."
msgstr "В этом файле содержатся мягкие и жёсткие ограничения (limit), а также измерения по каждого ограничению ресурсов процесса (см. B<getrlimit>(2)). Файл доступен на чтение только реальному UID процесса. Начиная с Linux 2.6.36, может читаться всеми пользователями системы."

#. type: TP
#: man-pages/man5/proc.5:561
#, no-wrap
msgid "I</proc/[pid]/map_files/> (since kernel 3.3)"
msgstr "I</proc/[pid]/map_files/> (начиная с версии ядра 3.3)"

#.  commit 640708a2cff7f81e246243b0073c66e6ece7e53e
#. type: Plain text
#: man-pages/man5/proc.5:571
msgid ""
"This subdirectory contains entries corresponding to memory-mapped files (see"
" B<mmap>(2)).  Entries are named by memory region start and end address pair"
" (expressed as hexadecimal numbers), and are symbolic links to the mapped "
"files themselves.  Here is an example, with the output wrapped and "
"reformatted to fit on an 80-column display:"
msgstr "В этом подкаталоге содержатся записи, соответствующие файлам, отображённым в память (смотрит B<mmap>(2)). Имена записей соответствуют начальному и конечному адресу области памяти (в виде шестнадцатеричных чисел), и символьными ссылками на само отображённые файлы. Пример (подогнан под 80-колоночный терминал):"

#. type: Plain text
#: man-pages/man5/proc.5:578
#, no-wrap
msgid ""
"$B< ls -l /proc/self/map_files/>\n"
"lr--------. 1 root root 64 Apr 16 21:31\n"
"            3252e00000-3252e20000 -E<gt> /usr/lib64/ld-2.15.so\n"
"\\&...\n"
msgstr "$B< ls -l /proc/self/map_files/>\nlr--------. 1 root root 64 Apr 16 21:31\n            3252e00000-3252e20000 -E<gt> /usr/lib64/ld-2.15.so\n\\&...\n"

#. type: Plain text
#: man-pages/man5/proc.5:592
msgid ""
"Although these entries are present for memory regions that were mapped with "
"the B<MAP_FILE> flag, the way anonymous shared memory (regions created with "
"the B<MAP_ANON | MAP_SHARED> flags)  is implemented in Linux means that such"
" regions also appear on this directory.  Here is an example where the target"
" file is the deleted I</dev/zero> one:"
msgstr "Хотя эти записи предназначены для областей памяти, отображённых с флагом B<MAP_FILE>, из реализации в Linux области анонимной общей памяти (области, созданные с флагами B<MAP_ANON | MAP_SHARED>) также будут присутствовать в этом каталоге. Пример, в котором файл назначения — удалённый I</dev/zero>:"

#. type: Plain text
#: man-pages/man5/proc.5:598
#, no-wrap
msgid ""
"lrw-------. 1 root root 64 Apr 16 21:33\n"
"            7fc075d2f000-7fc075e6f000 -E<gt> /dev/zero (deleted)\n"
msgstr "lrw-------. 1 root root 64 Apr 16 21:33\n            7fc075d2f000-7fc075e6f000 -E<gt> /dev/zero (deleted)\n"

#. type: Plain text
#: man-pages/man5/proc.5:604
msgid ""
"This directory appears only if the B<CONFIG_CHECKPOINT_RESTORE> kernel "
"configuration option is enabled."
msgstr "Данный каталог присутствуют только, если ядро собрано с включённым параметром B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man5/proc.5:604
#, no-wrap
msgid "I</proc/[pid]/maps>"
msgstr "I</proc/[pid]/maps>"

#. type: Plain text
#: man-pages/man5/proc.5:611
msgid ""
"A file containing the currently mapped memory regions and their access "
"permissions.  See B<mmap>(2)  for some further information about memory "
"mappings."
msgstr "Файл, содержащий адреса областей памяти, которые используются программой в данный момент и права доступа к ним. Информацию об отображении памяти смотрите в B<mmap>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:613
msgid "The format of the file is:"
msgstr "Формат файла:"

#. type: Plain text
#: man-pages/man5/proc.5:638
#, no-wrap
msgid ""
"I<address           perms offset  dev   inode       pathname>\n"
"00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon\n"
"00651000-00652000 r--p 00051000 08:02 173521      /usr/bin/dbus-daemon\n"
"00652000-00655000 rw-p 00052000 08:02 173521      /usr/bin/dbus-daemon\n"
"00e03000-00e24000 rw-p 00000000 00:00 0           [heap]\n"
"00e24000-011f7000 rw-p 00000000 00:00 0           [heap]\n"
"\\&...\n"
"35b1800000-35b1820000 r-xp 00000000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a1f000-35b1a20000 r--p 0001f000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a20000-35b1a21000 rw-p 00020000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a21000-35b1a22000 rw-p 00000000 00:00 0\n"
"35b1c00000-35b1dac000 r-xp 00000000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1dac000-35b1fac000 ---p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1fac000-35b1fb0000 r--p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1fb0000-35b1fb2000 rw-p 001b0000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"\\&...\n"
"f2c6ff8c000-7f2c7078c000 rw-p 00000000 00:00 0    [stack:986]\n"
"\\&...\n"
"7fffb2c0d000-7fffb2c2e000 rw-p 00000000 00:00 0   [stack]\n"
"7fffb2d48000-7fffb2d49000 r-xp 00000000 00:00 0   [vdso]\n"
msgstr "I<address           perms offset  dev   inode       pathname>\n00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon\n00651000-00652000 r--p 00051000 08:02 173521      /usr/bin/dbus-daemon\n00652000-00655000 rw-p 00052000 08:02 173521      /usr/bin/dbus-daemon\n00e03000-00e24000 rw-p 00000000 00:00 0           [heap]\n00e24000-011f7000 rw-p 00000000 00:00 0           [heap]\n\\&...\n35b1800000-35b1820000 r-xp 00000000 08:02 135522  /usr/lib64/ld-2.15.so\n35b1a1f000-35b1a20000 r--p 0001f000 08:02 135522  /usr/lib64/ld-2.15.so\n35b1a20000-35b1a21000 rw-p 00020000 08:02 135522  /usr/lib64/ld-2.15.so\n35b1a21000-35b1a22000 rw-p 00000000 00:00 0\n35b1c00000-35b1dac000 r-xp 00000000 08:02 135870  /usr/lib64/libc-2.15.so\n35b1dac000-35b1fac000 ---p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n35b1fac000-35b1fb0000 r--p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n35b1fb0000-35b1fb2000 rw-p 001b0000 08:02 135870  /usr/lib64/libc-2.15.so\n\\&...\nf2c6ff8c000-7f2c7078c000 rw-p 00000000 00:00 0    [stack:986]\n\\&...\n7fffb2c0d000-7fffb2c2e000 rw-p 00000000 00:00 0   [stack]\n7fffb2d48000-7fffb2d49000 r-xp 00000000 00:00 0   [vdso]\n"

#. type: Plain text
#: man-pages/man5/proc.5:647
msgid ""
"The I<address> field is the address space in the process that the mapping "
"occupies.  The I<perms> field is a set of permissions:"
msgstr "В поле I<address> показано адресное пространство процесса, в которое выполнено отображение, а в поле I<perms> — права доступа:"

#. type: Plain text
#: man-pages/man5/proc.5:655
#, no-wrap
msgid ""
"r = read\n"
"w = write\n"
"x = execute\n"
"s = shared\n"
"p = private (copy on write)\n"
msgstr "r = можно читать\nw = можно писать\nx = можно выполнять\ns = можно использовать несколькими процессами совместно\np = личное (копирование при записи)\n"

#. type: Plain text
#: man-pages/man5/proc.5:668
msgid ""
"The I<offset> field is the offset into the file/whatever; I<dev> is the "
"device (major:minor); I<inode> is the inode on that device.  0 indicates "
"that no inode is associated with the memory region, as would be the case "
"with BSS (uninitialized data)."
msgstr "Поле I<offset> — это смещение в файле/где-то ещё; I<dev> — устройство (старший номер:младший номер); I<inode> — индексный дескриптор на данном устройстве. 0 означает, что с данной областью памяти не связаны индексные дескрипторы: примером тому является сегмент BSS (неинициализированные данные)."

#. type: Plain text
#: man-pages/man5/proc.5:678
msgid ""
"The I<pathname> field will usually be the file that is backing the mapping."
"  For ELF files, you can easily coordinate with the I<offset> field by "
"looking at the Offset field in the ELF program headers (I<readelf\\ -l>)."
msgstr "В поле I<pathname> обычно указывается отображённый файл. Если файл в формате ELF, то вы легко можете установить связь с полем I<offset>, посмотрев в Offset программного заголовка ELF (I<readelf\\ -l>)."

#. type: Plain text
#: man-pages/man5/proc.5:680
msgid "There are additional helpful pseudo-paths:"
msgstr "Дополнительные полезные псевдо-пути:"

#. type: TP
#: man-pages/man5/proc.5:681
#, no-wrap
msgid "I<[stack]>"
msgstr "I<[stack]>"

#. type: Plain text
#: man-pages/man5/proc.5:684
msgid "The initial process's (also known as the main thread's) stack."
msgstr "Начальный стек процесса (главной нити)."

#. type: TP
#: man-pages/man5/proc.5:684
#, no-wrap
msgid "I<[stack:E<lt>tidE<gt>]> (since Linux 3.4)"
msgstr "I<[stack:E<lt>tidE<gt>]> (начиная с Linux 3.4)"

#.  commit b76437579d1344b612cf1851ae610c636cec7db0
#. type: Plain text
#: man-pages/man5/proc.5:693
msgid ""
"A thread's stack (where the I<E<lt>tidE<gt>> is a thread ID).  It "
"corresponds to the I</proc/[pid]/task/[tid]/> path."
msgstr "Стек нити (где I<E<lt>tidE<gt>> — ID нити). Совпадает с  путём I</proc/[pid]/task/[tid]/>."

#. type: TP
#: man-pages/man5/proc.5:693
#, no-wrap
msgid "I<[vdso]>"
msgstr "I<[vdso]>"

#. type: Plain text
#: man-pages/man5/proc.5:696
msgid "The virtual dynamically linked shared object."
msgstr "Виртуальный, динамически компонуемый, общий объект."

#. type: TP
#: man-pages/man5/proc.5:696
#, no-wrap
msgid "I<[heap]>"
msgstr "I<[heap]>"

#. type: Plain text
#: man-pages/man5/proc.5:699
msgid "The process's heap."
msgstr "Куча процесса."

#. type: Plain text
#: man-pages/man5/proc.5:713
msgid ""
"If the I<pathname> field is blank, this is an anonymous mapping as obtained "
"via the B<mmap>(2)  function.  There is no easy way to coordinate this back "
"to a process's source, short of running it through B<gdb>(1), B<strace>(1), "
"or similar."
msgstr "Если значение поля I<pathname> пусто, то это анонимное отображение, полученное с помощью вызова B<mmap>(2). Нет простого способа увязать это с источником в процессе, кроме как запустив его в B<gdb>(1), B<strace>(1) и т.п."

#. type: Plain text
#: man-pages/man5/proc.5:715
msgid "Under Linux 2.0, there is no field giving pathname."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:715
#, no-wrap
msgid "I</proc/[pid]/mem>"
msgstr "I</proc/[pid]/mem>"

#. type: Plain text
#: man-pages/man5/proc.5:722
msgid ""
"This file can be used to access the pages of a process's memory through "
"B<open>(2), B<read>(2), and B<lseek>(2)."
msgstr "Этот файл можно использовать для получения доступа к страницам памяти процесса через вызовы B<open>(2), B<read>(2) и B<lseek>(2)."

#. type: TP
#: man-pages/man5/proc.5:722
#, no-wrap
msgid "I</proc/[pid]/mountinfo> (since Linux 2.6.26)"
msgstr "I</proc/[pid]/mountinfo> (начиная с Linux 2.6.26)"

#.  This info adapted from Documentation/filesystems/proc.txt
#. type: Plain text
#: man-pages/man5/proc.5:727
msgid ""
"This file contains information about mount points.  It contains lines of the"
" form:"
msgstr "В этом файле содержится информация о точках монтирования. Формат строк:"

#. type: Plain text
#: man-pages/man5/proc.5:732
#, no-wrap
msgid ""
"CW<36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue\n"
"(1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)>\n"
msgstr "CW<36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue\n(1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)>\n"

#. type: Plain text
#: man-pages/man5/proc.5:736
msgid "The numbers in parentheses are labels for the descriptions below:"
msgstr "Описания полей (номер представлен в скобках):"

#. type: TP
#: man-pages/man5/proc.5:737 man-pages/man5/proc.5:830
#, no-wrap
msgid "(1)"
msgstr "(1)"

#. type: Plain text
#: man-pages/man5/proc.5:741
msgid ""
"mount ID: unique identifier of the mount (may be reused after B<umount>(2))."
msgstr "ID монтирования: уникальный идентификатор монтирования (может использоваться повторно после B<umount>(2))."

#. type: TP
#: man-pages/man5/proc.5:741 man-pages/man5/proc.5:834
#, no-wrap
msgid "(2)"
msgstr "(2)"

#. type: Plain text
#: man-pages/man5/proc.5:744
msgid ""
"parent ID: ID of parent mount (or of self for the top of the mount tree)."
msgstr "родительский ID: ID родительского монтирования (или ID самого себя для вершины дерева монтирования)."

#. type: TP
#: man-pages/man5/proc.5:744 man-pages/man5/proc.5:837
#, no-wrap
msgid "(3)"
msgstr "(3)"

#. type: Plain text
#: man-pages/man5/proc.5:750
msgid ""
"major:minor: value of I<st_dev> for files on filesystem (see B<stat>(2))."
msgstr "старший:младший: значение I<st_dev> для файлов на файловой системе (см. B<stat>(2))."

#. type: TP
#: man-pages/man5/proc.5:750 man-pages/man5/proc.5:840
#, no-wrap
msgid "(4)"
msgstr "(4)"

#. type: Plain text
#: man-pages/man5/proc.5:753
msgid "root: root of the mount within the filesystem."
msgstr "корень: корень монтирования в файловой системе."

#. type: TP
#: man-pages/man5/proc.5:753
#, no-wrap
msgid "(5)"
msgstr "(5)"

#. type: Plain text
#: man-pages/man5/proc.5:756
msgid "mount point: mount point relative to the process's root."
msgstr "точка монтирования: точка монтирования относительно корня процесса."

#. type: TP
#: man-pages/man5/proc.5:756
#, no-wrap
msgid "(6)"
msgstr "(6)"

#. type: Plain text
#: man-pages/man5/proc.5:759
msgid "mount options: per-mount options."
msgstr "параметры монтирования: параметры данного монтирования."

#. type: TP
#: man-pages/man5/proc.5:759
#, no-wrap
msgid "(7)"
msgstr "(7)"

#. type: Plain text
#: man-pages/man5/proc.5:762
msgid "optional fields: zero or more fields of the form \"tag[:value]\"."
msgstr "необязательные поля: ноль или более полей в виде \"метка[:значение]\"."

#. type: TP
#: man-pages/man5/proc.5:762
#, no-wrap
msgid "(8)"
msgstr "(8)"

#. type: Plain text
#: man-pages/man5/proc.5:765
msgid "separator: marks the end of the optional fields."
msgstr "разделитель: отмечает конец необязательных полей."

#. type: TP
#: man-pages/man5/proc.5:765
#, no-wrap
msgid "(9)"
msgstr "(9)"

#. type: Plain text
#: man-pages/man5/proc.5:768
msgid "filesystem type: name of filesystem in the form \"type[.subtype]\"."
msgstr "тип файловой системы: имя файловой системы в виде «тип[.подтип]»."

#. type: TP
#: man-pages/man5/proc.5:768
#, no-wrap
msgid "(10)"
msgstr "(10)"

#. type: Plain text
#: man-pages/man5/proc.5:771
msgid "mount source: filesystem-specific information or \"none\"."
msgstr "источник монтирования: информация, специфичная для файловой системы или «none»."

#. type: TP
#: man-pages/man5/proc.5:771
#, no-wrap
msgid "(11)"
msgstr "(11)"

#. type: Plain text
#: man-pages/man5/proc.5:774
msgid "super options: per-superblock options."
msgstr "параметры суперблока: параметры конкретного суперблока."

#. type: Plain text
#: man-pages/man5/proc.5:778
msgid ""
"Parsers should ignore all unrecognized optional fields.  Currently the "
"possible optional fields are:"
msgstr "Анализаторы должны игнорировать все неизвестные необязательные поля. Необязательные поля на данный момент:"

#. type: TP
#: man-pages/man5/proc.5:779
#, no-wrap
msgid "shared:X"
msgstr "shared:X"

#. type: Plain text
#: man-pages/man5/proc.5:782
msgid "mount is shared in peer group X"
msgstr "монтирование используется всеми из группы X"

#. type: TP
#: man-pages/man5/proc.5:782
#, no-wrap
msgid "master:X"
msgstr "master:X"

#. type: Plain text
#: man-pages/man5/proc.5:785
msgid "mount is slave to peer group X"
msgstr "монтирование подчиняется группе X"

#. type: TP
#: man-pages/man5/proc.5:785
#, no-wrap
msgid "propagate_from:X"
msgstr "propagate_from:X"

#. type: Plain text
#: man-pages/man5/proc.5:788
msgid "mount is slave and receives propagation from peer group X (*)"
msgstr "монтирования подчиняется и получает распространение от группы X (*)"

#. type: TP
#: man-pages/man5/proc.5:788
#, no-wrap
msgid "unbindable"
msgstr "unbindable"

#. type: Plain text
#: man-pages/man5/proc.5:791
msgid "mount is unbindable"
msgstr "монтирование недоступно для привязки"

#. type: Plain text
#: man-pages/man5/proc.5:798
msgid ""
"(*) X is the closest dominant peer group under the process's root.  If X is "
"the immediate master of the mount, or if there is no dominant peer group "
"under the same root, then only the \"master:X\" field is present and not the"
" \"propagate_from:X\" field."
msgstr "(*) X \\(em это ближайший основной член группы корня процесса. Если X является непосредственным хозяином монтирования, или если нет основной группы под тем же корнем, то присутствует только поле \"master:X\" и нет поля \"propagate_from:X\"."

#. type: Plain text
#: man-pages/man5/proc.5:802
msgid ""
"For more information on mount propagation see: "
"I<Documentation/filesystems/sharedsubtree.txt> in the Linux kernel source "
"tree."
msgstr "Подробней о концепции распространения монтирования смотрите в исходном коде ядра Linux в файле I<Documentation/filesystems/sharedsubtree.txt>."

#. type: TP
#: man-pages/man5/proc.5:802
#, no-wrap
msgid "I</proc/[pid]/mounts> (since Linux 2.4.19)"
msgstr "I</proc/[pid]/mounts> (начиная с Linux 2.4.19)"

#. type: Plain text
#: man-pages/man5/proc.5:817
msgid ""
"This is a list of all the filesystems currently mounted in the process's "
"mount namespace.  The format of this file is documented in B<fstab>(5).  "
"Since kernel version 2.6.15, this file is pollable: after opening the file "
"for reading, a change in this file (i.e., a filesystem mount or unmount) "
"causes B<select>(2)  to mark the file descriptor as readable, and B<poll>(2)"
"  and B<epoll_wait>(2)  mark the file as having an error condition."
msgstr "В файле содержится список всех смонтированных файловых систем в пространстве имён монтирования процесса. Формат файла описан в B<fstab>(5). Начиная с ядра версии 2.6.15, этот файл можно опрашивать: после открытия файла на чтение, изменение в этом файле (т.е., монтирование или размонтирование файловой системы) заставляет B<select>(2) пометить файловый дескриптор как доступный для чтения, а B<poll>(2) и B<epoll_wait>(2) помечают файл как имеющий ошибочное состояние."

#. type: TP
#: man-pages/man5/proc.5:817
#, no-wrap
msgid "I</proc/[pid]/mountstats> (since Linux 2.6.17)"
msgstr "I</proc/[pid]/mountstats> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man5/proc.5:822
msgid ""
"This file exports information (statistics, configuration information)  about"
" the mount points in the process's name space.  Lines in this file have the "
"form:"
msgstr "В этом файле содержится информация (статистика, информация о настройке) о точках монтирования в пространстве имён процесса. Формат строк:"

#. type: Plain text
#: man-pages/man5/proc.5:826
#, no-wrap
msgid ""
"device /dev/sda7 mounted on /home with fstype ext3 [statistics]\n"
"(       1      )            ( 2 )             (3 ) (4)\n"
msgstr "device /dev/sda7 mounted on /home with fstype ext3 [statistics]\n(       1      )            ( 2 )             (3 ) (4)\n"

#. type: Plain text
#: man-pages/man5/proc.5:829
msgid "The fields in each line are:"
msgstr "Поля каждой строки:"

#. type: Plain text
#: man-pages/man5/proc.5:834
msgid ""
"The name of the mounted device (or \"nodevice\" if there is no corresponding"
" device)."
msgstr "Имя смонтированного устройства (или \"nodevice\", если нет соответствующего устройства)."

#. type: Plain text
#: man-pages/man5/proc.5:837
msgid "The mount point within the filesystem tree."
msgstr "Точка монтирования в дереве файловой системы."

#. type: Plain text
#: man-pages/man5/proc.5:840
msgid "The filesystem type."
msgstr "Тип файловой системы."

#. type: Plain text
#: man-pages/man5/proc.5:845
msgid ""
"Optional statistics and configuration information.  Currently (as at Linux "
"2.6.26), only NFS filesystems export information via this field."
msgstr "Необязательная статистика и информация о настройке. В настоящее время (Linux версии 2.6.26), в этом поле доступна только информация об экспортируемых файловых системах NFS."

#. type: Plain text
#: man-pages/man5/proc.5:848
msgid "This file is readable only by the owner of the process."
msgstr "Данный файл доступен на чтение только владельцу процесса."

#. type: TP
#: man-pages/man5/proc.5:848
#, no-wrap
msgid "I</proc/[pid]/ns/> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/> (начиная с Linux 3.0)"

#.  See commit 6b4e306aa3dc94a0545eb9279475b1ab6209a31f
#. type: Plain text
#: man-pages/man5/proc.5:856
msgid ""
"This is a subdirectory containing one entry for each namespace that supports"
" being manipulated by B<setns>(2).  For information about namespaces, see "
"B<clone>(2)."
msgstr "В этом подкаталоге содержится по одной записи на каждое пространство имён, для которых в B<setns>(2) есть поддержка изменения. Информацию о пространствах имён смотрите в B<clone>(2)."

#. type: TP
#: man-pages/man5/proc.5:856
#, no-wrap
msgid "I</proc/[pid]/ns/ipc> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/ipc> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man5/proc.5:864
msgid ""
"Bind mounting this file (see B<mount>(2))  to somewhere else in the "
"filesystem keeps the IPC namespace of the process specified by I<pid> alive "
"even if all processes currently in the namespace terminate."
msgstr "При псевдонимном монтировании этого файла (смотрите B<mount>(2)) куда-то ещё в файловой системе оставляет действующим пространство имён IPC процесса заданного I<pid>, даже если все процессы в пространстве имён завершились."

#. type: Plain text
#: man-pages/man5/proc.5:873
msgid ""
"Opening this file returns a file handle for the IPC namespace of the process"
" specified by I<pid>.  As long as this file descriptor remains open, the IPC"
" namespace will remain alive, even if all processes in the namespace "
"terminate.  The file descriptor can be passed to B<setns>(2)."
msgstr "При открытии этого файла возвращается файловый указатель для пространства имён IPC процесса заданного I<pid>. Пока этот файловый дескриптор остаётся открытым, пространство имён IPC будет оставаться действующим, даже если все процессы в пространстве имён завершились. Файловый дескриптор может быть передан B<setns>(2)."

#. type: TP
#: man-pages/man5/proc.5:873
#, no-wrap
msgid "I</proc/[pid]/ns/net> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/net> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man5/proc.5:881
msgid ""
"Bind mounting this file (see B<mount>(2))  to somewhere else in the "
"filesystem keeps the network namespace of the process specified by I<pid> "
"alive even if all processes in the namespace terminate."
msgstr "При псевдонимном монтировании этого файла (смотрите B<mount>(2)) куда-то ещё в файловой системе оставляет действующим сетевое пространство имён процесса заданного I<pid>, даже если все процессы в пространстве имён завершились."

#. type: Plain text
#: man-pages/man5/proc.5:890
msgid ""
"Opening this file returns a file handle for the network namespace of the "
"process specified by I<pid>.  As long as this file descriptor remains open, "
"the network namespace will remain alive, even if all processes in the "
"namespace terminate.  The file descriptor can be passed to B<setns>(2)."
msgstr "При открытии этого файла возвращается файловый указатель для сетевого пространства имён процесса, заданного I<pid>. Пока этот файловый дескриптор остаётся открытым, сетевое пространство имён будет оставаться действующим, даже если все процессы в пространстве имён завершились. Файловый дескриптор может быть передан B<setns>(2)."

#. type: TP
#: man-pages/man5/proc.5:890
#, no-wrap
msgid "I</proc/[pid]/ns/uts> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/uts> (начиная с Linux 3.0)"

#. type: Plain text
#: man-pages/man5/proc.5:898
msgid ""
"Bind mounting this file (see B<mount>(2))  to somewhere else in the "
"filesystem keeps the UTS namespace of the process specified by I<pid> alive "
"even if all processes currently in the namespace terminate."
msgstr "При псевдонимном монтировании этого файла (смотрите B<mount>(2)) куда-то ещё в файловой системе оставляет действующим пространство имён UTS процесса заданного I<pid>, даже если все процессы в пространстве имён завершились."

#. type: Plain text
#: man-pages/man5/proc.5:907
msgid ""
"Opening this file returns a file handle for the UTS namespace of the process"
" specified by I<pid>.  As long as this file descriptor remains open, the UTS"
" namespace will remain alive, even if all processes in the namespace "
"terminate.  The file descriptor can be passed to B<setns>(2)."
msgstr "При открытии этого файла возвращается файловый указатель для пространства имён UTS процесса заданного I<pid>. Пока этот файловый дескриптор остаётся открытым, пространство имён UTS будет оставаться действующим, даже если все процессы в пространстве имён завершились. Файловый дескриптор может быть передан B<setns>(2)."

#. type: TP
#: man-pages/man5/proc.5:907
#, no-wrap
msgid "I</proc/[pid]/numa_maps> (since Linux 2.6.14)"
msgstr "I</proc/[pid]/numa_maps> (начиная с Linux 2.6.14)"

#. type: Plain text
#: man-pages/man5/proc.5:911
msgid "See B<numa>(7)."
msgstr "Смотрите B<numa>(7)."

#. type: TP
#: man-pages/man5/proc.5:911
#, no-wrap
msgid "I</proc/[pid]/oom_adj> (since Linux 2.6.11)"
msgstr "I</proc/[pid]/oom_adj> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man5/proc.5:924
msgid ""
"This file can be used to adjust the score used to select which process "
"should be killed in an out-of-memory (OOM) situation.  The kernel uses this "
"value for a bit-shift operation of the process's I<oom_score> value: valid "
"values are in the range -16 to +15, plus the special value -17, which "
"disables OOM-killing altogether for this process.  A positive score "
"increases the likelihood of this process being killed by the OOM-killer; a "
"negative score decreases the likelihood."
msgstr "Этот файл может использоваться для подгонки оценки, используемой при выборе процесса, который нужно завершить при нехватке памяти (OOM). Ядро использует это значение в операции побитового сдвига значения I<oom_score> у процесса: допустимые находятся в диапазоне от -16 до +15, плюс специальное значение -17, которое отключает OOM-завершение для этого процесса совсем. Положительная оценка увеличивает вероятность, что процесс будет завершён OOM-killer; отрицательная оценка уменьшает вероятность."

#. type: Plain text
#: man-pages/man5/proc.5:932
msgid ""
"The default value for this file is 0; a new process inherits its parent's "
"I<oom_adj> setting.  A process must be privileged (B<CAP_SYS_RESOURCE>)  to "
"update this file."
msgstr "Значение по умолчанию в этом файле равно 0; новый процесс наследует его от родительского значения I<oom_adj>. Для изменения этого файла процесс должен иметь мандат B<CAP_SYS_RESOURCE>."

#. type: Plain text
#: man-pages/man5/proc.5:935
msgid ""
"Since Linux 2.6.36, use of this file is deprecated in favor of "
"I</proc/[pid]/oom_score_adj>."
msgstr "Начиная с Linux 2.6.36, вместо этого файла рекомендуется использовать I</proc/[pid]/oom_score_adj>."

#. type: TP
#: man-pages/man5/proc.5:935
#, no-wrap
msgid "I</proc/[pid]/oom_score> (since Linux 2.6.11)"
msgstr "I</proc/[pid]/oom_score> (начиная с Linux 2.6.11)"

#.  See mm/oom_kill.c::badness() in the 2.6.25 sources
#.  See mm/oom_kill.c::badness() in the 2.6.25 sources
#. type: Plain text
#: man-pages/man5/proc.5:946
msgid ""
"This file displays the current score that the kernel gives to this process "
"for the purpose of selecting a process for the OOM-killer.  A higher score "
"means that the process is more likely to be selected by the OOM-killer.  The"
" basis for this score is the amount of memory used by the process, with "
"increases (+) or decreases (-) for factors including:"
msgstr "Этот файл содержит текущую оценку, которую ядро назначило процессу, учитывающуюся при избрании процесса OOM-killer. Более высокая оценка означает, что у процесса есть больше шансов быть выбранным OOM-killer. Основой оценки является количество памяти используемой процессом и различные увеличивающие (+) и уменьшающие (-) факторы:"

#. type: Plain text
#: man-pages/man5/proc.5:951
msgid "whether the process creates a lot of children using B<fork>(2)  (+);"
msgstr "создавал ли процесс много потомков с помощью B<fork>(2) (+);"

#. type: Plain text
#: man-pages/man5/proc.5:954
msgid ""
"whether the process has been running a long time, or has used a lot of CPU "
"time (-);"
msgstr "долго ли работал процесс, или использовал много процессорного времени (-);"

#. type: Plain text
#: man-pages/man5/proc.5:956
msgid "whether the process has a low nice value (i.e., E<gt> 0) (+);"
msgstr "имеет ли процесс низкое значение любезности (nice) (т.е., E<gt> 0) (+);"

#.  More precisely, if it has CAP_SYS_ADMIN or CAP_SYS_RESOURCE
#. type: Plain text
#: man-pages/man5/proc.5:959
msgid "whether the process is privileged (-); and"
msgstr "считается ли процесс привилегированным (-); и"

#.  More precisely, if it has CAP_SYS_RAWIO
#. type: Plain text
#: man-pages/man5/proc.5:962
msgid "whether the process is making direct hardware access (-)."
msgstr "обращается ли процесс к аппаратному обеспечению напрямую (-)."

#. type: Plain text
#: man-pages/man5/proc.5:971
msgid ""
"The I<oom_score> also reflects the adjustment specified by the "
"I<oom_score_adj> or I<oom_adj> setting for the process."
msgstr "Значение I<oom_score> также отражает подгонку смещения, указанную в I<oom_score_adj> или I<oom_adj> процесса."

#. type: TP
#: man-pages/man5/proc.5:971
#, no-wrap
msgid "I</proc/[pid]/oom_score_adj> (since Linux 2.6.36)"
msgstr "I</proc/[pid]/oom_score_adj> (начиная с Linux 2.6.36)"

#.  Text taken from 3.7 Documentation/filesystems/proc.txt
#. type: Plain text
#: man-pages/man5/proc.5:976
msgid ""
"This file can be used to adjust the badness heuristic used to select which "
"process gets killed in out-of-memory conditions."
msgstr "Этот файл может использоваться для подгонки оценки вредности для выбора процесса, который нужно завершить при нехватке памяти."

#. type: Plain text
#: man-pages/man5/proc.5:985
msgid ""
"The badness heuristic assigns a value to each candidate task ranging from 0 "
"(never kill) to 1000 (always kill) to determine which process is targeted.  "
"The units are roughly a proportion along that range of allowed memory the "
"process may allocate from, based on an estimation of its current memory and "
"swap use.  For example, if a task is using all allowed memory, its badness "
"score will be 1000.  If it is using half of its allowed memory, its score "
"will be 500."
msgstr "Значение оценки вредности назначается каждой задаче-кандидату от 0 (никогда не завершать) до 1000 (всегда завершать), которым определяется какой процесс будет выбран. Единицы примерно пропорциональны диапазону разрешённой памяти, которую может запросить процесс, на основе вычисления его текущей памяти и использованию подкачки.Например, если задача использует всю разрешённую память, то значение вредности будет равно 1000. Если процесс использует половину разрешённой памяти, то значение будет 500."

#. type: Plain text
#: man-pages/man5/proc.5:988
msgid ""
"There is an additional factor included in the badness score: root processes "
"are given 3% extra memory over other tasks."
msgstr "Есть дополнительный фактор, учитывающийся для вредности: процессам root даётся на 3% больше памяти, чем другим задачам."

#. type: Plain text
#: man-pages/man5/proc.5:1002
msgid ""
"The amount of \"allowed\" memory depends on the context in which the OOM-"
"killer was called.  If it is due to the memory assigned to the allocating "
"task's cpuset being exhausted, the allowed memory represents the set of mems"
" assigned to that cpuset (see B<cpuset>(7)).  If it is due to a mempolicy's "
"node(s) being exhausted, the allowed memory represents the set of mempolicy "
"nodes.  If it is due to a memory limit (or swap limit) being reached, the "
"allowed memory is that configured limit.  Finally, if it is due to the "
"entire system being out of memory, the allowed memory represents all "
"allocatable resources."
msgstr "Количество «разрешённой» памяти зависит от контекста, в котором был вызван OOM-killer. Если он вызван в момент, когда при назначении памяти для выделенного cpuset задачи происходит исчерпание, то разрешённая память представляет набор mem, назначенных этому cpuset (смотрите B<cpuset>(7)). Если это происходит при исчерпании узлов mempolicy, то разрешённая память представляет набор узлов mempolicy. Если это происходит при достижении лимита на память (или лимита подкачки), то разрешённой памятью считается настроенный лимит. Наконец, если это происходит при нехватке памяти во всей системе, то разрешённой памятью считаются все доступные для выделения ресурсы."

#. type: Plain text
#: man-pages/man5/proc.5:1015
msgid ""
"The value of I<oom_score_adj> is added to the badness score before it is "
"used to determine which task to kill.  Acceptable values range from -1000 "
"(OOM_SCORE_ADJ_MIN) to +1000 (OOM_SCORE_ADJ_MAX).  This allows user space to"
" control the preference for OOM-killing, ranging from always preferring a "
"certain task or completely disabling it from OOM-killing.  The lowest "
"possible value, -1000, is equivalent to disabling OOM-killing entirely for "
"that task, since it will always report a badness score of 0."
msgstr "Значение I<oom_score_adj> добавляется к значению вредности перед тем как оно будет использовано для определения завершаемой задачи. Диапазон разрешённых значений: от -1000 (OOM_SCORE_ADJ_MIN) до +1000 (OOM_SCORE_ADJ_MAX). Это позволяет осуществлять контроль за настройкой OOM-killing из пользовательского пространства, указывая самые ненужные задачи или полностью отключая OOM-killing для самых важных. Самое минимальное значение, -1000, эквивалентно полному отключению OOM-killing для определённой задачи, так как оно снижает значение вредности до 0."

#. type: Plain text
#: man-pages/man5/proc.5:1027
msgid ""
"Consequently, it is very simple for user space to define the amount of "
"memory to consider for each task.  Setting a I<oom_score_adj> value of +500,"
" for example, is roughly equivalent to allowing the remainder of tasks "
"sharing the same system, cpuset, mempolicy, or memory controller resources "
"to use at least 50% more memory.  A value of -500, on the other hand, would "
"be roughly equivalent to discounting 50% of the task's allowed memory from "
"being considered as scoring against the task."
msgstr "Следовательно, из пользовательского пространства очень просто определить количество памяти по каждой задаче. Например, установка значения I<oom_score_adj> равным +500, примерно эквивалентна разрешению оставшимся задачам использовать общим в системы ресурсам, cpuset, mempolicy, или контроллеру памяти не менее 50% памяти. С другой стороны, значение -500 было бы примерно эквивалентно отниманию 50% из разрешённой памяти задачи при подсчёте вредности задачи."

#. type: Plain text
#: man-pages/man5/proc.5:1034
msgid ""
"For backward compatibility with previous kernels, I</proc/[pid]/oom_adj> can"
" still be used to tune the badness score.  Its value is scaled linearly with"
" I<oom_score_adj>."
msgstr "Для обратной совместимости с предыдущими версиями ядер значение в I</proc/[pid]/oom_adj> всё ещё может учитываться при подстройке значения вредности. Это значение линейно масштабируется с I<oom_score_adj>."

#. type: Plain text
#: man-pages/man5/proc.5:1040
msgid ""
"Writing to I</proc/[pid]/oom_score_adj> or I</proc/[pid]/oom_adj> will "
"change the other with its scaled value."
msgstr "Запись в I</proc/[pid]/oom_score_adj> или I</proc/[pid]/oom_adj> изменит и значение в другом параметре с соответствующим масштабом."

#. type: TP
#: man-pages/man5/proc.5:1040
#, no-wrap
msgid "I</proc/[pid]/pagemap> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1046
msgid ""
"This file shows the mapping of each of the process's virtual pages into "
"physical page frames or swap area.  It contains one 64-bit value for each "
"virtual page, with the bits set as follows:"
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1047
#, no-wrap
msgid "63"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1050
msgid "If set, the page is present in RAM."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1050
#, no-wrap
msgid "62"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1053
msgid "If set, the page is in swap space"
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1053
#, no-wrap
msgid "61 (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1056
msgid "The page is a file-mapped page or a shared anonymous page."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1056
#, no-wrap
msgid "60-56 (since Linux 3.11)"
msgstr ""

#.  Not quite true; see commit 541c237c0923f567c9c4cabb8a81635baadc713f
#. type: Plain text
#: man-pages/man5/proc.5:1060
msgid "Zero"
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1060
#, no-wrap
msgid "55 (Since Linux 3.11)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1065
msgid ""
"PTE is soft-dirty (see the kernel source file I<Documentation/vm/soft-"
"dirty.txt>)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1065
#, no-wrap
msgid "54-0"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1074
msgid ""
"If the page is present in RAM (bit 63), then these bits provide the page "
"frame number, which can be used to index I</proc/kpageflags> and "
"I</proc/kpagecount>.  If the page is present in swap (bit 62), then bits 4-0"
" give the swap type, and bits 54-5 encode the swap offset."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1078
msgid ""
"Before Linux 3.11, bits 60-55 were used to encode the base-2 log of the page"
" size."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1085
msgid ""
"To employ I</proc/[pid]/pagemap> efficiently, use I</proc/[pid]/maps> to "
"determine which areas of memory are actually mapped and seek to skip over "
"unmapped regions."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1091
msgid ""
"The I</proc/[pid]/pagemap> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1091
#, no-wrap
msgid "I</proc/[pid]/personality> (since Linux 2.6.28)"
msgstr ""

#.  commit 478307230810d7e2a753ed220db9066dfdf88718
#. type: Plain text
#: man-pages/man5/proc.5:1097
msgid ""
"This read-only file exposes the process's execution domain, as set by "
"B<personality>(2).  The value is displayed in hexadecimal notation."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1097
#, no-wrap
msgid "I</proc/[pid]/root>"
msgstr "I</proc/[pid]/root>"

#. type: Plain text
#: man-pages/man5/proc.5:1108
msgid ""
"UNIX and Linux support the idea of a per-process root of the filesystem, set"
" by the B<chroot>(2)  system call.  This file is a symbolic link that points"
" to the process's root directory, and behaves in the same way as I<exe>, and"
" I<fd/*>."
msgstr "UNIX и Linux поддерживают идею о корневом каталоге файловой системы для каждого процесса, который может быть установлен системным вызовом B<chroot>(2). Этот файл является символьной ссылкой, которая указывает на корневой каталог процесса и ведёт себя так же, как I<exe> и I<fd/*>."

#. type: TP
#: man-pages/man5/proc.5:1133
#, no-wrap
msgid "I</proc/[pid]/smaps> (since Linux 2.6.14)"
msgstr "I</proc/[pid]/smaps> (начиная с Linux 2.6.14)"

#. type: Plain text
#: man-pages/man5/proc.5:1137
msgid ""
"This file shows memory consumption for each of the process's mappings.  For "
"each mapping there is a series of lines such as the following:"
msgstr "Этот файл содержит значение потребления памяти каждого отображения процесса. Для каждого отображения есть несколько строк в виде:"

#. type: Plain text
#: man-pages/man5/proc.5:1155
#, no-wrap
msgid ""
"00400000-0048a000 r-xp 00000000 fd:03 960637       /bin/bash\n"
"Size:                552 kB\n"
"Rss:                 460 kB\n"
"Pss:                 100 kB\n"
"Shared_Clean:        452 kB\n"
"Shared_Dirty:          0 kB\n"
"Private_Clean:         8 kB\n"
"Private_Dirty:         0 kB\n"
"Referenced:          460 kB\n"
"Anonymous:             0 kB\n"
"AnonHugePages:         0 kB\n"
"Swap:                  0 kB\n"
"KernelPageSize:        4 kB\n"
"MMUPageSize:           4 kB\n"
"Locked:                0 kB\n"
msgstr "00400000-0048a000 r-xp 00000000 fd:03 960637       /bin/bash\nSize:                552 kB\nRss:                 460 kB\nPss:                 100 kB\nShared_Clean:        452 kB\nShared_Dirty:          0 kB\nPrivate_Clean:         8 kB\nPrivate_Dirty:         0 kB\nReferenced:          460 kB\nAnonymous:             0 kB\nAnonHugePages:         0 kB\nSwap:                  0 kB\nKernelPageSize:        4 kB\nMMUPageSize:           4 kB\nLocked:                0 kB\n"

#. type: Plain text
#: man-pages/man5/proc.5:1172
msgid ""
"The first of these lines shows the same information as is displayed for the "
"mapping in I</proc/[pid]/maps>.  The remaining lines show the size of the "
"mapping, the amount of the mapping that is currently resident in RAM "
"(\"Rss\"), the process' proportional share of this mapping (\"Pss\"), the "
"number of clean and dirty shared pages in the mapping, and the number of "
"clean and dirty private pages in the mapping.  \"Referenced\" indicates the "
"amount of memory currently marked as referenced or accessed.  \"Anonymous\" "
"shows the amount of memory that does not belong to any file.  \"Swap\" shows"
" how much would-be-anonymous memory is also used, but out on swap."
msgstr "Первые строки содержат ту же информацию, что и для отображения в I</proc/[pid]/maps>. Оставшиеся строки содержат размер отображения, размер отображения, которое сейчас находится в RAM («Rss»), вклад этого отображения в пропорцию общих страниц процесса («Pss»), количество чистых и грязных общих страниц в отображении и количеств количество чистых и грязных частных страниц в отображении. В «Referenced» указано количество памяти помеченной, в данный момент, как ссылочная или доступная. В «Anonymous» указано количество памяти, которая не принадлежит никакому файлу. В «Swap» указано как много также использовалось было бы анонимной памяти, но она в подкачке."

#. type: Plain text
#: man-pages/man5/proc.5:1180
msgid ""
"The \"KernelPageSize\" entry is the page size used by the kernel to back a "
"VMA.  This matches the size used by the MMU in the majority of cases.  "
"However, one counter-example occurs on PPC64 kernels whereby a kernel using "
"64K as a base page size may still use 4K pages for the MMU on older "
"processors.  To distinguish, this patch reports \"MMUPageSize\" as the page "
"size used by the MMU."
msgstr "Значение «KernelPageSize» — размер страницы, используемый ядром в (to back a) VMA. В большинстве случаев, размер совпадает с используемым в MMU. Однако, например в ядрах PPC64 в качестве базового размера страницы используется 64К, но при этом по-прежнему могут использоваться 4К страницы для MMU на старых процессорах. Чтобы отличать, эта заплата выдаёт размер страницы, используемый MMU, в «MMUPageSize»."

#. type: Plain text
#: man-pages/man5/proc.5:1183
msgid "The \"Locked\" indicates whether the mapping is locked in memory or not."
msgstr "Значение «Locked» указывает будет ли отображение заблокировано в памяти или нет."

#. type: Plain text
#: man-pages/man5/proc.5:1187
msgid ""
"\"VmFlags\" field represents the kernel flags associated with the particular"
" virtual memory area in two letter encoded manner.  The codes are the "
"following:"
msgstr "Поле «VmFlags» представляет флаги ядра, связанные с определённой виртуальной областью памяти, в виде двух букв. Описание кодирования:"

#. type: Plain text
#: man-pages/man5/proc.5:1216
#, no-wrap
msgid ""
"    rd  - readable\n"
"    wr  - writable\n"
"    ex  - executable\n"
"    sh  - shared\n"
"    mr  - may read\n"
"    mw  - may write\n"
"    me  - may execute\n"
"    ms  - may share\n"
"    gd  - stack segment grows down\n"
"    pf  - pure PFN range\n"
"    dw  - disabled write to the mapped file\n"
"    lo  - pages are locked in memory\n"
"    io  - memory mapped I/O area\n"
"    sr  - sequential read advise provided\n"
"    rr  - random read advise provided\n"
"    dc  - do not copy area on fork\n"
"    de  - do not expand area on remapping\n"
"    ac  - area is accountable\n"
"    nr  - swap space is not reserved for the area\n"
"    ht  - area uses huge tlb pages\n"
"    nl  - non-linear mapping\n"
"    ar  - architecture specific flag\n"
"    dd  - do not include area into core dump\n"
"    sd  - soft-dirty flag\n"
"    mm  - mixed map area\n"
"    hg  - huge page advise flag\n"
"    nh  - no-huge page advise flag\n"
"    mg  - mergeable advise flag\n"
msgstr "    rd  - доступна для чтения\n    wr  - доступна для записи\n    ex  - доступна для исполнения\n    sh  - общая\n    mr  - может читаться\n    mw  - может писаться\n    me  - может исполняться\n    ms  - может быть общей\n    gd  - сегмент стека растёт вниз\n    pf  - чистый диапазон PFN\n    dw  - отключена запись в отображаемый файл\n    lo  - страницы заблокированы в памяти\n    io  - память отображённой области ввода-вывода\n    sr  - предоставляет уведомление для последовательного чтения\n    rr  - предоставляет уведомление для чтения с произвольным доступом\n    dc  - область не копируется при fork\n    de  - область не расширяется при переотображении\n    ac  - область учитывается\n    nr  - для области не зарезервировано пространство подкачки\n    ht  - область использует огромные страницы tlb\n    nl  - нелинейное отображение\n    ar  - флаг, зависящий от архитектуры\n    dd  - область не включается в дамп памяти\n    sd  - флаг несильного загрязнения\n    mm  - область смешанной карты\n    hg  - уведомительный флаг огромной страницы\n    nh  - уведомительный флаг не огромной страницы\n    mg  - уведомительный флаг слияния\n"

#. type: Plain text
#: man-pages/man5/proc.5:1222
msgid ""
"The I</proc/[pid]/smaps> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr "Файл I</proc/[pid]/smaps> существует только, если если включён параметр настройки ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:1222
#, no-wrap
msgid "I</proc/[pid]/stack> (since Linux 2.6.29)"
msgstr "I</proc/[pid]/stack> (начиная с Linux 2.6.29)"

#.  2ec220e27f5040aec1e88901c1b6ea3d135787ad
#. type: Plain text
#: man-pages/man5/proc.5:1230
msgid ""
"This file provides a symbolic trace of the function calls in this process's "
"kernel stack.  This file is provided only if the kernel was built with the "
"B<CONFIG_STACKTRACE> configuration option."
msgstr "Этот файл предоставляет символическую трассировку вызовов функций в стеке ядра для этого процесса. Этот файл есть в системе только, если ядро было собрано с параметром настройки B<CONFIG_STACKTRACE>."

#. type: TP
#: man-pages/man5/proc.5:1230
#, no-wrap
msgid "I</proc/[pid]/stat>"
msgstr "I</proc/[pid]/stat>"

#. type: Plain text
#: man-pages/man5/proc.5:1237
msgid ""
"Status information about the process.  This is used by B<ps>(1).  It is "
"defined in the kernel source file I<fs/proc/array.c>."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1241
msgid ""
"The fields, in order, with their proper B<scanf>(3)  format specifiers, are:"
msgstr "Вот поля с соответствующими им спецификаторами формата B<scanf>(3) по порядку:"

#. type: TP
#: man-pages/man5/proc.5:1242
#, no-wrap
msgid "(1) I<pid> \\ %d"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1246
msgid "The process ID."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1246
#, no-wrap
msgid "(2) I<comm> \\ %s"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1250
msgid ""
"The filename of the executable, in parentheses.  This is visible whether or "
"not the executable is swapped out."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1250
#, no-wrap
msgid "(3) I<state> \\ %c"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1253
msgid "One of the following characters, indicating process state:"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1254
#, no-wrap
msgid "R"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1256
msgid "Running"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1256
#, no-wrap
msgid "S"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1258
msgid "Sleeping in an interruptible wait"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1258
#, no-wrap
msgid "D"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1261
msgid "Waiting in uninterruptible disk sleep"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1261
#, no-wrap
msgid "Z"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1263
msgid "Zombie"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1263
#, no-wrap
msgid "T"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1265
msgid "Stopped (on a signal) or (before Linux 2.6.33) trace stopped"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1265
#, no-wrap
msgid "t"
msgstr ""

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#. type: Plain text
#: man-pages/man5/proc.5:1268
msgid "Tracing stop (Linux 2.6.33 onward)"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1268 man-pages/man5/proc.5:1282
#, no-wrap
msgid "W"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1270
msgid "Paging (only before Linux 2.6.0)"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1270
#, no-wrap
msgid "X"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1272
msgid "Dead (from Linux 2.6.0 onward)"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1272
#, no-wrap
msgid "x"
msgstr ""

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:1277
msgid "Dead (Linux 2.6.33 to 3.13 only)"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1277
#, no-wrap
msgid "K"
msgstr ""

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:1282
msgid "Wakekill (Linux 2.6.33 to 3.13 only)"
msgstr ""

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:1287
msgid "Waking (Linux 2.6.33 to 3.13 only)"
msgstr ""

#. type: IP
#: man-pages/man5/proc.5:1287
#, no-wrap
msgid "P"
msgstr ""

#.  commit f2530dc71cf0822f90bb63ea4600caaef33a66bb
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:1292
msgid "Parked (Linux 3.9 to 3.13 only)"
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1293
#, no-wrap
msgid "(4) I<ppid> \\ %d"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1296
msgid "The PID of the parent of this process."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1296
#, no-wrap
msgid "(5) I<pgrp> \\ %d"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1299
msgid "The process group ID of the process."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1299
#, no-wrap
msgid "(6) I<session> \\ %d"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1302
msgid "The session ID of the process."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1302
#, no-wrap
msgid "(7) I<tty_nr> \\ %d"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1308
msgid ""
"The controlling terminal of the process.  (The minor device number is "
"contained in the combination of bits 31 to 20 and 7 to 0; the major device "
"number is in bits 15 to 8.)"
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1308
#, no-wrap
msgid "(8) I<tpgid> \\ %d"
msgstr ""

#.  This field and following, up to and including wchan added 0.99.1
#. type: Plain text
#: man-pages/man5/proc.5:1313
msgid ""
"The ID of the foreground process group of the controlling terminal of the "
"process."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1313
#, no-wrap
msgid "(9) I<flags> \\ %u"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1320
msgid ""
"The kernel flags word of the process.  For bit meanings, see the PF_* "
"defines in the Linux kernel source file I<include/linux/sched.h>.  Details "
"depend on the kernel version."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1322 man-pages/man5/proc.5:1424
msgid "The format for this field was %lu before Linux 2.6."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1322
#, no-wrap
msgid "(1) I<minflt> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1326
msgid ""
"The number of minor faults the process has made which have not required "
"loading a memory page from disk."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1326
#, no-wrap
msgid "(11) I<cminflt> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1330
msgid ""
"The number of minor faults that the process's waited-for children have made."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1330
#, no-wrap
msgid "(12) I<majflt> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1334
msgid ""
"The number of major faults the process has made which have required loading "
"a memory page from disk."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1334
#, no-wrap
msgid "(13) I<cmajflt> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1338
msgid ""
"The number of major faults that the process's waited-for children have made."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1338
#, no-wrap
msgid "(14) I<utime> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1347
msgid ""
"Amount of time that this process has been scheduled in user mode, measured "
"in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>).  This includes guest "
"time, I<guest_time> (time spent running a virtual CPU, see below), so that "
"applications that are not aware of the guest time field do not lose that "
"time from their calculations."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1347
#, no-wrap
msgid "(15) I<stime> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1352
msgid ""
"Amount of time that this process has been scheduled in kernel mode, measured"
" in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1352
#, no-wrap
msgid "(16) I<cutime> \\ %ld"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1362
msgid ""
"Amount of time that this process's waited-for children have been scheduled "
"in user mode, measured in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>).  "
"(See also B<times>(2).)  This includes guest time, I<cguest_time> (time "
"spent running a virtual CPU, see below)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1362
#, no-wrap
msgid "(17) I<cstime> \\ %ld"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1368
msgid ""
"Amount of time that this process's waited-for children have been scheduled "
"in kernel mode, measured in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1368
#, no-wrap
msgid "(18) I<priority> \\ %ld"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1385
msgid ""
"(Explanation for Linux 2.6)  For processes running a real-time scheduling "
"policy (I<policy> below; see B<sched_setscheduler>(2)), this is the negated "
"scheduling priority, minus one; that is, a number in the range -2 to -100, "
"corresponding to real-time priorities 1 to 99.  For processes running under "
"a non-real-time scheduling policy, this is the raw nice value "
"(B<setpriority>(2))  as represented in the kernel.  The kernel stores nice "
"values as numbers in the range 0 (high) to 39 (low), corresponding to the "
"user-visible nice range of -20 to 19."
msgstr ""

#.  And back in kernel 1.2 days things were different again.
#. type: Plain text
#: man-pages/man5/proc.5:1389
msgid ""
"Before Linux 2.6, this was a scaled value based on the scheduler weighting "
"given to this process."
msgstr "До Linux 2.6 это была пересчитанная величина на основе весов планировщика для определённого процесса."

#. type: TP
#: man-pages/man5/proc.5:1389
#, no-wrap
msgid "(19) I<nice> \\ %ld"
msgstr ""

#.  Back in kernel 1.2 days things were different.
#.  .TP
#.  \fIcounter\fP %ld
#.  The current maximum size in jiffies of the process's next timeslice,
#.  or what is currently left of its current timeslice, if it is the
#.  currently running process.
#.  .TP
#.  \fItimeout\fP %u
#.  The time in jiffies of the process's next timeout.
#.  timeout was removed sometime around 2.1/2.2
#. type: Plain text
#: man-pages/man5/proc.5:1404
msgid ""
"The nice value (see B<setpriority>(2)), a value in the range 19 (low "
"priority) to -20 (high priority)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1404
#, no-wrap
msgid "(20) I<num_threads> \\ %ld"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1409
msgid ""
"Number of threads in this process (since Linux 2.6).  Before kernel 2.6, "
"this field was hard coded to 0 as a placeholder for an earlier removed "
"field."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1409
#, no-wrap
msgid "(21) I<itrealvalue> \\ %ld"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1416
msgid ""
"The time in jiffies before the next B<SIGALRM> is sent to the process due to"
" an interval timer.  Since kernel 2.6.17, this field is no longer "
"maintained, and is hard coded as 0."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1416
#, no-wrap
msgid "(22) I<starttime> \\ %llu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1422
msgid ""
"The time the process started after system boot.  In kernels before Linux "
"2.6, this value was expressed in jiffies.  Since Linux 2.6, the value is "
"expressed in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1424
#, no-wrap
msgid "(23) I<vsize> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1427
msgid "Virtual memory size in bytes."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1427
#, no-wrap
msgid "(24) I<rss> \\ %ld"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1434
msgid ""
"Resident Set Size: number of pages the process has in real memory.  This is "
"just the pages which count toward text, data, or stack space.  This does not"
" include pages which have not been demand-loaded in, or which are swapped "
"out."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1434
#, no-wrap
msgid "(25) I<rsslim> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1441
msgid ""
"Current soft limit in bytes on the rss of the process; see the description "
"of B<RLIMIT_RSS> in B<getrlimit>(2)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1441
#, no-wrap
msgid "(26) I<startcode> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1444
msgid "The address above which program text can run."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1444
#, no-wrap
msgid "(27) I<endcode> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1447
msgid "The address below which program text can run."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1447
#, no-wrap
msgid "(28) I<startstack> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1450
msgid "The address of the start (i.e., bottom) of the stack."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1450
#, no-wrap
msgid "(29) I<kstkesp> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1454
msgid ""
"The current value of ESP (stack pointer), as found in the kernel stack page "
"for the process."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1454
#, no-wrap
msgid "(30) I<kstkeip> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1457
msgid "The current EIP (instruction pointer)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1457
#, no-wrap
msgid "(31) I<signal> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1463
msgid ""
"The bitmap of pending signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use "
"I</proc/[pid]/status> instead."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1463
#, no-wrap
msgid "(32) I<blocked> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1469
msgid ""
"The bitmap of blocked signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use "
"I</proc/[pid]/status> instead."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1469
#, no-wrap
msgid "(33) I<sigignore> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1475
msgid ""
"The bitmap of ignored signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use "
"I</proc/[pid]/status> instead."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1475
#, no-wrap
msgid "(34) I<sigcatch> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1481
msgid ""
"The bitmap of caught signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use "
"I</proc/[pid]/status> instead."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1481
#, no-wrap
msgid "(35) I<wchan> \\ %lu"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1487
msgid ""
"This is the \"channel\" in which the process is waiting.  It is the address "
"of a location in the kernel where the process is sleeping.  The "
"corresponding symbolic name can be found in I</proc/[pid]/wchan>."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1487
#, no-wrap
msgid "(36) I<nswap> \\ %lu"
msgstr ""

#.  nswap was added in 2.0
#. type: Plain text
#: man-pages/man5/proc.5:1491
msgid "Number of pages swapped (not maintained)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1491
#, no-wrap
msgid "(37) I<cnswap> \\ %lu"
msgstr ""

#.  cnswap was added in 2.0
#. type: Plain text
#: man-pages/man5/proc.5:1495
msgid "Cumulative I<nswap> for child processes (not maintained)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1495
#, no-wrap
msgid "(38) I<exit_signal> \\ %d \\ (since Linux 2.1.22)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1498
msgid "Signal to be sent to parent when we die."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1498
#, no-wrap
msgid "(39) I<processor> \\ %d \\ (since Linux 2.2.8)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1501
msgid "CPU number last executed on."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1501
#, no-wrap
msgid "(40) I<rt_priority> \\ %u \\ (since Linux 2.5.19)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1507
msgid ""
"Real-time scheduling priority, a number in the range 1 to 99 for processes "
"scheduled under a real-time policy, or 0, for non-real-time processes (see "
"B<sched_setscheduler>(2))."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1507
#, no-wrap
msgid "(41) I<policy> \\ %u \\ (since Linux 2.5.19)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1513
msgid ""
"Scheduling policy (see B<sched_setscheduler>(2)).  Decode using the SCHED_* "
"constants in I<linux/sched.h>."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1515
msgid "The format for this field was %lu before Linux 2.6.22."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1515
#, no-wrap
msgid "(42) I<delayacct_blkio_ticks> \\ %llu \\ (since Linux 2.6.18)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1518
msgid "Aggregated block I/O delays, measured in clock ticks (centiseconds)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1518
#, no-wrap
msgid "(43) I<guest_time> \\ %lu \\ (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1523
msgid ""
"Guest time of the process (time spent running a virtual CPU for a guest "
"operating system), measured in clock ticks (divide by "
"I<sysconf(_SC_CLK_TCK)>)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1523
#, no-wrap
msgid "(44) I<cguest_time> \\ %ld \\ (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1527
msgid ""
"Guest time of the process's children, measured in clock ticks (divide by "
"I<sysconf(_SC_CLK_TCK)>)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1527
#, no-wrap
msgid "(45) I<start_data> \\ %lu \\ (since Linux 3.3)"
msgstr ""

#.  commit b3f7f573a20081910e34e99cbc91831f4f02f1ff
#. type: Plain text
#: man-pages/man5/proc.5:1532
msgid ""
"Address above which program initialized and uninitialized (BSS) data are "
"placed."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1532
#, no-wrap
msgid "(46) I<end_data> \\ %lu \\ (since Linux 3.3)"
msgstr ""

#.  commit b3f7f573a20081910e34e99cbc91831f4f02f1ff
#. type: Plain text
#: man-pages/man5/proc.5:1537
msgid ""
"Address below which program initialized and uninitialized (BSS) data are "
"placed."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1537
#, no-wrap
msgid "(47) I<start_brk> \\ %lu \\ (since Linux 3.3)"
msgstr ""

#.  commit b3f7f573a20081910e34e99cbc91831f4f02f1ff
#. type: Plain text
#: man-pages/man5/proc.5:1542
msgid "Address above which program heap can be expanded with B<brk>(2)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1542
#, no-wrap
msgid "(48) I<arg_start> \\ %lu \\ (since Linux 3.5)"
msgstr ""

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:1548
msgid ""
"Address above which program command-line arguments (I<argv>)  are placed."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1548
#, no-wrap
msgid "(49) I<arg_end> \\ %lu \\ (since Linux 3.5)"
msgstr ""

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:1554
msgid "Address below program command-line arguments (I<argv>)  are placed."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1554
#, no-wrap
msgid "(50) I<env_start> \\ %lu \\ (since Linux 3.5)"
msgstr ""

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:1558
msgid "Address above which program environment is placed."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1558
#, no-wrap
msgid "(51) I<env_end> \\ %lu \\ (since Linux 3.5)"
msgstr ""

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:1562
msgid "Address below which program environment is placed."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1562
#, no-wrap
msgid "(52) I<exit_code> \\ %d \\ (since Linux 3.5)"
msgstr ""

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:1567
msgid "The thread's exit status in the form reported by B<waitpid>(2)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1568
#, no-wrap
msgid "I</proc/[pid]/statm>"
msgstr "I</proc/[pid]/statm>"

#. type: Plain text
#: man-pages/man5/proc.5:1572
msgid ""
"Provides information about memory usage, measured in pages.  The columns "
"are:"
msgstr "Предоставляет информацию об использовании памяти, измеряется в страницах. Колонки:"

#.  (not including libs; broken, includes data segment)
#.  (including libs; broken, includes library text)
#. type: Plain text
#: man-pages/man5/proc.5:1586
#, no-wrap
msgid ""
"size       (1) total program size\n"
"           (same as VmSize in I</proc/[pid]/status>)\n"
"resident   (2) resident set size\n"
"           (same as VmRSS in I</proc/[pid]/status>)\n"
"share      (3) shared pages (i.e., backed by a file)\n"
"text       (4) text (code)\n"
"lib        (5) library (unused in Linux 2.6)\n"
"data       (6) data + stack\n"
"dt         (7) dirty pages (unused in Linux 2.6)\n"
msgstr "size       (1) общий размер программы\n           (тоже что и VmSize в I</proc/[pid]/status>)\nresident   (2) размер резидентной части\n           (тоже что и VmRSS в I</proc/[pid]/status>)\nshare      (3) страницы общего пользования (из общих отображений)\ntext       (4) текст (код)\nlib        (5) библиотека (не используется в Linux 2.6)\ndata       (6) данные + стек\ndt         (7) грязные страницы (не используется в Linux 2.6)\n"

#. type: TP
#: man-pages/man5/proc.5:1588
#, no-wrap
msgid "I</proc/[pid]/status>"
msgstr "I</proc/[pid]/status>"

#. type: Plain text
#: man-pages/man5/proc.5:1596
msgid ""
"Provides much of the information in I</proc/[pid]/stat> and "
"I</proc/[pid]/statm> in a format that's easier for humans to parse.  Here's "
"an example:"
msgstr "В основном, предоставляет информацию из I</proc/[pid]/stat> и I</proc/[pid]/statm> в более лёгком для прочтения человеком формате. Пример:"

#. type: Plain text
#: man-pages/man5/proc.5:1637
#, no-wrap
msgid ""
"$B< cat /proc/$$/status>\n"
"Name:   bash\n"
"State:  S (sleeping)\n"
"Tgid:   3515\n"
"Pid:    3515\n"
"PPid:   3452\n"
"TracerPid:      0\n"
"Uid:    1000    1000    1000    1000\n"
"Gid:    100     100     100     100\n"
"FDSize: 256\n"
"Groups: 16 33 100\n"
"VmPeak:     9136 kB\n"
"VmSize:     7896 kB\n"
"VmLck:         0 kB\n"
"VmHWM:      7572 kB\n"
"VmRSS:      6316 kB\n"
"VmData:     5224 kB\n"
"VmStk:        88 kB\n"
"VmExe:       572 kB\n"
"VmLib:      1708 kB\n"
"VmPTE:        20 kB\n"
"Threads:        1\n"
"SigQ:   0/3067\n"
"SigPnd: 0000000000000000\n"
"ShdPnd: 0000000000000000\n"
"SigBlk: 0000000000010000\n"
"SigIgn: 0000000000384004\n"
"SigCgt: 000000004b813efb\n"
"CapInh: 0000000000000000\n"
"CapPrm: 0000000000000000\n"
"CapEff: 0000000000000000\n"
"CapBnd: ffffffffffffffff\n"
"Cpus_allowed:   00000001\n"
"Cpus_allowed_list:      0\n"
"Mems_allowed:   1\n"
"Mems_allowed_list:      0\n"
"voluntary_ctxt_switches:        150\n"
"nonvoluntary_ctxt_switches:     545\n"
msgstr "$B< cat /proc/$$/status>\nName:   bash\nState:  S (sleeping)\nTgid:   3515\nPid:    3515\nPPid:   3452\nTracerPid:      0\nUid:    1000    1000    1000    1000\nGid:    100     100     100     100\nFDSize: 256\nGroups: 16 33 100\nVmPeak:     9136 kB\nVmSize:     7896 kB\nVmLck:         0 kB\nVmHWM:      7572 kB\nVmRSS:      6316 kB\nVmData:     5224 kB\nVmStk:        88 kB\nVmExe:       572 kB\nVmLib:      1708 kB\nVmPTE:        20 kB\nThreads:        1\nSigQ:   0/3067\nSigPnd: 0000000000000000\nShdPnd: 0000000000000000\nSigBlk: 0000000000010000\nSigIgn: 0000000000384004\nSigCgt: 000000004b813efb\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: ffffffffffffffff\nCpus_allowed:   00000001\nCpus_allowed_list:      0\nMems_allowed:   1\nMems_allowed_list:      0\nvoluntary_ctxt_switches:        150\nnonvoluntary_ctxt_switches:     545\n"

#. type: Plain text
#: man-pages/man5/proc.5:1645
msgid "I<Name>: Command run by this process."
msgstr "I<Name>: Команда, выполняемая этим процессом."

#. type: Plain text
#: man-pages/man5/proc.5:1657
msgid ""
"I<State>: Current state of the process.  One of \"R (running)\", \"S "
"(sleeping)\", \"D (disk sleep)\", \"T (stopped)\", \"T (tracing stop)\", \"Z"
" (zombie)\", or \"X (dead)\"."
msgstr "I<State>: Текущее состояние процесса. Может быть \"R (работает)\", \"S (спит)\", \"D (спит на диске)\", \"T (остановлен)\", \"T (остановлен трассировкой)\", \"Z (зомби)\" или \"X (завершён)\"."

#. type: Plain text
#: man-pages/man5/proc.5:1660
msgid "I<Tgid>: Thread group ID (i.e., Process ID)."
msgstr "I<Tgid>: Групповой ID нити (т.е., ID процесса)."

#. type: Plain text
#: man-pages/man5/proc.5:1664
msgid "I<Pid>: Thread ID (see B<gettid>(2))."
msgstr "I<Pid>: ID нити (см. B<gettid>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:1667
msgid "I<PPid>: PID of parent process."
msgstr "I<PPid>: PID родительского процесса."

#. type: Plain text
#: man-pages/man5/proc.5:1670
msgid ""
"I<TracerPid>: PID of process tracing this process (0 if not being traced)."
msgstr "I<TracerPid>: PID процесса, который выполняет трассировку данного процесса (0, если трассировки нет)."

#. type: Plain text
#: man-pages/man5/proc.5:1673
msgid ""
"I<Uid>, I<Gid>: Real, effective, saved set, and filesystem UIDs (GIDs)."
msgstr "I<Uid>, I<Gid>: Реальный, эффективный, сохранённый и используемый в файловой системе UID (GID)."

#. type: Plain text
#: man-pages/man5/proc.5:1676
msgid "I<FDSize>: Number of file descriptor slots currently allocated."
msgstr "I<FDSize>: Количество слотов файловых дескрипторов выделенных в данный момент."

#. type: Plain text
#: man-pages/man5/proc.5:1679
msgid "I<Groups>: Supplementary group list."
msgstr "I<Groups>: Список дополнительных групп."

#. type: Plain text
#: man-pages/man5/proc.5:1682
msgid "I<VmPeak>: Peak virtual memory size."
msgstr "I<VmPeak>: Пик размера виртуальной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:1685
msgid "I<VmSize>: Virtual memory size."
msgstr "I<VmSize>: Размер виртуальной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:1689
msgid "I<VmLck>: Locked memory size (see B<mlock>(3))."
msgstr "I<VmLck>: Размер заблокированной памяти (см. B<mlock>(3))."

#. type: Plain text
#: man-pages/man5/proc.5:1692
msgid "I<VmHWM>: Peak resident set size (\"high water mark\")."
msgstr "I<VmHWM>: Пик размера резидентной памяти (\"отметка высоты прилива\")."

#. type: Plain text
#: man-pages/man5/proc.5:1695
msgid "I<VmRSS>: Resident set size."
msgstr "I<VmRSS>: Размер резидентной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:1698
msgid "I<VmData>, I<VmStk>, I<VmExe>: Size of data, stack, and text segments."
msgstr "I<VmData>, I<VmStk>, I<VmExe>: Размер сегментов данных, стека и кода."

#. type: Plain text
#: man-pages/man5/proc.5:1701
msgid "I<VmLib>: Shared library code size."
msgstr "I<VmLib>: Размер кода общей библиотеки."

#. type: Plain text
#: man-pages/man5/proc.5:1704
msgid "I<VmPTE>: Page table entries size (since Linux 2.6.10)."
msgstr "I<VmPTE>: Размер элементов страничной таблицы (начиная с Linux 2.6.10)."

#. type: Plain text
#: man-pages/man5/proc.5:1707
msgid "I<Threads>: Number of threads in process containing this thread."
msgstr "I<Threads>: Количество нитей в процессе, содержащем эту нить."

#. type: Plain text
#: man-pages/man5/proc.5:1718
msgid ""
"I<SigQ>: This field contains two slash-separated numbers that relate to "
"queued signals for the real user ID of this process.  The first of these is "
"the number of currently queued signals for this real user ID, and the second"
" is the resource limit on the number of queued signals for this process (see"
" the description of B<RLIMIT_SIGPENDING> in B<getrlimit>(2))."
msgstr "I<SigQ>: В этом поле содержится два числа, разделённых косой чертой, которые относятся к сигналам, имеющимся в очереди для реального пользовательского ID этого процесса. Первое число показывает текущее количество сигналов в очереди для реального пользовательского ID, а второе — ограничитель ресурса на количество сигналов в очереди для этого процесса (смотрите описание B<RLIMIT_SIGPENDING> в B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:1724
msgid ""
"I<SigPnd>, I<ShdPnd>: Number of signals pending for thread and for process "
"as a whole (see B<pthreads>(7)  and B<signal>(7))."
msgstr "I<SigPnd>, I<ShdPnd>: Количество сигналов, ждущих обработки нитью и всем процессом (см. B<pthreads>(7) и B<signal>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1728
msgid ""
"I<SigBlk>, I<SigIgn>, I<SigCgt>: Masks indicating signals being blocked, "
"ignored, and caught (see B<signal>(7))."
msgstr "I<SigBlk>, I<SigIgn>, I<SigCgt>: Маски, отражающие блокированные, игнорируемые и перехваченные сигналы (см. B<signal>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1733
msgid ""
"I<CapInh>, I<CapPrm>, I<CapEff>: Masks of capabilities enabled in "
"inheritable, permitted, and effective sets (see B<capabilities>(7))."
msgstr "I<CapInh>, I<CapPrm>, I<CapEff>: Маски мандатов, включённые в наследуемый, разрешающий и эффективный наборы (см. B<capabilities>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1738
msgid ""
"I<CapBnd>: Capability Bounding set (since kernel 2.6.26, see "
"B<capabilities>(7))."
msgstr "I<CapBnd>: Мандатный ограничивающий набор (начиная с ядра 2.6.26, см. B<capabilities>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1743
msgid ""
"I<Cpus_allowed>: Mask of CPUs on which this process may run (since Linux "
"2.6.24, see B<cpuset>(7))."
msgstr "I<Cpus_allowed>: Маска процессоров, на которых может выполняться процесс (начиная с Linux 2.6.24, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1748
msgid ""
"I<Cpus_allowed_list>: Same as previous, but in \"list format\" (since Linux "
"2.6.26, see B<cpuset>(7))."
msgstr "I<Cpus_allowed_list>: Тоже что предыдущий, но в \"формате списка\" (начиная с Linux 2.6.26, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1753
msgid ""
"I<Mems_allowed>: Mask of memory nodes allowed to this process (since Linux "
"2.6.24, see B<cpuset>(7))."
msgstr "I<Mems_allowed>: Маска узлов памяти, разрешённых для этого процесса (начиная с Linux 2.6.24, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1758
msgid ""
"I<Mems_allowed_list>: Same as previous, but in \"list format\" (since Linux "
"2.6.26, see B<cpuset>(7))."
msgstr "I<Mems_allowed_list>: Тоже что и предыдущее, но в \"формате списка\" (начиная с Linux 2.6.26, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:1761
msgid ""
"I<voluntary_ctxt_switches>, I<nonvoluntary_ctxt_switches>: Number of "
"voluntary and involuntary context switches (since Linux 2.6.23)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1762
#, no-wrap
msgid "I</proc/[pid]/syscall> (since Linux 2.6.27)"
msgstr ""

#.  commit ebcb67341fee34061430f3367f2e507e52ee051b
#. type: Plain text
#: man-pages/man5/proc.5:1770
msgid ""
"This file exposes the system call number and argument registers for the "
"system call currently being executed by the process, followed by the values "
"of the stack pointer and program counter registers.  The values of all six "
"argument registers are exposed, although most system calls use fewer "
"registers."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1775
msgid ""
"If the process is blocked, but not in a system call, then the file displays "
"-1 in place of the system call number, followed by just the values of the "
"stack pointer and program counter.  If process is not blocked, then file "
"contains just the string \"running\"."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:1778
msgid ""
"This file is present only if the kernel was configured with "
"B<CONFIG_HAVE_ARCH_TRACEHOOK>."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:1778
#, no-wrap
msgid "I</proc/[pid]/task> (since Linux 2.6.0-test6)"
msgstr "I</proc/[pid]/task> (начиная с Linux 2.6.0-test6)"

#. type: Plain text
#: man-pages/man5/proc.5:1809
msgid ""
"This is a directory that contains one subdirectory for each thread in the "
"process.  The name of each subdirectory is the numerical thread ID "
"(I<[tid]>)  of the thread (see B<gettid>(2)).  Within each of these "
"subdirectories, there is a set of files with the same names and contents as "
"under the I</proc/[pid]> directories.  For attributes that are shared by all"
" threads, the contents for each of the files under the I<task/[tid]> "
"subdirectories will be the same as in the corresponding file in the parent "
"I</proc/[pid]> directory (e.g., in a multithreaded process, all of the "
"I<task/[tid]/cwd> files will have the same value as the I</proc/[pid]/cwd> "
"file in the parent directory, since all of the threads in a process share a "
"working directory).  For attributes that are distinct for each thread, the "
"corresponding files under I<task/[tid]> may have different values (e.g., "
"various fields in each of the I<task/[tid]/status> files may be different "
"for each thread)."
msgstr "В этом каталоге содержатся подкаталоги, под одному на нить. Имя подкаталога задаётся числом, которое является ID нити (I<[tid]>) (см. B<gettid>(2)). В каждом подкаталоге есть набор файлов с одинаковыми именами и содержимым как у каталогов I</proc/[pid]>. Для общих атрибутов всех нитей содержимое каждого файла в подкаталогах I<task/[tid]> будет одинаковым, как у соответствующего файла в родительском каталоге I</proc/[pid]> (например, в многонитевом процессе все файлы I<task/[tid]/cwd> будут иметь одинаковое значение, совпадающее с содержимым файла I</proc/[pid]/cwd> в родительском каталоге, так как все нити в процессе используют общий рабочий каталог).Для отличающихся атрибутов нитей соответствующие файлы в I<task/[tid]> могут иметь различные значения (например, различные поля в каждом файле I<task/[tid]/status> могут отличаться в каждой нити)."

#.  The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:1816
msgid ""
"In a multithreaded process, the contents of the I</proc/[pid]/task> "
"directory are not available if the main thread has already terminated "
"(typically by calling B<pthread_exit>(3))."
msgstr "В многонитевом процессе содержимое каталога I</proc/[pid]/task> недоступно, если выполнение главной нити уже завершилось (обычно вызовом B<pthread_exit>(3))."

#. type: TP
#: man-pages/man5/proc.5:1816
#, no-wrap
msgid "I</proc/[pid]/wchan> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/wchan> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:1820
msgid ""
"The symbolic name corresponding to the location in the kernel where the "
"process is sleeping."
msgstr "Символическое имя, соответствующее расположению, где процесс спит в ядре."

#. type: TP
#: man-pages/man5/proc.5:1820
#, no-wrap
msgid "I</proc/apm>"
msgstr "I</proc/apm>"

#. type: Plain text
#: man-pages/man5/proc.5:1825
msgid ""
"Advanced power management version and battery information when B<CONFIG_APM>"
" is defined at kernel compilation time."
msgstr "Версия системы расширенного управления питанием и информация о батарее, если ядро собрано с поддержкой B<CONFIG_APM>."

#. type: TP
#: man-pages/man5/proc.5:1825
#, no-wrap
msgid "I</proc/bus>"
msgstr "I</proc/bus>"

#. type: Plain text
#: man-pages/man5/proc.5:1828
msgid "Contains subdirectories for installed busses."
msgstr "Содержит подкаталоги для установленных шин."

#. type: TP
#: man-pages/man5/proc.5:1828
#, no-wrap
msgid "I</proc/bus/pccard>"
msgstr "I</proc/bus/pccard>"

#. type: Plain text
#: man-pages/man5/proc.5:1833
msgid ""
"Subdirectory for PCMCIA devices when B<CONFIG_PCMCIA> is set at kernel "
"compilation time."
msgstr "Подкаталог для устройств PCMCIA, если ядро собрано с поддержкой B<CONFIG_PCMCIA>."

#. type: TP
#: man-pages/man5/proc.5:1833
#, no-wrap
msgid "I</proc/[pid]/timers> (since Linux 3.10)"
msgstr "I</proc/[pid]/timers> (начиная с Linux 3.10)"

#.  commit 5ed67f05f66c41e39880a6d61358438a25f9fee5
#.  commit 48f6a7a511ef8823fdff39afee0320092d43a8a0
#. type: Plain text
#: man-pages/man5/proc.5:1840
msgid ""
"A list of the POSIX timers for this process.  Each timer is listed with a "
"line that started with the string \"ID:\".  For example:"
msgstr "Список таймеров POSIX этого процесса. Каждый таймер описывается в строке, которая начинается со строки «ID:». Пример:"

#. type: Plain text
#: man-pages/man5/proc.5:1851
#, no-wrap
msgid ""
"ID: 1\n"
"signal: 60/00007fff86e452a8\n"
"notify: signal/pid.2634\n"
"ClockID: 0\n"
"ID: 0\n"
"signal: 60/00007fff86e452a8\n"
"notify: signal/pid.2634\n"
"ClockID: 1\n"
msgstr "ID: 1\nsignal: 60/00007fff86e452a8\nnotify: signal/pid.2634\nClockID: 0\nID: 0\nsignal: 60/00007fff86e452a8\nnotify: signal/pid.2634\nClockID: 1\n"

#. type: Plain text
#: man-pages/man5/proc.5:1855
msgid "The lines shown for each timer have the following meanings:"
msgstr "Строки каждого таймера имеют следующее значение:"

#. type: TP
#: man-pages/man5/proc.5:1856
#, no-wrap
msgid "I<ID>"
msgstr "I<ID>"

#. type: Plain text
#: man-pages/man5/proc.5:1867
msgid ""
"The ID for this timer.  This is not the same as the timer ID returned by "
"B<timer_create>(2); rather, it is the same kernel-internal ID that is "
"available via the I<si_timerid> field of the I<siginfo_t> structure (see "
"B<sigaction>(2))."
msgstr "Идентификатор таймера. Это не тоже самое, что возвращает B<timer_create>(2); это внутренний идентификатор в ядре, который доступен в поле I<si_timerid> структуры I<siginfo_t> (смотрите B<sigaction>(2))."

#. type: TP
#: man-pages/man5/proc.5:1867
#, no-wrap
msgid "I<signal>"
msgstr "I<signal>"

#. type: Plain text
#: man-pages/man5/proc.5:1874
msgid ""
"This is the signal number that this timer uses to deliver notifications "
"followed by a slash, and then the I<sigev_value.sival_ptr> value supplied to"
" the signal handler.  Valid only for timers that notify via a signal."
msgstr "Номер сигнала, который данный таймер использует для доставки уведомлений, затем косая черта, а затем показано значение I<sigev_value.sival_ptr>, передаваемое в обработчик сигнала. Актуален только для таймеров, которые выполняют уведомления посредством сигнала."

#. type: TP
#: man-pages/man5/proc.5:1874
#, no-wrap
msgid "I<notify>"
msgstr "I<notify>"

#. type: Plain text
#: man-pages/man5/proc.5:1885
msgid ""
"The part before the slash specifies the mechanism that this timer uses to "
"deliver notifications, and is one of \"thread\", \"signal\", or \"none\".  "
"Immediately following the slash is either the string \"tid\" for timers with"
" B<SIGEV_THREAD_ID> notification, or \"pid\" for timers that notify by other"
" mechanisms.  Following the \".\" is the PID of the process that will be "
"delivered a signal if the timer delivers notifications via a signal."
msgstr "Часть перед косой чертой определяет механизм, который данный таймер использует для доставки уведомлений, и может быть одним из «thread», «signal» или «none». Сразу за косой чертой может быть строка «tid» для таймеров с уведомлением  B<SIGEV_THREAD_ID>, или «pid» для таймеров, которые уведомляют другими механизмами. Далее после «.»  указан PID процесса, которому будет доставлен сигнал, если таймер доставляет уведомления через сигнал."

#. type: TP
#: man-pages/man5/proc.5:1885
#, no-wrap
msgid "I<ClockID>"
msgstr "I<ClockID>"

#. type: Plain text
#: man-pages/man5/proc.5:1898
msgid ""
"This field identifies the clock that the timer uses for measuring time.  For"
" most clocks, this is a number that matches one of the user-space B<CLOCK_*>"
" constants exposed via I<E<lt>time.hE<gt>>.  B<CLOCK_PROCESS_CPUTIME_ID> "
"timers display with a value of -6 in this field.  B<CLOCK_THREAD_CPUTIME_ID>"
" timers display with a value of -2 in this field."
msgstr "В этом поле задаются часы, которые таймер использует для измерения времени. Для большинства часов это номер, который совпадает с одной из констант пользовательского окружения B<CLOCK_*>, располагающихся в I<E<lt>time.hE<gt>>. Таймеры B<CLOCK_PROCESS_CPUTIME_ID> показываются со значением -6 в этом поле. Таймеры B<CLOCK_THREAD_CPUTIME_ID> показываются со значением -2 в этом поле."

#. type: TP
#: man-pages/man5/proc.5:1899
#, no-wrap
msgid "I</proc/bus/pccard/drivers>"
msgstr "I</proc/bus/pccard/drivers>"

#. type: TP
#: man-pages/man5/proc.5:1901
#, no-wrap
msgid "I</proc/bus/pci>"
msgstr "I</proc/bus/pci>"

#. type: Plain text
#: man-pages/man5/proc.5:1907
msgid ""
"Contains various bus subdirectories and pseudo-files containing information "
"about PCI busses, installed devices, and device drivers.  Some of these "
"files are not ASCII."
msgstr "Содержит различные подкаталоги шин и псевдо-файлы, содержащие информацию о шинах PCI, установленных устройствах и драйверах устройств. Некоторые из этих файлов не являются текстовыми."

#. type: TP
#: man-pages/man5/proc.5:1907
#, no-wrap
msgid "I</proc/bus/pci/devices>"
msgstr "I</proc/bus/pci/devices>"

#. type: Plain text
#: man-pages/man5/proc.5:1914
msgid ""
"Information about PCI devices.  They may be accessed through B<lspci>(8)  "
"and B<setpci>(8)."
msgstr "Информация о устройствах PCI. К ним можно получить доступ через B<lspci>(8) и B<setpci>(8)."

#. type: TP
#: man-pages/man5/proc.5:1914
#, no-wrap
msgid "I</proc/cmdline>"
msgstr "I</proc/cmdline>"

#. type: Plain text
#: man-pages/man5/proc.5:1921
msgid ""
"Arguments passed to the Linux kernel at boot time.  Often done via a boot "
"manager such as B<lilo>(8)  or B<grub>(8)."
msgstr "Аргументы, переданные ядру Linux во время начальной загрузки. Часто это делается через менеджер начальной загрузки, такой как B<lilo>(8) или B<grub>(8)."

#. type: TP
#: man-pages/man5/proc.5:1921
#, no-wrap
msgid "I</proc/config.gz> (since Linux 2.6)"
msgstr "I</proc/config.gz> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man5/proc.5:1939
msgid ""
"This file exposes the configuration options that were used to build the "
"currently running kernel, in the same format as they would be shown in the "
"I<.config> file that resulted when configuring the kernel (using I<make "
"xconfig>, I<make config>, or similar).  The file contents are compressed; "
"view or search them using B<zcat>(1)  and B<zgrep>(1).  As long as no "
"changes have been made to the following file, the contents of "
"I</proc/config.gz> are the same as those provided by :"
msgstr "В этом файле представлены параметры настройки, которые использовались при сборке выполняющегося в данный момент ядра. Его формат одинаков с файлом I<.config>, который создаётся после настройки ядра (с помощью I<make xconfig>, I<make config> и подобных команд). Содержимое файла сжато; для просмотра и поиска используйте B<zcat>(1) и B<zgrep>(1). Пока не внесены изменения в настройку ядра, содержимое I</proc/config.gz> и показываемого по команде файла одинаково:"

#. type: Plain text
#: man-pages/man5/proc.5:1943
#, no-wrap
msgid "cat /lib/modules/$(uname -r)/build/.config\n"
msgstr "cat /lib/modules/$(uname -r)/build/.config\n"

#. type: Plain text
#: man-pages/man5/proc.5:1949
msgid ""
"I</proc/config.gz> is provided only if the kernel is configured with "
"B<CONFIG_IKCONFIG_PROC>."
msgstr "Файл I</proc/config.gz> доступен только, если ядро собрано с поддержкой B<CONFIG_IKCONFIG_PROC>."

#. type: TP
#: man-pages/man5/proc.5:1949
#, no-wrap
msgid "I</proc/cpuinfo>"
msgstr "I</proc/cpuinfo>"

#. type: Plain text
#: man-pages/man5/proc.5:1961
msgid ""
"This is a collection of CPU and system architecture dependent items, for "
"each supported architecture a different list.  Two common entries are "
"I<processor> which gives CPU number and I<bogomips>; a system constant that "
"is calculated during kernel initialization.  SMP machines have information "
"for each CPU.  The B<lscpu>(1)  command gathers its information from this "
"file."
msgstr "Это коллекция элементов, зависящих от процессора и системной архитектуры; для каждой поддерживаемой архитектуры список различен. Имеются только две общих записи: I<processor> \\(em обозначает номер процессора и I<bogomips>\\(em системная константа, которая высчитывается во время инициализации ядра. Для многопроцессорных машин информация предоставляется по каждому процессору. Команда B<lscpu>(1) берёт информацию из этого файла."

#. type: TP
#: man-pages/man5/proc.5:1961
#, no-wrap
msgid "I</proc/devices>"
msgstr "I</proc/devices>"

#. type: Plain text
#: man-pages/man5/proc.5:1965
msgid ""
"Text listing of major numbers and device groups.  This can be used by "
"MAKEDEV scripts for consistency with the kernel."
msgstr "Текстовый список старших (major) номеров устройств и групп устройств. Он может быть использован сценариями MAKEDEV для того, чтобы создать устройства, поддерживаемые ядром."

#. type: TP
#: man-pages/man5/proc.5:1965
#, no-wrap
msgid "I</proc/diskstats> (since Linux 2.5.69)"
msgstr "I</proc/diskstats> (начиная с Linux 2.5.69)"

#. type: Plain text
#: man-pages/man5/proc.5:1971
msgid ""
"This file contains disk I/O statistics for each disk device.  See the Linux "
"kernel source file I<Documentation/iostats.txt> for further information."
msgstr "Файл со статистикой дискового ввода-вывода по каждому устройству. Дополнительная информация доступна в файле I<Documentation/iostats.txt> из исходного кода ядра Linux."

#. type: TP
#: man-pages/man5/proc.5:1971
#, no-wrap
msgid "I</proc/dma>"
msgstr "I</proc/dma>"

#. type: Plain text
#: man-pages/man5/proc.5:1975
msgid ""
"This is a list of the registered I<ISA> DMA (direct memory access)  channels"
" in use."
msgstr "Список рабочих зарегистрированных каналов DMA (прямого доступа в память) I<ISA>."

#. type: TP
#: man-pages/man5/proc.5:1975
#, no-wrap
msgid "I</proc/driver>"
msgstr "I</proc/driver>"

#. type: Plain text
#: man-pages/man5/proc.5:1978
msgid "Empty subdirectory."
msgstr "Пустой подкаталог."

#. type: TP
#: man-pages/man5/proc.5:1978
#, no-wrap
msgid "I</proc/execdomains>"
msgstr "I</proc/execdomains>"

#. type: Plain text
#: man-pages/man5/proc.5:1981
msgid "List of the execution domains (ABI personalities)."
msgstr "Список доменов исполнения (индивидуально для ABI)."

#. type: TP
#: man-pages/man5/proc.5:1981
#, no-wrap
msgid "I</proc/fb>"
msgstr "I</proc/fb>"

#. type: Plain text
#: man-pages/man5/proc.5:1986
msgid ""
"Frame buffer information when B<CONFIG_FB> is defined during kernel "
"compilation."
msgstr "Информация о фрейм-буфере, если ядро собрано с поддержкой B<CONFIG_FB>."

#. type: TP
#: man-pages/man5/proc.5:1986
#, no-wrap
msgid "I</proc/filesystems>"
msgstr "I</proc/filesystems>"

#. type: Plain text
#: man-pages/man5/proc.5:1996
msgid ""
"A text listing of the filesystems which are supported by the kernel, namely "
"filesystems which were compiled into the kernel or whose kernel modules are "
"currently loaded.  (See also B<filesystems>(5).)  If a filesystem is marked "
"with \"nodev\", this means that it does not require a block device to be "
"mounted (e.g., virtual filesystem, network filesystem)."
msgstr "Текстовый список файловых систем, которые поддерживаются ядром, а именно файловые системы, вкомпилированные в ядро или загруженные в данный момент модулями (смотрите также B<filesystems>(5)). Если файловая система помечена как «nodev», то это означает, что для неё не требуется монтировать блочное устройство (например, виртуальная и сетевая файловые системы)."

#. type: Plain text
#: man-pages/man5/proc.5:2003
msgid ""
"Incidentally, this file may be used by B<mount>(8)  when no filesystem is "
"specified and it didn't manage to determine the filesystem type.  Then "
"filesystems contained in this file are tried (excepted those that are marked"
" with \"nodev\")."
msgstr "В частности, этот файл может использоваться программой B<mount>(8) для поиска нужной файловой системы, если она не указана при монтировании и её тип невозможно определить. При этом пробуются все файловые системы из этого файла (за исключением помеченных как «nodev»)."

#. type: TP
#: man-pages/man5/proc.5:2003
#, no-wrap
msgid "I</proc/fs>"
msgstr "I</proc/fs>"

#.  FIXME Much more needs to be said about /proc/fs
#. type: Plain text
#: man-pages/man5/proc.5:2009
msgid ""
"Contains subdirectories that in turn contain files with information about "
"(certain) mounted filesystems."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:2009
#, no-wrap
msgid "I</proc/ide>"
msgstr "I</proc/ide>"

#. type: Plain text
#: man-pages/man5/proc.5:2015
msgid ""
"This directory exists on systems with the IDE bus.  There are directories "
"for each IDE channel and attached device.  Files include:"
msgstr "Данный подкаталог существует в системах с шиной IDE. Для каждого канала IDE и подключенных устройств имеется отдельный каталог. Файлы каталога:"

#. type: Plain text
#: man-pages/man5/proc.5:2028
#, no-wrap
msgid ""
"cache              buffer size in KB\n"
"capacity           number of sectors\n"
"driver             driver version\n"
"geometry           physical and logical geometry\n"
"identify           in hexadecimal\n"
"media              media type\n"
"model              manufacturer's model number\n"
"settings           drive settings\n"
"smart_thresholds   in hexadecimal\n"
"smart_values       in hexadecimal\n"
msgstr "cache              размер буфера в KБ\ncapacity           количество секторов\ndriver             версия драйвера\ngeometry           физическая и логическая геометрия\nidentify           в шестнадцатеричном виде\nmedia              тип носителя\nmodel              номер модели производителя\nsettings           настройки драйвера\nsmart_thresholds   в шестнадцатеричном виде\nsmart_values       в шестнадцатеричном виде\n"

#. type: Plain text
#: man-pages/man5/proc.5:2034
msgid ""
"The B<hdparm>(8)  utility provides access to this information in a friendly "
"format."
msgstr "Утилита B<hdparm>(8) предоставляет доступ к этой информации в дружественном формате."

#. type: TP
#: man-pages/man5/proc.5:2034
#, no-wrap
msgid "I</proc/interrupts>"
msgstr "I</proc/interrupts>"

#. type: Plain text
#: man-pages/man5/proc.5:2044
msgid ""
"This is used to record the number of interrupts per CPU per IO device.  "
"Since Linux 2.6.24, for the i386 and x86_64 architectures, at least, this "
"also includes interrupts internal to the system (that is, not associated "
"with a device as such), such as NMI (nonmaskable interrupt), LOC (local "
"timer interrupt), and for SMP systems, TLB (TLB flush interrupt), RES "
"(rescheduling interrupt), CAL (remote function call interrupt), and possibly"
" others.  Very easy to read formatting, done in ASCII."
msgstr "Используется для записи количества прерываний по каждому процессору и по каждому устройству ввода-вывода. Начиная с Linux 2.6.24 для архитектур i386 и x86_64 (по крайней мере), также включены внутренние прерывания системы (то есть, не связанные с устройством как таковым), такими как NMI (немаскируемые прерывания), LOC (прерывание локального таймера) и для многопроцессорных систем: TLB (прерывание сброса TLB), RES (прерывание перепланирования), CAL (прерывание вызова удалённой функции), и, возможно другие. Очень легко понять, так как записи в ASCII."

#. type: TP
#: man-pages/man5/proc.5:2044
#, no-wrap
msgid "I</proc/iomem>"
msgstr "I</proc/iomem>"

#. type: Plain text
#: man-pages/man5/proc.5:2047
msgid "I/O memory map in Linux 2.4."
msgstr "Карта памяти ввода/вывода в Linux 2.4."

#. type: TP
#: man-pages/man5/proc.5:2047
#, no-wrap
msgid "I</proc/ioports>"
msgstr "I</proc/ioports>"

#. type: Plain text
#: man-pages/man5/proc.5:2051
msgid ""
"This is a list of currently registered Input-Output port regions that are in"
" use."
msgstr "Список зарегистрированных областей портов ввода-вывода, которые используются в данный момент."

#. type: TP
#: man-pages/man5/proc.5:2051
#, no-wrap
msgid "I</proc/kallsyms> (since Linux 2.5.71)"
msgstr "I</proc/kallsyms> (начиная с Linux 2.5.71)"

#. type: Plain text
#: man-pages/man5/proc.5:2059
msgid ""
"This holds the kernel exported symbol definitions used by the B<modules>(X)"
"  tools to dynamically link and bind loadable modules.  In Linux 2.5.47 and "
"earlier, a similar file with slightly different syntax was named I<ksyms>."
msgstr "Содержит определения экспортируемых ядром символов, используемые инструментами B<modules>(X) для динамической компоновки и связывания загружаемых модулей. В Linux 2.5.47 и ранее был подобный файл I<ksyms>, но имел немного другой синтаксис."

#. type: TP
#: man-pages/man5/proc.5:2059
#, no-wrap
msgid "I</proc/kcore>"
msgstr "I</proc/kcore>"

#. type: Plain text
#: man-pages/man5/proc.5:2068
msgid ""
"This file represents the physical memory of the system and is stored in the "
"ELF core file format.  With this pseudo-file, and an unstripped kernel "
"(I</usr/src/linux/vmlinux>)  binary, GDB can be used to examine the current "
"state of any kernel data structures."
msgstr "Этот файл отображает физическую память системы и хранится в формате ELF core. С помощью этого псевдо-файла и ядра, из которого не убраны таблицы символов (I</usr/src/linux/vmlinux>), можно использовать GDB для проверки текущего состояния любых структур данных ядра."

#. type: Plain text
#: man-pages/man5/proc.5:2071
msgid ""
"The total length of the file is the size of physical memory (RAM) plus 4KB."
msgstr "Полная длина этого файла \\(em это размер физической памяти (RAM) плюс 4КБ."

#. type: TP
#: man-pages/man5/proc.5:2071
#, no-wrap
msgid "I</proc/kmsg>"
msgstr "I</proc/kmsg>"

#. type: Plain text
#: man-pages/man5/proc.5:2083
msgid ""
"This file can be used instead of the B<syslog>(2)  system call to read "
"kernel messages.  A process must have superuser privileges to read this "
"file, and only one process should read this file.  This file should not be "
"read if a syslog process is running which uses the B<syslog>(2)  system call"
" facility to log kernel messages."
msgstr "Этот файл может быть использован вместо системного вызова B<syslog>(2) для чтения сообщений ядра. Процесс должен иметь привилегии суперпользователя, чтобы читать этот файл, причём делать это может только один процесс. Данный файл невозможно прочесть, если запущен процесс syslog, который использует системный вызов B<syslog>(2) для протоколирования сообщений ядра."

#. type: Plain text
#: man-pages/man5/proc.5:2087
msgid "Information in this file is retrieved with the B<dmesg>(1)  program."
msgstr "Информация из этого файла извлекается с помощью программы B<dmesg>(1)."

#. type: TP
#: man-pages/man5/proc.5:2087
#, no-wrap
msgid "I</proc/kpagecount> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:2093
msgid ""
"This file contains a 64-bit count of the number of times each physical page "
"frame is mapped, indexed by page frame number (see the discussion of "
"I</proc/[pid]/pagemap>)."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:2099
msgid ""
"The I</proc/kpagecount> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:2099
#, no-wrap
msgid "I</proc/kpageflags> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:2105
msgid ""
"This file contains 64-bit masks corresponding to each physical page frame; "
"it is indexed by page frame number (see the discussion of "
"I</proc/[pid]/pagemap>).  The bits are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:2129
#, no-wrap
msgid ""
"     0 - KPF_LOCKED\n"
"     1 - KPF_ERROR\n"
"     2 - KPF_REFERENCED\n"
"     3 - KPF_UPTODATE\n"
"     4 - KPF_DIRTY\n"
"     5 - KPF_LRU\n"
"     6 - KPF_ACTIVE\n"
"     7 - KPF_SLAB\n"
"     8 - KPF_WRITEBACK\n"
"     9 - KPF_RECLAIM\n"
"    10 - KPF_BUDDY\n"
"    11 - KPF_MMAP           (since Linux 2.6.31)\n"
"    12 - KPF_ANON           (since Linux 2.6.31)\n"
"    13 - KPF_SWAPCACHE      (since Linux 2.6.31)\n"
"    14 - KPF_SWAPBACKED     (since Linux 2.6.31)\n"
"    15 - KPF_COMPOUND_HEAD  (since Linux 2.6.31)\n"
"    16 - KPF_COMPOUND_TAIL  (since Linux 2.6.31)\n"
"    16 - KPF_HUGE           (since Linux 2.6.31)\n"
"    18 - KPF_UNEVICTABLE    (since Linux 2.6.31)\n"
"    19 - KPF_HWPOISON       (since Linux 2.6.31)\n"
"    20 - KPF_NOPAGE         (since Linux 2.6.31)\n"
"    21 - KPF_KSM            (since Linux 2.6.32)\n"
"    22 - KPF_THP            (since Linux 3.4)\n"
msgstr ""

#.  commit ad3bdefe877afb47480418fdb05ecd42842de65e
#.  commit e07a4b9217d1e97d2f3a62b6b070efdc61212110
#. type: Plain text
#: man-pages/man5/proc.5:2142
msgid ""
"For further details on the meanings of these bits, see the kernel source "
"file I<Documentation/vm/pagemap.txt>.  Before kernel 2.6.29, "
"B<KPF_WRITEBACK>, B<KPF_RECLAIM>, B<KPF_BUDDY>, and B<KPF_LOCKED> did not "
"report correctly."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:2148
msgid ""
"The I</proc/kpageflags> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:2148
#, no-wrap
msgid "I</proc/ksyms> (Linux 1.1.23-2.5.47)"
msgstr "I</proc/ksyms> (Linux 1.1.23-2.5.47)"

#. type: Plain text
#: man-pages/man5/proc.5:2152
msgid "See I</proc/kallsyms>."
msgstr "Смотрите I</proc/kallsyms>."

#. type: TP
#: man-pages/man5/proc.5:2152
#, no-wrap
msgid "I</proc/loadavg>"
msgstr "I</proc/loadavg>"

#. type: Plain text
#: man-pages/man5/proc.5:2167
msgid ""
"The first three fields in this file are load average figures giving the "
"number of jobs in the run queue (state R)  or waiting for disk I/O (state D)"
" averaged over 1, 5, and 15 minutes.  They are the same as the load average "
"numbers given by B<uptime>(1)  and other programs.  The fourth field "
"consists of two numbers separated by a slash (/).  The first of these is the"
" number of currently runnable kernel scheduling entities (processes, "
"threads).  The value after the slash is the number of kernel scheduling "
"entities that currently exist on the system.  The fifth field is the PID of "
"the process that was most recently created on the system."
msgstr "Первые три поля в этом файле содержат параметры средней загрузки, которые предоставляют собой количество заданий в очереди выполнения (состояние R) или ожидают дискового ввода-вывода (состояние D) в среднем за 1, 5 и 15 минут. Это то же самое, что и средняя загрузка, которую выдаёт B<uptime>(1) и другие программы. Четвёртое поле состоит из двух чисел, разделённых косой чертой (/). Первое из них показывает количество исполняемых планируемых ядерных элементов в данный момент (процессы, нити). Значение после косой черты показывает количество планируемых ядерных элементов, существующих в системе. В пятом поле содержится PID процесса, который был создан системой последним."

#. type: TP
#: man-pages/man5/proc.5:2167
#, no-wrap
msgid "I</proc/locks>"
msgstr "I</proc/locks>"

#. type: Plain text
#: man-pages/man5/proc.5:2173
msgid ""
"This file shows current file locks (B<flock>(2) and B<fcntl>(2))  and leases"
" (B<fcntl>(2))."
msgstr "Этот файл показывает текущие файловые блокировки (B<flock>(2) и B<fcntl>(2)) параметры (B<fcntl>(2))."

#. type: TP
#: man-pages/man5/proc.5:2173
#, no-wrap
msgid "I</proc/malloc> (only up to and including Linux 2.2)"
msgstr "I</proc/malloc> (только до Linux 2.2 включительно)"

#.  It looks like this only ever did something back in 1.0 days
#. type: Plain text
#: man-pages/man5/proc.5:2179
msgid ""
"This file is present only if B<CONFIG_DEBUG_MALLOC> was defined during "
"compilation."
msgstr "Данный файл существует только, если ядро собрано с поддержкой B<CONFIG_DEBUG_MALLOC>."

#. type: TP
#: man-pages/man5/proc.5:2179
#, no-wrap
msgid "I</proc/meminfo>"
msgstr "I</proc/meminfo>"

#. type: Plain text
#: man-pages/man5/proc.5:2195
msgid ""
"This file reports statistics about memory usage on the system.  It is used "
"by B<free>(1)  to report the amount of free and used memory (both physical "
"and swap)  on the system as well as the shared memory and buffers used by "
"the kernel.  Each line of the file consists of a parameter name, followed by"
" a colon, the value of the parameter, and an option unit of measurement "
"(e.g., \"kB\").  The list below describes the parameter names and the format"
" specifier required to read the field value.  Except as noted below, all of "
"the fields have been present since at least Linux 2.6.0.  Some fields are "
"displayed only if the kernel was configured with various options; those "
"dependencies are noted in the list."
msgstr "Этот файл содержит статистику по использованию памяти системы. Он используется программой B<free>(1) для формирования отчёта о свободной и используемой памяти (как физической, так и подкачки), а также общей памяти и памяти под буферы, которую использует ядро. В каждой строке файла содержится имя параметра, двоеточие, значение параметра и необязательная единица измерения (например, «kB»). В списке далее описываются параметры и определитель формата, требуемый для чтения значения поля. За исключением замечаний, представленных ниже, все показанные поля имеются начиная с Linux 2.6.0. Некоторые поля появляются только, если ядро собрано с определёнными параметрами; это зависимости также показаны в списке."

#. type: TP
#: man-pages/man5/proc.5:2196
#, no-wrap
msgid "I<MemTotal> %lu"
msgstr "I<MemTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2200
msgid ""
"Total usable RAM (i.e., physical RAM minus a few reserved bits and the "
"kernel binary code)."
msgstr "Общее количество используемой RAM (т.е. физической RAM минус несколько зарезервированных бит и исполняемый код ядра)."

#. type: TP
#: man-pages/man5/proc.5:2200
#, no-wrap
msgid "I<MemFree> %lu"
msgstr "I<MemFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2204
msgid "The sum of I<LowFree>+I<HighFree>."
msgstr "Сумма I<LowFree>+I<HighFree>."

#. type: TP
#: man-pages/man5/proc.5:2204
#, no-wrap
msgid "I<Buffers> %lu"
msgstr "I<Buffers> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2208
msgid ""
"Relatively temporary storage for raw disk blocks that shouldn't get "
"tremendously large (20MB or so)."
msgstr "Относительно временное хранилище сырых дисковых блоков, которое не должно быть очень велико (порядка 20МБ)."

#. type: TP
#: man-pages/man5/proc.5:2208
#, no-wrap
msgid "I<Cached> %lu"
msgstr "I<Cached> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2213
msgid ""
"In-memory cache for files read from the disk (the page cache).  Doesn't "
"include I<SwapCached>."
msgstr "Кэш в памяти для прочитанных дисковых файлов (страничный кэш). Не включает I<SwapCached>."

#. type: TP
#: man-pages/man5/proc.5:2213
#, no-wrap
msgid "I<SwapCached> %lu"
msgstr "I<SwapCached> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2221
msgid ""
"Memory that once was swapped out, is swapped back in but still also is in "
"the swap file.  (If memory pressure is high, these pages don't need to be "
"swapped out again because they are already in the swap file.  This saves "
"I/O.)"
msgstr "Память, которая однажды попала в подкачку, выгрузилась обратно в память, но всё равно остаётся в файле подкачки (если нагрузка на память велика, эти страницы не придётся снова выгружать, так как они уже в файле подкачки — предотвращается ввод-вывод)."

#. type: TP
#: man-pages/man5/proc.5:2221
#, no-wrap
msgid "I<Active> %lu"
msgstr "I<Active> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2225
msgid ""
"Memory that has been used more recently and usually not reclaimed unless "
"absolutely necessary."
msgstr "Память, которая часто использовалась и обычно не высвобождается без сильной необходимости."

#. type: TP
#: man-pages/man5/proc.5:2225
#, no-wrap
msgid "I<Inactive> %lu"
msgstr "I<Inactive> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2229
msgid ""
"Memory which has been less recently used.  It is more eligible to be "
"reclaimed for other purposes."
msgstr "Память, которая редко использовалась. Кандидат на высвобождение для других нужд."

#. type: TP
#: man-pages/man5/proc.5:2229
#, no-wrap
msgid "I<Active(anon)> %lu (since Linux 2.6.28)"
msgstr "I<Active(anon)> %lu (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man5/proc.5:2232 man-pages/man5/proc.5:2235
#: man-pages/man5/proc.5:2238 man-pages/man5/proc.5:2241
#: man-pages/man5/proc.5:2308
msgid "[To be documented.]"
msgstr "[Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:2232
#, no-wrap
msgid "I<Inactive(anon)> %lu (since Linux 2.6.28)"
msgstr "I<Inactive(anon)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:2235
#, no-wrap
msgid "I<Active(file)> %lu (since Linux 2.6.28)"
msgstr "I<Active(file)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:2238
#, no-wrap
msgid "I<Inactive(file)> %lu (since Linux 2.6.28)"
msgstr "I<Inactive(file)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:2241
#, no-wrap
msgid "I<Unevictable> %lu (since Linux 2.6.28)"
msgstr "I<Unevictable> %lu (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man5/proc.5:2246 man-pages/man5/proc.5:2251
msgid ""
"(From Linux 2.6.28 to 2.6.30, B<CONFIG_UNEVICTABLE_LRU> was required.)  [To "
"be documented.]"
msgstr "(В Linux с версии 2.6.28 по 2.6.30, требовался параметр B<CONFIG_UNEVICTABLE_LRU>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:2246
#, no-wrap
msgid "I<Mlocked> %lu (since Linux 2.6.28)"
msgstr "I<Mlocked> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:2251
#, no-wrap
msgid "I<HighTotal> %lu"
msgstr "I<HighTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2260
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Total amount "
"of highmem.  Highmem is all memory above ~860MB of physical memory.  Highmem"
" areas are for use by user-space programs, or for the page cache.  The "
"kernel must use tricks to access this memory, making it slower to access "
"than lowmem."
msgstr "(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Общее количество highmem. Highmem — это вся память выше ~860МБ физической памяти. Области highmem используются программами пользовательского пространства или страничным кэшем. Ядро должно применять специальные методы для получения доступа к этой памяти, что делает её более медленной по сравнению с lowmem."

#. type: TP
#: man-pages/man5/proc.5:2260
#, no-wrap
msgid "I<HighFree> %lu"
msgstr "I<HighFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2264
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Amount of free"
" highmem."
msgstr "(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Количество свободной highmem."

#. type: TP
#: man-pages/man5/proc.5:2264
#, no-wrap
msgid "I<LowTotal> %lu"
msgstr "I<LowTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2276
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Total amount "
"of lowmem.  Lowmem is memory which can be used for everything that highmem "
"can be used for, but it is also available for the kernel's use for its own "
"data structures.  Among many other things, it is where everything from "
"I<Slab> is allocated.  Bad things happen when you're out of lowmem."
msgstr "(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Общее количество lowmem. Lowmem — это память, используемая для всего, что и highmem, но также доступна и для структур ядра. Среди прочего, выделяется для I<Slab>. Когда заканчивается lowmem происходят нехорошие вещи."

#. type: TP
#: man-pages/man5/proc.5:2276
#, no-wrap
msgid "I<LowFree> %lu"
msgstr "I<LowFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2280
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Amount of free"
" lowmem."
msgstr "(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Количество свободной lowmem."

#. type: TP
#: man-pages/man5/proc.5:2280
#, no-wrap
msgid "I<MmapCopy> %lu (since Linux 2.6.29)"
msgstr "I<MmapCopy> %lu (начиная с Linux 2.6.29)"

#. type: Plain text
#: man-pages/man5/proc.5:2285
msgid "(B<CONFIG_MMU> is required.)  [To be documented.]"
msgstr "(Требуется параметр B<CONFIG_MMU>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:2285
#, no-wrap
msgid "I<SwapTotal> %lu"
msgstr "I<SwapTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2288
msgid "Total amount of swap space available."
msgstr "Общее количество доступного пространства подкачки."

#. type: TP
#: man-pages/man5/proc.5:2288
#, no-wrap
msgid "I<SwapFree> %lu"
msgstr "I<SwapFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2291
msgid "Amount of swap space that is currently unused."
msgstr "Общее количество неиспользуемого пространства подкачки."

#. type: TP
#: man-pages/man5/proc.5:2291
#, no-wrap
msgid "I<Dirty> %lu"
msgstr "I<Dirty> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2294
msgid "Memory which is waiting to get written back to the disk."
msgstr "Память, которая ждёт записи обратно на диск."

#. type: TP
#: man-pages/man5/proc.5:2294
#, no-wrap
msgid "I<Writeback> %lu"
msgstr "I<Writeback> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2297
msgid "Memory which is actively being written back to the disk."
msgstr "Память, которая переписывается обратно на диск."

#. type: TP
#: man-pages/man5/proc.5:2297
#, no-wrap
msgid "I<AnonPages> %lu (since Linux 2.6.18)"
msgstr "I<AnonPages> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:2300
msgid "Non-file backed pages mapped into user-space page tables."
msgstr "Не файловые фоновые (backed) страницы, отображённые в страничные таблицы пользовательского пространства."

#. type: TP
#: man-pages/man5/proc.5:2300
#, no-wrap
msgid "I<Mapped> %lu"
msgstr "I<Mapped> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2305
msgid ""
"Files which have been mapped into memory (with B<mmap>(2)), such as "
"libraries."
msgstr "Отображённые в память файлы (с помощью B<mmap>(2)), например библиотеки."

#. type: TP
#: man-pages/man5/proc.5:2305
#, no-wrap
msgid "I<Shmem> %lu (since Linux 2.6.32)"
msgstr "I<Shmem> %lu (начиная с Linux 2.6.32)"

#. type: TP
#: man-pages/man5/proc.5:2308
#, no-wrap
msgid "I<Slab> %lu"
msgstr "I<Slab> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2311
msgid "In-kernel data structures cache."
msgstr "Кэш ядерных структур данных."

#. type: TP
#: man-pages/man5/proc.5:2311
#, no-wrap
msgid "I<SReclaimable> %lu (since Linux 2.6.19)"
msgstr "I<SReclaimable> %lu (начиная с Linux 2.6.19)"

#. type: Plain text
#: man-pages/man5/proc.5:2316
msgid "Part of I<Slab>, that might be reclaimed, such as caches."
msgstr "Часть I<Slab>, которая может быть высвобождена, например кэши."

#. type: TP
#: man-pages/man5/proc.5:2316
#, no-wrap
msgid "I<SUnreclaim> %lu (since Linux 2.6.19)"
msgstr "I<SUnreclaim> %lu (начиная с Linux 2.6.19)"

#. type: Plain text
#: man-pages/man5/proc.5:2321
msgid "Part of I<Slab>, that cannot be reclaimed on memory pressure."
msgstr "Часть I<Slab>, которая не может быть высвобождена при нехватке памяти."

#. type: TP
#: man-pages/man5/proc.5:2321
#, no-wrap
msgid "I<KernelStack> %lu (since Linux 2.6.32)"
msgstr "I<KernelStack> %lu (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man5/proc.5:2324
msgid "Amount of memory allocated to kernel stacks."
msgstr "Количество памяти, выделенное под стеки ядра."

#. type: TP
#: man-pages/man5/proc.5:2324
#, no-wrap
msgid "I<PageTables> %lu (since Linux 2.6.18)"
msgstr "I<PageTables> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:2327
msgid "Amount of memory dedicated to the lowest level of page tables."
msgstr "Количество памяти, выделенное под страничные таблицы на самом нижнем уровне."

#. type: TP
#: man-pages/man5/proc.5:2327
#, no-wrap
msgid "I<Quicklists> %lu (since Linux 2.6.27)"
msgstr "I<Quicklists> %lu (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man5/proc.5:2331
msgid "(B<CONFIG_QUICKLIST> is required.)  [To be documented.]"
msgstr "(Требуется параметр B<CONFIG_QUICKLIST>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:2331
#, no-wrap
msgid "I<NFS_Unstable> %lu (since Linux 2.6.18)"
msgstr "I<NFS_Unstable> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:2334
msgid "NFS pages sent to the server, but not yet committed to stable storage."
msgstr "Страницы NFS, полученные сервером, но ещё не записанные в стабильное хранилище."

#. type: TP
#: man-pages/man5/proc.5:2334
#, no-wrap
msgid "I<Bounce> %lu (since Linux 2.6.18)"
msgstr "I<Bounce> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:2337
msgid "Memory used for block device \"bounce buffers\"."
msgstr "Память, используемая для блочного устройства «bounce buffers»."

#. type: TP
#: man-pages/man5/proc.5:2337
#, no-wrap
msgid "I<WritebackTmp> %lu (since Linux 2.6.26)"
msgstr "I<WritebackTmp> %lu (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man5/proc.5:2340
msgid "Memory used by FUSE for temporary writeback buffers."
msgstr "Память, используемая FUSE для временных буферов обратной записи."

#. type: TP
#: man-pages/man5/proc.5:2340
#, no-wrap
msgid "I<CommitLimit> %lu (since Linux 2.6.10)"
msgstr "I<CommitLimit> %lu (начиная с Linux 2.6.10)"

#. type: Plain text
#: man-pages/man5/proc.5:2351
msgid ""
"This is the total amount of memory currently available to be allocated on "
"the system, expressed in kilobytes.  This limit is adhered to only if strict"
" overcommit accounting is enabled (mode 2 in "
"I</proc/sys/vm/overcommit_memory>).  The limit is calculated according to "
"the formula described under I</proc/sys/vm/overcommit_memory>.  For further "
"details, see the kernel source file I<Documentation/vm/overcommit-"
"accounting>."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:2351
#, no-wrap
msgid "I<Committed_AS> %lu"
msgstr "I<Committed_AS> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2362
msgid ""
"The amount of memory presently allocated on the system.  The committed "
"memory is a sum of all of the memory which has been allocated by processes, "
"even if it has not been \"used\" by them as of yet.  A process which "
"allocates 1GB of memory (using B<malloc>(3)  or similar), but touches only "
"300MB of that memory will show up as using only 300MB of memory even if it "
"has the address space allocated for the entire 1GB."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:2372
msgid ""
"This 1GB is memory which has been \"committed\" to by the VM and can be used"
" at any time by the allocating application.  With strict overcommit enabled "
"on the system (mode 2 in IR /proc/sys/vm/overcommit_memory ), allocations "
"which would exceed the I<CommitLimit> will not be permitted.  This is useful"
" if one needs to guarantee that processes will not fail due to lack of "
"memory once that memory has been successfully allocated."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:2372
#, no-wrap
msgid "I<VmallocTotal> %lu"
msgstr "I<VmallocTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2375
msgid "Total size of vmalloc memory area."
msgstr "Общий размер области памяти vmalloc."

#. type: TP
#: man-pages/man5/proc.5:2375
#, no-wrap
msgid "I<VmallocUsed> %lu"
msgstr "I<VmallocUsed> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2378
msgid "Amount of vmalloc area which is used."
msgstr "Размер используемой области vmalloc."

#. type: TP
#: man-pages/man5/proc.5:2378
#, no-wrap
msgid "I<VmallocChunk> %lu"
msgstr "I<VmallocChunk> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2381
msgid "Largest contiguous block of vmalloc area which is free."
msgstr "Наибольший непрерывный свободный блок области vmalloc."

#. type: TP
#: man-pages/man5/proc.5:2381
#, no-wrap
msgid "I<HardwareCorrupted> %lu (since Linux 2.6.32)"
msgstr "I<HardwareCorrupted> %lu (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man5/proc.5:2385
msgid "(B<CONFIG_MEMORY_FAILURE> is required.)  [To be documented.]"
msgstr "(Требуется параметр B<CONFIG_MEMORY_FAILURE>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:2385
#, no-wrap
msgid "I<AnonHugePages> %lu (since Linux 2.6.38)"
msgstr "I<AnonHugePages> %lu (начиная с Linux 2.6.38)"

#. type: Plain text
#: man-pages/man5/proc.5:2389
msgid ""
"(B<CONFIG_TRANSPARENT_HUGEPAGE> is required.)  Non-file backed huge pages "
"mapped into user-space page tables."
msgstr "(Требуется параметр B<CONFIG_TRANSPARENT_HUGEPAGE>.) Не файловые фоновые огромные страницы, отображённые в страничные таблицы пользовательского пространства."

#. type: TP
#: man-pages/man5/proc.5:2389
#, no-wrap
msgid "I<HugePages_Total> %lu"
msgstr "I<HugePages_Total> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2393
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  The size of the pool of huge pages."
msgstr "(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Размер пула огромных страниц."

#. type: TP
#: man-pages/man5/proc.5:2393
#, no-wrap
msgid "I<HugePages_Free> %lu"
msgstr "I<HugePages_Free> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2397
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  The number of huge pages in the pool "
"that are not yet allocated."
msgstr "(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Количество нераспределённых огромных страниц в пуле."

#. type: TP
#: man-pages/man5/proc.5:2397
#, no-wrap
msgid "I<HugePages_Rsvd> %lu (since Linux 2.6.17)"
msgstr "I<HugePages_Rsvd> %lu (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man5/proc.5:2406
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  This is the number of huge pages for "
"which a commitment to allocate from the pool has been made, but no "
"allocation has yet been made.  These reserved huge pages guarantee that an "
"application will be able to allocate a huge page from the pool of huge pages"
" at fault time."
msgstr "(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Количество огромных страниц, для которых есть обязательство по распределению в пуле, но которые ещё не распределены. Эти зарезервированные огромные страницы гарантируют, что приложение сможет получить огромную страницу из пула огромных страниц при нехватке памяти."

#. type: TP
#: man-pages/man5/proc.5:2406
#, no-wrap
msgid "I<HugePages_Surp> %lu (since Linux 2.6.24)"
msgstr "I<HugePages_Surp> %lu (начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:2414
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  This is the number of huge pages in "
"the pool above the value in I</proc/sys/vm/nr_hugepages>.  The maximum "
"number of surplus huge pages is controlled by "
"I</proc/sys/vm/nr_overcommit_hugepages>."
msgstr "(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Количество огромных страниц в пуле выше значения в I</proc/sys/vm/nr_hugepages>. Максимальное число избыточных огромных страниц настраивается в I</proc/sys/vm/nr_overcommit_hugepages>."

#. type: TP
#: man-pages/man5/proc.5:2414
#, no-wrap
msgid "I<Hugepagesize> %lu"
msgstr "I<Hugepagesize> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2418
msgid "(B<CONFIG_HUGETLB_PAGE> is required.)  The size of huge pages."
msgstr "(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Размер огромных страниц."

#. type: TP
#: man-pages/man5/proc.5:2419
#, no-wrap
msgid "I</proc/modules>"
msgstr "I</proc/modules>"

#. type: Plain text
#: man-pages/man5/proc.5:2424
msgid ""
"A text list of the modules that have been loaded by the system.  See also "
"B<lsmod>(8)."
msgstr "Текстовый список модулей, которые были загружены системой. Смотрите также B<lsmod>(8)."

#. type: TP
#: man-pages/man5/proc.5:2424
#, no-wrap
msgid "I</proc/mounts>"
msgstr "I</proc/mounts>"

#. type: Plain text
#: man-pages/man5/proc.5:2434
msgid ""
"Before kernel 2.4.19, this file was a list of all the filesystems currently "
"mounted on the system.  With the introduction of per-process mount "
"namespaces in Linux 2.4.19, this file became a link to I</proc/self/mounts>,"
" which lists the mount points of the process's own mount namespace.  The "
"format of this file is documented in B<fstab>(5)."
msgstr "До ядра версии 2.4.19, в этом файле содержался список всех файловых систем, которые примонтированы в настоящий момент. С введением попроцессных пространств имён монтирования в Linux 2.4.19, этот файл стал указывать на I</proc/self/mounts>, в котором представлен список точек монтирования из пространства монтирования процесса. Формат этого файла описан в B<fstab>(5)."

#. type: TP
#: man-pages/man5/proc.5:2434
#, no-wrap
msgid "I</proc/mtrr>"
msgstr "I</proc/mtrr>"

#. type: Plain text
#: man-pages/man5/proc.5:2440
msgid ""
"Memory Type Range Registers.  See the Linux kernel source file "
"I<Documentation/mtrr.txt> for details."
msgstr "Диапазонные регистры типа памяти. Подробности смотрите в файле дерева исходного кода ядра Linux I<Documentation/mtrr.txt>."

#. type: TP
#: man-pages/man5/proc.5:2440
#, no-wrap
msgid "I</proc/net>"
msgstr "I</proc/net>"

#. type: Plain text
#: man-pages/man5/proc.5:2450
msgid ""
"various net pseudo-files, all of which give the status of some part of the "
"networking layer.  These files contain ASCII structures and are, therefore, "
"readable with B<cat>(1).  However, the standard B<netstat>(8)  suite "
"provides much cleaner access to these files."
msgstr "Разные псевдо-файлы, содержащие информацию по какой-либо части сетевой подсистемы. Они содержат структуры в ASCII и прекрасно читаются утилитой B<cat>(1). Однако, стандартная утилита B<netstat>(8) предоставляет более понятную информацию из этих файлов."

#. type: TP
#: man-pages/man5/proc.5:2450
#, no-wrap
msgid "I</proc/net/arp>"
msgstr "I</proc/net/arp>"

#. type: Plain text
#: man-pages/man5/proc.5:2456
msgid ""
"This holds an ASCII readable dump of the kernel ARP table used for address "
"resolutions.  It will show both dynamically learned and preprogrammed ARP "
"entries.  The format is:"
msgstr "Файл содержит читабельный ASCII-дамп ARP таблицы ядра, которая используется для определения адресов. Она покажет как полученные динамически, так и заданные явно записи ARP. Формат файла:"

#. type: Plain text
#: man-pages/man5/proc.5:2463
#, no-wrap
msgid ""
"CW<IP address     HW type   Flags     HW address          Mask   Device\n"
"192.168.0.50   0x1       0x2       00:50:BF:25:68:F3   *      eth0\n"
"192.168.0.250  0x1       0xc       00:00:00:00:00:00   *      eth0>\n"
msgstr "CW<IP-адрес       Тип обор. Флаги     Аппарат. адрес      Маска  Устройство\n192.168.0.50   0x1       0x2       00:50:BF:25:68:F3   *      eth0\n192.168.0.250  0x1       0xc       00:00:00:00:00:00   *      eth0>\n"

#. type: Plain text
#: man-pages/man5/proc.5:2475
msgid ""
"Here \"IP address\" is the IPv4 address of the machine and the \"HW type\" "
"is the hardware type of the address from RFC\\ 826.  The flags are the "
"internal flags of the ARP structure (as defined in "
"I</usr/include/linux/if_arp.h>)  and the \"HW address\" is the data link "
"layer mapping for that IP address if it is known."
msgstr "Здесь \"IP-адрес\" это адрес машины в нотации IPv4, \"Тип обор.\" это тип аппаратного обеспечения для этого адреса согласно RFC\\ 826. Флаги \\(em это внутренние флаги структуры ARP(определённые в I</usr/include/linux/if_arp.h>), а \"Аппарат. адрес\" \\(em это адрес канального уровня для IP-адреса, если он известен."

#. type: TP
#: man-pages/man5/proc.5:2475
#, no-wrap
msgid "I</proc/net/dev>"
msgstr "I</proc/net/dev>"

#. type: Plain text
#: man-pages/man5/proc.5:2486
msgid ""
"The dev pseudo-file contains network device status information.  This gives "
"the number of received and sent packets, the number of errors and collisions"
" and other basic statistics.  These are used by the B<ifconfig>(8)  program "
"to report device status.  The format is:"
msgstr "Псевдо-файл dev содержит информацию о состоянии сетевых устройств. Она представляет собой количество принятых и отправленных пакетов, количество ошибок и коллизий и другую базовую статистику. Эта информация используется программой B<ifconfig>(8) для вывода отчёта о состоянии устройства. Формат информации:"

#. type: Plain text
#: man-pages/man5/proc.5:2496
#, no-wrap
msgid ""
"CW<Inter-|   Receive                                                |  Transmit\n"
" face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n"
"    lo: 2776770   11307    0    0    0     0          0         0  2776770   11307    0    0    0     0       0          0\n"
"  eth0: 1215645    2751    0    0    0     0          0         0  1782404    4324    0    0    0   427       0          0\n"
"  ppp0: 1622270    5552    1    0    0     0          0         0   354130    5669    0    0    0     0       0          0\n"
"  tap0:    7714      81    0    0    0     0          0         0     7714      81    0    0    0     0       0          0>\n"
msgstr "CW<Inter-|   Receive                                                |  Transmit\n face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n    lo: 2776770   11307    0    0    0     0          0         0  2776770   11307    0    0    0     0       0          0\n  eth0: 1215645    2751    0    0    0     0          0         0  1782404    4324    0    0    0   427       0          0\n  ppp0: 1622270    5552    1    0    0     0          0         0   354130    5669    0    0    0     0       0          0\n  tap0:    7714      81    0    0    0     0          0         0     7714      81    0    0    0     0       0          0>\n"

#. type: TP
#: man-pages/man5/proc.5:2505
#, no-wrap
msgid "I</proc/net/dev_mcast>"
msgstr "I</proc/net/dev_mcast>"

#. type: Plain text
#: man-pages/man5/proc.5:2509
msgid "Defined in I</usr/src/linux/net/core/dev_mcast.c>:"
msgstr "Определено в I</usr/src/linux/net/core/dev_mcast.c>:"

#. type: Plain text
#: man-pages/man5/proc.5:2515
#, no-wrap
msgid ""
"indx interface_name  dmi_u dmi_g dmi_address\n"
"2    eth0            1     0     01005e000001\n"
"3    eth1            1     0     01005e000001\n"
"4    eth2            1     0     01005e000001\n"
msgstr "индекс имя_интерфейса  dmi_u dmi_g адрес_dmi\n2      eth0            1     0     01005e000001\n3      eth1            1     0     01005e000001\n4      eth2            1     0     01005e000001\n"

#. type: TP
#: man-pages/man5/proc.5:2517
#, no-wrap
msgid "I</proc/net/igmp>"
msgstr "I</proc/net/igmp>"

#. type: Plain text
#: man-pages/man5/proc.5:2522
msgid ""
"Internet Group Management Protocol.  Defined in "
"I</usr/src/linux/net/core/igmp.c>."
msgstr "Internet Group Management Protocol (Протокол Управления Интернет-Группами). Определён в I</usr/src/linux/net/core/igmp.c>."

#. type: TP
#: man-pages/man5/proc.5:2522
#, no-wrap
msgid "I</proc/net/rarp>"
msgstr "I</proc/net/rarp>"

#. type: Plain text
#: man-pages/man5/proc.5:2532
msgid ""
"This file uses the same format as the I<arp> file and contains the current "
"reverse mapping database used to provide B<rarp>(8)  reverse address lookup "
"services.  If RARP is not configured into the kernel, this file will not be "
"present."
msgstr "Данный файл использует тот же формат, что и файл I<arp> и содержит текущую обратную базу данных адресов ARP, используемую при работе служб обратного поиска адресов B<rarp>(8). Если поддержки RARP нет в ядре, то этот файл не существует."

#. type: TP
#: man-pages/man5/proc.5:2532
#, no-wrap
msgid "I</proc/net/raw>"
msgstr "I</proc/net/raw>"

#.  .TP
#.  .I /proc/net/route
#.  No information, but looks similar to
#.  .BR route (8).
#. type: Plain text
#: man-pages/man5/proc.5:2552
msgid ""
"Holds a dump of the RAW socket table.  Much of the information is not of use"
" apart from debugging.  The \"sl\" value is the kernel hash slot for the "
"socket, the \"local_address\" is the local address and protocol number pair."
"  \\&\"St\" is the internal status of the socket.  The \"tx_queue\" and "
"\"rx_queue\" are the outgoing and incoming data queue in terms of kernel "
"memory usage.  The \"tr\", \"tm-E<gt>when\", and \"rexmits\" fields are not "
"used by RAW.  The \"uid\" field holds the effective UID of the creator of "
"the socket."
msgstr "Содержит дамп таблицы неструктурированных (RAW) сокетов. Большая часть этой информации не используется ни для чего, кроме отладки. Значение «s»\" \\(em это хешируемый слот ядра для сокета, «local_address» \\(em это пара локальный адрес, номер протокола. \\&«St» \\(em это внутреннее состояние сокета. «tx_queue» и «rx_queue» \\(em это исходящая и входящая очереди данных в том, виде в каком они используются в памяти ядра. Поля «tr», «tm-E<gt>when» и «rexmits» не используются в RAW. Поле «uid» содержит эффективный UID создателя сокета."

#. type: TP
#: man-pages/man5/proc.5:2552
#, no-wrap
msgid "I</proc/net/snmp>"
msgstr "I</proc/net/snmp>"

#. type: Plain text
#: man-pages/man5/proc.5:2557
msgid ""
"This file holds the ASCII data needed for the IP, ICMP, TCP, and UDP "
"management information bases for an SNMP agent."
msgstr "Этот файл содержит ASCII данные, необходимые SNMP-агенту для баз управляющей информации IP, ICMP, TCP и UDP."

#. type: TP
#: man-pages/man5/proc.5:2557
#, no-wrap
msgid "I</proc/net/tcp>"
msgstr "I</proc/net/tcp>"

#. type: Plain text
#: man-pages/man5/proc.5:2573
msgid ""
"Holds a dump of the TCP socket table.  Much of the information is not of use"
" apart from debugging.  The \"sl\" value is the kernel hash slot for the "
"socket, the \"local_address\" is the local address and port number pair.  "
"The \"rem_address\" is the remote address and port number pair (if "
"connected).  \\&\"St\" is the internal status of the socket.  The "
"\"tx_queue\" and \"rx_queue\" are the outgoing and incoming data queue in "
"terms of kernel memory usage.  The \"tr\", \"tm-E<gt>when\", and \"rexmits\""
" fields hold internal information of the kernel socket state and are only "
"useful for debugging.  The \"uid\" field holds the effective UID of the "
"creator of the socket."
msgstr "Содержит дамп таблицы TCP-сокетов. Большая часть этой информации не используется ни для чего, кроме отладки. Значение \"sl\" \\(em это хешируемый слот ядра для сокета, \"local_address\" \\(em это пара локальный адрес и номер порта. \"rem_address\" \\(em это пара удалённого локального адреса и номера порта. \\&\"St\" \\(em это внутреннее состояние сокета. \"tx_queue\" и \"rx_queue\" \\(em это исходящая и входящая очереди данных в том, виде в каком они используются в памяти ядра. Поля \"tr\", \"tm-E<gt>when\" и \"rexmits\" содержат внутреннюю информацию ядра о состоянии сокета и полезны только для отладки. Поле \"uid\" содержит эффективный UID создателя сокета."

#. type: TP
#: man-pages/man5/proc.5:2573
#, no-wrap
msgid "I</proc/net/udp>"
msgstr "I</proc/net/udp>"

#. type: Plain text
#: man-pages/man5/proc.5:2589
msgid ""
"Holds a dump of the UDP socket table.  Much of the information is not of use"
" apart from debugging.  The \"sl\" value is the kernel hash slot for the "
"socket, the \"local_address\" is the local address and port number pair.  "
"The \"rem_address\" is the remote address and port number pair (if "
"connected). \"St\" is the internal status of the socket.  The \"tx_queue\" "
"and \"rx_queue\" are the outgoing and incoming data queue in terms of kernel"
" memory usage.  The \"tr\", \"tm-E<gt>when\", and \"rexmits\" fields are not"
" used by UDP.  The \"uid\" field holds the effective UID of the creator of "
"the socket.  The format is:"
msgstr "Содержит дамп таблицы UDP-сокетов. Большая часть этой информации не используется ни для чего, кроме отладки. Значение \"sl\" \\(em это хешируемый слот ядра для сокета, \"local_address\" \\(em это пара локальный адрес и номер порта. \"rem_address\" \\(em это пара удалённого локального адреса и номера порта. \\&\"St\" \\(em это внутреннее состояние сокета. \"tx_queue\" и \"rx_queue\" \\(em это исходящая и входящая очереди данных в том, виде в каком они используются в памяти ядра. Поля \"tr\", \"tm-E<gt>when\" и \"rexmits\" не используются в UDP. Поле \"uid\" содержит эффективный UID создателя сокета. Формат:"

#. type: Plain text
#: man-pages/man5/proc.5:2597
#, no-wrap
msgid ""
"CW<sl  local_address rem_address   st tx_queue rx_queue tr rexmits  tm-E<gt>when uid\n"
" 1: 01642C89:0201 0C642C89:03FF 01 00000000:00000001 01:000071BA 00000000 0\n"
" 1: 00000000:0801 00000000:0000 0A 00000000:00000000 00:00000000 6F000100 0\n"
" 1: 00000000:0201 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0>\n"
msgstr "CW<sl  local_address rem_address   st tx_queue rx_queue tr rexmits  tm-E<gt>when uid\n 1: 01642C89:0201 0C642C89:03FF 01 00000000:00000001 01:000071BA 00000000 0\n 1: 00000000:0801 00000000:0000 0A 00000000:00000000 00:00000000 6F000100 0\n 1: 00000000:0201 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0>\n"

#. type: TP
#: man-pages/man5/proc.5:2600
#, no-wrap
msgid "I</proc/net/unix>"
msgstr "I</proc/net/unix>"

#. type: Plain text
#: man-pages/man5/proc.5:2605
msgid ""
"Lists the UNIX domain sockets present within the system and their status.  "
"The format is:"
msgstr "Показывает список доменных сокетов UNIX, присутствующих в системе, а также их состояния. Формат:"

#. type: Plain text
#: man-pages/man5/proc.5:2611
#, no-wrap
msgid ""
"CW<Num RefCount Protocol Flags    Type St Path\n"
" 0: 00000002 00000000 00000000 0001 03\n"
" 1: 00000001 00000000 00010000 0001 01 /dev/printer>\n"
msgstr "CW<Номер СчётчикСсылок Протокол Флаги    Тип  Состояние Путь\n 0:   00000002      00000000 00000000 0001 03\n 1:   00000001      00000000 00010000 0001 01        /dev/printer>\n"

#. type: Plain text
#: man-pages/man5/proc.5:2623
msgid ""
"Here \"Num\" is the kernel table slot number, \"RefCount\" is the number of "
"users of the socket, \"Protocol\" is currently always 0, \"Flags\" represent"
" the internal kernel flags holding the status of the socket.  Currently, "
"type is always \"1\" (UNIX domain datagram sockets are not yet supported in "
"the kernel).  \\&\"St\" is the internal state of the socket and Path is the "
"bound path (if any) of the socket."
msgstr "Здесь «Номер» \\(em это номер слота в таблице ядра, «СчётчикСсылок» \\(em количество пользователей данного сокета, «Протокол» \\(em в настоящий момент всегда 0, «Флаги» \\(em представляет внутренние флаги ядра, содержащие состояние сокета. «Тип» в настоящий момент всегда равен \"1\" (дейтаграммы доменных сокетов UNIX ядром пока не поддерживаются).  \\&«Состояние» \\(em это внутреннее состояние сокета, а «Путь» \\(em это путь привязки (если он есть) данного сокета."

#. type: TP
#: man-pages/man5/proc.5:2623
#, no-wrap
msgid "I</proc/partitions>"
msgstr "I</proc/partitions>"

#. type: Plain text
#: man-pages/man5/proc.5:2627
msgid ""
"Contains the major and minor numbers of each partition as well as the number"
" of 1024-byte blocks and the partition name."
msgstr "Содержит старший (major) и младший (minor) номер каждого раздела, а также количество 1024-байтных блоков и имя раздела."

#. type: TP
#: man-pages/man5/proc.5:2627
#, no-wrap
msgid "I</proc/pci>"
msgstr "I</proc/pci>"

#. type: Plain text
#: man-pages/man5/proc.5:2631
msgid ""
"This is a listing of all PCI devices found during kernel initialization and "
"their configuration."
msgstr "Это список всех устройств PCI, найденных во время инициализации ядра, а также их конфигурация."

#.  FIXME /proc/sched_debug
#.  .TP
#.  .IR /proc/sched_debug " (since Linux 2.6.23)"
#.  See also /proc/[pid]/sched
#. type: Plain text
#: man-pages/man5/proc.5:2647
msgid ""
"This file has been deprecated in favor of a new I</proc> interface for PCI "
"(I</proc/bus/pci>).  It became optional in Linux 2.2 (available with "
"B<CONFIG_PCI_OLD_PROC> set at kernel compilation).  It became once more "
"nonoptionally enabled in Linux 2.4.  Next, it was deprecated in Linux 2.6 "
"(still available with B<CONFIG_PCI_LEGACY_PROC> set), and finally removed "
"altogether since Linux 2.6.17."
msgstr "Этот файл устарел и был заменён на новый интерфейс I</proc> для PCI (I</proc/bus/pci>). Он стал необязательным в Linux 2.2 (доступен, если установлен параметр сборки ядра B<CONFIG_PCI_OLD_PROC>). Он стал ещё более необязательным в Linux 2.4. В Linux 2.6 он стал не рекомендуемым (но ещё доступным через параметр B<CONFIG_PCI_LEGACY_PROC>), и, наконец, был полностью удалён в Linux 2.6.17."

#. type: TP
#: man-pages/man5/proc.5:2647
#, no-wrap
msgid "I</proc/profile> (since Linux 2.4)"
msgstr "I</proc/profile> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:2659
msgid ""
"This file is present only if the kernel was booted with the I<profile=1> "
"command-line option.  It exposes kernel profiling information in a binary "
"format for use by B<readprofile>(1).  Writing (e.g., an empty string) to "
"this file resets the profiling counters; on some architectures, writing a "
"binary integer \"profiling multiplier\" of size I<sizeof(int)> sets the "
"profiling interrupt frequency."
msgstr "Данный файл существует только, если ядро загружено с параметром командной строки I<profile=1>. В нём содержится профилирующая информация ядра в двоичном формате, которую использует B<readprofile>(1). Запись (например, пустой строки) в этот файл обнуляет счётчики профилирования; на некоторых архитектурах запись двоичного целого «профилирующего умножителя» размером с I<sizeof(int)> устанавливает частоту профилирующего прерывания."

#. type: TP
#: man-pages/man5/proc.5:2659
#, no-wrap
msgid "I</proc/scsi>"
msgstr "I</proc/scsi>"

#. type: Plain text
#: man-pages/man5/proc.5:2669
msgid ""
"A directory with the I<scsi> mid-level pseudo-file and various SCSI low-"
"level driver directories, which contain a file for each SCSI host in this "
"system, all of which give the status of some part of the SCSI IO subsystem."
"  These files contain ASCII structures and are, therefore, readable with "
"B<cat>(1)."
msgstr "Каталог с псевдо-файлом I<scsi> и различными каталогами низкоуровневых драйверов SCSI, которые содержат по одному файлу на каждый SCSI-узел в системе, и которые представляют некоторую информацию о части подсистемы ввода/вывода SCSI. Данные файлы содержат ASCII структуры и прекрасно читаются утилитой B<cat>(1)."

#. type: Plain text
#: man-pages/man5/proc.5:2672
msgid ""
"You can also write to some of the files to reconfigure the subsystem or "
"switch certain features on or off."
msgstr "Также вы можете писать в некоторые из этих файлов для перенастройки подсистемы или включения/выключения некоторых возможностей."

#. type: TP
#: man-pages/man5/proc.5:2672
#, no-wrap
msgid "I</proc/scsi/scsi>"
msgstr "I</proc/scsi/scsi>"

#. type: Plain text
#: man-pages/man5/proc.5:2678
msgid ""
"This is a listing of all SCSI devices known to the kernel.  The listing is "
"similar to the one seen during bootup.  scsi currently supports only the I"
"<add-single-device> command which allows root to add a hotplugged device to "
"the list of known devices."
msgstr "Это список всех SCSI-устройств, которые известны ядру. Список похож на тот, что выдается при начальной загрузке. scsi в настоящий момент поддерживает только команду I<add-single-device>, которая позволяет суперпользователю добавлять устройства на ходу, без выключения машины."

#. type: Plain text
#: man-pages/man5/proc.5:2680
msgid "The command"
msgstr "Команда"

#. type: Plain text
#: man-pages/man5/proc.5:2684
#, no-wrap
msgid "echo \\(aqscsi add-single-device 1 0 5 0\\(aq E<gt> /proc/scsi/scsi\n"
msgstr "echo \\(aqscsi add-single-device 1 0 5 0\\(aq E<gt> /proc/scsi/scsi\n"

#. type: Plain text
#: man-pages/man5/proc.5:2692
msgid ""
"will cause host scsi1 to scan on SCSI channel 0 for a device on ID 5 LUN 0."
"  If there is already a device known on this address or the address is "
"invalid, an error will be returned."
msgstr "заставит адаптер scsi1 просканировать SCSI канал 0, чтобы найти устройство с ID 5 и LUN 0. Если по этому адресу уже есть известное устройство или если заданный адрес неправилен, то будет возвращена ошибка."

#. type: TP
#: man-pages/man5/proc.5:2692
#, no-wrap
msgid "I</proc/scsi/[drivername]>"
msgstr "I</proc/scsi/[имя_драйвера]>"

#. type: Plain text
#: man-pages/man5/proc.5:2702
msgid ""
"I<[drivername]> can currently be NCR53c7xx, aha152x, aha1542, aha1740, "
"aic7xxx, buslogic, eata_dma, eata_pio, fdomain, in2000, pas16, qlogic, "
"scsi_debug, seagate, t128, u15-24f, ultrastore, or wd7000.  These "
"directories show up for all drivers that registered at least one SCSI HBA.  "
"Every directory contains one file per registered host.  Every host-file is "
"named after the number the host was assigned during initialization."
msgstr "I<[Именем_драйвера]> в настоящий момент могут быть: NCR53c7xx, aha152x, aha1542, aha1740, aic7xxx, buslogic, eata_dma, eata_pio, fdomain, in2000, pas16, qlogic, scsi_debug, seagate, t128, u15-24f, ultrastore или wd7000. Эти каталоги показывают все драйверы, который зарегистрированы хотя бы одним SCSI HBA. Каждый каталог содержит по одному файлу на каждый зарегистрированный узел. Имя каждого узла соответствует номеру, который был получен этим узлом во время инициализации."

#. type: Plain text
#: man-pages/man5/proc.5:2705
msgid ""
"Reading these files will usually show driver and host configuration, "
"statistics, and so on."
msgstr "Чтение данных файлов обычно показывает информацию о конфигурации драйвера и узла, статистику и т. п."

#. type: Plain text
#: man-pages/man5/proc.5:2712
msgid ""
"Writing to these files allows different things on different hosts.  For "
"example, with the I<latency> and I<nolatency> commands, root can switch on "
"and off command latency measurement code in the eata_dma driver.  With the "
"I<lockup> and I<unlock> commands, root can control bus lockups simulated by "
"the scsi_debug driver."
msgstr "Записывая в эти файлы, можно добиться различных результатов от разных узлов. Например, командами I<latency> и I<nolatency> суперпользователь может включить и выключить команду кода вычисления задержки в драйвере eata_dma. Командами I<lockup> и I<unlock> суперпользователь может управлять блокировками шины, которые симулирует драйвер scsi_debug."

#. type: TP
#: man-pages/man5/proc.5:2712
#, no-wrap
msgid "I</proc/self>"
msgstr "I</proc/self>"

#. type: Plain text
#: man-pages/man5/proc.5:2720
msgid ""
"This directory refers to the process accessing the I</proc> filesystem, and "
"is identical to the I</proc> directory named by the process ID of the same "
"process."
msgstr "Этот каталог указывает на процесс, обращающийся к файловой системе I</proc>, и идентичен каталогу I</proc>, соответствующему номеру этого процесса."

#. type: TP
#: man-pages/man5/proc.5:2720
#, no-wrap
msgid "I</proc/slabinfo>"
msgstr "I</proc/slabinfo>"

#. type: Plain text
#: man-pages/man5/proc.5:2729
msgid ""
"Information about kernel caches.  Since Linux 2.6.16 this file is present "
"only if the B<CONFIG_SLAB> kernel configuration option is enabled.  The "
"columns in I</proc/slabinfo> are:"
msgstr "Информация о кэшах ядра. Начиная с Linux 2.6.16 этот файл существует только, если включён параметр сборки ядра B<CONFIG_SLAB>. Список столбцов I</proc/slabinfo>:"

#. type: Plain text
#: man-pages/man5/proc.5:2739
#, no-wrap
msgid ""
"cache-name\n"
"num-active-objs\n"
"total-objs\n"
"object-size\n"
"num-active-slabs\n"
"total-slabs\n"
"num-pages-per-slab\n"
msgstr "cache-name\nnum-active-objs\ntotal-objs\nobject-size\nnum-active-slabs\ntotal-slabs\nnum-pages-per-slab\n"

#. type: Plain text
#: man-pages/man5/proc.5:2745
msgid "See B<slabinfo>(5)  for details."
msgstr "Дополнительную информацию смотрите в B<slabinfo>(5)."

#. type: TP
#: man-pages/man5/proc.5:2745
#, no-wrap
msgid "I</proc/stat>"
msgstr "I</proc/stat>"

#. type: Plain text
#: man-pages/man5/proc.5:2751
msgid ""
"kernel/system statistics.  Varies with architecture.  Common entries "
"include:"
msgstr "Статистика ядра/системы. Различается для разных архитектур. Общие элементы:"

#. type: TP
#: man-pages/man5/proc.5:2752
#, no-wrap
msgid "I<cpu  3357 0 4313 1362393>"
msgstr "I<cpu  3357 0 4313 1362393>"

#.  1024 on Alpha and ia64
#. type: Plain text
#: man-pages/man5/proc.5:2760
msgid ""
"The amount of time, measured in units of USER_HZ (1/100ths of a second on "
"most architectures, use I<sysconf(_SC_CLK_TCK)> to obtain the right value), "
"that the system spent in various states:"
msgstr "Количество времени, измеряемое в единицах USER_HZ (на большинстве архитектур1/100-я секунды; чтобы получить правильное значение используйте I<sysconf(_SC_CLK_TCK)>), которые система находилась в следующих режимах:"

#. type: TP
#: man-pages/man5/proc.5:2761
#, no-wrap
msgid "I<user>"
msgstr "I<пользовательский>"

#. type: Plain text
#: man-pages/man5/proc.5:2764
msgid "(1) Time spent in user mode."
msgstr "(1) Время, проведённое в пользовательском режиме."

#. type: TP
#: man-pages/man5/proc.5:2764
#, no-wrap
msgid "I<nice>"
msgstr "I<nice>"

#. type: Plain text
#: man-pages/man5/proc.5:2767
msgid "(2) Time spent in user mode with low priority (nice)."
msgstr "(2) Время, проведённое в пользовательском режиме с низким приоритетом (nice)."

#. type: TP
#: man-pages/man5/proc.5:2767
#, no-wrap
msgid "I<system>"
msgstr "I<системный>"

#. type: Plain text
#: man-pages/man5/proc.5:2770
msgid "(3) Time spent in system mode."
msgstr "(3) Время, проведённое в системном режиме."

#. type: TP
#: man-pages/man5/proc.5:2770
#, no-wrap
msgid "I<idle>"
msgstr "I<простой>"

#.  FIXME Actually, the following info about the /proc/stat 'cpu' field
#.        does not seem to be quite right (at least in 2.6.12 or 3.6):
#.        the idle time in /proc/uptime does not quite match this value
#. type: Plain text
#: man-pages/man5/proc.5:2780
msgid ""
"(4) Time spent in the idle task.  This value should be USER_HZ times the "
"second entry in the I</proc/uptime> pseudo-file."
msgstr "(4) Время, проведённое в ожидании. Это значение совпадает с значением второго поля в псевдо-файле I</proc/uptime>."

#. type: TP
#: man-pages/man5/proc.5:2780
#, no-wrap
msgid "I<iowait> (since Linux 2.5.41)"
msgstr "I<iowait> (начиная с Linux 2.5.41)"

#. type: Plain text
#: man-pages/man5/proc.5:2783
msgid "(5) Time waiting for I/O to complete."
msgstr "(5) Время ожидания завершения операций ввода-вывода."

#. type: TP
#: man-pages/man5/proc.5:2783
#, no-wrap
msgid "I<irq> (since Linux 2.6.0-test4)"
msgstr "I<irq> (начиная с Linux 2.6.0-test4)"

#. type: Plain text
#: man-pages/man5/proc.5:2786
msgid "(6) Time servicing interrupts."
msgstr "(6) Время обслуживания прерываний."

#. type: TP
#: man-pages/man5/proc.5:2786
#, no-wrap
msgid "I<softirq> (since Linux 2.6.0-test4)"
msgstr "I<softirq> (начиная с Linux 2.6.0-test4)"

#. type: Plain text
#: man-pages/man5/proc.5:2789
msgid "(7) Time servicing softirqs."
msgstr "(7) Время обслуживания softirq."

#. type: TP
#: man-pages/man5/proc.5:2789
#, no-wrap
msgid "I<steal> (since Linux 2.6.11)"
msgstr "I<steal> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man5/proc.5:2793
msgid ""
"(8) Stolen time, which is the time spent in other operating systems when "
"running in a virtualized environment"
msgstr "(8) Упущенное время — время, потраченное в других операционных системах при работе в виртуализованном окружении."

#. type: TP
#: man-pages/man5/proc.5:2793
#, no-wrap
msgid "I<guest> (since Linux 2.6.24)"
msgstr "I<guest> (начиная с Linux 2.6.24)"

#.  See Changelog entry for 5e84cfde51cf303d368fcb48f22059f37b3872de
#. type: Plain text
#: man-pages/man5/proc.5:2798
msgid ""
"(9) Time spent running a virtual CPU for guest operating systems under the "
"control of the Linux kernel."
msgstr "(9) Время, потраченное на работу виртуального процессора для гостевых операционных системах, управляемых ядром Linux."

#. type: TP
#: man-pages/man5/proc.5:2798
#, no-wrap
msgid "I<guest_nice> (since Linux 2.6.33)"
msgstr "I<guest_nice> (начиная с Linux 2.6.33)"

#.  commit ce0e7b28fb75cb003cfc8d0238613aaf1c55e797
#. type: Plain text
#: man-pages/man5/proc.5:2803
msgid ""
"(10) Time spent running a niced guest (virtual CPU for guest operating "
"systems under the control of the Linux kernel)."
msgstr "(10) Время, потраченное на работу гостевого niced (виртуального процессора для гостевых операционных системах, управляемых ядром Linux)."

#. type: TP
#: man-pages/man5/proc.5:2804
#, no-wrap
msgid "I<page 5741 1808>"
msgstr "I<page 5741 1808>"

#. type: Plain text
#: man-pages/man5/proc.5:2808
msgid ""
"The number of pages the system paged in and the number that were paged out "
"(from disk)."
msgstr "Количество страниц, которые система загрузила с диска и выгрузила на диск."

#. type: TP
#: man-pages/man5/proc.5:2808
#, no-wrap
msgid "I<swap 1 0>"
msgstr "I<swap 1 0>"

#. type: Plain text
#: man-pages/man5/proc.5:2811
msgid "The number of swap pages that have been brought in and out."
msgstr "Количество страниц подкачки, которые загружены и выгружены."

#.  FIXME The following is not the full picture for the 'intr' of
#.        /proc/stat on 2.6:
#. type: TP
#: man-pages/man5/proc.5:2811
#, no-wrap
msgid "I<intr 1462898>"
msgstr "I<intr 1462898>"

#. type: Plain text
#: man-pages/man5/proc.5:2821
msgid ""
"This line shows counts of interrupts serviced since boot time, for each of "
"the possible system interrupts.  The first column is the total of all "
"interrupts serviced including unnumbered architecture specific interrupts; "
"each subsequent column is the total for that particular numbered interrupt."
"  Unnumbered interrupts are not shown, only summed into the total."
msgstr "В этой строке содержится счётчик прерываний, обработанных с момента загрузки системы, по каждому возможному системному прерыванию. В первом столбце содержится общее количество всех обработанных прерываний, включая ненумерованные, специфичные для архитектуры; в каждом последующем столбце содержится общееколичество по конкретному прерыванию. Ненумерованные прерывания не показываются, выдаётся только их общее количество."

#. type: TP
#: man-pages/man5/proc.5:2821
#, no-wrap
msgid "I<disk_io: (2,0):(31,30,5764,1,2) (3,0):>..."
msgstr "I<disk_io: (2,0):(31,30,5764,1,2) (3,0):>…"

#. type: Plain text
#: man-pages/man5/proc.5:2824
msgid ""
"(major,disk_idx):(noinfo, read_io_ops, blks_read, write_io_ops, "
"blks_written)"
msgstr "(major,minor):(noinfo, read_io_ops, blks_read, write_io_ops, blks_written)"

#. type: Plain text
#: man-pages/man5/proc.5:2826
msgid "(Linux 2.4 only)"
msgstr "(только в Linux 2.4)"

#. type: TP
#: man-pages/man5/proc.5:2826
#, no-wrap
msgid "I<ctxt 115315>"
msgstr "I<ctxt 115315>"

#. type: Plain text
#: man-pages/man5/proc.5:2829
msgid "The number of context switches that the system underwent."
msgstr "Количество переключений контекста, произошедших в системе."

#. type: TP
#: man-pages/man5/proc.5:2829
#, no-wrap
msgid "I<btime 769041601>"
msgstr "I<btime 769041601>"

#. type: Plain text
#: man-pages/man5/proc.5:2832
msgid ""
"boot time, in seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr "Время начальной загрузки прошедшее с начала эпохи, 1970-01-01 00:00:00 +0000 (UTC), в секундах."

#. type: TP
#: man-pages/man5/proc.5:2832
#, no-wrap
msgid "I<processes 86031>"
msgstr "I<processes 86031>"

#. type: Plain text
#: man-pages/man5/proc.5:2835
msgid "Number of forks since boot."
msgstr "Количество разветвлений (вызовов fork) с момента начальной загрузки."

#. type: TP
#: man-pages/man5/proc.5:2835
#, no-wrap
msgid "I<procs_running 6>"
msgstr "I<procs_running 6>"

#. type: Plain text
#: man-pages/man5/proc.5:2839
msgid "Number of processes in runnable state.  (Linux 2.5.45 onward.)"
msgstr "Количество процессов в состоянии работы (Linux 2.5.45 и новее)."

#. type: TP
#: man-pages/man5/proc.5:2839
#, no-wrap
msgid "I<procs_blocked 2>"
msgstr "I<procs_blocked 2>"

#. type: Plain text
#: man-pages/man5/proc.5:2843
msgid ""
"Number of processes blocked waiting for I/O to complete.  (Linux 2.5.45 "
"onward.)"
msgstr "Количество заблокированных процессов, ожидающих завершения ввода-вывода (Linux 2.5.45 и новее)."

#. type: TP
#: man-pages/man5/proc.5:2844
#, no-wrap
msgid "I</proc/swaps>"
msgstr "I</proc/swaps>"

#. type: Plain text
#: man-pages/man5/proc.5:2849
msgid "Swap areas in use.  See also B<swapon>(8)."
msgstr "Используемое пространство подкачки. См. также B<swapon>(8)."

#. type: TP
#: man-pages/man5/proc.5:2849
#, no-wrap
msgid "I</proc/sys>"
msgstr "I</proc/sys>"

#. type: Plain text
#: man-pages/man5/proc.5:2857
msgid ""
"This directory (present since 1.3.57) contains a number of files and "
"subdirectories corresponding to kernel variables.  These variables can be "
"read and sometimes modified using the I</proc> filesystem, and the "
"(deprecated)  B<sysctl>(2)  system call."
msgstr "Этот каталог (присутствующий, начиная с версии 1.3.57) содержит несколько файлов и подкаталогов, которые соответствуют переменным ядра. Эти переменные могут быть прочитаны и иногда изменены через файловую систему I</proc>, а также с помощью (не рекомендуется) системного вызова B<sysctl>(2)."

#. type: TP
#: man-pages/man5/proc.5:2857
#, no-wrap
msgid "I</proc/sys/abi> (since Linux 2.4.10)"
msgstr "I</proc/sys/abi> (начиная с Linux 2.4.10)"

#.  On some systems, it is not present.
#. type: Plain text
#: man-pages/man5/proc.5:2864
msgid ""
"This directory may contain files with application binary information.  See "
"the Linux kernel source file I<Documentation/sysctl/abi.txt> for more "
"information."
msgstr "Этот каталог может содержать файлы информацию об исполнении приложений (application binary information). Дополнительную информацию смотрите в файле исходного кода ядра Linux I<Documentation/sysctl/abi.txt>."

#. type: TP
#: man-pages/man5/proc.5:2864
#, no-wrap
msgid "I</proc/sys/debug>"
msgstr "I</proc/sys/debug>"

#. type: Plain text
#: man-pages/man5/proc.5:2867 man-pages/man5/proc.5:3701
msgid "This directory may be empty."
msgstr "Данный каталог может быть пуст."

#. type: TP
#: man-pages/man5/proc.5:2867
#, no-wrap
msgid "I</proc/sys/dev>"
msgstr "I</proc/sys/dev>"

#. type: Plain text
#: man-pages/man5/proc.5:2873
msgid ""
"This directory contains device-specific information (e.g., "
"I<dev/cdrom/info>).  On some systems, it may be empty."
msgstr "Данный каталог содержит информацию, специфичную для устройств (например, I<dev/cdrom/info>). В некоторых системах он может быть пуст."

#. type: TP
#: man-pages/man5/proc.5:2873
#, no-wrap
msgid "I</proc/sys/fs>"
msgstr "I</proc/sys/fs>"

#. type: Plain text
#: man-pages/man5/proc.5:2877
msgid ""
"This directory contains the files and subdirectories for kernel variables "
"related to filesystems."
msgstr "Подкаталог, содержащий файлы и подкаталоги с переменными ядра, касающиеся файловых систем."

#. type: TP
#: man-pages/man5/proc.5:2877
#, no-wrap
msgid "I</proc/sys/fs/binfmt_misc>"
msgstr "I</proc/sys/fs/binfmt_misc>"

#. type: Plain text
#: man-pages/man5/proc.5:2882
msgid ""
"Documentation for files in this directory can be found in the Linux kernel "
"sources in I<Documentation/binfmt_misc.txt>."
msgstr "Документацию по файлам в этом каталоге можно найти в исходном коде ядра Linux в I<Documentation/binfmt_misc.txt>."

#. type: TP
#: man-pages/man5/proc.5:2882
#, no-wrap
msgid "I</proc/sys/fs/dentry-state> (since Linux 2.2)"
msgstr "I</proc/sys/fs/dentry-state> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:2890
msgid ""
"This file contains information about the status of the directory cache "
"(dcache).  The file contains six numbers, I<nr_dentry>, I<nr_unused>, "
"I<age_limit> (age in seconds), I<want_pages> (pages requested by system) and"
" two dummy values."
msgstr "Файл содержит информацию о состоянии кэша каталогов (dcache). В нём есть шесть чисел, I<nr_dentry>, I<nr_unused>, I<age_limit> (возраст в секундах), I<want_pages> (страниц, запрошенных системой) и два пустых значения."

#. type: Plain text
#: man-pages/man5/proc.5:2895
msgid ""
"I<nr_dentry> is the number of allocated dentries (dcache entries).  This "
"field is unused in Linux 2.2."
msgstr "I<nr_dentry> содержит количество отведённых dentries (элементов dcache). Это поле не используется в Linux 2.2."

#. type: Plain text
#: man-pages/man5/proc.5:2898
msgid "I<nr_unused> is the number of unused dentries."
msgstr "I<nr_unused> содержит количество неиспользуемых dentries."

#.  looks like this is unused in kernels 2.2 to 2.6
#. type: Plain text
#: man-pages/man5/proc.5:2903
msgid ""
"I<age_limit> is the age in seconds after which dcache entries can be "
"reclaimed when memory is short."
msgstr "I<age_limit> \\(em  это возраст в секундах по истечении которого элементы dcache могут быть отозваны, когда памяти становится мало."

#.  looks like this is unused in kernels 2.2 to 2.6
#. type: Plain text
#: man-pages/man5/proc.5:2908
msgid ""
"I<want_pages> is nonzero when the kernel has called shrink_dcache_pages() "
"and the dcache isn't pruned yet."
msgstr "I<want_pages> не равно нулю, если ядро вызвало shrink_dcache_pages(), а dcache ещё не сокращён (pruned)."

#. type: TP
#: man-pages/man5/proc.5:2909
#, no-wrap
msgid "I</proc/sys/fs/dir-notify-enable>"
msgstr "I</proc/sys/fs/dir-notify-enable>"

#. type: Plain text
#: man-pages/man5/proc.5:2918
msgid ""
"This file can be used to disable or enable the I<dnotify> interface "
"described in B<fcntl>(2)  on a system-wide basis.  A value of 0 in this file"
" disables the interface, and a value of 1 enables it."
msgstr "Этот файл может быть использован для включения и выключения интерфейса I<dnotify>, описанного в B<fcntl>(2), во всей системе. Значение 0 в этом файле отключает интерфейс, а значение 1 включает его."

#. type: TP
#: man-pages/man5/proc.5:2918
#, no-wrap
msgid "I</proc/sys/fs/dquot-max>"
msgstr "I</proc/sys/fs/dquot-max>"

#. type: Plain text
#: man-pages/man5/proc.5:2925
msgid ""
"This file shows the maximum number of cached disk quota entries.  On some "
"(2.4) systems, it is not present.  If the number of free cached disk quota "
"entries is very low and you have some awesome number of simultaneous system "
"users, you might want to raise the limit."
msgstr "Этот файл показывает максимальное количество кэшируемых элементов дисковых квот. В некоторых (2.4) системах его нет. Если число свободных кэшируемых дисковых квот является очень маленьким, а у вас в системе одновременно работает большое количество пользователей, то вам, возможно, захочется увеличить этот лимит."

#. type: TP
#: man-pages/man5/proc.5:2925
#, no-wrap
msgid "I</proc/sys/fs/dquot-nr>"
msgstr "I</proc/sys/fs/dquot-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:2929
msgid ""
"This file shows the number of allocated disk quota entries and the number of"
" free disk quota entries."
msgstr "Этот файл показывает количество выделенных в использование элементов дисковых квот и количество свободных элементов дисковых квот."

#. type: TP
#: man-pages/man5/proc.5:2929
#, no-wrap
msgid "I</proc/sys/fs/epoll> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll> (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man5/proc.5:2938
msgid ""
"This directory contains the file I<max_user_watches>, which can be used to "
"limit the amount of kernel memory consumed by the I<epoll> interface.  For "
"further details, see B<epoll>(7)."
msgstr "В этом каталоге содержится файл I<max_user_watches>, который можно использовать для ограничения количества памяти ядра, потребляемой интерфейсом I<epoll>. Подробности смотрите в B<epoll>(7)."

#. type: TP
#: man-pages/man5/proc.5:2938
#, no-wrap
msgid "I</proc/sys/fs/file-max>"
msgstr "I</proc/sys/fs/file-max>"

#. type: Plain text
#: man-pages/man5/proc.5:2951
msgid ""
"This file defines a system-wide limit on the number of open files for all "
"processes.  (See also B<setrlimit>(2), which can be used by a process to set"
" the per-process limit, B<RLIMIT_NOFILE>, on the number of files it may "
"open.)  If you get lots of error messages in the kernel log about running "
"out of file handles (look for \"VFS: file-max limit E<lt>numberE<gt> "
"reached\"), try increasing this value:"
msgstr "Этот файл показывает системный лимит на количество открытых файлов для всех процессов. (См. также B<setrlimit>(2), который можно использовать, чтобы установить ограничение B<RLIMIT_NOFILE> на количество открытых файлов файлов на процесс). Если вы получаете большое количество сообщений в журнале ядра об ошибках о невозможности открыть файловые дескрипторы (такие как «VFS: file-max limit E<lt>numberE<gt> reached»), попытайтесь увеличить это значение:"

#. type: Plain text
#: man-pages/man5/proc.5:2957
#, no-wrap
msgid "CW<    echo 100000 E<gt> /proc/sys/fs/file-max>\n"
msgstr "CW<    echo 100000 E<gt> /proc/sys/fs/file-max>\n"

#. type: Plain text
#: man-pages/man5/proc.5:2964
msgid ""
"The kernel constant B<NR_OPEN> imposes an upper limit on the value that may "
"be placed in I<file-max>."
msgstr "Константа ядра B<NR_OPEN> устанавливает верхний лимит значения, которое может быть установлено в I<file-max>."

#. type: Plain text
#: man-pages/man5/proc.5:2970
msgid ""
"Privileged processes (B<CAP_SYS_ADMIN>)  can override the I<file-max> limit."
msgstr "Привилегированный процесс (с B<CAP_SYS_ADMIN>) может изменять ограничение I<file-max>."

#. type: TP
#: man-pages/man5/proc.5:2970
#, no-wrap
msgid "I</proc/sys/fs/file-nr>"
msgstr "I</proc/sys/fs/file-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:2989
msgid ""
"This (read-only) file contains three numbers: the number of allocated file "
"handles (i.e., the number of files presently opened); the number of free "
"file handles; and the maximum number of file handles (i.e., the same value "
"as I</proc/sys/fs/file-max>).  If the number of allocated file handles is "
"close to the maximum, you should consider increasing the maximum.  Before "
"Linux 2.6, the kernel allocated file handles dynamically, but it didn't free"
" them again.  Instead the free file handles were kept in a list for "
"reallocation; the \"free file handles\" value indicates the size of that "
"list.  A large number of free file handles indicates that there was a past "
"peak in the usage of open file handles.  Since Linux 2.6, the kernel does "
"deallocate freed file handles, and the \"free file handles\" value is always"
" zero."
msgstr "Этот файл (доступный только для чтения) содержит три числа: количество выделенных файловых дескрипторов (handles), количество свободных файловых дескрипторов (handles) и максимальное количество файловых дескрипторов (handles). Ядро выделяет файловые дескрипторы динамически, но оно не освобождает их сразу же. Если количество выделенных файловых дескрипторов приближается к максимальному, то вам необходимо увеличить максимальное значение. До Linux 2.6 ядро выделяло файловые дескрипторы динамически, но не освобождало их. Вместо этого свободные файловые дескрипторы оставались в списке для повторного выделения; значение «количество свободных файловых дескрипторов» показывает размер этого списка. Большое когда количество свободных файловых дескрипторов указывает на то, что ранее был пик использования свободных файловых дескрипторов. Начиная с Linux 2.6 ядро освобождает свободные файловые дескрипторы и «количество свободных файловых дескрипторов» всегда равно 0."

#. type: TP
#: man-pages/man5/proc.5:2989
#, no-wrap
msgid "I</proc/sys/fs/inode-max> (only present until Linux 2.2)"
msgstr "I</proc/sys/fs/inode-max> (только до Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:2998
msgid ""
"This file contains the maximum number of in-memory inodes.  This value "
"should be 3-4 times larger than the value in I<file-max>, since I<stdin>, "
"I<stdout> and network sockets also need an inode to handle them.  When you "
"regularly run out of inodes, you need to increase this value."
msgstr "Этот файл содержит максимальное количество индексных дескрипторов, находящихся в памяти. Это значение должно быть в 3-4 раза больше, чем максимальное значение в I<file-max>, так как I<stdin>, I<stdout> и сетевым сокетам также необходимы индексные дескрипторы. Если вам регулярно не хватает индексных дескрипторов, то вам необходимо увеличить это значение."

#. type: Plain text
#: man-pages/man5/proc.5:3002
msgid ""
"Starting with Linux 2.4, there is no longer a static limit on the number of "
"inodes, and this file is removed."
msgstr "Начиная с Linux 2.4, больше не существует статического ограничения на количество индексных дескрипторов и этот файл удалён."

#. type: TP
#: man-pages/man5/proc.5:3002
#, no-wrap
msgid "I</proc/sys/fs/inode-nr>"
msgstr "I</proc/sys/fs/inode-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:3006
msgid "This file contains the first two values from I<inode-state>."
msgstr "Этот файл содержит первые два значения из I<inode-state>."

#. type: TP
#: man-pages/man5/proc.5:3006
#, no-wrap
msgid "I</proc/sys/fs/inode-state>"
msgstr "I</proc/sys/fs/inode-state>"

#. type: Plain text
#: man-pages/man5/proc.5:3014
msgid ""
"This file contains seven numbers: I<nr_inodes>, I<nr_free_inodes>, "
"I<preshrink>, and four dummy values (always zero)."
msgstr "Этот файл содержит сем чисел: I<nr_inodes>, I<nr_free_inodes>, I<preshrink> и четыре заглушки (всегда равные нулю)."

#.  This can be slightly more than
#.  .I inode-max
#.  because Linux allocates them one page full at a time.
#. type: Plain text
#: man-pages/man5/proc.5:3022
msgid ""
"I<nr_inodes> is the number of inodes the system has allocated.  "
"I<nr_free_inodes> represents the number of free inodes."
msgstr "В I<nr_inodes> содержится количество выделенных системой индексных дескрипторов. В I<nr_free_inodes> содержится количество свободных индексных дескрипторов."

#. type: Plain text
#: man-pages/man5/proc.5:3030
msgid ""
"I<preshrink> is nonzero when the I<nr_inodes> E<gt> I<inode-max> and the "
"system needs to prune the inode list instead of allocating more; since Linux"
" 2.4, this field is a dummy value (always zero)."
msgstr "Значение I<preshrink> не равно нулю, если I<nr_inodes> E<gt> I<inode-max> и системе нужно сократить список индексных дескрипторов, а не выделять новые; начиная с Linux 2.4 это значение не используется (всегда равно нулю)."

#. type: TP
#: man-pages/man5/proc.5:3030
#, no-wrap
msgid "I</proc/sys/fs/inotify> (since Linux 2.6.13)"
msgstr "I</proc/sys/fs/inotify> (начиная с Linux 2.6.13)"

#. type: Plain text
#: man-pages/man5/proc.5:3039
msgid ""
"This directory contains files I<max_queued_events>, I<max_user_instances>, "
"and I<max_user_watches>, that can be used to limit the amount of kernel "
"memory consumed by the I<inotify> interface.  For further details, see "
"B<inotify>(7)."
msgstr "Этот каталог содержит файлы I<max_queued_events>, I<max_user_instances>, и I<max_user_watches>, которые можно использовать для ограничения количества памяти ядра, потребляемом интерфейсом I<inotify>. Подробней смотрите в B<inotify>(7)."

#. type: TP
#: man-pages/man5/proc.5:3039
#, no-wrap
msgid "I</proc/sys/fs/lease-break-time>"
msgstr "I</proc/sys/fs/lease-break-time>"

#. type: Plain text
#: man-pages/man5/proc.5:3048
msgid ""
"This file specifies the grace period that the kernel grants to a process "
"holding a file lease (B<fcntl>(2))  after it has sent a signal to that "
"process notifying it that another process is waiting to open the file.  If "
"the lease holder does not remove or downgrade the lease within this grace "
"period, the kernel forcibly breaks the lease."
msgstr "В этом файле задаётся период, в течении которого, ядро предоставляет процессу возможность удерживать файл (B<fcntl>(2)), по окончании которого оно посылает сигнал процессу, извещая его о том, что другой процесс ожидает открытия этого файла. Если удерживающий файл процесс не удалит или не отменит удержание файла в течении указанного периода, то ядро принудительно снимет удержание."

#. type: TP
#: man-pages/man5/proc.5:3048
#, no-wrap
msgid "I</proc/sys/fs/leases-enable>"
msgstr "I</proc/sys/fs/leases-enable>"

#. type: Plain text
#: man-pages/man5/proc.5:3055
msgid ""
"This file can be used to enable or disable file leases (B<fcntl>(2))  on a "
"system-wide basis.  If this file contains the value 0, leases are disabled."
"  A nonzero value enables leases."
msgstr "Этот файл можно использовать, чтобы разрешить или запретить в системе возможность удержания файла (B<fcntl>(2)). Если файл содержит 0, удержание запрещено. Если не ноль \\(em разрешено."

#. type: TP
#: man-pages/man5/proc.5:3055
#, no-wrap
msgid "I</proc/sys/fs/mqueue> (since Linux 2.6.6)"
msgstr "I</proc/sys/fs/mqueue> (начиная с Linux 2.6.6)"

#. type: Plain text
#: man-pages/man5/proc.5:3063
msgid ""
"This directory contains files I<msg_max>, I<msgsize_max>, and I<queues_max>,"
" controlling the resources used by POSIX message queues.  See "
"B<mq_overview>(7)  for details."
msgstr "В этом каталоге содержатся файлы I<msg_max>, I<msgsize_max> и I<queues_max>, которые контролируют ресурсы, используемые очередями сообщений POSIX. Подробней смотрите в B<mq_overview>(7)."

#. type: TP
#: man-pages/man5/proc.5:3063
#, no-wrap
msgid "I</proc/sys/fs/overflowgid> and I</proc/sys/fs/overflowuid>"
msgstr "I</proc/sys/fs/overflowgid> и I</proc/sys/fs/overflowuid>"

#. type: Plain text
#: man-pages/man5/proc.5:3073
msgid ""
"These files allow you to change the value of the fixed UID and GID.  The "
"default is 65534.  Some filesystems support only 16-bit UIDs and GIDs, "
"although in Linux UIDs and GIDs are 32 bits.  When one of these filesystems "
"is mounted with writes enabled, any UID or GID that would exceed 65535 is "
"translated to the overflow value before being written to disk."
msgstr "Эти файлы позволяют вам изменить значение фиксированных UID и GID. По умолчанию оно равно 65534. Некоторые файловые системы поддерживают только 16-битные UID и GID, в то время как в Linux UID и GID являются 32-битными. Когда монтируется одна из таких файловых систем с правами, позволяющими запись, все UID или GID, которые превышают 65535, транслируются перед записью на диск в значения переполнения."

#. type: TP
#: man-pages/man5/proc.5:3073
#, no-wrap
msgid "I</proc/sys/fs/pipe-max-size> (since Linux 2.6.35)"
msgstr "I</proc/sys/fs/pipe-max-size> (начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man5/proc.5:3087
msgid ""
"The value in this file defines an upper limit for raising the capacity of a "
"pipe using the B<fcntl>(2)  B<F_SETPIPE_SZ> operation.  This limit applies "
"only to unprivileged processes.  The default value for this file is "
"1,048,576.  The value assigned to this file may be rounded upward, to "
"reflect the value actually employed for a convenient implementation.  To "
"determine the rounded-up value, display the contents of this file after "
"assigning a value to it.  The minimum value that can be assigned to this "
"file is the system page size."
msgstr "Значение в этом файле определяет максимальное ограничение увеличения ёмкости канала с помощью операции B<F_SETPIPE_SZ> вызова B<fcntl>(2). Это ограничение накладывается только на непривилегированные процессы. Значение по умолчанию в файле равно 1,048,576. Значение в этом файле может округляться в большую сторону, отражая фактически используемое значение для удобства реализации. Для определения округлённого значение, посмотрите содержимое этого файла после записи в него значения. Минимальное значение, которое можно присвоить, равно значению страницы в системе."

#. type: TP
#: man-pages/man5/proc.5:3087
#, no-wrap
msgid "I</proc/sys/fs/protected_hardlinks> (since Linux 3.6)"
msgstr "I</proc/sys/fs/protected_hardlinks> (начиная с Linux 3.6)"

#.  commit 800179c9b8a1e796e441674776d11cd4c05d61d7
#. type: Plain text
#: man-pages/man5/proc.5:3096
msgid ""
"When the value in this file is 0, no restrictions are placed on the creation"
" of hard links (i.e., this is the historical behavior before Linux 3.6).  "
"When the value in this file is 1, a hard link can be created to a target "
"file only if one of the following conditions is true:"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3101
msgid "The caller has the B<CAP_FOWNER> capability."
msgstr "Вызывающий имеет мандат B<CAP_FOWNER>."

#. type: Plain text
#: man-pages/man5/proc.5:3107
msgid ""
"The filesystem UID of the process creating the link matches the owner (UID) "
"of the target file (as described in B<credentials>(7), a process's "
"filesystem UID is normally the same as its effective UID)."
msgstr "UID файловой системы процесса, создающего ссылку, совпадает с владельцем (UID) файла, на который создаётся ссылка (как описано в B<credentials>(7), UID файловой системы процесса обычно совпадает с эффективным UID)."

#. type: Plain text
#: man-pages/man5/proc.5:3109
msgid "All of the following conditions are true:"
msgstr "Все следующие условия выполняются:"

#. type: IP
#: man-pages/man5/proc.5:3110 man-pages/man5/proc.5:3112
#: man-pages/man5/proc.5:3114 man-pages/man5/proc.5:3117
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man5/proc.5:3112
msgid "the target is a regular file;"
msgstr "целевой файл является обычным;"

#. type: Plain text
#: man-pages/man5/proc.5:3114
msgid "the target file does not have its set-user-ID permission bit enabled;"
msgstr "на целевом файле не установлен бит прав set-user-ID;"

#. type: Plain text
#: man-pages/man5/proc.5:3117
msgid ""
"the target file does not have both its set-group-ID and group-executable "
"permission bits enabled; and"
msgstr "на целевом файле не установлены биты прав set-group-ID и group-executable; и"

#. type: Plain text
#: man-pages/man5/proc.5:3121
msgid ""
"the caller has permission to read and write the target file (either via the "
"file's permissions mask or because it has suitable capabilities)."
msgstr "вызывающий имеет право на чтение и запись целевого файла (согласно маске прав на файл или из-за имеющихся мандатов)."

#. type: Plain text
#: man-pages/man5/proc.5:3137
msgid ""
"The default value in this file is 0.  Setting the value to 1 prevents a "
"longstanding class of security issues caused by hard-link-based time-of-"
"check, time-of-use races, most commonly seen in world-writable directories "
"such as I</tmp>.  The common method of exploiting this flaw is to cross "
"privilege boundaries when following a given hard link (i.e., a root process "
"follows a hard link created by another user).  Additionally, on systems "
"without separated partitions, this stops unauthorized users from \"pinning\""
" vulnerable set-user-ID and set-group-ID files against being upgraded by the"
" administrator, or linking to special files."
msgstr "Значение по умолчанию в файле равно 0. Установка значения в 1 закрывает долголетний класс проблем с безопасностью, вызванных проверкой времени на основе жёсткой ссылки, состязательностью при использовании времени, наиболее часто встречающейся в каталогах доступным на запись всем, таким как I</tmp>. Распространённый метод использования этой уязвимости — присвоение прав при переходе по жёсткой ссылке (т.е., процесс суперпользователя переходит по жёсткой ссылке, созданной другим пользователем). Также, в системах без выделенных разделов это останавливает неправомочных пользователей от «закрепления» уязвимых файлов с битами set-user-ID и set-group-ID при выполнении администратором обновления, или компоновки со специальными файлами."

#. type: TP
#: man-pages/man5/proc.5:3137
#, no-wrap
msgid "I</proc/sys/fs/protected_symlinks> (since Linux 3.6)"
msgstr "I</proc/sys/fs/protected_symlinks> (начиная с Linux 3.6)"

#.  commit 800179c9b8a1e796e441674776d11cd4c05d61d7
#. type: Plain text
#: man-pages/man5/proc.5:3145
msgid ""
"When the value in this file is 0, no restrictions are placed on following "
"symbolic links (i.e., this is the historical behavior before Linux 3.6).  "
"When the value in this file is 1, symbolic links are followed only in the "
"following circumstances:"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3152
msgid ""
"the filesystem UID of the process following the link matches the owner (UID)"
" of the symbolic link (as described in B<credentials>(7), a process's "
"filesystem UID is normally the same as its effective UID);"
msgstr "UID файловой системы процесса, переходящего по ссылке, совпадает с владельцем (UID) символьной ссылки (как описано в B<credentials>(7), UID файловой системы процесса обычно совпадает с эффективным UID);"

#. type: Plain text
#: man-pages/man5/proc.5:3154
msgid "the link is not in a sticky world-writable directory; or"
msgstr "ссылка не является «прилипшим» (sticky) каталогом, доступным на запись всем; или"

#. type: Plain text
#: man-pages/man5/proc.5:3156
msgid "the symbolic link and its parent directory have the same owner (UID)"
msgstr "символьная ссылка и её родительский каталог имеют одного владельца (UID)"

#. type: Plain text
#: man-pages/man5/proc.5:3163
msgid ""
"A system call that fails to follow a symbolic link because of the above "
"restrictions returns the error B<EACCES> in I<errno>."
msgstr "Системный вызов, который не может перейти по символьной ссылке из-за перечисленных выше ограничений, возвращает ошибку B<EACCES> в I<errno>."

#. type: Plain text
#: man-pages/man5/proc.5:3167
msgid ""
"The default value in this file is 0.  Setting the value to 1 avoids a "
"longstanding class of security issues based on time-of-check, time-of-use "
"races when accessing symbolic links."
msgstr "Значение по умолчанию в файле равно 0. Установка значения в 1 закрывает долголетний класс проблем с безопасностью, вызванных проверкой времени, состязательностью при использовании времени при доступе к символьным ссылкам."

#. type: TP
#: man-pages/man5/proc.5:3167
#, no-wrap
msgid "I</proc/sys/fs/suid_dumpable> (since Linux 2.6.13)"
msgstr "I</proc/sys/fs/suid_dumpable> (начиная с Linux 2.6.13)"

#.  The following is based on text from Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:3173
msgid ""
"The value in this file determines whether core dump files are produced for "
"set-user-ID or otherwise protected/tainted binaries.  Three different "
"integer values can be specified:"
msgstr "Значение в этом файле определяет будут ли создаваться файлы дампа памяти для файлов с установленным битом set-user-ID или других защищённых/с добавкой (tainted) исполняемых файлов. Можно указать три целых значения:"

#. type: TP
#: man-pages/man5/proc.5:3174
#, no-wrap
msgid "I<0\\ (default)>"
msgstr "I<0\\ (default)>"

#. type: Plain text
#: man-pages/man5/proc.5:3183
msgid ""
"This provides the traditional (pre-Linux 2.6.13) behavior.  A core dump will"
" not be produced for a process which has changed credentials (by calling "
"B<seteuid>(2), B<setgid>(2), or similar, or by executing a set-user-ID or "
"set-group-ID program)  or whose binary does not have read permission "
"enabled."
msgstr "Традиционное поведение ( до Linux 2.6.13). Дамп памяти не создаётся для процесса, у которого изменены учётные данные (вызовом B<seteuid>(2), B<setgid>(2) и подобным или при исполнении программы с установленными битами set-user-ID или set-group-ID) или если для исполняемого файла нет права на чтение."

#. type: TP
#: man-pages/man5/proc.5:3183
#, no-wrap
msgid "I<1\\ (\"debug\")>"
msgstr "I<1\\ (\"debug\")>"

#. type: Plain text
#: man-pages/man5/proc.5:3190
msgid ""
"All processes dump core when possible.  The core dump is owned by the "
"filesystem user ID of the dumping process and no security is applied.  This "
"is intended for system debugging situations only.  Ptrace is unchecked."
msgstr "Если возможно, создавать дамп памяти для любого процесса. Дамп памяти будет принадлежать пользователю файловой системы с ID владельца выполнявшегося процесса, и никаких мер безопасности предпринято не будет. Предназначено только для системной отладки. Ptrace не проверяется."

#. type: TP
#: man-pages/man5/proc.5:3190
#, no-wrap
msgid "I<2\\ (\"suidsafe\")>"
msgstr "I<2\\ (\"suidsafe\")>"

#. type: Plain text
#: man-pages/man5/proc.5:3199
msgid ""
"Any binary which normally would not be dumped (see \"0\" above)  is dumped "
"readable by root only.  This allows the user to remove the core dump file "
"but not to read it.  For security reasons core dumps in this mode will not "
"overwrite one another or other files.  This mode is appropriate when "
"administrators are attempting to debug problems in a normal environment."
msgstr "Дамп памяти будет выполняться для любого исполняемого файла, для которого обычно это не происходит (см. «0» ранее) и будет доступен на чтение только суперпользователю. Файл с дампом памяти обычный пользователь может удалять, но не читать. По соображениям безопасности дампы памяти в этом режиме не будут перезаписываться новыми или другими файлами. Этот режим подходит для администраторов, когда администраторы пытаются разобраться с проблемами в обычном окружении."

#.  9520628e8ceb69fa9a4aee6b57f22675d9e1b709
#.  54b501992dd2a839e94e76aa392c392b55080ce8
#. type: Plain text
#: man-pages/man5/proc.5:3210
msgid ""
"Additionally, since Linux 3.6, I</proc/sys/kernel/core_pattern> must either "
"be an absolute pathname or a pipe command, as detailed in B<core>(5).  "
"Warnings will be written to the kernel log if I<core_pattern> does not "
"follow these rules, and no core dump will be produced."
msgstr "Также, начиная с Linux 3.6, значение I</proc/sys/kernel/core_pattern> должно быть абсолютным путём или командой с каналом, как это описано в B<core>(5). В ядерный журнал будет выдано предупреждение, если значение I<core_pattern> отступает от этих правил, и дамп создан не будет."

#. type: TP
#: man-pages/man5/proc.5:3211
#, no-wrap
msgid "I</proc/sys/fs/super-max>"
msgstr "I</proc/sys/fs/super-max>"

#. type: Plain text
#: man-pages/man5/proc.5:3222
msgid ""
"This file controls the maximum number of superblocks, and thus the maximum "
"number of mounted filesystems the kernel can have.  You need increase only I"
"<super-max> if you need to mount more filesystems than the current value in "
"I<super-max> allows you to."
msgstr "Этот файл управляет максимальным значением суперблоков и таким образом максимальным количеством файловых систем, которое может смонтировать ядро. Вам необходимо увеличивать I<super-max> только в том случае, если нужно смонтировать больше файловых систем, чем это позволяет значение в файле I<super-max>."

#. type: TP
#: man-pages/man5/proc.5:3222
#, no-wrap
msgid "I</proc/sys/fs/super-nr>"
msgstr "I</proc/sys/fs/super-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:3226
msgid "This file contains the number of filesystems currently mounted."
msgstr "Этот файл содержит количество файловых систем, которое смонтировано в данный момент."

#. type: TP
#: man-pages/man5/proc.5:3226
#, no-wrap
msgid "I</proc/sys/kernel>"
msgstr "I</proc/sys/kernel>"

#. type: Plain text
#: man-pages/man5/proc.5:3230
msgid ""
"This directory contains files controlling a range of kernel parameters, as "
"described below."
msgstr "В этом каталоге содержатся файлы, контролирующие набор параметров ядра, описанных далее."

#. type: TP
#: man-pages/man5/proc.5:3230
#, no-wrap
msgid "I</proc/sys/kernel/acct>"
msgstr "I</proc/sys/kernel/acct>"

#. type: Plain text
#: man-pages/man5/proc.5:3254
msgid ""
"This file contains three numbers: I<highwater>, I<lowwater>, and "
"I<frequency>.  If BSD-style process accounting is enabled, these values "
"control its behavior.  If free space on filesystem where the log lives goes "
"below I<lowwater> percent, accounting suspends.  If free space gets above "
"I<highwater> percent, accounting resumes.  I<frequency> determines how often"
" the kernel checks the amount of free space (value is in seconds).  Default "
"values are 4, 2 and 30.  That is, suspend accounting if 2% or less space is "
"free; resume it if 4% or more space is free; consider information about "
"amount of free space valid for 30 seconds."
msgstr "В этом файле содержатся три числа: I<highwater>, I<lowwater> и I<frequency>. Если включён учёт процессов в стиле BSD, то эти значения управляют его поведением. Если свободного места на файловой системе, куда осуществляется протоколирование учёта, становится меньше, чем I<lowwater> процентов, то учёт процессов приостанавливается. Если свободного места становится больше, чем I<highwater> процентов, то учёт процессов возобновляется. Значение I<frequency> определяет как часто ядро проверяет свободное место (в секундах). По умолчанию значения соответственно составляют 4, 2 и 30. Таким образом, приостановка учёта осуществляется, если свободно менее 2% места на диске; возобновление если места больше или равно 4%; информация о свободном месте обновляется каждые 30 секунд."

#. type: TP
#: man-pages/man5/proc.5:3254
#, no-wrap
msgid "I</proc/sys/kernel/cap_last_cap> (since Linux 3.2)"
msgstr "I</proc/sys/kernel/cap_last_cap> (начиная с Linux 3.2)"

#. type: Plain text
#: man-pages/man5/proc.5:3258
msgid "See B<capabilities>(7)."
msgstr "Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man5/proc.5:3258
#, no-wrap
msgid "I</proc/sys/kernel/cap-bound> (from Linux 2.2 to 2.6.24)"
msgstr "I</proc/sys/kernel/cap-bound> (с Linux 2.2 до 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:3270
msgid ""
"This file holds the value of the kernel I<capability bounding set> "
"(expressed as a signed decimal number).  This set is ANDed against the "
"capabilities permitted to a process during B<execve>(2).  Starting with "
"Linux 2.6.25, the system-wide capability bounding set disappeared, and was "
"replaced by a per-thread bounding set; see B<capabilities>(7)."
msgstr "Этот файл содержит I<набор привязанных мандатов> ядра (выражаемый как десятичные числа со знаком). Этот набор мандатов, предоставляемых процессу во время B<execve>(2), которые складываются посредством битового умножения (AND). Начиная с Linux 2.6.25, глобального набора привязанных мандатов больше нет, теперь свой набор привязанных мандатов есть у каждой нити; смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man5/proc.5:3270
#, no-wrap
msgid "I</proc/sys/kernel/core_pattern>"
msgstr "I</proc/sys/kernel/core_pattern>"

#. type: TP
#: man-pages/man5/proc.5:3274
#, no-wrap
msgid "I</proc/sys/kernel/core_uses_pid>"
msgstr "I</proc/sys/kernel/core_uses_pid>"

#. type: TP
#: man-pages/man5/proc.5:3278
#, no-wrap
msgid "I</proc/sys/kernel/ctrl-alt-del>"
msgstr "I</proc/sys/kernel/ctrl-alt-del>"

#. type: Plain text
#: man-pages/man5/proc.5:3293
msgid ""
"This file controls the handling of Ctrl-Alt-Del from the keyboard.  When the"
" value in this file is 0, Ctrl-Alt-Del is trapped and sent to the B<init>(8)"
"  program to handle a graceful restart.  When the value is greater than "
"zero, Linux's reaction to a Vulcan Nerve Pinch (tm) will be an immediate "
"reboot, without even syncing its dirty buffers.  Note: when a program (like "
"dosemu) has the keyboard in \"raw\" mode, the ctrl-alt-del is intercepted by"
" the program before it ever reaches the kernel tty layer, and it's up to the"
" program to decide what to do with it."
msgstr "Этот файл управляет обработкой нажатия клавиш Ctrl-Alt-Del. Когда значение в этом файле равно 0, Ctrl-Alt-Del обрабатывается и производит вызов программы B<init>(8) для выполнения контролируемого перезапуска системы. Когда значение в файле больше 0, реакция Linux соответствует Vulcan Nerve Pinch (tm) [коронный приём расы Vulcan, см. сериал Star Trek], согласно которому произойдёт немедленная перезагрузка, даже без синхронизации буферов дисков. Замечание: когда какая-либо программа (типа dosemu) работает с клавиатурой \"напрямую\", нажатие ctrl-alt-del обработается этой программой, до того как оно достигнет уровня tty ядра и, таким образом, именно эта программа будет решать, что делать."

#. type: TP
#: man-pages/man5/proc.5:3293
#, no-wrap
msgid "I</proc/sys/kernel/dmesg_restrict> (since Linux 2.6.37)"
msgstr "I</proc/sys/kernel/dmesg_restrict> (начиная с Linux 2.6.37)"

#.  commit 620f6e8e855d6d447688a5f67a4e176944a084e8
#. type: Plain text
#: man-pages/man5/proc.5:3306
msgid ""
"The value in this file determines who can see kernel syslog contents.  A "
"value of 0 in this file imposes no restrictions.  If the value is 1, only "
"privileged users can read the kernel syslog.  (See B<syslog>(2)  for more "
"details.)  Since Linux 3.4, only users with the B<CAP_SYS_ADMIN> capability "
"may change the value in this file."
msgstr "Значение этого файла определяет, кто может видеть содержимое syslog от ядра. Значение 0 снимает все ограничения. Если значение равно 1,то только привилегированные пользователи могут читать syslog от ядра (подробности смотрите B<syslog>(2) в). Начиная с Linux 3.4, только пользователи с мандатом B<CAP_SYS_ADMIN> могут изменять содержимое этого файла."

#. type: TP
#: man-pages/man5/proc.5:3306
#, no-wrap
msgid "I</proc/sys/kernel/domainname> and I</proc/sys/kernel/hostname>"
msgstr "I</proc/sys/kernel/domainname> и I</proc/sys/kernel/hostname>"

#. type: Plain text
#: man-pages/man5/proc.5:3314
msgid ""
"can be used to set the NIS/YP domainname and the hostname of your box in "
"exactly the same way as the commands B<domainname>(1)  and B<hostname>(1), "
"that is:"
msgstr "могут быть использованы для установки имени домена службы NIS/YP и имени узла вашей машины точно таким же образом как и командами B<domainname>(1) и B<hostname>(1), т.е.:"

#. type: Plain text
#: man-pages/man5/proc.5:3319
#, no-wrap
msgid ""
"#B< echo \\(aqdarkstar\\(aq E<gt> /proc/sys/kernel/hostname>\n"
"#B< echo \\(aqmydomain\\(aq E<gt> /proc/sys/kernel/domainname>\n"
msgstr "#B< echo \\(aqdarkstar\\(aq E<gt> /proc/sys/kernel/hostname>\n#B< echo \\(aqmydomain\\(aq E<gt> /proc/sys/kernel/domainname>\n"

#. type: Plain text
#: man-pages/man5/proc.5:3323
msgid "has the same effect as"
msgstr "выполнят тоже самое, что и команды"

#. type: Plain text
#: man-pages/man5/proc.5:3328
#, no-wrap
msgid ""
"#B< hostname \\(aqdarkstar\\(aq>\n"
"#B< domainname \\(aqmydomain\\(aq>\n"
msgstr "#B< hostname \\(aqdarkstar\\(aq>\n#B< domainname \\(aqmydomain\\(aq>\n"

#. type: Plain text
#: man-pages/man5/proc.5:3341
msgid ""
"Note, however, that the classic darkstar.frop.org has the hostname "
"\"darkstar\" and DNS (Internet Domain Name Server)  domainname \"frop.org\","
" not to be confused with the NIS (Network Information Service) or YP (Yellow"
" Pages) domainname.  These two domain names are in general different.  For a"
" detailed discussion see the B<hostname>(1)  man page."
msgstr "Однако заметим, что классический darkstar.frop.org имеет имя узла \"darkstar\" и доменное имя DNS (Сервера Доменных Имен) \"frop.org\", не путайте с доменным именем NIS (Службы Сетевой Информации) или как она раньше называлась YP (Yellow Pages). Эти два доменных имени полностью различны по своей сути. Подробности об это можно найти в справочной странице B<hostname>(1)."

#. type: TP
#: man-pages/man5/proc.5:3341
#, no-wrap
msgid "I</proc/sys/kernel/hotplug>"
msgstr "I</proc/sys/kernel/hotplug>"

#. type: Plain text
#: man-pages/man5/proc.5:3347
msgid ""
"This file contains the path for the hotplug policy agent.  The default value"
" in this file is I</sbin/hotplug>."
msgstr "Этот файл содержит путь для агента политики устройств. По умолчанию это файл \"/sbin/hotplug\"."

#. type: TP
#: man-pages/man5/proc.5:3347
#, no-wrap
msgid "I</proc/sys/kernel/htab-reclaim>"
msgstr "I</proc/sys/kernel/htab-reclaim>"

#. type: Plain text
#: man-pages/man5/proc.5:3355
msgid ""
"(PowerPC only) If this file is set to a nonzero value, the PowerPC htab (see"
" kernel file I<Documentation/powerpc/ppc_htab.txt>)  is pruned each time the"
" system hits the idle loop."
msgstr "(только для PowerPC) Если значение в этом файле установлено в ненулевое значение, то PowerPC htab (см. файл I<Documentation/powerpc/ppc_htab.txt> в исходном коде ядра) сокращается каждый раз, когда система входит в цикл простоя."

#. type: TP
#: man-pages/man5/proc.5:3355
#, no-wrap
msgid "I</proc/sys/kernel/kptr_restrict> (since Linux 2.6.38)"
msgstr "I</proc/sys/kernel/kptr_restrict> (начиная с Linux 2.6.38)"

#.  455cd5ab305c90ffc422dd2e0fb634730942b257
#.  commit 411f05f123cbd7f8aa1edcae86970755a6e2a9d9
#.  commit 620f6e8e855d6d447688a5f67a4e176944a084e8
#. type: Plain text
#: man-pages/man5/proc.5:3380
msgid ""
"The value in this file determines whether kernel addresses are exposed via "
"I</proc> files and other interfaces.  A value of 0 in this file imposes no "
"restrictions.  If the value is 1, kernel pointers printed using the I<%pK> "
"format specifier will be replaced with zeros unless the user has the "
"B<CAP_SYSLOG> capability.  If the value is 2, kernel pointers printed using "
"the I<%pK> format specifier will be replaced with zeros regardless of the "
"user's capabilities.  The initial default value for this file was 1, but the"
" default was changed to 0 in Linux 2.6.39.  Since Linux 3.4, only users with"
" the B<CAP_SYS_ADMIN> capability can change the value in this file."
msgstr "Значением этого файла определяется будут ли видны ядра ядра, показываемые в файлах I</proc> и других интерфейсах. Значение 0 снимает все ограничения. Если значение равно 1, то указатели ядра, выводимые по формату I<%pK>, будут заменены на нули, если пользователь не имеет мандата B<CAP_SYSLOG>. Если значение равно 2, то указатели ядра, выводимые по формату I<%pK>, будут заменены на нули, независимо от наличия мандатов у пользователя. В начале значение по умолчанию было равно 1, но изменилось на 0 в Linux 2.6.39. Начиная с Linux 3.4, только пользователи с мандатом B<CAP_SYS_ADMIN> могут изменять значение в этом файле."

#. type: TP
#: man-pages/man5/proc.5:3380
#, no-wrap
msgid "I</proc/sys/kernel/l2cr>"
msgstr "I</proc/sys/kernel/l2cr>"

#. type: Plain text
#: man-pages/man5/proc.5:3387
msgid ""
"(PowerPC only) This file contains a flag that controls the L2 cache of G3 "
"processor boards.  If 0, the cache is disabled.  Enabled if nonzero."
msgstr "(только для PowerPC) Этот файл содержит флаг, который управляет кэшем L2 на процессорных платах G3. Если 0, кэш выключен. Если не ноль, то включён."

#. type: TP
#: man-pages/man5/proc.5:3387
#, no-wrap
msgid "I</proc/sys/kernel/modprobe>"
msgstr "I</proc/sys/kernel/modprobe>"

#. type: Plain text
#: man-pages/man5/proc.5:3400
msgid ""
"This file contains the path for the kernel module loader.  The default value"
" is I</sbin/modprobe>.  The file is present only if the kernel is built with"
" the B<CONFIG_MODULES> (B<CONFIG_KMOD> in Linux 2.6.26 and earlier)  option "
"enabled.  It is described by the Linux kernel source file "
"I<Documentation/kmod.txt> (present only in kernel 2.4 and earlier)."
msgstr "В этом файле содержится путь к загрузчику модулей ядра. Значение по умолчанию равно I</sbin/modprobe>. Файл существует только, если ядро собрано с параметром B<CONFIG_MODULES> (B<CONFIG_KMOD> — в Linux 2.6.26 и более ранних). Он описан в файле I<Documentation/kmod.txt> из дерева исходного кода ядра Linux (есть только в ядре версии 2.4 и более ранних)."

#. type: TP
#: man-pages/man5/proc.5:3400
#, no-wrap
msgid "I</proc/sys/kernel/modules_disabled> (since Linux 2.6.31)"
msgstr "I</proc/sys/kernel/modules_disabled> (начиная с Linux 2.6.31)"

#.  3d43321b7015387cfebbe26436d0e9d299162ea1
#.  From Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:3412
msgid ""
"A toggle value indicating if modules are allowed to be loaded in an "
"otherwise modular kernel.  This toggle defaults to off (0), but can be set "
"true (1).  Once true, modules can be neither loaded nor unloaded, and the "
"toggle cannot be set back to false.  The file is present only if the kernel "
"is built with the B<CONFIG_MODULES> option enabled."
msgstr "Значение-переключатель, показывающий, можно ли загружать модули в модульное ядро. Значение по умолчанию равно 0 (можно загружать), но может быть установлено в 1 (нельзя загружать). При значении 1 модули нельзя не загружать не выгружать, и значение-переключатель тоже нельзя изменить. Данный файл появляется только, если ядро собрано с включённым параметром B<CONFIG_MODULES>."

#. type: TP
#: man-pages/man5/proc.5:3412
#, no-wrap
msgid "I</proc/sys/kernel/msgmax> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/msgmax> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:3417
msgid ""
"This file defines a system-wide limit specifying the maximum number of bytes"
" in a single message written on a System V message queue."
msgstr "Этот файл определяет системный лимит на максимальное число байт в одном сообщении, которое пишется в очередь сообщений System\\ V."

#. type: TP
#: man-pages/man5/proc.5:3417
#, no-wrap
msgid "I</proc/sys/kernel/msgmni> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/msgmni> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:3421
msgid ""
"This file defines the system-wide limit on the number of message queue "
"identifiers."
msgstr "Этот файл определяет системное ограничение на количество идентификаторов в очереди сообщений."

#. type: TP
#: man-pages/man5/proc.5:3421
#, no-wrap
msgid "I</proc/sys/kernel/msgmnb> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/msgmnb> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:3430
msgid ""
"This file defines a system-wide parameter used to initialize the "
"I<msg_qbytes> setting for subsequently created message queues.  The "
"I<msg_qbytes> setting specifies the maximum number of bytes that may be "
"written to the message queue."
msgstr "Этот файл определяет системный параметр, используемый при начальной настройке I<msg_qbytes> для последовательно создаваемых очередей сообщений. Настройка I<msg_qbytes> задаёт максимальное число байт, которые могут быть записаны в очередь сообщений."

#. type: TP
#: man-pages/man5/proc.5:3430
#, no-wrap
msgid "I</proc/sys/kernel/ngroups_max> (since Linux 2.6.4)"
msgstr "I</proc/sys/kernel/ngroups_max> (начиная с Linux 2.6.4)"

#. type: Plain text
#: man-pages/man5/proc.5:3434
msgid ""
"This is a read-only file that displays the upper limit on the number of a "
"process's group memberships."
msgstr "Этот файл только для чтения, отображает верхний предел на количество членов группы процесса."

#. type: TP
#: man-pages/man5/proc.5:3434
#, no-wrap
msgid "I</proc/sys/kernel/ostype> and I</proc/sys/kernel/osrelease>"
msgstr "I</proc/sys/kernel/ostype> и I</proc/sys/kernel/osrelease>"

#. type: Plain text
#: man-pages/man5/proc.5:3439
msgid "These files give substrings of I</proc/version>."
msgstr "Эти файлы содержат подстроки из I</proc/version>."

#. type: TP
#: man-pages/man5/proc.5:3439
#, no-wrap
msgid "I</proc/sys/kernel/overflowgid> and I</proc/sys/kernel/overflowuid>"
msgstr "I</proc/sys/kernel/overflowgid> и I</proc/sys/kernel/overflowuid>"

#. type: Plain text
#: man-pages/man5/proc.5:3445
msgid ""
"These files duplicate the files I</proc/sys/fs/overflowgid> and "
"I</proc/sys/fs/overflowuid>."
msgstr "Эти файлы дублируют файлы I</proc/sys/fs/overflowgid> и I</proc/sys/fs/overflowuid>."

#. type: TP
#: man-pages/man5/proc.5:3445
#, no-wrap
msgid "I</proc/sys/kernel/panic>"
msgstr "I</proc/sys/kernel/panic>"

#. type: Plain text
#: man-pages/man5/proc.5:3454
msgid ""
"This file gives read/write access to the kernel variable I<panic_timeout>.  "
"If this is zero, the kernel will loop on a panic; if nonzero, it indicates "
"that the kernel should autoreboot after this number of seconds.  When you "
"use the software watchdog device driver, the recommended setting is 60."
msgstr "Этот файл предоставляет доступ на чтение и запись к переменной ядра I<panic_timeout>. Если значение в файле равно нулю, ядро будет зацикливаться при крахе системы по panic; если не ноль, то это означает, что ядро должно выполнить автоматическую перезагрузку после этого количества секунд. Когда вы используете программный драйвер устройства watchdog (устройство, периодически делающее проверку, что система функционирует), то рекомендуется установить значение 60."

#. type: TP
#: man-pages/man5/proc.5:3454
#, no-wrap
msgid "I</proc/sys/kernel/panic_on_oops> (since Linux 2.5.68)"
msgstr "I</proc/sys/kernel/panic_on_oops> (начиная с Linux 2.5.68)"

#. type: Plain text
#: man-pages/man5/proc.5:3466
msgid ""
"This file controls the kernel's behavior when an oops or BUG is encountered."
"  If this file contains 0, then the system tries to continue operation.  If "
"it contains 1, then the system delays a few seconds (to give klogd time to "
"record the oops output)  and then panics.  If the I</proc/sys/kernel/panic> "
"file is also nonzero, then the machine will be rebooted."
msgstr "Этот файл управляет поведением ядра, когда случается oops или BUG. Если файл содержит 0, то система пытается продолжить работу. Если содержит 1, то система выполняет задержку на несколько секунд (чтобы дать время klogd записать вывод oops) и затем генерирует крах системы через panic. Если файл I</proc/sys/kernel/panic> также содержит ненулевое значение, то машина будет перезагружена."

#. type: TP
#: man-pages/man5/proc.5:3466
#, no-wrap
msgid "I</proc/sys/kernel/pid_max> (since Linux 2.5.34)"
msgstr "I</proc/sys/kernel/pid_max> (начиная с Linux 2.5.34)"

#.  Prior to 2.6.10, pid_max could also be raised above 32768 on 32-bit
#.  platforms, but this broke /proc/[pid]
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=109513010926152&w=2
#. type: Plain text
#: man-pages/man5/proc.5:3485
msgid ""
"This file specifies the value at which PIDs wrap around (i.e., the value in "
"this file is one greater than the maximum PID).  PIDs greater than this "
"value not allocated; thus, the value in this file also acts as a system-wide"
" limit on the total number of processes and threads.  The default value for "
"this file, 32768, results in the same range of PIDs as on earlier kernels.  "
"On 32-bit platforms, 32768 is the maximum value for I<pid_max>.  On 64-bit "
"systems, I<pid_max> can be set to any value up to 2^22 (B<PID_MAX_LIMIT>, "
"approximately 4 million)."
msgstr "Этот файл задаёт значение, после которого идентификаторы процессов (PID)начинают использоваться с начала (т. е., значение в этом файле на единицу больше,чем максимальный PID). Значения PID больше этого значения не выделяются; то есть значение в этом файле также служит системным ограничением общего количества процессов и нитей. По умолчанию, значение в этом файле составляет 32768, т. е. означает тот же самый диапазон PID-ов, что и в ранних ядрах. На 32-битных платформах максимальное значение I<pid_max> равно 32768. На 64-битных платформах I<pid_max> может принимать любое значение до 2^22 (B<PID_MAX_LIMIT>, приблизительно 4 миллиона)."

#. type: TP
#: man-pages/man5/proc.5:3485
#, no-wrap
msgid "I</proc/sys/kernel/powersave-nap> (PowerPC only)"
msgstr "I</proc/sys/kernel/powersave-nap> (только на PowerPC)"

#. type: Plain text
#: man-pages/man5/proc.5:3491
msgid ""
"This file contains a flag.  If set, Linux-PPC will use the \"nap\" mode of "
"powersaving, otherwise the \"doze\" mode will be used."
msgstr "Этот файл содержит флаг. Если он установлен Linux-PPC будет использовать режим \"nap\" для энергосбережения, в противном случае будет использоваться режим \"doze\"."

#. type: TP
#: man-pages/man5/proc.5:3491
#, no-wrap
msgid "I</proc/sys/kernel/printk>"
msgstr "I</proc/sys/kernel/printk>"

#. type: Plain text
#: man-pages/man5/proc.5:3495
msgid "See B<syslog>(2)."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:3495
#, no-wrap
msgid "I</proc/sys/kernel/pty> (since Linux 2.6.4)"
msgstr "I</proc/sys/kernel/pty> (начиная с Linux 2.6.4)"

#. type: Plain text
#: man-pages/man5/proc.5:3501
msgid ""
"This directory contains two files relating to the number of UNIX 98 "
"pseudoterminals (see B<pts>(4))  on the system."
msgstr "В этом каталоге содержится два файла, отражающих количество псевдо-терминалов UNIX 98 (см. B<pts>(4)) в системе."

#. type: TP
#: man-pages/man5/proc.5:3501
#, no-wrap
msgid "I</proc/sys/kernel/pty/max>"
msgstr "I</proc/sys/kernel/pty/max>"

#. type: Plain text
#: man-pages/man5/proc.5:3504
msgid "This file defines the maximum number of pseudoterminals."
msgstr "Этот файл определяет максимальное количество псевдо-терминалов."

#. type: TP
#: man-pages/man5/proc.5:3504
#, no-wrap
msgid "I</proc/sys/kernel/pty/nr>"
msgstr "I</proc/sys/kernel/pty/nr>"

#. type: Plain text
#: man-pages/man5/proc.5:3508
msgid ""
"This read-only file indicates how many pseudoterminals are currently in use."
msgstr "Файл доступен только для чтения, показывает количество используемых в данный момент псевдо-терминалов."

#. type: TP
#: man-pages/man5/proc.5:3508
#, no-wrap
msgid "I</proc/sys/kernel/random>"
msgstr "I</proc/sys/kernel/random>"

#. type: Plain text
#: man-pages/man5/proc.5:3516
msgid ""
"This directory contains various parameters controlling the operation of the "
"file I</dev/random>.  See B<random>(4)  for further information."
msgstr "Этот каталог содержит различные параметры, управляющие работой файла I</dev/random>. Дополнительную информацию смотрите в B<random>(4)."

#. type: TP
#: man-pages/man5/proc.5:3516
#, no-wrap
msgid "I</proc/sys/kernel/random/uuid> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/random/uuid> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:3520
msgid ""
"Each read from this read-only file returns a randomly generated 128-bit "
"UUID, as a string in the standard UUID format."
msgstr "При каждом чтении из этого, доступного только для чтения файла, возвращается генерируемый случайным образом 128-битный UUID в виде строки в стандартном формате UUID."

#. type: TP
#: man-pages/man5/proc.5:3520
#, no-wrap
msgid "I</proc/sys/kernel/real-root-dev>"
msgstr "I</proc/sys/kernel/real-root-dev>"

#. type: Plain text
#: man-pages/man5/proc.5:3524
msgid ""
"This file is documented in the Linux kernel source file "
"I<Documentation/initrd.txt>."
msgstr "Этот файл описывается в файле исходного кода ядра Linux I<Documentation/initrd.txt>."

#. type: TP
#: man-pages/man5/proc.5:3524
#, no-wrap
msgid "I</proc/sys/kernel/reboot-cmd> (Sparc only) "
msgstr "I</proc/sys/kernel/reboot-cmd> (только на Sparc)"

#. type: Plain text
#: man-pages/man5/proc.5:3530
msgid ""
"This file seems to be a way to give an argument to the SPARC ROM/Flash boot "
"loader.  Maybe to tell it what to do after rebooting?"
msgstr "Этот файл, вероятно, является способом задания аргументов для начального загрузчика SPARC ROM/Flash. Способ сказать ему, что делать после перезагрузки?"

#. type: TP
#: man-pages/man5/proc.5:3530
#, no-wrap
msgid "I</proc/sys/kernel/rtsig-max>"
msgstr "I</proc/sys/kernel/rtsig-max>"

#. type: Plain text
#: man-pages/man5/proc.5:3537
msgid ""
"(Only in kernels up to and including 2.6.7; see B<setrlimit>(2))  This file "
"can be used to tune the maximum number of POSIX real-time (queued) signals "
"that can be outstanding in the system."
msgstr "(Только в ядре 2.6.7 и более ранних; см. B<setrlimit>(2)) Этот файл может быть использован для настройки максимального количества сигналов реального времени POSIX (в очереди), которое может воспринять система."

#. type: TP
#: man-pages/man5/proc.5:3537
#, no-wrap
msgid "I</proc/sys/kernel/rtsig-nr>"
msgstr "I</proc/sys/kernel/rtsig-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:3541
msgid ""
"(Only in kernels up to and including 2.6.7.)  This file shows the number "
"POSIX real-time signals currently queued."
msgstr "(Только в ядре 2.6.7 и более ранних) Этот файл показывает количество сигналов реального времени POSIX, которые в настоящий момент находятся в очереди."

#. type: TP
#: man-pages/man5/proc.5:3541
#, no-wrap
msgid "I</proc/sys/kernel/sched_rr_timeslice_ms> (since Linux 3.9)"
msgstr "I</proc/sys/kernel/sched_rr_timeslice_ms> (начиная с Linux 3.9)"

#. type: Plain text
#: man-pages/man5/proc.5:3545
msgid "See B<sched_rr_get_interval>(2)."
msgstr "Смотрите B<sched_rr_get_interval>(2)."

#. type: TP
#: man-pages/man5/proc.5:3545
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_period_us> (Since Linux 2.6.25)"
msgstr "I</proc/sys/kernel/sched_rt_period_us> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man5/proc.5:3549 man-pages/man5/proc.5:3553
msgid "See B<sched>(7)."
msgstr "Смотрите B<sched>(7)."

#. type: TP
#: man-pages/man5/proc.5:3549
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_runtime_us> (Since Linux 2.6.25)"
msgstr "I</proc/sys/kernel/sched_rt_runtime_us> (начиная с Linux 2.6.25)"

#. type: TP
#: man-pages/man5/proc.5:3553
#, no-wrap
msgid "I</proc/sys/kernel/sem> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/sem> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:3557
msgid ""
"This file contains 4 numbers defining limits for System V IPC semaphores.  "
"These fields are, in order:"
msgstr "Этот файл содержит 4 значения, описывающих ограничения семафоров System V IPC. Вот эти значения по порядку:"

#. type: IP
#: man-pages/man5/proc.5:3558
#, no-wrap
msgid "SEMMSL"
msgstr "SEMMSL"

#. type: Plain text
#: man-pages/man5/proc.5:3560
msgid "The maximum semaphores per semaphore set."
msgstr "Максимальное количество семафоров в одном списке семафоров."

#. type: IP
#: man-pages/man5/proc.5:3560
#, no-wrap
msgid "SEMMNS"
msgstr "SEMMNS"

#. type: Plain text
#: man-pages/man5/proc.5:3562
msgid "A system-wide limit on the number of semaphores in all semaphore sets."
msgstr "Системный лимит на количество семафоров во всех списках семафоров."

#. type: IP
#: man-pages/man5/proc.5:3562
#, no-wrap
msgid "SEMOPM"
msgstr "SEMOPM"

#. type: Plain text
#: man-pages/man5/proc.5:3566
msgid ""
"The maximum number of operations that may be specified in a B<semop>(2)  "
"call."
msgstr "Максимальное количество операций, которое может быть указано в вызове B<semop>(2)."

#. type: IP
#: man-pages/man5/proc.5:3566
#, no-wrap
msgid "SEMMNI"
msgstr "SEMMNI"

#. type: Plain text
#: man-pages/man5/proc.5:3568
msgid "A system-wide limit on the maximum number of semaphore identifiers."
msgstr "Системный лимит на максимальное количество идентификаторов семафоров."

#. type: TP
#: man-pages/man5/proc.5:3569
#, no-wrap
msgid "I</proc/sys/kernel/sg-big-buff>"
msgstr "I</proc/sys/kernel/sg-big-buff>"

#. type: Plain text
#: man-pages/man5/proc.5:3580
msgid ""
"This file shows the size of the generic SCSI device (sg) buffer.  You can't "
"tune it just yet, but you could change it at compile time by editing "
"I<include/scsi/sg.h> and changing the value of B<SG_BIG_BUFF>.  However, "
"there shouldn't be any reason to change this value."
msgstr "Этот файл показывает размер буфера стандартного SCSI устройства (sg). Вы не можете пока настраивать его, но его можно изменить при компиляции ядра, исправив I<include/scsi/sg.h>, изменив в нём значение B<SG_BIG_BUFF>. Однако, в этом, как правило, нет необходимости."

#. type: TP
#: man-pages/man5/proc.5:3580
#, no-wrap
msgid "I</proc/sys/kernel/shm_rmid_forced> (since Linux 3.1)"
msgstr "I</proc/sys/kernel/shm_rmid_forced> (начиная с Linux 3.1)"

#.  commit b34a6b1da371ed8af1221459a18c67970f7e3d53
#.  See also Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:3589
msgid ""
"If this file is set to 1, all System V shared memory segments will be marked"
" for destruction as soon as the number of attached processes falls to zero; "
"in other words, it is no longer possible to create shared memory segments "
"that exist independently of any attached process."
msgstr "Если значение в файле равно 1, то все общие сегменты памяти System V будут помечены на уничтожение сразу после сокращения присоединённых процессов до нуля; другими словами становится невозможно создать сегмент общей памяти, существующий независимо от присоединённого процесса."

#. type: Plain text
#: man-pages/man5/proc.5:3601
msgid ""
"The effect is as though a B<shmctl>(2)  B<IPC_RMID> is performed on all "
"existing segments as well as all segments created in the future (until this "
"file is reset to 0).  Note that existing segments that are attached to no "
"process will be immediately destroyed when this file is set to 1.  Setting "
"this option will also destroy segments that were created, but never "
"attached, upon termination of the process that created the segment with "
"B<shmget>(2)."
msgstr "Это подобно тому, как если бы выполнили B<shmctl>(2) B<IPC_RMID> для всех существующих сегментов, а также выполняли бы для всех сегментов, создаваемых в будущем (пока значение в файле не будет сброшено в 0). Заметим, что при задании в файле значения 1 существующие сегменты, не присоединённые к процессу, будут немедленно уничтожены. Установка этого значения также будет уничтожать сегменты, которые были созданы, но не присоединены — при завершении процесса, который создал эти сегменты с помощью B<shmget>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:3609
msgid ""
"Setting this file to 1 provides a way of ensuring that all System V shared "
"memory segments are counted against the resource usage and resource limits "
"(see the description of B<RLIMIT_AS> in B<getrlimit>(2))  of at least one "
"process."
msgstr "Установка значения в 1 позволяет быть уверенным, что все общие сегменты памяти System V подсчитаны и следуют заданным ограничениям ресурсов, как минимум, в одном процессе (смотрите описание B<RLIMIT_AS> в B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:3616
msgid ""
"Because setting this file to 1 produces behavior that is nonstandard and "
"could also break existing applications, the default value in this file is 0."
"  Only set this file to 1 if you have a good understanding of the semantics "
"of the applications using System V shared memory on your system."
msgstr "Так как установка значения в 1 вызывает нестандартное поведение и может привести к неработоспособности приложений, значение по умолчанию равно 0. Указывайте значение 1 только, если хорошо понимаете работу приложений, использующих общую память System V."

#. type: TP
#: man-pages/man5/proc.5:3616
#, no-wrap
msgid "I</proc/sys/kernel/shmall> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/shmall> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:3621
msgid ""
"This file contains the system-wide limit on the total number of pages of "
"System V shared memory."
msgstr "Этот файл содержит системный лимит на общее количество страниц общей памяти по стандарту System\\ V."

#. type: TP
#: man-pages/man5/proc.5:3621
#, no-wrap
msgid "I</proc/sys/kernel/shmmax> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/shmmax> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:3631
msgid ""
"This file can be used to query and set the run-time limit on the maximum "
"(System V IPC) shared memory segment size that can be created.  Shared "
"memory segments up to 1GB are now supported in the kernel.  This value "
"defaults to B<SHMMAX>."
msgstr "Этот файл может быть использован для опроса и установки ограничения максимального размера сегмента общей памяти по стандарту System\\ V во время выполнения. В настоящий момент ядро поддерживает сегменты общей памяти до 1ГБ. Значение по умолчанию равно B<SHMMAX>."

#. type: TP
#: man-pages/man5/proc.5:3631
#, no-wrap
msgid "I</proc/sys/kernel/shmmni> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/shmmni> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:3636
msgid ""
"This file specifies the system-wide maximum number of System V shared memory"
" segments that can be created."
msgstr "Задаёт максимальное системное ограничение на количество создаваемых общих сегментов памяти по стандарту System V."

#. type: TP
#: man-pages/man5/proc.5:3636
#, no-wrap
msgid "I</proc/sys/kernel/sysrq>"
msgstr "I</proc/sys/kernel/sysrq>"

#. type: Plain text
#: man-pages/man5/proc.5:3645
msgid ""
"This file controls the functions allowed to be invoked by the SysRq key.  By"
" default, the file contains 1 meaning that every possible SysRq request is "
"allowed (in older kernel versions, SysRq was disabled by default, and you "
"were required to specifically enable it at run-time, but this is not the "
"case any more).  Possible values in this file are:"
msgstr "Этот файл контролирует функции, которые можно вызывать по клавише SysRq. По умолчанию в нём содержится 1, которая означает, что разрешены любые возможные запросы SysRq (в старых ядрах SysRq по умолчанию выключена, и её требовалось явно включать при работе, но теперь этого больше не требуется.). Возможные значения:"

#. type: Plain text
#: man-pages/man5/proc.5:3657
#, no-wrap
msgid ""
"   0 - disable sysrq completely\n"
"   1 - enable all functions of sysrq\n"
"  E<gt>1 - bit mask of allowed sysrq functions, as follows:\n"
"          2 - enable control of console logging level\n"
"          4 - enable control of keyboard (SAK, unraw)\n"
"          8 - enable debugging dumps of processes etc.\n"
"         16 - enable sync command\n"
"         32 - enable remount read-only\n"
"         64 - enable signaling of processes (term, kill, oom-kill)\n"
"        128 - allow reboot/poweroff\n"
"        256 - allow nicing of all real-time tasks\n"
msgstr "   0 - отключить sysrq полностью\n   1 - включить все функции sysrq\n  E<gt>1 - маска битов разрешённых функций sysrq:\n          2 - включить управление уровнем протоколирования на консоль\n          4 - включить управление клавиатурой (SAK, unraw)\n          8 - включить отладочные дампы процессов и т.д.\n         16 - включить команду sync\n         32 - включить перемонтирование только для чтения\n         64 - включить отправку сигналов процессам (term, kill, oom-kill)\n        128 - разрешить перезагрузку/выключение\n        256 - разрешить изменение приоритета всех задач времени выполнения\n"

#. type: Plain text
#: man-pages/man5/proc.5:3663
msgid ""
"This file is present only if the B<CONFIG_MAGIC_SYSRQ> kernel configuration "
"option is enabled.  For further details see the Linux kernel source file "
"I<Documentation/sysrq.txt>."
msgstr "Этот файл существует только, если включён параметр сборки ядра B<CONFIG_MAGIC_SYSRQ>. Дополнительную информацию можно найти в исходном коде ядра Linux в файле I<Documentation/sysrq.txt>."

#. type: TP
#: man-pages/man5/proc.5:3663
#, no-wrap
msgid "I</proc/sys/kernel/version>"
msgstr "I</proc/sys/kernel/version>"

#. type: Plain text
#: man-pages/man5/proc.5:3666
msgid "This file contains a string like:"
msgstr "Этот файл содержит строку, подобную:"

#. type: Plain text
#: man-pages/man5/proc.5:3668
#, no-wrap
msgid "    #5 Wed Feb 25 21:49:24 MET 1998\n"
msgstr "    #5 Wed Feb 25 21:49:24 MET 1998\n"

#. type: Plain text
#: man-pages/man5/proc.5:3672
msgid ""
"The \"#5\" means that this is the fifth kernel built from this source base "
"and the date behind it indicates the time the kernel was built."
msgstr "Часть \"#5\" означает, что это пятая сборка ядра из исходной базы, а далее указана дата и время сборки ядра."

#. type: TP
#: man-pages/man5/proc.5:3672
#, no-wrap
msgid "I</proc/sys/kernel/threads-max> (since Linux 2.3.11)"
msgstr "I</proc/sys/kernel/threads-max> (начиная с Linux 2.3.11)"

#. type: Plain text
#: man-pages/man5/proc.5:3676
msgid ""
"This file specifies the system-wide limit on the number of threads (tasks) "
"that can be created on the system."
msgstr "Этот файл определяет системный лимит на количество нитей (задач), которое может быть создано в системе."

#. type: TP
#: man-pages/man5/proc.5:3676
#, no-wrap
msgid "I</proc/sys/kernel/zero-paged> (PowerPC only) "
msgstr "I</proc/sys/kernel/zero-paged> (только на PowerPC)"

#. type: Plain text
#: man-pages/man5/proc.5:3682
msgid ""
"This file contains a flag.  When enabled (nonzero), Linux-PPC will pre-zero "
"pages in the idle loop, possibly speeding up get_free_pages."
msgstr "Этот файл содержит флаг. Когда он установлен (не ноль), Linux-PPC будет размещать пре-нулевые страницы в цикле простоя, что возможно увеличит скорость выполнения get_free_pages."

#. type: TP
#: man-pages/man5/proc.5:3682
#, no-wrap
msgid "I</proc/sys/net>"
msgstr "I</proc/sys/net>"

#. type: Plain text
#: man-pages/man5/proc.5:3689
msgid ""
"This directory contains networking stuff.  Explanations for some of the "
"files under this directory can be found in B<tcp>(7)  and B<ip>(7)."
msgstr "Этот каталог содержит некоторую информацию по функционированию сетевой подсистемы. Описание некоторых файлов в этом каталоге можно найти в B<tcp>(7) и B<ip>(7)."

#. type: TP
#: man-pages/man5/proc.5:3689
#, no-wrap
msgid "I</proc/sys/net/core/somaxconn>"
msgstr "I</proc/sys/net/core/somaxconn>"

#. type: Plain text
#: man-pages/man5/proc.5:3698
msgid ""
"This file defines a ceiling value for the I<backlog> argument of "
"B<listen>(2); see the B<listen>(2)  manual page for details."
msgstr "Этот файл определяет наименьшее значение параметра I<backlog> системного вызова B<listen>(2); подробности смотрите в справочной странице B<listen>(2)."

#. type: TP
#: man-pages/man5/proc.5:3698
#, no-wrap
msgid "I</proc/sys/proc>"
msgstr "I</proc/sys/proc>"

#. type: TP
#: man-pages/man5/proc.5:3701
#, no-wrap
msgid "I</proc/sys/sunrpc>"
msgstr "I</proc/sys/sunrpc>"

#. type: Plain text
#: man-pages/man5/proc.5:3706
msgid ""
"This directory supports Sun remote procedure call for network filesystem "
"(NFS).  On some systems, it is not present."
msgstr "Данный каталог поддерживает удалённый вызов процедур Sun для сетевой файловой системы (NFS). В некоторых системах его нет."

#. type: TP
#: man-pages/man5/proc.5:3706
#, no-wrap
msgid "I</proc/sys/vm>"
msgstr "I</proc/sys/vm>"

#. type: Plain text
#: man-pages/man5/proc.5:3710
msgid ""
"This directory contains files for memory management tuning, buffer and cache"
" management."
msgstr "Этот каталог содержит файлы для тонкой настройки управления памятью, буферами и кэшем."

#. type: TP
#: man-pages/man5/proc.5:3710
#, no-wrap
msgid "I</proc/sys/vm/drop_caches> (since Linux 2.6.16)"
msgstr "I</proc/sys/vm/drop_caches> (начиная с Linux 2.6.16)"

#. type: Plain text
#: man-pages/man5/proc.5:3718
msgid ""
"Writing to this file causes the kernel to drop clean caches, dentries, and "
"inodes from memory, causing that memory to become free.  This can be useful "
"for memory management testing and performing reproducible filesystem "
"benchmarks.  Because writing to this file causes the benefits of caching to "
"be lost, it can degrade overall system performance."
msgstr "Запись в этот файл заставляет ядро сбросить чистые кэши, dentries и индексные дескрипторы из памяти, тем самым освобождая её. Это может быть полезно для тестирования управления памятью и выполнения воспроизводимых тестов производительности файловой системы. Так как запись в этот файл вызывает потерю преимуществ кэширования, это может снизить производительность системы в целом."

#. type: Plain text
#: man-pages/man5/proc.5:3720
msgid "To free pagecache, use:"
msgstr "Для освобождения страничного кэша (pagecache) используйте:"

#. type: Plain text
#: man-pages/man5/proc.5:3722
#, no-wrap
msgid "    echo 1 E<gt> /proc/sys/vm/drop_caches\n"
msgstr "    echo 1 E<gt> /proc/sys/vm/drop_caches\n"

#. type: Plain text
#: man-pages/man5/proc.5:3724
msgid "To free dentries and inodes, use:"
msgstr "Для освобождения dentries и индексных дескрипторов используйте:"

#. type: Plain text
#: man-pages/man5/proc.5:3726
#, no-wrap
msgid "    echo 2 E<gt> /proc/sys/vm/drop_caches\n"
msgstr "    echo 2 E<gt> /proc/sys/vm/drop_caches\n"

#. type: Plain text
#: man-pages/man5/proc.5:3728
msgid "To free pagecache, dentries and inodes, use:"
msgstr "Для освобождения страничного кэша, dentries и индексных дескрипторов используйте:"

#. type: Plain text
#: man-pages/man5/proc.5:3730
#, no-wrap
msgid "    echo 3 E<gt> /proc/sys/vm/drop_caches\n"
msgstr "    echo 3 E<gt> /proc/sys/vm/drop_caches\n"

#. type: Plain text
#: man-pages/man5/proc.5:3736
msgid ""
"Because writing to this file is a nondestructive operation and dirty objects"
" are not freeable, the user should run B<sync>(8)  first."
msgstr "Так как запись в этот файл — неразрушающая операция и изменившиеся (dirty) объекты не свободны, пользователь сначала должен запустить команду B<sync>(8)."

#. type: TP
#: man-pages/man5/proc.5:3736
#, no-wrap
msgid "I</proc/sys/vm/legacy_va_layout> (since Linux 2.6.9)"
msgstr "I</proc/sys/vm/legacy_va_layout> (начиная с Linux 2.6.9)"

#.  The following is from Documentation/filesystems/proc.txt
#. type: Plain text
#: man-pages/man5/proc.5:3741
msgid ""
"If nonzero, this disables the new 32-bit memory-mapping layout; the kernel "
"will use the legacy (2.4) layout for all processes."
msgstr "Если не равно нулю, то новая раскладка 32-битного отображения памяти выключается; ядро будет использовать старую (2.4) раскладку для всех процессов."

#. type: TP
#: man-pages/man5/proc.5:3741
#, no-wrap
msgid "I</proc/sys/vm/memory_failure_early_kill> (since Linux 2.6.32)"
msgstr "I</proc/sys/vm/memory_failure_early_kill> (начиная с Linux 2.6.32)"

#.  The following is based on the text in Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:3753
msgid ""
"Control how to kill processes when an uncorrected memory error (typically a "
"2-bit error in a memory module)  that cannot be handled by the kernel is "
"detected in the background by hardware.  In some cases (like the page still "
"having a valid copy on disk), the kernel will handle the failure "
"transparently without affecting any applications.  But if there is no other "
"up-to-date copy of the data, it will kill processes to prevent any data "
"corruptions from propagating."
msgstr "Управляет, как завершать процессы, когда неисправленная ошибка памяти (обычно, 2-битная ошибка в модуле памяти), которая не может быть обработана ядром, обнаружена в фоновом режиме аппаратным обеспечением. В некоторых случаях (например, когда страница имеет правильную копию на диске), ядро может может прозрачно исправить ошибку без влияния на приложения. Но если актуальной копии данных нет, то ядро завершит процесс, чтобы остановить распространение повреждения данных."

#. type: Plain text
#: man-pages/man5/proc.5:3755
msgid "The file has one of the following values:"
msgstr "В файле содержатся следующие значения:"

#. type: IP
#: man-pages/man5/proc.5:3756 man-pages/man5/proc.5:3793
#, no-wrap
msgid "1:"
msgstr "1:"

#. type: Plain text
#: man-pages/man5/proc.5:3761
msgid ""
"Kill all processes that have the corrupted-and-not-reloadable page mapped as"
" soon as the corruption is detected.  Note this is not supported for a few "
"types of pages, like kernel internally allocated data or the swap cache, but"
" works for the majority of user pages."
msgstr "При обнаружении завершать все процессы, у которых есть повреждённые и не восстановимые с диска страницы. Заметим, что это поддерживается не для всех типов страниц, например для внутренних данных ядра или кэша подкачки, но работает для большинства пользовательских страниц."

#. type: IP
#: man-pages/man5/proc.5:3761 man-pages/man5/proc.5:3795
#, no-wrap
msgid "0:"
msgstr "0:"

#. type: Plain text
#: man-pages/man5/proc.5:3764
msgid ""
"Only unmap the corrupted page from all processes and kill only a process "
"that tries to access it."
msgstr "Только отключить отображение повреждённой страницы у всех процессов и завершать только процессы, которые пытаются к ней обратиться."

#. type: Plain text
#: man-pages/man5/proc.5:3775
msgid ""
"The kill is performed using a B<SIGBUS> signal with I<si_code> set to "
"B<BUS_MCEERR_AO>.  Processes can handle this if they want to; see "
"B<sigaction>(2)  for more details."
msgstr "Такое завершение выполняется с использованием сигнала B<SIGBUS> с установления значения I<si_code> равным B<BUS_MCEERR_AO>. Процессы могут обработать такую ситуацию, если захотят; подробней см. B<sigaction>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:3778
msgid ""
"This feature is active only on architectures/platforms with advanced machine"
" check handling and depends on the hardware capabilities."
msgstr "Это свойство активно только на архитектурах/платформах с дополнительными проверки и зависит от возможностей аппаратного обеспечения."

#. type: Plain text
#: man-pages/man5/proc.5:3785
msgid ""
"Applications can override the I<memory_failure_early_kill> setting "
"individually with the B<prctl>(2)  B<PR_MCE_KILL> operation."
msgstr "Приложения могут изменить настройку I<memory_failure_early_kill> для себя с помощью операции B<PR_MCE_KILL> вызова B<prctl>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:3788 man-pages/man5/proc.5:3801
msgid ""
"Only present if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr "Доступен только, если ядро собрано с поддержкой B<CONFIG_MEMORY_FAILURE>."

#. type: TP
#: man-pages/man5/proc.5:3788
#, no-wrap
msgid "I</proc/sys/vm/memory_failure_recovery> (since Linux 2.6.32)"
msgstr "I</proc/sys/vm/memory_failure_recovery> (начиная с Linux 2.6.32)"

#.  The following is based on the text in Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:3792
msgid "Enable memory failure recovery (when supported by the platform)"
msgstr "Включает восстановление отказов памяти (если поддерживается платформой)"

#. type: Plain text
#: man-pages/man5/proc.5:3795
msgid "Attempt recovery."
msgstr "Пытаться восстановить."

#. type: Plain text
#: man-pages/man5/proc.5:3797
msgid "Always panic on a memory failure."
msgstr "При отказе памяти всегда доводить до паники."

#. type: TP
#: man-pages/man5/proc.5:3801
#, no-wrap
msgid "I</proc/sys/vm/oom_dump_tasks> (since Linux 2.6.25)"
msgstr "I</proc/sys/vm/oom_dump_tasks> (начиная с Linux 2.6.25)"

#.  The following is from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:3816
msgid ""
"Enables a system-wide task dump (excluding kernel threads) to be produced "
"when the kernel performs an OOM-killing.  The dump includes the following "
"information for each task (thread, process): thread ID, real user ID, thread"
" group ID (process ID), virtual memory size, resident set size, the CPU that"
" the task is scheduled on, oom_adj score (see the description of "
"I</proc/[pid]/oom_adj>), and command name.  This is helpful to determine why"
" the OOM-killer was invoked and to identify the rogue task that caused it."
msgstr "Включает системный дамп задач (исключая ядерные нити), который создаётся когда ядро выполняет OOM-killing. Дамп включает следующую информацию по каждой задаче (нити, процессу): ID нити, реальный ID пользователя, ID группы нитей (ID процесса), размер виртуальной памяти, размер резидентной настройки, процессор, на котором работала задача, счётчик oom_adj (описание смотрите в I</proc/[pid]/oom_adj>) и имя команды. Эти данные полезны для определения того, почему был вызван OOM-killer и нахождения экземпляра задачи, его вызвавшего."

#. type: Plain text
#: man-pages/man5/proc.5:3822
msgid ""
"If this contains the value zero, this information is suppressed.  On very "
"large systems with thousands of tasks, it may not be feasible to dump the "
"memory state information for each one.  Such systems should not be forced to"
" incur a performance penalty in OOM situations when the information may not "
"be desired."
msgstr "Если в файле содержится нулевое значение, то информация не выдаётся. На очень больших системах с тысячами задач дамп информации о состоянии памяти может быть неосуществим по каждой задаче. Системы не должны страдать от потери производительности из-за возникновения ситуаций с OOM, если такая информация ненужна."

#. type: Plain text
#: man-pages/man5/proc.5:3825
msgid ""
"If this is set to nonzero, this information is shown whenever the OOM-killer"
" actually kills a memory-hogging task."
msgstr "Если задано ненулевое значение, то эта информация показывается в момент когда OOM-killer завершает захватившую память задачу."

#. type: Plain text
#: man-pages/man5/proc.5:3827 man-pages/man5/proc.5:3848
msgid "The default value is 0."
msgstr "Значение по умолчанию равно 0."

#. type: TP
#: man-pages/man5/proc.5:3827
#, no-wrap
msgid "I</proc/sys/vm/oom_kill_allocating_task> (since Linux 2.6.24)"
msgstr "I</proc/sys/vm/oom_kill_allocating_task> (начиная с Linux 2.6.24)"

#.  The following is from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:3832
msgid ""
"This enables or disables killing the OOM-triggering task in out-of-memory "
"situations."
msgstr "Включает или выключает задачу завершения при OOM (исчерпание свободной памяти)."

#. type: Plain text
#: man-pages/man5/proc.5:3837
msgid ""
"If this is set to zero, the OOM-killer will scan through the entire tasklist"
" and select a task based on heuristics to kill.  This normally selects a "
"rogue memory-hogging task that frees up a large amount of memory when "
"killed."
msgstr "Если это значение равно нулю, то OOM-killer будет сканировать весь список задач и выбирать задачу для завершения на основе набора эвристических правил. Обычно выбирается задача, которая больше всех захватила памяти, что при её завершении позволит освободить огромное количество памяти."

#. type: Plain text
#: man-pages/man5/proc.5:3841
msgid ""
"If this is set to nonzero, the OOM-killer simply kills the task that "
"triggered the out-of-memory condition.  This avoids a possibly expensive "
"tasklist scan."
msgstr "Если это значение не равно нулю, то OOM-killer просто завершит задачу, из-за которой возникла ситуация нехватки памяти. Это позволяет избежать затратной операции сканирования списка задач."

#. type: Plain text
#: man-pages/man5/proc.5:3846
msgid ""
"If I</proc/sys/vm/panic_on_oom> is nonzero, it takes precedence over "
"whatever value is used in I</proc/sys/vm/oom_kill_allocating_task>."
msgstr "Если I</proc/sys/vm/panic_on_oom> не равно нулю, то оно имеет приоритет над значением из I</proc/sys/vm/oom_kill_allocating_task>."

#. type: TP
#: man-pages/man5/proc.5:3848
#, no-wrap
msgid "I</proc/sys/vm/overcommit_kbytes> (since Linux 3.14)"
msgstr ""

#.  commit 49f0ce5f92321cdcf741e35f385669a421013cb7
#. type: Plain text
#: man-pages/man5/proc.5:3865
msgid ""
"This writable file provides an alternative to "
"I</proc/sys/vm/overcommit_ratio> for controlling the I<CommitLimit> when "
"I</proc/sys/vm/overcommit_memory> has the value 2.  It allows the amount of "
"memory overcommitting to be specified as an absolute value (in kB), rather "
"than as a percentage, as is done with I<overcommit_ratio>.  This allows for "
"finer-grained control of I<CommitLimit> on systems with extremely large "
"memory sizes."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3880
msgid ""
"Only one of I<overcommit_kbytes> or I<overcommit_ratio> can have an effect: "
"if I<overcommit_kbytes> has a nonzero value, then it is used to calculate "
"I<CommitLimit>, otherwise I<overcommit_ratio> is used.  Writing a value to "
"either of these files causes the value in the other file to be set to zero."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:3880
#, no-wrap
msgid "I</proc/sys/vm/overcommit_memory>"
msgstr "I</proc/sys/vm/overcommit_memory>"

#. type: Plain text
#: man-pages/man5/proc.5:3884
msgid ""
"This file contains the kernel virtual memory accounting mode.  Values are:"
msgstr "Этот файл содержит значение режима учёта виртуальной памяти ядра. Значения:"

#. type: Plain text
#: man-pages/man5/proc.5:3887
msgid "0: heuristic overcommit (this is the default)"
msgstr "0: эвристический перерасход (значение по умолчанию)"

#. type: Plain text
#: man-pages/man5/proc.5:3889
msgid "1: always overcommit, never check"
msgstr "1: всегда разрешать перерасход, не проверять"

#. type: Plain text
#: man-pages/man5/proc.5:3891
msgid "2: always check, never overcommit"
msgstr "2: всегда проверять, запретить перерасход"

#. type: Plain text
#: man-pages/man5/proc.5:3900
msgid ""
"In mode 0, calls of B<mmap>(2)  with B<MAP_NORESERVE> are not checked, and "
"the default check is very weak, leading to the risk of getting a process "
"\"OOM-killed\".  Under Linux 2.4, any nonzero value implies mode 1."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3907
msgid ""
"In mode 2 (available since Linux 2.6), the total virtual address space that "
"can be allocated (I<CommitLimit> in I</proc/meminfo>)  is calculated as"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3910
#, no-wrap
msgid ""
"    CommitLimit = (total_RAM - total_huge_TLB) *\n"
"                  overcommit_ratio / 100 + total_swap\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3912
msgid "where:"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3916
msgid "I<total_RAM> is the total amount of RAM on the system;"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3919
msgid "I<total_huge_TLB> is the amount of memory set aside for huge pages;"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3924
msgid ""
"I<overcommit_ratio> is the value in I</proc/sys/vm/overcommit_ratio>; and"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3927
msgid "I<total_swap> is the amount of swap space."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3935
msgid ""
"For example, on a system with 16GB of physical RAM, 16GB of swap, no space "
"dedicated to huge pages, and an I<overcommit_ratio> of 50, this formula "
"yields a I<CommitLimit> of 24GB."
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3941
msgid ""
"Since Linux 3.14, if the value in I</proc/sys/vm/overcommit_kbytes> is "
"nonzero, then I<CommitLimit> is instead calculated as:"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3943
#, no-wrap
msgid "    CommitLimit = overcommit_kbytes + total_swap\n"
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:3943
#, no-wrap
msgid "I</proc/sys/vm/overcommit_ratio> (since Linux 2.6.0)"
msgstr ""

#. type: Plain text
#: man-pages/man5/proc.5:3950
msgid ""
"This writable file defines a percentage by which memory can be "
"overcommitted.  The default value in the file is 50.  See the description of"
" I</proc/sys/vm/overcommit_memory>."
msgstr ""

#. type: TP
#: man-pages/man5/proc.5:3950
#, no-wrap
msgid "I</proc/sys/vm/panic_on_oom> (since Linux 2.6.18)"
msgstr "I</proc/sys/vm/panic_on_oom> (начиная с Linux 2.6.18)"

#.  The following is adapted from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:3955
msgid "This enables or disables a kernel panic in an out-of-memory situation."
msgstr "Включает или отключает панику ядра при нехватке памяти."

#. type: Plain text
#: man-pages/man5/proc.5:3960
msgid ""
"If this file is set to the value 0, the kernel's OOM-killer will kill some "
"rogue process.  Usually, the OOM-killer is able to kill a rogue process and "
"the system will survive."
msgstr "Если значение равно 0, то ядерный OOM-killer завершит какой-нибудь вышедший из подчинения процесс. Обычно, OOM-killer способен завершить такой процесс и система продолжит работу."

#. type: Plain text
#: man-pages/man5/proc.5:3975
msgid ""
"If this file is set to the value 1, then the kernel normally panics when "
"out-of-memory happens.  However, if a process limits allocations to certain "
"nodes using memory policies (B<mbind>(2)  B<MPOL_BIND>)  or cpusets "
"(B<cpuset>(7))  and those nodes reach memory exhaustion status, one process "
"may be killed by the OOM-killer.  No panic occurs in this case: because "
"other nodes' memory may be free, this means the system as a whole may not "
"have reached an out-of-memory situation yet."
msgstr "Если значение в файле равно 1, то ядро, обычно, переходит в состояние паники при нехватке памяти. Однако, если процесс ограничен в выделении определённых элементов (nodes) согласно политике памяти (B<mbind>(2) B<MPOL_BIND>) или процессора (B<cpuset>(7)) и предел таких элементов памяти был достигнут, то такой процесс может быть завершён OOM-killer. В этом случае состояние паники не возникнет, так как другие элементы памяти могут освободиться, что означает, что система в целом может не прийти к ситуации нехватки памяти."

#. type: Plain text
#: man-pages/man5/proc.5:3978
msgid ""
"If this file is set to the value 2, the kernel always panics when an out-of-"
"memory condition occurs."
msgstr "Если значение в файле равно 2, то ядро всегда переходит в состояние паники, когда возникает нехватка памяти."

#. type: Plain text
#: man-pages/man5/proc.5:3982
msgid ""
"The default value is 0.  1 and 2 are for failover of clustering.  Select "
"either according to your policy of failover."
msgstr "Значение по умолчанию равно 0. Значение 1 и 2 используются для отказоустойчивости кластеров. Выберите любое согласно вашей политике отказоустойчивости."

#. type: TP
#: man-pages/man5/proc.5:3982
#, no-wrap
msgid "I</proc/sys/vm/swappiness>"
msgstr "I</proc/sys/vm/swappiness>"

#.  The following is from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:3990
msgid ""
"The value in this file controls how aggressively the kernel will swap memory"
" pages.  Higher values increase aggressiveness, lower values decrease "
"aggressiveness.  The default value is 60."
msgstr "Значение в этом файле определяет, насколько активно ядро будет вытеснять страницы в пространство подкачки. Большие значения увеличивают активность, меньшие значения сокращают активность. По умолчанию значение равно 60."

#. type: TP
#: man-pages/man5/proc.5:3990
#, no-wrap
msgid "I</proc/sysrq-trigger> (since Linux 2.4.21)"
msgstr "I</proc/sysrq-trigger> (начиная с Linux 2.4.21)"

#. type: Plain text
#: man-pages/man5/proc.5:3999
msgid ""
"Writing a character to this file triggers the same SysRq function as typing "
"ALT-SysRq-E<lt>characterE<gt> (see the description of "
"I</proc/sys/kernel/sysrq>).  This file is normally writable only by I<root>."
"  For further details see the Linux kernel source file "
"I<Documentation/sysrq.txt>."
msgstr "Запись символа в этот файл приводит к вызову функции SysRq, как если бы была нажата ALT-SysRq-E<lt>клавишаE<gt> (смотрите описание I</proc/sys/kernel/sysrq>). Обычно, этот файл доступен на запись только I<root>. Дополнительную информацию смотрите в исходном коде ядра Linux в файле I<Documentation/sysrq.txt>."

#. type: TP
#: man-pages/man5/proc.5:3999
#, no-wrap
msgid "I</proc/sysvipc>"
msgstr "I</proc/sysvipc>"

#. type: Plain text
#: man-pages/man5/proc.5:4012
msgid ""
"Subdirectory containing the pseudo-files I<msg>, I<sem> and I<shm>.  These "
"files list the System V Interprocess Communication (IPC) objects "
"(respectively: message queues, semaphores, and shared memory)  that "
"currently exist on the system, providing similar information to that "
"available via B<ipcs>(1).  These files have headers and are formatted (one "
"IPC object per line)  for easy understanding.  B<svipc>(7)  provides further"
" background on the information shown by these files."
msgstr "Подкаталог содержит псевдо-файлы I<msg>, I<sem> и I<shm>.Эти файлы описывают объекты межпроцессного взаимодействия (System V Interprocess Communication (IPC)) (соответственно: очереди сообщений, семафоры и общую память), которые существуют в системе в настоящий момент. Похожая информация предоставляется через B<ipcs>(1). Эти файлы имеют заголовки и форматируются (по одному IPC объекту на строку) для более лёгкого понимания. B<svipc>(7) представляет подготовительный материал по информации, которую показывают эти файлы."

#. type: TP
#: man-pages/man5/proc.5:4012
#, no-wrap
msgid "I</proc/timer_list> (since Linux 2.6.21)"
msgstr "I</proc/timer_list> (начиная с Linux 2.6.21)"

#.  commit 289f480af87e45f7a6de6ba9b4c061c2e259fe98
#. type: Plain text
#: man-pages/man5/proc.5:4018
msgid ""
"This read-only file exposes a list of all currently pending (high-"
"resolution) timers, all clock-event sources, and their parameters in a "
"human-readable form."
msgstr "Этот файл, доступный только для чтения, содержит список всех ожидающих в данный момент таймеров (высокой точности), всех источников событий часов и их параметры."

#. type: TP
#: man-pages/man5/proc.5:4018
#, no-wrap
msgid "I</proc/timer_stats> (since Linux 2.6.21)"
msgstr "I</proc/timer_stats> (начиная с Linux 2.6.21)"

#.  commit 82f67cd9fca8c8762c15ba7ed0d5747588c1e221
#. 	Date:   Fri Feb 16 01:28:13 2007 -0800
#.  Text largely derived from Documentation/timers/timer_stats.txt
#. type: Plain text
#: man-pages/man5/proc.5:4029
msgid ""
"This is a debugging facility to make timer (ab)use in a Linux system visible"
" to kernel and user-space developers.  It can be used by kernel and user-"
"space developers to verify that their code does not make undue use of "
"timers.  The goal is to avoid unnecessary wakeups, thereby optimizing power "
"consumption."
msgstr "Это отладочное средство делает таймер, используемый в системе Linux, видимым разработчикам ядра и в пользовательском пространстве. Оно может использоваться для проверки отсутствия чрезмерной нагрузки на таймеры. Цель — для оптимизации потребления энергии избежать ненужных пробуждений."

#. type: Plain text
#: man-pages/man5/proc.5:4037
msgid ""
"If enabled in the kernel (B<CONFIG_TIMER_STATS>), but not used, it has "
"almost zero runtime overhead and a relatively small data-structure overhead."
"  Even if collection is enabled at runtime, overhead is low: all the locking"
" is per-CPU and lookup is hashed."
msgstr "Если включено в ядре (B<CONFIG_TIMER_STATS>) и не используется, то почти не задействует процессор и потребляет относительно малое количество памяти под структуры данных. Даже включённый сбор статистики не даёт высокой нагрузки: все блокировки относятся к ЦП, а поиск хэшируется."

#. type: Plain text
#: man-pages/man5/proc.5:4042
msgid ""
"The I</proc/timer_stats> file is used both to control sampling facility and "
"to read out the sampled information."
msgstr "Файл I</proc/timer_stats> используется для управления функцией сборки и чтения полученных результатов."

#. type: Plain text
#: man-pages/man5/proc.5:4045
msgid ""
"timer_stats collects information about the timer events which are fired in a"
" Linux system over a sample period:"
msgstr "Средство timer_stats собирает информацию о событиях таймеров, которые сработали в системе Linux за заданный период:"

#. type: Plain text
#: man-pages/man5/proc.5:4051
msgid ""
"- the pid of the task(process) which initialized the timer - the name of the"
" process which initialized the timer - the function where the timer was "
"initialized - the callback function which is associated to the timer - the "
"number of events (callbacks)"
msgstr "- pid задачи (процесса), которая инициализировала таймер — имя процесса, который инициализировал таймер — функция, откуда был инициализирован таймер — функция обратного вызова, которая связана с таймером — количество событий (обратных вызовов)"

#. type: Plain text
#: man-pages/man5/proc.5:4054
msgid ""
"The timer_stats functionality is inactive on bootup.  A sampling period can "
"be started using the following command:"
msgstr "Средство timer_stats при запуске неактивно. Период тестирования может быть запущен командой:"

#. type: Plain text
#: man-pages/man5/proc.5:4056
#, no-wrap
msgid "    # echo 1 E<gt> /proc/timer_stats\n"
msgstr "    # echo 1 E<gt> /proc/timer_stats\n"

#. type: Plain text
#: man-pages/man5/proc.5:4058
msgid "The following command stops a sampling period:"
msgstr "Следующая команда остановит период тестирования:"

#. type: Plain text
#: man-pages/man5/proc.5:4060
#, no-wrap
msgid "    # echo 0 E<gt> /proc/timer_stats\n"
msgstr "    # echo 0 E<gt> /proc/timer_stats\n"

#. type: Plain text
#: man-pages/man5/proc.5:4062
msgid "The statistics can be retrieved by:"
msgstr "Статистику можно получить так:"

#. type: Plain text
#: man-pages/man5/proc.5:4064
#, no-wrap
msgid "    $ cat /proc/timer_stats\n"
msgstr "    $ cat /proc/timer_stats\n"

#. type: Plain text
#: man-pages/man5/proc.5:4070
msgid ""
"While sampling is enabled, each readout from /proc/timer_stats will see "
"newly updated statistics.  Once sampling is disabled, the sampled "
"information is kept until a new sample period is started.  This allows "
"multiple readouts."
msgstr "На время действия периода сбора каждым чтением /proc/timer_stats можно получить обновлённую статистику. После выключения сбора статистика останется доступной до следующего начала периода сбора. Это позволяет читать несколько раз."

#. type: Plain text
#: man-pages/man5/proc.5:4073
msgid "Sample output from I</proc/timer_stats>:"
msgstr "Пример статистики из I</proc/timer_stats>:"

#. type: Plain text
#: man-pages/man5/proc.5:4089
#, no-wrap
msgid ""
"$B< cat /proc/timer_stats>\n"
"Timer Stats Version: v0.3\n"
"Sample period: 1.764 s\n"
"Collection: active\n"
"  255,     0 swapper/3        hrtimer_start_range_ns (tick_sched_timer)\n"
"   71,     0 swapper/1        hrtimer_start_range_ns (tick_sched_timer)\n"
"   58,     0 swapper/0        hrtimer_start_range_ns (tick_sched_timer)\n"
"    4,  1694 gnome-shell      mod_delayed_work_on (delayed_work_timer_fn)\n"
"   17,     7 rcu_sched        rcu_gp_kthread (process_timeout)\n"
"\\&...\n"
"    1,  4911 kworker/u16:0    mod_delayed_work_on (delayed_work_timer_fn)\n"
"   1D,  2522 kworker/0:0      queue_delayed_work_on (delayed_work_timer_fn)\n"
"1029 total events, 583.333 events/sec\n"
msgstr "$B< cat /proc/timer_stats>\nTimer Stats Version: v0.3\nSample period: 1.764 s\nCollection: active\n  255,     0 swapper/3        hrtimer_start_range_ns (tick_sched_timer)\n   71,     0 swapper/1        hrtimer_start_range_ns (tick_sched_timer)\n   58,     0 swapper/0        hrtimer_start_range_ns (tick_sched_timer)\n    4,  1694 gnome-shell      mod_delayed_work_on (delayed_work_timer_fn)\n   17,     7 rcu_sched        rcu_gp_kthread (process_timeout)\n\\&...\n    1,  4911 kworker/u16:0    mod_delayed_work_on (delayed_work_timer_fn)\n   1D,  2522 kworker/0:0      queue_delayed_work_on (delayed_work_timer_fn)\n1029 total events, 583.333 events/sec\n"

#. type: Plain text
#: man-pages/man5/proc.5:4094
msgid "The output columns are:"
msgstr "Выводимые столбцы:"

#.  commit c5c061b8f9726bc2c25e19dec227933a13d1e6b7 deferrable timers
#. type: Plain text
#: man-pages/man5/proc.5:4100
msgid ""
"a count of the number of events, optionally (since Linux 2.6.23) followed by"
" the letter \\(aqD\\(aq if this is a deferrable timer;"
msgstr "счётчик событий, за которым следует (начиная с Linux 2.6.23) необязательная буква «D», если это отложенный таймер;"

#. type: Plain text
#: man-pages/man5/proc.5:4102
msgid "the PID of the process that initialized the timer;"
msgstr "PID процесса, который инициализировал таймер;"

#. type: Plain text
#: man-pages/man5/proc.5:4104
msgid "the name of the process that initialized the timer;"
msgstr "имя процесса, который инициализировал таймер;"

#. type: Plain text
#: man-pages/man5/proc.5:4106
msgid "the function where the timer was initialized; and"
msgstr "функция, откуда был инициализирован таймер, и"

#. type: Plain text
#: man-pages/man5/proc.5:4109
msgid ""
"(in parentheses)  the callback function that is associated with the timer."
msgstr "(в скобках) функция обратного вызова, которая связана с таймером."

#. type: TP
#: man-pages/man5/proc.5:4110
#, no-wrap
msgid "I</proc/tty>"
msgstr "I</proc/tty>"

#. type: Plain text
#: man-pages/man5/proc.5:4114
msgid ""
"Subdirectory containing the pseudo-files and subdirectories for tty drivers "
"and line disciplines."
msgstr "Подкаталог, содержащий псевдо-файлы и подкаталоги драйверов tty и параметры линий."

#. type: TP
#: man-pages/man5/proc.5:4114
#, no-wrap
msgid "I</proc/uptime>"
msgstr "I</proc/uptime>"

#. type: Plain text
#: man-pages/man5/proc.5:4118
msgid ""
"This file contains two numbers: the uptime of the system (seconds), and the "
"amount of time spent in idle process (seconds)."
msgstr "Этот файл содержит два числа: время работы системы с момента загрузки (в секундах) и общее время, которое система провела в состоянии простоя (в секундах)."

#. type: TP
#: man-pages/man5/proc.5:4118
#, no-wrap
msgid "I</proc/version>"
msgstr "I</proc/version>"

#. type: Plain text
#: man-pages/man5/proc.5:4127
msgid ""
"This string identifies the kernel version that is currently running.  It "
"includes the contents of I</proc/sys/kernel/ostype>, "
"I</proc/sys/kernel/osrelease> and I</proc/sys/kernel/version>.  For example:"
msgstr "Строка, идентифицирующая версию ядра, которое запущено в данный момент. Она включает содержимое I</proc/sys/kernel/ostype>, I</proc/sys/kernel/osrelease> и I</proc/sys/kernel/version>. Пример:"

#. type: Plain text
#: man-pages/man5/proc.5:4131
#, no-wrap
msgid ""
"CW<Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994>\n"
msgstr "CW<Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994>\n"

#. type: TP
#: man-pages/man5/proc.5:4139
#, no-wrap
msgid "I</proc/vmstat> (since Linux 2.6)"
msgstr "I</proc/vmstat> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man5/proc.5:4142
msgid "This file displays various virtual memory statistics."
msgstr "Этот файл содержит различную статистику по виртуальной памяти."

#. type: TP
#: man-pages/man5/proc.5:4142
#, no-wrap
msgid "I</proc/zoneinfo> (since Linux 2.6.13)"
msgstr "I</proc/zoneinfo> (начиная с Linux 2.6.13)"

#.  FIXME more should be said about /proc/zoneinfo
#. type: Plain text
#: man-pages/man5/proc.5:4147
msgid ""
"This file display information about memory zones.  This is useful for "
"analyzing virtual memory behavior."
msgstr "Этот файл содержит информацию о зонах памяти. Он полезен при анализе поведения виртуальной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:4154
msgid ""
"Many strings (i.e., the environment and command line) are in the internal "
"format, with subfields terminated by null bytes (\\(aq\\e0\\(aq), so you may"
" find that things are more readable if you use I<od -c> or I<tr \"\\e000\" "
"\"\\en\"> to read them.  Alternatively, I<echo \\`cat E<lt>fileE<gt>\\`> "
"works well."
msgstr "Много строк (например, окружение и командная строка) хранятся во внутреннем формате с полями, завершающимися нулевыми байтами (\\(aq\\e0\\(aq), поэтому они будут более читаемыми, если вы воспользуетесь командой I<od -c> или I<tr \"\\e000\" \"\\en\">. Команда I<echo \\`cat E<lt>fileE<gt>\\`> также хорошо работает."

#.  .SH ACKNOWLEDGEMENTS
#.  The material on /proc/sys/fs and /proc/sys/kernel is closely based on
#.  kernel source documentation files written by Rik van Riel.
#. type: Plain text
#: man-pages/man5/proc.5:4160
msgid ""
"This manual page is incomplete, possibly inaccurate, and is the kind of "
"thing that needs to be updated very often."
msgstr "Данная справочная страница неполна, в ней могут быть неточности и является одной из страниц, которую требуется обновлять очень часто."

#. type: Plain text
#: man-pages/man5/proc.5:4186
msgid ""
"B<cat>(1), B<dmesg>(1), B<find>(1), B<free>(1), B<ps>(1), B<tr>(1), "
"B<uptime>(1), B<chroot>(2), B<mmap>(2), B<readlink>(2), B<syslog>(2), "
"B<slabinfo>(5), B<hier>(7), B<time>(7), B<arp>(8), B<hdparm>(8), "
"B<ifconfig>(8), B<init>(8), B<lsmod>(8), B<lspci>(8), B<mount>(8), "
"B<netstat>(8), B<procinfo>(8), B<route>(8), B<sysctl>(8)"
msgstr "B<cat>(1), B<dmesg>(1), B<find>(1), B<free>(1), B<ps>(1), B<tr>(1), B<uptime>(1), B<chroot>(2), B<mmap>(2), B<readlink>(2), B<syslog>(2), B<slabinfo>(5), B<hier>(7), B<time>(7), B<arp>(8), B<hdparm>(8), B<ifconfig>(8), B<init>(8), B<lsmod>(8), B<lspci>(8), B<mount>(8), B<netstat>(8), B<procinfo>(8), B<route>(8), B<sysctl>(8)"

#. type: Plain text
#: man-pages/man5/proc.5:4193
msgid ""
"The Linux kernel source files: I<Documentation/filesystems/proc.txt> "
"I<Documentation/sysctl/fs.txt>, I<Documentation/sysctl/kernel.txt>, "
"I<Documentation/sysctl/net.txt>, and I<Documentation/sysctl/vm.txt>."
msgstr "Файлы исходного кода ядра Linux: I<Documentation/filesystems/proc.txt> I<Documentation/sysctl/fs.txt>, I<Documentation/sysctl/kernel.txt>, I<Documentation/sysctl/net.txt> и I<Documentation/sysctl/vm.txt>."

#. type: TH
#: man-pages/man5/passwd.5:30
#, no-wrap
msgid "PASSWD"
msgstr "PASSWD"

#. type: TH
#: man-pages/man5/passwd.5:30
#, no-wrap
msgid "2014-02-11"
msgstr "2014-02-11"

#. type: Plain text
#: man-pages/man5/passwd.5:33
msgid "passwd - password file"
msgstr "passwd - файл паролей"

#. type: Plain text
#: man-pages/man5/passwd.5:41
msgid ""
"The I</etc/passwd> file is a text file that describes user login accounts "
"for the system.  It should have read permission allowed for all users (many "
"utilities, like B<ls>(1)  use it to map user IDs to usernames), but write "
"access only for the superuser."
msgstr "В текстовом файле I</etc/passwd> содержится список учётных записей пользователей в системе. Файл должен быть доступен для чтения всем пользователям (многие утилиты, такие как B<ls>(1), используют его, чтобы преобразовывать идентификаторы пользователей в их имена), но доступ на запись должен предоставляться только суперпользователю."

#. type: Plain text
#: man-pages/man5/passwd.5:53
msgid ""
"In the good old days there was no great problem with this general read "
"permission.  Everybody could read the encrypted passwords, but the hardware "
"was too slow to crack a well-chosen password, and moreover the basic "
"assumption used to be that of a friendly user-community.  These days many "
"people run some version of the shadow password suite, where I</etc/passwd> "
"has an \\(aqx\\(aq character in the password field, and the encrypted "
"passwords are in I</etc/shadow>, which is readable by the superuser only."
msgstr "В старые добрые времена не существовало большой проблемы, связанной с доступностью этого файла на чтение для всех. Любой мог прочитать зашифрованные пароли, но мощности компьютеров не хватало для подбора грамотно выбранных паролей, а кроме того, наивно предполагалось, что сеть используется дружественным сообществом пользователей. В наши дни, многие пользователи стали использовать механизм теневых паролей, где файл I</etc/passwd> содержит \\(aqx\\(aq в поле пароля, а зашифрованные пароли хранятся в файле I</etc/shadow>, который доступен на чтение только суперпользователю."

#. type: Plain text
#: man-pages/man5/passwd.5:62
msgid ""
"If the encrypted password, whether in I</etc/passwd> or in I</etc/shadow>, "
"is an empty string, login is allowed without even asking for a password.  "
"Note that this functionality may be intentionally disabled in applications, "
"or configurable (for example using the \"nullok\" or \"nonull\" arguments to"
" pam_unix.so)."
msgstr "Если значение шифрованного пароля, в I</etc/passwd> или I</etc/shadow>, равно пустой строке, то вход будет разрешён без запроса пароля. Заметим, что данной свойство может быть специально отключено в приложениях или может настраиваться (например, с помощью аргументов «nullok» или «nonull»модуля pam_unix.so)."

#. type: Plain text
#: man-pages/man5/passwd.5:67
msgid ""
"If the encrypted password in I</etc/passwd> is \"I<*NP*>\" (without the "
"quotes), the shadow record should be obtained from an NIS+ server."
msgstr "Если значение шифрованного пароля в I</etc/passwd> равно «I<*NP*>» (без кавычек), то теневая запись запрашивается с сервера NIS+."

#. type: Plain text
#: man-pages/man5/passwd.5:73
msgid ""
"Regardless of whether shadow passwords are used, many system administrators "
"use an asterisk (*) in the encrypted password field to make sure that this "
"user can not authenticate him- or herself using a password.  (But see NOTES "
"below.)"
msgstr "Вне зависимости от того, применяется ли механизм теневых паролей или нет, многие системные администраторы ставят звёздочку (*) в поле зашифрованного пароля, чтобы быть уверенными, что данный пользователь не пройдёт аутентификацию, используя какой-либо пароль (но смотри раздел ЗАМЕЧАНИЯ далее)."

#. type: Plain text
#: man-pages/man5/passwd.5:78
msgid ""
"If you create a new login, first put an asterisk (*) in the password field, "
"then use B<passwd>(1)  to set it."
msgstr "Если вы создаёте новую учётную запись, сперва в поле пароля помещается звёздочка (*), а затем с помощью команды B<passwd>(1) вы можете задать пароль."

#. type: Plain text
#: man-pages/man5/passwd.5:81
msgid ""
"Each line of the file describes a single user, and contains seven colon-"
"separated fields:"
msgstr "Каждая строка файла состоит из семи полей, разделённых двоеточием и описывает одного пользователя:"

#. type: Plain text
#: man-pages/man5/passwd.5:84
msgid "name:password:UID:GID:GECOS:directory:shell"
msgstr "имя:пароль:UID:GID:GECOS:каталог:оболочка"

#. type: Plain text
#: man-pages/man5/passwd.5:87
msgid "The field are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man5/passwd.5:87
#, no-wrap
msgid "I<name>"
msgstr "I<имя>"

#. type: Plain text
#: man-pages/man5/passwd.5:91
msgid "This is the user's login name.  It should not contain capital letters."
msgstr "Имя пользователя в системе. Оно не должно содержать букв в верхнем регистре."

#. type: TP
#: man-pages/man5/passwd.5:91
#, no-wrap
msgid "I<password>"
msgstr "I<пароль>"

#. type: Plain text
#: man-pages/man5/passwd.5:98
msgid ""
"This is either the encrypted user password, an asterisk (*), or the letter "
"\\(aqx\\(aq.  (See B<pwconv>(8)  for an explanation of \\(aqx\\(aq.)"
msgstr "Может содержать шифрованный пароль пользователя, звёздочку (*) или букву \\(aqx\\(aq (про \\(aqx\\(aq см. в B<pwconv>(8))."

#. type: TP
#: man-pages/man5/passwd.5:98
#, no-wrap
msgid "I<UID>"
msgstr "I<UID>"

#. type: Plain text
#: man-pages/man5/passwd.5:103
msgid "The privileged I<root> login account (superuser) has the user ID 0."
msgstr "Привилегированная учётная запись I<root> (суперпользователь) имеет идентификатор пользователя равный 0."

#. type: TP
#: man-pages/man5/passwd.5:103
#, no-wrap
msgid "I<GID>"
msgstr "I<GID>"

#. type: Plain text
#: man-pages/man5/passwd.5:108
msgid ""
"This is the numeric primary group ID for this user.  (Additional groups for "
"the user are defined in the system group file; see B<group>(5))."
msgstr "Числовой идентификатор первичной группы (GID) пользователя. Дополнительные группы пользователя могут быть заданы в файле групп системы; смотрите B<group>(5)."

#. type: TP
#: man-pages/man5/passwd.5:108
#, no-wrap
msgid "I<GECOS>"
msgstr "I<GECOS>"

#. type: Plain text
#: man-pages/man5/passwd.5:116
msgid ""
"This field (sometimes called the \"comment field\")  is optional and used "
"only for informational purposes.  Usually, it contains the full username.  "
"Some programs (for example, B<finger>(1))  display information from this "
"field."
msgstr "Данное поле является необязательным и используется только для информационных целей. Обычно, оно содержит полное имя пользователя. Некоторые программы (например, B<finger>(1)) показывают значение этого поля."

#. type: Plain text
#: man-pages/man5/passwd.5:125
msgid ""
"GECOS stands for \"General Electric Comprehensive Operating System\", which "
"was renamed to GCOS when GE's large systems division was sold to Honeywell."
"  Dennis Ritchie has reported: \"Sometimes we sent printer output or batch "
"jobs to the GCOS machine.  The gcos field in the password file was a place "
"to stash the information for the $IDENTcard.  Not elegant.\""
msgstr "GECOS — это аббревиатура от General Electric Comprehensive Operating System, которая была переименована в GCOS, когда подразделение больших систем компании GE было продано компании Honeywell. Денис Ритчи писал: «Иногда мы направляем вывод печати или пачку заданий на GCOS машину. Поле gcos в файле паролей было местом, где хранилась информация для $IDENTcard. Не элегантно.»"

#. type: TP
#: man-pages/man5/passwd.5:125
#, no-wrap
msgid "I<directory>"
msgstr "I<каталог>"

#. type: Plain text
#: man-pages/man5/passwd.5:132
msgid ""
"This is the user's home directory: the initial directory where the user is "
"placed after logging in.  The value in this field is used to set the B<HOME>"
" environment variable."
msgstr "Домашний каталог пользователя: начальный каталог, куда попадает пользователь после входа в систему. Значение данного поля используется для настройки переменной окружения B<HOME>."

#. type: TP
#: man-pages/man5/passwd.5:132
#, no-wrap
msgid "I<shell>"
msgstr "I<оболочка>"

#. type: Plain text
#: man-pages/man5/passwd.5:142
msgid ""
"This is the program to run at login (if empty, use I</bin/sh>).  If set to a"
" nonexistent executable, the user will be unable to login through "
"B<login>(1).  The value in this field is used to set the B<SHELL> "
"environment variable."
msgstr "Это программа, которая запускается после входа в систему (если это поле пустое, то используется I</bin/sh>). Если в поле указан несуществующий исполняемый файл, то пользователь не сможет войти в систему с помощью B<login>(1). Значение данного поля используется для настройки переменной окружения B<SHELL>."

#. type: Plain text
#: man-pages/man5/passwd.5:144
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: man-pages/man5/passwd.5:148
msgid ""
"If you want to create user groups, there must be an entry in I</etc/group>, "
"or no group will exist."
msgstr "Если вы хотите создать группу пользователя, то такая группа должна существовать в файле I</etc/group>, иначе группа не будет существовать."

#. type: Plain text
#: man-pages/man5/passwd.5:162
msgid ""
"If the encrypted password is set to an asterisk (*), the user will be unable"
" to login using B<login>(1), but may still login using B<rlogin>(1), run "
"existing processes and initiate new ones through B<rsh>(1), B<cron>(8), "
"B<at>(1), or mail filters, etc.  Trying to lock an account by simply "
"changing the shell field yields the same result and additionally allows the "
"use of B<su>(1)."
msgstr "Если вместо зашифрованного пароля установлена звёздочка (*), то пользователь не сможет войти в систему, используя команду B<login>(1), но сможет войти в систему, используя B<rlogin>(1), запустить существующие процессы и инициировать новые, используя B<rsh>(1), B<cron>(8), B<at>(1) или почтовые фильтры и т.д. Попытка заблокировать учётную запись простым изменением поля shell, даст тот же результат и в дополнении разрешит использование B<su>(1)."

#. type: Plain text
#: man-pages/man5/passwd.5:170
msgid ""
"B<login>(1), B<passwd>(1), B<su>(1), B<crypt>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<group>(5), B<shadow>(5)"
msgstr "B<login>(1), B<passwd>(1), B<su>(1), B<crypt>(3), B<getpwent>(3), B<getpwnam>(3), B<group>(5), B<shadow>(5)"

#. type: TH
#: man-pages/man3/pthread_detach.3:26
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr "PTHREAD_DETACH"

#. type: TH
#: man-pages/man3/pthread_detach.3:26
#, no-wrap
msgid "2008-11-27"
msgstr "2008-11-27"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:29
msgid "pthread_detach - detach a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:32
#, no-wrap
msgid "B<#include E<lt>pthread.hE<gt>>\n"
msgstr "B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:34
#, no-wrap
msgid "B<int pthread_detach(pthread_t >I<thread>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:37
msgid "Compile and link with I<-pthread>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:46
msgid ""
"The B<pthread_detach>()  function marks the thread identified by I<thread> "
"as detached.  When a detached thread terminates, its resources are "
"automatically released back to the system without the need for another "
"thread to join with the terminated thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:49
msgid ""
"Attempting to detach an already detached thread results in unspecified "
"behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:54
msgid ""
"On success, B<pthread_detach>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:59
msgid "I<thread> is not a joinable thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:64
msgid "No thread with the ID I<thread> could be found."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:70
msgid ""
"Once a thread has been detached, it can't be joined with B<pthread_join>(3)"
"  or be made joinable again."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:77
msgid ""
"A new thread can be created in a detached state using "
"B<pthread_attr_setdetachstate>(3)  to set the detached attribute of the "
"I<attr> argument of B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:84
msgid ""
"The detached attribute merely determines the behavior of the system when the"
" thread terminates; it does not prevent the thread from being terminated if "
"the process terminates using B<exit>(3)  (or equivalently, if the main "
"thread returns)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:93
msgid ""
"Either B<pthread_join>(3)  or B<pthread_detach>()  should be called for each"
" thread that an application creates, so that system resources for the thread"
" can be released.  (But note that the resources of all threads are freed "
"when the process terminates.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:95
msgid "The following statement detaches the calling thread:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:97
#, no-wrap
msgid "    pthread_detach(pthread_self());\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_detach.3:103
msgid ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), "
"B<pthread_create>(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/posix_fallocate.3:25
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr ""

#. type: TH
#: man-pages/man3/posix_fallocate.3:25
#, no-wrap
msgid "2014-06-03"
msgstr ""

#. type: TH
#: man-pages/man3/posix_fallocate.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:28
msgid "posix_fallocate - allocate file space"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:33
#, no-wrap
msgid ""
"B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:42
msgid "B<posix_fallocate>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:61
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:66
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:72
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:77
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr "I<fd> не является допустимым файловым дескриптором или не открыт на запись."

#. type: TP
#: man-pages/man3/posix_fallocate.3:77
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:81
msgid "I<offset+len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:87
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr "I<offset> меньше 0, или I<len> меньше или равна 0."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:91
msgid "I<fd> does not refer to a regular file."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:96
msgid ""
"There is not enough space left on the device containing the file referred to"
" by I<fd>."
msgstr "Недостаточно дискового пространства на устройстве, на котором расположен файл, указанный в I<fd>."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:100
msgid "I<fd> refers to a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:103
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr ""

#. type: SH
#: man-pages/man3/posix_fallocate.3:103
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/posix_fallocate.3:104
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:108
msgid "The B<posix_fallocate>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:133
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:137
msgid "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_cancel.3:26
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_cancel.3:26
#, no-wrap
msgid "2008-11-17"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:29
msgid "pthread_cancel - send a cancellation request to a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:34
#, no-wrap
msgid "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:36
#, no-wrap
msgid "Compile and link with I<-pthread>.\n"
msgstr "Компилируется и компонуется вместе с I<-pthread>.\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:49
msgid ""
"The B<pthread_cancel>()  function sends a cancellation request to the thread"
" I<thread>.  Whether and when the target thread reacts to the cancellation "
"request depends on two attributes that are under the control of that thread:"
" its cancelability I<state> and I<type>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:61
msgid ""
"A thread's cancelability state, determined by B<pthread_setcancelstate>(3), "
"can be I<enabled> (the default for new threads) or I<disabled>.  If a thread"
" has disabled cancellation, then a cancellation request remains queued until"
" the thread enables cancellation.  If a thread has enabled cancellation, "
"then its cancelability type determines when cancellation occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:77
msgid ""
"A thread's cancellation type, determined by B<pthread_setcanceltype>(3), may"
" be either I<asynchronous> or I<deferred> (the default for new threads).  "
"Asynchronous cancelability means that the thread can be canceled at any time"
" (usually immediately, but the system does not guarantee this).  Deferred "
"cancelability means that cancellation will be delayed until the thread next "
"calls a function that is a I<cancellation point>.  A list of functions that "
"are or may be cancellation points is provided in B<pthreads>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:81
msgid ""
"When a cancellation requested is acted on, the following steps occur for "
"I<thread> (in this order):"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:86
msgid ""
"Cancellation clean-up handlers are popped (in the reverse of the order in "
"which they were pushed) and called.  (See B<pthread_cleanup_push>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:91
msgid ""
"Thread-specific data destructors are called, in an unspecified order.  (See "
"B<pthread_key_create>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:95
msgid "The thread is terminated.  (See B<pthread_exit>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:103
msgid ""
"The above steps happen asynchronously with respect to the "
"B<pthread_cancel>()  call; the return status of B<pthread_cancel>()  merely "
"informs the caller whether the cancellation request was successfully queued."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:112
msgid ""
"After a canceled thread has terminated, a join with that thread using "
"B<pthread_join>(3)  obtains B<PTHREAD_CANCELED> as the thread's exit status."
"  (Joining with a thread is the only way to know that cancellation has "
"completed.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:117
msgid ""
"On success, B<pthread_cancel>()  returns 0; on error, it returns a nonzero "
"error number."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:135
msgid ""
"On Linux, cancellation is implemented using signals.  Under the NPTL "
"threading implementation, the first real-time signal (i.e., signal 32) is "
"used for this purpose.  On LinuxThreads, the second real-time signal is "
"used, if real-time signals are available, otherwise B<SIGUSR2> is used."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:141
msgid ""
"The program below creates a thread and then cancels it.  The main thread "
"joins with the canceled thread to check that its exit status was "
"B<PTHREAD_CANCELED>.  The following shell session shows what happens when we"
" run the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:149
#, no-wrap
msgid ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:159
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:162
#, no-wrap
msgid ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:167
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:170
#, no-wrap
msgid ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:174
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:178
#, no-wrap
msgid ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:182
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:184
#, no-wrap
msgid "    /* sleep() is a cancellation point */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:186
#, no-wrap
msgid "    sleep(1000);        /* Should get canceled while we sleep */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:188
#, no-wrap
msgid "    /* Should never get here */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:192
#, no-wrap
msgid ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:199
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:201
#, no-wrap
msgid "    /* Start a thread and then send it a cancellation request */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:205
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:207
#, no-wrap
msgid "    sleep(2);           /* Give thread a chance to get started */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:212
#, no-wrap
msgid ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:214
#, no-wrap
msgid "    /* Join with thread to see what its exit status was */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:218
#, no-wrap
msgid ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:225
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:237
msgid ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/program_invocation_name.3:24
#, no-wrap
msgid "INVOCATION_NAME"
msgstr ""

#. type: TH
#: man-pages/man3/program_invocation_name.3:24
#, no-wrap
msgid "2006-04-29"
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:28
msgid ""
"program_invocation_name, program_invocation_short_name - obtain name used to"
" invoke calling program"
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>errno.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:35
#, no-wrap
msgid ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:46
msgid ""
"I<program_invocation_name> contains the name that was used to invoke the "
"calling program.  This is the same as the value of I<argv[0]> in I<main>(), "
"with the difference that the scope of I<program_invocation_name> is global."
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:53
msgid ""
"I<program_invocation_short_name> contains the basename component of name "
"that was used to invoke the calling program.  That is, it is the same value "
"as I<program_invocation_name>, with all text up to and including the final "
"slash (/), if any, removed."
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:56
msgid ""
"These variables are automatically initialized by the glibc run-time startup "
"code."
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:59
msgid ""
"These variables are GNU extensions, and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:63
msgid ""
"The Linux-specific I</proc/[number]/cmdline> file provides access to similar"
" information."
msgstr ""

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:64
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: man-pages/man3/pthread_testcancel.3:26
#, no-wrap
msgid "PTHREAD_TESTCANCEL"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_testcancel.3:26
#, no-wrap
msgid "2014-05-19"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:29
msgid ""
"pthread_testcancel - request delivery of any pending cancellation request"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:34
#, no-wrap
msgid "B<void pthread_testcancel(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:43
msgid ""
"Calling B<pthread_testcancel>()  creates a cancellation point within the "
"calling thread, so that a thread that is otherwise executing code that "
"contains no cancellation points will respond to a cancellation request."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:50
msgid ""
"If cancelability is disabled (using B<pthread_setcancelstate>(3)), or no "
"cancellation request is pending, then a call to B<pthread_testcancel>()  has"
" no effect."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:54
msgid ""
"This function does not return a value.  If the calling thread is canceled as"
" a consequence of a call to this function, then the function does not "
"return."
msgstr ""

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:58
msgid "This function always succeeds."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:63
msgid "The B<pthread_testcancel>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:68
msgid "See B<pthread_cleanup_push>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:72
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/ptsname.3:7
#, no-wrap
msgid "PTSNAME"
msgstr "PTSNAME"

#. type: Plain text
#: man-pages/man3/ptsname.3:10
msgid "ptsname, ptsname_r - get the name of the slave pseudoterminal"
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:13
#, no-wrap
msgid "B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:15 man-pages/man3/ptsname.3:21
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ptsname.3:17
#, no-wrap
msgid "B<char *ptsname(int >I<fd>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:19
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"

#. type: Plain text
#: man-pages/man3/ptsname.3:23
#, no-wrap
msgid "B<int ptsname_r(int >I<fd>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:30
msgid ""
"The B<ptsname>()  function returns the name of the slave pseudoterminal "
"device corresponding to the master referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:42
msgid ""
"The B<ptsname_r>()  function is the reentrant equivalent of B<ptsname>().  "
"It returns the name of the slave pseudoterminal device as a null-terminated "
"string in the buffer pointed to by I<buf>.  The I<buflen> argument specifies"
" the number of bytes available in I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:49
msgid ""
"On success, B<ptsname>()  returns a pointer to a string in static storage "
"which will be overwritten by subsequent calls.  This pointer must not be "
"freed.  On failure, NULL is returned."
msgstr ""

#.  In fact the errno value is also returned as the function
#.  result -- MTK, Dec 04
#. type: Plain text
#: man-pages/man3/ptsname.3:59
msgid ""
"On success, B<ptsname_r>()  returns 0.  On failure, a nonzero value is "
"returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:66
msgid "(B<ptsname_r>()  only)  I<buf> is NULL."
msgstr ""

#. type: TP
#: man-pages/man3/ptsname.3:66
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: man-pages/man3/ptsname.3:70
msgid "I<fd> does not refer to a pseudoterminal master device."
msgstr ""

#. type: TP
#: man-pages/man3/ptsname.3:70
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man3/ptsname.3:76
msgid "(B<ptsname_r>()  only)  I<buf> is too small."
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:79
msgid "B<ptsname>()  is provided in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:84
msgid "The B<ptsname>()  function is not thread-safe."
msgstr "Функцию B<ptsname>() нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/ptsname.3:88
msgid "The B<ptsname_r>()  function is thread-safe."
msgstr "Функцию B<ptsname_r>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/ptsname.3:93
msgid ""
"B<ptsname>()  is part of the UNIX 98 pseudoterminal support (see B<pts>(4))."
"  This function is specified in POSIX.1-2001."
msgstr "Функция B<ptsname>() является частью поддержки псевдотерминалов UNIX 98 (смотрите B<pts>(4)). Эта функция определена в POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/ptsname.3:101
msgid ""
"B<ptsname_r>()  is a Linux extension.  A version of this function is "
"documented on Tru64 and HP-UX, but on those implementations, -1 is returned "
"on error, with I<errno> set to indicate the error.  Avoid using this "
"function in portable programs."
msgstr ""

#. type: Plain text
#: man-pages/man3/ptsname.3:107
msgid ""
"B<grantpt>(3), B<posix_openpt>(3), B<ttyname>(3), B<unlockpt>(3), B<pts>(4),"
" B<pty>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_getattr_np.3:26
#, no-wrap
msgid "PTHREAD_GETATTR_NP"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_getattr_np.3:26
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:29
msgid "pthread_getattr_np - get attributes of created thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:35
#, no-wrap
msgid ""
"B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t "
"*>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:45
msgid ""
"The B<pthread_getattr_np>()  function initializes the thread attributes "
"object referred to by I<attr> so that it contains actual attribute values "
"describing the running thread I<thread>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:52
msgid ""
"The returned attribute values may differ from the corresponding attribute "
"values passed in the I<attr> object that was used to create the thread using"
" B<pthread_create>(3).  In particular, the following attributes may differ:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:55
msgid ""
"the detach state, since a joinable thread may have detached itself after "
"creation;"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:58
msgid ""
"the stack size, which the implementation may align to a suitable boundary."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:63
msgid ""
"and the guard size, which the implementation may round upward to a multiple "
"of the page size, or ignore (i.e., treat as 0), if the application is "
"allocating its own stack."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:68
msgid ""
"Furthermore, if the stack address attribute was not set in the thread "
"attributes object used to create the thread, then the returned thread "
"attributes object will report the actual stack address that the "
"implementation selected for the thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:73
msgid ""
"When the thread attributes object returned by B<pthread_getattr_np>()  is no"
" longer required, it should be destroyed using B<pthread_attr_destroy>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:76
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number."
msgstr ""

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:81
msgid "Insufficient memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:96
msgid ""
"In addition, if I<thread> refers to the main thread, then "
"B<pthread_getattr_np>()  can fail because of errors from various underlying "
"calls: B<fopen>(3), if I</proc/self/maps> can't be opened; and "
"B<getrlimit>(2), if the B<RLIMIT_STACK> resource limit is not supported."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:98
msgid "This function is available in glibc since version 2.2.3."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:101
msgid ""
"This function is a nonstandard GNU extension; hence the suffix \"_np\" "
"(nonportable) in the name."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:111
msgid ""
"The program below demonstrates the use of B<pthread_getattr_np>().  The "
"program creates a thread that then uses B<pthread_getattr_np>()  to retrieve"
" and display its guard size, stack address, and stack size attributes.  "
"Command-line arguments can be used to set these attributes to values other "
"than the default when creating the thread.  The shell sessions below "
"demonstrate the use of the program."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:114
msgid ""
"In the first run, on an x86-32 system, a thread is created using default "
"attributes:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:124
#, no-wrap
msgid ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:130
msgid ""
"In the following run, we see that if a guard size is specified, it is "
"rounded up to the next multiple of the system page size (4096 bytes on "
"x86-32):"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:138
#, no-wrap
msgid ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:143
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""

#. .in +4n
#. .nf
#. $ ./a.out \-s 0x8000
#. Thread attributes object after initializations:
#.         Guard size          = 4096 bytes
#.         Stack address       = 0xffff8000 (EOS = (nil))
#.         Stack size          = 0x8000 (32768) bytes
#. Attributes of created thread:
#.         Guard size          = 4096 bytes
#.         Stack address       = 0x4001e000 (EOS = 0x40026000)
#.         Stack size          = 0x8000 (32768) bytes
#. .fi
#. .in
#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:162
msgid ""
"In the last run, the program manually allocates a stack for the thread.  In "
"this case, the guard size attribute is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:167
#, no-wrap
msgid ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:172
#, no-wrap
msgid ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:177
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:188
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:198
#, no-wrap
msgid ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:203
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, guard_size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:214
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = 0x%x (%d) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:220
#, no-wrap
msgid ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:224
#, no-wrap
msgid ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:226
#, no-wrap
msgid "    display_stack_related_attributes(&attr, prefix);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:231
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:237
#, no-wrap
msgid ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:240
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:251
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:264
#, no-wrap
msgid ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    long stack_size, guard_size;\n"
"            void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:273
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:276
#, no-wrap
msgid ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:279
#, no-wrap
msgid ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:282
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:287
#, no-wrap
msgid ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:299
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:305
#, no-wrap
msgid ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:311
#, no-wrap
msgid ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:314
#, no-wrap
msgid ""
"    return ret_attrp;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:323
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:325
#, no-wrap
msgid "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:331
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:335
#, no-wrap
msgid ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:341
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:344
#, no-wrap
msgid ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:360
msgid ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_SETAFFINITY_NP"
msgstr "PTHREAD_SETAFFINITY_NP"

#. type: TH
#: man-pages/man3/pthread_setaffinity_np.3:26
#, no-wrap
msgid "2014-05-23"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:30
msgid ""
"pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a "
"thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"
msgstr "B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\nB<                           const cpu_set_t *>I<cpuset>B<);>\nB<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\nB<                           cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:54
msgid ""
"The B<pthread_setaffinity_np>()  function sets the CPU affinity mask of the "
"thread I<thread> to the CPU set pointed to by I<cpuset>.  If the call is "
"successful, and the thread is not currently running on one of the CPUs in "
"I<cpuset>, then it is migrated to one of those CPUs."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:61
msgid ""
"The B<pthread_getaffinity_np>()  function returns the CPU affinity mask of "
"the thread I<thread> in the buffer pointed to by I<cpuset>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:67
msgid ""
"For more details on CPU affinity masks, see B<sched_setaffinity>(2).  For a "
"description of a set of macros that can be used to manipulate and inspect "
"CPU sets, see B<CPU_SET>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:77
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to"
" by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>.  (It may be some other value, if using the macros "
"described in B<CPU_SET>(3)  for dynamically allocating a CPU set.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:80
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number."
msgstr "В случае успеха данные функции возвращают 0, в случае ошибки - ненулевое число."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:84
msgid "A supplied memory address was invalid."
msgstr "Указан некорректный адрес памяти."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:93
msgid ""
"(B<pthread_setaffinity_np>())  The affinity bit mask I<mask> contains no "
"processors that are currently physically on the system and permitted to the "
"thread according to any restrictions that may be imposed by the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""

#.  FIXME . ?
#.  Loic Domaigne commented: it seems that in the future the
#.  kernel developers want to make cpumask_t dynamic, so
#.  CONFIG_NR_CPUS might become obsolete in the future.
#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:109
msgid ""
"(B<pthread_setaffinity_np>())  I<cpuset> specified a CPU that was outside "
"the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:114
msgid ""
"(B<pthread_getaffinity_np>())  I<cpusetsize> is smaller than the size of the"
" affinity mask used by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:121
msgid "These functions are provided by glibc since version 2.3.4."
msgstr "Эти функции определены в glibc начиная с версии 2.3.4."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:128
msgid ""
"The B<pthread_setaffinity_np>()  and B<pthread_getaffinity_np>()  functions "
"are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:131
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np\" "
"(nonportable) in the names."
msgstr "Данные функции являются не стандартизированными расширениями GNU, о чем свидетельствует наличие суффикса \"_np\" (nonportable)."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:144
msgid ""
"After a call to B<pthread_setaffinity_np>(), the set of CPUs on which the "
"thread will actually run is the intersection of the set specified in the "
"I<cpuset> argument and the set of CPUs actually present on the system.  The "
"system may further restrict the set of CPUs on which the thread runs if the "
"\"cpuset\" mechanism described in B<cpuset>(7)  is being used.  These "
"restrictions on the actual set of CPUs on which the thread will run are "
"silently imposed by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:150
msgid ""
"These functions are implemented on top of the B<sched_setaffinity>(2)  and "
"B<sched_getaffinity>(2)  system calls."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:157
msgid ""
"In glibc 2.3.3 only, versions of these functions were provided that did not "
"have a I<cpusetsize> argument.  Instead the CPU set size given to the "
"underlying system calls was always I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:161
msgid ""
"A new thread created by B<pthread_create>(3)  inherits a copy of its "
"creator's CPU affinity mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:169
msgid ""
"In the following program, the main thread uses B<pthread_setaffinity_np>()  "
"to set its CPU affinity mask to include CPUs 0 to 7 (which may not all be "
"available on the system), and then calls B<pthread_getaffinity_np>()  to "
"check the resulting CPU affinity mask of the thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:176
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:186
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, j;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:188
#, no-wrap
msgid "    thread = pthread_self();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:190
#, no-wrap
msgid "    /* Set affinity mask to include CPUs 0 to 7 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:194
#, no-wrap
msgid ""
"    CPU_ZERO(&cpuset);\n"
"    for (j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:198
#, no-wrap
msgid ""
"    s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:200
#, no-wrap
msgid "    /* Check the actual affinity mask assigned to the thread */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:204
#, no-wrap
msgid ""
"    s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:209
#, no-wrap
msgid ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:212
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:220
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_self>(3), B<sched_getcpu>(3), B<cpuset>(7), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_cleanup_push.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_cleanup_push.3:26
#, no-wrap
msgid "2008-11-24"
msgstr "2008-11-24"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:30
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation"
" clean-up handlers"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:48
msgid ""
"These functions manipulate the calling thread's stack of thread-cancellation"
" clean-up handlers.  A clean-up handler is a function that is automatically "
"executed when a thread is canceled (or in various other circumstances "
"described below); it might, for example, unlock a mutex so that it becomes "
"available to other threads in the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:59
msgid ""
"The B<pthread_cleanup_push>()  function pushes I<routine> onto the top of "
"the stack of clean-up handlers.  When I<routine> is later invoked, it will "
"be given I<arg> as its argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:66
msgid ""
"The B<pthread_cleanup_pop>()  function removes the routine at the top of the"
" stack of clean-up handlers, and optionally executes it if I<execute> is "
"nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:69
msgid ""
"A cancellation clean-up handler is popped from the stack and executed in the"
" following circumstances:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:73
msgid ""
"When a thread is canceled, all of the stacked clean-up handlers are popped "
"and executed in the reverse of the order in which they were pushed onto the "
"stack."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:83
msgid ""
"When a thread terminates by calling B<pthread_exit>(3), all clean-up "
"handlers are executed as described in the preceding point.  (Clean-up "
"handlers are I<not> called if the thread terminates by performing a "
"I<return> from the thread start function.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:89
msgid ""
"When a thread calls B<pthread_cleanup_pop>()  with a nonzero I<execute> "
"argument, the top-most clean-up handler is popped and executed."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:101
msgid ""
"POSIX.1 permits B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  to "
"be implemented as macros that expand to text containing \\(aqB<{>\\(aq and "
"\\(aqB<}>\\(aq, respectively.  For this reason, the caller must ensure that "
"calls to these functions are paired within the same function, and at the "
"same lexical nesting level.  (In other words, a clean-up handler is "
"established only during the execution of a specified section of code.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:121
msgid ""
"Calling B<longjmp>(3)  (B<siglongjmp>(3))  produces undefined results if any"
" call has been made to B<pthread_cleanup_push>()  or "
"B<pthread_cleanup_pop>()  without the matching call of the pair since the "
"jump buffer was filled by B<setjmp>(3)  (B<sigsetjmp>(3)).  Likewise, "
"calling B<longjmp>(3)  (B<siglongjmp>(3))  from inside a clean-up handler "
"produces undefined results unless the jump buffer was also filled by "
"B<setjmp>(3)  (B<sigsetjmp>(3))  inside the handler."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:123
msgid "These functions do not return a value."
msgstr ""

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:127
msgid "There are no errors."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:140
msgid ""
"On Linux, the B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  "
"functions I<are> implemented as macros that expand to text containing "
"\\(aqB<{>\\(aq and \\(aqB<}>\\(aq, respectively.  This means that variables "
"declared within the scope of paired calls to these functions will be visible"
" within only that scope."
msgstr ""

#.  The text was actually added in the 2004 TC2
#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:155
msgid ""
"POSIX.1 says that the effect of using I<return>, I<break>, I<continue>, or "
"I<goto> to prematurely leave a block bracketed B<pthread_cleanup_push>()  "
"and B<pthread_cleanup_pop>()  is undefined.  Portable applications should "
"avoid doing this."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:170
msgid ""
"The program below provides a simple example of the use of the functions "
"described in this page.  The program creates a thread that executes a loop "
"bracketed by B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>().  This "
"loop increments a global variable, I<cnt>, once each second.  Depending on "
"what command-line arguments are supplied, the main thread sends the other "
"thread a cancellation request, or sets a global variable that causes the "
"other thread to exit its loop and terminate normally (by doing a I<return>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:173
msgid ""
"In the following shell session, the main thread sends a cancellation request"
" to the other thread:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:183
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:191
msgid ""
"From the above, we see that the thread was canceled, and that the "
"cancellation clean-up handler was called and it reset the value of the "
"global variable I<cnt> to 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:194
msgid ""
"In the next run, the main program sets a global variable that causes other "
"thread to terminate normally:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:202
#, no-wrap
msgid ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:210
msgid ""
"From the above, we see that the clean-up handler was not executed (because "
"I<cleanup_pop_arg> was 0), and therefore the value of I<cnt> was not reset."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:215
msgid ""
"In the next run, the main program sets a global variable that causes the "
"other thread to terminate normally, and supplies a nonzero value for "
"I<cleanup_pop_arg>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:224
#, no-wrap
msgid ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:231
msgid ""
"In the above, we see that although the thread was not canceled, the clean-up"
" handler was executed, because the argument given to "
"B<pthread_cleanup_pop>()  was nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:240
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:247
#, no-wrap
msgid ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:254
#, no-wrap
msgid ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:259
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:261
#, no-wrap
msgid "    printf(\"New thread started\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:263
#, no-wrap
msgid "    pthread_cleanup_push(cleanup_handler, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:265
#, no-wrap
msgid "    curr = start = time(NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:274
#, no-wrap
msgid ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:278
#, no-wrap
msgid ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:285
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:289
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:291
#, no-wrap
msgid "    sleep(2);           /* Allow new thread to run a while */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:296
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:303
#, no-wrap
msgid ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:314
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:320
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_equal.3:26
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:29
msgid "pthread_equal - compare thread IDs"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:34
#, no-wrap
msgid "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:41
msgid "The B<pthread_equal>()  function compares two thread identifiers."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:45
msgid ""
"If the two thread IDs are equal, B<pthread_equal>()  returns a nonzero "
"value; otherwise, it returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:52
msgid "The B<pthread_equal>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:61
msgid ""
"The B<pthread_equal>()  function is necessary because thread IDs should be "
"considered opaque: there is no portable way for applications to directly "
"compare two I<pthread_t> values."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_equal.3:64
msgid "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/psignal.3:30
#, no-wrap
msgid "PSIGNAL"
msgstr ""

#. type: TH
#: man-pages/man3/psignal.3:30
#, no-wrap
msgid "2010-10-06"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:33
msgid "psignal, psiginfo - print signal message"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:36
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/psignal.3:39
#, no-wrap
msgid ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:41
#, no-wrap
msgid "B<extern const char *const >I<sys_siglist>B<[];>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:50
msgid "B<psignal>(): _SVID_SOURCE || _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:53
msgid ""
"B<psiginfo>(): _XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200809L"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:56
msgid "I<sys_siglist>: _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:65
msgid ""
"The B<psignal>()  function displays a message on I<stderr> consisting of the"
" string I<s>, a colon, a space, a string describing the signal number "
"I<sig>, and a trailing newline.  If the string I<s> is NULL or empty, the "
"colon and space are omitted.  If I<sig> is invalid, the message displayed "
"will indicate an unknown signal."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:86
msgid ""
"The B<psiginfo>()  function is like B<psignal>(), except that it displays "
"information about the signal described by I<pinfo>, which should point to a "
"valid I<siginfo_t> structure.  As well as the signal description, "
"B<psiginfo>()  displays information about the origin of the signal, and "
"other information relevant to the signal (e.g., the relevant memory address "
"for hardware-generated signals, the child process ID for B<SIGCHLD>, and the"
" user ID and process ID of the sender, for signals set using B<kill>(2)  or "
"B<sigqueue>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:89
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:95
msgid "The B<psignal>()  and B<psiginfo>()  functions return no value."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:99
msgid "The B<psiginfo>()  function was added to glibc in version 2.10."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:101
msgid "POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:105
msgid "In glibc versions up to 2.12, B<psiginfo>()  had the following bugs:"
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12107
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: man-pages/man3/psignal.3:109
msgid "In some circumstances, a trailing newline is not printed."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12108
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: man-pages/man3/psignal.3:113
msgid "Additional details are not displayed for real-time signals."
msgstr ""

#. type: Plain text
#: man-pages/man3/psignal.3:117
msgid "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pow.3:35
#, no-wrap
msgid "POW"
msgstr "POW"

#. type: TH
#: man-pages/man3/pow.3:35
#, no-wrap
msgid "2010-09-12"
msgstr "2010-09-12"

#. type: Plain text
#: man-pages/man3/pow.3:38
msgid "pow, powf, powl - power functions"
msgstr "pow, powf, powl - функции возведения в степень"

#. type: Plain text
#: man-pages/man3/pow.3:41
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pow.3:43
#, no-wrap
msgid "B<double pow(double >I<x>B<, double >I<y>B<);>\n"
msgstr "B<double pow(double >I<x>B<, double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow.3:45
#, no-wrap
msgid "B<float powf(float >I<x>B<, float >I<y>B<);>\n"
msgstr "B<float powf(float >I<x>B<, float >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow.3:47
#, no-wrap
msgid "B<long double powl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr "B<long double powl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow.3:50
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/pow.3:59
msgid "B<powf>(), B<powl>():"
msgstr "B<powf>(), B<powl>():"

#. type: Plain text
#: man-pages/man3/pow.3:62
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/pow.3:65
msgid "or I<cc\\ -std=c99>"
msgstr "или I<cc\\ -std=c99>"

#. type: Plain text
#: man-pages/man3/pow.3:75
msgid ""
"The B<pow>()  function returns the value of I<x> raised to the power of "
"I<y>."
msgstr "Функция B<pow>() возвращает значение I<x>, возведённое в степень I<y>."

#. type: Plain text
#: man-pages/man3/pow.3:80
msgid ""
"On success, these functions return the value of I<x> to the power of I<y>."
msgstr "При успешном выполнении данные функции возвращают значение I<x>, возведённое в степень I<y>."

#.  The domain error is generated at least as far back as glibc 2.4
#. type: Plain text
#: man-pages/man3/pow.3:88
msgid ""
"If I<x> is a finite value less than 0, and I<y> is a finite noninteger, a "
"domain error occurs, and a NaN is returned."
msgstr "Если I<x> — конечное значение меньшее 0 и I<y> — конечное не целое, то будет сгенерирована ошибка выхода за пределы области, а в качестве результата будет возвращено NaN."

#.  The range error is generated at least as far back as glibc 2.4
#. type: Plain text
#: man-pages/man3/pow.3:98
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the "
"mathematically correct sign."
msgstr "Если происходит переполнение результата, возникает ошибка диапазона, а функция возвращает B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, соответственно, с математически правильным знаком."

#.  POSIX.1 does not specify the sign of the zero,
#.  but http://sources.redhat.com/bugzilla/show_bug.cgi?id=2678
#.  points out that the zero has the wrong sign in some cases.
#. type: Plain text
#: man-pages/man3/pow.3:105
msgid ""
"If result underflows, and is not representable, a range error occurs, and "
"0.0 is returned."
msgstr "Если в результате исчезает порядок числа и он не представим, то возникает ошибка диапазона и возвращается 0.0."

#. type: Plain text
#: man-pages/man3/pow.3:111
msgid ""
"Except as specified below, if I<x> or I<y> is a NaN, the result is a NaN."
msgstr "За исключениями, указанными далее, если значение I<x> или I<y> равно NaN, то результат равен NaN."

#. type: Plain text
#: man-pages/man3/pow.3:117
msgid "If I<x> is +1, the result is 1.0 (even if I<y> is a NaN)."
msgstr "Если I<x> равно +1, то результат равен 1.0 (даже если I<y> равно NaN)."

#. type: Plain text
#: man-pages/man3/pow.3:123
msgid "If I<y> is 0, the result is 1.0 (even if I<x> is a NaN)."
msgstr "Если I<y> равно 0, то результат равен 1.0 (даже если I<x> равно NaN)."

#. type: Plain text
#: man-pages/man3/pow.3:131
msgid ""
"If I<x> is +0 (-0), and I<y> is an odd integer greater than 0, the result is"
" +0 (-0)."
msgstr "Если I<x> равно +0 (-0) и I<y> — нечётное целое большее 0, то результат равен +0 (-0)."

#. type: Plain text
#: man-pages/man3/pow.3:139
msgid ""
"If I<x> is 0, and I<y> greater than 0 and not an odd integer, the result is "
"+0."
msgstr "Если I<x> равно 0 и I<y> больше 0 и не чётное целое, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:147
msgid ""
"If I<x> is -1, and I<y> is positive infinity or negative infinity, the "
"result is 1.0."
msgstr "Если I<x> равно -1 и I<y> стремится к плюс или минус бесконечности, то результат равен 1.0."

#. type: Plain text
#: man-pages/man3/pow.3:155
msgid ""
"If the absolute value of I<x> is less than 1, and I<y> is negative infinity,"
" the result is positive infinity."
msgstr "Если абсолютное значение I<x> меньше 1 и I<y> стремится к минус бесконечности, то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:163
msgid ""
"If the absolute value of I<x> is greater than 1, and I<y> is negative "
"infinity, the result is +0."
msgstr "Если абсолютное значение I<x> больше 1 и I<y> стремится к минус бесконечности, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:171
msgid ""
"If the absolute value of I<x> is less than 1, and I<y> is positive infinity,"
" the result is +0."
msgstr "Если абсолютное значение I<x> меньше 1 и I<y> стремится к плюс бесконечности, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:179
msgid ""
"If the absolute value of I<x> is greater than 1, and I<y> is positive "
"infinity, the result is positive infinity."
msgstr "Если абсолютное значение I<x> больше 1 и I<y> стремится к плюс бесконечности, то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:187
msgid ""
"If I<x> is negative infinity, and I<y> is an odd integer less than 0, the "
"result is -0."
msgstr "Если I<x> стремится к минус бесконечности и I<y> — нечётное целое меньшее 0, то результат равен -0."

#. type: Plain text
#: man-pages/man3/pow.3:195
msgid ""
"If I<x> is negative infinity, and I<y> less than 0 and not an odd integer, "
"the result is +0."
msgstr "Если I<x> стремится к минус бесконечности и I<y> — меньше 0 и чётное целое, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:203
msgid ""
"If I<x> is negative infinity, and I<y> is an odd integer greater than 0, the"
" result is negative infinity."
msgstr "Если I<x> стремится к минус бесконечности и I<y> — нечётное целое большее 0, то результат стремится к минус бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:211
msgid ""
"If I<x> is negative infinity, and I<y> greater than 0 and not an odd "
"integer, the result is positive infinity."
msgstr "Если I<x> стремится к минус бесконечности и I<y> — больше 0 и чётное целое, то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:219
msgid "If I<x> is positive infinity, and I<y> less than 0, the result is +0."
msgstr "Если I<x> стремится к плюс бесконечности и I<y> — меньше 0, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:227
msgid ""
"If I<x> is positive infinity, and I<y> greater than 0, the result is "
"positive infinity."
msgstr "Если I<x> стремится к плюс бесконечности и I<y> — больше 0, то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:242
msgid ""
"If I<x> is +0 or -0, and I<y> is an odd integer less than 0, a pole error "
"occurs and B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, is returned, with the"
" same sign as I<x>."
msgstr "Если I<x> равно +0 или -0 и I<y> — нечётное целое меньшее 0, то генерируется ошибка особой точки и возвращается B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>с тем же знаком что и у I<x>."

#.  The pole error is generated at least as far back as glibc 2.4
#. type: Plain text
#: man-pages/man3/pow.3:256
msgid ""
"If I<x> is +0 or -0, and I<y> is less than 0 and not an odd integer, a pole "
"error occurs and +B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, is returned."
msgstr "Если I<x> равно + или -0 и I<y> — меньше 0 и чётное целое, то генерируется ошибка особой точки и возвращается +B<HUGE_VAL>, +B<HUGE_VALF> или +B<HUGE_VALL>."

#.  FIXME . review status of this error
#.  longstanding bug report for glibc:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=369
#.  For negative x, and -large and +large y, glibc 2.8 gives incorrect
#.  results
#.  pow(-0.5,-DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-overflow (ERANGE, FE_OVERFLOW); +INF)
#.  pow(-1.5,-DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-underflow (ERANGE, FE_UNDERFLOW); +0)
#.  pow(-0.5,DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-underflow (ERANGE, FE_UNDERFLOW); +0)
#.  pow(-1.5,DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-overflow (ERANGE, FE_OVERFLOW); +INF)
#. type: Plain text
#: man-pages/man3/pow.3:281
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr "Смотрите B<math_error>(7), чтобы определить, где возникла ошибка при вызове этих функций."

#. type: Plain text
#: man-pages/man3/pow.3:283
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/pow.3:283
#, no-wrap
msgid "Domain error: I<x> is negative, and I<y> is a finite noninteger"
msgstr "Ошибка области: I<x> является отрицательным и I<y> конечное нецелое"

#. type: Plain text
#: man-pages/man3/pow.3:291
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr "I<errno> устанавливается в B<EDOM>. Возникает исключение неправильной плавающей запятой (B<FE_INVALID>)."

#. type: TP
#: man-pages/man3/pow.3:291
#, no-wrap
msgid "Pole error: I<x> is zero, and I<y> is negative"
msgstr "Ошибка особой точки: I<x> равно нулю и I<y> отрицательно"

#. type: Plain text
#: man-pages/man3/pow.3:300
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  A divide-by-zero floating-"
"point exception (B<FE_DIVBYZERO>)  is raised."
msgstr "I<errno> устанавливается в B<ERANGE> (но смотрите ДЕФЕКТЫ). Возникает исключение деления плавающей запятой на ноль (B<FE_DIVBYZERO>)."

#. type: TP
#: man-pages/man3/pow.3:300
#, no-wrap
msgid "Range error: the result overflows"
msgstr "Ошибка диапазона: результат превысил разрядность"

#. type: Plain text
#: man-pages/man3/pow.3:308
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr "Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение переполнения плавающей запятой (B<FE_OVERFLOW>)."

#. type: TP
#: man-pages/man3/pow.3:308
#, no-wrap
msgid "Range error: the result underflows"
msgstr "Ошибка диапазона: результат потерял разрядность"

#. type: Plain text
#: man-pages/man3/pow.3:316
msgid ""
"I<errno> is set to B<ERANGE>.  An underflow floating-point exception "
"(B<FE_UNDERFLOW>)  is raised."
msgstr "Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение исчезновение порядка плавающей запятой (B<FE_UNDERFLOW>)."

#. type: Plain text
#: man-pages/man3/pow.3:322
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD, C89."
msgstr "C99, POSIX.1-2001. Вариант, возвращающий значение типа I<double>, также соответствует SVr4, 4.3BSD и C89."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6776
#.  or possibly 2.9, I haven't found the source code change
#.  and I don't have a 2.9 system to test
#. type: Plain text
#: man-pages/man3/pow.3:336
msgid ""
"In glibc 2.9 and earlier, when a pole error occurs, I<errno> is set to "
"B<EDOM> instead of the POSIX-mandated B<ERANGE>.  Since version 2.10, glibc "
"does the right thing."
msgstr "В glibc 2.9 и ранее при возникновении ошибки особой точки, значению I<errno> присваивается B<EDOM> вместо B<ERANGE> согласно POSIX. Начиная с версии 2.10, в glibc это исправлено."

#.  see bug http://sources.redhat.com/bugzilla/show_bug.cgi?id=3866
#.  and http://sources.redhat.com/bugzilla/show_bug.cgi?id=369
#. type: Plain text
#: man-pages/man3/pow.3:356
msgid ""
"If I<x> is negative, then large negative or positive I<y> values yield a NaN"
" as the function result, with I<errno> set to B<EDOM>, and an invalid "
"(B<FE_INVALID>)  floating-point exception.  For example, with B<pow>(), one "
"sees this behavior when the absolute value of I<y> is greater than about "
"9.223373e18."
msgstr "Если I<x> отрицательно, то большие отрицательные или положительные значения I<y> приводят к результату NaN, с присвоением I<errno> значения B<EDOM> или  исключению неправильной плавающей запятой (B<FE_INVALID>). Например для B<pow>() такое случает когда абсолютное значение I<y> больше 9.223373e18."

#.  FIXME . Actually, 2.3.2 is the earliest test result I have; so yet
#.  to confirm if this error occurs only in 2.3.2.
#. type: Plain text
#: man-pages/man3/pow.3:365
msgid ""
"In version 2.3.2 and earlier, when an overflow or underflow error occurs, "
"glibc's B<pow>()  generates a bogus invalid floating-point exception "
"(B<FE_INVALID>)  in addition to the overflow or underflow exception."
msgstr "В glibc версии 2.3.2 или старее при возникновении ошибки переполнения или потери разрядов функция B<pow>() кроме исключения переполнения или потери генерирует необоснованное исключение неправильной плавающей запятой (B<FE_INVALID>)."

#. type: Plain text
#: man-pages/man3/pow.3:368
msgid "B<cbrt>(3), B<cpow>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cpow>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/pthread_attr_setstacksize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKSIZE"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_attr_setstacksize.3:26
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:30
msgid ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(const pthread_attr_t *>I<attr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:49
msgid ""
"The B<pthread_attr_setstacksize>()  function sets the stack size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<stacksize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:53
msgid ""
"The stack size attribute determines the minimum size (in bytes) that will be"
" allocated for threads created using the thread attributes object I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:61
msgid ""
"The B<pthread_attr_getstacksize>()  function returns the stack size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stacksize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:67
msgid "B<pthread_attr_setstacksize>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:72
msgid "The stack size is less than B<PTHREAD_STACK_MIN> (16384) bytes."
msgstr ""

#.  e.g., MacOS
#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:81
msgid ""
"On some systems, B<pthread_attr_setstacksize>()  can fail with the error "
"B<EINVAL> if I<stacksize> is not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:83
msgid "These functions are provided by glibc since version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:90
msgid ""
"The B<pthread_attr_setstacksize>()  and B<pthread_attr_getstacksize>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:95
msgid ""
"For details on the default stack size of new threads, see "
"B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:98
msgid ""
"A thread's stack size is fixed at the time of thread creation.  Only the "
"main thread can dynamically grow its stack."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:103
msgid ""
"The B<pthread_attr_setstack>(3)  function allows an application to set both "
"the size and location of a caller-allocated stack that is to be used by a "
"thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:115
msgid ""
"As at glibc 2.8, if the specified I<stacksize> is not a multiple of "
"B<STACK_ALIGN> (16 bytes on most architectures), it may be rounded "
"I<downward>, in violation of POSIX.1-2001, which says that the allocated "
"stack will be at least I<stacksize> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:118
msgid "See B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:124
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pow10.3:25
#, no-wrap
msgid "POW10"
msgstr "POW10"

#. type: TH
#: man-pages/man3/pow10.3:25
#, no-wrap
msgid "2008-08-11"
msgstr "2008-08-11"

#. type: Plain text
#: man-pages/man3/pow10.3:28
msgid "pow10, pow10f, pow10l - base-10 power functions"
msgstr "pow10, pow10f, pow10l - функция возведения числа 10 в степень"

#. type: Plain text
#: man-pages/man3/pow10.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pow10.3:34
#, no-wrap
msgid "B<double pow10(double >I<x>B<);>\n"
msgstr "B<double pow10(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow10.3:36
#, no-wrap
msgid "B<float pow10f(float >I<x>B<);>\n"
msgstr "B<float pow10f(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow10.3:38
#, no-wrap
msgid "B<long double pow10l(long double >I<x>B<);>\n"
msgstr "B<long double pow10l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow10.3:47
msgid ""
"The B<pow10>()  function returns the value of 10 raised to the power I<x>."
msgstr "Функция B<pow10>() возвращает 10 в степени I<x>."

#. type: Plain text
#: man-pages/man3/pow10.3:49
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/pow10.3:51
msgid "This is a GNU extension."
msgstr "Это расширение GNU."

#. type: Plain text
#: man-pages/man3/pow10.3:54
msgid ""
"These functions are identical to the functions listed under B<exp10>(3)."
msgstr "Данные функции идентичны функциям, перечисленным в B<exp10>(3)."

#. type: Plain text
#: man-pages/man3/pow10.3:56
msgid "B<exp10>(3), B<pow>(3)"
msgstr "B<exp10>(3), B<pow>(3)"

#. type: TH
#: man-pages/man3/pthread_attr_setstackaddr.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKADDR"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:30
msgid ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address"
" attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(const pthread_attr_t *>I<attr>B<, void **>I<stackaddr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:49
msgid ""
"These functions are obsolete: B<do not use them.> Use "
"B<pthread_attr_setstack>(3)  and B<pthread_attr_getstack>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:60
msgid ""
"The B<pthread_attr_setstackaddr>()  function sets the stack address "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<stackaddr>.  This attribute specifies the location of "
"the stack that should be used by a thread that is created using the thread "
"attributes object I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:66
msgid ""
"I<stackaddr> should point to a buffer of at least B<PTHREAD_STACK_MIN> bytes"
" that was allocated by the caller.  The pages of the allocated buffer should"
" be both readable and writable."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:74
msgid ""
"The B<pthread_attr_getstackaddr>()  function returns the stack address "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stackaddr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:81
msgid ""
"No errors are defined (but applications should nevertheless handle a "
"possible error return)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:90
msgid ""
"The B<pthread_attr_setstackaddr>()  and B<pthread_attr_getstackaddr>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:93
msgid ""
"POSIX.1-2001 specifies these functions but marks them as obsolete.  "
"POSIX.1-2008 removes the specification of these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:117
msgid ""
"I<Do not use these functions!> They cannot be portably used, since they "
"provide no way of specifying the direction of growth or the range of the "
"stack.  For example, on architectures with a stack that grows downward, "
"I<stackaddr> specifies the next address past the I<highest> address of the "
"allocated stack area.  However, on architectures with a stack that grows "
"upward, I<stackaddr> specifies the I<lowest> address in the allocated stack "
"area.  By contrast, the I<stackaddr> used by B<pthread_attr_setstack>(3)  "
"and B<pthread_attr_getstack>(3), is always a pointer to the lowest address "
"in the allocated stack area (and the I<stacksize> argument specifies the "
"range of the stack)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:122
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_setconcurrency.3:25
#, no-wrap
msgid "PTHREAD_SETCONCURRENCY"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:29
msgid ""
"pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency "
"level"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:35
#, no-wrap
msgid ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:48
msgid ""
"The B<pthread_setconcurrency>()  function informs the implementation of the "
"application's desired concurrency level, specified in I<new_level>.  The "
"implementation takes this only as a hint: POSIX.1 does not specify the level"
" of concurrency that should be provided as a result of calling "
"B<pthread_setconcurrency>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:53
msgid ""
"Specifying I<new_level> as 0 instructs the implementation to manage the "
"concurrency level as it deems appropriate."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:56
msgid ""
"B<pthread_getconcurrency>()  returns the current value of the concurrency "
"level for this process."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:61
msgid ""
"On success, B<pthread_setconcurrency>()  returns 0; on error, it returns a "
"nonzero error number."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:68
msgid ""
"B<pthread_getconcurrency>()  always succeeds, returning the concurrency "
"level set by a previous call to B<pthread_setconcurrency>(), or 0, if "
"B<pthread_setconcurrency>()  has not previously been called."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:71
msgid "B<pthread_setconcurrency>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:75
msgid "I<new_level> is negative."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:81
msgid ""
"POSIX.1-2001 also documents an B<EAGAIN> error (\"the value specified by "
"I<new_level> would cause a system resource to be exceeded\")."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:83
msgid "These functions are available in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:90
msgid ""
"The B<pthread_setconcurrency>()  and B<pthread_getconcurrency>()  functions "
"are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:94
msgid "The default concurrency level is 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:101
msgid ""
"Concurrency levels are meaningful only for M:N threading implementations, "
"where at any moment a subset of a process's set of user-level threads may be"
" bound to a smaller number of kernel-scheduling entities.  Setting the "
"concurrency level allows the application to give the system a hint as to the"
" number of kernel-scheduling entities that should be provided for efficient "
"execution of the application."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:107
msgid ""
"Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the"
" concurrency level has no meaning.  In other words, on Linux these functions"
" merely exist for compatibility with other systems, and they have no effect "
"on the execution of a program."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:109
msgid "B<pthread_attr_setscope>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_setscope>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_init.3:26
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr "PTHREAD_ATTR_INIT"

#. type: TH
#: man-pages/man3/pthread_attr_init.3:26
#, no-wrap
msgid "2008-11-11"
msgstr "2008-11-11"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:30
msgid ""
"pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
"attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"
msgstr "B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\nB<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:50
msgid ""
"The B<pthread_attr_init>()  function initializes the thread attributes "
"object pointed to by I<attr> with default attribute values.  After this "
"call, individual attributes of the object can be set using various related "
"functions (listed under SEE ALSO), and then the object can be used in one or"
" more B<pthread_create>(3)  calls that create threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:55
msgid ""
"Calling B<pthread_attr_init>()  on a thread attributes object that has "
"already been initialized results in undefined behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:62
msgid ""
"When a thread attributes object is no longer required, it should be "
"destroyed using the B<pthread_attr_destroy>()  function.  Destroying a "
"thread attributes object has no effect on threads that were created using "
"that object."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:68
msgid ""
"Once a thread attributes object has been destroyed, it can be reinitialized "
"using B<pthread_attr_init>().  Any other use of a destroyed thread "
"attributes object has undefined results."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:79
msgid ""
"POSIX.1-2001 documents an B<ENOMEM> error for B<pthread_attr_init>(); on "
"Linux these functions always succeed (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:87
msgid ""
"The I<pthread_attr_t> type should be treated as opaque: any access to the "
"object other than via pthreads functions is nonportable and produces "
"undefined results."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:96
msgid ""
"The program below optionally makes use of B<pthread_attr_init>()  and "
"various related functions to initialize a thread attributes object that is "
"used to create a single thread.  Once created, the thread uses the "
"B<pthread_getattr_np>(3)  function (a nonstandard GNU extension) to retrieve"
" the thread's attributes, and then displays those attributes."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:105
msgid ""
"If the program is run with no command-line argument, then it passes NULL as "
"the I<attr> argument of B<pthread_create>(3), so that the thread is created "
"with default attributes.  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:121
#, no-wrap
msgid ""
"$B< ulimit -s>       # No stack imit ==E<gt> default stack size is 2MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:131
msgid ""
"When we supply a stack size as a command-line argument, the program "
"initializes a thread attributes object, sets various attributes in that "
"object, and passes a pointer to the object in the call to "
"B<pthread_create>(3).  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:146
#, no-wrap
msgid ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:168
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"
msgstr "static void\ndisplay_pthread_attr(pthread_attr_t *attr, char *prefix)\n{\n    int s, i;\n    size_t v;\n    void *stkaddr;\n    struct sched_param sp;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:176
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:184
#, no-wrap
msgid ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:192
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:201
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:206
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:211
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, v);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:218
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = 0x%x bytes\\en\", prefix, v);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:224
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:228
#, no-wrap
msgid ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:232
#, no-wrap
msgid ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:235
#, no-wrap
msgid ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:246
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:248
#, no-wrap
msgid "    attrp = NULL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:252
#, no-wrap
msgid ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:256
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        int stack_size;\n"
"        void *sp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:258
#, no-wrap
msgid "        attrp = &attr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:262
#, no-wrap
msgid ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:266
#, no-wrap
msgid ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:270
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:272
#, no-wrap
msgid "        stack_size = strtoul(argv[1], NULL, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:276
#, no-wrap
msgid ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:278
#, no-wrap
msgid "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:283
#, no-wrap
msgid ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:312
msgid ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthread_getattr_np>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), B<pthread_attr_setstack>(3), B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthread_getattr_np>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/perror.3:31
#, no-wrap
msgid "PERROR"
msgstr "PERROR"

#. type: Plain text
#: man-pages/man3/perror.3:34
msgid "perror - print a system error message"
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:36
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/perror.3:38
msgid "B<void perror(const char *>I<s>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:40
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr "B<#include E<lt>errno.hE<gt>>"

#. type: Plain text
#: man-pages/man3/perror.3:42
msgid "B<const char * const >I<sys_errlist>B<[];>"
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:44
msgid "B<int >I<sys_nerr>B<;>"
msgstr "B<int >I<sys_nerr>B<;>"

#. type: Plain text
#: man-pages/man3/perror.3:46
msgid "B<int >I<errno>B<; /* Not really declared this way; see errno(3). */>"
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:55
msgid "I<sys_errlist>, I<sys_nerr>: _BSD_SOURCE"
msgstr "I<sys_errlist>, I<sys_nerr>: _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/perror.3:68
msgid ""
"The routine B<perror>()  produces a message on the standard error output, "
"describing the last error encountered during a call to a system or library "
"function.  First (if I<s> is not NULL and I<*s> is not a null byte "
"(\\(aq\\e0\\(aq)) the argument string I<s> is printed, followed by a colon "
"and a blank.  Then the message and a new-line."
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:76
msgid ""
"To be of most use, the argument string should include the name of the "
"function that incurred the error.  The error number is taken from the "
"external variable I<errno>, which is set when errors occur but not cleared "
"when successful calls are made."
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:90
msgid ""
"The global error list I<sys_errlist>[] indexed by I<errno> can be used to "
"obtain the error message without the newline.  The largest message number "
"provided in the table is I<sys_nerr>-1.  Be careful when directly accessing "
"this list because new error values may not have been added to "
"I<sys_errlist>[].  The use of I<sys_errlist>[] is nowadays deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:111
msgid ""
"When a system call fails, it usually returns -1 and sets the variable "
"I<errno> to a value describing what went wrong.  (These values can be found "
"in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The function"
" B<perror>()  serves to translate this error code into human-readable form."
"  Note that I<errno> is undefined after a successful library call: this call"
" may well change this variable, even though it succeeds, for example because"
" it internally used some other library function that failed.  Thus, if a "
"failing call is not immediately followed by a call to B<perror>(), the value"
" of I<errno> should be saved."
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:124
msgid ""
"The function B<perror>()  and the external I<errno> (see B<errno>(3))  "
"conform to C89, C99, 4.3BSD, POSIX.1-2001.  The externals I<sys_nerr> and "
"I<sys_errlist> conform to BSD."
msgstr ""

#.  and only when _BSD_SOURCE is defined.
#.  When
#.  .B _GNU_SOURCE
#.  is defined, the symbols
#.  .I _sys_nerr
#.  and
#.  .I _sys_errlist
#.  are provided.
#. type: Plain text
#: man-pages/man3/perror.3:139
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/perror.3:143
msgid "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"
msgstr "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/putgrent.3:7
#, no-wrap
msgid "PUTGRENT"
msgstr "PUTGRENT"

#. type: TH
#: man-pages/man3/putgrent.3:7
#, no-wrap
msgid "2003-09-09"
msgstr "2003-09-09"

#. type: Plain text
#: man-pages/man3/putgrent.3:10
msgid "putgrent - write a group database entry to a file"
msgstr ""

#. type: Plain text
#: man-pages/man3/putgrent.3:12
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man3/putgrent.3:14
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr "B<#include E<lt>grp.hE<gt>>"

#. type: Plain text
#: man-pages/man3/putgrent.3:16
msgid "B<int putgrent(const struct group *>I<grp>B<, FILE *>I<fp>B<);>"
msgstr "B<int putgrent(const struct group *>I<grp>B<, FILE *>I<fp>B<);>"

#. type: Plain text
#: man-pages/man3/putgrent.3:27
msgid ""
"The B<putgrent>()  function is the counterpart for B<fgetgrent>(3).  The "
"function writes the content of the provided I<struct group> into the file "
"pointed to by I<fp>.  The list of group members must be NULL-terminated or "
"NULL-initialized."
msgstr ""

#. type: Plain text
#: man-pages/man3/putgrent.3:31
msgid "The I<struct group> is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/putgrent.3:40
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;      /* group name */\n"
"    char   *gr_passwd;    /* group password */\n"
"    gid_t   gr_gid;       /* group ID */\n"
"    char  **gr_mem;       /* group members */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/putgrent.3:44
msgid "The function returns zero on success, and a nonzero value on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/putgrent.3:46
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/putgrent.3:49
msgid "B<fgetgrent>(3), B<getgrent>(3), B<group>(5)"
msgstr "B<fgetgrent>(3), B<getgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/pthread_attr_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETAFFINITY_NP"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:30
msgid ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU "
"affinity attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:54
msgid ""
"The B<pthread_attr_setaffinity_np>()  function sets the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<cpuset>.  This attribute determines the CPU affinity "
"mask of a thread created using the thread attributes object I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:63
msgid ""
"The B<pthread_attr_getaffinity_np>()  function returns the CPU affinity mask"
" attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<cpuset>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:70
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to"
" by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>."
msgstr ""

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:92
msgid ""
"(B<pthread_attr_setaffinity_np>())  I<cpuset> specified a CPU that was "
"outside the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:102
msgid ""
"(B<pthread_attr_getaffinity_np>())  A CPU in the affinity mask of the thread"
" attributes object referred to by I<attr> lies outside the range specified "
"by I<cpusetsize> (i.e., I<cpuset>/I<cpusetsize> is too small)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:106
msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:123
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"
msgstr "B<sched_setaffinity>(2), B<pthread_attr_init>(3), B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setscope.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCOPE"
msgstr "PTHREAD_ATTR_SETSCOPE"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:30
msgid ""
"pthread_attr_setscope, pthread_attr_getscope - set/get contention scope "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:53
msgid ""
"The B<pthread_attr_setscope>()  function sets the contention scope attribute"
" of the thread attributes object referred to by I<attr> to the value "
"specified in I<scope>.  The contention scope attribute defines the set of "
"threads against which a thread competes for resources such as the CPU.  "
"POSIX.1-2001 specifies two possible values for I<scope>:"
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setscope.3:53
#, no-wrap
msgid "B<PTHREAD_SCOPE_SYSTEM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:61
msgid ""
"The thread competes for resources with all other threads in all processes on"
" the system that are in the same scheduling allocation domain (a group of "
"one or more processors).  B<PTHREAD_SCOPE_SYSTEM> threads are scheduled "
"relative to one another according to their scheduling policy and priority."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setscope.3:61
#, no-wrap
msgid "B<PTHREAD_SCOPE_PROCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:76
msgid ""
"The thread competes for resources with all other threads in the same process"
" that were also created with the B<PTHREAD_SCOPE_PROCESS> contention scope."
"  B<PTHREAD_SCOPE_PROCESS> threads are scheduled relative to other threads "
"in the process according to their scheduling policy and priority.  "
"POSIX.1-2001 leaves it unspecified how these threads contend with other "
"threads in other process on the system or with other threads in the same "
"process that were created with the B<PTHREAD_SCOPE_SYSTEM> contention scope."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:83
msgid ""
"POSIX.1-2001 requires that an implementation support at least one of these "
"contention scopes.  Linux supports B<PTHREAD_SCOPE_SYSTEM>, but not "
"B<PTHREAD_SCOPE_PROCESS>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:95
msgid ""
"On systems that support multiple contention scopes, then, in order for the "
"parameter setting made by B<pthread_attr_setscope>()  to have effect when "
"calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:103
msgid ""
"The B<pthread_attr_getscope>()  function returns the contention scope "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<scope>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:109
msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:113
msgid "An invalid value was specified in I<scope>."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setscope.3:113
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:119
msgid ""
"I<scope> specified the value B<PTHREAD_SCOPE_PROCESS>, which is not "
"supported on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:126
msgid ""
"The B<pthread_attr_setscope>()  and B<pthread_attr_getscope>()  functions "
"are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:136
msgid ""
"The B<PTHREAD_SCOPE_SYSTEM> contention scope typically indicates that a "
"user-space thread is bound directly to a single kernel-scheduling entity.  "
"This is the case on Linux for the obsolete LinuxThreads implementation and "
"the modern NPTL implementation, which are both 1:1 threading "
"implementations."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:139
msgid ""
"POSIX.1-2001 specifies that the default contention scope is implementation-"
"defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:148
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_exit.3:26
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:29
msgid "pthread_exit - terminate calling thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:34
#, no-wrap
msgid "B<void pthread_exit(void *>I<retval>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:45
msgid ""
"The B<pthread_exit>()  function terminates the calling thread and returns a "
"value via I<retval> that (if the thread is joinable)  is available to "
"another thread in the same process that calls B<pthread_join>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:55
msgid ""
"Any clean-up handlers established by B<pthread_cleanup_push>(3)  that have "
"not yet been popped, are popped (in the reverse of the order in which they "
"were pushed)  and executed.  If the thread has any thread-specific data, "
"then, after the clean-up handlers have been executed, the corresponding "
"destructor functions are called, in an unspecified order."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:62
msgid ""
"When a thread terminates, process-shared resources (e.g., mutexes, condition"
" variables, semaphores, and file descriptors) are not released, and "
"functions registered using B<atexit>(3)  are not called."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:71
msgid ""
"After the last thread in a process terminates, the process terminates as by "
"calling B<exit>(3)  with an exit status of zero; thus, process-shared "
"resources are released and functions registered using B<atexit>(3)  are "
"called."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:73
msgid "This function does not return to the caller."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:80
msgid "The B<pthread_exit>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:87
msgid ""
"Performing a return from the start function of any thread other than the "
"main thread results in an implicit call to B<pthread_exit>(), using the "
"function's return value as the thread's exit status."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:93
msgid ""
"To allow other threads to continue execution, the main thread should "
"terminate by calling B<pthread_exit>()  rather than B<exit>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:98
msgid ""
"The value pointed to by I<retval> should not be located on the calling "
"thread's stack, since the contents of that stack are undefined after the "
"thread terminates."
msgstr ""

#.  Linux 2.6.27
#.  FIXME . review a later kernel to see if this gets fixed
#.  http://thread.gmane.org/gmane.linux.kernel/611611
#.  http://marc.info/?l=linux-kernel&m=122525468300823&w=2
#. type: Plain text
#: man-pages/man3/pthread_exit.3:110
msgid ""
"Currently, there are limitations in the kernel implementation logic for "
"B<wait>(2)ing on a stopped thread group with a dead thread group leader.  "
"This can manifest in problems such as a locked terminal if a stop signal is "
"sent to a foreground process whose thread group leader has already called "
"B<pthread_exit>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_exit.3:113
msgid "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_setname_np.3:26
#, no-wrap
msgid "PTHREAD_SETNAME_NP"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:29
msgid "pthread_setname_np, pthread_getname_np - set/get the name of a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:36
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
"B<int pthread_setname_np(pthread_t >I<thread>B<, const char *>I<name>B<);>\n"
"B<int pthread_getname_np(pthread_t >I<thread>B<,>\n"
"B<                       char *>I<name>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:55
msgid ""
"By default, all the threads created using B<pthread_create>()  inherit the "
"program name.  The B<pthread_setname_np>()  function can be used to set a "
"unique name for a thread, which can be useful for debugging multithreaded "
"applications.  The thread name is a meaningful C language string, whose "
"length is restricted to 16 characters, including the terminating null byte "
"(\\(aq\\e0\\(aq).  The I<thread> argument specifies the thread whose name is"
" to be changed; I<name> specifies the new name."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:72
msgid ""
"The B<pthread_getname_np>()  function can be used to retrieve the name of "
"the thread.  The I<thread> argument specifies the thread whose name is to be"
" retrieved.  The buffer I<name> is used to return the thread name; I<len> "
"specifies the number of bytes available in I<name>.  The buffer specified by"
" I<name> should be at least 16 characters in length.  The returned thread "
"name in the output buffer will be null terminated."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:79
msgid ""
"The B<pthread_setname_np>()  function can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:84
msgid ""
"The length of the string specified pointed to by I<name> exceeds the allowed"
" limit."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:88
msgid ""
"The B<pthread_getname_np>()  function can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:95
msgid ""
"The buffer specified by I<name> and I<len> is too small to hold the thread "
"name."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:100
msgid ""
"If either of these functions fails to open I</proc/self/task/[tid]/comm>, "
"then the call may fail with one of the errors described in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:102
msgid "These functions first appeared in glibc in version 2.12."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:104
msgid "These functions are nonstandard GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:114
msgid ""
"B<pthread_setname_np>()  internally writes to the thread-specific I<comm> "
"file under the I</proc> filesystem: I</proc/self/task/[tid]/comm>.  "
"B<pthread_getname_np>()  retrieves it from the same location."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:120
msgid ""
"The program below demonstrates the use of B<pthread_setname_np>()  and "
"B<pthread_getname_np>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:122
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:138
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Created a thread. Default name is: a.out\n"
"The thread name after setting it is THREADFOO.\n"
"B<^Z>                           # Suspend the program\n"
"[1]+  Stopped           ./a.out\n"
"$ B<ps H -C a.out -o 'pid tid cmd comm'>\n"
"  PID   TID CMD                         COMMAND\n"
" 5990  5990 ./a.out                     a.out\n"
" 5990  5991 ./a.out                     THREADFOO\n"
"$ B<cat /proc/5990/task/5990/comm>\n"
"a.out\n"
"$ B<cat /proc/5990/task/5991/comm>\n"
"THREADFOO\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:150
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:152
#, no-wrap
msgid "#define NAMELEN 16\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:156
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"            do { errno = en; perror(msg); exit(EXIT_FAILURE); \\e\n"
"        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:163
#, no-wrap
msgid ""
"static void *\n"
"threadfunc(void *parm)\n"
"{\n"
"    sleep(5);          // allow main program to set the thread name\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:170
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    pthread_t thread;\n"
"    int rc;\n"
"    char thread_name[NAMELEN];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:174
#, no-wrap
msgid ""
"    rc = pthread_create(&thread, NULL, threadfunc, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:178
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name, NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:183
#, no-wrap
msgid ""
"    printf(\"Created a thread. Default name is: %s\\en\", thread_name);\n"
"    rc = pthread_setname_np(thread, (argc E<gt> 1) ? argv[1] : \"THREADFOO\");\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_setname_np\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:185
#, no-wrap
msgid "    sleep(2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:191
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name,\n"
"                            (argc E<gt> 2) ? atoi(argv[1]) : NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
"    printf(\"The thread name after setting it is %s.\\en\", thread_name);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:195
#, no-wrap
msgid ""
"    rc = pthread_join(thread, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:199
#, no-wrap
msgid ""
"    printf(\"Done\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:205
msgid "B<prctl>(2), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_join.3:26
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:29
msgid "pthread_join - join with a terminated thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:34
#, no-wrap
msgid "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:49
msgid ""
"The B<pthread_join>()  function waits for the thread specified by I<thread> "
"to terminate.  If that thread has already terminated, then B<pthread_join>()"
"  returns immediately.  The thread specified by I<thread> must be joinable."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:63
msgid ""
"If I<retval> is not NULL, then B<pthread_join>()  copies the exit status of "
"the target thread (i.e., the value that the target thread supplied to "
"B<pthread_exit>(3))  into the location pointed to by I<*retval>.  If the "
"target thread was canceled, then B<PTHREAD_CANCELED> is placed in "
"I<*retval>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:70
msgid ""
"If multiple threads simultaneously try to join with the same thread, the "
"results are undefined.  If the thread calling B<pthread_join>()  is "
"canceled, then the target thread will remain joinable (i.e., it will not be "
"detached)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:75
msgid ""
"On success, B<pthread_join>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_join.3:76
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#.  The following verified by testing on glibc 2.8/NPTL:
#.  The following verified by testing on glibc 2.8/NPTL:
#. type: Plain text
#: man-pages/man3/pthread_join.3:85
msgid ""
"A deadlock was detected (e.g., two threads tried to join with each other); "
"or I<thread> specifies the calling thread."
msgstr ""

#.  POSIX.1-2001 does not specify this error case.
#. type: Plain text
#: man-pages/man3/pthread_join.3:93
msgid "Another thread is already waiting to join with this thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:104
msgid ""
"After a successful call to B<pthread_join>(), the caller is guaranteed that "
"the target thread has terminated."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:107
msgid ""
"Joining with a thread that has previously been joined results in undefined "
"behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:115
msgid ""
"Failure to join with a thread that is joinable (i.e., one that is not "
"detached), produces a \"zombie thread\".  Avoid doing this, since each "
"zombie thread consumes some system resources, and when enough zombie threads"
" have accumulated, it will no longer be possible to create new threads (or "
"processes)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:121
msgid ""
"There is no pthreads analog of I<waitpid(-1,\\ &status,\\ 0)>, that is, "
"\"join with any terminated thread\".  If you believe you need this "
"functionality, you probably need to rethink your application design."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:124
msgid ""
"All of the threads in a process are peers: any thread can join with any "
"other thread in the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_join.3:133
msgid ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_attr_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPARAM"
msgstr "PTHREAD_ATTR_SETSCHEDPARAM"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:30
msgid ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling "
"parameter attributes in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:52
msgid ""
"The B<pthread_attr_setschedparam>()  function sets the scheduling parameter "
"attributes of the thread attributes object referred to by I<attr> to the "
"values specified in the buffer pointed to by I<param>.  These attributes "
"determine the scheduling parameters of a thread created using the thread "
"attributes object I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:59
msgid ""
"The B<pthread_attr_getschedparam>()  returns the scheduling parameter "
"attributes of the thread attributes object I<attr> in the buffer pointed to "
"by I<param>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:61
msgid "Scheduling parameters are maintained in the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:67
#, no-wrap
msgid ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:74
msgid ""
"As can be seen, only one scheduling parameter is supported.  For details of "
"the permitted ranges for scheduling priorities in each scheduling policy, "
"see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:85
msgid ""
"In order for the parameter setting made by B<pthread_attr_setschedparam>()  "
"to have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:100
msgid ""
"POSIX.1 documents B<EINVAL> and B<ENOTSUP> errors for "
"B<pthread_attr_setschedparam>().  On Linux these functions always succeed "
"(but portable and future-proof applications should nevertheless handle a "
"possible error return)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:107
msgid ""
"The B<pthread_attr_setschedparam>()  and B<pthread_attr_getschedparam>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:113
msgid ""
"See B<pthread_attr_setschedpolicy>(3)  for a list of the thread scheduling "
"policies supported on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:116
msgid "See B<pthread_setschedparam>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:127
msgid ""
"B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7).  B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_self.3:26
#, no-wrap
msgid "PTHREAD_SELF"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_self.3:26
#, no-wrap
msgid "2014-05-13"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:29
msgid "pthread_self - obtain ID of the calling thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:34
#, no-wrap
msgid "B<pthread_t pthread_self(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:46
msgid ""
"The B<pthread_self>()  function returns the ID of the calling thread.  This "
"is the same value that is returned in I<*thread> in the B<pthread_create>(3)"
"  call that created this thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:48
msgid "This function always succeeds, returning the calling thread's ID."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:55
msgid "The B<pthread_self>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:68
msgid ""
"POSIX.1 allows an implementation wide freedom in choosing the type used to "
"represent a thread ID; for example, representation using either an "
"arithmetic type or a structure is permitted.  Therefore, variables of type "
"I<pthread_t> can't portably be compared using the C equality operator "
"(B<==>); use B<pthread_equal>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:72
msgid ""
"Thread identifiers should be considered opaque: any attempt to use a thread "
"ID other than in pthreads calls is nonportable and can lead to unspecified "
"results."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:76
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  A thread ID "
"may be reused after a terminated thread has been joined, or a detached "
"thread has terminated."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:81
msgid ""
"The thread ID returned by B<pthread_self>()  is not the same thing as the "
"kernel thread ID returned by a call to B<gettid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_self.3:84
msgid "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_sigmask.3:26
#, no-wrap
msgid "PTHREAD_SIGMASK"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:29
msgid "pthread_sigmask - examine and change mask of blocked signals"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:35
#, no-wrap
msgid ""
"B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t "
"*>I<oldset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:46
msgid "B<pthread_sigmask>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:48
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 199506L || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:58
msgid ""
"The B<pthread_sigmask>()  function is just like B<sigprocmask>(2), with the "
"difference that its use in multithreaded programs is explicitly specified by"
" POSIX.1-2001.  Other differences are noted in this page."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:61
msgid ""
"For a description of the arguments and operation of this function, see "
"B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:66
msgid ""
"On success, B<pthread_sigmask>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:69
msgid "See B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:74
msgid "The B<pthread_sigmask>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:78
msgid "A new thread inherits a copy of its creator's signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:83
msgid ""
"The program below blocks some signals in the main thread, and then creates a"
" dedicated thread to fetch those signals via B<sigwait>(3).  The following "
"shell session demonstrates its use:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:94
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:105
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:107
#, no-wrap
msgid "/* Simple error handling functions */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:116
#, no-wrap
msgid ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = arg;\n"
"    int s, sig;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:124
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:131
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:134
#, no-wrap
msgid ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:141
#, no-wrap
msgid ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:145
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:148
#, no-wrap
msgid ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:151
#, no-wrap
msgid ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:160
msgid ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<pthread_create>(3), "
"B<pthread_kill>(3), B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/posix_memalign.3:29
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr ""

#. type: TH
#: man-pages/man3/posix_memalign.3:29
#, no-wrap
msgid "2013-09-02"
msgstr "2013-09-02"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:32
msgid ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - allocate aligned "
"memory"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:41
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:44
#, no-wrap
msgid ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:54
msgid ""
"B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:57
msgid "B<aligned_alloc>(): _ISOC11_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:59
msgid "B<valloc>():"
msgstr ""

#. type: TP
#: man-pages/man3/posix_memalign.3:62
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:69
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr "_BSD_SOURCE ||\n    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: TP
#: man-pages/man3/posix_memalign.3:71
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:75
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:82
msgid ""
"(The (nonstandard) header file I<E<lt>malloc.hE<gt>> also exposes the "
"declaration of B<valloc>(); no feature test macros are required.)"
msgstr ""

#.  glibc does this:
#. type: Plain text
#: man-pages/man3/posix_memalign.3:104
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated"
" memory will be a multiple of I<alignment>, which must be a power of two and"
" a multiple of I<sizeof(void\\ *)>.  If I<size> is 0, then the value placed "
"in I<*memptr> is either NULL, or a unique pointer value that can later be "
"successfully passed to B<free>(3)."
msgstr ""

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: man-pages/man3/posix_memalign.3:115
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<alignment>, which must be a power of two."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:124
msgid ""
"The function B<aligned_alloc>()  is the same as B<memalign>(), except for "
"the added restriction that I<size> should be a multiple of I<alignment>."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:133
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:140
msgid ""
"The obsolete function B<pvalloc>()  is similar to B<valloc>(), but rounds "
"the size of the allocation up to the next multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:142
msgid "For all of these functions, the memory is not zeroed."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:149
msgid ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return a "
"pointer to the allocated memory, or NULL if the request fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:157
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  The value of I<errno> is "
"indeterminate after a call to B<posix_memalign>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:164
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void\\ *)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:167
msgid "There was insufficient memory to fulfill the allocation request."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:174
msgid ""
"The functions B<memalign>(), B<valloc>(), and B<pvalloc>()  have been "
"available in all Linux libc libraries."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:178
msgid "The function B<aligned_alloc>()  was added to glibc in version 2.16."
msgstr "Функция B<aligned_alloc>() впервые появилась в glibc 2.16."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:182
msgid "The function B<posix_memalign>()  is available since glibc 2.1.91."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:189
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:193
msgid "The function B<pvalloc>()  is a GNU extension."
msgstr "Функция B<pvalloc>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:197
msgid "The function B<memalign>()  appears in SunOS 4.1.3 but not in 4.4BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:201
msgid "The function B<posix_memalign>()  comes from POSIX.1d."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:206
msgid "The function B<aligned_alloc>()  is specified in the C11 standard."
msgstr ""

#. type: SS
#: man-pages/man3/posix_memalign.3:206
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:210
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:214
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:221
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Libc4,5 and glibc declare it in I<E<lt>malloc.hE<gt>>, and also in "
"I<E<lt>stdlib.hE<gt>> if suitable feature test macros are defined (see "
"above)."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:230
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the "
"I<pathconf(path,_PC_REC_XFER_ALIGN)> call that tells what alignment is "
"needed.  Now one can use B<posix_memalign>()  to satisfy this requirement."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:239
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<alignment> argument"
" is correct."
msgstr ""

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: man-pages/man3/posix_memalign.3:267
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can pass to B<free>(3)  "
"only a pointer obtained from B<malloc>(3), while, for example, B<memalign>()"
"  would call B<malloc>(3)  and then align the obtained value).  The glibc "
"implementation allows memory obtained from any of these functions to be "
"reclaimed with B<free>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:272
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these functions are needed only if you require larger alignment values."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_memalign.3:276
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/printf.3:34
#, no-wrap
msgid "PRINTF"
msgstr "PRINTF"

#. type: Plain text
#: man-pages/man3/printf.3:38
msgid ""
"printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf -"
" formatted output conversion"
msgstr "printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - преобразование форматированного вывода"

#. type: Plain text
#: man-pages/man3/printf.3:42
msgid "B<int printf(const char *>I<format>B<, ...);>"
msgstr "B<int printf(const char *>I<format>B<, ...);>"

#. type: Plain text
#: man-pages/man3/printf.3:44
msgid "B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>"
msgstr "B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: man-pages/man3/printf.3:46
msgid "B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>"
msgstr "B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: man-pages/man3/printf.3:48
msgid ""
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<,"
" ...);>"
msgstr "B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: man-pages/man3/printf.3:50
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr "B<#include E<lt>stdarg.hE<gt>>"

#. type: Plain text
#: man-pages/man3/printf.3:52
msgid "B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr "B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/printf.3:54
msgid ""
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr "B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/printf.3:56
msgid ""
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr "B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/printf.3:59
msgid ""
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, va_list >I<ap>B<);>"
msgstr "B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/printf.3:68
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr "B<snprintf>(), B<vsnprintf>():"

#. type: Plain text
#: man-pages/man3/printf.3:71
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/printf.3:74
msgid "or I<cc -std=c99>"
msgstr "или I<cc -std=c99>"

#. type: Plain text
#: man-pages/man3/printf.3:101
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>()  and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:110
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes"
" (including the terminating null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:134
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vsprintf>(), B<vsnprintf>()  "
"are equivalent to the functions B<printf>(), B<fprintf>(), B<sprintf>(), "
"B<snprintf>(), respectively, except that they are called with a I<va_list> "
"instead of a variable number of arguments.  These functions do not call the "
"I<va_end> macro.  Because they invoke the I<va_arg> macro, the value of "
"I<ap> is undefined after the call.  See B<stdarg>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:141
msgid ""
"These eight functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:152
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:152
#, no-wrap
msgid "Return value"
msgstr "Возвращаемое значение"

#. type: Plain text
#: man-pages/man3/printf.3:155
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (excluding the null byte used to end output to strings)."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:171
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the terminating null byte (\\(aq\\e0\\(aq)).  If "
"the output was truncated due to this limit, then the return value is the "
"number of characters (excluding the terminating null byte)  which would have"
" been written to the final string if enough space had been available.  Thus,"
" a return value of I<size> or more means that the output was truncated.  "
"(See also below under NOTES.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:173
msgid "If an output error is encountered, a negative value is returned."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:173
#, no-wrap
msgid "Format of the format string"
msgstr "Формат форматирующей строки"

#. type: Plain text
#: man-pages/man3/printf.3:195
msgid ""
"The format string is a character string, beginning and ending in its initial"
" shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional"
" I<length modifier>."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:208
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq and each conversion specifier asks for the "
"next argument (and it is an error if insufficiently many arguments are "
"given).  One can also specify explicitly which argument is taken, at each "
"place where an argument is required, by writing \"%m$\" instead of "
"\\(aq%\\(aq and \"*m$\" instead of \\(aq*\\(aq, where the decimal integer m "
"denotes the position in the argument list of the desired argument, indexed "
"starting from 1.  Thus,"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:212
#, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr "printf(\"%*d\", width, num);\n"

#. type: Plain text
#: man-pages/man3/printf.3:216
msgid "and"
msgstr "и"

#. type: Plain text
#: man-pages/man3/printf.3:220
#, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr "printf(\"%2$*1$d\", width, num);\n"

#. type: Plain text
#: man-pages/man3/printf.3:236
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using "
"\\(aq$\\(aq is used, it must be used throughout for all conversions taking "
"an argument and all width and precision arguments, but it may be mixed with "
"\"%%\" formats which do not consume an argument.  There may be no gaps in "
"the numbers of arguments specified using \\(aq$\\(aq; for example, if "
"arguments 1 and 3 are specified, argument 2 must also be specified somewhere"
" in the format string."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:246
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on"
" the B<LC_NUMERIC> part of the locale.  The POSIX locale uses \\(aq.\\(aq as"
" radix character, and does not have a grouping character.  Thus,"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:250
#, no-wrap
msgid "    printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:255
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:255
#, no-wrap
msgid "The flag characters"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:257
msgid "The character % is followed by zero or more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:257
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#: man-pages/man3/printf.3:291
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a"
" nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:291
#, no-wrap
msgid "B<\\&0>"
msgstr "B<\\&0>"

#. type: Plain text
#: man-pages/man3/printf.3:331
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the"
" B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior"
" is undefined."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:331
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#: man-pages/man3/printf.3:344
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  Except for B<n> conversions, the converted"
" value is padded on the right with blanks, rather than on the left with "
"blanks or zeros.  A B<-> overrides a B<\\&0> if both are given."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:344
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr "B<\\(aq \\(aq>"

#. type: Plain text
#: man-pages/man3/printf.3:348
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:348
#, no-wrap
msgid "B<+>"
msgstr "B<+>"

#. type: Plain text
#: man-pages/man3/printf.3:356
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed"
" conversion.  By default a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:359
msgid ""
"The five flag characters above are defined in the C standard.  SUSv2 "
"specifies one further flag character."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:359
#, no-wrap
msgid "B<\\(aq>"
msgstr "B<\\(aq>"

#. type: Plain text
#: man-pages/man3/printf.3:376
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  Note that many versions of B<gcc>(1)  cannot "
"parse this option and will issue a warning.  SUSv2 does not include "
"I<%\\(aqF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:378
msgid "glibc 2.2 adds one further flag character."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:378
#, no-wrap
msgid "B<I>"
msgstr "B<I>"

#.  outdigits keyword in locale file
#. type: Plain text
#: man-pages/man3/printf.3:388
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:388
#, no-wrap
msgid "The field width"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:404
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one"
" may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken"
" as a \\(aq-\\(aq flag followed by a positive field width.  In no case does "
"a nonexistent or small field width cause truncation of a field; if the "
"result of a conversion is wider than the field width, the field is expanded "
"to contain the conversion result."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:404
#, no-wrap
msgid "The precision"
msgstr "Точность"

#. type: Plain text
#: man-pages/man3/printf.3:441
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an"
" optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer m) to specify that the "
"precision is given in the next argument, or in the m-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, the precision is taken to be zero.  A negative precision "
"is taken as if the precision were omitted.  This gives the minimum number of"
" digits to appear for B<d>, B<i>, B<o>, B<u>, B<x>, and B<X> conversions, "
"the number of digits to appear after the radix character for B<a>, B<A>, "
"B<e>, B<E>, B<f>, and B<F> conversions, the maximum number of significant "
"digits for B<g> and B<G> conversions, or the maximum number of characters to"
" be printed from a string for B<s> and B<S> conversions."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:441
#, no-wrap
msgid "The length modifier"
msgstr "Модификатор длины"

#. type: Plain text
#: man-pages/man3/printf.3:451
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:451
#, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#: man-pages/man3/printf.3:462
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned"
" char> argument, or a following B<n> conversion corresponds to a pointer to "
"a I<signed char> argument."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:462
#, no-wrap
msgid "B<h>"
msgstr "B<h>"

#. type: Plain text
#: man-pages/man3/printf.3:473
msgid ""
"A following integer conversion corresponds to a I<short int> or I<unsigned "
"short int> argument, or a following B<n> conversion corresponds to a pointer"
" to a I<short int> argument."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:473
#, no-wrap
msgid "B<l>"
msgstr "B<l>"

#. type: Plain text
#: man-pages/man3/printf.3:492
msgid ""
"(ell) A following integer conversion corresponds to a I<long int> or "
"I<unsigned long int> argument, or a following B<n> conversion corresponds to"
" a pointer to a I<long int> argument, or a following B<c> conversion "
"corresponds to a I<wint_t> argument, or a following B<s> conversion "
"corresponds to a pointer to I<wchar_t> argument."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:492
#, no-wrap
msgid "B<ll>"
msgstr "B<ll>"

#. type: Plain text
#: man-pages/man3/printf.3:504
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long int>"
" or I<unsigned long long int> argument, or a following B<n> conversion "
"corresponds to a pointer to a I<long long int> argument."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:504
#, no-wrap
msgid "B<L>"
msgstr "B<L>"

#.  .TP
#.  .B q
#.  ("quad". 4.4BSD and Linux libc5 only.
#.  Don't use.)
#. type: Plain text
#: man-pages/man3/printf.3:526
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)  This is a synonym for B<ll>."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:526
#, no-wrap
msgid "B<j>"
msgstr "B<j>"

#. type: Plain text
#: man-pages/man3/printf.3:533
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t>"
" argument."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:533
#, no-wrap
msgid "B<z>"
msgstr "B<z>"

#.  (Linux libc5 has
#.  .B Z
#.  with this meaning.
#.  Don't use it.)
#. type: Plain text
#: man-pages/man3/printf.3:544
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:544
#, no-wrap
msgid "B<t>"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:549
msgid "A following integer conversion corresponds to a I<ptrdiff_t> argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:578
msgid ""
"SUSv2 knows about only the length modifiers B<h> (in B<hd>, B<hi>, B<ho>, "
"B<hx>, B<hX>, B<hn>)  and B<l> (in B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>,"
" B<lc>, B<ls>)  and B<L> (in B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""

#. type: SS
#: man-pages/man3/printf.3:578
#, no-wrap
msgid "The conversion specifier"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:581
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:581
#, no-wrap
msgid "B<d>, B<i>"
msgstr "B<d>, B<i>"

#. type: Plain text
#: man-pages/man3/printf.3:591
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision,"
" if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros."
"  The default precision is 1.  When 0 is printed with an explicit precision "
"0, the output is empty."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:591
#, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr "B<o>, B<u>, B<x>, B<X>"

#. type: Plain text
#: man-pages/man3/printf.3:618
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned"
" decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it"
" is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:618
#, no-wrap
msgid "B<e>, B<E>"
msgstr "B<e>, B<E>"

#. type: Plain text
#: man-pages/man3/printf.3:637
msgid ""
"The I<double> argument is rounded and converted in the style "
"[-]dB<\\&.>dddB<e>\\(+-dd where there is one digit before the decimal-point "
"character and the number of digits after it is equal to the precision; if "
"the precision is missing, it is taken as 6; if the precision is zero, no "
"decimal-point character appears.  An B<E> conversion uses the letter B<E> "
"(rather than B<e>)  to introduce the exponent.  The exponent always contains"
" at least two digits; if the value is zero, the exponent is 00."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:637
#, no-wrap
msgid "B<f>, B<F>"
msgstr "B<f>, B<F>"

#. type: Plain text
#: man-pages/man3/printf.3:648
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no decimal-"
"point character appears.  If a decimal point appears, at least one digit "
"appears before it."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:659
msgid ""
"(SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  The C99 "
"standard specifies \"[-]inf\" or \"[-]infinity\" for infinity, and a string "
"starting with \"nan\" for NaN, in the case of B<f> conversion, and "
"\"[-]INF\" or \"[-]INFINITY\" or \"NAN*\" in the case of B<F> conversion.)"
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:659
#, no-wrap
msgid "B<g>, B<G>"
msgstr "B<g>, B<G>"

#. type: Plain text
#: man-pages/man3/printf.3:684
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal"
" point appears only if it is followed by at least one digit."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:684
#, no-wrap
msgid "B<a>, B<A>"
msgstr "B<a>, B<A>"

#. type: Plain text
#: man-pages/man3/printf.3:708
msgid ""
"(C99; not in SUSv2) For B<a> conversion, the I<double> argument is converted"
" to hexadecimal notation (using the letters abcdef)  in the style "
"[-]B<0x>hB<\\&.>hhhhB<p>\\(+-; for B<A> conversion the prefix B<0X>, the "
"letters ABCDEF, and the exponent separator B<P> is used.  There is one "
"hexadecimal digit before the decimal point, and the number of digits after "
"it is equal to the precision.  The default precision suffices for an exact "
"representation of the value if an exact representation in base 2 exists and "
"otherwise is sufficiently large to distinguish values of type I<double>.  "
"The digit before the decimal point is unspecified for nonnormalized numbers,"
" and nonzero but otherwise unspecified for normalized numbers."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:708
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#: man-pages/man3/printf.3:726
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to"
" a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:726
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#: man-pages/man3/printf.3:741
msgid ""
"If no B<l> modifier is present: The I<const char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more"
" than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:768
msgid ""
"If an B<l> modifier is present: The I<const wchar_t\\ *> argument is "
"expected to be a pointer to an array of wide characters.  Wide characters "
"from the array are converted to multibyte characters (each by a call to the "
"B<wcrtomb>(3)  function, with a conversion state starting in the initial "
"state before the first wide character), up to and including a terminating "
"null wide character.  The resulting multibyte characters are written up to "
"(but not including) the terminating null byte.  If a precision is specified,"
" no more bytes than the number specified are written, but no partial "
"multibyte characters are written.  Note that the precision determines the "
"number of I<bytes> written, not the number of I<wide characters> or I<screen"
" positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:768
#, no-wrap
msgid "B<C>"
msgstr "B<C>"

#. type: Plain text
#: man-pages/man3/printf.3:774
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<lc>.  "
"Don't use."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:774
#, no-wrap
msgid "B<S>"
msgstr "B<S>"

#. type: Plain text
#: man-pages/man3/printf.3:780
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<ls>.  "
"Don't use."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:780
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: man-pages/man3/printf.3:788
msgid ""
"The I<void\\ *> pointer argument is printed in hexadecimal (as if by B<%#x> "
"or B<%#lx>)."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:788
#, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#: man-pages/man3/printf.3:795
msgid ""
"The number of characters written so far is stored into the integer indicated"
" by the I<int\\ *> (or variant) pointer argument.  No argument is converted."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:795
#, no-wrap
msgid "B<m>"
msgstr "B<m>"

#. type: Plain text
#: man-pages/man3/printf.3:801
msgid ""
"(Glibc extension.)  Print output of I<strerror(errno)>.  No argument is "
"required."
msgstr ""

#. type: TP
#: man-pages/man3/printf.3:801
#, no-wrap
msgid "B<%>"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:807
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:822
msgid ""
"The B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"and B<vsprintf>()  functions conform to C89 and C99.  The B<snprintf>()  and"
" B<vsnprintf>()  functions conform to C99."
msgstr ""

#.  .PP
#.  Linux libc4 knows about the five C standard flags.
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  and the conversions
#.  \fBc\fP, \fBd\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP,
#.  \fBg\fP, \fBG\fP, \fBi\fP, \fBn\fP, \fBo\fP, \fBp\fP,
#.  \fBs\fP, \fBu\fP, \fBx\fP, and \fBX\fP,
#.  where \fBF\fP is a synonym for \fBf\fP.
#.  Additionally, it accepts \fBD\fP, \fBO\fP, and \fBU\fP as synonyms
#.  for \fBld\fP, \fBlo\fP, and \fBlu\fP.
#.  (This is bad, and caused serious bugs later, when
#.  support for \fB%D\fP disappeared.)
#.  No locale-dependent radix character,
#.  no thousands' separator, no NaN or infinity, no "%m$" and "*m$".
#.  .PP
#.  Linux libc5 knows about the five C standard flags and the \(aq flag,
#.  locale, "%m$" and "*m$".
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  \fBZ\fP, and \fBq\fP, but accepts \fBL\fP and \fBq\fP
#.  both for \fIlong double\fP and for \fIlong long int\fP (this is a bug).
#.  It no longer recognizes \fBF\fP, \fBD\fP, \fBO\fP, and \fBU\fP,
#.  but adds the conversion character
#.  .BR m ,
#.  which outputs
#.  .IR strerror(errno) .
#.  .PP
#.  glibc 2.0 adds conversion characters \fBC\fP and \fBS\fP.
#. type: Plain text
#: man-pages/man3/printf.3:865
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an"
" unspecified return value less than 1, while C99 allows I<str> to be NULL in"
" this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough.  SUSv3 and later align their specification of B<snprintf>()  "
"with C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:868
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:871
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:873
msgid "Some programs imprudently rely on code such as the following"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:875
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr "    sprintf(buf, \"%s some further text\", buf);\n"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
#: man-pages/man3/printf.3:891
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling"
" B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for
#. ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
#: man-pages/man3/printf.3:933
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()"
"  conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6, they would return -1 when the output "
"was truncated."
msgstr ""

#.  .PP
#.  Linux libc4.[45] does not have a
#.  .BR snprintf (),
#.  but provides a libbsd that contains an
#.  .BR snprintf ()
#.  equivalent to
#.  .BR sprintf (),
#.  that is, one that ignores the
#.  .I size
#.  argument.
#.  Thus, the use of
#.  .BR snprintf ()
#.  with early libc4 leads to serious security problems.
#. type: Plain text
#: man-pages/man3/printf.3:963
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#: man-pages/man3/printf.3:977
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating"
" a security hole."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:981
msgid "To print I<Pi> to five decimal places:"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:987
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:996
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1002
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1008
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1014
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1021
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1025
#, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1029
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1032
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1037
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/printf.3:1045
#, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n;\n"
"    int size = 100;     /* Guess we need no more than 100 bytes */\n"
"    char *p, *np;\n"
"    va_list ap;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1049
#, no-wrap
msgid ""
"    p = malloc(size);\n"
"    if (p == NULL)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1051
#, no-wrap
msgid "    while (1) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1053
#, no-wrap
msgid "        /* Try to print in the allocated space */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1057
#, no-wrap
msgid ""
"        va_start(ap, fmt);\n"
"        n = vsnprintf(p, size, fmt, ap);\n"
"        va_end(ap);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1059
#, no-wrap
msgid "        /* Check error code */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1064
#, no-wrap
msgid ""
"        if (n E<lt> 0) {\n"
"            free(p);\n"
"            return NULL;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1066
#, no-wrap
msgid "        /* If that worked, return the string */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1069
#, no-wrap
msgid ""
"        if (n E<lt> size)\n"
"            return p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1071
#, no-wrap
msgid "        /* Else try again with more space */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1073
#, no-wrap
msgid "        size = n + 1;       /* Precisely what is needed */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1084
#, no-wrap
msgid ""
"        np = realloc(p, size);\n"
"        if (np == NULL) {\n"
"            free(p);\n"
"            return NULL;\n"
"        } else {\n"
"            p = np;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1088
msgid ""
"If truncation occurs in glibc versions prior to 2.0.6, this is treated as an"
" error instead of being handled gracefully."
msgstr ""

#. type: Plain text
#: man-pages/man3/printf.3:1096
msgid ""
"B<printf>(1), B<asprintf>(3), B<dprintf>(3), B<scanf>(3), B<setlocale>(3), "
"B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/puts.3:26
#, no-wrap
msgid "PUTS"
msgstr ""

#. type: TH
#: man-pages/man3/puts.3:26
#, no-wrap
msgid "2014-01-11"
msgstr "2014-01-11"

#. type: Plain text
#: man-pages/man3/puts.3:29
msgid "fputc, fputs, putc, putchar, puts - output of characters and strings"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:32
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/puts.3:34
#, no-wrap
msgid "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:36
#, no-wrap
msgid "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:38
#, no-wrap
msgid "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:40
#, no-wrap
msgid "B<int putchar(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:42
#, no-wrap
msgid "B<int puts(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:51
msgid ""
"B<fputc>()  writes the character I<c>, cast to an I<unsigned char>, to "
"I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:58
msgid ""
"B<fputs>()  writes the string I<s> to I<stream>, without its terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:65
msgid ""
"B<putc>()  is equivalent to B<fputc>()  except that it may be implemented as"
" a macro which evaluates I<stream> more than once."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:69
msgid "B<putchar(>I<c>B<);> is equivalent to B<putc(>I<c>B<, >I<stdout>B<).>"
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:76
msgid "B<puts>()  writes the string I<s> and a trailing newline to I<stdout>."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:81
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other output functions from the I<stdio> library for the same "
"output stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:84
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr "Для неблокирующих аналогов, см. B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/puts.3:96
msgid ""
"B<fputc>(), B<putc>()  and B<putchar>()  return the character written as an "
"I<unsigned char> cast to an I<int> or B<EOF> on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:103
msgid ""
"B<puts>()  and B<fputs>()  return a nonnegative number on success, or B<EOF>"
" on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:105
msgid "C89, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:112
msgid ""
"It is not advisable to mix calls to output functions from the I<stdio> "
"library with low-level calls to B<write>(2)  for the file descriptor "
"associated with the same output stream; the results will be undefined and "
"very probably not what you want."
msgstr ""

#. type: Plain text
#: man-pages/man3/puts.3:123
msgid ""
"B<write>(2), B<ferror>(3), B<fgets>(3), B<fopen>(3), B<fputwc>(3), "
"B<fputws>(3), B<fseek>(3), B<fwrite>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_kill.3:26
#, no-wrap
msgid "PTHREAD_KILL"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:29
msgid "pthread_kill - send a signal to a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:34
#, no-wrap
msgid "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:45
msgid "B<pthread_kill>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:59
msgid ""
"The B<pthread_kill>()  function sends the signal I<sig> to I<thread>, a "
"thread in the same process as the caller.  The signal is asynchronously "
"directed to I<thread>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:63
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:68
msgid ""
"On success, B<pthread_kill>()  returns 0; on error, it returns an error "
"number, and no signal is sent."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:72
msgid "An invalid signal was specified."
msgstr "Указан некорректный сигнал. "

#. type: Plain text
#: man-pages/man3/pthread_kill.3:77
msgid "The B<pthread_kill>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:79
msgid "POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:86
msgid ""
"Signal dispositions are process-wide: if a signal handler is installed, the "
"handler will be invoked in the thread I<thread>, but if the disposition of "
"the signal is \"stop\", \"continue\", or \"terminate\", this action will "
"affect the whole process."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:99
msgid ""
"POSIX.1-2008 recommends that if an implementation detects the use of a "
"thread ID after the end of its lifetime, B<pthread_kill>()  should return "
"the error B<ESRCH>.  The glibc implementation returns this error in the "
"cases where an invalid thread ID can be detected.  But note also that POSIX "
"says that an attempt to use a thread ID whose lifetime has ended produces "
"undefined behavior, and an attempt to use an invalid thread ID in a call to "
"B<pthread_kill>()  can, for example, cause a segmentation fault."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill.3:107
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_sigqueue.3:25
#, no-wrap
msgid "PTHREAD_SIGQUEUE"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:28
msgid "pthread_sigqueue - queue a signal and data to a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:32
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:35
#, no-wrap
msgid ""
"B<int pthread_sigqueue(pthread_t >I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:46
msgid "B<pthread_sigqueue>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:54
msgid ""
"The B<pthread_sigqueue>()  function performs a similar task to "
"B<sigqueue>(3), but, rather than sending a signal to a process, it sends a "
"signal to a thread in the same process as the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:66
msgid ""
"The I<thread> argument is the ID of a thread in the same process as the "
"caller.  The I<sig> argument specifies the signal to be sent.  The I<value> "
"argument specifies data to accompany the signal; see B<sigqueue>(3)  for "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:71
msgid ""
"On success, B<pthread_sigqueue>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_sigqueue.3:72
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:78
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr "Достигнуто ограничение на количество сигналов в очереди (подробней об этом смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:82
msgid "I<sig> was invalid."
msgstr "Значение I<sig> некорректно."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:86
msgid "B<pthread_sigqueue>()  is not supported on this system."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:90
msgid "I<thread> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:94
msgid "The B<pthread_sigqueue>()  function first appeared in glibc 2.11."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:99
msgid "The B<pthread_sigqueue>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:108
msgid ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), "
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_tryjoin_np.3:26
#, no-wrap
msgid "PTHREAD_TRYJOIN_NP"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:30
msgid ""
"pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated "
"thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:36
#, no-wrap
msgid ""
"B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:39
#, no-wrap
msgid ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:46
msgid ""
"These functions operate in the same way as B<pthread_join>(3), except for "
"the differences described on this page."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:58
msgid ""
"The B<pthread_tryjoin_np>()  function performs a nonblocking join with the "
"thread I<thread>, returning the exit status of the thread in I<*retval>.  If"
" I<thread> has not yet terminated, then instead of blocking, as is done by "
"B<pthread_join>(3), the call returns an error."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:76
msgid ""
"The B<pthread_timedjoin_np>()  function performs a join-with-timeout.  If "
"I<thread> has not yet terminated, then the call blocks until a maximum time,"
" specified in I<abstime>.  If the timeout expires before I<thread> "
"terminates, the call returns an error.  The I<abstime> argument is a "
"structure of the following form, specifying an absolute time measured since "
"the Epoch (see B<time>(2)):"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:83
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:89
msgid ""
"On success, these functions return 0; on error, they return an error number."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:94
msgid ""
"These functions can fail with the same errors as B<pthread_join>(3).  "
"B<pthread_tryjoin_np>()  can in addition fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:98
msgid "I<thread> had not yet terminated at the time of the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:101
msgid ""
"B<pthread_timedjoin_np>()  can in addition fail with the following error:"
msgstr ""

#. type: TP
#: man-pages/man3/pthread_tryjoin_np.3:101
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:106
msgid "The call timed out before I<thread> terminated."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:110
msgid "B<pthread_timedjoin_np>()  never returns the error B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:112
msgid "These functions first appeared in glibc in version 2.3.3."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:117
msgid "The following code waits to join for up to 5 seconds:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:121
#, no-wrap
msgid ""
"    struct timespec ts;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:123
#, no-wrap
msgid "    ...\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:127
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"\t/* Handle error */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:129
#, no-wrap
msgid "    ts.tv_sec += 5;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:134
#, no-wrap
msgid ""
"    s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"    if (s != 0) {\n"
"        /* Handle error */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:139
msgid ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_attr_setschedpolicy.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPOLICY"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:30
msgid ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - set/get "
"scheduling policy attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:52
msgid ""
"The B<pthread_attr_setschedpolicy>()  function sets the scheduling policy "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<policy>.  This attribute determines the scheduling "
"policy of a thread created using the thread attributes object I<attr>."
msgstr ""

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:65
msgid ""
"The supported values for I<policy> are B<SCHED_FIFO>, B<SCHED_RR>, and "
"B<SCHED_OTHER>, with the semantics described in B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:72
msgid ""
"The B<pthread_attr_getschedpolicy>()  returns the scheduling policy "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<policy>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:83
msgid ""
"In order for the policy setting made by B<pthread_attr_setschedpolicy>()  to"
" have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:89
msgid "B<pthread_attr_setschedpolicy>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:93
msgid "Invalid value in I<policy>."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:100
msgid ""
"POSIX.1-2001 also documents an optional B<ENOTSUP> error (\"attempt was made"
" to set the attribute to an unsupported value\") for "
"B<pthread_attr_setschedpolicy>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:107
msgid ""
"The B<pthread_attr_setschedpolicy>()  and B<pthread_attr_getschedpolicy>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:122
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_create>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_attr_setguardsize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETGUARDSIZE"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:30
msgid ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size "
"attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(const pthread_attr_t *>I<attr>B<, size_t *>I<guardsize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:49
msgid ""
"The B<pthread_attr_setguardsize>()  function sets the guard size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<guardsize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:59
msgid ""
"If I<guardsize> is greater than 0, then for each new thread created using "
"I<attr> the system allocates an additional region of at least I<guardsize> "
"bytes at the end of the thread's stack to act as the guard area for the "
"stack (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:65
msgid ""
"If I<guardsize> is 0, then new threads created with I<attr> will not have a "
"guard area."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:67
msgid "The default guard size is the same as the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:82
msgid ""
"If the stack address attribute has been set in I<attr> (using "
"B<pthread_attr_setstack>(3)  or B<pthread_attr_setstackaddr>(3)), meaning "
"that the caller is allocating the thread's stack, then the guard size "
"attribute is ignored (i.e., no guard area is created by the system): it is "
"the application's responsibility to handle stack overflow (perhaps by using "
"B<mprotect>(2)  to manually define a guard area at the end of the stack that"
" it has allocated)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:90
msgid ""
"The B<pthread_attr_getguardsize>()  function returns the guard size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<guardsize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:104
msgid ""
"POSIX.1-2001 documents an B<EINVAL> error if I<attr> or I<guardsize> is "
"invalid.  On Linux these functions always succeed (but portable and future-"
"proof applications should nevertheless handle a possible error return)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:113
msgid ""
"The B<pthread_attr_setguardsize>()  and B<pthread_attr_getguardsize>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:129
msgid ""
"A guard area consists of virtual memory pages that are protected to prevent "
"read and write access.  If a thread overflows its stack into the guard area,"
" then, on most hard architectures, it receives a B<SIGSEGV> signal, thus "
"notifying it of the overflow.  Guard areas start on page boundaries, and the"
" guard size is internally rounded up to the system page size when creating a"
" thread.  (Nevertheless, B<pthread_attr_getguardsize>()  returns the guard "
"size that was set by B<pthread_attr_setguardsize>().)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:133
msgid ""
"Setting a guard size of 0 may be useful to save memory in an application "
"that creates many threads and knows that stack overflow can never occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:137
msgid ""
"Choosing a guard size larger than the default size may be necessary for "
"detecting stack overflows if a thread allocates large data structures on the"
" stack."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:148
msgid ""
"As at glibc 2.8, the NPTL threading implementation includes the guard area "
"within the stack size allocation, rather than allocating extra space at the "
"end of the stack, as POSIX.1 requires.  (This can result in an B<EINVAL> "
"error from B<pthread_create>(3)  if the guard size value is too large, "
"leaving no space for the actual stack.)"
msgstr ""

#.  glibc includes the guardsize within the allocated stack size,
#.  which looks pretty clearly to be in violation of POSIX.
#.  Filed bug, 22 Oct 2008:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6973
#.  Older reports:
#.  https//bugzilla.redhat.com/show_bug.cgi?id=435337
#.  Reportedly, LinuxThreads did the right thing, allocating
#.  extra space at the end of the stack:
#.  http://sourceware.org/ml/libc-alpha/2008-05/msg00086.html
#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:162
msgid ""
"The obsolete LinuxThreads implementation did the right thing, allocating "
"extra space at the end of the stack for the guard area."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:165
msgid "See B<pthread_getattr_np>(3)."
msgstr "См. B<pthread_getattr_np>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:172
msgid ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthreads>(7)"
msgstr "B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/popen.3:40
#, no-wrap
msgid "POPEN"
msgstr "POPEN"

#. type: TH
#: man-pages/man3/popen.3:40
#, no-wrap
msgid "2013-04-19"
msgstr "2013-04-19"

#. type: Plain text
#: man-pages/man3/popen.3:43
msgid "popen, pclose - pipe stream to or from a process"
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:48
#, no-wrap
msgid "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/popen.3:50
#, no-wrap
msgid "B<int pclose(FILE *>I<stream>B<);>\n"
msgstr "B<int pclose(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/popen.3:60
msgid "B<popen>(), B<pclose>():"
msgstr "B<popen>(), B<pclose>():"

#. type: Plain text
#: man-pages/man3/popen.3:62
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/popen.3:73
msgid ""
"The B<popen>()  function opens a process by creating a pipe, forking, and "
"invoking the shell.  Since a pipe is by definition unidirectional, the "
"I<type> argument may specify only reading or writing, not both; the "
"resulting stream is correspondingly read-only or write-only."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:97
msgid ""
"The I<command> argument is a pointer to a null-terminated string containing "
"a shell command line.  This command is passed to I</bin/sh> using the B<-c> "
"flag; interpretation, if any, is performed by the shell.  The I<type> "
"argument is a pointer to a null-terminated string which must contain either "
"the letter \\(aqr\\(aq for reading or the letter \\(aqw\\(aq for writing.  "
"Since glibc 2.9, this argument can additionally include the letter "
"\\(aqe\\(aq, which causes the close-on-exec flag (B<FD_CLOEXEC>)  to be set "
"on the underlying file descriptor; see the description of the B<O_CLOEXEC> "
"flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:113
msgid ""
"The return value from B<popen>()  is a normal standard I/O stream in all "
"respects save that it must be closed with B<pclose>()  rather than "
"B<fclose>(3).  Writing to such a stream writes to the standard input of the "
"command; the command's standard output is the same as that of the process "
"that called B<popen>(), unless this is altered by the command itself.  "
"Conversely, reading from the stream reads the command's standard output, and"
" the command's standard input is the same as that of the process that called"
" B<popen>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:117
msgid "Note that output B<popen>()  streams are fully buffered by default."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:123
msgid ""
"The B<pclose>()  function waits for the associated process to terminate and "
"returns the exit status of the command as returned by B<wait4>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:131
msgid ""
"The B<popen>()  function returns NULL if the B<fork>(2)  or B<pipe>(2)  "
"calls fail, or if it cannot allocate memory."
msgstr ""

#.  These conditions actually give undefined results, so I commented
#.  them out.
#.  .I stream
#.  is not associated with a "popen()ed" command, if
#. .I stream
#.  already "pclose()d", or if
#. type: Plain text
#: man-pages/man3/popen.3:146
msgid ""
"The B<pclose>()  function returns -1 if B<wait4>(2)  returns an error, or "
"some other error is detected.  In the event of an error, these functions set"
" I<errno> to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:165
msgid ""
"The B<popen>()  function does not set I<errno> if memory allocation fails.  "
"If the underlying B<fork>(2)  or B<pipe>(2)  fails, I<errno> is set "
"appropriately.  If the I<type> argument is invalid, and this condition is "
"detected, I<errno> is set to B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:172
msgid ""
"If B<pclose>()  cannot obtain the child status, I<errno> is set to "
"B<ECHILD>."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:178
msgid "The \\(aqe\\(aq value for I<type> is a Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:191
msgid ""
"Since the standard input of a command opened for reading shares its seek "
"offset with the process that called B<popen>(), if the original process has "
"done a buffered read, the command's input position may not be as expected.  "
"Similarly, the output from a command opened for writing may become "
"intermingled with that of the original process.  The latter can be avoided "
"by calling B<fflush>(3)  before B<popen>()."
msgstr ""

#.  .SH HISTORY
#.  A
#.  .BR popen ()
#.  and a
#.  .BR pclose ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: man-pages/man3/popen.3:201
msgid ""
"Failure to execute the shell is indistinguishable from the shell's failure "
"to execute command, or an immediate exit of the command.  The only hint is "
"an exit status of 127."
msgstr ""

#. type: Plain text
#: man-pages/man3/popen.3:210
msgid ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"
msgstr "B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<stdio>(3), B<system>(3)"

#. type: TH
#: man-pages/man3/pthread_create.3:26
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr "PTHREAD_CREATE"

#. type: Plain text
#: man-pages/man3/pthread_create.3:29
msgid "pthread_create - create a new thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:35
#, no-wrap
msgid ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:47
msgid ""
"The B<pthread_create>()  function starts a new thread in the calling "
"process.  The new thread starts execution by invoking I<start_routine>(); "
"I<arg> is passed as the sole argument of I<start_routine>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:49
msgid "The new thread terminates in one of the following ways:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:55
msgid ""
"It calls B<pthread_exit>(3), specifying an exit status value that is "
"available to another thread in the same process that calls "
"B<pthread_join>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:63
msgid ""
"It returns from I<start_routine>().  This is equivalent to calling "
"B<pthread_exit>(3)  with the value supplied in the I<return> statement."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:66
msgid "It is canceled (see B<pthread_cancel>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:72
msgid ""
"Any of the threads in the process calls B<exit>(3), or the main thread "
"performs a return from I<main>().  This causes the termination of all "
"threads in the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:86
msgid ""
"The I<attr> argument points to a I<pthread_attr_t> structure whose contents "
"are used at thread creation time to determine attributes for the new thread;"
" this structure is initialized using B<pthread_attr_init>(3)  and related "
"functions.  If I<attr> is NULL, then the thread is created with default "
"attributes."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:93
msgid ""
"Before returning, a successful call to B<pthread_create>()  stores the ID of"
" the new thread in the buffer pointed to by I<thread>; this identifier is "
"used to refer to the thread in subsequent calls to other pthreads functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:101
msgid ""
"The new thread inherits a copy of the creating thread's signal mask "
"(B<pthread_sigmask>(3)).  The set of pending signals for the new thread is "
"empty (B<sigpending>(2)).  The new thread does not inherit the creating "
"thread's alternate signal stack (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:104
msgid ""
"The new thread inherits the calling thread's floating-point environment "
"(B<fenv>(3))."
msgstr ""

#.  CLOCK_THREAD_CPUTIME_ID in clock_gettime(2)
#. type: Plain text
#: man-pages/man3/pthread_create.3:109
msgid ""
"The initial value of the new thread's CPU-time clock is 0 (see "
"B<pthread_getcpuclockid>(3))."
msgstr ""

#. type: SS
#: man-pages/man3/pthread_create.3:109
#, no-wrap
msgid "Linux-specific details"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:115
msgid ""
"The new thread inherits copies of the calling thread's capability sets (see "
"B<capabilities>(7))  and CPU affinity mask (see B<sched_setaffinity>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:122
msgid ""
"On success, B<pthread_create>()  returns 0; on error, it returns an error "
"number, and the contents of I<*thread> are undefined."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:126
msgid "Insufficient resources to create another thread."
msgstr ""

#.  NOTE! The following should match the description in fork(2)
#. type: Plain text
#: man-pages/man3/pthread_create.3:144
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error: the B<RLIMIT_NPROC> soft "
"resource limit (set via B<setrlimit>(2)), which limits the number of "
"processes and threads for a real user ID, was reached; the kernel's system-"
"wide limit on the number of processes threads, I</proc/sys/kernel/threads-"
"max>, was reached (see B<proc>(5)); or the maximum number of PIDs, "
"I</proc/sys/kernel/pid_max>, was reached (see B<proc>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:148
msgid "Invalid settings in I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:153
msgid ""
"No permission to set the scheduling policy and parameters specified in "
"I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:167
msgid ""
"See B<pthread_self>(3)  for further information on the thread ID returned in"
" I<*thread> by B<pthread_create>().  Unless real-time scheduling policies "
"are being employed, after a call to B<pthread_create>(), it is indeterminate"
" which thread\\(emthe caller or the new thread\\(emwill next execute."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:187
msgid ""
"A thread may either be I<joinable> or I<detached>.  If a thread is joinable,"
" then another thread can call B<pthread_join>(3)  to wait for the thread to "
"terminate and fetch its exit status.  Only when a terminated joinable thread"
" has been joined are the last of its resources released back to the system."
"  When a detached thread terminates, its resources are automatically "
"released back to the system: it is not possible to join with the thread in "
"order to obtain its exit status.  Making a thread detached is useful for "
"some types of daemon threads whose exit status the application does not need"
" to care about.  By default, a new thread is created in a joinable state, "
"unless I<attr> was set to create the thread in a detached state (using "
"B<pthread_attr_setdetachstate>(3))."
msgstr ""

#.  FIXME . Perhaps some of the following detail should be in
#.  a future pthread_attr_setstacksize(3) page.
#. type: Plain text
#: man-pages/man3/pthread_create.3:203
msgid ""
"On Linux/x86-32, the default stack size for a new thread is 2 megabytes.  "
"Under the NPTL threading implementation, if the B<RLIMIT_STACK> soft "
"resource limit I<at the time the program started> has any value other than "
"\"unlimited\", then it determines the default stack size of new threads.  "
"Using B<pthread_attr_setstacksize>(3), the stack size attribute can be "
"explicitly set in the I<attr> argument used to create a thread, in order to "
"obtain a stack size other than the default."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:209
msgid ""
"In the obsolete LinuxThreads implementation, each of the threads in a "
"process has a different process ID.  This is in violation of the POSIX "
"threads specification, and is the source of many other nonconformances to "
"the standard; see B<pthreads>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:213
msgid ""
"The program below demonstrates the use of B<pthread_create>(), as well as a "
"number of other functions in the pthreads API."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:218
msgid ""
"In the following run, on a system providing the NPTL threading "
"implementation, the stack size defaults to the value given by the \"stack "
"size\" resource limit:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:230
#, no-wrap
msgid ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x800000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:236
msgid ""
"In the next run, the program explicitly sets a stack size of 1MB (using "
"B<pthread_attr_setstacksize>(3))  for the created threads:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:246
#, no-wrap
msgid ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:258
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:264
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr "#define handle_error(msg) \\e\n        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:270
#, no-wrap
msgid ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:273
#, no-wrap
msgid ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:279
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = arg;\n"
"    char *uargv, *p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:282
#, no-wrap
msgid ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:286
#, no-wrap
msgid ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:289
#, no-wrap
msgid ""
"    for (p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:292
#, no-wrap
msgid ""
"    return uargv;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:301
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, tnum, opt, num_threads;\n"
"    struct thread_info *tinfo;\n"
"    pthread_attr_t attr;\n"
"    int stack_size;\n"
"    void *res;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:303
#, no-wrap
msgid "    /* The \"-s\" option specifies a stack size for our threads */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:310
#, no-wrap
msgid ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:317
#, no-wrap
msgid ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:319
#, no-wrap
msgid "    num_threads = argc - optind;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:321
#, no-wrap
msgid "    /* Initialize thread creation attributes */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:325
#, no-wrap
msgid ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:331
#, no-wrap
msgid ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:333
#, no-wrap
msgid "    /* Allocate memory for pthread_create() arguments */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:337
#, no-wrap
msgid ""
"    tinfo = calloc(num_threads, sizeof(struct thread_info));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:339
#, no-wrap
msgid "    /* Create one thread for each command-line argument */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:343
#, no-wrap
msgid ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:346
#, no-wrap
msgid ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:352
#, no-wrap
msgid ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:355
#, no-wrap
msgid ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:359
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:361
#, no-wrap
msgid "    /* Now join with each thread, and display its returned value */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:366
#, no-wrap
msgid ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:371
#, no-wrap
msgid ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:375
#, no-wrap
msgid ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_create.3:388
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), "
"B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_attr_setdetachstate.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETDETACHSTATE"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:30
msgid ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach "
"state attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<, int *>I<detachstate>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:53
msgid ""
"The B<pthread_attr_setdetachstate>()  function sets the detach state "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<detachstate>.  The detach state attribute determines "
"whether a thread created using the thread attributes object I<attr> will be "
"created in a joinable or a detached state."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:56
msgid "The following values may be specified in I<detachstate>:"
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setdetachstate.3:56
#, no-wrap
msgid "B<PTHREAD_CREATE_DETACHED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:61
msgid ""
"Threads that are created using I<attr> will be created in a detached state."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setdetachstate.3:61
#, no-wrap
msgid "B<PTHREAD_CREATE_JOINABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:66
msgid ""
"Threads that are created using I<attr> will be created in a joinable state."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:70
msgid ""
"The default setting of the detach state attribute in a newly initialized "
"thread attributes object is B<PTHREAD_CREATE_JOINABLE>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:77
msgid ""
"The B<pthread_attr_getdetachstate>()  returns the detach state attribute of "
"the thread attributes object I<attr> in the buffer pointed to by "
"I<detachstate>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:83
msgid "B<pthread_attr_setdetachstate>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:87
msgid "An invalid value was specified in I<detachstate>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:94
msgid ""
"The B<pthread_attr_setdetachstate>()  and B<pthread_attr_getdetachstate>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:100
msgid ""
"See B<pthread_create>(3)  for more details on detached and joinable threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:108
msgid ""
"A thread that is created in a joinable state should eventually either be "
"joined using B<pthread_join>(3)  or detached using B<pthread_detach>(3); see"
" B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:115
msgid ""
"It is an error to specify the thread ID of a thread that was created in a "
"detached state in a later call to B<pthread_detach>(3)  or "
"B<pthread_join>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:118
msgid "See B<pthread_attr_init>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:123
msgid ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_yield.3:25
#, no-wrap
msgid "PTHREAD_YIELD"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:28
msgid "pthread_yield - yield the processor"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:34
#, no-wrap
msgid "B<int pthread_yield(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:44
msgid ""
"B<pthread_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is placed at the end of the run queue for its static priority and "
"another thread is scheduled to run.  For further details, see "
"B<sched_yield>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:49
msgid ""
"On success, B<pthread_yield>()  returns 0; on error, it returns an error "
"number."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:53
msgid ""
"On Linux, this call always succeeds (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:58
msgid "The B<pthread_yield>()  function is thread-safe."
msgstr ""

#.  e.g., the BSDs, Tru64, AIX, and Irix.
#. type: Plain text
#: man-pages/man3/pthread_yield.3:64
msgid ""
"This call is nonstandard, but present on several other systems.  Use the "
"standardized B<sched_yield>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:67
msgid "On Linux, this function is implemented as a call to B<sched_yield>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_yield.3:70
msgid "B<sched_yield>(2), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/posix_openpt.3:25
#, no-wrap
msgid "POSIX_OPENPT"
msgstr "POSIX_OPENPT"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:28
msgid "posix_openpt - open a pseudoterminal device"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:32
#, no-wrap
msgid ""
"B<#include E<lt>stdlib.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\nB<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:34
#, no-wrap
msgid "B<int posix_openpt(int >I<flags>B<);>\n"
msgstr "B<int posix_openpt(int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:44
msgid "B<posix_openpt>(): _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "B<posix_openpt>(): _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:50
msgid ""
"The B<posix_openpt>()  function opens an unused pseudoterminal master "
"device, returning a file descriptor that can be used to refer to that "
"device."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:55
msgid ""
"The I<flags> argument is a bit mask that ORs together zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: man-pages/man3/posix_openpt.3:55
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:59
msgid ""
"Open the device for both reading and writing.  It is usual to specify this "
"flag."
msgstr ""

#. type: TP
#: man-pages/man3/posix_openpt.3:59
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr "B<O_NOCTTY>"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:62
msgid "Do not make this device the controlling terminal for the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:70
msgid ""
"On success, B<posix_openpt>()  returns a nonnegative file descriptor which "
"is the lowest numbered unused descriptor.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:73
msgid "See B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:77
msgid ""
"Glibc support for B<posix_openpt>()  has been provided since version 2.2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:82
msgid "The B<posix_openpt>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:87
msgid ""
"B<posix_openpt>()  is part of the UNIX 98 pseudoterminal support (see "
"B<pts>(4)).  This function is specified in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:94
msgid ""
"The B<posix_openpt>()  function is a recent invention in POSIX.  Some UNIX "
"implementations that support System V (aka UNIX 98) pseudoterminals don't "
"have this function, but it is easy to implement:"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:102
#, no-wrap
msgid ""
"int\n"
"posix_openpt(int flags)\n"
"{\n"
"    return open(\"/dev/ptmx\", flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:111
msgid ""
"Calling B<posix_openpt>()  creates a pathname for the corresponding "
"pseudoterminal slave device.  The pathname of the slave device can be "
"obtained using B<ptsname>(3).  The slave device pathname exists only as long"
" as the master device is open."
msgstr ""

#. type: Plain text
#: man-pages/man3/posix_openpt.3:118
msgid ""
"B<open>(2), B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), "
"B<pts>(4), B<pty>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_setschedprio.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPRIO"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:29
msgid "pthread_setschedprio - set scheduling priority of a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:34
#, no-wrap
msgid "B<int pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"
msgstr ""

#.  FIXME . nptl/pthread_setschedprio.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#.  nptl/pthread_setschedparam.c has a similar case.
#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:53
msgid ""
"The B<pthread_setschedprio>()  function sets the scheduling priority of the "
"thread I<thread> to the value specified in I<prio>.  (By contrast "
"B<pthread_setschedparam>(3)  changes both the scheduling policy and priority"
" of a thread.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:61
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number.  If B<pthread_setschedprio>()  fails, the scheduling priority of "
"I<thread> is not changed."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:66
msgid ""
"I<prio> is not valid for the scheduling policy of the specified thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:70
msgid ""
"The caller does not have appropriate privileges to set the specified "
"priority."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:81
msgid ""
"POSIX.1-2001 also documents an B<ENOTSUP> (\"attempt was made to set the "
"priority to an unsupported value\") error for B<pthread_setschedparam>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:83
msgid "This function is available in glibc since version 2.3.4."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:88
msgid "The B<pthread_setschedprio>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:96
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling priority, and details of the permitted ranges"
" for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:109
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3),"
" B<pthread_setschedparam>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/putenv.3:36
#, no-wrap
msgid "PUTENV"
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:39
msgid "putenv - change or add an environment variable"
msgstr ""

#.  Not: const char *
#. type: Plain text
#: man-pages/man3/putenv.3:45
#, no-wrap
msgid "B<int putenv(char *>I<string>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:54
msgid "B<putenv>(): _SVID_SOURCE || _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:67
msgid ""
"The B<putenv>()  function adds or changes the value of environment "
"variables.  The argument I<string> is of the form I<name>=I<value>.  If "
"I<name> does not already exist in the environment, then I<string> is added "
"to the environment.  If I<name> does exist, then the value of I<name> in the"
" environment is changed to I<value>.  The string pointed to by I<string> "
"becomes part of the environment, so altering the string changes the "
"environment."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:75
msgid ""
"The B<putenv>()  function returns zero on success, or nonzero if an error "
"occurs.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:79
msgid "Insufficient space to allocate new environment."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:81
msgid "SVr4, POSIX.1-2001, 4.3BSD."
msgstr "SVr4, POSIX.1-2001, 4.3BSD."

#. type: Plain text
#: man-pages/man3/putenv.3:86
msgid ""
"The B<putenv>()  function is not required to be reentrant, and the one in "
"libc4, libc5 and glibc 2.0 is not, but the glibc 2.1 version is."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:99
msgid ""
"Description for libc4, libc5, glibc: If the argument I<string> is of the "
"form I<name>, and does not contain an \\(aq=\\(aq character, then the "
"variable I<name> is removed from the environment.  If B<putenv>()  has to "
"allocate a new array I<environ>, and the previous array was also allocated "
"by B<putenv>(), then it will be freed.  In no case will the old storage "
"associated to the environment variable itself be freed."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:115
msgid ""
"The libc4 and libc5 and glibc 2.1.2 versions conform to SUSv2: the pointer "
"I<string> given to B<putenv>()  is used.  In particular, this string becomes"
" part of the environment; changing it later will change the environment.  "
"(Thus, it is an error is to call B<putenv>()  with an automatic variable as "
"the argument, then return from the calling function while I<string> is still"
" part of the environment.)  However, glibc 2.0-2.1.1 differs: a copy of the "
"string is used.  On the one hand this causes a memory leak, and on the other"
" hand it violates SUSv2.  This has been fixed in glibc 2.1.2."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:117
msgid "The 4.4BSD version, like glibc 2.0, uses a copy."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:119
msgid ""
"SUSv2 removes the I<const> from the prototype, and so does glibc 2.1.3."
msgstr ""

#. type: Plain text
#: man-pages/man3/putenv.3:124
msgid ""
"B<clearenv>(3), B<getenv>(3), B<setenv>(3), B<unsetenv>(3), B<environ>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/putwchar.3:17
#, no-wrap
msgid "PUTWCHAR"
msgstr ""

#. type: TH
#: man-pages/man3/putwchar.3:17
#, no-wrap
msgid "1999-07-25"
msgstr "1999-07-25"

#. type: Plain text
#: man-pages/man3/putwchar.3:20
msgid "putwchar - write a wide character to standard output"
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/putwchar.3:25
#, no-wrap
msgid "B<wint_t putwchar(wchar_t >I<wc>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:49
msgid ""
"The B<putwchar>()  function is the wide-character equivalent of the "
"B<putchar>(3)  function.  It writes the wide character I<wc> to I<stdout>.  "
"If I<ferror(stdout)> becomes true, it returns B<WEOF>.  If a wide character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>."
"  Otherwise, it returns I<wc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:52
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:60
msgid ""
"The B<putwchar>()  function returns I<wc> if no error occurred, or B<WEOF> "
"to indicate an error."
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:62
msgid "C99."
msgstr "C99."

#. type: Plain text
#: man-pages/man3/putwchar.3:69
msgid ""
"The behavior of B<putwchar>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:75
msgid ""
"It is reasonable to expect that B<putwchar>()  will actually write the "
"multibyte sequence corresponding to the wide character I<wc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/putwchar.3:77
msgid "B<fputwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_getcpuclockid.3:26
#, no-wrap
msgid "PTHREAD_GETCPUCLOCKID"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:29
msgid "pthread_getcpuclockid - retrieve ID of a thread's CPU time clock"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:33
#, no-wrap
msgid ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:35
#, no-wrap
msgid ""
"B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t "
"*>I<clock_id>B<);>\n"
msgstr ""

#.  The clockid is constructed as follows:
#.  *clockid = CLOCK_THREAD_CPUTIME_ID | (pd->tid << CLOCK_IDFIELD_SIZE)
#.  where CLOCK_IDFIELD_SIZE is 3.
#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:46
msgid ""
"The B<pthread_getcpuclockid>()  function returns the clock ID for the CPU "
"time clock of the thread I<thread>."
msgstr ""

#.  CLOCK_THREAD_CPUTIME_ID not defined
#.  Looking at nptl/pthread_getcpuclockid.c an ERANGE error would
#.  be possible if kernel thread IDs took more than 29 bits (which
#.  they currently cannot).
#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:58
msgid "Per-thread CPU time clocks are not supported by the system."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:65
msgid "This function is available in glibc since version 2.2."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:70
msgid "The B<pthread_getcpuclockid>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:83
msgid ""
"When I<thread> refers to the calling thread, this function returns an "
"identifier that refers to the same clock manipulated by B<clock_gettime>(2)"
"  and B<clock_settime>(2)  when given the clock ID "
"B<CLOCK_THREAD_CPUTIME_ID>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:89
msgid ""
"The program below creates a thread and then uses B<clock_gettime>(2)  to "
"retrieve the total process CPU time, and the per-thread CPU time consumed by"
" the two threads.  The following shell session shows an example run:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:99
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:105
#, no-wrap
msgid "/* Link with \"-lrt\" */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:113
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:127
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:132
#, no-wrap
msgid ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:138
#, no-wrap
msgid ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4ld.%03ld\\en\", ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:145
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int j, s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:149
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:152
#, no-wrap
msgid ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:156
#, no-wrap
msgid ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:158
#, no-wrap
msgid "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:163
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:166
#, no-wrap
msgid ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:171
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:174
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:182
msgid ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_setcancelstate.3:26
#, no-wrap
msgid "PTHREAD_SETCANCELSTATE"
msgstr "PTHREAD_SETCANCELSTATE"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:30
msgid ""
"pthread_setcancelstate, pthread_setcanceltype - set cancelability state and "
"type"
msgstr "pthread_setcancelstate, pthread_setcanceltype - установка состояния и типа отменяемости"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:36
#, no-wrap
msgid ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"
msgstr "B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\nB<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:51
msgid ""
"The B<pthread_setcancelstate>()  sets the cancelability state of the calling"
" thread to the value given in I<state>.  The previous cancelability state of"
" the thread is returned in the buffer pointed to by I<oldstate>.  The "
"I<state> argument must have one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:51
#, no-wrap
msgid "B<PTHREAD_CANCEL_ENABLE>"
msgstr "B<PTHREAD_CANCEL_ENABLE>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:58
msgid ""
"The thread is cancelable.  This is the default cancelability state in all "
"new threads, including the initial thread.  The thread's cancelability type "
"determines when a cancelable thread will respond to a cancellation request."
msgstr "Поток является отменяемым. Для всех новых потоков, включая первичный это состояние является основным по умолчанию. Тип отменяемости потока определяет, когда поток будет отвечать на запрос об отмене."

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:58
#, no-wrap
msgid "B<PTHREAD_CANCEL_DISABLE>"
msgstr "B<PTHREAD_CANCEL_DISABLE>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:63
msgid ""
"The thread is not cancelable.  If a cancellation request is received, it is "
"blocked until cancelability is enabled."
msgstr "Поток является неотменяемым. Если был получен запрос об отмене, он будет блокироваться до тех пор, пока не будет включена отменяемость."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:75
msgid ""
"The B<pthread_setcanceltype>()  sets the cancelability type of the calling "
"thread to the value given in I<type>.  The previous cancelability type of "
"the thread is returned in the buffer pointed to by I<oldtype>.  The I<type> "
"argument must have one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:75
#, no-wrap
msgid "B<PTHREAD_CANCEL_DEFERRED>"
msgstr "B<PTHREAD_CANCEL_DEFERRED>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:82
msgid ""
"A cancellation request is deferred until the thread next calls a function "
"that is a cancellation point (see B<pthreads>(7)).  This is the default "
"cancelability type in all new threads, including the initial thread."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:82
#, no-wrap
msgid "B<PTHREAD_CANCEL_ASYNCHRONOUS>"
msgstr "B<PTHREAD_CANCEL_ASYNCHRONOUS>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:88
msgid ""
"The thread can be canceled at any time.  (Typically, it will be canceled "
"immediately upon receiving a cancellation request, but the system doesn't "
"guarantee this.)"
msgstr "Поток может быть отменен в любой момент (практически сразу же после получения запроса об отмене, однако система не гарантирует этого)."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:92
msgid ""
"The set-and-get operation performed by each of these functions is atomic "
"with respect to other threads in the process calling the same function."
msgstr "Операции установки и получения (set-and-get), выполняемые каждой из этих функций, являются атомарными для предотвращения пересечения с другими процессами, вызывающими ту же функцию."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:99
msgid "The B<pthread_setcancelstate>()  can fail with the following error:"
msgstr "B<pthread_setcancelstate>() может завершиться неудачей со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:103
msgid "Invalid value for I<state>."
msgstr "Неправильное значение для I<state>."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:107
msgid "The B<pthread_setcanceltype>()  can fail with the following error:"
msgstr "B<pthread_setcanceltype>() может завершиться неудачей со следующей ошибкой:"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:113
msgid "Invalid value for I<type>."
msgstr "Неправильное значение для I<type>."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:120
msgid ""
"The B<pthread_setcancelstate>()  and B<pthread_setcanceltype>()  functions "
"are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:125
msgid ""
"For details of what happens when a thread is canceled, see "
"B<pthread_cancel>(3)."
msgstr "Для более подробной информации о том, что происходит с отменяемым потоком см. B<pthread_cancel>(3)."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:132
msgid ""
"Briefly disabling cancelability is useful if a thread performs some critical"
" action that must not be interrupted by a cancellation request.  Beware of "
"disabling cancelability for long periods, or around operations that may "
"block for long periods, since that will render the thread unresponsive to "
"cancellation requests."
msgstr ""

#. type: SS
#: man-pages/man3/pthread_setcancelstate.3:132
#, no-wrap
msgid "Asynchronous cancelability"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:151
msgid ""
"Setting the cancelability type to B<PTHREAD_CANCEL_ASYNCHRONOUS> is rarely "
"useful.  Since the thread could be canceled at I<any> time, it cannot safely"
" reserve resources (e.g., allocating memory with B<malloc>(3)), acquire "
"mutexes, semaphores, or locks, and so on.  Reserving resources is unsafe "
"because the application has no way of knowing what the state of these "
"resources is when the thread is canceled; that is, did cancellation occur "
"before the resources were reserved, while they were reserved, or after they "
"were released? Furthermore, some internal data structures (e.g., the linked "
"list of free blocks managed by the B<malloc>(3)  family of functions) may be"
" left in an inconsistent state if cancellation occurs in the middle of the "
"function call.  Consequently, clean-up handlers cease to be useful."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:162
msgid ""
"Functions that can be safely asynchronously canceled are called I<async-"
"cancel-safe functions>.  POSIX.1-2001 requires only that "
"B<pthread_cancel>(3), B<pthread_setcancelstate>(), and "
"B<pthread_setcanceltype>()  be async-cancel-safe.  In general, other library"
" functions can't be safely called from an asynchronously cancelable thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:165
msgid ""
"One of the few circumstances in which asynchronous cancelability is useful "
"is for cancellation of a thread that is in a pure compute-bound loop."
msgstr ""

#.  It looks like at least Solaris, FreeBSD and Tru64 support this.
#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:183
msgid ""
"The Linux threading implementations permit the I<oldstate> argument of "
"B<pthread_setcancelstate>()  to be NULL, in which case the information about"
" the previous cancelability state is not returned to the caller.  Many other"
" implementations also permit a NULL I<oldstat> argument, but POSIX.1-2001 "
"does not specify this point, so portable applications should always specify "
"a non-NULL value in I<oldstate>.  A precisely analogous set of statements "
"applies for the I<oldtype> argument of B<pthread_setcanceltype>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:186
msgid "See B<pthread_cancel>(3)."
msgstr "См. B<pthread_cancel>(3)."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:190
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"
msgstr "B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setstack.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACK"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:30
msgid ""
"pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in "
"thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(const pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:50
msgid "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:52
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:68
msgid ""
"The B<pthread_attr_setstack>()  function sets the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> to "
"the values specified in I<stackaddr> and I<stacksize>, respectively.  These "
"attributes specify the location and size of the stack that should be used by"
" a thread that is created using the thread attributes object I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:74
msgid ""
"I<stackaddr> should point to the lowest addressable byte of a buffer of "
"I<stacksize> bytes that was allocated by the caller.  The pages of the "
"allocated buffer should be both readable and writable."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:85
msgid ""
"The B<pthread_attr_getstack>()  function returns the stack address and stack"
" size attributes of the thread attributes object referred to by I<attr> in "
"the buffers pointed to by I<stackaddr> and I<stacksize>, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:91
msgid "B<pthread_attr_setstack>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:102
msgid ""
"I<stacksize> is less than B<PTHREAD_STACK_MIN> (16384) bytes.  On some "
"systems, this error may also occur if I<stackaddr> or I<stackaddr\\ +\\ "
"stacksize> is not suitably aligned."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:110
msgid ""
"POSIX.1-2001 also documents an B<EACCES> error if the stack area described "
"by I<stackaddr> and I<stacksize> is not both readable and writable by the "
"caller."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:112
msgid "These functions are provided by glibc since version 2.2."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:119
msgid ""
"The B<pthread_attr_setstack>()  and B<pthread_attr_getstack>()  functions "
"are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:129
msgid ""
"These functions are provided for applications that must ensure that a "
"thread's stack is placed in a particular location.  For most applications, "
"this is not necessary, and the use of these functions should be avoided.  "
"(Use B<pthread_attr_setstacksize>(3)  if an application simply requires a "
"stack size other than the default.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:140
msgid ""
"When an application employs B<pthread_attr_setstack>(), it takes over the "
"responsibility of allocating the stack.  Any guard size value that was set "
"using B<pthread_attr_setguardsize>(3)  is ignored.  If deemed necessary, it "
"is the application's responsibility to allocate a guard area (one or more "
"pages protected against reading and writing)  to handle the possibility of "
"stack overflow."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:151
msgid ""
"The address specified in I<stackaddr> should be suitably aligned: for full "
"portability, align it on a page boundary (I<sysconf(_SC_PAGESIZE)>).  "
"B<posix_memalign>(3)  may be useful for allocation.  Probably, I<stacksize> "
"should also be a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:159
msgid ""
"If I<attr> is used to create multiple threads, then the caller must change "
"the stack address attribute between calls to B<pthread_create>(3); "
"otherwise, the threads will attempt to use the same memory area for their "
"stacks, and chaos will ensue."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:173
msgid ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_attr_setinheritsched.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETINHERITSCHED"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:30
msgid ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get "
"inherit-scheduler attribute in thread attributes object"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:55
msgid ""
"The B<pthread_attr_setinheritsched>()  function sets the inherit-scheduler "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<inheritsched>.  The inherit-scheduler attribute "
"determines whether a thread created using the thread attributes object "
"I<attr> will inherit its scheduling attributes from the calling thread or "
"whether it will take them from I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:64
msgid ""
"The following scheduling attributes are affected by the inherit-scheduler "
"attribute: scheduling policy (B<pthread_attr_setschedpolicy>(3)), scheduling"
" priority (B<pthread_attr_setschedparam>(3)), and contention scope "
"(B<pthread_attr_setscope>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:67
msgid "The following values may be specified in I<inheritsched>:"
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setinheritsched.3:67
#, no-wrap
msgid "B<PTHREAD_INHERIT_SCHED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:75
msgid ""
"Threads that are created using I<attr> inherit scheduling attributes from "
"the creating thread; the scheduling attributes in I<attr> are ignored."
msgstr ""

#. type: TP
#: man-pages/man3/pthread_attr_setinheritsched.3:75
#, no-wrap
msgid "B<PTHREAD_EXPLICIT_SCHED>"
msgstr ""

#.  FIXME what are the defaults for scheduler settings?
#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:82
msgid ""
"Threads that are created using I<attr> take their scheduling attributes from"
" the values specified by the attributes object."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:86
msgid ""
"The default setting of the inherit-scheduler attribute in a newly "
"initialized thread attributes object is B<PTHREAD_INHERIT_SCHED>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:93
msgid ""
"The B<pthread_attr_getinheritsched>()  returns the inherit-scheduler "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<inheritsched>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:99
msgid "B<pthread_attr_setinheritsched>()  can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:103
msgid "Invalid value in I<inheritsched>."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:110
msgid ""
"POSIX.1-2001 also documents an optional B<ENOTSUP> error (\"attempt was made"
" to set the attribute to an unsupported value\") for "
"B<pthread_attr_setinheritsched>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:117
msgid ""
"The B<pthread_attr_setinheritsched>()  and B<pthread_attr_getinheritsched>()"
"  functions are thread-safe."
msgstr ""

#.  FIXME . Track status of the following bug:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7007
#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:135
msgid ""
"As at glibc 2.8, if a thread attributes object is initialized using "
"B<pthread_attr_init>(3), then the scheduling policy of the attributes object"
" is set to B<SCHED_OTHER> and the scheduling priority is set to 0.  However,"
" if the inherit-scheduler attribute is then set to "
"B<PTHREAD_EXPLICIT_SCHED>, then a thread created using the attribute object "
"wrongly inherits its scheduling attributes from the creating thread.  This "
"bug does not occur if either the scheduling policy or scheduling priority "
"attribute is explicitly set in the thread attributes object before calling "
"B<pthread_create>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:149
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>,(7)  B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_kill_other_threads_np.3:26
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:29
msgid "pthread_kill_other_threads_np - terminate all other threads in process"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:34
#, no-wrap
msgid "B<void pthread_kill_other_threads_np(void);>\n"
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:47
msgid ""
"B<pthread_kill_other_threads_np>()  has an effect only in the LinuxThreads "
"threading implementation.  On that implementation, calling this function "
"causes the immediate termination of all threads in the application, except "
"the calling thread.  The cancellation state and cancellation type of the to-"
"be-terminated threads are ignored, and the cleanup handlers are not called "
"in those threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:52
msgid "The B<pthread_kill_other_threads_np>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:64
msgid ""
"B<pthread_kill_other_threads_np>()  is intended to be called just before a "
"thread calls B<execve>(2)  or a similar function.  This function is designed"
" to address a limitation in the obsolete LinuxThreads implementation whereby"
" the other threads of an application are not automatically terminated (as "
"POSIX.1-2001 requires) during B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:71
msgid ""
"In the NPTL threading implementation, B<pthread_kill_other_threads_np>()  "
"exists, but does nothing.  (Nothing needs to be done, because the "
"implementation does the right thing during an B<execve>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:76
msgid ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_cleanup_push_defer_np.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH_DEFER_NP"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:30
msgid ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - push and pop"
" thread cancellation clean-up handlers while saving cancelability type"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:49
msgid "B<pthread_cleanup_push_defer_np>(), B<pthread_cleanup_pop_defer_np>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:51
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:59
msgid ""
"These functions are the same as B<pthread_cleanup_push>(3)  and "
"B<pthread_cleanup_pop>(3), except for the differences noted on this page."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:72
msgid ""
"Like B<pthread_cleanup_push>(3), B<pthread_cleanup_push_defer_np>()  pushes "
"I<routine> onto the thread's stack of cancellation clean-up handlers.  In "
"addition, it also saves the thread's current cancelability type, and sets "
"the cancelability type to \"deferred\" (see B<pthread_setcanceltype>(3)); "
"this ensures that cancellation clean-up will occur even if the thread's "
"cancelability type was \"asynchronous\" before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:81
msgid ""
"Like B<pthread_cleanup_pop>(3), B<pthread_cleanup_pop_restore_np>()  pops "
"the top-most clean-up handler from the thread's stack of cancellation clean-"
"up handlers.  In addition, it restores the thread's cancelability type to "
"its value at the time of the matching B<pthread_cleanup_push_defer_np>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:87
msgid ""
"The caller must ensure that calls to these functions are paired within the "
"same function, and at the same lexical nesting level.  Other restrictions "
"apply, as described in B<pthread_cleanup_push>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:89
msgid "This sequence of calls:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:94
#, no-wrap
msgid ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:98
msgid "is equivalent to (but shorter and more efficient than):"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:104
#, no-wrap
msgid "int oldtype;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:110
#, no-wrap
msgid ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:122
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/profil.3:28
#, no-wrap
msgid "PROFIL"
msgstr "PROFIL"

#. type: Plain text
#: man-pages/man3/profil.3:31
msgid "profil - execution time profile"
msgstr ""

#. type: Plain text
#: man-pages/man3/profil.3:37
#, no-wrap
msgid ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<,>\n"
"B<           size_t >I<offset>B<, unsigned int >I<scale>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/profil.3:46
msgid "B<profil>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr "B<profil>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: man-pages/man3/profil.3:68
msgid ""
"This routine provides a means to find out in what areas your program spends "
"most of its time.  The argument I<buf> points to I<bufsiz> bytes of core.  "
"Every virtual 10 milliseconds, the user's program counter (PC)  is examined:"
" I<offset> is subtracted and the result is multiplied by I<scale> and "
"divided by 65536.  If the resulting value is less than I<bufsiz>, then the "
"corresponding entry in I<buf> is incremented.  If I<buf> is NULL, profiling "
"is disabled."
msgstr ""

#. type: Plain text
#: man-pages/man3/profil.3:70
msgid "Zero is always returned."
msgstr "Всегда возвращается ноль."

#. type: Plain text
#: man-pages/man3/profil.3:72
msgid "Similar to a call in SVr4 (but not POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/profil.3:78
msgid ""
"B<profil>()  cannot be used on a program that also uses B<ITIMER_PROF> "
"interval timers (see B<setitimer>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/profil.3:81
msgid ""
"True kernel profiling provides more accurate results.  Libc 4.4 contained a "
"kernel patch providing a system call profil."
msgstr ""

#. type: Plain text
#: man-pages/man3/profil.3:86
msgid ""
"B<gprof>(1), B<sprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/putpwent.3:30
#, no-wrap
msgid "PUTPWENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:33
msgid "putpwent - write a password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:38
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:40
#, no-wrap
msgid "B<int putpwent(const struct passwd *>I<p>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:49
msgid "B<putpwent>(): _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:54
msgid ""
"The B<putpwent>()  function writes a password entry from the structure I<p> "
"in the file associated with I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:56
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:68
#, no-wrap
msgid ""
"struct passwd {\n"
"    char    *pw_name;        /* username */\n"
"    char    *pw_passwd;      /* user password */\n"
"    uid_t    pw_uid;         /* user ID */\n"
"    gid_t    pw_gid;         /* group ID */\n"
"    char    *pw_gecos;       /* real name */\n"
"    char    *pw_dir;         /* home directory */\n"
"    char    *pw_shell;       /* shell program */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:78
msgid ""
"The B<putpwent>()  function returns 0 on success, or -1 if an error occurs."
"  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:82
msgid "Invalid (NULL) argument given."
msgstr ""

#. type: Plain text
#: man-pages/man3/putpwent.3:84
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man3/putpwent.3:91
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<getpwuid>(3), B<setpwent>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/pthread_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:30
msgid ""
"pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and"
" parameters of a thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                          const struct sched_param *>I<param>B<);>\n"
"B<int pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                          struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:46
msgid ""
"The B<pthread_setschedparam>()  function sets the scheduling policy and "
"parameters of the thread I<thread>."
msgstr ""

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:57
msgid ""
"I<policy> specifies the new scheduling policy for I<thread>.  The supported "
"values for I<policy>, and their semantics, are described in B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:63
msgid ""
"The structure pointed to by I<param> specifies the new scheduling parameters"
" for I<thread>.  Scheduling parameters are maintained in the following "
"structure:"
msgstr ""

#.  FIXME . nptl/pthread_setschedparam.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:104
msgid ""
"The B<pthread_getschedparam>()  function returns the scheduling policy and "
"parameters of the thread I<thread>, in the buffers pointed to by I<policy> "
"and I<param>, respectively.  The returned priority value is that set by the "
"most recent B<pthread_setschedparam>(), B<pthread_setschedprio>(3), or "
"B<pthread_create>(3)  call that affected I<thread>.  The returned priority "
"does not reflect any temporary priority adjustments as a result of calls to "
"any priority inheritance or priority ceiling functions (see, for example, "
"B<pthread_mutexattr_setprioceiling>(3)  and "
"B<pthread_mutexattr_setprotocol>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:112
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number.  If B<pthread_setschedparam>()  fails, the scheduling policy and "
"parameters of I<thread> are not changed."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:114
msgid "Both of these functions can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:122
msgid ""
"B<pthread_setschedparam>()  may additionally fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:129
msgid ""
"I<policy> is not a recognized policy, or I<param> does not make sense for "
"the I<policy>."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:133
msgid ""
"The caller does not have appropriate privileges to set the specified "
"scheduling policy and parameters."
msgstr ""

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:141
msgid ""
"POSIX.1-2001 also documents an B<ENOTSUP> (\"attempt was made to set the "
"policy or scheduling parameters to an unsupported value\") error for "
"B<pthread_setschedparam>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:148
msgid ""
"The B<pthread_setschedparam>()  and B<pthread_getschedparam>()  functions "
"are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:156
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling policy and priority, and details of the "
"permitted ranges for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:163
msgid ""
"The program below demonstrates the use of B<pthread_setschedparam>()  and "
"B<pthread_getschedparam>(), as well as the use of a number of other "
"scheduling-related pthreads functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:179
msgid ""
"In the following run, the main thread sets its scheduling policy to "
"B<SCHED_FIFO> with a priority of 10, and initializes a thread attributes "
"object with a scheduling policy attribute of B<SCHED_RR> and a scheduling "
"priority attribute of 20.  The program then sets (using "
"B<pthread_attr_setinheritsched>(3))  the inherit scheduler attribute of the "
"thread attributes object to B<PTHREAD_EXPLICIT_SCHED>, meaning that threads "
"created using this attributes object should take their scheduling attributes"
" from the thread attributes object.  The program then creates a thread using"
" the thread attributes object, and that thread displays its scheduling "
"policy and priority."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:187
#, no-wrap
msgid ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:191
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:194
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:199
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the values specified in the thread attributes object."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:206
msgid ""
"The next run is the same as the previous, except that the inherit scheduler "
"attribute is set to B<PTHREAD_INHERIT_SCHED>, meaning that threads created "
"using the thread attributes object should ignore the scheduling attributes "
"specified in the attributes object and instead take their scheduling "
"attributes from the creating thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:212
#, no-wrap
msgid ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:216
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:219
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:225
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the creating thread, rather than the thread attributes "
"object."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:231
msgid ""
"Note that if we had omitted the I<-i\\ i> option, the output would have been"
" the same, since B<PTHREAD_INHERIT_SCHED> is the default for the inherit "
"scheduler attribute."
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:235
#, no-wrap
msgid "/* pthreads_sched_test.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:241
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:250
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:267
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|s}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:278
#, no-wrap
msgid ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:289
#, no-wrap
msgid ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:295
#, no-wrap
msgid ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:299
#, no-wrap
msgid ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:303
#, no-wrap
msgid ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:308
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:311
#, no-wrap
msgid ""
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:321
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:323
#, no-wrap
msgid "    /* Process command-line options */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:328
#, no-wrap
msgid ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:338
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:342
#, no-wrap
msgid ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:345
#, no-wrap
msgid ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:350
#, no-wrap
msgid ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-s)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:355
#, no-wrap
msgid ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:358
#, no-wrap
msgid ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:360
#, no-wrap
msgid "    /* Initialize thread attributes object according to options */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:369
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:377
#, no-wrap
msgid ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or \\(aqi\\(aq\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:382
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:388
#, no-wrap
msgid ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:396
#, no-wrap
msgid ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:399
#, no-wrap
msgid ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:407
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:410
#, no-wrap
msgid ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:418
#, no-wrap
msgid ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:420
#, no-wrap
msgid "    /* Create a thread that will display its scheduling attributes */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:424
#, no-wrap
msgid ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:426
#, no-wrap
msgid "    /* Destroy unneeded thread attributes object */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:434
#, no-wrap
msgid ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:451
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3),"
" B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
