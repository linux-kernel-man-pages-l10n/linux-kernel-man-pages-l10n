# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Alexey, 2016.
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2014-2017.
# kogamatranslator49 <r.podarov@yandex.ru>, 2015.
# Kogan, Darima <silverdk99@gmail.com>, 2014.
# Max Is <ismax799@gmail.com>, 2016.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019.
# Yuri Kozlov <yuray@komyakino.ru>, 2013.
# Иван Павлов <pavia00@gmail.com>, 2017.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:26+0300\n"
"PO-Revision-Date: 2019-09-22 20:08+0300\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "PTS"
msgstr "PTS"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/pts.4:8
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/pts.4:9
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/pts.4:11
msgid "ptmx, pts - pseudoterminal master and slave"
msgstr "ptmx, pts - основной и подчинённый псевдо-терминал"

#. type: SH
#: man-pages/man4/pts.4:11
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/pts.4:17
msgid ""
"The file I</dev/ptmx> is a character file with major number 5 and minor "
"number 2, usually with mode 0666 and ownership root:root.  It is used to "
"create a pseudoterminal master and slave pair."
msgstr ""
"Файл I</dev/ptmx> является символьным файлом со старшим номером 5 и младшим "
"номером 2, обычно имеет права доступа 0666 и принадлежит root:root. "
"Используется для создания пары основного и подчинённого псевдо-терминала."

#. type: Plain text
#: man-pages/man4/pts.4:30
msgid ""
"When a process opens I</dev/ptmx>, it gets a file descriptor for a "
"pseudoterminal master (PTM), and a pseudoterminal slave (PTS) device is "
"created in the I</dev/pts> directory.  Each file descriptor obtained by "
"opening I</dev/ptmx> is an independent PTM with its own associated PTS, "
"whose path can be found by passing the file descriptor to B<ptsname>(3)."
msgstr ""
"Когда процесс открывает I</dev/ptmx>, то он получает дескриптор файла "
"основного псевдо-терминала (PTM, pseudoterminal master), а в каталоге I</dev/"
"pts> создаётся устройство подчинённого псевдо-терминала (PTS, pseudoterminal "
"slave). Каждый дескриптор файла, полученный открытием I</dev/ptmx>, является "
"независимым PTM со своим отдельным, связанным с ним PTS, чей путь можно "
"определить, передав файловый дескриптор B<ptsname>(3)."

#. type: Plain text
#: man-pages/man4/pts.4:36
msgid ""
"Before opening the pseudoterminal slave, you must pass the master's file "
"descriptor to B<grantpt>(3)  and B<unlockpt>(3)."
msgstr ""
"Перед открытием подчинённого псевдо-терминала вы должны передать дескриптор "
"файла основного терминала в B<grantpt>(3) и B<unlockpt>(3)."

#. type: Plain text
#: man-pages/man4/pts.4:39
msgid ""
"Once both the pseudoterminal master and slave are open, the slave provides "
"processes with an interface that is identical to that of a real terminal."
msgstr ""
"Когда основной и подчинённый псевдо-терминалы будут открыты, подчинённый "
"предоставляет процессам интерфейс, идентичный обычному терминалу."

#. type: Plain text
#: man-pages/man4/pts.4:42
msgid ""
"Data written to the slave is presented on the master file descriptor as "
"input.  Data written to the master is presented to the slave as input."
msgstr ""
"Данные, записываемые на подчинённый терминал, появляются у файлового "
"дескриптора основного терминала как входные данные. Данные, записываемые на "
"основной терминал, появляются на подчинённом терминале в виде входных данных."

#. type: Plain text
#: man-pages/man4/pts.4:53
msgid ""
"In practice, pseudoterminals are used for implementing terminal emulators "
"such as B<xterm>(1), in which data read from the pseudoterminal master is "
"interpreted by the application in the same way a real terminal would "
"interpret the data, and for implementing remote-login programs such as "
"B<sshd>(8), in which data read from the pseudoterminal master is sent across "
"the network to a client program that is connected to a terminal or terminal "
"emulator."
msgstr ""
"На практике, псевдо-терминалы используются для реализации эмуляторов "
"терминала, таких как B<xterm>(1), где данные, считываемые с основного псевдо-"
"терминала, интерпретируются приложениями в том же виде, как и данные с "
"обычного терминала, а также в программах, реализующих удалённый доступ, "
"таких как B<sshd>(8), где данные, считываемые с основного псевдо-терминала, "
"отправляются по сети в программу-клиент, подключённую к терминалу или "
"эмулятору терминала."

#. type: Plain text
#: man-pages/man4/pts.4:59
msgid ""
"Pseudoterminals can also be used to send input to programs that normally "
"refuse to read input from pipes (such as B<su>(1), and B<passwd>(1))."
msgstr ""
"Псевдо-терминалы также могут использоваться для отправки вводимых данных в "
"программы, не желающих принимать обычный ввод из канала (например B<su>(1) и "
"B<passwd>(1))."

#. type: SH
#: man-pages/man4/pts.4:59
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/pts.4:62
msgid "I</dev/ptmx>, I</dev/pts/*>"
msgstr "I</dev/ptmx>, I</dev/pts/*>"

#. type: SH
#: man-pages/man4/pts.4:62
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/pts.4:68
msgid ""
"The Linux support for the above (known as UNIX 98 pseudoterminal naming)  is "
"done using the I<devpts> filesystem, that should be mounted on I</dev/pts>."
msgstr ""
"Поддержка в Linux для всего вышеперечисленного (т.н. именование псевдо-"
"терминалов UNIX 98) осуществляется через файловую систему I<devpts>, которая "
"монтируется к I</dev/pts>."

#. type: Plain text
#: man-pages/man4/pts.4:74
msgid ""
"Before this UNIX 98 scheme, master pseudoterminals were called I</dev/"
"ptyp0>, ...  and slave pseudoterminals I</dev/ttyp0>, ...  and one needed "
"lots of preallocated device nodes."
msgstr ""
"До схемы UNIX 98, основные псевдо-терминалы назывались I</dev/ptyp0>, ..., а "
"подчинённые псевдо-терминалы \\(em I</dev/ttyp0>, …, и для них требовалось "
"очень много предварительно размещённых нод устройств."

#. type: SH
#: man-pages/man4/pts.4:74
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/pts.4:79
msgid "B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pty>(7)"
msgstr "B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pty>(7)"

#. type: TH
#: man-pages/man1/pldd.1:25
#, no-wrap
msgid "PLDD"
msgstr "PLDD"

#. type: TH
#: man-pages/man1/pldd.1:25
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: TH
#: man-pages/man1/pldd.1:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: man-pages/man1/pldd.1:25
#, no-wrap
msgid "Linux User Manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man1/pldd.1:28
msgid "pldd - display dynamic shared objects linked into a process"
msgstr ""
"pldd - отобразить список динамических объектов общего пользования, связанных "
"в процесс"

#. type: SH
#: man-pages/man1/pldd.1:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man1/pldd.1:32
#, no-wrap
msgid ""
"B<pldd >I<pid>\n"
"B<pldd>I< option>\n"
msgstr ""
"B<pldd >I<pid>\n"
"B<pldd>I< option>\n"

#. type: Plain text
#: man-pages/man1/pldd.1:40
msgid ""
"The B<pldd> command displays a list of the dynamic shared objects (DSOs) "
"that are linked into the process with the specified process ID (PID).  The "
"list includes the libraries that have been dynamically loaded using "
"B<dlopen>(3)."
msgstr ""
"Команда  B<pldd> отображает список динамических объектов общего пользования "
"(DSO), связанных в процесс для указанного идентификатора процесса (PID). "
"Этот список также включает в себя библиотеки, динамически загруженные с "
"помощью B<dlopen>(3)."

#. type: SH
#: man-pages/man1/pldd.1:40
#, no-wrap
msgid "OPTIONS"
msgstr "ПАРАМЕТРЫ"

#. type: TP
#: man-pages/man1/pldd.1:41
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr "B<-?>, B<--help>"

#. type: Plain text
#: man-pages/man1/pldd.1:44
msgid "Display a help message and exit."
msgstr "Показать справку и выйти."

#. type: TP
#: man-pages/man1/pldd.1:44
#, no-wrap
msgid "B<--usage>"
msgstr "B<--usage>"

#. type: Plain text
#: man-pages/man1/pldd.1:47
msgid "Display a short usage message and exit."
msgstr "Показать короткое сообщение об использовании и завершить работу."

#. type: TP
#: man-pages/man1/pldd.1:47
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr "B<-V>, B<--version>"

#. type: Plain text
#: man-pages/man1/pldd.1:50
msgid "Display program version information and exit."
msgstr "Показать сведения о версии программы и выйти."

#. type: SH
#: man-pages/man1/pldd.1:50
#, no-wrap
msgid "EXIT STATUS"
msgstr "КОД РЕЗУЛЬТАТА"

#. type: Plain text
#: man-pages/man1/pldd.1:61
msgid ""
"On success, B<pldd> exits with the status 0.  If the specified process does "
"not exist, the user does not have permission to access its dynamic shared "
"object list, or no command-line arguments are supplied, B<pldd> exists with "
"a status of 1.  If given an invalid option, it exits with the status 64."
msgstr ""
"При успешном выполнении B<pldd> завершается с кодом 0. Если указанный "
"процесс не существует, пользователь не имеет прав для доступа к списку общих "
"динамических объектов или не указаны аргументы командной строки, B<pldd> "
"завершается с кодом 1. Если указан неправильный параметр, команда "
"завершается с кодом ошибки 64."

#. type: SH
#: man-pages/man1/pldd.1:61
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man1/pldd.1:64
msgid "B<pldd> is available since glibc 2.15."
msgstr "B<pldd> доступна в glibc с версии 2.15."

#. type: SH
#: man-pages/man1/pldd.1:64
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#.  There are man pages on Solaris and HP-UX.
#. type: Plain text
#: man-pages/man1/pldd.1:71
msgid ""
"The B<pldd> command is not specified by POSIX.1.  Some other systems have a "
"similar command."
msgstr ""
"Команда B<pldd> не описана в POSIX.1. В других системах есть похожая команда."

#. type: Plain text
#: man-pages/man1/pldd.1:73
msgid "The command"
msgstr "Команда"

#. type: Plain text
#: man-pages/man1/pldd.1:77
#, no-wrap
msgid "lsof -p PID\n"
msgstr "lsof -p PID\n"

#. type: Plain text
#: man-pages/man1/pldd.1:82
msgid ""
"also shows output that includes the dynamic shared objects that are linked "
"into a process."
msgstr ""
"также показывает в выводе общие динамические объекты, связанные с процессом."

#. type: Plain text
#: man-pages/man1/pldd.1:92
msgid ""
"The B<gdb>(1)  I<info shared> command also shows the shared libraries being "
"used by a process, so that one can obtain similar output to B<pldd> using a "
"command such as the following (to monitor the process with the specified "
"I<pid>):"
msgstr ""
"Команда I<info shared> в B<gdb>(1) также показывает используется процессом "
"общие библиотеки, что позволяет получить подобную B<pldd> информацию с "
"помощью команды (для процесса с указанным I<pid>):"

#. type: Plain text
#: man-pages/man1/pldd.1:97
#, no-wrap
msgid ""
"$ B<gdb -ex \"set confirm off\" -ex \"set height 0\" -ex \"info shared\" \\e>\n"
"        B<-ex \"quit\" -p $pid | grep '^0x.*0x'>\n"
msgstr ""
"$ B<gdb -ex \"set confirm off\" -ex \"set height 0\" -ex \"info shared\" \\e>\n"
"        B<-ex \"quit\" -p $pid | grep '^0x.*0x'>\n"

#. type: SH
#: man-pages/man1/pldd.1:99
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  glibc commit 1a4c27355e146b6d8cc6487b998462c7fdd1048f
#. type: Plain text
#: man-pages/man1/pldd.1:106
msgid ""
"From glibc 2.19 to 2.29, B<pldd> was broken: it just hung when executed.  "
"This problem was fixed in glibc 2.30, and the fix has been backported to "
"earlier glibc versions in some distributions."
msgstr ""
"В glibc с версии 2.19 по 2.29, B<pldd> не работала: висла при запуске. Эта "
"проблема была исправлена в glibc 2.30, и в некоторых дистрибутивах это "
"исправление было добавлено и в старые версии glibc."

#. type: SH
#: man-pages/man1/pldd.1:106
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man1/pldd.1:118
#, no-wrap
msgid ""
"$ B<echo $$>               # Display PID of shell\n"
"1143\n"
"$ B<pldd $$>               # Display DSOs linked into the shell\n"
"1143:   /usr/bin/bash\n"
"linux-vdso.so.1\n"
"/lib64/libtinfo.so.5\n"
"/lib64/libdl.so.2\n"
"/lib64/libc.so.6\n"
"/lib64/ld-linux-x86-64.so.2\n"
"/lib64/libnss_files.so.2\n"
msgstr ""
"$ B<echo $$>               # Показать PID оболочки\n"
"1143\n"
"$ B<pldd $$>               # Показать объекты, скомпонованные с оболочкой\n"
"1143:   /usr/bin/bash\n"
"linux-vdso.so.1\n"
"/lib64/libtinfo.so.5\n"
"/lib64/libdl.so.2\n"
"/lib64/libc.so.6\n"
"/lib64/ld-linux-x86-64.so.2\n"
"/lib64/libnss_files.so.2\n"

#. type: Plain text
#: man-pages/man1/pldd.1:123
msgid "B<ldd>(1), B<lsof>(1), B<dlopen>(3), B<ld.so>(8)"
msgstr "B<ldd>(1), B<lsof>(1), B<dlopen>(3), B<ld.so>(8)"

#. type: TH
#: man-pages/man7/path_resolution.7:25
#, no-wrap
msgid "PATH_RESOLUTION"
msgstr "PATH_RESOLUTION"

#. type: TH
#: man-pages/man7/path_resolution.7:25
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: man-pages/man7/path_resolution.7:28
msgid "path_resolution - how a pathname is resolved to a file"
msgstr "path_resolution - как путь преобразуется в файл"

#. type: Plain text
#: man-pages/man7/path_resolution.7:31
msgid ""
"Some UNIX/Linux system calls have as parameter one or more filenames.  A "
"filename (or pathname) is resolved as follows."
msgstr ""
"У некоторых системных вызовов UNIX/Linux есть параметр для указания одного "
"или нескольких имён файлов. Имя файла (или путь) преобразуется (resolved) "
"следующим образом."

#. type: SS
#: man-pages/man7/path_resolution.7:31
#, no-wrap
msgid "Step 1: start of the resolution process"
msgstr "Шаг 1: запуск процесса преобразования"

#. type: Plain text
#: man-pages/man7/path_resolution.7:50
msgid ""
"If the pathname starts with the \\(aq/\\(aq character, the starting lookup "
"directory is the root directory of the calling process.  (A process inherits "
"its root directory from its parent.  Usually this will be the root directory "
"of the file hierarchy.  A process may get a different root directory by use "
"of the B<chroot>(2)  system call.  A process may get an entirely private "
"mount namespace in case it\\(emor one of its ancestors\\(emwas started by an "
"invocation of the B<clone>(2)  system call that had the B<CLONE_NEWNS> flag "
"set.)  This handles the \\(aq/\\(aq part of the pathname."
msgstr ""
"Если путь начинается с символа «/», то начальным каталогом поиска "
"назначается корневой каталог вызывающего процесса (процесс наследует свой "
"корневой каталог от родителя. Обычно, это корневой каталог файловой "
"иерархии. Процесс может получить другой корневой каталог, используя "
"системный вызов B<chroot>(2). Процесс может получить полностью закрытое "
"пространство имён монтирования когда он сам или один из его предков был "
"запущен системным вызовом B<clone>(2) с флагом B<CLONE_NEWNS>). Так "
"обрабатывается часть пути «/»."

#. type: Plain text
#: man-pages/man7/path_resolution.7:58
msgid ""
"If the pathname does not start with the \\(aq/\\(aq character, the starting "
"lookup directory of the resolution process is the current working directory "
"of the process.  (This is also inherited from the parent.  It can be changed "
"by use of the B<chdir>(2)  system call.)"
msgstr ""
"Если путь не начинается с символа «/», то начальным каталогом поиска "
"процесса преобразование выбирается текущий рабочий каталог процесса (также "
"наследуемый от родителя; может быть системным вызовом B<chdir>(2))."

#. type: Plain text
#: man-pages/man7/path_resolution.7:61
msgid ""
"Pathnames starting with a \\(aq/\\(aq character are called absolute "
"pathnames.  Pathnames not starting with a \\(aq/\\(aq are called relative "
"pathnames."
msgstr ""
"Пути, начинающиеся с символа «/», называются абсолютными путями. Пути, не "
"начинающиеся с символа «/», называются относительными путями."

#. type: SS
#: man-pages/man7/path_resolution.7:61
#, no-wrap
msgid "Step 2: walk along the path"
msgstr "Шаг 2: обход пути"

#. type: Plain text
#: man-pages/man7/path_resolution.7:66
msgid ""
"Set the current lookup directory to the starting lookup directory.  Now, for "
"each nonfinal component of the pathname, where a component is a substring "
"delimited by \\(aq/\\(aq characters, this component is looked up in the "
"current lookup directory."
msgstr ""
"Назначаем текущим каталогом поиска начальный каталог поиска. Теперь для "
"каждого не конечного компонента пути (подстрока, разделённая символами «/») "
"будет производиться поиск в текущем каталоге поиска."

#. type: Plain text
#: man-pages/man7/path_resolution.7:72
msgid ""
"If the process does not have search permission on the current lookup "
"directory, an B<EACCES> error is returned (\"Permission denied\")."
msgstr ""
"Если у процесса нет права поиска в текущем каталоге просмотра, будет "
"возвращена ошибка B<EACCES> («Доступ запрещён»)."

#. type: Plain text
#: man-pages/man7/path_resolution.7:77
msgid ""
"If the component is not found, an B<ENOENT> error is returned (\"No such "
"file or directory\")."
msgstr ""
"Если компонент не найдет, будет возвращена ошибка B<ENOENT> («Нет такого "
"файла или каталога»)."

#. type: Plain text
#: man-pages/man7/path_resolution.7:82
msgid ""
"If the component is found, but is neither a directory nor a symbolic link, "
"an B<ENOTDIR> error is returned (\"Not a directory\")."
msgstr ""
"Если компонент найден, но не является ни каталогом, ни символической "
"ссылкой, будет возвращена ошибка B<ENOTDIR> («Не является каталогом»)."

#. type: Plain text
#: man-pages/man7/path_resolution.7:86
msgid ""
"If the component is found and is a directory, we set the current lookup "
"directory to that directory, and go to the next component."
msgstr ""
"Если компонент найден и является каталогом, значением текущего каталога "
"поиска устанавливается этот каталог, после чего осуществляется переход к "
"следующему компоненту."

#. type: Plain text
#: man-pages/man7/path_resolution.7:109
msgid ""
"If the component is found and is a symbolic link (symlink), we first resolve "
"this symbolic link (with the current lookup directory as starting lookup "
"directory).  Upon error, that error is returned.  If the result is not a "
"directory, an B<ENOTDIR> error is returned.  If the resolution of the "
"symlink is successful and returns a directory, we set the current lookup "
"directory to that directory, and go to the next component.  Note that the "
"resolution process here can involve recursion if the prefix ('dirname') "
"component of a pathname contains a filename that is a symbolic link that "
"resolves to a directory (where the prefix component of that directory may "
"contain a symbolic link, and so on).  In order to protect the kernel against "
"stack overflow, and also to protect against denial of service, there are "
"limits on the maximum recursion depth, and on the maximum number of symbolic "
"links followed.  An B<ELOOP> error is returned when the maximum is exceeded "
"(\"Too many levels of symbolic links\")."
msgstr ""
"Если компонент найден и это символическая ссылка (symlink), то сначала мы "
"разрешаем эту символическую ссылку (от текущего каталога, как начального "
"пути поиска). При ошибках, возвращаем ошибку. Если результат не каталог, то "
"возвращается ошибка B<ENOTDIR>. Если разрешение символической ссылки удалось "
"и получен каталог, то мы назначаем этот каталог текущим каталогом поиска и "
"переходим к следующему компоненту. Заметим, что процесс разрешения здесь "
"может вызвать рекурсию, если компонент префикса («dirname») пути содержит "
"имя символической ссылки, которая разрешается в каталог (где префикс "
"компонента этого каталога может содержать символическую ссылку и т .д.). Для "
"защиты ядра от переполнения стека, а также от отказа в обслуживании, есть "
"ограничение на максимальную глубину рекурсии и на максимальное количество "
"переходов по символическим ссылкам. При превышении возвращается ошибка "
"B<ELOOP> («Слишком много уровней символических ссылок»)."

#.  presently: max recursion depth during symlink resolution: 5
#.  max total number of symbolic links followed: 40
#.  _POSIX_SYMLOOP_MAX is 8
#.  MAXSYMLINKS is 40
#.  MAX_NESTED_LINKS
#.  commit 894bc8c4662ba9daceafe943a5ba0dd407da5cd3
#. type: Plain text
#: man-pages/man7/path_resolution.7:127
msgid ""
"As currently implemented on Linux, the maximum number of symbolic links that "
"will be followed while resolving a pathname is 40.  In kernels before "
"2.6.18, the limit on the recursion depth was 5.  Starting with Linux 2.6.18, "
"this limit was raised to 8.  In Linux 4.2, the kernel's pathname-resolution "
"code was reworked to eliminate the use of recursion, so that the only limit "
"that remains is the maximum of 40 resolutions for the entire pathname."
msgstr ""
"В текущей реализации Linux максимальное количество допустимых переходов по "
"символическим ссылкам при преобразовании пути равно 40. В ядрах до версии "
"2.6.18 ограничение глубины рекурсии было равно 5. Начиная с Linux 2.6.18, "
"это ограничение увеличилось до 8. В Linux 4.2 код ядра разрешения пути был "
"переработан и возникновение рекурсии больше не происходит, поэтому осталось "
"только ограничение на 40 разрешений для всего пути."

#. type: SS
#: man-pages/man7/path_resolution.7:127
#, no-wrap
msgid "Step 3: find the final entry"
msgstr "Шаг 3: поиск последнего элемента"

#. type: Plain text
#: man-pages/man7/path_resolution.7:139
msgid ""
"The lookup of the final component of the pathname goes just like that of all "
"other components, as described in the previous step, with two differences: "
"(i) the final component need not be a directory (at least as far as the path "
"resolution process is concerned\\(emit may have to be a directory, or a "
"nondirectory, because of the requirements of the specific system call), and "
"(ii) it is not necessarily an error if the component is not found\\(emmaybe "
"we are just creating it.  The details on the treatment of the final entry "
"are described in the manual pages of the specific system calls."
msgstr ""
"Поиск конечного компонента пути происходит таким же образом, как и всех "
"других компонентов, как было описано в предыдущем шаге, но с двумя "
"различиями: конечному компоненту не нужно быть каталогом (по крайней мере, "
"это не важно для процесса преобразования — он может быть каталогом или не "
"каталогом, в зависимости от требований определённого системного вызова), и "
"если компонент не найден это необязательна ошибка — возможно, его только "
"требуется создать. О том, чем считается последний элемент, описано в "
"справочных страницах соответствующих системных вызовов."

#. type: SS
#: man-pages/man7/path_resolution.7:139
#, no-wrap
msgid ". and .."
msgstr ". и .."

#. type: Plain text
#: man-pages/man7/path_resolution.7:143
msgid ""
"By convention, every directory has the entries \".\" and \"..\", which refer "
"to the directory itself and to its parent directory, respectively."
msgstr ""
"По соглашению, в каждом каталоге есть записи «.» и «..», которые ссылаются "
"на сам каталог и на его родительских каталог, соответственно."

#. type: Plain text
#: man-pages/man7/path_resolution.7:147
msgid ""
"The path resolution process will assume that these entries have their "
"conventional meanings, regardless of whether they are actually present in "
"the physical filesystem."
msgstr ""
"Процесс определения пути предполагает, что эти записи имеют свои "
"общепринятые значения, независимо от того, присутствуют ли они на самом деле "
"в физической файловой системе."

#. type: Plain text
#: man-pages/man7/path_resolution.7:149
msgid "One cannot walk down past the root: \"/..\" is the same as \"/\"."
msgstr "Невозможно перейти за пределы корня: путь «/..» равен «/»."

#. type: SS
#: man-pages/man7/path_resolution.7:149
#, no-wrap
msgid "Mount points"
msgstr "Точки монтирования"

#. type: Plain text
#: man-pages/man7/path_resolution.7:153
msgid ""
"After a \"mount dev path\" command, the pathname \"path\" refers to the root "
"of the filesystem hierarchy on the device \"dev\", and no longer to whatever "
"it referred to earlier."
msgstr ""
"После команды «mount устройство путь» путь указывает на корень иерархии "
"файловой системы устройства, и больше не указывает на то, что было раньше."

#. type: Plain text
#: man-pages/man7/path_resolution.7:157
msgid ""
"One can walk out of a mounted filesystem: \"path/..\" refers to the parent "
"directory of \"path\", outside of the filesystem hierarchy on \"dev\"."
msgstr ""
"Можно выйти за пределы смонтированной файловой системы: «путь/..» указывает "
"на родительский каталог «пути», лежащий вне иерархии файловой системы "
"устройства."

#. type: SS
#: man-pages/man7/path_resolution.7:157
#, no-wrap
msgid "Trailing slashes"
msgstr "Конечные символы косой черты"

#. type: Plain text
#: man-pages/man7/path_resolution.7:163
msgid ""
"If a pathname ends in a \\(aq/\\(aq, that forces resolution of the preceding "
"component as in Step 2: it has to exist and resolve to a directory.  "
"Otherwise, a trailing \\(aq/\\(aq is ignored.  (Or, equivalently, a pathname "
"with a trailing \\(aq/\\(aq is equivalent to the pathname obtained by "
"appending \\(aq.\\(aq to it.)"
msgstr ""
"Если путь заканчивается на «/», то это приводит к обработке предыдущего "
"компонента согласно шагу 2: он существует и преобразуется в каталог. В "
"противном случае конечный  «/» будет проигнорирован (или, что тоже самое, "
"путь с конечной косой чертой «/» будет равен пути, полученному добавлением к "
"его концу «.»)."

#. type: SS
#: man-pages/man7/path_resolution.7:163
#, no-wrap
msgid "Final symlink"
msgstr "Символьная ссылка в конце"

#. type: Plain text
#: man-pages/man7/path_resolution.7:172
msgid ""
"If the last component of a pathname is a symbolic link, then it depends on "
"the system call whether the file referred to will be the symbolic link or "
"the result of path resolution on its contents.  For example, the system call "
"B<lstat>(2)  will operate on the symlink, while B<stat>(2)  operates on the "
"file pointed to by the symlink."
msgstr ""
"Если последний компонент пути является символической ссылкой, то это зависит "
"от системного вызова, будет ли файл указывать на саму символическую ссылку "
"или на её содержимое. Например, системный вызов B<lstat>(2) будет работать с "
"символической ссылкой, а B<stat>(2) работает с файлом, на который указывает "
"символическая ссылка."

#. type: SS
#: man-pages/man7/path_resolution.7:172
#, no-wrap
msgid "Length limit"
msgstr "Ограничение длины"

#. type: Plain text
#: man-pages/man7/path_resolution.7:179
msgid ""
"There is a maximum length for pathnames.  If the pathname (or some "
"intermediate pathname obtained while resolving symbolic links)  is too long, "
"an B<ENAMETOOLONG> error is returned (\"Filename too long\")."
msgstr ""
"Существует максимально допустимая длина пути. Если путь (или какой-нибудь "
"промежуточный путь, полученный при разрешении символических ссылок) очень "
"длинный, то возвращается B<ENAMETOOLONG> («Имя файла очень длинное»)."

#. type: SS
#: man-pages/man7/path_resolution.7:179
#, no-wrap
msgid "Empty pathname"
msgstr "Пустой путь"

#. type: Plain text
#: man-pages/man7/path_resolution.7:186
msgid ""
"In the original UNIX, the empty pathname referred to the current directory.  "
"Nowadays POSIX decrees that an empty pathname must not be resolved "
"successfully.  Linux returns B<ENOENT> in this case."
msgstr ""
"В оригинальном UNIX, пустой путь считался текущим каталогом. В наши дни в "
"POSIX указано, что пустой путь не должен быть преобразован без ошибки. В "
"Linux в этом случае возвращается B<ENOENT>."

#. type: SS
#: man-pages/man7/path_resolution.7:186
#, no-wrap
msgid "Permissions"
msgstr "Права доступа"

#. type: Plain text
#: man-pages/man7/path_resolution.7:199
msgid ""
"The permission bits of a file consist of three groups of three bits; see "
"B<chmod>(1)  and B<stat>(2).  The first group of three is used when the "
"effective user ID of the calling process equals the owner ID of the file.  "
"The second group of three is used when the group ID of the file either "
"equals the effective group ID of the calling process, or is one of the "
"supplementary group IDs of the calling process (as set by B<setgroups>(2)).  "
"When neither holds, the third group is used."
msgstr ""
"Биты прав файла делятся на три группы по три бита; смотрите B<chmod>(1) и "
"B<stat>(2). Первая группа используется тогда, когда эффективный "
"идентификатор пользователя вызывающего процесса равен идентификатору "
"владельца файла. Вторая группа используется, если идентификатор группы файла "
"равен эффективному идентификатору группы вызывающего процесса или одному из "
"дополнительных групп вызывающего процесса (установленных B<setgroups>(2)). В "
"остальных случаях используется третья группа."

#. type: Plain text
#: man-pages/man7/path_resolution.7:203
msgid ""
"Of the three bits used, the first bit determines read permission, the second "
"write permission, and the last execute permission in case of ordinary files, "
"or search permission in case of directories."
msgstr ""
"Три бита используются следующим образом: первым битом задаётся доступ на "
"чтение, вторым на запись, а последним, в случае обычных файлов — разрешение "
"на выполнение, в в случае каталогов разрешение на поиск."

#. type: Plain text
#: man-pages/man7/path_resolution.7:208
msgid ""
"Linux uses the fsuid instead of the effective user ID in permission checks.  "
"Ordinarily the fsuid will equal the effective user ID, but the fsuid can be "
"changed by the system call B<setfsuid>(2)."
msgstr ""
"Для проверки доступа в Linux используется fsuid вместо эффективного "
"идентификатора пользователя. Обычно, fsuid равен эффективному идентификатору "
"пользователя, fsuid может быть изменён системным вызовом B<setfsuid>(2)."

#. type: Plain text
#: man-pages/man7/path_resolution.7:216
msgid ""
"(Here \"fsuid\" stands for something like \"filesystem user ID\".  The "
"concept was required for the implementation of a user space NFS server at a "
"time when processes could send a signal to a process with the same effective "
"user ID.  It is obsolete now.  Nobody should use B<setfsuid>(2).)"
msgstr ""
"(Здесь «fsuid» сокращение от «пользовательский идентификатор в файловой "
"системе, filesystem user ID». Это требовалось для реализации сервера NFS в "
"пользовательском пространстве во времена, когда процессы могли посылать "
"сигнал процессу с тем же эффективным идентификатором пользователя. Сейчас "
"это устарело. Никто не должен использовать B<setfsuid>(2).)"

#.  FIXME . say something about filesystem mounted read-only ?
#. type: Plain text
#: man-pages/man7/path_resolution.7:222
msgid ""
"Similarly, Linux uses the fsgid (\"filesystem group ID\")  instead of the "
"effective group ID.  See B<setfsgid>(2)."
msgstr ""
"Схожим образом в Linux используется fsgid (\"filesystem group ID\") вместо "
"идентификатора эффективной группы. Смотрите B<setfsgid>(2)."

#. type: SS
#: man-pages/man7/path_resolution.7:222
#, no-wrap
msgid "Bypassing permission checks: superuser and capabilities"
msgstr "Пропуск проверки прав доступа: суперпользователь и мандаты"

#.  (but for exec at least one x bit must be set) -- AEB
#.  but there is variation across systems on this point: for
#.  example, HP-UX and Tru64 are as described by AEB.  However,
#.  on some implementations (e.g., Solaris, FreeBSD),
#.  access(X_OK) by superuser will report success, regardless
#.  of the file's execute permission bits. -- MTK (Oct 05)
#. type: Plain text
#: man-pages/man7/path_resolution.7:233
msgid ""
"On a traditional UNIX system, the superuser (I<root>, user ID 0) is all-"
"powerful, and bypasses all permissions restrictions when accessing files."
msgstr ""
"В традиционных системах UNIX суперпользователю (I<root>, идентификатор "
"пользователя 0) доступно всё и при доступе к файлам никаких проверок "
"ограничений не производится."

#. type: Plain text
#: man-pages/man7/path_resolution.7:241
msgid ""
"On Linux, superuser privileges are divided into capabilities (see "
"B<capabilities>(7)).  Two capabilities are relevant for file permissions "
"checks: B<CAP_DAC_OVERRIDE> and B<CAP_DAC_READ_SEARCH>.  (A process has "
"these capabilities if its fsuid is 0.)"
msgstr ""
"В Linux права суперпользователя делятся мандатами (смотрите "
"B<capabilities>(7)). Два мандата относятся к проверка доступа к файлам: "
"B<CAP_DAC_OVERRIDE> и B<CAP_DAC_READ_SEARCH> (процесс имеет эти мандаты, "
"если его fsuid равен 0)."

#. type: Plain text
#: man-pages/man7/path_resolution.7:247
msgid ""
"The B<CAP_DAC_OVERRIDE> capability overrides all permission checking, but "
"grants execute permission only when at least one of the file's three execute "
"permission bits is set."
msgstr ""
"Мандат B<CAP_DAC_OVERRIDE> заменяет всех проверки прав, но позволяет право "
"выполнения только, когда установлен хотя бы один из трёх битов выполнения "
"файла."

#.  FIXME . say something about immutable files
#.  FIXME . say something about ACLs
#. type: Plain text
#: man-pages/man7/path_resolution.7:254
msgid ""
"The B<CAP_DAC_READ_SEARCH> capability grants read and search permission on "
"directories, and read permission on ordinary files."
msgstr ""
"Мандат B<CAP_DAC_READ_SEARCH> разрешает чтение и поиск в по каталогу, а "
"также чтение обычных файлов."

#. type: Plain text
#: man-pages/man7/path_resolution.7:258
msgid "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"
msgstr "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man7/pkeys.7:25
#, no-wrap
msgid "PKEYS"
msgstr "PKEYS"

#. type: TH
#: man-pages/man7/pkeys.7:25
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: man-pages/man7/pkeys.7:28
msgid "pkeys - overview of Memory Protection Keys"
msgstr "pkeys - обзор ключей защиты памяти"

#. type: Plain text
#: man-pages/man7/pkeys.7:37
msgid ""
"Memory Protection Keys (pkeys) are an extension to existing page-based "
"memory permissions.  Normal page permissions using page tables require "
"expensive system calls and TLB invalidations when changing permissions.  "
"Memory Protection Keys provide a mechanism for changing protections without "
"requiring modification of the page tables on every permission change."
msgstr ""
"Ключи защиты памяти (pkeys) — это расширение существующих постраничных прав "
"на память. Для обычных прав на страницу используются страничные таблицы, "
"требующие для изменении прав затратных системных вызовов и аннулирования "
"TLB. Ключи защиты памяти предоставляют механизм изменения защиты без "
"необходимости изменять страничные таблицы при каждом изменении прав."

#. type: Plain text
#: man-pages/man7/pkeys.7:43
msgid ""
"To use pkeys, software must first \"tag\" a page in the page tables with a "
"pkey.  After this tag is in place, an application only has to change the "
"contents of a register in order to remove write access, or all access to a "
"tagged page."
msgstr ""
"Чтобы использовать pkeys, ПО сначала должно «пометить» (tag) страницу в "
"страничных таблицах значением pkey. После размещения этой метки для удаления "
"прав на запись или весь доступ к помеченной странице приложению нужно "
"изменить только содержимое регистра."

#. type: Plain text
#: man-pages/man7/pkeys.7:54
msgid ""
"Protection keys work in conjunction with the existing B<PROT_READ>/ "
"B<PROT_WRITE>/ B<PROT_EXEC> permissions passed to system calls such as "
"B<mprotect>(2)  and B<mmap>(2), but always act to further restrict these "
"traditional permission mechanisms."
msgstr ""
"Ключи защиты вместе с существующими правами B<PROT_READ>/ B<PROT_WRITE>/ "
"B<PROT_EXEC> передаются в системные вызовы, такие как B<mprotect>(2) и "
"B<mmap>(2), но всегда считаются как дополнительное ограничение к "
"существующим традиционным механизмам прав доступа."

#. type: Plain text
#: man-pages/man7/pkeys.7:62
msgid ""
"If a process performs an access that violates pkey restrictions, it receives "
"a B<SIGSEGV> signal.  See B<sigaction>(2)  for details of the information "
"available with that signal."
msgstr ""
"Если процесс осуществляет доступ, нарушающий ограничения pkey, то он "
"получает сигнал B<SIGSEGV>. Подробную информацию об этом сигнале смотрите в "
"B<sigaction>(2)."

#. type: Plain text
#: man-pages/man7/pkeys.7:72
msgid ""
"To use the pkeys feature, the processor must support it, and the kernel must "
"contain support for the feature on a given processor.  As of early 2016 only "
"future Intel x86 processors are supported, and this hardware supports 16 "
"protection keys in each process.  However, pkey 0 is used as the default "
"key, so a maximum of 15 are available for actual application use.  The "
"default key is assigned to any memory region for which a pkey has not been "
"explicitly assigned via B<pkey_mprotect>(2)."
msgstr ""
"Чтобы использовать свойство pkeys, это должен поддерживать процессор, а ядро "
"должно включать поддержку этого свойства для этого процессора. К началу  "
"2016 года это относится только к будущим процессорам Intel x86, и данная "
"аппаратура поддерживает 16 ключей защиты на каждый процесс. Однако pkey 0 "
"используется как ключ по умолчанию, поэтому для приложения доступно только "
"15. Ключ по умолчанию назначается любой области памяти, для которой pkey не "
"был назначен явным образом с помощью B<pkey_mprotect>(2)."

#. type: Plain text
#: man-pages/man7/pkeys.7:80
msgid ""
"Protection keys have the potential to add a layer of security and "
"reliability to applications.  But they have not been primarily designed as a "
"security feature.  For instance, WRPKRU is a completely unprivileged "
"instruction, so pkeys are useless in any case that an attacker controls the "
"PKRU register or can execute arbitrary instructions."
msgstr ""
"Потенциально, ключи защиты могут добавить уровень безопасности и надежности "
"приложений. Но, прежде всего, они не разрабатывались как средство защиты. "
"Например, WRPKRU — это полностью непривилегированная инструкция, поэтому "
"pkeys бесполезны, когда атакующий контролирует регистр PKRU или может "
"выполнять любые инструкции."

#. type: Plain text
#: man-pages/man7/pkeys.7:99
msgid ""
"Applications should be very careful to ensure that they do not \"leak\" "
"protection keys.  For instance, before calling B<pkey_free>(2), the "
"application should be sure that no memory has that pkey assigned.  If the "
"application left the freed pkey assigned, a future user of that pkey might "
"inadvertently change the permissions of an unrelated data structure, which "
"could impact security or stability.  The kernel currently allows in-use "
"pkeys to have B<pkey_free>(2)  called on them because it would have "
"processor or memory performance implications to perform the additional "
"checks needed to disallow it.  Implementation of the necessary checks is "
"left up to applications.  Applications may implement these checks by "
"searching the I</proc/[pid]/smaps> file for memory regions with the pkey "
"assigned.  Further details can be found in B<proc>(5)."
msgstr ""
"Приложения должны следить за тем, чтобы их ключи защиты не «не утекли». "
"Например, перед вызовом B<pkey_free>(2) приложение должно проверить, что "
"pkey не назначен памяти. Если приложение оставит назначенным освобождённый "
"pkey,  то будущий пользователь этого pkey может непреднамеренно изменить "
"права на не относящуюся к делу структуру данных, что может привести к "
"проблемам с безопасностью или стабильностью. В настоящее время ядро "
"позволяет вызывать B<pkey_free>(2) для задействованных pkeys, так как "
"выполнение дополнительных проверок повлияло бы на производительность "
"процессора или памяти. Реализация необходимых проверок переложена на "
"приложение. Приложения могут найти области памяти, которым назначен pkey, в "
"файле I</proc/[pid]/smaps>. Дополнительная информация представлена в "
"B<proc>(5)."

#. type: Plain text
#: man-pages/man7/pkeys.7:113
msgid ""
"Any application wanting to use protection keys needs to be able to function "
"without them.  They might be unavailable because the hardware that the "
"application runs on does not support them, the kernel code does not contain "
"support, the kernel support has been disabled, or because the keys have all "
"been allocated, perhaps by a library the application is using.  It is "
"recommended that applications wanting to use protection keys should simply "
"call B<pkey_alloc>(2)  and test whether the call succeeds, instead of "
"attempting to detect support for the feature in any other way."
msgstr ""
"Приложение, которое хочет воспользоваться ключами защиты, может работать и "
"без них. Ключи могут быть недоступны из-за отсутствия аппаратной поддержки "
"системе, где запускается приложение, в коде ядра может не быть поддержки, "
"поддержка в ядре может быть выключена или все ключи уже задействованы "
"библиотекой, которую использует приложение. В приложениях рекомендуется "
"просто вызывать B<pkey_alloc>(2) и проверять успешность выполнения, а не "
"пытаться проверять наличие поддержки каким-то другим образом."

#. type: Plain text
#: man-pages/man7/pkeys.7:126
msgid ""
"Although unnecessary, hardware support for protection keys may be enumerated "
"with the I<cpuid> instruction.  Details of how to do this can be found in "
"the Intel Software Developers Manual.  The kernel performs this enumeration "
"and exposes the information in I</proc/cpuinfo> under the \"flags\" field.  "
"The string \"pku\" in this field indicates hardware support for protection "
"keys and the string \"ospke\" indicates that the kernel contains and has "
"enabled protection keys support."
msgstr ""
"Хотя и необязательно, поддержку ключей защиты в аппаратуре можно определить "
"помощью инструкции I<cpuid>. От том, как это сделать, смотрите в программном "
"руководстве разработчика Intel. Ядро определяет наличие поддержки и выводит "
"информацию в I</proc/cpuinfo> в поле «flags». Строка «pku» в этом поле "
"означает, что аппаратура поддерживает ключи защиты, а строка «ospke» "
"означает, что ядро содержит включённую поддержку защиты."

#. type: Plain text
#: man-pages/man7/pkeys.7:139
msgid ""
"Applications using threads and protection keys should be especially "
"careful.  Threads inherit the protection key rights of the parent at the "
"time of the B<clone>(2), system call.  Applications should either ensure "
"that their own permissions are appropriate for child threads at the time "
"when B<clone>(2)  is called, or ensure that each child thread can perform "
"its own initialization of protection key rights."
msgstr ""
"Если приложение использует нити и ключи защиты, то нужно быть особенно "
"осторожным. Нити наследуют права ключей защиты родителя при выполнении "
"системного вызова B<clone>(2). Приложения должны убедиться, что их "
"собственные права подходят для дочерних нитей до вызова B<clone>(2) или "
"выполнять инициализацию прав ключей защиты в самих нитях."

#. type: SS
#: man-pages/man7/pkeys.7:139
#, no-wrap
msgid "Signal Handler Behavior"
msgstr "Поведение обработчика сигналов"

#. type: Plain text
#: man-pages/man7/pkeys.7:148
msgid ""
"Each time a signal handler is invoked (including nested signals), the thread "
"is temporarily given a new, default set of protection key rights that "
"override the rights from the interrupted context.  This means that "
"applications must re-establish their desired protection key rights upon "
"entering a signal handler if the desired rights differ from the defaults.  "
"The rights of any interrupted context are restored when the signal handler "
"returns."
msgstr ""
"Каждый раз, когда вызывается обработчик сигнала (включая вложенные сигналы), "
"нити временно даётся новый набор прав ключа защиты по умолчанию, который "
"заменяет права прерванного контекста. Это означает, что приложения должны "
"переустанавливать свои желаемые права ключа защиты при входе в обработчик "
"сигнала, если желаемые права отличаются от значения по умолчанию. Права "
"любого прерванного контекста восстанавливаются при завершении обработчика "
"сигналов."

#. type: Plain text
#: man-pages/man7/pkeys.7:154
msgid ""
"This signal behavior is unusual and is due to the fact that the x86 PKRU "
"register (which stores protection key access rights) is managed with the "
"same hardware mechanism (XSAVE) that manages floating-point registers.  The "
"signal behavior is the same as that of floating-point registers."
msgstr ""
"Данное поведение сигнала необычно из-за того, что регистр x86 PKRU (который "
"хранит права доступа ключа защиты) управляется тем же аппаратным механизмом "
"(XSAVE) что и регистры плавающей запятой. Поведение сигнала такое же как у "
"регистров плавающей запятой."

#. type: SS
#: man-pages/man7/pkeys.7:154
#, no-wrap
msgid "Protection Keys system calls"
msgstr "Системные вызовы ключей защиты"

#. type: Plain text
#: man-pages/man7/pkeys.7:160
msgid ""
"The Linux kernel implements the following pkey-related system calls: "
"B<pkey_mprotect>(2), B<pkey_alloc>(2), and B<pkey_free>(2)."
msgstr ""
"В ядре Linux реализованы следующие системные вызовы для работы с pkey: "
"B<pkey_mprotect>(2), B<pkey_alloc>(2) и B<pkey_free>(2)."

#. type: Plain text
#: man-pages/man7/pkeys.7:165
msgid ""
"The Linux pkey system calls are available only if the kernel was configured "
"and built with the B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS> option."
msgstr ""
"Системные вызовы Linux pkey доступны только, если ядро было собрано с "
"включённым параметром  B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS>."

#. type: Plain text
#: man-pages/man7/pkeys.7:174
msgid ""
"The program below allocates a page of memory with read and write "
"permissions.  It then writes some data to the memory and successfully reads "
"it back.  After that, it attempts to allocate a protection key and disallows "
"access to the page by using the WRPKRU instruction.  It then tries to access "
"the page, which we now expect to cause a fatal signal to the application."
msgstr ""
"Программа, представленная далее, выделяет страницу памяти с правами на "
"чтение и запись. Затем она записывает кусок данных в памяти и читает его. "
"После этого она пытается выделить ключ защиты и запретить доступ к странице "
"с помощью инструкции WRPKRU. Далее она пытается получить доступ к странице, "
"что, как мы ожидаем, вызовет сигнал завершения приложения."

#. type: Plain text
#: man-pages/man7/pkeys.7:181
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"buffer contains: 73\n"
"about to read buffer again...\n"
"Segmentation fault (core dumped)\n"
msgstr ""
"$B< ./a.out>\n"
"буфер содержит: 73\n"
"читаем буфер снова...\n"
"Segmentation fault (core dumped)\n"

#. type: SS
#: man-pages/man7/pkeys.7:183
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man7/pkeys.7:191
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:198
#, no-wrap
msgid ""
"static inline void\n"
"wrpkru(unsigned int pkru)\n"
"{\n"
"    unsigned int eax = pkru;\n"
"    unsigned int ecx = 0;\n"
"    unsigned int edx = 0;\n"
msgstr ""
"static inline void\n"
"wrpkru(unsigned int pkru)\n"
"{\n"
"    unsigned int eax = pkru;\n"
"    unsigned int ecx = 0;\n"
"    unsigned int edx = 0;\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:202
#, no-wrap
msgid ""
"    asm volatile(\".byte 0x0f,0x01,0xef\\en\\et\"\n"
"                 : : \"a\" (eax), \"c\" (ecx), \"d\" (edx));\n"
"}\n"
msgstr ""
"    asm volatile(\".byte 0x0f,0x01,0xef\\en\\et\"\n"
"                 : : \"a\" (eax), \"c\" (ecx), \"d\" (edx));\n"
"}\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:209
#, no-wrap
msgid ""
"int\n"
"pkey_set(int pkey, unsigned long rights, unsigned long flags)\n"
"{\n"
"    unsigned int pkru = (rights E<lt>E<lt> (2 * pkey));\n"
"    return wrpkru(pkru);\n"
"}\n"
msgstr ""
"int\n"
"pkey_set(int pkey, unsigned long rights, unsigned long flags)\n"
"{\n"
"    unsigned int pkru = (rights E<lt>E<lt> (2 * pkey));\n"
"    return wrpkru(pkru);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:216
#, no-wrap
msgid ""
"int\n"
"pkey_mprotect(void *ptr, size_t size, unsigned long orig_prot,\n"
"              unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_mprotect, ptr, size, orig_prot, pkey);\n"
"}\n"
msgstr ""
"int\n"
"pkey_mprotect(void *ptr, size_t size, unsigned long orig_prot,\n"
"              unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_mprotect, ptr, size, orig_prot, pkey);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:222
#, no-wrap
msgid ""
"int\n"
"pkey_alloc(void)\n"
"{\n"
"    return syscall(SYS_pkey_alloc, 0, 0);\n"
"}\n"
msgstr ""
"int\n"
"pkey_alloc(void)\n"
"{\n"
"    return syscall(SYS_pkey_alloc, 0, 0);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:228
#, no-wrap
msgid ""
"int\n"
"pkey_free(unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_free, pkey);\n"
"}\n"
msgstr ""
"int\n"
"pkey_free(unsigned long pkey)\n"
"{\n"
"    return syscall(SYS_pkey_free, pkey);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:231
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                           } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                           } while (0)\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:238
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int status;\n"
"    int pkey;\n"
"    int *buffer;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int status;\n"
"    int pkey;\n"
"    int *buffer;\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:246
#, no-wrap
msgid ""
"    /*\n"
"     *Allocate one page of memory\n"
"     */\n"
"    buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n"
"                  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n"
"    if (buffer == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""
"    /*\n"
"     * выделяем страницу памяти\n"
"     */\n"
"    buffer = mmap(NULL, getpagesize(), PROT_READ | PROT_WRITE,\n"
"                  MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n"
"    if (buffer == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:252
#, no-wrap
msgid ""
"    /*\n"
"     * Put some random data into the page (still OK to touch)\n"
"     */\n"
"    *buffer = __LINE__;\n"
"    printf(\"buffer contains: %d\\en\", *buffer);\n"
msgstr ""
"    /*\n"
"     * пишем произвольные данные в страницу (чуть)\n"
"     */\n"
"    *buffer = __LINE__;\n"
"    printf(\"буфер содержит: %d\\en\", *buffer);\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:259
#, no-wrap
msgid ""
"    /*\n"
"     * Allocate a protection key:\n"
"     */\n"
"    pkey = pkey_alloc();\n"
"    if (pkey == -1)\n"
"        errExit(\"pkey_alloc\");\n"
msgstr ""
"    /*\n"
"     * выделяем ключ защиты:\n"
"     */\n"
"    pkey = pkey_alloc();\n"
"    if (pkey == -1)\n"
"        errExit(\"pkey_alloc\");\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:267
#, no-wrap
msgid ""
"    /*\n"
"     * Disable access to any memory with \"pkey\" set,\n"
"     * even though there is none right now\n"
"     */\n"
"    status = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0);\n"
"    if (status)\n"
"        errExit(\"pkey_set\");\n"
msgstr ""
"    /*\n"
"     * запрещаем доступ к памяти, на которой будет установлен «pkey»,\n"
"     * хотя пока ничего не запрещено\n"
"     */\n"
"    status = pkey_set(pkey, PKEY_DISABLE_ACCESS, 0);\n"
"    if (status)\n"
"        errExit(\"pkey_set\");\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:277
#, no-wrap
msgid ""
"    /*\n"
"     * Set the protection key on \"buffer\".\n"
"     * Note that it is still read/write as far as mprotect() is\n"
"     * concerned and the previous pkey_set() overrides it.\n"
"     */\n"
"    status = pkey_mprotect(buffer, getpagesize(),\n"
"                           PROT_READ | PROT_WRITE, pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_mprotect\");\n"
msgstr ""
"    /*\n"
"     * установим ключ защиты на «буфер»\n"
"     * заметим, что он доступен пока не применён mprotect()\n"
"     * и ключ не заменен созданным ранее pkey_set()\n"
"     */\n"
"    status = pkey_mprotect(buffer, getpagesize(),\n"
"                           PROT_READ | PROT_WRITE, pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_mprotect\");\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:279
#, no-wrap
msgid "    printf(\"about to read buffer again...\\en\");\n"
msgstr "    printf(\"читаем буфер снова...\\en\");\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:284
#, no-wrap
msgid ""
"    /*\n"
"     * This will crash, because we have disallowed access\n"
"     */\n"
"    printf(\"buffer contains: %d\\en\", *buffer);\n"
msgstr ""
"    /*\n"
"     * приложение падает, так как мы запретили доступ\n"
"     */\n"
"    printf(\"буфер содержит: %d\\en\", *buffer);\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:288
#, no-wrap
msgid ""
"    status = pkey_free(pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_free\");\n"
msgstr ""
"    status = pkey_free(pkey);\n"
"    if (status == -1)\n"
"        errExit(\"pkey_free\");\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:291
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/pkeys.7:296
msgid "B<pkey_alloc>(2), B<pkey_free>(2), B<pkey_mprotect>(2), B<sigaction>(2)"
msgstr ""
"B<pkey_alloc>(2), B<pkey_free>(2), B<pkey_mprotect>(2), B<sigaction>(2)"

#. type: TH
#: man-pages/man7/pty.7:25
#, no-wrap
msgid "PTY"
msgstr "PTY"

#. type: TH
#: man-pages/man7/pty.7:25
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man7/pty.7:28
msgid "pty - pseudoterminal interfaces"
msgstr "pty - интерфейсы псевдо-терминалов"

#. type: Plain text
#: man-pages/man7/pty.7:61
msgid ""
"A pseudoterminal (sometimes abbreviated \"pty\")  is a pair of virtual "
"character devices that provide a bidirectional communication channel.  One "
"end of the channel is called the I<master>; the other end is called the "
"I<slave>.  The slave end of the pseudoterminal provides an interface that "
"behaves exactly like a classical terminal.  A process that expects to be "
"connected to a terminal, can open the slave end of a pseudoterminal and then "
"be driven by a program that has opened the master end.  Anything that is "
"written on the master end is provided to the process on the slave end as "
"though it was input typed on a terminal.  For example, writing the interrupt "
"character (usually control-C)  to the master device would cause an interrupt "
"signal (B<SIGINT>)  to be generated for the foreground process group that is "
"connected to the slave.  Conversely, anything that is written to the slave "
"end of the pseudoterminal can be read by the process that is connected to "
"the master end.  Pseudoterminals are used by applications such as network "
"login services (B<ssh>(1), B<rlogin>(1), B<telnet>(1)), terminal emulators "
"such as B<xterm>(1), B<script>(1), B<screen>(1), B<tmux>(1), B<unbuffer>(1), "
"and B<expect>(1)."
msgstr ""
"Псевдо-терминал (иногда применяют сокращение «pty») — это пара виртуальных "
"символьных устройств, которые предоставляют двунаправленный канал обмена. "
"Один конец канала называется I<основным> (master); другой конец канала "
"называется I<подчинённым> (slave). Подчинённый конец псевдо-терминала "
"предоставляет интерфейс, который работает также как обычный классический "
"терминал. Процесс, который управляется через терминал, может открыть "
"подчинённый конец псевдо-терминала и затем управляться программой, которая "
"открыла основной конец. Всё что пишется в основной конец поступает процессу "
"на подчинённом конце так, как-будто данные вводились с терминала. Например, "
"запись символа прерывания (обычно control-C) в основной конец приводит к "
"генерации сигнала прерывания (B<SIGINT>) для группы активных процессов, "
"которая подключена к подчинённому концу. И наоборот, всё что записывается в "
"в подчинённый конец псевдо-терминала, может быть прочитано процессом, "
"который подключён к основному концу. Псевдо-терминалы используются такими "
"приложениями как службы сетевого входа (B<ssh>(1), B<rlogin>(1), "
"B<telnet>(1)), эмуляторами терминалов B<xterm>(1), B<script>(1), "
"B<screen>(1), B<tmux>(1), B<unbuffer>(1) и B<expect>(1)."

#. type: Plain text
#: man-pages/man7/pty.7:68
msgid ""
"Data flow between master and slave is handled asynchronously, much like data "
"flow with a physical terminal.  Data written to the slave will be available "
"at the master promptly, but may not be available immediately.  Similarly, "
"there may be a small processing delay between a write to the master, and the "
"effect being visible at the slave."
msgstr ""
"Поток данных между основным и подчинённым концом обрабатывается асинхронно, "
"почти как поток с физического терминала. Данные, записываемые в подчинённый "
"конец, будут доступны без промедления, но могут быть недоступны немедленно. "
"Схожим образом, есть маленькая задержка обработки между записью в основной "
"конец и когда эти данные станут видимы на подчинённом конце."

#. type: Plain text
#: man-pages/man7/pty.7:73
msgid ""
"Historically, two pseudoterminal APIs have evolved: BSD and System V.  SUSv1 "
"standardized a pseudoterminal API based on the System V API, and this API "
"should be employed in all new programs that use pseudoterminals."
msgstr ""
"Исторически существует два программных интерфейса для взаимодействия с "
"псевдо-терминалами: BSD и System V. В SUSv1 стандартизирован программный "
"интерфейс, основанный на программном интерфейсе System V, который должен "
"применяться во всех новых программах, использующих псевдо-терминалы."

#. type: Plain text
#: man-pages/man7/pty.7:81
msgid ""
"Linux provides both BSD-style and (standardized) System V-style "
"pseudoterminals.  System V-style terminals are commonly called UNIX 98 "
"pseudoterminals on Linux systems.  Since kernel 2.6.4, BSD-style "
"pseudoterminals are considered deprecated (they can be disabled when "
"configuring the kernel); UNIX 98 pseudoterminals should be used in new "
"applications."
msgstr ""
"В Linux есть оба типа псевдо-терминалов — BSD и (стандартизированный) System "
"V. В системах Linux терминалы System V часто называют псевдо-терминалами "
"UNIX 98. Начиная с ядра версии 2.6.4 псевдо-терминалы BSD признаны "
"устаревшими (их можно отключить во время настройки ядра). В новых программах "
"следует использовать псевдо-терминалы UNIX 98."

#. type: SS
#: man-pages/man7/pty.7:81
#, no-wrap
msgid "UNIX 98 pseudoterminals"
msgstr "Псевдо-терминалы UNIX 98"

#. type: Plain text
#: man-pages/man7/pty.7:98
msgid ""
"An unused UNIX 98 pseudoterminal master is opened by calling "
"B<posix_openpt>(3).  (This function opens the master clone device, I</dev/"
"ptmx>; see B<pts>(4).)  After performing any program-specific "
"initializations, changing the ownership and permissions of the slave device "
"using B<grantpt>(3), and unlocking the slave using B<unlockpt>(3)), the "
"corresponding slave device can be opened by passing the name returned by "
"B<ptsname>(3)  in a call to B<open>(2)."
msgstr ""
"Незадействованный основной псевдо-терминал UNIX 98 открывается вызовом "
"B<posix_openpt>(3) (эта функция открывает основное клонирующее устройство, "
"I</dev/ptmx>; смотрите B<pts>(4)). После выполнения специальной программной "
"инициализации (с помощью B<grantpt>(3) изменяется владелец и права на "
"подчинённое устройство и с помощью B<unlockpt>(3) разблокируется подчинённое "
"устройство), соответствующее подчинённое устройство можно открыть, передав "
"имя, полученное от B<ptsname>(3), в вызов B<open>(2)."

#. type: Plain text
#: man-pages/man7/pty.7:113
msgid ""
"The Linux kernel imposes a limit on the number of available UNIX 98 "
"pseudoterminals.  In kernels up to and including 2.6.3, this limit is "
"configured at kernel compilation time (B<CONFIG_UNIX98_PTYS>), and the "
"permitted number of pseudoterminals can be up to 2048, with a default "
"setting of 256.  Since kernel 2.6.4, the limit is dynamically adjustable via "
"I</proc/sys/kernel/pty/max>, and a corresponding file, I</proc/sys/kernel/"
"pty/nr>, indicates how many pseudoterminals are currently in use.  For "
"further details on these two files, see B<proc>(5)."
msgstr ""
"Ядро Linux задаёт ограничение на количество доступных псевдо-терминалов UNIX "
"98. В ядрах до версии 2.6.3 включительно, это ограничение настраивалось при "
"компиляции ядра (B<CONFIG_UNIX98_PTYS>), и разрешалось 2048 псевдо-"
"терминалов (по умолчанию 256). Начиная с версии 2.6.4, ограничение "
"динамически настраивается через I</proc/sys/kernel/pty/max>, а в файле I</"
"proc/sys/kernel/pty/nr> хранится количество уже используемых псевдо-"
"терминалов. Подробности об этих двух файлах смотрите в B<proc>(5)."

#. type: SS
#: man-pages/man7/pty.7:113
#, no-wrap
msgid "BSD pseudoterminals"
msgstr "Псевдо-терминалы BSD"

#. type: Plain text
#: man-pages/man7/pty.7:134
msgid ""
"BSD-style pseudoterminals are provided as precreated pairs, with names of "
"the form I</dev/ptyXY> (master) and I</dev/ttyXY> (slave), where X is a "
"letter from the 16-character set [p-za-e], and Y is a letter from the 16-"
"character set [0-9a-f].  (The precise range of letters in these two sets "
"varies across UNIX implementations.)  For example, I</dev/ptyp1> and I</dev/"
"ttyp1> constitute a BSD pseudoterminal pair.  A process finds an unused "
"pseudoterminal pair by trying to B<open>(2)  each pseudoterminal master "
"until an open succeeds.  The corresponding pseudoterminal slave (substitute "
"\"tty\" for \"pty\" in the name of the master) can then be opened."
msgstr ""
"Псевдо-терминалы в стиле BSD предоставляются в виде заранее созданных пар, с "
"именами вида I</dev/ptyXY> (основной) и I</dev/ttyXY> (подчинённый), где X "
"это буква из 16-символьного набора [p-za-e], а Y это буква из 16-символьного "
"набора [0-9a-f] (точный диапазон символов этих наборов отличается в разных "
"реализациях UNIX). Например, I</dev/ptyp1> и I</dev/ttyp1> составляют псевдо-"
"терминальную пару  BSD. Процесс находит неиспользуемую псевдо-терминальную "
"пару пробуя вызывать B<open>(2) с каждым основным псевдо-терминалом, пока "
"вызов не выполнится успешно. Затем может быть открыт соответствующий "
"подчинённый псевдо-терминал (подставив «tty» вместо «pty» имени основного "
"конца)."

#. type: TP
#: man-pages/man7/pty.7:135
#, no-wrap
msgid "I</dev/ptmx>"
msgstr "I</dev/ptmx>"

#. type: Plain text
#: man-pages/man7/pty.7:138
msgid "UNIX 98 master clone device"
msgstr "основное клонирующее устройство UNIX 98"

#. type: TP
#: man-pages/man7/pty.7:138
#, no-wrap
msgid "I</dev/pts/*>"
msgstr "I</dev/pts/*>"

#. type: Plain text
#: man-pages/man7/pty.7:141
msgid "UNIX 98 slave devices"
msgstr "подчинённые устройства UNIX 98"

#. type: TP
#: man-pages/man7/pty.7:141
#, no-wrap
msgid "I</dev/pty[p-za-e][0-9a-f]>"
msgstr "I</dev/pty[p-za-e][0-9a-f]>"

#. type: Plain text
#: man-pages/man7/pty.7:144
msgid "BSD master devices"
msgstr "основные устройства BSD"

#. type: TP
#: man-pages/man7/pty.7:144
#, no-wrap
msgid "I</dev/tty[p-za-e][0-9a-f]>"
msgstr "I</dev/tty[p-za-e][0-9a-f]>"

#. type: Plain text
#: man-pages/man7/pty.7:147
msgid "BSD slave devices"
msgstr "подчинённые устройства BSD"

#. type: Plain text
#: man-pages/man7/pty.7:153
msgid ""
"A description of the B<TIOCPKT> B<ioctl>(2), which controls packet mode "
"operation, can be found in B<ioctl_tty>(2)."
msgstr ""
"Описание запроса B<TIOCPKT> B<ioctl>(2), который управляет пакетным режимом, "
"можно найти в B<ioctl_tty>(2)."

#. type: Plain text
#: man-pages/man7/pty.7:163
msgid ""
"The BSD B<ioctl>(2)  operations B<TIOCSTOP>, B<TIOCSTART>, B<TIOCUCNTL>, and "
"B<TIOCREMOTE> have not been implemented under Linux."
msgstr ""
"Вызовы B<ioctl>(2) для BSD B<TIOCSTOP>, B<TIOCSTART>, B<TIOCUCNTL> и "
"B<TIOCREMOTE> не реализованы в Linux."

#. type: Plain text
#: man-pages/man7/pty.7:171
msgid ""
"B<ioctl_tty>(2), B<select>(2), B<setsid>(2), B<forkpty>(3), B<openpty>(3), "
"B<termios>(3), B<pts>(4), B<tty>(4)"
msgstr ""
"B<ioctl_tty>(2), B<select>(2), B<setsid>(2), B<forkpty>(3), B<openpty>(3), "
"B<termios>(3), B<pts>(4), B<tty>(4)"

#. type: TH
#: man-pages/man7/pid_namespaces.7:27
#, no-wrap
msgid "PID_NAMESPACES"
msgstr "PID_NAMESPACES"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:30
msgid "pid_namespaces - overview of Linux PID namespaces"
msgstr "pid_namespaces - обзор пространств имён Linux PID"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:33
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr "Обзор пространств имён смотрите в B<namespaces>(7)."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:40
msgid ""
"PID namespaces isolate the process ID number space, meaning that processes "
"in different PID namespaces can have the same PID.  PID namespaces allow "
"containers to provide functionality such as suspending/resuming the set of "
"processes in the container and migrating the container to a new host while "
"the processes inside the container maintain the same PIDs."
msgstr ""
"Пространства имён PID изолируют пространство номеров идентификаторов "
"процессов, то есть процессы в разных пространствах имён PID могут иметь "
"единый  PID. Пространства имён PID позволяют предоставлять такие возможности "
"в контейнерах как приостановку/возобновление работы набора процессов в "
"контейнере и перенос контейнера на новый узел, при чём процессы внутри "
"контейнера сохранят свои PID."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:48
msgid ""
"PIDs in a new PID namespace start at 1, somewhat like a standalone system, "
"and calls to B<fork>(2), B<vfork>(2), or B<clone>(2)  will produce processes "
"with PIDs that are unique within the namespace."
msgstr ""
"Идентификаторы в новом пространстве имён PID начинаются с 1 как в автономной "
"системе, и вызовы B<fork>(2), B<vfork>(2) или B<clone>(2) будут создавать "
"процессы с уникальными идентификаторами в пределах пространства имён."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:55
msgid ""
"Use of PID namespaces requires a kernel that is configured with the "
"B<CONFIG_PID_NS> option."
msgstr ""
"Для использования пространств имён PID требуется, чтобы ядро было собрано с "
"параметром B<CONFIG_PID_NS>."

#. type: SS
#: man-pages/man7/pid_namespaces.7:55
#, no-wrap
msgid "The namespace init process"
msgstr "Пространство имён начального процесса"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:70
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using B<clone>(2)  with the B<CLONE_NEWPID> flag, or the first child created "
"by a process after a call to B<unshare>(2)  using the B<CLONE_NEWPID> flag) "
"has the PID 1, and is the \"init\" process for the namespace (see "
"B<init>(1)).  This process becomes the parent of any child processes that "
"are orphaned because a process that resides in this PID namespace terminated "
"(see below for further details)."
msgstr ""
"Первый процесс, созданный в новом пространстве имён (т. е., процесс, "
"созданный вызовом B<clone>(2) с флагом B<CLONE_NEWPID> или первый потомок, "
"созданный процессом после вызова B<unshare>(2) с флагом B<CLONE_NEWPID>) "
"имеет PID 1, и это «начальный» (init) процесс пространства имён (смотрите "
"B<init>(1)). Этот процесс становится родителем всех дочерних процессов, "
"которые осиротели из-за завершения родителей, находящихся внутри этого "
"пространства имён PID (дополнительную информацию смотрите ниже)."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:97
msgid ""
"If the \"init\" process of a PID namespace terminates, the kernel terminates "
"all of the processes in the namespace via a B<SIGKILL> signal.  This "
"behavior reflects the fact that the \"init\" process is essential for the "
"correct operation of a PID namespace.  In this case, a subsequent "
"B<fork>(2)  into this PID namespace fail with the error B<ENOMEM>; it is not "
"possible to create a new process in a PID namespace whose \"init\" process "
"has terminated.  Such scenarios can occur when, for example, a process uses "
"an open file descriptor for a I</proc/[pid]/ns/pid> file corresponding to a "
"process that was in a namespace to B<setns>(2)  into that namespace after "
"the \"init\" process has terminated.  Another possible scenario can occur "
"after a call to B<unshare>(2): if the first child subsequently created by a "
"B<fork>(2)  terminates, then subsequent calls to B<fork>(2)  fail with "
"B<ENOMEM>."
msgstr ""
"Если процесс «init» пространства имён PID завершает работу, то ядро "
"завершает работу всех процессов в пространстве имён с помощью сигнала "
"B<SIGKILL>. Такое поведение показывает, что процесс «init» необходим для "
"корректной работы пространства имён PID. В этом случае последующий вызов "
"B<fork>(2) в этом пространство имён PID завершается ошибкой B<ENOMEM>; "
"невозможно создать новый процесс в пространстве имён PID, в котором не "
"работает процесс «init». Такое может произойти, например, когда процесс "
"использует открытый файловый дескриптор файла I</proc/[pid]/ns/pid>, "
"соответствующий процессу, который был в пространстве имён B<setns>(2), в "
"этом пространстве имён после того, как процесс «init» завершился. Другой "
"возможный сценарий может произойти после вызова B<unshare>(2): если первый "
"потомок после этого созданный B<fork>(2) завершится, то последующие вызовы "
"B<fork>(2)  завершаются ошибкой B<ENOMEM>."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:103
msgid ""
"Only signals for which the \"init\" process has established a signal handler "
"can be sent to the \"init\" process by other members of the PID namespace.  "
"This restriction applies even to privileged processes, and prevents other "
"members of the PID namespace from accidentally killing the \"init\" process."
msgstr ""
"Члены пространства имён PID могут посылать процессу «init» только сигналы, "
"для которых процесс «init» установил обработчики. Это ограничение "
"применяется даже к привилегированным процессам, и не позволяет другим членам "
"пространства имён PID нечаянно убить процесс «init»."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:123
msgid ""
"Likewise, a process in an ancestor namespace can\\(emsubject to the usual "
"permission checks described in B<kill>(2)\\(emsend signals to the \"init\" "
"process of a child PID namespace only if the \"init\" process has "
"established a handler for that signal.  (Within the handler, the "
"I<siginfo_t> I<si_pid> field described in B<sigaction>(2)  will be zero.)  "
"B<SIGKILL> or B<SIGSTOP> are treated exceptionally: these signals are "
"forcibly delivered when sent from an ancestor PID namespace.  Neither of "
"these signals can be caught by the \"init\" process, and so will result in "
"the usual actions associated with those signals (respectively, terminating "
"and stopping the process)."
msgstr ""
"Также, процесс в родительском пространстве имён может (пройдя обычные "
"проверки прав, описанные в B<kill>(2)) послать сигнал процессу «init» "
"дочернего пространства имён PID только, если процесс «init» задал "
"обработчики для этого сигнала (внутри обработчика I<si_pid> в I<siginfo_t>, "
"описанное в B<sigaction>(2) будет равно нулю). Для сигналов B<SIGKILL> и "
"B<SIGSTOP> сделано исключение: эти сигналы принудительно доставляются при "
"отправке из родительского пространства имён PID. Ни один из них не может "
"быть пойман процессом «init», и в результате будут выполнены обычные "
"действия, связанные с этими сигналами (завершение и останов процесса, "
"соответственно)."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:133
msgid ""
"Starting with Linux 3.4, the B<reboot>(2)  system call causes a signal to be "
"sent to the namespace \"init\" process.  See B<reboot>(2)  for more details."
msgstr ""
"Начиная с Linux 3.4, системный вызов B<reboot>(2) посылает сигнал в "
"пространство имён процесса «init». Подробности смотрите в B<reboot>(2)."

#. type: SS
#: man-pages/man7/pid_namespaces.7:133
#, no-wrap
msgid "Nesting PID namespaces"
msgstr "Вложенные пространства имён PID"

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#.  The kernel constant MAX_PID_NS_LEVEL
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:148
msgid ""
"PID namespaces can be nested: each PID namespace has a parent, except for "
"the initial (\"root\") PID namespace.  The parent of a PID namespace is the "
"PID namespace of the process that created the namespace using B<clone>(2)  "
"or B<unshare>(2).  PID namespaces thus form a tree, with all namespaces "
"ultimately tracing their ancestry to the root namespace.  Since Linux 3.7, "
"the kernel limits the maximum nesting depth for PID namespaces to 32."
msgstr ""
"Пространства имён PID могут быть вложенными: каждое пространство имён PID "
"имеет родителя, за исключением начального («корневого») пространства имён "
"PID. Родитель пространства имён PID — это пространство имён PID процесса, "
"который был создан в пространстве имён с помощью B<clone>(2) или "
"B<unshare>(2). Таким образом пространства имён PID образуют дерево со всеми "
"пространствами имён по которому, в конечном счёте, можно проследить их "
"родословную до корневого пространства имён. Начиная с Linux 3.7, ядро "
"ограничивает  глубину максимальной вложенности пространств имён PID "
"значением 32."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:163
msgid ""
"A process is visible to other processes in its PID namespace, and to the "
"processes in each direct ancestor PID namespace going back to the root PID "
"namespace.  In this context, \"visible\" means that one process can be the "
"target of operations by another process using system calls that specify a "
"process ID.  Conversely, the processes in a child PID namespace can't see "
"processes in the parent and further removed ancestor namespaces.  More "
"succinctly: a process can see (e.g., send signals with B<kill>(2), set nice "
"values with B<setpriority>(2), etc.) only processes contained in its own PID "
"namespace and in descendants of that namespace."
msgstr ""
"Процесс видим другим процессам в своём пространстве имён PID, и процессам в "
"каждом прямом родительском пространстве имён PID вплоть до корневого "
"пространства имён PID. В этом контексте «видимость» означает, что процесс "
"может быть целью операции другого процесса в системных вызовах, который "
"указывает идентификатор процесса. И наоборот, процессы в дочернем "
"пространстве имён PID не видят процессы в родительском и более удалённых "
"родительских пространствах имён. Более кратко: процесс может видеть "
"(например, посылать сигналы с помощью B<kill>(2), назначать значения "
"уступчивости с помощью B<setpriority>(2) и т. п.) только процессы из своего "
"пространства имён PID и в потомках этого пространства имён."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:175
msgid ""
"A process has one process ID in each of the layers of the PID namespace "
"hierarchy in which is visible, and walking back though each direct ancestor "
"namespace through to the root PID namespace.  System calls that operate on "
"process IDs always operate using the process ID that is visible in the PID "
"namespace of the caller.  A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process was created."
msgstr ""
"Процесс имеет идентификатор в каждом слое иерархии пространства имён PID, в "
"котором он виден, и двигаясь назад, в каждом прямом предке пространства имён "
"вплоть до корневого пространства имён PID. Системные вызовы, работающие с "
"идентификатором процесса, всегда используют идентификатор процесса, который "
"видим в пространстве имён PID вызывающего. Вызов B<getpid>(2) всегда "
"возвращает PID, связанный с пространством имён, в котором был создан процесс."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:190
msgid ""
"Some processes in a PID namespace may have parents that are outside of the "
"namespace.  For example, the parent of the initial process in the namespace "
"(i.e., the B<init>(1)  process with PID 1) is necessarily in another "
"namespace.  Likewise, the direct children of a process that uses "
"B<setns>(2)  to cause its children to join a PID namespace are in a "
"different PID namespace from the caller of B<setns>(2).  Calls to "
"B<getppid>(2)  for such processes return 0."
msgstr ""
"Некоторые процессы в пространстве имён PID могут иметь родителей, которые "
"находятся вне пространства имён. Например, родитель начального процесса в "
"пространстве имён (т. е., процесс B<init>(1) с PID 1) неизбежно находится в "
"другом пространстве имён. Аналогичным образом, прямые потомки процесса, "
"который использует B<setns>(2) для объединения потомков в пространство имён "
"PID, находятся в другом пространстве имён PID относительно вызывающего "
"B<setns>(2). При вызове B<getppid>(2) для таких процессов возвращает 0."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:199
msgid ""
"While processes may freely descend into child PID namespaces (e.g., using "
"B<setns>(2)  with a PID namespace file descriptor), they may not move in the "
"other direction.  That is to say, processes may not enter any ancestor "
"namespaces (parent, grandparent, etc.).  Changing PID namespaces is a one-"
"way operation."
msgstr ""
"Хотя процессы могут свободно перемещаться вниз в дочерние пространства имён "
"PID (например, с помощью B<setns>(2) с файловым дескриптором пространства "
"имён PID), они не могут перемещаться в обратном направлении. То есть "
"процессы не могут входить в пространства имён предка (родителя, прародителя "
"и т .п.). Изменение пространств имён PID — это односторонняя операция."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:209
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between PID namespaces; see B<ioctl_ns>(2)."
msgstr ""
"Операцию B<NS_GET_PARENT> B<ioctl>(2) можно использовать для обнаружения "
"родительской связи между пространствами имён PID; смотрите B<ioctl_ns>(2)."

#. type: SS
#: man-pages/man7/pid_namespaces.7:209
#, no-wrap
msgid "setns(2) and unshare(2) semantics"
msgstr "Семантика setns(2) и unshare(2)"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:229
msgid ""
"Calls to B<setns>(2)  that specify a PID namespace file descriptor and calls "
"to B<unshare>(2)  with the B<CLONE_NEWPID> flag cause children subsequently "
"created by the caller to be placed in a different PID namespace from the "
"caller.  (Since Linux 4.12, that PID namespace is shown via the I</proc/"
"[pid]/ns/pid_for_children> file, as described in B<namespaces>(7).)  These "
"calls do not, however, change the PID namespace of the calling process, "
"because doing so would change the caller's idea of its own PID (as reported "
"by B<getpid>()), which would break many applications and libraries."
msgstr ""
"Последовательно выполняемые вызовы B<setns>(2) с файловым дескриптором "
"пространства имён PID и вызов B<unshare>(2) с флагом B<CLONE_NEWPID> "
"помещают потомков в другое пространство имён PID, отличное от пространства "
"вызывающего (начиная с Linux 4.12 данное пространство имён PID показывается "
"через файл I</proc/[pid]/ns/pid_for_children> как описано в "
"B<namespaces>(7)). Однако, эти вызовы не изменяют пространство имён PID "
"вызывающего процесса, так как это позволило бы изменять PID вызывающего "
"(сообщаемые B<getpid>()), что сломало бы многие приложения и библиотеки."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:237
msgid ""
"To put things another way: a process's PID namespace membership is "
"determined when the process is created and cannot be changed thereafter.  "
"Among other things, this means that the parental relationship between "
"processes mirrors the parental relationship between PID namespaces: the "
"parent of a process is either in the same namespace or resides in the "
"immediate parent PID namespace."
msgstr ""
"Посмотрим на вещи под другим углом: членство процесса в пространстве имён "
"PID определяется при создании процесса и не может быть изменено в "
"дальнейшем. Помимо прочего, это означает, что родственные отношения между "
"процессами зеркально отражают родственные отношения между пространствами "
"имён PID: родитель процесса находится в том же пространстве имён или в "
"непосредственном родительском пространстве имён namespace."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:249
msgid ""
"A process may call B<unshare>(2)  with the B<CLONE_NEWPID> flag only once.  "
"After it has performed this operation, its I</proc/PID/ns/pid_for_children> "
"symbolic link will be empty until the first child is created in the "
"namespace."
msgstr ""
"Процесс может вызвать B<unshare>(2) с флагом B<CLONE_NEWPID> только один "
"раз. После выполнения этой операции его символическая ссылка I</proc/PID/ns/"
"pid_for_children> станет пустой, пока пространстве имён не будет создать "
"первый потомок."

#. type: SS
#: man-pages/man7/pid_namespaces.7:249
#, no-wrap
msgid "Adoption of orphaned children"
msgstr "Усыновление осиротевших потомков"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:265
msgid ""
"When a child process becomes orphaned, it is reparented to the \"init\" "
"process in the PID namespace of its parent (unless one of the nearer "
"ancestors of the parent employed the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> "
"command to mark itself as the reaper of orphaned descendant processes).  "
"Note that because of the B<setns>(2)  and B<unshare>(2)  semantics described "
"above, this may be the \"init\" process in the PID namespace that is the "
"I<parent> of the child's PID namespace, rather than the \"init\" process in "
"the child's own PID namespace."
msgstr ""
"Когда дочерний процесс становится сиротой, его родителем становится "
"«начальный» процесс в пространстве имён PID его родителя (если один из "
"ближайших родственных процессов родителя не вызывал команду B<prctl>(2)  "
"B<PR_SET_CHILD_SUBREAPER> для назначения себя сборщиком собирателем дочерних "
"процессов). Заметим, что благодаря семантике B<setns>(2) и B<unshare>(2), "
"описанной выше, это может быть процесс «init» в пространстве имён PID, "
"являющийся I<родителем> пространства имён PID потомка, а не процесс «init» "
"пространства имён PID самого потомка."

#.  Furthermore, by definition, the parent of the "init" process
#.  of a PID namespace resides in the parent PID namespace.
#.  ============================================================
#. type: SS
#: man-pages/man7/pid_namespaces.7:270
#, no-wrap
msgid "Compatibility of CLONE_NEWPID with other CLONE_* flags"
msgstr "Совместимость CLONE_NEWPID с другими флагами CLONE_*"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:291
msgid ""
"In current versions of Linux, B<CLONE_NEWPID> can't be combined with "
"B<CLONE_THREAD>.  Threads are required to be in the same PID namespace such "
"that the threads in a process can send signals to each other.  Similarly, it "
"must be possible to see all of the threads of a processes in the B<proc>(5)  "
"filesystem.  Additionally, if two threads were in different PID namespaces, "
"the process ID of the process sending a signal could not be meaningfully "
"encoded when a signal is sent (see the description of the I<siginfo_t> type "
"in B<sigaction>(2)).  Since this is computed when a signal is enqueued, a "
"signal queue shared by processes in multiple PID namespaces would defeat "
"that."
msgstr ""
"В текущих версиях Linux B<CLONE_NEWPID> нельзя объединять вместе с "
"B<CLONE_THREAD>. Для нитей требуется находиться в том же пространстве имён "
"PID, чтобы нити процесса могли посылать сигналы друг другу. Также требуется "
"видеть все нити процессов в файловой системе B<proc>(5). Также, если две "
"нити находятся в разных пространствах имён PID, то ID процесса, посылающего "
"сигнал, невозможно достоверно закодировать при посылке (смотрите описание "
"типа I<siginfo_t> в B<sigaction>(2)). Так как вычисление выполняется когда "
"сигнал попадает в очередь сигналов, общая для процессов из нескольких "
"пространств имён PID, очередь сигналов не позволяет этого."

#.  Note these restrictions were all introduced in
#.  8382fcac1b813ad0a4e68a838fc7ae93fa39eda0
#.  when CLONE_NEWPID|CLONE_VM was disallowed
#.  (restriction lifted in faf00da544045fdc1454f3b9e6d7f65c841de302)
#.  (restriction lifted in e79f525e99b04390ca4d2366309545a836c03bf1)
#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:311
msgid ""
"In earlier versions of Linux, B<CLONE_NEWPID> was additionally disallowed "
"(failing with the error B<EINVAL>)  in combination with B<CLONE_SIGHAND> "
"(before Linux 4.3) as well as B<CLONE_VM> (before Linux 3.12).  The changes "
"that lifted these restrictions have also been ported to earlier stable "
"kernels."
msgstr ""
"В ранних версиях Linux значение B<CLONE_NEWPID> также запрещалось "
"(возвращалась ошибка B<EINVAL>) объединять с B<CLONE_SIGHAND> (до Linux "
"4.3), а также с B<CLONE_VM> (до Linux 3.12). Изменения, снявшие эти "
"ограничения, были также перенесены в более ранние стабильные ядра."

#. type: SS
#: man-pages/man7/pid_namespaces.7:311
#, no-wrap
msgid "/proc and PID namespaces"
msgstr "/proc и PID пространств имен"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:320
msgid ""
"A I</proc> filesystem shows (in the I</proc/[pid]> directories) only "
"processes visible in the PID namespace of the process that performed the "
"mount, even if the I</proc> filesystem is viewed from processes in other "
"namespaces."
msgstr ""
"В файловой системе I</proc> отображаются (в каталогах I</proc/[pid]>) только "
"процессы, видимые в пространстве имён PID процесса, который выполнил "
"монтирование, даже если файловая система I</proc> видима из процессов "
"другого пространства имён."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:339
msgid ""
"After creating a new PID namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  If a new mount namespace is "
"simultaneously created by including B<CLONE_NEWNS> in the I<flags> argument "
"of B<clone>(2)  or B<unshare>(2), then it isn't necessary to change the root "
"directory: a new procfs instance can be mounted directly over I</proc>."
msgstr ""
"После создания нового пространства имён PID у потомка полезно изменить его "
"корневой каталог и смонтировать новый экземпляр procfs в I</proc> для того, "
"чтобы корректно работали инструменты типа B<ps>(1). Если одновременно "
"создаётся новое пространство имён монтирования, добавлением флага "
"B<CLONE_NEWNS> в аргумент I<flags> вызова B<clone>(2) или B<unshare>(2), то "
"необязательно изменять корневой каталог: новый экземпляр procfs можно "
"смонтировать непосредственно в I</proc>."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:343
msgid "From a shell, the command to mount I</proc> is:"
msgstr "Команда оболочки для монтирования I</proc>:"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:347
#, no-wrap
msgid "$ mount -t proc proc /proc\n"
msgstr "$ mount -t proc proc /proc\n"

#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:361
msgid ""
"Calling B<readlink>(2)  on the path I</proc/self> yields the process ID of "
"the caller in the PID namespace of the procfs mount (i.e., the PID namespace "
"of the process that mounted the procfs).  This can be useful for "
"introspection purposes, when a process wants to discover its PID in other "
"namespaces."
msgstr ""
"Вызов B<readlink>(2) с путём I</proc/self> выдаёт идентификатор процесса "
"вызывающего из пространства имён PID, откуда смонтирован procfs (т. е., из "
"пространства имён PID процесса, который смонтировал procfs). Это может быть "
"полезно при самоанализе, когда процесс хочет узнать свой PID в других "
"пространствах имён."

#. type: SS
#: man-pages/man7/pid_namespaces.7:361
#, no-wrap
msgid "/proc files"
msgstr "Файлы в /proc"

#. type: TP
#: man-pages/man7/pid_namespaces.7:362
#, no-wrap
msgid "B</proc/sys/kernel/ns_last_pid> (since Linux 3.3)"
msgstr "B</proc/sys/kernel/ns_last_pid> (начиная с Linux 3.3)"

#.  commit b8f566b04d3cddd192cfd2418ae6d54ac6353792
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:370
msgid ""
"This file displays the last PID that was allocated in this PID namespace.  "
"When the next PID is allocated, the kernel will search for the lowest "
"unallocated PID that is greater than this value, and when this file is "
"subsequently read it will show that PID."
msgstr ""
"Этот файл отражает последний PID, который был выделен в этом пространстве "
"имён PID. Когда выделяется следующий PID, ядро ищет самый маленький не "
"выделенный PID, который больше этого значения, и при следующем чтении этого "
"файла в нём будет этот PID."

#.  This ability is necessary to support checkpoint restore in user-space
#.  ============================================================
#. type: Plain text
#: man-pages/man7/pid_namespaces.7:380
msgid ""
"This file is writable by a process that has the B<CAP_SYS_ADMIN> capability "
"inside its user namespace.  This makes it possible to determine the PID that "
"is allocated to the next process that is created inside this PID namespace."
msgstr ""
"Этот файл доступен на запись процессу с мандатом B<CAP_SYS_ADMIN> внутри "
"своего пространства имён пользователя. Это делает возможным задать PID, "
"который выделяется следующему процессу, создаваемому внутри этого "
"пространства имён PID."

#. type: SS
#: man-pages/man7/pid_namespaces.7:380
#, no-wrap
msgid "Miscellaneous"
msgstr "Разное"

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:388
msgid ""
"When a process ID is passed over a UNIX domain socket to a process in a "
"different PID namespace (see the description of B<SCM_CREDENTIALS> in "
"B<unix>(7)), it is translated into the corresponding PID value in the "
"receiving process's PID namespace."
msgstr ""
"Когда идентификатор процесса передаётся через доменный сокет UNIX в процесс "
"в другом пространстве имён PID (смотрите описание B<SCM_CREDENTIALS> в "
"B<unix>(7)), то он транслируется в соответствующее значения PID из "
"пространства имён PID принимающего процесса."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:390
msgid "Namespaces are a Linux-specific feature."
msgstr "Пространства имён есть только в Linux."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:393
msgid "See B<user_namespaces>(7)."
msgstr "См. B<user_namespaces>(7)."

#. type: Plain text
#: man-pages/man7/pid_namespaces.7:404
msgid ""
"B<clone>(2), B<reboot>(2), B<setns>(2), B<unshare>(2), B<proc>(5), "
"B<capabilities>(7), B<credentials>(7), B<mount_namespaces>(7), "
"B<namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"
msgstr ""
"B<clone>(2), B<reboot>(2), B<setns>(2), B<unshare>(2), B<proc>(5), "
"B<capabilities>(7), B<credentials>(7), B<mount_namespaces>(7), "
"B<namespaces>(7), B<user_namespaces>(7), B<switch_root>(8)"

#. type: TH
#: man-pages/man7/persistent-keyring.7:12
#, no-wrap
msgid "PERSISTENT-KEYRING"
msgstr "PERSISTENT-KEYRING"

#. type: TH
#: man-pages/man7/persistent-keyring.7:12
#, no-wrap
msgid "2017-03-13"
msgstr "2017-03-13"

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:15
msgid "persistent-keyring - per-user persistent keyring"
msgstr "persistent-keyring - пользовательская постоянная связка ключей"

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:24
msgid ""
"The persistent keyring is a keyring used to anchor keys on behalf of a "
"user.  Each UID the kernel deals with has its own persistent keyring that is "
"shared between all threads owned by that UID.  The persistent keyring has a "
"name (description) of the form I<_persistent.E<lt>UIDE<gt>> where "
"I<E<lt>UIDE<gt>> is the user ID of the corresponding user."
msgstr ""
"Постоянная связка ключей — это связка, используемая для привязки от имени "
"пользователя. Для каждого UID ядро создаёт отдельную постоянную связку "
"ключей, которая используется всеми нитями, принадлежащими этому UID. "
"Постоянная связка ключей имеет имя (описание) в виде I<_persistent."
"E<lt>UIDE<gt>>, I<E<lt>UIDE<gt>> — ID пользователя соответствующего "
"пользователя."

#.  FIXME The meaning of the preceding sentence isn't clear. What is meant?
#. type: Plain text
#: man-pages/man7/persistent-keyring.7:34
msgid ""
"The persistent keyring may not be accessed directly, even by processes with "
"the appropriate UID.  Instead, it must first be linked to one of a process's "
"keyrings, before that keyring can access the persistent keyring by virtue of "
"its possessor permits.  This linking is done with the "
"B<keyctl_get_persistent>(3)  function."
msgstr ""
"Прямой доступ к постоянной связке ключей невозможен, даже процессам с "
"подходящим UID. Вместо этого сначала она должна быть прицеплена к одной из "
"связок ключей процесса, до этого связка ключей может получить доступ к "
"постоянной связке ключей согласно правам своего владельца. Эта связь "
"создаётся с помощью функции B<keyctl_get_persistent>(3)."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:38
msgid ""
"If a persistent keyring does not exist when it is accessed by the "
"B<keyctl_get_persistent>(3)  operation, it will be automatically created."
msgstr ""
"Если постоянная связка ключей не существует на момент вызова операции "
"B<keyctl_get_persistent>(3), то она автоматически создаётся."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:43
msgid ""
"Each time the B<keyctl_get_persistent>(3)  operation is performed, the "
"persistent key's expiration timer is reset to the value in:"
msgstr ""
"Каждый раз при выполнении операции B<keyctl_get_persistent>(3) срок действия "
"постоянного  ключа сбрасывается в значение:"

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:45
#, no-wrap
msgid "    /proc/sys/kernel/keys/persistent_keyring_expiry\n"
msgstr "    /proc/sys/kernel/keys/persistent_keyring_expiry\n"

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:51
msgid ""
"Should the timeout be reached, the persistent keyring will be removed and "
"everything it pins can then be garbage collected.  The key will then be re-"
"created on a subsequent call to B<keyctl_get_persistent>(3)."
msgstr ""
"По истечению срока действия постоянная связка ключей удаляется и все ссылки "
"на неё затем удаляются сборщиком мусора. После этого ключ будет пересоздан "
"при следующем вызове B<keyctl_get_persistent>(3)."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:57
msgid ""
"The persistent keyring is not directly searched by B<request_key>(2); it is "
"searched only if it is linked into one of the keyrings that is searched by "
"B<request_key>(2)."
msgstr ""
"В постоянной связке ключей напрямую невозможно искать с помощью "
"B<request_key>(2); в ней можно искать только, если она прицеплена к одной из "
"связок ключей, по которой выполняется B<request_key>(2)."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:77
msgid ""
"The persistent keyring is independent of B<clone>(2), B<fork>(2), "
"B<vfork>(2), B<execve>(2), and B<_exit>(2).  It persists until its "
"expiration timer triggers, at which point it is garbage collected.  This "
"allows the persistent keyring to carry keys beyond the life of the kernel's "
"record of the corresponding UID (the destruction of which results in the "
"destruction of the B<user-keyring>(7)  and the B<user-session-keyring>(7)).  "
"The persistent keyring can thus be used to hold authentication tokens for "
"processes that run without user interaction, such as programs started by "
"B<cron>(8)."
msgstr ""
"Постоянная связка ключей не зависит от B<clone>(2), B<fork>(2), B<vfork>(2), "
"B<execve>(2) и B<_exit>(2). Она существует до истечения срока действия "
"таймера, после чего удаляется сборщиком мусора. Это позволяет связке ключей "
"хранить ключи дольше жизни ядерной записи соответствующего UID (удаление "
"которой приводит к уничтожению B<user-keyring>(7) и B<user-session-"
"keyring>(7)). Таким образом, постоянную связку ключей можно использовать для "
"хранения токенов аутентификации для процессов, которые выполняются без "
"взаимодействия с пользователем, например программы, выполняемые B<cron>(8)."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:85
msgid ""
"The persistent keyring is used to store UID-specific objects that themselves "
"have limited lifetimes (e.g., kerberos tokens).  If those tokens cease to be "
"used (i.e., the persistent keyring is not accessed), then the timeout of the "
"persistent keyring ensures that the corresponding objects are automatically "
"discarded."
msgstr ""
"Постоянная связка ключей используется для хранения объектов, для UID, "
"которые сами имеют ограниченный срок жизни (например, токены kerberos). Если "
"такие токены больше не используются (т. е., связка ключей недоступна), то "
"срок действия постоянной связки ключей позволяет автоматически удалять "
"соответствующие ей объекты."

#. type: SS
#: man-pages/man7/persistent-keyring.7:85
#, no-wrap
msgid "Special operations"
msgstr "Специальные операции"

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:100
msgid ""
"The I<keyutils> library provides the B<keyctl_get_persistent>(3)  function "
"for manipulating persistent keyrings.  (This function is an interface to the "
"B<keyctl>(2)  B<KEYCTL_GET_PERSISTENT> operation.)  This operation allows "
"the calling thread to get the persistent keyring corresponding to its own "
"UID or, if the thread has the B<CAP_SETUID> capability, the persistent "
"keyring corresponding to some other UID in the same user namespace."
msgstr ""
"Библиотека I<keyutils> для работы с постоянными связками ключей "
"предоставляет функцию B<keyctl_get_persistent>(3) (эта функция является "
"интерфейсом к операции B<keyctl>(2)  B<KEYCTL_GET_PERSISTENT>). Данная "
"операция позволяет вызывающей нити получить постоянную связку ключей, "
"соответствующую её UID или, если нить имеет мандат B<CAP_SETUID>, то "
"постоянная связка ключей соответствует какому-то другому UID в этом же "
"пространстве имён пользователя."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:115
msgid ""
"Each user namespace owns a keyring called I<.persistent_register> that "
"contains links to all of the persistent keys in that namespace.  (The I<."
"persistent_register> keyring can be seen when reading the contents of the I</"
"proc/keys> file for the UID 0 in the namespace.)  The "
"B<keyctl_get_persistent>(3)  operation looks for a key with a name of the "
"form I<_persistent.E<lt>UIDE<gt>> in that keyring, creates the key if it "
"does not exist, and links it into the keyring."
msgstr ""
"Каждое пространство имён пользователя имеет свою связку ключей с именем I<."
"persistent_register>, в которой содержатся ссылки на все постоянные ключи в "
"этом пространстве имён (связку ключей I<.persistent_register> можно увидеть "
"при чтении в пространстве имён содержимого файла I</proc/keys> для UID 0). "
"Операция B<keyctl_get_persistent>(3) ищет ключ с именем в виде I<_persistent."
"E<lt>UIDE<gt>> в этой связке ключей, создаёт ключ, если он не существует и "
"прицепляет его в связку ключей."

#. type: Plain text
#: man-pages/man7/persistent-keyring.7:126
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyctl_get_persistent>(3), B<keyrings>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7)"
msgstr ""
"B<keyctl>(1), B<keyctl>(3), B<keyctl_get_persistent>(3), B<keyrings>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7)"

#. type: TH
#: man-pages/man7/posixoptions.7:24
#, no-wrap
msgid "POSIXOPTIONS"
msgstr "POSIXOPTIONS"

#. type: TH
#: man-pages/man7/posixoptions.7:24
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man7/posixoptions.7:27
msgid "posixoptions - optional parts of the POSIX standard"
msgstr "posixoptions - необязательные части стандарта POSIX"

#. type: Plain text
#: man-pages/man7/posixoptions.7:41
msgid ""
"The POSIX standard (the information below is from POSIX.1-2001)  describes a "
"set of behaviors and interfaces for a compliant system.  However, many "
"interfaces are optional and there are feature test macros to test the "
"availability of interfaces at compile time, and functions B<sysconf>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<confstr>(3)  to do this at run time.  "
"From shell scripts one can use B<getconf>(1).  For more detail, see "
"B<sysconf>(3)."
msgstr ""
"В стандарте POSIX (информация взята POSIX.1-2001) описан набор правил работы "
"и интерфейсы, требуемый от совместимой системы. Однако много интерфейсов "
"являются необязательными и имеется набор макросов тестирования свойств для "
"проверки доступности интерфейсов во время компиляции, а также есть функции "
"B<sysconf>(3), B<fpathconf>(3), B<pathconf>(3), B<confstr>(3), которые "
"выполняют проверки во время выполнения.  Из сценариев оболочки можно "
"использовать B<getconf>(1). Подробности смотрите в B<sysconf>(3)."

#. type: Plain text
#: man-pages/man7/posixoptions.7:48
msgid ""
"We give the name of the POSIX abbreviation, the option, the name of the "
"B<sysconf>(3)  parameter used to inquire about the option, and possibly a "
"very short description.  Much more precise detail can be found in the POSIX "
"standard itself, versions of which can nowadays be accessed freely on the "
"web."
msgstr ""
"Мы приводим имя из POSIX, свойство, имя параметра B<sysconf>(3), который "
"используется для запроса этого свойство, и возможно, очень краткое описание. "
"Более полную информацию можно найти в самом стандарте POSIX, из версий, "
"которые теперь свободно доступны через веб."

#. type: SS
#: man-pages/man7/posixoptions.7:48
#, no-wrap
msgid "ADV - _POSIX_ADVISORY_INFO - _SC_ADVISORY_INFO"
msgstr "ADV - _POSIX_ADVISORY_INFO - _SC_ADVISORY_INFO"

#. type: Plain text
#: man-pages/man7/posixoptions.7:50
msgid "The following advisory functions are present:"
msgstr "Доступны следующие консультативные функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:57
#, no-wrap
msgid ""
"I<posix_fadvise>()\n"
"I<posix_fallocate>()\n"
"I<posix_memalign>()\n"
"I<posix_madvise>()\n"
msgstr ""
"I<posix_fadvise>()\n"
"I<posix_fallocate>()\n"
"I<posix_memalign>()\n"
"I<posix_madvise>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:59
#, no-wrap
msgid "AIO - _POSIX_ASYNCHRONOUS_IO - _SC_ASYNCHRONOUS_IO"
msgstr "AIO - _POSIX_ASYNCHRONOUS_IO - _SC_ASYNCHRONOUS_IO"

#. type: Plain text
#: man-pages/man7/posixoptions.7:64
msgid ""
"The header I<E<lt>aio.hE<gt>> is present.  The following functions are "
"present:"
msgstr ""
"Доступен заголовочный файл I<E<lt>aio.hE<gt>>. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:75
#, no-wrap
msgid ""
"I<aio_cancel>()\n"
"I<aio_error>()\n"
"I<aio_fsync>()\n"
"I<aio_read>()\n"
"I<aio_return>()\n"
"I<aio_suspend>()\n"
"I<aio_write>()\n"
"I<lio_listio>()\n"
msgstr ""
"I<aio_cancel>()\n"
"I<aio_error>()\n"
"I<aio_fsync>()\n"
"I<aio_read>()\n"
"I<aio_return>()\n"
"I<aio_suspend>()\n"
"I<aio_write>()\n"
"I<lio_listio>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:77
#, no-wrap
msgid "BAR - _POSIX_BARRIERS - _SC_BARRIERS"
msgstr "BAR - _POSIX_BARRIERS - _SC_BARRIERS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:84 man-pages/man7/posixoptions.7:460
msgid ""
"This option implies the B<_POSIX_THREADS> and "
"B<_POSIX_THREAD_SAFE_FUNCTIONS> options.  The following functions are "
"present:"
msgstr ""
"Это свойство подразумевает свойства B<_POSIX_THREADS> и "
"B<_POSIX_THREAD_SAFE_FUNCTIONS>. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:92
#, no-wrap
msgid ""
"I<pthread_barrier_destroy>()\n"
"I<pthread_barrier_init>()\n"
"I<pthread_barrier_wait>()\n"
"I<pthread_barrierattr_destroy>()\n"
"I<pthread_barrierattr_init>()\n"
msgstr ""
"I<pthread_barrier_destroy>()\n"
"I<pthread_barrier_init>()\n"
"I<pthread_barrier_wait>()\n"
"I<pthread_barrierattr_destroy>()\n"
"I<pthread_barrierattr_init>()\n"

#.  .SS BE
#.  Batch environment.
#.  .SS CD
#.  C development.
#. type: SS
#: man-pages/man7/posixoptions.7:98
#, no-wrap
msgid "--- - POSIX_CHOWN_RESTRICTED"
msgstr "--- - POSIX_CHOWN_RESTRICTED"

#. type: Plain text
#: man-pages/man7/posixoptions.7:103
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then only "
"root may change the owner of a file, and nonroot can set the group of a file "
"only to one of the groups it belongs to.  This affects the following "
"functions"
msgstr ""
"Если действует это свойство (всегда, согласно POSIX.1-2001), то только "
"суперпользователь может изменять владельца файла, а обычный пользователь "
"может задать группу файла только на одну из групп, которой принадлежит. "
"Учитывается в функциях:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:108
#, no-wrap
msgid ""
"I<chown>()\n"
"I<fchown>()\n"
msgstr ""
"I<chown>()\n"
"I<fchown>()\n"

#.  What about lchown() ?
#. type: SS
#: man-pages/man7/posixoptions.7:111
#, no-wrap
msgid "CS - _POSIX_CLOCK_SELECTION - _SC_CLOCK_SELECTION"
msgstr "CS - _POSIX_CLOCK_SELECTION - _SC_CLOCK_SELECTION"

#. type: Plain text
#: man-pages/man7/posixoptions.7:116
msgid ""
"This option implies the B<_POSIX_TIMERS> option.  The following functions "
"are present:"
msgstr ""
"Это свойство подразумевает свойство B<_POSIX_TIMERS>. Доступны следующие "
"функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:122
#, no-wrap
msgid ""
"I<pthread_condattr_getclock>()\n"
"I<pthread_condattr_setclock>()\n"
"I<clock_nanosleep>()\n"
msgstr ""
"I<pthread_condattr_getclock>()\n"
"I<pthread_condattr_setclock>()\n"
"I<clock_nanosleep>()\n"

#. type: Plain text
#: man-pages/man7/posixoptions.7:130
msgid ""
"If B<CLOCK_REALTIME> is changed by the function I<clock_settime>(), then "
"this affects all timers set for an absolute time."
msgstr ""
"Если B<CLOCK_REALTIME> изменяется функцией I<clock_settime>(), то это влияет "
"на все таймеры, заданные абсолютным временем."

#. type: SS
#: man-pages/man7/posixoptions.7:130
#, no-wrap
msgid "CPT - _POSIX_CPUTIME - _SC_CPUTIME"
msgstr "CPT - _POSIX_CPUTIME - _SC_CPUTIME"

#.  .SS FD
#.  Fortran development
#.  .SS FR
#.  Fortran runtime
#. type: Plain text
#: man-pages/man7/posixoptions.7:145
msgid ""
"The B<CLOCK_PROCESS_CPUTIME_ID> clock ID is supported.  The initial value of "
"this clock is 0 for each process.  This option implies the B<_POSIX_TIMERS> "
"option.  The function I<clock_getcpuclockid>()  is present."
msgstr ""
"Поддерживается идентификатор часов B<CLOCK_PROCESS_CPUTIME_ID>. Начальное "
"значение этих часов равно нулю для каждого процесса. Данное свойство "
"подразумевает свойство B<_POSIX_TIMERS>. Доступна функция "
"I<clock_getcpuclockid>()."

#. type: SS
#: man-pages/man7/posixoptions.7:145
#, no-wrap
msgid "--- - _POSIX_FILE_LOCKING - _SC_FILE_LOCKING"
msgstr "--- - _POSIX_FILE_LOCKING - _SC_FILE_LOCKING"

#.  .SS MX
#.  IEC 60559 Floating-Point Option.
#. type: Plain text
#: man-pages/man7/posixoptions.7:148 man-pages/man7/posixoptions.7:248
msgid "This option has been deleted.  Not in final XPG6."
msgstr "Эта функция была удалена. Нет в окончательной XPG6."

#. type: SS
#: man-pages/man7/posixoptions.7:148
#, no-wrap
msgid "FSC - _POSIX_FSYNC - _SC_FSYNC"
msgstr "FSC - _POSIX_FSYNC - _SC_FSYNC"

#. type: Plain text
#: man-pages/man7/posixoptions.7:152
msgid "The function I<fsync>()  is present."
msgstr "Доступна функция I<fsync>()."

#. type: SS
#: man-pages/man7/posixoptions.7:152
#, no-wrap
msgid "IP6 - _POSIX_IPV6 - _SC_IPV6"
msgstr "IP6 - _POSIX_IPV6 - _SC_IPV6"

#. type: Plain text
#: man-pages/man7/posixoptions.7:154
msgid "Internet Protocol Version 6 is supported."
msgstr "Поддерживается Internet Protocol Version 6."

#. type: SS
#: man-pages/man7/posixoptions.7:154
#, no-wrap
msgid "--- - _POSIX_JOB_CONTROL - _SC_JOB_CONTROL"
msgstr "--- - _POSIX_JOB_CONTROL - _SC_JOB_CONTROL"

#. type: Plain text
#: man-pages/man7/posixoptions.7:158
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then the "
"system implements POSIX-style job control, and the following functions are "
"present:"
msgstr ""
"Если доступно это свойство (всегда в POSIX.1-2001), то в системе реализовано "
"управление заданиями в стиле POSIX и доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:168
#, no-wrap
msgid ""
"I<setpgid>()\n"
"I<tcdrain>()\n"
"I<tcflush>()\n"
"I<tcgetpgrp>()\n"
"I<tcsendbreak>()\n"
"I<tcsetattr>()\n"
"I<tcsetpgrp>()\n"
msgstr ""
"I<setpgid>()\n"
"I<tcdrain>()\n"
"I<tcflush>()\n"
"I<tcgetpgrp>()\n"
"I<tcsendbreak>()\n"
"I<tcsetattr>()\n"
"I<tcsetpgrp>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:170
#, no-wrap
msgid "MF - _POSIX_MAPPED_FILES - _SC_MAPPED_FILES"
msgstr "MF - _POSIX_MAPPED_FILES - _SC_MAPPED_FILES"

#. type: Plain text
#: man-pages/man7/posixoptions.7:176
msgid ""
"Shared memory is supported.  The include file I<E<lt>sys/mman.hE<gt>> is "
"present.  The following functions are present:"
msgstr ""
"Поддерживается общая память. Доступен заголовочный файл I<E<lt>sys/mman."
"hE<gt>>. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:182
#, no-wrap
msgid ""
"I<mmap>()\n"
"I<msync>()\n"
"I<munmap>()\n"
msgstr ""
"I<mmap>()\n"
"I<msync>()\n"
"I<munmap>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:184
#, no-wrap
msgid "ML - _POSIX_MEMLOCK - _SC_MEMLOCK"
msgstr "ML - _POSIX_MEMLOCK - _SC_MEMLOCK"

#. type: Plain text
#: man-pages/man7/posixoptions.7:187
msgid ""
"Shared memory can be locked into core.  The following functions are present:"
msgstr ""
"Общая память может блокироваться в ядре (core). Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:192
#, no-wrap
msgid ""
"I<mlockall>()\n"
"I<munlockall>()\n"
msgstr ""
"I<mlockall>()\n"
"I<munlockall>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:194
#, no-wrap
msgid "MR/MLR - _POSIX_MEMLOCK_RANGE - _SC_MEMLOCK_RANGE"
msgstr "MR/MLR - _POSIX_MEMLOCK_RANGE - _SC_MEMLOCK_RANGE"

#. type: Plain text
#: man-pages/man7/posixoptions.7:197
msgid ""
"More precisely, ranges can be locked into core.  The following functions are "
"present:"
msgstr ""
"Более точно, диапазоны могут блокироваться в ядре (core). Доступны следующие "
"функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:202
#, no-wrap
msgid ""
"I<mlock>()\n"
"I<munlock>()\n"
msgstr ""
"I<mlock>()\n"
"I<munlock>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:204
#, no-wrap
msgid "MPR - _POSIX_MEMORY_PROTECTION - _SC_MEMORY_PROTECTION"
msgstr "MPR - _POSIX_MEMORY_PROTECTION - _SC_MEMORY_PROTECTION"

#. type: Plain text
#: man-pages/man7/posixoptions.7:208
msgid "The function I<mprotect>()  is present."
msgstr "Доступна функция I<mprotect>()."

#. type: SS
#: man-pages/man7/posixoptions.7:208
#, no-wrap
msgid "MSG - _POSIX_MESSAGE_PASSING - _SC_MESSAGE_PASSING"
msgstr "MSG - _POSIX_MESSAGE_PASSING - _SC_MESSAGE_PASSING"

#. type: Plain text
#: man-pages/man7/posixoptions.7:213
msgid ""
"The include file I<E<lt>mqueue.hE<gt>> is present.  The following functions "
"are present:"
msgstr ""
"Доступен заголовочный файл I<E<lt>mqueue.hE<gt>>. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:224
#, no-wrap
msgid ""
"I<mq_close>()\n"
"I<mq_getattr>()\n"
"I<mq_notify>()\n"
"I<mq_open>()\n"
"I<mq_receive>()\n"
"I<mq_send>()\n"
"I<mq_setattr>()\n"
"I<mq_unlink>()\n"
msgstr ""
"I<mq_close>()\n"
"I<mq_getattr>()\n"
"I<mq_notify>()\n"
"I<mq_open>()\n"
"I<mq_receive>()\n"
"I<mq_send>()\n"
"I<mq_setattr>()\n"
"I<mq_unlink>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:226
#, no-wrap
msgid "MON - _POSIX_MONOTONIC_CLOCK - _SC_MONOTONIC_CLOCK"
msgstr "MON - _POSIX_MONOTONIC_CLOCK - _SC_MONOTONIC_CLOCK"

#. type: Plain text
#: man-pages/man7/posixoptions.7:233
msgid ""
"B<CLOCK_MONOTONIC> is supported.  This option implies the B<_POSIX_TIMERS> "
"option.  The following functions are affected:"
msgstr ""
"Поддерживается B<CLOCK_MONOTONIC>. Это свойство подразумевает свойство "
"B<_POSIX_TIMERS>. Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:241
#, no-wrap
msgid ""
"I<aio_suspend>()\n"
"I<clock_getres>()\n"
"I<clock_gettime>()\n"
"I<clock_settime>()\n"
"I<timer_create>()\n"
msgstr ""
"I<aio_suspend>()\n"
"I<clock_getres>()\n"
"I<clock_gettime>()\n"
"I<clock_settime>()\n"
"I<timer_create>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:243
#, no-wrap
msgid "--- - _POSIX_MULTI_PROCESS - _SC_MULTI_PROCESS"
msgstr "--- - _POSIX_MULTI_PROCESS - _SC_MULTI_PROCESS"

#. type: SS
#: man-pages/man7/posixoptions.7:248
#, no-wrap
msgid "--- - _POSIX_NO_TRUNC"
msgstr "--- - _POSIX_NO_TRUNC"

#. type: Plain text
#: man-pages/man7/posixoptions.7:255
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then "
"pathname components longer than B<NAME_MAX> are not truncated, but give an "
"error.  This property may be dependent on the path prefix of the component."
msgstr ""
"Если доступно это свойство (всегда в POSIX.1-2001), то компоненты пути "
"длиннее чем B<NAME_MAX> не обрезаются, а выдаётся ошибка. Данное свойство "
"может зависеть от префикса компонента пути."

#. type: SS
#: man-pages/man7/posixoptions.7:255
#, no-wrap
msgid "PIO - _POSIX_PRIORITIZED_IO - _SC_PRIORITIZED_IO"
msgstr "PIO - _POSIX_PRIORITIZED_IO - _SC_PRIORITIZED_IO"

#. type: Plain text
#: man-pages/man7/posixoptions.7:258
msgid ""
"This option says that one can specify priorities for asynchronous I/O.  This "
"affects the functions"
msgstr ""
"Это свойство показывает, то можно задавать приоритеты для асинхронного ввода-"
"вывода. Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:263
#, no-wrap
msgid ""
"I<aio_read>()\n"
"I<aio_write>()\n"
msgstr ""
"I<aio_read>()\n"
"I<aio_write>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:265
#, no-wrap
msgid "PS - _POSIX_PRIORITY_SCHEDULING - _SC_PRIORITY_SCHEDULING"
msgstr "PS - _POSIX_PRIORITY_SCHEDULING - _SC_PRIORITY_SCHEDULING"

#. type: Plain text
#: man-pages/man7/posixoptions.7:270
msgid ""
"The include file I<E<lt>sched.hE<gt>> is present.  The following functions "
"are present:"
msgstr ""
"Доступен заголовочный файл I<E<lt>sched.hE<gt>>. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:281
#, no-wrap
msgid ""
"I<sched_get_priority_max>()\n"
"I<sched_get_priority_min>()\n"
"I<sched_getparam>()\n"
"I<sched_getscheduler>()\n"
"I<sched_rr_get_interval>()\n"
"I<sched_setparam>()\n"
"I<sched_setscheduler>()\n"
"I<sched_yield>()\n"
msgstr ""
"I<sched_get_priority_max>()\n"
"I<sched_get_priority_min>()\n"
"I<sched_getparam>()\n"
"I<sched_getscheduler>()\n"
"I<sched_rr_get_interval>()\n"
"I<sched_setparam>()\n"
"I<sched_setscheduler>()\n"
"I<sched_yield>()\n"

#. type: Plain text
#: man-pages/man7/posixoptions.7:287
msgid ""
"If also B<_POSIX_SPAWN> is in effect, then the following functions are "
"present:"
msgstr ""
"Если также доступно свойство B<_POSIX_SPAWN>, доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:294 man-pages/man7/posixoptions.7:451
#, no-wrap
msgid ""
"I<posix_spawnattr_getschedparam>()\n"
"I<posix_spawnattr_getschedpolicy>()\n"
"I<posix_spawnattr_setschedparam>()\n"
"I<posix_spawnattr_setschedpolicy>()\n"
msgstr ""
"I<posix_spawnattr_getschedparam>()\n"
"I<posix_spawnattr_getschedpolicy>()\n"
"I<posix_spawnattr_setschedparam>()\n"
"I<posix_spawnattr_setschedpolicy>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:296
#, no-wrap
msgid "RS - _POSIX_RAW_SOCKETS"
msgstr "RS - _POSIX_RAW_SOCKETS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:299
msgid "Raw sockets are supported.  The following functions are affected:"
msgstr ""
"Поддерживаются неструктурированные сокеты. Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:304
#, no-wrap
msgid ""
"I<getsockopt>()\n"
"I<setsockopt>()\n"
msgstr ""
"I<getsockopt>()\n"
"I<setsockopt>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:306
#, no-wrap
msgid "--- - _POSIX_READER_WRITER_LOCKS - _SC_READER_WRITER_LOCKS"
msgstr "--- - _POSIX_READER_WRITER_LOCKS - _SC_READER_WRITER_LOCKS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:314
msgid ""
"This option implies the B<_POSIX_THREADS> option.  Conversely, under "
"POSIX.1-2001 the B<_POSIX_THREADS> option implies this option."
msgstr ""
"Это свойство подразумевает свойство B<_POSIX_THREADS>. И наоборот, согласно "
"POSIX.1-2001, свойство B<_POSIX_THREADS> подразумевает это свойство."

#. type: Plain text
#: man-pages/man7/posixoptions.7:316 man-pages/man7/posixoptions.7:392
#: man-pages/man7/posixoptions.7:686 man-pages/man7/posixoptions.7:700
#: man-pages/man7/posixoptions.7:804 man-pages/man7/posixoptions.7:819
#: man-pages/man7/posixoptions.7:944 man-pages/man7/posixoptions.7:981
msgid "The following functions are present:"
msgstr "Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:328
#, no-wrap
msgid ""
"I<pthread_rwlock_destroy>()\n"
"I<pthread_rwlock_init>()\n"
"I<pthread_rwlock_rdlock>()\n"
"I<pthread_rwlock_tryrdlock>()\n"
"I<pthread_rwlock_trywrlock>()\n"
"I<pthread_rwlock_unlock>()\n"
"I<pthread_rwlock_wrlock>()\n"
"I<pthread_rwlockattr_destroy>()\n"
"I<pthread_rwlockattr_init>()\n"
msgstr ""
"I<pthread_rwlock_destroy>()\n"
"I<pthread_rwlock_init>()\n"
"I<pthread_rwlock_rdlock>()\n"
"I<pthread_rwlock_tryrdlock>()\n"
"I<pthread_rwlock_trywrlock>()\n"
"I<pthread_rwlock_unlock>()\n"
"I<pthread_rwlock_wrlock>()\n"
"I<pthread_rwlockattr_destroy>()\n"
"I<pthread_rwlockattr_init>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:330
#, no-wrap
msgid "RTS - _POSIX_REALTIME_SIGNALS - _SC_REALTIME_SIGNALS"
msgstr "RTS - _POSIX_REALTIME_SIGNALS - _SC_REALTIME_SIGNALS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:333
msgid "Realtime signals are supported.  The following functions are present:"
msgstr "Доступны сигналы реального времени. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:339
#, no-wrap
msgid ""
"I<sigqueue>()\n"
"I<sigtimedwait>()\n"
"I<sigwaitinfo>()\n"
msgstr ""
"I<sigqueue>()\n"
"I<sigtimedwait>()\n"
"I<sigwaitinfo>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:341
#, no-wrap
msgid "--- - _POSIX_REGEXP - _SC_REGEXP"
msgstr "--- - _POSIX_REGEXP - _SC_REGEXP"

#. type: Plain text
#: man-pages/man7/posixoptions.7:345
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then POSIX "
"regular expressions are supported and the following functions are present:"
msgstr ""
"Если доступно это свойство (всегда в POSIX.1-2001), то поддерживаются "
"регулярные выражения POSIX и доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:352
#, no-wrap
msgid ""
"I<regcomp>()\n"
"I<regerror>()\n"
"I<regexec>()\n"
"I<regfree>()\n"
msgstr ""
"I<regcomp>()\n"
"I<regerror>()\n"
"I<regexec>()\n"
"I<regfree>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:354
#, no-wrap
msgid "--- - _POSIX_SAVED_IDS - _SC_SAVED_IDS"
msgstr "--- - _POSIX_SAVED_IDS - _SC_SAVED_IDS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:358
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), then a "
"process has a saved set-user-ID and a saved set-group-ID.  The following "
"functions are affected:"
msgstr ""
"Если доступно это свойство (всегда в POSIX.1-2001), то у процесса имеются "
"сохранённый set-user-ID и сохранённый set-group-ID. Влияет на следующие "
"функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:367
#, no-wrap
msgid ""
"I<exec>()\n"
"I<kill>()\n"
"I<seteuid>()\n"
"I<setegid>()\n"
"I<setgid>()\n"
"I<setuid>()\n"
msgstr ""
"I<exec>()\n"
"I<kill>()\n"
"I<seteuid>()\n"
"I<setegid>()\n"
"I<setgid>()\n"
"I<setuid>()\n"

#.  .SS SD
#.  Software development
#. type: SS
#: man-pages/man7/posixoptions.7:371
#, no-wrap
msgid "SEM - _POSIX_SEMAPHORES - _SC_SEMAPHORES"
msgstr "SEM - _POSIX_SEMAPHORES - _SC_SEMAPHORES"

#. type: Plain text
#: man-pages/man7/posixoptions.7:376
msgid ""
"The include file I<E<lt>semaphore.hE<gt>> is present.  The following "
"functions are present:"
msgstr ""
"Доступен заголовочный файл I<E<lt>semaphore.hE<gt>>. Доступны следующие "
"функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:388
#, no-wrap
msgid ""
"I<sem_close>()\n"
"I<sem_destroy>()\n"
"I<sem_getvalue>()\n"
"I<sem_init>()\n"
"I<sem_open>()\n"
"I<sem_post>()\n"
"I<sem_trywait>()\n"
"I<sem_unlink>()\n"
"I<sem_wait>()\n"
msgstr ""
"I<sem_close>()\n"
"I<sem_destroy>()\n"
"I<sem_getvalue>()\n"
"I<sem_init>()\n"
"I<sem_open>()\n"
"I<sem_post>()\n"
"I<sem_trywait>()\n"
"I<sem_unlink>()\n"
"I<sem_wait>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:390
#, no-wrap
msgid "SHM - _POSIX_SHARED_MEMORY_OBJECTS - _SC_SHARED_MEMORY_OBJECTS"
msgstr "SHM - _POSIX_SHARED_MEMORY_OBJECTS - _SC_SHARED_MEMORY_OBJECTS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:399
#, no-wrap
msgid ""
"I<mmap>()\n"
"I<munmap>()\n"
"I<shm_open>()\n"
"I<shm_unlink>()\n"
msgstr ""
"I<mmap>()\n"
"I<munmap>()\n"
"I<shm_open>()\n"
"I<shm_unlink>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:401
#, no-wrap
msgid "--- - _POSIX_SHELL - _SC_SHELL"
msgstr "--- - _POSIX_SHELL - _SC_SHELL"

#. type: Plain text
#: man-pages/man7/posixoptions.7:406
msgid ""
"If this option is in effect (as it always is under POSIX.1-2001), the "
"function I<system>()  is present."
msgstr ""
"Если доступно это свойство (всегда в POSIX.1-2001), то в системе доступна "
"функция I<system>()."

#. type: SS
#: man-pages/man7/posixoptions.7:406
#, no-wrap
msgid "SPN - _POSIX_SPAWN - _SC_SPAWN"
msgstr "SPN - _POSIX_SPAWN - _SC_SPAWN"

#. type: Plain text
#: man-pages/man7/posixoptions.7:411
msgid ""
"This option describes support for process creation in a context where it is "
"difficult or impossible to use I<fork>(), for example, because no MMU is "
"present."
msgstr ""
"Данное свойство выделяет процесс создания поддержки в связи с тем, что "
"трудно или невозможно использовать I<fork>(), например, из-за отсутствия MMU."

#. type: Plain text
#: man-pages/man7/posixoptions.7:417
msgid ""
"If B<_POSIX_SPAWN> is in effect, then the include file I<E<lt>spawn.hE<gt>> "
"and the following functions are present:"
msgstr ""
"Если задействовано свойство B<_POSIX_SPAWN>, то доступен заголовочный файл "
"I<E<lt>spawn.hE<gt>>  и следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:437
#, no-wrap
msgid ""
"I<posix_spawn>()\n"
"I<posix_spawn_file_actions_addclose>()\n"
"I<posix_spawn_file_actions_adddup2>()\n"
"I<posix_spawn_file_actions_addopen>()\n"
"I<posix_spawn_file_actions_destroy>()\n"
"I<posix_spawn_file_actions_init>()\n"
"I<posix_spawnattr_destroy>()\n"
"I<posix_spawnattr_getsigdefault>()\n"
"I<posix_spawnattr_getflags>()\n"
"I<posix_spawnattr_getpgroup>()\n"
"I<posix_spawnattr_getsigmask>()\n"
"I<posix_spawnattr_init>()\n"
"I<posix_spawnattr_setsigdefault>()\n"
"I<posix_spawnattr_setflags>()\n"
"I<posix_spawnattr_setpgroup>()\n"
"I<posix_spawnattr_setsigmask>()\n"
"I<posix_spawnp>()\n"
msgstr ""
"I<posix_spawn>()\n"
"I<posix_spawn_file_actions_addclose>()\n"
"I<posix_spawn_file_actions_adddup2>()\n"
"I<posix_spawn_file_actions_addopen>()\n"
"I<posix_spawn_file_actions_destroy>()\n"
"I<posix_spawn_file_actions_init>()\n"
"I<posix_spawnattr_destroy>()\n"
"I<posix_spawnattr_getsigdefault>()\n"
"I<posix_spawnattr_getflags>()\n"
"I<posix_spawnattr_getpgroup>()\n"
"I<posix_spawnattr_getsigmask>()\n"
"I<posix_spawnattr_init>()\n"
"I<posix_spawnattr_setsigdefault>()\n"
"I<posix_spawnattr_setflags>()\n"
"I<posix_spawnattr_setpgroup>()\n"
"I<posix_spawnattr_setsigmask>()\n"
"I<posix_spawnp>()\n"

#. type: Plain text
#: man-pages/man7/posixoptions.7:444
msgid ""
"If also B<_POSIX_PRIORITY_SCHEDULING> is in effect, then the following "
"functions are present:"
msgstr ""
"Если также доступно свойство B<_POSIX_PRIORITY_SCHEDULING>, то доступны "
"следующие функции:"

#. type: SS
#: man-pages/man7/posixoptions.7:453
#, no-wrap
msgid "SPI - _POSIX_SPIN_LOCKS - _SC_SPIN_LOCKS"
msgstr "SPI - _POSIX_SPIN_LOCKS - _SC_SPIN_LOCKS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:468
#, no-wrap
msgid ""
"I<pthread_spin_destroy>()\n"
"I<pthread_spin_init>()\n"
"I<pthread_spin_lock>()\n"
"I<pthread_spin_trylock>()\n"
"I<pthread_spin_unlock>()\n"
msgstr ""
"I<pthread_spin_destroy>()\n"
"I<pthread_spin_init>()\n"
"I<pthread_spin_lock>()\n"
"I<pthread_spin_trylock>()\n"
"I<pthread_spin_unlock>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:470
#, no-wrap
msgid "SS - _POSIX_SPORADIC_SERVER - _SC_SPORADIC_SERVER"
msgstr "SS - _POSIX_SPORADIC_SERVER - _SC_SPORADIC_SERVER"

#. type: Plain text
#: man-pages/man7/posixoptions.7:478
msgid ""
"The scheduling policy B<SCHED_SPORADIC> is supported.  This option implies "
"the B<_POSIX_PRIORITY_SCHEDULING> option.  The following functions are "
"affected:"
msgstr ""
"Поддерживается алгоритм планирования B<SCHED_SPORADIC>. Это свойство "
"подразумевает свойство B<_POSIX_PRIORITY_SCHEDULING>. Влияет на следующие "
"функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:483
#, no-wrap
msgid ""
"I<sched_setparam>()\n"
"I<sched_setscheduler>()\n"
msgstr ""
"I<sched_setparam>()\n"
"I<sched_setscheduler>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:485
#, no-wrap
msgid "SIO - _POSIX_SYNCHRONIZED_IO - _SC_SYNCHRONIZED_IO"
msgstr "SIO - _POSIX_SYNCHRONIZED_IO - _SC_SYNCHRONIZED_IO"

#. type: Plain text
#: man-pages/man7/posixoptions.7:487 man-pages/man7/posixoptions.7:498
#: man-pages/man7/posixoptions.7:509 man-pages/man7/posixoptions.7:536
#: man-pages/man7/posixoptions.7:545 man-pages/man7/posixoptions.7:576
#: man-pages/man7/posixoptions.7:591
msgid "The following functions are affected:"
msgstr "Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:494
#, no-wrap
msgid ""
"I<open>()\n"
"I<msync>()\n"
"I<fsync>()\n"
"I<fdatasync>()\n"
msgstr ""
"I<open>()\n"
"I<msync>()\n"
"I<fsync>()\n"
"I<fdatasync>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:496
#, no-wrap
msgid "TSA - _POSIX_THREAD_ATTR_STACKADDR - _SC_THREAD_ATTR_STACKADDR"
msgstr "TSA - _POSIX_THREAD_ATTR_STACKADDR - _SC_THREAD_ATTR_STACKADDR"

#. type: Plain text
#: man-pages/man7/posixoptions.7:505
#, no-wrap
msgid ""
"I<pthread_attr_getstack>()\n"
"I<pthread_attr_getstackaddr>()\n"
"I<pthread_attr_setstack>()\n"
"I<pthread_attr_setstackaddr>()\n"
msgstr ""
"I<pthread_attr_getstack>()\n"
"I<pthread_attr_getstackaddr>()\n"
"I<pthread_attr_setstack>()\n"
"I<pthread_attr_setstackaddr>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:507
#, no-wrap
msgid "TSS - _POSIX_THREAD_ATTR_STACKSIZE - _SC_THREAD_ATTR_STACKSIZE"
msgstr "TSS - _POSIX_THREAD_ATTR_STACKSIZE - _SC_THREAD_ATTR_STACKSIZE"

#. type: Plain text
#: man-pages/man7/posixoptions.7:516
#, no-wrap
msgid ""
"I<pthread_attr_getstack>()\n"
"I<pthread_attr_getstacksize>()\n"
"I<pthread_attr_setstack>()\n"
"I<pthread_attr_setstacksize>()\n"
msgstr ""
"I<pthread_attr_getstack>()\n"
"I<pthread_attr_getstacksize>()\n"
"I<pthread_attr_setstack>()\n"
"I<pthread_attr_setstacksize>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:518
#, no-wrap
msgid "TCT - _POSIX_THREAD_CPUTIME - _SC_THREAD_CPUTIME"
msgstr "TCT - _POSIX_THREAD_CPUTIME - _SC_THREAD_CPUTIME"

#. type: Plain text
#: man-pages/man7/posixoptions.7:524
msgid ""
"The clockID CLOCK_THREAD_CPUTIME_ID is supported.  This option implies the "
"B<_POSIX_TIMERS> option.  The following functions are affected:"
msgstr ""
"Поддерживается идентификатор часов CLOCK_THREAD_CPUTIME_ID. Это свойство "
"подразумевает свойство B<_POSIX_TIMERS>. Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:532
#, no-wrap
msgid ""
"I<pthread_getcpuclockid>()\n"
"I<clock_getres>()\n"
"I<clock_gettime>()\n"
"I<clock_settime>()\n"
"I<timer_create>()\n"
msgstr ""
"I<pthread_getcpuclockid>()\n"
"I<clock_getres>()\n"
"I<clock_gettime>()\n"
"I<clock_settime>()\n"
"I<timer_create>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:534
#, no-wrap
msgid "TPI - _POSIX_THREAD_PRIO_INHERIT - _SC_THREAD_PRIO_INHERIT"
msgstr "TPI - _POSIX_THREAD_PRIO_INHERIT - _SC_THREAD_PRIO_INHERIT"

#. type: Plain text
#: man-pages/man7/posixoptions.7:541
#, no-wrap
msgid ""
"I<pthread_mutexattr_getprotocol>()\n"
"I<pthread_mutexattr_setprotocol>()\n"
msgstr ""
"I<pthread_mutexattr_getprotocol>()\n"
"I<pthread_mutexattr_setprotocol>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:543
#, no-wrap
msgid "TPP - _POSIX_THREAD_PRIO_PROTECT - _SC_THREAD_PRIO_PROTECT"
msgstr "TPP - _POSIX_THREAD_PRIO_PROTECT - _SC_THREAD_PRIO_PROTECT"

#. type: Plain text
#: man-pages/man7/posixoptions.7:554
#, no-wrap
msgid ""
"I<pthread_mutex_getprioceiling>()\n"
"I<pthread_mutex_setprioceiling>()\n"
"I<pthread_mutexattr_getprioceiling>()\n"
"I<pthread_mutexattr_getprotocol>()\n"
"I<pthread_mutexattr_setprioceiling>()\n"
"I<pthread_mutexattr_setprotocol>()\n"
msgstr ""
"I<pthread_mutex_getprioceiling>()\n"
"I<pthread_mutex_setprioceiling>()\n"
"I<pthread_mutexattr_getprioceiling>()\n"
"I<pthread_mutexattr_getprotocol>()\n"
"I<pthread_mutexattr_setprioceiling>()\n"
"I<pthread_mutexattr_setprotocol>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:556
#, no-wrap
msgid "TPS - _POSIX_THREAD_PRIORITY_SCHEDULING - _SC_THREAD_PRIORITY_SCHEDULING"
msgstr "TPS - _POSIX_THREAD_PRIORITY_SCHEDULING - _SC_THREAD_PRIORITY_SCHEDULING"

#. type: Plain text
#: man-pages/man7/posixoptions.7:560
msgid ""
"If this option is in effect, the different threads inside a process can run "
"with different priorities and/or different schedulers.  The following "
"functions are affected:"
msgstr ""
"Если доступно это свойство, то нити в процессе можно выполнять с разными "
"приоритетами или планировщиками. Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:572
#, no-wrap
msgid ""
"I<pthread_attr_getinheritsched>()\n"
"I<pthread_attr_getschedpolicy>()\n"
"I<pthread_attr_getscope>()\n"
"I<pthread_attr_setinheritsched>()\n"
"I<pthread_attr_setschedpolicy>()\n"
"I<pthread_attr_setscope>()\n"
"I<pthread_getschedparam>()\n"
"I<pthread_setschedparam>()\n"
"I<pthread_setschedprio>()\n"
msgstr ""
"I<pthread_attr_getinheritsched>()\n"
"I<pthread_attr_getschedpolicy>()\n"
"I<pthread_attr_getscope>()\n"
"I<pthread_attr_setinheritsched>()\n"
"I<pthread_attr_setschedpolicy>()\n"
"I<pthread_attr_setscope>()\n"
"I<pthread_getschedparam>()\n"
"I<pthread_setschedparam>()\n"
"I<pthread_setschedprio>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:574
#, no-wrap
msgid "TSH - _POSIX_THREAD_PROCESS_SHARED - _SC_THREAD_PROCESS_SHARED"
msgstr "TSH - _POSIX_THREAD_PROCESS_SHARED - _SC_THREAD_PROCESS_SHARED"

#. type: Plain text
#: man-pages/man7/posixoptions.7:587
#, no-wrap
msgid ""
"I<pthread_barrierattr_getpshared>()\n"
"I<pthread_barrierattr_setpshared>()\n"
"I<pthread_condattr_getpshared>()\n"
"I<pthread_condattr_setpshared>()\n"
"I<pthread_mutexattr_getpshared>()\n"
"I<pthread_mutexattr_setpshared>()\n"
"I<pthread_rwlockattr_getpshared>()\n"
"I<pthread_rwlockattr_setpshared>()\n"
msgstr ""
"I<pthread_barrierattr_getpshared>()\n"
"I<pthread_barrierattr_setpshared>()\n"
"I<pthread_condattr_getpshared>()\n"
"I<pthread_condattr_setpshared>()\n"
"I<pthread_mutexattr_getpshared>()\n"
"I<pthread_mutexattr_setpshared>()\n"
"I<pthread_rwlockattr_getpshared>()\n"
"I<pthread_rwlockattr_setpshared>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:589
#, no-wrap
msgid "TSF - _POSIX_THREAD_SAFE_FUNCTIONS - _SC_THREAD_SAFE_FUNCTIONS"
msgstr "TSF - _POSIX_THREAD_SAFE_FUNCTIONS - _SC_THREAD_SAFE_FUNCTIONS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:613
#, no-wrap
msgid ""
"I<readdir_r>()\n"
"I<getgrgid_r>()\n"
"I<getgrnam_r>()\n"
"I<getpwnam_r>()\n"
"I<getpwuid_r>()\n"
"I<flockfile>()\n"
"I<ftrylockfile>()\n"
"I<funlockfile>()\n"
"I<getc_unlocked>()\n"
"I<getchar_unlocked>()\n"
"I<putc_unlocked>()\n"
"I<putchar_unlocked>()\n"
"I<rand_r>()\n"
"I<strerror_r>()\n"
"I<strtok_r>()\n"
"I<asctime_r>()\n"
"I<ctime_r>()\n"
"I<gmtime_r>()\n"
"I<localtime_r>()\n"
msgstr ""
"I<readdir_r>()\n"
"I<getgrgid_r>()\n"
"I<getgrnam_r>()\n"
"I<getpwnam_r>()\n"
"I<getpwuid_r>()\n"
"I<flockfile>()\n"
"I<ftrylockfile>()\n"
"I<funlockfile>()\n"
"I<getc_unlocked>()\n"
"I<getchar_unlocked>()\n"
"I<putc_unlocked>()\n"
"I<putchar_unlocked>()\n"
"I<rand_r>()\n"
"I<strerror_r>()\n"
"I<strtok_r>()\n"
"I<asctime_r>()\n"
"I<ctime_r>()\n"
"I<gmtime_r>()\n"
"I<localtime_r>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:615
#, no-wrap
msgid "TSP - _POSIX_THREAD_SPORADIC_SERVER - _SC_THREAD_SPORADIC_SERVER"
msgstr "TSP - _POSIX_THREAD_SPORADIC_SERVER - _SC_THREAD_SPORADIC_SERVER"

#. type: Plain text
#: man-pages/man7/posixoptions.7:620
msgid ""
"This option implies the B<_POSIX_THREAD_PRIORITY_SCHEDULING> option.  The "
"following functions are affected:"
msgstr ""
"Это свойство подразумевает свойство B<_POSIX_THREAD_PRIORITY_SCHEDULING>. "
"Влияет на следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:626
#, no-wrap
msgid ""
"I<sched_getparam>()\n"
"I<sched_setparam>()\n"
"I<sched_setscheduler>()\n"
msgstr ""
"I<sched_getparam>()\n"
"I<sched_setparam>()\n"
"I<sched_setscheduler>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:628
#, no-wrap
msgid "THR - _POSIX_THREADS - _SC_THREADS"
msgstr "THR - _POSIX_THREADS - _SC_THREADS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:631
msgid ""
"Basic support for POSIX threads is available.  The following functions are "
"present:"
msgstr "Доступна начальная поддержка нитей POSIX. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:682
#, no-wrap
msgid ""
"I<pthread_atfork>()\n"
"I<pthread_attr_destroy>()\n"
"I<pthread_attr_getdetachstate>()\n"
"I<pthread_attr_getschedparam>()\n"
"I<pthread_attr_init>()\n"
"I<pthread_attr_setdetachstate>()\n"
"I<pthread_attr_setschedparam>()\n"
"I<pthread_cancel>()\n"
"I<pthread_cleanup_push>()\n"
"I<pthread_cleanup_pop>()\n"
"I<pthread_cond_broadcast>()\n"
"I<pthread_cond_destroy>()\n"
"I<pthread_cond_init>()\n"
"I<pthread_cond_signal>()\n"
"I<pthread_cond_timedwait>()\n"
"I<pthread_cond_wait>()\n"
"I<pthread_condattr_destroy>()\n"
"I<pthread_condattr_init>()\n"
"I<pthread_create>()\n"
"I<pthread_detach>()\n"
"I<pthread_equal>()\n"
"I<pthread_exit>()\n"
"I<pthread_getspecific>()\n"
"I<pthread_join>()\n"
"I<pthread_key_create>()\n"
"I<pthread_key_delete>()\n"
"I<pthread_mutex_destroy>()\n"
"I<pthread_mutex_init>()\n"
"I<pthread_mutex_lock>()\n"
"I<pthread_mutex_trylock>()\n"
"I<pthread_mutex_unlock>()\n"
"I<pthread_mutexattr_destroy>()\n"
"I<pthread_mutexattr_init>()\n"
"I<pthread_once>()\n"
"I<pthread_rwlock_destroy>()\n"
"I<pthread_rwlock_init>()\n"
"I<pthread_rwlock_rdlock>()\n"
"I<pthread_rwlock_tryrdlock>()\n"
"I<pthread_rwlock_trywrlock>()\n"
"I<pthread_rwlock_unlock>()\n"
"I<pthread_rwlock_wrlock>()\n"
"I<pthread_rwlockattr_destroy>()\n"
"I<pthread_rwlockattr_init>()\n"
"I<pthread_self>()\n"
"I<pthread_setcancelstate>()\n"
"I<pthread_setcanceltype>()\n"
"I<pthread_setspecific>()\n"
"I<pthread_testcancel>()\n"
msgstr ""
"I<pthread_atfork>()\n"
"I<pthread_attr_destroy>()\n"
"I<pthread_attr_getdetachstate>()\n"
"I<pthread_attr_getschedparam>()\n"
"I<pthread_attr_init>()\n"
"I<pthread_attr_setdetachstate>()\n"
"I<pthread_attr_setschedparam>()\n"
"I<pthread_cancel>()\n"
"I<pthread_cleanup_push>()\n"
"I<pthread_cleanup_pop>()\n"
"I<pthread_cond_broadcast>()\n"
"I<pthread_cond_destroy>()\n"
"I<pthread_cond_init>()\n"
"I<pthread_cond_signal>()\n"
"I<pthread_cond_timedwait>()\n"
"I<pthread_cond_wait>()\n"
"I<pthread_condattr_destroy>()\n"
"I<pthread_condattr_init>()\n"
"I<pthread_create>()\n"
"I<pthread_detach>()\n"
"I<pthread_equal>()\n"
"I<pthread_exit>()\n"
"I<pthread_getspecific>()\n"
"I<pthread_join>()\n"
"I<pthread_key_create>()\n"
"I<pthread_key_delete>()\n"
"I<pthread_mutex_destroy>()\n"
"I<pthread_mutex_init>()\n"
"I<pthread_mutex_lock>()\n"
"I<pthread_mutex_trylock>()\n"
"I<pthread_mutex_unlock>()\n"
"I<pthread_mutexattr_destroy>()\n"
"I<pthread_mutexattr_init>()\n"
"I<pthread_once>()\n"
"I<pthread_rwlock_destroy>()\n"
"I<pthread_rwlock_init>()\n"
"I<pthread_rwlock_rdlock>()\n"
"I<pthread_rwlock_tryrdlock>()\n"
"I<pthread_rwlock_trywrlock>()\n"
"I<pthread_rwlock_unlock>()\n"
"I<pthread_rwlock_wrlock>()\n"
"I<pthread_rwlockattr_destroy>()\n"
"I<pthread_rwlockattr_init>()\n"
"I<pthread_self>()\n"
"I<pthread_setcancelstate>()\n"
"I<pthread_setcanceltype>()\n"
"I<pthread_setspecific>()\n"
"I<pthread_testcancel>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:684
#, no-wrap
msgid "TMO - _POSIX_TIMEOUTS - _SC_TIMEOUTS"
msgstr "TMO - _POSIX_TIMEOUTS - _SC_TIMEOUTS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:696
#, no-wrap
msgid ""
"I<mq_timedreceive>()\n"
"I<mq_timedsend>()\n"
"I<pthread_mutex_timedlock>()\n"
"I<pthread_rwlock_timedrdlock>()\n"
"I<pthread_rwlock_timedwrlock>()\n"
"I<sem_timedwait>()\n"
"I<posix_trace_timedgetnext_event>()\n"
msgstr ""
"I<mq_timedreceive>()\n"
"I<mq_timedsend>()\n"
"I<pthread_mutex_timedlock>()\n"
"I<pthread_rwlock_timedrdlock>()\n"
"I<pthread_rwlock_timedwrlock>()\n"
"I<sem_timedwait>()\n"
"I<posix_trace_timedgetnext_event>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:698
#, no-wrap
msgid "TMR - _POSIX_TIMERS - _SC_TIMERS"
msgstr "TMR - _POSIX_TIMERS - _SC_TIMERS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:712
#, no-wrap
msgid ""
"I<clock_getres>()\n"
"I<clock_gettime>()\n"
"I<clock_settime>()\n"
"I<nanosleep>()\n"
"I<timer_create>()\n"
"I<timer_delete>()\n"
"I<timer_gettime>()\n"
"I<timer_getoverrun>()\n"
"I<timer_settime>()\n"
msgstr ""
"I<clock_getres>()\n"
"I<clock_gettime>()\n"
"I<clock_settime>()\n"
"I<nanosleep>()\n"
"I<timer_create>()\n"
"I<timer_delete>()\n"
"I<timer_gettime>()\n"
"I<timer_getoverrun>()\n"
"I<timer_settime>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:714
#, no-wrap
msgid "TRC - _POSIX_TRACE - _SC_TRACE"
msgstr "TRC - _POSIX_TRACE - _SC_TRACE"

#. type: Plain text
#: man-pages/man7/posixoptions.7:717
msgid "POSIX tracing is available.  The following functions are present:"
msgstr "Доступна поддержка трассировки POSIX. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:751
#, no-wrap
msgid ""
"I<posix_trace_attr_destroy>()\n"
"I<posix_trace_attr_getclockres>()\n"
"I<posix_trace_attr_getcreatetime>()\n"
"I<posix_trace_attr_getgenversion>()\n"
"I<posix_trace_attr_getmaxdatasize>()\n"
"I<posix_trace_attr_getmaxsystemeventsize>()\n"
"I<posix_trace_attr_getmaxusereventsize>()\n"
"I<posix_trace_attr_getname>()\n"
"I<posix_trace_attr_getstreamfullpolicy>()\n"
"I<posix_trace_attr_getstreamsize>()\n"
"I<posix_trace_attr_init>()\n"
"I<posix_trace_attr_setmaxdatasize>()\n"
"I<posix_trace_attr_setname>()\n"
"I<posix_trace_attr_setstreamsize>()\n"
"I<posix_trace_attr_setstreamfullpolicy>()\n"
"I<posix_trace_clear>()\n"
"I<posix_trace_create>()\n"
"I<posix_trace_event>()\n"
"I<posix_trace_eventid_equal>()\n"
"I<posix_trace_eventid_get_name>()\n"
"I<posix_trace_eventid_open>()\n"
"I<posix_trace_eventtypelist_getnext_id>()\n"
"I<posix_trace_eventtypelist_rewind>()\n"
"I<posix_trace_flush>()\n"
"I<posix_trace_get_attr>()\n"
"I<posix_trace_get_status>()\n"
"I<posix_trace_getnext_event>()\n"
"I<posix_trace_shutdown>()\n"
"I<posix_trace_start>()\n"
"I<posix_trace_stop>()\n"
"I<posix_trace_trygetnext_event>()\n"
msgstr ""
"I<posix_trace_attr_destroy>()\n"
"I<posix_trace_attr_getclockres>()\n"
"I<posix_trace_attr_getcreatetime>()\n"
"I<posix_trace_attr_getgenversion>()\n"
"I<posix_trace_attr_getmaxdatasize>()\n"
"I<posix_trace_attr_getmaxsystemeventsize>()\n"
"I<posix_trace_attr_getmaxusereventsize>()\n"
"I<posix_trace_attr_getname>()\n"
"I<posix_trace_attr_getstreamfullpolicy>()\n"
"I<posix_trace_attr_getstreamsize>()\n"
"I<posix_trace_attr_init>()\n"
"I<posix_trace_attr_setmaxdatasize>()\n"
"I<posix_trace_attr_setname>()\n"
"I<posix_trace_attr_setstreamsize>()\n"
"I<posix_trace_attr_setstreamfullpolicy>()\n"
"I<posix_trace_clear>()\n"
"I<posix_trace_create>()\n"
"I<posix_trace_event>()\n"
"I<posix_trace_eventid_equal>()\n"
"I<posix_trace_eventid_get_name>()\n"
"I<posix_trace_eventid_open>()\n"
"I<posix_trace_eventtypelist_getnext_id>()\n"
"I<posix_trace_eventtypelist_rewind>()\n"
"I<posix_trace_flush>()\n"
"I<posix_trace_get_attr>()\n"
"I<posix_trace_get_status>()\n"
"I<posix_trace_getnext_event>()\n"
"I<posix_trace_shutdown>()\n"
"I<posix_trace_start>()\n"
"I<posix_trace_stop>()\n"
"I<posix_trace_trygetnext_event>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:753
#, no-wrap
msgid "TEF - _POSIX_TRACE_EVENT_FILTER - _SC_TRACE_EVENT_FILTER"
msgstr "TEF - _POSIX_TRACE_EVENT_FILTER - _SC_TRACE_EVENT_FILTER"

#. type: Plain text
#: man-pages/man7/posixoptions.7:758 man-pages/man7/posixoptions.7:789
msgid ""
"This option implies the B<_POSIX_TRACE> option.  The following functions are "
"present:"
msgstr ""
"Это свойство подразумевает свойство B<_POSIX_TRACE>. Доступны следующие "
"функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:769
#, no-wrap
msgid ""
"I<posix_trace_eventset_add>()\n"
"I<posix_trace_eventset_del>()\n"
"I<posix_trace_eventset_empty>()\n"
"I<posix_trace_eventset_fill>()\n"
"I<posix_trace_eventset_ismember>()\n"
"I<posix_trace_get_filter>()\n"
"I<posix_trace_set_filter>()\n"
"I<posix_trace_trid_eventid_open>()\n"
msgstr ""
"I<posix_trace_eventset_add>()\n"
"I<posix_trace_eventset_del>()\n"
"I<posix_trace_eventset_empty>()\n"
"I<posix_trace_eventset_fill>()\n"
"I<posix_trace_eventset_ismember>()\n"
"I<posix_trace_get_filter>()\n"
"I<posix_trace_set_filter>()\n"
"I<posix_trace_trid_eventid_open>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:771
#, no-wrap
msgid "TRI - _POSIX_TRACE_INHERIT - _SC_TRACE_INHERIT"
msgstr "TRI - _POSIX_TRACE_INHERIT - _SC_TRACE_INHERIT"

#. type: Plain text
#: man-pages/man7/posixoptions.7:777
msgid ""
"Tracing children of the traced process is supported.  This option implies "
"the B<_POSIX_TRACE> option.  The following functions are present:"
msgstr ""
"Поддерживается трассировка потомков трассируемого процесса. Это свойство "
"подразумевает свойство B<_POSIX_TRACE>. Доступны следующие функции:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:782
#, no-wrap
msgid ""
"I<posix_trace_attr_getinherited>()\n"
"I<posix_trace_attr_setinherited>()\n"
msgstr ""
"I<posix_trace_attr_getinherited>()\n"
"I<posix_trace_attr_setinherited>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:784
#, no-wrap
msgid "TRL - _POSIX_TRACE_LOG - _SC_TRACE_LOG"
msgstr "TRL - _POSIX_TRACE_LOG - _SC_TRACE_LOG"

#. type: Plain text
#: man-pages/man7/posixoptions.7:800
#, no-wrap
msgid ""
"I<posix_trace_attr_getlogfullpolicy>()\n"
"I<posix_trace_attr_getlogsize>()\n"
"I<posix_trace_attr_setlogfullpolicy>()\n"
"I<posix_trace_attr_setlogsize>()\n"
"I<posix_trace_close>()\n"
"I<posix_trace_create_withlog>()\n"
"I<posix_trace_open>()\n"
"I<posix_trace_rewind>()\n"
msgstr ""
"I<posix_trace_attr_getlogfullpolicy>()\n"
"I<posix_trace_attr_getlogsize>()\n"
"I<posix_trace_attr_setlogfullpolicy>()\n"
"I<posix_trace_attr_setlogsize>()\n"
"I<posix_trace_close>()\n"
"I<posix_trace_create_withlog>()\n"
"I<posix_trace_open>()\n"
"I<posix_trace_rewind>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:802
#, no-wrap
msgid "TYM - _POSIX_TYPED_MEMORY_OBJECTS - _SC_TYPED_MEMORY_OBJECT"
msgstr "TYM - _POSIX_TYPED_MEMORY_OBJECTS - _SC_TYPED_MEMORY_OBJECT"

#. type: Plain text
#: man-pages/man7/posixoptions.7:810
#, no-wrap
msgid ""
"I<posix_mem_offset>()\n"
"I<posix_typed_mem_get_info>()\n"
"I<posix_typed_mem_open>()\n"
msgstr ""
"I<posix_mem_offset>()\n"
"I<posix_typed_mem_get_info>()\n"
"I<posix_typed_mem_open>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:812
#, no-wrap
msgid "--- - _POSIX_VDISABLE"
msgstr "--- - _POSIX_VDISABLE"

#. type: Plain text
#: man-pages/man7/posixoptions.7:816
msgid ""
"Always present (probably 0).  Value to set a changeable special control "
"character to indicate that it is disabled."
msgstr ""
"Имеется всегда (вероятное значение — 0). Присвоение значения специального "
"управляющего символа означает выключение."

#. type: SH
#: man-pages/man7/posixoptions.7:816
#, no-wrap
msgid "X/OPEN SYSTEM INTERFACE EXTENSIONS"
msgstr "РАСШИРЕНИЯ X/OPEN SYSTEM INTERFACE"

#. type: SS
#: man-pages/man7/posixoptions.7:817
#, no-wrap
msgid "XSI - _XOPEN_CRYPT - _SC_XOPEN_CRYPT"
msgstr "XSI - _XOPEN_CRYPT - _SC_XOPEN_CRYPT"

#. type: Plain text
#: man-pages/man7/posixoptions.7:825
#, no-wrap
msgid ""
"I<crypt>()\n"
"I<encrypt>()\n"
"I<setkey>()\n"
msgstr ""
"I<crypt>()\n"
"I<encrypt>()\n"
"I<setkey>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:826
#, no-wrap
msgid "XSI - _XOPEN_REALTIME - _SC_XOPEN_REALTIME"
msgstr "XSI - _XOPEN_REALTIME - _SC_XOPEN_REALTIME"

#. type: Plain text
#: man-pages/man7/posixoptions.7:828 man-pages/man7/posixoptions.7:991
msgid "This option implies the following options:"
msgstr "Это свойство подразумевает следующие свойства:"

#. type: TP
#: man-pages/man7/posixoptions.7:830
#, no-wrap
msgid "B<_POSIX_ASYNCHRONOUS_IO>==B<200112L>"
msgstr "B<_POSIX_ASYNCHRONOUS_IO>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:832 man-pages/man7/posixoptions.7:993
#, no-wrap
msgid "B<_POSIX_FSYNC>"
msgstr "B<_POSIX_FSYNC>"

#. type: TP
#: man-pages/man7/posixoptions.7:834 man-pages/man7/posixoptions.7:995
#, no-wrap
msgid "B<_POSIX_MAPPED_FILES>"
msgstr "B<_POSIX_MAPPED_FILES>"

#. type: TP
#: man-pages/man7/posixoptions.7:836
#, no-wrap
msgid "B<_POSIX_MEMLOCK>==B<200112L>"
msgstr "B<_POSIX_MEMLOCK>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:838
#, no-wrap
msgid "B<_POSIX_MEMLOCK_RANGE>==B<200112L>"
msgstr "B<_POSIX_MEMLOCK_RANGE>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:840 man-pages/man7/posixoptions.7:997
#, no-wrap
msgid "B<_POSIX_MEMORY_PROTECTION>"
msgstr "B<_POSIX_MEMORY_PROTECTION>"

#. type: TP
#: man-pages/man7/posixoptions.7:842
#, no-wrap
msgid "B<_POSIX_MESSAGE_PASSING>==B<200112L>"
msgstr "B<_POSIX_MESSAGE_PASSING>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:844
#, no-wrap
msgid "B<_POSIX_PRIORITIZED_IO>"
msgstr "B<_POSIX_PRIORITIZED_IO>"

#. type: TP
#: man-pages/man7/posixoptions.7:846
#, no-wrap
msgid "B<_POSIX_PRIORITY_SCHEDULING>==B<200112L>"
msgstr "B<_POSIX_PRIORITY_SCHEDULING>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:848
#, no-wrap
msgid "B<_POSIX_REALTIME_SIGNALS>==B<200112L>"
msgstr "B<_POSIX_REALTIME_SIGNALS>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:850
#, no-wrap
msgid "B<_POSIX_SEMAPHORES>==B<200112L>"
msgstr "B<_POSIX_SEMAPHORES>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:852
#, no-wrap
msgid "B<_POSIX_SHARED_MEMORY_OBJECTS>==B<200112L>"
msgstr "B<_POSIX_SHARED_MEMORY_OBJECTS>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:854
#, no-wrap
msgid "B<_POSIX_SYNCHRONIZED_IO>==B<200112L>"
msgstr "B<_POSIX_SYNCHRONIZED_IO>==B<200112L>"

#. type: TP
#: man-pages/man7/posixoptions.7:856
#, no-wrap
msgid "B<_POSIX_TIMERS>==B<200112L>"
msgstr "B<_POSIX_TIMERS>==B<200112L>"

#. type: SS
#: man-pages/man7/posixoptions.7:860
#, no-wrap
msgid "ADV - --- - ---"
msgstr "ADV - --- - ---"

#. type: Plain text
#: man-pages/man7/posixoptions.7:863
msgid ""
"The Advanced Realtime option group implies that the following options are "
"all defined to 200112L:"
msgstr ""
"Группа свойств Advanced Realtime подразумевает, что все следующие свойства "
"определены до 200112L:"

#. type: TP
#: man-pages/man7/posixoptions.7:865
#, no-wrap
msgid "B<_POSIX_ADVISORY_INFO>"
msgstr "B<_POSIX_ADVISORY_INFO>"

#. type: TP
#: man-pages/man7/posixoptions.7:867
#, no-wrap
msgid "B<_POSIX_CLOCK_SELECTION>"
msgstr "B<_POSIX_CLOCK_SELECTION>"

#. type: Plain text
#: man-pages/man7/posixoptions.7:871 man-pages/man7/posixoptions.7:875
#: man-pages/man7/posixoptions.7:879 man-pages/man7/posixoptions.7:922
msgid "(implies B<_POSIX_TIMERS>)"
msgstr "(подразумевает B<_POSIX_TIMERS>)"

#. type: TP
#: man-pages/man7/posixoptions.7:871
#, no-wrap
msgid "B<_POSIX_CPUTIME>"
msgstr "B<_POSIX_CPUTIME>"

#. type: TP
#: man-pages/man7/posixoptions.7:875
#, no-wrap
msgid "B<_POSIX_MONOTONIC_CLOCK>"
msgstr "B<_POSIX_MONOTONIC_CLOCK>"

#. type: TP
#: man-pages/man7/posixoptions.7:879
#, no-wrap
msgid "B<_POSIX_SPAWN>"
msgstr "B<_POSIX_SPAWN>"

#. type: TP
#: man-pages/man7/posixoptions.7:881
#, no-wrap
msgid "B<_POSIX_SPORADIC_SERVER>"
msgstr "B<_POSIX_SPORADIC_SERVER>"

#. type: Plain text
#: man-pages/man7/posixoptions.7:885
msgid "(implies B<_POSIX_PRIORITY_SCHEDULING>)"
msgstr "(подразумевает B<_POSIX_PRIORITY_SCHEDULING>)"

#. type: TP
#: man-pages/man7/posixoptions.7:885
#, no-wrap
msgid "B<_POSIX_TIMEOUTS>"
msgstr "B<_POSIX_TIMEOUTS>"

#. type: TP
#: man-pages/man7/posixoptions.7:887
#, no-wrap
msgid "B<_POSIX_TYPED_MEMORY_OBJECTS>"
msgstr "B<_POSIX_TYPED_MEMORY_OBJECTS>"

#. type: SS
#: man-pages/man7/posixoptions.7:891
#, no-wrap
msgid "XSI - _XOPEN_REALTIME_THREADS - _SC_XOPEN_REALTIME_THREADS"
msgstr "XSI - _XOPEN_REALTIME_THREADS - _SC_XOPEN_REALTIME_THREADS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:894 man-pages/man7/posixoptions.7:906
#: man-pages/man7/posixoptions.7:931
msgid ""
"This option implies that the following options are all defined to 200112L:"
msgstr ""
"Это свойство подразумевает, что все следующие свойства определены до 200112L:"

#. type: TP
#: man-pages/man7/posixoptions.7:896
#, no-wrap
msgid "B<_POSIX_THREAD_PRIO_INHERIT>"
msgstr "B<_POSIX_THREAD_PRIO_INHERIT>"

#. type: TP
#: man-pages/man7/posixoptions.7:898
#, no-wrap
msgid "B<_POSIX_THREAD_PRIO_PROTECT>"
msgstr "B<_POSIX_THREAD_PRIO_PROTECT>"

#. type: TP
#: man-pages/man7/posixoptions.7:900
#, no-wrap
msgid "B<_POSIX_THREAD_PRIORITY_SCHEDULING>"
msgstr "B<_POSIX_THREAD_PRIORITY_SCHEDULING>"

#. type: SS
#: man-pages/man7/posixoptions.7:903
#, no-wrap
msgid "ADVANCED REALTIME THREADS - --- - ---"
msgstr "ADVANCED REALTIME THREADS - --- - ---"

#. type: TP
#: man-pages/man7/posixoptions.7:908
#, no-wrap
msgid "B<_POSIX_BARRIERS>"
msgstr "B<_POSIX_BARRIERS>"

#. type: Plain text
#: man-pages/man7/posixoptions.7:913 man-pages/man7/posixoptions.7:918
msgid "(implies B<_POSIX_THREADS>, B<_POSIX_THREAD_SAFE_FUNCTIONS>)"
msgstr "(подразумевает B<_POSIX_THREADS>, B<_POSIX_THREAD_SAFE_FUNCTIONS>)"

#. type: TP
#: man-pages/man7/posixoptions.7:913
#, no-wrap
msgid "B<_POSIX_SPIN_LOCKS>"
msgstr "B<_POSIX_SPIN_LOCKS>"

#. type: TP
#: man-pages/man7/posixoptions.7:918
#, no-wrap
msgid "B<_POSIX_THREAD_CPUTIME>"
msgstr "B<_POSIX_THREAD_CPUTIME>"

#. type: TP
#: man-pages/man7/posixoptions.7:922
#, no-wrap
msgid "B<_POSIX_THREAD_SPORADIC_SERVER>"
msgstr "B<_POSIX_THREAD_SPORADIC_SERVER>"

#. type: Plain text
#: man-pages/man7/posixoptions.7:926
msgid "(implies B<_POSIX_THREAD_PRIORITY_SCHEDULING>)"
msgstr "(подразумевает B<_POSIX_THREAD_PRIORITY_SCHEDULING>)"

#. type: SS
#: man-pages/man7/posixoptions.7:928
#, no-wrap
msgid "TRACING - --- - ---"
msgstr "TRACING - --- - ---"

#. type: TP
#: man-pages/man7/posixoptions.7:933
#, no-wrap
msgid "B<_POSIX_TRACE>"
msgstr "B<_POSIX_TRACE>"

#. type: TP
#: man-pages/man7/posixoptions.7:935
#, no-wrap
msgid "B<_POSIX_TRACE_EVENT_FILTER>"
msgstr "B<_POSIX_TRACE_EVENT_FILTER>"

#. type: TP
#: man-pages/man7/posixoptions.7:937
#, no-wrap
msgid "B<_POSIX_TRACE_LOG>"
msgstr "B<_POSIX_TRACE_LOG>"

#. type: TP
#: man-pages/man7/posixoptions.7:939
#, no-wrap
msgid "B<_POSIX_TRACE_INHERIT>"
msgstr "B<_POSIX_TRACE_INHERIT>"

#. type: SS
#: man-pages/man7/posixoptions.7:942
#, no-wrap
msgid "STREAMS - _XOPEN_STREAMS - _SC_XOPEN_STREAMS"
msgstr "STREAMS - _XOPEN_STREAMS - _SC_XOPEN_STREAMS"

#. type: Plain text
#: man-pages/man7/posixoptions.7:955
#, no-wrap
msgid ""
"I<fattach>()\n"
"I<fdetach>()\n"
"I<getmsg>()\n"
"I<getpmsg>()\n"
"I<ioctl>()\n"
"I<isastream>()\n"
"I<putmsg>()\n"
"I<putpmsg>()\n"
msgstr ""
"I<fattach>()\n"
"I<fdetach>()\n"
"I<getmsg>()\n"
"I<getpmsg>()\n"
"I<ioctl>()\n"
"I<isastream>()\n"
"I<putmsg>()\n"
"I<putpmsg>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:957
#, no-wrap
msgid "XSI - _XOPEN_LEGACY - _SC_XOPEN_LEGACY"
msgstr "XSI - _XOPEN_LEGACY - _SC_XOPEN_LEGACY"

#. type: Plain text
#: man-pages/man7/posixoptions.7:961
msgid ""
"Functions included in the legacy option group were previously mandatory, but "
"are now optional in this version.  The following functions are present:"
msgstr ""
"Функции, включённые в группу устаревших свойств, которые были обязательны "
"ранее, но в этой версии стали необязательными. Это относится к следующим "
"функциям:"

#. type: Plain text
#: man-pages/man7/posixoptions.7:977
#, no-wrap
msgid ""
"I<bcmp>()\n"
"I<bcopy>()\n"
"I<bzero>()\n"
"I<ecvt>()\n"
"I<fcvt>()\n"
"I<ftime>()\n"
"I<gcvt>()\n"
"I<getcwd>()\n"
"I<index>()\n"
"I<mktemp>()\n"
"I<rindex>()\n"
"I<utimes>()\n"
"I<wcswcs>()\n"
msgstr ""
"I<bcmp>()\n"
"I<bcopy>()\n"
"I<bzero>()\n"
"I<ecvt>()\n"
"I<fcvt>()\n"
"I<ftime>()\n"
"I<gcvt>()\n"
"I<getcwd>()\n"
"I<index>()\n"
"I<mktemp>()\n"
"I<rindex>()\n"
"I<utimes>()\n"
"I<wcswcs>()\n"

#. type: SS
#: man-pages/man7/posixoptions.7:979
#, no-wrap
msgid "XSI - _XOPEN_UNIX - _SC_XOPEN_UNIX"
msgstr "XSI - _XOPEN_UNIX - _SC_XOPEN_UNIX"

#. type: Plain text
#: man-pages/man7/posixoptions.7:987
#, no-wrap
msgid ""
"I<mmap>()\n"
"I<munmap>()\n"
"I<msync>()\n"
msgstr ""
"I<mmap>()\n"
"I<munmap>()\n"
"I<msync>()\n"

#. type: TP
#: man-pages/man7/posixoptions.7:999
#, no-wrap
msgid "B<_POSIX_THREAD_ATTR_STACKADDR>"
msgstr "B<_POSIX_THREAD_ATTR_STACKADDR>"

#. type: TP
#: man-pages/man7/posixoptions.7:1001
#, no-wrap
msgid "B<_POSIX_THREAD_ATTR_STACKSIZE>"
msgstr "B<_POSIX_THREAD_ATTR_STACKSIZE>"

#. type: TP
#: man-pages/man7/posixoptions.7:1003
#, no-wrap
msgid "B<_POSIX_THREAD_PROCESS_SHARED>"
msgstr "B<_POSIX_THREAD_PROCESS_SHARED>"

#. type: TP
#: man-pages/man7/posixoptions.7:1005
#, no-wrap
msgid "B<_POSIX_THREAD_SAFE_FUNCTIONS>"
msgstr "B<_POSIX_THREAD_SAFE_FUNCTIONS>"

#. type: TP
#: man-pages/man7/posixoptions.7:1007
#, no-wrap
msgid "B<_POSIX_THREADS>"
msgstr "B<_POSIX_THREADS>"

#. type: Plain text
#: man-pages/man7/posixoptions.7:1012
msgid "This option may imply the following options from the XSI option groups:"
msgstr ""
"Это свойство может подразумевать следующие свойства из групп свойств XSI:"

#. type: TP
#: man-pages/man7/posixoptions.7:1014
#, no-wrap
msgid "Encryption (B<_XOPEN_CRYPT>)"
msgstr "Шифрование (B<_XOPEN_CRYPT>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1016
#, no-wrap
msgid "Realtime (B<_XOPEN_REALTIME>)"
msgstr "Realtime (B<_XOPEN_REALTIME>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1018
#, no-wrap
msgid "Advanced Realtime (B<ADB>)"
msgstr "Advanced Realtime (B<ADB>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1020
#, no-wrap
msgid "Realtime Threads (B<_XOPEN_REALTIME_THREADS>)"
msgstr "Realtime Threads (B<_XOPEN_REALTIME_THREADS>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1022
#, no-wrap
msgid "Advanced Realtime Threads (B<ADVANCED REALTIME THREADS>)"
msgstr "Advanced Realtime Threads (B<ADVANCED REALTIME THREADS>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1024
#, no-wrap
msgid "Tracing (B<TRACING>)"
msgstr "Tracing (B<TRACING>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1026
#, no-wrap
msgid "XSI Streams (B<STREAMS>)"
msgstr "XSI Streams (B<STREAMS>)"

#. type: TP
#: man-pages/man7/posixoptions.7:1028
#, no-wrap
msgid "Legacy (B<_XOPEN_LEGACY>)"
msgstr "Legacy (B<_XOPEN_LEGACY>)"

#. type: Plain text
#: man-pages/man7/posixoptions.7:1033
msgid "B<sysconf>(3), B<standards>(7)"
msgstr "B<sysconf>(3), B<standards>(7)"

#. type: TH
#: man-pages/man7/pipe.7:25
#, no-wrap
msgid "PIPE"
msgstr "PIPE"

#. type: Plain text
#: man-pages/man7/pipe.7:28
msgid "pipe - overview of pipes and FIFOs"
msgstr "pipe - обзор каналов и FIFO"

#. type: Plain text
#: man-pages/man7/pipe.7:37
msgid ""
"Pipes and FIFOs (also known as named pipes)  provide a unidirectional "
"interprocess communication channel.  A pipe has a I<read end> and a I<write "
"end>.  Data written to the write end of a pipe can be read from the read end "
"of the pipe."
msgstr ""
"Каналы и FIFO (также называемые именованными каналами) предоставляют "
"двунаправленный канал обмена между процессами. У канала имеется I<конец для "
"чтения> (read end) и I<конец для записи> (write end). Данные, записанные в "
"конец для записи, можно прочитать из конца для чтения."

#. type: Plain text
#: man-pages/man7/pipe.7:47
msgid ""
"A pipe is created using B<pipe>(2), which creates a new pipe and returns two "
"file descriptors, one referring to the read end of the pipe, the other "
"referring to the write end.  Pipes can be used to create a communication "
"channel between related processes; see B<pipe>(2)  for an example."
msgstr ""
"Канал создаётся с помощью вызова B<pipe>(2), который образует новый канал и "
"возвращает два файловых дескриптора, один указывает на конец для чтения, а "
"другой на конец для записи. Каналы можно использовать для создания канала "
"обмена между процессами; пример смотрите в B<pipe>(2)."

#. type: Plain text
#: man-pages/man7/pipe.7:66
msgid ""
"A FIFO (short for First In First Out) has a name within the filesystem "
"(created using B<mkfifo>(3)), and is opened using B<open>(2).  Any process "
"may open a FIFO, assuming the file permissions allow it.  The read end is "
"opened using the B<O_RDONLY> flag; the write end is opened using the "
"B<O_WRONLY> flag.  See B<fifo>(7)  for further details.  I<Note>: although "
"FIFOs have a pathname in the filesystem, I/O on FIFOs does not involve "
"operations on the underlying device (if there is one)."
msgstr ""
"У FIFO (сокращение от First In First Out, первым вошёл, первым вышел) "
"имеется имя в файловой системе (создаётся с помощью B<mkfifo>(3)), и такой "
"канал открывается с помощью B<open>(2). Любой процесс может открыть FIFO, "
"если это ему разрешено правами на файл. Конец для чтения открывается при "
"указании флага B<O_RDONLY>; конец для записи открывается при указании флага "
"B<O_WRONLY>. Подробней смотрите B<fifo>(7). I<Замечание>: хотя у FIFO есть "
"путь в файловой системе, при вводе-выводе из FIFO не используются операции с "
"нижележащим устройством (если оно есть)."

#. type: SS
#: man-pages/man7/pipe.7:66
#, no-wrap
msgid "I/O on pipes and FIFOs"
msgstr "Ввод-вывод из каналов и FIFO"

#. type: Plain text
#: man-pages/man7/pipe.7:71
msgid ""
"The only difference between pipes and FIFOs is the manner in which they are "
"created and opened.  Once these tasks have been accomplished, I/O on pipes "
"and FIFOs has exactly the same semantics."
msgstr ""
"Каналы и FIFO отличаются только способом создания и открытия. После "
"выполнения этих задач, ввод-вывод из каналов и FIFO имеет одинаковую "
"семантику."

#. type: Plain text
#: man-pages/man7/pipe.7:85
msgid ""
"If a process attempts to read from an empty pipe, then B<read>(2)  will "
"block until data is available.  If a process attempts to write to a full "
"pipe (see below), then B<write>(2)  blocks until sufficient data has been "
"read from the pipe to allow the write to complete.  Nonblocking I/O is "
"possible by using the B<fcntl>(2)  B<F_SETFL> operation to enable the "
"B<O_NONBLOCK> open file status flag."
msgstr ""
"Если процесс пытается выполнить чтение из пустого канала, то B<read>(2) "
"заблокирует выполнение в ожидании данных. Если процесс пытается выполнить "
"запись в заполненный канал (смотрите далее), то B<write>(2) заблокирует "
"выполнение до тех пор, пока из канала не будут прочитаны данные, чтобы можно "
"было записать ожидающие. Возможен неблокируемый ввод-вывод с помощью вызова "
"B<fcntl>(2) с операцией B<F_SETFL>, включающей флаг B<O_NONBLOCK> в "
"состоянии открытого файла."

#. type: Plain text
#: man-pages/man7/pipe.7:89
msgid ""
"The communication channel provided by a pipe is a I<byte stream>: there is "
"no concept of message boundaries."
msgstr ""
"Канал обмена, предоставляемый каналом, является I<потоком байт>: какие-либо "
"границы сообщений отсутствуют."

#. type: Plain text
#: man-pages/man7/pipe.7:116
msgid ""
"If all file descriptors referring to the write end of a pipe have been "
"closed, then an attempt to B<read>(2)  from the pipe will see end-of-file "
"(B<read>(2)  will return 0).  If all file descriptors referring to the read "
"end of a pipe have been closed, then a B<write>(2)  will cause a B<SIGPIPE> "
"signal to be generated for the calling process.  If the calling process is "
"ignoring this signal, then B<write>(2)  fails with the error B<EPIPE>.  An "
"application that uses B<pipe>(2)  and B<fork>(2)  should use suitable "
"B<close>(2)  calls to close unnecessary duplicate file descriptors; this "
"ensures that end-of-file and B<SIGPIPE>/B<EPIPE> are delivered when "
"appropriate."
msgstr ""
"Если все файловые дескрипторы, указывающие на конец канала для записи, были "
"закрыты, то попытка выполнить B<read>(2) из канала возвратит конец файла "
"(B<read>(2) вернёт 0). Если все файловые дескрипторы, указывающие на конец "
"канала для чтения, были закрыты, то B<write>(2) завершится сигналом "
"B<SIGPIPE>, который будет послан вызывающему процессу. Если вызывающий "
"процесс игнорирует этот сигнал, то B<write>(2) завершится ошибкой B<EPIPE>. "
"Приложение, использующее B<pipe>(2) и B<fork>(2), должно использовать "
"правильные вызовы B<close>(2) для закрытия ненужных копий файловых "
"дескрипторов; это обеспечит появления конца файла и доставку B<SIGPIPE>/"
"B<EPIPE> в подходящий момент."

#. type: Plain text
#: man-pages/man7/pipe.7:120
msgid "It is not possible to apply B<lseek>(2)  to a pipe."
msgstr "Для канала невозможно вызвать B<lseek>(2)."

#. type: SS
#: man-pages/man7/pipe.7:120
#, no-wrap
msgid "Pipe capacity"
msgstr "Ёмкость канала"

#. type: Plain text
#: man-pages/man7/pipe.7:132
msgid ""
"A pipe has a limited capacity.  If the pipe is full, then a B<write>(2)  "
"will block or fail, depending on whether the B<O_NONBLOCK> flag is set (see "
"below).  Different implementations have different limits for the pipe "
"capacity.  Applications should not rely on a particular capacity: an "
"application should be designed so that a reading process consumes data as "
"soon as it is available, so that a writing process does not remain blocked."
msgstr ""
"Канал имеет ограниченную ёмкость. Если канал переполнен, то B<write>(2) "
"заблокируется или завершится с ошибкой, в зависимости от наличия флага "
"B<O_NONBLOCK> (смотрите далее). В различных реализациях разные ограничения "
"на ёмкость канала. Приложения не должны полагаться на определённую величину: "
"их нужно разрабатывать так, чтобы читающий процесс перерабатывал данные как "
"только они появляются, чтобы пишущий процесс не блокировался."

#. type: Plain text
#: man-pages/man7/pipe.7:147
msgid ""
"In Linux versions before 2.6.11, the capacity of a pipe was the same as the "
"system page size (e.g., 4096 bytes on i386).  Since Linux 2.6.11, the pipe "
"capacity is 16 pages (i.e., 65,536 bytes in a system with a page size of "
"4096 bytes).  Since Linux 2.6.35, the default pipe capacity is 16 pages, but "
"the capacity can be queried and set using the B<fcntl>(2)  B<F_GETPIPE_SZ> "
"and B<F_SETPIPE_SZ> operations.  See B<fcntl>(2)  for more information."
msgstr ""
"В Linux до версии 2.6.11, ёмкость канала была равна размеру системной "
"страницы (4096 байт на i386). Начиная с Linux 2.6.11, ёмкость канала равна "
"16 страницам (т. е., 65536 байтам в системе с размером страницы в 4096 "
"байта). Начиная с Linux 2.6.35, ёмкость канала по умолчанию равна 16 "
"страницам, но это значение можно прочитать и изменить с помощью вызова "
"B<fcntl>(2) с операциями B<F_GETPIPE_SZ> и B<F_SETPIPE_SZ>. Подробности "
"смотрите в B<fcntl>(2)."

#. type: Plain text
#: man-pages/man7/pipe.7:155
msgid ""
"The following B<ioctl>(2)  operation, which can be applied to a file "
"descriptor that refers to either end of a pipe, places a count of the number "
"of unread bytes in the pipe in the I<int> buffer pointed to by the final "
"argument of the call:"
msgstr ""
"Следующая операция B<ioctl>(2), которая может быть применена к файловому "
"дескриптору, указывающему на любой конец канала, помещает количество "
"непрочитанных байт канала в буфер I<int>, задаваемый последним аргументом "
"вызова:"

#. type: Plain text
#: man-pages/man7/pipe.7:157
#, no-wrap
msgid "    ioctl(fd, FIONREAD, &nbytes);\n"
msgstr "    ioctl(fd, FIONREAD, &nbytes);\n"

#. type: Plain text
#: man-pages/man7/pipe.7:163
msgid ""
"The B<FIONREAD> operation is not specified in any standard, but is provided "
"on many implementations."
msgstr ""
"Операция B<FIONREAD> отсутствует в стандартах, но имеется во многих "
"реализациях."

#. type: Plain text
#: man-pages/man7/pipe.7:165
msgid ""
"On Linux, the following files control how much memory can be used for pipes:"
msgstr ""
"В Linux управление количеством памяти каналов осуществляется через следующие "
"файлы:"

#. type: TP
#: man-pages/man7/pipe.7:165
#, no-wrap
msgid "I</proc/sys/fs/pipe-max-pages> (only in Linux 2.6.34)"
msgstr "I</proc/sys/fs/pipe-max-pages> (только в Linux 2.6.34)"

#.  commit b492e95be0ae672922f4734acf3f5d35c30be948
#. type: Plain text
#: man-pages/man7/pipe.7:173
msgid ""
"An upper limit, in pages, on the capacity that an unprivileged user (one "
"without the B<CAP_SYS_RESOURCE> capability)  can set for a pipe."
msgstr ""
"Верхнее ограничение (в страницах) ёмкости, которое непривилегированный "
"пользователь (без мандата B<CAP_SYS_RESOURCE>) может задать для канала."

#. type: Plain text
#: man-pages/man7/pipe.7:176
msgid ""
"The default value for this limit is 16 times the default pipe capacity (see "
"above); the lower limit is two pages."
msgstr ""
"Значение по умолчанию этого ограничения равно 16 кратному размеру ёмкости "
"канала по умолчанию (смотрите выше); нижнее ограничение равно 2м страницам."

#. type: Plain text
#: man-pages/man7/pipe.7:179
msgid ""
"This interface was removed in Linux 2.6.35, in favor of I</proc/sys/fs/pipe-"
"max-size>."
msgstr ""
"Данный интерфейс удалён в Linux 2.6.35; его заменяет I</proc/sys/fs/pipe-max-"
"size>."

#. type: TP
#: man-pages/man7/pipe.7:179
#, no-wrap
msgid "I</proc/sys/fs/pipe-max-size> (since Linux 2.6.35)"
msgstr "I</proc/sys/fs/pipe-max-size> (начиная с Linux 2.6.35)"

#.  commit ff9da691c0498ff81fdd014e7a0731dab2337dac
#.  This limit is not checked on pipe creation, where the capacity is
#.  always PIPE_DEF_BUFS, regardless of pipe-max-size
#. type: Plain text
#: man-pages/man7/pipe.7:192
msgid ""
"The maximum size (in bytes) of individual pipes that can be set by users "
"without the B<CAP_SYS_RESOURCE> capability.  The value assigned to this file "
"may be rounded upward, to reflect the value actually employed for a "
"convenient implementation.  To determine the rounded-up value, display the "
"contents of this file after assigning a value to it."
msgstr ""
"Максимальный размер (в байтах) отдельных каналов, который может быть "
"установлен пользователем без мандата B<CAP_SYS_RESOURCE>. Значение, "
"записываемое в этот файл, может округлиться в большую сторону, отражая "
"реальное значение, принятое для удобства реализации. Чтобы определить "
"увеличенное значение, прочитайте содержимое этого файла после записи "
"значения."

#. type: Plain text
#: man-pages/man7/pipe.7:199
msgid ""
"The default value for this file is 1048576 (1\\ MiB).  The minimum value "
"that can be assigned to this file is the system page size.  Attempts to set "
"a limit less than the page size cause B<write>(2)  to fail with the error "
"B<EINVAL>."
msgstr ""
"Значение по умолчанию равно 1048576 (1\\ МиБ). Минимальное значение равно "
"размеру системной страницы. При попытке задать меньшее значение вызов "
"B<write>(2) завершится ошибкой B<EINVAL>."

#.  commit 086e774a57fba4695f14383c0818994c0b31da7c
#. type: Plain text
#: man-pages/man7/pipe.7:204
msgid ""
"Since Linux 4.9, the value on this file also acts as a ceiling on the "
"default capacity of a new pipe or newly opened FIFO."
msgstr ""
"Начиная с Linux 4.9 значение в данном файле также служит верхним пределом "
"ёмкости по умолчанию для новых каналов или открываемых FIFO."

#. type: TP
#: man-pages/man7/pipe.7:204
#, no-wrap
msgid "I</proc/sys/fs/pipe-user-pages-hard> (since Linux 4.5)"
msgstr "I</proc/sys/fs/pipe-user-pages-hard> (начиная с Linux 4.5)"

#.  commit 759c01142a5d0f364a462346168a56de28a80f52
#. type: Plain text
#: man-pages/man7/pipe.7:217
msgid ""
"The hard limit on the total size (in pages) of all pipes created or set by a "
"single unprivileged user (i.e., one with neither the B<CAP_SYS_RESOURCE> nor "
"the B<CAP_SYS_ADMIN> capability).  So long as the total number of pages "
"allocated to pipe buffers for this user is at this limit, attempts to create "
"new pipes will be denied, and attempts to increase a pipe's capacity will be "
"denied."
msgstr ""
"Жёсткое ограничение на общий размер (в страницах) всех каналов создаваемых "
"или изменяемых одним непривилегированным пользователем (т. е., без мандата "
"B<CAP_SYS_RESOURCE> или B<CAP_SYS_ADMIN>). Пока общее количество страниц, "
"выделенных под буферы каналов для этого пользователя, равно этому "
"ограничению, попытки создать новые каналы будут отклоняться, также как и "
"попытки увеличить ёмкость канала."

#.  The default was chosen to avoid breaking existing applications that
#.  make intensive use of pipes (e.g., for splicing).
#. type: Plain text
#: man-pages/man7/pipe.7:222
msgid ""
"When the value of this limit is zero (which is the default), no hard limit "
"is applied."
msgstr ""
"Если значение этого ограничения равно нулю (по умолчанию), то жёсткое "
"ограничение не применяется."

#. type: TP
#: man-pages/man7/pipe.7:222
#, no-wrap
msgid "I</proc/sys/fs/pipe-user-pages-soft> (since Linux 4.5)"
msgstr "I</proc/sys/fs/pipe-user-pages-soft> (начиная с Linux 4.5)"

#.  commit 759c01142a5d0f364a462346168a56de28a80f52
#. type: Plain text
#: man-pages/man7/pipe.7:235
msgid ""
"The soft limit on the total size (in pages) of all pipes created or set by a "
"single unprivileged user (i.e., one with neither the B<CAP_SYS_RESOURCE> nor "
"the B<CAP_SYS_ADMIN> capability).  So long as the total number of pages "
"allocated to pipe buffers for this user is at this limit, individual pipes "
"created by a user will be limited to one page, and attempts to increase a "
"pipe's capacity will be denied."
msgstr ""
"Мягкое ограничение на общий размер (в страницах) всех каналов создаваемых "
"или изменяемых одним непривилегированным пользователем (т. е., без мандата "
"B<CAP_SYS_RESOURCE> или B<CAP_SYS_ADMIN>). Пока общее количество страниц, "
"выделенных под буферы каналов для этого пользователя, равно этому "
"ограничению, отдельные каналы, создаваемые пользователем, будут ограничены "
"одной страницей, а попытки увеличить ёмкость канала будут отклоняться."

#. type: Plain text
#: man-pages/man7/pipe.7:239
msgid ""
"When the value of this limit is zero, no soft limit is applied.  The default "
"value for this file is 16384, which permits creating up to 1024 pipes with "
"the default capacity."
msgstr ""
"Если значение этого ограничения равно нулю, то мягкое ограничение не "
"применяется. По умолчанию значение в этом файле равно 16384, что позволяет "
"создать до 1024 каналов с ёмкостью по умолчанию."

#. type: Plain text
#: man-pages/man7/pipe.7:246
msgid ""
"Before Linux 4.9, some bugs affected the handling of the I<pipe-user-pages-"
"soft> and I<pipe-user-pages-hard> limits; see BUGS."
msgstr ""
"До Linux 4.9 имелись дефекты, влияющие на обработку ограничений I<pipe-user-"
"pages-soft> и I<pipe-user-pages-hard>; смотрите ДЕФЕКТЫ."

#. type: SS
#: man-pages/man7/pipe.7:246
#, no-wrap
msgid "PIPE_BUF"
msgstr "PIPE_BUF"

#. type: Plain text
#: man-pages/man7/pipe.7:268
msgid ""
"POSIX.1 says that B<write>(2)s of less than B<PIPE_BUF> bytes must be "
"atomic: the output data is written to the pipe as a contiguous sequence.  "
"Writes of more than B<PIPE_BUF> bytes may be nonatomic: the kernel may "
"interleave the data with data written by other processes.  POSIX.1 requires "
"B<PIPE_BUF> to be at least 512 bytes.  (On Linux, B<PIPE_BUF> is 4096 "
"bytes.)  The precise semantics depend on whether the file descriptor is "
"nonblocking (B<O_NONBLOCK>), whether there are multiple writers to the pipe, "
"and on I<n>, the number of bytes to be written:"
msgstr ""
"В POSIX.1 указано, что операция B<write>(2) для записи меньше чем "
"B<PIPE_BUF> байт должна быть атомарна: выходные данные записываются в канал "
"как непрерывная последовательность. Запись более B<PIPE_BUF> байт может быть "
"не атомарна: ядро может чередовать данные с данными, записываемыми другими "
"процессами. В POSIX.1 требуется, чтобы значение B<PIPE_BUF> было не менее "
"512 байт (в Linux, B<PIPE_BUF> равно 4096 байт). Точная семантика зависит от "
"вида блокированности файлового дескриптора (B<O_NONBLOCK>), есть ли "
"несколько писателей в канала и от I<n>, количества записываемых байт:"

#. type: TP
#: man-pages/man7/pipe.7:268
#, no-wrap
msgid "B<O_NONBLOCK> disabled, I<n> E<lt>= B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> сброшен, I<n> E<lt>= B<PIPE_BUF>"

#. type: Plain text
#: man-pages/man7/pipe.7:277
msgid ""
"All I<n> bytes are written atomically; B<write>(2)  may block if there is "
"not room for I<n> bytes to be written immediately"
msgstr ""
"Все I<n> байт записываются атомарно; B<write>(2) может заблокироваться, если "
"нет места для немедленной записи I<n> байт"

#. type: TP
#: man-pages/man7/pipe.7:277
#, no-wrap
msgid "B<O_NONBLOCK> enabled, I<n> E<lt>= B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> установлен, I<n> E<lt>= B<PIPE_BUF>"

#. type: Plain text
#: man-pages/man7/pipe.7:291
msgid ""
"If there is room to write I<n> bytes to the pipe, then B<write>(2)  succeeds "
"immediately, writing all I<n> bytes; otherwise B<write>(2)  fails, with "
"I<errno> set to B<EAGAIN>."
msgstr ""
"Если есть место для записи I<n> байт в канал, то B<write>(2) немедленно "
"завершается без ошибки, записывая все I<n> байт; в противном случае "
"B<write>(2) завершается с ошибкой, а I<errno> присваивается значение "
"B<EAGAIN>."

#. type: TP
#: man-pages/man7/pipe.7:291
#, no-wrap
msgid "B<O_NONBLOCK> disabled, I<n> E<gt> B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> сброшен, I<n> E<gt> B<PIPE_BUF>"

#. type: Plain text
#: man-pages/man7/pipe.7:303
msgid ""
"The write is nonatomic: the data given to B<write>(2)  may be interleaved "
"with B<write>(2)s by other process; the B<write>(2)  blocks until I<n> bytes "
"have been written."
msgstr ""
"Запись не атомарна: данные, переданные во B<write>(2), могут чередоваться с "
"B<write>(2) из других процессов; B<write>(2) блокируется до тех пор, пока не "
"будут записаны I<n> байт."

#. type: TP
#: man-pages/man7/pipe.7:303
#, no-wrap
msgid "B<O_NONBLOCK> enabled, I<n> E<gt> B<PIPE_BUF>"
msgstr "B<O_NONBLOCK> установлен, I<n> E<gt> B<PIPE_BUF>"

#. type: Plain text
#: man-pages/man7/pipe.7:318
msgid ""
"If the pipe is full, then B<write>(2)  fails, with I<errno> set to "
"B<EAGAIN>.  Otherwise, from 1 to I<n> bytes may be written (i.e., a "
"\"partial write\" may occur; the caller should check the return value from "
"B<write>(2)  to see how many bytes were actually written), and these bytes "
"may be interleaved with writes by other processes."
msgstr ""
"Если канала переполнен, то B<write>(2) завершается с ошибкой, а I<errno> "
"присваивается значение B<EAGAIN>. В противном случае,  может быть записано "
"от 1 до I<n> байт (т. е., может произойти «частичная запись»; вызывающий "
"должен проверить возвращаемое значение B<write>(2), чтобы узнать сколько "
"байт действительно записано), и эти байты могут чередоваться с данными, "
"записанными другими процессами."

#. type: SS
#: man-pages/man7/pipe.7:318
#, no-wrap
msgid "Open file status flags"
msgstr "Флаги состояния открытого файла"

#. type: Plain text
#: man-pages/man7/pipe.7:324
msgid ""
"The only open file status flags that can be meaningfully applied to a pipe "
"or FIFO are B<O_NONBLOCK> and B<O_ASYNC>."
msgstr ""
"К каналу и FIFO из флагов состояния открытого файла применимы только "
"B<O_NONBLOCK> и B<O_ASYNC>."

#. type: Plain text
#: man-pages/man7/pipe.7:337
msgid ""
"Setting the B<O_ASYNC> flag for the read end of a pipe causes a signal "
"(B<SIGIO> by default) to be generated when new input becomes available on "
"the pipe.  The target for delivery of signals must be set using the "
"B<fcntl>(2)  B<F_SETOWN> command.  On Linux, B<O_ASYNC> is supported for "
"pipes and FIFOs only since kernel 2.6."
msgstr ""
"Установка флага B<O_ASYNC> для чтения от конца канала проводит к генерации "
"сигнала (по умолчанию B<SIGIO>) при появлении новых данных в канале. "
"Получатель сигнала должен быть указан с помощью команды B<F_SETOWN> вызовом "
"B<fcntl>(2). В Linux B<O_ASYNC> поддерживается для каналов и FIFO только "
"начиная с ядра версии 2.6."

#. type: SS
#: man-pages/man7/pipe.7:337
#, no-wrap
msgid "Portability notes"
msgstr "Замечания о переносимости"

#. type: Plain text
#: man-pages/man7/pipe.7:343
msgid ""
"On some systems (but not Linux), pipes are bidirectional: data can be "
"transmitted in both directions between the pipe ends.  POSIX.1 requires only "
"unidirectional pipes.  Portable applications should avoid reliance on "
"bidirectional pipe semantics."
msgstr ""
"В некоторых системах (но не в Linux), каналы являются двунаправленными: "
"данные можно передавать в обоих направлениях между концами канала. Согласно "
"POSIX.1 требуются только однонаправленные каналы. Переносимые приложения не "
"должны зависеть от семантики двунаправленных каналов."

#.  These bugs where remedied by a series of patches, in particular,
#.  commit b0b91d18e2e97b741b294af9333824ecc3fadfd8 and
#.  commit a005ca0e6813e1d796a7422a7e31d8b8d6555df1
#. type: Plain text
#: man-pages/man7/pipe.7:355
msgid ""
"Before Linux 4.9, some bugs affected the handling of the I<pipe-user-pages-"
"soft> and I<pipe-user-pages-hard> limits when using the B<fcntl>(2)  "
"B<F_SETPIPE_SZ> operation to change a pipe's capacity:"
msgstr ""
"До Linux 4.9 имелись дефекты, влияющие на обработку ограничений I<pipe-user-"
"pages-soft> и I<pipe-user-pages-hard> при операции B<fcntl>(2) "
"B<F_SETPIPE_SZ> по изменению ёмкости канала:"

#. type: IP
#: man-pages/man7/pipe.7:355
#, no-wrap
msgid "(1)"
msgstr "(1)"

#. type: Plain text
#: man-pages/man7/pipe.7:362
msgid ""
"When increasing the pipe capacity, the checks against the soft and hard "
"limits were made against existing consumption, and excluded the memory "
"required for the increased pipe capacity.  The new increase in pipe capacity "
"could then push the total memory used by the user for pipes (possibly far) "
"over a limit.  (This could also trigger the problem described next.)"
msgstr ""
"При увеличении ёмкости канала, проверки мягких и жёстких ограничений "
"делались по существующему потреблению и не включали память, требуемую для "
"увеличения ёмкости канала. Новое увеличение ёмкости канала в последствии "
"могло превысить ограничение на общее количество памяти, используемой "
"пользователем для каналов (это могло также вызвать проблему, описанную "
"далее)."

#. type: Plain text
#: man-pages/man7/pipe.7:365
msgid ""
"Starting with Linux 4.9, the limit checking includes the memory required for "
"the new pipe capacity."
msgstr ""
"Начиная с Linux 4.9 при проверке ограничения добавляется память, требуемая "
"под ёмкость нового канала."

#. type: IP
#: man-pages/man7/pipe.7:365
#, no-wrap
msgid "(2)"
msgstr "(2)"

#. type: Plain text
#: man-pages/man7/pipe.7:371
msgid ""
"The limit checks were performed even when the new pipe capacity was less "
"than the existing pipe capacity.  This could lead to problems if a user set "
"a large pipe capacity, and then the limits were lowered, with the result "
"that the user could no longer decrease the pipe capacity."
msgstr ""
"Проверки ограничения выполнялись даже, когда ёмкость нового канала была "
"меньше чем ёмкость существующего канала. Это могло привести к проблемам, "
"если пользователь устанавливал большую ёмкость канала, а затем ограничения "
"снижались, и в результате этого пользователь больше не мог уменьшить ёмкость "
"канала."

#. type: Plain text
#: man-pages/man7/pipe.7:375
msgid ""
"Starting with Linux 4.9, checks against the limits are performed only when "
"increasing a pipe's capacity; an unprivileged user can always decrease a "
"pipe's capacity."
msgstr ""
"Начиная с Linux 4.9 проверки ограничений выполняются только когда ёмкость "
"канала увеличивается; непривилегированный пользователь всегда может "
"уменьшить ёмкость канала."

#. type: IP
#: man-pages/man7/pipe.7:375
#, no-wrap
msgid "(3)"
msgstr "(3)"

#. type: Plain text
#: man-pages/man7/pipe.7:377
msgid "The accounting and checking against the limits were done as follows:"
msgstr "Учёт и проверка ограничений выполнялись следующим образом:"

#. type: IP
#: man-pages/man7/pipe.7:380
#, no-wrap
msgid "(a)"
msgstr "(а)"

#. type: Plain text
#: man-pages/man7/pipe.7:382
msgid "Test whether the user has exceeded the limit."
msgstr "Выполнялась проверка не превышает ли пользователь ограничение."

#. type: IP
#: man-pages/man7/pipe.7:382
#, no-wrap
msgid "(b)"
msgstr "(б)"

#. type: Plain text
#: man-pages/man7/pipe.7:384
msgid "Make the new pipe buffer allocation."
msgstr "Выделялся буфер под новый канал."

#. type: IP
#: man-pages/man7/pipe.7:384
#, no-wrap
msgid "(c)"
msgstr "(в)"

#. type: Plain text
#: man-pages/man7/pipe.7:386
msgid "Account new allocation against the limits."
msgstr "Учитывалось новое выделение в ограничениях."

#. type: Plain text
#: man-pages/man7/pipe.7:394
msgid ""
"This was racey.  Multiple processes could pass point (a) simultaneously, and "
"then allocate pipe buffers that were accounted for only in step (c), with "
"the result that the user's pipe buffer allocation could be pushed over the "
"limit."
msgstr ""
"Это приводило к появлению состязательности. Несколько процессов могли пройти "
"пункт (а) одновременно и затем выделить буферы канала, которое учитывалось "
"только в шаге (в), что приводило к превышению пользовательского ограничения "
"размера выделения буферов под канал."

#. type: Plain text
#: man-pages/man7/pipe.7:398
msgid ""
"Starting with Linux 4.9, the accounting step is performed before doing the "
"allocation, and the operation fails if the limit would be exceeded."
msgstr ""
"Начиная с Linux 4.9, шаг учёта выполняется до выделения и операция "
"завершается с ошибкой, если бы было превышение ограничения."

#. type: Plain text
#: man-pages/man7/pipe.7:404
msgid ""
"Before Linux 4.9, bugs similar to points (1) and (3) could also occur when "
"the kernel allocated memory for a new pipe buffer; that is, when calling "
"B<pipe>(2)  and when opening a previously unopened FIFO."
msgstr ""
"До Linux 4.9, дефекты подобные (1) и (3), также могли происходить, когда "
"ядро выделяет память под буферы нового канала; то есть, когда вызывается "
"B<pipe>(2) и когда открывается ранее не открытый FIFO."

#. type: Plain text
#: man-pages/man7/pipe.7:419
msgid ""
"B<mkfifo>(1), B<dup>(2), B<fcntl>(2), B<open>(2), B<pipe>(2), B<poll>(2), "
"B<select>(2), B<socketpair>(2), B<splice>(2), B<stat>(2), B<tee>(2), "
"B<vmsplice>(2), B<mkfifo>(3), B<epoll>(7), B<fifo>(7)"
msgstr ""
"B<mkfifo>(1), B<dup>(2), B<fcntl>(2), B<open>(2), B<pipe>(2), B<poll>(2), "
"B<select>(2), B<socketpair>(2), B<splice>(2), B<stat>(2), B<tee>(2), "
"B<vmsplice>(2), B<mkfifo>(3), B<epoll>(7), B<fifo>(7)"

#. type: TH
#: man-pages/man7/packet.7:12
#, no-wrap
msgid "PACKET"
msgstr "PACKET"

#. type: Plain text
#: man-pages/man7/packet.7:15
msgid "packet - packet interface on device level"
msgstr "packet - пакетный интерфейс на уровне устройства"

#. type: Plain text
#: man-pages/man7/packet.7:20
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/if_packet.hE<gt>>\n"
"B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
msgstr ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>linux/if_packet.hE<gt>>\n"
"B<#include E<lt>net/ethernet.hE<gt> /* протоколы L2 */>\n"

#. type: Plain text
#: man-pages/man7/packet.7:22
#, no-wrap
msgid "B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int >I<protocol>B<);>\n"
msgstr "B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int >I<protocol>B<);>\n"

#. type: Plain text
#: man-pages/man7/packet.7:28
msgid ""
"Packet sockets are used to receive or send raw packets at the device driver "
"(OSI Layer 2) level.  They allow the user to implement protocol modules in "
"user space on top of the physical layer."
msgstr ""
"Пакетные сокеты используются для приёма и передачи неструктурированных "
"пакетов на уровне драйвера устройства (второй уровень OSI). Они позволяют "
"пользователю реализовывать модули протоколов в пользовательском пространстве "
"поверх физического уровня."

#. type: Plain text
#: man-pages/man7/packet.7:50
msgid ""
"The I<socket_type> is either B<SOCK_RAW> for raw packets including the link-"
"level header or B<SOCK_DGRAM> for cooked packets with the link-level header "
"removed.  The link-level header information is available in a common format "
"in a I<sockaddr_ll> structure.  I<protocol> is the IEEE 802.3 protocol "
"number in network byte order.  See the I<E<lt>linux/if_ether.hE<gt>> include "
"file for a list of allowed protocols.  When protocol is set to "
"B<htons(ETH_P_ALL)>, then all protocols are received.  All incoming packets "
"of that protocol type will be passed to the packet socket before they are "
"passed to the protocols implemented in the kernel."
msgstr ""
"Значением I<socket_type> может быть B<SOCK_RAW> — для неструктурированных "
"пакетов, содержащих заголовок уровня связи, или B<SOCK_DGRAM> — для "
"подготовленных (cooked) пакетов без заголовка уровня связи. Информация "
"заголовка уровня связи имеет общий формат и предоставляется структурой "
"I<sockaddr_ll>. В I<protocol> содержится номер протокола согласно IEEE 802.3 "
"в сетевом порядке байт. Список допустимых протоколов можно найти в "
"заголовочном файле I<E<lt>linux/if_ether.hE<gt>>. Если значение протокола "
"равно B<htons(ETH_P_ALL)>, то принимаются все протоколы. Все входящие пакеты "
"с этим типом протокола будут переданы в пакетный сокет до их передачи "
"протоколам, реализуемым в ядре."

#. type: Plain text
#: man-pages/man7/packet.7:54
msgid ""
"In order to create a packet socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""
"Для создания пакетного сокета процесс должен иметь мандат B<CAP_NET_RAW> в "
"пользовательском пространстве имён, определяемом по его сетевому "
"пространству имён."

#. type: Plain text
#: man-pages/man7/packet.7:72
msgid ""
"B<SOCK_RAW> packets are passed to and from the device driver without any "
"changes in the packet data.  When receiving a packet, the address is still "
"parsed and passed in a standard I<sockaddr_ll> address structure.  When "
"transmitting a packet, the user-supplied buffer should contain the physical-"
"layer header.  That packet is then queued unmodified to the network driver "
"of the interface defined by the destination address.  Some device drivers "
"always add other headers.  B<SOCK_RAW> is similar to but not compatible with "
"the obsolete B<AF_INET/SOCK_PACKET> of Linux 2.0."
msgstr ""
"Пакеты B<SOCK_RAW> передаются в и из драйвера устройства без каких-либо "
"изменений в данных пакета. При получении пакета, адрес по-прежнему "
"анализируется и передаётся в стандартной адресной структуре I<sockaddr_ll>. "
"При отправке пакета, выделенный пользователем буфер должен содержать "
"заголовок физического уровня. Этот пакет затем ставится без изменений в "
"очередь сетевого драйвера интерфейса, определяемого адресом назначения. "
"Некоторые драйверы устройств всегда добавляют другой заголовок. Пакеты "
"B<SOCK_RAW> похожи, но не совместимы с устаревшими B<AF_INET/SOCK_PACKET> из "
"Linux 2.0."

#. type: Plain text
#: man-pages/man7/packet.7:82
msgid ""
"B<SOCK_DGRAM> operates on a slightly higher level.  The physical header is "
"removed before the packet is passed to the user.  Packets sent through a "
"B<SOCK_DGRAM> packet socket get a suitable physical-layer header based on "
"the information in the I<sockaddr_ll> destination address before they are "
"queued."
msgstr ""
"При типе B<SOCK_DGRAM> обработка происходит на чуть более высоком уровне. "
"Физический заголовок удаляется перед передачей пакета пользователю. Пакеты, "
"посылаемые через пакетный сокет B<SOCK_DGRAM>, перед постановкой в очередь "
"получают подходящий заголовок физического уровня на основе информации из "
"адреса назначения в I<sockaddr_ll>."

#. type: Plain text
#: man-pages/man7/packet.7:97
msgid ""
"By default, all packets of the specified protocol type are passed to a "
"packet socket.  To get packets only from a specific interface use "
"B<bind>(2)  specifying an address in a I<struct sockaddr_ll> to bind the "
"packet socket to an interface.  Fields used for binding are I<sll_family> "
"(should be B<AF_PACKET>), I<sll_protocol>, and I<sll_ifindex>."
msgstr ""
"По умолчанию, все пакеты заданного типа протокола передаются в пакетный "
"сокет. Для получения пакетов только из определённого интерфейса используйте "
"B<bind>(2), задав адрес в I<struct sockaddr_ll> для привязки пакетного "
"сокета к интерфейсу. Поля, используемые для привязывания: I<sll_family> "
"(должно быть равно B<AF_PACKET>), I<sll_protocol> и I<sll_ifindex>."

#. type: Plain text
#: man-pages/man7/packet.7:101
msgid "The B<connect>(2)  operation is not supported on packet sockets."
msgstr "Операция B<connect>(2) не поддерживается для пакетных сокетов."

#. type: Plain text
#: man-pages/man7/packet.7:111
msgid ""
"When the B<MSG_TRUNC> flag is passed to B<recvmsg>(2), B<recv>(2), or "
"B<recvfrom>(2), the real length of the packet on the wire is always "
"returned, even when it is longer than the buffer."
msgstr ""
"Если в B<recvmsg>(2), B<recv>(2) или B<recvfrom>(2) передаётся флаг "
"B<MSG_TRUNC>, то возвращается реальная длина пакета в канале, даже если "
"значение длиннее буфера."

#. type: SS
#: man-pages/man7/packet.7:111
#, no-wrap
msgid "Address types"
msgstr "Типы адресов"

#. type: Plain text
#: man-pages/man7/packet.7:115
msgid ""
"The I<sockaddr_ll> structure is a device-independent physical-layer address."
msgstr ""
"Структура I<sockaddr_ll> описывает независимый от устройства адрес на "
"физическом уровне."

#. type: Plain text
#: man-pages/man7/packet.7:127
#, no-wrap
msgid ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* Always AF_PACKET */\n"
"    unsigned short sll_protocol; /* Physical-layer protocol */\n"
"    int            sll_ifindex;  /* Interface number */\n"
"    unsigned short sll_hatype;   /* ARP hardware type */\n"
"    unsigned char  sll_pkttype;  /* Packet type */\n"
"    unsigned char  sll_halen;    /* Length of address */\n"
"    unsigned char  sll_addr[8];  /* Physical-layer address */\n"
"};\n"
msgstr ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* всегда равно AF_PACKET */\n"
"    unsigned short sll_protocol; /* протокол физического уровня */\n"
"    int            sll_ifindex;  /* номер интерфейса */\n"
"    unsigned short sll_hatype;   /* тип аппаратного ARP */\n"
"    unsigned char  sll_pkttype;  /* тип пакета */\n"
"    unsigned char  sll_halen;    /* длина адреса */\n"
"    unsigned char  sll_addr[8];  /* адрес на физическом уровне */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/packet.7:131
msgid "The fields of this structure are as follows:"
msgstr "Поля этой структуры имеют следующее назначение:"

#. type: IP
#: man-pages/man7/packet.7:131 man-pages/man7/packet.7:138
#: man-pages/man7/packet.7:148 man-pages/man7/packet.7:165
#: man-pages/man7/packet.7:290 man-pages/man7/packet.7:298
#: man-pages/man7/packet.7:302 man-pages/man7/packet.7:305
#: man-pages/man7/packet.7:309 man-pages/man7/packet.7:312
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/packet.7:138
msgid ""
"I<sll_protocol> is the standard ethernet protocol type in network byte order "
"as defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It defaults "
"to the socket's protocol."
msgstr ""
"Поле I<sll_protocol> содержит стандартные типы протокола ethernet в сетевом "
"порядке байт; значения определены в заголовочном файле I<E<lt>linux/if_ether."
"hE<gt>>. Это значение по умолчанию для протокола сокета."

#. type: Plain text
#: man-pages/man7/packet.7:148
msgid ""
"I<sll_ifindex> is the interface index of the interface (see "
"B<netdevice>(7)); 0 matches any interface (only permitted for binding).  "
"I<sll_hatype> is an ARP type as defined in the I<E<lt>linux/if_arp.hE<gt>> "
"include file."
msgstr ""
"Поле I<sll_ifindex> содержит индекс интерфейса (смотрите B<netdevice>(7)); 0 "
"означает любой интерфейс (допустимо только для привязывания). Поле "
"I<sll_hatype> содержит тип ARP; значения хранятся в заголовочном файле "
"I<E<lt>linux/if_arp.hE<gt>>."

#. type: Plain text
#: man-pages/man7/packet.7:165
msgid ""
"I<sll_pkttype> contains the packet type.  Valid types are B<PACKET_HOST> for "
"a packet addressed to the local host, B<PACKET_BROADCAST> for a physical-"
"layer broadcast packet, B<PACKET_MULTICAST> for a packet sent to a physical-"
"layer multicast address, B<PACKET_OTHERHOST> for a packet to some other host "
"that has been caught by a device driver in promiscuous mode, and "
"B<PACKET_OUTGOING> for a packet originating from the local host that is "
"looped back to a packet socket.  These types make sense only for receiving."
msgstr ""
"В поле I<sll_pkttype> содержится тип пакета. Допустимые типы: B<PACKET_HOST> "
"— пакет предназначен локальному узлу, B<PACKET_BROADCAST> — "
"широковещательный пакет физического уровня, B<PACKET_MULTICAST> — пакет, "
"посланный на групповой (multicast) адрес физического уровня, "
"B<PACKET_OTHERHOST> — пакет предназначен не тому узлу, где он пойман "
"драйвером устройства в неразборчивом режиме, B<PACKET_OUTGOING> — пакет, "
"поступивший от локального узла и завёрнутый обратно в пакетный сокет. Эти "
"типы имеют смысл только для принятых пакетов."

#. type: Plain text
#: man-pages/man7/packet.7:171
msgid ""
"I<sll_addr> and I<sll_halen> contain the physical-layer (e.g., IEEE 802.3) "
"address and its length.  The exact interpretation depends on the device."
msgstr ""
"В полях I<sll_addr> и I<sll_halen> содержится адрес физического уровня "
"(например, IEEE 802.3) и его длина. Конкретный смысл зависит от устройства."

#. type: Plain text
#: man-pages/man7/packet.7:184
msgid ""
"When you send packets, it is enough to specify I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex>, and I<sll_protocol>.  The other fields should "
"be 0.  I<sll_hatype> and I<sll_pkttype> are set on received packets for your "
"information."
msgstr ""
"Когда вы посылаете пакеты, достаточно указать I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex> и I<sll_protocol>. Остальные поля должны "
"равняться 0. Поля I<sll_hatype> и I<sll_pkttype> заполняются в получаемых "
"пакетах для вашей информированности."

#. type: SS
#: man-pages/man7/packet.7:184
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокета"

#. type: Plain text
#: man-pages/man7/packet.7:189
msgid ""
"Packet socket options are configured by calling B<setsockopt>(2)  with level "
"B<SOL_PACKET>."
msgstr ""
"Параметры пакетных сокетов настраиваются вызовом B<setsockopt>(2) с уровнем "
"B<SOL_PACKET>."

#. type: TP
#: man-pages/man7/packet.7:189
#, no-wrap
msgid "B<PACKET_ADD_MEMBERSHIP>"
msgstr "B<PACKET_ADD_MEMBERSHIP>"

#. type: TP
#: man-pages/man7/packet.7:192
#, no-wrap
msgid "B<PACKET_DROP_MEMBERSHIP>"
msgstr "B<PACKET_DROP_MEMBERSHIP>"

#. type: Plain text
#: man-pages/man7/packet.7:204
msgid ""
"Packet sockets can be used to configure physical-layer multicasting and "
"promiscuous mode.  B<PACKET_ADD_MEMBERSHIP> adds a binding and "
"B<PACKET_DROP_MEMBERSHIP> drops it.  They both expect a I<packet_mreq> "
"structure as argument:"
msgstr ""
"Пакетные сокеты можно использовать для настройки неразборчивого режима и "
"групповой рассылки на физическом уровне. Параметр B<PACKET_ADD_MEMBERSHIP> "
"добавляет привязку, B<PACKET_DROP_MEMBERSHIP> отменяет её. Для обоих в "
"качестве аргумента передаётся структура I<packet_mreq>:"

#. type: Plain text
#: man-pages/man7/packet.7:213
#, no-wrap
msgid ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* interface index */\n"
"    unsigned short mr_type;       /* action */\n"
"    unsigned short mr_alen;       /* address length */\n"
"    unsigned char  mr_address[8]; /* physical-layer address */\n"
"};\n"
msgstr ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* индекс интерфейса */\n"
"    unsigned short mr_type;       /* действие */\n"
"    unsigned short mr_alen;       /* длина адреса */\n"
"    unsigned char  mr_address[8]; /* адрес физ-кого уровня */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/packet.7:234
msgid ""
"I<mr_ifindex> contains the interface index for the interface whose status "
"should be changed.  The I<mr_type> field specifies which action to perform.  "
"B<PACKET_MR_PROMISC> enables receiving all packets on a shared medium (often "
"known as \"promiscuous mode\"), B<PACKET_MR_MULTICAST> binds the socket to "
"the physical-layer multicast group specified in I<mr_address> and "
"I<mr_alen>, and B<PACKET_MR_ALLMULTI> sets the socket up to receive all "
"multicast packets arriving at the interface."
msgstr ""
"В I<mr_ifindex> содержится индекс интерфейса, состояние которого нужно "
"изменить. В поле I<mr_type> указывается какое действие нужно выполнить. "
"Значение B<PACKET_MR_PROMISC> включает приём всех пакетов из общего носителя "
"(часто называется «неразборчивый режим»), B<PACKET_MR_MULTICAST> привязывает "
"сокет к групповой рассылке физического уровня, задаваемой в I<mr_address> и "
"I<mr_alen>, а B<PACKET_MR_ALLMULTI> заставляет сокет принимать все пакеты "
"групповых рассылок, поступающих на интерфейс."

#. type: Plain text
#: man-pages/man7/packet.7:240
msgid ""
"In addition, the traditional ioctls B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> can be used for the same purpose."
msgstr ""
"Также, для тех же целей можно использовать обычные ioctl B<SIOCSIFFLAGS>, "
"B<SIOCADDMULTI>, B<SIOCDELMULTI>."

#. type: TP
#: man-pages/man7/packet.7:240
#, no-wrap
msgid "B<PACKET_AUXDATA> (since Linux 2.6.21)"
msgstr "B<PACKET_AUXDATA> (начиная с Linux 2.6.21)"

#.  commit 8dc4194474159660d7f37c495e3fc3f10d0db8cc
#. type: Plain text
#: man-pages/man7/packet.7:250
msgid ""
"If this binary option is enabled, the packet socket passes a metadata "
"structure along with each packet in the B<recvmsg>(2)  control field.  The "
"structure can be read with B<cmsg>(3).  It is defined as"
msgstr ""
"Если включён этот двоичный параметр, то пакетный сокет передаёт структуру "
"метаданных вместе с каждым пакетом в управляющем поле B<recvmsg>(2). "
"Структуру можно прочитать с помощью B<cmsg>(3). Она определена как:"

#. type: Plain text
#: man-pages/man7/packet.7:262
#, no-wrap
msgid ""
"struct tpacket_auxdata {\n"
"    __u32 tp_status;\n"
"    __u32 tp_len;      /* packet length */\n"
"    __u32 tp_snaplen;  /* captured length */\n"
"    __u16 tp_mac;\n"
"    __u16 tp_net;\n"
"    __u16 tp_vlan_tci;\n"
"    __u16 tp_padding;\n"
"};\n"
msgstr ""
"struct tpacket_auxdata {\n"
"    __u32 tp_status;\n"
"    __u32 tp_len;      /* длина пакета */\n"
"    __u32 tp_snaplen;  /* захваченная длина */\n"
"    __u16 tp_mac;\n"
"    __u16 tp_net;\n"
"    __u16 tp_vlan_tci;\n"
"    __u16 tp_padding;\n"
"};\n"

#. type: TP
#: man-pages/man7/packet.7:264
#, no-wrap
msgid "B<PACKET_FANOUT> (since Linux 3.1)"
msgstr "B<PACKET_FANOUT> (начиная с Linux 3.1)"

#.  commit dc99f600698dcac69b8f56dda9a8a00d645c5ffc
#. type: Plain text
#: man-pages/man7/packet.7:286
msgid ""
"To scale processing across threads, packet sockets can form a fanout group.  "
"In this mode, each matching packet is enqueued onto only one socket in the "
"group.  A socket joins a fanout group by calling B<setsockopt>(2)  with "
"level B<SOL_PACKET> and option B<PACKET_FANOUT>.  Each network namespace can "
"have up to 65536 independent groups.  A socket selects a group by encoding "
"the ID in the first 16 bits of the integer option value.  The first packet "
"socket to join a group implicitly creates it.  To successfully join an "
"existing group, subsequent packet sockets must have the same protocol, "
"device settings, fanout mode and flags (see below).  Packet sockets can "
"leave a fanout group only by closing the socket.  The group is deleted when "
"the last socket is closed."
msgstr ""
"Для масштабирования обработки на несколько нитей, пакетные сокеты можно "
"объединять в разветвлённую группу (fanout group). В этом режиме каждый "
"подходящий пакет ставится в очередь только одного сокета в группе. Сокет "
"добавляется в разветвлённую группу вызовом B<setsockopt>(2) с уровнем "
"B<SOL_PACKET> и параметром B<PACKET_FANOUT>. Каждое сетевое пространство "
"имён может включать до 65536 независимых групп. Сокет выбирает группу по "
"закодированному ID в первых 16 битах целочисленного значения параметра. "
"Первый пакетный сокет, подключаемый к группе неявно её создаёт. Для "
"успешного подключения к существующей группе все дальнейшие пакетные сокеты "
"должны иметь тот же протокол, настройки устройства, режим разветвления и "
"флаги (смотрите далее). Пакетные сокеты могут покинуть группу только при "
"закрытия сокета. Группа удаляется после закрытия последнего сокета."

#. type: Plain text
#: man-pages/man7/packet.7:289
msgid ""
"Fanout supports multiple algorithms to spread traffic between sockets, as "
"follows:"
msgstr ""
"Для разветвления поддерживается несколько алгоритмов распределения трафика "
"по сокетам:"

#. type: Plain text
#: man-pages/man7/packet.7:298
msgid ""
"The default mode, B<PACKET_FANOUT_HASH>, sends packets from the same flow to "
"the same socket to maintain per-flow ordering.  For each packet, it chooses "
"a socket by taking the packet flow hash modulo the number of sockets in the "
"group, where a flow hash is a hash over network-layer address and optional "
"transport-layer port fields."
msgstr ""
"Режим по умолчанию B<PACKET_FANOUT_HASH> посылает пакеты из одного потока в "
"один и тот же сокет для обеспечения упорядочивания по потоку. Для каждого "
"пакета выбирается сокет, получаемый из хэша потока пакетов, взятого по "
"модулю количества сокетов в группе, где хэш потока — это хэш адреса сетевого "
"уровня и необязательных полей портов транспортного уровня."

#. type: Plain text
#: man-pages/man7/packet.7:302
msgid ""
"The load-balance mode B<PACKET_FANOUT_LB> implements a round-robin algorithm."
msgstr ""
"Режим балансировки нагрузки B<PACKET_FANOUT_LB> реализует карусельный "
"алгоритм."

#. type: Plain text
#: man-pages/man7/packet.7:305
msgid ""
"B<PACKET_FANOUT_CPU> selects the socket based on the CPU that the packet "
"arrived on."
msgstr ""
"В режиме B<PACKET_FANOUT_CPU> выбираются сокеты исходя из ЦП, на который "
"поступил пакет."

#. type: Plain text
#: man-pages/man7/packet.7:309
msgid ""
"B<PACKET_FANOUT_ROLLOVER> processes all data on a single socket, moving to "
"the next when one becomes backlogged."
msgstr ""
"В режиме B<PACKET_FANOUT_ROLLOVER> все данные обрабатываются одним сокетом, "
"следующий задействуется, если текущий занят (backlogged)."

#. type: Plain text
#: man-pages/man7/packet.7:312
msgid ""
"B<PACKET_FANOUT_RND> selects the socket using a pseudo-random number "
"generator."
msgstr ""
"В режиме B<PACKET_FANOUT_RND> сокет выбирается согласно генератору "
"псевдослучайных чисел."

#.  commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
#. type: Plain text
#: man-pages/man7/packet.7:317
msgid ""
"B<PACKET_FANOUT_QM> (available since Linux 3.14)  selects the socket using "
"the recorded queue_mapping of the received skb."
msgstr ""
"В режиме B<PACKET_FANOUT_QM> (доступен, начиная с Linux 3.14)  сокет "
"выбирается с помощью записанного queue_mapping из полученной skb."

#. type: Plain text
#: man-pages/man7/packet.7:333
msgid ""
"Fanout modes can take additional options.  IP fragmentation causes packets "
"from the same flow to have different flow hashes.  The flag "
"B<PACKET_FANOUT_FLAG_DEFRAG>, if set, causes packets to be defragmented "
"before fanout is applied, to preserve order even in this case.  Fanout mode "
"and options are communicated in the second 16 bits of the integer option "
"value.  The flag B<PACKET_FANOUT_FLAG_ROLLOVER> enables the roll over "
"mechanism as a backup strategy: if the original fanout algorithm selects a "
"backlogged socket, the packet rolls over to the next available one."
msgstr ""
"Режимы разветвления могут учитывать дополнительные параметры. Фрагментация "
"IP приводит к тому, что пакеты одного потока имеют разные хэши потоков. Если "
"установлен флаг B<PACKET_FANOUT_FLAG_DEFRAG>, то пакеты будут "
"дефрагментироваться перед применением разветвления, что позволит сохранить "
"порядок даже в этом случае. Параметры режима разветвления задаются во вторых "
"16 битах целочисленного значения параметра. Флаг "
"B<PACKET_FANOUT_FLAG_ROLLOVER> включает механизм перекатывания в качестве "
"запасного: если первоначальный алгоритм разветвления выбрал занятый сокет, "
"то пакет переходит на следующий доступный."

#. type: TP
#: man-pages/man7/packet.7:333
#, no-wrap
msgid "B<PACKET_LOSS> (with B<PACKET_TX_RING>)"
msgstr "B<PACKET_LOSS> (с B<PACKET_TX_RING>)"

#. type: Plain text
#: man-pages/man7/packet.7:356
msgid ""
"When a malformed packet is encountered on a transmit ring, the default is to "
"reset its I<tp_status> to B<TP_STATUS_WRONG_FORMAT> and abort the "
"transmission immediately.  The malformed packet blocks itself and "
"subsequently enqueued packets from being sent.  The format error must be "
"fixed, the associated I<tp_status> reset to B<TP_STATUS_SEND_REQUEST>, and "
"the transmission process restarted via B<send>(2).  However, if "
"B<PACKET_LOSS> is set, any malformed packet will be skipped, its "
"I<tp_status> reset to B<TP_STATUS_AVAILABLE>, and the transmission process "
"continued."
msgstr ""
"Когда в кольце передачи обнаруживается некорректный пакет, то по умолчанию "
"его состояние в I<tp_status> сбрасывается в B<TP_STATUS_WRONG_FORMAT> и "
"происходит немедленная отмена передачи. Некорректный пакет блокирует как "
"свою отправку, так и всех следующих пакетов в очереди. Ошибка в формате "
"должна быть исправлена, соответствующий I<tp_status> сброшен в значение "
"B<TP_STATUS_SEND_REQUEST>, а передача перезапущена с помощью B<send>(2). "
"Однако, если задан параметр B<PACKET_LOSS>, то все некорректные пакеты будут "
"пропускаться, их I<tp_status> сбрасываться в B<TP_STATUS_AVAILABLE> и "
"процесс передачи продолжаться."

#. type: TP
#: man-pages/man7/packet.7:356
#, no-wrap
msgid "B<PACKET_RESERVE> (with B<PACKET_RX_RING>)"
msgstr "B<PACKET_RESERVE> (с B<PACKET_RX_RING>)"

#. type: Plain text
#: man-pages/man7/packet.7:361
msgid ""
"By default, a packet receive ring writes packets immediately following the "
"metadata structure and alignment padding.  This integer option reserves "
"additional headroom."
msgstr ""
"По умолчанию, в кольцо приёма пакетов сразу за пакетом записывается "
"структура метаданных и заполнитель для выравнивания. Этот целочисленный "
"параметр резервирует дополнительное свободное место."

#. type: TP
#: man-pages/man7/packet.7:361
#, no-wrap
msgid "B<PACKET_RX_RING>"
msgstr "B<PACKET_RX_RING>"

#. type: Plain text
#: man-pages/man7/packet.7:403
msgid ""
"Create a memory-mapped ring buffer for asynchronous packet reception.  The "
"packet socket reserves a contiguous region of application address space, "
"lays it out into an array of packet slots and copies packets (up to "
"I<tp_snaplen>)  into subsequent slots.  Each packet is preceded by a "
"metadata structure similar to I<tpacket_auxdata>.  The protocol fields "
"encode the offset to the data from the start of the metadata header.  "
"I<tp_net> stores the offset to the network layer.  If the packet socket is "
"of type B<SOCK_DGRAM>, then I<tp_mac> is the same.  If it is of type "
"B<SOCK_RAW>, then that field stores the offset to the link-layer frame.  "
"Packet socket and application communicate the head and tail of the ring "
"through the I<tp_status> field.  The packet socket owns all slots with "
"I<tp_status> equal to B<TP_STATUS_KERNEL>.  After filling a slot, it changes "
"the status of the slot to transfer ownership to the application.  During "
"normal operation, the new I<tp_status> value has at least the "
"B<TP_STATUS_USER> bit set to signal that a received packet has been stored.  "
"When the application has finished processing a packet, it transfers "
"ownership of the slot back to the socket by setting I<tp_status> equal to "
"B<TP_STATUS_KERNEL>."
msgstr ""
"Включает создание отображаемого в памяти кольцевого буфера асинхронного "
"приёма пакетов. Пакетный сокет резервирует непрерывную область в адресном "
"пространстве приложения, размечает её как массив пакетных слотов и "
"последовательно копирует пакеты (не более I<tp_snaplen>) в слоты. В начале "
"каждого пакета помещается структура метаданных, похожая на "
"I<tpacket_auxdata>. В поле протокола кодируется смещение данных от начала "
"заголовка метаданных. В I<tp_net> хранится смещение сетевого уровня. Если "
"тип пакетного сокета — B<SOCK_DGRAM>, то это делается и для I<tp_mac>. Если "
"тип — B<SOCK_RAW>, то в этом поле хранится смещение на кадр канального "
"уровня. Пакетный сокет и приложение обмениваются началом и концом кольца "
"через поле I<tp_status>. Пакетному сокету принадлежат все слоты со значением "
"I<tp_status> равным B<TP_STATUS_KERNEL>. После заполнения слота, изменяется "
"состояние слота и права на него передаются приложению. При нормальной работе "
"в новом значении I<tp_status>, как минимум, установлен бит "
"B<TP_STATUS_USER>, что показывает, что принятый пакет был сохранён. Когда "
"приложение заканчивает обработку пакета, оно передаёт права на слот обратно "
"сокету посредством установки I<tp_status> в значение B<TP_STATUS_KERNEL>."

#. type: Plain text
#: man-pages/man7/packet.7:408
msgid ""
"Packet sockets implement multiple variants of the packet ring.  The "
"implementation details are described in I<Documentation/networking/"
"packet_mmap.txt> in the Linux kernel source tree."
msgstr ""
"Для пакетных сокетов реализовано несколько вариантов пакетных колец. "
"Информацию о реализации можно найти в файле I<Documentation/networking/"
"packet_mmap.txt> из дерева исходного кода ядра Linux."

#. type: TP
#: man-pages/man7/packet.7:408
#, no-wrap
msgid "B<PACKET_STATISTICS>"
msgstr "B<PACKET_STATISTICS>"

#. type: Plain text
#: man-pages/man7/packet.7:411
msgid "Retrieve packet socket statistics in the form of a structure"
msgstr "Возвращает статистику по пакетному сокету в виде структуры"

#. type: Plain text
#: man-pages/man7/packet.7:418
#, no-wrap
msgid ""
"struct tpacket_stats {\n"
"    unsigned int tp_packets;  /* Total packet count */\n"
"    unsigned int tp_drops;    /* Dropped packet count */\n"
"};\n"
msgstr ""
"struct tpacket_stats {\n"
"    unsigned int tp_packets;  /* общее количество пакетов */\n"
"    unsigned int tp_drops;    /* кол-во отброшенных пакетов */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/packet.7:424
msgid ""
"Receiving statistics resets the internal counters.  The statistics structure "
"differs when using a ring of variant B<TPACKET_V3>."
msgstr ""
"При получении статистики сбрасываются внутренние счётчики. Если используется "
"вариант кольца B<TPACKET_V3>, то статистика имеет другую структуру."

#. type: TP
#: man-pages/man7/packet.7:424
#, no-wrap
msgid "B<PACKET_TIMESTAMP> (with B<PACKET_RX_RING>; since Linux 2.6.36)"
msgstr "B<PACKET_TIMESTAMP> (с B<PACKET_RX_RING>; начиная с Linux 2.6.36)"

#.  commit 614f60fa9d73a9e8fdff3df83381907fea7c5649
#. type: Plain text
#: man-pages/man7/packet.7:434
msgid ""
"The packet receive ring always stores a timestamp in the metadata header.  "
"By default, this is a software generated timestamp generated when the packet "
"is copied into the ring.  This integer option selects the type of "
"timestamp.  Besides the default, it support the two hardware formats "
"described in I<Documentation/networking/timestamping.txt> in the Linux "
"kernel source tree."
msgstr ""
"В кольце приёма пакетов всегда сохраняется метка времени в заголовке "
"метаданных. По умолчанию, это метка генерируется ПО при копировании пакета в "
"кольцо. Данный целочисленный параметр задаёт тип метки времени. Кроме "
"значения по умолчанию, поддерживается два аппаратных формата, описанных в "
"файле I<Documentation/networking/timestamping.txt> из дерева исходного кода "
"ядра Linux."

#. type: TP
#: man-pages/man7/packet.7:434
#, no-wrap
msgid "B<PACKET_TX_RING> (since Linux 2.6.31)"
msgstr "B<PACKET_TX_RING> (начиная с Linux 2.6.31)"

#.  commit 69e3c75f4d541a6eb151b3ef91f34033cb3ad6e1
#. type: Plain text
#: man-pages/man7/packet.7:469
msgid ""
"Create a memory-mapped ring buffer for packet transmission.  This option is "
"similar to B<PACKET_RX_RING> and takes the same arguments.  The application "
"writes packets into slots with I<tp_status> equal to B<TP_STATUS_AVAILABLE> "
"and schedules them for transmission by changing I<tp_status> to "
"B<TP_STATUS_SEND_REQUEST>.  When packets are ready to be transmitted, the "
"application calls B<send>(2)  or a variant thereof.  The I<buf> and I<len> "
"fields of this call are ignored.  If an address is passed using "
"B<sendto>(2)  or B<sendmsg>(2), then that overrides the socket default.  On "
"successful transmission, the socket resets I<tp_status> to "
"B<TP_STATUS_AVAILABLE>.  It immediately aborts the transmission on error "
"unless B<PACKET_LOSS> is set."
msgstr ""
"Включает создание отображаемого в памяти кольцевого буфера передачи пакетов. "
"Этот параметр подобен B<PACKET_RX_RING> и имеет те же аргументы. Приложение "
"записывает пакеты в слоты со значением I<tp_status> равным "
"B<TP_STATUS_AVAILABLE> и планирует их для передачи делая значение "
"I<tp_status> равным B<TP_STATUS_SEND_REQUEST>. Когда пакеты готовы к "
"передаче, приложение вызывает B<send>(2) или его вариант. Поля I<buf> и "
"I<len> в этом вызове игнорируются. Если передаётся адрес с помощью "
"B<sendto>(2) или B<sendmsg>(2), то он заменяет сокетное значение по "
"умолчанию. При успешной передаче сокет сбрасывает значение I<tp_status> в "
"B<TP_STATUS_AVAILABLE>. При ошибке передача немедленно прерывается, если не "
"задан B<PACKET_LOSS>."

#. type: TP
#: man-pages/man7/packet.7:469
#, no-wrap
msgid "B<PACKET_VERSION> (with B<PACKET_RX_RING>; since Linux 2.6.27)"
msgstr "B<PACKET_VERSION> (с B<PACKET_RX_RING>; начиная с Linux 2.6.27)"

#.  commit bbd6ef87c544d88c30e4b762b1b61ef267a7d279
#. type: Plain text
#: man-pages/man7/packet.7:478
msgid ""
"By default, B<PACKET_RX_RING> creates a packet receive ring of variant "
"B<TPACKET_V1>.  To create another variant, configure the desired variant by "
"setting this integer option before creating the ring."
msgstr ""
"По умолчанию, B<PACKET_RX_RING> создаёт кольцо приёма пакетов по варианту "
"B<TPACKET_V1>. Для создания другого варианта, задайте желаемый, указав "
"целочисленное значение в этом параметре перед созданием кольца."

#. type: TP
#: man-pages/man7/packet.7:478
#, no-wrap
msgid "B<PACKET_QDISC_BYPASS> (since Linux 3.14)"
msgstr "B<PACKET_QDISC_BYPASS> (начиная с Linux 3.14)"

#.  commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
#. type: Plain text
#: man-pages/man7/packet.7:493
msgid ""
"By default, packets sent through packet sockets pass through the kernel's "
"qdisc (traffic control) layer, which is fine for the vast majority of use "
"cases.  For traffic generator appliances using packet sockets that intend to "
"brute-force flood the network\\(emfor example, to test devices under load in "
"a similar fashion to pktgen\\(emthis layer can be bypassed by setting this "
"integer option to 1.  A side effect is that packet buffering in the qdisc "
"layer is avoided, which will lead to increased drops when network device "
"transmit queues are busy; therefore, use at your own risk."
msgstr ""
"По умолчанию, пакеты, посылаемые через пакетные сокеты, проходят через "
"уровень ядра qdisc (управление трафиком), что правильно в подавляющем "
"большинстве случаев. Для программно-аппаратных комплексов, использующих "
"пакетные фильтры для затопления сети — например, для тестирования устройств "
"под нагрузкой, подобно тому, как это делает pktgen — этот уровень можно не "
"задействовать, установив целочисленной параметр в 1. Побочным эффектом будет "
"отмена пакетной буферизации на уровне qdisc, что приведёт к увеличению "
"отброшенных пакетов при занятости передающих очередей сетевого устройства; "
"поэтому, пользуйтесь с осторожностью."

#. type: SS
#: man-pages/man7/packet.7:493
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#.  FIXME Document SIOCGSTAMPNS
#. type: Plain text
#: man-pages/man7/packet.7:500
msgid ""
"B<SIOCGSTAMP> can be used to receive the timestamp of the last received "
"packet.  Argument is a I<struct timeval> variable."
msgstr ""
"Вызов B<SIOCGSTAMP> можно использовать для получения метки времени "
"последнего полученного пакета. Аргументом является I<struct timeval>."

#. type: Plain text
#: man-pages/man7/packet.7:506
msgid ""
"In addition, all standard ioctls defined in B<netdevice>(7)  and "
"B<socket>(7)  are valid on packet sockets."
msgstr ""
"Также, для пакетных сокетов работают все стандартные ioctl, определённые в "
"B<netdevice>(7) и B<socket>(7)."

#. type: SS
#: man-pages/man7/packet.7:506
#, no-wrap
msgid "Error handling"
msgstr "Обработка ошибок"

#. type: Plain text
#: man-pages/man7/packet.7:510
msgid ""
"Packet sockets do no error handling other than errors occurred while passing "
"the packet to the device driver.  They don't have the concept of a pending "
"error."
msgstr ""
"Пакетные сокеты не выполняют обработку ошибок, кроме ошибок, которые "
"возникают при передаче пакета драйверу устройства. В них не заложен принцип "
"ожидания ошибки."

#. type: SH
#: man-pages/man7/packet.7:510
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/packet.7:511
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: man-pages/man7/packet.7:514
msgid "Unknown multicast group address passed."
msgstr "Передан неизвестный адрес групповой рассылки."

#. type: TP
#: man-pages/man7/packet.7:514
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man7/packet.7:517
msgid "User passed invalid memory address."
msgstr "Пользователь передал неправильный адрес памяти."

#. type: TP
#: man-pages/man7/packet.7:517
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/packet.7:520
msgid "Invalid argument."
msgstr "Неверный аргумент."

#. type: TP
#: man-pages/man7/packet.7:520
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man7/packet.7:523
msgid "Packet is bigger than interface MTU."
msgstr "Пакет больше, чем интерфейс MTU."

#. type: TP
#: man-pages/man7/packet.7:523
#, no-wrap
msgid "B<ENETDOWN>"
msgstr "B<ENETDOWN>"

#. type: Plain text
#: man-pages/man7/packet.7:526
msgid "Interface is not up."
msgstr "Интерфейс не поднят."

#. type: TP
#: man-pages/man7/packet.7:526
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: man-pages/man7/packet.7:529
msgid "Not enough memory to allocate the packet."
msgstr "Недостаточно памяти для размещения пакета."

#. type: TP
#: man-pages/man7/packet.7:529
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man7/packet.7:532
msgid "Unknown device name or interface index specified in interface address."
msgstr ""
"В адресе интерфейса указано неизвестное имя устройства или индекс интерфейса."

#. type: TP
#: man-pages/man7/packet.7:532
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man7/packet.7:535
msgid "No packet received."
msgstr "Пакет не принят."

#. type: TP
#: man-pages/man7/packet.7:535
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man7/packet.7:538
msgid "No interface address passed."
msgstr "Не передан адрес интерфейса."

#. type: TP
#: man-pages/man7/packet.7:538
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man7/packet.7:541
msgid "Interface address contained an invalid interface index."
msgstr "В адресе интерфейса содержится некорректный индекс интерфейса."

#. type: TP
#: man-pages/man7/packet.7:541
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man7/packet.7:544
msgid "User has insufficient privileges to carry out this operation."
msgstr "У пользователя недостаточно прав для выполнения этой операции."

#. type: Plain text
#: man-pages/man7/packet.7:546
msgid "In addition, other errors may be generated by the low-level driver."
msgstr "Также, драйвером низкого уровня могут генерироваться другие ошибки."

#. type: Plain text
#: man-pages/man7/packet.7:551
msgid ""
"B<AF_PACKET> is a new feature in Linux 2.2.  Earlier Linux versions "
"supported only B<SOCK_PACKET>."
msgstr ""
"B<AF_PACKET> появился в Linux 2.2. В ранних версиях Linux поддерживался "
"только B<SOCK_PACKET>."

#. type: Plain text
#: man-pages/man7/packet.7:560
msgid ""
"For portable programs it is suggested to use B<AF_PACKET> via B<pcap>(3); "
"although this covers only a subset of the B<AF_PACKET> features."
msgstr ""
"Для переносимых программ предлагается использовать B<AF_PACKET> в "
"B<pcap>(3), хотя это покрывает не весь набор возможностей B<AF_PACKET>."

#. type: Plain text
#: man-pages/man7/packet.7:581
msgid ""
"The B<SOCK_DGRAM> packet sockets make no attempt to create or parse the IEEE "
"802.2 LLC header for a IEEE 802.3 frame.  When B<ETH_P_802_3> is specified "
"as protocol for sending the kernel creates the 802.3 frame and fills out the "
"length field; the user has to supply the LLC header to get a fully "
"conforming packet.  Incoming 802.3 packets are not multiplexed on the DSAP/"
"SSAP protocol fields; instead they are supplied to the user as protocol "
"B<ETH_P_802_2> with the LLC header prefixed.  It is thus not possible to "
"bind to B<ETH_P_802_3>; bind to B<ETH_P_802_2> instead and do the protocol "
"multiplex yourself.  The default for sending is the standard Ethernet DIX "
"encapsulation with the protocol filled in."
msgstr ""
"Пакетные сокеты B<SOCK_DGRAM> не пытаются создать или разобрать заголовок "
"IEEE 802.2 LLC из кадров IEEE 802.3. Если для отправки в качестве протокола "
"указан B<ETH_P_802_3>, то ядро создаёт кадр 802.3 и заполняет поле длины; "
"пользователь передаёт заголовок LLC в пакете уже полностью заполненным. "
"Входящие пакеты 802.3 не уплотняются по полям протокола DSAP/SSAP; вместо "
"этого они передаются пользователю как протокол B<ETH_P_802_2> с начальным "
"заголовком LLC. То есть невозможно выполнить привязку к B<ETH_P_802_3>; "
"вместо этого выполняйте привязку к B<ETH_P_802_2> и выполняйте протокольное  "
"уплотнение самостоятельно. По умолчанию, отправка происходит в стандартной "
"упаковке Ethernet DIX с заполненным полем протокола."

#. type: Plain text
#: man-pages/man7/packet.7:583
msgid "Packet sockets are not subject to the input or output firewall chains."
msgstr ""
"Пакетные сокеты недоступны (not subject) во входной и выходной цепочках "
"межсетевого экрана."

#. type: SS
#: man-pages/man7/packet.7:583
#, no-wrap
msgid "Compatibility"
msgstr "Совместимость"

#. type: Plain text
#: man-pages/man7/packet.7:585
msgid "In Linux 2.0, the only way to get a packet socket was with the call:"
msgstr ""
"В Linux 2.0 единственным способом получить пакетный сокет является вызов:"

#. type: Plain text
#: man-pages/man7/packet.7:587
#, no-wrap
msgid "    socket(AF_INET, SOCK_PACKET, protocol)\n"
msgstr "    socket(AF_INET, SOCK_PACKET, протокол)\n"

#. type: Plain text
#: man-pages/man7/packet.7:595
msgid ""
"This is still supported, but deprecated and strongly discouraged.  The main "
"difference between the two methods is that B<SOCK_PACKET> uses the old "
"I<struct sockaddr_pkt> to specify an interface, which doesn't provide "
"physical-layer independence."
msgstr ""
"Он всё ещё поддерживается, но устарел и настоятельно не рекомендуется. "
"Основным отличием между методами — для указания интерфейса через "
"B<SOCK_PACKET> используется старая I<struct sockaddr_pkt>, которая не "
"предоставляет независимого физического уровня."

#. type: Plain text
#: man-pages/man7/packet.7:603
#, no-wrap
msgid ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"
msgstr ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/packet.7:615
msgid ""
"I<spkt_family> contains the device type, I<spkt_protocol> is the IEEE 802.3 "
"protocol type as defined in I<E<lt>sys/if_ether.hE<gt>> and I<spkt_device> "
"is the device name as a null-terminated string, for example, eth0."
msgstr ""
"В I<spkt_family> содержится тип устройства, в I<spkt_protocol> — тип "
"протокола IEEE 802.3, определённый в I<E<lt>sys/if_ether.hE<gt>>, а в "
"I<spkt_device> — имя устройства в виде строки с null в конце, например, eth0."

#. type: Plain text
#: man-pages/man7/packet.7:617
msgid "This structure is obsolete and should not be used in new code."
msgstr "Эта структура устарела и не должна использоваться в новом коде."

#. type: Plain text
#: man-pages/man7/packet.7:619
msgid "The IEEE 802.2/803.3 LLC handling could be considered as a bug."
msgstr "Способ обработки IEEE 802.2/803.3 LLC не считается за дефектный."

#. type: Plain text
#: man-pages/man7/packet.7:621
msgid "Socket filters are not documented."
msgstr "Не описаны сокетные фильтры."

#.  .SH CREDITS
#.  This man page was written by Andi Kleen with help from Matthew Wilcox.
#.  AF_PACKET in Linux 2.2 was implemented
#.  by Alexey Kuznetsov, based on code by Alan Cox and others.
#. type: Plain text
#: man-pages/man7/packet.7:633
msgid ""
"The B<MSG_TRUNC> B<recvmsg>(2)  extension is an ugly hack and should be "
"replaced by a control message.  There is currently no way to get the "
"original destination address of packets via B<SOCK_DGRAM>."
msgstr ""
"Расширение B<MSG_TRUNC> B<recvmsg>(2) является неудачным решением и должно "
"быть заменено на управляющее сообщение. Пока нет способа получить "
"первоначальный адрес назначения пакетов через B<SOCK_DGRAM>."

#. type: Plain text
#: man-pages/man7/packet.7:640
msgid ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"
msgstr ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"

#. type: Plain text
#: man-pages/man7/packet.7:643
msgid ""
"RFC\\ 894 for the standard IP Ethernet encapsulation.  RFC\\ 1700 for the "
"IEEE 802.3 IP encapsulation."
msgstr ""
"В RFC\\ 894 описана упаковка стандартного IP Ethernet. В RFC\\ 1700 описана "
"упаковка IP IEEE 802.3."

#. type: Plain text
#: man-pages/man7/packet.7:647
msgid ""
"The I<E<lt>linux/if_ether.hE<gt>> include file for physical-layer protocols."
msgstr ""
"Заголовочный файл I<E<lt>linux/if_ether.hE<gt>> содержит протоколы "
"физического уровня."

#. type: Plain text
#: man-pages/man7/packet.7:655
msgid ""
"The Linux kernel source tree.  I</Documentation/networking/filter.txt> "
"describes how to apply Berkeley Packet Filters to packet sockets.  I</tools/"
"testing/selftests/net/psock_tpacket.c> contains example source code for all "
"available versions of B<PACKET_RX_RING> and B<PACKET_TX_RING>."
msgstr ""
"Дерево исходного кода ядра Linux. В I</Documentation/networking/filter.txt> "
"описано как к пакетным сокетам применять Berkeley Packet Filters. В I</tools/"
"testing/selftests/net/psock_tpacket.c> содержится пример исходного кода для "
"всех доступных версий B<PACKET_RX_RING> и B<PACKET_TX_RING>."

#. type: TH
#: man-pages/man7/pthreads.7:26
#, no-wrap
msgid "PTHREADS"
msgstr "PTHREADS"

#. type: Plain text
#: man-pages/man7/pthreads.7:29
msgid "pthreads - POSIX threads"
msgstr "pthreads - нити POSIX"

#. type: Plain text
#: man-pages/man7/pthreads.7:36
msgid ""
"POSIX.1 specifies a set of interfaces (functions, header files) for threaded "
"programming commonly known as POSIX threads, or Pthreads.  A single process "
"can contain multiple threads, all of which are executing the same program.  "
"These threads share the same global memory (data and heap segments), but "
"each thread has its own stack (automatic variables)."
msgstr ""
"В POSIX.1 определён набор интерфейсов (функции, заголовочные файлы) для "
"работы с нитями, более известными как нити POSIX или Pthreads. В одном "
"процессе может быть несколько нитей, которые выполняют одну программу. Эти "
"нити работают с общей глобальной памятью (сегментами данных и кучи), но у "
"каждой нити есть собственный стек (автоматические переменные)."

#. type: Plain text
#: man-pages/man7/pthreads.7:39
msgid ""
"POSIX.1 also requires that threads share a range of other attributes (i.e., "
"these attributes are process-wide rather than per-thread):"
msgstr ""
"Также, в POSIX.1 требуется, чтобы нити имели общий диапазон других атрибутов "
"(т. е., эти атрибуты процесса, а не нити):"

#. type: IP
#: man-pages/man7/pthreads.7:39 man-pages/man7/pthreads.7:41
#: man-pages/man7/pthreads.7:43 man-pages/man7/pthreads.7:45
#: man-pages/man7/pthreads.7:47 man-pages/man7/pthreads.7:49
#: man-pages/man7/pthreads.7:51 man-pages/man7/pthreads.7:54
#: man-pages/man7/pthreads.7:56 man-pages/man7/pthreads.7:59
#: man-pages/man7/pthreads.7:65 man-pages/man7/pthreads.7:70
#: man-pages/man7/pthreads.7:73 man-pages/man7/pthreads.7:76
#: man-pages/man7/pthreads.7:84 man-pages/man7/pthreads.7:88
#: man-pages/man7/pthreads.7:91 man-pages/man7/pthreads.7:95
#: man-pages/man7/pthreads.7:98 man-pages/man7/pthreads.7:103
#: man-pages/man7/pthreads.7:106 man-pages/man7/pthreads.7:687
#: man-pages/man7/pthreads.7:694 man-pages/man7/pthreads.7:706
#: man-pages/man7/pthreads.7:716 man-pages/man7/pthreads.7:720
#: man-pages/man7/pthreads.7:729 man-pages/man7/pthreads.7:739
#: man-pages/man7/pthreads.7:746 man-pages/man7/pthreads.7:753
#: man-pages/man7/pthreads.7:755 man-pages/man7/pthreads.7:758
#: man-pages/man7/pthreads.7:764 man-pages/man7/pthreads.7:767
#: man-pages/man7/pthreads.7:769 man-pages/man7/pthreads.7:771
#: man-pages/man7/pthreads.7:781 man-pages/man7/pthreads.7:803
#: man-pages/man7/pthreads.7:812 man-pages/man7/pthreads.7:818
#: man-pages/man7/pthreads.7:820 man-pages/man7/pthreads.7:822
#: man-pages/man7/pthreads.7:826 man-pages/man7/pthreads.7:831
#: man-pages/man7/pthreads.7:839
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: man-pages/man7/pthreads.7:41
msgid "process ID"
msgstr "идентификатор процесса"

#. type: Plain text
#: man-pages/man7/pthreads.7:43
msgid "parent process ID"
msgstr "идентификатор родительского процесса"

#. type: Plain text
#: man-pages/man7/pthreads.7:45
msgid "process group ID and session ID"
msgstr "Идентификатор группы процессов и сеанса"

#. type: Plain text
#: man-pages/man7/pthreads.7:47
msgid "controlling terminal"
msgstr "Управляющий терминал"

#. type: Plain text
#: man-pages/man7/pthreads.7:49
msgid "user and group IDs"
msgstr "Идентификаторы пользователя и группы"

#. type: Plain text
#: man-pages/man7/pthreads.7:51
msgid "open file descriptors"
msgstr "Открытые файловые дескрипторы"

#. type: Plain text
#: man-pages/man7/pthreads.7:54
msgid "record locks (see B<fcntl>(2))"
msgstr "Обычные блокировки (смотрите B<fcntl>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:56
msgid "signal dispositions"
msgstr "Обработчики сигналов"

#. type: Plain text
#: man-pages/man7/pthreads.7:59
msgid "file mode creation mask (B<umask>(2))"
msgstr "Маска создания режима доступа к файлу (B<umask>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:65
msgid "current directory (B<chdir>(2))  and root directory (B<chroot>(2))"
msgstr "Текущий каталог (B<chdir>(2)) и корневой каталог (B<chroot>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:70
msgid ""
"interval timers (B<setitimer>(2))  and POSIX timers (B<timer_create>(2))"
msgstr ""
"Интервальные таймеры (B<setitimer>(2)) и таймеры POSIX (B<timer_create>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:73
msgid "nice value (B<setpriority>(2))"
msgstr "Значение уступчивости (B<setpriority>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:76
msgid "resource limits (B<setrlimit>(2))"
msgstr "Ограничения по ресурсам (B<setrlimit>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:81
msgid ""
"measurements of the consumption of CPU time (B<times>(2))  and resources "
"(B<getrusage>(2))"
msgstr ""
"Измерители потребления времени ЦП (B<times>(2)) и ресурсов (B<getrusage>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:84
msgid ""
"As well as the stack, POSIX.1 specifies that various other attributes are "
"distinct for each thread, including:"
msgstr ""
"Как и для стека, в POSIX.1 определены другие атрибуты, которые уникальны в "
"каждой нити:"

#. type: Plain text
#: man-pages/man7/pthreads.7:88
msgid "thread ID (the I<pthread_t> data type)"
msgstr "Идентификатор нити (тип данных I<pthread_t>)"

#. type: Plain text
#: man-pages/man7/pthreads.7:91
msgid "signal mask (B<pthread_sigmask>(3))"
msgstr "Маска сигналов (B<pthread_sigmask>(3))"

#. type: Plain text
#: man-pages/man7/pthreads.7:95
msgid "the I<errno> variable"
msgstr "Переменная I<errno>"

#. type: Plain text
#: man-pages/man7/pthreads.7:98
msgid "alternate signal stack (B<sigaltstack>(2))"
msgstr "Альтернативный стек сигнала (B<sigaltstack>(2))"

#. type: Plain text
#: man-pages/man7/pthreads.7:101
msgid "real-time scheduling policy and priority (B<sched>(7))"
msgstr "Алгоритм и приоритет планирования реального времени (B<sched>(7))"

#. type: Plain text
#: man-pages/man7/pthreads.7:103
msgid "The following Linux-specific features are also per-thread:"
msgstr ""
"Следующие свойства есть только в Linux и также уникальны в каждой нити:"

#. type: Plain text
#: man-pages/man7/pthreads.7:106
msgid "capabilities (see B<capabilities>(7))"
msgstr "мандаты (смотрите B<capabilities>(7))"

#. type: Plain text
#: man-pages/man7/pthreads.7:109
msgid "CPU affinity (B<sched_setaffinity>(2))"
msgstr "Привязка к ЦП (B<sched_setaffinity>(2))"

#. type: SS
#: man-pages/man7/pthreads.7:109
#, no-wrap
msgid "Pthreads function return values"
msgstr "Возвращаемые значения из функций pthreads"

#. type: Plain text
#: man-pages/man7/pthreads.7:116
msgid ""
"Most pthreads functions return 0 on success, and an error number on "
"failure.  Note that the pthreads functions do not set I<errno>.  For each of "
"the pthreads functions that can return an error, POSIX.1-2001 specifies that "
"the function can never fail with the error B<EINTR>."
msgstr ""
"Большинство функций pthreads при успешном выполнении возвращает 0 или номер "
"ошибки в противном случае. Заметим, что функции pthreads не изменяют "
"I<errno>. Для каждой функции pthreads, которая может вернуть ошибку, в "
"POSIX.1-2001 определено, что функция никогда не может завершиться с ошибкой "
"B<EINTR>."

#. type: SS
#: man-pages/man7/pthreads.7:116
#, no-wrap
msgid "Thread IDs"
msgstr "Идентификатор нити"

#. type: Plain text
#: man-pages/man7/pthreads.7:124
msgid ""
"Each of the threads in a process has a unique thread identifier (stored in "
"the type I<pthread_t>).  This identifier is returned to the caller of "
"B<pthread_create>(3), and a thread can obtain its own thread identifier "
"using B<pthread_self>(3)."
msgstr ""
"Каждой нити процесса назначается уникальный идентификатор нити (имеет тип "
"I<pthread_t>). Этот идентификатор возвращается вызывающему "
"B<pthread_create>(3), а в самой нити её идентификатор можно получить с "
"помощью B<pthread_self>(3)."

#. type: Plain text
#: man-pages/man7/pthreads.7:129
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  (In all "
"pthreads functions that accept a thread ID as an argument, that ID by "
"definition refers to a thread in the same process as the caller.)"
msgstr ""
"Внутри процесса гарантируется уникальность идентификаторов нитей (во всех "
"функциях pthreads, которые принимают аргумент идентификатора нити, "
"подразумевается, что указана нить из процесса вызывающего)."

#. type: Plain text
#: man-pages/man7/pthreads.7:134
msgid ""
"The system may reuse a thread ID after a terminated thread has been joined, "
"or a detached thread has terminated.  POSIX says: \"If an application "
"attempts to use a thread ID whose lifetime has ended, the behavior is "
"undefined.\""
msgstr ""
"Система может повторно использовать идентификатор нити после объединения "
"завершённой нити или отсоединения завершённой нити. В POSIX сказано: «Если "
"приложение пытается использовать идентификатор нити, у который закончился "
"срок жизни, то поведение не предсказуемо»."

#. type: SS
#: man-pages/man7/pthreads.7:134
#, no-wrap
msgid "Thread-safe functions"
msgstr "Нитебезопасные функции"

#. type: Plain text
#: man-pages/man7/pthreads.7:138
msgid ""
"A thread-safe function is one that can be safely (i.e., it will deliver the "
"same results regardless of whether it is)  called from multiple threads at "
"the same time."
msgstr ""
"Нитебезопасная функция — это функция, которую можно безопасно (т. е., это "
"приведёт к единым результатам независимо от окружения) вызывать из "
"нескольких нитей одновременно."

#. type: Plain text
#: man-pages/man7/pthreads.7:142
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that all functions specified in the "
"standard shall be thread-safe, except for the following functions:"
msgstr ""
"В POSIX.1-2001 и POSIX.1-2008 требуется, чтобы все функции, описанные в "
"стандарте, были нитебезопасными, за исключением следующих функций:"

#. type: Plain text
#: man-pages/man7/pthreads.7:236
#, no-wrap
msgid ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() if passed a non-NULL argument\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [Added in POSIX.1-2008]\n"
"strtok()\n"
"system() [Added in POSIX.1-2008]\n"
"tmpnam() if passed a non-NULL argument\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() if its final argument is NULL\n"
"wcsrtombs() if its final argument is NULL\n"
"wcstombs()\n"
"wctomb()\n"
msgstr ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() если передаётся аргумент не NULL\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [только POSIX.1-2001 (удалена из POSIX.1-2008)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [только POSIX.1-2001 (удалена из POSIX.1-2008)]\n"
"ftw()\n"
"gcvt() [только POSIX.1-2001 (удалена из POSIX.1-2008)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [только POSIX.1-2001 (удалена из POSIX.1-2008)]\n"
"gethostbyname() [только POSIX.1-2001 (удалена из POSIX.1-2008)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [добавлена в POSIX.1-2008]\n"
"strtok()\n"
"system() [добавлена в POSIX.1-2008]\n"
"tmpnam() если передаётся аргумент не NULL\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() если конечный аргумент NULL\n"
"wcsrtombs() если конечный аргумент NULL\n"
"wcstombs()\n"
"wctomb()\n"

#. type: SS
#: man-pages/man7/pthreads.7:238
#, no-wrap
msgid "Async-cancel-safe functions"
msgstr "Безопасные асинхронные отменяемые функции"

#. type: Plain text
#: man-pages/man7/pthreads.7:242
msgid ""
"An async-cancel-safe function is one that can be safely called in an "
"application where asynchronous cancelability is enabled (see "
"B<pthread_setcancelstate>(3))."
msgstr ""
"Безопасная асинхронная отменяемая функция (async-cancel-safe function) — это "
"функция, которую можно безопасно вызывать в приложении, в котором разрешено "
"асинхронная отмена (смотрите B<pthread_setcancelstate>(3))."

#. type: Plain text
#: man-pages/man7/pthreads.7:245
msgid ""
"Only the following functions are required to be async-cancel-safe by "
"POSIX.1-2001 and POSIX.1-2008:"
msgstr ""
"Согласно POSIX.1-2001 и POSIX.1-2008 только следующие функции должны быть "
"безопасными асинхронными отменяемыми:"

#. type: Plain text
#: man-pages/man7/pthreads.7:251
#, no-wrap
msgid ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"
msgstr ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"

#. type: SS
#: man-pages/man7/pthreads.7:253
#, no-wrap
msgid "Cancellation points"
msgstr "Точки отмены"

#. type: Plain text
#: man-pages/man7/pthreads.7:260
msgid ""
"POSIX.1 specifies that certain functions must, and certain other functions "
"may, be cancellation points.  If a thread is cancelable, its cancelability "
"type is deferred, and a cancellation request is pending for the thread, then "
"the thread is canceled when it calls a function that is a cancellation point."
msgstr ""
"В POSIX.1 определено, что некоторые функции должны, а несколько других могут "
"было точками отмены. Если нить отменяема, её тип отменяемости откладывается, "
"и ожидается запрос отмены нити, затем нить отменяется, когда она вызывает "
"функцию, которая является точкой отмены."

#. type: Plain text
#: man-pages/man7/pthreads.7:263
msgid ""
"The following functions are required to be cancellation points by "
"POSIX.1-2001 and/or POSIX.1-2008:"
msgstr ""
"Следующие функции должны быть точками отмены согласно POSIX.1-2001 и/или "
"POSIX.1-2008:"

#. type: Plain text
#: man-pages/man7/pthreads.7:326
#, no-wrap
msgid ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [Added in POSIX.1-2008]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"
msgstr ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [добавлена в POSIX.1-2008]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [только POSIX.1-2001 (перемещена в список «может» в POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [только POSIX.1-2001 (функция удалена в POSIX.1-2008)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"

#. type: Plain text
#: man-pages/man7/pthreads.7:331
msgid ""
"The following functions may be cancellation points according to POSIX.1-2001 "
"and/or POSIX.1-2008:"
msgstr ""
"Следующие функции могут быть точками отмены согласно POSIX.1-2001 и/или "
"POSIX.1-2008:"

#. type: Plain text
#: man-pages/man7/pthreads.7:559
#, no-wrap
msgid ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [Added in POSIX.1-2008]\n"
"chown() [Added in POSIX.1-2008]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [Added in POSIX.1-2008]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [Added in POSIX.1-2008]\n"
"fchmod() [Added in POSIX.1-2008]\n"
"fchmodat() [Added in POSIX.1-2008]\n"
"fchown() [Added in POSIX.1-2008]\n"
"fchownat() [Added in POSIX.1-2008]\n"
"fclose()\n"
"fcntl() (for any value of cmd argument)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [Added in POSIX.1-2008]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [Added in POSIX.1-2008]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [Added in POSIX.1-2008]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"gethostbyname() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [Added in POSIX.1-2008]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (if opterr is nonzero)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [Added in POSIX.1-2008]\n"
"lio_listio() [Added in POSIX.1-2008]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [Added in POSIX.1-2008]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [Added in POSIX.1-2008]\n"
"mkdirat() [Added in POSIX.1-2008]\n"
"mkdtemp() [Added in POSIX.1-2008]\n"
"mkfifo() [Added in POSIX.1-2008]\n"
"mkfifoat() [Added in POSIX.1-2008]\n"
"mknod() [Added in POSIX.1-2008]\n"
"mknodat() [Added in POSIX.1-2008]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [Added in POSIX.1-2008]\n"
"psignal() [Added in POSIX.1-2008]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [Added in POSIX.1-2008]\n"
"readlinkat() [Added in POSIX.1-2008]\n"
"remove()\n"
"rename()\n"
"renameat() [Added in POSIX.1-2008]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [Added in POSIX.1-2008]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [Added in POSIX.1-2008]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [Added in POSIX.1-2008]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [Added in POSIX.1-2008]\n"
"utime() [Added in POSIX.1-2008]\n"
"utimensat() [Added in POSIX.1-2008]\n"
"utimes() [Added in POSIX.1-2008]\n"
"vdprintf() [Added in POSIX.1-2008]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"
msgstr ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [добавлена в POSIX.1-2008]\n"
"chown() [добавлена в POSIX.1-2008]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [добавлена в POSIX.1-2008]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [добавлена в POSIX.1-2008]\n"
"fchmod() [добавлена в POSIX.1-2008]\n"
"fchmodat() [добавлена в POSIX.1-2008]\n"
"fchown() [добавлена в POSIX.1-2008]\n"
"fchownat() [Added in POSIX.1-2008]\n"
"fclose()\n"
"fcntl() (для любого значения аргумента cmd)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [добавлена в POSIX.1-2008]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [добавлена в POSIX.1-2008]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [добавлена в POSIX.1-2008]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [только SUSv3 (функция удалена из POSIX.1-2008)]\n"
"gethostbyname() [только SUSv3 (функция удалена из POSIX.1-2008)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [добавлена в POSIX.1-2008]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (если opterr не равно 0)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [только SUSv3 (функция удалена из POSIX.1-2008)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [добавлена в POSIX.1-2008]\n"
"lio_listio() [добавлена в POSIX.1-2008]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [добавлена в POSIX.1-2008]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [добавлена в POSIX.1-2008]\n"
"mkdirat() [добавлена в POSIX.1-2008]\n"
"mkdtemp() [добавлена в POSIX.1-2008]\n"
"mkfifo() [добавлена в POSIX.1-2008]\n"
"mkfifoat() [добавлена в POSIX.1-2008]\n"
"mknod() [добавлена в POSIX.1-2008]\n"
"mknodat() [добавлена в POSIX.1-2008]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [добавлена в POSIX.1-2008]\n"
"psignal() [добавлена в POSIX.1-2008]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [добавлена в POSIX.1-2008]\n"
"readlinkat() [добавлена в POSIX.1-2008]\n"
"remove()\n"
"rename()\n"
"renameat() [добавлена в POSIX.1-2008]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [добавлена в POSIX.1-2008]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [добавлена в POSIX.1-2008]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [добавлена в POSIX.1-2008]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [добавлена в POSIX.1-2008]\n"
"utime() [добавлена в POSIX.1-2008]\n"
"utimensat() [добавлена в POSIX.1-2008]\n"
"utimes() [добавлена в POSIX.1-2008]\n"
"vdprintf() [добавлена в POSIX.1-2008]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"

#.  So, scanning "cancellation point" comments in the glibc 2.8 header
#.  files, it looks as though at least the following nonstandard
#.  functions are cancellation points:
#.  endnetgrent
#.  endspent
#.  epoll_pwait
#.  epoll_wait
#.  fcloseall
#.  fdopendir
#.  fflush_unlocked
#.  fgetc_unlocked
#.  fgetgrent
#.  fgetgrent_r
#.  fgetpwent
#.  fgetpwent_r
#.  fgets_unlocked
#.  fgetspent
#.  fgetspent_r
#.  fgetwc_unlocked
#.  fgetws_unlocked
#.  fputc_unlocked
#.  fputs_unlocked
#.  fputwc_unlocked
#.  fputws_unlocked
#.  fread_unlocked
#.  fwrite_unlocked
#.  gai_suspend
#.  getaddrinfo_a
#.  getdate_r
#.  getgrent_r
#.  getgrouplist
#.  gethostbyaddr_r
#.  gethostbyname2
#.  gethostbyname2_r
#.  gethostbyname_r
#.  gethostent_r
#.  getnetbyaddr_r
#.  getnetbyname_r
#.  getnetent_r
#.  getnetgrent
#.  getnetgrent_r
#.  getprotobyname_r
#.  getprotobynumber_r
#.  getprotoent_r
#.  getpw
#.  getpwent_r
#.  getservbyname_r
#.  getservbyport_r
#.  getservent_r
#.  getspent
#.  getspent_r
#.  getspnam
#.  getspnam_r
#.  getutmp
#.  getutmpx
#.  getw
#.  getwc_unlocked
#.  getwchar_unlocked
#.  initgroups
#.  innetgr
#.  mkostemp
#.  mkostemp64
#.  mkstemp64
#.  ppoll
#.  pthread_timedjoin_np
#.  putgrent
#.  putpwent
#.  putspent
#.  putw
#.  putwc_unlocked
#.  putwchar_unlocked
#.  rcmd
#.  rcmd_af
#.  rexec
#.  rexec_af
#.  rresvport
#.  rresvport_af
#.  ruserok
#.  ruserok_af
#.  setnetgrent
#.  setspent
#.  sgetspent
#.  sgetspent_r
#.  updwtmpx
#.  utmpxname
#.  vfscanf
#.  vfwscanf
#.  vscanf
#.  vsyslog
#.  vwscanf
#. type: Plain text
#: man-pages/man7/pthreads.7:657
msgid ""
"An implementation may also mark other functions not specified in the "
"standard as cancellation points.  In particular, an implementation is likely "
"to mark any nonstandard function that may block as a cancellation point.  "
"(This includes most functions that can touch files.)"
msgstr ""
"Реализация также может помечать другие функции, не указанные в стандарте, "
"как точки отмены. В частности, реализация, вероятно, пометит как точку "
"отмены любую нестандартную функцию, которая может блокироваться (большинство "
"функций, работающих с файлами)."

#. type: SS
#: man-pages/man7/pthreads.7:657
#, no-wrap
msgid "Compiling on Linux"
msgstr "Компиляция в Linux"

#. type: Plain text
#: man-pages/man7/pthreads.7:660
msgid ""
"On Linux, programs that use the Pthreads API should be compiled using I<cc -"
"pthread>."
msgstr ""
"В Linux, программы, использующие программный интерфейс pthreads, должны "
"компилироваться с помощью I<cc -pthread>."

#. type: SS
#: man-pages/man7/pthreads.7:660
#, no-wrap
msgid "Linux implementations of POSIX threads"
msgstr "Реализации нитей POSIX в Linux"

#. type: Plain text
#: man-pages/man7/pthreads.7:663
msgid ""
"Over time, two threading implementations have been provided by the GNU C "
"library on Linux:"
msgstr "За всё время в библиотеке GNU C было две реализации нитей для Linux:"

#. type: TP
#: man-pages/man7/pthreads.7:663
#, no-wrap
msgid "B<LinuxThreads>"
msgstr "B<LinuxThreads>"

#. type: Plain text
#: man-pages/man7/pthreads.7:667
msgid ""
"This is the original Pthreads implementation.  Since glibc 2.4, this "
"implementation is no longer supported."
msgstr ""
"Первоначальная реализация pthreads. Начиная с glibc 2.4 эта реализация "
"больше не поддерживается."

#. type: TP
#: man-pages/man7/pthreads.7:667
#, no-wrap
msgid "B<NPTL> (Native POSIX Threads Library)"
msgstr "B<NPTL> (библиотека нитей POSIX)"

#. type: Plain text
#: man-pages/man7/pthreads.7:675
msgid ""
"This is the modern Pthreads implementation.  By comparison with "
"LinuxThreads, NPTL provides closer conformance to the requirements of the "
"POSIX.1 specification and better performance when creating large numbers of "
"threads.  NPTL is available since glibc 2.3.2, and requires features that "
"are present in the Linux 2.6 kernel."
msgstr ""
"Современная реализация pthreads. По сравнению с LinuxThreads, NPTL более "
"точно соответствует требованиям POSIX.1 и более производительна при создании "
"большого количества нитей. NPTL появилась в glibc начиная с версии 2.3.2, и "
"требует свойства, появившиеся в ядре Linux 2.6."

#. type: Plain text
#: man-pages/man7/pthreads.7:685
msgid ""
"Both of these are so-called 1:1 implementations, meaning that each thread "
"maps to a kernel scheduling entity.  Both threading implementations employ "
"the Linux B<clone>(2)  system call.  In NPTL, thread synchronization "
"primitives (mutexes, thread joining, and so on) are implemented using the "
"Linux B<futex>(2)  system call."
msgstr ""
"Обе реализации являются, так называемыми реализациями 1:1, то есть каждая "
"нить отображается в планируемый элемента ядра. Обе реализации используют "
"системный вызов Linux B<clone>(2). В NPTL примитивы синхронизации нитей "
"(мьютексы, объединение нитей и т .п.) реализованы с помощью системного "
"вызова Linux B<futex>(2)."

#. type: SS
#: man-pages/man7/pthreads.7:685
#, no-wrap
msgid "LinuxThreads"
msgstr "LinuxThreads"

#. type: Plain text
#: man-pages/man7/pthreads.7:687
msgid "The notable features of this implementation are the following:"
msgstr "Отличительные свойства данной реализации:"

#. type: Plain text
#: man-pages/man7/pthreads.7:694
msgid ""
"In addition to the main (initial) thread, and the threads that the program "
"creates using B<pthread_create>(3), the implementation creates a \"manager\" "
"thread.  This thread handles thread creation and termination.  (Problems can "
"result if this thread is inadvertently killed.)"
msgstr ""
"В дополнении к главной (начальной) нити, нити программы создаются с помощью "
"B<pthread_create>(3), реализация создаёт «управляющую» нить. Эта нить "
"выполняет создание и завершение нитей (что приводит к проблемам, если эта "
"нить случайно завершится)."

#. type: Plain text
#: man-pages/man7/pthreads.7:706
msgid ""
"Signals are used internally by the implementation.  On Linux 2.2 and later, "
"the first three real-time signals are used (see also B<signal>(7)).  On "
"older Linux kernels, B<SIGUSR1> and B<SIGUSR2> are used.  Applications must "
"avoid the use of whichever set of signals is employed by the implementation."
msgstr ""
"Внутри реализации используются сигналы. В Linux 2.2 и новее используются "
"первые три сигнала реального времени (смотрите также B<signal>(7)). В старых "
"ядрах Linux используются сигналы B<SIGUSR1> и B<SIGUSR2>. В приложениях "
"нельзя использовать набор сигналов, задействованный в реализации."

#. type: Plain text
#: man-pages/man7/pthreads.7:713
msgid ""
"Threads do not share process IDs.  (In effect, LinuxThreads threads are "
"implemented as processes which share more information than usual, but which "
"do not share a common process ID.)  LinuxThreads threads (including the "
"manager thread)  are visible as separate processes using B<ps>(1)."
msgstr ""
"У нитей разные ID процесса (фактически, нити LinuxThreads реализованы как "
"процессы, у которых больше общей информации чем обычно, но которые имеют "
"разный идентификаторы процесса). Нити LinuxThreads (включая управляющую "
"нить) в B<ps>(1) видимы как отдельные процессы."

#. type: Plain text
#: man-pages/man7/pthreads.7:716
msgid ""
"The LinuxThreads implementation deviates from the POSIX.1 specification in a "
"number of ways, including the following:"
msgstr ""
"Реализация LinuxThreads отклоняется от спецификации POSIX.1 в нескольких "
"местах, а именно:"

#. type: Plain text
#: man-pages/man7/pthreads.7:720
msgid "Calls to B<getpid>(2)  return a different value in each thread."
msgstr "Вызов B<getpid>(2) возвращает разные значения для каждой нити."

#. type: Plain text
#: man-pages/man7/pthreads.7:729
msgid ""
"Calls to B<getppid>(2)  in threads other than the main thread return the "
"process ID of the manager thread; instead B<getppid>(2)  in these threads "
"should return the same value as B<getppid>(2)  in the main thread."
msgstr ""
"Вызов B<getppid>(2) в нитях, кроме главной, возвращает идентификатор "
"процесса управляющей нити; вместо B<getppid>(2) в этих нитях будет "
"возвращаться тоже значение, что и из B<getppid>(2) в главной нити."

#. type: Plain text
#: man-pages/man7/pthreads.7:739
msgid ""
"When one thread creates a new child process using B<fork>(2), any thread "
"should be able to B<wait>(2)  on the child.  However, the implementation "
"allows only the thread that created the child to B<wait>(2)  on it."
msgstr ""
"Когда нить создаёт новый процесс-потомок с помощью B<fork>(2), все нити "
"должны ожидать потомка в B<wait>(2). Однако реализация позволяет вызвать "
"B<wait>(2) только в нити, которая создала потомка."

#. type: Plain text
#: man-pages/man7/pthreads.7:746
msgid ""
"When a thread calls B<execve>(2), all other threads are terminated (as "
"required by POSIX.1).  However, the resulting process has the same PID as "
"the thread that called B<execve>(2): it should have the same PID as the main "
"thread."
msgstr ""
"Когда нить вызывает B<execve>(2), остальные нити завершают работу "
"(требование POSIX.1). Однако, получаемый процесс имеет тот же PID, что и "
"нить, которая вызвала B<execve>(2): это должен быть тот же PID, что и у "
"главной нити."

#. type: Plain text
#: man-pages/man7/pthreads.7:753
msgid ""
"Threads do not share user and group IDs.  This can cause complications with "
"set-user-ID programs and can cause failures in Pthreads functions if an "
"application changes its credentials using B<seteuid>(2)  or similar."
msgstr ""
"У нитей разные ID пользователя и группы. Это может вызвать сложности в "
"программах с set-user-ID и может привести к ошибкам функций pthreads, если "
"приложение изменяет свои учётные данные с помощью B<seteuid>(2) и подобных "
"вызовов."

#. type: Plain text
#: man-pages/man7/pthreads.7:755
msgid "Threads do not share a common session ID and process group ID."
msgstr "У нитей разные ID сеанса и группы процессов."

#. type: Plain text
#: man-pages/man7/pthreads.7:758
msgid "Threads do not share record locks created using B<fcntl>(2)."
msgstr "У нитей разные записи о блокировках, созданных B<fcntl>(2)."

#. type: Plain text
#: man-pages/man7/pthreads.7:764
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide."
msgstr ""
"Информация, возвращаемая B<times>(2) и B<getrusage>(2), относится только к "
"нити, а не к процессу в целом."

#. type: Plain text
#: man-pages/man7/pthreads.7:767
msgid "Threads do not share semaphore undo values (see B<semop>(2))."
msgstr "У нитей разные значения отмен семафоров (смотрите B<semop>(2))."

#. type: Plain text
#: man-pages/man7/pthreads.7:769
msgid "Threads do not share interval timers."
msgstr "У нитей разные интервалы таймеров."

#.  FIXME . bug report filed for NPTL nice nonconformance
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6258
#.  Sep 08: there is a patch by Denys Vlasenko to address this
#.  "make setpriority POSIX compliant; introduce PRIO_THREAD extension"
#.  Monitor this to see if it makes it into mainline.
#. type: Plain text
#: man-pages/man7/pthreads.7:771 man-pages/man7/pthreads.7:810
msgid "Threads do not share a common nice value."
msgstr "У нитей разные значения уступчивости."

#. type: Plain text
#: man-pages/man7/pthreads.7:781
msgid ""
"POSIX.1 distinguishes the notions of signals that are directed to the "
"process as a whole and signals that are directed to individual threads.  "
"According to POSIX.1, a process-directed signal (sent using B<kill>(2), for "
"example) should be handled by a single, arbitrarily selected thread within "
"the process.  LinuxThreads does not support the notion of process-directed "
"signals: signals may be sent only to specific threads."
msgstr ""
"В POSIX.1 различаются сигналы, адресованные процессу в целом и отдельным "
"нитям. Согласно POSIX.1, сигналы, направленные процессу (посланные, "
"например, с помощью B<kill>(2)), должны обрабатываться одной произвольно "
"выбранной нитью внутри процесса. LinuxThreads не поддерживает сигналы, "
"направленные процессу: сигналы могут посылаться только определённым нитям."

#. type: Plain text
#: man-pages/man7/pthreads.7:790
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack.  "
"(A new thread should start with no alternate signal stack defined.  If two "
"threads handle signals on their shared alternate signal stack at the same "
"time, unpredictable program failures are likely to occur.)"
msgstr ""
"Нити имеют разные настройки альтернативного стека сигналов. Однако, новые "
"настройки альтернативного стека сигналов копируются из нити, которая его "
"создаёт, так что изначально нити имеют единый альтернативный стек сигналов "
"(новая нить должна запускаться без альтернативного стека сигналов. Если две "
"нити обрабатывают сигналы в едином альтернативном стеке сигналов "
"одновременно, то в программе возникнет непредсказуемая ошибка)."

#. type: SS
#: man-pages/man7/pthreads.7:790
#, no-wrap
msgid "NPTL"
msgstr "NPTL"

#. type: Plain text
#: man-pages/man7/pthreads.7:795
msgid ""
"With NPTL, all of the threads in a process are placed in the same thread "
"group; all members of a thread group share the same PID.  NPTL does not "
"employ a manager thread."
msgstr ""
"В NPTL все нити процесса помещаются в одну группу нитей; все члены группы "
"нитей имеют один PID. В NPTL нет управляющей нити."

#. type: Plain text
#: man-pages/man7/pthreads.7:801
msgid ""
"NPTL makes internal use of the first two real-time signals; these signals "
"cannot be used in applications.  See B<nptl>(7)  for further details."
msgstr ""
"Внутри NPTL используются первые два сигнала реального времени; эти сигналы "
"нельзя использовать в приложениях. Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man7/pthreads.7:803
msgid "NPTL still has at least one nonconformance with POSIX.1:"
msgstr "NPTL тоже не соответствует POSIX.1, как минимум, в одном:"

#. type: Plain text
#: man-pages/man7/pthreads.7:812
msgid "Some NPTL nonconformances occur only with older kernels:"
msgstr ""
"Несколько несоответствий NPTL проявляется только при работе со старыми "
"ядрами:"

#. type: Plain text
#: man-pages/man7/pthreads.7:818
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide (fixed in kernel 2.6.9)."
msgstr ""
"Информация, возвращаемая B<times>(2) и B<getrusage>(2), относится только к "
"нити, а не к процессу в целом (исправлено в ядре 2.6.9)."

#. type: Plain text
#: man-pages/man7/pthreads.7:820
msgid "Threads do not share resource limits (fixed in kernel 2.6.10)."
msgstr "У нитей разные ограничения по ресурсам (исправлено в ядре 2.6.10)."

#. type: Plain text
#: man-pages/man7/pthreads.7:822
msgid "Threads do not share interval timers (fixed in kernel 2.6.12)."
msgstr "У нитей разные интервалы таймеров (исправлено в ядре 2.6.12)."

#. type: Plain text
#: man-pages/man7/pthreads.7:826
msgid ""
"Only the main thread is permitted to start a new session using B<setsid>(2)  "
"(fixed in kernel 2.6.16)."
msgstr ""
"Только из главной нити разрешено запускать новый сеанс с помощью "
"B<setsid>(2) (исправлено в версии 2.6.16)."

#. type: Plain text
#: man-pages/man7/pthreads.7:831
msgid ""
"Only the main thread is permitted to make the process into a process group "
"leader using B<setpgid>(2)  (fixed in kernel 2.6.16)."
msgstr ""
"Только из главной нити разрешено делать процесс лидером группы процессов с "
"помощью B<setpgid>(2) (исправлено в версии 2.6.16)."

#. type: Plain text
#: man-pages/man7/pthreads.7:837
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack "
"(fixed in kernel 2.6.16)."
msgstr ""
"Нити имеют разные настройки альтернативного стека сигналов Однако, новые "
"настройки альтернативного стека сигналов копируются из нити, которая его "
"создаёт, так что изначально нити имеют единый альтернативный стек сигналов "
"(исправлено в ядре 2.6.16)."

#. type: Plain text
#: man-pages/man7/pthreads.7:839
msgid "Note the following further points about the NPTL implementation:"
msgstr "Также стоит учитывать следующее о реализации NPTL:"

#. type: Plain text
#: man-pages/man7/pthreads.7:853
msgid ""
"If the stack size soft resource limit (see the description of "
"B<RLIMIT_STACK> in B<setrlimit>(2))  is set to a value other than "
"I<unlimited>, then this value defines the default stack size for new "
"threads.  To be effective, this limit must be set before the program is "
"executed, perhaps using the I<ulimit -s> shell built-in command (I<limit "
"stacksize> in the C shell)."
msgstr ""
"Если мягкое ограничение ресурса на размер стека (смотрите описание "
"B<RLIMIT_STACK> в B<setrlimit>(2)) устанавливается в значение, отличное от "
"I<unlimited>, то это значение определяет размер стека по умолчанию для новых "
"нитей. В целях эффективности, это ограничение должно быть установлено но "
"выполнения программы, возможно с помощью встроенной команды оболочки "
"I<ulimit -s> (I<limit stacksize> в оболочке C)."

#. type: SS
#: man-pages/man7/pthreads.7:853
#, no-wrap
msgid "Determining the threading implementation"
msgstr "Определение реализации нитей"

#. type: Plain text
#: man-pages/man7/pthreads.7:858
msgid ""
"Since glibc 2.3.2, the B<getconf>(1)  command can be used to determine the "
"system's threading implementation, for example:"
msgstr ""
"Начиная с glibc 2.3.2, для определение реализации нитей в системе можно "
"использовать команду B<getconf>(1), например:"

#. type: Plain text
#: man-pages/man7/pthreads.7:863
#, no-wrap
msgid ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"
msgstr ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"

#. type: Plain text
#: man-pages/man7/pthreads.7:868
msgid ""
"With older glibc versions, a command such as the following should be "
"sufficient to determine the default threading implementation:"
msgstr "При наличии старых версий glibc можно использовать команду:"

#. type: Plain text
#: man-pages/man7/pthreads.7:874
#, no-wrap
msgid ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|nptl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"
msgstr ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|nptl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"

#. type: SS
#: man-pages/man7/pthreads.7:876
#, no-wrap
msgid "Selecting the threading implementation: LD_ASSUME_KERNEL"
msgstr "Выбор реализации нитей: LD_ASSUME_KERNEL"

#. type: Plain text
#: man-pages/man7/pthreads.7:891
msgid ""
"On systems with a glibc that supports both LinuxThreads and NPTL (i.e., "
"glibc 2.3.I<x>), the B<LD_ASSUME_KERNEL> environment variable can be used to "
"override the dynamic linker's default choice of threading implementation.  "
"This variable tells the dynamic linker to assume that it is running on top "
"of a particular kernel version.  By specifying a kernel version that does "
"not provide the support required by NPTL, we can force the use of "
"LinuxThreads.  (The most likely reason for doing this is to run a (broken) "
"application that depends on some nonconformant behavior in LinuxThreads.)  "
"For example:"
msgstr ""
"В системах с glibc, которая поддерживает и LinuxThreads и NPTL (например, "
"glibc 2.3.I<x>), можно воспользоваться переменной окружения "
"B<LD_ASSUME_KERNEL> для замены выбранной динамическим компоновщиков "
"реализации нитей по умолчанию. Эта переменная указывает динамическому "
"компоновщику считать, что он запускается с определённой версией ядра в "
"системе. Указав версию ядра, в которой не поддержки, требуемой NPTL, его "
"можно заставить использовать LinuxThreads (наиболее вероятной причиной для "
"этого будет необходимость запуска (сломанного) приложения, которое зависит "
"от некоторого не совместимого поведения LinuxThreads). Пример:"

#. type: Plain text
#: man-pages/man7/pthreads.7:897
#, no-wrap
msgid ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|nptl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"
msgstr ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|nptl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"

#. type: Plain text
#: man-pages/man7/pthreads.7:912
msgid ""
"B<clone>(2), B<fork>(2), B<futex>(2), B<gettid>(2), B<proc>(5), "
"B<attributes>(7), B<futex>(7), B<nptl>(7), B<sigevent>(7), B<signal>(7)"
msgstr ""
"B<clone>(2), B<fork>(2), B<futex>(2), B<gettid>(2), B<proc>(5), "
"B<attributes>(7), B<futex>(7), B<nptl>(7), B<sigevent>(7), B<signal>(7)"

#. type: Plain text
#: man-pages/man7/pthreads.7:940
msgid ""
"Various Pthreads manual pages, for example: B<pthread_atfork>(3), "
"B<pthread_attr_init>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<pthread_mutexattr_destroy>(3), "
"B<pthread_mutexattr_init>(3), B<pthread_once>(3), B<pthread_spin_init>(3), "
"B<pthread_spin_lock>(3), B<pthread_rwlockattr_setkind_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3), "
"and B<pthread_testcancel>(3)"
msgstr ""
"Различные справочные страницы pthreads, например: B<pthread_atfork>(3), "
"B<pthread_attr_init>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<pthread_mutexattr_destroy>(3), "
"B<pthread_mutexattr_init>(3), B<pthread_once>(3), B<pthread_spin_init>(3), "
"B<pthread_spin_lock>(3), B<pthread_rwlockattr_setkind_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3), "
"B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3) и "
"B<pthread_testcancel>(3)"

#. type: TH
#: man-pages/man7/process-keyring.7:12
#, no-wrap
msgid "PROCESS-KEYRING"
msgstr "PROCESS-KEYRING"

#. type: Plain text
#: man-pages/man7/process-keyring.7:15
msgid "process-keyring - per-process shared keyring"
msgstr "process-keyring - общая связка ключей для процесса"

#. type: Plain text
#: man-pages/man7/process-keyring.7:20
msgid ""
"The process keyring is a keyring used to anchor keys on behalf of a "
"process.  It is created only when a process requests it.  The process "
"keyring has the name (description)  I<_pid>."
msgstr ""
"Связка ключей процесса — это связка ключей, используемая для привязки ключей "
"процесса. Она создаётся только по запросу процесса. Связка ключей процесса "
"имеет имя (описание)  I<_pid>."

#. type: Plain text
#: man-pages/man7/process-keyring.7:25
msgid ""
"A special serial number value, B<KEY_SPEC_PROCESS_KEYRING>, is defined that "
"can be used in lieu of the actual serial number of the calling process's "
"process keyring."
msgstr ""
"Существует специальное значение, B<KEY_SPEC_PROCESS_KEYRING>, которое можно "
"использовать вместо настоящего серийного номера связки ключей процесса "
"вызывающего процесса."

#. type: Plain text
#: man-pages/man7/process-keyring.7:32
msgid ""
"From the B<keyctl>(1)  utility, 'B<@p>' can be used instead of a numeric key "
"ID in much the same way, but since B<keyctl>(1)  is a program run after "
"forking, this is of no utility."
msgstr ""
"В утилите B<keyctl>(1) подобным образом можно использовать «B<@p>» вместо "
"числового ID ключа, но так как B<keyctl>(1) выполняется после разветвления, "
"это не используется."

#. type: Plain text
#: man-pages/man7/process-keyring.7:45
msgid ""
"A thread created using the B<clone>(2)  B<CLONE_THREAD> flag has the same "
"process keyring as the caller of B<clone>(2).  When a new process is created "
"using B<fork>()  it initially has no process keyring.  A process's process "
"keyring is cleared on B<execve>(2).  The process keyring is destroyed when "
"the last thread that refers to it terminates."
msgstr ""
"Нить, создаваемая B<clone>(2) с флагом B<CLONE_THREAD>, имеет ту же связку "
"ключей процесса, что и вызвавший B<clone>(2). Если новый процесс создаётся с "
"помощью B<fork>(), то изначально он не имеет связки ключей процесса. Связка "
"ключей процесса очищается при B<execve>(2). Связка ключей процесса "
"уничтожается когда завершается последняя нить, которая на неё ссылалась."

#. type: Plain text
#: man-pages/man7/process-keyring.7:51
msgid ""
"If a process doesn't have a process keyring when it is accessed, then the "
"process keyring will be created if the keyring is to be modified; otherwise, "
"the error B<ENOKEY> results."
msgstr ""
"Если процесс не имеет связки ключей процесса, когда к ней обращается, то она "
"будет создана, если запрашивается изменение связки ключей; в противном "
"случае возвращается ошибка B<ENOKEY>."

#. type: Plain text
#: man-pages/man7/process-keyring.7:61
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<session-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7)"
msgstr ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<session-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), B<user-"
"session-keyring>(7)"

#. type: TH
#: man-pages/man2/process_vm_readv.2:29
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr "PROCESS_VM_READV"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:32
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""
"process_vm_readv, process_vm_writev - производит обмен данными между "
"адресными пространствами процессов"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:35
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:42
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:49
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:54
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:58
msgid "B<process_vm_readv>(), B<process_vm_writev>():"
msgstr "B<process_vm_readv>(), B<process_vm_writev>():"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:62
msgid "B<_GNU_SOURCE>"
msgstr "B<_GNU_SOURCE>"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:72
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""
"Данные системные вызовы перемещают данные между адресным пространством "
"вызывающего процесса («локального процесса») и процесса с указанным I<pid> "
"(«удалённый процесс»). Данные перемещаются прямо между адресными "
"пространствами двух процессов, без копирования через пространство ядра."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:97
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""
"Системный вызов B<process_vm_readv>()  перемещает данные из удалённого "
"процесса в локальный. Перемещаемые данные задаются I<remote_iov> и "
"I<riovcnt>: I<remote_iov> — указатель на массив, описывающий адресные "
"пространства в процессе I<pid>, и в I<riovcnt> указывается количество "
"элементов в I<remote_iov>. Данные перемещаются в расположения, задаваемые "
"I<local_iov> и I<liovcnt>: I<local_iov> — указатель на массив, описывающий "
"адресные пространства в вызывающем процессе, а в I<liovcnt> задаётся "
"количество элементов в I<local_iov>."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:111
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""
"Системный вызов B<process_vm_writev>() выполняет операцию, обратную "
"B<process_vm_readv>() — перемещает данные из локального процесса в "
"удалённый. Кроме направления передачи, аргументы I<liovcnt>, I<local_iov>, "
"I<riovcnt> и I<remote_iov> имеют то назначение что и для "
"B<process_vm_readv>()."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:121
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""
"Аргументы I<local_iov> и I<remote_iov> указывают на массив структур "
"I<iovec>, определённых в I<E<lt>sys/uio.hE<gt>>:"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:128
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;    /* начальный адрес */\n"
"    size_t iov_len;     /* количество перемещаемых байт */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:144
msgid ""
"Buffers are processed in array order.  This means that "
"B<process_vm_readv>()  completely fills I<local_iov[0]> before proceeding to "
"I<local_iov[1]>, and so on.  Likewise, I<remote_iov[0]> is completely read "
"before proceeding to I<remote_iov[1]>, and so on."
msgstr ""
"Буферы обрабатываются в порядке, в каком они указаны в массиве. Это "
"означает, что B<process_vm_readv>() сначала полностью заполнит "
"I<local_iov[0]> и только потом перейдёт к I<local_iov[1]> и так далее. "
"Подобным образом I<remote_iov[0]> сначала полностью читается перед переходом "
"к I<remote_iov[1]> и так далее."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:155
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""
"Подобным образом B<process_vm_writev>() записывает всё содержимое "
"I<local_iov[0]> перед тем, как перейти к I<local_iov[1]>, и это полностью "
"заполняет I<remote_iov[0]> перед тем как перейти к I<remote_iov[1]>."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:163
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""
"Длины I<remote_iov[i].iov_len> и I<local_iov[i].iov_len> могут быть не "
"одинаковы. То есть, возможно разделить одни локальный буфер на несколько "
"удалённых буферов и наоборот."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:167
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr ""
"В настоящее время аргумент I<flags> не используется и должен равняться 0."

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: man-pages/man2/process_vm_readv.2:180
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less "
"than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible "
"via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""
"Значения, указанные в аргументах I<liovcnt> и I<riovcnt>, должны быть меньше "
"или равны B<IOV_MAX> (определено в I<E<lt>limits.hE<gt>> или доступно через "
"вызов I<sysconf(_SC_IOV_MAX)>)."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:190
msgid ""
"The count arguments and I<local_iov> are checked before doing any "
"transfers.  If the counts are too big, or I<local_iov> is invalid, or the "
"addresses refer to regions that are inaccessible to the local process, none "
"of the vectors will be processed and an error will be returned immediately."
msgstr ""
"Количество аргументов и I<local_iov> проверяется перед началом передачи. "
"Если количество слишком велико или I<local_iov> содержит некорректное "
"значение, или адреса областей недоступны локальному процессу, то ни один из "
"векторов не будет обработан и сразу возвращается ошибка."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:210
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep "
"this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4\\ KiB) in a single remote I<iovec> "
"element.  (Instead, split the remote read into two I<remote_iov> elements "
"and have them merge back into a single write I<local_iov> entry.  The first "
"read entry goes up to the page boundary, while the second starts on the next "
"page boundary.)"
msgstr ""
"Однако заметим, что эти системные вызовы не проверяют области памяти в "
"удалённом процессе до начала выполнения чтения/записи. Следовательно может "
"выполниться частичное чтение/запись (смотрите ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ), если "
"один из элементов I<remote_iov> указывает на некорректную область памяти в "
"удалённом процессе. После нахождения такого элемента дальнейшее чтение/"
"запись не производится. Помните об этом, когда читаете данные неизвестной "
"длины (например, строки C, завершающиеся null) из удалённого процесса, "
"избегайте объединения страниц памяти (обычно, 4\\ КиБ) одного удалённого "
"элемента I<iovec> (вместо этого разделите чтение удалённого элемента на два "
"элемента I<remote_iov> и объедините их обратно в одну запись I<local_iov> "
"entry. Первый читаемый элемент дойдёт до границы страницы, а второй начнётся "
"на следующей границе страницы)."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:216
msgid ""
"Permission to read from or write to another process is governed by a ptrace "
"access mode B<PTRACE_MODE_ATTACH_REALCREDS> check; see B<ptrace>(2)."
msgstr ""
"Право читать или писать в другой процесс определяется проверкой режима "
"доступа ptrace B<PTRACE_MODE_ATTACH_REALCREDS>; смотрите B<ptrace>(2)."

#. type: SH
#: man-pages/man2/process_vm_readv.2:216
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:232
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that "
"splits a single I<iovec> element.)  The caller should check the return value "
"to determine whether a partial read/write occurred."
msgstr ""
"При успешном выполнении B<process_vm_readv>() возвращает количество "
"прочитанных байт, B<process_vm_writev>() возвращает количество записанных "
"байт. Это значение может быть меньше полного числа запрашиваемых байт, если "
"произошло частичное чтение/запись (частичная передача выполняется с "
"точностью по I<iovec> элементам. Эти системные вызовы не выполняют частичной "
"передачи, которая разделила бы один элемент I<iovec>). Вызывающий должен "
"проверить возвращаемое значение, чтобы определить возникало ли частичное "
"чтение/запись."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:236
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr ""
"В случае ошибки возвращается -1 и значение I<errno> устанавливается "
"соответствующим образом."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:242
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""
"Память, описываемая в I<local_iov>, находится вне пределов доступного "
"адресного пространства вызывающего."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:248
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""
"Память, описываемая в I<remote_iov>, находится вне пределов доступного "
"адресного пространства процесса I<pid>."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:259
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""
"Сумма значений I<iov_len> из I<local_iov> или I<remote_iov> превышает "
"значение I<ssize_t>."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:263
msgid "I<flags> is not 0."
msgstr "Значение I<flags> не равно 0."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:269
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr "Значение I<liovcnt> или I<riovcnt> слишком велико."

#. type: TP
#: man-pages/man2/process_vm_readv.2:269
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:274
msgid ""
"Could not allocate memory for internal copies of the I<iovec> structures."
msgstr "Невозможно выделить память для внутренних копий структур I<iovec>."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:278
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""
"Вызывающий не имеет прав на доступ к адресному пространству процесса I<pid>."

#. type: TP
#: man-pages/man2/process_vm_readv.2:278
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:283
msgid "No process with ID I<pid> exists."
msgstr "Процесс с идентификатором I<pid> не существует."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:286
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""
"Данные системные вызовы были добавлены в Linux 3.2. Поддержка в glibc "
"появилась в версии 2.15."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:288
msgid "These system calls are nonstandard Linux extensions."
msgstr "Данные системные вызовы являются нестандартными расширениями Linux."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:294
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""
"При пересылке данных с помощью B<process_vm_readv>() и "
"B<process_vm_writev>() не гарантируется атомарность."

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: man-pages/man2/process_vm_readv.2:302
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or "
"pipes)."
msgstr ""
"Эти системные вызовы были разработаны для быстрой передачи сообщений, чтобы "
"позволить выполнить обмен за одну операцию копирования (а не двойного "
"копирования, что требуется, например, при использовании общей памяти или "
"каналов)."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:310
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It "
"reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""
"В следующем примере показано использование B<process_vm_readv>(). Вызов "
"читает 20 байт по адресу 0x10000 из процесса с PID 10 и записывает первые 10 "
"байт в I<buf1>, а вторые 10 байт в I<buf2>."

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:313
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr "#include E<lt>sys/uio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:323
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID удалённого процесса */\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:330
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[0].iov_len = 20;\n"
msgstr ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[0].iov_len = 20;\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:337
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:340
msgid "B<readv>(2), B<writev>(2)"
msgstr "B<readv>(2), B<writev>(2)"

#. type: TH
#: man-pages/man2/poll.2:31
#, no-wrap
msgid "POLL"
msgstr "POLL"

#. type: Plain text
#: man-pages/man2/poll.2:34
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr "poll, ppoll - ожидает некоторое событие над файловым дескриптором"

#. type: Plain text
#: man-pages/man2/poll.2:37
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr "B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/poll.2:39
#, no-wrap
msgid "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"
msgstr "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/poll.2:43
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/poll.2:46
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<tmo_p>B<, const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<tmo_p>B<, const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/poll.2:53
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O."
msgstr ""
"Вызов B<poll>() выполняет сходную с B<select>(2) задачу: он ждёт пока один "
"дескриптор из набора файловых дескрипторов не станет готов выполнить "
"операцию ввода-вывода."

#. type: Plain text
#: man-pages/man2/poll.2:57
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""
"Отслеживаемый набор файловых дескрипторов задаётся в аргументе I<fds>, "
"который представляет собой массив структур:"

#. type: Plain text
#: man-pages/man2/poll.2:65
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""
"struct pollfd {\n"
"    int   fd;         /* файловый дескриптор */\n"
"    short events;     /* запрашиваемые события */\n"
"    short revents;    /* возвращённые события */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/poll.2:72
msgid ""
"The caller should specify the number of items in the I<fds> array in I<nfds>."
msgstr ""
"Вызывающий должен указать количество элементов в массиве I<fds> в аргументе "
"I<nfds>."

#. type: Plain text
#: man-pages/man2/poll.2:88
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> "
"field.  Note, however, that this technique can't be used to ignore file "
"descriptor 0.)"
msgstr ""
"В поле I<fd> содержится файловый дескриптор открытого файла. Если значение "
"поля отрицательно, то соответствующее поле I<events> игнорируется, а полю "
"I<revents> возвращает ноль (простой способ игнорирования файлового "
"дескриптора в одиночном вызове B<poll>(): просто сделать значение поля I<fd> "
"отрицательным. Заметим, что это нельзя использовать для игнорирования "
"файлового дескриптора 0)."

#. type: Plain text
#: man-pages/man2/poll.2:103
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned "
"in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr ""
"Поле I<events> представляет собой входной параметр — битовую маску, "
"указывающую на события, происходящие с файловым дескриптором I<fd>, которые "
"важны для приложения. Если это поле равно нулю, то возвращаемыми событиями в "
"I<revents> могут быть B<POLLHUP>, B<POLLERR> и B<POLLNVAL> (смотрите ниже)."

#. type: Plain text
#: man-pages/man2/poll.2:122
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""
"Поле I<revents> представляет собой параметр-результат, в который ядро "
"помещает информацию о произошедших событиях. В I<revents> могут содержаться "
"любые битовые флаги из задаваемых в I<events>, или там может быть одно из "
"значений: B<POLLERR>, B<POLLHUP> или B<POLLNVAL>. Эти три битовых флага не "
"имеют смысла в поле I<events>, но будут установлены в поле I<revents>, если "
"соответствующее условие истинно."

#. type: Plain text
#: man-pages/man2/poll.2:127
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""
"Если ни одно из запрошенных событий с файловыми дескрипторами не произошло "
"или не возникло ошибок, то B<poll>() блокируется до их появления."

#. type: Plain text
#: man-pages/man2/poll.2:134
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()  "
"should block waiting for a file descriptor to become ready.  The call will "
"block until either:"
msgstr ""
"В аргументе I<timeout> указывается количество миллисекунд, на которые будет "
"блокироваться B<poll>() в ожидании готовности файлового дескриптора. Вызов "
"будет заблокирован пока:"

#. type: Plain text
#: man-pages/man2/poll.2:136
msgid "a file descriptor becomes ready;"
msgstr "файловый дескриптор не станет готов;"

#. type: Plain text
#: man-pages/man2/poll.2:138
msgid "the call is interrupted by a signal handler; or"
msgstr "вызов не прервётся обработчиком сигнала;"

#. type: Plain text
#: man-pages/man2/poll.2:140
msgid "the timeout expires."
msgstr "не истечёт время ожидания."

#. type: Plain text
#: man-pages/man2/poll.2:154
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes "
"B<poll>()  to return immediately, even if no file descriptors are ready."
msgstr ""
"Заметим, что интервал I<timeout> будет округлён с точностью системных часов, "
"а из-за задержки при планировании в ядре блокирующий интервал будет немного "
"больше. Отрицательное значение в I<timeout> означает бесконечное ожидание. "
"Значение I<timeout>, равное нулю, приводит к немедленному завершению "
"B<poll>(), даже если ни один файловый дескриптор не готов."

#. type: Plain text
#: man-pages/man2/poll.2:160
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""
"Вот возможные биты, описанные в I<E<lt>poll.hE<gt>>, которые могут быть "
"установлены/получены в I<events> и I<revents>:"

#. type: TP
#: man-pages/man2/poll.2:160
#, no-wrap
msgid "B<POLLIN>"
msgstr "B<POLLIN>"

#. type: Plain text
#: man-pages/man2/poll.2:163
msgid "There is data to read."
msgstr "Есть данные для чтения."

#. type: TP
#: man-pages/man2/poll.2:163
#, no-wrap
msgid "B<POLLPRI>"
msgstr "B<POLLPRI>"

#. type: Plain text
#: man-pages/man2/poll.2:167
msgid ""
"There is some exceptional condition on the file descriptor.  Possibilities "
"include:"
msgstr "Исключительное состояние файлового дескриптора. Может быть из-за:"

#. type: Plain text
#: man-pages/man2/poll.2:171
msgid "There is out-of-band data on a TCP socket (see B<tcp>(7))."
msgstr "Внеполосные данные в сокете TCP (смотрите B<tcp>(7))."

#. type: Plain text
#: man-pages/man2/poll.2:175
msgid ""
"A pseudoterminal master in packet mode has seen a state change on the slave "
"(see B<ioctl_tty>(2))."
msgstr ""
"Мастер псевдо-терминала в пакетном режиме увидел изменение состояния "
"подчинённого терминала (смотрите B<ioctl_tty>(2))."

#. type: Plain text
#: man-pages/man2/poll.2:180
msgid "A I<cgroup.events> file has been modified (see B<cgroups>(7))."
msgstr "Изменился файл I<cgroup.events> (смотрите B<cgroups>(7))."

#. type: TP
#: man-pages/man2/poll.2:181
#, no-wrap
msgid "B<POLLOUT>"
msgstr "B<POLLOUT>"

#. type: Plain text
#: man-pages/man2/poll.2:187
msgid ""
"Writing is now possible, though a write larger that the available space in a "
"socket or pipe will still block (unless B<O_NONBLOCK> is set)."
msgstr ""
"Теперь запись возможна, но запись данных больше, чем доступно места в сокете "
"или канале, по-прежнему приводит к блокировке (если не указан B<O_NONBLOCK>)."

#. type: TP
#: man-pages/man2/poll.2:187
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr "B<POLLRDHUP> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man2/poll.2:198
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""
"Удалённая сторона потокового сокета закрыла соединение, или отключила запись "
"в одну сторону. Для использования данного определения должен быть определён "
"макрос тестирования свойств B<_GNU_SOURCE> (до включения I<каких-либо> "
"заголовочных файлов)."

#. type: TP
#: man-pages/man2/poll.2:198
#, no-wrap
msgid "B<POLLERR>"
msgstr "B<POLLERR>"

#. type: Plain text
#: man-pages/man2/poll.2:206
msgid ""
"Error condition (only returned in I<revents>; ignored in I<events>).  This "
"bit is also set for a file descriptor referring to the write end of a pipe "
"when the read end has been closed."
msgstr ""
"Состояние ошибки (возвращается только в I<revents>; игнорируется в "
"I<events>). Также этот бит устанавливается для файлового дескриптора, "
"указывающего в пишущий конец канала при закрытом читающем конце."

#. type: TP
#: man-pages/man2/poll.2:206
#, no-wrap
msgid "B<POLLHUP>"
msgstr "B<POLLHUP>"

#. type: Plain text
#: man-pages/man2/poll.2:216
msgid ""
"Hang up (only returned in I<revents>; ignored in I<events>).  Note that when "
"reading from a channel such as a pipe or a stream socket, this event merely "
"indicates that the peer closed its end of the channel.  Subsequent reads "
"from the channel will return 0 (end of file)  only after all outstanding "
"data in the channel has been consumed."
msgstr ""
"Зависание (hang up, возвращается только в I<revents>; игнорируется в "
"I<events>). Заметим, что при чтении из канала, такого как канал (pipe) или "
"потоковый сокет, это событие всего-навсего показывает, что партнёр закрыл "
"канал со своего конца. Дальнейшее чтение из канала будет возвращать 0 (конец "
"файла) только после потребления всех неполученных данных в канале."

#. type: TP
#: man-pages/man2/poll.2:216
#, no-wrap
msgid "B<POLLNVAL>"
msgstr "B<POLLNVAL>"

#. type: Plain text
#: man-pages/man2/poll.2:224
msgid ""
"Invalid request: I<fd> not open (only returned in I<revents>; ignored in "
"I<events>)."
msgstr ""
"Неверный запрос: I<fd> не открыт (возвращается только в I<revents>; "
"игнорируется в I<events>)."

#. type: Plain text
#: man-pages/man2/poll.2:229
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""
"При компилировании с установленным B<_XOPEN_SOURCE> также определены "
"следующие значения, которые не передают дополнительной информации вне "
"упомянутых выше битов:"

#. type: TP
#: man-pages/man2/poll.2:229
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr "B<POLLRDNORM>"

#. type: Plain text
#: man-pages/man2/poll.2:233
msgid "Equivalent to B<POLLIN>."
msgstr "Эквивалентно B<POLLIN>."

#. type: TP
#: man-pages/man2/poll.2:233
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr "B<POLLRDBAND>"

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: man-pages/man2/poll.2:237
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""
"Доступны для чтения приоритетные внутриполосные данные (в Linux, обычно, не "
"используется)."

#. type: TP
#: man-pages/man2/poll.2:237
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr "B<POLLWRNORM>"

#. type: Plain text
#: man-pages/man2/poll.2:241
msgid "Equivalent to B<POLLOUT>."
msgstr "Эквивалентно B<POLLOUT>."

#. type: TP
#: man-pages/man2/poll.2:241
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr "B<POLLWRBAND>"

#. type: Plain text
#: man-pages/man2/poll.2:244
msgid "Priority data may be written."
msgstr "Можно писать приоритетные данные."

#. type: Plain text
#: man-pages/man2/poll.2:247
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr "В Linux также есть B<POLLMSG>, но он не используется."

#. type: SS
#: man-pages/man2/poll.2:247
#, no-wrap
msgid "ppoll()"
msgstr "ppoll()"

#. type: Plain text
#: man-pages/man2/poll.2:261
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""
"Отношения между B<poll>() и B<ppoll>() аналогичны родству B<select>(2) и "
"B<pselect>(2): как B<pselect>(2), B<ppoll>() позволяет приложению безопасно "
"ждать, пока файловый дескриптор не станет готов или пока не будет получен "
"сигнал."

#. type: Plain text
#: man-pages/man2/poll.2:267
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr "Кроме различия в точности аргумента I<timeout> вызов B<ppoll>()"

#. type: Plain text
#: man-pages/man2/poll.2:271
#, no-wrap
msgid "ready = ppoll(&fds, nfds, tmo_p, &sigmask);\n"
msgstr "ready = ppoll(&fds, nfds, tmo_p, &sigmask);\n"

#. type: Plain text
#: man-pages/man2/poll.2:277
msgid "is nearly equivalent to I<atomically> executing the following calls:"
msgstr "почти эквивалентен I<атомарному> выполнению следующих вызовов:"

#. type: Plain text
#: man-pages/man2/poll.2:282
#, no-wrap
msgid ""
"sigset_t origmask;\n"
"int timeout;\n"
msgstr ""
"sigset_t origmask;\n"
"int timeout;\n"

#. type: Plain text
#: man-pages/man2/poll.2:288
#, no-wrap
msgid ""
"timeout = (tmo_p == NULL) ? -1 :\n"
"          (tmo_p-E<gt>tv_sec * 1000 + tmo_p-E<gt>tv_nsec / 1000000);\n"
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = poll(&fds, nfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"timeout = (tmo_p == NULL) ? -1 :\n"
"          (tmo_p-E<gt>tv_sec * 1000 + tmo_p-E<gt>tv_nsec / 1000000);\n"
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = poll(&fds, nfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: man-pages/man2/poll.2:301
msgid ""
"The above code segment is described as I<nearly> equivalent because whereas "
"a negative I<timeout> value for B<poll>()  is interpreted as an infinite "
"timeout, a negative value expressed in I<*tmo_p> results in an error from "
"B<ppoll>()."
msgstr ""
"Приведённый выше сегмент кода показывает I<ближайший> эквивалент, так как "
"отрицательное значение I<timeout> в B<poll>() рассматривается как "
"бесконечное ожидание, а отрицательное значение в I<*tmo_p> привело бы к "
"ошибке B<ppoll>()."

#. type: Plain text
#: man-pages/man2/poll.2:307
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr "Смотрите в B<pselect>(2) пояснения о необходимости B<ppoll>()."

#. type: Plain text
#: man-pages/man2/poll.2:319
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""
"Если значение аргумента I<sigmask> равно NULL, то изменение маски сигналов "
"не происходит (и поэтому B<ppoll>() отличается от B<poll>() только в "
"точности аргумента I<timeout>)."

#. type: Plain text
#: man-pages/man2/poll.2:326
msgid ""
"The I<tmo_p> argument specifies an upper limit on the amount of time that "
"B<ppoll>()  will block.  This argument is a pointer to a structure of the "
"following form:"
msgstr ""
"В аргументе I<tmo_p> указывается верхняя граница промежутка времени, на "
"который будет заблокирован B<ppoll>(). Этот аргумент представляет собой "
"указатель на структуру следующего вида:"

#. type: Plain text
#: man-pages/man2/poll.2:333
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* секунды */\n"
"    long    tv_nsec;        /* наносекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/poll.2:341
msgid ""
"If I<tmo_p> is specified as NULL, then B<ppoll>()  can block indefinitely."
msgstr ""
"Если значение I<tmo_p> равно NULL, то B<ppoll>() может оставаться "
"заблокированным бесконечно."

#. type: Plain text
#: man-pages/man2/poll.2:351
msgid ""
"On success, a positive number is returned; this is the number of structures "
"which have nonzero I<revents> fields (in other words, those descriptors with "
"events or errors reported).  A value of 0 indicates that the call timed out "
"and no file descriptors were ready.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"При успешном выполнении возвращается положительное значение; оно означает "
"количество структур, в которых поля I<revents> имеют ненулевое значение "
"(другими словами, тех дескрипторов, для которых возникли события или "
"ошибки). Значение 0 означает, что время ожидания истекло, и нет готовых "
"файловых дескрипторов. В случае ошибки возвращается -1, а I<errno> "
"устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/poll.2:356
msgid ""
"The array given as argument was not contained in the calling program's "
"address space."
msgstr ""
"Указанный аргументом массив содержится вне адресного пространства вызывающей "
"программы."

#. type: TP
#: man-pages/man2/poll.2:356
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/poll.2:360
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""
"Получен сигнал раньше какого-либо запрашиваемого события; смотрите "
"B<signal>(7)."

#. type: Plain text
#: man-pages/man2/poll.2:367
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr "Значение I<nfds> превышает значение B<RLIMIT_NOFILE>."

#. type: Plain text
#: man-pages/man2/poll.2:373
msgid ""
"(B<ppoll>())  The timeout value expressed in I<*ip> is invalid (negative)."
msgstr "(B<ppoll>()) Время ожидания в I<*ip> некорректно (отрицательное)."

#. type: Plain text
#: man-pages/man2/poll.2:376
msgid "There was no space to allocate file descriptor tables."
msgstr "Нет места под таблицы файловых дескрипторов."

#.  library call was introduced in libc 5.4.28
#. type: Plain text
#: man-pages/man2/poll.2:386
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels "
"that lack this system call, the glibc (and the old Linux libc)  B<poll>()  "
"wrapper function provides emulation using B<select>(2)."
msgstr ""
"Системный вызов B<poll>() появился в Linux 2.1.23. Для старых ядер, в "
"которых этот вызов отсутствует, glibc (и старая Linux libc) предоставляет "
"обёрточную функцию B<poll>(), которая эмулируется с помощью B<select>(2)."

#. type: Plain text
#: man-pages/man2/poll.2:393
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""
"Системный вызов B<ppoll>() был добавлен в ядро Linux в версии 2.6.16. "
"Библиотечный вызов B<ppoll>() был добавлен в glibc 2.4."

#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: man-pages/man2/poll.2:399
msgid ""
"B<poll>()  conforms to POSIX.1-2001 and POSIX.1-2008.  B<ppoll>()  is Linux-"
"specific."
msgstr ""
"Вызов B<poll>() соответствует POSIX.1-2001 и POSIX.1-2008. Вызов B<ppoll>() "
"есть только в Linux."

#. type: Plain text
#: man-pages/man2/poll.2:407
msgid ""
"The operation of B<poll>()  and B<ppoll>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr "На операции B<poll>() и B<ppoll>() флаг B<O_NONBLOCK> не влияет."

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: man-pages/man2/poll.2:421
msgid ""
"On some other UNIX systems, B<poll>()  can fail with the error B<EAGAIN> if "
"the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX permits this behavior.  Portable programs "
"may wish to check for B<EAGAIN> and loop, just as with B<EINTR>."
msgstr ""
"В некоторых системах UNIX вызов B<poll>() может завершаться с ошибкой "
"B<EAGAIN>, если системе не удаётся выделить внутренние ресурсы ядра, вместо "
"ошибки B<ENOMEM> как это происходит в Linux. В POSIX допускается такое "
"поведение. Переносимые программы должны ожидать B<EAGAIN> в цикле, как для "
"B<EINTR>."

#. type: Plain text
#: man-pages/man2/poll.2:429
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""
"В некоторых реализациях определена нестандартная константа B<INFTIM> со "
"значением -1 для использования в качестве значения I<timeout> в B<poll>(). "
"Эта константа отсутствует в glibc."

#. type: Plain text
#: man-pages/man2/poll.2:434
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr ""
"Обсуждение того, что может случиться, если файловый дескриптор отслеживается "
"B<poll>() и при этом закрывается в другой нити, смотрите в B<select>(2)."

#. type: SS
#: man-pages/man2/poll.2:434
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#. type: Plain text
#: man-pages/man2/poll.2:448
msgid ""
"The Linux B<ppoll>()  system call modifies its I<tmo_p> argument.  However, "
"the glibc wrapper function hides this behavior by using a local variable for "
"the timeout argument that is passed to the system call.  Thus, the glibc "
"B<ppoll>()  function does not modify its I<tmo_p> argument."
msgstr ""
"В Linux системный вызов B<ppoll>() изменяет свой аргумент I<tmo_p>. Однако, "
"обёрточная функция glibc скрывает это поведение с помощью локальной "
"переменной для аргумента timeout, которая передаётся в системный вызов. "
"Поэтому glibc функция B<ppoll>() не изменяет свой аргумент I<tmo_p>."

#. type: Plain text
#: man-pages/man2/poll.2:465
msgid ""
"The raw B<ppoll>()  system call has a fifth argument, I<size_t sigsetsize>, "
"which specifies the size in bytes of the I<sigmask> argument.  The glibc "
"B<ppoll>()  wrapper function specifies this argument as a fixed value (equal "
"to I<sizeof(kernel_sigset_t)>).  See B<sigprocmask>(2)  for a discussion on "
"the differences between the kernel and the libc notion of the sigset."
msgstr ""
"Ядерный системный вызов B<ppoll>() имеет пятый аргумент, I<size_t "
"sigsetsize>, в котором указывается размер аргумента I<sigmask> в байтах. В "
"обёрточной функции glibc B<ppoll>() в этом аргументе передаётся постоянная "
"величина (равная I<sizeof(kernel_sigset_t)>). Описание различий sigset между "
"ядерным и библиотечным вызовом смотрите в B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man2/poll.2:469
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""
"Смотрите описание ложных уведомлений о готовности в разделе ДЕФЕКТЫ "
"справочной страницы B<select>(2)."

#. type: Plain text
#: man-pages/man2/poll.2:474
msgid ""
"B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<epoll>(7), "
"B<time>(7)"
msgstr ""
"B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<epoll>(7), "
"B<time>(7)"

#. type: TH
#: man-pages/man2/pkey_alloc.2:25
#, no-wrap
msgid "PKEY_ALLOC"
msgstr "PKEY_ALLOC"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:28
msgid "pkey_alloc, pkey_free - allocate or free a protection key"
msgstr "pkey_alloc, pkey_free - выделяет или освобождает ключ защиты"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:35
#, no-wrap
msgid ""
"B<int pkey_alloc(unsigned int >I<flags>B<, unsigned int >I<access_rights>B<);>\n"
"B<int pkey_free(int >I<pkey>B<);>\n"
msgstr ""
"B<int pkey_alloc(unsigned int >I<flags>B<, unsigned int >I<access_rights>B<);>\n"
"B<int pkey_free(int >I<pkey>B<);>\n"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:40
msgid ""
"B<pkey_alloc>()  allocates a protection key (pkey) and allows it to be "
"passed to B<pkey_mprotect>(2)."
msgstr ""
"Вызов B<pkey_alloc>() выделяет ключ защиты (pkey), который можно передавать "
"в B<pkey_mprotect>(2)."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:45
msgid ""
"The B<pkey_alloc>()  I<flags> is reserved for future use and currently must "
"always be specified as 0."
msgstr ""
"Аргумент I<flags> вызова B<pkey_alloc>() зарезервирован для использования в "
"будущем и в настоящее время должен равняться 0."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:50
msgid ""
"The B<pkey_alloc>()  I<access_rights> argument may contain zero or more "
"disable operations:"
msgstr ""
"Аргумент I<access_rights> вызова B<pkey_alloc>() может содержать ноль или "
"более запретительных операций:"

#. type: TP
#: man-pages/man2/pkey_alloc.2:50
#, no-wrap
msgid "B<PKEY_DISABLE_ACCESS>"
msgstr "B<PKEY_DISABLE_ACCESS>"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:53
msgid ""
"Disable all data access to memory covered by the returned protection key."
msgstr ""
"Запретить доступ ко всем данным памяти, на которую наложен возвращаемый ключ."

#. type: TP
#: man-pages/man2/pkey_alloc.2:53
#, no-wrap
msgid "B<PKEY_DISABLE_WRITE>"
msgstr "B<PKEY_DISABLE_WRITE>"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:56
msgid "Disable write access to memory covered by the returned protection key."
msgstr ""
"Запретить доступ на запись в память, на которую наложен возвращаемый ключ."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:62
msgid ""
"B<pkey_free>()  frees a protection key and makes it available for later "
"allocations.  After a protection key has been freed, it may no longer be "
"used in any protection-key-related operations."
msgstr ""
"Вызов B<pkey_free>() освобождает ключ защиты и делает его доступным для "
"будущего выделения. После освобождения ключа защиты он может больше не "
"использоваться в операциях по защите ключом."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:70
msgid ""
"An application should not call B<pkey_free>()  on any protection key which "
"has been assigned to an address range by B<pkey_mprotect>(2)  and which is "
"still in use.  The behavior in this case is undefined and may result in an "
"error."
msgstr ""
"Приложение не должно вызывать B<pkey_free>() с ключом защиты, который был "
"назначен адресному диапазону с помощью B<pkey_mprotect>(2) и который пока "
"используется. Это вызывает непредсказуемое поведение и может привести к "
"ошибке."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:80
msgid ""
"On success, B<pkey_alloc>()  returns a positive protection key value.  On "
"success, B<pkey_free>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<pkey_alloc>() возвращается положительное значение "
"ключа защиты. При успешном выполнении B<pkey_free>() возвращается ноль. При "
"ошибке возвращается -1 и I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:88
msgid "I<pkey>, I<flags>, or I<access_rights> is invalid."
msgstr "Неверное значение I<pkey>, I<flags> или I<access_rights>."

#. type: TP
#: man-pages/man2/pkey_alloc.2:88
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:97
msgid ""
"(B<pkey_alloc>())  All protection keys available for the current process "
"have been allocated.  The number of keys available is architecture-specific "
"and implementation-specific and may be reduced by kernel-internal use of "
"certain keys.  There are currently 15 keys available to user programs on x86."
msgstr ""
"(B<pkey_alloc>()) Все ключи защиты, доступные текущему процессу уже "
"распределены. Количество доступных ключей зависит от архитектуры и "
"реализации и может быть меньшим из-за использования отдельных ключей самим "
"ядром. В настоящее время на x86 для пользовательской программы доступно 15 "
"ключей."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:103
msgid ""
"This error will also be returned if the processor or operating system does "
"not support protection keys.  Applications should always be prepared to "
"handle this error, since factors outside of the application's control can "
"reduce the number of available pkeys."
msgstr ""
"Также эта ошибка возвращается, если процессор или операционная система не "
"поддерживают ключи защиты. Приложения всегда должны быть готовы к получению "
"этой ошибки, так как приложение не может контролировать сокращение "
"количества доступных pkey."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:109
msgid ""
"B<pkey_alloc>()  and B<pkey_free>()  were added to Linux in kernel 4.9; "
"library support was added in glibc 2.27."
msgstr ""
"Вызовы B<pkey_alloc>() и B<pkey_free>() были добавлены в Linux 4.9; "
"поддержка в glibc доступна с версии 2.27."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:115
msgid ""
"The B<pkey_alloc>()  and B<pkey_free>()  system calls are Linux-specific."
msgstr "Системные вызовы B<pkey_alloc>() и B<pkey_free>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:123
msgid ""
"B<pkey_alloc>()  is always safe to call regardless of whether or not the "
"operating system supports protection keys.  It can be used in lieu of any "
"other mechanism for detecting pkey support and will simply fail with the "
"error B<ENOSPC> if the operating system has no pkey support."
msgstr ""
"Вызов B<pkey_alloc>() всегда безопасен в независимости от поддержки ключей "
"операционной системой. Его можно использовать как механизм определения "
"поддержки pkey; он всегда просто возвращает ошибку B<ENOSPC>, если "
"операционная система не поддерживает pkey."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:134
msgid ""
"The kernel guarantees that the contents of the hardware rights register "
"(PKRU) will be preserved only for allocated protection keys.  Any time a key "
"is unallocated (either before the first call returning that key from "
"B<pkey_alloc>()  or after it is freed via B<pkey_free>()), the kernel may "
"make arbitrary changes to the parts of the rights register affecting access "
"to that key."
msgstr ""
"Ядро гарантирует, что содержимое аппаратных регистров прав (PKRU) будет "
"сохранено только для выделенных ключей защиты. Пока ключ не выделен (до "
"первого вызова, возвращающего этот ключ B<pkey_alloc>(), или после его "
"освобождения с помощью B<pkey_free>()), ядро может вносить произвольные "
"изменения в части регистров прав, относящихся к этому ключу."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:137
msgid "See B<pkeys>(7)."
msgstr "Смотрите B<pkeys>(7)."

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:139
msgid "B<pkey_mprotect>(2), B<pkeys>(7)"
msgstr "B<pkey_mprotect>(2), B<pkeys>(7)"

#. type: TH
#: man-pages/man2/pivot_root.2:10
#, no-wrap
msgid "PIVOT_ROOT"
msgstr "PIVOT_ROOT"

#. type: Plain text
#: man-pages/man2/pivot_root.2:13
msgid "pivot_root - change the root filesystem"
msgstr "pivot_root - изменяет корневую файловую систему"

#. type: Plain text
#: man-pages/man2/pivot_root.2:15
msgid ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"

#. type: Plain text
#: man-pages/man2/pivot_root.2:18
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#.  The
#.  .B CAP_SYS_ADMIN
#.  capability is required.
#. type: Plain text
#: man-pages/man2/pivot_root.2:27
msgid ""
"B<pivot_root>()  moves the root filesystem of the calling process to the "
"directory I<put_old> and makes I<new_root> the new root filesystem of the "
"calling process."
msgstr ""
"Вызов B<pivot_root>() перемещает корневую систему вызывающего процесса в "
"каталог I<put_old> и делает каталог I<new_root> новой корневой файловой "
"системой у вызывающего процесса."

#. type: Plain text
#: man-pages/man2/pivot_root.2:34
msgid ""
"The typical use of B<pivot_root>()  is during system startup, when the "
"system mounts a temporary root filesystem (e.g., an B<initrd>), then mounts "
"the real root filesystem, and eventually turns the latter into the current "
"root of all relevant processes or threads."
msgstr ""
"Обычно, B<pivot_root>() используется при загрузке, когда система монтирует "
"временную корневую файловую систему (например, B<initrd>), а затем монтирует "
"настоящую корневую файловую систему, делая, тем самым, её корневой для всех "
"последующих процессов или нитей."

#. type: Plain text
#: man-pages/man2/pivot_root.2:46
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""
"Вызов B<pivot_root>() может изменить (или не изменить) текущий корневой и "
"текущий рабочий каталоги во всех процессах или нитях, использующих старый "
"корневой каталог. Вызывающий B<pivot_root>() должен быть уверен в том, что "
"процессы у которых корневой или текущий рабочий каталог равен старому "
"корневому каталогу, работают нормально в каждом случае. Самый простой способ "
"достичь этого — сменить их корневой и текущий рабочий каталог на I<new_root> "
"до вызова B<pivot_root>()."

#. type: Plain text
#: man-pages/man2/pivot_root.2:62
msgid ""
"The paragraph above is intentionally vague because the implementation of "
"B<pivot_root>()  may change in the future.  At the time of writing, "
"B<pivot_root>()  changes root and current working directory of each process "
"or thread to I<new_root> if they point to the old root directory.  This is "
"necessary in order to prevent kernel threads from keeping the old root "
"directory busy with their root and current working directory, even if they "
"never access the filesystem in any way.  In the future, there may be a "
"mechanism for kernel threads to explicitly relinquish any access to the "
"filesystem, such that this fairly intrusive mechanism can be removed from "
"B<pivot_root>()."
msgstr ""
"Содержимое предыдущего абзаца, на самом деле, является не совсем "
"определённым, потому что реализация B<pivot_root>() может измениться в "
"будущем. На момент написания этого документа B<pivot_root>() изменяет "
"корневой и текущий рабочий каталоги каждого процесса или нити на "
"I<new_root>, если они указывают на старый корневой каталог. Это необходимо "
"для того, чтобы нити ядра не занимали старый корневой и текущий рабочий "
"каталог, даже если они вообще не обращались к файловой системе. В будущем, "
"возможно, будет создан механизм, заставляющий нити ядра отказаться от "
"доступа к файловой системе, что позволит удалить этот довольно навязчивый "
"механизм из B<pivot_root>()."

#. type: Plain text
#: man-pages/man2/pivot_root.2:69
msgid ""
"Note that this also applies to the calling process: B<pivot_root>()  may or "
"may not affect its current working directory.  It is therefore recommended "
"to call B<chdir(\"/\")> immediately after B<pivot_root>()."
msgstr ""
"Заметим, что всё это относится и к вызывающему процессу: B<pivot_root>() "
"может изменить (а может и не изменить) его текущий рабочий каталог. По этой "
"причине рекомендуется вызывать B<chdir(\"/\")> сразу после вызова "
"B<pivot_root>()."

#. type: Plain text
#: man-pages/man2/pivot_root.2:71
msgid "The following restrictions apply to I<new_root> and I<put_old>:"
msgstr ""
"На значения I<new_root> и I<put_old> накладываются следующие ограничения:"

#. type: Plain text
#: man-pages/man2/pivot_root.2:73
msgid "They must be directories."
msgstr "Они должны быть каталогами."

#. type: Plain text
#: man-pages/man2/pivot_root.2:76
msgid ""
"I<new_root> and I<put_old> must not be on the same filesystem as the current "
"root."
msgstr ""
"Аргументы I<new_root> и I<put_old> не могут быть в одной файловой системе с "
"текущим корневым каталогом."

#. type: Plain text
#: man-pages/man2/pivot_root.2:80
msgid ""
"I<put_old> must be underneath I<new_root>, that is, adding a nonzero number "
"of I</..> to the string pointed to by I<put_old> must yield the same "
"directory as I<new_root>."
msgstr ""
"Аргумент I<put_old> должен быть в дереве каталогов I<new_root>, т.е., путём "
"добавления ненулевого количества I</..> в строке, на которую указывает "
"I<put_old>, можно получить каталог, равный I<new_root>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:82
msgid "No other filesystem may be mounted on I<put_old>."
msgstr "К I<put_old> не должны быть подмонтированы файловые системы."

#. type: Plain text
#: man-pages/man2/pivot_root.2:86
msgid "See also B<pivot_root>(8)  for additional usage examples."
msgstr ""
"См. также страницу B<pivot_root>(8), в которой приведены примеры возможного "
"использования."

#. type: Plain text
#: man-pages/man2/pivot_root.2:93
msgid ""
"If the current root is not a mount point (e.g., after B<chroot>(2)  or "
"B<pivot_root>(), see also below), not the old root directory, but the mount "
"point of that filesystem is mounted on I<put_old>."
msgstr ""
"Если текущий корневой каталог не является точкой монтирования (например, "
"после B<chroot>(2) или B<pivot_root>(), см. ниже), то к I<put_old> "
"подключается не старый корневой каталог, а точка монтирования этой файловой "
"системы."

#. type: Plain text
#: man-pages/man2/pivot_root.2:99
msgid ""
"I<new_root> must be a mount point.  (If it is not otherwise a mount point, "
"it suffices to bind mount I<new_root> on top of itself.)"
msgstr ""
"Значение I<new_root> должно быть точкой монтирования (если это не точка "
"монтирования, то достаточно привязать монтирование I<new_root> поверх самой "
"себя)."

#. type: Plain text
#: man-pages/man2/pivot_root.2:108
msgid ""
"The propagation type of I<new_root> and its parent mount must not be "
"B<MS_SHARED>; similarly, if I<put_old> is an existing mount point, its "
"propagation type must not be B<MS_SHARED>."
msgstr ""
"Типа распространения I<new_root> и его родительского монтирования не должно "
"быть B<MS_SHARED>; схожим образом, если I<put_old> — существующая точка "
"монтирования, то её тип распространения не должен быть B<MS_SHARED>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:112
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/pivot_root.2:117
msgid ""
"B<pivot_root>()  may return (in I<errno>) any of the errors returned by "
"B<stat>(2).  Additionally, it may return:"
msgstr ""
"Вызов B<pivot_root>() может возвращать (в I<errno>) любые ошибки, которые "
"возвращаются B<stat>(2). Также он может вернуть:"

#. type: TP
#: man-pages/man2/pivot_root.2:117
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/pivot_root.2:121
msgid ""
"I<new_root> or I<put_old> are on the current root filesystem, or a "
"filesystem is already mounted on I<put_old>."
msgstr ""
"Аргумент I<new_root> или I<put_old> находится в текущей корневой файловой "
"системе, или какая-то файловая система уже смонтирована в I<put_old>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:125
msgid "I<new_root> is not a mount point."
msgstr "Значение I<new_root> не является точкой монтирования."

#. type: Plain text
#: man-pages/man2/pivot_root.2:128
msgid "I<put_old> is not underneath I<new_root>."
msgstr "Аргумент I<put_old> не находится в дереве каталогов I<new_root>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:131
msgid "The current root is on the rootfs (initial ramfs) filesystem."
msgstr ""
"Текущий корень расположен на файловой системе rootfs (начальная ramfs)."

#. type: Plain text
#: man-pages/man2/pivot_root.2:138
msgid ""
"Either the mount point at I<new_root>, or the parent mount of that mount "
"point, has propagation type B<MS_SHARED>."
msgstr ""
"Точка монтирования I<new_root> и её родительское монтирование имеет тип "
"распространения B<MS_SHARED>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:143
msgid "I<put_old> is a mount point and has the propagation type B<MS_SHARED>."
msgstr ""
"Значение I<put_old> является точкой монтирования и имеет тип распространения "
"B<MS_SHARED>."

#. type: TP
#: man-pages/man2/pivot_root.2:143
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/pivot_root.2:146
msgid "I<new_root> or I<put_old> is not a directory."
msgstr "Аргумент I<new_root> или I<put_old> не является каталогом."

#. type: Plain text
#: man-pages/man2/pivot_root.2:151
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr "Вызывающий процесс не имеет мандата B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/pivot_root.2:154
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr "Вызов B<pivot_root>() появился в Linux 2.3.41."

#. type: Plain text
#: man-pages/man2/pivot_root.2:157
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr ""
"Вызов B<pivot_root>() есть только в Linux и поэтому его использование не "
"переносимо."

#. type: Plain text
#: man-pages/man2/pivot_root.2:160
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/pivot_root.2:172
msgid ""
"The rootfs (initial ramfs) cannot be B<pivot_root>()ed.  The recommended "
"method of changing the root filesystem in this case is to delete everything "
"in rootfs, overmount rootfs with the new root, attach I<stdin>/I<stdout>/"
"I<stderr> to the new I</dev/console>, and exec the new B<init>(1).  Helper "
"programs for this process exist; see B<switch_root>(8)."
msgstr ""
"Для rootfs (начальная ramfs) нельзя вызвать B<pivot_root>(). Рекомендуемым "
"методом изменения корневой файловой системы в этом случае является удаление "
"всего в rootfs, перемонтирование в rootfs нового корня, присоединение "
"I<stdin>/I<stdout>/I<stderr> к новой I</dev/console> и запуск нового "
"B<init>(1). Для этого существуют вспомогательные программы; смотрите "
"B<switch_root>(8)."

#. type: Plain text
#: man-pages/man2/pivot_root.2:176
msgid ""
"B<pivot_root>()  should not have to change root and current working "
"directory of all other processes in the system."
msgstr ""
"Вызов B<pivot_root>() не должен изменять корневой и рабочий каталоги других "
"процессов в системе."

#. type: Plain text
#: man-pages/man2/pivot_root.2:181
msgid ""
"Some of the more obscure uses of B<pivot_root>()  may quickly lead to "
"insanity."
msgstr ""
"Некорректное использование B<pivot_root>() может привести к непредсказуемым "
"последствиям."

#. type: Plain text
#: man-pages/man2/pivot_root.2:188
msgid ""
"B<chdir>(2), B<chroot>(2), B<mount>(2), B<stat>(2), B<initrd>(4), "
"B<pivot_root>(8), B<switch_root>(8)"
msgstr ""
"B<chdir>(2), B<chroot>(2), B<mount>(2), B<stat>(2), B<initrd>(4), "
"B<pivot_root>(8), B<switch_root>(8)"

#. type: TH
#: man-pages/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr "PAUSE"

#. type: TH
#: man-pages/man2/pause.2:30
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man2/pause.2:33
msgid "pause - wait for signal"
msgstr "pause - ждать сигнала"

#. type: Plain text
#: man-pages/man2/pause.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr "B<int pause(void);>"

#. type: Plain text
#: man-pages/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr ""
"B<pause>() заставляет вызвавший процесс (или нить) уснуть до тех пор, пока "
"не поступит сигнал, который или завершит процесс, или приведёт к запуску "
"функции, обрабатывающей сигнал."

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: man-pages/man2/pause.2:53
msgid ""
"B<pause>()  returns only when a signal was caught and the signal-catching "
"function returned.  In this case, B<pause>()  returns -1, and I<errno> is "
"set to B<EINTR>."
msgstr ""
"B<pause>() возвращает значение, только когда был пойман сигнал и завершилась "
"функция его обработки. В этом случае B<pause>() возвращает -1, а I<errno> "
"устанавливается равной B<EINTR>."

#. type: Plain text
#: man-pages/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr "пойман сигнал и завершилась функция его обработки."

#. type: Plain text
#: man-pages/man2/pause.2:59
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/pause.2:63
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"

#. type: Plain text
#: man-pages/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr "pipe, pipe2 - создаёт канал"

#. type: Plain text
#: man-pages/man2/pipe.2:42
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:48
#, no-wrap
msgid ""
"/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */\n"
"B<struct fd_pair {>\n"
"B<long fd[2];>\n"
"B<};>\n"
"B<struct fd_pair pipe();>\n"
msgstr ""
"/* На Alpha, IA-64, MIPS, SuperH и SPARC/SPARC64; смотрите ЗАМЕЧАНИЯ */\n"
"B<struct fd_pair {>\n"
"B<long fd[2];>\n"
"B<};>\n"
"B<struct fd_pair pipe();>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:51
#, no-wrap
msgid ""
"/* On all other architectures */\n"
"B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr ""
"/* На остальных архитектурах */\n"
"B<int pipe(int >I<pipefd>B<[2]);>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:55
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Определение констант O_* */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:57
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:73
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""
"B<pipe>() создаёт однонаправленный канал данных, который можно использовать "
"для взаимодействия между процессами. Массив I<pipefd> используется для "
"возврата двух файловых описателей, указывающих на концы канала. I<pipefd[0]> "
"указывает на конец канала для чтения. I<pipefd[1]> указывает на конец канала "
"для записи. Данные, записанные в конец канала, буферизируются ядром до тех "
"пор, пока не будут прочитаны из конца канала для чтения. Подробней см. "
"B<pipe>(7)."

#. type: Plain text
#: man-pages/man2/pipe.2:83
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""
"Если I<flags> равно 0, то B<pipe2>() выполняет то же что и B<pipe>(). "
"Следующие значения могут быть побитово сложены в I<flags> для получения "
"различного поведения:"

#. type: TP
#: man-pages/man2/pipe.2:83
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/pipe.2:91
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""
"Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для двух новых открытых "
"файловых дескрипторов. Смотрите описание того же флага в B<open>(2) для "
"того, чтобы узнать как это может пригодиться."

#. type: TP
#: man-pages/man2/pipe.2:91
#, no-wrap
msgid "B<O_DIRECT> (since Linux 3.4)"
msgstr "B<O_DIRECT> (начиная с Linux 3.4)"

#.  commit 9883035ae7edef3ec62ad215611cb8e17d6a1a5d
#. type: Plain text
#: man-pages/man2/pipe.2:101
msgid ""
"Create a pipe that performs I/O in \"packet\" mode.  Each B<write>(2)  to "
"the pipe is dealt with as a separate packet, and B<read>(2)s from the pipe "
"will read one packet at a time.  Note the following points:"
msgstr ""
"Создаёт канал, в котором ввод-вывод выполняется в «пакетном» режиме. Каждый "
"B<write>(2) в канал рассматривается как отдельный пакет, а B<read>(2) из "
"канала читает один пакет за раз. Заметим следующее:"

#. type: Plain text
#: man-pages/man2/pipe.2:112
msgid ""
"Writes of greater than B<PIPE_BUF> bytes (see B<pipe>(7))  will be split "
"into multiple packets.  The constant B<PIPE_BUF> is defined in I<E<lt>limits."
"hE<gt>>."
msgstr ""
"Запись более B<PIPE_BUF> байт (смотрите B<pipe>(7)) будет разделена на "
"несколько пакетов. Константа B<PIPE_BUF> определена в I<E<lt>limits.hE<gt>>."

#. type: Plain text
#: man-pages/man2/pipe.2:122
msgid ""
"If a B<read>(2)  specifies a buffer size that is smaller than the next "
"packet, then the requested number of bytes are read, and the excess bytes in "
"the packet are discarded.  Specifying a buffer size of B<PIPE_BUF> will be "
"sufficient to read the largest possible packets (see the previous point)."
msgstr ""
"Если в B<read>(2) указан размер буфера меньше чем следующий пакет, то "
"читается запрашиваемое количество байт, а лишние байты пакета отбрасываются. "
"Указание B<PIPE_BUF> в качестве размера буфера будет достаточно для чтения "
"самых больших пакетов (смотрите предыдущее примечание)."

#. type: Plain text
#: man-pages/man2/pipe.2:127
msgid ""
"Zero-length packets are not supported.  (A B<read>(2)  that specifies a "
"buffer size of zero is a no-op, and returns 0.)"
msgstr ""
"Пакеты нулевой длины не поддерживаются (вызов B<read>(2) с нулевым размером "
"буфера ничего не делает и возвращает 0)."

#. type: Plain text
#: man-pages/man2/pipe.2:132
msgid ""
"Older kernels that do not support this flag will indicate this via an "
"B<EINVAL> error."
msgstr ""
"Старые ядра, которые не поддерживают этот флаг, возвращают ошибку B<EINVAL>."

#.  commit 0dbf5f20652108106cb822ad7662c786baaa03ff
#.  FIXME . But, it is not possible to specify O_DIRECT when opening a FIFO
#. type: Plain text
#: man-pages/man2/pipe.2:140
msgid ""
"Since Linux 4.5, it is possible to change the B<O_DIRECT> setting of a pipe "
"file descriptor using B<fcntl>(2)."
msgstr ""
"Начиная с Linux 4.5, у файлового дескриптора канала возможно менять "
"установку B<O_DIRECT> с помощью B<fcntl>(2)."

#. type: TP
#: man-pages/man2/pipe.2:140
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/pipe.2:149
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file descriptions "
"referred to by the new file descriptors.  Using this flag saves extra calls "
"to B<fcntl>(2)  to achieve the same result."
msgstr ""
"Устанавливает флаг состояния файла B<O_NONBLOCK> для открытого файлового "
"описания, на которое ссылаются новые файловые дескрипторы. Использование "
"данного флага делает ненужными дополнительные вызовы B<fcntl>(2) для "
"достижения того же результата."

#. type: Plain text
#: man-pages/man2/pipe.2:156
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<pipefd> is left unchanged."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, "
"I<errno> устанавливается в соответствующее значение, а I<pipefd> не "
"изменяется."

#.  http://austingroupbugs.net/view.php?id=467
#. type: Plain text
#: man-pages/man2/pipe.2:170
msgid ""
"On Linux (and other systems), B<pipe>()  does not modify I<pipefd> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2016.  The Linux-specific B<pipe2>()  system call likewise does not "
"modify I<pipefd> on failure."
msgstr ""
"В Linux (и других системах) B<pipe>() не изменяет I<pipefd> при ошибке. "
"Требование стандартизации этого поведения было добавлено в POSIX.1-2016. "
"Системный вызов Linux B<pipe2>() также не изменяет I<pipefd> при ошибке."

#. type: Plain text
#: man-pages/man2/pipe.2:175
msgid "I<pipefd> is not valid."
msgstr "I<pipefd> задан некорректно."

#. type: Plain text
#: man-pages/man2/pipe.2:180
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr "(B<pipe2>())  Некорректное значение I<flags>."

#. type: TP
#: man-pages/man2/pipe.2:180
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/pipe.2:183
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""
"Было достигнуто ограничение по количеству открытых файловых дескрипторов на "
"процесс."

#. type: TP
#: man-pages/man2/pipe.2:183 man-pages/man2/pipe.2:186
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man2/pipe.2:186
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: Plain text
#: man-pages/man2/pipe.2:191
msgid ""
"The user hard limit on memory that can be allocated for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""
"Достигнуто жёсткое пользовательское ограничение на выделение памяти для "
"каналов и вызывающий не имеет дополнительных прав; смотрите B<pipe>(7)."

#. type: Plain text
#: man-pages/man2/pipe.2:196
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"Вызов B<pipe2>() был добавлен в Linux начиная с версии 2.6.27; поддержка в "
"glibc появилась начиная с версии 2.9."

#.  See http://math-atlas.sourceforge.net/devel/assembly/64.psabi.1.33.ps.Z
#.  for example, section 3.2.1 "Registers and the Stack Frame".
#. type: Plain text
#: man-pages/man2/pipe.2:213
msgid ""
"The SystemV ABI on some architectures allows the use of more than one "
"register for returning multiple values; several architectures (namely, "
"Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64)  (ab)use this feature in "
"order to implement the B<pipe>()  system call in a functional manner: the "
"call doesn't take any arguments and returns a pair of file descriptors as "
"the return value on success.  The glibc B<pipe>()  wrapper function "
"transparently deals with this.  See B<syscall>(2)  for information regarding "
"registers used for storing second file descriptor."
msgstr ""
"SystemV ABI на некоторых архитектурах позволяет использовать более одного "
"регистра для возврата нескольких значений; в нескольких архитектурах (Alpha, "
"IA-64, MIPS, SuperH и SPARC/SPARC64) использована эта возможность для "
"реализации системного вызова B<pipe>() подобно функциям: вызов не использует "
"параметры и при успешном выполнении возвращает пару файловых дескрипторов "
"как результат. Обёрточная функция glibc B<pipe>() учитывает это. Описание "
"регистров хранения второго файлового дескриптора смотрите в  B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/pipe.2:216
msgid "B<pipe>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<pipe>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/pipe.2:219
msgid "B<pipe2>()  is Linux-specific."
msgstr "Вызов B<pipe2>() есть только в Linux."

#.  fork.2 refers to this example program.
#. type: Plain text
#: man-pages/man2/pipe.2:235
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the file "
"descriptors that it doesn't need for the pipe (see B<pipe>(7)).  The parent "
"then writes the string contained in the program's command-line argument to "
"the pipe, and the child reads this string a byte at a time from the pipe and "
"echoes it on standard output."
msgstr ""
"Следующая программа создаёт канал, и затем выполняет B<fork>(2) для создания "
"потомка; потомок наследует скопированный набор файловых дескрипторов, "
"которые указывают на тот же канал. После B<fork>(2) каждый процесс закрывает "
"файловые дескрипторы, которые ненужны каналу (см. B<pipe>(7)). Затем "
"родитель записывает строку, переданную в качестве аргумента командной "
"строки, в канал, а потомок читает эту строку из канала по байту за раз, и "
"выводит её на стандартный вывод."

#. type: Plain text
#: man-pages/man2/pipe.2:243
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/pipe.2:250
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"

#. type: Plain text
#: man-pages/man2/pipe.2:255
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/pipe.2:260
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/pipe.2:266
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/pipe.2:269
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""
"    if (cpid == 0) {    /* Потомок читает из канала */\n"
"        close(pipefd[1]);          /* Закрывает неиспользуемый конец для записи */\n"

#. type: Plain text
#: man-pages/man2/pipe.2:272
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"

#. type: Plain text
#: man-pages/man2/pipe.2:276
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/pipe.2:285
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"    } else {            /* Родитель пишет значение argv[1] в канал */\n"
"        close(pipefd[0]);          /* Закрывает неиспользуемый конец для чтения */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Читатель видит EOF */\n"
"        wait(NULL);                /* Ожидание потомка */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/pipe.2:295
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<tee>(2), "
"B<vmsplice>(2), B<write>(2), B<popen>(3), B<pipe>(7)"
msgstr ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<tee>(2), "
"B<vmsplice>(2), B<write>(2), B<popen>(3), B<pipe>(7)"

#. type: TH
#: man-pages/man2/perfmonctl.2:27
#, no-wrap
msgid "PERFMONCTL"
msgstr "PERFMONCTL"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:30
msgid "perfmonctl - interface to IA-64 performance monitoring unit"
msgstr "perfmonctl - интерфейс к блоку слежения за производительностью IA-64"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"
msgstr ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:36
#, no-wrap
msgid "B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int >I<narg>B<);>\n"
msgstr "B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int >I<narg>B<);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:47
msgid ""
"The IA-64-specific B<perfmonctl>()  system call provides an interface to the "
"PMU (performance monitoring unit).  The PMU consists of PMD (performance "
"monitoring data) registers and PMC (performance monitoring control) "
"registers, which gather hardware statistics."
msgstr ""
"Специальный системный вызов B<perfmonctl>() для IA-64 предоставляет "
"интерфейс к PMU (блок слежения за производительностью, perfomance monitoring "
"unit). PMU содержит регистры PMD (данные производительности, performance "
"monitoring data) и PMC (управление слежением за производительностью, "
"performance monitoring control), в которых собирается статистика по "
"аппаратному обеспечению."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:57
msgid ""
"B<perfmonctl>()  applies the operation I<cmd> to the input arguments "
"specified by I<arg>.  The number of arguments is defined by I<narg>.  The "
"I<fd> argument specifies the perfmon context to operate on."
msgstr ""
"Вызов B<perfmonctl>() выполняет операцию I<cmd> над входными аргументами, "
"указанными в I<arg>. Количество аргументов указывается в I<narg>. В "
"аргументе I<fd> задаётся контекст perfmon для операции."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:61
msgid "Supported values for I<cmd> are:"
msgstr "Поддерживаемые значения I<cmd>:"

#. type: TP
#: man-pages/man2/perfmonctl.2:61
#, no-wrap
msgid "B<PFM_CREATE_CONTEXT>"
msgstr "B<PFM_CREATE_CONTEXT>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:65
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, 1);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, 1);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:67
msgid "Set up a context."
msgstr "Создаёт контекст."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:74
msgid ""
"The I<fd> parameter is ignored.  A new perfmon context is created as "
"specified in I<ctxt> and its file descriptor is returned in I<ctxt-"
"E<gt>ctx_fd>."
msgstr ""
"Параметр I<fd> игнорируется. Создаётся новый контекст perfmon согласно "
"I<ctxt> и его файловый дескриптор возвращается в I<ctxt-E<gt>ctx_fd>."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:86
msgid ""
"The file descriptor can be used in subsequent calls to B<perfmonctl>()  and "
"can be used to read event notifications (type I<pfm_msg_t>)  using "
"B<read>(2).  The file descriptor is pollable using B<select>(2), B<poll>(2), "
"and B<epoll>(7)."
msgstr ""
"Файловый дескриптор можно использовать в последующих вызовах "
"B<perfmonctl>(), а также для чтения уведомлений о событиях (тип "
"I<pfm_msg_t>) с помощью B<read>(2). Файловый дескриптор можно опрашивать с "
"помощью B<select>(2), B<poll>(2) и B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:90
msgid ""
"The context can be destroyed by calling B<close>(2)  on the file descriptor."
msgstr ""
"Контекст можно уничтожить вызвав B<close>(2), указав файловый дескриптор."

#. type: TP
#: man-pages/man2/perfmonctl.2:90
#, no-wrap
msgid "B<PFM_WRITE_PMCS>"
msgstr "B<PFM_WRITE_PMCS>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:95
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:97
msgid "Set PMC registers."
msgstr "Назначает значения регистрам PMC."

#. type: TP
#: man-pages/man2/perfmonctl.2:97
#, no-wrap
msgid "B<PFM_WRITE_PMDS>"
msgstr "B<PFM_WRITE_PMDS>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:101
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"

#.  pfm_write_pmds()
#. type: Plain text
#: man-pages/man2/perfmonctl.2:104
msgid "Set PMD registers."
msgstr "Назначает значения регистрам PMD."

#. type: TP
#: man-pages/man2/perfmonctl.2:104
#, no-wrap
msgid "B<PFM_READ_PMDS>"
msgstr "B<PFM_READ_PMDS>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:109
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:111
msgid "Read PMD registers."
msgstr "Читает регистры PMD."

#. type: TP
#: man-pages/man2/perfmonctl.2:111
#, no-wrap
msgid "B<PFM_START>"
msgstr "B<PFM_START>"

#.  .BI  "perfmonctl(int " fd ", PFM_START, arg, 1);
#. type: Plain text
#: man-pages/man2/perfmonctl.2:117
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:119
msgid "Start monitoring."
msgstr "Запускает слежение."

#. type: TP
#: man-pages/man2/perfmonctl.2:119
#, no-wrap
msgid "B<PFM_STOP>"
msgstr "B<PFM_STOP>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:124
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:126
msgid "Stop monitoring."
msgstr "Останавливает слежение."

#. type: TP
#: man-pages/man2/perfmonctl.2:126
#, no-wrap
msgid "B<PFM_LOAD_CONTEXT>"
msgstr "B<PFM_LOAD_CONTEXT>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:131
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, 1);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, 1);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:133
msgid "Attach the context to a thread."
msgstr "Присоединяет контекст к нити."

#. type: TP
#: man-pages/man2/perfmonctl.2:133
#, no-wrap
msgid "B<PFM_UNLOAD_CONTEXT>"
msgstr "B<PFM_UNLOAD_CONTEXT>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:138
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:140
msgid "Detach the context from a thread."
msgstr "Отсоединяет контекст от нити."

#. type: TP
#: man-pages/man2/perfmonctl.2:140
#, no-wrap
msgid "B<PFM_RESTART>"
msgstr "B<PFM_RESTART>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:145
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:147
msgid "Restart monitoring after receiving an overflow notification."
msgstr "Перезапускает слежение после приёма уведомления о переполнении."

#. type: TP
#: man-pages/man2/perfmonctl.2:147
#, no-wrap
msgid "B<PFM_GET_FEATURES>"
msgstr "B<PFM_GET_FEATURES>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:152
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_GET_FEATURES, pfarg_features_t *>I<arg>B<, 1);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_GET_FEATURES, pfarg_features_t *>I<arg>B<, 1);>\n"

#. type: TP
#: man-pages/man2/perfmonctl.2:153
#, no-wrap
msgid "B<PFM_DEBUG>"
msgstr "B<PFM_DEBUG>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:158
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:162
msgid "If I<val> is nonzero, enable debugging mode, otherwise disable."
msgstr ""
"Если I<val> не равно нулю, то включает режим отладки, в противном случае "
"выключает."

#. type: TP
#: man-pages/man2/perfmonctl.2:162
#, no-wrap
msgid "B<PFM_GET_PMC_RESET_VAL>"
msgstr "B<PFM_GET_PMC_RESET_VAL>"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:167
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t *>I<req>B<, n);>\n"
msgstr "B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t *>I<req>B<, n);>\n"

#.  .TP
#.  .B PFM_CREATE_EVTSETS
#.  create or modify event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_CREATE_EVTSETS, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_DELETE_EVTSETS
#.  delete event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_DELETE_EVTSET, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_GETINFO_EVTSETS
#.  get information about event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_GETINFO_EVTSETS, pfarg_setinfo_t *info, n);
#.  .fi
#. type: Plain text
#: man-pages/man2/perfmonctl.2:190
msgid "Reset PMC registers to default values."
msgstr "Сбрасывает регистры PMC в их значения по умолчанию."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:196
msgid ""
"B<perfmonctl>()  returns zero when the operation is successful.  On error, "
"-1 is returned and I<errno> is set to indicate the cause of the error."
msgstr ""
"При успешном выполнении операции B<perfmonctl>() возвращает ноль. При ошибке "
"возвращается -1, а в I<errno> записывается причина ошибки."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:199
msgid "B<perfmonctl>()  is available since Linux 2.4."
msgstr "B<perfmonctl>() доступна в Linux начиная с 2.4."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:202
msgid ""
"B<perfmonctl>()  is Linux-specific and is available only on the IA-64 "
"architecture."
msgstr ""
"Вызов B<perfmonctl>() есть только в Linux и доступен только для архитектуры "
"IA-64."

#. type: Plain text
#: man-pages/man2/perfmonctl.2:207
msgid "B<gprof>(1)"
msgstr "B<gprof>(1)"

#. type: Plain text
#: man-pages/man2/perfmonctl.2:208
msgid "The perfmon2 interface specification"
msgstr "Спецификация интерфейса perfmon2"

#. type: TH
#: man-pages/man2/pciconfig_read.2:8
#, no-wrap
msgid "PCICONFIG_READ"
msgstr "PCICONFIG_READ"

#. type: TH
#: man-pages/man2/pciconfig_read.2:8
#, no-wrap
msgid "2016-07-17"
msgstr "2016-07-17"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:11
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - работа с информацией "
"устройства PCI"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:14
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr "B<#include E<lt>pci.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:21
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:27
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"user space."
msgstr ""
"Всё взаимодействие с устройствами PCI, в основном, уже выполнено в ядре на "
"уровне PCI, и поэтому данные вызовы, обычно, ненужны при вызове из "
"пользовательского пространства."

#. type: TP
#: man-pages/man2/pciconfig_read.2:27 man-pages/man2/pciconfig_read.2:51
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr "B<pciconfig_read>()"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:36
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr ""
"Выполняет чтение в буфер I<buf> из устройства I<dev> со смещением I<off>."

#. type: TP
#: man-pages/man2/pciconfig_read.2:36 man-pages/man2/pciconfig_read.2:57
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr "B<pciconfig_write>()"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:45
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr ""
"Выполняет запись буфера I<buf> в устройство I<dev> со смещением I<off>."

#. type: TP
#: man-pages/man2/pciconfig_read.2:45 man-pages/man2/pciconfig_read.2:63
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr "B<pciconfig_iobase>()"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:50
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""
"Принимает пару шина/функция_устройства и возвращает физический адрес или "
"смещения в памяти (для таких вещей как prep, это 0xc0000000), базы ввода-"
"вывода для циклов PIO, или промежутки (holes) ISA, если они есть."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:57 man-pages/man2/pciconfig_read.2:63
msgid ""
"On success, zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, "
"а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:77
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""
"Возвращает информацию о расположении различных областей ввода-вывода в "
"физической памяти согласно значению I<which>. Значениями I<which> могут "
"быть: B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, "
"B<IOBASE_ISA_IO>, B<IOBASE_ISA_MEM>."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:84
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr "Неправильное значение I<len>. Не применимо к B<pciconfig_iobase>()."

#. type: TP
#: man-pages/man2/pciconfig_read.2:84
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:87
msgid "I/O error."
msgstr "Ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:93
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""
"Для B<pciconfig_iobase>() значение «рукава (hose)» равно NULL. Для других "
"вызовов не удаётся найти слот."

#. type: TP
#: man-pages/man2/pciconfig_read.2:93
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:98
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""
"Данные вызовы в системе не реализованы (не определён макрос B<CONFIG_PCI>)."

#. type: TP
#: man-pages/man2/pciconfig_read.2:98
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:105
msgid ""
"This return value is valid only for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""
"Данное значение верно только для B<pciconfig_iobase>(). Возвращается, если "
"указано неверное значение I<which>."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:112
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""
"Пользователь не имеет мандата B<CAP_SYS_ADMIN>. Не применимо к "
"B<pciconfig_iobase>()."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:114
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""
"Данные вызовы есть только в Linux, они доступны начиная с версии "
"2.0.26/2.1.11."

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:115
msgid "B<capabilities>(7)"
msgstr "B<capabilities>(7)"

#. type: TH
#: man-pages/man2/perf_event_open.2:27
#, no-wrap
msgid "PERF_EVENT_OPEN"
msgstr "PERF_EVENT_OPEN"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:30
msgid "perf_event_open - set up performance monitoring"
msgstr "perf_event_open - настройка слежения за производительностью"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:38
#, no-wrap
msgid ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:47
msgid ""
"Given a list of parameters, B<perf_event_open>()  returns a file descriptor, "
"for use in subsequent system calls (B<read>(2), B<mmap>(2), B<prctl>(2), "
"B<fcntl>(2), etc.)."
msgstr ""
"Получая список параметров, B<perf_event_open>() возвращает файловый "
"дескриптор, который можно использовать в последующих вызовах (B<read>(2), "
"B<mmap>(2), B<prctl>(2), B<fcntl>(2) и т. п.)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:55
msgid ""
"A call to B<perf_event_open>()  creates a file descriptor that allows "
"measuring performance information.  Each file descriptor corresponds to one "
"event that is measured; these can be grouped together to measure multiple "
"events simultaneously."
msgstr ""
"Вызов B<perf_event_open>() создаёт файловый дескриптор, через который можно "
"получать измерения производительности. Каждый файловый дескриптор "
"соответствует одному измеряемому событию; события можно группировать для "
"одновременного измерения."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:62
msgid ""
"Events can be enabled and disabled in two ways: via B<ioctl>(2)  and via "
"B<prctl>(2).  When an event is disabled it does not count or generate "
"overflows but does continue to exist and maintain its count value."
msgstr ""
"События можно включать и выключать двумя способами: через B<ioctl>(2) и "
"через B<prctl>(2). Когда событие отключено, оно не учитывается и не "
"генерирует переполнения, но продолжает существовать и содержать своё "
"значение счётчика."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:76
msgid ""
"Events come in two flavors: counting and sampled.  A I<counting> event is "
"one that is used for counting the aggregate number of events that occur.  In "
"general, counting event results are gathered with a B<read>(2)  call.  A "
"I<sampling> event periodically writes measurements to a buffer that can then "
"be accessed via B<mmap>(2)."
msgstr ""
"События бывают двух видов: подсчитывающие (counting) и измеряющие (sampled). "
"I<Подсчитывающее> событие используется для сложения числа произошедших "
"событий. Обычно, результат подсчёта событий выбирается с помощью вызова "
"B<read>(2). I<Измеряющее> событие периодически пишет значения измерения в "
"буфер, который доступен через вызов B<mmap>(2)."

#. type: SS
#: man-pages/man2/perf_event_open.2:76
#, no-wrap
msgid "Arguments"
msgstr "Аргументы"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:83
msgid ""
"The I<pid> and I<cpu> arguments allow specifying which process and CPU to "
"monitor:"
msgstr "Аргументы I<pid> и I<cpu> позволяют задать отслеживаемый процесс и ЦП:"

#. type: TP
#: man-pages/man2/perf_event_open.2:83
#, no-wrap
msgid "B<pid == 0> and B<cpu == -1>"
msgstr "B<pid == 0> и B<cpu == -1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:86
msgid "This measures the calling process/thread on any CPU."
msgstr "Это позволяет измерять вызывающий процесс/нить на любом ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:86
#, no-wrap
msgid "B<pid == 0> and B<cpu E<gt>= 0>"
msgstr "B<pid == 0> и B<cpu E<gt>= 0>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:90
msgid ""
"This measures the calling process/thread only when running on the specified "
"CPU."
msgstr ""
"Это позволяет измерять вызывающий процесс/нить только, когда выполнение "
"происходит на указанном ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:90
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu == -1>"
msgstr "B<pid E<gt> 0> и B<cpu == -1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:93
msgid "This measures the specified process/thread on any CPU."
msgstr "Это позволяет измерять указанный процесс/нить на любом ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:93
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu E<gt>= 0>"
msgstr "B<pid E<gt> 0> и B<cpu E<gt>= 0>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:97
msgid ""
"This measures the specified process/thread only when running on the "
"specified CPU."
msgstr ""
"Это позволяет измерять указанный процесс/нить только, когда выполнение "
"происходит на указанном ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:97
#, no-wrap
msgid "B<pid == -1> and B<cpu E<gt>= 0>"
msgstr "B<pid == -1> и B<cpu E<gt>= 0>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:105
msgid ""
"This measures all processes/threads on the specified CPU.  This requires "
"B<CAP_SYS_ADMIN> capability or a I</proc/sys/kernel/perf_event_paranoid> "
"value of less than 1."
msgstr ""
"Это позволяет измерять все процессы/нити на указанном ЦП. Для этого "
"требуется мандат B<CAP_SYS_ADMIN> или значение в I</proc/sys/kernel/"
"perf_event_paranoid> должно быть меньше 1."

#. type: TP
#: man-pages/man2/perf_event_open.2:105
#, no-wrap
msgid "B<pid == -1> and B<cpu == -1>"
msgstr "B<pid == -1> и B<cpu == -1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:108
msgid "This setting is invalid and will return an error."
msgstr "Это некорректные значения и будет возвращена ошибка."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:116
msgid ""
"When I<pid> is greater than zero, permission to perform this system call is "
"governed by a ptrace access mode B<PTRACE_MODE_READ_REALCREDS> check; see "
"B<ptrace>(2)."
msgstr ""
"При I<pid> больше нуля право выполнять этот системный вызов определяется "
"проверкой режима доступа ptrace B<PTRACE_MODE_READ_REALCREDS>; смотрите "
"B<ptrace>(2)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:138
msgid ""
"The I<group_fd> argument allows event groups to be created.  An event group "
"has one event which is the group leader.  The leader is created first, with "
"I<group_fd> = -1.  The rest of the group members are created with subsequent "
"B<perf_event_open>()  calls with I<group_fd> being set to the file "
"descriptor of the group leader.  (A single event on its own is created with "
"I<group_fd> = -1 and is considered to be a group with only 1 member.)  An "
"event group is scheduled onto the CPU as a unit: it will be put onto the CPU "
"only if all of the events in the group can be put onto the CPU.  This means "
"that the values of the member events can be meaningfully compared\\(emadded, "
"divided (to get ratios), and so on\\(emwith each other, since they have "
"counted events for the same set of executed instructions."
msgstr ""
"Аргумент I<group_fd> позволяет создавать группы событий. У группы событий "
"есть одно событие, которое считается лидером. Лидер создаётся самым первым и "
"имеет I<group_fd> = -1. Оставшиеся члены группы создаются последующими "
"вызовами B<perf_event_open>() с I<group_fd> равным файловому дескриптору "
"лидера группы (единственное событие создаётся с I<group_fd> = -1 и "
"считается, что группу имеет только 1 члена). Группа событий планируется для "
"выполнения на одном ЦП как один элемент: он помещается на ЦП только, если "
"все события в группе могут размещаться на ЦП. Это означает, что значения "
"событий-членов могут сравниваться между собой — добавляться, делиться "
"(соотноситься друг с другом) и так далее — следовательно они подсчитывают "
"события для одного набора исполняемых инструкций."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:142
msgid ""
"The I<flags> argument is formed by ORing together zero or more of the "
"following values:"
msgstr ""
"Аргумент I<flags> формируется с помощью объединения логической операцией ИЛИ "
"нуля или более следующих значений:"

#. type: TP
#: man-pages/man2/perf_event_open.2:142
#, no-wrap
msgid "B<PERF_FLAG_FD_CLOEXEC> (since Linux 3.14)"
msgstr "B<PERF_FLAG_FD_CLOEXEC> (начиная с Linux 3.14)"

#.  commit a21b0b354d4ac39be691f51c53562e2c24443d9e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:159
msgid ""
"This flag enables the close-on-exec flag for the created event file "
"descriptor, so that the file descriptor is automatically closed on "
"B<execve>(2).  Setting the close-on-exec flags at creation time, rather than "
"later with B<fcntl>(2), avoids potential race conditions where the calling "
"thread invokes B<perf_event_open>()  and B<fcntl>(2)  at the same time as "
"another thread calls B<fork>(2)  then B<execve>(2)."
msgstr ""
"Этот флаг включает флаг close-on-exec на созданном файловом дескрипторе "
"события, то есть файловый дескриптор автоматически закрывается при "
"B<execve>(2). Установка флага close-on-exec при создании, а не в процессе "
"работы с помощью B<fcntl>(2), позволяет избежать потенциальной "
"состязательности, когда вызывающая нить вызывает B<perf_event_open>() и "
"B<fcntl>(2) одновременно с запуском другой нитью вызовов B<fork>(2) и "
"B<execve>(2)."

#. type: TP
#: man-pages/man2/perf_event_open.2:159
#, no-wrap
msgid "B<PERF_FLAG_FD_NO_GROUP>"
msgstr "B<PERF_FLAG_FD_NO_GROUP>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:167
msgid ""
"This flag tells the event to ignore the I<group_fd> parameter except for the "
"purpose of setting up output redirection using the B<PERF_FLAG_FD_OUTPUT> "
"flag."
msgstr ""
"Этот флаг указывает событию игнорировать параметр I<group_fd>, если не  "
"выполняется настройка перенаправления вывода с помощью флага "
"B<PERF_FLAG_FD_OUTPUT>."

#. type: TP
#: man-pages/man2/perf_event_open.2:167
#, no-wrap
msgid "B<PERF_FLAG_FD_OUTPUT> (broken since Linux 2.6.35)"
msgstr "B<PERF_FLAG_FD_OUTPUT> (не работает, начиная с Linux 2.6.35)"

#.  commit ac9721f3f54b27a16c7e1afb2481e7ee95a70318
#. type: Plain text
#: man-pages/man2/perf_event_open.2:173
msgid ""
"This flag re-routes the event's sampled output to instead be included in the "
"mmap buffer of the event specified by I<group_fd>."
msgstr ""
"Этот флаг переключает вывод измерений с буфера mmap в событие, указанное "
"I<group_fd>."

#. type: TP
#: man-pages/man2/perf_event_open.2:173
#, no-wrap
msgid "B<PERF_FLAG_PID_CGROUP> (since Linux 2.6.39)"
msgstr "B<PERF_FLAG_PID_CGROUP> (начиная с Linux 2.6.39)"

#.  commit e5d1367f17ba6a6fed5fd8b74e4d5720923e0c25
#. type: Plain text
#: man-pages/man2/perf_event_open.2:197
msgid ""
"This flag activates per-container system-wide monitoring.  A container is an "
"abstraction that isolates a set of resources for finer-grained control "
"(CPUs, memory, etc.).  In this mode, the event is measured only if the "
"thread running on the monitored CPU belongs to the designated container "
"(cgroup).  The cgroup is identified by passing a file descriptor opened on "
"its directory in the cgroupfs filesystem.  For instance, if the cgroup to "
"monitor is called I<test>, then a file descriptor opened on I</dev/cgroup/"
"test> (assuming cgroupfs is mounted on I</dev/cgroup>)  must be passed as "
"the I<pid> parameter.  cgroup monitoring is available only for system-wide "
"events and may therefore require extra permissions."
msgstr ""
"Этот флаг включает поконтейнерное системное слежение. Контейнер — это "
"абстракция, которая изолирует набор ресурсов для их точного расходования "
"(ЦП, память и т. п.). В этом режиме событие измеряется только, если нить "
"выполняется в отслеживаемом ЦП, принадлежащем назначенному контейнеру "
"(cgroup). Значение cgroup задаётся переданным файловым дескриптором, "
"открываемом в его каталоге в файловой системе cgroupfs. Например, если "
"отслеживаемая cgroup называется I<test>, то файловый дескриптор для I</dev/"
"cgroup/test> (предполагается, что cgroupfs смонтирована в I</dev/cgroup>) "
"должен передаваться как параметр I<pid>. Слежение за cgroup доступно только "
"для системных событий и поэтому требуется дополнительных прав."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:202
msgid ""
"The I<perf_event_attr> structure provides detailed configuration information "
"for the event being created."
msgstr ""
"Структура I<perf_event_attr> предоставляет подробную информацию о "
"создаваемом событии."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:209
#, no-wrap
msgid ""
"struct perf_event_attr {\n"
"    __u32 type;                 /* Type of event */\n"
"    __u32 size;                 /* Size of attribute structure */\n"
"    __u64 config;               /* Type-specific configuration */\n"
msgstr ""
"struct perf_event_attr {\n"
"    __u32 type;         /* тип события */\n"
"    __u32 size;         /* размер структуры атрибутов */\n"
"    __u64 config;       /* настройки для типа */\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:214
#, no-wrap
msgid ""
"    union {\n"
"        __u64 sample_period;    /* Period of sampling */\n"
"        __u64 sample_freq;      /* Frequency of sampling */\n"
"    };\n"
msgstr ""
"    union {\n"
"        __u64 sample_period;    /* период выборки */\n"
"        __u64 sample_freq;      /* частота выборки */\n"
"    };\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:217
#, no-wrap
msgid ""
"    __u64 sample_type;  /* Specifies values included in sample */\n"
"    __u64 read_format;  /* Specifies values returned in read */\n"
msgstr ""
"    __u64 sample_type;  /* значения, включённые в измерение */\n"
"    __u64 read_format;  /* значения, возвращаемые при чтении */\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:247
#, no-wrap
msgid ""
"    __u64 disabled       : 1,   /* off by default */\n"
"          inherit        : 1,   /* children inherit it */\n"
"          pinned         : 1,   /* must always be on PMU */\n"
"          exclusive      : 1,   /* only group on PMU */\n"
"          exclude_user   : 1,   /* don't count user */\n"
"          exclude_kernel : 1,   /* don't count kernel */\n"
"          exclude_hv     : 1,   /* don't count hypervisor */\n"
"          exclude_idle   : 1,   /* don't count when idle */\n"
"          mmap           : 1,   /* include mmap data */\n"
"          comm           : 1,   /* include comm data */\n"
"          freq           : 1,   /* use freq, not period */\n"
"          inherit_stat   : 1,   /* per task counts */\n"
"          enable_on_exec : 1,   /* next exec enables */\n"
"          task           : 1,   /* trace fork/exit */\n"
"          watermark      : 1,   /* wakeup_watermark */\n"
"          precise_ip     : 2,   /* skid constraint */\n"
"          mmap_data      : 1,   /* non-exec mmap data */\n"
"          sample_id_all  : 1,   /* sample_type all events */\n"
"          exclude_host   : 1,   /* don't count in host */\n"
"          exclude_guest  : 1,   /* don't count in guest */\n"
"          exclude_callchain_kernel : 1,\n"
"                                /* exclude kernel callchains */\n"
"          exclude_callchain_user   : 1,\n"
"                                /* exclude user callchains */\n"
"          mmap2          :  1,  /* include mmap with inode data */\n"
"          comm_exec      :  1,  /* flag comm events that are\n"
"                                   due to exec */\n"
"          use_clockid    :  1,  /* use clockid for time fields */\n"
"          context_switch :  1,  /* context switch data */\n"
msgstr ""
"    __u64 disabled       : 1,   /* по умолчанию выключено */\n"
"          inherit        : 1,   /* потомок наследует это */\n"
"          pinned         : 1,   /* должно быть всегда на PMU */\n"
"          exclusive      : 1,   /* только группа на PMU */\n"
"          exclude_user   : 1,   /* не учитывать режим пользователя */\n"
"          exclude_kernel : 1,   /* не учитывать режим ядра */\n"
"          exclude_hv     : 1,   /* не учитывать режим гипервизора */\n"
"          exclude_idle   : 1,   /* не учитывать простой */\n"
"          mmap           : 1,   /* включать данные mmap */\n"
"          comm           : 1,   /* включать данные comm */\n"
"          freq           : 1,   /* использовать частоту вместо\n"
"                                       периода */\n"
"          inherit_stat   : 1,   /* позадачный учёт */\n"
"          enable_on_exec : 1,   /* включать при следующем exec */\n"
"          task           : 1,   /* трассировка fork/exit */\n"
"          watermark      : 1,   /* wakeup_watermark */\n"
"          precise_ip     : 2,   /* ограничение skid */\n"
"          mmap_data      : 1,   /* неисполняемые данные mmap */\n"
"          sample_id_all  : 1,   /* sample_type всех событий */\n"
"          exclude_host   : 1,   /* не учитывать на узле */\n"
"          exclude_guest  : 1,   /* не учитывать на госте */\n"
"          exclude_callchain_kernel : 1,\n"
"                                /* исключать цепочки ядерных\n"
"                                   вызовов */\n"
"          exclude_callchain_user   : 1,\n"
"                                /* исключать цепочки пользовательских\n"
"                                   вызовов */\n"
"          mmap2          :  1,  /* включать mmap с данными inode */\n"
"          comm_exec      :  1,  /* помечать события comm,\n"
"                                   произошедшие из-за exec */\n"
"          use_clockid    :  1,  /* использовать clockid в полях\n"
"                                           времени */\n"
"          context_switch :  1,  /* данные переключения контекста */\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:249
#, no-wrap
msgid "          __reserved_1   : 37;\n"
msgstr "          __reserved_1   : 37;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:254
#, no-wrap
msgid ""
"    union {\n"
"        __u32 wakeup_events;    /* wakeup every n events */\n"
"        __u32 wakeup_watermark; /* bytes before wakeup */\n"
"    };\n"
msgstr ""
"    union {\n"
"        __u32 wakeup_events;    /* пробуждаться каждые n событий */\n"
"        __u32 wakeup_watermark; /* байт до пробуждения */\n"
"    };\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:256
#, no-wrap
msgid "    __u32     bp_type;          /* breakpoint type */\n"
msgstr "    __u32     bp_type;          /* тип точки останова */\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:263
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_addr;          /* breakpoint address */\n"
"        __u64 kprobe_func;      /* for perf_kprobe */\n"
"        __u64 uprobe_path;      /* for perf_uprobe */\n"
"        __u64 config1;          /* extension of config */\n"
"    };\n"
msgstr ""
"    union {\n"
"        __u64 bp_addr;          /* адрес точки останова */\n"
"        __u64 kprobe_func;      /* для perf_kprobe */\n"
"        __u64 uprobe_path;      /* для perf_uprobe */\n"
"        __u64 config1;          /* расширение of config */\n"
"    };\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:279
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_len;           /* breakpoint length */\n"
"        __u64 kprobe_addr;      /* with kprobe_func == NULL */\n"
"        __u64 probe_offset;     /* for perf_[k,u]probe */\n"
"        __u64 config2;          /* extension of config1 */\n"
"    };\n"
"    __u64 branch_sample_type;   /* enum perf_branch_sample_type */\n"
"    __u64 sample_regs_user;     /* user regs to dump on samples */\n"
"    __u32 sample_stack_user;    /* size of stack to dump on\n"
"                                   samples */\n"
"    __s32 clockid;              /* clock to use for time fields */\n"
"    __u64 sample_regs_intr;     /* regs to dump on samples */\n"
"    __u32 aux_watermark;        /* aux bytes before wakeup */\n"
"    __u16 sample_max_stack;     /* max frames in callchain */\n"
"    __u16 __reserved_2;         /* align to u64 */\n"
msgstr ""
"    union {\n"
"        __u64 bp_len;           /* длина точки останова */\n"
"        __u64 kprobe_addr;      /* с kprobe_func == NULL */\n"
"        __u64 probe_offset;     /* для perf_[k,u]probe */\n"
"        __u64 config2;          /* расширение config1 */\n"
"    };\n"
"    __u64 branch_sample_type;   /* enum perf_branch_sample_type */\n"
"    __u64 sample_regs_user;     /* пользовательские регистры,\n"
"                                   записываемые в замер */\n"
"    __u32 sample_stack_user;    /* размер стека, записываемые в\n"
"                                   замер */\n"
"    __s32 clockid;              /* часы, используемые в полях\n"
"                                   времени */\n"
"    __u64 sample_regs_intr;     /* регистры, записываемые в замер */\n"
"    __u32 aux_watermark;        /* вспомогательные байт перед\n"
"                                   пробуждением */\n"
"    __u16 sample_max_stack;     /* максимальное количество фреймов\n"
"                                   в цепочке вызовов */\n"
"    __u16 __reserved_2;         /* выравнивание до u64 */\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:281
#, no-wrap
msgid "};\n"
msgstr "};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:287
msgid ""
"The fields of the I<perf_event_attr> structure are described in more detail "
"below:"
msgstr "Описание полей структуры I<perf_event_attr>:"

#. type: TP
#: man-pages/man2/perf_event_open.2:287 man-pages/man2/perf_event_open.2:1923
#, no-wrap
msgid "I<type>"
msgstr "I<type>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:291
msgid ""
"This field specifies the overall event type.  It has one of the following "
"values:"
msgstr ""
"В этом поле указывается общий тип события. Может быть одно из следующих "
"значений:"

#. type: TP
#: man-pages/man2/perf_event_open.2:292
#, no-wrap
msgid "B<PERF_TYPE_HARDWARE>"
msgstr "B<PERF_TYPE_HARDWARE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:299
msgid ""
"This indicates one of the \"generalized\" hardware events provided by the "
"kernel.  See the I<config> field definition for more details."
msgstr ""
"Одно из «общих»  аппаратных событий, предоставляется ядром. Подробней "
"смотрите в описании поля I<config>."

#. type: TP
#: man-pages/man2/perf_event_open.2:299
#, no-wrap
msgid "B<PERF_TYPE_SOFTWARE>"
msgstr "B<PERF_TYPE_SOFTWARE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:303
msgid ""
"This indicates one of the software-defined events provided by the kernel "
"(even if no hardware support is available)."
msgstr ""
"Одно из программных событий, предоставляется ядром (даже, если нет "
"аппаратной поддержки)."

#. type: TP
#: man-pages/man2/perf_event_open.2:303
#, no-wrap
msgid "B<PERF_TYPE_TRACEPOINT>"
msgstr "B<PERF_TYPE_TRACEPOINT>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:307
msgid ""
"This indicates a tracepoint provided by the kernel tracepoint infrastructure."
msgstr ""
"Точка трассировки, предоставляется ядерной инфраструктурой точек трассировки."

#. type: TP
#: man-pages/man2/perf_event_open.2:307
#, no-wrap
msgid "B<PERF_TYPE_HW_CACHE>"
msgstr "B<PERF_TYPE_HW_CACHE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:313
msgid ""
"This indicates a hardware cache event.  This has a special encoding, "
"described in the I<config> field definition."
msgstr ""
"Событие аппаратного кэша. Создаётся специальным кодированием, смотрите "
"описание к полю I<config>."

#. type: TP
#: man-pages/man2/perf_event_open.2:313
#, no-wrap
msgid "B<PERF_TYPE_RAW>"
msgstr "B<PERF_TYPE_RAW>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:317
msgid ""
"This indicates a \"raw\" implementation-specific event in the I<config> "
"field."
msgstr ""
"«Неструктурированное», определяемое реализацией событие из поля I<config>."

#. type: TP
#: man-pages/man2/perf_event_open.2:317
#, no-wrap
msgid "B<PERF_TYPE_BREAKPOINT> (since Linux 2.6.33)"
msgstr "B<PERF_TYPE_BREAKPOINT> (начиная с Linux 2.6.33)"

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:323
msgid ""
"This indicates a hardware breakpoint as provided by the CPU.  Breakpoints "
"can be read/write accesses to an address as well as execution of an "
"instruction address."
msgstr ""
"Аппаратная точка останова, предоставляемая ЦП. Точки останова можно "
"настроить на событие чтения/записи по адресу, а также на выполнение "
"инструкции по определённому адресу."

#. type: TP
#: man-pages/man2/perf_event_open.2:323
#, no-wrap
msgid "dynamic PMU"
msgstr "динамический PMU"

#.  commit 2e80a82a49c4c7eca4e35734380f28298ba5db19
#. type: Plain text
#: man-pages/man2/perf_event_open.2:343
msgid ""
"Since Linux 2.6.38, B<perf_event_open>()  can support multiple PMUs.  To "
"enable this, a value exported by the kernel can be used in the I<type> field "
"to indicate which PMU to use.  The value to use can be found in the sysfs "
"filesystem: there is a subdirectory per PMU instance under I</sys/bus/"
"event_source/devices>.  In each subdirectory there is a I<type> file whose "
"content is an integer that can be used in the I<type> field.  For instance, "
"I</sys/bus/event_source/devices/cpu/type> contains the value for the core "
"CPU PMU, which is usually 4."
msgstr ""
"Начиная с Linux 2.6.38, B<perf_event_open>() поддерживает несколько PMU. "
"Чтобы задать используемый PMU, его указывают в значении I<type>, "
"экспортируемое ядром. Нужное значение можно найти в файловой системе sysfs: "
"для каждого экземпляра PMU создаётся подкаталог в каталоге I</sys/bus/"
"event_source/devices>. В каждом подкаталоге есть файл I<type>, содержащий "
"целое число, которое можно использовать в поле I<type>. Например, в I</sys/"
"bus/event_source/devices/cpu/type> содержится значение для PMU ядра ЦП, "
"которое, обычно равно 4."

#. type: TP
#: man-pages/man2/perf_event_open.2:343
#, no-wrap
msgid "B<kprobe> and B<uprobe> (since Linux 4.17)"
msgstr "B<kprobe> и B<uprobe> (начиная с Linux 4.17)"

#.  commit 65074d43fc77bcae32776724b7fa2696923c78e4
#.  commit e12f03d7031a977356e3d7b75a68c2185ff8d155
#.  commit 33ea4b24277b06dbc55d7f5772a46f029600255e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:354
msgid ""
"These two dynamic PMUs create a kprobe/uprobe and attach it to the file "
"descriptor generated by perf_event_open.  The kprobe/uprobe will be "
"destroyed on the destruction of the file descriptor.  See fields "
"I<kprobe_func>, I<uprobe_path>, I<kprobe_addr>, and I<probe_offset> for more "
"details."
msgstr ""
"Эти два динамических PMU создают kprobe/uprobe и присоединяют к файловому "
"дескриптору, сгенерованному perf_event_open. kprobe/uprobe будет уничтожен "
"при уничтожении файлового дескриптора. Подробности смотрите в описании полей "
"I<kprobe_func>, I<uprobe_path>, I<kprobe_addr> и I<probe_offset>."

#. type: TP
#: man-pages/man2/perf_event_open.2:355 man-pages/man2/perf_event_open.2:1835
#, no-wrap
msgid "I<size>"
msgstr "I<size>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:364
msgid ""
"The size of the I<perf_event_attr> structure for forward/backward "
"compatibility.  Set this using I<sizeof(struct perf_event_attr)> to allow "
"the kernel to see the struct size at the time of compilation."
msgstr ""
"Размер структуры I<perf_event_attr> совместимости. Присвоение значения "
"I<sizeof(struct perf_event_attr)> позволяет ядру видеть размер структуры во "
"время компиляции."

#.  commit cb5d76999029ae7a517cb07dfa732c1b5a934fc2
#.  this was added much later when PERF_ATTR_SIZE_VER2 happened
#.  but the actual attr_size had increased in 2.6.33
#.  commit cb5d76999029ae7a517cb07dfa732c1b5a934fc2
#.  commit 1659d129ed014b715b0b2120e6fd929bdd33ed03
#.  commit 60e2364e60e86e81bc6377f49779779e6120977f
#.  commit 1a5941312414c71dece6717da9a0fa1303127afa
#. type: Plain text
#: man-pages/man2/perf_event_open.2:394
msgid ""
"The related define B<PERF_ATTR_SIZE_VER0> is set to 64; this was the size of "
"the first published struct.  B<PERF_ATTR_SIZE_VER1> is 72, corresponding to "
"the addition of breakpoints in Linux 2.6.33.  B<PERF_ATTR_SIZE_VER2> is 80 "
"corresponding to the addition of branch sampling in Linux 3.4.  "
"B<PERF_ATTR_SIZE_VER3> is 96 corresponding to the addition of "
"I<sample_regs_user> and I<sample_stack_user> in Linux 3.7.  "
"B<PERF_ATTR_SIZE_VER4> is 104 corresponding to the addition of "
"I<sample_regs_intr> in Linux 3.19.  B<PERF_ATTR_SIZE_VER5> is 112 "
"corresponding to the addition of I<aux_watermark> in Linux 4.1."
msgstr ""
"Соответствующее определение B<PERF_ATTR_SIZE_VER0> равно 64; это размер "
"первой опубликованной структуры. Значение B<PERF_ATTR_SIZE_VER1> равно 72, "
"соответствует добавленным в Linux 2.6.33 точкам останова. Значение "
"B<PERF_ATTR_SIZE_VER2> равно 80, соответствует добавленным в Linux 3.4 "
"ветвям замеров. Значение B<PERF_ATTR_SIZE_VER3> равно 96, соответствует "
"добавленным в Linux 3.7 полям I<sample_regs_user> и I<sample_stack_user>. "
"Значение B<PERF_ATTR_SIZE_VER4> равно 104, соответствует добавленному в "
"Linux 3.19 полю I<sample_regs_intr>. Значение B<PERF_ATTR_SIZE_VER5> равно "
"112, соответствует добавленному в in Linux 4.1 полю I<aux_watermark>."

#. type: TP
#: man-pages/man2/perf_event_open.2:394
#, no-wrap
msgid "I<config>"
msgstr "I<config>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:405
msgid ""
"This specifies which event you want, in conjunction with the I<type> field.  "
"The I<config1> and I<config2> fields are also taken into account in cases "
"where 64 bits is not enough to fully specify the event.  The encoding of "
"these fields are event dependent."
msgstr ""
"Здесь указывается требуемое событие в сочетании с полем I<type>. Поля "
"I<config1> и I<config2> также учитываются, если 64 бит недостаточно для "
"полного описания события. Кодирование значения этих полей зависит от события."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:416
msgid ""
"There are various ways to set the I<config> field that are dependent on the "
"value of the previously described I<type> field.  What follows are various "
"possible settings for I<config> separated out by I<type>."
msgstr ""
"Есть несколько способов присвоения значения полю I<config>, которые зависят "
"от значения описанного ранее поля I<type>. Содержимое различных возможных "
"настроек I<config> выделяется по I<type>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:426
msgid ""
"If I<type> is B<PERF_TYPE_HARDWARE>, we are measuring one of the generalized "
"hardware CPU events.  Not all of these are available on all platforms.  Set "
"I<config> to one of the following:"
msgstr ""
"Если I<type> равно B<PERF_TYPE_HARDWARE>, то измеряется одно из общих "
"аппаратных событий ЦП. Не все из них доступны на всех платформах. В "
"I<config> может быть одно из следующих значений:"

#. type: TP
#: man-pages/man2/perf_event_open.2:427
#, no-wrap
msgid "B<PERF_COUNT_HW_CPU_CYCLES>"
msgstr "B<PERF_COUNT_HW_CPU_CYCLES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:431
msgid "Total cycles.  Be wary of what happens during CPU frequency scaling."
msgstr ""
"Общее количество циклов. Опасайтесь того, что происходит во время частотного "
"масштабирования ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:431
#, no-wrap
msgid "B<PERF_COUNT_HW_INSTRUCTIONS>"
msgstr "B<PERF_COUNT_HW_INSTRUCTIONS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:436
msgid ""
"Retired instructions.  Be careful, these can be affected by various issues, "
"most notably hardware interrupt counts."
msgstr ""
"Запоздалые инструкции (retired instructions). Осторожно, могут влиять "
"различные ситуации, в основном, подсчёт аппаратных прерываний."

#. type: TP
#: man-pages/man2/perf_event_open.2:436
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_REFERENCES>"
msgstr "B<PERF_COUNT_HW_CACHE_REFERENCES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:443
msgid ""
"Cache accesses.  Usually this indicates Last Level Cache accesses but this "
"may vary depending on your CPU.  This may include prefetches and coherency "
"messages; again this depends on the design of your CPU."
msgstr ""
"Доступ к кэшу. Обычно, учитывается доступ к кэшу последнего уровня, но для "
"различных ЦП может быть по-разному. Может включать сообщения о "
"предварительной выборке и связности; опять же, зависит от ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:443
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_MISSES>"
msgstr "B<PERF_COUNT_HW_CACHE_MISSES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:450
msgid ""
"Cache misses.  Usually this indicates Last Level Cache misses; this is "
"intended to be used in conjunction with the "
"B<PERF_COUNT_HW_CACHE_REFERENCES> event to calculate cache miss rates."
msgstr ""
"Промахи кэша. Обычно, отражает промахи кэша последнего уровня; предназначена "
"для использования вместе с событием B<PERF_COUNT_HW_CACHE_REFERENCES> для "
"подсчёта коэффициента промахов кэша."

#. type: TP
#: man-pages/man2/perf_event_open.2:450
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"
msgstr "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"

#.  commit f287d332ce835f77a4f5077d2c0ef1e3f9ea42d2
#. type: Plain text
#: man-pages/man2/perf_event_open.2:456
msgid ""
"Retired branch instructions.  Prior to Linux 2.6.35, this used the wrong "
"event on AMD processors."
msgstr ""
"Запоздалые инструкции ветвления. До Linux 2.6.35 использовалось неправильное "
"сообщение на процессорах AMD."

#. type: TP
#: man-pages/man2/perf_event_open.2:456
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_MISSES>"
msgstr "B<PERF_COUNT_HW_BRANCH_MISSES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:459
msgid "Mispredicted branch instructions."
msgstr "Непредсказанные инструкции ветвления."

#. type: TP
#: man-pages/man2/perf_event_open.2:459
#, no-wrap
msgid "B<PERF_COUNT_HW_BUS_CYCLES>"
msgstr "B<PERF_COUNT_HW_BUS_CYCLES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:462
msgid "Bus cycles, which can be different from total cycles."
msgstr ""
"Количество циклов шины, которое может отличаться от общего количества циклов."

#. type: TP
#: man-pages/man2/perf_event_open.2:462
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (since Linux 3.0)"
msgstr "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (начиная с Linux 3.0)"

#.  commit 8f62242246351b5a4bc0c1f00c0c7003edea128a
#. type: Plain text
#: man-pages/man2/perf_event_open.2:466
msgid "Stalled cycles during issue."
msgstr "Блокировано циклов во время проблемы."

#. type: TP
#: man-pages/man2/perf_event_open.2:466
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (since Linux 3.0)"
msgstr "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (начиная с Linux 3.0)"

#.  commit 8f62242246351b5a4bc0c1f00c0c7003edea128a
#. type: Plain text
#: man-pages/man2/perf_event_open.2:470
msgid "Stalled cycles during retirement."
msgstr "Блокировано циклов во время запаздывания."

#. type: TP
#: man-pages/man2/perf_event_open.2:470
#, no-wrap
msgid "B<PERF_COUNT_HW_REF_CPU_CYCLES> (since Linux 3.3)"
msgstr "B<PERF_COUNT_HW_REF_CPU_CYCLES> (начиная с Linux 3.3)"

#.  commit c37e17497e01fc0f5d2d6feb5723b210b3ab8890
#. type: Plain text
#: man-pages/man2/perf_event_open.2:474
msgid "Total cycles; not affected by CPU frequency scaling."
msgstr ""
"Общее количество циклов; не подвержено влиянию частотного масштабирования ЦП."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:484
msgid ""
"If I<type> is B<PERF_TYPE_SOFTWARE>, we are measuring software events "
"provided by the kernel.  Set I<config> to one of the following:"
msgstr ""
"Если значение I<type> равно B<PERF_TYPE_SOFTWARE>, то измеряются программные "
"события, предоставляемые ядром. Значением I<config> может быть одно из "
"следующих:"

#. type: TP
#: man-pages/man2/perf_event_open.2:485
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_CLOCK>"
msgstr "B<PERF_COUNT_SW_CPU_CLOCK>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:488
msgid "This reports the CPU clock, a high-resolution per-CPU timer."
msgstr ""
"Сообщить о часах ЦП, таймере высокого разрешения, работающем на каждом ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:488
#, no-wrap
msgid "B<PERF_COUNT_SW_TASK_CLOCK>"
msgstr "B<PERF_COUNT_SW_TASK_CLOCK>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:491
msgid "This reports a clock count specific to the task that is running."
msgstr "Сообщить о часах выполняющейся задачи."

#. type: TP
#: man-pages/man2/perf_event_open.2:491
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS>"
msgstr "B<PERF_COUNT_SW_PAGE_FAULTS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:494
msgid "This reports the number of page faults."
msgstr "Сообщить о количестве сбойных страниц."

#. type: TP
#: man-pages/man2/perf_event_open.2:494
#, no-wrap
msgid "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"
msgstr "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"

#.  commit e49a5bd38159dfb1928fd25b173bc9de4bbadb21
#. type: Plain text
#: man-pages/man2/perf_event_open.2:500
msgid ""
"This counts context switches.  Until Linux 2.6.34, these were all reported "
"as user-space events, after that they are reported as happening in the "
"kernel."
msgstr ""
"Подсчёт числа переключений контекста. До Linux 2.6.34, это считалось "
"событиями пользовательского пространства, теперь об этом сообщается как о "
"происходящем в ядре."

#. type: TP
#: man-pages/man2/perf_event_open.2:500
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_MIGRATIONS>"
msgstr "B<PERF_COUNT_SW_CPU_MIGRATIONS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:504
msgid "This reports the number of times the process has migrated to a new CPU."
msgstr "Сообщить сколько раз процесс перемещался в другой ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:504
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"
msgstr "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:508
msgid ""
"This counts the number of minor page faults.  These did not require disk I/O "
"to handle."
msgstr ""
"Сообщить о количестве незначительных промахов страниц. Они не связаны с "
"обработкой дисковых операций ввода-вывода."

#. type: TP
#: man-pages/man2/perf_event_open.2:508
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"
msgstr "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:512
msgid ""
"This counts the number of major page faults.  These required disk I/O to "
"handle."
msgstr ""
"Сообщить о количестве значительных промахов страниц. Они связаны с "
"обработкой дисковых операций ввода-вывода."

#. type: TP
#: man-pages/man2/perf_event_open.2:512
#, no-wrap
msgid "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (since Linux 2.6.33)"
msgstr "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (начиная с Linux 2.6.33)"

#.  commit f7d7986060b2890fc26db6ab5203efbd33aa2497
#. type: Plain text
#: man-pages/man2/perf_event_open.2:519
msgid ""
"This counts the number of alignment faults.  These happen when unaligned "
"memory accesses happen; the kernel can handle these but it reduces "
"performance.  This happens only on some architectures (never on x86)."
msgstr ""
"Сообщить о количестве ошибок выравнивания. Они возникают, когда происходит "
"доступ к памяти по невыровненному адресу; ядро может обработать такую "
"ситуацию, но  это снижает производительность. Бывает только на некоторых "
"архитектурах (на x86 — никогда)."

#. type: TP
#: man-pages/man2/perf_event_open.2:519
#, no-wrap
msgid "B<PERF_COUNT_SW_EMULATION_FAULTS> (since Linux 2.6.33)"
msgstr "B<PERF_COUNT_SW_EMULATION_FAULTS> (начиная с Linux 2.6.33)"

#.  commit f7d7986060b2890fc26db6ab5203efbd33aa2497
#. type: Plain text
#: man-pages/man2/perf_event_open.2:526
msgid ""
"This counts the number of emulation faults.  The kernel sometimes traps on "
"unimplemented instructions and emulates them for user space.  This can "
"negatively impact performance."
msgstr ""
"Сообщить о количестве ошибок эмуляции. Ядро иногда попадает в ловушки "
"нереализованных инструкций и эмулирует их в пользовательском пространстве. "
"Это может негативно отражаться на производительности."

#. type: TP
#: man-pages/man2/perf_event_open.2:526
#, no-wrap
msgid "B<PERF_COUNT_SW_DUMMY> (since Linux 3.12)"
msgstr "B<PERF_COUNT_SW_DUMMY> (начиная с Linux 3.12)"

#.  commit fa0097ee690693006ab1aea6c01ad3c851b65c77
#. type: Plain text
#: man-pages/man2/perf_event_open.2:534
msgid ""
"This is a placeholder event that counts nothing.  Informational sample "
"record types such as mmap or comm must be associated with an active event.  "
"This dummy event allows gathering such records without requiring a counting "
"event."
msgstr ""
"Заместитель события, которое ничего не подсчитывает. This is a placeholder "
"event that counts nothing.  Информационные образцы типов записей, таких как "
"mmap или comm, должны быть связаны с активным событием. Данное пустое "
"событие позволяет собирать такие записи без необходимости в подсчитывающем "
"событии."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:547
msgid ""
"If I<type> is B<PERF_TYPE_TRACEPOINT>, then we are measuring kernel "
"tracepoints.  The value to use in I<config> can be obtained from under "
"debugfs I<tracing/events/*/*/id> if ftrace is enabled in the kernel."
msgstr ""
"Если I<type> равно B<PERF_TYPE_TRACEPOINT>, то измеряется точки трассировки "
"ядра. Значение, используемое в I<config>, можно получить из debugfs "
"I<tracing/events/*/*/id>, если ftrace включён в ядре."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:558
msgid ""
"If I<type> is B<PERF_TYPE_HW_CACHE>, then we are measuring a hardware CPU "
"cache event.  To calculate the appropriate I<config> value use the following "
"equation:"
msgstr ""
"Если I<type> равно B<PERF_TYPE_HW_CACHE>, то измеряется событие кэша "
"аппаратного ЦП. Для вычисления соответствующего значения I<config> "
"используйте следующую формулу:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:563
#, no-wrap
msgid ""
"    (perf_hw_cache_id) | (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"    (perf_hw_cache_op_result_id E<lt>E<lt> 16)\n"
msgstr ""
"    (perf_hw_cache_id) | (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"    (perf_hw_cache_op_result_id E<lt>E<lt> 16)\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:568
msgid "where I<perf_hw_cache_id> is one of:"
msgstr "где I<perf_hw_cache_id> одно из:"

#. type: TP
#: man-pages/man2/perf_event_open.2:569
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1D>"
msgstr "B<PERF_COUNT_HW_CACHE_L1D>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:572
msgid "for measuring Level 1 Data Cache"
msgstr "для измерения кэша данных 1-го уровня"

#. type: TP
#: man-pages/man2/perf_event_open.2:572
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1I>"
msgstr "B<PERF_COUNT_HW_CACHE_L1I>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:575
msgid "for measuring Level 1 Instruction Cache"
msgstr "для измерения кэша инструкций 1-го уровня"

#. type: TP
#: man-pages/man2/perf_event_open.2:575
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_LL>"
msgstr "B<PERF_COUNT_HW_CACHE_LL>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:578
msgid "for measuring Last-Level Cache"
msgstr "для измерения кэша последнего уровня"

#. type: TP
#: man-pages/man2/perf_event_open.2:578
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_DTLB>"
msgstr "B<PERF_COUNT_HW_CACHE_DTLB>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:581
msgid "for measuring the Data TLB"
msgstr "для измерения TLB данных"

#. type: TP
#: man-pages/man2/perf_event_open.2:581
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_ITLB>"
msgstr "B<PERF_COUNT_HW_CACHE_ITLB>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:584
msgid "for measuring the Instruction TLB"
msgstr "для измерения TLB инструкций"

#. type: TP
#: man-pages/man2/perf_event_open.2:584
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_BPU>"
msgstr "B<PERF_COUNT_HW_CACHE_BPU>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:587
msgid "for measuring the branch prediction unit"
msgstr "для измерения модуля предсказания ветвлений"

#. type: TP
#: man-pages/man2/perf_event_open.2:587
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_NODE> (since Linux 3.1)"
msgstr "B<PERF_COUNT_HW_CACHE_NODE> (начиная с Linux 3.1)"

#.  commit 89d6c0b5bdbb1927775584dcf532d98b3efe1477
#. type: Plain text
#: man-pages/man2/perf_event_open.2:591
msgid "for measuring local memory accesses"
msgstr "для измерения доступа к локальной памяти"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:596
msgid "and I<perf_hw_cache_op_id> is one of:"
msgstr "и I<perf_hw_cache_op_id> одно из:"

#. type: TP
#: man-pages/man2/perf_event_open.2:597
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_READ>"
msgstr "B<PERF_COUNT_HW_CACHE_OP_READ>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:600
msgid "for read accesses"
msgstr "для доступа на чтение"

#. type: TP
#: man-pages/man2/perf_event_open.2:600
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_WRITE>"
msgstr "B<PERF_COUNT_HW_CACHE_OP_WRITE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:603
msgid "for write accesses"
msgstr "для доступа на запись"

#. type: TP
#: man-pages/man2/perf_event_open.2:603
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"
msgstr "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:606
msgid "for prefetch accesses"
msgstr "для доступа предварительной выборки"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:611
msgid "and I<perf_hw_cache_op_result_id> is one of:"
msgstr "и I<perf_hw_cache_op_result_id> одно из:"

#. type: TP
#: man-pages/man2/perf_event_open.2:612
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"
msgstr "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:615
msgid "to measure accesses"
msgstr "для измерения доступа"

#. type: TP
#: man-pages/man2/perf_event_open.2:615
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"
msgstr "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:618
msgid "to measure misses"
msgstr "для измерения промахов"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:636
msgid ""
"If I<type> is B<PERF_TYPE_RAW>, then a custom \"raw\" I<config> value is "
"needed.  Most CPUs support events that are not covered by the \"generalized"
"\" events.  These are implementation defined; see your CPU manual (for "
"example the Intel Volume 3B documentation or the AMD BIOS and Kernel "
"Developer Guide).  The libpfm4 library can be used to translate from the "
"name in the architectural manuals to the raw hex value B<perf_event_open>()  "
"expects in this field."
msgstr ""
"Если I<type> равно B<PERF_TYPE_RAW>, то требуется пользовательское "
"«неструктурированное» значение I<config>. Большинство ЦП поддерживают "
"события, которые не подпадают под «общие» события. Они определяются "
"реализацией; смотрите руководство на ЦП (например,  документацию Intel "
"Volume 3B или AMD BIOS и руководство разработчика ядра). Для трансляции "
"ожидаемых значений в этом поле шестнадцатеричных значений в "
"B<perf_event_open>() из имён справочников по архитектуре можно использовать "
"библиотеку libpfm4."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:645
msgid ""
"If I<type> is B<PERF_TYPE_BREAKPOINT>, then leave I<config> set to zero.  "
"Its parameters are set in other places."
msgstr ""
"Если I<type> равно B<PERF_TYPE_BREAKPOINT>, то присвойте I<config> значение "
"0. Его параметры задаются в других местах."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:662
msgid ""
"If I<type> is B<kprobe> or B<uprobe>, set I<retprobe> (bit 0 of I<config>, "
"see I</sys/bus/event_source/devices/[k,u]probe/format/retprobe>)  for "
"kretprobe/uretprobe.  See fields I<kprobe_func>, I<uprobe_path>, "
"I<kprobe_addr>, and I<probe_offset> for more details."
msgstr ""
"Если I<type> равно B<kprobe> или B<uprobe>, установите I<retprobe> (бит 0 в "
"I<config>, смотрите I</sys/bus/event_source/devices/[k,u]probe/format/"
"retprobe>) равным kretprobe/uretprobe. Дополнительную информацию смотрите в "
"описании полей I<kprobe_func>, I<uprobe_path>, I<kprobe_addr> и "
"I<probe_offset>."

#. type: TP
#: man-pages/man2/perf_event_open.2:663
#, no-wrap
msgid "I<kprobe_func>, I<uprobe_path>, I<kprobe_addr>, and I<probe_offset>"
msgstr "I<kprobe_func>, I<uprobe_path>, I<kprobe_addr> и I<probe_offset>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:686
msgid ""
"These fields describe the kprobe/uprobe for dynamic PMUs B<kprobe> and "
"B<uprobe>.  For B<kprobe>: use I<kprobe_func> and I<probe_offset>, or use "
"I<kprobe_addr> and leave I<kprobe_func> as NULL.  For B<uprobe>: use "
"I<uprobe_path> and I<probe_offset>."
msgstr ""
"Эти поля описывают kprobe/uprobe в динамических PMU B<kprobe> и B<uprobe>. "
"Для B<kprobe>: используйте I<kprobe_func> и I<probe_offset>, или используйте "
"I<kprobe_addr> и оставьте I<kprobe_func> равным NULL. Для B<uprobe>: "
"используйте I<uprobe_path> и I<probe_offset>."

#. type: TP
#: man-pages/man2/perf_event_open.2:686
#, no-wrap
msgid "I<sample_period>, I<sample_freq>"
msgstr "I<sample_period>, I<sample_freq>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:698
msgid ""
"A \"sampling\" event is one that generates an overflow notification every N "
"events, where N is given by I<sample_period>.  A sampling event has "
"I<sample_period> E<gt> 0.  When an overflow occurs, requested data is "
"recorded in the mmap buffer.  The I<sample_type> field controls what data is "
"recorded on each overflow."
msgstr ""
"«Измеряющее» событие генерирует уведомление о переполнении каждые N событий, "
"где N указывается в I<sample_period>. У измеряющего события I<sample_period> "
"E<gt> 0. Если происходит переполнение, то запрашиваемые данные записываются "
"в буфер mmap. В поле I<sample_type> указывается какие данные записываются "
"при каждом переполнении."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:708
msgid ""
"I<sample_freq> can be used if you wish to use frequency rather than period.  "
"In this case, you set the I<freq> flag.  The kernel will adjust the sampling "
"period to try and achieve the desired rate.  The rate of adjustment is a "
"timer tick."
msgstr ""
"Если вы хотите использовать частоту, а не период, то можно использовать "
"I<sample_freq>. В этом случае установите флаг I<freq>. Ядро откорректирует "
"период измерений, чтобы попытаться достигнуть желаемой частоты. Частота "
"измеряется в тактах таймера."

#. type: TP
#: man-pages/man2/perf_event_open.2:708
#, no-wrap
msgid "I<sample_type>"
msgstr "I<sample_type>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:720
msgid ""
"The various bits in this field specify which values to include in the "
"sample.  They will be recorded in a ring-buffer, which is available to user "
"space using B<mmap>(2).  The order in which the values are saved in the "
"sample are documented in the MMAP Layout subsection below; it is not the "
"I<enum perf_event_sample_format> order."
msgstr ""
"Различными битами этого поля определяется какие значения включать в "
"измерение. Они будут записаны в кольцевой буфер, который доступен в "
"пользовательском пространстве через B<mmap>(2). Порядок сохраняемых значений "
"описан в разделе «Разбивка MMAP» ниже; он не совпадает с порядком I<enum "
"perf_event_sample_format>."

#. type: TP
#: man-pages/man2/perf_event_open.2:721
#, no-wrap
msgid "B<PERF_SAMPLE_IP>"
msgstr "B<PERF_SAMPLE_IP>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:724
msgid "Records instruction pointer."
msgstr "Сохранять указатель инструкций."

#. type: TP
#: man-pages/man2/perf_event_open.2:724
#, no-wrap
msgid "B<PERF_SAMPLE_TID>"
msgstr "B<PERF_SAMPLE_TID>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:727
msgid "Records the process and thread IDs."
msgstr "Сохранять идентификатор процесса и нити."

#. type: TP
#: man-pages/man2/perf_event_open.2:727
#, no-wrap
msgid "B<PERF_SAMPLE_TIME>"
msgstr "B<PERF_SAMPLE_TIME>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:730
msgid "Records a timestamp."
msgstr "Сохранять метку времени."

#. type: TP
#: man-pages/man2/perf_event_open.2:730
#, no-wrap
msgid "B<PERF_SAMPLE_ADDR>"
msgstr "B<PERF_SAMPLE_ADDR>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:733
msgid "Records an address, if applicable."
msgstr "Сохранять адрес (если используется)."

#. type: TP
#: man-pages/man2/perf_event_open.2:733
#, no-wrap
msgid "B<PERF_SAMPLE_READ>"
msgstr "B<PERF_SAMPLE_READ>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:736
msgid ""
"Record counter values for all events in a group, not just the group leader."
msgstr ""
"Сохранять значения счётчика для всех событий в группе, а не только для "
"лидера группы."

#. type: TP
#: man-pages/man2/perf_event_open.2:736
#, no-wrap
msgid "B<PERF_SAMPLE_CALLCHAIN>"
msgstr "B<PERF_SAMPLE_CALLCHAIN>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:739
msgid "Records the callchain (stack backtrace)."
msgstr "Сохранять цепочку вызовов (обратная трассировка стека)."

#. type: TP
#: man-pages/man2/perf_event_open.2:739
#, no-wrap
msgid "B<PERF_SAMPLE_ID>"
msgstr "B<PERF_SAMPLE_ID>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:742
msgid "Records a unique ID for the opened event's group leader."
msgstr ""
"Сохранять уникальный идентификатор для открытых лидером группы событий."

#. type: TP
#: man-pages/man2/perf_event_open.2:742
#, no-wrap
msgid "B<PERF_SAMPLE_CPU>"
msgstr "B<PERF_SAMPLE_CPU>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:745
msgid "Records CPU number."
msgstr "Сохранять номер ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:745
#, no-wrap
msgid "B<PERF_SAMPLE_PERIOD>"
msgstr "B<PERF_SAMPLE_PERIOD>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:748
msgid "Records the current sampling period."
msgstr "Сохранять текущий период измерения."

#. type: TP
#: man-pages/man2/perf_event_open.2:748
#, no-wrap
msgid "B<PERF_SAMPLE_STREAM_ID>"
msgstr "B<PERF_SAMPLE_STREAM_ID>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:756
msgid ""
"Records a unique ID for the opened event.  Unlike B<PERF_SAMPLE_ID> the "
"actual ID is returned, not the group leader.  This ID is the same as the one "
"returned by B<PERF_FORMAT_ID>."
msgstr ""
"Сохранять уникальный идентификатор открытого события. В отличии от "
"B<PERF_SAMPLE_ID> возвращается реальный идентификатор, а не лидера группы. "
"Этот же идентификатор возвращается B<PERF_FORMAT_ID>."

#. type: TP
#: man-pages/man2/perf_event_open.2:756
#, no-wrap
msgid "B<PERF_SAMPLE_RAW>"
msgstr "B<PERF_SAMPLE_RAW>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:760
msgid ""
"Records additional data, if applicable.  Usually returned by tracepoint "
"events."
msgstr ""
"Сохранять дополнительные данные, если есть. Обычно возвращаются для событий "
"трассировки."

#. type: TP
#: man-pages/man2/perf_event_open.2:760
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_STACK> (since Linux 3.4)"
msgstr "B<PERF_SAMPLE_BRANCH_STACK> (начиная с Linux 3.4)"

#.  commit bce38cd53e5ddba9cb6d708c4ef3d04a4016ec7e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:766
msgid ""
"This provides a record of recent branches, as provided by CPU branch "
"sampling hardware (such as Intel Last Branch Record).  Not all hardware "
"supports this feature."
msgstr ""
"Сохранять запись о новых ветвях, предоставляемых аппаратурой ветвления ЦП "
"(например, Intel Last Branch Record). Не каждая аппаратура поддерживает "
"данную возможность."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:770
msgid ""
"See the I<branch_sample_type> field for how to filter which branches are "
"reported."
msgstr ""
"В описании поля I<branch_sample_type> показано как выбирать ветви, о которых "
"нужно сообщать."

#. type: TP
#: man-pages/man2/perf_event_open.2:770
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_USER> (since Linux 3.7)"
msgstr "B<PERF_SAMPLE_REGS_USER> (начиная с Linux 3.7)"

#.  commit 4018994f3d8785275ef0e7391b75c3462c029e56
#. type: Plain text
#: man-pages/man2/perf_event_open.2:775
msgid ""
"Records the current user-level CPU register state (the values in the process "
"before the kernel was called)."
msgstr ""
"Записывать текущее состояние регистров ЦП на уровне пользователя (значения в "
"процессе до вызова ядра)."

#. type: TP
#: man-pages/man2/perf_event_open.2:775
#, no-wrap
msgid "B<PERF_SAMPLE_STACK_USER> (since Linux 3.7)"
msgstr "B<PERF_SAMPLE_STACK_USER> (начиная с Linux 3.7)"

#.  commit c5ebcedb566ef17bda7b02686e0d658a7bb42ee7
#. type: Plain text
#: man-pages/man2/perf_event_open.2:779
msgid "Records the user level stack, allowing stack unwinding."
msgstr "Сохранять стек пользовательского уровня для размотки стека."

#. type: TP
#: man-pages/man2/perf_event_open.2:779
#, no-wrap
msgid "B<PERF_SAMPLE_WEIGHT> (since Linux 3.10)"
msgstr "B<PERF_SAMPLE_WEIGHT> (начиная с Linux 3.10)"

#.  commit c3feedf2aaf9ac8bad6f19f5d21e4ee0b4b87e9c
#. type: Plain text
#: man-pages/man2/perf_event_open.2:786
msgid ""
"Records a hardware provided weight value that expresses how costly the "
"sampled event was.  This allows the hardware to highlight expensive events "
"in a profile."
msgstr ""
"Сохранять данные аппаратуры, предоставляющие весовое значение, которое "
"отражает насколько затратным было измеряемое событие. Это позволяет "
"аппаратуре выявлять затратные события в профиле."

#. type: TP
#: man-pages/man2/perf_event_open.2:786
#, no-wrap
msgid "B<PERF_SAMPLE_DATA_SRC> (since Linux 3.10)"
msgstr "B<PERF_SAMPLE_DATA_SRC> (начиная с Linux 3.10)"

#.  commit d6be9ad6c960f43800a6f118932bc8a5a4eadcd1
#. type: Plain text
#: man-pages/man2/perf_event_open.2:793
msgid ""
"Records the data source: where in the memory hierarchy the data associated "
"with the sampled instruction came from.  This is available only if the "
"underlying hardware supports this feature."
msgstr ""
"Сохранять источник данных: где в иерархии памяти находятся данные, связанные "
"с измеряемое инструкцией. Доступно только, если поддерживается аппаратурой."

#. type: TP
#: man-pages/man2/perf_event_open.2:793
#, no-wrap
msgid "B<PERF_SAMPLE_IDENTIFIER> (since Linux 3.12)"
msgstr "B<PERF_SAMPLE_IDENTIFIER> (начиная с Linux 3.12)"

#.  commit ff3d527cebc1fa3707c617bfe9e74f53fcfb0955
#. type: Plain text
#: man-pages/man2/perf_event_open.2:801
msgid ""
"Places the B<SAMPLE_ID> value in a fixed position in the record, either at "
"the beginning (for sample events) or at the end (if a non-sample event)."
msgstr ""
"Помещать значение B<SAMPLE_ID> в фиксированном месте записи, или в начале "
"(для измеряемых событий) или в конце (для не измеряемого события)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:813
msgid ""
"This was necessary because a sample stream may have records from various "
"different event sources with different I<sample_type> settings.  Parsing the "
"event stream properly was not possible because the format of the record was "
"needed to find B<SAMPLE_ID>, but the format could not be found without "
"knowing what event the sample belonged to (causing a circular dependency)."
msgstr ""
"Это было необходимо потому, что поток измерений может содержать записи из "
"различных источников событий с различными параметрами I<sample_type>. "
"Корректный разбор потока событий невозможен, так как для формата записи "
"необходимо найти B<SAMPLE_ID>, но формат невозможно определить без значения "
"какому измерению принадлежит событие (что вызывает циклическую зависимость)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:823
msgid ""
"The B<PERF_SAMPLE_IDENTIFIER> setting makes the event stream always parsable "
"by putting B<SAMPLE_ID> in a fixed location, even though it means having "
"duplicate B<SAMPLE_ID> values in records."
msgstr ""
"Значение B<PERF_SAMPLE_IDENTIFIER> делает поток всегда анализируемым, "
"помещая B<SAMPLE_ID> в фиксированное расположение, несмотря на уже имеющиеся "
"значения B<SAMPLE_ID> в записях."

#. type: TP
#: man-pages/man2/perf_event_open.2:823
#, no-wrap
msgid "B<PERF_SAMPLE_TRANSACTION> (since Linux 3.13)"
msgstr "B<PERF_SAMPLE_TRANSACTION> (начиная с Linux 3.13)"

#.  commit fdfbbd07e91f8fe387140776f3fd94605f0c89e5
#. type: Plain text
#: man-pages/man2/perf_event_open.2:828
msgid ""
"Records reasons for transactional memory abort events (for example, from "
"Intel TSX transactional memory support)."
msgstr ""
"Сохранять причины событий аварий транзакционной памяти (например, из "
"поддержки транзакционной памяти Intel TSX)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:836
msgid ""
"The I<precise_ip> setting must be greater than 0 and a transactional memory "
"abort event must be measured or no values will be recorded.  Also note that "
"some perf_event measurements, such as sampled cycle counting, may cause "
"extraneous aborts (by causing an interrupt during a transaction)."
msgstr ""
"Значение I<precise_ip> должно быть больше 0 и должно измеряться событие "
"аварии транзакционной памяти или значения не будут записаны. Также отметим, "
"что некоторые измерения perf_event, такие как подсчёт числа циклов, могут "
"приводить к дополнительным авариям (вызванным прерыванием во время "
"транзакции)."

#. type: TP
#: man-pages/man2/perf_event_open.2:836
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_INTR> (since Linux 3.19)"
msgstr "B<PERF_SAMPLE_REGS_INTR> (начиная с Linux 3.19)"

#.  commit 60e2364e60e86e81bc6377f49779779e6120977f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:854
msgid ""
"Records a subset of the current CPU register state as specified by "
"I<sample_regs_intr>.  Unlike B<PERF_SAMPLE_REGS_USER> the register values "
"will return kernel register state if the overflow happened while kernel code "
"is running.  If the CPU supports hardware sampling of register state (i.e., "
"PEBS on Intel x86) and I<precise_ip> is set higher than zero then the "
"register values returned are those captured by hardware at the time of the "
"sampled instruction's retirement."
msgstr ""
"Сохранять поднабор текущего состояния регистров ЦП, который определяется "
"I<sample_regs_intr>. В отличии от B<PERF_SAMPLE_REGS_USER> будут возвращены "
"значения регистров из состояния ядра, если произойдёт переполнение при "
"выполнении кода ядра. Если ЦП аппаратно поддерживает измерение состояния "
"регистра (PEBS в Intel x86) и I<precise_ip> больше нуля, то возвращаются "
"значения регистров, захваченных аппаратурой во время измерения запоздалой "
"инструкции."

#. type: TP
#: man-pages/man2/perf_event_open.2:855
#, no-wrap
msgid "I<read_format>"
msgstr "I<read_format>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:862
msgid ""
"This field specifies the format of the data returned by B<read>(2)  on a "
"B<perf_event_open>()  file descriptor."
msgstr ""
"В этом поле задаётся формат данных, возвращаемых B<read>(2) из файлового "
"дескриптора B<perf_event_open>()."

#. type: TP
#: man-pages/man2/perf_event_open.2:863
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"
msgstr "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:870
msgid ""
"Adds the 64-bit I<time_enabled> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""
"Добавлять 64-битное поле I<time_enabled>. Его можно использовать для "
"вычисления общей оценки, если PMU слишком загружено и возникло "
"мультиплексирование."

#. type: TP
#: man-pages/man2/perf_event_open.2:870
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"
msgstr "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:877
msgid ""
"Adds the 64-bit I<time_running> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""
"Добавлять 64-битное поле I<time_running>. Его можно использовать для "
"вычисления общей оценки, если PMU слишком загружено и возникло "
"мультиплексирование."

#. type: TP
#: man-pages/man2/perf_event_open.2:877
#, no-wrap
msgid "B<PERF_FORMAT_ID>"
msgstr "B<PERF_FORMAT_ID>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:880
msgid "Adds a 64-bit unique value that corresponds to the event group."
msgstr ""
"Добавлять 64-битное уникальное значение, которое соответствует группе "
"событий."

#. type: TP
#: man-pages/man2/perf_event_open.2:880
#, no-wrap
msgid "B<PERF_FORMAT_GROUP>"
msgstr "B<PERF_FORMAT_GROUP>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:883
msgid "Allows all counter values in an event group to be read with one read."
msgstr ""
"Позволить все значения счётчиков в группе событий читать за один проход."

#. type: TP
#: man-pages/man2/perf_event_open.2:884
#, no-wrap
msgid "I<disabled>"
msgstr "I<disabled>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:894
msgid ""
"The I<disabled> bit specifies whether the counter starts out disabled or "
"enabled.  If disabled, the event can later be enabled by B<ioctl>(2), "
"B<prctl>(2), or I<enable_on_exec>."
msgstr ""
"Битом I<disabled> определяется, будет ли счётчик изначально включен или "
"выключен. Если выключен, то событие может быть включено позже с помощью "
"B<ioctl>(2), B<prctl>(2) или I<enable_on_exec>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:905
msgid ""
"When creating an event group, typically the group leader is initialized with "
"I<disabled> set to 1 and any child events are initialized with I<disabled> "
"set to 0.  Despite I<disabled> being 0, the child events will not start "
"until the group leader is enabled."
msgstr ""
"Обычно, при создании группы событий значение I<disabled> лидера группы "
"устанавливается в 1, а у любого дочернего события I<disabled> "
"устанавливается в 0. Несмотря на I<disabled> равное 0, дочерние события не "
"запускаются до тех пор, пока не включится лидер группы."

#. type: TP
#: man-pages/man2/perf_event_open.2:905
#, no-wrap
msgid "I<inherit>"
msgstr "I<inherit>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:914
msgid ""
"The I<inherit> bit specifies that this counter should count events of child "
"tasks as well as the task specified.  This applies only to new children, not "
"to any existing children at the time the counter is created (nor to any new "
"children of existing children)."
msgstr ""
"Битом I<inherit> задаётся, должен ли этот счётчик событий считать события "
"дочерних задач, кроме указанной задачи. Это применяется только к новым "
"потомкам, а не к существующим на момент создания счётчика (и не к новым "
"потомкам существующих потомков)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:919
msgid ""
"Inherit does not work for some combinations of I<read_format> values, such "
"as B<PERF_FORMAT_GROUP>."
msgstr ""
"Наследование не работает с некоторыми  комбинациями значений I<read_format>, "
"например с B<PERF_FORMAT_GROUP>."

#. type: TP
#: man-pages/man2/perf_event_open.2:919
#, no-wrap
msgid "I<pinned>"
msgstr "I<pinned>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:932
msgid ""
"The I<pinned> bit specifies that the counter should always be on the CPU if "
"at all possible.  It applies only to hardware counters and only to group "
"leaders.  If a pinned counter cannot be put onto the CPU (e.g., because "
"there are not enough hardware counters or because of a conflict with some "
"other event), then the counter goes into an 'error' state, where reads "
"return end-of-file (i.e., B<read>(2)  returns 0) until the counter is "
"subsequently enabled or disabled."
msgstr ""
"Битом I<pinned> определяется, что счётчик должен всегда быть на ЦП, если это "
"возможно. Применяется только к аппаратным счётчикам и только для лидеров "
"группы. Если прикреплённый счётчик невозможно поместить на ЦП (например, "
"потому что кончились аппаратные счётчики или возник конфликт с другим "
"событием), то счётчик переводится в состояние «ошибки», в котором чтение "
"возвращает конец файла (т. е., B<read>(2) возвращает 0) до тех пор, пока "
"счётчик не будет включен или выключен."

#. type: TP
#: man-pages/man2/perf_event_open.2:932
#, no-wrap
msgid "I<exclusive>"
msgstr "I<exclusive>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:941
msgid ""
"The I<exclusive> bit specifies that when this counter's group is on the CPU, "
"it should be the only group using the CPU's counters.  In the future this "
"may allow monitoring programs to support PMU features that need to run alone "
"so that they do not disrupt other hardware counters."
msgstr ""
"Битом I<exclusive> определяется, что когда эта группа счётчиков на ЦП, то "
"должна быть только одна группа использующая счётчики ЦП. В будущем, это "
"может позволить следящим программам поддерживать возможности PMU, "
"необходимые для автономной работы без нарушения других аппаратных счётчиков."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:948
msgid ""
"Note that many unexpected situations may prevent events with the "
"I<exclusive> bit set from ever running.  This includes any users running a "
"system-wide measurement as well as any kernel use of the performance "
"counters (including the commonly enabled NMI Watchdog Timer interface)."
msgstr ""
"Заметим, что многие неожиданные ситуации могут не позволить событиям с битом "
"I<exclusive> даже выполниться. К ним относятся выполнение любых "
"пользовательских системных измерений, а также использование ядром счётчиков "
"производительности (включая обычно включённый интерфейс NMI Watchdog Timer)."

#. type: TP
#: man-pages/man2/perf_event_open.2:948
#, no-wrap
msgid "I<exclude_user>"
msgstr "I<exclude_user>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:951
msgid ""
"If this bit is set, the count excludes events that happen in user space."
msgstr ""
"Если этот бит установлен, то счётчик не учитывает события, происходящие в "
"пользовательском пространстве."

#. type: TP
#: man-pages/man2/perf_event_open.2:951
#, no-wrap
msgid "I<exclude_kernel>"
msgstr "I<exclude_kernel>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:954
msgid ""
"If this bit is set, the count excludes events that happen in kernel space."
msgstr ""
"Если этот бит установлен, то счётчик не учитывает события, происходящие в "
"пространстве ядра."

#. type: TP
#: man-pages/man2/perf_event_open.2:954
#, no-wrap
msgid "I<exclude_hv>"
msgstr "I<exclude_hv>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:962
msgid ""
"If this bit is set, the count excludes events that happen in the "
"hypervisor.  This is mainly for PMUs that have built-in support for handling "
"this (such as POWER).  Extra support is needed for handling hypervisor "
"measurements on most machines."
msgstr ""
"Если этот бит установлен, то счётчик не учитывает события, происходящие в "
"гипервизоре. В основном для PMU, имеющего для этого возможности (такие как "
"POWER). На большинстве машин необходима дополнительная поддержка для "
"измерений гипервизора."

#. type: TP
#: man-pages/man2/perf_event_open.2:962
#, no-wrap
msgid "I<exclude_idle>"
msgstr "I<exclude_idle>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:967
msgid ""
"If set, don't count when the CPU is running the idle task.  While you can "
"currently enable this for any event type, it is ignored for all but software "
"events."
msgstr ""
"Если установлен, то счётчик не учитывает когда ЦП выполняет задачу простоя. "
"Хотя сейчас вы и можете включить его для любого типа события, он "
"игнорируется во всех кроме программных событий."

#. type: TP
#: man-pages/man2/perf_event_open.2:967
#, no-wrap
msgid "I<mmap>"
msgstr "I<mmap>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:981
msgid ""
"The I<mmap> bit enables generation of B<PERF_RECORD_MMAP> samples for every "
"B<mmap>(2)  call that has B<PROT_EXEC> set.  This allows tools to notice new "
"executable code being mapped into a program (dynamic shared libraries for "
"example)  so that addresses can be mapped back to the original code."
msgstr ""
"Бит I<mmap> включает генерацию измерений B<PERF_RECORD_MMAP> для каждого "
"вызова B<mmap>(2) с установленными битом B<PROT_EXEC>. Это позволяет "
"инструментам замечать новый исполняемый код, отображённый в программу "
"(например, общие динамические библиотеки) так, чтобы адреса можно было "
"отобразить обратно в первоначальный код."

#. type: TP
#: man-pages/man2/perf_event_open.2:981 man-pages/man2/perf_event_open.2:2014
#, no-wrap
msgid "I<comm>"
msgstr "I<comm>"

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1000
msgid ""
"The I<comm> bit enables tracking of process command name as modified by the "
"B<exec>(2)  and B<prctl>(PR_SET_NAME)  system calls as well as writing to I</"
"proc/self/comm>.  If the I<comm_exec> flag is also successfully set "
"(possible since Linux 3.16), then the misc flag "
"B<PERF_RECORD_MISC_COMM_EXEC> can be used to differentiate the B<exec>(2)  "
"case from the others."
msgstr ""
"Битом I<comm> включается слежение за именем команды процесса, изменяемого "
"системными вызовами B<exec>(2) и B<prctl>(PR_SET_NAME), а также через запись "
"в I</proc/self/comm>. Если флаг I<comm_exec> также установлен (работает, "
"начиная с Linux 3.16), то можно использовать вспомогательный флаг "
"B<PERF_RECORD_MISC_COMM_EXEC>, чтобы отличить использование B<exec>(2) от "
"остальных."

#. type: TP
#: man-pages/man2/perf_event_open.2:1000
#, no-wrap
msgid "I<freq>"
msgstr "I<freq>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1007
msgid ""
"If this bit is set, then I<sample_frequency> not I<sample_period> is used "
"when setting up the sampling interval."
msgstr ""
"Если этот бит установлен, то задания интервала измерения используется "
"I<sample_frequency>, а не I<sample_period>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1007
#, no-wrap
msgid "I<inherit_stat>"
msgstr "I<inherit_stat>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1014
msgid ""
"This bit enables saving of event counts on context switch for inherited "
"tasks.  This is meaningful only if the I<inherit> field is set."
msgstr ""
"Этот бит включает сохранение счётчика событий при переключении контекста для "
"наследуемых задач. Это полезно только, если установлен бит I<inherit>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1014
#, no-wrap
msgid "I<enable_on_exec>"
msgstr "I<enable_on_exec>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1019
msgid ""
"If this bit is set, a counter is automatically enabled after a call to "
"B<exec>(2)."
msgstr ""
"Если этот бит установлен, то счётчик автоматически включается после вызова "
"B<exec>(2)."

#. type: TP
#: man-pages/man2/perf_event_open.2:1019
#, no-wrap
msgid "I<task>"
msgstr "I<task>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1023
msgid ""
"If this bit is set, then fork/exit notifications are included in the ring "
"buffer."
msgstr ""
"Если этот бит установлен, то в кольцевой буфер включаются уведомления fork/"
"exit."

#. type: TP
#: man-pages/man2/perf_event_open.2:1023
#, no-wrap
msgid "I<watermark>"
msgstr "I<watermark>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1031
msgid ""
"If set, have an overflow notification happen when we cross the "
"I<wakeup_watermark> boundary.  Otherwise, overflow notifications happen "
"after I<wakeup_events> samples."
msgstr ""
"Если установлен, то выдаётся уведомление о переполнении при пересечении "
"границы I<wakeup_watermark>. В противном случае, уведомления о переполнении "
"выдаются после I<wakeup_events> измерений."

#. type: TP
#: man-pages/man2/perf_event_open.2:1031
#, no-wrap
msgid "I<precise_ip> (since Linux 2.6.35)"
msgstr "I<precise_ip> (начиная с Linux 2.6.35)"

#.  commit ab608344bcbde4f55ec4cd911b686b0ce3eae076
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1042
msgid ""
"This controls the amount of skid.  Skid is how many instructions execute "
"between an event of interest happening and the kernel being able to stop and "
"record the event.  Smaller skid is better and allows more accurate reporting "
"of which events correspond to which instructions, but hardware is often "
"limited with how small this can be."
msgstr ""
"Управляет размером ската (skid). Скат — количество инструкций, выполняемое "
"между возникновением интересующего события и когда ядро способно "
"остановиться и записать событие. Чем меньше скат тем лучше: это приближает "
"события к инструкциям, от которых они возникли, но часто значение "
"ограничивается аппаратурой."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1044
msgid "The possible values of this field are the following:"
msgstr "Возможными значениями этого поля могут быть:"

#. type: IP
#: man-pages/man2/perf_event_open.2:1045 man-pages/man2/perf_event_open.2:3028
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1048
msgid "B<SAMPLE_IP> can have arbitrary skid."
msgstr "B<SAMPLE_IP> может иметь произвольный скат."

#. type: IP
#: man-pages/man2/perf_event_open.2:1048 man-pages/man2/perf_event_open.2:3026
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1051
msgid "B<SAMPLE_IP> must have constant skid."
msgstr "B<SAMPLE_IP> должен иметь постоянный скат."

#. type: IP
#: man-pages/man2/perf_event_open.2:1051 man-pages/man2/perf_event_open.2:3023
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1054
msgid "B<SAMPLE_IP> requested to have 0 skid."
msgstr "B<SAMPLE_IP> запрашивает нулевой скат."

#. type: IP
#: man-pages/man2/perf_event_open.2:1054
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1059
msgid ""
"B<SAMPLE_IP> must have 0 skid.  See also the description of "
"B<PERF_RECORD_MISC_EXACT_IP>."
msgstr ""
"Значение B<SAMPLE_IP> должно иметь 0 скат (skid). Смотрите также описание I "
"в B<PERF_RECORD_MISC_EXACT_IP>()."

#. type: TP
#: man-pages/man2/perf_event_open.2:1060
#, no-wrap
msgid "I<mmap_data> (since Linux 2.6.36)"
msgstr "I<mmap_data> (начиная с Linux 2.6.36)"

#.  commit 3af9e859281bda7eb7c20b51879cf43aa788ac2e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1073
msgid ""
"This is the counterpart of the I<mmap> field.  This enables generation of "
"B<PERF_RECORD_MMAP> samples for B<mmap>(2)  calls that do not have "
"B<PROT_EXEC> set (for example data and SysV shared memory)."
msgstr ""
"Противоположно полю I<mmap>. Включает генерацию измерений "
"B<PERF_RECORD_MMAP> для вызовов B<mmap>(2), у которых не установлен бит "
"B<PROT_EXEC> (например, у данных и общей памяти SysV)."

#. type: TP
#: man-pages/man2/perf_event_open.2:1073
#, no-wrap
msgid "I<sample_id_all> (since Linux 2.6.38)"
msgstr "I<sample_id_all> (начиная с Linux 2.6.38)"

#.  commit c980d1091810df13f21aabbce545fd98f545bbf7
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1082
msgid ""
"If set, then TID, TIME, ID, STREAM_ID, and CPU can additionally be included "
"in non-B<PERF_RECORD_SAMPLE>s if the corresponding I<sample_type> is "
"selected."
msgstr ""
"Если установлен, то TID, TIME, ID, STREAM_ID и ЦП могут дополнительно "
"включаться в не-B<PERF_RECORD_SAMPLE>, если выбран соответствующий "
"I<sample_type>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1090
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is specified, then an additional ID value is "
"included as the last value to ease parsing the record stream.  This may lead "
"to the I<id> value appearing twice."
msgstr ""
"Если указан B<PERF_SAMPLE_IDENTIFIER>, то дополнительно включается значение "
"ID в качестве последнего значения для облегчения разбора потока записей. Это "
"может привести к появлению значения I<id> дважды."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1092
msgid "The layout is described by this pseudo-structure:"
msgstr "Состав описывается следующей псевдо-структурой:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1103
#, no-wrap
msgid ""
"struct sample_id {\n"
"    { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */\n"
"    { u64 time;     }   /* if PERF_SAMPLE_TIME set */\n"
"    { u64 id;       }   /* if PERF_SAMPLE_ID set */\n"
"    { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */\n"
"    { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */\n"
"    { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */\n"
"};\n"
msgstr ""
"struct sample_id {\n"
"    { u32 pid, tid; } /* если есть PERF_SAMPLE_TID */\n"
"    { u64 time;     } /* если есть PERF_SAMPLE_TIME */\n"
"    { u64 id;       } /* если есть PERF_SAMPLE_ID */\n"
"    { u64 stream_id;} /* если есть PERF_SAMPLE_STREAM_ID */\n"
"    { u32 cpu, res; } /* если есть PERF_SAMPLE_CPU */\n"
"    { u64 id;       } /* если есть PERF_SAMPLE_IDENTIFIER */\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1105
#, no-wrap
msgid "I<exclude_host> (since Linux 3.2)"
msgstr "I<exclude_host> (начиная с Linux 3.2)"

#.  commit a240f76165e6255384d4bdb8139895fac7988799
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1116
msgid ""
"When conducting measurements that include processes running VM instances (i."
"e., have executed a B<KVM_RUN> B<ioctl>(2)), only measure events happening "
"inside a guest instance.  This is only meaningful outside the guests; this "
"setting does not change counts gathered inside of a guest.  Currently, this "
"functionality is x86 only."
msgstr ""
"При проведении измерений, которые включают процессы, запускающие экземпляры "
"VM (т. е. выполняют I B<ioctl>(2) B<KVM_RUN>), измеряются только события, "
"возникающие внутри гостевого экземпляра. Имеет смысл только вне гостевых "
"машин; эта настройка не изменяет счётчики, собираемые внутри гостей. В "
"настоящее время работает только на x86."

#. type: TP
#: man-pages/man2/perf_event_open.2:1116
#, no-wrap
msgid "I<exclude_guest> (since Linux 3.2)"
msgstr "I<exclude_guest> (начиная с Linux 3.2)"

#.  commit a240f76165e6255384d4bdb8139895fac7988799
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1127
msgid ""
"When conducting measurements that include processes running VM instances (i."
"e., have executed a B<KVM_RUN> B<ioctl>(2)), do not measure events happening "
"inside guest instances.  This is only meaningful outside the guests; this "
"setting does not change counts gathered inside of a guest.  Currently, this "
"functionality is x86 only."
msgstr ""
"При проведении измерений, которые включают процессы, запускающие экземпляры "
"VM (т. е. выполняют I B<ioctl>(2) B<KVM_RUN>), не измеряются события, "
"возникающие внутри гостевого экземпляра. Имеет смысл только вне гостевых "
"машин; эта настройка не изменяет счётчики, собираемые внутри гостей. В "
"настоящее время работает только на x86."

#. type: TP
#: man-pages/man2/perf_event_open.2:1127
#, no-wrap
msgid "I<exclude_callchain_kernel> (since Linux 3.7)"
msgstr "I<exclude_callchain_kernel> (начиная с Linux 3.7)"

#.  commit d077526485d5c9b12fe85d0b2b3b7041e6bc5f91
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1131
msgid "Do not include kernel callchains."
msgstr "Не включать цепочку вызовов ядра."

#. type: TP
#: man-pages/man2/perf_event_open.2:1131
#, no-wrap
msgid "I<exclude_callchain_user> (since Linux 3.7)"
msgstr "I<exclude_callchain_user> (начиная с Linux 3.7)"

#.  commit d077526485d5c9b12fe85d0b2b3b7041e6bc5f91
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1135
msgid "Do not include user callchains."
msgstr "Не включать цепочку вызовов пользовательского пространства."

#. type: TP
#: man-pages/man2/perf_event_open.2:1135
#, no-wrap
msgid "I<mmap2> (since Linux 3.16)"
msgstr "I<mmap2> (начиная с Linux 3.16)"

#.  commit 13d7a2410fa637f450a29ecb515ac318ee40c741
#.  This is tricky; was committed during 3.12 development
#.  but right before release was disabled.
#.  So while you could select mmap2 starting with 3.12
#.  it did not work until 3.16
#.  commit a5a5ba72843dd05f991184d6cb9a4471acce1005
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1148
msgid ""
"Generate an extended executable mmap record that contains enough additional "
"information to uniquely identify shared mappings.  The I<mmap> flag must "
"also be set for this to work."
msgstr ""
"Генерировать расширенную запись выполняемого mmap, которая содержит "
"дополнительную информацию, достаточную для определения уникальности общих "
"отображений. Для работы также требуется установить флаг I<mmap>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1148
#, no-wrap
msgid "I<comm_exec> (since Linux 3.16)"
msgstr "I<comm_exec> (начиная с Linux 3.16)"

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1164
msgid ""
"This is purely a feature-detection flag, it does not change kernel "
"behavior.  If this flag can successfully be set, then, when I<comm> is "
"enabled, the B<PERF_RECORD_MISC_COMM_EXEC> flag will be set in the I<misc> "
"field of a comm record header if the rename event being reported was caused "
"by a call to B<exec>(2).  This allows tools to distinguish between the "
"various types of process renaming."
msgstr ""
"Флаг определения свойств, не изменяет поведение ядра. Если флаг установлен, "
"то когда включён I<comm>, будет устанавливаться флаг "
"B<PERF_RECORD_MISC_COMM_EXEC> в поле I<misc> заголовка записи comm, если "
"сообщается о событии переименования, вызванного вызовом B<exec>(2). Это "
"позволяет инструментам различать различные тип переименования процесса."

#. type: TP
#: man-pages/man2/perf_event_open.2:1164
#, no-wrap
msgid "I<use_clockid> (since Linux 4.1)"
msgstr "I<use_clockid> (начиная с Linux 4.1)"

#.  commit 34f439278cef7b1177f8ce24f9fc81dfc6221d3b
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1173
msgid ""
"This allows selecting which internal Linux clock to use when generating "
"timestamps via the I<clockid> field.  This can make it easier to correlate "
"perf sample times with timestamps generated by other tools."
msgstr ""
"Через I<clockid> позволяет выбрать внутренние часы Linux, используемые для "
"генерации меток времени. Это может облегчить соответствие времён измерений с "
"метками времени, сгенерированными другими инструментами."

#. type: TP
#: man-pages/man2/perf_event_open.2:1173
#, no-wrap
msgid "I<context_switch> (since Linux 4.3)"
msgstr "I<context_switch> (начиная с Linux 4.3)"

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1188
msgid ""
"This enables the generation of B<PERF_RECORD_SWITCH> records when a context "
"switch occurs.  It also enables the generation of "
"B<PERF_RECORD_SWITCH_CPU_WIDE> records when sampling in CPU-wide mode.  This "
"functionality is in addition to existing tracepoint and software events for "
"measuring context switches.  The advantage of this method is that it will "
"give full information even with strict I<perf_event_paranoid> settings."
msgstr ""
"Включает генерацию записей B<PERF_RECORD_SWITCH> при переключении контекста. "
"Также включает генерацию записей B<PERF_RECORD_SWITCH_CPU_WIDE> при "
"измерении в режиме CPU-wide. Данная возможность дополняет существующие точки "
"трассировки и программные события для измерения переключений контекста. "
"Преимущество этого метода в том, что он даёт полную информацию даже при "
"ограничительных настройках I<perf_event_paranoid>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1188
#, no-wrap
msgid "I<wakeup_events>, I<wakeup_watermark>"
msgstr "I<wakeup_events>, I<wakeup_watermark>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1198
msgid ""
"This union sets how many samples (I<wakeup_events>)  or bytes "
"(I<wakeup_watermark>)  happen before an overflow notification happens.  "
"Which one is used is selected by the I<watermark> bit flag."
msgstr ""
"Это объединение задаёт как много измерений (I<wakeup_events>) или байт "
"(I<wakeup_watermark>) должно произойти до уведомления о переполнении. "
"Используемое поле выбирается битом флага I<watermark>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1208
msgid ""
"I<wakeup_events> counts only B<PERF_RECORD_SAMPLE> record types.  To receive "
"overflow notification for all B<PERF_RECORD> types choose watermark and set "
"I<wakeup_watermark> to 1."
msgstr ""
"В I<wakeup_events> подсчитываются только записи с типом "
"B<PERF_RECORD_SAMPLE>. Для приёма уведомления о переполнении всех типов "
"B<PERF_RECORD> выберите watermark и присвойте I<wakeup_watermark> значение 1."

#.  commit f506b3dc0ec454a16d40cab9ee5d75435b39dc50
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1214
msgid ""
"Prior to Linux 3.0, setting I<wakeup_events> to 0 resulted in no overflow "
"notifications; more recent kernels treat 0 the same as 1."
msgstr ""
"До Linux 3.0 установка I<wakeup_events> в 0 приводила к выключению "
"уведомления о переполнении; новые ядра считают 0 как 1."

#. type: TP
#: man-pages/man2/perf_event_open.2:1214
#, no-wrap
msgid "I<bp_type> (since Linux 2.6.33)"
msgstr "I<bp_type> (начиная с Linux 2.6.33)"

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1219
msgid "This chooses the breakpoint type.  It is one of:"
msgstr "Задаёт тип точки останова. Может быть:"

#. type: TP
#: man-pages/man2/perf_event_open.2:1220
#, no-wrap
msgid "B<HW_BREAKPOINT_EMPTY>"
msgstr "B<HW_BREAKPOINT_EMPTY>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1223
msgid "No breakpoint."
msgstr "Нет точки останова."

#. type: TP
#: man-pages/man2/perf_event_open.2:1223
#, no-wrap
msgid "B<HW_BREAKPOINT_R>"
msgstr "B<HW_BREAKPOINT_R>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1226
msgid "Count when we read the memory location."
msgstr "Считать, когда выполняется чтение из определённого места памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:1226
#, no-wrap
msgid "B<HW_BREAKPOINT_W>"
msgstr "B<HW_BREAKPOINT_W>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1229
msgid "Count when we write the memory location."
msgstr "Считать, когда выполняется запись в определённое место памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:1229
#, no-wrap
msgid "B<HW_BREAKPOINT_RW>"
msgstr "B<HW_BREAKPOINT_RW>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1232
msgid "Count when we read or write the memory location."
msgstr ""
"Считать, когда выполняется чтение или запись в определённое место памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:1232
#, no-wrap
msgid "B<HW_BREAKPOINT_X>"
msgstr "B<HW_BREAKPOINT_X>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1235
msgid "Count when we execute code at the memory location."
msgstr "Считать, когда выполняется код из определённого места памяти."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1244
msgid ""
"The values can be combined via a bitwise or, but the combination of "
"B<HW_BREAKPOINT_R> or B<HW_BREAKPOINT_W> with B<HW_BREAKPOINT_X> is not "
"allowed."
msgstr ""
"Значения можно побитово объединять, но комбинация B<HW_BREAKPOINT_R> или "
"B<HW_BREAKPOINT_W> с B<HW_BREAKPOINT_X> недопустима."

#. type: TP
#: man-pages/man2/perf_event_open.2:1245
#, no-wrap
msgid "I<bp_addr> (since Linux 2.6.33)"
msgstr "I<bp_addr> (начиная с Linux 2.6.33)"

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1252
msgid ""
"This is the address of the breakpoint.  For execution breakpoints, this is "
"the memory address of the instruction of interest; for read and write "
"breakpoints, it is the memory address of the memory location of interest."
msgstr ""
"Адрес точки останова. Для точек останова выполнения это адрес памяти "
"интересующей инструкции; для точек останова чтения и записи это адрес памяти "
"интересующего расположения в памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:1252
#, no-wrap
msgid "I<config1> (since Linux 2.6.39)"
msgstr "I<config1> (начиная с Linux 2.6.39)"

#.  commit a7e3ed1e470116c9d12c2f778431a481a6be8ab6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1260
msgid ""
"I<config1> is used for setting events that need an extra register or "
"otherwise do not fit in the regular config field.  Raw OFFCORE_EVENTS on "
"Nehalem/Westmere/SandyBridge use this field on Linux 3.3 and later kernels."
msgstr ""
"Значение I<config1> используется для задания событий, которым нужен "
"дополнительный регистр или не хватает обычного поля config. Это поле "
"используется в Linux 3.3  и новее для неструктурированного OFFCORE_EVENTS на "
"архитектурах Nehalem/Westmere/SandyBridge."

#. type: TP
#: man-pages/man2/perf_event_open.2:1260
#, no-wrap
msgid "I<bp_len> (since Linux 2.6.33)"
msgstr "I<bp_len> (начиная с Linux 2.6.33)"

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1276
msgid ""
"I<bp_len> is the length of the breakpoint being measured if I<type> is "
"B<PERF_TYPE_BREAKPOINT>.  Options are B<HW_BREAKPOINT_LEN_1>, "
"B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4>, and B<HW_BREAKPOINT_LEN_8>.  "
"For an execution breakpoint, set this to I<sizeof(long)>."
msgstr ""
"В I<bp_len> содержится длина точки измеряемой останова, если значение "
"I<type> равно B<PERF_TYPE_BREAKPOINT>. Можно указывать "
"B<HW_BREAKPOINT_LEN_1>, B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4> и "
"B<HW_BREAKPOINT_LEN_8>. Для точки останова выполнения присвойте "
"I<sizeof(long)>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1276
#, no-wrap
msgid "I<config2> (since Linux 2.6.39)"
msgstr "I<config2> (начиная с Linux 2.6.39)"

#.  commit a7e3ed1e470116c9d12c2f778431a481a6be8ab6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1283
msgid "I<config2> is a further extension of the I<config1> field."
msgstr "Поле I<config2> — дальнейшее расширение поля I<config1>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1283
#, no-wrap
msgid "I<branch_sample_type> (since Linux 3.4)"
msgstr "I<branch_sample_type> (начиная с Linux 3.4)"

#.  commit bce38cd53e5ddba9cb6d708c4ef3d04a4016ec7e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1290
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then this specifies what branches "
"to include in the branch record."
msgstr ""
"Если установлен B<PERF_SAMPLE_BRANCH_STACK>, то ветви будут включаться в "
"запись ветви."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1296
msgid ""
"The first part of the value is the privilege level, which is a combination "
"of one of the values listed below.  If the user does not set privilege level "
"explicitly, the kernel will use the event's privilege level.  Event and "
"branch privilege levels do not have to match."
msgstr ""
"В первой части значения задаётся уровень привилегий, который может быть "
"комбинацией одного из показанных ниже значений. Если пользователь явно не "
"задал уровень привилегий, то ядро будет использовать уровень привилегий "
"события. Событие и уровни привилегий ветви не совпадают."

#. type: TP
#: man-pages/man2/perf_event_open.2:1297
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_USER>"
msgstr "B<PERF_SAMPLE_BRANCH_USER>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1300
msgid "Branch target is in user space."
msgstr "Цель ветвления в пользовательском пространстве"

#. type: TP
#: man-pages/man2/perf_event_open.2:1300
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_KERNEL>"
msgstr "B<PERF_SAMPLE_BRANCH_KERNEL>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1303
msgid "Branch target is in kernel space."
msgstr "Цель ветвления в пространстве ядра"

#. type: TP
#: man-pages/man2/perf_event_open.2:1303
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_HV>"
msgstr "B<PERF_SAMPLE_BRANCH_HV>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1306
msgid "Branch target is in hypervisor."
msgstr "Цель ветвления в гипервизоре."

#. type: TP
#: man-pages/man2/perf_event_open.2:1306
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_PLM_ALL>"
msgstr "B<PERF_SAMPLE_BRANCH_PLM_ALL>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1309
msgid "A convenience value that is the three preceding values ORed together."
msgstr ""
"Подходящее значение состоит из трёх предшествующих значений объединённых OR."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1312
msgid ""
"In addition to the privilege value, at least one or more of the following "
"bits must be set."
msgstr ""
"В дополнении к значению привилегий, должно быть указано как минимум, одно из "
"следующих:"

#. type: TP
#: man-pages/man2/perf_event_open.2:1312
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY>"
msgstr "B<PERF_SAMPLE_BRANCH_ANY>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1315
msgid "Any branch type."
msgstr "Любой тип ветвления."

#. type: TP
#: man-pages/man2/perf_event_open.2:1315
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_CALL>"
msgstr "B<PERF_SAMPLE_BRANCH_ANY_CALL>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1318
msgid "Any call branch (includes direct calls, indirect calls, and far jumps)."
msgstr "Любое ветвление (прямые вызовы, косвенные вызовы и дальние переходы)."

#. type: TP
#: man-pages/man2/perf_event_open.2:1318
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_CALL>"
msgstr "B<PERF_SAMPLE_BRANCH_IND_CALL>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1321
msgid "Indirect calls."
msgstr "Косвенные вызовы."

#. type: TP
#: man-pages/man2/perf_event_open.2:1321
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_CALL> (since Linux 4.4)"
msgstr "B<PERF_SAMPLE_BRANCH_CALL> (начиная с Linux 4.4)"

#.  commit c229bf9dc179d2023e185c0f705bdf68484c1e73
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1325
msgid "Direct calls."
msgstr "Прямые вызовы."

#. type: TP
#: man-pages/man2/perf_event_open.2:1325
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"
msgstr "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1328
msgid "Any return branch."
msgstr "Любой возврат из ветвления."

#. type: TP
#: man-pages/man2/perf_event_open.2:1328
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_JUMP> (since Linux 4.2)"
msgstr "B<PERF_SAMPLE_BRANCH_IND_JUMP> (начиная с Linux 4.2)"

#.  commit c9fdfa14c3792c0160849c484e83aa57afd80ccc
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1332
msgid "Indirect jumps."
msgstr "Косвенные прыжки."

#. type: TP
#: man-pages/man2/perf_event_open.2:1332
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_COND> (since Linux 3.16)"
msgstr "B<PERF_SAMPLE_BRANCH_COND> (начиная с Linux 3.16)"

#.  commit bac52139f0b7ab31330e98fd87fc5a2664951050
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1336
msgid "Conditional branches."
msgstr "Ветвления по условию."

#. type: TP
#: man-pages/man2/perf_event_open.2:1336
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ABORT_TX> (since Linux 3.11)"
msgstr "B<PERF_SAMPLE_BRANCH_ABORT_TX> (начиная с Linux 3.11)"

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1340
msgid "Transactional memory aborts."
msgstr "Аварии транзакционной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:1340
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IN_TX> (since Linux 3.11)"
msgstr "B<PERF_SAMPLE_BRANCH_IN_TX> (начиная с Linux 3.11)"

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1344
msgid "Branch in transactional memory transaction."
msgstr "Ветвление в транзакции транзакционной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:1344
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_NO_TX> (since Linux 3.11)"
msgstr "B<PERF_SAMPLE_BRANCH_NO_TX> (начиная с Linux 3.11)"

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#.  commit 2c44b1936bb3b135a3fac8b3493394d42e51cf70
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1353
msgid ""
"Branch not in transactional memory transaction.  "
"B<PERF_SAMPLE_BRANCH_CALL_STACK> (since Linux 4.1)  Branch is part of a "
"hardware-generated call stack.  This requires hardware support, currently "
"only found on Intel x86 Haswell or newer."
msgstr ""
"Ветвление не транзакции транзакционной памяти. "
"B<PERF_SAMPLE_BRANCH_CALL_STACK> (начиная с Linux 4.1) Ветвление это часть "
"аппаратно создаваемого стека вызовов. Требует аппаратной поддержки, в "
"настоящее время работает только на Intel x86 Haswell и новее."

#. type: TP
#: man-pages/man2/perf_event_open.2:1354
#, no-wrap
msgid "I<sample_regs_user> (since Linux 3.7)"
msgstr "I<sample_regs_user> (начиная с Linux 3.7)"

#.  commit 4018994f3d8785275ef0e7391b75c3462c029e56
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1361
msgid ""
"This bit mask defines the set of user CPU registers to dump on samples.  The "
"layout of the register mask is architecture-specific and is described in the "
"kernel header file I<arch/ARCH/include/uapi/asm/perf_regs.h>."
msgstr ""
"Данной битовой маской задаётся набор битов пользовательских регистров ЦП, "
"которые сохраняются в измерениях. Значения битов в битовой маске зависят от "
"архитектуры и описаны в заголовочном файле ядра I<arch/ARCH/include/uapi/asm/"
"perf_regs.h>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1361
#, no-wrap
msgid "I<sample_stack_user> (since Linux 3.7)"
msgstr "I<sample_stack_user> (начиная с Linux 3.7)"

#.  commit c5ebcedb566ef17bda7b02686e0d658a7bb42ee7
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1367
msgid ""
"This defines the size of the user stack to dump if B<PERF_SAMPLE_STACK_USER> "
"is specified."
msgstr ""
"Задаёт размер сохраняемого пользовательского стека, если указан "
"B<PERF_SAMPLE_STACK_USER>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1367
#, no-wrap
msgid "I<clockid> (since Linux 4.1)"
msgstr "I<clockid> (начиная с Linux 4.1)"

#.  commit 34f439278cef7b1177f8ce24f9fc81dfc6221d3b
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1384
msgid ""
"If I<use_clockid> is set, then this field selects which internal Linux timer "
"to use for timestamps.  The available timers are defined in I<linux/time.h>, "
"with B<CLOCK_MONOTONIC>, B<CLOCK_MONOTONIC_RAW>, B<CLOCK_REALTIME>, "
"B<CLOCK_BOOTTIME>, and B<CLOCK_TAI> currently supported."
msgstr ""
"Если установлен I<use_clockid>, то этим полем выбирается внутренний таймер "
"Linux, используемый для меток времени.Доступные таймеры определены в I<linux/"
"time.h>; в настоящее время поддерживаются B<CLOCK_MONOTONIC>, "
"B<CLOCK_MONOTONIC_RAW>, B<CLOCK_REALTIME>, B<CLOCK_BOOTTIME> и B<CLOCK_TAI>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1384
#, no-wrap
msgid "I<aux_watermark> (since Linux 4.1)"
msgstr "I<aux_watermark> (начиная с Linux 4.1)"

#.  commit 1a5941312414c71dece6717da9a0fa1303127afa
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1390
msgid ""
"This specifies how much data is required to trigger a B<PERF_RECORD_AUX> "
"sample."
msgstr ""
"Определяет какое количество данных требуется для запуска измерения "
"B<PERF_RECORD_AUX>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1390
#, no-wrap
msgid "I<sample_max_stack> (since Linux 4.8)"
msgstr "I<sample_max_stack> (начиная с Linux 4.8)"

#.  commit 97c79a38cd454602645f0470ffb444b3b75ce574
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1399
msgid ""
"When I<sample_type> includes B<PERF_SAMPLE_CALLCHAIN>, this field specifies "
"how many stack frames to report when generating the callchain."
msgstr ""
"Если I<sample_type> содержит B<PERF_SAMPLE_CALLCHAIN>, то в этом поле "
"задаётся количество выводимых кадров стека при генерации цепочки вызовов."

#. type: SS
#: man-pages/man2/perf_event_open.2:1399
#, no-wrap
msgid "Reading results"
msgstr "Чтение результатов"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1409
msgid ""
"Once a B<perf_event_open>()  file descriptor has been opened, the values of "
"the events can be read from the file descriptor.  The values that are there "
"are specified by the I<read_format> field in the I<attr> structure at open "
"time."
msgstr ""
"После открытия файлового дескриптора с помощью B<perf_event_open>(), "
"значения событий доступны на чтение. События задаются вв поле I<read_format> "
"структуры I<attr> в момент открытия."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1414
msgid ""
"If you attempt to read into a buffer that is not big enough to hold the "
"data, the error B<ENOSPC> results."
msgstr ""
"Если вы попытаетесь выполнить чтение в буфер недостаточного размера, то "
"результатом будет ошибка B<ENOSPC>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1416
msgid "Here is the layout of the data returned by a read:"
msgstr "Вот компоновка данных, возвращаемых чтением:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1420
msgid ""
"If B<PERF_FORMAT_GROUP> was specified to allow reading all events in a group "
"at once:"
msgstr ""
"Если указан B<PERF_FORMAT_GROUP> для разрешения чтения всех событий в группе "
"за раз:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1432
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 nr;            /* The number of events */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct {\n"
"        u64 value;     /* The value of the event */\n"
"        u64 id;        /* if PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"
msgstr ""
"struct read_format {\n"
"    u64 nr;            /* количество событий */\n"
"    u64 time_enabled;  /* если PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* если PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct {\n"
"        u64 value;     /* значение события */\n"
"        u64 id;        /* если PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1440
msgid "If B<PERF_FORMAT_GROUP> was I<not> specified:"
msgstr "Если B<PERF_FORMAT_GROUP> I<не> указан:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1449
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 value;         /* The value of the event */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* if PERF_FORMAT_ID */\n"
"};\n"
msgstr ""
"struct read_format {\n"
"    u64 value;         /* значение события */\n"
"    u64 time_enabled;  /* если PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* если PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* если PERF_FORMAT_ID */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1453
msgid "The values read are as follows:"
msgstr "Значения полей:"

#. type: TP
#: man-pages/man2/perf_event_open.2:1453
#, no-wrap
msgid "I<nr>"
msgstr "I<nr>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1459
msgid ""
"The number of events in this file descriptor.  Available only if "
"B<PERF_FORMAT_GROUP> was specified."
msgstr ""
"Количество событий в этом файловом дескрипторе. Доступно только, если указан "
"B<PERF_FORMAT_GROUP>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1459
#, no-wrap
msgid "I<time_enabled>, I<time_running>"
msgstr "I<time_enabled>, I<time_running>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1470
msgid ""
"Total time the event was enabled and running.  Normally these values are the "
"same.  Multiplexing happens if the number of events is more than the number "
"of available PMU counter slots.  In that case the events run only part of "
"the time and the I<time_enabled> and I<time running> values can be used to "
"scale an estimated value for the count."
msgstr ""
"Полное время события с момента включения и выполнения. Обычно, эти значения "
"одинаковы. Если событий больше, чем доступно счётчиков слотов в PMU, то "
"возникает мультиплексирование. В этом случае  события выполняются только "
"часть времени и значения I<time_enabled> и I<time running> можно "
"использовать для градации рассчитанного значения в счётчике."

#. type: TP
#: man-pages/man2/perf_event_open.2:1470
#, no-wrap
msgid "I<value>"
msgstr "I<value>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1473
msgid "An unsigned 64-bit value containing the counter result."
msgstr "Целое беззнаковое 64-битное значение, содержащее счётчик-результат."

#. type: TP
#: man-pages/man2/perf_event_open.2:1473 man-pages/man2/perf_event_open.2:1985
#: man-pages/man2/perf_event_open.2:2156
#, no-wrap
msgid "I<id>"
msgstr "I<id>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1479
msgid ""
"A globally unique value for this particular event; only present if "
"B<PERF_FORMAT_ID> was specified in I<read_format>."
msgstr ""
"Глобально уникальное значение данного события; присутствует только, если в "
"I<read_format> указан B<PERF_FORMAT_ID>."

#. type: SS
#: man-pages/man2/perf_event_open.2:1479
#, no-wrap
msgid "MMAP layout"
msgstr "Разбивка MMAP"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1489
msgid ""
"When using B<perf_event_open>()  in sampled mode, asynchronous events (like "
"counter overflow or B<PROT_EXEC> mmap tracking)  are logged into a ring-"
"buffer.  This ring-buffer is created and accessed through B<mmap>(2)."
msgstr ""
"При использовании B<perf_event_open>() в режиме измерений, асинхронные "
"события (такие как переполнение счётчика или слежение за B<PROT_EXEC> mmap) "
"протоколируются в кольцевой буфер. Этот кольцевой буфер создаётся и доступен "
"через B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1495
msgid ""
"The mmap size should be 1+2^n pages, where the first page is a metadata page "
"(I<struct perf_event_mmap_page>)  that contains various bits of information "
"such as where the ring-buffer head is."
msgstr ""
"Размер mmap должен быть 1+2^n страниц, где первая страница — страница "
"метаданных (I<struct perf_event_mmap_page>), в которой содержится различная "
"информация (например, начало кольцевого буфера)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1498
msgid ""
"Before kernel 2.6.39, there is a bug that means you must allocate an mmap "
"ring buffer when sampling even if you do not plan to access it."
msgstr ""
"До ядра версии 2.6.39, существовал дефект, который требовал от вас выделения "
"кольцевого буфера mmap при измерении, даже если доступ к нему не "
"планировался."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1500
msgid "The structure of the first metadata mmap page is as follows:"
msgstr "Структура первой страницы метаданных mmap:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1534
#, no-wrap
msgid ""
"struct perf_event_mmap_page {\n"
"    __u32 version;        /* version number of this structure */\n"
"    __u32 compat_version; /* lowest version this is compat with */\n"
"    __u32 lock;           /* seqlock for synchronization */\n"
"    __u32 index;          /* hardware counter identifier */\n"
"    __s64 offset;         /* add to hardware counter value */\n"
"    __u64 time_enabled;   /* time event active */\n"
"    __u64 time_running;   /* time event on CPU */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        struct {\n"
"            __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,\n"
"                  cap_bit0_is_deprecated : 1,\n"
"                  cap_user_rdpmc         : 1,\n"
"                  cap_user_time          : 1,\n"
"                  cap_user_time_zero     : 1,\n"
"        };\n"
"    };\n"
"    __u16 pmc_width;\n"
"    __u16 time_shift;\n"
"    __u32 time_mult;\n"
"    __u64 time_offset;\n"
"    __u64 __reserved[120];   /* Pad to 1 k */\n"
"    __u64 data_head;         /* head in the data section */\n"
"    __u64 data_tail;         /* user-space written tail */\n"
"    __u64 data_offset;       /* where the buffer starts */\n"
"    __u64 data_size;         /* data buffer size */\n"
"    __u64 aux_head;\n"
"    __u64 aux_tail;\n"
"    __u64 aux_offset;\n"
"    __u64 aux_size;\n"
msgstr ""
"struct perf_event_mmap_page {\n"
"    __u32 version;        /* номер версии структуры */\n"
"    __u32 compat_version; /* наименьшая совместимая версия */\n"
"    __u32 lock;           /* seqlock для синхронизации */\n"
"    __u32 index;          /* идентификатор аппаратного счётчика */\n"
"    __s64 offset;         /* добавляется к значению аппаратного\n"
"                             счётчика */\n"
"    __u64 time_enabled;   /* время активности события */\n"
"    __u64 time_running;   /* время события на ЦП */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        struct {\n"
"            __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,\n"
"                  cap_bit0_is_deprecated : 1,\n"
"                  cap_user_rdpmc         : 1,\n"
"                  cap_user_time          : 1,\n"
"                  cap_user_time_zero     : 1,\n"
"        };\n"
"    };\n"
"    __u16 pmc_width;\n"
"    __u16 time_shift;\n"
"    __u32 time_mult;\n"
"    __u64 time_offset;\n"
"    __u64 __reserved[120];   /* дополнение до 1 k */\n"
"    __u64 data_head;         /* заголовок в секции данных */\n"
"    __u64 data_tail;         /* хвост, записываемый из\n"
"                                пользовательского пространства */\n"
"    __u64 data_offset;       /* начало буфера */\n"
"    __u64 data_size;         /* размер буфера данных */\n"
"    __u64 aux_head;\n"
"    __u64 aux_tail;\n"
"    __u64 aux_offset;\n"
"    __u64 aux_size;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1536
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1542
msgid ""
"The following list describes the fields in the I<perf_event_mmap_page> "
"structure in more detail:"
msgstr ""
"В следующем списке поля структуры I<perf_event_mmap_page> описаны более "
"подробно:"

#. type: TP
#: man-pages/man2/perf_event_open.2:1542
#, no-wrap
msgid "I<version>"
msgstr "I<version>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1545
msgid "Version number of this structure."
msgstr "Номер версии этой структуры."

#. type: TP
#: man-pages/man2/perf_event_open.2:1545
#, no-wrap
msgid "I<compat_version>"
msgstr "I<compat_version>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1548
msgid "The lowest version this is compatible with."
msgstr "Наименьший номер версии, совместимой с данной структурой."

#. type: TP
#: man-pages/man2/perf_event_open.2:1548
#, no-wrap
msgid "I<lock>"
msgstr "I<lock>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1551
msgid "A seqlock for synchronization."
msgstr "Значение seqlock для синхронизации."

#. type: TP
#: man-pages/man2/perf_event_open.2:1551
#, no-wrap
msgid "I<index>"
msgstr "I<index>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1554
msgid "A unique hardware counter identifier."
msgstr "Уникальный идентификатор аппаратного счётчика."

#. type: TP
#: man-pages/man2/perf_event_open.2:1554
#, no-wrap
msgid "I<offset>"
msgstr "I<offset>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1559
msgid ""
"When using rdpmc for reads this offset value must be added to the one "
"returned by rdpmc to get the current total event count."
msgstr ""
"При использовании rdpmc для чтения это значение смещения должно добавляться "
"к возвращаемому rdpmc для получения текущего общего количества событий."

#. type: TP
#: man-pages/man2/perf_event_open.2:1559
#, no-wrap
msgid "I<time_enabled>"
msgstr "I<time_enabled>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1562
msgid "Time the event was active."
msgstr "Время активности события."

#. type: TP
#: man-pages/man2/perf_event_open.2:1562
#, no-wrap
msgid "I<time_running>"
msgstr "I<time_running>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1565
msgid "Time the event was running."
msgstr "Время выполнения события."

#. type: TP
#: man-pages/man2/perf_event_open.2:1565
#, no-wrap
msgid "I<cap_usr_time> / I<cap_usr_rdpmc> / I<cap_bit0> (since Linux 3.4)"
msgstr "I<cap_usr_time> / I<cap_usr_rdpmc> / I<cap_bit0> (начиная с Linux 3.4)"

#.  commit c7206205d00ab375839bd6c7ddb247d600693c09
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1579
msgid ""
"There was a bug in the definition of I<cap_usr_time> and I<cap_usr_rdpmc> "
"from Linux 3.4 until Linux 3.11.  Both bits were defined to point to the "
"same location, so it was impossible to know if I<cap_usr_time> or "
"I<cap_usr_rdpmc> were actually set."
msgstr ""
"С Linux 3.4 по Linux 3.11 был дефект в определении I<cap_usr_time> и "
"I<cap_usr_rdpmc>. В обоих биты указывали на одно место, поэтому было "
"невозможно узнать что на самом деле установлено: I<cap_usr_time> или "
"I<cap_usr_rdpmc>."

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1588
msgid ""
"Starting with Linux 3.12, these are renamed to I<cap_bit0> and you should "
"use the I<cap_user_time> and I<cap_user_rdpmc> fields instead."
msgstr ""
"Начиная с Linux 3.12, они были переименованы в I<cap_bit0> и вместо них вы "
"должны использовать поля I<cap_user_time> и I<cap_user_rdpmc>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1588
#, no-wrap
msgid "I<cap_bit0_is_deprecated> (since Linux 3.12)"
msgstr "I<cap_bit0_is_deprecated> (начиная с Linux 3.12)"

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1597
msgid ""
"If set, this bit indicates that the kernel supports the properly separated "
"I<cap_user_time> and I<cap_user_rdpmc> bits."
msgstr ""
"Если установлен, то этот бит показывает, что ядро поддерживает правильно "
"разделённые биты I<cap_user_time> и I<cap_user_rdpmc>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1604
msgid ""
"If not-set, it indicates an older kernel where I<cap_usr_time> and "
"I<cap_usr_rdpmc> map to the same bit and thus both features should be used "
"with caution."
msgstr ""
"Если не установлен, то это означает используется старое ядро, в котором "
"I<cap_usr_time> и I<cap_usr_rdpmc> отражают один и тот же бит, и оба "
"свойства нужно использовать с осторожностью."

#. type: TP
#: man-pages/man2/perf_event_open.2:1604
#, no-wrap
msgid "I<cap_user_rdpmc> (since Linux 3.12)"
msgstr "I<cap_user_rdpmc> (начиная с Linux 3.12)"

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1610
msgid ""
"If the hardware supports user-space read of performance counters without "
"syscall (this is the \"rdpmc\" instruction on x86), then the following code "
"can be used to do a read:"
msgstr ""
"Если есть аппаратная поддержка чтения счётчиков производительности из "
"пользовательского пространства без системного вызова (инструкция «rdpmc» в "
"x86), то для чтения можно использовать следующий код:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1616
#, no-wrap
msgid ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"
msgstr ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1622
#, no-wrap
msgid ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"
msgstr ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1629
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"
msgstr ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1632
#, no-wrap
msgid ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"
msgstr ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1637
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        count += rdpmc(idx - 1);\n"
"    }\n"
msgstr ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        count += rdpmc(idx - 1);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1640
#, no-wrap
msgid ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"
msgstr ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1642
#, no-wrap
msgid "I<cap_user_time> (since Linux 3.12)"
msgstr "I<cap_user_time> (начиная с Linux 3.12)"

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1647
msgid ""
"This bit indicates the hardware has a constant, nonstop timestamp counter "
"(TSC on x86)."
msgstr ""
"Этот бит указывает на наличие аппаратного, неизменяемого, неостанавливаемого "
"счётчика временных меток (TSC на x86)."

#. type: TP
#: man-pages/man2/perf_event_open.2:1647
#, no-wrap
msgid "I<cap_user_time_zero> (since Linux 3.12)"
msgstr "I<cap_user_time_zero> (начиная с Linux 3.12)"

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1654
msgid ""
"Indicates the presence of I<time_zero> which allows mapping timestamp values "
"to the hardware clock."
msgstr ""
"Указывает на наличие I<time_zero>, который позволяет отображать значения "
"временных меток в аппаратные часы."

#. type: TP
#: man-pages/man2/perf_event_open.2:1654
#, no-wrap
msgid "I<pmc_width>"
msgstr "I<pmc_width>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1661
msgid ""
"If I<cap_usr_rdpmc>, this field provides the bit-width of the value read "
"using the rdpmc or equivalent instruction.  This can be used to sign extend "
"the result like:"
msgstr ""
"Если установлен I<cap_usr_rdpmc>, то это поле предоставляет ширину (в битах) "
"значения, считываемого с помощью rdpmc или эквивалентной инструкции. Может "
"использоваться для расширения знаком:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1667
#, no-wrap
msgid ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // signed shift right\n"
"count += pmc;\n"
msgstr ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // сдвиг знака вправо\n"
"count += pmc;\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1669
#, no-wrap
msgid "I<time_shift>, I<time_mult>, I<time_offset>"
msgstr "I<time_shift>, I<time_mult>, I<time_offset>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1678
msgid ""
"If I<cap_usr_time>, these fields can be used to compute the time delta since "
"I<time_enabled> (in nanoseconds) using rdtsc or similar."
msgstr ""
"Если установлен I<cap_usr_time>, то эти поля можно использоваться для "
"вычисления разницы времени, начиная с I<time_enabled> (в наносекундах) с "
"помощью rdtsc или подобной инструкции."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1686
#, no-wrap
msgid ""
"    u64 quot, rem;\n"
"    u64 delta;\n"
"    quot = (cyc E<gt>E<gt> time_shift);\n"
"    rem = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"    delta = time_offset + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""
"    u64 quot, rem;\n"
"    u64 delta;\n"
"    quot = (cyc E<gt>E<gt> time_shift);\n"
"    rem = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"    delta = time_offset + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1698
msgid ""
"Where I<time_offset>, I<time_mult>, I<time_shift>, and I<cyc> are read in "
"the seqcount loop described above.  This delta can then be added to enabled "
"and possible running (if idx), improving the scaling:"
msgstr ""
"Где I<time_offset>, I<time_mult>, I<time_shift> и I<cyc> читаются в цикле "
"seqcount, описанном выше. Затем эта разница может быть добавлена для "
"включения и, возможно, запуска (если idx) для улучшения масштабирования:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1706
#, no-wrap
msgid ""
"    enabled += delta;\n"
"    if (idx)\n"
"        running += delta;\n"
"    quot = count / running;\n"
"    rem  = count % running;\n"
"    count = quot * enabled + (rem * enabled) / running;\n"
msgstr ""
"    enabled += delta;\n"
"    if (idx)\n"
"        running += delta;\n"
"    quot = count / running;\n"
"    rem  = count % running;\n"
"    count = quot * enabled + (rem * enabled) / running;\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1707
#, no-wrap
msgid "I<time_zero> (since Linux 3.12)"
msgstr "I<time_zero> (начиная с Linux 3.12)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1716
msgid ""
"If I<cap_usr_time_zero> is set, then the hardware clock (the TSC timestamp "
"counter on x86)  can be calculated from the I<time_zero>, I<time_mult>, and "
"I<time_shift> values:"
msgstr ""
"Если установлен I<cap_usr_time_zero>, то аппаратные часы (счётчик временных "
"меток TSC на x86) могут быть вычислены из значений I<time_zero>, "
"I<time_mult> и I<time_shift>:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1722
#, no-wrap
msgid ""
"    time = timestamp - time_zero;\n"
"    quot = time / time_mult;\n"
"    rem  = time % time_mult;\n"
"    cyc = (quot E<lt>E<lt> time_shift) + (rem E<lt>E<lt> time_shift) / time_mult;\n"
msgstr ""
"    time = timestamp - time_zero;\n"
"    quot = time / time_mult;\n"
"    rem  = time % time_mult;\n"
"    cyc = (quot E<lt>E<lt> time_shift) + (rem E<lt>E<lt> time_shift) / time_mult;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1725
msgid "And vice versa:"
msgstr "И наоборот:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1731
#, no-wrap
msgid ""
"    quot = cyc E<gt>E<gt> time_shift;\n"
"    rem  = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"    timestamp = time_zero + quot * time_mult +\n"
"        ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""
"    quot = cyc E<gt>E<gt> time_shift;\n"
"    rem  = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"    timestamp = time_zero + quot * time_mult +\n"
"        ((rem * time_mult) E<gt>E<gt> time_shift);\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1732
#, no-wrap
msgid "I<data_head>"
msgstr "I<data_head>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1738
msgid ""
"This points to the head of the data section.  The value continuously "
"increases, it does not wrap.  The value needs to be manually wrapped by the "
"size of the mmap buffer before accessing the samples."
msgstr ""
"Указывает на начало секции данных. Значение непрерывно увеличивается, но не "
"возвращается в начало. Перед доступом к образцам его нужно возвращать в "
"начало вручную — на размер буфера mmap."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1743
msgid ""
"On SMP-capable platforms, after reading the I<data_head> value, user space "
"should issue an rmb()."
msgstr ""
"На платформах с SMP после чтения значения I<data_head> из пользовательского "
"пространства нужно вызвать функцию rmb()."

#. type: TP
#: man-pages/man2/perf_event_open.2:1743
#, no-wrap
msgid "I<data_tail>"
msgstr "I<data_tail>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1751
msgid ""
"When the mapping is B<PROT_WRITE>, the I<data_tail> value should be written "
"by user space to reflect the last read data.  In this case, the kernel will "
"not overwrite unread data."
msgstr ""
"Если отображение B<PROT_WRITE>, то значение I<data_tail> будет записываться "
"из пользовательского пространства для отражения последних прочитанных "
"данных. В этом случае ядро не перезаписывает непрочитанные данные."

#. type: TP
#: man-pages/man2/perf_event_open.2:1751
#, no-wrap
msgid "I<data_offset> (since Linux 4.1)"
msgstr "I<data_offset> (начиная с Linux 4.1)"

#.  commit e8c6deac69629c0cb97c3d3272f8631ef17f8f0f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1756
msgid ""
"Contains the offset of the location in the mmap buffer where perf sample "
"data begins."
msgstr ""
"Содержит смещение расположения начала данных образца perf в буфере mmap."

#. type: TP
#: man-pages/man2/perf_event_open.2:1756
#, no-wrap
msgid "I<data_size> (since Linux 4.1)"
msgstr "I<data_size> (начиная с Linux 4.1)"

#.  commit e8c6deac69629c0cb97c3d3272f8631ef17f8f0f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1761
msgid "Contains the size of the perf sample region within the mmap buffer."
msgstr "Содержит размер области образца perf в буфере mmap."

#. type: TP
#: man-pages/man2/perf_event_open.2:1761
#, no-wrap
msgid "I<aux_head>, I<aux_tail>, I<aux_offset>, I<aux_size> (since Linux 4.1)"
msgstr "I<aux_head>, I<aux_tail>, I<aux_offset>, I<aux_size> (начиная с Linux 4.1)"

#.  commit 45bfb2e50471abbbfd83d40d28c986078b0d24ff
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1768
msgid ""
"The AUX region allows mmaping a separate sample buffer for high-bandwidth "
"data streams (separate from the main perf sample buffer).  An example of a "
"high-bandwidth stream is instruction tracing support, as is found in newer "
"Intel processors."
msgstr ""
"Область AUX позволяет отобразить отдельный буфер образцов для "
"высокоскоростных потоков данных (отдельный от основного буфера образцов "
"perf). Примером высокоскоростного потока может быть поддержка трассировки "
"инструкций, имеющаяся в новых процессорах Intel."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1786
msgid ""
"To set up an AUX area, first I<aux_offset> needs to be set with an offset "
"greater than I<data_offset>+I<data_size> and I<aux_size> needs to be set to "
"the desired buffer size.  The desired offset and size must be page aligned, "
"and the size must be a power of two.  These values are then passed to mmap "
"in order to map the AUX buffer.  Pages in the AUX buffer are included as "
"part of the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2)), and also "
"as part of the I<perf_event_mlock_kb> allowance."
msgstr ""
"Для задания области AUX, сначала задайте I<aux_offset> со смещением больше "
"чем I<data_offset>+I<data_size>, а в I<aux_size> нужно указать желаемых "
"размер буфера. Желаемое смещение и размер должны быть выровнены по границе "
"страницы, и размер должен быть степенью двойки. Затем эти значения "
"передаются в mmap для отображения буфера AUX. Страницы буфера AUX "
"учитываются в ограничении ресурса B<RLIMIT_MEMLOCK> (смотрите "
"B<setrlimit>(2)), а также проходят допустимость I<perf_event_mlock_kb>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1795
msgid ""
"By default, the AUX buffer will be truncated if it will not fit in the "
"available space in the ring buffer.  If the AUX buffer is mapped as a read "
"only buffer, then it will operate in ring buffer mode where old data will be "
"overwritten by new.  In overwrite mode, it might not be possible to infer "
"where the new data began, and it is the consumer's job to disable "
"measurement while reading to avoid possible data races."
msgstr ""
"По умолчанию буфер AUX будет обрезан, если он не вмещается в доступное "
"пространство кольцевого буфера. Если буфер AUX отображается только для "
"чтения, то он будет работать в режиме кольцевого буфера, где старые данные "
"перезаписываются новыми. В режиме перезаписи нельзя угадать место начала "
"новых данных, и задачей потребителя становится отключение измерения для "
"избежания возможной состязательности по данным."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1801
msgid ""
"The I<aux_head> and I<aux_tail> ring buffer pointers have the same behavior "
"and ordering rules as the previous described I<data_head> and I<data_tail>."
msgstr ""
"Указатели кольцевого буфера I<aux_head> и I<aux_tail> работают и подчиняются "
"тем же правилам, которые описаны выше для I<data_head> и I<data_tail>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1803
msgid "The following 2^n ring-buffer pages have the layout described below."
msgstr "Далее приводится раскладка страниц кольцевого буфера размером 2^n."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1817
msgid ""
"If I<perf_event_attr.sample_id_all> is set, then all event types will have "
"the sample_type selected fields related to where/when (identity)  an event "
"took place (TID, TIME, ID, CPU, STREAM_ID) described in "
"B<PERF_RECORD_SAMPLE> below, it will be stashed just after the "
"I<perf_event_header> and the fields already present for the existing fields, "
"that is, at the end of the payload.  This allows a newer perf.data file to "
"be supported by older perf tools, with the new optional fields being ignored."
msgstr ""
"Если установлен I<perf_event_attr.sample_id_all>, то все типы событий будут "
"иметь выбранные поля sample_type, относящиеся к где/когда (отличительность) "
"происходило событие (TID, TIME, ID, CPU, STREAM_ID), описанные в "
"B<PERF_RECORD_SAMPLE> ниже; они будут спрятаны за I<perf_event_header> и уже "
"имеющимися полями, то есть в записываться в конец полезных данных. Это "
"позволяет читать новый файл perf.data старыми инструментами perf, игнорируя "
"новые необязательные поля."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1819
msgid "The mmap values start with a header:"
msgstr "Значения mmap начинаются с заголовка:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1827
#, no-wrap
msgid ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"
msgstr ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1835
msgid ""
"Below, we describe the I<perf_event_header> fields in more detail.  For ease "
"of reading, the fields with shorter descriptions are presented first."
msgstr ""
"Далее мы опишем поля I<perf_event_header> более подробно. Для простоты поля "
"с короткими описаниями показаны первыми."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1838
msgid "This indicates the size of the record."
msgstr "Показывает размер записи."

#. type: TP
#: man-pages/man2/perf_event_open.2:1838
#, no-wrap
msgid "I<misc>"
msgstr "I<misc>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1843
msgid "The I<misc> field contains additional information about the sample."
msgstr "В поле I<misc> содержится дополнительная информация об образце."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1848
msgid ""
"The CPU mode can be determined from this value by masking with "
"B<PERF_RECORD_MISC_CPUMODE_MASK> and looking for one of the following (note "
"these are not bit masks, only one can be set at a time):"
msgstr ""
"По этому значению можно определить режим ЦП, наложив на него маску "
"B<PERF_RECORD_MISC_CPUMODE_MASK> и  одно из следующих значений (заметим, что "
"это не битовые маски, можно указывать только одно значение за раз):"

#. type: TP
#: man-pages/man2/perf_event_open.2:1849
#, no-wrap
msgid "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"
msgstr "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1852
msgid "Unknown CPU mode."
msgstr "Неизвестный режим ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:1852
#, no-wrap
msgid "B<PERF_RECORD_MISC_KERNEL>"
msgstr "B<PERF_RECORD_MISC_KERNEL>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1855
msgid "Sample happened in the kernel."
msgstr "Образец возник в ядре."

#. type: TP
#: man-pages/man2/perf_event_open.2:1855
#, no-wrap
msgid "B<PERF_RECORD_MISC_USER>"
msgstr "B<PERF_RECORD_MISC_USER>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1858
msgid "Sample happened in user code."
msgstr "Образец возник в пользовательском коде."

#. type: TP
#: man-pages/man2/perf_event_open.2:1858
#, no-wrap
msgid "B<PERF_RECORD_MISC_HYPERVISOR>"
msgstr "B<PERF_RECORD_MISC_HYPERVISOR>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1861
msgid "Sample happened in the hypervisor."
msgstr "Образец возник в гипервизоре."

#. type: TP
#: man-pages/man2/perf_event_open.2:1861
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_KERNEL> (since Linux 2.6.35)"
msgstr "B<PERF_RECORD_MISC_GUEST_KERNEL> (начиная с Linux 2.6.35)"

#.  commit 39447b386c846bbf1c56f6403c5282837486200f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1865
msgid "Sample happened in the guest kernel."
msgstr "Образец возник в гостевом ядре."

#. type: TP
#: man-pages/man2/perf_event_open.2:1865
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_USER  (since Linux 2.6.35)>"
msgstr "B<PERF_RECORD_MISC_GUEST_USER  (начиная с Linux 2.6.35)>"

#.  commit 39447b386c846bbf1c56f6403c5282837486200f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1869
msgid "Sample happened in guest user code."
msgstr "Образец возник в гостевом пользовательском коде."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1874
msgid ""
"Since the following three statuses are generated by different record types, "
"they alias to the same bit:"
msgstr ""
"Так как следующие три состояния сгенерированы различными типами записей, то "
"они указывают на один и тот же бит:"

#. type: TP
#: man-pages/man2/perf_event_open.2:1874
#, no-wrap
msgid "B<PERF_RECORD_MISC_MMAP_DATA> (since Linux 3.10)"
msgstr "B<PERF_RECORD_MISC_MMAP_DATA> (начиная с Linux 3.10)"

#.  commit 2fe85427e3bf65d791700d065132772fc26e4d75
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1879
msgid ""
"This is set when the mapping is not executable; otherwise the mapping is "
"executable."
msgstr ""
"Устанавливается, когда отображение не выполняемое; в противном случае "
"отображение выполняемое."

#. type: TP
#: man-pages/man2/perf_event_open.2:1879
#, no-wrap
msgid "B<PERF_RECORD_MISC_COMM_EXEC> (since Linux 3.16)"
msgstr "B<PERF_RECORD_MISC_COMM_EXEC> (начиная с Linux 3.16)"

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1888
msgid ""
"This is set for a B<PERF_RECORD_COMM> record on kernels more recent than "
"Linux 3.16 if a process name change was caused by an B<exec>(2)  system call."
msgstr ""
"Устанавливается для записи B<PERF_RECORD_COMM> в ядрах новее версии Linux "
"3.16, если имя процесса изменено системным вызовом B<exec>(2)."

#. type: TP
#: man-pages/man2/perf_event_open.2:1888
#, no-wrap
msgid "B<PERF_RECORD_MISC_SWITCH_OUT> (since Linux 4.3)"
msgstr "B<PERF_RECORD_MISC_SWITCH_OUT> (начиная с Linux 4.3)"

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1898
msgid ""
"When a B<PERF_RECORD_SWITCH> or B<PERF_RECORD_SWITCH_CPU_WIDE> record is "
"generated, this bit indicates that the context switch is away from the "
"current process (instead of into the current process)."
msgstr ""
"При генерации записи B<PERF_RECORD_SWITCH> или "
"B<PERF_RECORD_SWITCH_CPU_WIDE> этот бит показывает, что переключение "
"контекста происходило из текущего процесса (а не в текущий процесс)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1902
msgid "In addition, the following bits can be set:"
msgstr "Также могут устанавливаться следующие биты:"

#. type: TP
#: man-pages/man2/perf_event_open.2:1902
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXACT_IP>"
msgstr "B<PERF_RECORD_MISC_EXACT_IP>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1910
msgid ""
"This indicates that the content of B<PERF_SAMPLE_IP> points to the actual "
"instruction that triggered the event.  See also I<perf_event_attr."
"precise_ip>."
msgstr ""
"Показывает, что содержимое B<PERF_SAMPLE_IP> указывает на актуальную "
"инструкцию, из-за которой произошло событие. Смотрите также "
"I<perf_event_attr.precise_ip>."

#. type: TP
#: man-pages/man2/perf_event_open.2:1910
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXT_RESERVED> (since Linux 2.6.35)"
msgstr "B<PERF_RECORD_MISC_EXT_RESERVED> (начиная с Linux 2.6.35)"

#.  commit 1676b8a077c352085d52578fb4f29350b58b6e74
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1914
msgid "This indicates there is extended data available (currently not used)."
msgstr "Показывает, что доступны расширенные данные (пока не используется)."

#. type: TP
#: man-pages/man2/perf_event_open.2:1914
#, no-wrap
msgid "B<PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT>"
msgstr "B<PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT>"

#.  commit 930e6fcd2bcce9bcd9d4aa7e755678d33f3fe6f4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1922
msgid ""
"This bit is not set by the kernel.  It is reserved for the user-space perf "
"utility to indicate that I</proc/i[pid]/maps> parsing was taking too long "
"and was stopped, and thus the mmap records may be truncated."
msgstr ""
"Данный бит не устанавливается ядром. Он зарезервирован для утилиты "
"пользовательского пространства perf и показывает, что разбор I</proc/i[pid]/"
"maps> выполнялся слишком долго и был остановлен, и поэтому записи mmap могут "
"быть обрезанными."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1932
msgid ""
"The I<type> value is one of the below.  The values in the corresponding "
"record (that follows the header)  depend on the I<type> selected as shown."
msgstr ""
"Значение I<type> — одно из представленных ниже. Значения в соответствующей "
"записи (следующие за заголовком) зависят от выбранного I<type> как описано."

#. type: TP
#: man-pages/man2/perf_event_open.2:1933
#, no-wrap
msgid "B<PERF_RECORD_MMAP>"
msgstr "B<PERF_RECORD_MMAP>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1940
msgid ""
"The MMAP events record the B<PROT_EXEC> mappings so that we can correlate "
"user-space IPs to code.  They have the following structure:"
msgstr ""
"События MMAP записывают отображения B<PROT_EXEC> так, чтобы можно было "
"соотнести IP пользовательского пространства с кодом. Они имеют следующую "
"структуру:"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1951
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:1954 man-pages/man2/perf_event_open.2:2008
#: man-pages/man2/perf_event_open.2:2566 man-pages/man2/perf_event_open.2:2656
#, no-wrap
msgid "I<pid>"
msgstr "I<pid>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1957 man-pages/man2/perf_event_open.2:2011
#: man-pages/man2/perf_event_open.2:2569
msgid "is the process ID."
msgstr "идентификатор процесса."

#. type: TP
#: man-pages/man2/perf_event_open.2:1957 man-pages/man2/perf_event_open.2:2011
#: man-pages/man2/perf_event_open.2:2569 man-pages/man2/perf_event_open.2:2659
#, no-wrap
msgid "I<tid>"
msgstr "I<tid>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1960 man-pages/man2/perf_event_open.2:2014
#: man-pages/man2/perf_event_open.2:2572
msgid "is the thread ID."
msgstr "идентификатор нити."

#. type: TP
#: man-pages/man2/perf_event_open.2:1960 man-pages/man2/perf_event_open.2:2149
#: man-pages/man2/perf_event_open.2:2572
#, no-wrap
msgid "I<addr>"
msgstr "I<addr>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1969
msgid ""
"is the address of the allocated memory.  I<len> is the length of the "
"allocated memory.  I<pgoff> is the page offset of the allocated memory.  "
"I<filename> is a string describing the backing of the allocated memory."
msgstr ""
"адрес выделенной памяти. В I<len> указывается длина выделенной памяти. В "
"I<pgoff> указывается смещение страницы выделенной памяти. В I<filename> "
"указывается строка, описывающая выделенную память."

#. type: TP
#: man-pages/man2/perf_event_open.2:1970
#, no-wrap
msgid "B<PERF_RECORD_LOST>"
msgstr "B<PERF_RECORD_LOST>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1973
msgid "This record indicates when events are lost."
msgstr "Эта запись указывает на потерю событий."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1982
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    id;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    id;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1988
msgid "is the unique event ID for the samples that were lost."
msgstr "уникальный ID события утерянных образцов."

#. type: TP
#: man-pages/man2/perf_event_open.2:1988 man-pages/man2/perf_event_open.2:2678
#, no-wrap
msgid "I<lost>"
msgstr "I<lost>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1991
msgid "is the number of events that were lost."
msgstr "количество потерянных событий."

#. type: TP
#: man-pages/man2/perf_event_open.2:1992
#, no-wrap
msgid "B<PERF_RECORD_COMM>"
msgstr "B<PERF_RECORD_COMM>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1995
msgid "This record indicates a change in the process name."
msgstr "Эта запись указывает на изменение имени процесса."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2005
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    char   comm[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    char   comm[];\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2017
msgid "is a string containing the new name of the process."
msgstr "строка, содержащая новое имя процесса."

#. type: TP
#: man-pages/man2/perf_event_open.2:2018
#, no-wrap
msgid "B<PERF_RECORD_EXIT>"
msgstr "B<PERF_RECORD_EXIT>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2021
msgid "This record indicates a process exit event."
msgstr "Эта запись указывает на событие выхода процесса."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2031 man-pages/man2/perf_event_open.2:2061
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, ppid;\n"
"    u32    tid, ptid;\n"
"    u64    time;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, ppid;\n"
"    u32    tid, ptid;\n"
"    u64    time;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2033
#, no-wrap
msgid "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"
msgstr "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2036
msgid "This record indicates a throttle/unthrottle event."
msgstr ""
"Эта запись указывает на событие включения/выключения регулировки (throttle)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2046
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    time;\n"
"    u64    id;\n"
"    u64    stream_id;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    time;\n"
"    u64    id;\n"
"    u64    stream_id;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2048
#, no-wrap
msgid "B<PERF_RECORD_FORK>"
msgstr "B<PERF_RECORD_FORK>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2051
msgid "This record indicates a fork event."
msgstr "Эта запись указывает на событие порождения (fork) процесса."

#. type: TP
#: man-pages/man2/perf_event_open.2:2063
#, no-wrap
msgid "B<PERF_RECORD_READ>"
msgstr "B<PERF_RECORD_READ>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2066
msgid "This record indicates a read event."
msgstr "Эта запись указывает на событие чтения."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2075
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    struct read_format values;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    struct read_format values;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2077
#, no-wrap
msgid "B<PERF_RECORD_SAMPLE>"
msgstr "B<PERF_RECORD_SAMPLE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2080
msgid "This record indicates a sample."
msgstr "Эта запись указывает на образец."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2117
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */\n"
"    u64    ip;          /* if PERF_SAMPLE_IP */\n"
"    u32    pid, tid;    /* if PERF_SAMPLE_TID */\n"
"    u64    time;        /* if PERF_SAMPLE_TIME */\n"
"    u64    addr;        /* if PERF_SAMPLE_ADDR */\n"
"    u64    id;          /* if PERF_SAMPLE_ID */\n"
"    u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */\n"
"    u32    cpu, res;    /* if PERF_SAMPLE_CPU */\n"
"    u64    period;      /* if PERF_SAMPLE_PERIOD */\n"
"    struct read_format v;\n"
"                        /* if PERF_SAMPLE_READ */\n"
"    u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u32    size;        /* if PERF_SAMPLE_RAW */\n"
"    char  data[size];   /* if PERF_SAMPLE_RAW */\n"
"    u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                        /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    u64    abi;         /* if PERF_SAMPLE_REGS_USER */\n"
"    u64    regs[weight(mask)];\n"
"                        /* if PERF_SAMPLE_REGS_USER */\n"
"    u64    size;        /* if PERF_SAMPLE_STACK_USER */\n"
"    char   data[size];  /* if PERF_SAMPLE_STACK_USER */\n"
"    u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &&\n"
"                           size != 0 */\n"
"    u64    weight;      /* if PERF_SAMPLE_WEIGHT */\n"
"    u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */\n"
"    u64    transaction; /* if PERF_SAMPLE_TRANSACTION */\n"
"    u64    abi;         /* if PERF_SAMPLE_REGS_INTR */\n"
"    u64    regs[weight(mask)];\n"
"                        /* if PERF_SAMPLE_REGS_INTR */\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    sample_id;       /* для PERF_SAMPLE_IDENTIFIER */\n"
"    u64    ip;              /* для PERF_SAMPLE_IP */\n"
"    u32    pid, tid;        /* для PERF_SAMPLE_TID */\n"
"    u64    time;            /* для PERF_SAMPLE_TIME */\n"
"    u64    addr;            /* для PERF_SAMPLE_ADDR */\n"
"    u64    id;              /* для PERF_SAMPLE_ID */\n"
"    u64    stream_id;       /* для PERF_SAMPLE_STREAM_ID */\n"
"    u32    cpu, res;        /* для PERF_SAMPLE_CPU */\n"
"    u64    period;          /* для PERF_SAMPLE_PERIOD */\n"
"    struct read_format v;   /* для PERF_SAMPLE_READ */\n"
"    u64    nr;              /* для PERF_SAMPLE_CALLCHAIN */\n"
"    u64    ips[nr];         /* для PERF_SAMPLE_CALLCHAIN */\n"
"    u32    size;            /* для PERF_SAMPLE_RAW */\n"
"    char  data[size];       /* для PERF_SAMPLE_RAW */\n"
"    u64    bnr;             /* для PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                            /* для PERF_SAMPLE_BRANCH_STACK */\n"
"    u64    abi;             /* для PERF_SAMPLE_REGS_USER */\n"
"    u64    regs[weight(mask)];\n"
"                            /* для PERF_SAMPLE_REGS_USER */\n"
"    u64    size;            /* для PERF_SAMPLE_STACK_USER */\n"
"    char   data[size];      /* для PERF_SAMPLE_STACK_USER */\n"
"    u64    dyn_size;        /* для PERF_SAMPLE_STACK_USER &&\n"
"                               size != 0 */\n"
"    u64    weight;          /* для PERF_SAMPLE_WEIGHT */\n"
"    u64    data_src;        /* для PERF_SAMPLE_DATA_SRC */\n"
"    u64    transaction;     /* для PERF_SAMPLE_TRANSACTION */\n"
"    u64    abi;             /* для PERF_SAMPLE_REGS_INTR */\n"
"    u64    regs[weight(mask)];\n"
"                            /* для PERF_SAMPLE_REGS_INTR */\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2119
#, no-wrap
msgid "I<sample_id>"
msgstr "I<sample_id>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2129
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is enabled, a 64-bit unique ID is included.  "
"This is a duplication of the B<PERF_SAMPLE_ID> I<id> value, but included at "
"the beginning of the sample so parsers can easily obtain the value."
msgstr ""
"Если включён B<PERF_SAMPLE_IDENTIFIER>, то добавляется уникальный 64-битный "
"идентификатор. Это дубль значения I<id> при B<PERF_SAMPLE_ID>, но "
"добавляется в начало образца, для простоты получения значения анализаторами."

#. type: TP
#: man-pages/man2/perf_event_open.2:2129
#, no-wrap
msgid "I<ip>"
msgstr "I<ip>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2135
msgid ""
"If B<PERF_SAMPLE_IP> is enabled, then a 64-bit instruction pointer value is "
"included."
msgstr ""
"Если включён B<PERF_SAMPLE_IP>, то добавляется значение 64-битного указателя "
"инструкции."

#. type: TP
#: man-pages/man2/perf_event_open.2:2135
#, no-wrap
msgid "I<pid>, I<tid>"
msgstr "I<pid>, I<tid>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2141
msgid ""
"If B<PERF_SAMPLE_TID> is enabled, then a 32-bit process ID and 32-bit thread "
"ID are included."
msgstr ""
"Если включён B<PERF_SAMPLE_TID>, то добавляется 32-битный идентификатор "
"процесс и 32-битный идентификатор нити."

#. type: TP
#: man-pages/man2/perf_event_open.2:2141
#, no-wrap
msgid "I<time>"
msgstr "I<time>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2149
msgid ""
"If B<PERF_SAMPLE_TIME> is enabled, then a 64-bit timestamp is included.  "
"This is obtained via local_clock() which is a hardware timestamp if "
"available and the jiffies value if not."
msgstr ""
"Если включён B<PERF_SAMPLE_TIME>, то добавляется 64-битная метка времени. "
"Она получается из local_clock(), которая возвращает, если возможно, "
"аппаратную метку времени или количество мигов, если нет."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2156
msgid ""
"If B<PERF_SAMPLE_ADDR> is enabled, then a 64-bit address is included.  This "
"is usually the address of a tracepoint, breakpoint, or software event; "
"otherwise the value is 0."
msgstr ""
"Если включён B<PERF_SAMPLE_ADDR>, то добавляется 64-битный адрес. Обычно, "
"это адрес точки трассировки, останова или программного события; в противном "
"случае 0."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2164
msgid ""
"If B<PERF_SAMPLE_ID> is enabled, a 64-bit unique ID is included.  If the "
"event is a member of an event group, the group leader ID is returned.  This "
"ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""
"Если включён B<PERF_SAMPLE_ID>, то добавляется 64-битный уникальный "
"идентификатор. Если события является членом группы событий, то возвращается "
"идентификатор лидера группы. Этот идентификатор одинаков со значением, "
"возвращаемым при B<PERF_FORMAT_ID>."

#. type: TP
#: man-pages/man2/perf_event_open.2:2164
#, no-wrap
msgid "I<stream_id>"
msgstr "I<stream_id>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2174
msgid ""
"If B<PERF_SAMPLE_STREAM_ID> is enabled, a 64-bit unique ID is included.  "
"Unlike B<PERF_SAMPLE_ID> the actual ID is returned, not the group leader.  "
"This ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""
"Если включён B<PERF_SAMPLE_STREAM_ID>, то добавляется 64-битный уникальный "
"идентификатор. В отличии от B<PERF_SAMPLE_ID> возвращается реальный "
"идентификатор, а не лидера группы. Этот же идентификатор возвращается при "
"B<PERF_FORMAT_ID>."

#. type: TP
#: man-pages/man2/perf_event_open.2:2174
#, no-wrap
msgid "I<cpu>, I<res>"
msgstr "I<cpu>, I<res>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2181
msgid ""
"If B<PERF_SAMPLE_CPU> is enabled, this is a 32-bit value indicating which "
"CPU was being used, in addition to a reserved (unused)  32-bit value."
msgstr ""
"Если включён B<PERF_SAMPLE_CPU>, здесь хранится 32-битное значение, "
"показывающее, какой использовался ЦП, а также зарезервированное "
"(неиспользуемое) 32-битное значение."

#. type: TP
#: man-pages/man2/perf_event_open.2:2181
#, no-wrap
msgid "I<period>"
msgstr "I<period>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2187
msgid ""
"If B<PERF_SAMPLE_PERIOD> is enabled, a 64-bit value indicating the current "
"sampling period is written."
msgstr ""
"Если включён B<PERF_SAMPLE_PERIOD>, то записывается 64-битное значение, "
"отражающее период выборки."

#. type: TP
#: man-pages/man2/perf_event_open.2:2187
#, no-wrap
msgid "I<v>"
msgstr "I<v>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2198
msgid ""
"If B<PERF_SAMPLE_READ> is enabled, a structure of type read_format is "
"included which has values for all events in the event group.  The values "
"included depend on the I<read_format> value used at B<perf_event_open>()  "
"time."
msgstr ""
"Если включён B<PERF_SAMPLE_READ>, то добавляется структура read_format, "
"которая содержит значения для всех событий группы событий. Добавляемые "
"значения зависят от значения I<read_format>, использованного во время "
"B<perf_event_open>()."

#. type: TP
#: man-pages/man2/perf_event_open.2:2198
#, no-wrap
msgid "I<nr>, I<ips[nr]>"
msgstr "I<nr>, I<ips[nr]>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2206
msgid ""
"If B<PERF_SAMPLE_CALLCHAIN> is enabled, then a 64-bit number is included "
"which indicates how many following 64-bit instruction pointers will follow.  "
"This is the current callchain."
msgstr ""
"Если включён B<PERF_SAMPLE_CALLCHAIN>, то добавляется 64-битный номер, "
"показывающий сколько далее следует 64-битных указателей инструкций. Это "
"относится к текущей цепочке вызовов."

#. type: TP
#: man-pages/man2/perf_event_open.2:2206
#, no-wrap
msgid "I<size>, I<data[size]>"
msgstr "I<size>, I<data[size]>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2213
msgid ""
"If B<PERF_SAMPLE_RAW> is enabled, then a 32-bit value indicating size is "
"included followed by an array of 8-bit values of length size.  The values "
"are padded with 0 to have 64-bit alignment."
msgstr ""
"Если включён B<PERF_SAMPLE_RAW>, то добавляется 32-битное значение, "
"показывающее размер размещённого далее массива 8-битных значений. Значения "
"дополняются нулями до 64-битного."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2218
msgid ""
"This RAW record data is opaque with respect to the ABI.  The ABI doesn't "
"make any promises with respect to the stability of its content, it may vary "
"depending on event, hardware, and kernel version."
msgstr ""
"Это неструктурированные записи с данными, скрытыми программным интерфейсом. "
"Не гарантируется неизменность их структуры в будущем, она может зависеть от "
"события, аппаратного обеспечения и версии ядра."

#. type: TP
#: man-pages/man2/perf_event_open.2:2218
#, no-wrap
msgid "I<bnr>, I<lbr[bnr]>"
msgstr "I<bnr>, I<lbr[bnr]>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2227
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then a 64-bit value indicating "
"the number of records is included, followed by I<bnr> I<perf_branch_entry> "
"structures which each include the fields:"
msgstr ""
"Если включён B<PERF_SAMPLE_BRANCH_STACK>, то добавляется 64-битное значение, "
"показывающее количество записей, следующих за структурами I<bnr> "
"I<perf_branch_entry>, каждая из которых содержит следующие поля:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2228
#, no-wrap
msgid "I<from>"
msgstr "I<from>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2231
msgid "This indicates the source instruction (may not be a branch)."
msgstr "Источник инструкции (может быть не ветвление)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2231
#, no-wrap
msgid "I<to>"
msgstr "I<to>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2234
msgid "The branch target."
msgstr "Цель ветвления."

#. type: TP
#: man-pages/man2/perf_event_open.2:2234
#, no-wrap
msgid "I<mispred>"
msgstr "I<mispred>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2237
msgid "The branch target was mispredicted."
msgstr "Цель ветвления предсказана ошибочно."

#. type: TP
#: man-pages/man2/perf_event_open.2:2237
#, no-wrap
msgid "I<predicted>"
msgstr "I<predicted>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2240
msgid "The branch target was predicted."
msgstr "Цель ветвления предсказана."

#. type: TP
#: man-pages/man2/perf_event_open.2:2240
#, no-wrap
msgid "I<in_tx> (since Linux 3.11)"
msgstr "I<in_tx> (начиная с Linux 3.11)"

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2244
msgid "The branch was in a transactional memory transaction."
msgstr "Ветвление возникло в транзакции транзакционной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:2244
#, no-wrap
msgid "I<abort> (since Linux 3.11)"
msgstr "I<abort> (начиная с Linux 3.11)"

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2248
msgid "The branch was in an aborted transactional memory transaction."
msgstr "Ветвление возникло в аварийной транзакции транзакционной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:2248
#, no-wrap
msgid "I<cycles> (since Linux 4.3)"
msgstr "I<cycles> (начиная с Linux 4.3)"

#.  commit 71ef3c6b9d4665ee7afbbe4c208a98917dcfc32f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2253
msgid ""
"This reports the number of cycles elapsed since the previous branch stack "
"update."
msgstr "Количество циклов, прошедших с предыдущего обновления стека ветви."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2256
msgid ""
"The entries are from most to least recent, so the first entry has the most "
"recent branch."
msgstr ""
"Элементы располагаются от новых к старым, таким образом, первый указывает на "
"самое новое ветвление."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2264
msgid ""
"Support for I<mispred>, I<predicted>, and I<cycles> is optional; if not "
"supported, those values will be 0."
msgstr ""
"Поддержка I<mispred>, I<predicted> и I<cycles> необязательна; если "
"отсутствует, то значения будут равны 0."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2268
msgid ""
"The type of branches recorded is specified by the I<branch_sample_type> "
"field."
msgstr "Тип сохранённых ветвлений указывается в поле I<branch_sample_type>."

#. type: TP
#: man-pages/man2/perf_event_open.2:2269 man-pages/man2/perf_event_open.2:2512
#, no-wrap
msgid "I<abi>, I<regs[weight(mask)]>"
msgstr "I<abi>, I<regs[weight(mask)]>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2274
msgid ""
"If B<PERF_SAMPLE_REGS_USER> is enabled, then the user CPU registers are "
"recorded."
msgstr ""
"Если включён B<PERF_SAMPLE_REGS_USER>, то сохраняются пользовательские "
"регистры ЦП."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2280
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""
"Значением поля I<abi> может быть B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> или B<PERF_SAMPLE_REGS_ABI_64>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2290
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_user> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_user> bit mask."
msgstr ""
"В I<regs> хранится массив регистров ЦП, которые были перечислены в поле "
"I<sample_regs_user>. Количество значений определяется количеством бит, "
"установленных в битовой маске I<sample_regs_user>."

#. type: TP
#: man-pages/man2/perf_event_open.2:2290
#, no-wrap
msgid "I<size>, I<data[size]>, I<dyn_size>"
msgstr "I<size>, I<data[size]>, I<dyn_size>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2311
msgid ""
"If B<PERF_SAMPLE_STACK_USER> is enabled, then the user stack is recorded.  "
"This can be used to generate stack backtraces.  I<size> is the size "
"requested by the user in I<sample_stack_user> or else the maximum record "
"size.  I<data> is the stack data (a raw dump of the memory pointed to by the "
"stack pointer at the time of sampling).  I<dyn_size> is the amount of data "
"actually dumped (can be less than I<size>).  Note that I<dyn_size> is "
"omitted if I<size> is 0."
msgstr ""
"Если включён B<PERF_SAMPLE_STACK_USER>, то сохраняется пользовательский "
"стек. Он может использоваться для генерации стека обратных вызовов. Значение "
"I<size> — размер, запрашиваемый пользователем для I<sample_stack_user> или "
"максимальное значение записи. Значение I<data> — данные стека "
"(неструктурированная копия памяти, на которую указывает указатель стека во "
"время взятия образца). Значение I<dyn_size> — количество данных, которые "
"были записаны (может быть меньше I<size>). Заметим, что I<dyn_size> "
"пропускается, если I<size> равно 0."

#. type: TP
#: man-pages/man2/perf_event_open.2:2311
#, no-wrap
msgid "I<weight>"
msgstr "I<weight>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2319
msgid ""
"If B<PERF_SAMPLE_WEIGHT> is enabled, then a 64-bit value provided by the "
"hardware is recorded that indicates how costly the event was.  This allows "
"expensive events to stand out more clearly in profiles."
msgstr ""
"Если включён B<PERF_SAMPLE_WEIGHT>, то добавляется 64-битное аппаратное "
"значение, показывающее стоимость события. Это позволяет выделить в профилях "
"затратные события."

#. type: TP
#: man-pages/man2/perf_event_open.2:2319
#, no-wrap
msgid "I<data_src>"
msgstr "I<data_src>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2325
msgid ""
"If B<PERF_SAMPLE_DATA_SRC> is enabled, then a 64-bit value is recorded that "
"is made up of the following fields:"
msgstr ""
"Если включён B<PERF_SAMPLE_DATA_SRC>, то сохраняется 64-битное значение, "
"состоящее из следующих полей:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2326
#, no-wrap
msgid "I<mem_op>"
msgstr "I<mem_op>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2329
msgid "Type of opcode, a bitwise combination of:"
msgstr "Тип кода операции, битовая комбинация из следующих значений:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2332
#, no-wrap
msgid "B<PERF_MEM_OP_NA>"
msgstr "B<PERF_MEM_OP_NA>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2335 man-pages/man2/perf_event_open.2:2360
#: man-pages/man2/perf_event_open.2:2411 man-pages/man2/perf_event_open.2:2435
#: man-pages/man2/perf_event_open.2:2451
msgid "Not available"
msgstr "Недоступен"

#. type: TP
#: man-pages/man2/perf_event_open.2:2335
#, no-wrap
msgid "B<PERF_MEM_OP_LOAD>"
msgstr "B<PERF_MEM_OP_LOAD>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2338
msgid "Load instruction"
msgstr "Инструкция загрузки"

#. type: TP
#: man-pages/man2/perf_event_open.2:2338
#, no-wrap
msgid "B<PERF_MEM_OP_STORE>"
msgstr "B<PERF_MEM_OP_STORE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2341
msgid "Store instruction"
msgstr "Инструкция сохранения"

#. type: TP
#: man-pages/man2/perf_event_open.2:2341
#, no-wrap
msgid "B<PERF_MEM_OP_PFETCH>"
msgstr "B<PERF_MEM_OP_PFETCH>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2344
msgid "Prefetch"
msgstr "Предварительная выборка"

#. type: TP
#: man-pages/man2/perf_event_open.2:2344
#, no-wrap
msgid "B<PERF_MEM_OP_EXEC>"
msgstr "B<PERF_MEM_OP_EXEC>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2347
msgid "Executable code"
msgstr "Исполняемый код"

#. type: TP
#: man-pages/man2/perf_event_open.2:2349
#, no-wrap
msgid "I<mem_lvl>"
msgstr "I<mem_lvl>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2354
msgid ""
"Memory hierarchy level hit or miss, a bitwise combination of the following, "
"shifted left by B<PERF_MEM_LVL_SHIFT>:"
msgstr ""
"Попадание или промах по уровням иерархии памяти, побитовая комбинация "
"следующего, сдвинутого влево на B<PERF_MEM_LVL_SHIFT>:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2357
#, no-wrap
msgid "B<PERF_MEM_LVL_NA>"
msgstr "B<PERF_MEM_LVL_NA>"

#. type: TP
#: man-pages/man2/perf_event_open.2:2360
#, no-wrap
msgid "B<PERF_MEM_LVL_HIT>"
msgstr "B<PERF_MEM_LVL_HIT>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2363 man-pages/man2/perf_event_open.2:2454
msgid "Hit"
msgstr "Попадание"

#. type: TP
#: man-pages/man2/perf_event_open.2:2363
#, no-wrap
msgid "B<PERF_MEM_LVL_MISS>"
msgstr "B<PERF_MEM_LVL_MISS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2366 man-pages/man2/perf_event_open.2:2457
msgid "Miss"
msgstr "Промах"

#. type: TP
#: man-pages/man2/perf_event_open.2:2366
#, no-wrap
msgid "B<PERF_MEM_LVL_L1>"
msgstr "B<PERF_MEM_LVL_L1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2369
msgid "Level 1 cache"
msgstr "Кэш 1 уровня"

#. type: TP
#: man-pages/man2/perf_event_open.2:2369
#, no-wrap
msgid "B<PERF_MEM_LVL_LFB>"
msgstr "B<PERF_MEM_LVL_LFB>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2372
msgid "Line fill buffer"
msgstr "Построчно заполняемый буфер"

#. type: TP
#: man-pages/man2/perf_event_open.2:2372
#, no-wrap
msgid "B<PERF_MEM_LVL_L2>"
msgstr "B<PERF_MEM_LVL_L2>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2375
msgid "Level 2 cache"
msgstr "Кэш 2 уровня"

#. type: TP
#: man-pages/man2/perf_event_open.2:2375
#, no-wrap
msgid "B<PERF_MEM_LVL_L3>"
msgstr "B<PERF_MEM_LVL_L3>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2378
msgid "Level 3 cache"
msgstr "Кэш 3 уровня"

#. type: TP
#: man-pages/man2/perf_event_open.2:2378
#, no-wrap
msgid "B<PERF_MEM_LVL_LOC_RAM>"
msgstr "B<PERF_MEM_LVL_LOC_RAM>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2381
msgid "Local DRAM"
msgstr "Локальная оперативная память"

#. type: TP
#: man-pages/man2/perf_event_open.2:2381
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM1>"
msgstr "B<PERF_MEM_LVL_REM_RAM1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2384
msgid "Remote DRAM 1 hop"
msgstr "Удалённая на 1 скачок оперативная память"

#. type: TP
#: man-pages/man2/perf_event_open.2:2384
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM2>"
msgstr "B<PERF_MEM_LVL_REM_RAM2>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2387
msgid "Remote DRAM 2 hops"
msgstr "Удалённая на 2 скачка оперативная память"

#. type: TP
#: man-pages/man2/perf_event_open.2:2387
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE1>"
msgstr "B<PERF_MEM_LVL_REM_CCE1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2390
msgid "Remote cache 1 hop"
msgstr "Удалённый на 1 скачок кэш"

#. type: TP
#: man-pages/man2/perf_event_open.2:2390
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE2>"
msgstr "B<PERF_MEM_LVL_REM_CCE2>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2393
msgid "Remote cache 2 hops"
msgstr "Удалённый на 2 скачка кэш"

#. type: TP
#: man-pages/man2/perf_event_open.2:2393
#, no-wrap
msgid "B<PERF_MEM_LVL_IO>"
msgstr "B<PERF_MEM_LVL_IO>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2396
msgid "I/O memory"
msgstr "Память ввода-вывода"

#. type: TP
#: man-pages/man2/perf_event_open.2:2396
#, no-wrap
msgid "B<PERF_MEM_LVL_UNC>"
msgstr "B<PERF_MEM_LVL_UNC>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2399
msgid "Uncached memory"
msgstr "Некэшируемая память"

#. type: TP
#: man-pages/man2/perf_event_open.2:2401
#, no-wrap
msgid "I<mem_snoop>"
msgstr "I<mem_snoop>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2405
msgid ""
"Snoop mode, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_SNOOP_SHIFT>:"
msgstr ""
"Режим подглядывания (snoop mode), побитовая комбинация следующего, "
"сдвинутого влево на B<PERF_MEM_SNOOP_SHIFT>:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2408
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NA>"
msgstr "B<PERF_MEM_SNOOP_NA>"

#. type: TP
#: man-pages/man2/perf_event_open.2:2411
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NONE>"
msgstr "B<PERF_MEM_SNOOP_NONE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2414
msgid "No snoop"
msgstr "Нет подглядывания"

#. type: TP
#: man-pages/man2/perf_event_open.2:2414
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HIT>"
msgstr "B<PERF_MEM_SNOOP_HIT>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2417
msgid "Snoop hit"
msgstr "Срабатывание подглядывания"

#. type: TP
#: man-pages/man2/perf_event_open.2:2417
#, no-wrap
msgid "B<PERF_MEM_SNOOP_MISS>"
msgstr "B<PERF_MEM_SNOOP_MISS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2420
msgid "Snoop miss"
msgstr "Промах подглядывания"

#. type: TP
#: man-pages/man2/perf_event_open.2:2420
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HITM>"
msgstr "B<PERF_MEM_SNOOP_HITM>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2423
msgid "Snoop hit modified"
msgstr "Срабатывание подглядывания изменено"

#. type: TP
#: man-pages/man2/perf_event_open.2:2425
#, no-wrap
msgid "I<mem_lock>"
msgstr "I<mem_lock>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2429
msgid ""
"Lock instruction, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_LOCK_SHIFT>:"
msgstr ""
"Инструкция блокировки, побитовая комбинация следующего, сдвинутого влево на "
"B<PERF_MEM_LOCK_SHIFT>:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2432
#, no-wrap
msgid "B<PERF_MEM_LOCK_NA>"
msgstr "B<PERF_MEM_LOCK_NA>"

#. type: TP
#: man-pages/man2/perf_event_open.2:2435
#, no-wrap
msgid "B<PERF_MEM_LOCK_LOCKED>"
msgstr "B<PERF_MEM_LOCK_LOCKED>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2438
msgid "Locked transaction"
msgstr "Заблокированная транзакция"

#. type: TP
#: man-pages/man2/perf_event_open.2:2440
#, no-wrap
msgid "I<mem_dtlb>"
msgstr "I<mem_dtlb>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2445
msgid ""
"TLB access hit or miss, a bitwise combination of the following, shifted left "
"by B<PERF_MEM_TLB_SHIFT>:"
msgstr ""
"Попадание или промах доступа к TLB, побитовая комбинация следующего, "
"сдвинутого влево на B<PERF_MEM_TLB_SHIFT>:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2448
#, no-wrap
msgid "B<PERF_MEM_TLB_NA>"
msgstr "B<PERF_MEM_TLB_NA>"

#. type: TP
#: man-pages/man2/perf_event_open.2:2451
#, no-wrap
msgid "B<PERF_MEM_TLB_HIT>"
msgstr "B<PERF_MEM_TLB_HIT>"

#. type: TP
#: man-pages/man2/perf_event_open.2:2454
#, no-wrap
msgid "B<PERF_MEM_TLB_MISS>"
msgstr "B<PERF_MEM_TLB_MISS>"

#. type: TP
#: man-pages/man2/perf_event_open.2:2457
#, no-wrap
msgid "B<PERF_MEM_TLB_L1>"
msgstr "B<PERF_MEM_TLB_L1>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2460
msgid "Level 1 TLB"
msgstr "1 уровень TLB"

#. type: TP
#: man-pages/man2/perf_event_open.2:2460
#, no-wrap
msgid "B<PERF_MEM_TLB_L2>"
msgstr "B<PERF_MEM_TLB_L2>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2463
msgid "Level 2 TLB"
msgstr "2 уровень TLB"

#. type: TP
#: man-pages/man2/perf_event_open.2:2463
#, no-wrap
msgid "B<PERF_MEM_TLB_WK>"
msgstr "B<PERF_MEM_TLB_WK>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2466
msgid "Hardware walker"
msgstr "Обходчик оборудования"

#. type: TP
#: man-pages/man2/perf_event_open.2:2466
#, no-wrap
msgid "B<PERF_MEM_TLB_OS>"
msgstr "B<PERF_MEM_TLB_OS>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2469
msgid "OS fault handler"
msgstr "Обработчик ошибок ОС"

#. type: TP
#: man-pages/man2/perf_event_open.2:2472
#, no-wrap
msgid "I<transaction>"
msgstr "I<transaction>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2478
msgid ""
"If the B<PERF_SAMPLE_TRANSACTION> flag is set, then a 64-bit field is "
"recorded describing the sources of any transactional memory aborts."
msgstr ""
"Если установлен флаг B<PERF_SAMPLE_TRANSACTION>, то записывается 64-битное "
"поле, описывающее источники аварий транзакционной памяти."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2480
msgid "The field is a bitwise combination of the following values:"
msgstr "Данное поле является побитовым объединением следующих значений:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2481
#, no-wrap
msgid "B<PERF_TXN_ELISION>"
msgstr "B<PERF_TXN_ELISION>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2484
msgid "Abort from an elision type transaction (Intel-CPU-specific)."
msgstr "Авария из-за транзакции пропущенного типа (только для ЦП Intel)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2484
#, no-wrap
msgid "B<PERF_TXN_TRANSACTION>"
msgstr "B<PERF_TXN_TRANSACTION>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2487
msgid "Abort from a generic transaction."
msgstr "Авария из-за общей транзакции."

#. type: TP
#: man-pages/man2/perf_event_open.2:2487
#, no-wrap
msgid "B<PERF_TXN_SYNC>"
msgstr "B<PERF_TXN_SYNC>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2490
msgid "Synchronous abort (related to the reported instruction)."
msgstr "Синхронная авария (относится к сообщению об инструкции)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2490
#, no-wrap
msgid "B<PERF_TXN_ASYNC>"
msgstr "B<PERF_TXN_ASYNC>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2493
msgid "Asynchronous abort (not related to the reported instruction)."
msgstr "Асинхронная авария (не относится к сообщению об инструкции)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2493
#, no-wrap
msgid "B<PERF_TXN_RETRY>"
msgstr "B<PERF_TXN_RETRY>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2496
msgid "Retryable abort (retrying the transaction may have succeeded)."
msgstr ""
"Повторяемая авария (повтор транзакции может привести к успешному выполнению)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2496
#, no-wrap
msgid "B<PERF_TXN_CONFLICT>"
msgstr "B<PERF_TXN_CONFLICT>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2499
msgid "Abort due to memory conflicts with other threads."
msgstr "Авария из-за конфликта памяти между нитями."

#. type: TP
#: man-pages/man2/perf_event_open.2:2499
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_WRITE>"
msgstr "B<PERF_TXN_CAPACITY_WRITE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2502
msgid "Abort due to write capacity overflow."
msgstr "Авария из-за переполнения объёма при записи."

#. type: TP
#: man-pages/man2/perf_event_open.2:2502
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_READ>"
msgstr "B<PERF_TXN_CAPACITY_READ>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2505
msgid "Abort due to read capacity overflow."
msgstr "Авария из-за переполнения объёма при чтении."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2512
msgid ""
"In addition, a user-specified abort code can be obtained from the high 32 "
"bits of the field by shifting right by B<PERF_TXN_ABORT_SHIFT> and masking "
"with the value B<PERF_TXN_ABORT_MASK>."
msgstr ""
"Также, можно получить указанный пользователем код аварии, если сдвинуть 32 "
"бита поля вправо на B<PERF_TXN_ABORT_SHIFT> и наложить маску "
"B<PERF_TXN_ABORT_MASK>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2517
msgid ""
"If B<PERF_SAMPLE_REGS_INTR> is enabled, then the user CPU registers are "
"recorded."
msgstr ""
"Если включён B<PERF_SAMPLE_REGS_INTR>, то сохраняются пользовательские "
"регистры ЦП."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2525
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32>, or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""
"Значением поля I<abi> может быть B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> или B<PERF_SAMPLE_REGS_ABI_64>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2535
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_intr> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_intr> bit mask."
msgstr ""
"В I<regs> хранится массив регистров ЦП, которые были перечислены в поле "
"I<sample_regs_intr>. Количество значений определяется количеством бит, "
"установленных в битовой маске I<sample_regs_intr>."

#. type: TP
#: man-pages/man2/perf_event_open.2:2536
#, no-wrap
msgid "B<PERF_RECORD_MMAP2>"
msgstr "B<PERF_RECORD_MMAP2>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2545
msgid ""
"This record includes extended information on B<mmap>(2)  calls returning "
"executable mappings.  The format is similar to that of the "
"B<PERF_RECORD_MMAP> record, but includes extra values that allow uniquely "
"identifying shared mappings."
msgstr ""
"В этой записи добавлена расширенная информация вызовов B<mmap>(2), "
"возвращающих выполняемые отображения. Формат подобен записи "
"B<PERF_RECORD_MMAP>, до добавлены дополнительные значения, позволяющие "
"однозначно определить общие отображения."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2564
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    u32    maj;\n"
"    u32    min;\n"
"    u64    ino;\n"
"    u64    ino_generation;\n"
"    u32    prot;\n"
"    u32    flags;\n"
"    char   filename[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    u32    maj;\n"
"    u32    min;\n"
"    u64    ino;\n"
"    u64    ino_generation;\n"
"    u32    prot;\n"
"    u32    flags;\n"
"    char   filename[];\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2575
msgid "is the address of the allocated memory."
msgstr "адрес выделенной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:2575
#, no-wrap
msgid "I<len>"
msgstr "I<len>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2578
msgid "is the length of the allocated memory."
msgstr "длина выделенной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:2578
#, no-wrap
msgid "I<pgoff>"
msgstr "I<pgoff>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2581
msgid "is the page offset of the allocated memory."
msgstr "смещение на странице выделенной памяти."

#. type: TP
#: man-pages/man2/perf_event_open.2:2581
#, no-wrap
msgid "I<maj>"
msgstr "I<maj>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2584
msgid "is the major ID of the underlying device."
msgstr "основной идентификатор подлежащего устройства."

#. type: TP
#: man-pages/man2/perf_event_open.2:2584
#, no-wrap
msgid "I<min>"
msgstr "I<min>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2587
msgid "is the minor ID of the underlying device."
msgstr "второстепенный идентификатор подлежащего устройства."

#. type: TP
#: man-pages/man2/perf_event_open.2:2587
#, no-wrap
msgid "I<ino>"
msgstr "I<ino>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2590
msgid "is the inode number."
msgstr "номер inode."

#. type: TP
#: man-pages/man2/perf_event_open.2:2590
#, no-wrap
msgid "I<ino_generation>"
msgstr "I<ino_generation>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2593
msgid "is the inode generation."
msgstr "поколение inode."

#. type: TP
#: man-pages/man2/perf_event_open.2:2593
#, no-wrap
msgid "I<prot>"
msgstr "I<prot>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2596
msgid "is the protection information."
msgstr "защитная информация."

#. type: TP
#: man-pages/man2/perf_event_open.2:2596 man-pages/man2/perf_event_open.2:2626
#, no-wrap
msgid "I<flags>"
msgstr "I<flags>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2599
msgid "is the flags information."
msgstr "информация о флагах."

#. type: TP
#: man-pages/man2/perf_event_open.2:2599
#, no-wrap
msgid "I<filename>"
msgstr "I<filename>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2602
msgid "is a string describing the backing of the allocated memory."
msgstr "строка, описывающая выделенную память."

#. type: TP
#: man-pages/man2/perf_event_open.2:2603
#, no-wrap
msgid "B<PERF_RECORD_AUX> (since Linux 4.1)"
msgstr "B<PERF_RECORD_AUX> (начиная с Linux 4.1)"

#.  commit 68db7e98c3a6ebe7284b6cf14906ed7c55f3f7f0
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2608
msgid ""
"This record reports that new data is available in the separate AUX buffer "
"region."
msgstr ""
"Эта запись сообщает о доступности новых данных в отдельной буферной области "
"AUX."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2618
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    aux_offset;\n"
"    u64    aux_size;\n"
"    u64    flags;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    aux_offset;\n"
"    u64    aux_size;\n"
"    u64    flags;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2620
#, no-wrap
msgid "I<aux_offset>"
msgstr "I<aux_offset>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2623
msgid "offset in the AUX mmap region where the new data begins."
msgstr "смещение области AUX mmap, где начинаются новые данные."

#. type: TP
#: man-pages/man2/perf_event_open.2:2623
#, no-wrap
msgid "I<aux_size>"
msgstr "I<aux_size>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2626
msgid "size of the data made available."
msgstr "размер доступных данных."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2629
msgid "describes the AUX update."
msgstr "описывает обновление AUX."

#. type: TP
#: man-pages/man2/perf_event_open.2:2630
#, no-wrap
msgid "B<PERF_AUX_FLAG_TRUNCATED>"
msgstr "B<PERF_AUX_FLAG_TRUNCATED>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2634
msgid ""
"if set, then the data returned was truncated to fit the available buffer "
"size."
msgstr ""
"Если установлен, то возвращённые данные были обрезаны до размера доступного "
"буфера."

#. type: TP
#: man-pages/man2/perf_event_open.2:2634
#, no-wrap
msgid "B<PERF_AUX_FLAG_OVERWRITE>"
msgstr "B<PERF_AUX_FLAG_OVERWRITE>"

#.  commit 2023a0d2829e521fe6ad6b9907f3f90bfbf57142
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2638
msgid "if set, then the data returned has overwritten previous data."
msgstr "Если установлен, то возвращённые данные перезаписали имеющиеся данные."

#. type: TP
#: man-pages/man2/perf_event_open.2:2640
#, no-wrap
msgid "B<PERF_RECORD_ITRACE_START> (since Linux 4.1)"
msgstr "B<PERF_RECORD_ITRACE_START> (начиная с Linux 4.1)"

#.  ec0d7729bbaed4b9d2d3fada693278e13a3d1368
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2646
msgid ""
"This record indicates which process has initiated an instruction trace "
"event, allowing tools to properly correlate the instruction addresses in the "
"AUX buffer with the proper executable."
msgstr ""
"Эта запись показывает, что процесс начал событие трассировки инструкции, "
"который позволяет инструментам правильно соотносить адреса инструкций в "
"буфере AUX с подходящим исполняемым файлом."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2654
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2659
msgid "process ID of the thread starting an instruction trace."
msgstr "идентификатор процесса нити, начавшей трассировку инструкций."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2662
msgid "thread ID of the thread starting an instruction trace."
msgstr "идентификатор нити для нити, начавшей трассировку инструкций."

#. type: TP
#: man-pages/man2/perf_event_open.2:2663
#, no-wrap
msgid "B<PERF_RECORD_LOST_SAMPLES> (since Linux 4.2)"
msgstr "B<PERF_RECORD_LOST_SAMPLES> (начиная с Linux 4.2)"

#.  f38b0dbb491a6987e198aa6b428db8692a6480f8
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2668
msgid ""
"When using hardware sampling (such as Intel PEBS) this record indicates some "
"number of samples that may have been lost."
msgstr ""
"Если используются аппаратное измерение (такое как Intel PEBS), то данная "
"запись указывает, что несколько образцов могли потеряться."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2676
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2681
msgid "the number of potentially lost samples."
msgstr "количество потенциально потерянных образцов."

#. type: TP
#: man-pages/man2/perf_event_open.2:2682
#, no-wrap
msgid "B<PERF_RECORD_SWITCH> (since Linux 4.3)"
msgstr "B<PERF_RECORD_SWITCH> (начиная с Linux 4.3)"

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2692
msgid ""
"This record indicates a context switch has happened.  The "
"B<PERF_RECORD_MISC_SWITCH_OUT> bit in the I<misc> field indicates whether it "
"was a context switch into or away from the current process."
msgstr ""
"Данная запись указывает на выполнение переключения контекста. Бит "
"B<PERF_RECORD_MISC_SWITCH_OUT> в поле I<misc> показывает направление "
"переключение контекста — из или в текущий процесс."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2699
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2700
#, no-wrap
msgid "B<PERF_RECORD_SWITCH_CPU_WIDE> (since Linux 4.3)"
msgstr "B<PERF_RECORD_SWITCH_CPU_WIDE> (начиная с Linux 4.3)"

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2715
msgid ""
"As with B<PERF_RECORD_SWITCH> this record indicates a context switch has "
"happened, but it only occurs when sampling in CPU-wide mode and provides "
"additional information on the process being switched to/from.  The "
"B<PERF_RECORD_MISC_SWITCH_OUT> bit in the I<misc> field indicates whether it "
"was a context switch into or away from the current process."
msgstr ""
"Как и у B<PERF_RECORD_SWITCH> данная запись показывает, что произошло "
"переключение контекста, но это случается только при измерении в режиме CPU-"
"wide и предоставляет дополнительную информацию о направлении переключения "
"контекста в/из. Бит B<PERF_RECORD_MISC_SWITCH_OUT> в поле I<misc> показывает "
"направление переключения контекста: в или из текущего процесса."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2724
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 next_prev_pid;\n"
"    u32 next_prev_tid;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 next_prev_pid;\n"
"    u32 next_prev_tid;\n"
"    struct sample_id sample_id;\n"
"};\n"

#. type: TP
#: man-pages/man2/perf_event_open.2:2726
#, no-wrap
msgid "I<next_prev_pid>"
msgstr "I<next_prev_pid>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2730
msgid ""
"The process ID of the previous (if switching in)  or next (if switching out) "
"process on the CPU."
msgstr ""
"Идентификатор процесса предыдущего (если переключается в) или следующего "
"(если переключается из) процесса ЦП."

#. type: TP
#: man-pages/man2/perf_event_open.2:2730
#, no-wrap
msgid "I<next_prev_tid>"
msgstr "I<next_prev_tid>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2734
msgid ""
"The thread ID of the previous (if switching in)  or next (if switching out) "
"thread on the CPU."
msgstr ""
"Идентификатор нити предыдущей (если переключается в) или следующей (если "
"переключается из) нити ЦП."

#. type: SS
#: man-pages/man2/perf_event_open.2:2736
#, no-wrap
msgid "Overflow handling"
msgstr "Обработка переполнения"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2752
msgid ""
"Events can be set to notify when a threshold is crossed, indicating an "
"overflow.  Overflow conditions can be captured by monitoring the event file "
"descriptor with B<poll>(2), B<select>(2), or B<epoll>(7).  Alternatively, "
"the overflow events can be captured via sa signal handler, by enabling I/O "
"signaling on the file descriptor; see the discussion of the B<F_SETOWN> and "
"B<F_SETSIG> operations in B<fcntl>(2)."
msgstr ""
"Можно задать события, которые будут уведомлять о прохождении порога, "
"указывающие на переполнение. Состояние переполнения можно перехватить, "
"проследив за файловым дескриптором событий с помощью B<poll>(2), "
"B<select>(2) или B<epoll>(7). Или же события переполнения можно перехватить "
"через обработчик сигнала, включив ввод-вывод сигналов о файловом "
"дескрипторе; смотрите описание операций B<F_SETOWN> и B<F_SETSIG> в "
"B<fcntl>(2)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2756
msgid ""
"Overflows are generated only by sampling events (I<sample_period> must have "
"a nonzero value)."
msgstr ""
"Переполнения генерируются только подсчитывающими событиями (значение "
"I<sample_period> должно быть ненулевым)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2758
msgid "There are two ways to generate overflow notifications."
msgstr "Существует два способа генерации уведомлений о переполнении."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2768
msgid ""
"The first is to set a I<wakeup_events> or I<wakeup_watermark> value that "
"will trigger if a certain number of samples or bytes have been written to "
"the mmap ring buffer.  In this case, B<POLL_IN> is indicated."
msgstr ""
"Первый: задать значение I<wakeup_events> или I<wakeup_watermark>, которые "
"будут срабатывать после записи определённого количества образцов или байт "
"кольцевой буфер mmap. В этом случае признаком служит B<POLL_IN>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2780
msgid ""
"The other way is by use of the B<PERF_EVENT_IOC_REFRESH> ioctl.  This ioctl "
"adds to a counter that decrements each time the event overflows.  When "
"nonzero, B<POLL_IN> is indicated, but once the counter reaches 0 B<POLL_HUP> "
"is indicated and the underlying event is disabled."
msgstr ""
"Второй: использовать ioctl B<PERF_EVENT_IOC_REFRESH>. Данный ioctl "
"добавляется к счётчику, который уменьшается каждый раз при наступлении "
"события переполнения. Если значение не равно 0, то признаком служит "
"B<POLL_IN>, то после того, как счётчик достигнет 0, признаком становится "
"B<POLL_HUP> и определяющее событие отключается."

#.  See https://lkml.org/lkml/2011/5/24/337
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2786
msgid ""
"Refreshing an event group leader refreshes all siblings and refreshing with "
"a parameter of 0 currently enables infinite refreshes; these behaviors are "
"unsupported and should not be relied on."
msgstr ""
"Актуализация лидера группы событий, обновляет всех его потомков, а "
"актуализация с параметром 0 в настоящее время включает бесконечную "
"актуализацию; такое поведение не поддерживается и на него нельзя полагаться."

#.  commit 179033b3e064d2cd3f5f9945e76b0a0f0fbf4883
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2792
msgid ""
"Starting with Linux 3.18, B<POLL_HUP> is indicated if the event being "
"monitored is attached to a different process and that process exits."
msgstr ""
"Начиная с Linux 3.18, признак B<POLL_HUP> учитывается, если отслеживаемое "
"событие присоединено к другому процессу и этот процесс существует."

#. type: SS
#: man-pages/man2/perf_event_open.2:2792
#, no-wrap
msgid "rdpmc instruction"
msgstr "Инструкция rdpmc"

#.  commit c7206205d00ab375839bd6c7ddb247d600693c09
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2800
msgid ""
"Starting with Linux 3.4 on x86, you can use the I<rdpmc> instruction to get "
"low-latency reads without having to enter the kernel.  Note that using "
"I<rdpmc> is not necessarily faster than other methods for reading event "
"values."
msgstr ""
"Начиная с Linux 3.4 на x86, вы можете использовать инструкцию I<rdpmc> для "
"выполнения чтения с низкой задержкой без входа в ядро. Заметим, что "
"использование I<rdpmc> необязательно быстрее других способов чтения значений "
"события."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2805
msgid ""
"Support for this can be detected with the I<cap_usr_rdpmc> field in the mmap "
"page; documentation on how to calculate event values can be found in that "
"section."
msgstr ""
"Возможность использования этого можно определить по полю I<cap_usr_rdpmc> "
"страницы mmap; документацию по вычислению событий значения можно найти в "
"этом разделе."

#.  7911d3f7af14a614617e38245fedf98a724e46a9
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2815
msgid ""
"Originally, when rdpmc support was enabled, any process (not just ones with "
"an active perf event) could use the rdpmc instruction to access the "
"counters.  Starting with Linux 4.0, rdpmc support is only allowed if an "
"event is currently enabled in a process's context.  To restore the old "
"behavior, write the value 2 to I</sys/devices/cpu/rdpmc>."
msgstr ""
"Сначала, когда поддержка rdpmc была только включена, любой процесс (не "
"только с активным событием perf) мог использовать инструкцию rdpmc для "
"доступа к счётчикам. Начиная с Linux 4.0 поддержка rdpmc разрешена только, "
"если событие в данный момент включено в контексте процесса. Для возвращению "
"к старому поведению запишите значение 2 в I</sys/devices/cpu/rdpmc>."

#. type: SS
#: man-pages/man2/perf_event_open.2:2815
#, no-wrap
msgid "perf_event ioctl calls"
msgstr "Вызовы ioctl perf_event"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2820
msgid "Various ioctls act on B<perf_event_open>()  file descriptors:"
msgstr ""
"К файловым дескрипторам B<perf_event_open>() допускаются различные вызовы "
"ioctl:"

#. type: TP
#: man-pages/man2/perf_event_open.2:2820
#, no-wrap
msgid "B<PERF_EVENT_IOC_ENABLE>"
msgstr "B<PERF_EVENT_IOC_ENABLE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2824
msgid ""
"This enables the individual event or event group specified by the file "
"descriptor argument."
msgstr ""
"Включает событие или группу событий, указанное в аргументе файлового "
"дескриптора."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2830
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are enabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""
"Если в аргументе ioctl установлен бит B<PERF_IOC_FLAG_GROUP>, то включаются "
"все события в группе, даже если указанное событие не лидер группы (но "
"смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2830
#, no-wrap
msgid "B<PERF_EVENT_IOC_DISABLE>"
msgstr "B<PERF_EVENT_IOC_DISABLE>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2834
msgid ""
"This disables the individual counter or event group specified by the file "
"descriptor argument."
msgstr ""
"Отключает определённый счётчик или группу событий, указанный в аргументе "
"файлового дескриптора."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2841
msgid ""
"Enabling or disabling the leader of a group enables or disables the entire "
"group; that is, while the group leader is disabled, none of the counters in "
"the group will count.  Enabling or disabling a member of a group other than "
"the leader affects only that counter; disabling a non-leader stops that "
"counter from counting but doesn't affect any other counter."
msgstr ""
"Включение или отключение лидера группы включает или выключает всю группу; то "
"есть пока отключён лидер группы, не считается ни один из счётчиков. "
"Включение или выключение члена группы (не лидера) влияет только на этот "
"счётчик; выключение не лидера останавливает его счётчик и не влияет на "
"другие счётчики."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2847
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are disabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""
"Если в аргументе ioctl установлен бит B<PERF_IOC_FLAG_GROUP>, то выключаются "
"все события в группе, даже если указанное событие не лидер группы (но "
"смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2847
#, no-wrap
msgid "B<PERF_EVENT_IOC_REFRESH>"
msgstr "B<PERF_EVENT_IOC_REFRESH>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2861
msgid ""
"Non-inherited overflow counters can use this to enable a counter for a "
"number of overflows specified by the argument, after which it is disabled.  "
"Subsequent calls of this ioctl add the argument value to the current count.  "
"An overflow notification with B<POLL_IN> set will happen on each overflow "
"until the count reaches 0; when that happens a notification with B<POLL_HUP> "
"set is sent and the event is disabled.  Using an argument of 0 is considered "
"undefined behavior."
msgstr ""
"Не унаследованные счётчики переполнения могут использовать это для установки "
"счётчика количества переполнений, после чего он выключается (значение "
"задаётся в аргументе). Последующие вызовы этого ioctl добавляют значение "
"аргумента в текущий счётчик. При каждом переполнении будет возникать "
"уведомление о переполнении с установленным B<POLL_IN> пока счётчик не "
"достигнет 0; когда это произойдёт, посылается уведомление с установленным "
"B<POLL_HUP> и событие выключается. Для значения 0 в аргументе поведение не "
"определено."

#. type: TP
#: man-pages/man2/perf_event_open.2:2861
#, no-wrap
msgid "B<PERF_EVENT_IOC_RESET>"
msgstr "B<PERF_EVENT_IOC_RESET>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2871
msgid ""
"Reset the event count specified by the file descriptor argument to zero.  "
"This resets only the counts; there is no way to reset the multiplexing "
"I<time_enabled> or I<time_running> values."
msgstr ""
"Сбрасывает (в ноль) счётчик событий, указанный в аргументе файлового "
"дескриптора. Сбрасывается только счётчики; невозможно обнулить "
"мультиплексирующее значение I<time_enabled> или I<time_running>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2877
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are reset, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""
"Если в аргументе ioctl установлен бит B<PERF_IOC_FLAG_GROUP>, то "
"сбрасываются все события в группе, даже если указанное событие не лидер "
"группы (но смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2877
#, no-wrap
msgid "B<PERF_EVENT_IOC_PERIOD>"
msgstr "B<PERF_EVENT_IOC_PERIOD>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2880
msgid "This updates the overflow period for the event."
msgstr "Обновляет период переполнения события."

#.  commit 3581fe0ef37ce12ac7a4f74831168352ae848edc
#.  commit bad7192b842c83e580747ca57104dd51fe08c223
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2888
msgid ""
"Since Linux 3.7 (on ARM)  and Linux 3.14 (all other architectures), the new "
"period takes effect immediately.  On older kernels, the new period did not "
"take effect until after the next overflow."
msgstr ""
"Начиная с Linux 3.7 (на ARM) и Linux 3.14 (на всех остальных архитектурах), "
"новый период начинает действовать немедленно. В старых ядрах новый период не "
"работает пока не возникнет следующее переполнение."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2891
msgid ""
"The argument is a pointer to a 64-bit value containing the desired new "
"period."
msgstr ""
"Аргумент представляет собой указатель на 64-битное значение, содержащее "
"желаемый новый период."

#.  commit ad0cf3478de8677f720ee06393b3147819568d6a
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2896
msgid ""
"Prior to Linux 2.6.36, this ioctl always failed due to a bug in the kernel."
msgstr ""
"До Linux 2.6.36 данный ioctl всегда завершался с ошибкой из-за дефекта в "
"ядре."

#. type: TP
#: man-pages/man2/perf_event_open.2:2896
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_OUTPUT>"
msgstr "B<PERF_EVENT_IOC_SET_OUTPUT>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2901
msgid ""
"This tells the kernel to report event notifications to the specified file "
"descriptor rather than the default one.  The file descriptors must all be on "
"the same CPU."
msgstr ""
"Указывает ядру посылать уведомляющие события в указанный файловый "
"дескриптор, не в умолчательный. Все файловые дескрипторы должны быть на "
"одном ЦП."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2904
msgid ""
"The argument specifies the desired file descriptor, or -1 if output should "
"be ignored."
msgstr ""
"В аргументе указывается желаемый файловый дескриптор или -1, если вывод "
"нужно игнорировать."

#. type: TP
#: man-pages/man2/perf_event_open.2:2904
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_FILTER> (since Linux 2.6.33)"
msgstr "B<PERF_EVENT_IOC_SET_FILTER> (начиная с Linux 2.6.33)"

#.  commit 6fb2915df7f0747d9044da9dbff5b46dc2e20830
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2908
msgid "This adds an ftrace filter to this event."
msgstr "Добавить фильтр ftrace в это событие."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2910
msgid "The argument is a pointer to the desired ftrace filter."
msgstr "В аргументе указывается указатель на желаемый фильтр ftrace."

#. type: TP
#: man-pages/man2/perf_event_open.2:2910
#, no-wrap
msgid "B<PERF_EVENT_IOC_ID> (since Linux 3.12)"
msgstr "B<PERF_EVENT_IOC_ID> (начиная с Linux 3.12)"

#.  commit cf4957f17f2a89984915ea808876d9c82225b862
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2914
msgid "This returns the event ID value for the given event file descriptor."
msgstr ""
"Возвращает значение идентификатора события для заданного файлового "
"дескриптора события."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2917
msgid ""
"The argument is a pointer to a 64-bit unsigned integer to hold the result."
msgstr ""
"Аргументом является указатель на 64-битное беззнаковое целое число, в "
"которое будет сохранён результат."

#. type: TP
#: man-pages/man2/perf_event_open.2:2917
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_BPF> (since Linux 4.1)"
msgstr "B<PERF_EVENT_IOC_SET_BPF> (начиная с Linux 4.1)"

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2925
msgid ""
"This allows attaching a Berkeley Packet Filter (BPF)  program to an existing "
"kprobe tracepoint event.  You need B<CAP_SYS_ADMIN> privileges to use this "
"ioctl."
msgstr ""
"Позволяет присоединить программу Berkeley Packet Filter (BPF) к "
"существующему событию точки трассировки kprobe. Для этого ioctl требуется "
"мандат B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2930
msgid ""
"The argument is a BPF program file descriptor that was created by a previous "
"B<bpf>(2)  system call."
msgstr ""
"Аргументом является файловый дескриптор программы BPF, который был создан "
"ранее системным вызовом B<bpf>(2)."

#. type: TP
#: man-pages/man2/perf_event_open.2:2930
#, no-wrap
msgid "B<PERF_EVENT_IOC_PAUSE_OUTPUT> (since Linux 4.7)"
msgstr "B<PERF_EVENT_IOC_PAUSE_OUTPUT> (начиная с Linux 4.7)"

#.  commit 86e7972f690c1017fd086cdfe53d8524e68c661c
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2941
msgid ""
"This allows pausing and resuming the event's ring-buffer.  A paused ring-"
"buffer does not prevent generation of samples, but simply discards them.  "
"The discarded samples are considered lost, and cause a B<PERF_RECORD_LOST> "
"sample to be generated when possible.  An overflow signal may still be "
"triggered by the discarded sample even though the ring-buffer remains empty."
msgstr ""
"Позволяет приостанавливать и возобновлять работу кольцевого буфера событий. "
"Приостановленный кольцевой буфер не останавливает генерацию измерений, а "
"просто отбрасывает их. Отброшенные измерения считаются пропавшими и "
"генерируется, если возможно, измерение B<PERF_RECORD_LOST>. Сигнал "
"переполнения по-прежнему может возникнуть из-за отброшенного измерения, даже "
"при пустом кольцевом буфере."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2945
msgid ""
"The argument is an unsigned 32-bit integer.  A nonzero value pauses the ring-"
"buffer, while a zero value resumes the ring-buffer."
msgstr ""
"Аргументом является беззнаковое 32-битное целое. Ненулевое значение "
"приостанавливает кольцевой буфер, а нулевое — возобновляет работу кольцевого "
"буфера."

#. type: TP
#: man-pages/man2/perf_event_open.2:2945
#, no-wrap
msgid "B<PERF_EVENT_MODIFY_ATTRIBUTES> (since Linux 4.17)"
msgstr "B<PERF_EVENT_MODIFY_ATTRIBUTES> (начиная с Linux 4.17)"

#.  commit 32ff77e8cc9e66cc4fb38098f64fd54cc8f54573
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2951
msgid ""
"This allows modifying an existing event without the overhead of closing and "
"reopening a new event.  Currently this is supported only for breakpoint "
"events."
msgstr ""
"Позволяет изменить существующее событие без накладных расходов на закрытие и "
"повторное открытие нового события. В настоящее время поддерживается только "
"для событий точек останова (breakpoint)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2955
msgid ""
"The argument is a pointer to a I<perf_event_attr> structure containing the "
"updated event settings."
msgstr ""
"В аргументе содержится указатель на структуру I<perf_event_attr> с "
"обновлёнными данными события."

#. type: TP
#: man-pages/man2/perf_event_open.2:2955
#, no-wrap
msgid "B<PERF_EVENT_IOC_QUERY_BPF> (since Linux 4.16)"
msgstr "B<PERF_EVENT_IOC_QUERY_BPF> (начиная с Linux 4.16)"

#.  commit f371b304f12e31fe30207c41ca7754564e0ea4dc
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2967
msgid ""
"This allows querying which Berkeley Packet Filter (BPF)  programs are "
"attached to an existing kprobe tracepoint.  You can only attach one BPF "
"program per event, but you can have multiple events attached to a "
"tracepoint.  Querying this value on one tracepoint event returns the id of "
"all BPF programs in all events attached to the tracepoint.  You need "
"B<CAP_SYS_ADMIN> privileges to use this ioctl."
msgstr ""
"Позволяет запросить какие программы Berkeley Packet Filter (BPF) "
"присоединены к существующей точке трассировки kprobe. Вы можете присоединить "
"только одну программу BPF на событие, но можно присоединить несколько "
"событий к точке трассировки. При опросе этого значения для события точки "
"трассировки возвращается идентификатор всех программ BPF во всех событиях, "
"присоединённых к точке трассировки. Для использования этого ioctl нужно "
"иметь права B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2969
msgid "The argument is a pointer to a structure"
msgstr "В аргументе содержится указатель на структуру"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2976
#, no-wrap
msgid ""
"struct perf_event_query_bpf {\n"
"    __u32    ids_len;\n"
"    __u32    prog_cnt;\n"
"    __u32    ids[0];\n"
"};\n"
msgstr ""
"struct perf_event_query_bpf {\n"
"    __u32    ids_len;\n"
"    __u32    prog_cnt;\n"
"    __u32    ids[0];\n"
"};\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2997
msgid ""
"The I<ids_len> field indicates the number of ids that can fit in the "
"provided I<ids> array.  The I<prog_cnt> value is filled in by the kernel "
"with the number of attached BPF programs.  The I<ids> array is filled with "
"the id of each attached BPF program.  If there are more programs than will "
"fit in the array, then the kernel will return B<ENOSPC> and I<ids_len> will "
"indicate the number of program IDs that were successfully copied."
msgstr ""
"Значение поля I<ids_len> показывает сколько идентификаторов могут "
"поместиться в массив I<ids>. Значение I<prog_cnt> заполняется ядром и "
"показывает количество присоединённых программ BPF. Массив I<ids> заполняется "
"идентификаторами каждой присоединённой программы BPF. Если имеет больше "
"программ, чем влезает в массив, то ядро вернёт B<ENOSPC> и I<ids_len> укажет "
"количество идентификаторов программ, которые были успешно скопированы."

#. type: SS
#: man-pages/man2/perf_event_open.2:2997
#, no-wrap
msgid "Using prctl(2)"
msgstr "Использование prctl(2)"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3010
msgid ""
"A process can enable or disable all currently open event groups using the "
"B<prctl>(2)  B<PR_TASK_PERF_EVENTS_ENABLE> and "
"B<PR_TASK_PERF_EVENTS_DISABLE> operations.  This applies only to events "
"created locally by the calling process.  This does not apply to events "
"created by other processes attached to the calling process or inherited "
"events from a parent process.  Only group leaders are enabled and disabled, "
"not any other members of the groups."
msgstr ""
"Процесс может включить или выключить все группы, в данный момент, открытых "
"событий (с помощью операций B<prctl>(2) B<PR_TASK_PERF_EVENTS_ENABLE> и "
"B<PR_TASK_PERF_EVENTS_DISABLE>). Это применимо только к событиям созданным "
"локально вызывающим процессом. Это не применимо к событиям, созданным "
"другими процессами, присоединёнными к вызывающему процессу, или к "
"унаследованным от родительского процесса событиям. При этом включаются или "
"выключаются только лидеры групп, а не члены групп."

#. type: SS
#: man-pages/man2/perf_event_open.2:3010
#, no-wrap
msgid "perf_event related configuration files"
msgstr "Файлы настройки perf_event"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3014
msgid "Files in I</proc/sys/kernel/>"
msgstr "Файлы в I</proc/sys/kernel/>"

#. type: TP
#: man-pages/man2/perf_event_open.2:3015
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_paranoid>"
msgstr "I</proc/sys/kernel/perf_event_paranoid>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3020
msgid ""
"The I<perf_event_paranoid> file can be set to restrict access to the "
"performance counters."
msgstr ""
"Файл I<perf_event_paranoid> можно использовать для ограничения доступа к "
"счётчикам производительности."

#.  default changed in commit 0161028b7c8aebef64194d3d73e43bc3b53b5c66
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3026
msgid "allow only user-space measurements (default since Linux 4.6)."
msgstr ""
"разрешить только измерения пользовательского пространства (по умолчанию "
"начиная с Linux 4.6)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3028
msgid "allow both kernel and user measurements (default before Linux 4.6)."
msgstr ""
"разрешить измерения ядра и пользовательского пространства (по умолчанию "
"начиная с Linux 4.6)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3030
msgid "allow access to CPU-specific data but not raw tracepoint samples."
msgstr ""
"разрешить доступ к данным ЦП, но не к структурированным образцам точек "
"трассировки."

#. type: IP
#: man-pages/man2/perf_event_open.2:3030
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3032
msgid "no restrictions."
msgstr "без ограничений."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3039
msgid ""
"The existence of the I<perf_event_paranoid> file is the official method for "
"determining if a kernel supports B<perf_event_open>()."
msgstr ""
"Наличие файла I<perf_event_paranoid> — официальный метод определения "
"поддержки ядром B<perf_event_open>()."

#. type: TP
#: man-pages/man2/perf_event_open.2:3039
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_sample_rate>"
msgstr "I</proc/sys/kernel/perf_event_max_sample_rate>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3047
msgid ""
"This sets the maximum sample rate.  Setting this too high can allow users to "
"sample at a rate that impacts overall machine performance and potentially "
"lock up the machine.  The default value is 100000 (samples per second)."
msgstr ""
"Максимальная скорость выборки. Установка слишком большого значения может "
"позволить пользователям задать выборку, которая скажется на "
"производительности машины и, возможно, заблокирует машину. Значение по "
"умолчанию 100000 (образов в секунду)."

#. type: TP
#: man-pages/man2/perf_event_open.2:3047
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_stack>"
msgstr "I</proc/sys/kernel/perf_event_max_stack>"

#.  Introduced in c5dfd78eb79851e278b7973031b9ca363da87a7e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3052
msgid ""
"This file sets the maximum depth of stack frame entries reported when "
"generating a call trace."
msgstr ""
"Данный файл задаёт максимальную глубину стека кадров, выдаваемых при "
"генерации трассировки вызова."

#. type: TP
#: man-pages/man2/perf_event_open.2:3052
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_mlock_kb>"
msgstr "I</proc/sys/kernel/perf_event_mlock_kb>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3057
msgid ""
"Maximum number of pages an unprivileged user can B<mlock>(2).  The default "
"is 516 (kB)."
msgstr ""
"Максимальное количество страниц, которое может получить непривилегированный "
"пользователь с помощью B<mlock>(2). По умолчанию 516 (кБ)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3061
msgid "Files in I</sys/bus/event_source/devices/>"
msgstr "Файлы в I</sys/bus/event_source/devices/>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3068
msgid ""
"Since Linux 2.6.34, the kernel supports having multiple PMUs available for "
"monitoring.  Information on how to program these PMUs can be found under I</"
"sys/bus/event_source/devices/>.  Each subdirectory corresponds to a "
"different PMU."
msgstr ""
"Начиная с Linux 2.6.34, ядро поддерживает использование нескольких PMU для "
"слежения. Информацию о программировании этих PMU можно найти вI</sys/bus/"
"event_source/devices/>. Каждый подкаталог соответствует одному PMU."

#. type: TP
#: man-pages/man2/perf_event_open.2:3068
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/type> (since Linux 2.6.38)"
msgstr "I</sys/bus/event_source/devices/*/type> (начиная с Linux 2.6.38)"

#.  commit abe43400579d5de0078c2d3a760e6598e183f871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3076
msgid ""
"This contains an integer that can be used in the I<type> field of "
"I<perf_event_attr> to indicate that you wish to use this PMU."
msgstr ""
"Содержит целое, которое можно использовать в поле I<type> из "
"I<perf_event_attr>, отражает, что вы хотите использовать этот PMU."

#. type: TP
#: man-pages/man2/perf_event_open.2:3076
#, no-wrap
msgid "I</sys/bus/event_source/devices/cpu/rdpmc> (since Linux 3.4)"
msgstr "I</sys/bus/event_source/devices/cpu/rdpmc> (начиная с Linux 3.4)"

#.  commit 0c9d42ed4cee2aa1dfc3a260b741baae8615744f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3082
msgid ""
"If this file is 1, then direct user-space access to the performance counter "
"registers is allowed via the rdpmc instruction.  This can be disabled by "
"echoing 0 to the file."
msgstr ""
"Если в файле значение 1, то с помощью инструкции rdpmc возможен прямой "
"доступ из пользовательского пространства к регистрам счётчика "
"производительности. Выключить доступ можно посредством записи 0 в этот файл."

#.  a66734297f78707ce39d756b656bfae861d53f62
#.  7911d3f7af14a614617e38245fedf98a724e46a9
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3089
msgid ""
"As of Linux 4.0 the behavior has changed, so that 1 now means only allow "
"access to processes with active perf events, with 2 indicating the old allow-"
"anyone-access behavior."
msgstr ""
"В Linux 4.0 это поведение изменено, теперь 1 означает лишь доступ к "
"процессам с активными событиями perf, а 2 возвращает старое поведение "
"разрешения доступа всем."

#. type: TP
#: man-pages/man2/perf_event_open.2:3089
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/format/> (since Linux 3.4)"
msgstr "I</sys/bus/event_source/devices/*/format/> (начиная с Linux 3.4)"

#.  commit 641cc938815dfd09f8fa1ec72deb814f0938ac33
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3098
msgid ""
"This subdirectory contains information on the architecture-specific "
"subfields available for programming the various I<config> fields in the "
"I<perf_event_attr> struct."
msgstr ""
"В этом подкаталоге содержится информация по зависящим от архитектуры полям, "
"доступным для программирования различных полей I<config> структуры "
"I<perf_event_attr>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3109
msgid ""
"The content of each file is the name of the config field, followed by a "
"colon, followed by a series of integer bit ranges separated by commas.  For "
"example, the file I<event> may contain the value I<config1:1,6-10,44> which "
"indicates that event is an attribute that occupies bits 1,6\\(en10, and 44 "
"of I<perf_event_attr::config1>."
msgstr ""
"В каждом файле содержится имя поля config, двоеточие, диапазоны бит через "
"запятую. Например, файл I<event> может содержать значение "
"I<config1:1,6-10,44>, что означает, что событие — атрибут, занимающий биты "
"1,6\\(en10 и 44 в I<perf_event_attr::config1>."

#. type: TP
#: man-pages/man2/perf_event_open.2:3109
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/events/> (since Linux 3.4)"
msgstr "I</sys/bus/event_source/devices/*/events/> (начиная с Linux 3.4)"

#.  commit 641cc938815dfd09f8fa1ec72deb814f0938ac33
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3119
msgid ""
"This subdirectory contains files with predefined events.  The contents are "
"strings describing the event settings expressed in terms of the fields found "
"in the previously mentioned I<./format/> directory.  These are not "
"necessarily complete lists of all events supported by a PMU, but usually a "
"subset of events deemed useful or interesting."
msgstr ""
"В данном подкаталоге содержатся поля с предопределёнными событиями. "
"Содержимое — строки, описывающие настройки события в виде полей упомянутых в "
"каталоге I<./format/> ранее. Это не обязательно полный список всех событий, "
"поддерживаемых PMU, но обычно это поднабор событий, считаемый полезным."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3127
msgid ""
"The content of each file is a list of attribute names separated by commas.  "
"Each entry has an optional value (either hex or decimal).  If no value is "
"specified, then it is assumed to be a single-bit field with a value of 1.  "
"An example entry may look like this: I<event=0x2,inv,ldlat=3>."
msgstr ""
"Содержимое каждого файла — список имён атрибутов через запятую. Каждая "
"запись имеет необязательное значение (десятичное или шестнадцатеричное "
"число). Если значение не указано, то предполагается что это однобитовое поле "
"со значением 1. Пример: I<event=0x2,inv,ldlat=3>."

#. type: TP
#: man-pages/man2/perf_event_open.2:3127
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/uevent>"
msgstr "I</sys/bus/event_source/devices/*/uevent>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3131
msgid ""
"This file is the standard kernel device interface for injecting hotplug "
"events."
msgstr ""
"Данный файл — стандартное ядерное интерфейсное устройство для введения "
"событий на лету."

#. type: TP
#: man-pages/man2/perf_event_open.2:3131
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/cpumask> (since Linux 3.7)"
msgstr "I</sys/bus/event_source/devices/*/cpumask> (начиная с Linux 3.7)"

#.  commit 314d9f63f385096580e9e2a06eaa0745d92fe4ac
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3141
msgid ""
"The I<cpumask> file contains a comma-separated list of integers that "
"indicate a representative CPU number for each socket (package)  on the "
"motherboard.  This is needed when setting up uncore or northbridge events, "
"as those PMUs present socket-wide events."
msgstr ""
"В файле I<cpumask> содержится список целых чисел (через запятую), которые "
"представляют номер ЦП для каждого сокета (пакета) на материнской плате. Он "
"необходим для настройки внеядерных событий или событий северного моста, "
"поскольку эти PMU представляют события всего сокета."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3148
msgid ""
"B<perf_event_open>()  returns the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""
"Вызов B<perf_event_open>() возвращает новый дескриптор файла или -1 в случае "
"ошибки (в этом случае I<errno> устанавливается в соответствующее значение)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3153
msgid ""
"The errors returned by B<perf_event_open>()  can be inconsistent, and may "
"vary across processor architectures and performance monitoring units."
msgstr ""
"Ошибки, возвращаемые B<perf_event_open>(), могут различаться на разных "
"процессорных архитектурах и модулях слежения за производительностью."

#. type: TP
#: man-pages/man2/perf_event_open.2:3153
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3170
msgid ""
"Returned if the I<perf_event_attr> I<size> value is too small (smaller than "
"B<PERF_ATTR_SIZE_VER0>), too big (larger than the page size), or larger than "
"the kernel supports and the extra bytes are not zero.  When B<E2BIG> is "
"returned, the I<perf_event_attr> I<size> field is overwritten by the kernel "
"to be the size of the structure it was expecting."
msgstr ""
"Возвращается, если значение I<perf_event_attr> I<size> слишком мало (меньше "
"чем B<PERF_ATTR_SIZE_VER0>), слишком велико (больше размера страницы) или "
"больше чем поддерживает ядро и дополнительные байты не равны нулю. При "
"возврате B<E2BIG> ядро перезаписывает поле I<size> I<perf_event_attr> "
"размером структуры, который ожидался."

#. type: TP
#: man-pages/man2/perf_event_open.2:3170
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3184
msgid ""
"Returned when the requested event requires B<CAP_SYS_ADMIN> permissions (or "
"a more permissive perf_event paranoid setting).  Some common cases where an "
"unprivileged process may encounter this error: attaching to a process owned "
"by a different user; monitoring all processes on a given CPU (i.e., "
"specifying the I<pid> argument as -1); and not setting I<exclude_kernel> "
"when the paranoid setting requires it."
msgstr ""
"Возвращается, когда для запрашиваемого события требуется мандат "
"B<CAP_SYS_ADMIN> (или более разрешительная параноидное perf_event). "
"Распространённые случае, в которых непривилегированный процесс получает эту "
"ошибку: присоединение к процессу, принадлежащему другому пользователю; "
"слежение за всеми процессами на указанном ЦП (т. е., указание в аргументе "
"I<pid> значения -1); не указано I<exclude_kernel>, когда параноидная "
"настройка требует этого."

#. type: TP
#: man-pages/man2/perf_event_open.2:3184
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3194
msgid ""
"Returned if the I<group_fd> file descriptor is not valid, or, if "
"B<PERF_FLAG_PID_CGROUP> is set, the cgroup file descriptor in I<pid> is not "
"valid."
msgstr ""
"Возвращается, если файловый дескриптор I<group_fd> некорректен, или если "
"установлен B<PERF_FLAG_PID_CGROUP> и файловый дескриптор cgroup в I<pid> "
"некорректен."

#. type: TP
#: man-pages/man2/perf_event_open.2:3194
#, no-wrap
msgid "B<EBUSY> (since Linux 4.1)"
msgstr "B<EBUSY> (начиная с Linux 4.1)"

#.  bed5b25ad9c8a2f5d735ef0bc746ec870c01c1b0
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3199
msgid "Returned if another event already has exclusive access to the PMU."
msgstr ""
"Возвращается, если другое событие уже владеет эксклюзивным доступом к PMU."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3204
msgid "Returned if the I<attr> pointer points at an invalid memory address."
msgstr ""
"Возвращается, если указатель I<attr> указывает на некорректный адрес памяти."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3230
msgid ""
"Returned if the specified event is invalid.  There are many possible reasons "
"for this.  A not-exhaustive list: I<sample_freq> is higher than the maximum "
"setting; the I<cpu> to monitor does not exist; I<read_format> is out of "
"range; I<sample_type> is out of range; the I<flags> value is out of range; "
"I<exclusive> or I<pinned> set and the event is not a group leader; the event "
"I<config> values are out of range or set reserved bits; the generic event "
"selected is not supported; or there is not enough room to add the selected "
"event."
msgstr ""
"Возвращается, если указано некорректное событие. Может быть по многим "
"причинам. Неполный список: значение I<sample_freq> больше, чем максимальное "
"настроенное; значение I<cpu> для слежения не существует; значение "
"I<read_format> вне пределов диапазона; значение I<sample_type> вне пределов "
"диапазона; значение I<flags> вне пределов диапазона; указано значение "
"I<exclusive> или I<pinned> и событие не является лидером группы; значения "
"события I<config> вне пределов диапазона или задают зарезервированные биты; "
"выбранное общее событие не поддерживается; не хватает места для добавления "
"события."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3236
msgid ""
"Each opened event uses one file descriptor.  If a large number of events are "
"opened, the per-process limit on the number of open file descriptors will be "
"reached, and no more events can be created."
msgstr ""
"Каждое открытое событие использует один файловый дескриптор. Если открыто "
"большое количество событий, то достигается процессное ограничение на "
"количество открытых файловых дескрипторов и больше событий создать будет "
"невозможно."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3240
msgid ""
"Returned when the event involves a feature not supported by the current CPU."
msgstr ""
"Возвращается, когда событие используется свойство, которое не поддерживается "
"текущим ЦП."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3247
msgid ""
"Returned if the I<type> setting is not valid.  This error is also returned "
"for some unsupported generic events."
msgstr ""
"Возвращается, если значение I<type> некорректно. Эта ошибка также "
"возвращается для некоторых неподдерживаемых общих событий."

#.  commit aa2bc1ade59003a379ffc485d6da2d92ea3370a6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3258
msgid ""
"Prior to Linux 3.3, if there was not enough room for the event, B<ENOSPC> "
"was returned.  In Linux 3.3, this was changed to B<EINVAL>.  B<ENOSPC> is "
"still returned if you try to add more breakpoint events than supported by "
"the hardware."
msgstr ""
"До Linux 3.3, при недостаточности места для события возвращалось значение "
"B<ENOSPC>. В Linux 3.3 она была заменена на B<EINVAL>. Значение B<ENOSPC> "
"всё ещё возвращается, если вы попытаетесь добавить больше событий точек "
"прерывания, чем поддерживается аппаратно."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3265
msgid ""
"Returned if B<PERF_SAMPLE_STACK_USER> is set in I<sample_type> and it is not "
"supported by hardware."
msgstr ""
"Возвращается, если установлен B<PERF_SAMPLE_STACK_USER> в I<sample_type> и "
"не поддерживается оборудованием."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3272
msgid ""
"Returned if an event requiring a specific hardware feature is requested but "
"there is no hardware support.  This includes requesting low-skid events if "
"not supported, branch tracing if it is not available, sampling if no PMU "
"interrupt is available, and branch stacks for software events."
msgstr ""
"Возвращается, если требуемое событие запрашивает специального свойства "
"аппаратуры, но оно отсутствует. Возникает при запросе низкоуровневых (low-"
"skid) событий без поддержки, трассировке ветвления без поддержки, выборки, "
"если отсутствует прерывание PMU и стеки ветви для программных событий."

#. type: TP
#: man-pages/man2/perf_event_open.2:3272
#, no-wrap
msgid "B<EOVERFLOW> (since Linux 4.8)"
msgstr "B<EOVERFLOW> (начиная с Linux 4.8)"

#.  97c79a38cd454602645f0470ffb444b3b75ce574
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3281
msgid ""
"Returned if B<PERF_SAMPLE_CALLCHAIN> is requested and I<sample_max_stack> is "
"larger than the maximum specified in I</proc/sys/kernel/"
"perf_event_max_stack>."
msgstr ""
"Возвращается, если запрошена B<PERF_SAMPLE_CALLCHAIN> и значение "
"I<sample_max_stack> больше максимального, указанного в I</proc/sys/kernel/"
"perf_event_max_stack>."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3286
msgid ""
"Returned on many (but not all) architectures when an unsupported "
"I<exclude_hv>, I<exclude_idle>, I<exclude_user>, or I<exclude_kernel> "
"setting is specified."
msgstr ""
"Возвращается на многих (но не всех) архитектурах, если указана "
"неподдерживаемая настройка I<exclude_hv>, I<exclude_idle>, I<exclude_user> "
"или I<exclude_kernel>."

#.  commit a4e95fc2cbb31d70a65beffeaf8773f881328c34
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3295
msgid ""
"It can also happen, as with B<EACCES>, when the requested event requires "
"B<CAP_SYS_ADMIN> permissions (or a more permissive perf_event paranoid "
"setting).  This includes setting a breakpoint on a kernel address, and "
"(since Linux 3.13) setting a kernel function-trace tracepoint."
msgstr ""
"Также это может случаться как при B<EACCES>, когда запрашиваемое событие "
"требует мандата B<CAP_SYS_ADMIN> (или более разрешительную параноидную "
"настройку perf_event). Это относится к установке точки останова на адрес "
"ядра и (начиная с Linux 3.13) установке точки трассировки функции ядра."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3298
msgid "Returned if attempting to attach to a process that does not exist."
msgstr "Возвращается при попытке присоединения к несуществующему процессу."

#. type: SH
#: man-pages/man2/perf_event_open.2:3298
#, no-wrap
msgid "VERSION"
msgstr "ВЕРСИЯ"

#.  commit 0793a61d4df8daeac6492dbf8d2f3e5713caae5e
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3305
msgid ""
"B<perf_event_open>()  was introduced in Linux 2.6.31 but was called "
"B<perf_counter_open>().  It was renamed in Linux 2.6.32."
msgstr ""
"Системный вызов B<perf_event_open>() появился в Linux 2.6.31, но с именем "
"B<perf_counter_open>(). Он был переименован в Linux 2.6.32."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3310
msgid ""
"This B<perf_event_open>()  system call Linux-specific and should not be used "
"in programs intended to be portable."
msgstr ""
"Данный системный вызов B<perf_event_open>() существует только в Linux и не "
"должен использоваться переносимых программах."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3314
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  See the example below."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2). Смотрите пример ниже."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3320
msgid ""
"The official way of knowing if B<perf_event_open>()  support is enabled is "
"checking for the existence of the file I</proc/sys/kernel/"
"perf_event_paranoid>."
msgstr ""
"Официальным способом наличия поддержки B<perf_event_open>() является "
"проверка существования файла I</proc/sys/kernel/perf_event_paranoid>."

#.  commit ba0a6c9f6fceed11c6a99e8326f0477fe383e6b5
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3328
msgid ""
"The B<F_SETOWN_EX> option to B<fcntl>(2)  is needed to properly get overflow "
"signals in threads.  This was introduced in Linux 2.6.32."
msgstr ""
"Значение B<F_SETOWN_EX> в B<fcntl>(2) требуется для правильного получения "
"сигналов переполнения в нитях. Появилось в Linux 2.6.32."

#.  commit b690081d4d3f6a23541493f1682835c3cd5c54a1
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3338
msgid ""
"Prior to Linux 2.6.33 (at least for x86), the kernel did not check if events "
"could be scheduled together until read time.  The same happens on all known "
"kernels if the NMI watchdog is enabled.  This means to see if a given set of "
"events works you have to B<perf_event_open>(), start, then read before you "
"know for sure you can get valid measurements."
msgstr ""
"До Linux 2.6.33 (как минимум, на x86), ядро не проверяло возможность "
"планирования события для совместной работы до чтения. Это же происходит на "
"всех известных ядрах при включённом сторожке NMI. Чтобы увидеть, работает ли "
"заданный набор событий, выполните B<perf_event_open>(), запуск, затем "
"выполните чтения, зная наверняка, что ещё не можете получить корректные "
"измерения."

#.  FIXME . cannot find a kernel commit for this one
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3344
msgid ""
"Prior to Linux 2.6.34, event constraints were not enforced by the kernel.  "
"In that case, some events would silently return \"0\" if the kernel "
"scheduled them in an improper counter slot."
msgstr ""
"До Linux 2.6.34 ограничения на события не соблюдались ядром. В этом случае "
"некоторые события просто возвращали «0», если ядро планировало их в "
"неподходящий слот счётчика."

#.  commit 45e16a6834b6af098702e5ea6c9a40de42ff77d8
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3348
msgid ""
"Prior to Linux 2.6.34, there was a bug when multiplexing where the wrong "
"results could be returned."
msgstr ""
"До Linux 2.6.34 существовала ошибка в мультиплексировании, при котором могли "
"вернуться некорректные результаты."

#.  commit 38b435b16c36b0d863efcf3f07b34a6fac9873fd
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3352
msgid ""
"Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "
"\"inherit\" is enabled and many threads are started."
msgstr ""
"Ядра с Linux 2.6.35 по Linux 2.6.39 могли быстро упасть, если включено "
"«наследование» и запускалось много нитей."

#.  commit 050735b08ca8a016bbace4445fa025b88fee770b
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3357
msgid ""
"Prior to Linux 2.6.35, B<PERF_FORMAT_GROUP> did not work with attached "
"processes."
msgstr ""
"До Linux 2.6.35 функция B<PERF_FORMAT_GROUP> не работает с присоединёнными "
"процессами."

#.  commit 4ec8363dfc1451f8c8f86825731fe712798ada02
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3364
msgid ""
"There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that "
"ignores the \"watermark\" field and acts as if a wakeup_event was chosen if "
"the union has a nonzero value in it."
msgstr ""
"Существует ошибка в коде ядра с Linux 2.6.36 по Linux 3.0, из-за которой "
"игнорируется поле «watermark» и ядро работает, как если бы было выбрано "
"wakeup_event, если объединение в нём не равно нулю."

#.  commit 724b6daa13e100067c30cfc4d1ad06629609dc4e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3371
msgid ""
"From Linux 2.6.31 to Linux 3.4, the B<PERF_IOC_FLAG_GROUP> ioctl argument "
"was broken and would repeatedly operate on the event specified rather than "
"iterating across all sibling events in a group."
msgstr ""
"С Linux 2.6.31 по Linux 3.4 аргумент ioctl B<PERF_IOC_FLAG_GROUP> работает "
"неправильно и постоянно применяется к указанному событию, а не ко всем "
"одноуровневым событиям в группе."

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3383
msgid ""
"From Linux 3.4 to Linux 3.11, the mmap I<cap_usr_rdpmc> and I<cap_usr_time> "
"bits mapped to the same location.  Code should migrate to the new "
"I<cap_user_rdpmc> and I<cap_user_time> fields instead."
msgstr ""
"С Linux 3.4 по Linux 3.11, биты mmap I<cap_usr_rdpmc> и I<cap_usr_time> "
"отображаются на одно расположение. Использующий их код нужно переписать, "
"использовав новые поля I<cap_user_rdpmc> и I<cap_user_time>."

#.  commit f287d332ce835f77a4f5077d2c0ef1e3f9ea42d2
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3389
msgid ""
"Always double-check your results! Various generalized events have had wrong "
"values.  For example, retired branches measured the wrong thing on AMD "
"machines until Linux 2.6.35."
msgstr ""
"Всегда дважды проверяйте результаты! Различные обобщённые события содержат "
"некорректные результаты. Например, прошедшие ветви измеряются неправильно на "
"машинах сAMD до Linux 2.6.35."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3393
msgid ""
"The following is a short example that measures the total instruction count "
"of a call to B<printf>(3)."
msgstr ""
"Следующий короткий пример показывает как подсчитать количество инструкций в "
"вызове B<printf>(3)."

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3402
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3408
#, no-wrap
msgid ""
"static long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"
msgstr ""
"static long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3413
#, no-wrap
msgid ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"
msgstr ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3420
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3428
#, no-wrap
msgid ""
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
msgstr ""
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3434
#, no-wrap
msgid ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Ошибка открытия лидера %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3437
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"
msgstr ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3439
#, no-wrap
msgid "    printf(\"Measuring instruction count for this printf\\en\");\n"
msgstr "    printf(\"Измерение счётчика количества инструкций для этого printf\\en\");\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3442
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(long long));\n"
msgstr ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(long long));\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3444
#, no-wrap
msgid "    printf(\"Used %lld instructions\\en\", count);\n"
msgstr "    printf(\"Использовано %lld инструкций\\en\", count);\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3447
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""
"    close(fd);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3454
msgid ""
"B<perf>(1), B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"
msgstr ""
"B<perf>(1), B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"

#. type: TH
#: man-pages/man2/personality.2:33
#, no-wrap
msgid "PERSONALITY"
msgstr "PERSONALITY"

#. type: Plain text
#: man-pages/man2/personality.2:36
msgid "personality - set the process execution domain"
msgstr "personality - задаёт домен исполнения процесса"

#. type: Plain text
#: man-pages/man2/personality.2:38
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr "B<#include E<lt>sys/personality.hE<gt>>"

#. type: Plain text
#: man-pages/man2/personality.2:40
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr "B<int personality(unsigned long >I<persona>B<);>"

#. type: Plain text
#: man-pages/man2/personality.2:48
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""
"Linux поддерживает несколько видов доменов исполнения процессов или "
"специализаций (personalities) для каждого процесса. Среди прочего, домены "
"исполнения указывают Linux как связывать номера сигналов с обработчиками "
"сигналов. Система доменов исполнения позволяет Linux частично поддерживать "
"программы, собранные в других ОС, подобных UNIX."

#. type: Plain text
#: man-pages/man2/personality.2:60
msgid ""
"If I<persona> is not 0xffffffff, then B<personality>()  sets the caller's "
"execution domain to the value specified by I<persona>.  Specifying "
"I<persona> as 0xffffffff provides a way of retrieving the current persona "
"without changing it."
msgstr ""
"Если значение I<persona> не равно 0xffffffff, то B<personality>() установит "
"домен исполнения вызывающего равным значению I<persona>. Если значение "
"I<persona> равно 0xffffffff, то возвращается текущую специализацию (persona) "
"не изменяя её."

#. type: Plain text
#: man-pages/man2/personality.2:70
msgid ""
"A list of the available execution domains can be found in I<E<lt>sys/"
"personality.hE<gt>>.  The execution domain is a 32-bit value in which the "
"top three bytes are set aside for flags that cause the kernel to modify the "
"behavior of certain system calls so as to emulate historical or "
"architectural quirks.  The least significant byte is value defining the "
"personality the kernel should assume.  The flag values are as follows:"
msgstr ""
"Список доступных доменов исполнения можно найти в I<E<lt>sys/personality."
"hE<gt>>. Домен исполнения — это 32-битное значение, в котором верхние три "
"байта отведены под флаги, заставляющие ядро изменить поведение определённых "
"системных вызов, чтобы они эмулировали устаревшие или архитектурные "
"особенности. Младший байт содержит значение, определяющее специализацию, "
"которую должно предполагать ядро. Значения флагов:"

#. type: TP
#: man-pages/man2/personality.2:70
#, no-wrap
msgid "B<ADDR_COMPAT_LAYOUT> (since Linux 2.6.9)"
msgstr "B<ADDR_COMPAT_LAYOUT> (начиная с Linux 2.6.9)"

#. type: Plain text
#: man-pages/man2/personality.2:73
msgid "With this flag set, provide legacy virtual address space layout."
msgstr ""
"При указании этого флага предоставляется устаревшая раскладка виртуального "
"адресного пространства."

#. type: TP
#: man-pages/man2/personality.2:73
#, no-wrap
msgid "B<ADDR_NO_RANDOMIZE> (since Linux 2.6.12)"
msgstr "B<ADDR_NO_RANDOMIZE> (начиная с Linux 2.6.12)"

#. type: Plain text
#: man-pages/man2/personality.2:76
msgid "With this flag set, disable address-space-layout randomization."
msgstr ""
"При указании этого флага отключается случайное расположение виртуального "
"адресного пространства."

#. type: TP
#: man-pages/man2/personality.2:76
#, no-wrap
msgid "B<ADDR_LIMIT_32BIT> (since Linux 2.2)"
msgstr "B<ADDR_LIMIT_32BIT> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/personality.2:79
msgid "Limit the address space to 32 bits."
msgstr "Ограничивает адресное пространство 32 битами."

#. type: TP
#: man-pages/man2/personality.2:79
#, no-wrap
msgid "B<ADDR_LIMIT_3GB> (since Linux 2.4.0)"
msgstr "B<ADDR_LIMIT_3GB> (начиная с Linux 2.4.0)"

#. type: Plain text
#: man-pages/man2/personality.2:85
msgid ""
"With this flag set, use 0xc0000000 as the offset at which to search a "
"virtual memory chunk on B<mmap>(2); otherwise use 0xffffe000."
msgstr ""
"При указании этого флага значение 0xc0000000 используется как смещение, по "
"которому ищется блок (chunk) виртуальной памяти в B<mmap>(2); в противном "
"случае используется 0xffffe000."

#. type: TP
#: man-pages/man2/personality.2:85
#, no-wrap
msgid "B<FDPIC_FUNCPTRS> (since Linux 2.6.11)"
msgstr "B<FDPIC_FUNCPTRS> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man2/personality.2:89
msgid ""
"User-space function pointers to signal handlers point (on certain "
"architectures) to descriptors."
msgstr ""
"Указатели на функции пользовательского пространства для сигнальных "
"обработчиков указывают (на определённых архитектурах) на дескрипторы."

#. type: TP
#: man-pages/man2/personality.2:89
#, no-wrap
msgid "B<MMAP_PAGE_ZERO> (since Linux 2.4.0)"
msgstr "B<MMAP_PAGE_ZERO> (начиная с Linux 2.4.0)"

#. type: Plain text
#: man-pages/man2/personality.2:93
msgid ""
"Map page 0 as read-only (to support binaries that depend on this SVr4 "
"behavior)."
msgstr ""
"Отображать страницу 0 только для чтения (для поддержки двоичных файлов, "
"зависящих от такого поведения согласно SVr4)."

#. type: TP
#: man-pages/man2/personality.2:93
#, no-wrap
msgid "B<READ_IMPLIES_EXEC> (since Linux 2.6.8)"
msgstr "B<READ_IMPLIES_EXEC> (начиная с Linux 2.6.8)"

#. type: Plain text
#: man-pages/man2/personality.2:101
msgid "With this flag set, B<PROT_READ> implies B<PROT_EXEC> for B<mmap>(2)."
msgstr ""
"При указании этого флага операция B<PROT_READ> в B<mmap>(2) подразумевает и "
"B<PROT_EXEC>."

#. type: TP
#: man-pages/man2/personality.2:101
#, no-wrap
msgid "B<SHORT_INODE> (since Linux 2.4.0)"
msgstr "B<SHORT_INODE> (начиная с Linux 2.4.0)"

#. type: Plain text
#: man-pages/man2/personality.2:104 man-pages/man2/personality.2:123
msgid "No effects(?)."
msgstr "Никак не влияет(?)."

#. type: TP
#: man-pages/man2/personality.2:104
#, no-wrap
msgid "B<STICKY_TIMEOUTS> (since Linux 1.2.0)"
msgstr "B<STICKY_TIMEOUTS> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:113
msgid ""
"With this flag set, B<select>(2), B<pselect>(2), and B<ppoll>(2)  do not "
"modify the returned timeout argument when interrupted by a signal handler."
msgstr ""
"При указании этого флага вызовы B<select>(2), B<pselect>(2) и B<ppoll>(2) не "
"изменяют возвращаемый аргумент ожидания, если их работа прерывается "
"обработчиком сигнала."

#. type: TP
#: man-pages/man2/personality.2:113
#, no-wrap
msgid "B<UNAME26> (since Linux 3.1)"
msgstr "B<UNAME26> (начиная с Linux 3.1)"

#. type: Plain text
#: man-pages/man2/personality.2:120
msgid ""
"Have B<uname>(2)  report a 2.6.40+ version number rather than a 3.x version "
"number.  Added as a stopgap measure to support broken applications that "
"could not handle the kernel version-numbering switch from 2.6.x to 3.x."
msgstr ""
"Заставляет B<uname>(2) выдавать номер версии 2.6.40+, а не 3.x. Добавлен как "
"временная мера поддержки некорректных приложений, которые не могут учесть "
"переход в нумерации версий ядра с 2.6.x на 3.x."

#. type: TP
#: man-pages/man2/personality.2:120
#, no-wrap
msgid "B<WHOLE_SECONDS> (since Linux 1.2.0)"
msgstr "B<WHOLE_SECONDS> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:125
msgid "The available execution domains are:"
msgstr "Список доступных доменов исполнения:"

#. type: TP
#: man-pages/man2/personality.2:125
#, no-wrap
msgid "B<PER_BSD> (since Linux 1.2.0)"
msgstr "B<PER_BSD> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:128
msgid "BSD. (No effects.)"
msgstr "BSD. (Никак не влияет)"

#. type: TP
#: man-pages/man2/personality.2:128
#, no-wrap
msgid "B<PER_HPUX> (since Linux 2.4)"
msgstr "B<PER_HPUX> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man2/personality.2:133
msgid ""
"Support for 32-bit HP/UX.  This support was never complete, and was dropped "
"so that since Linux 4.0, this value has no effect."
msgstr ""
"Поддержка 32-битного HP/UX. Никогда не была полной и удалена начиная с Linux "
"4.0, данное значение никак не влияет на работу."

#. type: TP
#: man-pages/man2/personality.2:133
#, no-wrap
msgid "B<PER_IRIX32> (since Linux 2.2)"
msgstr "B<PER_IRIX32> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/personality.2:139
msgid ""
"IRIX 5 32-bit.  Never fully functional; support dropped in Linux 2.6.27.  "
"Implies B<STICKY_TIMEOUTS>."
msgstr ""
"Поддержка 32-битного IRIX 5. Никогда полностью не работала; удалена в Linux  "
"2.6.27. Подразумевает B<STICKY_TIMEOUTS>."

#. type: TP
#: man-pages/man2/personality.2:139
#, no-wrap
msgid "B<PER_IRIX64> (since Linux 2.2)"
msgstr "B<PER_IRIX64> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/personality.2:145
msgid "IRIX 6 64-bit.  Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""
"IRIX 6, 64-битная версия. Подразумевает B<STICKY_TIMEOUTS>; в противном "
"случае никак не влияет."

#. type: TP
#: man-pages/man2/personality.2:145
#, no-wrap
msgid "B<PER_IRIXN32> (since Linux 2.2)"
msgstr "B<PER_IRIXN32> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/personality.2:151
msgid "IRIX 6 new 32-bit.  Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""
"IRIX 6, новая 32-битная версия. Подразумевает B<STICKY_TIMEOUTS>; в "
"противном случае никак не влияет."

#. type: TP
#: man-pages/man2/personality.2:151
#, no-wrap
msgid "B<PER_ISCR4> (since Linux 1.2.0)"
msgstr "B<PER_ISCR4> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:156 man-pages/man2/personality.2:206
msgid "Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr "Подразумевает B<STICKY_TIMEOUTS>; в противном случае никак не влияет."

#. type: TP
#: man-pages/man2/personality.2:156
#, no-wrap
msgid "B<PER_LINUX> (since Linux 1.2.0)"
msgstr "B<PER_LINUX> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:159
msgid "Linux."
msgstr "Linux."

#. type: TP
#: man-pages/man2/personality.2:159
#, no-wrap
msgid "B<PER_LINUX32> (since Linux 2.2)"
msgstr "B<PER_LINUX32> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/personality.2:162 man-pages/man2/personality.2:193
msgid "[To be documented.]"
msgstr "[Будет описано.]"

#. type: TP
#: man-pages/man2/personality.2:162
#, no-wrap
msgid "B<PER_LINUX32_3GB> (since Linux 2.4)"
msgstr "B<PER_LINUX32_3GB> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man2/personality.2:166
msgid "Implies B<ADDR_LIMIT_3GB>."
msgstr "Подразумевает B<ADDR_LIMIT_3GB>."

#. type: TP
#: man-pages/man2/personality.2:166
#, no-wrap
msgid "B<PER_LINUX_32BIT> (since Linux 2.0)"
msgstr "B<PER_LINUX_32BIT> (начиная с Linux 2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:170
msgid "Implies B<ADDR_LIMIT_32BIT>."
msgstr "Подразумевает B<ADDR_LIMIT_32BIT>."

#. type: TP
#: man-pages/man2/personality.2:170
#, no-wrap
msgid "B<PER_LINUX_FDPIC> (since Linux 2.6.11)"
msgstr "B<PER_LINUX_FDPIC> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man2/personality.2:174
msgid "Implies B<FDPIC_FUNCPTRS>."
msgstr "Подразумевает B<FDPIC_FUNCPTRS>."

#. type: TP
#: man-pages/man2/personality.2:174
#, no-wrap
msgid "B<PER_OSF4> (since Linux 2.4)"
msgstr "B<PER_OSF4> (начиная с Linux 2.4)"

#.  Following is from a comment in arch/alpha/kernel/osf_sys.c
#. type: Plain text
#: man-pages/man2/personality.2:183
msgid ""
"OSF/1 v4.  On alpha, clear top 32 bits of iov_len in the user's buffer for "
"compatibility with old versions of OSF/1 where iov_len was defined as.  "
"I<int>."
msgstr ""
"OSF/1 v4. На alpha, очищает верхние 32 бита iov_len в пользовательском "
"буфере для совместимости со старыми версиями OSF/1, где iov_len определено "
"как I<int>."

#. type: TP
#: man-pages/man2/personality.2:183
#, no-wrap
msgid "B<PER_OSR5> (since Linux 2.4)"
msgstr "B<PER_OSR5> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man2/personality.2:190
msgid "Implies B<STICKY_TIMEOUTS> and B<WHOLE_SECONDS>; otherwise no effects."
msgstr ""
"Подразумевает B<STICKY_TIMEOUTS> и B<WHOLE_SECONDS>; в противном случае "
"никак не влияет."

#. type: TP
#: man-pages/man2/personality.2:190
#, no-wrap
msgid "B<PER_RISCOS> (since Linux 2.2)"
msgstr "B<PER_RISCOS> (начиная с Linux 2.2)"

#. type: TP
#: man-pages/man2/personality.2:193
#, no-wrap
msgid "B<PER_SCOSVR3> (since Linux 1.2.0)"
msgstr "B<PER_SCOSVR3> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:201
msgid ""
"Implies B<STICKY_TIMEOUTS>, B<WHOLE_SECONDS>, and B<SHORT_INODE>; otherwise "
"no effects."
msgstr ""
"Подразумевает B<STICKY_TIMEOUTS>, B<WHOLE_SECONDS> и B<SHORT_INODE>; в "
"противном случае никак не влияет."

#. type: TP
#: man-pages/man2/personality.2:201
#, no-wrap
msgid "B<PER_SOLARIS> (since Linux 2.4)"
msgstr "B<PER_SOLARIS> (начиная с Linux 2.4)"

#. type: TP
#: man-pages/man2/personality.2:206
#, no-wrap
msgid "B<PER_SUNOS> (since Linux 2.4.0)"
msgstr "B<PER_SUNOS> (начиная с Linux 2.4.0)"

#. type: Plain text
#: man-pages/man2/personality.2:214
msgid ""
"Implies B<STICKY_TIMEOUTS>.  Divert library and dynamic linker searches to "
"I</usr/gnemul>.  Buggy, largely unmaintained, and almost entirely unused; "
"support was removed in Linux 2.6.26."
msgstr ""
"Подразумевает B<STICKY_TIMEOUTS>. Библиотека отклонений и динамический "
"компоновщик ищутся в I</usr/gnemul>. Содержит ошибки, практически не "
"сопровождается и почти никем не используется; поддержка была удалена в Linux "
"2.6.26."

#. type: TP
#: man-pages/man2/personality.2:214
#, no-wrap
msgid "B<PER_SVR3> (since Linux 1.2.0)"
msgstr "B<PER_SVR3> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:221 man-pages/man2/personality.2:242
#: man-pages/man2/personality.2:249
msgid "Implies B<STICKY_TIMEOUTS> and B<SHORT_INODE>; otherwise no effects."
msgstr ""
"Подразумевает B<STICKY_TIMEOUTS> и B<SHORT_INODE>; в противном случае никак "
"не влияет."

#. type: TP
#: man-pages/man2/personality.2:221
#, no-wrap
msgid "B<PER_SVR4> (since Linux 1.2.0)"
msgstr "B<PER_SVR4> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:228 man-pages/man2/personality.2:235
msgid "Implies B<STICKY_TIMEOUTS> and B<MMAP_PAGE_ZERO>; otherwise no effects."
msgstr ""
"Подразумевает B<STICKY_TIMEOUTS> и B<MMAP_PAGE_ZERO>; в противном случае "
"никак не влияет."

#. type: TP
#: man-pages/man2/personality.2:228
#, no-wrap
msgid "B<PER_UW7> (since Linux 2.4)"
msgstr "B<PER_UW7> (начиная с Linux 2.4)"

#. type: TP
#: man-pages/man2/personality.2:235
#, no-wrap
msgid "B<PER_WYSEV386> (since Linux 1.2.0)"
msgstr "B<PER_WYSEV386> (начиная с Linux 1.2.0)"

#. type: TP
#: man-pages/man2/personality.2:242
#, no-wrap
msgid "B<PER_XENIX> (since Linux 1.2.0)"
msgstr "B<PER_XENIX> (начиная с Linux 1.2.0)"

#. type: Plain text
#: man-pages/man2/personality.2:256
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""
"При нормальном завершении работы возвращается предыдущее значение "
"I<persona>. При ошибке возвращается -1, а переменная I<errno>, "
"устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/personality.2:260
msgid "The kernel was unable to change the personality."
msgstr "Ядру не удалось изменить специализацию."

#.  personality wrapper first appeared in glibc 1.90,
#.  <sys/personality.h> was added later in 2.2.91.
#. type: Plain text
#: man-pages/man2/personality.2:266
msgid ""
"This system call first appeared in Linux 1.1.20 (and thus first in a stable "
"kernel release with Linux 1.2.0); library support was added in glibc 2.3."
msgstr ""
"Данный системный вызов впервые появился в Linux 1.1.20 (и, таким образом, в "
"первом стабильном выпуске ядра Linux 1.2.0); поддержка в glibc добавлена в "
"версии 2.3."

#. type: Plain text
#: man-pages/man2/personality.2:270
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"Вызов B<personality>() есть только в Linux, и он не должен использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man2/personality.2:271
msgid "B<setarch>(8)"
msgstr "B<setarch>(8)"

#. type: TH
#: man-pages/man2/pread.2:25
#, no-wrap
msgid "PREAD"
msgstr "PREAD"

#. type: Plain text
#: man-pages/man2/pread.2:28
msgid ""
"pread, pwrite - read from or write to a file descriptor at a given offset"
msgstr ""
"pread, pwrite - чтение или запись информации из файлового дескриптора "
"согласно заданному смещению"

#. type: Plain text
#: man-pages/man2/pread.2:33
msgid ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"
msgstr ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"

#. type: Plain text
#: man-pages/man2/pread.2:36
msgid ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"
msgstr ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"

#. type: Plain text
#: man-pages/man2/pread.2:46
msgid "B<pread>(), B<pwrite>():"
msgstr "B<pread>(), B<pwrite>():"

#. type: Plain text
#: man-pages/man2/pread.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man2/pread.2:50
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man2/pread.2:64
msgid ""
"B<pread>()  reads up to I<count> bytes from file descriptor I<fd> at offset "
"I<offset> (from the start of the file) into the buffer starting at I<buf>.  "
"The file offset is not changed."
msgstr ""
"B<pread>() читает максимум I<count> байтов из файлового дескриптора I<fd>, "
"начиная со смещения I<offset> (от начала файла), в буфер, начиная с I<buf>. "
"Текущая позиция файла не изменяется."

#. type: Plain text
#: man-pages/man2/pread.2:75
msgid ""
"B<pwrite>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file descriptor I<fd> at offset I<offset>.  The file offset is not "
"changed."
msgstr ""
"B<pwrite>() записывает максимум I<count> байтов из буфера I<buf> в файловый "
"дескриптор I<fd> , начиная со смещения I<offset>. Текущая позиция файла не "
"изменяется."

#. type: Plain text
#: man-pages/man2/pread.2:79
msgid "The file referenced by I<fd> must be capable of seeking."
msgstr "Файл, заданный в I<fd>, должен позволять изменение смещения."

#. type: Plain text
#: man-pages/man2/pread.2:87
msgid ""
"On success, B<pread>()  returns the number of bytes read (a return of zero "
"indicates end of file)  and B<pwrite>()  returns the number of bytes written."
msgstr ""
"При успешном выполнении B<pread>() возвращается количество считанных байт "
"(ноль указывает на конец файла), а B<pwrite>() — количество записанных байт."

#. type: Plain text
#: man-pages/man2/pread.2:93
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""
"Заметим, что для успешного выполнения не считается ошибкой передача меньшего "
"количества байт чем запрошено (смотрите B<read>(2) и B<write>(2))."

#. type: Plain text
#: man-pages/man2/pread.2:97
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error."
msgstr "При ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/pread.2:112
msgid ""
"B<pread>()  can fail and set I<errno> to any error specified for B<read>(2)  "
"or B<lseek>(2).  B<pwrite>()  can fail and set I<errno> to any error "
"specified for B<write>(2)  or B<lseek>(2)."
msgstr ""
"Вызов B<pread>() может завершиться неудачно и записать в I<errno> один из "
"кодов ошибки, определённых для B<read>(2) или B<lseek>(2). Вызов B<pwrite>() "
"может завершиться неудачно и записать в I<errno> один из кодов ошибки, "
"определённых для B<write>(2) или B<lseek>(2)."

#. type: Plain text
#: man-pages/man2/pread.2:123
msgid ""
"The B<pread>()  and B<pwrite>()  system calls were added to Linux in version "
"2.1.60; the entries in the i386 system call table were added in 2.1.69.  C "
"library support (including emulation using B<lseek>(2)  on older kernels "
"without the system calls) was added in glibc 2.1."
msgstr ""
"Системные вызовы B<pread>() и B<pwrite>() были внесены в ядро Linux, начиная "
"с версии 2.1.60; как элементы таблицы системных вызовов i386 были добавлены "
"в ядро версии 2.1.69. Поддержка в библиотеке С (включая эмуляцию с помощью "
"B<lseek>(2) в старых ядрах, не имеющих соответствующих системных вызовов) "
"была добавлена в glibc 2.1."

#. type: Plain text
#: man-pages/man2/pread.2:125
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/pread.2:134
msgid ""
"The B<pread>()  and B<pwrite>()  system calls are especially useful in "
"multithreaded applications.  They allow multiple threads to perform I/O on "
"the same file descriptor without being affected by changes to the file "
"offset by other threads."
msgstr ""
"Системные вызовы B<pread>() и B<pwrite>()  особенно полезны в многонитевых "
"приложениях. Они позволяют нескольким нитям выполнять ввод-вывод в один "
"файловый дескриптор не учитывая изменений файлового смещения, сделанного "
"другими нитями."

#. type: Plain text
#: man-pages/man2/pread.2:150
msgid ""
"On Linux, the underlying system calls were renamed in kernel 2.6: "
"B<pread>()  became B<pread64>(), and B<pwrite>()  became B<pwrite64>().  The "
"system call numbers remained the same.  The glibc B<pread>()  and "
"B<pwrite>()  wrapper functions transparently deal with the change."
msgstr ""
"В Linux нижележащие системные вызовы переименованы в ядре версии 2.6: "
"B<pread>() стал называться B<pread64>(), а B<pwrite>() \\(em B<pwrite64>(). "
"Номера системных вызовов остались прежними. Обёрточные функции B<pread>() и "
"B<pwrite>() в glibc скрывают данные переименование."

#. type: Plain text
#: man-pages/man2/pread.2:155
msgid ""
"On some 32-bit architectures, the calling signature for these system calls "
"differ, for the reasons described in B<syscall>(2)."
msgstr ""
"На некоторых 32-битных архитектурах интерфейс этих системных вызовов "
"отличается от описанного выше, по причинам указанным в B<syscall>(2)."

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=43178
#. type: Plain text
#: man-pages/man2/pread.2:167
msgid ""
"POSIX requires that opening a file with the B<O_APPEND> flag should have no "
"effect on the location at which B<pwrite>()  writes data.  However, on "
"Linux, if a file is opened with B<O_APPEND>, B<pwrite>()  appends data to "
"the end of the file, regardless of the value of I<offset>."
msgstr ""
"Согласно POSIX требуется, чтобы открытие файла с флагом B<O_APPEND> не "
"влияло на расположение, по которому B<pwrite>() записывает данные. Однако в "
"Linux, если файл открывается с флагом B<O_APPEND>, B<pwrite>() добавляет "
"данные в конец файла, независимо от значения I<offset>."

#. type: Plain text
#: man-pages/man2/pread.2:171
msgid "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"
msgstr "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"

#. type: TH
#: man-pages/man2/prctl.2:54
#, no-wrap
msgid "PRCTL"
msgstr "PRCTL"

#. type: Plain text
#: man-pages/man2/prctl.2:57
msgid "prctl - operations on a process"
msgstr "prctl - операции над процессом"

#. type: Plain text
#: man-pages/man2/prctl.2:60
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/prctl.2:63
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"

#. type: Plain text
#: man-pages/man2/prctl.2:71
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr ""
"Первый аргумент B<prctl>() задаёт тип операции (типы определены в "
"I<E<lt>linux/prctl.hE<gt>>, значения остальных аргументов зависят от "
"указываемого типа. Первый аргумент может принимать следующие значения:"

#. type: TP
#: man-pages/man2/prctl.2:71
#, no-wrap
msgid "B<PR_CAP_AMBIENT> (since Linux 4.3)"
msgstr "B<PR_CAP_AMBIENT> (начиная с Linux 4.3)"

#.  commit 58319057b7847667f0c9585b9de0e8932b0fdb08
#. type: Plain text
#: man-pages/man2/prctl.2:78
msgid ""
"Reads or changes the ambient capability set of the calling thread, according "
"to the value of I<arg2>, which must be one of the following:"
msgstr ""
"Читает или изменяет наружный набор мандатов вызывающей нити согласно "
"значению I<arg2>, которое должно быть одним из следующих:"

#. type: TP
#: man-pages/man2/prctl.2:80
#, no-wrap
msgid "B<PR_CAP_AMBIENT_RAISE>"
msgstr "B<PR_CAP_AMBIENT_RAISE>"

#. type: Plain text
#: man-pages/man2/prctl.2:90
msgid ""
"The capability specified in I<arg3> is added to the ambient set.  The "
"specified capability must already be present in both the permitted and the "
"inheritable sets of the process.  This operation is not permitted if the "
"B<SECBIT_NO_CAP_AMBIENT_RAISE> securebit is set."
msgstr ""
"Мандат, указанный в I<arg3>, добавляется в наружный набор. Указанный мандат "
"уже должен присутствовать в разрешающем и наследуемом наборе. Эта операция "
"неприменима, если установлен бит безопасности B<SECBIT_NO_CAP_AMBIENT_RAISE>."

#. type: TP
#: man-pages/man2/prctl.2:90
#, no-wrap
msgid "B<PR_CAP_AMBIENT_LOWER>"
msgstr "B<PR_CAP_AMBIENT_LOWER>"

#. type: Plain text
#: man-pages/man2/prctl.2:95
msgid "The capability specified in I<arg3> is removed from the ambient set."
msgstr "Мандат, указанный в I<arg3>, удаляется из наружного набора."

#. type: TP
#: man-pages/man2/prctl.2:95
#, no-wrap
msgid "B<PR_CAP_AMBIENT_IS_SET>"
msgstr "B<PR_CAP_AMBIENT_IS_SET>"

#. type: Plain text
#: man-pages/man2/prctl.2:102
msgid ""
"The B<prctl>()  call returns 1 if the capability in I<arg3> is in the "
"ambient set and 0 if it is not."
msgstr ""
"Вызов B<prctl>() возвращает 1, если мандат в I<arg3> присутствует в наружном "
"наборе и 0, если нет."

#. type: TP
#: man-pages/man2/prctl.2:102
#, no-wrap
msgid "B<PR_CAP_AMBIENT_CLEAR_ALL>"
msgstr "B<PR_CAP_AMBIENT_CLEAR_ALL>"

#. type: Plain text
#: man-pages/man2/prctl.2:108
msgid ""
"All capabilities will be removed from the ambient set.  This operation "
"requires setting I<arg3> to zero."
msgstr ""
"Все мандаты будут удалены из наружного набора. Для этой операции требуется "
"указать в I<arg3> значение 0."

#. type: Plain text
#: man-pages/man2/prctl.2:115
msgid ""
"In all of the above operations, I<arg4> and I<arg5> must be specified as 0."
msgstr ""
"Во всех перечисленных выше операциях значения I<arg4> и I<arg5> должны быть "
"равны 0."

#. type: Plain text
#: man-pages/man2/prctl.2:124
msgid ""
"Higher-level interfaces layered on top of the above operations are provided "
"in the B<libcap>(3)  library in the form of B<cap_get_ambient>(3), "
"B<cap_set_ambient>(3), and B<cap_reset_ambient>(3)."
msgstr ""
"Интерфейсы высокого уровня, построенные поверх описанных выше операций, "
"предоставляются в библиотеке B<libcap>(3) под именами B<cap_get_ambient>(3), "
"B<cap_set_ambient>(3) и B<cap_reset_ambient>(3)."

#. type: TP
#: man-pages/man2/prctl.2:124
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_READ> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man2/prctl.2:136
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to "
"B<execve>(2)."
msgstr ""
"Возвращает 1 (как результат функции), если мандат, указанный в I<arg2>, есть "
"в списке мандатов вызывающей нити (capability bounding set), или 0, если "
"нет. Константы мандатов определены в I<E<lt>linux/capability.hE<gt>>. "
"Значениями списка мандатов определяется, может ли процесс получить мандат "
"через установку набора файловых прав при последующем вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:141
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr ""
"Если мандат, указанный в I<arg2>, некорректен, то вызов завершится с ошибкой "
"B<EINVAL>."

#. type: Plain text
#: man-pages/man2/prctl.2:146
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_get_bound>(3)."
msgstr ""
"Интерфейс высокого уровня, построенный поверх описанной выше операции, "
"предоставляется в библиотеке B<libcap>() под именем B<cap_get_bound>(3)."

#. type: TP
#: man-pages/man2/prctl.2:146
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_DROP> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man2/prctl.2:155
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability within its user "
"namespace, then drop the capability specified by I<arg2> from the calling "
"thread's capability bounding set.  Any children of the calling thread will "
"inherit the newly reduced bounding set."
msgstr ""
"Если вызывающая нить имеет мандат B<CAP_SETPCAP> в своём пользовательском "
"пространстве имён, то мандат, указанный в I<arg2>, удаляется из списка "
"мандатов вызывающей нити. Любой потомок вызывающей нити унаследует новый "
"сокращённый список мандатов."

#. type: Plain text
#: man-pages/man2/prctl.2:167
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel, "
"in which case bounding sets are not supported."
msgstr ""
"Вызов завершается с ошибками: B<EPERM>, если вызывающая нить не имеет "
"мандата B<CAP_SETPCAP>; B<EINVAL>, если в I<arg2> указан недопустимый "
"мандат; B<EINVAL>, если файловые мандаты не включены в ядре, в этом случае "
"списки мандатов не поддерживаются."

#. type: Plain text
#: man-pages/man2/prctl.2:172
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_drop_bound>(3)."
msgstr ""
"Интерфейс высокого уровня, построенный поверх описанной выше операции, "
"предоставляется в библиотеке B<libcap>() под именем B<cap_drop_bound>(3)."

#. type: TP
#: man-pages/man2/prctl.2:172
#, no-wrap
msgid "B<PR_SET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr "B<PR_SET_CHILD_SUBREAPER> (начиная с Linux 3.4)"

#.  commit ebec18a6d3aa1e7d84aab16225e87fd25170ec2b
#. type: Plain text
#: man-pages/man2/prctl.2:182
msgid ""
"If I<arg2> is nonzero, set the \"child subreaper\" attribute of the calling "
"process; if I<arg2> is zero, unset the attribute."
msgstr ""
"Если значение I<arg2> не равно 0, то в вызвавшем процессе устанавливается "
"атрибут «сборщика потомков» (child subreaper); если значение I<arg2> равно "
"0, то атрибут удаляется."

#. type: Plain text
#: man-pages/man2/prctl.2:199
msgid ""
"A subreaper fulfills the role of B<init>(1)  for its descendant processes.  "
"When a process becomes orphaned (i.e., its immediate parent terminates), "
"then that process will be reparented to the nearest still living ancestor "
"subreaper.  Subsequently, calls to B<getppid>()  in the orphaned process "
"will now return the PID of the subreaper process, and when the orphan "
"terminates, it is the subreaper process that will receive a B<SIGCHLD> "
"signal and will be able to B<wait>(2)  on the process to discover its "
"termination status."
msgstr ""
"Сборщик потомков выполняет функцию B<init>(1) для своих потомков. При "
"завершении осиротевшего процесса (т. е., прямой предок уже завершил "
"выполнение), его родителем станет ближайший действующий сборщик-предок. "
"После этого вызов B<getppid>() в осиротевшем процессе будет возвращать PID "
"процесса-сборщика, и когда осиротевший процесс завершит работу, сборщик "
"получит сигнал B<SIGCHLD> и сможет запустить B<wait>(2) для получения "
"состояния завершения потомка."

#. type: Plain text
#: man-pages/man2/prctl.2:207
msgid ""
"The setting of the \"child subreaper\" attribute is not inherited by "
"children created by B<fork>(2)  and B<clone>(2).  The setting is preserved "
"across B<execve>(2)."
msgstr ""
"Установка атрибута «сборщика потомков» не наследуется потомками, "
"создаваемыми B<fork>(2) и B<clone>(2). Данное значение сохраняется после "
"B<execve>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:218
msgid ""
"Establishing a subreaper process is useful in session management frameworks "
"where a hierarchical group of processes is managed by a subreaper process "
"that needs to be informed when one of the processes\\(emfor example, a "
"double-forked daemon\\(emterminates (perhaps so that it can restart that "
"process).  Some B<init>(1)  frameworks (e.g., B<systemd>(1))  employ a "
"subreaper process for similar reasons."
msgstr ""
"Назначение процесса-сборщика полезно в инфраструктуре управления сеансами, "
"где иерархическая группа процессов управляется процессом-сборщиком, которому "
"нужно сообщать, когда один из процессов — например, служба, выполнившая "
"двойное создание (fork) — завершается (возможно для того, чтобы её можно "
"было перезапустить). Некоторые инфраструктуры B<init>(1) (например, "
"B<systemd>(1)) используют a процесс-сборщик для этих целей."

#. type: TP
#: man-pages/man2/prctl.2:218
#, no-wrap
msgid "B<PR_GET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr "B<PR_GET_CHILD_SUBREAPER> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/prctl.2:223
msgid ""
"Return the \"child subreaper\" setting of the caller, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""
"Возвращает значение атрибута «сборщика потомков» вызывающего в расположение, "
"указанное I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:223
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_SET_DUMPABLE> (начиная с Linux 2.3.20)"

#. type: Plain text
#: man-pages/man2/prctl.2:228
msgid ""
"Set the state of the \"dumpable\" flag, which determines whether core dumps "
"are produced for the calling process upon delivery of a signal whose default "
"behavior is to produce a core dump."
msgstr ""
"Установить состояние флага «дампа», определяющего создание файла core "
"вызывающего процесса после доставки сигнала, чьё поведение по умолчанию "
"вызывает создание файла core."

#.  commit abf75a5033d4da7b8a7e92321d74021d1fcfb502
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: man-pages/man2/prctl.2:250
msgid ""
"In kernels up to and including 2.6.12, I<arg2> must be either 0 "
"(B<SUID_DUMP_DISABLE>, process is not dumpable) or 1 (B<SUID_DUMP_USER>, "
"process is dumpable).  Between kernels 2.6.13 and 2.6.17, the value 2 was "
"also permitted, which caused any binary which normally would not be dumped "
"to be dumped readable by root only; for security reasons, this feature has "
"been removed.  (See also the description of I</proc/sys/fs/\\:suid_dumpable> "
"in B<proc>(5).)"
msgstr ""
"В ядрах по 2.6.12 включительно, значение I<arg2> должно быть равно 0 "
"(B<SUID_DUMP_DISABLE>, от процесса не остаётся дампа) или 1 "
"(B<SUID_DUMP_USER>, после процесса остаётся дамп). Между ядрами 2.6.13 и "
"2.6.17, также было разрешено значение 2, означающее что от любого "
"исполняемого файла, обычно дампа не остаётся, но суперпользователь может это "
"сделать; для улучшения безопасности эта возможность была удалена (смотрите "
"также описание I</proc/sys/fs/\\:suid_dumpable> в B<proc>(5))."

#.  See kernel/cred.c::commit_creds() (Linux 3.18 sources)
#. type: Plain text
#: man-pages/man2/prctl.2:257
msgid ""
"Normally, this flag is set to 1.  However, it is reset to the current value "
"contained in the file I</proc/sys/fs/\\:suid_dumpable> (which by default has "
"the value 0), in the following circumstances:"
msgstr ""
"Обычно, значение этого флага равно 1. Однако, оно сбрасывается в текущее "
"значение, содержащееся в файле I</proc/sys/fs/\\:suid_dumpable> (которое по "
"умолчанию равно 0), в следующих случаях:"

#. type: Plain text
#: man-pages/man2/prctl.2:260
msgid "The process's effective user or group ID is changed."
msgstr "Изменён эффективный идентификатор пользователя или группы процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:263
msgid ""
"The process's filesystem user or group ID is changed (see B<credentials>(7))."
msgstr ""
"Изменён процессный идентификатор пользователя или группы файловой системы "
"(смотрите B<credentials>(7))."

#. type: Plain text
#: man-pages/man2/prctl.2:268
msgid ""
"The process executes (B<execve>(2))  a set-user-ID or set-group-ID program, "
"resulting in a change of either the effective user ID or the effective group "
"ID."
msgstr ""
"Процесс выполняет (B<execve>(2)) программу с установленным битом set-user-ID "
"или set-group-ID, что приводит к изменению идентификатора эффективного "
"пользователя или эффективной группы."

#.  See kernel/cred.c::commit_creds()
#.  Also certain namespace operations;
#. type: Plain text
#: man-pages/man2/prctl.2:277
msgid ""
"The process executes (B<execve>(2))  a program that has file capabilities "
"(see B<capabilities>(7)), but only if the permitted capabilities gained "
"exceed those already permitted for the process."
msgstr ""
"Процесс выполняет (B<execve>(2)) программу, которая имеет файловые мандаты "
"(смотрите B<capabilities>(7)), но только если полученные разрешенные мандаты "
"превосходят уже разрешенные для процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:285
msgid ""
"Processes that are not dumpable can not be attached via B<ptrace>(2)  "
"B<PTRACE_ATTACH>; see B<ptrace>(2)  for further details."
msgstr ""
"Процессы, для которых невозможен дамп, нельзя присоединить через операцию "
"B<ptrace>2() B<PTRACE_ATTACH>; подробности смотрите в B<ptrace>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:291
msgid ""
"If a process is not dumpable, the ownership of files in the process's I</"
"proc/[pid]> directory is affected as described in B<proc>(5)."
msgstr ""
"Если для процесса невозможен дамп, то на владение файлами в каталоге "
"процесса I</proc/[pid]> действуют правила, описанные в B<proc>(5)."

#. type: TP
#: man-pages/man2/prctl.2:291
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_GET_DUMPABLE> (начиная с Linux 2.3.20)"

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#. type: Plain text
#: man-pages/man2/prctl.2:298
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable flag."
msgstr ""
"Возвращает (как результат функции) текущее состояние флага дампа вызывающего "
"процесса."

#. type: TP
#: man-pages/man2/prctl.2:298
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_SET_ENDIAN> (начиная с Linux 2.6.18, только для PowerPC)"

#.  Respectively 0, 1, 2
#. type: Plain text
#: man-pages/man2/prctl.2:308
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr ""
"Устанавливает порядок байт вызывающего процесса равным значению I<arg2>, "
"которое может быть одним из: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE> или "
"B<PR_ENDIAN_PPC_LITTLE> (для PowerPC псевдо обратный порядок (pseudo little "
"endian))."

#. type: TP
#: man-pages/man2/prctl.2:308
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_GET_ENDIAN> (начиная с Linux 2.6.18, только для PowerPC)"

#. type: Plain text
#: man-pages/man2/prctl.2:313
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""
"Записывает значение порядка байт вызывающего процесса по адресу, указанному "
"в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:313
#, no-wrap
msgid "B<PR_SET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr "B<PR_SET_FP_MODE> (начиная с Linux 4.0, только на MIPS)"

#.  commit 9791554b45a2acc28247f66a5fd5bbc212a6b8c8
#. type: Plain text
#: man-pages/man2/prctl.2:325
msgid ""
"On the MIPS architecture, user-space code can be built using an ABI which "
"permits linking with code that has more restrictive floating-point (FP) "
"requirements.  For example, user-space code may be built to target the O32 "
"FPXX ABI and linked with code built for either one of the more restrictive "
"FP32 or FP64 ABIs.  When more restrictive code is linked in, the overall "
"requirement for the process is to use the more restrictive floating-point "
"mode."
msgstr ""
"На архитектуре MIPS код пользовательского пространства можно собирать "
"используя ABI, который позволяет компоновку с кодом, имеющем более "
"ограничительные требования для плавающей запятой (FP). Например, код "
"пользовательского пространства может собираться для цели O32 FPXX ABI и "
"компоноваться с кодом, собранным с одним из более ограничительных FP32 или "
"FP64 ABI. При этом требование всего процесса устанавливается в более "
"ограничительный режим плавающей запятой."

#. type: Plain text
#: man-pages/man2/prctl.2:333
msgid ""
"Because the kernel has no means of knowing in advance which mode the process "
"should be executed in, and because these restrictions can change over the "
"lifetime of the process, the B<PR_SET_FP_MODE> operation is provided to "
"allow control of the floating-point mode from user space."
msgstr ""
"Так как ядро не знает в каком режиме должен запускаться процесс и "
"ограничения могут измениться во время работы процесса, создана операция "
"B<PR_SET_FP_MODE>, позволяющая контролировать режим плавающей запятой из "
"пользовательского пространства."

#.  https://dmz-portal.mips.com/wiki/MIPS_O32_ABI_-_FR0_and_FR1_Interlinking
#. type: Plain text
#: man-pages/man2/prctl.2:338
msgid ""
"The I<(unsigned int) arg2> argument is a bit mask describing the floating-"
"point mode used:"
msgstr ""
"В аргументе I<(unsigned int) arg2> указывается битовая маска, описывающая "
"используемый режим плавающей запятой:"

#. type: TP
#: man-pages/man2/prctl.2:339
#, no-wrap
msgid "B<PR_FP_MODE_FR>"
msgstr "B<PR_FP_MODE_FR>"

#. type: Plain text
#: man-pages/man2/prctl.2:350
msgid ""
"When this bit is I<unset> (so called B<FR=0> or B<FR0> mode), the 32 "
"floating-point registers are 32 bits wide, and 64-bit registers are "
"represented as a pair of registers (even- and odd- numbered, with the even-"
"numbered register containing the lower 32 bits, and the odd-numbered "
"register containing the higher 32 bits)."
msgstr ""
"Если это бит I<сброшен> (так называемый режим B<FR=0> или B<FR0>), то ширина "
"32 регистров плавающей запятой равна 32, а 64-битные регистры представляются "
"в виде пары регистров (с чётными и нечётными номерами; регистры с чётными "
"номерами содержат 32 младших бита, а с нечётными номерами 32 старших бита)."

#. type: Plain text
#: man-pages/man2/prctl.2:360
msgid ""
"When this bit is I<set> (on supported hardware), the 32 floating-point "
"registers are 64 bits wide (so called B<FR=1> or B<FR1> mode).  Note that "
"modern MIPS implementations (MIPS R6 and newer) support B<FR=1> mode only."
msgstr ""
"Если этот бит I<установлен> (есть поддержка в оборудовании), то ширина 32 "
"регистров плавающей запятой равна 64 (так называемый режим B<FR=1> или "
"B<FR1>). Заметим, что современные реализации MIPS (MIPS R6 и новее) "
"поддерживают только режим B<FR=1>."

#. type: Plain text
#: man-pages/man2/prctl.2:376
msgid ""
"Applications that use the O32 FP32 ABI can operate only when this bit is "
"I<unset> (B<FR=0>; or they can be used with FRE enabled, see below).  "
"Applications that use the O32 FP64 ABI (and the O32 FP64A ABI, which exists "
"to provide the ability to operate with existing FP32 code; see below)  can "
"operate only when this bit is I<set> (B<FR=1>).  Applications that use the "
"O32 FPXX ABI can operate with either B<FR=0> or B<FR=1>."
msgstr ""
"Приложения, использующие O32 FP32 ABI, могут работать только когда этот бит "
"I<сброшен> (B<FR=0>; или они могут использоваться с включённым FRE, смотрите "
"ниже). Приложения, использующие O32 FP64 ABI (и O32 FP64A ABI, существующий "
"для предоставления возможности работы с существующим кодом FP32; смотрите "
"ниже), могут работать только когда этот бит I<установлен> (B<FR=1>). "
"Приложения, использующие O32 FPXX ABI, могут работать и с B<FR=0> и с "
"B<FR=1>."

#. type: TP
#: man-pages/man2/prctl.2:376
#, no-wrap
msgid "B<PR_FP_MODE_FRE>"
msgstr "B<PR_FP_MODE_FRE>"

#. type: Plain text
#: man-pages/man2/prctl.2:397
msgid ""
"Enable emulation of 32-bit floating-point mode.  When this mode is enabled, "
"it emulates 32-bit floating-point operations by raising a reserved-"
"instruction exception on every instruction that uses 32-bit formats and the "
"kernel then handles the instruction in software.  (The problem lies in the "
"discrepancy of handling odd-numbered registers which are the high 32 bits of "
"64-bit registers with even numbers in B<FR=0> mode and the lower 32-bit "
"parts of odd-numbered 64-bit registers in B<FR=1> mode.)  Enabling this bit "
"is necessary when code with the O32 FP32 ABI should operate with code with "
"compatible the O32 FPXX or O32 FP64A ABIs (which require B<FR=1> FPU mode) "
"or when it is executed on newer hardware (MIPS R6 onwards)  which lacks "
"B<FR=0> mode support when a binary with the FP32 ABI is used."
msgstr ""
"Включает эмуляцию 32-битного режима плавающей запятой. Когда этот режим "
"включён, эмуляция 32-битных операций с плавающей запятой выполняется "
"генерацией исключения на каждую инструкцию, использующую 32-битный формат, и "
"ядро обрабатывает инструкцию программно (проблема заключается в "
"несоответствии обработке регистров с нечётными номерами, которые содержатся "
"в 32 старших битах 64-битных регистров с чётными номерами при режиме B<FR=0> "
"и в 32 младших битах 64-битах регистров с нечётными номерами при режиме "
"B<FR=1>). При включении этого бита необходимо, чтобы код с O32 FP32 ABI "
"работал с кодом O32 FPXX или O32 FP64A ABI (для которого требуется режим "
"B<FR=1> FPU) или когда он выполняется на новой аппаратуре (MIPS R6 и новее), "
"в которой нет поддержки режима B<FR=0>, когда используется двоичный файл с "
"FP32 ABI."

#. type: Plain text
#: man-pages/man2/prctl.2:400
msgid ""
"Note that this mode makes sense only when the FPU is in 64-bit mode "
"(B<FR=1>)."
msgstr ""
"Заметим, что этот режим приобретает смысл только, если FPU в 64-битном "
"режиме (B<FR=1>)."

#. type: Plain text
#: man-pages/man2/prctl.2:403
msgid ""
"Note that the use of emulation inherently has a significant performance hit "
"and should be avoided if possible."
msgstr ""
"Также заметим, что использование эмуляции по определению уменьшает "
"производительность и её нужно, по возможности, избегать."

#. type: Plain text
#: man-pages/man2/prctl.2:409
msgid ""
"In the N32/N64 ABI, 64-bit floating-point mode is always used, so FPU "
"emulation is not required and the FPU always operates in B<FR=1> mode."
msgstr ""
"В N32/N64 ABI всегда используется 64-битный режим плавающей запятой, поэтому "
"эмуляция FPU не требуется и FPU всегда работает в режиме B<FR=1>."

#. type: Plain text
#: man-pages/man2/prctl.2:412
msgid ""
"This option is mainly intended for use by the dynamic linker (B<ld.so>(8))."
msgstr ""
"Данный параметр, в основном, предназначен для динамического компоновщика "
"(B<ld.so>(8))."

#. type: Plain text
#: man-pages/man2/prctl.2:419
msgid "The arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr "Аргументы I<arg3>, I<arg4> и I<arg5> игнорируются."

#. type: TP
#: man-pages/man2/prctl.2:419
#, no-wrap
msgid "B<PR_GET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr "B<PR_GET_FP_MODE> (начиная с Linux 4.0, только на MIPS)"

#. type: Plain text
#: man-pages/man2/prctl.2:424
msgid ""
"Get the current floating-point mode (see the description of "
"B<PR_SET_FP_MODE> for details)."
msgstr ""
"Возвращает текущий режим плавающей запятой (смотрите описание "
"B<PR_SET_FP_MODE>)."

#. type: Plain text
#: man-pages/man2/prctl.2:427
msgid ""
"On success, the call returns a bit mask which represents the current "
"floating-point mode."
msgstr ""
"При успешном выполнении возвращается битовая маска, представляющая текущий "
"режим плавающей запятой."

#. type: Plain text
#: man-pages/man2/prctl.2:435
msgid "The arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr "Аргументы I<arg2>, I<arg3>, I<arg4> и I<arg5> игнорируются."

#. type: TP
#: man-pages/man2/prctl.2:435
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_SET_FPEMU> (начиная с Linux 2.4.18, 2.5.9, только для ia64)"

#. type: Plain text
#: man-pages/man2/prctl.2:445
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate floating-point operation accesses, "
"or B<PR_FPEMU_SIGFPE> to not emulate floating-point operations and send "
"B<SIGFPE> instead."
msgstr ""
"Устанавливает значение управляющих эмуляцией плавающей точки бит равным "
"значению I<arg2>. Для негласной (silently) эмуляции операций с плавающей "
"точкой передайте B<PR_FPEMU_NOPRINT>; при указании B<PR_FPEMU_SIGFPE> "
"операции с плавающей точкой не эмулируются, а посылается сигнал B<SIGFPE>."

#. type: TP
#: man-pages/man2/prctl.2:445
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_GET_FPEMU> (начиная с Linux 2.4.18, 2.5.9, только для ia64)"

#. type: Plain text
#: man-pages/man2/prctl.2:450
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""
"Записывает значение управляющих бит эмуляции плавающей точки по адресу, "
"указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:450
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_SET_FPEXC> (начиная с Linux 2.4.21, 2.5.32, только для PowerPC)"

#. type: Plain text
#: man-pages/man2/prctl.2:463
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for floating-"
"point inexact result, B<PR_FP_EXC_INV> for floating-point invalid operation, "
"B<PR_FP_EXC_DISABLED> for FP exceptions disabled, B<PR_FP_EXC_NONRECOV> for "
"async nonrecoverable exception mode, B<PR_FP_EXC_ASYNC> for async "
"recoverable exception mode, B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr ""
"Устанавливает режим исключений плавающей точки равным I<arg2>. Значение "
"B<PR_FP_EXC_SW_ENABLE> включает использование FPEXC для исключений плавающей "
"точки, B<PR_FP_EXC_DIV> \\(em исключение деления на ноль, B<PR_FP_EXC_OVF> "
"\\(em исключение переполнения, B<PR_FP_EXC_UND> \\(em исключение исчерпания, "
"B<PR_FP_EXC_RES> \\(em исключение неточного результата, B<PR_FP_EXC_INV> "
"\\(em исключение недопустимой операции, B<PR_FP_EXC_DISABLED> отключает "
"исключения плавающей точки, B<PR_FP_EXC_NONRECOV> включает режим "
"асинхронного невосстанавливаемого исключения, B<PR_FP_EXC_ASYNC> включает "
"режим асинхронного восстанавливаемого исключения, B<PR_FP_EXC_PRECISE> "
"включает режим исключения точности."

#. type: TP
#: man-pages/man2/prctl.2:463
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_GET_FPEXC> (начиная с Linux 2.4.21, 2.5.32, только для PowerPC)"

#. type: Plain text
#: man-pages/man2/prctl.2:468
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""
"Записывает значение режима исключений плавающей точки по адресу, указанному "
"в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:468
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_SET_KEEPCAPS> (начиная с Linux 2.2.18)"

#. type: Plain text
#: man-pages/man2/prctl.2:478
msgid ""
"Set the state of the calling thread's \"keep capabilities\" flag.  The "
"effect of this flag is described in B<capabilities>(7).  I<arg2> must be "
"either 0 (clear the flag)  or 1 (set the flag).  The \"keep capabilities\" "
"value will be reset to 0 on subsequent calls to B<execve>(2)."
msgstr ""
"Устанавливает флаг вызывающей нити «оставить мандаты». Этот флаг описан в "
"B<capabilities>(7). Значение I<arg2> должно быть или 0 (сбросить флаг) или 1 "
"(установить флаг). Значение флага «оставить мандаты» будет сброшено в 0 при "
"последующих вызовах B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:478
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_GET_KEEPCAPS> (начиная с Linux 2.2.18)"

#. type: Plain text
#: man-pages/man2/prctl.2:485
msgid ""
"Return (as the function result) the current state of the calling thread's "
"\"keep capabilities\" flag.  See B<capabilities>(7)  for a description of "
"this flag."
msgstr ""
"Возвращает (как результат функции) текущее состояние флага «оставить "
"мандаты» вызывающей нити. Описание флага смотрите в B<capabilities>(7)."

#. type: TP
#: man-pages/man2/prctl.2:485
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/prctl.2:525
msgid ""
"Set the machine check memory corruption kill policy for the calling thread.  "
"If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption kill "
"policy and use the system-wide default.  (The system-wide default is defined "
"by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If I<arg2> "
"is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill policy.  "
"In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the system-"
"wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the thread "
"receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is killed "
"only when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr ""
"Устанавливает политику удаления (kill) при обнаружении повреждения памяти "
"машинной проверкой для вызывающей нити. Если значение I<arg> равно "
"B<PR_MCE_KILL_CLEAR>, то политика удаления (kill) сбрасывается и "
"используется системная установка по умолчанию. (Значение системной установки "
"по умолчанию определено в I</proc/sys/vm/memory_failure_early_kill>; "
"смотрите B<proc>(5).) Значение I<arg2>, равное B<PR_MCE_KILL_SET>, указывает "
"использовать политику удаления, заданную в нити. В этом случае значение "
"I<arg3> определяет политику: I<раннее удаление> (B<PR_MCE_KILL_EARLY>), "
"I<позднее удаление> (B<PR_MCE_KILL_LATE>) или системная установка по "
"умолчанию (B<PR_MCE_KILL_DEFAULT>). При раннем удалении нить получает сигнал "
"B<SIGBUS> сразу же при аппаратном обнаружении повреждения памяти в её "
"адресном пространстве. В режиме позднего удаления процесс будет удалён "
"только когда обратится к повреждённой странице. Более подробную информацию о "
"сигнале B<SIGBUS> смотрите в I<sigaction(2)>. Политика наследуется "
"потомками. Значения остальных неиспользуемых аргументов B<prctl>() должны "
"быть равны нулю для совместимости в будущем."

#. type: TP
#: man-pages/man2/prctl.2:525
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL_GET> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/prctl.2:531
msgid ""
"Return the current per-process machine check kill policy.  All unused "
"B<prctl>()  arguments must be zero."
msgstr ""
"Возвращает значение политики удаления при машинной проверке для текущего "
"процесса. Значения всех неиспользуемых аргументов B<prctl>() должны быть "
"равны нулю."

#. type: TP
#: man-pages/man2/prctl.2:531
#, no-wrap
msgid "B<PR_SET_MM> (since Linux 3.3)"
msgstr "B<PR_SET_MM> (начиная с Linux 3.3)"

#.  commit 028ee4be34a09a6d48bdf30ab991ae933a7bc036
#. type: Plain text
#: man-pages/man2/prctl.2:541
msgid ""
"Modify certain kernel memory map descriptor fields of the calling process.  "
"Usually these fields are set by the kernel and dynamic loader (see B<ld."
"so>(8)  for more information) and a regular application should not use this "
"feature.  However, there are cases, such as self-modifying programs, where a "
"program might find it useful to change its own memory map."
msgstr ""
"Изменяет определённые поля дескриптора карты памяти ядра вызывающего "
"процесса. Обычно, значения этих полей задаются ядром или динамическим "
"загрузчиком (подробней смотрите B<ld.so>(8)), и обычные приложения не должны "
"использовать эту возможность. Однако, есть случаи (самоизменяющиеся "
"программы), где для программы может оказаться полезным изменение своей карты "
"памяти."

#. type: Plain text
#: man-pages/man2/prctl.2:555
msgid ""
"The calling process must have the B<CAP_SYS_RESOURCE> capability.  The value "
"in I<arg2> is one of the options below, while I<arg3> provides a new value "
"for the option.  The I<arg4> and I<arg5> arguments must be zero if unused."
msgstr ""
"Вызывающий процесс должен иметь мандат B<CAP_SYS_RESOURCE>. Значения "
"аргумента I<arg2> описаны далее, а в I<arg3> задаётся новое значение."
"Аргументы, I<arg4> и I<arg5>, если не используются, должны быть равно нулю."

#.  commit 52b3694157e3aa6df871e283115652ec6f2d31e0
#. type: Plain text
#: man-pages/man2/prctl.2:561
msgid ""
"Before Linux 3.10, this feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""
"До Linux 3.10 эта возможность доступна только, если ядро собрано с "
"параметром B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man2/prctl.2:562
#, no-wrap
msgid "B<PR_SET_MM_START_CODE>"
msgstr "B<PR_SET_MM_START_CODE>"

#. type: Plain text
#: man-pages/man2/prctl.2:571
msgid ""
"Set the address above which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable "
"(see B<mprotect>(2)  and B<mmap>(2)  for more information)."
msgstr ""
"Устанавливает адрес памяти, выше которого располагается код программы, "
"который может выполняться. Соответствующая область памяти должна быть "
"доступна на чтение и выполнение, но не на запись или быть общедоступной "
"(подробности смотрите в B<mprotect>(2) и B<mmap>(2))."

#. type: TP
#: man-pages/man2/prctl.2:571
#, no-wrap
msgid "B<PR_SET_MM_END_CODE>"
msgstr "B<PR_SET_MM_END_CODE>"

#. type: Plain text
#: man-pages/man2/prctl.2:576
msgid ""
"Set the address below which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable."
msgstr ""
"Устанавливает адрес памяти, ниже которого располагается код программы, "
"который может выполняться. Соответствующая область памяти должна быть "
"доступна на чтение и выполнение, но не на запись или быть общедоступной."

#. type: TP
#: man-pages/man2/prctl.2:576
#, no-wrap
msgid "B<PR_SET_MM_START_DATA>"
msgstr "B<PR_SET_MM_START_DATA>"

#. type: Plain text
#: man-pages/man2/prctl.2:582
msgid ""
"Set the address above which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""
"Устанавливает адрес памяти, выше которого располагаются инициализированные и "
"не инициализированные (bss) данные. Соответствующая область памяти должна "
"быть доступна на чтение и запись, но не на выполнение или быть в общем "
"доступе."

#. type: TP
#: man-pages/man2/prctl.2:582
#, no-wrap
msgid "B<PR_SET_MM_END_DATA>"
msgstr "B<PR_SET_MM_END_DATA>"

#. type: Plain text
#: man-pages/man2/prctl.2:588
msgid ""
"Set the address below which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""
"Устанавливает адрес памяти, ниже которого располагаются инициализированные и "
"не инициализированные (bss) данные. Соответствующая область памяти должна "
"быть доступна на чтение и запись, но не на выполнение или быть в общем "
"доступе."

#. type: TP
#: man-pages/man2/prctl.2:588
#, no-wrap
msgid "B<PR_SET_MM_START_STACK>"
msgstr "B<PR_SET_MM_START_STACK>"

#. type: Plain text
#: man-pages/man2/prctl.2:592
msgid ""
"Set the start address of the stack.  The corresponding memory area must be "
"readable and writable."
msgstr ""
"Устанавливает начальный адрес стека. Соответствующая область памяти должна "
"быть доступна на чтение и запись."

#. type: TP
#: man-pages/man2/prctl.2:592
#, no-wrap
msgid "B<PR_SET_MM_START_BRK>"
msgstr "B<PR_SET_MM_START_BRK>"

#. type: Plain text
#: man-pages/man2/prctl.2:604
msgid ""
"Set the address above which the program heap can be expanded with B<brk>(2)  "
"call.  The address must be greater than the ending address of the current "
"program data segment.  In addition, the combined size of the resulting heap "
"and the size of the data segment can't exceed the B<RLIMIT_DATA> resource "
"limit (see B<setrlimit>(2))."
msgstr ""
"Устанавливает адрес памяти, выше которого можно расширять программную кучу с "
"помощью вызова B<brk>(2). Адрес должен быть больше конечного адреса текущего "
"программного сегмента данных. Также, суммарный размер полученной кучи и "
"сегмента данных не может превышать ограничитель ресурса B<RLIMIT_DATA> "
"(смотрите B<setrlimit>(2))."

#. type: TP
#: man-pages/man2/prctl.2:604
#, no-wrap
msgid "B<PR_SET_MM_BRK>"
msgstr "B<PR_SET_MM_BRK>"

#. type: Plain text
#: man-pages/man2/prctl.2:612
msgid ""
"Set the current B<brk>(2)  value.  The requirements for the address are the "
"same as for the B<PR_SET_MM_START_BRK> option."
msgstr ""
"Устанавливает текущее значение B<brk>(2). Требования к адресу те же, что и в "
"параметре B<PR_SET_MM_START_BRK>."

#.  commit fe8c7f5cbf91124987106faa3bdf0c8b955c4cf7
#. type: Plain text
#: man-pages/man2/prctl.2:615
msgid "The following options are available since Linux 3.5."
msgstr "Начиная с Linux 3.5 доступны следующие параметры:"

#. type: TP
#: man-pages/man2/prctl.2:615
#, no-wrap
msgid "B<PR_SET_MM_ARG_START>"
msgstr "B<PR_SET_MM_ARG_START>"

#. type: Plain text
#: man-pages/man2/prctl.2:618
msgid "Set the address above which the program command line is placed."
msgstr "Задаёт адрес, выше которого размещена командная строка программы."

#. type: TP
#: man-pages/man2/prctl.2:618
#, no-wrap
msgid "B<PR_SET_MM_ARG_END>"
msgstr "B<PR_SET_MM_ARG_END>"

#. type: Plain text
#: man-pages/man2/prctl.2:621
msgid "Set the address below which the program command line is placed."
msgstr "Задаёт адрес, ниже которого размещена командная строка программы."

#. type: TP
#: man-pages/man2/prctl.2:621
#, no-wrap
msgid "B<PR_SET_MM_ENV_START>"
msgstr "B<PR_SET_MM_ENV_START>"

#. type: Plain text
#: man-pages/man2/prctl.2:624
msgid "Set the address above which the program environment is placed."
msgstr "Задаёт адрес, выше которого размещено окружение программы."

#. type: TP
#: man-pages/man2/prctl.2:624
#, no-wrap
msgid "B<PR_SET_MM_ENV_END>"
msgstr "B<PR_SET_MM_ENV_END>"

#. type: Plain text
#: man-pages/man2/prctl.2:627
msgid "Set the address below which the program environment is placed."
msgstr "Задаёт адрес, ниже которого размещено окружение программы."

#. type: Plain text
#: man-pages/man2/prctl.2:640
msgid ""
"The address passed with B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, "
"B<PR_SET_MM_ENV_START>, and B<PR_SET_MM_ENV_END> should belong to a process "
"stack area.  Thus, the corresponding memory area must be readable, writable, "
"and (depending on the kernel configuration) have the B<MAP_GROWSDOWN> "
"attribute set (see B<mmap>(2))."
msgstr ""
"Адрес, передаваемый с B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, "
"B<PR_SET_MM_ENV_START> и B<PR_SET_MM_ENV_END>, должен принадлежать области "
"стека процесса. То есть, соответствующая память должна быть доступна на "
"чтение, запись и (в зависимости от настройки ядра) у неё должен быть "
"установлен атрибут B<MAP_GROWSDOWN> (смотрите B<mmap>(2))."

#. type: TP
#: man-pages/man2/prctl.2:640
#, no-wrap
msgid "B<PR_SET_MM_AUXV>"
msgstr "B<PR_SET_MM_AUXV>"

#. type: Plain text
#: man-pages/man2/prctl.2:649
msgid ""
"Set a new auxiliary vector.  The I<arg3> argument should provide the address "
"of the vector.  The I<arg4> is the size of the vector."
msgstr ""
"Задаёт новый вспомогательный вектор (auxiliary vector). В аргументе I<arg3> "
"должен передаваться адрес вектора. В аргументе I<arg4> — размер вектора."

#. type: TP
#: man-pages/man2/prctl.2:649
#, no-wrap
msgid "B<PR_SET_MM_EXE_FILE>"
msgstr "B<PR_SET_MM_EXE_FILE>"

#.  commit b32dfe377102ce668775f8b6b1461f7ad428f8b6
#. type: Plain text
#: man-pages/man2/prctl.2:661
msgid ""
"Supersede the I</proc/pid/exe> symbolic link with a new one pointing to a "
"new executable file identified by the file descriptor provided in I<arg3> "
"argument.  The file descriptor should be obtained with a regular B<open>(2)  "
"call."
msgstr ""
"Заменяет символьную ссылку I</proc/pid/exe> новой, указывающей на новый "
"исполняемый файл, задаваемый файловым дескриптором в аргументе I<arg3>. "
"Файловый дескриптор должен быть получен с помощью обычного вызова B<open>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:668
msgid ""
"To change the symbolic link, one needs to unmap all existing executable "
"memory areas, including those created by the kernel itself (for example the "
"kernel usually creates at least one executable memory area for the ELF I<."
"text> section)."
msgstr ""
"Для изменения символьной ссылки необходимо отключить (unmap) все "
"существующие исполняемые области памяти, включая созданные самим ядром "
"(например, ядро, обычно, создаёт, как минимум, исполняемую область памяти "
"для раздела ELF I<.text>)."

#.  commit 3fb4afd9a504c2386b8435028d43283216bf588e
#. type: Plain text
#: man-pages/man2/prctl.2:679
msgid ""
"In Linux 4.9 and earlier, the B<PR_SET_MM_EXE_FILE> operation can be "
"performed only once in a process's lifetime; attempting to perform the "
"operation a second time results in the error B<EPERM>.  This restriction was "
"enforced for security reasons that were subsequently deemed specious, and "
"the restriction was removed in Linux 4.10 because some user-space "
"applications needed to perform this operation more than once."
msgstr ""
"В Linux 4.9 и старее операцию B<PR_SET_MM_EXE_FILE> можно выполнить только "
"один раз за время существования процесса; повторная попытка выполнения "
"приводит к ошибке B<EPERM>. Это ограничение было введено по причинам "
"безопасности, которые впоследствии стали излишними, и ограничение было "
"удалено в Linux 4.10, так как некоторым приложениям пользовательского "
"пространства требуется выполнять эту операцию более одного раза."

#.  commit f606b77f1a9e362451aca8f81d8f36a3a112139e
#. type: Plain text
#: man-pages/man2/prctl.2:682
msgid "The following options are available since Linux 3.18."
msgstr "Начиная с Linux 3.18 доступны следующие параметры:"

#. type: TP
#: man-pages/man2/prctl.2:682
#, no-wrap
msgid "B<PR_SET_MM_MAP>"
msgstr "B<PR_SET_MM_MAP>"

#. type: Plain text
#: man-pages/man2/prctl.2:690
msgid ""
"Provides one-shot access to all the addresses by passing in a I<struct "
"prctl_mm_map> (as defined in I<E<lt>linux/prctl.hE<gt>>).  The I<arg4> "
"argument should provide the size of the struct."
msgstr ""
"Предоставляет однократный доступ ко всем адресам, переданным в I<struct "
"prctl_mm_map> (определена в I<E<lt>linux/prctl.hE<gt>>). В аргументе I<arg4> "
"должен указываться размер структуры."

#. type: Plain text
#: man-pages/man2/prctl.2:694 man-pages/man2/prctl.2:707
msgid ""
"This feature is available only if the kernel is built with the "
"B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""
"Эта возможность доступна только, если ядро собрано с параметром "
"B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man2/prctl.2:694
#, no-wrap
msgid "B<PR_SET_MM_MAP_SIZE>"
msgstr "B<PR_SET_MM_MAP_SIZE>"

#. type: Plain text
#: man-pages/man2/prctl.2:703
msgid ""
"Returns the size of the I<struct prctl_mm_map> the kernel expects.  This "
"allows user space to find a compatible struct.  The I<arg4> argument should "
"be a pointer to an unsigned int."
msgstr ""
"Возвращает размер I<struct prctl_mm_map>, который ожидает ядро. Это "
"позволяет пользователю подобрать совместимую структуру. Аргумент I<arg4> "
"должен быть указателем на unsigned int."

#. type: TP
#: man-pages/man2/prctl.2:708
#, no-wrap
msgid "B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (since Linux 3.19) "
msgstr "B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (начиная с Linux 3.19)"

#.  commit fe3d197f84319d3bce379a9c0dc17b1f48ad358c
#.  See also http://lwn.net/Articles/582712/
#.  See also https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler
#.  commit e9d1b4f3c60997fe197bf0243cb4a41a44387a88
#. type: Plain text
#: man-pages/man2/prctl.2:723
msgid ""
"Enable or disable kernel management of Memory Protection eXtensions (MPX)  "
"bounds tables.  The I<arg2>, I<arg3>, I<arg4>, and I<arg5> arguments must be "
"zero."
msgstr ""
"Включает или выключает управление таблицами границ Memory Protection "
"eXtensions (MPX) из ядра. Аргументы I<arg2>, I<arg3>, I<arg4> и I<arg5> "
"должны быть равно 0."

#. type: Plain text
#: man-pages/man2/prctl.2:736
msgid ""
"MPX is a hardware-assisted mechanism for performing bounds checking on "
"pointers.  It consists of a set of registers storing bounds information and "
"a set of special instruction prefixes that tell the CPU on which "
"instructions it should do bounds enforcement.  There is a limited number of "
"these registers and when there are more pointers than registers, their "
"contents must be \"spilled\" into a set of tables.  These tables are called "
"\"bounds tables\" and the MPX B<prctl>()  operations control whether the "
"kernel manages their allocation and freeing."
msgstr ""
"MPX — полуаппаратный механизм проверки границ указателей. Он состоит из "
"набора регистров, хранящих информацию о границах и наборе специальных "
"префиксов инструкций, которые указывают ЦП, в каких инструкциях нужно "
"проверить границы. Число регистров ограничено и когда указателей становится "
"больше чем регистров, их содержимое нужно «засыпать» в набор таблиц. Эти "
"таблицы называются «таблицами границ» (bounds tables), а для управления их "
"заполнением и освобождением из ядра существуют операции MPX B<prctl>()."

#. type: Plain text
#: man-pages/man2/prctl.2:746
msgid ""
"When management is enabled, the kernel will take over allocation and freeing "
"of the bounds tables.  It does this by trapping the #BR exceptions that "
"result at first use of missing bounds tables and instead of delivering the "
"exception to user space, it allocates the table and populates the bounds "
"directory with the location of the new table.  For freeing, the kernel "
"checks to see if bounds tables are present for memory which is not "
"allocated, and frees them if so."
msgstr ""
"Когда управление разрешено, ядро начинает следить за выделением и "
"освобождением таблиц границ. Это делается через ловлю исключений #BR, "
"которые возникают при первом использовании отсутствующей таблицы границ и в "
"результате доставляется исключение в пользовательское пространство,  там "
"выделяется таблица и заполняется каталог границ с расположением новой "
"таблицы. Для освобождения ядро проверяет есть ли таблицы границ для "
"нераспределённой памяти и освобождает их если есть."

#. type: Plain text
#: man-pages/man2/prctl.2:753
msgid ""
"Before enabling MPX management using B<PR_MPX_ENABLE_MANAGEMENT>, the "
"application must first have allocated a user-space buffer for the bounds "
"directory and placed the location of that directory in the I<bndcfgu> "
"register."
msgstr ""
"Перед включением управления MPX с помощью B<PR_MPX_ENABLE_MANAGEMENT> "
"приложение сначала должно выделить буфер в пользовательском пространстве для "
"каталог границ и поместить расположение этого каталоге в регистр I<bndcfgu>."

#. type: Plain text
#: man-pages/man2/prctl.2:760
msgid ""
"These calls fail if the CPU or kernel does not support MPX.  Kernel support "
"for MPX is enabled via the B<CONFIG_X86_INTEL_MPX> configuration option.  "
"You can check whether the CPU supports MPX by looking for the 'mpx' CPUID "
"bit, like with the following command:"
msgstr ""
"Эти вызовы завершаются ошибкой, если ЦП или ядро не поддерживают MPX. "
"Поддержка MPX в ядре включается параметром настройки "
"B<CONFIG_X86_INTEL_MPX>. Вы можете проверить наличие поддержки MPX в ЦП "
"прочитав бит «mpx» в CPUID следующей командой:"

#. type: Plain text
#: man-pages/man2/prctl.2:764
#, no-wrap
msgid "cat /proc/cpuinfo | grep ' mpx '\n"
msgstr "cat /proc/cpuinfo | grep ' mpx '\n"

#. type: Plain text
#: man-pages/man2/prctl.2:769
msgid ""
"A thread may not switch in or out of long (64-bit) mode while MPX is enabled."
msgstr ""
"Нить может не переключиться в «длинный» режим (64-битный) при включённом MPX."

#. type: Plain text
#: man-pages/man2/prctl.2:771
msgid "All threads in a process are affected by these calls."
msgstr "Эти вызовы влияют на все нити процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:780
msgid ""
"The child of a B<fork>(2)  inherits the state of MPX management.  During "
"B<execve>(2), MPX management is reset to a state as if "
"B<PR_MPX_DISABLE_MANAGEMENT> had been called."
msgstr ""
"Потомок B<fork>(2) наследует состояние управления MPX. Во время B<execve>(2) "
"управление MPX сбрасывается в состояние, как если бы выполнился вызов "
"B<PR_MPX_DISABLE_MANAGEMENT>."

#. type: Plain text
#: man-pages/man2/prctl.2:783
msgid ""
"For further information on Intel MPX, see the kernel source file "
"I<Documentation/x86/intel_mpx.txt>."
msgstr ""
"Дополнительную информацию по Intel MPX смотрите в файле исходного кода ядра "
"I<Documentation/x86/intel_mpx.txt>."

#. type: TP
#: man-pages/man2/prctl.2:783
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr "B<PR_SET_NAME> (начиная с Linux 2.6.9)"

#.  TASK_COMM_LEN in include/linux/sched.h
#. type: Plain text
#: man-pages/man2/prctl.2:802
msgid ""
"Set the name of the calling thread, using the value in the location pointed "
"to by I<(char\\ *) arg2>.  The name can be up to 16 bytes long, including "
"the terminating null byte.  (If the length of the string, including the "
"terminating null byte, exceeds 16 bytes, the string is silently truncated.)  "
"This is the same attribute that can be set via B<pthread_setname_np>(3)  and "
"retrieved using B<pthread_getname_np>(3).  The attribute is likewise "
"accessible via I</proc/self/task/[tid]/comm>, where I<tid> is the name of "
"the calling thread."
msgstr ""
"Назначает имя вызывающей нити, используя значение памяти, переданное в "
"указателе I<(char\\ *) arg2>. Имя может быть не более 16, включая "
"завершающий байт null (если длина строки, включая завершающий null, "
"превышает 16 байт, то строка просто обрезается). Это то же атрибут, который "
"можно установить через B<pthread_setname_np>(3) и получить с помощью "
"B<pthread_getname_np>(3). Также этот атрибут доступен через I</proc/self/"
"task/[tid]/comm>, где I<tid> — имя вызывающей нити."

#. type: TP
#: man-pages/man2/prctl.2:802
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr "B<PR_GET_NAME> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man2/prctl.2:809
msgid ""
"Return the name of the calling thread, in the buffer pointed to by I<(char\\ "
"*) arg2>.  The buffer should allow space for up to 16 bytes; the returned "
"string will be null-terminated."
msgstr ""
"Записывает имя вызывающей нити в буфер, указанный в I<(char\\ *) arg2>. "
"Буфер должен быть не более 16 байт; полученная строка будет завершаться null."

#. type: TP
#: man-pages/man2/prctl.2:809
#, no-wrap
msgid "B<PR_SET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr "B<PR_SET_NO_NEW_PRIVS> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/prctl.2:834
msgid ""
"Set the calling thread's I<no_new_privs> attribute to the value in I<arg2>.  "
"With I<no_new_privs> set to 1, B<execve>(2)  promises not to grant "
"privileges to do anything that could not have been done without the "
"B<execve>(2)  call (for example, rendering the set-user-ID and set-group-ID "
"mode bits, and file capabilities non-functional).  Once set, this the "
"I<no_new_privs> attribute cannot be unset.  The setting of this attribute is "
"inherited by children created by B<fork>(2)  and B<clone>(2), and preserved "
"across B<execve>(2)."
msgstr ""
"Устанавливает атрибут I<no_new_privs> вызывающей нити равным I<arg2>. Если "
"значение I<no_new_privs> равно 1, то B<execve>(2) не выдаст прав никому, кто "
"бы не мог это сделать без вызова B<execve>(2) (например, без битов прав "
"режима set-user-ID и set-group-ID и файловых мандатов). После установки "
"атрибута I<no_new_privs> его нельзя сбросить. Значение этого атрибута "
"наследуется потомками, созданными с помощью B<fork>(2) и B<clone>(2), и "
"сохраняется при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:843
msgid ""
"Since Linux 4.10, the value of a thread's I<no_new_privs> attribute can be "
"viewed via the I<NoNewPrivs> field in the I</proc/[pid]/status> file."
msgstr ""
"Начиная с Linux 4.10, значения атрибута I<no_new_privs> нити отражено в поле "
"I<NoNewPrivs> файла I</proc/[pid]/status>."

#.  commit 40fde647ccb0ae8c11d256d271e24d385eed595b
#. type: Plain text
#: man-pages/man2/prctl.2:852
msgid ""
"For more information, see the kernel source file I<Documentation/userspace-"
"api/no_new_privs.rst> (or I<Documentation/prctl/no_new_privs.txt> before "
"Linux 4.13).  See also B<seccomp>(2)."
msgstr ""
"Дополнительную информацию смотрите в файле исходного кода ядра "
"I<Documentation/userspace-api/no_new_privs.rst> (или в I<Documentation/prctl/"
"no_new_privstxt> до Linux 4.13). Также смотрите B<seccomp>(2)."

#. type: TP
#: man-pages/man2/prctl.2:852
#, no-wrap
msgid "B<PR_GET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr "B<PR_GET_NO_NEW_PRIVS> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/prctl.2:863
msgid ""
"Return (as the function result) the value of the I<no_new_privs> attribute "
"for the calling thread.  A value of 0 indicates the regular B<execve>(2)  "
"behavior.  A value of 1 indicates B<execve>(2)  will operate in the "
"privilege-restricting mode described above."
msgstr ""
"Возвращает значение (как результат функции) атрибута I<no_new_privs> в "
"вызывающей нити. Значение 0 соответствует обычному поведению B<execve>(2). "
"Значение 1 показывает, что B<execve>(2) будет работать в ограничивающем "
"права режиме, как описано ранее."

#. type: TP
#: man-pages/man2/prctl.2:863
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr "B<PR_SET_PDEATHSIG> (начиная с Linux 2.1.57)"

#. type: Plain text
#: man-pages/man2/prctl.2:870
msgid ""
"Set the parent-death signal of the calling process to I<arg2> (either a "
"signal value in the range 1..maxsig, or 0 to clear).  This is the signal "
"that the calling process will get when its parent dies."
msgstr ""
"Устанавливает значение сигнала, приходящего процессу при завершении работы "
"родительского процесса, равным I<arg2> (значение может быть из диапазона 1.."
"maxsig или 0 для снятия). Этот сигнал получит вызывающий процесс, когда его "
"родитель завершит работу."

#.  https://bugzilla.kernel.org/show_bug.cgi?id=43300
#. type: Plain text
#: man-pages/man2/prctl.2:880
msgid ""
"I<Warning>: the \"parent\" in this case is considered to be the I<thread> "
"that created this process.  In other words, the signal will be sent when "
"that thread terminates (via, for example, B<pthread_exit>(3)), rather than "
"after all of the threads in the parent process terminate."
msgstr ""
"I<Предупреждение>: «родителем» здесь считается I<нить>, создавшая этот "
"процесс. Иначе говоря, сигнал будет послан при завершении нити (например, с "
"помощью B<pthread_exit>(3)), а не всех нитей родительского процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:890
msgid ""
"The parent-death signal is sent upon subsequent termination of the parent "
"thread and also upon termination of each subreaper process (see the "
"description of B<PR_SET_CHILD_SUBREAPER> above) to which the caller is "
"subsequently reparented.  If the parent thread and all ancestor subreapers "
"have already terminated by the time of the B<PR_SET_PDEATHSIG> operation, "
"then no parent-death signal is sent to the caller."
msgstr ""
"Сигнал отправляется после завершения родительской нити, а также после "
"завершения каждого процесса-сборщика потомков (смотрите описание "
"B<PR_SET_CHILD_SUBREAPER> выше), которыми вызывающий был последовательно "
"усыновлён. Если родительская нить и все предки сборщиков завершили работу на "
"момент операции B<PR_SET_PDEATHSIG>, то сигнал о завершении вызывающему не "
"посылается."

#. type: Plain text
#: man-pages/man2/prctl.2:901
msgid ""
"The parent-death signal is process-directed (see B<signal>(7))  and, if the "
"child installs a handler using the B<sigaction>(2)  B<SA_SIGINFO> flag, the "
"I<si_pid> field of the I<siginfo_t> argument of the handler contains the PID "
"of the terminating parent process."
msgstr ""
"Сигнал о завершении родителя направляется процессу (смотрите B<signal>(7)) "
"и, если потомок установил обработчик использовав B<sigaction>(2) с флагом "
"B<SA_SIGINFO>, то поле I<si_pid> аргумента I<siginfo_t> обработчика содержит "
"PID завершающегося родительского процесса."

#.  commit d2d56c5f51028cb9f3d800882eb6f4cbd3f9099f
#. type: Plain text
#: man-pages/man2/prctl.2:912
msgid ""
"The parent-death signal setting is cleared for the child of a B<fork>(2).  "
"It is also (since Linux 2.4.36 / 2.6.23)  cleared when executing a set-user-"
"ID or set-group-ID binary, or a binary that has associated capabilities (see "
"B<capabilities>(7)); otherwise, this value is preserved across B<execve>(2)."
msgstr ""
"Значение сигнала о завершении родителя очищается для потомков, созданных "
"B<fork>(2). Он также очищается (начиная с Linux 2.4.36 / 2.6.23) при "
"выполнении исполняемого файла с установленным битом set-user-ID или set-"
"group-ID, и исполняемого файла с соответствующими мандатами (смотрите "
"B<capabilities>(7)); иначе это значение сохраняется при B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:912
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr "B<PR_GET_PDEATHSIG> (начиная с Linux 2.3.15)"

#. type: Plain text
#: man-pages/man2/prctl.2:917
msgid ""
"Return the current value of the parent process death signal, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""
"Записывает текущее значение сигнала о завершении работы родительского "
"процесса по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:917
#, no-wrap
msgid "B<PR_SET_PTRACER> (since Linux 3.4)"
msgstr "B<PR_SET_PTRACER> (начиная с Linux 3.4)"

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#.  commit bf06189e4d14641c0148bea16e9dd24943862215
#. type: Plain text
#: man-pages/man2/prctl.2:942
msgid ""
"This is meaningful only when the Yama LSM is enabled and in mode 1 "
"(\"restricted ptrace\", visible via I</proc/sys/kernel/yama/ptrace_scope>).  "
"When a \"ptracer process ID\" is passed in I<arg2>, the caller is declaring "
"that the ptracer process can B<ptrace>(2)  the calling process as if it were "
"a direct process ancestor.  Each B<PR_SET_PTRACER> operation replaces the "
"previous \"ptracer process ID\".  Employing B<PR_SET_PTRACER> with I<arg2> "
"set to 0 clears the caller's \"ptracer process ID\".  If I<arg2> is "
"B<PR_SET_PTRACER_ANY>, the ptrace restrictions introduced by Yama are "
"effectively disabled for the calling process."
msgstr ""
"Имеет смысл, только если включён Yama LSM и в режиме 1 («ограниченный "
"ptrace», значение доступно в I</proc/sys/kernel/yama/ptrace_scope>). Когда "
"«идентификатор процесса ptracer» передаётся в I<arg2>, вызывающий объявляет, "
"что процесс ptracer может выполнить B<ptrace>(2), как если бы он был прямым "
"предком процесса. Каждая операция B<PR_SET_PTRACER> заменяет предыдущий "
"«идентификатор процесса ptracer». Применение B<PR_SET_PTRACER> с значением "
"I<arg2> равным 0 очищает «идентификатор процесса ptracer» вызывающего. Если "
"I<arg2> равно B<PR_SET_PTRACER_ANY>, то ограничения ptrace, предоставленные "
"Yama отключаются для вызывающего процесса."

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#. type: Plain text
#: man-pages/man2/prctl.2:949
msgid ""
"For further information, see the kernel source file I<Documentation/admin-"
"guide/LSM/Yama.rst> (or I<Documentation/security/Yama.txt> before Linux "
"4.13)."
msgstr ""
"Дополнительную информацию смотрите в файле исходного кода ядра "
"I<Documentation/admin-guide/LSM/Yama.rst> (или в I<Documentation/security/"
"Yama.txt> до Linux 4.13)."

#. type: TP
#: man-pages/man2/prctl.2:949
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_SET_SECCOMP> (начиная с Linux 2.6.23)"

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: man-pages/man2/prctl.2:960
msgid ""
"Set the secure computing (seccomp) mode for the calling thread, to limit the "
"available system calls.  The more recent B<seccomp>(2)  system call provides "
"a superset of the functionality of B<PR_SET_SECCOMP>."
msgstr ""
"Устанавливает режим безопасных вычислений (seccomp) в вызывающей нити, в "
"котором ограничен список доступных системных вызовов. Новый системный вызов "
"B<seccomp>(2) предоставляет большие возможности чем B<PR_SET_SECCOMP>."

#. type: Plain text
#: man-pages/man2/prctl.2:965
msgid ""
"The seccomp mode is selected via I<arg2>.  (The seccomp constants are "
"defined in I<E<lt>linux/seccomp.hE<gt>>.)"
msgstr ""
"Режим seccomp выбирается из I<arg2> (константы seccomp определены в "
"I<E<lt>linux/seccomp.hE<gt>>)."

#. type: Plain text
#: man-pages/man2/prctl.2:988
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_STRICT>, the only system calls that the "
"thread is permitted to make are B<read>(2), B<write>(2), B<_exit>(2)  (but "
"not B<exit_group>(2)), and B<sigreturn>(2).  Other system calls result in "
"the delivery of a B<SIGKILL> signal.  Strict secure computing mode is useful "
"for number-crunching applications that may need to execute untrusted byte "
"code, perhaps obtained by reading from a pipe or socket.  This operation is "
"available only if the kernel is configured with B<CONFIG_SECCOMP> enabled."
msgstr ""
"Если значение I<arg2> равно B<SECCOMP_MODE_STRICT>, то в нити доступны "
"только системные вызовы B<read>(2), B<write>(2), B<_exit>(2) (но не "
"B<exit_group>(2)) и B<sigreturn>(2). При запуске других системных вызовов "
"генерируется сигнал B<SIGKILL>. Режим безопасных вычислений полезен для "
"вычислительных приложений, которым может потребоваться выполнить "
"недоверительный байт-код, возможно полученный при чтении из канала или "
"сокета. Эта операция доступна только, если в ядре включён параметр "
"B<CONFIG_SECCOMP>."

#. type: Plain text
#: man-pages/man2/prctl.2:1003
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_FILTER> (since Linux 3.5), the system "
"calls allowed are defined by a pointer to a Berkeley Packet Filter passed in "
"I<arg3>.  This argument is a pointer to I<struct sock_fprog>; it can be "
"designed to filter arbitrary system calls and system call arguments.  This "
"mode is available only if the kernel is configured with "
"B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""
"Если значение I<arg2> равно B<SECCOMP_MODE_FILTER> (начиная с Linux 3.5), то "
"список разрешённых системных вызовов определяется указателем (I<arg3>) на "
"пакетный фильтр Berkeley. Аргумент указывает на I<struct sock_fprog>; в "
"структуре можно описать фильтр и произвольных системных вызовов и их "
"аргументов. Этот режим доступен только, если ядро собрано с параметром "
"B<CONFIG_SECCOMP_FILTER>."

#. type: Plain text
#: man-pages/man2/prctl.2:1018
msgid ""
"If B<SECCOMP_MODE_FILTER> filters permit B<fork>(2), then the seccomp mode "
"is inherited by children created by B<fork>(2); if B<execve>(2)  is "
"permitted, then the seccomp mode is preserved across B<execve>(2).  If the "
"filters permit B<prctl>()  calls, then additional filters can be added; they "
"are run in order until the first non-allow result is seen."
msgstr ""
"Если в фильтрах B<SECCOMP_MODE_FILTER> разрешён B<fork>(2), то режим seccomp "
"наследуется потомками, создаваемыми B<fork>(2); если разрешён B<execve>(2), "
"то режим seccomp сохраняется при B<execve>(2). Если в фильтрах разрешены "
"B<prctl>(), то могут быть добавлены дополнительные фильтры; они применяются "
"до тех пор пока не будет найдено запрещение."

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#. type: Plain text
#: man-pages/man2/prctl.2:1025
msgid ""
"For further information, see the kernel source file I<Documentation/"
"userspace-api/seccomp_filter.rst> (or I<Documentation/prctl/seccomp_filter."
"txt> before Linux 4.13)."
msgstr ""
"Дополнительную информацию смотрите в файле исходного кода ядра "
"I<Documentation/userspace-api/seccomp_filter.rst> (или в I<Documentation/"
"prctl/seccomp_filter.txt> до Linux 4.13)."

#. type: TP
#: man-pages/man2/prctl.2:1025
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_GET_SECCOMP> (начиная с Linux 2.6.23)"

#. type: Plain text
#: man-pages/man2/prctl.2:1043
msgid ""
"Return (as the function result)  the secure computing mode of the calling "
"thread.  If the caller is not in secure computing mode, this operation "
"returns 0; if the caller is in strict secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"If the caller is in filter mode, and this system call is allowed by the "
"seccomp filters, it returns 2; otherwise, the process is killed with a "
"B<SIGKILL> signal.  This operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP> enabled."
msgstr ""
"Возвращает значение (как результат функции) режима безопасных вычислений "
"вызвавшей нити. Если вызывающий не работает в режиме безопасных вычислений, "
"то возвращается 0; если вызывающий находится в режиме ограниченных "
"безопасных вычислений, то вызов B<prctl>() приведёт к отправке процессу "
"сигнала B<SIGKILL>. Если вызывающий работает в режиме фильтрации и данный "
"системный вызов разрешён в фильтрах seccomp, то возвращается 2; в противном "
"случае процесс завершается по сигналу B<SIGKILL>. Эта операция доступна "
"только, если ядро собрано с параметром B<CONFIG_SECCOMP>."

#. type: Plain text
#: man-pages/man2/prctl.2:1051
msgid ""
"Since Linux 3.8, the I<Seccomp> field of the I</proc/[pid]/status> file "
"provides a method of obtaining the same information, without the risk that "
"the process is killed; see B<proc>(5)."
msgstr ""
"Начиная с Linux 3.8 в поле I<Seccomp> файла I</proc/[pid]/status> "
"предоставляется метод получения той же информации, без риска уничтожения "
"процесса; смотрите B<proc>(5)."

#. type: TP
#: man-pages/man2/prctl.2:1051
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_SET_SECUREBITS> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/prctl.2:1057
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr ""
"Устанавливает значение флагов «securebits» вызывающей нити равным значению "
"I<arg2>. Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man2/prctl.2:1057
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_GET_SECUREBITS> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/prctl.2:1063
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr ""
"Возвращает (как результат функции) флаги «securebits» вызывающей нити. "
"Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man2/prctl.2:1063
#, no-wrap
msgid "B<PR_GET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr "B<PR_GET_SPECULATION_CTRL> (начиная с Linux 4.17)"

#. type: Plain text
#: man-pages/man2/prctl.2:1071
msgid ""
"Returns the state of the speculation misfeature specified in I<arg2>.  "
"Currently, the only permitted value for this argument is "
"B<PR_SPEC_STORE_BYPASS> (otherwise the call fails with the error B<ENODEV>)."
msgstr ""
"Возвращает состояние нежелательной спекулятовности, указанной в I<arg2>. В "
"настоящее время значением аргумента может быть только "
"B<PR_SPEC_STORE_BYPASS> (в противном случае возвращается ошибка B<ENODEV>)."

#. type: Plain text
#: man-pages/man2/prctl.2:1073
msgid "The return value uses bits 0-3 with the following meaning:"
msgstr "В значении результата используются биты 0-3:"

#. type: TP
#: man-pages/man2/prctl.2:1074
#, no-wrap
msgid "B<PR_SPEC_PRCTL>"
msgstr "B<PR_SPEC_PRCTL>"

#. type: Plain text
#: man-pages/man2/prctl.2:1078
msgid "Mitigation can be controlled per thread by B<PR_SET_SPECULATION_CTRL>"
msgstr ""
"Смягчение (mitigation) можно контролировать на уровне нити через "
"B<PR_SET_SPECULATION_CTRL>"

#. type: TP
#: man-pages/man2/prctl.2:1078 man-pages/man2/prctl.2:1124
#, no-wrap
msgid "B<PR_SPEC_ENABLE>"
msgstr "B<PR_SPEC_ENABLE>"

#. type: Plain text
#: man-pages/man2/prctl.2:1081 man-pages/man2/prctl.2:1127
msgid "The speculation feature is enabled, mitigation is disabled."
msgstr "Свойство спекулятивности включено, смягчение выключено."

#. type: TP
#: man-pages/man2/prctl.2:1081 man-pages/man2/prctl.2:1127
#, no-wrap
msgid "B<PR_SPEC_DISABLE>"
msgstr "B<PR_SPEC_DISABLE>"

#. type: Plain text
#: man-pages/man2/prctl.2:1084 man-pages/man2/prctl.2:1130
msgid "The speculation feature is disabled, mitigation is enabled"
msgstr "Свойство спекулятивности выключено, смягчение включено"

#. type: TP
#: man-pages/man2/prctl.2:1084 man-pages/man2/prctl.2:1130
#, no-wrap
msgid "B<PR_SPEC_FORCE_DISABLE>"
msgstr "B<PR_SPEC_FORCE_DISABLE>"

#. type: Plain text
#: man-pages/man2/prctl.2:1089
msgid "Same as B<PR_SPEC_DISABLE> but cannot be undone."
msgstr "Тоже, что и B<PR_SPEC_DISABLE>, но нельзя отменить."

#. type: Plain text
#: man-pages/man2/prctl.2:1093
msgid ""
"If all bits are 0, then the CPU is not affected by the speculation "
"misfeature."
msgstr ""
"Если все биты равны 0, то на ЦП нежелательная спекулятовность не работает."

#. type: Plain text
#: man-pages/man2/prctl.2:1100
msgid ""
"If B<PR_SPEC_PRCTL> is set, then per-thread control of the mitigation is "
"available.  If not set, B<prctl>()  for the speculation misfeature will fail."
msgstr ""
"Если установлен B<PR_SPEC_PRCTL>, то доступно управление смягчением на "
"уровне нити. Если не установлен, то вызов B<prctl>() для нежелательной "
"спекулятовности завершится ошибкой."

#. type: Plain text
#: man-pages/man2/prctl.2:1108
msgid ""
"The I<arg3>, I<arg4>, and I<arg5> arguments must be specified as 0; "
"otherwise the call fails with the error B<EINVAL>."
msgstr ""
"Аргументы I<arg3>, I<arg4> и I<arg5> должны быть равны 0; в противном случае "
"вызов завершается ошибкой B<EINVAL>."

#. type: TP
#: man-pages/man2/prctl.2:1108
#, no-wrap
msgid "B<PR_SET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr "B<PR_SET_SPECULATION_CTRL> (начиная с Linux 4.17)"

#.  commit b617cfc858161140d69cc0b5cc211996b557a1c7
#.  commit 356e4bfff2c5489e016fdb925adbf12a1e3950ee
#. type: Plain text
#: man-pages/man2/prctl.2:1123
msgid ""
"Sets the state of the speculation misfeature specified in I<arg2>.  "
"Currently, the only permitted value for this argument is "
"B<PR_SPEC_STORE_BYPASS> (otherwise the call fails with the error "
"B<ENODEV>).  This setting is a per-thread attribute.  The I<arg3> argument "
"is used to hand in the control value, which is one of the following:"
msgstr ""
"Задаёт состояние нежелательной спекулятовности, согласно значению I<arg2>. В "
"настоящее время значением аргумента может быть только "
"B<PR_SPEC_STORE_BYPASS> (в противном случае возвращается ошибка B<ENODEV>)."
"Данная настройка является атрибутом нити. Аргумент I<arg3> используется как "
"управляющее значение, которое может быть одним из следующих:"

#. type: Plain text
#: man-pages/man2/prctl.2:1140
msgid ""
"Same as B<PR_SPEC_DISABLE> but cannot be undone.  A subsequent B<prctl(..., "
"PR_SPEC_ENABLE)> will fail with the error B<EPERM>."
msgstr ""
"Тоже, что и B<PR_SPEC_DISABLE>, но нельзя отменить. Последующий вызов "
"B<prctl(..., PR_SPEC_ENABLE)> завершится ошибкой B<EPERM>."

#. type: Plain text
#: man-pages/man2/prctl.2:1146
msgid ""
"Any other value in I<arg3> will result in the call failing with the error "
"B<ERANGE>."
msgstr "Любое другое значение в I<arg3> приведёт к ошибке B<ERANGE>."

#. type: Plain text
#: man-pages/man2/prctl.2:1153
msgid ""
"The I<arg4> and I<arg5> arguments must be specified as 0; otherwise the call "
"fails with the error B<EINVAL>."
msgstr ""
"Аргументы I<arg4> и I<arg5> должны быть равны 0; в противном случае вызов "
"завершается ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/prctl.2:1163
msgid ""
"The speculation feature can also be controlled by the "
"B<spec_store_bypass_disable> boot parameter.  This parameter may enforce a "
"read-only policy which will result in the B<prctl>(2)  call failing with the "
"error B<ENXIO>.  For further details, see the kernel source file "
"I<Documentation/admin-guide/kernel-parameters.txt>."
msgstr ""
"Свойство спекулятивного выполнения также может контролироваться параметром "
"загрузки B<spec_store_bypass_disable>. Это параметр может установить режим "
"только для чтения, при котором вызов B<prctl>(2) будет завершаться ошибкой "
"B<ENXIO>. Дополнительную информацию смотрите в файле исходного кода ядра "
"I<Documentation/admin-guide/kernel-parameters.txt>."

#. type: TP
#: man-pages/man2/prctl.2:1163
#, no-wrap
msgid "B<PR_SET_THP_DISABLE> (since Linux 3.15)"
msgstr "B<PR_SET_THP_DISABLE> (начиная с Linux 3.15)"

#.  commit a0715cc22601e8830ace98366c0c2bd8da52af52
#. type: Plain text
#: man-pages/man2/prctl.2:1180
msgid ""
"Set the state of the \"THP disable\" flag for the calling thread.  If "
"I<arg2> has a nonzero value, the flag is set, otherwise it is cleared.  "
"Setting this flag provides a method for disabling transparent huge pages for "
"jobs where the code cannot be modified, and using a malloc hook with "
"B<madvise>(2)  is not an option (i.e., statically allocated data).  The "
"setting of the \"THP disable\" flag is inherited by a child created via "
"B<fork>(2)  and is preserved across B<execve>(2)."
msgstr ""
"Задать состояние флага «THP disable» вызывающей нити. Если I<arg2> не равно "
"нулю, то флаг устанавливается, иначе очищается. Установка этого флага "
"предоставляет метод отключения прозрачных огромных страниц для заданий, код "
"которых нельзя изменить и использование обработчика malloc с B<madvise>(2) "
"невозможно (т. е., место под данные выделено статически). Значение флага "
"«THP disable» наследуется потомком, создаваемым B<fork>(2) и сохраняется "
"после B<execve>(2)."

#. type: TP
#: man-pages/man2/prctl.2:1180
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_DISABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_DISABLE> (начиная с Linux 2.6.31)"

#. type: Plain text
#: man-pages/man2/prctl.2:1189
msgid ""
"Disable all performance counters attached to the calling process, regardless "
"of whether the counters were created by this process or another process.  "
"Performance counters created by the calling process for other processes are "
"unaffected.  For more information on performance counters, see the Linux "
"kernel source file I<tools/perf/design.txt>."
msgstr ""
"Отключает все счётчики производительности, прикреплённые к вызывающему "
"процессу, не учитывая, были ли они созданы этим процессом или каким-то "
"другим. Счётчики производительности, созданные вызывающим процессом для "
"других процессов, не отключаются. Подробности о счётчиках производительности "
"приведены в файле ядра Linux I<tools/perf/design.txt>."

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#. type: Plain text
#: man-pages/man2/prctl.2:1196
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (retaining the "
"same numerical value)  in Linux 2.6.32."
msgstr ""
"Сначала назывался B<PR_TASK_PERF_COUNTERS_DISABLE>; переименован (числовое "
"значение не изменилось) в Linux 2.6.32."

#. type: TP
#: man-pages/man2/prctl.2:1196
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_ENABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_ENABLE> (начиная с Linux 2.6.31)"

#. type: Plain text
#: man-pages/man2/prctl.2:1201
msgid ""
"The converse of B<PR_TASK_PERF_EVENTS_DISABLE>; enable performance counters "
"attached to the calling process."
msgstr ""
"Противоположное действие B<PR_TASK_PERF_EVENTS_DISABLE>; включает счётчики "
"производительности, прикреплённые к вызывающему процессу."

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: man-pages/man2/prctl.2:1209
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_ENABLE>; renamed in Linux 2.6.32."
msgstr ""
"Сначала назывался B<PR_TASK_PERF_COUNTERS_ENABLE>; переименован в Linux "
"2.6.32."

#. type: TP
#: man-pages/man2/prctl.2:1209
#, no-wrap
msgid "B<PR_GET_THP_DISABLE> (since Linux 3.15)"
msgstr "B<PR_GET_THP_DISABLE> (начиная с Linux 3.15)"

#. type: Plain text
#: man-pages/man2/prctl.2:1214
msgid ""
"Return (via the function result) the current setting of the \"THP disable\" "
"flag for the calling thread: either 1, if the flag is set, or 0, if it is "
"not."
msgstr ""
"Возвращает текущее значение (как результат функции) флага «THP disable» "
"вызывающей нити: 1 — флаг установлен; 0 — нет."

#. type: TP
#: man-pages/man2/prctl.2:1214
#, no-wrap
msgid "B<PR_GET_TID_ADDRESS> (since Linux 3.5)"
msgstr "B<PR_GET_TID_ADDRESS> (начиная с Linux 3.5)"

#.  commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
#. type: Plain text
#: man-pages/man2/prctl.2:1235
msgid ""
"Retrieve the I<clear_child_tid> address set by B<set_tid_address>(2)  and "
"the B<clone>(2)  B<CLONE_CHILD_CLEARTID> flag, in the location pointed to by "
"I<(int\\ **)\\ arg2>.  This feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled.  Note that since the "
"B<prctl>()  system call does not have a compat implementation for the AMD64 "
"x32 and MIPS n32 ABIs, and the kernel writes out a pointer using the "
"kernel's pointer size, this operation expects a user-space buffer of 8 (not "
"4) bytes on these ABIs."
msgstr ""
"Возвращает адрес I<clear_child_tid>, заданный B<set_tid_address>(2) и "
"B<clone>(2) с флагом B<CLONE_CHILD_CLEARTID>, в расположение, указанное в "
"I<(int\\ **)\\ arg2>. Эта возможность доступна только, если ядро собрано с "
"параметром B<CONFIG_CHECKPOINT_RESTORE>. Заметим, что так как системный "
"вызов B<prctl>() не содержит совместимой реализации для AMD64 x32 и MIPS n32 "
"ABI и ядро записывает указатель размером с ядерный, то эта операция требует "
"пользовательский буфер в 8 (не 4) байт в этих ABI."

#. type: TP
#: man-pages/man2/prctl.2:1235
#, no-wrap
msgid "B<PR_SET_TIMERSLACK> (since Linux 2.6.28)"
msgstr "B<PR_SET_TIMERSLACK> (начиная с Linux 2.6.28)"

#.  See https://lwn.net/Articles/369549/
#.  commit 6976675d94042fbd446231d1bd8b7de71a980ada
#. type: Plain text
#: man-pages/man2/prctl.2:1253
msgid ""
"Each thread has two associated timer slack values: a \"default\" value, and "
"a \"current\" value.  This operation sets the \"current\" timer slack value "
"for the calling thread.  I<arg2> is an unsigned long value, then maximum "
"\"current\" value is ULONG_MAX and the minimum \"current\" value is 1.  If "
"the nanosecond value supplied in I<arg2> is greater than zero, then the "
"\"current\" value is set to this value.  If I<arg2> is equal to zero, the "
"\"current\" timer slack is reset to the thread's \"default\" timer slack "
"value."
msgstr ""
"Каждая нити имеет два связанных с таймером значения допуска: значение «по "
"умолчанию» и «текущее» значение. Эта операция изменяет «текущее» значение "
"допуска таймера вызывающей нити. Значение I<arg2> имеет тип длинного "
"беззнакового целого, то есть максимальное «текущее» значение равно "
"ULONG_MAX, а минимальное «текущее» значение равно 1. Если наносекундное "
"значение из I<arg2> больше нуля, то оно присваивается «текущему» значению. "
"Если I<arg2> равно 0, то «текущий» допуск таймера нити сбрасывается в "
"значение допуска таймера «по умолчанию»."

#. type: Plain text
#: man-pages/man2/prctl.2:1260
msgid ""
"The \"current\" timer slack is used by the kernel to group timer expirations "
"for the calling thread that are close to one another; as a consequence, "
"timer expirations for the thread may be up to the specified number of "
"nanoseconds late (but will never expire early).  Grouping timer expirations "
"can help reduce system power consumption by minimizing CPU wake-ups."
msgstr ""
"«Текущий» допуск таймера используется ядром для группировки таймерных "
"окончаний при вызовах нити, которые происходят очень часто; как следствие, "
"таймерные окончания нити могут быть равны до указанной наносекундной "
"задержки (но никогда не будут истекать ранее). Группировка таймерных "
"окончаний может помочь сократить потребление энергии системой, в следствии "
"сокращения количества пробуждений ЦП."

#.  List obtained by grepping for futex usage in glibc source
#. type: Plain text
#: man-pages/man2/prctl.2:1280
msgid ""
"The timer expirations affected by timer slack are those set by B<select>(2), "
"B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), B<epoll_pwait>(2), "
"B<clock_nanosleep>(2), B<nanosleep>(2), and B<futex>(2)  (and thus the "
"library functions implemented via futexes, including "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3), and "
"B<sem_timedwait>(3))."
msgstr ""
"Таймерные окончания, на которые влияет допуск таймера, устанавливаются "
"B<select>(2), B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<clock_nanosleep>(2), B<nanosleep>(2) и B<futex>(2) (и, "
"следовательно, все библиотечными функциями, реализованными через futex: "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3) и "
"B<sem_timedwait>(3))."

#. type: Plain text
#: man-pages/man2/prctl.2:1284
msgid ""
"Timer slack is not applied to threads that are scheduled under a real-time "
"scheduling policy (see B<sched_setscheduler>(2))."
msgstr ""
"Допуск таймера не применяется к нитям, которые планируются в соответствии с "
"политикой реального времени (смотрите B<sched_setscheduler>(2))."

#. type: Plain text
#: man-pages/man2/prctl.2:1299
msgid ""
"When a new thread is created, the two timer slack values are made the same "
"as the \"current\" value of the creating thread.  Thereafter, a thread can "
"adjust its \"current\" timer slack value via B<PR_SET_TIMERSLACK>.  The "
"\"default\" value can't be changed.  The timer slack values of I<init> (PID "
"1), the ancestor of all processes, are 50,000 nanoseconds (50 "
"microseconds).  The timer slack value is inherited by a child created via "
"B<fork>(2), and is preserved across B<execve>(2)."
msgstr ""
"При создании новой нити этим двум значениям присваивается значение "
"«текущего» допуска создающей нити. После этого нить может подстроить "
"значение своего «текущего» допуска таймера с помощью B<PR_SET_TIMERSLACK> "
"(значение по умолчанию не может быть изменено). Значения допуска таймера для "
"I<init> (PID 1), предка всех процессов, равно 50000 наносекунд (50 "
"микросекунд). Значения допуска таймера наследуются потомком при B<fork>(2) и "
"сохраняются при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/prctl.2:1305
msgid ""
"Since Linux 4.6, the \"current\" timer slack value of any process can be "
"examined and changed via the file I</proc/[pid]/timerslack_ns>.  See "
"B<proc>(5)."
msgstr ""
"Начиная с Linux 4.6 значение «текущего» допуска таймера любого процесса "
"можно получить и изменить через файл I</proc/[pid]/timerslack_ns>. Смотрите "
"B<proc>(5)."

#. type: TP
#: man-pages/man2/prctl.2:1305
#, no-wrap
msgid "B<PR_GET_TIMERSLACK> (since Linux 2.6.28)"
msgstr "B<PR_GET_TIMERSLACK> (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man2/prctl.2:1309
msgid ""
"Return (as the function result)  the \"current\" timer slack value of the "
"calling thread."
msgstr ""
"Возвращает значение «текущего» допуска (как результат функции) таймера "
"вызывающей нити."

#. type: TP
#: man-pages/man2/prctl.2:1309
#, no-wrap
msgid "B<PR_SET_TIMING> (since Linux 2.6.0)"
msgstr "B<PR_SET_TIMING> (начиная с Linux 2.6.0)"

#.  Precisely: Linux 2.6.0-test4
#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#. type: Plain text
#: man-pages/man2/prctl.2:1327
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL> "
"or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr ""
"Включает использование обычного статистического временного режима выполнения "
"процесса (process timing) или точного режима на основе меток времени "
"(timestamp-based process timing), при передаче B<PR_TIMING_STATISTICAL> или "
"B<PR_TIMING_TIMESTAMP> в I<arg2>. Действия для B<PR_TIMING_TIMESTAMP> пока "
"не реализованы (попытка установить этот режим приведёт к ошибке B<EINVAL>)."

#. type: TP
#: man-pages/man2/prctl.2:1327
#, no-wrap
msgid "B<PR_GET_TIMING> (since Linux 2.6.0)"
msgstr "B<PR_GET_TIMING> (начиная с Linux 2.6.0)"

#.  Precisely: Linux 2.6.0-test4
#. type: Plain text
#: man-pages/man2/prctl.2:1332
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr ""
"Возвращает (как результат функции) тип используемого в данный момент "
"временного режима выполнения процесса."

#. type: TP
#: man-pages/man2/prctl.2:1332
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_SET_TSC> (начиная с Linux 2.6.26, только для x86)"

#. type: Plain text
#: man-pages/man2/prctl.2:1345
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr ""
"Устанавливает состояние флага, определяющего может ли процесс прочитать "
"счётчик метки времени (timestamp counter). Значение B<PR_TSC_ENABLE> в "
"I<arg2> разрешает чтение, B<PR_TSC_SIGSEGV> включает генерацию B<SIGSEGV>, "
"если процесс пытается прочитать счётчик метки времени."

#. type: TP
#: man-pages/man2/prctl.2:1345
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_GET_TSC> (начиная с Linux 2.6.26, только для x86)"

#. type: Plain text
#: man-pages/man2/prctl.2:1351
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr ""
"Записывает значение флага, определяющего может ли быть прочитан счётчик "
"метки времени (timestamp counter), по адресу, указанному в I<(int\\ *) arg2>."

#. type: TP
#: man-pages/man2/prctl.2:1351
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr "B<PR_SET_UNALIGN>"

#.  sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
#.  tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
#. type: Plain text
#: man-pages/man2/prctl.2:1374
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22; sh, since Linux 2.6.34; tile, "
"since Linux 3.12)  Set unaligned access control bits to I<arg2>.  Pass "
"B<PR_UNALIGN_NOPRINT> to silently fix up unaligned user accesses, or "
"B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned user access.  Alpha "
"also supports an additional flag with the value of 4 and no corresponding "
"named constant, which instructs kernel to not fix up unaligned accesses (it "
"is analogous to providing the B<UAC_NOFIX> flag in B<SSI_NVPAIRS> operation "
"of the B<setsysinfo>()  system call on Tru64)."
msgstr ""
"(только для: ia64, начиная с Linux 2.3.48; parisc, начиная с Linux 2.6.15; "
"PowerPC, начиная с Linux 2.6.18; Alpha, начиная с Linux 2.6.22; sh, начиная "
"с Linux 2.6.34; tile, начиная с Linux 3.12) Устанавливает значение битов "
"контроля доступа выравнивания равным значению I<arg2>. При значении "
"B<PR_UNALIGN_NOPRINT> пользовательский доступ без выравнивания без "
"уведомления исправляется, а при B<PR_UNALIGN_SIGBUS> генерируется сигнал "
"B<SIGBUS>. На Alpha также поддерживается дополнительный флаг со значением 4 "
"(именованная константа отсутствует), который указывает ядру не исправлять "
"невыровненный доступ (аналогично флагу B<UAC_NOFIX> в операции "
"B<SSI_NVPAIRS> системного вызова B<setsysinfo>() на Tru64)."

#. type: TP
#: man-pages/man2/prctl.2:1374
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr "B<PR_GET_UNALIGN>"

#. type: Plain text
#: man-pages/man2/prctl.2:1381
msgid ""
"(see B<PR_SET_UNALIGN> for information on versions and architectures)  "
"Return unaligned access control bits, in the location pointed to by "
"I<(unsigned int\\ *) arg2>."
msgstr ""
"(информацию о версиях и архитектурах смотрите в B<PR_SET_UNALIGN>) "
"Записывает значение битов контроля доступа выравнивания по адресу, "
"указанному в I<(unsigned int\\ *) arg2>."

#. type: Plain text
#: man-pages/man2/prctl.2:1402
msgid ""
"On success, B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, B<PR_GET_NO_NEW_PRIVS>, "
"B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, B<PR_GET_TIMING>, "
"B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, B<PR_MCE_KILL_GET>, "
"B<PR_CAP_AMBIENT>+B<PR_CAP_AMBIENT_IS_SET>, and (if it returns)  "
"B<PR_GET_SECCOMP> return the nonnegative values described above.  All other "
"I<option> values return 0 on success.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При успешном выполнении для операций B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, "
"B<PR_GET_NO_NEW_PRIVS>, B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, "
"B<PR_GET_TIMING>, B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, "
"B<PR_MCE_KILL_GET>, B<PR_CAP_AMBIENT>+B<PR_CAP_AMBIENT_IS_SET>, и (если "
"возвращается) B<PR_GET_SECCOMP> возвращаются неотрицательные значения, "
"описанные ранее. При успешном выполнении для остальных значений I<option> "
"возвращается 0. При ошибке возвращается -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/prctl.2:1419
msgid ""
"I<option> is B<PR_SET_SECCOMP> and I<arg2> is B<SECCOMP_MODE_FILTER>, but "
"the process does not have the B<CAP_SYS_ADMIN> capability or has not set the "
"I<no_new_privs> attribute (see the discussion of B<PR_SET_NO_NEW_PRIVS> "
"above)."
msgstr ""
"Значение I<option> равно B<PR_SET_SECCOMP> и I<arg2> равно "
"B<SECCOMP_MODE_FILTER>, но процесс не имеет мандата B<CAP_SYS_ADMIN> или "
"установленного атрибута I<no_new_privs> (смотрите обсуждение "
"B<PR_SET_NO_NEW_PRIVS> выше)."

#. type: Plain text
#: man-pages/man2/prctl.2:1429
msgid ""
"I<option> is B<PR_SET_MM>, and I<arg3> is B<PR_SET_MM_EXE_FILE>, the file is "
"not executable."
msgstr ""
"Значение I<option> равно B<PR_SET_MM>, а I<arg3> — B<PR_SET_MM_EXE_FILE>, "
"файл не является исполняемым."

#. type: Plain text
#: man-pages/man2/prctl.2:1440
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and the file "
"descriptor passed in I<arg4> is not valid."
msgstr ""
"Значение I<option> равно B<PR_SET_MM>, I<arg3> — B<PR_SET_MM_EXE_FILE>, и "
"файловый дескриптор, переданный в I<arg4>, некорректен."

#. type: Plain text
#: man-pages/man2/prctl.2:1451
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and this the "
"second attempt to change the I</proc/pid/exe> symbolic link, which is "
"prohibited."
msgstr ""
"Значение I<option> равно B<PR_SET_MM>, I<arg3> — B<PR_SET_MM_EXE_FILE>, и "
"это вторая попытка изменить символьную ссылку I</proc/pid/exe>, что "
"запрещено."

#. type: Plain text
#: man-pages/man2/prctl.2:1455
msgid "I<arg2> is an invalid address."
msgstr "В I<arg2> указан неправильный адрес."

#. type: Plain text
#: man-pages/man2/prctl.2:1468
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, the "
"system was built with B<CONFIG_SECCOMP_FILTER>, and I<arg3> is an invalid "
"address."
msgstr ""
"Значение I<option> равно B<PR_SET_SECCOMP>, I<arg2> равно "
"B<SECCOMP_MODE_FILTER>, система была собрана с B<CONFIG_SECCOMP_FILTER> и "
"I<arg3> содержит некорректный адрес."

#. type: Plain text
#: man-pages/man2/prctl.2:1473
msgid "The value of I<option> is not recognized."
msgstr "Не распознано значение I<option>."

#. type: Plain text
#: man-pages/man2/prctl.2:1485
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET> or B<PR_SET_MM>, and "
"unused B<prctl>()  arguments were not specified as zero."
msgstr ""
"Значение I<option> равно B<PR_MCE_KILL>, B<PR_MCE_KILL_GET> или "
"B<PR_SET_MM>, и неиспользуемые аргументы B<prctl>() не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:1490
msgid "I<arg2> is not valid value for this I<option>."
msgstr "Неверное значение I<arg2> для указанной в I<option> операции."

#. type: Plain text
#: man-pages/man2/prctl.2:1499
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_GET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr ""
"Значение I<option> равно B<PR_SET_SECCOMP> или B<PR_GET_SECCOMP>, и ядро не "
"собрано с параметром B<CONFIG_SECCOMP>."

#. type: Plain text
#: man-pages/man2/prctl.2:1509
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, and the "
"kernel was not configured with B<CONFIG_SECCOMP_FILTER>."
msgstr ""
"Значение I<option> равно B<PR_SET_SECCOMP>, I<arg2> равно "
"B<SECCOMP_MODE_FILTER> и ядро было собрано без B<CONFIG_SECCOMP_FILTER>."

#. type: Plain text
#: man-pages/man2/prctl.2:1515
msgid "I<option> is B<PR_SET_MM>, and one of the following is true"
msgstr ""
"Значение I<option> равно B<PR_SET_MM> и одно из следующего является истиной:"

#. type: Plain text
#: man-pages/man2/prctl.2:1521
msgid "I<arg4> or I<arg5> is nonzero;"
msgstr "Значение I<arg4> или I<arg5> не равно нулю;"

#. type: Plain text
#: man-pages/man2/prctl.2:1526
msgid ""
"I<arg3> is greater than B<TASK_SIZE> (the limit on the size of the user "
"address space for this architecture);"
msgstr ""
"Значение I<arg3> больше B<TASK_SIZE> (ограничение на размер "
"пользовательского адресного пространства для этой архитектуры);"

#. type: Plain text
#: man-pages/man2/prctl.2:1536
msgid ""
"I<arg2> is B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, or B<PR_SET_MM_START_STACK>, "
"and the permissions of the corresponding memory area are not as required;"
msgstr ""
"Значение I<arg2> равно B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA> или B<PR_SET_MM_START_STACK>, "
"и права на соответствующую область памяти не удовлетворяют требованиям;"

#. type: Plain text
#: man-pages/man2/prctl.2:1548
msgid ""
"I<arg2> is B<PR_SET_MM_START_BRK> or B<PR_SET_MM_BRK>, and I<arg3> is less "
"than or equal to the end of the data segment or specifies a value that would "
"cause the B<RLIMIT_DATA> resource limit to be exceeded."
msgstr ""
"Значение I<arg2> равно B<PR_SET_MM_START_BRK> или B<PR_SET_MM_BRK>, и "
"значение I<arg3> меньше или равно концу сегмента данных, или было бы "
"превышено ограничение ресурса B<RLIMIT_DATA>."

#. type: Plain text
#: man-pages/man2/prctl.2:1559
msgid ""
"I<option> is B<PR_SET_PTRACER> and I<arg2> is not 0, B<PR_SET_PTRACER_ANY>, "
"or the PID of an existing process."
msgstr ""
"Значение I<option> равно B<PR_SET_PTRACER> и значение I<arg2> не равно 0, "
"B<PR_SET_PTRACER_ANY> или PID существующего процесса."

#. type: Plain text
#: man-pages/man2/prctl.2:1567
msgid ""
"I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgstr ""
"Значение I<option> равно B<PR_SET_PDEATHSIG> и значение I<arg2> не является "
"корректным номером сигнала."

#. type: Plain text
#: man-pages/man2/prctl.2:1578
msgid ""
"I<option> is B<PR_SET_DUMPABLE> and I<arg2> is neither B<SUID_DUMP_DISABLE> "
"nor B<SUID_DUMP_USER>."
msgstr ""
"Значение I<option> равно B<PR_SET_DUMPABLE> и значение I<arg2> не равно "
"B<SUID_DUMP_DISABLE> или B<SUID_DUMP_USER>."

#. type: Plain text
#: man-pages/man2/prctl.2:1587
msgid ""
"I<option> is B<PR_SET_TIMING> and I<arg2> is not B<PR_TIMING_STATISTICAL>."
msgstr ""
"Значение I<option> равно B<PR_SET_TIMING> и значение I<arg2> не равно "
"B<PR_TIMING_STATISTICAL>."

#. type: Plain text
#: man-pages/man2/prctl.2:1601
msgid ""
"I<option> is B<PR_SET_NO_NEW_PRIVS> and I<arg2> is not equal to 1 or "
"I<arg3>, I<arg4>, or I<arg5> is nonzero."
msgstr ""
"Значение I<option> равно B<PR_SET_NO_NEW_PRIVS> и значение I<arg2> не равно "
"1 или I<arg3>, I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:1613
msgid ""
"I<option> is B<PR_GET_NO_NEW_PRIVS> and I<arg2>, I<arg3>, I<arg4>, or "
"I<arg5> is nonzero."
msgstr ""
"Значение I<option> равно B<PR_GET_NO_NEW_PRIVS> и значения I<arg2>, I<arg3>, "
"I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:1624
msgid ""
"I<option> is B<PR_SET_THP_DISABLE> and I<arg3>, I<arg4>, or I<arg5> is "
"nonzero."
msgstr ""
"Значение I<option> равно B<PR_SET_THP_DISABLE> и I<arg3>, I<arg4> или "
"I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:1636
msgid ""
"I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or I<arg5> "
"is nonzero."
msgstr ""
"Значение I<option> равно B<PR_GET_THP_DISABLE> и значения I<arg2>, I<arg3>, "
"I<arg4> или I<arg5> не равны нулю."

#. type: Plain text
#: man-pages/man2/prctl.2:1661
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and an unused argument (I<arg4>, I<arg5>, or, "
"in the case of B<PR_CAP_AMBIENT_CLEAR_ALL>, I<arg3>)  is nonzero; or I<arg2> "
"has an invalid value; or I<arg2> is B<PR_CAP_AMBIENT_LOWER>, "
"B<PR_CAP_AMBIENT_RAISE>, or B<PR_CAP_AMBIENT_IS_SET> and I<arg3> does not "
"specify a valid capability."
msgstr ""
"Значение I<option> равно B<PR_CAP_AMBIENT> и неиспользуемый аргумент "
"(I<arg4>, I<arg5> или, в случае B<PR_CAP_AMBIENT_CLEAR_ALL>, I<arg3>)  не "
"равен нулю; или I<arg2> содержит некорректное значение; или I<arg2> равно "
"B<PR_CAP_AMBIENT_LOWER>, B<PR_CAP_AMBIENT_RAISE> или "
"B<PR_CAP_AMBIENT_IS_SET> и в I<arg3> указан некорректный мандат."

#. type: Plain text
#: man-pages/man2/prctl.2:1667
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> the kernel or CPU does not support "
"the requested speculation misfeature."
msgstr ""
"Значение I<option> равно B<PR_SET_SPECULATION_CTRL>, но ядро или ЦП не "
"поддерживает запрашиваемую нежелательную спекулятовность."

#. type: Plain text
#: man-pages/man2/prctl.2:1676
msgid ""
"I<option> was B<PR_MPX_ENABLE_MANAGEMENT> or B<PR_MPX_DISABLE_MANAGEMENT> "
"and the kernel or the CPU does not support MPX management.  Check that the "
"kernel and processor have MPX support."
msgstr ""
"Значение I<option> было B<PR_MPX_ENABLE_MANAGEMENT> или "
"B<PR_MPX_DISABLE_MANAGEMENT> и ядро или ЦП не поддерживают управление MPX. "
"Проверьте, что ядро и процессор поддерживают MPX."

#. type: Plain text
#: man-pages/man2/prctl.2:1685
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> implies that the control of the "
"selected speculation misfeature is not possible.  See "
"B<PR_GET_SPECULATION_CTRL> for the bit fields to determine which option is "
"available."
msgstr ""
"Значение I<option>, равное B<PR_SET_SPECULATION_CTRL>, подразумевает, что "
"управление выбранной нежелательной спекулятовности невозможно. Доступные "
"значения смотрите в описании битовых полей B<PR_GET_SPECULATION_CTRL>."

#. type: Plain text
#: man-pages/man2/prctl.2:1693
msgid ""
"I<option> is B<PR_SET_FP_MODE> and I<arg2> has an invalid or unsupported "
"value."
msgstr ""
"Значение I<option> равно B<PR_SET_FP_MODE> и I<arg2> содержит неправильное "
"или неподдерживаемое значение."

#. type: Plain text
#: man-pages/man2/prctl.2:1705
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr ""
"Значение I<option> равно B<PR_SET_SECUREBITS>, и вызывающий не имеет мандата "
"B<CAP_SETPCAP>, или пытается сбросить «заблокированный» флаг, или пытается "
"установить флаг, для которого установлен соответствующий заблокированный "
"флаг (смотрите B<capabilities>(7))."

#. type: Plain text
#: man-pages/man2/prctl.2:1713
msgid ""
"I<option> is B<PR_SET_SPECULATION_CTRL> wherein the speculation was disabled "
"with B<PR_SPEC_FORCE_DISABLE> and caller tried to enable it again."
msgstr ""
"Значение I<option> равно B<PR_SET_SPECULATION_CTRL>, но спекулятивность была "
"отключена с помощью B<PR_SPEC_FORCE_DISABLE>, а вызывающий пытается включить "
"её снова."

#. type: Plain text
#: man-pages/man2/prctl.2:1723
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the caller's B<SECBIT_KEEP_CAPS_LOCKED> "
"flag is set (see B<capabilities>(7))."
msgstr ""
"Значение I<option> равно B<PR_SET_KEEPCAPS>, и у вызывающего установлен флаг "
"B<SECBIT_KEEP_CAPS_LOCKED> (смотрите B<capabilities>(7))."

#. type: Plain text
#: man-pages/man2/prctl.2:1731
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr ""
"Значение I<option> равно B<PR_CAPBSET_DROP>, и вызывающий не имеет мандата "
"B<CAP_SETPCAP>."

#. type: Plain text
#: man-pages/man2/prctl.2:1739
msgid ""
"I<option> is B<PR_SET_MM>, and the caller does not have the "
"B<CAP_SYS_RESOURCE> capability."
msgstr ""
"Значение I<option> равно B<PR_SET_MM>, и вызывающий не имеет мандата "
"B<CAP_SYS_RESOURCE>."

#. type: Plain text
#: man-pages/man2/prctl.2:1754
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and I<arg2> is B<PR_CAP_AMBIENT_RAISE>, but "
"either the capability specified in I<arg3> is not present in the process's "
"permitted and inheritable capability sets, or the B<PR_CAP_AMBIENT_LOWER> "
"securebit has been set."
msgstr ""
"Значение I<option> равно B<PR_CAP_AMBIENT> и I<arg2> равно "
"B<PR_CAP_AMBIENT_RAISE>, но мандат, указанный в I<arg3>, отсутствует в "
"разрешительном или унаследованном наборе мандатов, или был установлен бит "
"безопасности B<PR_CAP_AMBIENT_LOWER>."

#. type: TP
#: man-pages/man2/prctl.2:1754
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man2/prctl.2:1766
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> and I<arg3> is neither "
"B<PR_SPEC_ENABLE>, B<PR_SPEC_DISABLE>, nor B<PR_SPEC_FORCE_DISABLE>."
msgstr ""
"Значение I<option> равно B<PR_SET_SPECULATION_CTRL>, но значение I<arg3> не "
"равно B<PR_SPEC_ENABLE>, B<PR_SPEC_DISABLE> или B<PR_SPEC_FORCE_DISABLE>."

#. type: Plain text
#: man-pages/man2/prctl.2:1776
msgid ""
"I<option> was B<PR_GET_SPECULATION_CTRL> or B<PR_SET_SPECULATION_CTRL> and "
"unused arguments to B<prctl>()  are not 0."
msgstr ""
"Значение I<option> равно B<PR_GET_SPECULATION_CTRL> или "
"B<PR_SET_SPECULATION_CTRL>, но неиспользуемые аргументы B<prctl>() не равны "
"0."

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: man-pages/man2/prctl.2:1781
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr "Системный вызов B<prctl>() впервые появился в Linux 2.1.57."

#. type: Plain text
#: man-pages/man2/prctl.2:1788
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr ""
"Данный вызов существует только в Linux. В IRIX есть системный вызов "
"B<prctl>() (также представленный в Linux 2.1.44 как irix_prctl на "
"архитектуре MIPS) объявленный как"

#. type: Plain text
#: man-pages/man2/prctl.2:1792
#, no-wrap
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>\n"
msgstr "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>\n"

#. type: Plain text
#: man-pages/man2/prctl.2:1799
msgid ""
"and options to get the maximum number of processes per user, get the maximum "
"number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"and so on."
msgstr ""
"а также операции, позволяющие получить максимальное количество процессов для "
"каждого пользователя, максимальное количество процессоров, которое может "
"использовать вызывающий процесс; определить, блокирован ли заданный процесс; "
"получить или установить максимальный размер стека и т. д."

#. type: Plain text
#: man-pages/man2/prctl.2:1801
msgid "B<signal>(2), B<core>(5)"
msgstr "B<signal>(2), B<core>(5)"

#. type: TH
#: man-pages/man2/posix_fadvise.2:29
#, no-wrap
msgid "POSIX_FADVISE"
msgstr "POSIX_FADVISE"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:32
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr ""
"posix_fadvise - предварительно декларирует вариант доступа для данных файла"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:35
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:38
#, no-wrap
msgid "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"
msgstr "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:47
msgid "B<posix_fadvise>():"
msgstr "B<posix_fadvise>():"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:49
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:57
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""
"Программы могут использовать B<posix_fadvise>() для объявления намерений "
"осуществить доступ к файлу данных в скором будущем определённым образом, тем "
"самым позволяя ядру выполнить некоторые операции по оптимизации."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:64
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""
"Аргумент I<advice> применяется к (не обязательно существующей) области, "
"начинающейся с I<offset>, длиной I<len> байт (или до конца файла, если "
"I<len> равно 0) внутри файла, на который ссылается I<fd>. Аргумент I<advice> "
"не является привязкой; он всего лишь выражает ожидание приложения."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:66
msgid "Permissible values for I<advice> include:"
msgstr "Допустимые значения I<advice>:"

#. type: TP
#: man-pages/man2/posix_fadvise.2:66
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr "B<POSIX_FADV_NORMAL>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:72
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""
"Указывает, что приложение не может подсказать тип доступа для указанных "
"данных. Если не указано предположение для открываемого файла, то "
"используется предположение по умолчанию."

#. type: TP
#: man-pages/man2/posix_fadvise.2:72
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr "B<POSIX_FADV_SEQUENTIAL>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:76
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""
"Приложение ожидает последовательный доступ к указанным данным (чтение "
"выполняется начиная с младших адресов)."

#. type: TP
#: man-pages/man2/posix_fadvise.2:76
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr "B<POSIX_FADV_RANDOM>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:79
msgid "The specified data will be accessed in random order."
msgstr "Указанные данные будут запрашиваться в случайном порядке."

#. type: TP
#: man-pages/man2/posix_fadvise.2:79
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr "B<POSIX_FADV_NOREUSE>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:82
msgid "The specified data will be accessed only once."
msgstr "Указанные данные будут запрошены только один раз."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:86
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""
"В ядрах до версии 2.6.18, для B<POSIX_FADV_NOREUSE> использовалась такая же "
"семантика что и у B<POSIX_FADV_WILLNEED>. Это, вероятно, было дефектом; "
"начиная с ядра 2.6.18 для этого флага нет операции."

#. type: TP
#: man-pages/man2/posix_fadvise.2:86
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr "B<POSIX_FADV_WILLNEED>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:89
msgid "The specified data will be accessed in the near future."
msgstr "Указанные данные будут запрошены в скором будущем."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:96
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""
"При B<POSIX_FADV_WILLNEED> запускается неблокировочное чтение указанной "
"области в страницу кэша. Число неблокированных данных может быть уменьшено "
"ядром в зависимости от загрузки виртуальной памяти (несколько мегабайт "
"памяти наверняка будут выделены, а больше, обычно, и не бывает нужно)."

#. type: TP
#: man-pages/man2/posix_fadvise.2:96
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr "B<POSIX_FADV_DONTNEED>"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:99
msgid "The specified data will not be accessed in the near future."
msgstr "Указанные данные не будут запрошены в скором будущем."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:107
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""
"При указании B<POSIX_FADV_DONTNEED> вызов пытается высвободить кэшированные "
"страницы, связанные с указанной областью. Это полезно, например, при "
"потоковой обработке больших файлов. Программа может периодически запрашивать "
"ядро об освобождении уже использованных кэшированных данных, так что "
"полезные кэшированные страницы не будут освобождаться."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:115
msgid ""
"Requests to discard partial pages are ignored.  It is preferable to preserve "
"needed data than discard unneeded data.  If the application requires that "
"data be considered for discarding, then I<offset> and I<len> must be page-"
"aligned."
msgstr ""
"Запросы на удаление частичных страниц игнорируются. Предпочтительней "
"сохранять необходимые данные, а не удалять ненужные. Если приложению "
"требуется, чтобы данные считались подходящими для удаления, то I<offset> и "
"I<len> должны быть выровнены по границе страницы."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:127
msgid ""
"The implementation I<may> attempt to write back dirty pages in the specified "
"region, but this is not guaranteed.  Any unwritten dirty pages will not be "
"freed.  If the application wishes to ensure that dirty pages will be "
"released, it should call B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""
"Реализация I<может> пытаться записать неактуальные (dirty) страницы "
"указанную область, но это не гарантируется. Все не записанные неактуальные "
"страницы не будут освобождены. Если приложение хочет обязательно освободить "
"неактуальные страницы, то оно сначала должно вызвать B<fsync>(2) или "
"B<fdatasync>(2)."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:130
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается номер "
"ошибки."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:134
msgid "The I<fd> argument was not a valid file descriptor."
msgstr "Аргумент I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:137
msgid "An invalid value was specified for I<advice>."
msgstr "Неверное значение I<advice>."

#. type: TP
#: man-pages/man2/posix_fadvise.2:137
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#.  commit 87ba81dba431232548ce29d5d224115d0c2355ac
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:147
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (B<ESPIPE> is the "
"error specified by POSIX, but before kernel version 2.6.16, Linux returned "
"B<EINVAL> in this case.)"
msgstr ""
"Указанный файловый дескриптор ссылается на канал (pipe) или FIFO (в этом "
"случае в Linux до версии  2.6.16, возвращал B<EINVAL>, хотя согласно POSIX "
"ошибка должна быть B<ESPIPE>)."

#.  of fadvise64_64()
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:155
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""
"Поддержка в ядре впервые появилась в Linux 2.5.60; используемый системный "
"вызов называется B<fadvise64>(). Поддержка в библиотеке glibc появилась в "
"версии 2.2; обёрточная функция называется B<posix_fadvise>()."

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:162
msgid ""
"Since Linux 3.18, support for the underlying system call is optional, "
"depending on the setting of the B<CONFIG_ADVISE_SYSCALLS> configuration "
"option."
msgstr ""
"Начиная с Linux 3.18 поддержка данного системного вызова необязательна, она "
"зависит от того, собрано ли ядро с параметром B<CONFIG_ADVISE_SYSCALLS>."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008.  Note that the type of the I<len> argument was "
"changed from I<size_t> to I<off_t> in POSIX.1-2003 TC1."
msgstr ""
"POSIX.1-2001, POSIX.1-2008. Заметим, что в POSIX.1-2003 TC1 тип аргумента "
"I<len> был изменён с I<size_t> на I<off_t>."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:177
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""
"В Linux B<POSIX_FADV_NORMAL> устанавливает окно упреждающего чтения согласно "
"используемому размеру по умолчанию для ниже лежащего устройства; "
"B<POSIX_FADV_SEQUENTIAL> удваивает этот размер, а B<POSIX_FADV_RANDOM> "
"отменяет упреждающее чтение вообще. Эти изменения влияют на весь файл, а не "
"только на указанную его область (но другие открытые обработчики файлов на "
"этом файле не изменяются)."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:182
msgid ""
"The contents of the kernel buffer cache can be cleared via the I</proc/sys/"
"vm/drop_caches> interface described in B<proc>(5)."
msgstr ""
"Содержимое буферного кэша ядра может быть очищено через интерфейс I</proc/"
"sys/vm/drop_caches>, описанный в B<proc>(5)."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:189
msgid ""
"One can obtain a snapshot of which pages of a file are resident in the "
"buffer cache by opening a file, mapping it with B<mmap>(2), and then "
"applying B<mincore>(2)  to the mapping."
msgstr ""
"Можно получить снимок страниц файла, которые располагаются в буферном кэше: "
"открыть файл, отобразить его через B<mmap>(2) и затем применить "
"B<mincore>(2) к отображению."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:199
msgid ""
"The name of the wrapper function in the C library is B<posix_fadvise>().  "
"The underlying system call is called B<fadvise64>()  (or, on some "
"architectures, B<fadvise64_64>()); the difference between the two is that "
"the former system call assumes that the type of the I<len> argument is "
"I<size_t>, while the latter expects I<loff_t> there."
msgstr ""
"Обёрточная функция в библиотеке C называется B<posix_fadvise>(). "
"Используемый ей системный вызов называется B<fadvise64>() (на некоторых "
"архитектурах — B<fadvise64_64>()); разница между ними в том, что в "
"библиотечной функциитип аргумента I<len> равен I<size_t>, а у системного "
"вызова — I<loff_t>."

#. type: SS
#: man-pages/man2/posix_fadvise.2:199
#, no-wrap
msgid "Architecture-specific variants"
msgstr "Варианты, зависящие от архитектуры"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:216
msgid ""
"Some architectures require 64-bit arguments to be aligned in a suitable pair "
"of registers (see B<syscall>(2)  for further detail).  On such "
"architectures, the call signature of B<posix_fadvise>()  shown in the "
"SYNOPSIS would force a register to be wasted as padding between the I<fd> "
"and I<offset> arguments.  Therefore, these architectures define a version of "
"the system call that orders the arguments suitably, but is otherwise exactly "
"the same as B<posix_fadvise>()."
msgstr ""
"На некоторых архитектурах требуется, чтобы 64-битные аргументы были "
"выровнены в подходящей паре регистров (подробности в B<syscall>(2)). На "
"таких архитектурах показанная в СИНТАКСИСЕ форма вызова B<posix_fadvise>() "
"приводила бы пустой трате регистра для заполнения между аргументами I<fd> и "
"I<offset>. Поэтому на этих архитектурах определена версия системного вызова "
"с исправленным порядком аргументов, иначе используется формат как у "
"B<posix_fadvise>()."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:218
msgid "For example, since Linux 2.6.14, ARM has the following system call:"
msgstr ""
"Например, начиная с Linux 2.6.14, в ARM есть следующий системный вызов:"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:223
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:231
msgid ""
"These architecture-specific details are generally hidden from applications "
"by the glibc B<posix_fadvise>()  wrapper function, which invokes the "
"appropriate architecture-specific system call."
msgstr ""
"Данные, зависящие от архитектуры, детали, обычно, скрываются от приложений в "
"обёрточной функции glibc B<posix_fadvise>(), которая использует "
"соответствующий архитектуре системный вызов."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:236
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""
"В ядрах до версии 2.6.6, если значение I<len> равнялось 0, то это "
"воспринималось дословно как «ноль байт», а не как «все байты до конца файла»."

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:242
msgid ""
"B<fincore>(1), B<mincore>(2), B<readahead>(2), B<sync_file_range>(2), "
"B<posix_fallocate>(3), B<posix_madvise>(3)"
msgstr ""
"B<fincore>(1), B<mincore>(2), B<readahead>(2), B<sync_file_range>(2), "
"B<posix_fallocate>(3), B<posix_madvise>(3)"

#. type: TH
#: man-pages/man2/ptrace.2:105
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: Plain text
#: man-pages/man2/ptrace.2:108
msgid "ptrace - process trace"
msgstr "ptrace - трассировка процесса"

#. type: Plain text
#: man-pages/man2/ptrace.2:111
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:114
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:123
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""
"Системный вызов B<ptrace>() позволяет указать какому процессу "
"(«трассировщику») можно наблюдать и контролировать выполнение другого "
"процесса («трассироемого»), просматривать и изменять его память и регистры. "
"Обычно, он используется для реализации отладочных точек прерывания и для "
"отслеживания системных вызовов."

#. type: Plain text
#: man-pages/man2/ptrace.2:134
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""
"Сначала, трассировщик должен присоединиться к трассируемой нити. "
"Присоединение и последующие команды выполняются для нитей: в многонитевом "
"процессе трассировщик может подключаться как к каждой нити (трассировщики "
"могут быть у разных нитей разными), так и не подключаться к некоторым нитям "
"вовсе. Поэтому на самом деле «трассируемая нить»  всегда означает «(одну) "
"нить», а не «процесс в целом (возможно многонитевой)». Команды ptrace всегда "
"посылаются определённой трассируемой нити с помощью вызова"

#. type: Plain text
#: man-pages/man2/ptrace.2:136
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr "    ptrace(PTRACE_foo, pid, …)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:140
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr "где I<pid> — идентификатор соответствующей нити Linux."

#. type: Plain text
#: man-pages/man2/ptrace.2:146
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""
"Заметим, что в этой странице «многонитевой процесс» означает группу нитей, "
"состоящую из нитей, созданных с помощью B<clone>(2) с флагом B<CLONE_THREAD>."

#. type: Plain text
#: man-pages/man2/ptrace.2:157
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an "
"B<execve>(2).  Alternatively, one process may commence tracing another "
"process using B<PTRACE_ATTACH> or B<PTRACE_SEIZE>."
msgstr ""
"Процесс может начать трассировку с вызова B<fork>(2), в получившемся "
"дочернем процессе выполнить действие B<PTRACE_TRACEME>, после чего (обычно) "
"выполнить B<execve>(2). Или же один процесс может начать отладку другого "
"процесса при помощи B<PTRACE_ATTACH> или B<PTRACE_SEIZE>."

#. type: Plain text
#: man-pages/man2/ptrace.2:174
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""
"При трассировке трассируемая нить останавливается каждый раз при получении "
"сигнала, даже если этот сигнал игнорируется (исключением является "
"B<SIGKILL>, работающий обычным образом). Трассировщик будет уведомлён об "
"этом при следующем вызове B<waitpid>(2) (или подобном «ожидающем» системном "
"вызове); этот вызов вернёт значение I<status>, в котором содержится "
"информация, указывающая на причину остановки трассируемой нити. Так как "
"трассируемая нить остановлена, трассировщик может использовать различные "
"запросы ptrace для обследования и изменения трассируемой нити. По окончании "
"трассировщик разрешает трассируемой нити продолжить работу, возможно "
"подавляя посылаемый ему сигнал (или даже отправляя вместо него другой "
"сигнал)."

#. type: Plain text
#: man-pages/man2/ptrace.2:184
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""
"Если флаг B<PTRACE_O_TRACEEXEC> не действует, то все успешные вызовы "
"B<execve>(2) трассируемой нитью будут приводить к отправки сигнала "
"B<SIGTRAP>, давая таким образом родителю шанс перехватить управление до "
"того, как начнёт выполняться новая программа."

#. type: Plain text
#: man-pages/man2/ptrace.2:188
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""
"По окончании трассировки трассировщик может заставить трассируемую нить "
"продолжить свою работу в обычном не трассируемом режиме с помощью "
"B<PTRACE_DETACH>."

#. type: Plain text
#: man-pages/man2/ptrace.2:192
msgid "The value of I<request> determines the action to be performed:"
msgstr "Значение аргумента I<request> определяет выполняемое действие:"

#. type: TP
#: man-pages/man2/ptrace.2:192
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "B<PTRACE_TRACEME>"

#. type: Plain text
#: man-pages/man2/ptrace.2:202
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""
"Указывает, что этот процесс будет трассирован своим родительским процессом. "
"Вероятно, процессу не следует посылать этот запрос, если родительский "
"процесс не готов к трассировке (аргументы I<pid>, I<addr> и I<data> "
"игнорируются)."

#. type: Plain text
#: man-pages/man2/ptrace.2:217
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT>, and "
"B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""
"Действие B<PTRACE_TRACEME> используется только в трассируемой нити; "
"остальные действия предназначены только для трассировщика. Для значений, "
"описанных ниже, в параметре I<pid> задаётся идентификатор трассируемой нити, "
"над которой будет производиться действие. Перед выполнением действий (кроме "
"B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT> и B<PTRACE_KILL>) "
"трассируемая нить должна быть остановлена."

#. type: TP
#: man-pages/man2/ptrace.2:217
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"

#. type: Plain text
#: man-pages/man2/ptrace.2:228
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored; but see NOTES.)"
msgstr ""
"Читает слово по адресу I<addr>, находящееся в памяти трассируемой нити, "
"возвращая это слово как результат вызова B<ptrace>() Linux не разделяет "
"адресные пространства текста и данных, поэтому оба вызова абсолютно "
"идентичны (значение I<data> игнорируется; но смотрите ЗАМЕЧАНИЯ)."

#. type: TP
#: man-pages/man2/ptrace.2:228
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "B<PTRACE_PEEKUSER>"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: man-pages/man2/ptrace.2:246
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see I<E<lt>sys/user."
"hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
"Typically, the offset must be word-aligned, though this might vary by "
"architecture.  See NOTES.  (I<data> is ignored; but see NOTES.)"
msgstr ""
"Читает слово по смещению I<addr> из области USER трассируемой нити, которая "
"содержит информацию о регистрах и процессе (смотрите I<E<lt>sys/"
"userhE<gt>>). Слово возвращается в качестве результата вызова B<ptrace>(). "
"Обычно, смещение должно быть выровнено по границе слова, хотя это может "
"зависеть от архитектуры системы. Смотрите ЗАМЕЧАНИЯ (значение I<data> "
"игнорируется; но смотрите ЗАМЕЧАНИЯ)."

#. type: TP
#: man-pages/man2/ptrace.2:246
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"

#. type: Plain text
#: man-pages/man2/ptrace.2:258
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""
"Копирует слово I<data> в память трассируемой нити по адресу I<addr>. В "
"настоящее время, как и для B<PTRACE_PEEKTEXT> и B<PTRACE_PEEKDATA>, эти два "
"действия одинаковы."

#. type: TP
#: man-pages/man2/ptrace.2:258
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "B<PTRACE_POKEUSER>"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: man-pages/man2/ptrace.2:274
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""
"Копирует слово I<data> по смещению I<addr> в область USER трассирумой нити. "
"Как и для B<PTRACE_PEEKUSER>, смещение должно быть выровнено по границе "
"слова. Для того, чтобы сохранить целостность ядра, некоторые изменения в "
"область USER вносить запрещено."

#. type: TP
#: man-pages/man2/ptrace.2:274
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:297
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>.  "
"B<PTRACE_GETREGS> and B<PTRACE_GETFPREGS> are not present on all "
"architectures."
msgstr ""
"Копирует, соответственно, регистры общего назначения или регистры "
"сопроцессора трассируемой нити в память трассировщика по адресу I<data>. "
"Формат передаваемой структуры описан в файле I<E<lt>sys/user.hE<gt>> "
"(значение I<addr> игнорируется). Заметим, что в системах SPARC "
"предназначение I<data> и I<addr> поменяны местами; то есть I<data> "
"игнорируется, а регистры копируются по адресу I<addr>. B<PTRACE_GETREGS> и "
"B<PTRACE_GETFPREGS> есть не на всех архитектурах."

#. type: TP
#: man-pages/man2/ptrace.2:297
#, no-wrap
msgid "B<PTRACE_GETREGSET> (since Linux 2.6.34)"
msgstr "B<PTRACE_GETREGSET> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/ptrace.2:318
msgid ""
"Read the tracee's registers.  I<addr> specifies, in an architecture-"
"dependent way, the type of registers to be read.  B<NT_PRSTATUS> (with "
"numerical value 1)  usually results in reading of general-purpose "
"registers.  If the CPU has, for example, floating-point and/or vector "
"registers, they can be retrieved by setting I<addr> to the corresponding "
"B<NT_foo> constant.  I<data> points to a B<struct iovec>, which describes "
"the destination buffer's location and length.  On return, the kernel "
"modifies B<iov.len> to indicate the actual number of bytes returned."
msgstr ""
"Читает регистры трассируемой нити. В I<addr> указывается, в зависящей от "
"архитектуры форме, тип читаемых регистров. Значение B<NT_PRSTATUS> (равно 1) "
"обычно служит для чтения регистров общего назначения. Если в ЦП есть, "
"например, векторные регистры и для плавающей запятой, то их можно получить "
"назначив I<addr> соответствующую константу B<NT_foo>. Значение I<data> "
"указывает на B<struct iovec>, которая описывает расположение буфера "
"назначения и длину. При возврате ядро изменяет B<iov.len>, возвращая "
"реальное количество возвращаемых байт."

#. type: TP
#: man-pages/man2/ptrace.2:318
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"

#.  FIXME . In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: man-pages/man2/ptrace.2:343
msgid ""
"Modify the tracee's general-purpose or floating-point registers, "
"respectively, from the address I<data> in the tracer.  As for "
"B<PTRACE_POKEUSER>, some general-purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)  Note that SPARC systems have the meaning "
"of I<data> and I<addr> reversed; that is, I<data> is ignored and the "
"registers are copied from the address I<addr>.  B<PTRACE_SETREGS> and "
"B<PTRACE_SETFPREGS> are not present on all architectures."
msgstr ""
"Копирует, соответственно, регистры общего назначения или регистры для "
"плавающей запятой трассируемой нити из памяти трассировщика по адресу "
"I<data>. Как и в случае c B<PTRACE_POKEUSER>, изменения некоторых регистров "
"общего назначения запрещены (значение I<addr> игнорируется). Заметим, что в "
"системах SPARC предназначение I<data> и I<addr> переставлены местами; то "
"есть I<data> игнорируется, а регистры копируются из памяти, на которую "
"указывает адрес I<addr>. B<PTRACE_SETREGS> и B<PTRACE_SETFPREGS> есть не для "
"всех архитектур."

#. type: TP
#: man-pages/man2/ptrace.2:343
#, no-wrap
msgid "B<PTRACE_SETREGSET> (since Linux 2.6.34)"
msgstr "B<PTRACE_SETREGSET> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/ptrace.2:352
msgid ""
"Modify the tracee's registers.  The meaning of I<addr> and I<data> is "
"analogous to B<PTRACE_GETREGSET>."
msgstr ""
"Изменяет регистры трассируемой нити. Значение I<addr> и I<data> аналогичны "
"B<PTRACE_GETREGSET>."

#. type: TP
#: man-pages/man2/ptrace.2:352
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_GETSIGINFO> (начиная с Linux 2.3.99-pre6)"

#. type: Plain text
#: man-pages/man2/ptrace.2:364
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""
"Получает информацию о сигнале, который вызвал остановку. Копирует структуру "
"I<siginfo_t> (смотрите B<sigaction>(2)) из трассируемой нити в память "
"трассировщика по адресу I<data> (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:364
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_SETSIGINFO> (начиная с Linux 2.3.99-pre6)"

#. type: Plain text
#: man-pages/man2/ptrace.2:380
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""
"Устанавливает информацию о сигнале. Копирует структуру I<siginfo_t>, "
"расположенную по адресу I<data> трассировщика, в память трассируемой нити. "
"Влияет только на сигналы, которые обычно были бы доставлены трассируемой "
"нити и были пойманы трассировщиком. Затруднительно отличить обычные сигналы "
"от созданных самим B<ptrace>() (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:380
#, no-wrap
msgid "B<PTRACE_PEEKSIGINFO> (since Linux 3.10)"
msgstr "B<PTRACE_PEEKSIGINFO> (начиная с Linux 3.10)"

#.  commit 84c751bd4aebbaae995fe32279d3dba48327bad4
#. type: Plain text
#: man-pages/man2/ptrace.2:406
msgid ""
"Retrieve I<siginfo_t> structures without removing signals from a queue.  "
"I<addr> points to a I<ptrace_peeksiginfo_args> structure that specifies the "
"ordinal position from which copying of signals should start, and the number "
"of signals to copy.  I<siginfo_t> structures are copied into the buffer "
"pointed to by I<data>.  The return value contains the number of copied "
"signals (zero indicates that there is no signal corresponding to the "
"specified ordinal position).  Within the returned I<siginfo> structures, the "
"I<si_code> field includes information (B<__SI_CHLD>, B<__SI_FAULT>, etc.) "
"that are not otherwise exposed to user space."
msgstr ""
"Получает структуры I<siginfo_t> не удаляя сигналы из очереди. Значение "
"I<addr> указывает на структуру I<ptrace_peeksiginfo_args>, которая задаёт "
"начальную позицию, из которой нужно начать копирование сигналов, а также их "
"количество. Структуры I<siginfo_t> копируются в буфер, указываемый в "
"I<data>. Возвращаемое значение содержит количество скопированных сигналов "
"(ноль означает, что сигналов в указанной позиции нет). Внутри возвращаемых "
"структур I<siginfo> в поле I<si_code> включается информация (B<__SI_CHLD>, "
"B<__SI_FAULT> и т. д.), которая по-другому никак не выдаётся в "
"пользовательское пространство."

#. type: Plain text
#: man-pages/man2/ptrace.2:415
#, no-wrap
msgid ""
"struct ptrace_peeksiginfo_args {\n"
"    u64 off;    /* Ordinal position in queue at which\n"
"                   to start copying signals */\n"
"    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */\n"
"    s32 nr;     /* Number of signals to copy */\n"
"};\n"
msgstr ""
"struct ptrace_peeksiginfo_args {\n"
"    u64 off;    /* начальная позиция в очереди, с которой\n"
"                   начинается копирование сигналов */\n"
"    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED или 0 */\n"
"    s32 nr;     /* количество копируемых сигналов */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:423
msgid ""
"Currently, there is only one flag, B<PTRACE_PEEKSIGINFO_SHARED>, for dumping "
"signals from the process-wide signal queue.  If this flag is not set, "
"signals are read from the per-thread queue of the specified thread."
msgstr ""
"В настоящее время определён только один флаг, B<PTRACE_PEEKSIGINFO_SHARED>, "
"служащий для выборки сигналов из общей очереди сигналов процессов. Если этот "
"флаг не указан, то сигналы читаются из очереди указанной нити."

#. type: TP
#: man-pages/man2/ptrace.2:425
#, no-wrap
msgid "B<PTRACE_GETSIGMASK> (since Linux 3.11)"
msgstr "B<PTRACE_GETSIGMASK> (начиная с Linux 3.11)"

#.  commit 29000caecbe87b6b66f144f72111f0d02fbbf0c1
#. type: Plain text
#: man-pages/man2/ptrace.2:440
msgid ""
"Place a copy of the mask of blocked signals (see B<sigprocmask>(2))  in the "
"buffer pointed to by I<data>, which should be a pointer to a buffer of type "
"I<sigset_t>.  The I<addr> argument contains the size of the buffer pointed "
"to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr ""
"Помещает копию маски блокированных сигналов (смотрите B<sigprocmask>(2)) в "
"буфер, указанный в I<data> (должен быть указателем на буфер с типом "
"I<sigset_t>). Аргумент I<addr> содержит размер буфера, указанного в I<data> "
"(т. е. I<sizeof(sigset_t)>)."

#. type: TP
#: man-pages/man2/ptrace.2:440
#, no-wrap
msgid "B<PTRACE_SETSIGMASK> (since Linux 3.11)"
msgstr "B<PTRACE_SETSIGMASK> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man2/ptrace.2:454
msgid ""
"Change the mask of blocked signals (see B<sigprocmask>(2))  to the value "
"specified in the buffer pointed to by I<data>, which should be a pointer to "
"a buffer of type I<sigset_t>.  The I<addr> argument contains the size of the "
"buffer pointed to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr ""
"Изменяет маску блокированных сигналов (смотрите B<sigprocmask>(2)) на "
"значение из буфера, указанного в I<data> (должен быть указателем на буфер с "
"типом I<sigset_t>). Аргумент I<addr> содержит размер буфера, указанного в "
"I<data> (т. е. I<sizeof(sigset_t)>)."

#. type: TP
#: man-pages/man2/ptrace.2:454
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr "B<PTRACE_SETOPTIONS> (начиная с Linux 2.4.6; см. предостережения в разделе ДЕФЕКТЫ)"

#. type: Plain text
#: man-pages/man2/ptrace.2:463
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""
"Устанавливает флаги ptrace из I<data> (значение I<addr> игнорируется). "
"Значение I<data> воспринимается как битовая маска, в которой задаются "
"следующие флаги:"

#. type: TP
#: man-pages/man2/ptrace.2:464
#, no-wrap
msgid "B<PTRACE_O_EXITKILL> (since Linux 3.8)"
msgstr "B<PTRACE_O_EXITKILL> (начиная с Linux 3.8)"

#.  commit 992fb6e170639b0849bace8e49bf31bd37c4123
#. type: Plain text
#: man-pages/man2/ptrace.2:472
msgid ""
"Send a B<SIGKILL> signal to the tracee if the tracer exits.  This option is "
"useful for ptrace jailers that want to ensure that tracees can never escape "
"the tracer's control."
msgstr ""
"Посылать сигнал B<SIGKILL> трассируемому, если трассировщик существует. Этот "
"параметр полезен для надзирателей ptrace, которые хотят убедиться, что "
"трассируемые никогда не выйдут из-под контроля трассировщика."

#. type: TP
#: man-pages/man2/ptrace.2:472
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACECLONE> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:489
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""
"Останавливать трассируемую нить при следующем вызове B<clone>(2) и "
"автоматически запускать трассировку только что склонированного процесса, "
"который начнёт выполнение с обработки сигнала B<SIGSTOP> или "
"B<PTRACE_EVENT_STOP>, если используется B<PTRACE_SEIZE>. Вызов B<waitpid>(2) "
"вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:492
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:496 man-pages/man2/ptrace.2:582
#: man-pages/man2/ptrace.2:613
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"Значение PID нового процесса можно получить с помощью B<PTRACE_GETEVENTMSG>."

#. type: Plain text
#: man-pages/man2/ptrace.2:517
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""
"В некоторых случаях вызовы B<clone>(2) могут быть не пойманы. Если "
"трассируемая нить вызывает B<clone>(2) с флагом B<CLONE_VFORK>, то будет "
"доставлен B<PTRACE_EVENT_VFORK>, если установлен B<PTRACE_O_TRACEVFORK>; в "
"противном случае, если трассируемая нить вызывает B<clone>(2) с "
"установленным сигналом выхода равным B<SIGCHLD>, то будет доставлен "
"B<PTRACE_EVENT_FORK>, если установлен B<PTRACE_O_TRACEFORK>."

#. type: TP
#: man-pages/man2/ptrace.2:517
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEEXEC> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:526
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""
"Останавливать трассируемую нить при следующем вызове B<execve>(). Вызов "
"B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:529
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:535
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"Если исполняемая нить не является лидером группы нитей, то идентификатор "
"нити сбрасывается в значение идентификатора лидера группы нитей перед его "
"остановкой. Начиная с Linux 3.0, предыдущий идентификатор нити может быть "
"получен с помощью B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:535
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEEXIT> (начиная с Linux 2.5.60)"

#. type: Plain text
#: man-pages/man2/ptrace.2:543
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""
"Останавливать трассируемую нить при его завершении (exit). Вызов "
"B<waitpid>() вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:546
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:550
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"Значение кода завершения трассируемой нити можно получить с помощью "
"B<PTRACE_GETEVENTMSG>."

#. type: Plain text
#: man-pages/man2/ptrace.2:558
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""
"Остановка трассируемой нити будет выполнена в начальный момент завершения, "
"когда ещё доступны регистры, что позволяет трассировщику увидеть откуда "
"выполнялось завершение (обычное уведомление о завершении выполняется после "
"того как процесс уже завершил работу). Хотя в этот момент ещё доступен "
"контекст, трассировщик уже не может предотвратить завершение."

#. type: TP
#: man-pages/man2/ptrace.2:558
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEFORK> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:575
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""
"Останавливать трассируемую нить при следующем вызове B<fork>(2) и "
"автоматически запускать трассировку только что созданного с помощью fork "
"процесса, который начнёт выполнение с обработки сигнала B<SIGSTOP> или "
"B<PTRACE_EVENT_STOP>, если используется B<PTRACE_SEIZE>. Вызов B<waitpid>(2) "
"вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:578
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"

#. type: TP
#: man-pages/man2/ptrace.2:582
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr "B<PTRACE_O_TRACESYSGOOD> (начиная с Linux 2.4.6)"

#. type: Plain text
#: man-pages/man2/ptrace.2:589
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call."
msgstr ""
"При доставке сигналов ловушек системных вызовов, устанавливать бит 7 в "
"номере сигнала (т. е., доставляется I<SIGTRAP|0x80>). Это позволяет "
"трассировщику легко отличить обычные ловушки от тех, которые были вызваны "
"системным вызовом."

#. type: TP
#: man-pages/man2/ptrace.2:589
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEVFORK> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:606
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""
"Останавливать трассируемую нить при следующем вызове B<vfork>(2) и "
"автоматически запускать трассировку только что созданного с помощью vfork "
"процесса, который начнёт выполнение с обработки сигнала B<SIGSTOP> или "
"B<PTRACE_EVENT_STOP>, если используется B<PTRACE_SEIZE>. Вызов B<waitpid>(2) "
"вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:609
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"

#. type: TP
#: man-pages/man2/ptrace.2:613
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (начиная с Linux 2.5.60)"

#. type: Plain text
#: man-pages/man2/ptrace.2:622
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"Останавливать трассируемую нить при следующем вызове B<vfork>(2). Вызов "
"B<waitpid>(2) вернёт трассировщику значение I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:625
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:629
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""
"Значение PID нового процесса можно получить (начиная с Linux 2.6.18) с "
"помощью B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:629
#, no-wrap
msgid "B<PTRACE_O_TRACESECCOMP> (since Linux 3.5)"
msgstr "B<PTRACE_O_TRACESECCOMP> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man2/ptrace.2:640
msgid ""
"Stop the tracee when a B<seccomp>(2)  B<SECCOMP_RET_TRACE> rule is "
"triggered.  A B<waitpid>(2)  by the tracer will return a I<status> value "
"such that"
msgstr ""
"Останавливать трассируемую нить при возникновении правила B<seccomp>(2)  "
"B<SECCOMP_RET_TRACE>. Вызов B<waitpid>(2) вернёт трассировщику значение "
"I<status>, которое равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:643
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMPE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMPE<lt>E<lt>8))\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:655
msgid ""
"While this triggers a B<PTRACE_EVENT> stop, it is similar to a syscall-enter-"
"stop.  For details, see the note on B<PTRACE_EVENT_SECCOMP> below.  The "
"seccomp event message data (from the B<SECCOMP_RET_DATA> portion of the "
"seccomp filter rule) can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"Так как это останавливает B<PTRACE_EVENT>, это похоже на syscall-enter-stop. "
"Дополнительную информацию смотрите в замечании к B<PTRACE_EVENT_SECCOMP> "
"ниже. Данные сообщения события seccomp (из части B<SECCOMP_RET_DATA> правила "
"фильтрации seccomp) можно получить с помощью B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:655
#, no-wrap
msgid "B<PTRACE_O_SUSPEND_SECCOMP> (since Linux 4.3)"
msgstr "B<PTRACE_O_SUSPEND_SECCOMP> (начиная с Linux 4.3)"

#.  commit 13c4a90119d28cfcb6b5bdd820c233b86c2b0237
#. type: Plain text
#: man-pages/man2/ptrace.2:671
msgid ""
"Suspend the tracee's seccomp protections.  This applies regardless of mode, "
"and can be used when the tracee has not yet installed seccomp filters.  That "
"is, a valid use case is to suspend a tracee's seccomp protections before "
"they are installed by the tracee, let the tracee install the filters, and "
"then clear this flag when the filters should be resumed.  Setting this "
"option requires that the tracer have the B<CAP_SYS_ADMIN> capability, not "
"have any seccomp protections installed, and not have "
"B<PTRACE_O_SUSPEND_SECCOMP> set on itself."
msgstr ""
"Приостановить защиты seccomp трассируемого. Это применяется независимо от "
"режима и может быть использовано когда трассируемый ещё не установил фильтры "
"seccomp. То есть, корректным действием будет приостановка защит seccomp "
"трассируемого, до того как их установит трассируемый, позволить "
"трассируемому установить фильтры, и затем очистить этот флаг, когда нужно "
"возобновить работу фильтров. Установка этого параметра требует, чтобы "
"трассировщик имел мандат B<CAP_SYS_ADMIN>, не было установлено никаких защит "
"seccomp и не установлен сам B<PTRACE_O_SUSPEND_SECCOMP>."

#. type: TP
#: man-pages/man2/ptrace.2:672
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr "B<PTRACE_GETEVENTMSG> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/ptrace.2:699
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  For "
"B<PTRACE_EVENT_SECCOMP>, this is the B<seccomp>(2)  filter's "
"B<SECCOMP_RET_DATA> associated with the triggered rule.  (I<addr> is "
"ignored.)"
msgstr ""
"Возвращает сообщения (с типом I<unsigned long>) о событии ptrace, которое "
"только что произошло, помещая его по адресу I<data> в памяти трассировщика. "
"Для B<PTRACE_EVENT_EXIT> это код завершения трассируемой нити. Для "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE> и "
"B<PTRACE_EVENT_CLONE> это PID нового процесса. Для B<PTRACE_EVENT_SECCOMP> "
"это B<SECCOMP_RET_DATA> из фильтра B<seccomp>(2), связанного со сработавшим "
"правилом (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:699
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: man-pages/man2/ptrace.2:711
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""
"Возобновляет работу остановленной трассируемой нити. Если значение I<data> "
"не равно нулю, то оно считается номером сигнала, который надо доставить "
"трассируемой нити; в противном случае сигнал не передаётся. Таким образом, "
"например, трассировщик может контролировать передачу сигнала трассируемой "
"нити (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:711
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"

#. type: Plain text
#: man-pages/man2/ptrace.2:735
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""
"Аналогично B<PTRACE_CONT> они перезапускают остановленную трассируемую нить, "
"но указывают, что процесс должен быть остановлен перед входом/выходом из "
"системного вызова, или после исполнения одной инструкции, соответственно "
"(трассируемая нить также, как обычно, будет остановлена при получении "
"сигнала). С точки зрения трассировщика кажется, что трассируемая нить "
"остановлена из-за получения сигнала B<SIGTRAP>. Так, B<PTRACE_SYSCALL> "
"например, позволяет изучить содержимое аргументов перед системным вызовом, а "
"при следующем B<PTRACE_SYSCALL> можно просмотреть результат исполнения "
"системного вызова. Аргумент I<data> используется как в B<PTRACE_CONT> "
"(значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:735
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (начиная с Linux 2.6.14)"

#.  As at 3.7
#. type: Plain text
#: man-pages/man2/ptrace.2:757
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  See the documentation on syscall-stops below.  "
"For B<PTRACE_SYSEMU_SINGLESTEP>, do the same but also singlestep if not a "
"system call.  This call is used by programs like User Mode Linux that want "
"to emulate all the tracee's system calls.  The I<data> argument is treated "
"as for B<PTRACE_CONT>.  The I<addr> argument is ignored.  These requests are "
"currently supported only on x86."
msgstr ""
"Действие B<PTRACE_SYSEMU> приводит к продолжению и остановке на входе в "
"следующий системный вызов, который не будет выполнен . Смотрите описание по "
"syscall-stop ниже. Действие B<PTRACE_SYSEMU_SINGLESTEP> выполняет тоже "
"самое, но для одиночной инструкции, если это не системный вызов. Это "
"действие используется программами, подобными User Mode Linux, которым нужно "
"эмулировать все системные вызовы трассируемых нитей. Аргумент I<data> "
"используется также как у B<PTRACE_CONT>.  Аргумент I<addr> игнорируется. Эти "
"запросы поддерживаются только на x86."

#. type: TP
#: man-pages/man2/ptrace.2:757
#, no-wrap
msgid "B<PTRACE_LISTEN> (since Linux 3.4)"
msgstr "B<PTRACE_LISTEN> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/ptrace.2:768
msgid ""
"Restart the stopped tracee, but prevent it from executing.  The resulting "
"state of the tracee is similar to a process which has been stopped by a "
"B<SIGSTOP> (or other stopping signal).  See the \"group-stop\" subsection "
"for additional information.  B<PTRACE_LISTEN> works only on tracees attached "
"by B<PTRACE_SEIZE>."
msgstr ""
"Перезапускает остановленную трассируемую нить, но её выполнение не "
"начинается. Полученное состояние трассируемой нити подобно процессу, который "
"был остановлен по B<SIGSTOP> (или другим останавливающим сигналом). "
"Дополнительную информацию смотрите в подразделе «group-stop». "
"B<PTRACE_LISTEN> работает только для трассируемых нитей, присоединённых с "
"помощью B<PTRACE_SEIZE>."

#. type: TP
#: man-pages/man2/ptrace.2:768
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "B<PTRACE_KILL>"

#. type: Plain text
#: man-pages/man2/ptrace.2:777
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""
"Посылает трассируемой нити сигнал B<SIGKILL> для его уничтожения (значения "
"I<addr> и I<data> игнорируются)."

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: man-pages/man2/ptrace.2:796
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""
"I<Это действие устарело; не используйте его!> Вместо него отправляйте "
"B<SIGKILL> напрямую с помощью B<kill>(2) или B<tgkill>(2). Проблема с "
"действием B<PTRACE_KILL> в том, что оно требует, чтобы трассируемая нить "
"была режиме signal-delivery-stop, в противном случае оно может не сработать "
"(т. е., может завершиться без ошибок, но трассируемая нить не будет "
"уничтожена). В отличие от него, отправка B<SIGKILL> напрямую не имеет "
"данного ограничения."

#. type: TP
#: man-pages/man2/ptrace.2:796
#, no-wrap
msgid "B<PTRACE_INTERRUPT> (since Linux 3.4)"
msgstr "B<PTRACE_INTERRUPT> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/ptrace.2:824
msgid ""
"Stop a tracee.  If the tracee is running or sleeping in kernel space and "
"B<PTRACE_SYSCALL> is in effect, the system call is interrupted and syscall-"
"exit-stop is reported.  (The interrupted system call is restarted when the "
"tracee is restarted.)  If the tracee was already stopped by a signal and "
"B<PTRACE_LISTEN> was sent to it, the tracee stops with B<PTRACE_EVENT_STOP> "
"and I<WSTOPSIG(status)> returns the stop signal.  If any other ptrace-stop "
"is generated at the same time (for example, if a signal is sent to the "
"tracee), this ptrace-stop happens.  If none of the above applies (for "
"example, if the tracee is running in user space), it stops with "
"B<PTRACE_EVENT_STOP> with I<WSTOPSIG(status)> == B<SIGTRAP>.  "
"B<PTRACE_INTERRUPT> only works on tracees attached by B<PTRACE_SEIZE>."
msgstr ""
"Остановить трассируемый объект. Если трассируемый объект выполняется или "
"спит в пространстве ядра и действует B<PTRACE_SYSCALL>, то системный вызов "
"прерывается и сообщается о syscall-exit-stop (прерванный системный вызов "
"перезапускается при перезапуске трассируемого объекта). Если трассируемый "
"объект был уже остановлен по сигналу и ему был послан B<PTRACE_LISTEN>, то "
"трассируемый объект останавливается с B<PTRACE_EVENT_STOP> и "
"I<WSTOPSIG(status)> возвращает сигнал остановки. Если в этот же момент "
"генерируется любое другое событие ptrace-stop (например, если трассируемому "
"посылается сигнал), то возникает ptrace-stop. Если ничего из "
"вышеперечисленного не происходит (например, если трассируемый выполняется в "
"пространстве пользователя), то он останавливается с B<PTRACE_EVENT_STOP> и "
"I<WSTOPSIG(status)> == B<SIGTRAP>. B<PTRACE_INTERRUPT> работает только для "
"трассируемых объектов, к которым подключились с помощью B<PTRACE_SEIZE>."

#. type: TP
#: man-pages/man2/ptrace.2:824
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "B<PTRACE_ATTACH>"

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: man-pages/man2/ptrace.2:852
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""
"Выполняет присоединение к процессу с указанным I<pid>, делая его "
"трассируемым для вызывающего процесса. Трассируемой нити посылается "
"B<SIGSTOP>, но нет жёсткого правила, что она будет остановлен по завершению "
"этого вызова; используйте B<waitpid>(2) для ожидания остановки трассируемой "
"нити. Дополнительную информацию смотрите в подразделе «Присоединение и "
"отсоединение» (значения I<addr> и I<data> игнорируются)."

#. type: Plain text
#: man-pages/man2/ptrace.2:858
msgid ""
"Permission to perform a B<PTRACE_ATTACH> is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_REALCREDS> check; see below."
msgstr ""
"Право выполнять B<PTRACE_ATTACH> определяется проверкой режима доступа "
"ptrace B<PTRACE_MODE_READ_REALCREDS>; смотрите ниже."

#. type: TP
#: man-pages/man2/ptrace.2:858
#, no-wrap
msgid "B<PTRACE_SEIZE> (since Linux 3.4)"
msgstr "B<PTRACE_SEIZE> (начиная с Linux 3.4)"

#.  Noted by Dmitry Levin:
#.      PTRACE_SEIZE was introduced by commit v3.1-rc1~308^2~28, but
#.      it had to be used along with a temporary flag PTRACE_SEIZE_DEVEL,
#.      which was removed later by commit v3.4-rc1~109^2~20.
#.      That is, [before] v3.4 we had a test mode of PTRACE_SEIZE API,
#.      which was not compatible with the current PTRACE_SEIZE API introduced
#.      in Linux 3.4.
#. type: Plain text
#: man-pages/man2/ptrace.2:912
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  Unlike B<PTRACE_ATTACH>, B<PTRACE_SEIZE> does not stop the "
"process.  Group-stops are reported as B<PTRACE_EVENT_STOP> and "
"I<WSTOPSIG(status)> returns the stop signal.  Automatically attached "
"children stop with B<PTRACE_EVENT_STOP> and I<WSTOPSIG(status)> returns "
"B<SIGTRAP> instead of having B<SIGSTOP> signal delivered to them.  "
"B<execve>(2)  does not deliver an extra B<SIGTRAP>.  Only a B<PTRACE_SEIZE>d "
"process can accept B<PTRACE_INTERRUPT> and B<PTRACE_LISTEN> commands.  The "
"\"seized\" behavior just described is inherited by children that are "
"automatically attached using B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, "
"and B<PTRACE_O_TRACECLONE>.  I<addr> must be zero.  I<data> contains a bit "
"mask of ptrace options to activate immediately."
msgstr ""
"Выполняет присоединение к процессу, указанному в I<pid>, делает его "
"трассируемым для вызывающего процесса. В отличие от B<PTRACE_ATTACH>, "
"B<PTRACE_SEIZE> не останавливает процесс. О group-stops сообщается как "
"B<PTRACE_EVENT_STOP> и I<WSTOPSIG(status)> возвращает сигнал остановки. "
"Автоматически присоединённые потомки останавливаются с B<PTRACE_EVENT_STOP> "
"и I<WSTOPSIG(status)> возвращает B<SIGTRAP> вместо доставки им сигнала "
"B<SIGSTOP>. При вызове B<execve>(2) дополнительный B<SIGTRAP> не посылается. "
"Только подключённые с помощью B<PTRACE_SEIZE> процессы могут принимать "
"команды B<PTRACE_INTERRUPT> и B<PTRACE_LISTEN>. Только что описанное "
"поведение «захвата» (seized) наследуется потомками, которые автоматически "
"присоединяются с помощью B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK> и "
"B<PTRACE_O_TRACECLONE>. Значение I<addr> должно быть равно нулю. В I<data> "
"содержится битовая маска параметров ptrace, которая применяется сразу же."

#. type: Plain text
#: man-pages/man2/ptrace.2:919
msgid ""
"Permission to perform a B<PTRACE_SEIZE> is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_REALCREDS> check; see below."
msgstr ""
"Право выполнять B<PTRACE_SEIZE> определяется проверкой режима доступа ptrace "
"B<PTRACE_MODE_READ_REALCREDS>; смотрите ниже."

#. type: TP
#: man-pages/man2/ptrace.2:919
#, no-wrap
msgid "B<PTRACE_SECCOMP_GET_FILTER> (since Linux 4.4)"
msgstr "B<PTRACE_SECCOMP_GET_FILTER> (начиная с Linux 4.4)"

#.  commit f8e529ed941ba2bbcbf310b575d968159ce7e895
#. type: Plain text
#: man-pages/man2/ptrace.2:924
msgid ""
"This operation allows the tracer to dump the tracee's classic BPF filters."
msgstr ""
"Эта операция позволяет трассировщику получить дамп классических фильтров BPF "
"трассируемого."

#. type: Plain text
#: man-pages/man2/ptrace.2:933
msgid ""
"I<addr> is an integer specifying the index of the filter to be dumped.  The "
"most recently installed filter has the index 0.  If I<addr> is greater than "
"the number of installed filters, the operation fails with the error "
"B<ENOENT>."
msgstr ""
"Значение I<addr> имеет тип integer и задаёт индекс фильтра для дампа. Индекс "
"последнего установленного фильтра равен 0. Если I<addr> больше количества "
"установленных фильтров, то операция завершается ошибкой B<ENOENT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:939
msgid ""
"I<data> is either a pointer to a I<struct sock_filter> array that is large "
"enough to store the BPF program, or NULL if the program is not to be stored."
msgstr ""
"Значение I<data> является указателем на массив I<struct sock_filter> "
"достаточного размера для сохранения программы BPF, или NULL, если программа "
"не будет сохраняться."

#. type: Plain text
#: man-pages/man2/ptrace.2:947
msgid ""
"Upon success, the return value is the number of instructions in the BPF "
"program.  If I<data> was NULL, then this return value can be used to "
"correctly size the I<struct sock_filter> array passed in a subsequent call."
msgstr ""
"При успешном выполнении возвращаемое значение — количество инструкций в "
"программе BPF. Если I<data> равнялось NULL, то возвращается значение, "
"которое можно использовать для создания массива I<struct sock_filter> "
"корректного размера, который будет передан в последующем вызове."

#. type: Plain text
#: man-pages/man2/ptrace.2:957
msgid ""
"This operation fails with the error B<EACCES> if the caller does not have "
"the B<CAP_SYS_ADMIN> capability or if the caller is in strict or filter "
"seccomp mode.  If the filter referred to by I<addr> is not a classic BPF "
"filter, the operation fails with the error B<EMEDIUMTYPE>."
msgstr ""
"Данная операция завершается ошибкой B<EACCES>, если вызывающий не имеет "
"мандата B<CAP_SYS_ADMIN>, или если вызывающий находится в ограничительном "
"или фильтрующем режиме. Если фильтр, на который ссылается адрес I<addr>, не "
"является классическим фильтром BPF, то операция завершается ошибкой "
"B<EMEDIUMTYPE>."

#. type: Plain text
#: man-pages/man2/ptrace.2:963
msgid ""
"This operation is available if the kernel was configured with both the "
"B<CONFIG_SECCOMP_FILTER> and the B<CONFIG_CHECKPOINT_RESTORE> options."
msgstr ""
"Эта операция доступна только, если ядро собрано с параметрами "
"B<CONFIG_SECCOMP_FILTER> и B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man2/ptrace.2:963
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "B<PTRACE_DETACH>"

#. type: Plain text
#: man-pages/man2/ptrace.2:973
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""
"Возобновляет работу остановленной трассируемой нити, аналогично "
"B<PTRACE_CONT>, но сначала отсоединяется от него. В Linux при помощи этого "
"вызова трассируемая нить может быть отсоединёна независимо от того, каким "
"методом была запущена трассировка (значение I<addr> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:973
#, no-wrap
msgid "B<PTRACE_GET_THREAD_AREA> (since Linux 2.6.0)"
msgstr "B<PTRACE_GET_THREAD_AREA> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man2/ptrace.2:990
msgid ""
"This operation performs a similar task to B<get_thread_area>(2).  It reads "
"the TLS entry in the GDT whose index is given in I<addr>, placing a copy of "
"the entry into the I<struct user_desc> pointed to by I<data>.  (By contrast "
"with B<get_thread_area>(2), the I<entry_number> of the I<struct user_desc> "
"is ignored.)"
msgstr ""
"Данная операция выполняет задачу, подобную B<get_thread_area>(2). Она читает "
"элемент TLS из GDT, чей индекс передан в I<addr>, помещает копию элемента в "
"I<struct user_desc>, указанную в I<data> (в отличие от "
"B<get_thread_area>(2), значение I<entry_number> структуры I<struct "
"user_desc> игнорируется)."

#. type: TP
#: man-pages/man2/ptrace.2:990
#, no-wrap
msgid "B<PTRACE_SET_THREAD_AREA> (since Linux 2.6.0)"
msgstr "B<PTRACE_SET_THREAD_AREA> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man2/ptrace.2:1008
msgid ""
"This operation performs a similar task to B<set_thread_area>(2).  It sets "
"the TLS entry in the GDT whose index is given in I<addr>, assigning it the "
"data supplied in the I<struct user_desc> pointed to by I<data>.  (By "
"contrast with B<set_thread_area>(2), the I<entry_number> of the I<struct "
"user_desc> is ignored; in other words, this ptrace operation can't be used "
"to allocate a free TLS entry.)"
msgstr ""
"Данная операция выполняет задачу, подобную B<set_thread_area>(2). Она "
"изменяет элемент TLS в GDT, чей индекс  указан в I<addr>, данными, "
"переданными в структуре I<struct user_desc>, на которую указывает I<data> (в "
"отличие от B<set_thread_area>(2), значение I<entry_number> структуры "
"I<struct user_desc> игнорируется; иначе говоря, данная операция ptrace не "
"может использоваться для выделения свободного элемента TLS)."

#. type: TP
#: man-pages/man2/ptrace.2:1008
#, no-wrap
msgid "B<PTRACE_GET_SYSCALL_INFO> (since Linux 5.3)"
msgstr "B<PTRACE_GET_SYSCALL_INFO> (начиная с Linux 5.3)"

#.  commit 201766a20e30f982ccfe36bebfad9602c3ff574a
#. type: Plain text
#: man-pages/man2/ptrace.2:1029
msgid ""
"Retrieve information about the system call that caused the stop.  The "
"information is placed into the buffer pointed by the I<data> argument, which "
"should be a pointer to a buffer of type I<struct ptrace_syscall_info>.  The "
"I<addr> argument contains the size of the buffer pointed to by the I<data> "
"argument (i.e., I<sizeof(struct ptrace_syscall_info)>).  The return value "
"contains the number of bytes available to be written by the kernel.  If the "
"size of the data to be written by the kernel exceeds the size specified by "
"the I<addr> argument, the output data is truncated."
msgstr ""
"Возвращает информацию о системном вызове, который привёл к останову. "
"Информация помещается в буфер, указанный в аргументе I<data>, который должен "
"быть указателем на буфер с типом I<struct ptrace_syscall_info>. Аргумент "
"I<addr> содержит размер буфера, на который указывает аргумент I<data> (т. "
"е., I<sizeof(struct ptrace_syscall_info)>). Возвращаемое значение равно "
"количеству байт, записанных ядром. Если размер записываемых ядром данных "
"больше значения из аргумента I<addr>, то данные результата обрезаются."

#. type: Plain text
#: man-pages/man2/ptrace.2:1033
msgid "The I<ptrace_syscall_info> structure contains the following fields:"
msgstr "Структура I<ptrace_syscall_info> содержит следующие поля:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1062
#, no-wrap
msgid ""
"struct ptrace_syscall_info {\n"
"    __u8 op;         /* Type of system call stop */\n"
"    __u32 arch;      /* AUDIT_ARCH_* value; see seccomp(2) */\n"
"    __u64 instruction_pointer; /* CPU instruction pointer */\n"
"    __u64 stack_pointer;       /* CPU stack pointer */\n"
"    union {\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_ENTRY */\n"
"            __u64 nr;          /* System call number */\n"
"            __u64 args[6];     /* System call arguments */\n"
"        } entry;\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_EXIT */\n"
"            __s64 rval;        /* System call return value */\n"
"            __u8 is_error;     /* System call error flag;\n"
"                                  Boolean: does rval contain\n"
"                                  an error value (-ERRCODE) or\n"
"                                  a nonerror return value? */\n"
"        } exit;\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_SECCOMP */\n"
"            __u64 nr;          /* System call number */\n"
"            __u64 args[6];     /* System call arguments */\n"
"            __u32 ret_data;    /* SECCOMP_RET_DATA portion\n"
"                                  of SECCOMP_RET_TRACE\n"
"                                  return value */\n"
"        } seccomp;\n"
"    };\n"
"};\n"
msgstr ""
"struct ptrace_syscall_info {\n"
"    __u8 op;         /* тип останова системного вызова */\n"
"    __u32 arch;      /* значение AUDIT_ARCH_*; смотрите seccomp(2) */\n"
"    __u64 instruction_pointer; /* указатель инструкции ЦП*/\n"
"    __u64 stack_pointer;       /* указатель стека ЦП */\n"
"    union {\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_ENTRY */\n"
"            __u64 nr;          /* номер системнго вызова */\n"
"            __u64 args[6];     /* аргументы системного вызова */\n"
"        } entry;\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_EXIT */\n"
"            __s64 rval;        /* возвращаемое системным вызовом значение */\n"
"            __u8 is_error;     /* флаг ошибки системного вызова;\n"
"                                  логический: содержит ли rval\n"
"                                  значение ошибки (-ERRCODE) или\n"
"                                  нет? */\n"
"        } exit;\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_SECCOMP */\n"
"            __u64 nr;          /* номер системного вызова */\n"
"            __u64 args[6];     /* аргументы системного вызова */\n"
"            __u32 ret_data;    /* часть SECCOMP_RET_DATA \n"
"                                  из возвращаемого значения\n"
"                                   SECCOMP_RET_TRACE */\n"
"        } seccomp;\n"
"    };\n"
"};\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1076
msgid ""
"The I<op>, I<arch>, I<instruction_pointer>, and I<stack_pointer> fields are "
"defined for all kinds of ptrace system call stops.  The rest of the "
"structure is a union; one should read only those fields that are meaningful "
"for the kind of system call stop specified by the I<op> field."
msgstr ""
"Поля I<op>, I<arch>, I<instruction_pointer> и I<stack_pointer> определены "
"для всех вариантов останова системного вызова ptrace. Оставшаяся структура "
"является объединением; из неё должны читаться только те поля, которые "
"подходят для конкретного останова системного вызова, указанного в поле I<op>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1083
msgid ""
"The I<op> field has one of the following values (defined in I<E<lt>linux/"
"ptrace.hE<gt>)> indicating what type of stop occurred and which part of the "
"union is filled:"
msgstr ""
"В поле I<op> указывается одно из следующих значений (определены в "
"I<E<lt>linux/ptrace.hE<gt>)>, определяющих тип возникшего останова и какая "
"часть объединения заполнена:"

#. type: TP
#: man-pages/man2/ptrace.2:1084
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_ENTRY>"
msgstr "B<PTRACE_SYSCALL_INFO_ENTRY>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1090
msgid ""
"The I<entry> component of the union contains information relating to a "
"system call entry stop."
msgstr ""
"Компонент объединения I<entry> содержит информацию об элементе останова "
"системного вызова."

#. type: TP
#: man-pages/man2/ptrace.2:1090
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_EXIT>"
msgstr "B<PTRACE_SYSCALL_INFO_EXIT>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1096
msgid ""
"The I<exit> component of the union contains information relating to a system "
"call exit stop."
msgstr ""
"Компонент объединения I<exit> содержит информацию о выходе из останова "
"системного вызова."

#. type: TP
#: man-pages/man2/ptrace.2:1096
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_SECCOMP>"
msgstr "B<PTRACE_SYSCALL_INFO_SECCOMP>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1103
msgid ""
"The I<exit> component of the union contains information relating to a "
"B<PTRACE_EVENT_SECCOMP> stop."
msgstr ""
"Компонент объединения I<exit> содержит информацию об останове "
"B<PTRACE_EVENT_SECCOMP>."

#. type: TP
#: man-pages/man2/ptrace.2:1103
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_NONE>"
msgstr "B<PTRACE_SYSCALL_INFO_NONE>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1106
msgid "No component of the union contains relevant information."
msgstr "Нет компонента объединения с подходящей информацией."

#. type: SS
#: man-pages/man2/ptrace.2:1108
#, no-wrap
msgid "Death under ptrace"
msgstr "Смерть в момент ptrace"

#. type: Plain text
#: man-pages/man2/ptrace.2:1117
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""
"Когда (возможно, многонитевой) процесс получает уничтожающий сигнал (из-за "
"того, что обработчик равен B<SIG_DFL> и что действием по умолчанию является "
"уничтожение процесса), все нити завершают работу (exit). Трассируемые нити "
"сообщают о своей смерти своим трассировщикам. Уведомления об этом событии "
"доставляется с помощью B<waitpid>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1126
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term \"signal-"
"delivery-stop\" is explained below.)"
msgstr ""
"Заметим, что уничтожающий сигнал сначала вызовет вхождение в режим signal-"
"delivery-stop (только для одной трассируемой нити), и только после этого "
"будет внедрён трассировщиком (или после того, как был отослан нити, которая "
"не является трассируемой), затем I<все> трассируемые нити в многонитевом "
"процессе завершаются по сигналу (термин «signal-delivery-stop» объяснён "
"далее)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1138
msgid ""
"B<SIGKILL> does not generate signal-delivery-stop and therefore the tracer "
"can't suppress it.  B<SIGKILL> kills even within system calls (syscall-exit-"
"stop is not generated prior to death by B<SIGKILL>).  The net effect is that "
"B<SIGKILL> always kills the process (all its threads), even if some threads "
"of the process are ptraced."
msgstr ""
"Сигнал B<SIGKILL> не генерирует режим signal-delivery-stop и поэтому "
"трассировщик не может подавить его. Сигнал B<SIGKILL> уничтожает даже внутри "
"системных вызовов (syscall-exit-stop не генерируется перед уничтожением по "
"B<SIGKILL>). Конечным результатом B<SIGKILL> всегда является уничтожение "
"процесса (всех его нитей), даже если для некоторых нитей процесса "
"выполняется трассировка."

#. type: Plain text
#: man-pages/man2/ptrace.2:1143
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""
"Когда трассируемая нить вызывает B<_exit>(2), он сообщает о своём "
"уничтожении своему трассировщику. На оставшиеся нити ни какого влияния не "
"оказывается."

#. type: Plain text
#: man-pages/man2/ptrace.2:1147
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""
"Если какая-нибудь нить вызывает B<exit_group>(2), то каждая трассируемая "
"нить в этой группе нитей сообщает о своём уничтожении своему трассировщику."

#. type: Plain text
#: man-pages/man2/ptrace.2:1162
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), "
"B<exit_group>(2), and signal deaths (except B<SIGKILL>, depending on the "
"kernel version; see BUGS below), and when threads are torn down on "
"B<execve>(2)  in a multithreaded process."
msgstr ""
"Если установлен флаг B<PTRACE_O_TRACEEXIT>, то перед непосредственным "
"уничтожением возникает B<PTRACE_EVENT_EXIT>. Это случается при выходе "
"посредством B<exit>(2), B<exit_group>(2) и из-за уничтожения по сигналу (за "
"исключением B<SIGKILL>, в зависимости от версии ядра; смотрите ДЕФЕКТЫ ниже) "
"и когда нити многонитевой процесса разрушаются при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1187
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  "
"I<waitpid(WNOHANG)> may return 0 instead.  In other words, the tracee may be "
"\"not yet fully dead\", but already refusing ptrace requests."
msgstr ""
"Трассировщик не может предполагать, что трассируемая нить, остановленная по "
"ptrace, существует. Если много случаев, когда трассируемая нить может быть "
"уничтожена будучи в остановленном состоянии (например, по B<SIGKILL>). "
"Поэтому, трассировщик должен быть готов обработать ошибку B<ESRCH> при любом "
"действии ptrace. К сожалению, эта же ошибка возвращается, если трассируемая "
"нить существует, но не остановлена по ptrace (для действий, которые требуют "
"остановленной трассируемой нити), или если она не трассируется процессом, "
"который вызвал ptrace. Трассировщику необходимо отслеживать состояние "
"остановки/работы трассируемой нити и воспринимать B<ESRCH> как «трассируемая "
"нить была неожиданно уничтожена» только, если он знает, что трассируемая "
"нить была в состоянии ptrace-stop. Заметим, что нет гарантии того, что "
"I<waitpid(WNOHANG)> всегда сообщит о состоянии уничтожения трассируемой "
"нити, если действие ptrace вернуло B<ESRCH>. Вызов I<waitpid(WNOHANG)> "
"вместо этого может вернуть 0. Другими словами, трассируемая нить может быть "
"«ещё не полностью уничтожена», но уже отклонять действия ptrace."

#. type: Plain text
#: man-pages/man2/ptrace.2:1201
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""
"Трассировщик не может предполагать, что I<всегда> поймает завершение "
"существования трассируемой нити с помощью I<WIFEXITED(status)> или "
"I<WIFSIGNALED(status)>; есть несколько случаев, когда этого не происходит. "
"Например, если нить — не лидер группы нитей — вызывает B<execve>(2) и "
"исчезает; её PID больше не появится снова, и все последующие остановки по "
"ptrace будут приходить от PID лидера группы нитей."

#. type: SS
#: man-pages/man2/ptrace.2:1201
#, no-wrap
msgid "Stopped states"
msgstr "Состояния останова"

#. type: Plain text
#: man-pages/man2/ptrace.2:1223
msgid ""
"A tracee can be in two states: running or stopped.  For the purposes of "
"ptrace, a tracee which is blocked in a system call (such as B<read>(2), "
"B<pause>(2), etc.)  is nevertheless considered to be running, even if the "
"tracee is blocked for a long time.  The state of the tracee after "
"B<PTRACE_LISTEN> is somewhat of a gray area: it is not in any ptrace-stop "
"(ptrace commands won't work on it, and it will deliver B<waitpid>(2)  "
"notifications), but it also may be considered \"stopped\" because it is not "
"executing instructions (is not scheduled), and if it was in group-stop "
"before B<PTRACE_LISTEN>, it will not respond to signals until B<SIGCONT> is "
"received."
msgstr ""
"Трассируемый может находиться в двух состояниях: выполнения или остановки. В "
"целях ptrace, трассируемый, заблокированный в системном вызове (например, "
"B<read>(2), B<pause>(2) и т.д.), считается выполняющимся, даже если он "
"заблокирован уже долго. Состояние трассируемого после B<PTRACE_LISTEN> "
"находится, отчасти, в «сумеречной зоне»: не не в каком-либо из ptrace-stop "
"(команды ptrace не будут с ним работать и он будет посылать уведомления "
"B<waitpid>(2)), но он также может считаться за «остановленный», так как он "
"не выполняет инструкций (не планируется для этого), и если он был в group-"
"stop до B<PTRACE_LISTEN>, он не будет отвечать на сигналы до тех пор, пока "
"не получит B<SIGCONT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1227
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""
"Есть много разновидностей останова, и в обсуждении ptrace они часто "
"объединены. Поэтому очень важно использовать точную терминологию."

#. type: Plain text
#: man-pages/man2/ptrace.2:1239
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  Ptrace-"
"stops can be further subdivided into I<signal-delivery-stop>, I<group-stop>, "
"I<syscall-stop>, I<PTRACE_EVENT stops>, and so on.  These stopped states are "
"described in detail below."
msgstr ""
"В этой справочной странице любое состояние останова, в котором трассируемая "
"нить готова выполнить действия ptrace трассировщика, называется I<ptrace-"
"stop>. В свою очередь, ptrace-stop можно разделить на I<signal-delivery-"
"stop>, I<group-stop>, I<syscall-stop>, I<PTRACE_EVENT stops> и так далее. "
"Далее эти состояния останова будут описаны подробней."

#. type: Plain text
#: man-pages/man2/ptrace.2:1244
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""
"Когда выполняющаяся трассируемая нить входит в ptrace-stop, это видит "
"трассировщик с помощью B<waitpid>(2) (или через другой системный вызов "
"«wait»). В большей части текста данной справочной страницы предполагается, "
"что трассировщик ждёт с помощью:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1246
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr "    pid = waitpid(pid_или_минус_1, &состояние, __WALL);\n"

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: man-pages/man2/ptrace.2:1258
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""
"О трассируемой нити в состоянии ptrace-stop сообщается возвратом I<pid> "
"большим 0 и значением истины по I<WIFSTOPPED(status)>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1266
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""
"Флаг B<__WALL> не содержит флагов B<WSTOPPED> и B<WEXITED>, но подразумевает "
"их назначение."

#. type: Plain text
#: man-pages/man2/ptrace.2:1273
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""
"Устанавливать флаг B<WCONTINUED> при вызове B<waitpid>(2) не рекомендуется: "
"состояние «continued» относится к определённому процессу и его поглощение "
"может запутать реального родителя трассируемой нити."

#. type: Plain text
#: man-pages/man2/ptrace.2:1281
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""
"Использование флага B<WNOHANG> может привести к тому, что B<waitpid>(2) "
"вернёт 0 («не ждать результатов, если они не готовы»), даже если "
"трассировщик знает, что должно быть уведомление. Пример:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1291
#, no-wrap
msgid ""
"errno = 0;\n"
"ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"if (errno == ESRCH) {\n"
"    /* tracee is dead */\n"
"    r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"    /* r can still be 0 here! */\n"
"}\n"
msgstr ""
"errno = 0;\n"
"    ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"    if (errno == ESRCH) {\n"
"        /* трассируемая нить мертва */\n"
"        r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"        /* r может быть 0 ! */\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1315
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, group-"
"stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the "
"I<WSTOPSIG(status)> macro can't be used to perform this examination, because "
"it returns the value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""
"Существуют следующие разновидности ptrace-stop: signal-delivery-stop, group-"
"stop, остановки B<PTRACE_EVENT>, syscall-stop. Все они могут быть получены "
"по B<waitpid>(2) с значением истинным по I<WIFSTOPPED(status)>. Их можно "
"различить, если проверить значение I<statusE<gt>E<gt>8>, и, если есть "
"неоднозначность этого значения, то запросив B<PTRACE_GETSIGINFO> (замечание: "
"для выполнения этой проверки не может использоваться макрос "
"I<WSTOPSIG(status)>, так как он возвращает значение I<(statusE<gt>E<gt>8)\\ &"
"\\ 0xff>)."

#. type: SS
#: man-pages/man2/ptrace.2:1315
#, no-wrap
msgid "Signal-delivery-stop"
msgstr "Signal-delivery-stop"

#. type: Plain text
#: man-pages/man2/ptrace.2:1335
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""
"Когда процесс (возможно, многонитевой) принимает какой-либо сигнал кроме "
"B<SIGKILL>, ядро выбирает произвольную нить для его обработки (если сигнал "
"генерируется с помощью B<tgkill>(2), то назначаемая нить может быть явно "
"выбрана вызывающим). Если над выбранной нитью выполняется трассировка, то "
"она попадает в режим signal-delivery-stop. В этот момент сигнал ещё не "
"доставлен процессу и может быть отменён трассировщиком. Если трассировщик не "
"отменил сигнал, то он передаётся трассируемой нити при следующем запросе "
"перезапуска ptrace. Этот второй этап доставки сигнала называется в этой "
"справочной странице I<внедрением сигнала>. Заметим, что если сигнал "
"блокируется, то signal-delivery-stop не происходит пока сигнал не будет "
"разблокирован (исключением, как обычно, является B<SIGSTOP>, который нельзя "
"заблокировать)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1349
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by "
"I<WSTOPSIG(status)>.  If the signal is B<SIGTRAP>, this may be a different "
"kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below "
"for details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be "
"a group-stop; see below."
msgstr ""
"Signal-delivery-stop наблюдается трассировщиком посредством B<waitpid>(2), "
"возвращающим истинное значения для I<WIFSTOPPED(status)> с сигналом, который "
"возвращается по I<WSTOPSIG(status)>. Если возвращается сигнал B<SIGTRAP>, то "
"он может быть разновидностью ptrace-stop; смотрите разделы «Syscall-stops» и "
"«execve» далее. Если I<WSTOPSIG(status)> возвращает останавливающий сигнал, "
"то это может быть group-stop, смотрите далее."

#. type: SS
#: man-pages/man2/ptrace.2:1349
#, no-wrap
msgid "Signal injection and suppression"
msgstr "Внедрение и подавление сигнала"

#. type: Plain text
#: man-pages/man2/ptrace.2:1352
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""
"После обнаружения трассировщиком signal-delivery-stop, он должен "
"перезапустить трассируемую нить вызовом"

#. type: Plain text
#: man-pages/man2/ptrace.2:1354
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr "    ptrace(PTRACE_restart, pid, 0, sig)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1367
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""
"где B<PTRACE_restart> — одно из перезапускающих действий ptrace. Если "
"значение I<sig> равно 0, то сигнал не доставляется. В противном случае, "
"доставляется сигнал I<sig>. Данная операция в справочной странице называется "
"I<внедрением сигнала> для того, чтобы можно отличить её от signal-delivery-"
"stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1373
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""
"Значение I<sig> может отличаться от значения I<WSTOPSIG(status)>: "
"трассировщик может поменять внедряемый сигнал."

#. type: Plain text
#: man-pages/man2/ptrace.2:1389
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case, system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few system calls which use a "
"different mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  "
"Even system calls (such as B<poll>(2))  which are not restartable after "
"signal are restarted after signal is suppressed; however, kernel bugs exist "
"which cause some system calls to fail with B<EINTR> even though no "
"observable signal is injected to the tracee."
msgstr ""
"Заметим, что подавленный сигнал всё равно заставит системные вызовы "
"завершиться как можно скорее. В этом случае системные вызовы будут "
"перезапущены: если трассировщик использует B<PTRACE_SYSCALL>, то обнаружит, "
"когда трассируемая нить повторно выполнила прерванный системный вызов (или "
"системный вызов B<restart_syscall>(2) для некоторых системных вызовов, "
"которые используют другой механизм перезапуска). Даже системные вызовы "
"(такие как B<poll>(2)), которые не перезапускаются по сигналу, будут "
"перезапущены после подавления сигнала; однако, в ядре существуют дефекты, из-"
"за которых некоторые системные вызовы завершаются с ошибкой B<EINTR>, даже "
"если наблюдаемый сигнал не был внедрён в трассируемую нить."

#. type: Plain text
#: man-pages/man2/ptrace.2:1400
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than signal-delivery-"
"stop are not guaranteed to inject a signal, even if I<sig> is nonzero.  No "
"error is reported; a nonzero I<sig> may simply be ignored.  Ptrace users "
"should not try to \"create a new signal\" this way: use B<tgkill>(2)  "
"instead."
msgstr ""
"Перезапускающие действия ptrace, выдаваемые в ptrace-stops, отличные от "
"signal-delivery-stop, не гарантируют внедрения сигнала, даже если значение "
"I<sig> не равно нулю. Об ошибках не сообщается; ненулевое значение I<sig> "
"может быть просто проигнорировано. Пользователи ptrace не должны пытаться "
"«создать новый сигнал» таким способом — используйте вместо этого "
"B<tgkill>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1407
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""
"Тот факт, что запросы внедрения сигнала могут игнорироваться при перезапуске "
"трассируемой нити после остановок ptrace не из signal-delivery-stops, "
"вызывает путаницу у пользователей ptrace. Типичный сценарий: трассировщик "
"обнаруживает group-stop, принимает его за signal-delivery-stop, "
"перезапускает трассируемую нить с помощью"

#. type: Plain text
#: man-pages/man2/ptrace.2:1409
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"
msgstr "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1415
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""
"пытаясь внедрить I<stopsig>, но I<stopsig> игнорируется и трассируемая нить "
"продолжает выполняться."

#. type: Plain text
#: man-pages/man2/ptrace.2:1435
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before signal-delivery-"
"stop.  The tracer can't suppress this side effect (it can only suppress "
"signal injection, which only causes the B<SIGCONT> handler to not be "
"executed in the tracee, if such a handler is installed).  In fact, waking up "
"from group-stop may be followed by signal-delivery-stop for signal(s)  "
"I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> was "
"delivered.  In other words, B<SIGCONT> may be not the first signal observed "
"by the tracee after it was sent."
msgstr ""
"Сигнал B<SIGCONT> имеет побочный эффект — пробуждает (все нити) процесс, "
"находящийся в group-stop. Это случается перед signal-delivery-stop. "
"Трассировщик не может повлиять на это побочное действие (он может только "
"подавить внедрение сигнала, что приводит к тому, что обработчик B<SIGCONT> "
"не будет выполнен в трассируемой нити, если он установлен). Фактически, "
"пробуждение из group-stop может следовать после signal-delivery-stop для "
"сигнала(ов) I<отличных от> B<SIGCONT>, если они ожидают момента доставки "
"B<SIGCONT>. Другими словами, B<SIGCONT> может быть не первым сигналом, "
"который обнаруживает трассируемую нить после её посылки."

#. type: Plain text
#: man-pages/man2/ptrace.2:1439
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""
"Останавливающие сигналы заставляют процесс (все его нити) войти в group-"
"stop. Данный побочный эффект возникает после внедрения сигнала, и поэтому "
"может быть отменён трассировщиком."

#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: man-pages/man2/ptrace.2:1449
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""
"В Linux 2.4 и более ранних версиях, сигнал B<SIGSTOP> не может быть внедрён."

#. type: Plain text
#: man-pages/man2/ptrace.2:1466
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""
"Действие B<PTRACE_GETSIGINFO> может использоваться для получения структуры "
"I<siginfo_t>, которая соответствует доставленному сигналу. Для её изменения "
"можно использовать B<PTRACE_SETSIGINFO>. Если B<PTRACE_SETSIGINFO> "
"использовалась для изменения I<siginfo_t>, то поле I<si_signo> и параметр "
"I<sig> в перезапускающем действии должны совпадать, иначе результат "
"непредсказуем."

#. type: SS
#: man-pages/man2/ptrace.2:1466
#, no-wrap
msgid "Group-stop"
msgstr "Group-stop"

#. type: Plain text
#: man-pages/man2/ptrace.2:1478
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""
"Когда (возможно многонитевой) процесс получает останавливающий сигнал, все "
"нити останавливаются. Если для какой-то нити выполняется трассировка, то она "
"входит в режим group-stop. Заметим, что останавливающий сигнал сначала "
"приведёт к signal-delivery-stop (только в одной трассируемой нити) и только "
"затем будет внедрён трассировщиком (или после того, как будет отправлен "
"нити, над которой не выполняется трассировка), будет начат group-stop в "
"I<всех> трассируемых нитях многонитевого процесса. Как обычно, каждая "
"трассируемая нить сообщает о group-stop соответствующему трассировщику."

#. type: Plain text
#: man-pages/man2/ptrace.2:1487
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via "
"I<WSTOPSIG(status)>.  The same result is returned by some other classes of "
"ptrace-stops, therefore the recommended practice is to perform the call"
msgstr ""
"Group-stop обнаруживается трассировщиком с помощью B<waitpid>(2), который "
"возвращается с истинным значением I<WIFSTOPPED(status)> и останавливающим "
"сигналом из I<WSTOPSIG(status)>. Тот же результат возвращается другими "
"классами ptrace-stops, поэтому рекомендуется выполнять вызов"

#. type: Plain text
#: man-pages/man2/ptrace.2:1489
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1510
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""
"Вызова можно избежать, если сигнал не равен B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN> или B<SIGTTOU>; только эти четыре сигнала являются "
"останавливающими. Если трассировщик видит что-то другое, то это не может "
"быть group-stop. В противном случае, трассировщику нужно вызвать "
"B<PTRACE_GETSIGINFO>. Если B<PTRACE_GETSIGINFO> завершается с ошибкой "
"B<EINVAL>, то это определённо group-stop (возможны другие коды ошибок, "
"например, B<ESRCH> («нет такого процесса»), если трассируемая нить "
"уничтожена по B<SIGKILL>)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1520
msgid ""
"If tracee was attached using B<PTRACE_SEIZE>, group-stop is indicated by "
"B<PTRACE_EVENT_STOP>: I<statusE<gt>E<gt>16 == PTRACE_EVENT_STOP>.  This "
"allows detection of group-stops without requiring an extra "
"B<PTRACE_GETSIGINFO> call."
msgstr ""
"Если подключение к трассируемому было сделано с помощью B<PTRACE_SEIZE>, то "
"group-stop указывается B<PTRACE_EVENT_STOP>: I<statusE<gt>E<gt>16 == "
"PTRACE_EVENT_STOP>. Это позволяет обнаружить group-stop без дополнительного "
"вызова B<PTRACE_GETSIGINFO>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1529
msgid ""
"As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""
"Начиная с Linux 2.6.38, после того как трассировщик увидит ptrace-stop "
"трассируемой нити и пока он не перезапустит или завершит её, трассируемая "
"нить не будет выполняться, и не будет посылать уведомления (за исключением "
"уничтожения по B<SIGKILL>) трассировщику, даже если трассировщик войдёт в "
"другой вызов B<waitpid>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1543
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""
"Поведение ядра, описанное в предыдущем параграфе, вызывает проблемы с "
"прозрачностью обработки останавливающих сигналов. Если трассировщик "
"перезапускает трассируемую нить после group-stop, то останавливающий сигнал "
"просто игнорируется — трассируемая нить продолжает выполняться. Если "
"трассировщик не перезапускает трассируемую нить перед входом в следующий "
"B<waitpid>(2), то о будущих сигналах B<SIGCONT> не будет сообщено "
"трассировщику; это привело бы к тому, что сигналы B<SIGCONT> не повлияли бы "
"на трассируемую нить."

#. type: Plain text
#: man-pages/man2/ptrace.2:1554
msgid ""
"Since Linux 3.4, there is a method to overcome this problem: instead of "
"B<PTRACE_CONT>, a B<PTRACE_LISTEN> command can be used to restart a tracee "
"in a way where it does not execute, but waits for a new event which it can "
"report via B<waitpid>(2)  (such as when it is restarted by a B<SIGCONT>)."
msgstr ""
"Начиная с Linux 3.4, появился способ преодоления этой проблемы: вместо "
"B<PTRACE_CONT> для перезапуска трассируемой нити можно использовать "
"B<PTRACE_LISTEN>, при которой она не выполняется, а ждёт нового события, и "
"это можно прочитать с помощью B<waitpid>(2) (например, когда был перезапуск "
"по B<SIGCONT>)."

#. type: SS
#: man-pages/man2/ptrace.2:1554
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr "Остановки PTRACE_EVENT"

#. type: Plain text
#: man-pages/man2/ptrace.2:1560
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter ptrace-"
"stops called B<PTRACE_EVENT> stops."
msgstr ""
"Если трассировщик устанавливает флаги B<PTRACE_O_TRACE_*>, то трассируемая "
"нить будет входить в ptrace-stop-ы, называемые остановками B<PTRACE_EVENT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1574
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""
"Остановки B<PTRACE_EVENT> обнаруживаются трассировщиком когда B<waitpid>(2)  "
"возвращается с I<WIFSTOPPED(status)> и I<WSTOPSIG(status)> возвращает "
"B<SIGTRAP>. В старшем байте слова состояния устанавливается дополнительный "
"бит: значение I<statusE<gt>E<gt>8> будет равно"

#. type: Plain text
#: man-pages/man2/ptrace.2:1576
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1578
msgid "The following events exist:"
msgstr "Могут происходить следующие события:"

#. type: TP
#: man-pages/man2/ptrace.2:1578
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr "B<PTRACE_EVENT_VFORK>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1591
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""
"Остановка перед возвратом из B<vfork>(2) или B<clone>(2) с флагом "
"B<CLONE_VFORK>. Когда трассируемая нить продолжает выполняться после этой "
"остановки, она будет ждать выхода/exec потомка перед продолжением своего "
"исполнения (другими словами, обычное поведение при B<vfork>(2))."

#. type: TP
#: man-pages/man2/ptrace.2:1591
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1599
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""
"Остановка перед возвратом из B<fork>(2) или B<clone>(2) с установленным "
"сигналом выхода B<SIGCHLD>."

#. type: TP
#: man-pages/man2/ptrace.2:1599
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr "B<PTRACE_EVENT_CLONE>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1603
msgid "Stop before return from B<clone>(2)."
msgstr "Остановка перед возвратом из B<clone>(2)."

#. type: TP
#: man-pages/man2/ptrace.2:1603
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr "B<PTRACE_EVENT_VFORK_DONE>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1613
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""
"Остановка перед возвратом из B<vfork>(2) или B<clone>(2) с установленным "
"флагом B<CLONE_VFORK>, но после того, как потомок разблокирует эту "
"трассируемую нить, завершив работу или выполнив exec."

#. type: Plain text
#: man-pages/man2/ptrace.2:1619
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""
"Для всех четырёх остановок, описанных выше, остановка происходит в родителе "
"(т. е., трассируемой нити), а не в только что созданной нити. Для получения "
"ID новой нити может использовать B<PTRACE_GETEVENTMSG>."

#. type: TP
#: man-pages/man2/ptrace.2:1619
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr "B<PTRACE_EVENT_EXEC>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1626
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""
"Остановка перед возвратом из B<execve>(2). Начиная с Linux 3.0, "
"B<PTRACE_GETEVENTMSG> возвращает ID бывшей нити."

#. type: TP
#: man-pages/man2/ptrace.2:1626
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr "B<PTRACE_EVENT_EXIT>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1642
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""
"Остановка перед выходом (включая уничтожение из B<exit_group>(2)), "
"уничтожение от сигнала или выход, вызванный B<execve>(2) в многонитевом "
"процессе. B<PTRACE_GETEVENTMSG> возвращает код выхода. Можно прочитать "
"значения регистров (в отличие от случая, когда происходит «реальный» выход). "
"Трассируемая нить всё ещё существует; для завершения выхода должно быть "
"выполнено отсоединение с помощью B<PTRACE_CONT> или B<PTRACE_DETACH>."

#. type: TP
#: man-pages/man2/ptrace.2:1642
#, no-wrap
msgid "B<PTRACE_EVENT_STOP>"
msgstr "B<PTRACE_EVENT_STOP>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1649
msgid ""
"Stop induced by B<PTRACE_INTERRUPT> command, or group-stop, or initial "
"ptrace-stop when a new child is attached (only if attached using "
"B<PTRACE_SEIZE>)."
msgstr ""
"Остановка вызвана командой B<PTRACE_INTERRUPT>, или group-stop, или "
"начальным ptrace-stop при присоединении к новому потомку (только если для "
"присоединения использовалась B<PTRACE_SEIZE>)."

#. type: TP
#: man-pages/man2/ptrace.2:1649
#, no-wrap
msgid "B<PTRACE_EVENT_SECCOMP>"
msgstr "B<PTRACE_EVENT_SECCOMP>"

#. type: Plain text
#: man-pages/man2/ptrace.2:1662
msgid ""
"Stop triggered by a B<seccomp>(2)  rule on tracee syscall entry when "
"B<PTRACE_O_TRACESECCOMP> has been set by the tracer.  The seccomp event "
"message data (from the B<SECCOMP_RET_DATA> portion of the seccomp filter "
"rule) can be retrieved with B<PTRACE_GETEVENTMSG>.  The semantics of this "
"stop are described in detail in a separate section below."
msgstr ""
"Остановка вызвана правилом B<seccomp>(2) из-за элемента syscall "
"трассируемого, когда B<PTRACE_O_TRACESECCOMP> была установлена "
"трассировщиком. Данные сообщения события seccomp (из части "
"B<SECCOMP_RET_DATA> фильтрующего правила seccomp) можно получить с помощью "
"B<PTRACE_GETEVENTMSG>. Семантика данного останова подробно описана в "
"отдельном разделе далее."

#. type: Plain text
#: man-pages/man2/ptrace.2:1674
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""
"B<PTRACE_GETSIGINFO> при остановке B<PTRACE_EVENT> возвращает B<SIGTRAP> в "
"I<si_signo>, а значение I<si_code> устанавливается в I<(eventE<lt>E<lt>8)\\ |"
"\\ SIGTRAP>."

#. type: SS
#: man-pages/man2/ptrace.2:1674
#, no-wrap
msgid "Syscall-stops"
msgstr "Syscall-stop"

#. type: Plain text
#: man-pages/man2/ptrace.2:1701
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL> or B<PTRACE_SYSEMU>, the "
"tracee enters syscall-enter-stop just prior to entering any system call "
"(which will not be executed if the restart was using B<PTRACE_SYSEMU>, "
"regardless of any change made to registers at this point or how the tracee "
"is restarted after this stop).  No matter which method caused the syscall-"
"entry-stop, if the tracer restarts the tracee with B<PTRACE_SYSCALL>, the "
"tracee enters syscall-exit-stop when the system call is finished, or if it "
"is interrupted by a signal.  (That is, signal-delivery-stop never happens "
"between syscall-enter-stop and syscall-exit-stop; it happens I<after> "
"syscall-exit-stop.).  If the tracee is continued using any other method "
"(including B<PTRACE_SYSEMU>), no syscall-exit-stop occurs.  Note that all "
"mentions B<PTRACE_SYSEMU> apply equally to B<PTRACE_SYSEMU_SINGLESTEP.>"
msgstr ""
"Если трассируемый был перезапущен по B<PTRACE_SYSCALL> или B<PTRACE_SYSEMU>, "
"то он входит в режим syscall-enter-stop сразу перед тем как войти в какой-"
"либо системный вызов (который не будет выполняться, если перезапуск был из-"
"за B<PTRACE_SYSEMU>, независимо от каких-либо изменений в регистрах на этот "
"момент или если трассируемый перезапускается после своей остановки). Неважно "
"какой метод вызвал syscall-entry-stop, если трассировщик перезапускает "
"трассируемого с помощью B<PTRACE_SYSCALL>, то трассируемый входит в syscall-"
"exit-stop при окончании системного вызова, или если он прерывается сигналом "
"(то есть, signal-delivery-stop никогда не возникает между syscall-enter-stop "
"и syscall-exit-stop; он возникает I<после> syscall-exit-stop). Если "
"трассируемый продолжает выполнение с помощью какого-то другого метода "
"(включая B<PTRACE_SYSEMU>), то syscall-exit-stop не возникает. Заметим, что "
"все упоминания B<PTRACE_SYSEMU> применяются и к B<PTRACE_SYSEMU_SINGLESTEP>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1718
msgid ""
"However, even if the tracee was continued using B<PTRACE_SYSCALL>, it is not "
"guaranteed that the next stop will be a syscall-exit-stop.  Other "
"possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop "
"(including seccomp stops), exit (if it entered B<_exit>(2)  or "
"B<exit_group>(2)), be killed by B<SIGKILL>, or die silently (if it is a "
"thread group leader, the B<execve>(2)  happened in another thread, and that "
"thread is not traced by the same tracer; this situation is discussed later)."
msgstr ""
"Однако даже если трассируемый продолжил выполнение с помощью "
"B<PTRACE_SYSCALL>, это не гарантирует, что следующая остановка будет syscall-"
"exit-stop. Также, трассируемый может остановиться в остановке "
"B<PTRACE_EVENT> (включая остановку seccomp), при выходе (если он вошёл в "
"B<_exit>(2) или B<exit_group>(2)), уничтожении по сигналу B<SIGKILL>, или "
"тихом уничтожении (если он является лидером группы нитей, возникает "
"B<execve>(2) в другой нити, и эта нить не трассируется тем же "
"трассировщиком; эта ситуация описана далее)."

#. type: Plain text
#: man-pages/man2/ptrace.2:1733
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and "
"I<WSTOPSIG(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> "
"option was set by the tracer, then I<WSTOPSIG(status)> will give the value "
"I<(SIGTRAP\\ |\\ 0x80)>."
msgstr ""
"Syscall-enter-stop и syscall-exit-stop обнаруживаются трассировщиком из "
"B<waitpid>(2), возвращающем истинное значение I<WIFSTOPPED(status)> и "
"I<WSTOPSIG(status)> выдающем B<SIGTRAP>. Если трассировщиком был установлен "
"флаг B<PTRACE_O_TRACESYSGOOD>, то I<WSTOPSIG(status)> выдаст значение "
"I<(SIGTRAP\\ |\\ 0x80)>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1739
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""
"Syscall-stop можно отличить от signal-delivery-stop по B<SIGTRAP>, запросив "
"B<PTRACE_GETSIGINFO> в следующих случаях:"

#. type: TP
#: man-pages/man2/ptrace.2:1739
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr "I<si_code> E<lt>= 0"

#. type: Plain text
#: man-pages/man2/ptrace.2:1751
msgid ""
"B<SIGTRAP> was delivered as a result of a user-space action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""
"B<SIGTRAP> был доставлен в результате действия из пространства пользователя, "
"например, системного вызова (B<tgkill>(2), B<kill>(2), B<sigqueue>(3) и т. "
"д.), истечении таймера POSIX, изменении состояния очереди сообщений POSIX "
"или выполнении асинхронного запроса ввода/вывода."

#. type: TP
#: man-pages/man2/ptrace.2:1751
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr "I<si_code> == SI_KERNEL (0x80)"

#. type: Plain text
#: man-pages/man2/ptrace.2:1755
msgid "B<SIGTRAP> was sent by the kernel."
msgstr "B<SIGTRAP> был послан ядром."

#. type: TP
#: man-pages/man2/ptrace.2:1755
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr "I<si_code> == SIGTRAP или I<si_code> == (SIGTRAP|0x80)"

#. type: Plain text
#: man-pages/man2/ptrace.2:1758
msgid "This is a syscall-stop."
msgstr "Это syscall-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1763
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""
"Однако, syscall-stop происходят очень часто (дважды за системный вызов), и "
"выполнение B<PTRACE_GETSIGINFO> для каждого syscall-stop может быть отчасти "
"накладно."

#. type: Plain text
#: man-pages/man2/ptrace.2:1786
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in syscall-enter-"
"stop.  Since B<SIGTRAP> (like any other signal) always happens I<after> "
"syscall-exit-stop, and at this point I<rax> almost never contains -"
"B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not syscall-"
"enter-stop\"; in other words, it looks like a \"stray syscall-exit-stop\" "
"and can be detected this way.  But such detection is fragile and is best "
"avoided."
msgstr ""
"Некоторые архитектуры позволяют отличать эти случаи по значениям регистров. "
"Например, на x86, при syscall-enter-stop I<rax> == -B<ENOSYS>. Так как "
"B<SIGTRAP> (как и любой сигнал) всегда возникает I<после> syscall-exit-stop, "
"и в этот момент I<rax> почти никогда не содержит B<ENOSYS>, B<SIGTRAP> "
"выглядит как «syscall-stop, который не syscall-enter-stop»; другими словами, "
"это выглядит как «блуждающий syscall-exit-stop» и таким способом может быть "
"обнаружен. Но определение этим способом очень ненадёжно и лучше его не "
"использовать."

#. type: Plain text
#: man-pages/man2/ptrace.2:1792
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""
"Использование флага B<PTRACE_O_TRACESYSGOOD> — рекомендуемый метод "
"различения syscall-stop от похожих на них других ptrace-stop, так как это "
"надёжно и не приводит к ухудшению производительности."

#. type: Plain text
#: man-pages/man2/ptrace.2:1807
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-"
"stop or vice versa.  In general, a syscall-enter-stop is always followed by "
"syscall-exit-stop, B<PTRACE_EVENT> stop, or the tracee's death; no other "
"kinds of ptrace-stop can occur in between.  However, note that seccomp stops "
"(see below) can cause syscall-exit-stops, without preceding syscall-entry-"
"stops.  If seccomp is in use, care needs to be taken not to misinterpret "
"such stops as syscall-entry-stops."
msgstr ""
"Syscall-enter-stop и syscall-exit-stop неотличимы друг от друга "
"трассировщиком. Трассировщику требуется отслеживать последовательность "
"ptrace-stop, чтобы правильно истолковать syscall-enter-stop как syscall-exit-"
"stop или наоборот. В общем, за syscall-enter-stop всегда следует syscall-"
"exit-stop, B<PTRACE_EVENT> остановка или уничтожение трассируемого; никаких "
"других ptrace-stop не может возникнуть между ними. Однако заметим, что "
"остановки seccomp (смотрите ниже) могут приводить к syscall-exit-stop без "
"предварительного syscall-entry-stop. Если используется seccomp, необходима "
"осторожность чтобы не посчитать такие остановки за syscall-entry-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1812
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""
"Если после syscall-enter-stop трассировщик использует перезапускающее "
"действие, отличное от B<PTRACE_SYSCALL>, то syscall-exit-stop не "
"генерируется."

#. type: Plain text
#: man-pages/man2/ptrace.2:1825
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""
"B<PTRACE_GETSIGINFO> при syscall-stop возвращает B<SIGTRAP> в I<si_signo>, "
"значение I<si_code> устанавливается в B<SIGTRAP> или I<(SIGTRAP|0x80)>."

#. type: SS
#: man-pages/man2/ptrace.2:1825
#, no-wrap
msgid "PTRACE_EVENT_SECCOMP stops (Linux 3.5 to 4.7)"
msgstr "Остановки PTRACE_EVENT_SECCOMP (Linux 3.5 по 4.7)"

#. type: Plain text
#: man-pages/man2/ptrace.2:1833
msgid ""
"The behavior of B<PTRACE_EVENT_SECCOMP> stops and their interaction with "
"other kinds of ptrace stops has changed between kernel versions.  This "
"documents the behavior from their introduction until Linux 4.7 (inclusive).  "
"The behavior in later kernel versions is documented in the next section."
msgstr ""
"Поведение остановок B<PTRACE_EVENT_SECCOMP> и их взаимодействие с другими "
"видами остановок ptrace различается от версии к версии. Здесь описано "
"поведение от их появления до Linux 4.7 (включительно). Поведение в более "
"новых версиях описано в следующем разделе."

#. type: Plain text
#: man-pages/man2/ptrace.2:1843
msgid ""
"A B<PTRACE_EVENT_SECCOMP> stop occurs whenever a B<SECCOMP_RET_TRACE> rule "
"is triggered.  This is independent of which methods was used to restart the "
"system call.  Notably, seccomp still runs even if the tracee was restarted "
"using B<PTRACE_SYSEMU> and this system call is unconditionally skipped."
msgstr ""
"Остановка B<PTRACE_EVENT_SECCOMP> возникает из-за срабатывания правила "
"B<SECCOMP_RET_TRACE>. Она не зависит от используемых методов перезапуска "
"системного вызова. Примечательно, что seccomp по прежнему работает даже, "
"если трассируемый был перезапущен с помощью B<PTRACE_SYSEMU> и этот "
"системный вызов безоговорочно пропускается."

#. type: Plain text
#: man-pages/man2/ptrace.2:1862
msgid ""
"Restarts from this stop will behave as if the stop had occurred right before "
"the system call in question.  In particular, both B<PTRACE_SYSCALL> and "
"B<PTRACE_SYSEMU> will normally cause a subsequent syscall-entry-stop.  "
"However, if after the B<PTRACE_EVENT_SECCOMP> the system call number is "
"negative, both the syscall-entry-stop and the system call itself will be "
"skipped.  This means that if the system call number is negative after a "
"B<PTRACE_EVENT_SECCOMP> and the tracee is restarted using B<PTRACE_SYSCALL>, "
"the next observed stop will be a syscall-exit-stop, rather than the syscall-"
"entry-stop that might have been expected."
msgstr ""
"Перезапуск из этой остановки будет вести себя как если бы остановка возникла "
"прямо перед рассматриваемым системным вызовом. В частности, "
"B<PTRACE_SYSCALL> и B<PTRACE_SYSEMU> как обычно вызовут последующий syscall-"
"entry-stop. Однако, если после B<PTRACE_EVENT_SECCOMP> номер системного "
"вызова отрицательный, то и syscall-entry-stop и сам системный вызов будут "
"пропущены. Это означает, что если номер системного вызова отрицательный "
"после B<PTRACE_EVENT_SECCOMP> и трассируемый перезапущен с помощью "
"B<PTRACE_SYSCALL>, то следующая наблюдаемая остановка будет syscall-exit-"
"stop, а не syscall-entry-stop, как можно было ожидать."

#. type: SS
#: man-pages/man2/ptrace.2:1862
#, no-wrap
msgid "PTRACE_EVENT_SECCOMP stops (since Linux 4.8)"
msgstr "Остановки PTRACE_EVENT_SECCOMP (начиная с Linux 4.8)"

#.  commit 93e35efb8de45393cf61ed07f7b407629bf698ea
#. type: Plain text
#: man-pages/man2/ptrace.2:1873
msgid ""
"Starting with Linux 4.8, the B<PTRACE_EVENT_SECCOMP> stop was reordered to "
"occur between syscall-entry-stop and syscall-exit-stop.  Note that seccomp "
"no longer runs (and no B<PTRACE_EVENT_SECCOMP> will be reported) if the "
"system call is skipped due to B<PTRACE_SYSEMU>."
msgstr ""
"Начиная с Linux 4.8, остановка B<PTRACE_EVENT_SECCOMP> была преобразована "
"при возникновении между syscall-entry-stop и syscall-exit-stop. Заметим, что "
"seccomp больше не выполняется (и B<PTRACE_EVENT_SECCOMP> не будет выдан), "
"если системный вызов пропускается из-за B<PTRACE_SYSEMU>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1884
msgid ""
"Functionally, a B<PTRACE_EVENT_SECCOMP> stop functions comparably to a "
"syscall-entry-stop (i.e., continuations using B<PTRACE_SYSCALL> will cause "
"syscall-exit-stops, the system call number may be changed and any other "
"modified registers are visible to the to-be-executed system call as well).  "
"Note that there may be, but need not have been a preceding syscall-entry-"
"stop."
msgstr ""
"Функционально, остановка B<PTRACE_EVENT_SECCOMP> работает как syscall-entry-"
"stop (т. е., продолжение использования B<PTRACE_SYSCALL> приведёт к syscall-"
"exit-stop, может измениться номер системного вызова и любые другие регистры, "
"видимые выполняемому в будущем системному вызову). Заметим, что это может "
"быть, но не обязательно предваряется syscall-entry-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:1895
msgid ""
"After a B<PTRACE_EVENT_SECCOMP> stop, seccomp will be rerun, with a "
"B<SECCOMP_RET_TRACE> rule now functioning the same as a "
"B<SECCOMP_RET_ALLOW>.  Specifically, this means that if registers are not "
"modified during the B<PTRACE_EVENT_SECCOMP> stop, the system call will then "
"be allowed."
msgstr ""
"После остановки B<PTRACE_EVENT_SECCOMP>,  seccomp будет выполнен повторно с "
"правилом B<SECCOMP_RET_TRACE>, которое теперь работает также как "
"B<SECCOMP_RET_ALLOW>. Точнее говоря, это означает, что если регистры не "
"изменились во время остановки B<PTRACE_EVENT_SECCOMP>,то после этого "
"системный вызов будет разрешён."

#. type: SS
#: man-pages/man2/ptrace.2:1895
#, no-wrap
msgid "PTRACE_SINGLESTEP stops"
msgstr "Остановки PTRACE_SINGLESTEP"

#.  FIXME .
#.  document stops occurring with PTRACE_SINGLESTEP
#. type: Plain text
#: man-pages/man2/ptrace.2:1901
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr "[Пока не описаны.]"

#. type: SS
#: man-pages/man2/ptrace.2:1901
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr "Информационные и перезапускающие действия ptrace"

#. type: Plain text
#: man-pages/man2/ptrace.2:1911
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, "
"B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT>, and B<PTRACE_KILL>)  require the "
"tracee to be in a ptrace-stop, otherwise they fail with B<ESRCH>."
msgstr ""
"Для большинства действий ptrace (все, за исключением B<PTRACE_ATTACH>, "
"B<PTRACE_SEIZE>, B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT> и B<PTRACE_KILL>) "
"требуется, чтобы трассируемая нить была в режиме ptrace-stop, в противном "
"случае они завершаются с ошибкой B<ESRCH>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1916
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""
"Когда трассируемая нить в ptrace-stop, трассировщик может читать и "
"записывать данные в трассируемую нить с помощью информационных действий. Эти "
"действия оставляют трассируемую нить в состоянии ptrace-stop:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1929
#, no-wrap
msgid ""
"ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""
"ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1942
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""
"Заметим, что о некоторых ошибках не сообщается. Например, установка "
"информации о сигнале (I<siginfo>) может никак не отразиться в некоторых "
"ptrace-stop, при этом вызов может завершиться без ошибок (возвращается 0 и "
"значение I<errno> не устанавливается); действие B<PTRACE_GETEVENTMSG> может "
"выполниться без ошибок и вернуть произвольное значение, если текущий ptrace-"
"stop не описан как возвращающий какое-то осмысленное сообщение о событии."

#. type: Plain text
#: man-pages/man2/ptrace.2:1944
msgid "The call"
msgstr "Вызов"

#. type: Plain text
#: man-pages/man2/ptrace.2:1946
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1955
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""
"затрагивает одну трассируемую нить. Текущие флаги трассируемой нити "
"заменяются. Флаги, наследуемые новой трассируемой нитью, создаются и "
"«автоматически присоединяются» через активные флаги B<PTRACE_O_TRACEFORK>, "
"B<PTRACE_O_TRACEVFORK> или B<PTRACE_O_TRACECLONE>."

#. type: Plain text
#: man-pages/man2/ptrace.2:1958
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""
"Другая группа действий заставляет трассируемую нить, находящуюся в ptrace-"
"stop, выполняться. Они могут иметь вид:"

#. type: Plain text
#: man-pages/man2/ptrace.2:1960
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr "    ptrace(cmd, pid, 0, sig);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1981
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, "
"B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or "
"B<PTRACE_SYSEMU_SINGLESTEP>.  If the tracee is in signal-delivery-stop, "
"I<sig> is the signal to be injected (if it is nonzero).  Otherwise, I<sig> "
"may be ignored.  (When restarting a tracee from a ptrace-stop other than "
"signal-delivery-stop, recommended practice is to always pass 0 in I<sig>.)"
msgstr ""
"где значение I<cmd> равно B<PTRACE_CONT>, B<PTRACE_LISTEN>, "
"B<PTRACE_DETACH>, B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU> "
"или B<PTRACE_SYSEMU_SINGLESTEP>. Если трассируемая нить в signal-delivery-"
"stop, то в I<sig> указывается сигнал, который будет внедрён (если не равен "
"нулю). В противном случае, I<sig> может игнорироваться (при перезапуске "
"трассируемой нити из ptrace-stop в отличный от signal-delivery-stop, "
"рекомендуется передавать в I<sig> значение 0)."

#. type: SS
#: man-pages/man2/ptrace.2:1981
#, no-wrap
msgid "Attaching and detaching"
msgstr "Присоединение и отсоединение"

#. type: Plain text
#: man-pages/man2/ptrace.2:1983
msgid "A thread can be attached to the tracer using the call"
msgstr "Нить можно присоединить к трассировщику с помощью вызова"

#. type: Plain text
#: man-pages/man2/ptrace.2:1985
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:1987 man-pages/man2/ptrace.2:2841
msgid "or"
msgstr "или"

#. type: Plain text
#: man-pages/man2/ptrace.2:1989
#, no-wrap
msgid "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"
msgstr "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"

#.  FIXME Describe how to attach to a thread which is already group-stopped.
#. type: Plain text
#: man-pages/man2/ptrace.2:2013
msgid ""
"B<PTRACE_ATTACH> sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""
"B<PTRACE_ATTACH> посылает в нить B<SIGSTOP>. Если трассировщик хочет "
"отменить действие B<SIGSTOP>, ему нужно его подавить. Заметим, что если при "
"присоединении в эту нить в тоже время посылаются другие сигналы, то "
"трассировщик может увидеть, что трассируемая нить сначала вошла в signal-"
"delivery-stop из этих сигналов! Обычной практикой является повторное "
"внедрение этих сигналов до тех пор, пока не будет обнаружен B<SIGSTOP>, а "
"затем подавление внедрения B<SIGSTOP>. Здесь есть ошибка в проектировании в "
"том, что присоединение ptrace и одновременно доставляемый B<SIGSTOP> могут "
"состязаться и одновременный B<SIGSTOP> может быть утерян."

#. type: Plain text
#: man-pages/man2/ptrace.2:2020
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""
"Так как при присоединении посылается B<SIGSTOP> и трассировщик обычно "
"подавляет его, то это может привести к блуждающему возврату B<EINTR> из в "
"данный момент выполняемого системного вызова в трассируемой нити, как "
"описано в разделе «Внедрение и отмена сигнала»."

#. type: Plain text
#: man-pages/man2/ptrace.2:2032
msgid ""
"Since Linux 3.4, B<PTRACE_SEIZE> can be used instead of B<PTRACE_ATTACH>.  "
"B<PTRACE_SEIZE> does not stop the attached process.  If you need to stop it "
"after attach (or at any other time) without sending it any signals, use "
"B<PTRACE_INTERRUPT> command."
msgstr ""
"Начиная с Linux 3.4, вместо B<PTRACE_ATTACH> можно использовать "
"B<PTRACE_SEIZE>. B<PTRACE_SEIZE> не останавливает присоединённый. Если вам "
"нужно остановить его после присоединения (или в любое другое время) без "
"отправки каких-либо, используйте действие B<PTRACE_INTERRUPT>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2034
msgid "The request"
msgstr "Запрос"

#. type: Plain text
#: man-pages/man2/ptrace.2:2036
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2042
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""
"включает трассировку вызвавшей нити. Нить продолжает выполняться (не входит "
"в ptrace-stop). Обычно, за B<PTRACE_TRACEME> следует"

#. type: Plain text
#: man-pages/man2/ptrace.2:2044
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr "    raise(SIGSTOP);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2047
msgid ""
"and allow the parent (which is our tracer now) to observe our signal-"
"delivery-stop."
msgstr ""
"и это позволяет родителю (который теперь трассировщик) отследить signal-"
"delivery-stop."

#. type: Plain text
#: man-pages/man2/ptrace.2:2071
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""
"Если включены флаги B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK> или "
"B<PTRACE_O_TRACECLONE>, то потомок, создаваемый, соответственно, B<vfork>(2) "
"или B<clone>(2) с флагом B<CLONE_VFORK>, B<fork>(2) или B<clone>(2) с "
"установленным выходным сигналом равным B<SIGCHLD>, и другими видами "
"B<clone>(2), автоматически присоединяется к тому же трассировщику, которой "
"трассирует их родителя. Сигнал B<SIGSTOP> доставляется потомку, заставляя "
"его войти в signal-delivery-stop после завершения системного вызова, который "
"его создал."

#. type: Plain text
#: man-pages/man2/ptrace.2:2073
msgid "Detaching of the tracee is performed by:"
msgstr "Отсоединение от трассируемой нити выполняется с помощью:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2075
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2083
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""
"B<PTRACE_DETACH> является перезапускающей операцией, поэтому она требует, "
"чтобы трассируемая нить была в ptrace-stop. Если трассируемая нить в signal-"
"delivery-stop, то может быть внедрён сигнал. В противном случае параметр "
"I<sig> может быть проигнорирован."

#.  FIXME Describe how to detach from a group-stopped tracee so that it
#.  doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: man-pages/man2/ptrace.2:2107
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""
"Если трассировщик хочет отсоединиться,а трассируемая нить выполняется, то "
"решением является посылка сигнала B<SIGSTOP> (с помощью B<tgkill>(2), чтобы "
"точно достичь текущей нити), ожидание пока трассируемая нить не войдёт в "
"signal-delivery-stop для доставки B<SIGSTOP> и затем отсоединение от неё "
"(подавив внедрение B<SIGSTOP>). Ошибкой проектирования является возможность "
"гонок с параллельно отправленными B<SIGSTOP>. Другая трудность в том, что "
"трассируемая нить может войти в другой ptrace-stop и потребуется его "
"перезапуск и повторное ожидание появления B<SIGSTOP>. Ещё одной сложностью "
"является в проверки, что трассируемая нить уже не в ptrace-stop, так как в "
"этом случае доставки сигнала не происходит — даже B<SIGSTOP>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2115
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from signal-delivery-"
"stop, the pending signal is injected."
msgstr ""
"Если трассировщик завершает работу, то все трассируемые нити автоматически "
"отсоединяются и перезапускаются, если они не в group-stop. Выполнение "
"перезапуска из group-stop в настоящее время содержит ошибки, но «плановым» "
"поведением считается оставить трассируемую нить остановленной и подождать "
"B<SIGCONT>. Если трассируемая нить перезапускается из signal-delivery-stop, "
"то внедряется ожидающий сигнал."

#. type: SS
#: man-pages/man2/ptrace.2:2115
#, no-wrap
msgid "execve(2) under ptrace"
msgstr "Выполнение execve(2) во время ptrace"

#.  clone(2) CLONE_THREAD says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: man-pages/man2/ptrace.2:2134
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""
"Когда одна нить многонитевого процесса вызывает B<execve>(2), то ядро "
"уничтожает все остальные нити процесса и сбрасывает ID выполняющейся нити в "
"значение ID группы нитей (ID процесса. Или, говоря иначе, когда многонитевой "
"процесс выполняет B<execve>(2), то по завершению вызова это выглядит как "
"если бы B<execve>(2) произошёл в лидере группе нитей, независимо от того, "
"какая нить вызвала B<execve>(2)). Такой сброс ID нити запутывает "
"трассировщиков:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2144
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""
"Все остальные нити останавливаются в останове B<PTRACE_EVENT_EXIT>, если "
"включён флаг B<PTRACE_O_TRACEEXIT>. Затем все остальные нити, за исключением "
"лидера группы нитей, сообщают о завершении, как если бы они кончили работу с "
"помощью B<_exit>(2) с кодом выхода 0."

#. type: Plain text
#: man-pages/man2/ptrace.2:2152
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""
"У исполняемой трассируемой нити изменяется ID, так как она выполняет "
"B<execve>(2) (помните, что в ptrace «pid», возвращаемый из B<waitpid>(2) или "
"подаваемый в вызовы ptrace, это ID трассируемой нити). То есть ID "
"трассируемой нити сбрасывается в значение ID своего процесса, который равен "
"ID лидера группы нитей."

#. type: Plain text
#: man-pages/man2/ptrace.2:2158
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""
"Затем происходит остановка B<PTRACE_EVENT_EXEC>, если включён флаг "
"B<PTRACE_O_TRACEEXEC>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2179
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""
"Если в это время лидер группы нитей сообщил о своей остановке "
"B<PTRACE_EVENT_EXIT> в это время, то трассировщику кажется, что "
"завершившийся лидер группы «возник из ниоткуда» (замечание: лидер группы "
"нитей не сообщает о завершении через I<WIFEXITED(status)> до тех пор, пока "
"есть одна работающая нить. Это не даёт возможности трассировщику увидеть его "
"завершение и повторное появление). Если лидер группы нитей всё ещё "
"выполнялся, то для трассировщика может казаться, что лидер группы нитей "
"вернулся из другого системного вызова в который входил, или даже «вернулся "
"из системного вызова, хотя не был ни в каком системном вызове». Если лидер "
"группы нитей не трассируется (или трассируется другим трассировщиком), то во "
"время B<execve>(2) он выглядит так, как если бы стал трассируемым "
"трассировщиком выполняющейся трассируемой нити."

#. type: Plain text
#: man-pages/man2/ptrace.2:2182
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""
"Все перечисленные выше эффекты происходят из-за смены ID трассируемой нити."

#. type: Plain text
#: man-pages/man2/ptrace.2:2202
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0.)  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""
"В этой ситуации рекомендуется использовать флаг B<PTRACE_O_TRACEEXEC>. Во-"
"первых, он включает остановку B<PTRACE_EVENT_EXEC>, которая происходит перед "
"возвратом из B<execve>(2). В этой остановке трассировщик может использовать "
"B<PTRACE_GETEVENTMSG> для получения предыдущего ID трассируемой нити (эта "
"возможность появилась в Linux 3.0). Во-вторых, флаг B<PTRACE_O_TRACEEXEC> "
"отключает устаревшую генерацию B<SIGTRAP> при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2208
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""
"Когда трассировщик получает уведомление об остановке B<PTRACE_EVENT_EXEC>, "
"гарантируется, что за исключением этой трассируемой нити и лидера группы "
"нитей, больше живых нитей в этом процессе нет."

#. type: Plain text
#: man-pages/man2/ptrace.2:2216
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""
"По получению уведомления об остановке B<PTRACE_EVENT_EXEC> трассировщик "
"должен очистить все свои внутренние структуры данных, описывающие нити этого "
"процесса, и оставить только одну структуру данных, которая описывает одну "
"ещё выполняющуюся трассируемую нить, у которой"

#. type: Plain text
#: man-pages/man2/ptrace.2:2218
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr "    ID нити == ID группы нитей == ID процесса.\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2222
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr "Пример: две нити вызывают B<execve>(2) одновременно:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2233
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""
"*** мы получаем syscall-enter-stop в нити 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** мы выдаём PTRACE_SYSCALL для нити 1 **\n"
"*** мы получаем syscall-enter-stop в нити 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** мы выдаём PTRACE_SYSCALL для нити 2 **\n"
"*** мы получаем PTRACE_EVENT_EXEC for PID0, мы выдаём PTRACE_SYSCALL **\n"
"*** мы получаем syscall-exit-stop для PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2261
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, and if the tracee was B<PTRACE_ATTACH>ed rather that "
"B<PTRACE_SEIZE>d, the kernel delivers an extra B<SIGTRAP> to the tracee "
"after B<execve>(2)  returns.  This is an ordinary signal (similar to one "
"which can be generated by I<kill -TRAP>), not a special kind of ptrace-"
"stop.  Employing B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set "
"to 0 (I<SI_USER>).  This signal may be blocked by signal mask, and thus may "
"be delivered (much) later."
msgstr ""
"Если флаг B<PTRACE_O_TRACEEXEC> I<не> действует на выполняющуюся "
"трассируемую нить и если трассируемая нить подключена с помощью "
"B<PTRACE_ATTACH>, а не B<PTRACE_SEIZE>, то ядро доставляет ей дополнительный "
"B<SIGTRAP> после возврата из B<execve>(2). Это обычный сигнал (похожий на "
"тот, который генерируется с помощью I<kill -TRAP>), а не какая-то "
"специальная разновидность ptrace-stop. Выдача B<PTRACE_GETSIGINFO> для этого "
"сигнала возвращает I<si_code> равный 0 (I<SI_USER>). Этот сигнал может быть "
"блокирован маской сигналов и поэтому может быть доставлен (намного) позже."

#. type: Plain text
#: man-pages/man2/ptrace.2:2282
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option or using B<PTRACE_SEIZE> and thus "
"suppressing this extra B<SIGTRAP> is the recommended approach."
msgstr ""
"Обычно, трассировщик (например, B<strace>(1)) не хотел бы показывать этот "
"дополнительный пост-execve B<SIGTRAP> сигнал пользователю, и хотел бы "
"подавить его доставку в трассируемую нить (если обработчик B<SIGTRAP> равен "
"B<SIG_DFL>, то это уничтожающий сигнал). Однако, определить I<какой> "
"B<SIGTRAP> подавлять, нелегко. Рекомендуется установить флаг "
"B<PTRACE_O_TRACEEXEC> или B<PTRACE_SEIZE> и затем подавить этот "
"дополнительный B<SIGTRAP>."

#. type: SS
#: man-pages/man2/ptrace.2:2282
#, no-wrap
msgid "Real parent"
msgstr "Настоящий родитель"

#. type: Plain text
#: man-pages/man2/ptrace.2:2289
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""
"Программный интерфейс ptrace использует стандартный обмен сигналами UNIX "
"между родителем и потомком через B<waitpid>(2). Это приводит к тому, что "
"настоящий родитель процесса перестаёт получать некоторые виды уведомлений "
"B<waitpid>(2), когда дочерний процесс трассируется другим процессом."

#. type: Plain text
#: man-pages/man2/ptrace.2:2292
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""
"Многие из этих дефектов были исправлены, но на момент версии Linux 2.6.38 "
"некоторые из них всё ещё существуют; смотрите ДЕФЕКТЫ далее."

#. type: Plain text
#: man-pages/man2/ptrace.2:2294
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr "На момент версии Linux 2.6.38 работает правильно:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2302
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""
"при выходе/уничтожении по сигналу об этом сначала сообщается трассировщику, "
"а затем,когда трассировщик подтвердит результат B<waitpid>(2), настоящему "
"родителю (настоящему родителю только когда завершается многонитевой процесс "
"целиком). Если трассировщик и реальный родитель — один и тот же процесс, то "
"сообщение приходит лишь однажды."

#. type: Plain text
#: man-pages/man2/ptrace.2:2310
msgid ""
"On success, the B<PTRACE_PEEK*> requests return the requested data (but see "
"NOTES), the B<PTRACE_SECCOMP_GET_FILTER> request returns the number of "
"instructions in the BPF program, and other requests return zero."
msgstr ""
"При успешном выполнении запросы B<PTRACE_PEEK*> возвращают запрашиваемые "
"данные (но смотрите ЗАМЕЧАНИЯ), запрос B<PTRACE_SECCOMP_GET_FILTER> "
"возвращает количество инструкций в программе BPF, а другие запросы "
"возвращают ноль."

#. type: Plain text
#: man-pages/man2/ptrace.2:2320
msgid ""
"On error, all requests return -1, and I<errno> is set appropriately.  Since "
"the value returned by a successful B<PTRACE_PEEK*> request may be -1, the "
"caller must clear I<errno> before the call, and then check it afterward to "
"determine whether or not an error occurred."
msgstr ""
"При ошибке для всех действий возвращается -1, а переменной I<errno> "
"присваивается номер ошибки. Так как значение, возвращаемое при удачном "
"выполнении B<PTRACE_PEEK*>, может равняться -1, перед вызовом вызывающий "
"должен очистить содержимое I<errno>, чтобы узнать, возникала ошибка или нет."

#. type: Plain text
#: man-pages/man2/ptrace.2:2324
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""
"(только для i386) Произошла ошибка при размещении или освобождении "
"отладочного регистра."

#. type: Plain text
#: man-pages/man2/ptrace.2:2335
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""
"Была сделана попытка чтения или записи информации в область памяти "
"трассируемой нити или трассировщика, но, скорее всего, эта память не "
"отображена или недоступна. К сожалению, в Linux в разных ситуациях в "
"результате этой ошибки возвращаются значения B<EIO> или B<EFAULT>, что не "
"всегда поддается объяснению."

#. type: Plain text
#: man-pages/man2/ptrace.2:2338
msgid "An attempt was made to set an invalid option."
msgstr "Попытка установить недопустимое значение."

#. type: Plain text
#: man-pages/man2/ptrace.2:2345
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr ""
"Задано неверное значение I<request>, или была попытка чтения или записи "
"информации в неподходящую область памяти трассируемой нити или "
"трассировщика; ошибка выравнивания слов по границе, или при запросе "
"возобновления работы дочернего процесса был задан неверно номер сигнала."

#. type: Plain text
#: man-pages/man2/ptrace.2:2358
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(1)  (PID 1)."
msgstr ""
"Указанный процесс не может быть трассирован. Это может произойти потому, что "
"трассировщик не имеет прав на трассировку (требуется мандат "
"B<CAP_SYS_PTRACE>); непривилегированные процессы не могут трассировать "
"процессы, так как они не могут посылать сигналы, или если у них установлен "
"set-user-ID/set-group-ID бит. Также, процесс может уже трассироваться или "
"(на ядрах до версии 2.6.26) быть B<init>(1) (PID 1)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2363
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""
"Указанный процесс не существует, в данный момент не трассируется вызывающим "
"процессом, или не остановлен (для выполнения действий, которые требуют "
"остановки трассируемой нити)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2365
msgid "SVr4, 4.3BSD."
msgstr "SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/ptrace.2:2380
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  It is recommended to "
"always supply four arguments, even if the requested operation does not use "
"them, setting unused/ignored arguments to I<0L> or I<(void\\ *)\\ 0>."
msgstr ""
"Хотя параметры B<ptrace>() воспринимаются согласно заданному прототипу, в "
"настоящее время в glibc B<ptrace>() объявлена как функция с переменным "
"числом параметров, в которой фиксирован только параметр I<request>. "
"Рекомендуется всегда передавать четыре параметра, даже если в запрашиваемом "
"действии они не используются (неиспользуемые аргументы указывайте как I<0L> "
"или I<(void\\ *)\\ 0>)."

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: man-pages/man2/ptrace.2:2385
msgid ""
"In Linux kernels before 2.6.26, B<init>(1), the process with PID 1, may not "
"be traced."
msgstr ""
"В ядрах Linux до версии 2.6.26, процесс B<init>(1) с PID 1 не может быть "
"трассирован."

#. type: Plain text
#: man-pages/man2/ptrace.2:2388
msgid ""
"A tracees parent continues to be the tracer even if that tracer calls "
"B<execve>(2)."
msgstr ""
"Родитель трассируемой нити остаётся трассировщиком даже, если трассировщик "
"вызывает B<execve>(2)."

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: man-pages/man2/ptrace.2:2395
msgid ""
"The layout of the contents of memory and the USER area are quite operating-"
"system- and architecture-specific.  The offset supplied, and the data "
"returned, might not entirely match with the definition of I<struct user>."
msgstr ""
"Структура памяти и области USER зависят от ОС и архитектуры системы. "
"Указываемое смещение и возвращаемые данные могут не полностью "
"соответствовать определению I<struct user>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2398
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr ""
"Размер «слова» определяется вариантом ОС (например, для 32-битного варианта "
"Linux слово будет 32-битным)."

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/ptrace.2:2409
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs significantly on other flavors of UNIX.  In any case, "
"use of B<ptrace>()  is highly specific to the operating system and "
"architecture."
msgstr ""
"Эта страница описывает работу системного вызова B<ptrace>() в Linux. Его "
"работа значительно отличается от поведения в других системах UNIX. В любом "
"случае, использование B<ptrace>() очень сильно зависит от ОС и архитектуры."

#. type: SS
#: man-pages/man2/ptrace.2:2409
#, no-wrap
msgid "Ptrace access mode checking"
msgstr "Проверка режима доступа ptrace"

#. type: Plain text
#: man-pages/man2/ptrace.2:2424
msgid ""
"Various parts of the kernel-user-space API (not just B<ptrace>()  "
"operations), require so-called \"ptrace access mode\" checks, whose outcome "
"determines whether an operation is permitted (or, in a few cases, causes a "
"\"read\" operation to return sanitized data).  These checks are performed in "
"cases where one process can inspect sensitive information about, or in some "
"cases modify the state of, another process.  The checks are based on factors "
"such as the credentials and capabilities of the two processes, whether or "
"not the \"target\" process is dumpable, and the results of checks performed "
"by any enabled Linux Security Module (LSM)\\(emfor example, SELinux, Yama, "
"or Smack\\(emand by the commoncap LSM (which is always invoked)."
msgstr ""
"Для различных частей программного интерфейса ядро — пользовательское "
"пространство (не только операции B<ptrace>()) требуются так называемые "
"проверки «режима доступа ptrace», чьими результатами определяется будет ли "
"разрешена операция (или это, в некоторых случаях, заставит операцию «чтения» "
"цензурировать возвращаемые данные). Эти проверки выполняются в случаях, "
"когда один процесс может просмотреть конфиденциальную информацию или, в "
"некоторых случаях, изменять состояние другого процесса. Проверки "
"основываются на учётных данных и мандатах двух процессов, разрешено ли "
"создание дампа «целевого» процесса, а результаты проверок выполняются любым "
"включённым модулем безопасности Linux (LSM) — например, SELinux, Yama и  "
"Smack — и commoncap LSM (который вызывается всегда)."

#.  commit 006ebb40d3d65338bd74abb03b945f8d60e362bd
#. type: Plain text
#: man-pages/man2/ptrace.2:2429
msgid ""
"Prior to Linux 2.6.27, all access checks were of a single type.  Since Linux "
"2.6.27, two access mode levels are distinguished:"
msgstr ""
"До Linux 2.6.27 все проверки доступа были одного вида. Начиная с Linux "
"2.6.27 различают два уровня проверок доступа:"

#. type: TP
#: man-pages/man2/ptrace.2:2429
#, no-wrap
msgid "B<PTRACE_MODE_READ>"
msgstr "B<PTRACE_MODE_READ>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2445
msgid ""
"For \"read\" operations or other operations that are less dangerous, such "
"as: B<get_robust_list>(2); B<kcmp>(2); reading I</proc/[pid]/auxv>, I</proc/"
"[pid]/environ>, or I</proc/[pid]/stat>; or B<readlink>(2)  of a I</proc/"
"[pid]/ns/*> file."
msgstr ""
"Для операций «чтения» или других менее опасных операций: "
"B<get_robust_list>(2); B<kcmp>(2); чтение I</proc/[pid]/auxv>, I</proc/[pid]/"
"environ> или I</proc/[pid]/stat>, или B<readlink>(2) для файла I</proc/[pid]/"
"ns/*>."

#. type: TP
#: man-pages/man2/ptrace.2:2445
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH>"
msgstr "B<PTRACE_MODE_ATTACH>"

#.  Regarding the above description of the distinction between
#.  PTRACE_MODE_READ and PTRACE_MODE_ATTACH, Stephen Smalley notes:
#.      That was the intent when the distinction was introduced, but it doesn't
#.      appear to have been properly maintained, e.g. there is now a common
#.      helper lock_trace() that is used for
#.      /proc/pid/{stack,syscall,personality} but checks PTRACE_MODE_ATTACH, and
#.      PTRACE_MODE_ATTACH is also used in timerslack_ns_write/show().  Likely
#.      should review and make them consistent.  There was also some debate
#.      about proper handling of /proc/pid/fd.  Arguably that one might belong
#.      back in the _ATTACH camp.
#. type: Plain text
#: man-pages/man2/ptrace.2:2468
msgid ""
"For \"write\" operations, or other operations that are more dangerous, such "
"as: ptrace attaching (B<PTRACE_ATTACH>)  to another process or calling "
"B<process_vm_writev>(2).  (B<PTRACE_MODE_ATTACH> was effectively the default "
"before Linux 2.6.27.)"
msgstr ""
"Для операций  «записи» или других более опасных операций: присоединение "
"ptrace (B<PTRACE_ATTACH>) к другому процессу или вызов "
"B<process_vm_writev>(2) (B<PTRACE_MODE_ATTACH> было эффективным значением по "
"умолчанию до Linux 2.6.27)."

#.  commit caaee6234d05a58c5b4d05e7bf766131b810a657
#. type: Plain text
#: man-pages/man2/ptrace.2:2473
msgid ""
"Since Linux 4.5, the above access mode checks are combined (ORed) with one "
"of the following modifiers:"
msgstr ""
"Начиная с Linux 4.5 приведённые выше проверки режима доступа объединяются "
"(ИЛИ) с одним из следующих модификаторов:"

#. type: TP
#: man-pages/man2/ptrace.2:2473
#, no-wrap
msgid "B<PTRACE_MODE_FSCREDS>"
msgstr "B<PTRACE_MODE_FSCREDS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2478
msgid ""
"Use the caller's filesystem UID and GID (see B<credentials>(7))  or "
"effective capabilities for LSM checks."
msgstr ""
"Использовать UID и GID файловой системы у вызывающего (смотрите "
"B<credentials>(7)) или эффективные мандаты для проверок LSM."

#. type: TP
#: man-pages/man2/ptrace.2:2478
#, no-wrap
msgid "B<PTRACE_MODE_REALCREDS>"
msgstr "B<PTRACE_MODE_REALCREDS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2482
msgid ""
"Use the caller's real UID and GID or permitted capabilities for LSM checks.  "
"This was effectively the default before Linux 4.5."
msgstr ""
"Использовать реальные UID и GID у вызывающего или разрешающие мандаты для "
"проверок LSM. Это было эффективным значением по умолчанию до Linux 4.5."

#. type: Plain text
#: man-pages/man2/ptrace.2:2486
msgid ""
"Because combining one of the credential modifiers with one of the "
"aforementioned access modes is typical, some macros are defined in the "
"kernel sources for the combinations:"
msgstr ""
"Так как объединение модификаторов мандатов с одной из вышеупомянутых режимов "
"доступа часто используется, то в исходном коде ядра было определено "
"несколько макросов:"

#. type: TP
#: man-pages/man2/ptrace.2:2486
#, no-wrap
msgid "B<PTRACE_MODE_READ_FSCREDS>"
msgstr "B<PTRACE_MODE_READ_FSCREDS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2490
msgid "Defined as B<PTRACE_MODE_READ | PTRACE_MODE_FSCREDS>."
msgstr "Определён как B<PTRACE_MODE_READ | PTRACE_MODE_FSCREDS>."

#. type: TP
#: man-pages/man2/ptrace.2:2490
#, no-wrap
msgid "B<PTRACE_MODE_READ_REALCREDS>"
msgstr "B<PTRACE_MODE_READ_REALCREDS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2494
msgid "Defined as B<PTRACE_MODE_READ | PTRACE_MODE_REALCREDS>."
msgstr "Определён как B<PTRACE_MODE_READ | PTRACE_MODE_REALCREDS>."

#. type: TP
#: man-pages/man2/ptrace.2:2494
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH_FSCREDS>"
msgstr "B<PTRACE_MODE_ATTACH_FSCREDS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2498
msgid "Defined as B<PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS>."
msgstr "Определён как B<PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS>."

#. type: TP
#: man-pages/man2/ptrace.2:2498
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH_REALCREDS>"
msgstr "B<PTRACE_MODE_ATTACH_REALCREDS>"

#. type: Plain text
#: man-pages/man2/ptrace.2:2502
msgid "Defined as B<PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS>."
msgstr "Определён как B<PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2504
msgid "One further modifier can be ORed with the access mode:"
msgstr ""
"Один из следующих модификаторов может быть объединённых с режимом доступа:"

#. type: TP
#: man-pages/man2/ptrace.2:2504
#, no-wrap
msgid "B<PTRACE_MODE_NOAUDIT> (since Linux 3.3)"
msgstr "B<PTRACE_MODE_NOAUDIT> (начиная с Linux 3.3)"

#.  commit 69f594a38967f4540ce7a29b3fd214e68a8330bd
#.  Just for /proc/pid/stat
#. type: Plain text
#: man-pages/man2/ptrace.2:2518
msgid ""
"Don't audit this access mode check.  This modifier is employed for ptrace "
"access mode checks (such as checks when reading I</proc/[pid]/stat>)  that "
"merely cause the output to be filtered or sanitized, rather than causing an "
"error to be returned to the caller.  In these cases, accessing the file is "
"not a security violation and there is no reason to generate a security audit "
"record.  This modifier suppresses the generation of such an audit record for "
"the particular access check."
msgstr ""
"Не протоколировать (audit) проверку режима доступа. Данный модификатор "
"применяется для проверок режима доступа ptrace (например, проверки при "
"чтении I</proc/[pid]/stat>), которые просто фильтруют или цензурируют вывод, "
"вместо возврата ошибки вызывающему. В этих случаях, доступ к файлу не "
"нарушает правила безопасности и нет причины генерировать запись о нарушении. "
"Данный модификатор отключает создание подобных протокольных записей для "
"определённых проверок доступа."

#. type: Plain text
#: man-pages/man2/ptrace.2:2529
msgid ""
"Note that all of the B<PTRACE_MODE_*> constants described in this subsection "
"are kernel-internal, and not visible to user space.  The constant names are "
"mentioned here in order to label the various kinds of ptrace access mode "
"checks that are performed for various system calls and accesses to various "
"pseudofiles (e.g., under I</proc>).  These names are used in other manual "
"pages to provide a simple shorthand for labeling the different kernel checks."
msgstr ""
"Заметим, что все константы B<PTRACE_MODE_*>, описанные в данном разделе, "
"доступны только для ядра и не видны из пользовательского пространства. Имена "
"упомянутых констант служат обозначением различных видов проверок режима "
"доступа ptrace, которые выполняются для разных системных вызовов и получении "
"доступа к разным псевдо-файлам (например, в каталоге I</proc>). Эти имена "
"используются в других справочных страницах как простые сокращения различных "
"проверок ядра."

#. type: Plain text
#: man-pages/man2/ptrace.2:2538
msgid ""
"The algorithm employed for ptrace access mode checking determines whether "
"the calling process is allowed to perform the corresponding action on the "
"target process.  (In the case of opening I</proc/[pid]> files, the \"calling "
"process\" is the one opening the file, and the process with the "
"corresponding PID is the \"target process\".)  The algorithm is as follows:"
msgstr ""
"Задействуемый алгоритм проверок режима доступа ptrace определяется по "
"разрешению вызывающему процессу выполнять соответствующее действие над "
"процессом назначения (в случае открытия файлов I</proc/[pid]> «вызывающий "
"процесс» это открывающий файл, а процесс с соответствующим PID — «процесс "
"назначения»). Возможные алгоритмы:"

#. type: IP
#: man-pages/man2/ptrace.2:2538
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man2/ptrace.2:2541
msgid ""
"If the calling thread and the target thread are in the same thread group, "
"access is always allowed."
msgstr ""
"Если вызывающая нить и нить назначения в одной группе нитей, то доступ "
"всегда разрешён."

#. type: IP
#: man-pages/man2/ptrace.2:2541
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man2/ptrace.2:2550
msgid ""
"If the access mode specifies B<PTRACE_MODE_FSCREDS>, then, for the check in "
"the next step, employ the caller's filesystem UID and GID.  (As noted in "
"B<credentials>(7), the filesystem UID and GID almost always have the same "
"values as the corresponding effective IDs.)"
msgstr ""
"Если режим доступа равен B<PTRACE_MODE_FSCREDS>, то для проверки на "
"следующем шаге используется UID и GID файловой системы у вызывающего (как "
"упомянуто в B<credentials>(7), UID и GID файловой системы почти всегда равны "
"значениям соответствующих эффективных идентификаторов)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2558
msgid ""
"Otherwise, the access mode specifies B<PTRACE_MODE_REALCREDS>, so use the "
"caller's real UID and GID for the checks in the next step.  (Most APIs that "
"check the caller's UID and GID use the effective IDs.  For historical "
"reasons, the B<PTRACE_MODE_REALCREDS> check uses the real IDs instead.)"
msgstr ""
"В противном случае режим доступа равен B<PTRACE_MODE_REALCREDS>, и на "
"следующем шаге проверок используются реальные UID и GID вызывающего "
"(большинство программных интерфейсов, которые проверяют UID и GID "
"вызывающего, используют эффективные идентификаторы. В проверке "
"B<PTRACE_MODE_REALCREDS> используются реальные ID только в силу исторических "
"причин)."

#. type: IP
#: man-pages/man2/ptrace.2:2558
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man2/ptrace.2:2562 man-pages/man2/ptrace.2:2609
msgid "Deny access if I<neither> of the following is true:"
msgstr "Запрещается доступ, если срабатывает I<любое> из этих правил:"

#. type: IP
#: man-pages/man2/ptrace.2:2563 man-pages/man2/ptrace.2:2569
#: man-pages/man2/ptrace.2:2610 man-pages/man2/ptrace.2:2615
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man2/ptrace.2:2569
msgid ""
"The real, effective, and saved-set user IDs of the target match the caller's "
"user ID, I<and> the real, effective, and saved-set group IDs of the target "
"match the caller's group ID."
msgstr ""
"Реальные, эффективные и сохранённые пользовательские ID назначения совпадают "
"с пользовательским ID вызывающего, I<и> Реальные, эффективные и сохранённые "
"групповые ID назначения совпадают с групповым ID вызывающего."

#. type: Plain text
#: man-pages/man2/ptrace.2:2573
msgid ""
"The caller has the B<CAP_SYS_PTRACE> capability in the user namespace of the "
"target."
msgstr ""
"Вызывающий имеет мандат B<CAP_SYS_PTRACE> в пользовательском пространстве "
"имён назначения."

#. type: IP
#: man-pages/man2/ptrace.2:2574
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man2/ptrace.2:2584
msgid ""
"Deny access if the target process \"dumpable\" attribute has a value other "
"than 1 (B<SUID_DUMP_USER>; see the discussion of B<PR_SET_DUMPABLE> in "
"B<prctl>(2)), and the caller does not have the B<CAP_SYS_PTRACE> capability "
"in the user namespace of the target process."
msgstr ""
"Доступ запрещается, если у процесса назначения значение атрибута "
"«возможности дампа» не равно 1 (B<SUID_DUMP_USER>; смотрите обсуждение "
"B<PR_SET_DUMPABLE> в B<prctl>(2)), и вызывающий не имеет мандата "
"B<CAP_SYS_PTRACE> в пользовательском пространстве имён назначения."

#. type: IP
#: man-pages/man2/ptrace.2:2584
#, no-wrap
msgid "5."
msgstr "5."

#.  (in cap_ptrace_access_check()):
#. type: Plain text
#: man-pages/man2/ptrace.2:2592
msgid ""
"The kernel LSM I<security_ptrace_access_check>()  interface is invoked to "
"see if ptrace access is permitted.  The results depend on the LSM(s).  The "
"implementation of this interface in the commoncap LSM performs the following "
"steps:"
msgstr ""
"Для проверки того, что доступ ptrace разрешён, вызывается интерфейс ядра LSM "
"I<security_ptrace_access_check>(). Результат зависит от LSM. Реализация "
"интерфейса в commoncap LSM выполняет следующие шаги:"

#. type: IP
#: man-pages/man2/ptrace.2:2593
#, no-wrap
msgid "a)"
msgstr "а)"

#. type: Plain text
#: man-pages/man2/ptrace.2:2605
msgid ""
"If the access mode includes B<PTRACE_MODE_FSCREDS>, then use the caller's "
"I<effective> capability set in the following check; otherwise (the access "
"mode specifies B<PTRACE_MODE_REALCREDS>, so) use the caller's I<permitted> "
"capability set."
msgstr ""
"Если режим доступа включает B<PTRACE_MODE_FSCREDS>, то используется "
"I<эффективный> набор мандатов вызывающего в последующей проверке; в "
"противном случае (режим доступа равен B<PTRACE_MODE_REALCREDS>) используется "
"I<допускающий> набор мандатов."

#. type: IP
#: man-pages/man2/ptrace.2:2605
#, no-wrap
msgid "b)"
msgstr "б)"

#. type: Plain text
#: man-pages/man2/ptrace.2:2615
msgid ""
"The caller and the target process are in the same user namespace, and the "
"caller's capabilities are a superset of the target process's I<permitted> "
"capabilities."
msgstr ""
"Вызывающий и процесс назначения находятся в одном пользовательском "
"пространстве имён, и мандаты вызывающего составляют покрывающий набор "
"I<допускающих> мандатов процесса назначения."

#. type: Plain text
#: man-pages/man2/ptrace.2:2619
msgid ""
"The caller has the B<CAP_SYS_PTRACE> capability in the target process's user "
"namespace."
msgstr ""
"Вызывающий имеет мандат B<CAP_SYS_PTRACE> в пользовательском пространстве "
"имён процесса назначения."

#. type: Plain text
#: man-pages/man2/ptrace.2:2625
msgid ""
"Note that the commoncap LSM does not distinguish between B<PTRACE_MODE_READ> "
"and B<PTRACE_MODE_ATTACH>."
msgstr ""
"Заметим, что commoncap LSM не различает B<PTRACE_MODE_READ> и "
"B<PTRACE_MODE_ATTACH>."

#. type: IP
#: man-pages/man2/ptrace.2:2626
#, no-wrap
msgid "6."
msgstr "6."

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/ptrace.2:2632
msgid ""
"If access has not been denied by any of the preceding steps, then access is "
"allowed."
msgstr "Если доступ не был запрещён в предыдущих шагах, то доступ разрешается."

#. type: SS
#: man-pages/man2/ptrace.2:2632
#, no-wrap
msgid "/proc/sys/kernel/yama/ptrace_scope"
msgstr "/proc/sys/kernel/yama/ptrace_scope"

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#. type: Plain text
#: man-pages/man2/ptrace.2:2651
msgid ""
"On systems with the Yama Linux Security Module (LSM) installed (i.e., the "
"kernel was configured with B<CONFIG_SECURITY_YAMA>), the I</proc/sys/kernel/"
"yama/ptrace_scope> file (available since Linux 3.4)  can be used to restrict "
"the ability to trace a process with B<ptrace>()  (and thus also the ability "
"to use tools such as B<strace>(1)  and B<gdb>(1)).  The goal of such "
"restrictions is to prevent attack escalation whereby a compromised process "
"can ptrace-attach to other sensitive processes (e.g., a GPG agent or an SSH "
"session) owned by the user in order to gain additional credentials that may "
"exist in memory and thus expand the scope of the attack."
msgstr ""
"В системах с установленным модулем Yama Linux Security Module (LSM) (т. е., "
"ядро было настроено с параметром B<CONFIG_SECURITY_YAMA>) можно использовать "
"файл I</proc/sys/kernel/yama/ptrace_scope> (доступен, начиная с Linux 3.4) "
"для того, чтобы огранить возможность трассировки процесса с помощью "
"B<ptrace>() (то есть ограничить использование таких инструментов как "
"B<strace>(1) и B<gdb>(1)). Целью ограничения является предотвращение "
"возможности атаки, посредством которой скомпроментированный процесс "
"подключается через ptrace к другим ответственным процессам (например, к  "
"агенту GPG или сеансу SSH), принадлежащим пользователю, чтобы получить "
"дополнительные полномочия (которые могут существовать в памяти) и, таким "
"образом, расширить атакуемое пространство."

#. type: Plain text
#: man-pages/man2/ptrace.2:2653
msgid "More precisely, the Yama LSM limits two types of operations:"
msgstr "Более точно, Yama LSM ограничивает два типа операций:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2660
msgid ""
"Any operation that performs a ptrace access mode B<PTRACE_MODE_ATTACH> check"
"\\(emfor example, B<ptrace>()  B<PTRACE_ATTACH>.  (See the \"Ptrace access "
"mode checking\" discussion above.)"
msgstr ""
"Все операции, которые выполняют проверку режима доступа ptrace "
"B<PTRACE_MODE_ATTACH>, например, B<ptrace>() B<PTRACE_ATTACH> (смотрите "
"«Проверка режима доступа ptrace» выше)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2664
msgid "B<ptrace>()  B<PTRACE_TRACEME>."
msgstr "B<ptrace>()  B<PTRACE_TRACEME>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2670
msgid ""
"A process that has the B<CAP_SYS_PTRACE> capability can update the I</proc/"
"sys/kernel/yama/ptrace_scope> file with one of the following values:"
msgstr ""
"Процесс, имеющий мандат B<CAP_SYS_PTRACE>, может записать в файл I</proc/sys/"
"kernel/yama/ptrace_scope> одно из следующих значений:"

#. type: TP
#: man-pages/man2/ptrace.2:2670
#, no-wrap
msgid "0 (\"classic ptrace permissions\")"
msgstr "0 («обычные права ptrace»)"

#. type: Plain text
#: man-pages/man2/ptrace.2:2675
msgid ""
"No additional restrictions on operations that perform B<PTRACE_MODE_ATTACH> "
"checks (beyond those imposed by the commoncap and other LSMs)."
msgstr ""
"Без дополнительных ограничений на операции, выполняющие проверки "
"B<PTRACE_MODE_ATTACH> (кроме накладываемых commoncap и другими LSM)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2679 man-pages/man2/ptrace.2:2708
msgid "The use of B<PTRACE_TRACEME> is unchanged."
msgstr "Использование B<PTRACE_TRACEME> не изменяется."

#. type: TP
#: man-pages/man2/ptrace.2:2679
#, no-wrap
msgid "1 (\"restricted ptrace\") [default value]"
msgstr "1 («ограниченный ptrace») [значение по умолчанию]"

#. type: Plain text
#: man-pages/man2/ptrace.2:2690
msgid ""
"When performing an operation that requires a B<PTRACE_MODE_ATTACH> check, "
"the calling process must either have the B<CAP_SYS_PTRACE> capability in the "
"user namespace of the target process or it must have a predefined "
"relationship with the target process.  By default, the predefined "
"relationship is that the target process must be a descendant of the caller."
msgstr ""
"Когда выполняется операция, требующая проверки B<PTRACE_MODE_ATTACH>, "
"вызывающий процесс должен иметь мандат B<CAP_SYS_PTRACE> в пользовательском "
"пространстве имён процесса назначения или должен иметь предопределённые "
"отношения с процессом назначения. По умолчанию, предопределённые отношения "
"это когда процесс назначения должен быть потомком вызывающего."

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#. type: Plain text
#: man-pages/man2/ptrace.2:2704
msgid ""
"A target process can employ the B<prctl>(2)  B<PR_SET_PTRACER> operation to "
"declare an additional PID that is allowed to perform B<PTRACE_MODE_ATTACH> "
"operations on the target.  See the kernel source file I<Documentation/admin-"
"guide/LSM/Yama.rst> (or I<Documentation/security/Yama.txt> before Linux "
"4.13)  for further details."
msgstr ""
"Процесс назначения может выполнить операцию B<prctl>(2) B<PR_SET_PTRACER> "
"для объявления дополнительного PID, которому разрешено выполнять операции "
"B<PTRACE_MODE_ATTACH> над процессом назначения. Подробности смотрите в файле "
"исходного кода ядра I<Documentation/admin-guide/LSM/Yama.rst> (или "
"I<Documentation/security/Yama.txt> до Linux 4.13)."

#. type: TP
#: man-pages/man2/ptrace.2:2708
#, no-wrap
msgid "2 (\"admin-only attach\")"
msgstr "2 («только администраторское присоединение»)"

#. type: Plain text
#: man-pages/man2/ptrace.2:2716
msgid ""
"Only processes with the B<CAP_SYS_PTRACE> capability in the user namespace "
"of the target process may perform B<PTRACE_MODE_ATTACH> operations or trace "
"children that employ B<PTRACE_TRACEME>."
msgstr ""
"Только процессы с мандатом B<CAP_SYS_PTRACE> в пользовательском пространстве "
"имён процесса назначения могут выполнять операции B<PTRACE_MODE_ATTACH> или "
"трассировать потомков, выполнивших B<PTRACE_TRACEME>."

#. type: TP
#: man-pages/man2/ptrace.2:2716
#, no-wrap
msgid "3 (\"no attach\")"
msgstr "3 («присоединение заблокировано»)"

#. type: Plain text
#: man-pages/man2/ptrace.2:2722
msgid ""
"No process may perform B<PTRACE_MODE_ATTACH> operations or trace children "
"that employ B<PTRACE_TRACEME>."
msgstr ""
"Никакие процессы не могут выполнять операции B<PTRACE_MODE_ATTACH> или "
"трассировать потомков, выполнивших B<PTRACE_TRACEME>."

#. type: Plain text
#: man-pages/man2/ptrace.2:2724
msgid "Once this value has been written to the file, it cannot be changed."
msgstr "После записи такого значения в файл, его нельзя изменить."

#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/ptrace.2:2739
msgid ""
"With respect to values 1 and 2, note that creating a new user namespace "
"effectively removes the protection offered by Yama.  This is because a "
"process in the parent user namespace whose effective UID matches the UID of "
"the creator of a child namespace has all capabilities (including "
"B<CAP_SYS_PTRACE>)  when performing operations within the child user "
"namespace (and further-removed descendants of that namespace).  "
"Consequently, when a process tries to use user namespaces to sandbox itself, "
"it inadvertently weakens the protections offered by the Yama LSM."
msgstr ""
"Относительно значений 1 и 2 заметим, что создание нового пользовательского "
"пространства имён фактически удаляет защиту, предлагаемую Yama. Это "
"происходит из-за того, что процесс в родительском пользовательском "
"пространстве имён, у которого эффективный UID совпадает с UID создателя "
"дочернего пространства имён, имеет все мандаты (включая B<CAP_SYS_PTRACE>) "
"при выполнении им операций внутри дочернего пользовательского пространства "
"имён (вплоть до удаления потомков этого пространства имён). В результате, "
"когда процесс сам пытается использовать пользовательские пространства имён "
"для песочницы, это непреднамеренно ослабляет защиту, предлагаемую Yama LSM."

#. type: Plain text
#: man-pages/man2/ptrace.2:2751
msgid ""
"At the system call level, the B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>, and "
"B<PTRACE_PEEKUSER> requests have a different API: they store the result at "
"the address specified by the I<data> parameter, and the return value is the "
"error flag.  The glibc wrapper function provides the API given in "
"DESCRIPTION above, with the result being returned via the function return "
"value."
msgstr ""
"На уровне системных вызовов запросы B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA> и "
"B<PTRACE_PEEKUSER> имеют разный программный интерфейс: они сохраняют "
"результат по адресу, указанному в параметре I<data>, а возвращаемое значение "
"является индикатором ошибки. Обёрточная функция glibc предоставляет "
"программный интерфейс, описанные ОПИСАНИЕ выше, а результат возвращается в "
"виде возвращаемого значения функции."

#. type: Plain text
#: man-pages/man2/ptrace.2:2762
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""
"На машинах с заголовочными файлами ядра 2.6 значение B<PTRACE_SETOPTIONS> "
"отличается от использованного в версии 2.4. Это приводит к тому, что "
"приложения, скомпилированные с такими заголовочными файлами, не работают при "
"использовании ядер 2.4. Этого можно избежать сделав B<PTRACE_SETOPTIONS> "
"равным B<PTRACE_OLDSETOPTIONS>, если данная константа определена."

#. type: Plain text
#: man-pages/man2/ptrace.2:2765
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""
"Уведомления group-stop посылаются трассировщику, но не реальному родителю. "
"Последнее подтверждение в версии 2.6.38.6."

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME . need to test/verify this scenario
#. type: Plain text
#: man-pages/man2/ptrace.2:2796
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls "
"B<execve>(2), the death of the thread group leader will I<never> be "
"reported.  If the execed thread is not traced by this tracer, the tracer "
"will never know that B<execve>(2)  happened.  One possible workaround is to "
"B<PTRACE_DETACH> the thread group leader instead of restarting it in this "
"case.  Last confirmed on 2.6.38.6."
msgstr ""
"Если трассируется лидер группы нитей и завершается с помощью вызова "
"B<_exit>(2), то происходит его останов B<PTRACE_EVENT_EXIT> (если это "
"запрашивалось), но последующее уведомление B<WIFEXITED> не будет доставлено "
"пока все остальные нити не завершат работу. Как объяснялось выше, если одна "
"из остальных нитей вызывает B<execve>(2), то о завершении лидера группы "
"I<никогда> не будет сообщено. Если исполняемая нить не трассируется этим "
"трассировщиком, то трассировщик никогда не узнает, что происходил "
"B<execve>(2). Одним из обходных вариантов решения  в этом случае является "
"выполнение B<PTRACE_DETACH> для лидера группы вместо перезапуска. Последнее "
"подтверждение в версии 2.6.38.6."

#. type: Plain text
#: man-pages/man2/ptrace.2:2806
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on Linux "
"3.13."
msgstr ""
"Сигнал B<SIGKILL> всё ещё может вызвать остановку B<PTRACE_EVENT_EXIT> перед "
"настоящем завершением процесса по сигналу. Это поведение может измениться в "
"будущем; B<SIGKILL> всегда подразумевает немедленное завершение задач даже "
"под ptrace. Последняя подтверждённая версия Linux — 3.13."

#. type: Plain text
#: man-pages/man2/ptrace.2:2824
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor.  The usual symptom of this bug is "
"that when you attach to a quiescent process with the command"
msgstr ""
"Некоторые системные вызовы возвращаются с B<EINTR>, если сигнал был послан "
"трассируемой нити, но доставка была подавлена трассировщиком (это очень "
"распространённая операция: она обычно выполняется отладчиками при каждом "
"присоединении, чтобы не вызывать ненужный B<SIGSTOP>). Начиная с Linux "
"3.2.9, подвержены следующие системные вызовы (вероятно, это не полный "
"список): B<epoll_wait>(2) и B<read>(2) из файлового дескриптора "
"B<inotify>(7). Обычный симптом этой ошибки: когда вы присоединяетесь к "
"неактивному процессу с помощью команды"

#. type: Plain text
#: man-pages/man2/ptrace.2:2828
#, no-wrap
msgid "strace -p E<lt>process-IDE<gt>\n"
msgstr "strace -p E<lt>process-IDE<gt>\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2833
msgid "then, instead of the usual and expected one-line output such as"
msgstr "то вместо обычного и ожидаемого вывода одной строки"

#. type: Plain text
#: man-pages/man2/ptrace.2:2837
#, no-wrap
msgid "restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"
msgstr "restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2845
#, no-wrap
msgid "select(6, [5], NULL, [5], NULL_\n"
msgstr "select(6, [5], NULL, [5], NULL_\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2850
msgid ""
"('_' denotes the cursor position), you observe more than one line.  For "
"example:"
msgstr "(«_» означает позицию курсора), вы видите несколько строк. Пример:"

#. type: Plain text
#: man-pages/man2/ptrace.2:2855
#, no-wrap
msgid ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"
msgstr ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"

#. type: Plain text
#: man-pages/man2/ptrace.2:2877
msgid ""
"What is not visible here is that the process was blocked in "
"B<epoll_wait>(2)  before B<strace>(1)  has attached to it.  Attaching caused "
"B<epoll_wait>(2)  to return to user space with the error B<EINTR>.  In this "
"particular case, the program reacted to B<EINTR> by checking the current "
"time, and then executing B<epoll_wait>(2)  again.  (Programs which do not "
"expect such \"stray\" B<EINTR> errors may behave in an unintended way upon "
"an B<strace>(1)  attach.)"
msgstr ""
"Здесь не видно, что процесс был заблокирован в B<epoll_wait>(2) до того, как "
"B<strace>(1) присоединился к нему. Присоединение заставляет B<epoll_wait>(2) "
"вернуться в пользовательское пространство с ошибкой B<EINTR>. В этом частном "
"случае, программа отвечает на B<EINTR> проверкой текущего времени и затем "
"вызывает B<epoll_wait>(2) снова (программы, которые не ожидают таких "
"«побочных» ошибок B<EINTR>, при присоединении B<strace>(1) могут повести "
"себя непредсказуемо)."

#. type: Plain text
#: man-pages/man2/ptrace.2:2883
msgid ""
"Contrary to the normal rules, the glibc wrapper for B<ptrace>()  can set "
"I<errno> to zero."
msgstr ""
"В отличие от обычных правил, обёрточная функция glibc для B<ptrace>() может "
"присваивать I<errno> значение нуля."

#. type: Plain text
#: man-pages/man2/ptrace.2:2899
msgid ""
"B<gdb>(1), B<ltrace>(1), B<strace>(1), B<clone>(2), B<execve>(2), "
"B<fork>(2), B<gettid>(2), B<prctl>(2), B<seccomp>(2), B<sigaction>(2), "
"B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), B<capabilities>(7), "
"B<signal>(7)"
msgstr ""
"B<gdb>(1), B<ltrace>(1), B<strace>(1), B<clone>(2), B<execve>(2), "
"B<fork>(2), B<gettid>(2), B<prctl>(2), B<seccomp>(2), B<sigaction>(2), "
"B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), B<capabilities>(7), "
"B<signal>(7)"

#. type: TH
#: man-pages/man5/protocols.5:29
#, no-wrap
msgid "PROTOCOLS"
msgstr "PROTOCOLS"

#. type: TH
#: man-pages/man5/protocols.5:29
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: man-pages/man5/protocols.5:32
msgid "protocols - protocols definition file"
msgstr "protocols - файл определения протоколов"

#. type: Plain text
#: man-pages/man5/protocols.5:40
msgid ""
"This file is a plain ASCII file, describing the various DARPA internet "
"protocols that are available from the TCP/IP subsystem.  It should be "
"consulted instead of using the numbers in the ARPA include files, or, even "
"worse, just guessing them.  These numbers will occur in the protocol field "
"of any IP header."
msgstr ""
"Данный файл является простым файлом в кодировке ASCII и описывает различные "
"протоколы DARPA internet, которые доступны через подсистему TCP/IP. Вместо "
"того, чтобы использовать номера протоколов из заголовочных (include) файлов "
"ARPA или, ещё хуже, строить догадки относительно номеров протоколов, нужно "
"использовать данный файл. Номера протоколов присутствуют в поле протокола в "
"любом IP-заголовке."

#.  .. by the DDN Network Information Center.
#. type: Plain text
#: man-pages/man5/protocols.5:46
msgid ""
"Keep this file untouched since changes would result in incorrect IP "
"packages.  Protocol numbers and names are specified by the IANA (Internet "
"Assigned Numbers Authority)."
msgstr ""
"Не изменяйте этот файл, так как изменения могут привести к некорректному "
"формированию IP-пакетов. Номера протоколов и их имена определяются Центром "
"Сетевой Информации (DDN Network Information Center)."

#. type: Plain text
#: man-pages/man5/protocols.5:48
msgid "Each line is of the following format:"
msgstr "Каждая строка файла имеет следующий формат:"

#. type: Plain text
#: man-pages/man5/protocols.5:51
msgid "I<protocol number aliases ...>"
msgstr "I<протокол номер псевдоним ...>"

#. type: Plain text
#: man-pages/man5/protocols.5:57
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"If a line contains a hash mark (#), the hash mark and the part of the line "
"following it are ignored."
msgstr ""
"Поля отделяются друг от друга пробелами или символами табуляции. Пустые "
"строки игнорируются. Если строка содержит символ решётки (#), то он сам и "
"часть строки, которая следует за этим символом, игнорируется."

#. type: Plain text
#: man-pages/man5/protocols.5:59
msgid "The field descriptions are:"
msgstr "Описание полей:"

#. type: TP
#: man-pages/man5/protocols.5:59
#, no-wrap
msgid "I<protocol>"
msgstr "I<протокол>"

#. type: Plain text
#: man-pages/man5/protocols.5:67
msgid ""
"the native name for the protocol.  For example I<ip>, I<tcp>, or I<udp>."
msgstr "Имя протокола. Например, I<ip>, I<tcp> или I<udp>."

#. type: TP
#: man-pages/man5/protocols.5:67
#, no-wrap
msgid "I<number>"
msgstr "I<номер>"

#. type: Plain text
#: man-pages/man5/protocols.5:71
msgid ""
"the official number for this protocol as it will appear within the IP header."
msgstr ""
"Официальный номер этого протокола, который будет помещаться в IP-заголовок."

#. type: TP
#: man-pages/man5/protocols.5:71
#, no-wrap
msgid "I<aliases>"
msgstr "I<псевдонимы>"

#. type: Plain text
#: man-pages/man5/protocols.5:74
msgid "optional aliases for the protocol."
msgstr "Необязательные псевдонимы этого протокола."

#. type: Plain text
#: man-pages/man5/protocols.5:77
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr ""
"Данный файл может распространяться по сети с помощью сетевых служб имён, "
"таких как Yellow Pages/NIS или BIND/Hesiod."

#. type: TP
#: man-pages/man5/protocols.5:78
#, no-wrap
msgid "I</etc/protocols>"
msgstr "I</etc/protocols>"

#. type: Plain text
#: man-pages/man5/protocols.5:81
msgid "The protocols definition file."
msgstr "Файл определения протоколов."

#. type: Plain text
#: man-pages/man5/protocols.5:83
msgid "B<getprotoent>(3)"
msgstr "B<getprotoent>(3)"

#. type: Plain text
#: man-pages/man5/protocols.5:85
msgid "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"
msgstr "E<.UR http://www.iana.org\\:/assignments\\:/protocol-numbers> E<.UE>"

#. type: TH
#: man-pages/man5/proc.5:55
#, no-wrap
msgid "PROC"
msgstr "PROC"

#. type: Plain text
#: man-pages/man5/proc.5:58
msgid "proc - process information pseudo-filesystem"
msgstr "proc - псевдо-файловая система с информацией о процессах"

#. type: Plain text
#: man-pages/man5/proc.5:67
msgid ""
"The B<proc> filesystem is a pseudo-filesystem which provides an interface to "
"kernel data structures.  It is commonly mounted at I</proc>.  Typically, it "
"is mounted automatically by the system, but it can also be mounted manually "
"using a command such as:"
msgstr ""
"Файловая система B<proc> — это псевдо-файловая система, которая "
"предоставляет интерфейс к структурам данных ядра. Обычно, она монтируется в "
"I</proc> и это выполняется системой автоматически, но также можно "
"монтировать её вручную с помощью команды:"

#. type: Plain text
#: man-pages/man5/proc.5:71
#, no-wrap
msgid "mount -t proc proc /proc\n"
msgstr "mount -t proc proc /proc\n"

#. type: Plain text
#: man-pages/man5/proc.5:79
msgid ""
"Most of the files in the B<proc> filesystem are read-only, but some files "
"are writable, allowing kernel variables to be changed."
msgstr ""
"Большинство файлов файловой системы B<proc> доступны только для чтения, но "
"есть и доступные на запись, через которые можно изменять переменные ядра."

#. type: SS
#: man-pages/man5/proc.5:79
#, no-wrap
msgid "Mount options"
msgstr "Параметры монтирования"

#. type: Plain text
#: man-pages/man5/proc.5:83
msgid "The B<proc> filesystem supports the following mount options:"
msgstr ""
"Файловая система B<proc> поддерживает следующие параметры монтирования:"

#. type: TP
#: man-pages/man5/proc.5:83
#, no-wrap
msgid "B<hidepid>=I<n> (since Linux 3.3)"
msgstr "B<hidepid>=I<n> (начиная с Linux 3.3)"

#.  commit 0499680a42141d86417a8fbaa8c8db806bea1201
#. type: Plain text
#: man-pages/man5/proc.5:92
msgid ""
"This option controls who can access the information in I</proc/[pid]> "
"directories.  The argument, I<n>, is one of the following values:"
msgstr ""
"Позволяет управлять доступом к информации в каталогах I</proc/[pid]>. В "
"аргументе I<n> может указываться одно из следующих значений:"

#. type: Plain text
#: man-pages/man5/proc.5:100
msgid ""
"Everybody may access all I</proc/[pid]> directories.  This is the "
"traditional behavior, and the default if this mount option is not specified."
msgstr ""
"Все имеют доступ ко всем каталогам I</proc/[pid]>. Обычное поведение, "
"используется по умолчанию, если этот параметр не указан."

#.  As an additional bonus, since
#.  .IR /proc/[pid]/cmdline
#.  is unaccessible for other users,
#.  poorly written programs passing sensitive information via
#.  program arguments are now protected against local eavesdroppers.
#. type: Plain text
#: man-pages/man5/proc.5:120
msgid ""
"Users may not access files and subdirectories inside any I</proc/[pid]> "
"directories but their own (the I</proc/[pid]> directories themselves remain "
"visible).  Sensitive files such as I</proc/[pid]/cmdline> and I</proc/[pid]/"
"status> are now protected against other users.  This makes it impossible to "
"learn whether any user is running a specific program (so long as the program "
"doesn't otherwise reveal itself by its behavior)."
msgstr ""
"Пользователи не имеют доступа к файлам и подкаталогам любого каталога I</"
"proc/[pid]> кроме их собственных (сами каталоги I</proc/[pid]> остаются "
"видимыми). Важные файлы I</proc/[pid]/cmdline> и I</proc/[pid]/status> "
"теперь защищены от других пользователей. Это делает невозможным увидеть "
"какие программы запустил пользователь (до тех пор, пока сама программа не "
"раскрывает себя своим поведением)."

#. type: Plain text
#: man-pages/man5/proc.5:141
msgid ""
"As for mode 1, but in addition the I</proc/[pid]> directories belonging to "
"other users become invisible.  This means that I</proc/[pid]> entries can no "
"longer be used to discover the PIDs on the system.  This doesn't hide the "
"fact that a process with a specific PID value exists (it can be learned by "
"other means, for example, by \"kill -0 $PID\"), but it hides a process's UID "
"and GID, which could otherwise be learned by employing B<stat>(2)  on a I</"
"proc/[pid]> directory.  This greatly complicates an attacker's task of "
"gathering information about running processes (e.g., discovering whether "
"some daemon is running with elevated privileges, whether another user is "
"running some sensitive program, whether other users are running any program "
"at all, and so on)."
msgstr ""
"Как режим 1, но дополнительно и каталоги I</proc/[pid]>, принадлежащие "
"другим пользователям, становятся невидимыми. Это означает, что элементы I</"
"proc/[pid]> теперь нельзя использовать для получения PID в системе. Это не "
"скрывает факт того, что процесса с определённым PID не существует (это можно "
"определить по другому, например, командой «kill -0 $PID»), но это скрывает "
"UID и GID процесса, которые можно было определять с помощью B<stat>(2) на "
"каталог I</proc/[pid]>. Это сильно усложняет атакующему задачу по сбору "
"информации о выполняющихся процессах (например, определение того, запущены "
"ли некоторые службы с повышенными правами, запустил ли другой пользователь "
"некоторую важную программу, выполняет ли вообще какую-либо программу другой "
"пользователь и так далее)."

#. type: TP
#: man-pages/man5/proc.5:142
#, no-wrap
msgid "B<gid>=I<gid> (since Linux 3.3)"
msgstr "B<gid>=I<gid> (начиная с Linux 3.3)"

#.  commit 0499680a42141d86417a8fbaa8c8db806bea1201
#. type: Plain text
#: man-pages/man5/proc.5:157
msgid ""
"Specifies the ID of a group whose members are authorized to learn process "
"information otherwise prohibited by B<hidepid> (i.e., users in this group "
"behave as though I</proc> was mounted with I<hidepid=0>).  This group should "
"be used instead of approaches such as putting nonroot users into the "
"B<sudoers>(5)  file."
msgstr ""
"Задаёт ID группы, члены которой могут просматривать информацию о процессах в "
"обход запрещению B<hidepid>, (т. е. пользователям в этой группе кажется, что "
"I</proc> смонтирована с I<hidepid=0>). Эту группу нужно использовать вместо "
"помещения непривилегированных пользователем в файл B<sudoers>(5) для тех же "
"целей."

#. type: SS
#: man-pages/man5/proc.5:157
#, no-wrap
msgid "Overview"
msgstr "Обзор"

#. type: Plain text
#: man-pages/man5/proc.5:161
msgid ""
"Underneath I</proc>, there are the following general groups of files and "
"subdirectories:"
msgstr ""
"В каталоге I</proc> существуют следующие общие группы файлов и подкаталогов:"

#. type: TP
#: man-pages/man5/proc.5:161
#, no-wrap
msgid "I</proc/[pid]> subdirectories"
msgstr "Подкаталоги I</proc/[pid]>"

#. type: Plain text
#: man-pages/man5/proc.5:165
msgid ""
"Each one of these subdirectories contains files and subdirectories exposing "
"information about the process with the corresponding process ID."
msgstr ""
"Каждый из этих подкаталогов включает файлы и подкаталоги, которые содержат "
"информацию о процессе с соответствующим ID процесса."

#. type: Plain text
#: man-pages/man5/proc.5:176
msgid ""
"Underneath each of the I</proc/[pid]> directories, a I<task> subdirectory "
"contains subdirectories of the form I<task/[tid]>, which contain "
"corresponding information about each of the threads in the process, where "
"I<tid> is the kernel thread ID of the thread."
msgstr ""
"В каждом каталоге I</proc/[pid]> есть подкаталог I<task>, включающий "
"подкаталоги вида I<task/[tid]>, которые содержат информацию о каждой нить "
"процесса, где I<tid> — ID нити ядра."

#. type: Plain text
#: man-pages/man5/proc.5:187
msgid ""
"The I</proc/[pid]> subdirectories are visible when iterating through I</"
"proc> with B<getdents>(2)  (and thus are visible when one uses B<ls>(1)  to "
"view the contents of I</proc>)."
msgstr ""
"Подкаталоги I</proc/[pid]> видимы при обходе I</proc> с помощью "
"B<getdents>(2) (и поэтому они видимы программам подобным B<ls>(1), которые "
"используются для просмотра содержимого I</proc>)."

#. type: TP
#: man-pages/man5/proc.5:187
#, no-wrap
msgid "I</proc/[tid]> subdirectories"
msgstr "Подкаталоги I</proc/[tid]>"

#. type: Plain text
#: man-pages/man5/proc.5:194
msgid ""
"Each one of these subdirectories contains files and subdirectories exposing "
"information about the thread with the corresponding thread ID.  The contents "
"of these directories are the same as the corresponding I</proc/[pid]/task/"
"[tid]> directories."
msgstr ""
"В каждом из этих подкаталогов содержатся файлы и подкаталоги с информацией о "
"нити с соответствующим ID нити. Содержимое этих каталогов такое же как у "
"соответствующих каталогов I</proc/[pid]/task/[tid]>."

#. type: Plain text
#: man-pages/man5/proc.5:209
msgid ""
"The I</proc/[tid]> subdirectories are I<not> visible when iterating through "
"I</proc> with B<getdents>(2)  (and thus are I<not> visible when one uses "
"B<ls>(1)  to view the contents of I</proc>)."
msgstr ""
"Подкаталоги I</proc/[tid]> I<не> видимы при обходе I</proc> с помощью "
"B<getdents>(2) (и поэтому они I<не> видимы программам подобным B<ls>(1), "
"которые используются для просмотра содержимого I</proc>)."

#. type: TP
#: man-pages/man5/proc.5:209 man-pages/man5/proc.5:4153
#, no-wrap
msgid "I</proc/self>"
msgstr "I</proc/self>"

#. type: Plain text
#: man-pages/man5/proc.5:215
msgid ""
"When a process accesses this magic symbolic link, it resolves to the "
"process's own I</proc/[pid]> directory."
msgstr ""
"Когда процесс обращается по этой символьной ссылке, она указывает на каталог "
"I</proc/[pid]> самого процесса."

#. type: TP
#: man-pages/man5/proc.5:215
#, no-wrap
msgid "I</proc/thread-self>"
msgstr "I</proc/thread-self>"

#. type: Plain text
#: man-pages/man5/proc.5:221
msgid ""
"When a thread accesses this magic symbolic link, it resolves to the "
"process's own I</proc/self/task/[tid]> directory."
msgstr ""
"Когда нить обращается по этой символьной ссылке, она указывает на каталог I</"
"proc/self/task/[tid]> самого процесса."

#. type: TP
#: man-pages/man5/proc.5:221
#, no-wrap
msgid "I</proc/[a-z]*>"
msgstr "I</proc/[a-z]*>"

#. type: Plain text
#: man-pages/man5/proc.5:226
msgid ""
"Various other files and subdirectories under I</proc> expose system-wide "
"information."
msgstr ""
"Другие файлы и подкаталоги в I</proc> предоставляют информацию о системе."

#. type: Plain text
#: man-pages/man5/proc.5:229
msgid "All of the above are described in more detail below."
msgstr "Всё перечисленное выше далее будет описано подробней."

#. type: SS
#: man-pages/man5/proc.5:229
#, no-wrap
msgid "Files and directories"
msgstr "Файлы и каталоги"

#. type: Plain text
#: man-pages/man5/proc.5:234
msgid ""
"The following list provides details of many of the files and directories "
"under the I</proc> hierarchy."
msgstr ""
"В следующем списке подробно описаны многие файлы и каталоги в иерархии I</"
"proc>."

#. type: TP
#: man-pages/man5/proc.5:234
#, no-wrap
msgid "I</proc/[pid]>"
msgstr "I</proc/[pid]>"

#. type: Plain text
#: man-pages/man5/proc.5:241
msgid ""
"There is a numerical subdirectory for each running process; the subdirectory "
"is named by the process ID.  Each I</proc/[pid]> subdirectory contains the "
"pseudo-files and directories described below."
msgstr ""
"Эти числовые подкаталоги соответствуют работающим процессам; имя подкаталога "
"соответствует идентификатору процесса. Каждый подкаталог I</proc/[pid]> "
"содержит псевдо-файлы и каталоги, описываемые далее."

#. type: Plain text
#: man-pages/man5/proc.5:249
msgid ""
"The files inside each I</proc/[pid]> directory are normally owned by the "
"effective user and effective group ID of the process.  However, as a "
"security measure, the ownership is made I<root:root> if the process's "
"\"dumpable\" attribute is set to a value other than 1."
msgstr ""
"Файлы в каждом каталоге I</proc/[pid]>, обычно, принадлежат действующему "
"идентификатору пользователя и группы процесса. Однако в целях безопасности, "
"владельцем устанавливается I<root:root>, если у процесса атрибут «dumpable» "
"установлен в значение, отличное от 1."

#.  commit 68eb94f16227336a5773b83ecfa8290f1d6b78ce
#. type: Plain text
#: man-pages/man5/proc.5:263
msgid ""
"Before Linux 4.11, I<root:root> meant the \"global\" root user ID and group "
"ID (i.e., UID 0 and GID 0 in the initial user namespace).  Since Linux 4.11, "
"if the process is in a noninitial user namespace that has a valid mapping "
"for user (group) ID 0 inside the namespace, then the user (group) ownership "
"of the files under I</proc/[pid]> is instead made the same as the root user "
"(group) ID of the namespace.  This means that inside a container, things "
"work as expected for the container \"root\" user."
msgstr ""
"До Linux 4.11, I<root:root> означал «глобальный» идентификатор "
"суперпользователя и группы (т. е., UID 0 и GID 0 в первоначальном "
"пользовательском пространстве имён). Начиная с Linux 4.11, если процесс "
"находится не первоначальном пользовательском пространстве имён, имеющий "
"корректное отображение идентификатор 0 пользователя (группы) внутри "
"пространства имён, то владельцем (группой) файлов в I</proc/[pid]> вместо "
"этого будет тот же идентификатор суперпользователя (группы) как у "
"пространства имён. Это означает, что внутри контейнера для контейнерного "
"«суперпользователя» всё будет работать как ожидается."

#. type: Plain text
#: man-pages/man5/proc.5:265
msgid ""
"The process's \"dumpable\" attribute may change for the following reasons:"
msgstr "Атрибут процесса «dumpable» может измениться по следующим причинам:"

#. type: Plain text
#: man-pages/man5/proc.5:271
msgid ""
"The attribute was explicitly set via the B<prctl>(2)  B<PR_SET_DUMPABLE> "
"operation."
msgstr ""
"Атрибут был явно изменён с помощью операции B<PR_SET_DUMPABLE> вызова "
"B<prctl>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:276
msgid ""
"The attribute was reset to the value in the file I</proc/sys/fs/"
"suid_dumpable> (described below), for the reasons described in B<prctl>(2)."
msgstr ""
"Атрибут был сброшен в значение из файла I</proc/sys/fs/suid_dumpable> "
"(описан далее) по причинам, описанным в B<prctl>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:281
msgid ""
"Resetting the \"dumpable\" attribute to 1 reverts the ownership of the I</"
"proc/[pid]/*> files to the process's effective UID and GID."
msgstr ""
"Сброс атрибута «dumpable» в 1 возвращает владение файлами I</proc/[pid]/*> "
"действующим UID и GID процесса."

#. type: TP
#: man-pages/man5/proc.5:281
#, no-wrap
msgid "I</proc/[pid]/attr>"
msgstr "I</proc/[pid]/attr>"

#.  https://lwn.net/Articles/28222/
#.  From:    Stephen Smalley <sds@epoch.ncsc.mil>
#.  To:	     LKML and others
#.  Subject: [RFC][PATCH] Process Attribute API for Security Modules
#.  Date:    08 Apr 2003 16:17:52 -0400
#. 	http://www.nsa.gov/research/_files/selinux/papers/module/x362.shtml
#. type: Plain text
#: man-pages/man5/proc.5:299
msgid ""
"The files in this directory provide an API for security modules.  The "
"contents of this directory are files that can be read and written in order "
"to set security-related attributes.  This directory was added to support "
"SELinux, but the intention was that the API be general enough to support "
"other security modules.  For the purpose of explanation, examples of how "
"SELinux uses these files are provided below."
msgstr ""
"Файлы в этом катале предоставляют программный интерфейс к модулям "
"безопасности. Содержимое этого каталога представляет собой файлы для чтения "
"и записи атрибутов безопасности. Этот каталог был добавлен для поддержки "
"SELinux, но данный программный интерфейс может использоваться для поддержки "
"других модулей безопасности. Как работать с этими файлами показано на "
"примере с SELinux ниже."

#. type: Plain text
#: man-pages/man5/proc.5:302
msgid ""
"This directory is present only if the kernel was configured with "
"B<CONFIG_SECURITY>."
msgstr ""
"Данный каталог доступен только, если ядро собрано с параметром "
"B<CONFIG_SECURITY>."

#. type: TP
#: man-pages/man5/proc.5:302
#, no-wrap
msgid "I</proc/[pid]/attr/current> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/attr/current> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:306
msgid ""
"The contents of this file represent the current security attributes of the "
"process."
msgstr "В этом файле представлены текущие атрибуты безопасности процесса."

#. type: Plain text
#: man-pages/man5/proc.5:320
msgid ""
"In SELinux, this file is used to get the security context of a process.  "
"Prior to Linux 2.6.11, this file could not be used to set the security "
"context (a write was always denied), since SELinux limited process security "
"transitions to B<execve>(2)  (see the description of I</proc/[pid]/attr/"
"exec>, below).  Since Linux 2.6.11, SELinux lifted this restriction and "
"began supporting \"set\" operations via writes to this node if authorized by "
"policy, although use of this operation is only suitable for applications "
"that are trusted to maintain any desired separation between the old and new "
"security contexts."
msgstr ""
"В SELinux этот файл используется для получения контекста безопасности "
"процесса. До Linux 2.6.11 этот файл нельзя было использовать для задания "
"контекста безопасности (запись была запрещена), так как ограничение "
"безопасности SELinux процесса изменяется при B<execve>(2) (смотрите описание "
"I</proc/[pid]/attr/exec> ниже). Начиная с Linux 2.6.11 в SELinux это "
"ограничение снято и началась поддержка операций «установки» посредством "
"записи в эту ноду, если это допускается политикой, хотя использование данной "
"операции подходит только для приложений, которым можно доверять управление "
"любым желаемым разделением между старым и новым контекстами безопасности."

#. type: Plain text
#: man-pages/man5/proc.5:331
msgid ""
"Prior to Linux 2.6.28, SELinux did not allow threads within a multi-threaded "
"process to set their security context via this node as it would yield an "
"inconsistency among the security contexts of the threads sharing the same "
"memory space.  Since Linux 2.6.28, SELinux lifted this restriction and began "
"supporting \"set\" operations for threads within a multithreaded process if "
"the new security context is bounded by the old security context, where the "
"bounded relation is defined in policy and guarantees that the new security "
"context has a subset of the permissions of the old security context."
msgstr ""
"До Linux 2.6.28 в SELinux нитям не разрешалось внутри многонитевого процесса "
"задавать свой контекст безопасности через эту ноду, так как это привело бы к "
"нестыковке контекстов безопасности нитей, использующи[ общее адресное "
"пространство. Начиная с Linux 2.6.28 в SELinux это ограничение снято и "
"началась поддержка поддержка операций «установки» для нитей внутри "
"многонитевого процесса, если новый контекст безопасности привязан к старому "
"контексту безопасности, где связь определена политикой и гарантируется, что "
"новый контекст безопасности является поднабором прав старого контекста "
"безопасности."

#. type: Plain text
#: man-pages/man5/proc.5:334
msgid ""
"Other security modules may choose to support \"set\" operations via writes "
"to this node."
msgstr ""
"Другие модули безопасности могут также добавить поддержку операций "
"«установки» через запись в эту ноду."

#. type: TP
#: man-pages/man5/proc.5:334
#, no-wrap
msgid "I</proc/[pid]/attr/exec> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/attr/exec> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:339
msgid ""
"This file represents the attributes to assign to the process upon a "
"subsequent B<execve>(2)."
msgstr ""
"В этом файле представлены атрибуты, назначаемые процессу при последующем "
"B<execve>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:355
msgid ""
"In SELinux, this is needed to support role/domain transitions, and "
"B<execve>(2)  is the preferred point to make such transitions because it "
"offers better control over the initialization of the process in the new "
"security label and the inheritance of state.  In SELinux, this attribute is "
"reset on B<execve>(2)  so that the new program reverts to the default "
"behavior for any B<execve>(2)  calls that it may make.  In SELinux, a "
"process can set only its own I</proc/[pid]/attr/exec> attribute."
msgstr ""
"В SELinux это необходимо для поддержки перехода роль/домен и B<execve>(2) "
"является предпочтительным местом выполнения таких изменений, так как "
"предлагает лучший контроль над инициализацией процесса с новой меткой "
"безопасности и наследуемым состоянием. В SELinux этот атрибут сбрасывается "
"при B<execve>(2) и новая программа получает поведение по умолчанию для всех "
"вызовов B<execve>(2), которые она может сделать. В SELinux процесс может "
"задать только свой атрибут в I</proc/[pid]/attr/exec>."

#. type: TP
#: man-pages/man5/proc.5:355
#, no-wrap
msgid "I</proc/[pid]/attr/fscreate> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/attr/fscreate> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:364
msgid ""
"This file represents the attributes to assign to files created by subsequent "
"calls to B<open>(2), B<mkdir>(2), B<symlink>(2), and B<mknod>(2)"
msgstr ""
"В этом файле представлены атрибуты для назначения файлам, создаваемым "
"последующими вызовами B<open>(2), B<mkdir>(2), B<symlink>(2) и B<mknod>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:379
msgid ""
"SELinux employs this file to support creation of a file (using the "
"aforementioned system calls)  in a secure state, so that there is no risk of "
"inappropriate access being obtained between the time of creation and the "
"time that attributes are set.  In SELinux, this attribute is reset on "
"B<execve>(2), so that the new program reverts to the default behavior for "
"any file creation calls it may make, but the attribute will persist across "
"multiple file creation calls within a program unless it is explicitly "
"reset.  In SELinux, a process can set only its own I</proc/[pid]/attr/"
"fscreate> attribute."
msgstr ""
"SELinux создаёт этот файл для поддержки создания файла (с помощью "
"вышеупомянутых системных вызовов) в безопасном состоянии, исключая, таким "
"образом, риск неправомерного доступа, который можно получить в промежутке "
"между созданием и назначением атрибутов. В SELinux этот атрибут сбрасывается "
"при B<execve>(2), поэтому новой программе возвращается поведение по "
"умолчанию при любых вызовах создания файла, но атрибут сохраняется между "
"несколькими вызовами создания файла внутри программы, пока она явно его не "
"сбросит. В SELinux процесс может установить только свой атрибут I</proc/"
"[pid]/attr/fscreate>."

#. type: TP
#: man-pages/man5/proc.5:379
#, no-wrap
msgid "I</proc/[pid]/attr/keycreate> (since Linux 2.6.18)"
msgstr "I</proc/[pid]/attr/keycreate> (начиная с Linux 2.6.18)"

#.  commit 4eb582cf1fbd7b9e5f466e3718a59c957e75254e
#.  commit b68101a1e8f0263dbc7b8375d2a7c57c6216fb76
#.  commit d410fa4ef99112386de5f218dd7df7b4fca910b4
#. type: Plain text
#: man-pages/man5/proc.5:395
msgid ""
"If a process writes a security context into this file, all subsequently "
"created keys (B<add_key>(2))  will be labeled with this context.  For "
"further information, see the kernel source file I<Documentation/security/"
"keys/core.rst> (or file I<Documentation/security/keys.txt> on Linux between "
"3.0 and 4.13, or I<Documentation/keys.txt> before Linux 3.0)."
msgstr ""
"Если процесс записывает контекст безопасности в этот файл, то все "
"создаваемые далее ключи (B<add_key>(2)) будут помечены этим контекстом. "
"Подробности смотрите в файле исходного кода ядра I<Documentation/security/"
"keys/core.rst> (или в файле I<Documentation/security/keys.txt> в версиях "
"Linux между 3.0 и 4.13, или в I<Documentation/keys.txt> до Linux 3.0)."

#. type: TP
#: man-pages/man5/proc.5:395
#, no-wrap
msgid "I</proc/[pid]/attr/prev> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/attr/prev> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:401
msgid ""
"This file contains the security context of the process before the last "
"B<execve>(2); that is, the previous value of I</proc/[pid]/attr/current>."
msgstr ""
"Этот файл содержит контекст безопасности процесса перед последним "
"B<execve>(2) — предыдущее значение I</proc/[pid]/attr/current>."

#. type: TP
#: man-pages/man5/proc.5:401
#, no-wrap
msgid "I</proc/[pid]/attr/socketcreate> (since Linux 2.6.18)"
msgstr "I</proc/[pid]/attr/socketcreate> (начиная с Linux 2.6.18)"

#.  commit 42c3e03ef6b298813557cdb997bd6db619cd65a2
#. type: Plain text
#: man-pages/man5/proc.5:406
msgid ""
"If a process writes a security context into this file, all subsequently "
"created sockets will be labeled with this context."
msgstr ""
"Если процесс записывает контекст безопасности в этот файл, то все "
"создаваемые далее сокеты будут помечены этим контекстом."

#. type: TP
#: man-pages/man5/proc.5:406
#, no-wrap
msgid "I</proc/[pid]/autogroup> (since Linux 2.6.38)"
msgstr "I</proc/[pid]/autogroup> (начиная с Linux 2.6.38)"

#. type: Plain text
#: man-pages/man5/proc.5:411 man-pages/man5/proc.5:5120
#: man-pages/man5/proc.5:5137 man-pages/man5/proc.5:5141
msgid "See B<sched>(7)."
msgstr "Смотрите B<sched>(7)."

#. type: TP
#: man-pages/man5/proc.5:411
#, no-wrap
msgid "I</proc/[pid]/auxv> (since 2.6.0)"
msgstr "I</proc/[pid]/auxv> (начиная с 2.6.0)"

#.  Precisely: Linux 2.6.0-test7
#. type: Plain text
#: man-pages/man5/proc.5:421
msgid ""
"This contains the contents of the ELF interpreter information passed to the "
"process at exec time.  The format is one I<unsigned long> ID plus one "
"I<unsigned long> value for each entry.  The last entry contains two zeros.  "
"See also B<getauxval>(3)."
msgstr ""
"Содержит информацию, полученную интерпретатором ELF и переданную процессу во "
"время выполнения. Формат \\(em это один идентификатор типа I<unsigned long> "
"ID и по одному значению типа I<unsigned long> для каждого из элементов. "
"Последний элемент содержит два нуля. Смотрите также B<getauxval>(3)."

#. type: Plain text
#: man-pages/man5/proc.5:426 man-pages/man5/proc.5:624
#: man-pages/man5/proc.5:1183 man-pages/man5/proc.5:1257
#: man-pages/man5/proc.5:1778 man-pages/man5/proc.5:2926
msgid ""
"Permission to access this file is governed by a ptrace access mode "
"B<PTRACE_MODE_READ_FSCREDS> check; see B<ptrace>(2)."
msgstr ""
"Право доступа к этому файлу определяется проверкой режима доступа ptrace "
"B<PTRACE_MODE_READ_FSCREDS>; смотрите B<ptrace>(2)."

#. type: TP
#: man-pages/man5/proc.5:426
#, no-wrap
msgid "I</proc/[pid]/cgroup> (since Linux 2.6.24)"
msgstr "I</proc/[pid]/cgroup> (начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:430 man-pages/man5/proc.5:3031
msgid "See B<cgroups>(7)."
msgstr "Смотрите B<cgroups>(7)."

#. type: TP
#: man-pages/man5/proc.5:430
#, no-wrap
msgid "I</proc/[pid]/clear_refs> (since Linux 2.6.22)"
msgstr "I</proc/[pid]/clear_refs> (начиная с Linux 2.6.22)"

#. type: Plain text
#: man-pages/man5/proc.5:440
msgid "This is a write-only file, writable only by owner of the process."
msgstr "Данный файл доступен только для записи и только владельцу процесса."

#. type: Plain text
#: man-pages/man5/proc.5:442
msgid "The following values may be written to the file:"
msgstr "В файл могут быть записаны следующие значения:"

#. type: TP
#: man-pages/man5/proc.5:443
#, no-wrap
msgid "1 (since Linux 2.6.22)"
msgstr "1 (начиная с Linux 2.6.22)"

#.  Internally: CLEAR_REFS_ALL
#. type: Plain text
#: man-pages/man5/proc.5:450
msgid ""
"Reset the PG_Referenced and ACCESSED/YOUNG bits for all the pages associated "
"with the process.  (Before kernel 2.6.32, writing any nonzero value to this "
"file had this effect.)"
msgstr ""
"Сбросить биты PG_Referenced и ACCESSED/YOUNG для всех страниц, связанных с "
"процессом (до ядра версии 2.6.32, такое действие происходило при записи "
"любого ненулевого значения в этот файл)."

#. type: TP
#: man-pages/man5/proc.5:450
#, no-wrap
msgid "2 (since Linux 2.6.32)"
msgstr "2 (начиная с Linux 2.6.32)"

#.  Internally: CLEAR_REFS_ANON
#. type: Plain text
#: man-pages/man5/proc.5:455
msgid ""
"Reset the PG_Referenced and ACCESSED/YOUNG bits for all anonymous pages "
"associated with the process."
msgstr ""
"Сбросить биты PG_Referenced и ACCESSED/YOUNG для всех анонимных страниц, "
"связанных с процессом."

#. type: TP
#: man-pages/man5/proc.5:455
#, no-wrap
msgid "3 (since Linux 2.6.32)"
msgstr "3 (начиная с Linux 2.6.32)"

#.  Internally: CLEAR_REFS_MAPPED
#. type: Plain text
#: man-pages/man5/proc.5:460
msgid ""
"Reset the PG_Referenced and ACCESSED/YOUNG bits for all file-mapped pages "
"associated with the process."
msgstr ""
"Сбросить биты PG_Referenced и ACCESSED/YOUNG для всех страниц отображения "
"файлов, связанных с процессом."

#. type: Plain text
#: man-pages/man5/proc.5:476
msgid ""
"Clearing the PG_Referenced and ACCESSED/YOUNG bits provides a method to "
"measure approximately how much memory a process is using.  One first "
"inspects the values in the \"Referenced\" fields for the VMAs shown in I</"
"proc/[pid]/smaps> to get an idea of the memory footprint of the process.  "
"One then clears the PG_Referenced and ACCESSED/YOUNG bits and, after some "
"measured time interval, once again inspects the values in the \"Referenced\" "
"fields to get an idea of the change in memory footprint of the process "
"during the measured interval.  If one is interested only in inspecting the "
"selected mapping types, then the value 2 or 3 can be used instead of 1."
msgstr ""
"Очистка бит PG_Referenced и ACCESSED/YOUNG предоставляет метод "
"приблизительного измерения количества памяти, используемой процессом. Во-"
"первых, нужно прочитать значения в полях «Referenced» для VMA, показанных в "
"I</proc/[pid]/smaps>, и получить объём используемой процессом памяти. Во-"
"вторых, очистить биты PG_Referenced и ACCESSED/YOUNG и после некоторого "
"известного временного интервала ещё раз прочитать значения в полях "
"«Referenced», чтобы получить размер используемой процессом памяти за "
"известный интервал. Если это интересно только для изучения выбранных типов "
"отображения, то вместо значение 1 можно использовать 2 или 3."

#. type: Plain text
#: man-pages/man5/proc.5:478
msgid "Further values can be written to affect different properties:"
msgstr "Дополнительные записываемые значения, влияющие на другие свойства:"

#. type: TP
#: man-pages/man5/proc.5:479
#, no-wrap
msgid "4 (since Linux 3.11)"
msgstr "4 (начиная с Linux 3.11)"

#.  Internally: CLEAR_REFS_SOFT_DIRTY
#. type: Plain text
#: man-pages/man5/proc.5:489
msgid ""
"Clear the soft-dirty bit for all the pages associated with the process.  "
"This is used (in conjunction with I</proc/[pid]/pagemap>)  by the check-"
"point restore system to discover which pages of a process have been dirtied "
"since the file I</proc/[pid]/clear_refs> was written to."
msgstr ""
"Очистить бит несильного загрязнения (soft-dirty) для всех страниц, связанных "
"с процессом. Это используется (вместе с I</proc/[pid]/pagemap>) системой "
"восстановления контрольной точки для обнаружения какие страницы процесса "
"были испачканы (dirtied) из-за записи в файл I</proc/[pid]/clear_refs>."

#. type: TP
#: man-pages/man5/proc.5:489
#, no-wrap
msgid "5 (since Linux 4.0)"
msgstr "5 (начиная с Linux 4.0)"

#.  Internally: CLEAR_REFS_MM_HIWATER_RSS
#. type: Plain text
#: man-pages/man5/proc.5:494
msgid ""
"Reset the peak resident set size (\"high water mark\") to the process's "
"current resident set size value."
msgstr ""
"Сбрасывает пик размера резидентной памяти (\"отметка высоты прилива\") в "
"текущее значение размера резидентной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:499
msgid ""
"Writing any value to I</proc/[pid]/clear_refs> other than those listed above "
"has no effect."
msgstr ""
"Запись любого значения в I</proc/[pid]/clear_refs>, отличного от "
"перечисленных выше, ничего не меняет."

#. type: Plain text
#: man-pages/man5/proc.5:505
msgid ""
"The I</proc/[pid]/clear_refs> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""
"Файл I</proc/[pid]/clear_refs> существует только, если включён параметр "
"настройки ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:505
#, no-wrap
msgid "I</proc/[pid]/cmdline>"
msgstr "I</proc/[pid]/cmdline>"

#.  In 2.3.26, this also used to be true if the process was swapped out.
#. type: Plain text
#: man-pages/man5/proc.5:515
msgid ""
"This read-only file holds the complete command line for the process, unless "
"the process is a zombie.  In the latter case, there is nothing in this file: "
"that is, a read on this file will return 0 characters.  The command-line "
"arguments appear in this file as a set of strings separated by null bytes "
"(\\(aq\\e0\\(aq), with a further null byte after the last string."
msgstr ""
"Данный файл, доступный только для чтения, содержит полную командную строку "
"процесса, если процесс не является зомби. В последнем случае этот файл пуст, "
"поэтому чтение из него вернёт 0 символов. Аргументы командной строки в этом "
"файле представлены в виде набора строк, разделённых байтами null (\\(aq"
"\\e0\\(aq) и байтом null после последней строки."

#. type: TP
#: man-pages/man5/proc.5:515
#, no-wrap
msgid "I</proc/[pid]/comm> (since Linux 2.6.33)"
msgstr "I</proc/[pid]/comm> (начиная с Linux 2.6.33)"

#.  commit 4614a696bd1c3a9af3a08f0e5874830a85b889d4
#. type: Plain text
#: man-pages/man5/proc.5:537
msgid ""
"This file exposes the process's I<comm> value\\(emthat is, the command name "
"associated with the process.  Different threads in the same process may have "
"different I<comm> values, accessible via I</proc/[pid]/task/[tid]/comm>.  A "
"thread may modify its I<comm> value, or that of any of other thread in the "
"same thread group (see the discussion of B<CLONE_THREAD> in B<clone>(2)), by "
"writing to the file I</proc/self/task/[tid]/comm>.  Strings longer than "
"B<TASK_COMM_LEN> (16) characters are silently truncated."
msgstr ""
"В этом файле содержится значение I<comm> процесса — то есть имя команды, "
"связанное с процессом. Разные нити одного процесса могут иметь разные "
"значение I<comm>, они доступны через I</proc/[pid]/task/[tid]/comm>. "
"Значение I<comm> можно изменить из самой нити или из другой нити в той же "
"группе нитей (смотрите описание B<CLONE_THREAD> в B<clone>(2)) записью в "
"файл I</proc/self/task/[tid]/comm>. Строки длиннее B<TASK_COMM_LEN> (16) "
"символов просто обрезаются."

#. type: Plain text
#: man-pages/man5/proc.5:546
msgid ""
"This file provides a superset of the B<prctl>(2)  B<PR_SET_NAME> and "
"B<PR_GET_NAME> operations, and is employed by B<pthread_setname_np>(3)  when "
"used to rename threads other than the caller."
msgstr ""
"Этот файл содержит поднабор операций B<prctl>(2) B<PR_SET_NAME> и "
"B<PR_GET_NAME>, и возвращается B<pthread_setname_np>(3) при использовании "
"для переименования нитями, отличающимся от вызывающего."

#. type: TP
#: man-pages/man5/proc.5:546
#, no-wrap
msgid "I</proc/[pid]/coredump_filter> (since Linux 2.6.23)"
msgstr "I</proc/[pid]/coredump_filter> (начиная с Linux 2.6.23)"

#. type: Plain text
#: man-pages/man5/proc.5:550 man-pages/man5/proc.5:4793
#: man-pages/man5/proc.5:4797 man-pages/man5/proc.5:4801
msgid "See B<core>(5)."
msgstr "Смотрите B<core>(5)."

#. type: TP
#: man-pages/man5/proc.5:550
#, no-wrap
msgid "I</proc/[pid]/cpuset> (since Linux 2.6.12)"
msgstr "I</proc/[pid]/cpuset> (начиная с Linux 2.6.12)"

#.  and/proc/[pid]/task/[tid]/cpuset
#. type: Plain text
#: man-pages/man5/proc.5:555
msgid "See B<cpuset>(7)."
msgstr "Смотрите B<cpuset>(7)."

#. type: TP
#: man-pages/man5/proc.5:555
#, no-wrap
msgid "I</proc/[pid]/cwd>"
msgstr "I</proc/[pid]/cwd>"

#. type: Plain text
#: man-pages/man5/proc.5:560
msgid ""
"This is a symbolic link to the current working directory of the process.  To "
"find out the current working directory of process 20, for instance, you can "
"do this:"
msgstr ""
"Это символьная ссылка на текущий рабочий каталог процесса. Например, чтобы "
"узнать текущий каталог процесса 20, вы должны проделать следующее:"

#. type: Plain text
#: man-pages/man5/proc.5:564
#, no-wrap
msgid "$B< cd /proc/20/cwd; /bin/pwd>\n"
msgstr "$B< cd /proc/20/cwd; /bin/pwd>\n"

#. type: Plain text
#: man-pages/man5/proc.5:575
msgid ""
"Note that the I<pwd> command is often a shell built-in, and might not work "
"properly.  In B<bash>(1), you may use I<pwd\\ -P>."
msgstr ""
"Отметим, что команда I<pwd> часто является встроенной в оболочку, и поэтому "
"может работать не корректно. В B<bash>(1) вы можете воспользоваться I<pwd\\ -"
"P>."

#.  The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:581
msgid ""
"In a multithreaded process, the contents of this symbolic link are not "
"available if the main thread has already terminated (typically by calling "
"B<pthread_exit>(3))."
msgstr ""
"В многонитевых процессах, содержимое этой символьной ссылки недоступно, если "
"головная нить уже завершила работу (обычно с помощью вызова "
"B<pthread_exit>(3))."

#.  FIXME Describe /proc/[pid]/projid_map
#.        Added in 3.7
#.        commit f76d207a66c3a53defea67e7d36c3eb1b7d6d61d
#. type: Plain text
#: man-pages/man5/proc.5:588 man-pages/man5/proc.5:648
#: man-pages/man5/proc.5:1855
msgid ""
"Permission to dereference or read (B<readlink>(2))  this symbolic link is "
"governed by a ptrace access mode B<PTRACE_MODE_READ_FSCREDS> check; see "
"B<ptrace>(2)."
msgstr ""
"Право разыменовывать или читать (B<readlink>(2)) эту символическую ссылку "
"определяется проверкой режима доступа ptrace B<PTRACE_MODE_READ_FSCREDS>; "
"смотрите B<ptrace>(2)."

#. type: TP
#: man-pages/man5/proc.5:588
#, no-wrap
msgid "I</proc/[pid]/environ>"
msgstr "I</proc/[pid]/environ>"

#. type: Plain text
#: man-pages/man5/proc.5:596
msgid ""
"This file contains the initial environment that was set when the currently "
"executing program was started via B<execve>(2).  The entries are separated "
"by null bytes (\\(aq\\e0\\(aq), and there may be a null byte at the end.  "
"Thus, to print out the environment of process 1, you would do:"
msgstr ""
"Этот файл содержит начальное окружение, которое было настроено при запуске с "
"помощью B<execve>(2) выполняемой в настоящий момент программы. Элементы "
"разделяются байтами null (\\(aq\\e0\\(aq), а также может быть байт null в "
"конце. То есть, чтобы вывести окружение процесса 1, вы можете сделать "
"следующее:"

#. type: Plain text
#: man-pages/man5/proc.5:600
#, no-wrap
msgid "$B< cat /proc/1/environ | tr \\(aq\\e000\\(aq \\(aq\\en\\(aq>\n"
msgstr "$B< cat /proc/1/environ | tr \\(aq\\e000\\(aq \\(aq\\en\\(aq>\n"

#. type: Plain text
#: man-pages/man5/proc.5:614
msgid ""
"If, after an B<execve>(2), the process modifies its environment (e.g., by "
"calling functions such as B<putenv>(3)  or modifying the B<environ>(7)  "
"variable directly), this file will I<not> reflect those changes."
msgstr ""
"Если после B<execve>(2) процесс изменил своё окружение (например, вызвав "
"функцию B<putenv>(3) или напрямую изменив переменную B<environ>(7)), то этот "
"файл I<не> показываются такие изменения."

#. type: Plain text
#: man-pages/man5/proc.5:619
msgid ""
"Furthermore, a process may change the memory location that this file refers "
"via B<prctl>(2)  operations such as B<PR_SET_MM_ENV_START>."
msgstr ""
"Кроме этого, процесс может изменить расположение памяти с помощью операции "
"B<prctl>(2) B<PR_SET_MM_ENV_START>, на которое ссылается этот файл."

#. type: TP
#: man-pages/man5/proc.5:624
#, no-wrap
msgid "I</proc/[pid]/exe>"
msgstr "I</proc/[pid]/exe>"

#.  The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:641
msgid ""
"Under Linux 2.2 and later, this file is a symbolic link containing the "
"actual pathname of the executed command.  This symbolic link can be "
"dereferenced normally; attempting to open it will open the executable.  You "
"can even type I</proc/[pid]/exe> to run another copy of the same executable "
"that is being run by process [pid].  If the pathname has been unlinked, the "
"symbolic link will contain the string \\(aq(deleted)\\(aq appended to the "
"original pathname.  In a multithreaded process, the contents of this "
"symbolic link are not available if the main thread has already terminated "
"(typically by calling B<pthread_exit>(3))."
msgstr ""
"В Linux 2.2 и новее этот файл является символьной ссылкой, содержащей "
"актуальный путь выполняемой команды. Данная символьная ссылка может "
"обрабатываться обычным образом; попытка её открытия приведёт к открытию "
"исполняемого файла. Вы даже можете ввести I</proc/[pid]/exe> для запуска "
"другой копии того же  исполняемого файла, который выполняется процессом "
"[pid]. Если путь был удалён, то символьная ссылка будет содержать строку "
"\\(aq(deleted)\\(aq, добавленную к оригинальному пути. В многонитевом "
"процессе содержимое этой символьной ссылки недоступно, если основная нить "
"уже завершилась (обычно вызовом B<pthread_exit>(3))."

#. type: Plain text
#: man-pages/man5/proc.5:656
msgid ""
"Under Linux 2.0 and earlier, I</proc/[pid]/exe> is a pointer to the binary "
"which was executed, and appears as a symbolic link.  A B<readlink>(2)  call "
"on this file under Linux 2.0 returns a string in the format:"
msgstr ""
"В ядрах Linux 2.0 и более ранних, I</proc/[pid]/exe> указывает на двоичный "
"файл, который был выполнен, и работает как символьная ссылка. Вызов "
"B<readlink>(2) над этим файлом в Linux 2.0 вернёт строку следующего вида:"

#. type: Plain text
#: man-pages/man5/proc.5:658
#, no-wrap
msgid "    [device]:inode\n"
msgstr "    [device]:inode\n"

#. type: Plain text
#: man-pages/man5/proc.5:661
msgid ""
"For example, [0301]:1502 would be inode 1502 on device major 03 (IDE, MFM, "
"etc. drives) minor 01 (first partition on the first drive)."
msgstr ""
"Например, [0301]:1502 указывает на inode 1502 на устройстве со старшим "
"номером устройства 03 (IDE, MFM, и т.п. диски), младшим номером 01 (первый "
"раздел на первом диске)."

#. type: Plain text
#: man-pages/man5/proc.5:666
msgid "B<find>(1)  with the I<-inum> option can be used to locate the file."
msgstr ""
"Для поиска файла можно воспользоваться B<find>(1) с параметром I<-inum>."

#. type: TP
#: man-pages/man5/proc.5:666
#, no-wrap
msgid "I</proc/[pid]/fd/>"
msgstr "I</proc/[pid]/fd/>"

#. type: Plain text
#: man-pages/man5/proc.5:672
msgid ""
"This is a subdirectory containing one entry for each file which the process "
"has open, named by its file descriptor, and which is a symbolic link to the "
"actual file.  Thus, 0 is standard input, 1 standard output, 2 standard "
"error, and so on."
msgstr ""
"Этот подкаталог содержит одну запись для каждого файла, открытого процессом, "
"именем является номер его файлового дескриптора, и которая является "
"символьной ссылкой на настоящий файл. Так, 0 — это стандартный поток ввода, "
"1 — стандартный поток вывода, 2 — стандартный поток ошибок и т.п."

#. type: Plain text
#: man-pages/man5/proc.5:679
msgid ""
"For file descriptors for pipes and sockets, the entries will be symbolic "
"links whose content is the file type with the inode.  A B<readlink>(2)  call "
"on this file returns a string in the format:"
msgstr ""
"Для файловых дескрипторов каналов и сокетов записи будут символьными "
"ссылками, содержимое которых — тип файла и inode. Вызов B<readlink>(2) для "
"такого файла вернёт строку в формате:"

#. type: Plain text
#: man-pages/man5/proc.5:681
#, no-wrap
msgid "    type:[inode]\n"
msgstr "    тип:[inode]\n"

#. type: Plain text
#: man-pages/man5/proc.5:688
msgid ""
"For example, I<socket:[2248868]> will be a socket and its inode is 2248868.  "
"For sockets, that inode can be used to find more information in one of the "
"files under I</proc/net/>."
msgstr ""
"Например, I<socket:[2248868]> — для сокета с inode 2248868. Для сокетов эту "
"inode можно использовать для поиска дополнительной информации в одном из "
"файлов в I</proc/net/>."

#. type: Plain text
#: man-pages/man5/proc.5:701
msgid ""
"For file descriptors that have no corresponding inode (e.g., file "
"descriptors produced by B<bpf>(2), B<epoll_create>(2), B<eventfd>(2), "
"B<inotify_init>(2), B<perf_event_open>(2), B<signalfd>(2), "
"B<timerfd_create>(2), and B<userfaultfd>(2)), the entry will be a symbolic "
"link with contents of the form"
msgstr ""
"Для файловых дескриптор без соответствующей иноды (например, файловые "
"дескрипторы, создаваемые B<bpf>(2), B<epoll_create>(2), B<eventfd>(2), "
"B<inotify_init>(2), B<perf_event_open>(2), B<signalfd>(2), "
"B<timerfd_create>(2) и B<userfaultfd>(2)), запись будет символьной ссылкой с "
"содержимым в виде"

#. type: Plain text
#: man-pages/man5/proc.5:703
#, no-wrap
msgid "    anon_inode:E<lt>file-typeE<gt>\n"
msgstr "    anon_inode:E<lt>тип-файлаE<gt>\n"

#. type: Plain text
#: man-pages/man5/proc.5:707
msgid ""
"In many cases (but not all), the I<file-type> is surrounded by square "
"brackets."
msgstr ""
"Во многих случаях (но не всех) I<тип-файла> заключается в квадратные скобки."

#. type: Plain text
#: man-pages/man5/proc.5:711
msgid ""
"For example, an epoll file descriptor will have a symbolic link whose "
"content is the string I<anon_inode:[eventpoll]>."
msgstr ""
"Например, файловый дескриптор epoll будет иметь символьную ссылку с "
"содержимым в виде строки I<anon_inode:[eventpoll]>."

#. The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:717
msgid ""
"In a multithreaded process, the contents of this directory are not available "
"if the main thread has already terminated (typically by calling "
"B<pthread_exit>(3))."
msgstr ""
"В многонитевых процессах, содержимое этого каталога недоступно, если главная "
"нить уже завершила работу (обычно при помощи вызова B<pthread_exit>(3))."

#. type: Plain text
#: man-pages/man5/proc.5:731
msgid ""
"Programs that take a filename as a command-line argument, but don't take "
"input from standard input if no argument is supplied, and programs that "
"write to a file named as a command-line argument, but don't send their "
"output to standard output if no argument is supplied, can nevertheless be "
"made to use standard input or standard output by using I</proc/[pid]/fd> "
"files as command-line arguments.  For example, assuming that I<-i> is the "
"flag designating an input file and I<-o> is the flag designating an output "
"file:"
msgstr ""
"Программы, принимающие в аргументе командной строки имя файлы, не читают "
"данные из стандартного ввода, если аргумент не указан, а программы, которые "
"выполняют запись в файл с именем, указанным в аргументе командной строки, не "
"пишут данные в стандартный вывод, если аргумент не указан, но, тем не менее, "
"могут использовать стандартный ввод или вывод через файлы I</proc/[pid]/fd>, "
"указанные в аргументе командной строки. Например, подразумевая что I<-i> "
"является флагом, обозначающим входной файл, и I<-o> является флагом, "
"обозначающим выходной файл, вы можете указать:"

#. type: Plain text
#: man-pages/man5/proc.5:735
#, no-wrap
msgid "$B< foobar -i /proc/self/fd/0 -o /proc/self/fd/1 ...>\n"
msgstr "$B< foobar -i /proc/self/fd/0 -o /proc/self/fd/1 …>\n"

#.  The following is not true in my tests (MTK):
#.  Note that this will not work for
#.  programs that seek on their files, as the files in the fd directory
#.  are not seekable.
#. type: Plain text
#: man-pages/man5/proc.5:743
msgid "and you have a working filter."
msgstr "и вы получите работающий фильтр."

#. type: Plain text
#: man-pages/man5/proc.5:753
msgid ""
"I</proc/self/fd/N> is approximately the same as I</dev/fd/N> in some UNIX "
"and UNIX-like systems.  Most Linux MAKEDEV scripts symbolically link I</dev/"
"fd> to I</proc/self/fd>, in fact."
msgstr ""
"I</proc/self/fd/N> \\(em это примерно то же, что и I</dev/fd/N> на некоторых "
"системах UNIX и подобных им. Фактически, большинство сценариев MAKEDEV в "
"Linux создают символьную ссылку с именем I</dev/fd> на файл I</proc/self/fd>."

#. type: Plain text
#: man-pages/man5/proc.5:767
msgid ""
"Most systems provide symbolic links I</dev/stdin>, I</dev/stdout>, and I</"
"dev/stderr>, which respectively link to the files I<0>, I<1>, and I<2> in I</"
"proc/self/fd>.  Thus the example command above could be written as:"
msgstr ""
"Большинство систем предоставляют символьные ссылки I</dev/stdin>, I</dev/"
"stdout> и I</dev/stderr>, которые соответствуют ссылкам на файлы I<0>, I<1> "
"и I<2> в I</proc/self/fd>. Так, пример указанной выше команды может быть "
"переписан в следующем виде:"

#. type: Plain text
#: man-pages/man5/proc.5:771
#, no-wrap
msgid "$B< foobar -i /dev/stdin -o /dev/stdout ...>\n"
msgstr "$B< foobar -i /dev/stdin -o /dev/stdout ...>\n"

#. type: Plain text
#: man-pages/man5/proc.5:780
msgid ""
"Permission to dereference or read (B<readlink>(2))  the symbolic links in "
"this directory is governed by a ptrace access mode "
"B<PTRACE_MODE_READ_FSCREDS> check; see B<ptrace>(2)."
msgstr ""
"Право разыменовывать или читать (B<readlink>(2)) символические ссылки в этом "
"каталоге определяется проверкой режима доступа ptrace "
"B<PTRACE_MODE_READ_FSCREDS>; смотрите B<ptrace>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:788
msgid ""
"Note that for file descriptors referring to inodes (pipes and sockets, see "
"above), those inodes still have permission bits and ownership information "
"distinct from those of the I</proc/[pid]/fd> entry, and that the owner may "
"differ from the user and group IDs of the process.  An unprivileged process "
"may lack permissions to open them, as in this example:"
msgstr ""
"Заметим, что для файловых дескрипторов, указывающих на иноды (каналы и "
"сокеты, смотрите выше), эти иноды по-прежнему имеют биты прав и информация о "
"владельце отличается от имеющейся у I</proc/[pid]/fd> и этот владелец может "
"отличаться от идентификатора пользователя и группы процесса. "
"Непривилегированный процесс может не иметь прав на их открытие, как в этом "
"примере:"

#. type: Plain text
#: man-pages/man5/proc.5:795
#, no-wrap
msgid ""
"$B< echo test | sudo -u nobody cat>\n"
"test\n"
"$B< echo test | sudo -u nobody cat /proc/self/fd/0>\n"
"cat: /proc/self/fd/0: Permission denied\n"
msgstr ""
"$B< echo test | sudo -u nobody cat>\n"
"test\n"
"$B< echo test | sudo -u nobody cat /proc/self/fd/0>\n"
"cat: /proc/self/fd/0: Permission denied\n"

#. type: Plain text
#: man-pages/man5/proc.5:805
msgid ""
"File descriptor 0 refers to the pipe created by the shell and owned by that "
"shell's user, which is not I<nobody>, so B<cat> does not have permission to "
"create a new file descriptor to read from that inode, even though it can "
"still read from its existing file descriptor 0."
msgstr ""
"Файловый дескриптор 0 указывает на канал, созданный оболочкой и "
"принадлежащий владельцу оболочки, не I<nobody>, поэтому у программы B<cat> "
"нет прав на создание нового файлового дескриптора для чтения из этой иноды, "
"хотя при этом она всё-таки может читать из существующего файлового "
"дескриптора 0."

#. type: TP
#: man-pages/man5/proc.5:805
#, no-wrap
msgid "I</proc/[pid]/fdinfo/> (since Linux 2.6.22)"
msgstr "I</proc/[pid]/fdinfo/> (начиная с Linux 2.6.22)"

#. type: Plain text
#: man-pages/man5/proc.5:814
msgid ""
"This is a subdirectory containing one entry for each file which the process "
"has open, named by its file descriptor.  The files in this directory are "
"readable only by the owner of the process.  The contents of each file can be "
"read to obtain information about the corresponding file descriptor.  The "
"content depends on the type of file referred to by the corresponding file "
"descriptor."
msgstr ""
"Этот подкаталог содержит один элемент на каждый файл, который открыл "
"процесс, именем файла будет номер его файлового дескриптора. Файлы в этом "
"каталоге доступны на чтение только владельцу процесса. Содержимое каждого "
"файла может быть прочитано для получения информации о соответствующем "
"файловом дескрипторе. Содержимое зависит от типа файла, на который ссылается "
"соответствующий файловый дескриптор."

#. type: Plain text
#: man-pages/man5/proc.5:816
msgid "For regular files and directories, we see something like:"
msgstr "Для обычных файлов и каталогов содержимым будет, что-то типа:"

#. type: Plain text
#: man-pages/man5/proc.5:823
#, no-wrap
msgid ""
"$B< cat /proc/12015/fdinfo/4>\n"
"pos:    1000\n"
"flags:  01002002\n"
"mnt_id: 21\n"
msgstr ""
"$B< cat /proc/12015/fdinfo/4>\n"
"pos:    1000\n"
"flags:  01002002\n"
"mnt_id: 21\n"

#. type: Plain text
#: man-pages/man5/proc.5:827 man-pages/man5/proc.5:1116
#: man-pages/man5/proc.5:2468 man-pages/man5/proc.5:3962
msgid "The fields are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man5/proc.5:828
#, no-wrap
msgid "I<pos>"
msgstr "I<pos>"

#. type: Plain text
#: man-pages/man5/proc.5:831
msgid "This is a decimal number showing the file offset."
msgstr "Это десятичное число отражает смещение файла."

#. type: Plain text
#: man-pages/man5/proc.5:840
msgid ""
"This is an octal number that displays the file access mode and file status "
"flags (see B<open>(2)).  If the close-on-exec file descriptor flag is set, "
"then I<flags> will also include the value B<O_CLOEXEC>."
msgstr ""
"Это восьмеричное число отражает режим доступа к файлу и флаги состояния "
"файла (смотрите B<open>(2)). Если установлен флаг файлового дескриптора "
"close-on-exec, то I<flags> также содержат значение B<O_CLOEXEC>."

#.  commit 1117f72ea0217ba0cc19f05adbbd8b9a397f5ab7
#. type: Plain text
#: man-pages/man5/proc.5:847
msgid ""
"Before Linux 3.1, this field incorrectly displayed the setting of "
"B<O_CLOEXEC> at the time the file was opened, rather than the current "
"setting of the close-on-exec flag."
msgstr ""
"До Linux 3.1 в этом поле некорректно показывалось значение B<O_CLOEXEC> "
"верное на момент открытия файла, а не текущее значение флага close-on-exec."

#. type: TP
#: man-pages/man5/proc.5:847
#, no-wrap
msgid "I<mnt_id>"
msgstr "I<mnt_id>"

#.  commit 49d063cb353265c3af701bab215ac438ca7df36d
#. type: Plain text
#: man-pages/man5/proc.5:855
msgid ""
"This field, present since Linux 3.15, is the ID of the mount point "
"containing this file.  See the description of I</proc/[pid]/mountinfo>."
msgstr ""
"Это поле, появившееся в Linux 3.15, содержит ID точки монтирования, в "
"которой содержится данный файл. Смотрите описание I</proc/[pid]/mountinfo>."

#.  commit cbac5542d48127b546a23d816380a7926eee1c25
#. type: Plain text
#: man-pages/man5/proc.5:862
msgid ""
"For eventfd file descriptors (see B<eventfd>(2)), we see (since Linux 3.8)  "
"the following fields:"
msgstr ""
"Для файловых дескрипторов eventfd (смотрите B<eventfd>(2)) мы увидим "
"(начиная с Linux 3.8) следующие поля:"

#. type: Plain text
#: man-pages/man5/proc.5:869
#, no-wrap
msgid ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t10\n"
"eventfd-count:               40\n"
msgstr ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t10\n"
"eventfd-count:               40\n"

#. type: Plain text
#: man-pages/man5/proc.5:874
msgid ""
"I<eventfd-count> is the current value of the eventfd counter, in hexadecimal."
msgstr ""
"В I<eventfd-count> содержится текущее значение счётчика eventfd counter (в "
"виде шестнадцатеричного числа)."

#.  commit 138d22b58696c506799f8de759804083ff9effae
#. type: Plain text
#: man-pages/man5/proc.5:880
msgid ""
"For epoll file descriptors (see B<epoll>(7)), we see (since Linux 3.8)  the "
"following fields:"
msgstr ""
"Для файловых дескрипторов epoll (смотрите B<epoll>(7)) мы увидим (начиная с "
"Linux 3.8) следующие поля:"

#. type: Plain text
#: man-pages/man5/proc.5:888
#, no-wrap
msgid ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t10\n"
"tfd:        9 events:       19 data: 74253d2500000009\n"
"tfd:        7 events:       19 data: 74253d2500000007\n"
msgstr ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t10\n"
"tfd:        9 events:       19 data: 74253d2500000009\n"
"tfd:        7 events:       19 data: 74253d2500000007\n"

#. type: Plain text
#: man-pages/man5/proc.5:907
msgid ""
"Each of the lines beginning I<tfd> describes one of the file descriptors "
"being monitored via the epoll file descriptor (see B<epoll_ctl>(2)  for some "
"details).  The I<tfd> field is the number of the file descriptor.  The "
"I<events> field is a hexadecimal mask of the events being monitored for this "
"file descriptor.  The I<data> field is the data value associated with this "
"file descriptor."
msgstr ""
"Каждая строка, начинающаяся с I<tfd>, описывает один из файловых "
"дескрипторов, который отслеживается через файловый дескриптор epoll "
"(подробности смотрите в B<epoll_ctl>(2)). Поле I<tfd> содержит номер "
"файлового дескриптора. Поле I<events> представляет собой шестнадцатеричную "
"маску событий, которые отслеживаются для этого файлового дескриптора. Поле "
"I<data> содержит данные, связанные с этим файловым дескриптором."

#.  commit 138d22b58696c506799f8de759804083ff9effae
#. type: Plain text
#: man-pages/man5/proc.5:913
msgid ""
"For signalfd file descriptors (see B<signalfd>(2)), we see (since Linux "
"3.8)  the following fields:"
msgstr ""
"Для файловых дескрипторов signalfd (смотрите B<signalfd>(2)) мы увидим "
"(начиная с Linux 3.8) следующие поля:"

#. type: Plain text
#: man-pages/man5/proc.5:920
#, no-wrap
msgid ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t10\n"
"sigmask:\t0000000000000006\n"
msgstr ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t10\n"
"sigmask:\t0000000000000006\n"

#. type: Plain text
#: man-pages/man5/proc.5:932
msgid ""
"I<sigmask> is the hexadecimal mask of signals that are accepted via this "
"signalfd file descriptor.  (In this example, bits 2 and 3 are set, "
"corresponding to the signals B<SIGINT> and B<SIGQUIT>; see B<signal>(7).)"
msgstr ""
"В I<sigmask> содержится шестнадцатеричная маска сигналов, которые "
"принимаются через этот файловый дескриптор signalfd (в этом примере биты 2 и "
"3 установлены, что соответствует сигналам B<SIGINT> и B<SIGQUIT>; смотрите "
"B<signal>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:937
msgid ""
"For inotify file descriptors (see B<inotify>(7)), we see (since Linux 3.8)  "
"the following fields:"
msgstr ""
"Для файловых дескрипторов inotify (смотрите B<inotify>(7)) мы увидим "
"(начиная с Linux 3.8) следующие поля:"

#. type: Plain text
#: man-pages/man5/proc.5:945
#, no-wrap
msgid ""
"pos:\t0\n"
"flags:\t00\n"
"mnt_id:\t11\n"
"inotify wd:2 ino:7ef82a sdev:800001 mask:800afff ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:2af87e00220ffd73\n"
"inotify wd:1 ino:192627 sdev:800001 mask:800afff ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:27261900802dfd73\n"
msgstr ""
"pos:\t0\n"
"flags:\t00\n"
"mnt_id:\t11\n"
"inotify wd:2 ino:7ef82a sdev:800001 mask:800afff ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:2af87e00220ffd73\n"
"inotify wd:1 ino:192627 sdev:800001 mask:800afff ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:27261900802dfd73\n"

#. type: Plain text
#: man-pages/man5/proc.5:951
msgid ""
"Each of the lines beginning with \"inotify\" displays information about one "
"file or directory that is being monitored.  The fields in this line are as "
"follows:"
msgstr ""
"Каждая из строк, начинающаяся с «inotify», содержит информацию об одном "
"отслеживаемом файле или каталоге. Поля в этой строке:"

#. type: TP
#: man-pages/man5/proc.5:952
#, no-wrap
msgid "I<wd>"
msgstr "I<wd>"

#. type: Plain text
#: man-pages/man5/proc.5:955
msgid "A watch descriptor number (in decimal)."
msgstr "Отслеживаемый номер файлового дескриптора (десятичное число)."

#. type: Plain text
#: man-pages/man5/proc.5:958
msgid "The inode number of the target file (in hexadecimal)."
msgstr "Номер иноды целевого файла (шестнадцатеричное число)."

#. type: TP
#: man-pages/man5/proc.5:958
#, no-wrap
msgid "I<sdev>"
msgstr "I<sdev>"

#. type: Plain text
#: man-pages/man5/proc.5:961
msgid "The ID of the device where the target file resides (in hexadecimal)."
msgstr ""
"Идентификатор устройства, содержащего целевой файл (шестнадцатеричное число)."

#. type: TP
#: man-pages/man5/proc.5:961 man-pages/man5/proc.5:1016
#, no-wrap
msgid "I<mask>"
msgstr "I<mask>"

#. type: Plain text
#: man-pages/man5/proc.5:964
msgid ""
"The mask of events being monitored for the target file (in hexadecimal)."
msgstr ""
"Маска отслеживаемых событий для целевого файла (шестнадцатеричное число)."

#. type: Plain text
#: man-pages/man5/proc.5:972
msgid ""
"If the kernel was built with exportfs support, the path to the target file "
"is exposed as a file handle, via three hexadecimal fields: I<fhandle-bytes>, "
"I<fhandle-type>, and I<f_handle>."
msgstr ""
"Если ядро собрано с поддержкой exportfs, то путь целевого файла "
"представляется в виде описателя (handle) файла, выраженного тремя "
"шестнадцатеричными полями: I<fhandle-bytes>, I<fhandle-type> и I<f_handle>."

#. type: Plain text
#: man-pages/man5/proc.5:977
msgid ""
"For fanotify file descriptors (see B<fanotify>(7)), we see (since Linux "
"3.8)  the following fields:"
msgstr ""
"Для файловых дескрипторов fanotify (смотрите B<fanotify>(7)) мы увидим "
"(начиная с Linux 3.8) следующие поля:"

#. type: Plain text
#: man-pages/man5/proc.5:985
#, no-wrap
msgid ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t11\n"
"fanotify flags:0 event-flags:88002\n"
"fanotify ino:19264f sdev:800001 mflags:0 mask:1 ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:4f261900a82dfd73\n"
msgstr ""
"pos:\t0\n"
"flags:\t02\n"
"mnt_id:\t11\n"
"fanotify flags:0 event-flags:88002\n"
"fanotify ino:19264f sdev:800001 mflags:0 mask:1 ignored_mask:0 fhandle-bytes:8 fhandle-type:1 f_handle:4f261900a82dfd73\n"

#. type: Plain text
#: man-pages/man5/proc.5:991
msgid ""
"The fourth line displays information defined when the fanotify group was "
"created via B<fanotify_init>(2):"
msgstr ""
"В четвёртой строке содержится информация, определяющая когда была создана с "
"помощью B<fanotify_init>(2) группа fanotify:"

#. type: Plain text
#: man-pages/man5/proc.5:999
msgid ""
"The I<flags> argument given to B<fanotify_init>(2)  (expressed in "
"hexadecimal)."
msgstr ""
"Аргумент I<flags>, переданный B<fanotify_init>(2) (шестнадцатеричное число)."

#. type: TP
#: man-pages/man5/proc.5:999
#, no-wrap
msgid "I<event-flags>"
msgstr "I<event-flags>"

#. type: Plain text
#: man-pages/man5/proc.5:1006
msgid ""
"The I<event_f_flags> argument given to B<fanotify_init>(2)  (expressed in "
"hexadecimal)."
msgstr ""
"Аргумент I<event_f_flags>, переданный B<fanotify_init>(2) (шестнадцатеричное "
"число)."

#. type: Plain text
#: man-pages/man5/proc.5:1011
msgid ""
"Each additional line shown in the file contains information about one of the "
"marks in the fanotify group.  Most of these fields are as for inotify, "
"except:"
msgstr ""
"В каждой дополнительной строке файла содержится информация об одной из меток "
"в группе fanotify. Большинство полей аналогичны с inotify, за исключением:"

#. type: TP
#: man-pages/man5/proc.5:1012
#, no-wrap
msgid "I<mflags>"
msgstr "I<mflags>"

#. type: Plain text
#: man-pages/man5/proc.5:1016
msgid "The flags associated with the mark (expressed in hexadecimal)."
msgstr "Флаги, связанные с меткой (шестнадцатеричное число)."

#. type: Plain text
#: man-pages/man5/proc.5:1020
msgid "The events mask for this mark (expressed in hexadecimal)."
msgstr "Маска событий, связанная с этой меткой (шестнадцатеричное число)."

#. type: TP
#: man-pages/man5/proc.5:1020
#, no-wrap
msgid "I<ignored_mask>"
msgstr "I<ignored_mask>"

#. type: Plain text
#: man-pages/man5/proc.5:1024
msgid ""
"The mask of events that are ignored for this mark (expressed in hexadecimal)."
msgstr ""
"Маска событий, которые игнорируются для этой метки (шестнадцатеричное число)."

#. type: Plain text
#: man-pages/man5/proc.5:1028
msgid "For details on these fields, see B<fanotify_mark>(2)."
msgstr "Подробную информацию об этих полях смотрите в B<fanotify_mark>(2)."

#.  commit af9c4957cf212ad9cf0bee34c95cb11de5426e85
#. type: Plain text
#: man-pages/man5/proc.5:1034
msgid ""
"For timerfd file descriptors (see B<timerfd>(2)), we see (since Linux 3.17)  "
"the following fields:"
msgstr ""
"Для файловых дескрипторов timerfd (смотрите B<timerfd>(2)) мы увидим "
"(начиная с Linux 3.17) следующие поля:"

#. type: Plain text
#: man-pages/man5/proc.5:1045
#, no-wrap
msgid ""
"pos:    0\n"
"flags:  02004002\n"
"mnt_id: 13\n"
"clockid: 0\n"
"ticks: 0\n"
"settime flags: 03\n"
"it_value: (7695568592, 640020877)\n"
"it_interval: (0, 0)\n"
msgstr ""
"pos:    0\n"
"flags:  02004002\n"
"mnt_id: 13\n"
"clockid: 0\n"
"ticks: 0\n"
"settime flags: 03\n"
"it_value: (7695568592, 640020877)\n"
"it_interval: (0, 0)\n"

#. type: TP
#: man-pages/man5/proc.5:1048
#, no-wrap
msgid "I<clockid>"
msgstr "I<clockid>"

#. type: Plain text
#: man-pages/man5/proc.5:1057
msgid ""
"This is the numeric value of the clock ID (corresponding to one of the "
"B<CLOCK_*> constants defined via I<E<lt>time.hE<gt>>)  that is used to mark "
"the progress of the timer (in this example, 0 is B<CLOCK_REALTIME>)."
msgstr ""
"Числовое значение идентификатора часов (соответствует одной из констант "
"B<CLOCK_*>, определённых в I<E<lt>time.hE<gt>>), используемое для отметки "
"действия таймера (в этом примере 0 — B<CLOCK_REALTIME>)."

#. type: TP
#: man-pages/man5/proc.5:1057
#, no-wrap
msgid "I<ticks>"
msgstr "I<ticks>"

#. type: Plain text
#: man-pages/man5/proc.5:1063
msgid ""
"This is the number of timer expirations that have occurred, (i.e., the value "
"that B<read>(2)  on it would return)."
msgstr ""
"Количество раз прошедших окончаний таймера (т. е., значение, которое вернул "
"бы для него вызов B<read>(2))."

#. type: TP
#: man-pages/man5/proc.5:1063
#, no-wrap
msgid "I<settime flags>"
msgstr "I<settime flags>"

#. type: Plain text
#: man-pages/man5/proc.5:1073
msgid ""
"This field lists the flags with which the timerfd was last armed (see "
"B<timerfd_settime>(2)), in octal (in this example, both B<TFD_TIMER_ABSTIME> "
"and B<TFD_TIMER_CANCEL_ON_SET> are set)."
msgstr ""
"В этом поле перечислены флаги в восьмеричном виде (в этом примере "
"установлены B<TFD_TIMER_ABSTIME>и B<TFD_TIMER_CANCEL_ON_SET>), с которым был "
"запущен timerfd последний раз (смотрите B<timerfd_settime>(2))."

#. type: TP
#: man-pages/man5/proc.5:1073
#, no-wrap
msgid "I<it_value>"
msgstr "I<it_value>"

#. type: Plain text
#: man-pages/man5/proc.5:1081
msgid ""
"This field contains the amount of time until the timer will next expire, "
"expressed in seconds and nanoseconds.  This is always expressed as a "
"relative value, regardless of whether the timer was created using the "
"B<TFD_TIMER_ABSTIME> flag."
msgstr ""
"В этом поле содержит количество времени до следующего истечения таймера, "
"выраженное в секундах и наносекундах. Это всегда относительное значение, "
"независимо от флага создания таймера B<TFD_TIMER_ABSTIME>."

#. type: TP
#: man-pages/man5/proc.5:1081
#, no-wrap
msgid "I<it_interval>"
msgstr "I<it_interval>"

#. type: Plain text
#: man-pages/man5/proc.5:1092
msgid ""
"This field contains the interval of the timer, in seconds and nanoseconds.  "
"(The I<it_value> and I<it_interval> fields contain the values that "
"B<timerfd_gettime>(2)  on this file descriptor would return.)"
msgstr ""
"В этом поле содержится интервал таймера, выраженный в секундах и "
"наносекундах (поля I<it_value> и I<it_interval> содержат значения, которые "
"вернул бы вызов B<timerfd_gettime>(2) для этого файлового дескриптора)."

#. type: TP
#: man-pages/man5/proc.5:1093
#, no-wrap
msgid "I</proc/[pid]/gid_map> (since Linux 3.5)"
msgstr "I</proc/[pid]/gid_map> (начиная с Linux 3.5)"

#. type: TP
#: man-pages/man5/proc.5:1097
#, no-wrap
msgid "I</proc/[pid]/io> (since kernel 2.6.20)"
msgstr "I</proc/[pid]/io> (начиная с версии ядра 2.6.20)"

#.  commit 7c3ab7381e79dfc7db14a67c6f4f3285664e1ec2
#. type: Plain text
#: man-pages/man5/proc.5:1101
msgid "This file contains I/O statistics for the process, for example:"
msgstr "Этот файл содержит статистику ввода-вывода процесса, например:"

#. type: Plain text
#: man-pages/man5/proc.5:1112
#, no-wrap
msgid ""
"#B< cat /proc/3828/io>\n"
"rchar: 323934931\n"
"wchar: 323929600\n"
"syscr: 632687\n"
"syscw: 632675\n"
"read_bytes: 0\n"
"write_bytes: 323932160\n"
"cancelled_write_bytes: 0\n"
msgstr ""
"#B< cat /proc/3828/io>\n"
"rchar: 323934931\n"
"wchar: 323929600\n"
"syscr: 632687\n"
"syscw: 632675\n"
"read_bytes: 0\n"
"write_bytes: 323932160\n"
"cancelled_write_bytes: 0\n"

#. type: TP
#: man-pages/man5/proc.5:1117
#, no-wrap
msgid "I<rchar>: characters read"
msgstr "I<rchar>: прочитано символов"

#. type: Plain text
#: man-pages/man5/proc.5:1127
msgid ""
"The number of bytes which this task has caused to be read from storage.  "
"This is simply the sum of bytes which this process passed to B<read>(2)  and "
"similar system calls.  It includes things such as terminal I/O and is "
"unaffected by whether or not actual physical disk I/O was required (the read "
"might have been satisfied from pagecache)."
msgstr ""
"Количество байт, которое было прочитано данной задачей из хранилища. Это "
"просто сумма байт, которую процесс передал в B<read>(2) и подобные системные "
"вызовы. Здесь учитываются такие вещи как ввод-вывод с терминалом и не "
"учитывается, происходил ли ввод-вывод действительно с физического диска (для "
"чтения могло оказаться достаточно страничного кэша)."

#. type: TP
#: man-pages/man5/proc.5:1127
#, no-wrap
msgid "I<wchar>: characters written"
msgstr "I<wchar>: записано символов"

#. type: Plain text
#: man-pages/man5/proc.5:1133
msgid ""
"The number of bytes which this task has caused, or shall cause to be written "
"to disk.  Similar caveats apply here as with I<rchar>."
msgstr ""
"Количество байт, которые были или должны быть записаны задачей на диск. "
"Применимы те же оговорки, что и для I<rchar>."

#. type: TP
#: man-pages/man5/proc.5:1133
#, no-wrap
msgid "I<syscr>: read syscalls"
msgstr "I<syscr>: количество системных вызовов чтения"

#. type: Plain text
#: man-pages/man5/proc.5:1140
msgid ""
"Attempt to count the number of read I/O operations\\(emthat is, system calls "
"such as B<read>(2)  and B<pread>(2)."
msgstr ""
"Попытка подсчитать количество операций чтения — то есть системных вызовов "
"B<read>(2) и B<pread>(2)."

#. type: TP
#: man-pages/man5/proc.5:1140
#, no-wrap
msgid "I<syscw>: write syscalls"
msgstr "I<syscw>: количество системных вызовов записи"

#. type: Plain text
#: man-pages/man5/proc.5:1147
msgid ""
"Attempt to count the number of write I/O operations\\(emthat is, system "
"calls such as B<write>(2)  and B<pwrite>(2)."
msgstr ""
"Попытка подсчитать количество операций записи — то есть системных вызовов "
"B<write>(2) и B<pwrite>(2)."

#. type: TP
#: man-pages/man5/proc.5:1147
#, no-wrap
msgid "I<read_bytes>: bytes read"
msgstr "I<read_bytes>: прочитано байт"

#. type: Plain text
#: man-pages/man5/proc.5:1152
msgid ""
"Attempt to count the number of bytes which this process really did cause to "
"be fetched from the storage layer.  This is accurate for block-backed "
"filesystems."
msgstr ""
"Попытка подсчитать количество байт, которое процесс действительно получил с "
"уровня хранилища. Является точным для файловых систем блочного хранения."

#. type: TP
#: man-pages/man5/proc.5:1152
#, no-wrap
msgid "I<write_bytes>: bytes written"
msgstr "I<write_bytes>: записано байт"

#. type: Plain text
#: man-pages/man5/proc.5:1156
msgid ""
"Attempt to count the number of bytes which this process caused to be sent to "
"the storage layer."
msgstr ""
"Попытка подсчитать количество байт, которое процесс действительно послал на "
"уровень хранилища."

#. type: TP
#: man-pages/man5/proc.5:1156
#, no-wrap
msgid "I<cancelled_write_bytes>:"
msgstr "I<cancelled_write_bytes>:"

#. type: Plain text
#: man-pages/man5/proc.5:1170
msgid ""
"The big inaccuracy here is truncate.  If a process writes 1MB to a file and "
"then deletes the file, it will in fact perform no writeout.  But it will "
"have been accounted as having caused 1MB of write.  In other words: this "
"field represents the number of bytes which this process caused to not "
"happen, by truncating pagecache.  A task can cause \"negative\" I/O too.  If "
"this task truncates some dirty pagecache, some I/O which another task has "
"been accounted for (in its I<write_bytes>)  will not be happening."
msgstr ""
"Есть большая погрешность при усечении. Если процесс записывает 1МБ в файл, а "
"затем удаляет файл, то, фактически, он ничего не запишет. Но это будет "
"подсчитано как запись 1МБ. Другими словами: это поле представляет количество "
"байт, для которых процесс отменил запись посредством усечения страничного "
"кэша. Задача также может вызвать «отрицательный» ввод-вывод. Если задача "
"усекает часть устаревшего страничного кэша, то некоторый ввод-вывод, который "
"был учтён в другой задаче (в её I<write_bytes>), не произойдёт."

#. type: Plain text
#: man-pages/man5/proc.5:1178
msgid ""
"I<Note>: In the current implementation, things are a bit racy on 32-bit "
"systems: if process A reads process B's I</proc/[pid]/io> while process B is "
"updating one of these 64-bit counters, process A could see an intermediate "
"result."
msgstr ""
"I<Замечание>: В текущей реализации существует большая состязательность в 32-"
"битных системах: если процесс A читает I</proc/[pid]/io> процесса B в момент "
"обновления 64-битных счётчиков процесса B, то процесс A может увидеть "
"промежуточный результат."

#. type: TP
#: man-pages/man5/proc.5:1183
#, no-wrap
msgid "I</proc/[pid]/limits> (since Linux 2.6.24)"
msgstr "I</proc/[pid]/limits> (начиная с Linux 2.6.24)"

#.  commit 3036e7b490bf7878c6dae952eec5fb87b1106589
#.  FIXME Describe /proc/[pid]/loginuid
#.        Added in 2.6.11; updating requires CAP_AUDIT_CONTROL
#.        CONFIG_AUDITSYSCALL
#. type: Plain text
#: man-pages/man5/proc.5:1196
msgid ""
"This file displays the soft limit, hard limit, and units of measurement for "
"each of the process's resource limits (see B<getrlimit>(2)).  Up to and "
"including Linux 2.6.35, this file is protected to allow reading only by the "
"real UID of the process.  Since Linux 2.6.36, this file is readable by all "
"users on the system."
msgstr ""
"В этом файле содержатся мягкие и жёсткие ограничения (limit), а также "
"измерения по каждого ограничению ресурсов процесса (см. B<getrlimit>(2)). "
"Файл доступен на чтение только реальному UID процесса. Начиная с Linux "
"2.6.36, может читаться всеми пользователями системы."

#. type: TP
#: man-pages/man5/proc.5:1196
#, no-wrap
msgid "I</proc/[pid]/map_files/> (since kernel 3.3)"
msgstr "I</proc/[pid]/map_files/> (начиная с версии ядра 3.3)"

#.  commit 640708a2cff7f81e246243b0073c66e6ece7e53e
#. type: Plain text
#: man-pages/man5/proc.5:1206
msgid ""
"This subdirectory contains entries corresponding to memory-mapped files (see "
"B<mmap>(2)).  Entries are named by memory region start and end address pair "
"(expressed as hexadecimal numbers), and are symbolic links to the mapped "
"files themselves.  Here is an example, with the output wrapped and "
"reformatted to fit on an 80-column display:"
msgstr ""
"В этом подкаталоге содержатся записи, соответствующие файлам, отображённым в "
"память (смотрит B<mmap>(2)). Имена записей соответствуют начальному и "
"конечному адресу области памяти (в виде шестнадцатеричных чисел), и "
"символьными ссылками на само отображённые файлы. Пример (подогнан под 80-"
"колоночный терминал):"

#. type: Plain text
#: man-pages/man5/proc.5:1213
#, no-wrap
msgid ""
"#B< ls -l /proc/self/map_files/>\n"
"lr--------. 1 root root 64 Apr 16 21:31\n"
"            3252e00000-3252e20000 -E<gt> /usr/lib64/ld-2.15.so\n"
"\\&...\n"
msgstr ""
"#B< ls -l /proc/self/map_files/>\n"
"lr--------. 1 root root 64 Apr 16 21:31\n"
"            3252e00000-3252e20000 -E<gt> /usr/lib64/ld-2.15.so\n"
"\\&...\n"

#. type: Plain text
#: man-pages/man5/proc.5:1227
msgid ""
"Although these entries are present for memory regions that were mapped with "
"the B<MAP_FILE> flag, the way anonymous shared memory (regions created with "
"the B<MAP_ANON | MAP_SHARED> flags)  is implemented in Linux means that such "
"regions also appear on this directory.  Here is an example where the target "
"file is the deleted I</dev/zero> one:"
msgstr ""
"Хотя эти записи предназначены для областей памяти, отображённых с флагом "
"B<MAP_FILE>, из реализации в Linux области анонимной общей памяти (области, "
"созданные с флагами B<MAP_ANON | MAP_SHARED>) также будут присутствовать в "
"этом каталоге. Пример, в котором файл назначения — удалённый I</dev/zero>:"

#. type: Plain text
#: man-pages/man5/proc.5:1232
#, no-wrap
msgid ""
"lrw-------. 1 root root 64 Apr 16 21:33\n"
"            7fc075d2f000-7fc075e6f000 -E<gt> /dev/zero (deleted)\n"
msgstr ""
"lrw-------. 1 root root 64 Apr 16 21:33\n"
"            7fc075d2f000-7fc075e6f000 -E<gt> /dev/zero (deleted)\n"

#.  FIXME
#.  This may change. See the mail thread
#.  "[RFC][PATCH v2] procfs: Always expose /proc/<pid>/map_files/ and make it readable"
#.  from Jan 2015
#. type: Plain text
#: man-pages/man5/proc.5:1245
msgid ""
"This directory appears only if the B<CONFIG_CHECKPOINT_RESTORE> kernel "
"configuration option is enabled.  Privilege (B<CAP_SYS_ADMIN>)  is required "
"to view the contents of this directory."
msgstr ""
"Данный каталог присутствуют только, если ядро собрано с включённым "
"параметром B<CONFIG_CHECKPOINT_RESTORE>. Для просмотра содержимого этого "
"каталога требуется мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man5/proc.5:1245
#, no-wrap
msgid "I</proc/[pid]/maps>"
msgstr "I</proc/[pid]/maps>"

#. type: Plain text
#: man-pages/man5/proc.5:1252
msgid ""
"A file containing the currently mapped memory regions and their access "
"permissions.  See B<mmap>(2)  for some further information about memory "
"mappings."
msgstr ""
"Файл, содержащий адреса областей памяти, которые используются программой в "
"данный момент и права доступа к ним. Информацию об отображении памяти "
"смотрите в B<mmap>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:1259
msgid "The format of the file is:"
msgstr "Формат файла:"

#. type: Plain text
#: man-pages/man5/proc.5:1282
#, no-wrap
msgid ""
"I<address           perms offset  dev   inode       pathname>\n"
"00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon\n"
"00651000-00652000 r--p 00051000 08:02 173521      /usr/bin/dbus-daemon\n"
"00652000-00655000 rw-p 00052000 08:02 173521      /usr/bin/dbus-daemon\n"
"00e03000-00e24000 rw-p 00000000 00:00 0           [heap]\n"
"00e24000-011f7000 rw-p 00000000 00:00 0           [heap]\n"
"\\&...\n"
"35b1800000-35b1820000 r-xp 00000000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a1f000-35b1a20000 r--p 0001f000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a20000-35b1a21000 rw-p 00020000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a21000-35b1a22000 rw-p 00000000 00:00 0\n"
"35b1c00000-35b1dac000 r-xp 00000000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1dac000-35b1fac000 ---p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1fac000-35b1fb0000 r--p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1fb0000-35b1fb2000 rw-p 001b0000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"\\&...\n"
"f2c6ff8c000-7f2c7078c000 rw-p 00000000 00:00 0    [stack:986]\n"
"\\&...\n"
"7fffb2c0d000-7fffb2c2e000 rw-p 00000000 00:00 0   [stack]\n"
"7fffb2d48000-7fffb2d49000 r-xp 00000000 00:00 0   [vdso]\n"
msgstr ""
"I<address           perms offset  dev   inode       pathname>\n"
"00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon\n"
"00651000-00652000 r--p 00051000 08:02 173521      /usr/bin/dbus-daemon\n"
"00652000-00655000 rw-p 00052000 08:02 173521      /usr/bin/dbus-daemon\n"
"00e03000-00e24000 rw-p 00000000 00:00 0           [heap]\n"
"00e24000-011f7000 rw-p 00000000 00:00 0           [heap]\n"
"\\&...\n"
"35b1800000-35b1820000 r-xp 00000000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a1f000-35b1a20000 r--p 0001f000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a20000-35b1a21000 rw-p 00020000 08:02 135522  /usr/lib64/ld-2.15.so\n"
"35b1a21000-35b1a22000 rw-p 00000000 00:00 0\n"
"35b1c00000-35b1dac000 r-xp 00000000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1dac000-35b1fac000 ---p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1fac000-35b1fb0000 r--p 001ac000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"35b1fb0000-35b1fb2000 rw-p 001b0000 08:02 135870  /usr/lib64/libc-2.15.so\n"
"\\&...\n"
"f2c6ff8c000-7f2c7078c000 rw-p 00000000 00:00 0    [stack:986]\n"
"\\&...\n"
"7fffb2c0d000-7fffb2c2e000 rw-p 00000000 00:00 0   [stack]\n"
"7fffb2d48000-7fffb2d49000 r-xp 00000000 00:00 0   [vdso]\n"

#. type: Plain text
#: man-pages/man5/proc.5:1291
msgid ""
"The I<address> field is the address space in the process that the mapping "
"occupies.  The I<perms> field is a set of permissions:"
msgstr ""
"В поле I<address> показано адресное пространство процесса, в которое "
"выполнено отображение, а в поле I<perms> — права доступа:"

#. type: Plain text
#: man-pages/man5/proc.5:1299
#, no-wrap
msgid ""
"r = read\n"
"w = write\n"
"x = execute\n"
"s = shared\n"
"p = private (copy on write)\n"
msgstr ""
"r = можно читать\n"
"w = можно писать\n"
"x = можно выполнять\n"
"s = можно использовать несколькими процессами совместно\n"
"p = личное (копирование при записи)\n"

#. type: Plain text
#: man-pages/man5/proc.5:1312
msgid ""
"The I<offset> field is the offset into the file/whatever; I<dev> is the "
"device (major:minor); I<inode> is the inode on that device.  0 indicates "
"that no inode is associated with the memory region, as would be the case "
"with BSS (uninitialized data)."
msgstr ""
"Поле I<offset> — это смещение в файле/где-то ещё; I<dev> — устройство "
"(старший номер:младший номер); I<inode> — индексный дескриптор на данном "
"устройстве. 0 означает, что с данной областью памяти не связаны индексные "
"дескрипторы: примером тому является сегмент BSS (неинициализированные "
"данные)."

#. type: Plain text
#: man-pages/man5/proc.5:1322
msgid ""
"The I<pathname> field will usually be the file that is backing the mapping.  "
"For ELF files, you can easily coordinate with the I<offset> field by looking "
"at the Offset field in the ELF program headers (I<readelf\\ -l>)."
msgstr ""
"В поле I<pathname> обычно указывается отображённый файл. Если файл в формате "
"ELF, то вы легко можете установить связь с полем I<offset>, посмотрев в "
"Offset программного заголовка ELF (I<readelf\\ -l>)."

#. type: Plain text
#: man-pages/man5/proc.5:1324
msgid "There are additional helpful pseudo-paths:"
msgstr "Дополнительные полезные псевдо-пути:"

#. type: TP
#: man-pages/man5/proc.5:1325
#, no-wrap
msgid "I<[stack]>"
msgstr "I<[stack]>"

#. type: Plain text
#: man-pages/man5/proc.5:1328
msgid "The initial process's (also known as the main thread's) stack."
msgstr "Начальный стек процесса (главной нити)."

#. type: TP
#: man-pages/man5/proc.5:1328
#, no-wrap
msgid "I<[stack:E<lt>tidE<gt>]> (from Linux 3.4 to 4.4)"
msgstr "I<[stack:E<lt>tidE<gt>]> (с Linux 3.4 по 4.4)"

#.  commit b76437579d1344b612cf1851ae610c636cec7db0 (added)
#.  commit 65376df582174ffcec9e6471bf5b0dd79ba05e4a (removed)
#. type: Plain text
#: man-pages/man5/proc.5:1340
msgid ""
"A thread's stack (where the I<E<lt>tidE<gt>> is a thread ID).  It "
"corresponds to the I</proc/[pid]/task/[tid]/> path.  This field was removed "
"in Linux 4.5, since providing this information for a process with large "
"numbers of threads is expensive."
msgstr ""
"Стек нити (где I<E<lt>tidE<gt>> — ID нити). Соответствует пути I</proc/[pid]/"
"task/[tid]/>. Это поле было удалено в Linux 4.5, так как предоставление им "
"информации по процессу с большим количеством нитей оказалось слишком "
"затратным."

#. type: TP
#: man-pages/man5/proc.5:1340
#, no-wrap
msgid "I<[vdso]>"
msgstr "I<[vdso]>"

#. type: Plain text
#: man-pages/man5/proc.5:1345
msgid "The virtual dynamically linked shared object.  See B<vdso>(7)."
msgstr ""
"Виртуальный, динамически компонуемый, общий объект. Смотрите B<vdso>(7)."

#. type: TP
#: man-pages/man5/proc.5:1345
#, no-wrap
msgid "I<[heap]>"
msgstr "I<[heap]>"

#. type: Plain text
#: man-pages/man5/proc.5:1348
msgid "The process's heap."
msgstr "Куча процесса."

#. type: Plain text
#: man-pages/man5/proc.5:1361
msgid ""
"If the I<pathname> field is blank, this is an anonymous mapping as obtained "
"via B<mmap>(2).  There is no easy way to coordinate this back to a process's "
"source, short of running it through B<gdb>(1), B<strace>(1), or similar."
msgstr ""
"Если значение поля I<pathname> пусто, то это анонимное отображение, "
"полученное с помощью B<mmap>(2). Нет простого способа увязать это с "
"источником в процессе, кроме как запустив его в B<gdb>(1), B<strace>(1) и т."
"п."

#. type: Plain text
#: man-pages/man5/proc.5:1369
msgid ""
"I<pathname> is shown unescaped except for newline characters, which are "
"replaced with an octal escape sequence.  As a result, it is not possible to "
"determine whether the original pathname contained a newline character or the "
"literal I<\\ee012> character sequence."
msgstr ""
"Всё значение I<pathname> является неэкранированным, кроме символа новой "
"строки, который заменяется на восьмеричную экранирующую последовательность. "
"В результате невозможно определить, что в оригинальном пути — символ новой "
"строки или экранирующая последовательность буквенная I<\\ee012>."

#. type: Plain text
#: man-pages/man5/proc.5:1373
msgid ""
"If the mapping is file-backed and the file has been deleted, the string "
"\" (deleted)\" is appended to the pathname.  Note that this is ambiguous too."
msgstr ""
"Если файл отображается в виртуальную память и удаляется, то к пути "
"добавляется строка \" (deleted)\". Заметим, что это также проблематичное "
"решение."

#. type: Plain text
#: man-pages/man5/proc.5:1375
msgid "Under Linux 2.0, there is no field giving pathname."
msgstr "В Linux 2.0 поле, указывающее на имя файла, отсутствует."

#. type: TP
#: man-pages/man5/proc.5:1375
#, no-wrap
msgid "I</proc/[pid]/mem>"
msgstr "I</proc/[pid]/mem>"

#. type: Plain text
#: man-pages/man5/proc.5:1382
msgid ""
"This file can be used to access the pages of a process's memory through "
"B<open>(2), B<read>(2), and B<lseek>(2)."
msgstr ""
"Этот файл можно использовать для получения доступа к страницам памяти "
"процесса через вызовы B<open>(2), B<read>(2) и B<lseek>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:1387 man-pages/man5/proc.5:1789
#: man-pages/man5/proc.5:2030 man-pages/man5/proc.5:2744
msgid ""
"Permission to access this file is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_FSCREDS> check; see B<ptrace>(2)."
msgstr ""
"Право доступа к этому файлу определяется проверкой режима доступа ptrace "
"B<PTRACE_MODE_ATTACH_FSCREDS>; смотрите B<ptrace>(2)."

#. type: TP
#: man-pages/man5/proc.5:1387
#, no-wrap
msgid "I</proc/[pid]/mountinfo> (since Linux 2.6.26)"
msgstr "I</proc/[pid]/mountinfo> (начиная с Linux 2.6.26)"

#.  This info adapted from Documentation/filesystems/proc.txt
#.  commit 2d4d4864ac08caff5c204a752bd004eed4f08760
#. type: Plain text
#: man-pages/man5/proc.5:1401
msgid ""
"This file contains information about mount points in the process's mount "
"namespace (see B<mount_namespaces>(7)).  It supplies various information (e."
"g., propagation state, root of mount for bind mounts, identifier for each "
"mount and its parent) that is missing from the (older)  I</proc/[pid]/"
"mounts> file, and fixes various other problems with that file (e.g., "
"nonextensibility, failure to distinguish per-mount versus per-superblock "
"options)."
msgstr ""
"В этом файле содержится информация о точках монтирования в пространстве имён "
"монтирования процесса (смотрите B<mount_namespaces>(7)). Здесь представлена "
"различная информация (например, состояние распространения, корень "
"монтирования для привязок монтирования, идентификатор каждого монтирования и "
"его родитель), которой нет в (старом) файле I</proc/[pid]/mounts>, и "
"исправлены различные проблемы этого файла (например, непродолжаемость, "
"невозможность различить параметры конкретного монтирования и суперблока)."

#. type: Plain text
#: man-pages/man5/proc.5:1403
msgid "The file contains lines of the form:"
msgstr "В этом файле содержатся строки в следующем формате:"

#. type: Plain text
#: man-pages/man5/proc.5:1408
#, no-wrap
msgid ""
"36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue\n"
"(1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)\n"
msgstr ""
"36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue\n"
"(1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)\n"

#. type: Plain text
#: man-pages/man5/proc.5:1412
msgid "The numbers in parentheses are labels for the descriptions below:"
msgstr "Описания полей (номер представлен в скобках):"

#. type: Plain text
#: man-pages/man5/proc.5:1417
msgid "mount ID: a unique ID for the mount (may be reused after B<umount>(2))."
msgstr ""
"ID монтирования: уникальный идентификатор монтирования (может использоваться "
"повторно после B<umount>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:1421
msgid ""
"parent ID: the ID of the parent mount (or of self for the root of this mount "
"namespace's mount tree)."
msgstr ""
"родительский ID: ID родительского монтирования (или самого себя, для корня "
"дерева монтирования)."

#. type: Plain text
#: man-pages/man5/proc.5:1431
msgid ""
"If a new mount is stacked on top of a previous existing mount (so that it "
"hides the existing mount) at pathname P, then the parent of the new mount is "
"the previous mount at that location.  Thus, when looking at all the mounts "
"stacked at a particular location, the top-most mount is the one that is not "
"the parent of any other mount at the same location.  (Note, however, that "
"this top-most mount will be accessible only if the longest path subprefix of "
"P that is a mount point is not itself hidden by a stacked mount.)"
msgstr ""
"Если новая точка монтирования накладывается поверх существующей точки "
"монтирования (таким образ скрывая её) hides the existing mount) с путём P, "
"то родитель новой точки монтирования равен предыдущей точке монтирования в "
"этом расположении. То есть, если смотреть все точки монтирования наложенные "
"на определённое расположение, то самой верхней точкой монтирования будет та, "
"которая не является родителем каких-либо других точек монтирования в том же "
"расположении (однако заметим, что это верхняя точка монтирования будет "
"доступна только, если самый длинный подпрефикс пути P, являющийся точкой "
"монтирования, сам не будет скрыт наложенным монтированием)."

#.  Miklos Szeredi, Nov 2017: The hidden one is the initramfs, I believe
#.  mtk: In the initial mount namespace, this hidden ID has the value 0
#. type: Plain text
#: man-pages/man5/proc.5:1448
msgid ""
"If the parent mount point lies outside the process's root directory (see "
"B<chroot>(2)), the ID shown here won't have a corresponding record in "
"I<mountinfo> whose mount ID (field 1) matches this parent mount ID (because "
"mount points that lie outside the process's root directory are not shown in "
"I<mountinfo>).  As a special case of this point, the process's root mount "
"point may have a parent mount (for the initramfs filesystem) that lies "
"outside the process's root directory, and an entry for that mount point will "
"not appear in I<mountinfo>."
msgstr ""
"Если родительская точка монтирования находится вне корневого каталога "
"процесса (смотрите B<chroot>(2)), то ID, показываемый здесь, не имеет "
"соответствующей записи в I<mountinfo>, ID монтирования которого (1 поле) "
"совпадает с этим ID родительского монтирования (так как точки монтирования, "
"находящиеся вне корневого каталога процесса не показываются в I<mountinfo>). "
"Исключением является точка монтирования корня процесса, у неё родительское "
"монтирование (для файловой системы initramfs) располагается вне корневого "
"каталога процесса и запись об этой точке монтирования отсутствует в "
"I<mountinfo>."

#. type: Plain text
#: man-pages/man5/proc.5:1454
msgid ""
"major:minor: the value of I<st_dev> for files on this filesystem (see "
"B<stat>(2))."
msgstr ""
"старший:младший: значение I<st_dev> для файлов в этой файловой системе "
"(смотрите B<stat>(2))."

#. type: TP
#: man-pages/man5/proc.5:1454 man-pages/man5/proc.5:1550
#: man-pages/man5/proc.5:3378 man-pages/man5/proc.5:4035
#, no-wrap
msgid "(4)"
msgstr "(4)"

#. type: Plain text
#: man-pages/man5/proc.5:1458
msgid ""
"root: the pathname of the directory in the filesystem which forms the root "
"of this mount."
msgstr ""
"корень: путь к каталогу в файловой системе, с которого начинается корень "
"данного монтирования."

#. type: TP
#: man-pages/man5/proc.5:1458 man-pages/man5/proc.5:3389
#: man-pages/man5/proc.5:4040
#, no-wrap
msgid "(5)"
msgstr "(5)"

#. type: Plain text
#: man-pages/man5/proc.5:1462
msgid ""
"mount point: the pathname of the mount point relative to the process's root "
"directory."
msgstr ""
"точка монтирования: путь точки монтирования относительно корневого каталога "
"процесса."

#. type: TP
#: man-pages/man5/proc.5:1462 man-pages/man5/proc.5:3400
#: man-pages/man5/proc.5:4044
#, no-wrap
msgid "(6)"
msgstr "(6)"

#. type: Plain text
#: man-pages/man5/proc.5:1466
msgid "mount options: per-mount options (see B<mount>(2))."
msgstr ""
"параметры монтирования: параметры конкретного монтирования (смотрите "
"B<mount>(2))."

#. type: TP
#: man-pages/man5/proc.5:1466 man-pages/man5/proc.5:3404
#: man-pages/man5/proc.5:4050
#, no-wrap
msgid "(7)"
msgstr "(7)"

#. type: Plain text
#: man-pages/man5/proc.5:1469
msgid ""
"optional fields: zero or more fields of the form \"tag[:value]\"; see below."
msgstr ""
"необязательные поля: ноль или более полей в виде «метка[:значение]»; "
"смотрите далее."

#. type: TP
#: man-pages/man5/proc.5:1469 man-pages/man5/proc.5:3407
#: man-pages/man5/proc.5:4057
#, no-wrap
msgid "(8)"
msgstr "(8)"

#. type: Plain text
#: man-pages/man5/proc.5:1472
msgid "separator: the end of the optional fields is marked by a single hyphen."
msgstr ""
"разделитель: конец необязательных полей отмечается одиночным символом "
"переноса."

#. type: TP
#: man-pages/man5/proc.5:1472
#, no-wrap
msgid "(9)"
msgstr "(9)"

#. type: Plain text
#: man-pages/man5/proc.5:1475
msgid "filesystem type: the filesystem type in the form \"type[.subtype]\"."
msgstr "тип файловой системы: тип файловой системы в виде «тип[.подтип]»."

#. type: TP
#: man-pages/man5/proc.5:1475
#, no-wrap
msgid "(10)"
msgstr "(10)"

#. type: Plain text
#: man-pages/man5/proc.5:1478
msgid "mount source: filesystem-specific information or \"none\"."
msgstr ""
"источник монтирования: информация, специфичная для файловой системы или "
"«none»."

#. type: TP
#: man-pages/man5/proc.5:1478
#, no-wrap
msgid "(11)"
msgstr "(11)"

#. type: Plain text
#: man-pages/man5/proc.5:1482
msgid "super options: per-superblock options (see B<mount>(2))."
msgstr ""
"параметры суперблока: параметры конкретного суперблока (смотрите "
"B<mount>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:1494
msgid ""
"Currently, the possible optional fields are I<shared>, I<master>, "
"I<propagate_from>, and I<unbindable>.  See B<mount_namespaces>(7)  for a "
"description of these fields.  Parsers should ignore all unrecognized "
"optional fields."
msgstr ""
"Возможные необязательные поля на данный момент: I<shared>, I<master>, "
"I<propagate_from> и I<unbindable>. Описание этих полей смотрите в "
"B<mount_namespaces>(7). Анализаторы должны игнорировать все неизвестные "
"необязательные поля."

#. type: Plain text
#: man-pages/man5/proc.5:1498
msgid ""
"For more information on mount propagation see: I<Documentation/filesystems/"
"sharedsubtree.txt> in the Linux kernel source tree."
msgstr ""
"Подробней о концепции распространения монтирования смотрите в исходном коде "
"ядра Linux в файле I<Documentation/filesystems/sharedsubtree.txt>."

#. type: TP
#: man-pages/man5/proc.5:1498
#, no-wrap
msgid "I</proc/[pid]/mounts> (since Linux 2.4.19)"
msgstr "I</proc/[pid]/mounts> (начиная с Linux 2.4.19)"

#. type: Plain text
#: man-pages/man5/proc.5:1505
msgid ""
"This file lists all the filesystems currently mounted in the process's mount "
"namespace (see B<mount_namespaces>(7)).  The format of this file is "
"documented in B<fstab>(5)."
msgstr ""
"Этот файл содержит список всех файловых систем, смонтированных в "
"пространстве имён монтирования процесса в данный момент (смотрите "
"B<mount_namespaces>(7)). Формат этого файл описан в B<fstab>(5)."

#. type: Plain text
#: man-pages/man5/proc.5:1524
msgid ""
"Since kernel version 2.6.15, this file is pollable: after opening the file "
"for reading, a change in this file (i.e., a filesystem mount or unmount) "
"causes B<select>(2)  to mark the file descriptor as having an exceptional "
"condition, and B<poll>(2)  and B<epoll_wait>(2)  mark the file as having a "
"priority event (B<POLLPRI>).  (Before Linux 2.6.30, a change in this file "
"was indicated by the file descriptor being marked as readable for "
"B<select>(2), and being marked as having an error condition for B<poll>(2)  "
"and B<epoll_wait>(2).)"
msgstr ""
"Начиная с ядра версии 2.6.15 этот файл можно опрашивать: после открытия "
"файла на чтение, изменение в этом файле (т. е., монтирование или "
"размонтирование файловой системы) заставляют B<select>(2) помечать файловый "
"дескриптор как имеющий исключительное условие, а B<poll>(2) и "
"B<epoll_wait>(2) помечают файл как имеющий приоритетное событие (B<POLLPRI>) "
"(до Linux 2.6.30, изменение этого файла отражались на файловом дескрипторе с "
"помощью отметки как читаемого для B<select>(2) и имеющего условие ошибки для "
"B<poll>(2) и B<epoll_wait>(2))."

#. type: TP
#: man-pages/man5/proc.5:1524
#, no-wrap
msgid "I</proc/[pid]/mountstats> (since Linux 2.6.17)"
msgstr "I</proc/[pid]/mountstats> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man5/proc.5:1530
msgid ""
"This file exports information (statistics, configuration information)  about "
"the mount points in the process's mount namespace (see "
"B<mount_namespaces>(7)).  Lines in this file have the form:"
msgstr ""
"В этом файле содержится информация (статистика, информация о настройке) о "
"точках монтирования в пространстве имён монтирования процесса (смотрите "
"B<mount_namespaces>(7)). Формат строк в файле:"

#. type: Plain text
#: man-pages/man5/proc.5:1535
#, no-wrap
msgid ""
"device /dev/sda7 mounted on /home with fstype ext3 [statistics]\n"
"(       1      )            ( 2 )             (3 ) (4)\n"
msgstr ""
"device /dev/sda7 mounted on /home with fstype ext3 [statistics]\n"
"(       1      )            ( 2 )             (3 ) (4)\n"

#. type: Plain text
#: man-pages/man5/proc.5:1539 man-pages/man5/proc.5:4014
msgid "The fields in each line are:"
msgstr "Поля каждой строки:"

#. type: Plain text
#: man-pages/man5/proc.5:1544
msgid ""
"The name of the mounted device (or \"nodevice\" if there is no corresponding "
"device)."
msgstr ""
"Имя смонтированного устройства (или \"nodevice\", если нет соответствующего "
"устройства)."

#. type: Plain text
#: man-pages/man5/proc.5:1547
msgid "The mount point within the filesystem tree."
msgstr "Точка монтирования в дереве файловой системы."

#. type: Plain text
#: man-pages/man5/proc.5:1550
msgid "The filesystem type."
msgstr "Тип файловой системы."

#. type: Plain text
#: man-pages/man5/proc.5:1555
msgid ""
"Optional statistics and configuration information.  Currently (as at Linux "
"2.6.26), only NFS filesystems export information via this field."
msgstr ""
"Необязательная статистика и информация о настройке. В настоящее время (Linux "
"версии 2.6.26), в этом поле доступна только информация об экспортируемых "
"файловых системах NFS."

#. type: Plain text
#: man-pages/man5/proc.5:1558
msgid "This file is readable only by the owner of the process."
msgstr "Данный файл доступен на чтение только владельцу процесса."

#. type: TP
#: man-pages/man5/proc.5:1558
#, no-wrap
msgid "I</proc/[pid]/net> (since Linux 2.6.25)"
msgstr "I</proc/[pid]/net> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man5/proc.5:1562
msgid "See the description of I</proc/net>."
msgstr "Смотрите описание I</proc/net>."

#. type: TP
#: man-pages/man5/proc.5:1562
#, no-wrap
msgid "I</proc/[pid]/ns/> (since Linux 3.0)"
msgstr "I</proc/[pid]/ns/> (начиная с Linux 3.0)"

#.  See commit 6b4e306aa3dc94a0545eb9279475b1ab6209a31f
#. type: Plain text
#: man-pages/man5/proc.5:1570
msgid ""
"This is a subdirectory containing one entry for each namespace that supports "
"being manipulated by B<setns>(2).  For more information, see "
"B<namespaces>(7)."
msgstr ""
"В этом подкаталоге содержится по одной записи на каждое пространство имён, "
"для которых в B<setns>(2) есть поддержка изменений. Дополнительную "
"информацию смотрите в B<namespaces>(7)."

#. type: TP
#: man-pages/man5/proc.5:1570
#, no-wrap
msgid "I</proc/[pid]/numa_maps> (since Linux 2.6.14)"
msgstr "I</proc/[pid]/numa_maps> (начиная с Linux 2.6.14)"

#. type: Plain text
#: man-pages/man5/proc.5:1574
msgid "See B<numa>(7)."
msgstr "Смотрите B<numa>(7)."

#. type: TP
#: man-pages/man5/proc.5:1574
#, no-wrap
msgid "I</proc/[pid]/oom_adj> (since Linux 2.6.11)"
msgstr "I</proc/[pid]/oom_adj> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man5/proc.5:1587
msgid ""
"This file can be used to adjust the score used to select which process "
"should be killed in an out-of-memory (OOM) situation.  The kernel uses this "
"value for a bit-shift operation of the process's I<oom_score> value: valid "
"values are in the range -16 to +15, plus the special value -17, which "
"disables OOM-killing altogether for this process.  A positive score "
"increases the likelihood of this process being killed by the OOM-killer; a "
"negative score decreases the likelihood."
msgstr ""
"Этот файл может использоваться для подгонки оценки, используемой при выборе "
"процесса, который нужно завершить при нехватке памяти (OOM). Ядро использует "
"это значение в операции побитового сдвига значения I<oom_score> у процесса: "
"допустимые находятся в диапазоне от -16 до +15, плюс специальное значение "
"-17, которое отключает OOM-завершение для этого процесса совсем. "
"Положительная оценка увеличивает вероятность, что процесс будет завершён OOM-"
"killer; отрицательная оценка уменьшает вероятность."

#. type: Plain text
#: man-pages/man5/proc.5:1595
msgid ""
"The default value for this file is 0; a new process inherits its parent's "
"I<oom_adj> setting.  A process must be privileged (B<CAP_SYS_RESOURCE>)  to "
"update this file."
msgstr ""
"Значение по умолчанию в этом файле равно 0; новый процесс наследует его от "
"родительского значения I<oom_adj>. Для изменения этого файла процесс должен "
"иметь мандат B<CAP_SYS_RESOURCE>."

#. type: Plain text
#: man-pages/man5/proc.5:1598
msgid ""
"Since Linux 2.6.36, use of this file is deprecated in favor of I</proc/[pid]/"
"oom_score_adj>."
msgstr ""
"Начиная с Linux 2.6.36, вместо этого файла рекомендуется использовать I</"
"proc/[pid]/oom_score_adj>."

#. type: TP
#: man-pages/man5/proc.5:1598
#, no-wrap
msgid "I</proc/[pid]/oom_score> (since Linux 2.6.11)"
msgstr "I</proc/[pid]/oom_score> (начиная с Linux 2.6.11)"

#.  See mm/oom_kill.c::badness() in pre 2.6.36 sources
#.  See mm/oom_kill.c::oom_badness() after 2.6.36
#.  commit a63d83f427fbce97a6cea0db2e64b0eb8435cd10
#.  See mm/oom_kill.c::badness() in pre 2.6.36 sources
#.  See mm/oom_kill.c::oom_badness() after 2.6.36
#.  commit a63d83f427fbce97a6cea0db2e64b0eb8435cd10
#. type: Plain text
#: man-pages/man5/proc.5:1613
msgid ""
"This file displays the current score that the kernel gives to this process "
"for the purpose of selecting a process for the OOM-killer.  A higher score "
"means that the process is more likely to be selected by the OOM-killer.  The "
"basis for this score is the amount of memory used by the process, with "
"increases (+) or decreases (-) for factors including:"
msgstr ""
"Этот файл содержит текущую оценку, которую ядро назначило процессу, "
"учитывающуюся при избрании процесса OOM-killer. Более высокая оценка "
"означает, что у процесса есть больше шансов быть выбранным OOM-killer. "
"Основой оценки является количество памяти используемой процессом и различные "
"увеличивающие (+) и уменьшающие (-) факторы:"

#.  More precisely, if it has CAP_SYS_ADMIN or (pre 2.6.36) CAP_SYS_RESOURCE
#. type: Plain text
#: man-pages/man5/proc.5:1617
msgid "whether the process is privileged (-)."
msgstr "считается ли процесс привилегированным (-)."

#. type: Plain text
#: man-pages/man5/proc.5:1620
msgid ""
"Before kernel 2.6.36 the following factors were also used in the calculation "
"of oom_score:"
msgstr ""
"До ядра 2.6.36 при вычислении oom_score также используются следующие факторы:"

#. type: Plain text
#: man-pages/man5/proc.5:1625
msgid "whether the process creates a lot of children using B<fork>(2)  (+);"
msgstr "создавал ли процесс много потомков с помощью B<fork>(2) (+);"

#. type: Plain text
#: man-pages/man5/proc.5:1628
msgid ""
"whether the process has been running a long time, or has used a lot of CPU "
"time (-);"
msgstr ""
"долго ли работал процесс, или использовал много процессорного времени (-);"

#. type: Plain text
#: man-pages/man5/proc.5:1630
msgid "whether the process has a low nice value (i.e., E<gt> 0) (+); and"
msgstr ""
"имеет ли процесс низкое значение уступчивости (nice) (т. е., E<gt> 0) (+); и"

#.  More precisely, if it has CAP_SYS_RAWIO
#. type: Plain text
#: man-pages/man5/proc.5:1633
msgid "whether the process is making direct hardware access (-)."
msgstr "обращается ли процесс к аппаратному обеспечению напрямую (-)."

#. type: Plain text
#: man-pages/man5/proc.5:1642
msgid ""
"The I<oom_score> also reflects the adjustment specified by the "
"I<oom_score_adj> or I<oom_adj> setting for the process."
msgstr ""
"Значение I<oom_score> также отражает подгонку смещения, указанную в "
"I<oom_score_adj> или I<oom_adj> процесса."

#. type: TP
#: man-pages/man5/proc.5:1642
#, no-wrap
msgid "I</proc/[pid]/oom_score_adj> (since Linux 2.6.36)"
msgstr "I</proc/[pid]/oom_score_adj> (начиная с Linux 2.6.36)"

#.  Text taken from 3.7 Documentation/filesystems/proc.txt
#. type: Plain text
#: man-pages/man5/proc.5:1647
msgid ""
"This file can be used to adjust the badness heuristic used to select which "
"process gets killed in out-of-memory conditions."
msgstr ""
"Этот файл может использоваться для подгонки оценки вредности для выбора "
"процесса, который нужно завершить при нехватке памяти."

#. type: Plain text
#: man-pages/man5/proc.5:1656
msgid ""
"The badness heuristic assigns a value to each candidate task ranging from 0 "
"(never kill) to 1000 (always kill) to determine which process is targeted.  "
"The units are roughly a proportion along that range of allowed memory the "
"process may allocate from, based on an estimation of its current memory and "
"swap use.  For example, if a task is using all allowed memory, its badness "
"score will be 1000.  If it is using half of its allowed memory, its score "
"will be 500."
msgstr ""
"Значение оценки вредности назначается каждой задаче-кандидату от 0 (никогда "
"не завершать) до 1000 (всегда завершать), которым определяется какой процесс "
"будет выбран. Единицы примерно пропорциональны диапазону разрешённой памяти, "
"которую может запросить процесс, на основе вычисления его текущей памяти и "
"использованию подкачки.Например, если задача использует всю разрешённую "
"память, то значение вредности будет равно 1000. Если процесс использует "
"половину разрешённой памяти, то значение будет 500."

#. type: Plain text
#: man-pages/man5/proc.5:1659
msgid ""
"There is an additional factor included in the badness score: root processes "
"are given 3% extra memory over other tasks."
msgstr ""
"Есть дополнительный фактор, учитывающийся для вредности: процессам root "
"даётся на 3% больше памяти, чем другим задачам."

#. type: Plain text
#: man-pages/man5/proc.5:1673
msgid ""
"The amount of \"allowed\" memory depends on the context in which the OOM-"
"killer was called.  If it is due to the memory assigned to the allocating "
"task's cpuset being exhausted, the allowed memory represents the set of mems "
"assigned to that cpuset (see B<cpuset>(7)).  If it is due to a mempolicy's "
"node(s) being exhausted, the allowed memory represents the set of mempolicy "
"nodes.  If it is due to a memory limit (or swap limit) being reached, the "
"allowed memory is that configured limit.  Finally, if it is due to the "
"entire system being out of memory, the allowed memory represents all "
"allocatable resources."
msgstr ""
"Количество «разрешённой» памяти зависит от контекста, в котором был вызван "
"OOM-killer. Если он вызван в момент, когда при назначении памяти для "
"выделенного cpuset задачи происходит исчерпание, то разрешённая память "
"представляет набор mem, назначенных этому cpuset (смотрите B<cpuset>(7)). "
"Если это происходит при исчерпании узлов mempolicy, то разрешённая память "
"представляет набор узлов mempolicy. Если это происходит при достижении "
"лимита на память (или лимита подкачки), то разрешённой памятью считается "
"настроенный лимит. Наконец, если это происходит при нехватке памяти во всей "
"системе, то разрешённой памятью считаются все доступные для выделения "
"ресурсы."

#. type: Plain text
#: man-pages/man5/proc.5:1686
msgid ""
"The value of I<oom_score_adj> is added to the badness score before it is "
"used to determine which task to kill.  Acceptable values range from -1000 "
"(OOM_SCORE_ADJ_MIN) to +1000 (OOM_SCORE_ADJ_MAX).  This allows user space to "
"control the preference for OOM-killing, ranging from always preferring a "
"certain task or completely disabling it from OOM killing.  The lowest "
"possible value, -1000, is equivalent to disabling OOM-killing entirely for "
"that task, since it will always report a badness score of 0."
msgstr ""
"Значение I<oom_score_adj> добавляется к значению вредности перед тем как оно "
"будет использовано для определения завершаемой задачи. Диапазон разрешённых "
"значений: от -1000 (OOM_SCORE_ADJ_MIN) до +1000 (OOM_SCORE_ADJ_MAX). Это "
"позволяет осуществлять контроль за настройкой OOM-killing из "
"пользовательского пространства, указывая самые ненужные задачи или полностью "
"отключая OOM-killing для самых важных. Самое минимальное значение, -1000, "
"эквивалентно полному отключению OOM-killing для определённой задачи, так как "
"оно снижает значение вредности до 0."

#. type: Plain text
#: man-pages/man5/proc.5:1698
msgid ""
"Consequently, it is very simple for user space to define the amount of "
"memory to consider for each task.  Setting an I<oom_score_adj> value of "
"+500, for example, is roughly equivalent to allowing the remainder of tasks "
"sharing the same system, cpuset, mempolicy, or memory controller resources "
"to use at least 50% more memory.  A value of -500, on the other hand, would "
"be roughly equivalent to discounting 50% of the task's allowed memory from "
"being considered as scoring against the task."
msgstr ""
"Следовательно, из пользовательского пространства очень просто определить "
"количество памяти по каждой задаче. Например, установка значения "
"I<oom_score_adj> равным +500, примерно эквивалентна разрешению оставшимся "
"задачам использовать общим в системы ресурсам, cpuset, mempolicy, или "
"контроллеру памяти не менее 50% памяти. С другой стороны, значение -500 было "
"бы примерно эквивалентно отниманию 50% из разрешённой памяти задачи при "
"подсчёте вредности задачи."

#. type: Plain text
#: man-pages/man5/proc.5:1705
msgid ""
"For backward compatibility with previous kernels, I</proc/[pid]/oom_adj> can "
"still be used to tune the badness score.  Its value is scaled linearly with "
"I<oom_score_adj>."
msgstr ""
"Для обратной совместимости с предыдущими версиями ядер значение в I</proc/"
"[pid]/oom_adj> всё ещё может учитываться при подстройке значения вредности. "
"Это значение линейно масштабируется с I<oom_score_adj>."

#. type: Plain text
#: man-pages/man5/proc.5:1711
msgid ""
"Writing to I</proc/[pid]/oom_score_adj> or I</proc/[pid]/oom_adj> will "
"change the other with its scaled value."
msgstr ""
"Запись в I</proc/[pid]/oom_score_adj> или I</proc/[pid]/oom_adj> изменит и "
"значение в другом параметре с соответствующим масштабом."

#. type: Plain text
#: man-pages/man5/proc.5:1717
msgid ""
"The B<choom>(1)  program provides a command-line interface for adjusting the "
"I<oom_score_adj> value of a running process or a newly executed command."
msgstr ""
"Программа B<choom>(1)  предоставляет интерфейс командной строки для подбора "
"значения I<oom_score_adj> в уже работающем процессе или новой запускаемой "
"команде."

#. type: TP
#: man-pages/man5/proc.5:1717
#, no-wrap
msgid "I</proc/[pid]/pagemap> (since Linux 2.6.25)"
msgstr "I</proc/[pid]/pagemap> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man5/proc.5:1723
msgid ""
"This file shows the mapping of each of the process's virtual pages into "
"physical page frames or swap area.  It contains one 64-bit value for each "
"virtual page, with the bits set as follows:"
msgstr ""
"Через данный файл показываются отображения каждой виртуальной страницы "
"процесса в физические страничный кадры и области подкачки. Каждой страницы "
"соответствует одно 64-битное число, биты которого имеют следующее значение:"

#. type: TP
#: man-pages/man5/proc.5:1724
#, no-wrap
msgid "63"
msgstr "63"

#. type: Plain text
#: man-pages/man5/proc.5:1727
msgid "If set, the page is present in RAM."
msgstr "Если установлен, то страница находится в оперативной памяти."

#. type: TP
#: man-pages/man5/proc.5:1727
#, no-wrap
msgid "62"
msgstr "62"

#. type: Plain text
#: man-pages/man5/proc.5:1730
msgid "If set, the page is in swap space"
msgstr "Если установлен, то страница находится в пространстве подкачки."

#. type: TP
#: man-pages/man5/proc.5:1730
#, no-wrap
msgid "61 (since Linux 3.5)"
msgstr "61 (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man5/proc.5:1733
msgid "The page is a file-mapped page or a shared anonymous page."
msgstr ""
"Страница является отображённой файловой страницей или общей анонимной "
"страницей."

#. type: TP
#: man-pages/man5/proc.5:1733
#, no-wrap
msgid "60\\(en57 (since Linux 3.11)"
msgstr "60\\(en57 (начиная с Linux 3.11)"

#.  Not quite true; see commit 541c237c0923f567c9c4cabb8a81635baadc713f
#. type: Plain text
#: man-pages/man5/proc.5:1737
msgid "Zero"
msgstr "Ноль"

#. type: TP
#: man-pages/man5/proc.5:1737
#, no-wrap
msgid "56 (since Linux 4.2)"
msgstr "56 (начиная с Linux 4.2)"

#.  commit 77bb499bb60f4b79cca7d139c8041662860fcf87
#.  commit 83b4b0bb635eee2b8e075062e4e008d1bc110ed7
#. type: Plain text
#: man-pages/man5/proc.5:1742
msgid "The page is exclusively mapped."
msgstr "Страница отображена монопольно."

#. type: TP
#: man-pages/man5/proc.5:1742
#, no-wrap
msgid "55 (since Linux 3.11)"
msgstr "55 (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man5/proc.5:1747
msgid ""
"PTE is soft-dirty (see the kernel source file I<Documentation/admin-guide/mm/"
"soft-dirty.rst>)."
msgstr ""
"PTE содержит бит soft-dirty (смотрите файл исходного кода ядра "
"I<Documentation/admin-guide/mm/soft-dirty.rst>)."

#. type: TP
#: man-pages/man5/proc.5:1747
#, no-wrap
msgid "54\\(en0"
msgstr "54\\(en0"

#. type: Plain text
#: man-pages/man5/proc.5:1756
msgid ""
"If the page is present in RAM (bit 63), then these bits provide the page "
"frame number, which can be used to index I</proc/kpageflags> and I</proc/"
"kpagecount>.  If the page is present in swap (bit 62), then bits 4\\(en0 "
"give the swap type, and bits 54\\(en5 encode the swap offset."
msgstr ""
"Если страница находится в оперативной памяти (бит 63), то эти биты содержат "
"номер кадра страницы, который можно использовать для индексации I</proc/"
"kpageflags> и I</proc/kpagecount>. Если страница находится в пространстве "
"подкачки (бит 62), то биты 4\\(en0 содержат тип подкачки, а биты 54\\(en5 — "
"смещение в пространстве подкачки."

#. type: Plain text
#: man-pages/man5/proc.5:1760
msgid ""
"Before Linux 3.11, bits 60\\(en55 were used to encode the base-2 log of the "
"page size."
msgstr ""
"До Linux 3.11, биты 60\\(en55 использовались как кодирование размера "
"страницы в виде логарифма по основанию 2."

#. type: Plain text
#: man-pages/man5/proc.5:1767
msgid ""
"To employ I</proc/[pid]/pagemap> efficiently, use I</proc/[pid]/maps> to "
"determine which areas of memory are actually mapped and seek to skip over "
"unmapped regions."
msgstr ""
"Для эффективного использования I</proc/[pid]/pagemap> обратитесь к I</proc/"
"[pid]/maps> для определения какие области памяти действительно отображены и "
"отбросьте не отображённые области."

#. type: Plain text
#: man-pages/man5/proc.5:1773
msgid ""
"The I</proc/[pid]/pagemap> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""
"Файл I</proc/[pid]/pagemap> существует только, если включён параметр "
"настройки ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:1778
#, no-wrap
msgid "I</proc/[pid]/personality> (since Linux 2.6.28)"
msgstr "I</proc/[pid]/personality> (начиная с Linux 2.6.28)"

#.  commit 478307230810d7e2a753ed220db9066dfdf88718
#. type: Plain text
#: man-pages/man5/proc.5:1784
msgid ""
"This read-only file exposes the process's execution domain, as set by "
"B<personality>(2).  The value is displayed in hexadecimal notation."
msgstr ""
"В файле (только для чтения) содержится домен выполнения процесса, заданный "
"B<personality>(2). Значение отображено в шестнадцатеричной системе счисления."

#. type: TP
#: man-pages/man5/proc.5:1789
#, no-wrap
msgid "I</proc/[pid]/root>"
msgstr "I</proc/[pid]/root>"

#. type: Plain text
#: man-pages/man5/proc.5:1800
msgid ""
"UNIX and Linux support the idea of a per-process root of the filesystem, set "
"by the B<chroot>(2)  system call.  This file is a symbolic link that points "
"to the process's root directory, and behaves in the same way as I<exe>, and "
"I<fd/*>."
msgstr ""
"UNIX и Linux поддерживают идею о попроцессном корневом каталоге файловой "
"системы, который может быть установлен системным вызовом B<chroot>(2). Этот "
"файл является символьной ссылкой, которая указывает на корневой каталог "
"процесса и ведёт себя так же, как I<exe> и I<fd/*>."

#. type: Plain text
#: man-pages/man5/proc.5:1807
msgid ""
"Note however that this file is not merely a symbolic link.  It provides the "
"same view of the filesystem (including namespaces and the set of per-process "
"mounts) as the process itself.  An example illustrates this point.  In one "
"terminal, we start a shell in new user and mount namespaces, and in that "
"shell we create some new mount points:"
msgstr ""
"Однако заметим, что этот файл не просто символьная ссылка. Note however that "
"this file is not merely a symbolic link. Она предоставляет тоже отражение "
"файловой системы (включая пространства имён и набор попроцессного "
"монтирования) как сам процесс. Покажем это на примере. В одном терминале мы "
"запустим оболочку в новом пространстве имён пользователя и монтирования, и "
"создадим несколько новых точек монтирования:"

#. type: Plain text
#: man-pages/man5/proc.5:1815
#, no-wrap
msgid ""
"$ B<PS1='sh1# ' unshare -Urnm>\n"
"sh1# B<mount -t tmpfs tmpfs /etc>  # Mount empty tmpfs at /etc\n"
"sh1# B<mount --bind /usr /dev>     # Mount /usr at /dev\n"
"sh1# B<echo $$>\n"
"27123\n"
msgstr ""
"$ B<PS1='sh1# ' unshare -Urnm>\n"
"sh1# B<mount -t tmpfs tmpfs /etc>  # монтирование пустой tmpfs в /etc\n"
"sh1# B<mount --bind /usr /dev>     # монтирование /usr в /dev\n"
"sh1# B<echo $$>\n"
"27123\n"

#. type: Plain text
#: man-pages/man5/proc.5:1821
msgid ""
"In a second terminal window, in the initial mount namespace, we look at the "
"contents of the corresponding mounts in the initial and new namespaces:"
msgstr ""
"Во втором терминальном окне, в первоначальном пространстве имён "
"монтирования, посмотрим содержимое соответствующего монтирования в "
"первоначальном и новом пространстве имён:"

#. type: Plain text
#: man-pages/man5/proc.5:1836
#, no-wrap
msgid ""
"$ B<PS1='sh2# ' sudo sh>\n"
"sh2# B<ls /etc | wc -l>                  # In initial NS\n"
"309\n"
"sh2# B<ls /proc/27123/root/etc | wc -l>  # /etc in other NS\n"
"0                                     # The empty tmpfs dir\n"
"sh2# B<ls /dev | wc -l>                  # In initial NS\n"
"205\n"
"sh2# B<ls /proc/27123/root/dev | wc -l>  # /dev in other NS\n"
"11                                    # Actually bind\n"
"                                      # mounted to /usr\n"
"sh2# B<ls /usr | wc -l>                  # /usr in initial NS\n"
"11\n"
msgstr ""
"$ B<PS1='sh2# ' sudo sh>\n"
"sh2# B<ls /etc | wc -l>                  # в первоначальном NS\n"
"309\n"
"sh2# B<ls /proc/27123/root/etc | wc -l>  # /etc в другом NS\n"
"0                                     # пустой каталог tmpfs\n"
"sh2# B<ls /dev | wc -l>                  # в первоначальном NS\n"
"205\n"
"sh2# B<ls /proc/27123/root/dev | wc -l>  # /dev в другом NS\n"
"11                                    # в реальности привязано\n"
"                                      # к смонтированному /usr\n"
"sh2# B<ls /usr | wc -l>                  # /usr в первоначальном NS\n"
"11\n"

#.  The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:1845
msgid ""
"In a multithreaded process, the contents of the I</proc/[pid]/root> symbolic "
"link are not available if the main thread has already terminated (typically "
"by calling B<pthread_exit>(3))."
msgstr ""
"В многонитевых процессах, содержимое символьной ссылки I</proc/[pid]/root> "
"недоступно, если головная нить уже завершила работу (обычно с помощью вызова "
"B<pthread_exit>(3))."

#. type: TP
#: man-pages/man5/proc.5:1855
#, no-wrap
msgid "I</proc/[pid]/seccomp> (Linux 2.6.12 to 2.6.22)"
msgstr "I</proc/[pid]/seccomp> (Linux 2.6.12 по 2.6.22)"

#. type: Plain text
#: man-pages/man5/proc.5:1866
msgid ""
"This file can be used to read and change the process's secure computing "
"(seccomp) mode setting.  It contains the value 0 if the process is not in "
"seccomp mode, and 1 if the process is in strict seccomp mode (see "
"B<seccomp>(2)).  Writing 1 to this file places the process irreversibly in "
"strict seccomp mode.  (Further attempts to write to the file fail with the "
"B<EPERM> error.)"
msgstr ""
"Этот файл можно использовать для чтения и изменения настройки режима "
"безопасных вычислений в процессе (seccomp). Он содержит значение 0, если "
"процесс не в режиме seccomp, и 1, если процесс ограничен режимом seccomp "
"(смотрите B<seccomp>(2)). Запись 1 в этот файл безвозвратно помещает процесс "
"в ограниченный режим seccomp (последующие попытки записать в файл "
"завершаются ошибкой B<EPERM>)."

#.  FIXME Describe /proc/[pid]/sessionid
#. 	  commit 1e0bd7550ea9cf474b1ad4c6ff5729a507f75fdc
#.        CONFIG_AUDITSYSCALL
#.        Added in 2.6.25; read-only; only readable by real UID
#.  FIXME Describe /proc/[pid]/sched
#.        Added in 2.6.23
#.        CONFIG_SCHED_DEBUG, and additional fields if CONFIG_SCHEDSTATS
#.        Displays various scheduling parameters
#.        This file can be written, to reset stats
#.        The set of fields exposed by this file have changed
#. 	  significantly over time.
#.        commit 43ae34cb4cd650d1eb4460a8253a8e747ba052ac
#.  FIXME Describe /proc/[pid]/schedstats and
#.        /proc/[pid]/task/[tid]/schedstats
#.        Added in 2.6.9
#.        CONFIG_SCHEDSTATS
#. type: Plain text
#: man-pages/man5/proc.5:1897
msgid ""
"In Linux 2.6.23, this file went away, to be replaced by the B<prctl>(2)  "
"B<PR_GET_SECCOMP> and B<PR_SET_SECCOMP> operations (and later by "
"B<seccomp>(2)  and the I<Seccomp> field in I</proc/[pid]/status>)."
msgstr ""
"В Linux 2.6.23 этот файл был убран и заменён операциями B<PR_GET_SECCOMP> и "
"B<PR_SET_SECCOMP> вызова B<prctl>(2) (а позднее B<seccomp>(2) и полем "
"I<Seccomp> в I</proc/[pid]/status>)."

#. type: TP
#: man-pages/man5/proc.5:1897
#, no-wrap
msgid "I</proc/[pid]/setgroups> (since Linux 3.19)"
msgstr "I</proc/[pid]/setgroups> (начиная с Linux 3.19)"

#. type: TP
#: man-pages/man5/proc.5:1901
#, no-wrap
msgid "I</proc/[pid]/smaps> (since Linux 2.6.14)"
msgstr "I</proc/[pid]/smaps> (начиная с Linux 2.6.14)"

#. type: Plain text
#: man-pages/man5/proc.5:1909
msgid ""
"This file shows memory consumption for each of the process's mappings.  (The "
"B<pmap>(1)  command displays similar information, in a form that may be "
"easier for parsing.)  For each mapping there is a series of lines such as "
"the following:"
msgstr ""
"Этот файл содержит значение потребления памяти каждого отображения процесса. "
"(команда B<pmap>(1) выводит похожую информацию в пригодной для анализа "
"форме). Для каждого отображения есть несколько строк в виде:"

#. type: Plain text
#: man-pages/man5/proc.5:1933
#, no-wrap
msgid ""
"00400000-0048a000 r-xp 00000000 fd:03 960637       /bin/bash\n"
"Size:                552 kB\n"
"Rss:                 460 kB\n"
"Pss:                 100 kB\n"
"Shared_Clean:        452 kB\n"
"Shared_Dirty:          0 kB\n"
"Private_Clean:         8 kB\n"
"Private_Dirty:         0 kB\n"
"Referenced:          460 kB\n"
"Anonymous:             0 kB\n"
"AnonHugePages:         0 kB\n"
"ShmemHugePages:        0 kB\n"
"ShmemPmdMapped:        0 kB\n"
"Swap:                  0 kB\n"
"KernelPageSize:        4 kB\n"
"MMUPageSize:           4 kB\n"
"KernelPageSize:        4 kB\n"
"MMUPageSize:           4 kB\n"
"Locked:                0 kB\n"
"ProtectionKey:         0\n"
"VmFlags: rd ex mr mw me dw\n"
msgstr ""
"00400000-0048a000 r-xp 00000000 fd:03 960637       /bin/bash\n"
"Size:                552 kB\n"
"Rss:                 460 kB\n"
"Pss:                 100 kB\n"
"Shared_Clean:        452 kB\n"
"Shared_Dirty:          0 kB\n"
"Private_Clean:         8 kB\n"
"Private_Dirty:         0 kB\n"
"Referenced:          460 kB\n"
"Anonymous:             0 kB\n"
"AnonHugePages:         0 kB\n"
"ShmemHugePages:        0 kB\n"
"ShmemPmdMapped:        0 kB\n"
"Swap:                  0 kB\n"
"KernelPageSize:        4 kB\n"
"MMUPageSize:           4 kB\n"
"KernelPageSize:        4 kB\n"
"MMUPageSize:           4 kB\n"
"Locked:                0 kB\n"
"ProtectionKey:         0\n"
"VmFlags: rd ex mr mw me dw\n"

#. type: Plain text
#: man-pages/man5/proc.5:1950
msgid ""
"The first of these lines shows the same information as is displayed for the "
"mapping in I</proc/[pid]/maps>.  The following lines show the size of the "
"mapping, the amount of the mapping that is currently resident in RAM (\"Rss"
"\"), the process's proportional share of this mapping (\"Pss\"), the number "
"of clean and dirty shared pages in the mapping, and the number of clean and "
"dirty private pages in the mapping.  \"Referenced\" indicates the amount of "
"memory currently marked as referenced or accessed.  \"Anonymous\" shows the "
"amount of memory that does not belong to any file.  \"Swap\" shows how much "
"would-be-anonymous memory is also used, but out on swap."
msgstr ""
"Первые строки содержат ту же информацию, что и для отображения в I</proc/"
"[pid]/maps>. Следующие строки содержат размер отображения, размер "
"отображения, которое сейчас находится в RAM («Rss»), вклад этого отображения "
"в пропорцию общих страниц процесса («Pss»), количество чистых и грязных "
"общих страниц в отображении и количеств количество чистых и грязных частных "
"страниц в отображении. В «Referenced» указано количество памяти помеченной, "
"в данный момент, как ссылочная или доступная. В «Anonymous» указано "
"количество памяти, которая не принадлежит никакому файлу. В «Swap» указано "
"как много также использовалось было бы анонимной памяти, но она в подкачке."

#. type: Plain text
#: man-pages/man5/proc.5:1960
msgid ""
"The \"KernelPageSize\" line (available since Linux 2.6.29)  is the page size "
"used by the kernel to back the virtual memory area.  This matches the size "
"used by the MMU in the majority of cases.  However, one counter-example "
"occurs on PPC64 kernels whereby a kernel using 64kB as a base page size may "
"still use 4kB pages for the MMU on older processors.  To distinguish the two "
"attributes, the \"MMUPageSize\" line (also available since Linux 2.6.29)  "
"reports the page size used by the MMU."
msgstr ""
"Значение «KernelPageSize» (доступно, начиная с Linux 2.6.29) — размер "
"страницы, используемый ядром при делении области виртуальной памяти. В "
"большинстве случаев, размер совпадает с используемым в MMU. Однако, есть "
"один контрпример в ядрах на PPC64, где в качестве базового размера страницы "
"используется 64КБ, но при этом по-прежнему могут использоваться 4КБ страницы "
"для MMU на старых процессорах. Для различения двух атрибутов значением "
"«MMUPageSize» (также доступно начиная с Linux 2.6.29) определяется размер "
"страницы, используемой MMU."

#. type: Plain text
#: man-pages/man5/proc.5:1963
msgid ""
"The \"Locked\" indicates whether the mapping is locked in memory or not."
msgstr ""
"Значение «Locked» указывает будет ли отображение заблокировано в памяти или "
"нет."

#. type: Plain text
#: man-pages/man5/proc.5:1971
msgid ""
"The \"ProtectionKey\" line (available since Linux 4.9, on x86 only)  "
"contains the memory protection key (see B<pkeys>(7))  associated with the "
"virtual memory area.  This entry is present only if the kernel was built "
"with the B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS> configuration option."
msgstr ""
"Значение «ProtectionKey» (доступно, начиная с Linux 4.9 только на x86) "
"содержит ключ защиты памяти (смотрите B<pkeys>(7)), связанный с областью "
"виртуальной памяти. Этот элемент появляется, только если ядро было собрано с "
"параметром настройки B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS>."

#. type: Plain text
#: man-pages/man5/proc.5:1975
msgid ""
"The \"VmFlags\" line (available since Linux 3.8)  represents the kernel "
"flags associated with the virtual memory area, encoded using the following "
"two-letter codes:"
msgstr ""
"Значение «VmFlags» (доступно, начиная с Linux 3.8) представляет флаги ядра, "
"связанные с виртуальной областью памяти, в виде двухбуквенного кода:"

#. type: Plain text
#: man-pages/man5/proc.5:2004
#, no-wrap
msgid ""
"    rd  - readable\n"
"    wr  - writable\n"
"    ex  - executable\n"
"    sh  - shared\n"
"    mr  - may read\n"
"    mw  - may write\n"
"    me  - may execute\n"
"    ms  - may share\n"
"    gd  - stack segment grows down\n"
"    pf  - pure PFN range\n"
"    dw  - disabled write to the mapped file\n"
"    lo  - pages are locked in memory\n"
"    io  - memory mapped I/O area\n"
"    sr  - sequential read advise provided\n"
"    rr  - random read advise provided\n"
"    dc  - do not copy area on fork\n"
"    de  - do not expand area on remapping\n"
"    ac  - area is accountable\n"
"    nr  - swap space is not reserved for the area\n"
"    ht  - area uses huge tlb pages\n"
"    nl  - non-linear mapping\n"
"    ar  - architecture specific flag\n"
"    dd  - do not include area into core dump\n"
"    sd  - soft-dirty flag\n"
"    mm  - mixed map area\n"
"    hg  - huge page advise flag\n"
"    nh  - no-huge page advise flag\n"
"    mg  - mergeable advise flag\n"
msgstr ""
"    rd  - доступна для чтения\n"
"    wr  - доступна для записи\n"
"    ex  - доступна для исполнения\n"
"    sh  - общая\n"
"    mr  - может читаться\n"
"    mw  - может писаться\n"
"    me  - может исполняться\n"
"    ms  - может быть общей\n"
"    gd  - сегмент стека растёт вниз\n"
"    pf  - чистый диапазон PFN\n"
"    dw  - отключена запись в отображаемый файл\n"
"    lo  - страницы заблокированы в памяти\n"
"    io  - память отображённой области ввода-вывода\n"
"    sr  - предоставляет уведомление для последовательного чтения\n"
"    rr  - предоставляет уведомление для чтения с произвольным доступом\n"
"    dc  - область не копируется при fork\n"
"    de  - область не расширяется при переотображении\n"
"    ac  - область учитывается\n"
"    nr  - для области не зарезервировано пространство подкачки\n"
"    ht  - область использует огромные страницы tlb\n"
"    nl  - нелинейное отображение\n"
"    ar  - флаг, зависящий от архитектуры\n"
"    dd  - область не включается в дамп памяти\n"
"    sd  - флаг несильного загрязнения\n"
"    mm  - область смешанной карты\n"
"    hg  - уведомительный флаг огромной страницы\n"
"    nh  - уведомительный флаг не огромной страницы\n"
"    mg  - уведомительный флаг слияния\n"

#. type: Plain text
#: man-pages/man5/proc.5:2011
msgid ""
"\"ProtectionKey\" field contains the memory protection key (see "
"B<pkeys>(5))  associated with the virtual memory area.  Present only if the "
"kernel was built with the B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS> "
"configuration option. (since Linux 4.6)"
msgstr ""
"Значение «ProtectionKey» содержит ключ защиты памяти (смотрите B<pkeys>(5)), "
"связанный с областью виртуальной памяти. Этот элемент появляется, только "
"если ядро было собрано с параметром настройки "
"B<CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS> (начиная с Linux 4.6)"

#. type: Plain text
#: man-pages/man5/proc.5:2017
msgid ""
"The I</proc/[pid]/smaps> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""
"Файл I</proc/[pid]/smaps> существует только, если включён параметр настройки "
"ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:2017
#, no-wrap
msgid "I</proc/[pid]/stack> (since Linux 2.6.29)"
msgstr "I</proc/[pid]/stack> (начиная с Linux 2.6.29)"

#.  2ec220e27f5040aec1e88901c1b6ea3d135787ad
#. type: Plain text
#: man-pages/man5/proc.5:2025
msgid ""
"This file provides a symbolic trace of the function calls in this process's "
"kernel stack.  This file is provided only if the kernel was built with the "
"B<CONFIG_STACKTRACE> configuration option."
msgstr ""
"Этот файл предоставляет символическую трассировку вызовов функций в стеке "
"ядра для этого процесса. Этот файл есть в системе только, если ядро было "
"собрано с параметром настройки B<CONFIG_STACKTRACE>."

#. type: TP
#: man-pages/man5/proc.5:2030
#, no-wrap
msgid "I</proc/[pid]/stat>"
msgstr "I</proc/[pid]/stat>"

#. type: Plain text
#: man-pages/man5/proc.5:2037
msgid ""
"Status information about the process.  This is used by B<ps>(1).  It is "
"defined in the kernel source file I<fs/proc/array.c>."
msgstr ""
"Информация о состоянии процесса. Она используется командой B<ps>(1). "
"Определяется в файле исходного кода ядра I<fs/proc/array.c>."

#. type: Plain text
#: man-pages/man5/proc.5:2048
msgid ""
"The fields, in order, with their proper B<scanf>(3)  format specifiers, are "
"listed below.  Whether or not certain of these fields display valid "
"information is governed by a ptrace access mode B<PTRACE_MODE_READ_FSCREDS>"
"\\ |\\ B<PTRACE_MODE_NOAUDIT> check (refer to B<ptrace>(2)).  If the check "
"denies access, then the field value is displayed as 0.  The affected fields "
"are indicated with the marking [PT]."
msgstr ""
"Поля в соответствующем порядке с их надлежащими описателями формата "
"B<scanf>(3) перечислены ниже. Корректность информации в этих полях "
"управляется проверкой режима доступа ptrace B<PTRACE_MODE_READ_FSCREDS>\\ |"
"\\ B<PTRACE_MODE_NOAUDIT> (описана в B<ptrace>(2)). Если проверкой доступ "
"запрещён, то значение поля показывается как 0. Затронутые поля отмечены [PT]."

#. type: TP
#: man-pages/man5/proc.5:2050
#, no-wrap
msgid "(1) I<pid> \\ %d"
msgstr "(1) I<pid> \\ %d"

#. type: Plain text
#: man-pages/man5/proc.5:2054
msgid "The process ID."
msgstr "Идентификатор процесса."

#. type: TP
#: man-pages/man5/proc.5:2054
#, no-wrap
msgid "(2) I<comm> \\ %s"
msgstr "(2) I<comm> \\ %s"

#. type: Plain text
#: man-pages/man5/proc.5:2058
msgid ""
"The filename of the executable, in parentheses.  This is visible whether or "
"not the executable is swapped out."
msgstr ""
"Имя исполняемого файла в круглых скобках. Его можно увидеть независимо от "
"того, находится ли исполняемый файл в подкачке или нет."

#. type: TP
#: man-pages/man5/proc.5:2058
#, no-wrap
msgid "(3) I<state> \\ %c"
msgstr "(3) I<state> \\ %c"

#. type: Plain text
#: man-pages/man5/proc.5:2061
msgid "One of the following characters, indicating process state:"
msgstr "Один из следующих символов, описывающих состояние процесса:"

#. type: IP
#: man-pages/man5/proc.5:2062
#, no-wrap
msgid "R"
msgstr "R"

#. type: Plain text
#: man-pages/man5/proc.5:2064
msgid "Running"
msgstr "Выполняется"

#. type: IP
#: man-pages/man5/proc.5:2064
#, no-wrap
msgid "S"
msgstr "S"

#. type: Plain text
#: man-pages/man5/proc.5:2066
msgid "Sleeping in an interruptible wait"
msgstr "Спит, ожидая прерывания"

#. type: IP
#: man-pages/man5/proc.5:2066
#, no-wrap
msgid "D"
msgstr "D"

#. type: Plain text
#: man-pages/man5/proc.5:2069
msgid "Waiting in uninterruptible disk sleep"
msgstr "Ожидает в сне, непрерываемом диском"

#. type: IP
#: man-pages/man5/proc.5:2069
#, no-wrap
msgid "Z"
msgstr "Z"

#. type: Plain text
#: man-pages/man5/proc.5:2071
msgid "Zombie"
msgstr "Зомби"

#. type: IP
#: man-pages/man5/proc.5:2071
#, no-wrap
msgid "T"
msgstr "T"

#. type: Plain text
#: man-pages/man5/proc.5:2073
msgid "Stopped (on a signal) or (before Linux 2.6.33) trace stopped"
msgstr ""
"Остановлен (по сигналу) или остановлен из-за трассировки (до Linux 2.6.33)"

#. type: IP
#: man-pages/man5/proc.5:2073
#, no-wrap
msgid "t"
msgstr "t"

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#. type: Plain text
#: man-pages/man5/proc.5:2076
msgid "Tracing stop (Linux 2.6.33 onward)"
msgstr "Остановлен из-за трассировки (после Linux 2.6.33)"

#. type: IP
#: man-pages/man5/proc.5:2076 man-pages/man5/proc.5:2090
#, no-wrap
msgid "W"
msgstr "W"

#. type: Plain text
#: man-pages/man5/proc.5:2078
msgid "Paging (only before Linux 2.6.0)"
msgstr "Происходит замещение страниц (только до Linux 2.6.0)"

#. type: IP
#: man-pages/man5/proc.5:2078
#, no-wrap
msgid "X"
msgstr "X"

#. type: Plain text
#: man-pages/man5/proc.5:2080
msgid "Dead (from Linux 2.6.0 onward)"
msgstr "Мёртв (с Linux 2.6.0)"

#. type: IP
#: man-pages/man5/proc.5:2080
#, no-wrap
msgid "x"
msgstr "x"

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:2085
msgid "Dead (Linux 2.6.33 to 3.13 only)"
msgstr "Мёртв (только в Linux 2.6.33 по 3.13)"

#. type: IP
#: man-pages/man5/proc.5:2085
#, no-wrap
msgid "K"
msgstr "K"

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:2090
msgid "Wakekill (Linux 2.6.33 to 3.13 only)"
msgstr "Пробудился, чтобы умереть (только в Linux 2.6.33 по 3.13)"

#.  commit 44d90df6b757c59651ddd55f1a84f28132b50d29
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:2095
msgid "Waking (Linux 2.6.33 to 3.13 only)"
msgstr "Пробуждается (только в Linux 2.6.33 по 3.13)"

#. type: IP
#: man-pages/man5/proc.5:2095
#, no-wrap
msgid "P"
msgstr "P"

#.  commit f2530dc71cf0822f90bb63ea4600caaef33a66bb
#.  commit 74e37200de8e9c4e09b70c21c3f13c2071e77457
#. type: Plain text
#: man-pages/man5/proc.5:2100
msgid "Parked (Linux 3.9 to 3.13 only)"
msgstr "Припаркован (только в Linux 3.9 по 3.13)"

#. type: TP
#: man-pages/man5/proc.5:2101
#, no-wrap
msgid "(4) I<ppid> \\ %d"
msgstr "(4) I<ppid> \\ %d"

#. type: Plain text
#: man-pages/man5/proc.5:2104
msgid "The PID of the parent of this process."
msgstr "Идентификатор (PID) родителя данного процесса."

#. type: TP
#: man-pages/man5/proc.5:2104
#, no-wrap
msgid "(5) I<pgrp> \\ %d"
msgstr "(5) I<pgrp> \\ %d"

#. type: Plain text
#: man-pages/man5/proc.5:2107
msgid "The process group ID of the process."
msgstr "Идентификатор группы процесса."

#. type: TP
#: man-pages/man5/proc.5:2107
#, no-wrap
msgid "(6) I<session> \\ %d"
msgstr "(6) I<session> \\ %d"

#. type: Plain text
#: man-pages/man5/proc.5:2110
msgid "The session ID of the process."
msgstr "Идентификатор сеанса процесса."

#. type: TP
#: man-pages/man5/proc.5:2110
#, no-wrap
msgid "(7) I<tty_nr> \\ %d"
msgstr "(7) I<tty_nr> \\ %d"

#. type: Plain text
#: man-pages/man5/proc.5:2116
msgid ""
"The controlling terminal of the process.  (The minor device number is "
"contained in the combination of bits 31 to 20 and 7 to 0; the major device "
"number is in bits 15 to 8.)"
msgstr ""
"Управляющий терминал процесса (младший номер устройства определяется "
"сочетанием бит: c 31 по 20 и с 7 по 0; старший номер устройства расположен в "
"битах с 15 по 8)."

#. type: TP
#: man-pages/man5/proc.5:2116
#, no-wrap
msgid "(8) I<tpgid> \\ %d"
msgstr "(8) I<tpgid> \\ %d"

#.  This field and following, up to and including wchan added 0.99.1
#. type: Plain text
#: man-pages/man5/proc.5:2121
msgid ""
"The ID of the foreground process group of the controlling terminal of the "
"process."
msgstr ""
"Идентификатор группы процесса, которая в настоящий момент владеет "
"управляющим терминалом, к которому подключён данный процесс."

#. type: TP
#: man-pages/man5/proc.5:2121
#, no-wrap
msgid "(9) I<flags> \\ %u"
msgstr "(9) I<flags> \\ %u"

#. type: Plain text
#: man-pages/man5/proc.5:2128
msgid ""
"The kernel flags word of the process.  For bit meanings, see the PF_* "
"defines in the Linux kernel source file I<include/linux/sched.h>.  Details "
"depend on the kernel version."
msgstr ""
"Слово флагов процесса в ядре. Назначение бит определено макросами PF_* в "
"файле I<include/linux/sched.h> исходного ядра Linux. Смысл бит зависит от "
"версии ядра."

#. type: Plain text
#: man-pages/man5/proc.5:2130 man-pages/man5/proc.5:2232
msgid "The format for this field was %lu before Linux 2.6."
msgstr "Формат данного поля был %lu до Linux 2.6."

#. type: TP
#: man-pages/man5/proc.5:2130
#, no-wrap
msgid "(10) I<minflt> \\ %lu"
msgstr "(10) I<minflt> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2134
msgid ""
"The number of minor faults the process has made which have not required "
"loading a memory page from disk."
msgstr ""
"Количество незначительных промахов процесса, которые не потребовали загрузки "
"страницы памяти с диска."

#. type: TP
#: man-pages/man5/proc.5:2134
#, no-wrap
msgid "(11) I<cminflt> \\ %lu"
msgstr "(11) I<cminflt> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2138
msgid ""
"The number of minor faults that the process's waited-for children have made."
msgstr ""
"Количество незначительных промахов процесса, которые возникли при ожидании "
"окончания работы процессов-потомков."

#. type: TP
#: man-pages/man5/proc.5:2138
#, no-wrap
msgid "(12) I<majflt> \\ %lu"
msgstr "(12) I<majflt> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2142
msgid ""
"The number of major faults the process has made which have required loading "
"a memory page from disk."
msgstr ""
"Количество значительных промахов процесса, которые потребовали загрузки "
"страницы памяти с диска."

#. type: TP
#: man-pages/man5/proc.5:2142
#, no-wrap
msgid "(13) I<cmajflt> \\ %lu"
msgstr "(13) I<cmajflt> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2146
msgid ""
"The number of major faults that the process's waited-for children have made."
msgstr ""
"Количество значительных промахов процесса, которые возникли при ожидании "
"окончания работы процессов-потомков."

#. type: TP
#: man-pages/man5/proc.5:2146
#, no-wrap
msgid "(14) I<utime> \\ %lu"
msgstr "(14) I<utime> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2155
msgid ""
"Amount of time that this process has been scheduled in user mode, measured "
"in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>).  This includes guest "
"time, I<guest_time> (time spent running a virtual CPU, see below), so that "
"applications that are not aware of the guest time field do not lose that "
"time from their calculations."
msgstr ""
"Количество времени, которое было запланировано для работы процесса в "
"пользовательском режиме, измеряется в тиках (поделённое на "
"I<sysconf(_SC_CLK_TCK)>). Сюда включено гостевое время, I<guest_time> "
"(время, потраченное на работу виртуального ЦП, см. далее), так что "
"приложения, которые не учитывают гостевое поле, не потеряют его при "
"вычислениях."

#. type: TP
#: man-pages/man5/proc.5:2155
#, no-wrap
msgid "(15) I<stime> \\ %lu"
msgstr "(15) I<stime> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2160
msgid ""
"Amount of time that this process has been scheduled in kernel mode, measured "
"in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>)."
msgstr ""
"Количество времени, которое было запланировано для работы процесса в режиме "
"ядра, измеряется в тиках (поделённое на I<sysconf(_SC_CLK_TCK)>)."

#. type: TP
#: man-pages/man5/proc.5:2160
#, no-wrap
msgid "(16) I<cutime> \\ %ld"
msgstr "(16) I<cutime> \\ %ld"

#. type: Plain text
#: man-pages/man5/proc.5:2170
msgid ""
"Amount of time that this process's waited-for children have been scheduled "
"in user mode, measured in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>).  "
"(See also B<times>(2).)  This includes guest time, I<cguest_time> (time "
"spent running a virtual CPU, see below)."
msgstr ""
"Количество времени, которое было запланировано для работы процесса в "
"пользовательском режиме для ожидания окончания работы процессов-потомков, "
"измеряется в тиках (поделённое на I<sysconf(_SC_CLK_TCK)> (см). также "
"B<times>(2)). Сюда включено гостевое время, I<cguest_time> (время, "
"потраченное на работу виртуального ЦП, см. далее)."

#. type: TP
#: man-pages/man5/proc.5:2170
#, no-wrap
msgid "(17) I<cstime> \\ %ld"
msgstr "(17) I<cstime> \\ %ld"

#. type: Plain text
#: man-pages/man5/proc.5:2176
msgid ""
"Amount of time that this process's waited-for children have been scheduled "
"in kernel mode, measured in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>)."
msgstr ""
"Количество времени, которое было запланировано для работы процесса в режиме "
"ядра для ожидания окончания работы процессов-потомков, измеряется в тиках "
"(поделённое на I<sysconf(_SC_CLK_TCK)>)."

#. type: TP
#: man-pages/man5/proc.5:2176
#, no-wrap
msgid "(18) I<priority> \\ %ld"
msgstr "(18) I<priority> \\ %ld"

#. type: Plain text
#: man-pages/man5/proc.5:2193
msgid ""
"(Explanation for Linux 2.6)  For processes running a real-time scheduling "
"policy (I<policy> below; see B<sched_setscheduler>(2)), this is the negated "
"scheduling priority, minus one; that is, a number in the range -2 to -100, "
"corresponding to real-time priorities 1 to 99.  For processes running under "
"a non-real-time scheduling policy, this is the raw nice value "
"(B<setpriority>(2))  as represented in the kernel.  The kernel stores nice "
"values as numbers in the range 0 (high) to 39 (low), corresponding to the "
"user-visible nice range of -20 to 19."
msgstr ""
"(Объяснение относится к Linux 2.6) Для процессов, работающих согласно "
"политике планирования в реальном времени (I<policy> далее; см. "
"B<sched_setscheduler>(2)), это значение задаёт приоритет при планировании за "
"вычетом 1; то есть число в диапазоне от -2 до -100 соответствует приоритетам "
"реального времени от 1 до 99. Для процессов, работающих без политики "
"планирования в реальном времени, это не изменённое значение любезности "
"(B<setpriority>(2)) в том же виде в каком оно представлено в ядре. Ядро "
"хранит значения любезности в виде чисел в диапазоне от 0 (высокое) до 39 "
"(низкое), что соответствует диапазону пользователя от -20 до 19."

#.  And back in kernel 1.2 days things were different again.
#. type: Plain text
#: man-pages/man5/proc.5:2197
msgid ""
"Before Linux 2.6, this was a scaled value based on the scheduler weighting "
"given to this process."
msgstr ""
"До Linux 2.6 это была пересчитанная величина на основе весов планировщика "
"для определённого процесса."

#. type: TP
#: man-pages/man5/proc.5:2197
#, no-wrap
msgid "(19) I<nice> \\ %ld"
msgstr "(19) I<nice> \\ %ld"

#.  Back in kernel 1.2 days things were different.
#.  .TP
#.  \fIcounter\fP %ld
#.  The current maximum size in jiffies of the process's next timeslice,
#.  or what is currently left of its current timeslice, if it is the
#.  currently running process.
#.  .TP
#.  \fItimeout\fP %u
#.  The time in jiffies of the process's next timeout.
#.  timeout was removed sometime around 2.1/2.2
#. type: Plain text
#: man-pages/man5/proc.5:2212
msgid ""
"The nice value (see B<setpriority>(2)), a value in the range 19 (low "
"priority) to -20 (high priority)."
msgstr ""
"Значение любезности (смотрите B<setpriority>(2)) задаётся числом в диапазоне "
"от 19(низкий приоритет) до -20 (высокий приоритет)."

#. type: TP
#: man-pages/man5/proc.5:2212
#, no-wrap
msgid "(20) I<num_threads> \\ %ld"
msgstr "(20) I<num_threads> \\ %ld"

#. type: Plain text
#: man-pages/man5/proc.5:2217
msgid ""
"Number of threads in this process (since Linux 2.6).  Before kernel 2.6, "
"this field was hard coded to 0 as a placeholder for an earlier removed field."
msgstr ""
"Количество нитей в этом процессе (начиная с Linux 2.6). До ядер ветви 2.6 "
"это поле всегда имело значение 0 в качестве заменителя ранее удалённых полей."

#. type: TP
#: man-pages/man5/proc.5:2217
#, no-wrap
msgid "(21) I<itrealvalue> \\ %ld"
msgstr "(21) I<itrealvalue> \\ %ld"

#. type: Plain text
#: man-pages/man5/proc.5:2224
msgid ""
"The time in jiffies before the next B<SIGALRM> is sent to the process due to "
"an interval timer.  Since kernel 2.6.17, this field is no longer maintained, "
"and is hard coded as 0."
msgstr ""
"Время в мигах (jiffies) перед следующей посылкой процессу сигнала B<SIGALRM> "
"при срабатывании таймера интервала. Начиная с версии 2.6.17 это поле больше "
"не обновляется и всегда имеет значение 0."

#. type: TP
#: man-pages/man5/proc.5:2224
#, no-wrap
msgid "(22) I<starttime> \\ %llu"
msgstr "(22) I<starttime> \\ %llu"

#. type: Plain text
#: man-pages/man5/proc.5:2230
msgid ""
"The time the process started after system boot.  In kernels before Linux "
"2.6, this value was expressed in jiffies.  Since Linux 2.6, the value is "
"expressed in clock ticks (divide by I<sysconf(_SC_CLK_TCK)>)."
msgstr ""
"Время до запуска процесса от момента начальной загрузки системы. В ядрах до "
"Linux 2.6, это значение выражалось в мигах (jiffies). Начиная с Linux 2.6, "
"значение выражается в тиках часов (clock ticks) (поделённое на "
"I<sysconf(_SC_CLK_TCK)>)."

#. type: TP
#: man-pages/man5/proc.5:2232
#, no-wrap
msgid "(23) I<vsize> \\ %lu"
msgstr "(23) I<vsize> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2235
msgid "Virtual memory size in bytes."
msgstr "Размер виртуальной памяти в байтах."

#. type: TP
#: man-pages/man5/proc.5:2235
#, no-wrap
msgid "(24) I<rss> \\ %ld"
msgstr "(24) I<rss> \\ %ld"

#. type: Plain text
#: man-pages/man5/proc.5:2242
msgid ""
"Resident Set Size: number of pages the process has in real memory.  This is "
"just the pages which count toward text, data, or stack space.  This does not "
"include pages which have not been demand-loaded in, or which are swapped out."
msgstr ""
"Резидентный размер: количество страниц, которое занимает процесс в реальной "
"памяти. Это только те страницы, которые заняты кодом, данными и "
"пространством стека. Сюда не включаются страницы, которые не были загружены "
"по требованию или которые находятся в пространстве подкачки."

#. type: TP
#: man-pages/man5/proc.5:2242
#, no-wrap
msgid "(25) I<rsslim> \\ %lu"
msgstr "(25) I<rsslim> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2249
msgid ""
"Current soft limit in bytes on the rss of the process; see the description "
"of B<RLIMIT_RSS> in B<getrlimit>(2)."
msgstr ""
"Текущее мягкое ограничение rss процесса в байтах; смотрите описание "
"B<RLIMIT_RSS> в B<getrlimit>(2)."

#. type: TP
#: man-pages/man5/proc.5:2249
#, no-wrap
msgid "(26) I<startcode> \\ %lu \\ [PT]"
msgstr "(26) I<startcode> \\ %lu \\ [PT]"

#. type: Plain text
#: man-pages/man5/proc.5:2252
msgid "The address above which program text can run."
msgstr "Адрес начала сегмента исполняемого кода программы."

#. type: TP
#: man-pages/man5/proc.5:2252
#, no-wrap
msgid "(27) I<endcode> \\ %lu \\ [PT]"
msgstr "(27) I<endcode> \\ %lu \\ [PT]"

#. type: Plain text
#: man-pages/man5/proc.5:2255
msgid "The address below which program text can run."
msgstr "Адрес конца сегмента исполняемого кода программы."

#. type: TP
#: man-pages/man5/proc.5:2255
#, no-wrap
msgid "(28) I<startstack> \\ %lu \\ [PT]"
msgstr "(28) I<startstack> \\ %lu \\ [PT]"

#. type: Plain text
#: man-pages/man5/proc.5:2258
msgid "The address of the start (i.e., bottom) of the stack."
msgstr "Адрес начала (то есть низ) стека."

#. type: TP
#: man-pages/man5/proc.5:2258
#, no-wrap
msgid "(29) I<kstkesp> \\ %lu \\ [PT]"
msgstr "(29) I<kstkesp> \\ %lu \\ [PT]"

#. type: Plain text
#: man-pages/man5/proc.5:2262
msgid ""
"The current value of ESP (stack pointer), as found in the kernel stack page "
"for the process."
msgstr ""
"Текущее значение ESP (указателя стека) процесса, хранящееся в странице стека "
"ядра."

#. type: TP
#: man-pages/man5/proc.5:2262
#, no-wrap
msgid "(30) I<kstkeip> \\ %lu \\ [PT]"
msgstr "(30) I<kstkeip> \\ %lu \\ [PT]"

#. type: Plain text
#: man-pages/man5/proc.5:2265
msgid "The current EIP (instruction pointer)."
msgstr "Текущее значение EIP (указатель инструкций)."

#. type: TP
#: man-pages/man5/proc.5:2265
#, no-wrap
msgid "(31) I<signal> \\ %lu"
msgstr "(31) I<signal> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2271
msgid ""
"The bitmap of pending signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use I</proc/"
"[pid]/status> instead."
msgstr ""
"Карта ожидающих сигналов, отображается как число в десятичной системе "
"счисления. Устарело, так как не предоставляет информации о сигналах "
"реального времени; вместо неё используйте I</proc/[pid]/status>."

#. type: TP
#: man-pages/man5/proc.5:2271
#, no-wrap
msgid "(32) I<blocked> \\ %lu"
msgstr "(32) I<blocked> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2277
msgid ""
"The bitmap of blocked signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use I</proc/"
"[pid]/status> instead."
msgstr ""
"Карта блокированных сигналов, отображается как число в десятичной системе "
"счисления. Устарело, так как не предоставляет информации о сигналах "
"реального времени; вместо неё используйте I</proc/[pid]/status>."

#. type: TP
#: man-pages/man5/proc.5:2277
#, no-wrap
msgid "(33) I<sigignore> \\ %lu"
msgstr "(33) I<sigignore> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2283
msgid ""
"The bitmap of ignored signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use I</proc/"
"[pid]/status> instead."
msgstr ""
"Карта игнорированных сигналов, отображается как число в десятичной системе "
"счисления. Устарело, так как не предоставляет информации о сигналах "
"реального времени; вместо неё используйте I</proc/[pid]/status>."

#. type: TP
#: man-pages/man5/proc.5:2283
#, no-wrap
msgid "(34) I<sigcatch> \\ %lu"
msgstr "(34) I<sigcatch> \\ %lu"

#. type: Plain text
#: man-pages/man5/proc.5:2289
msgid ""
"The bitmap of caught signals, displayed as a decimal number.  Obsolete, "
"because it does not provide information on real-time signals; use I</proc/"
"[pid]/status> instead."
msgstr ""
"Карта перехваченных сигналов, отображается как число в десятичной системе "
"счисления. Устарело, так как не предоставляет информации о сигналах "
"реального времени; вместо неё используйте I</proc/[pid]/status>."

#. type: TP
#: man-pages/man5/proc.5:2289
#, no-wrap
msgid "(35) I<wchan> \\ %lu \\ [PT]"
msgstr "(35) I<wchan> \\ %lu \\ [PT]"

#. type: Plain text
#: man-pages/man5/proc.5:2295
msgid ""
"This is the \"channel\" in which the process is waiting.  It is the address "
"of a location in the kernel where the process is sleeping.  The "
"corresponding symbolic name can be found in I</proc/[pid]/wchan>."
msgstr ""
"Это «канал», в котором ожидает процесс. Он является адресом расположения в "
"ядре, где спит процесс. Соответствующее символическое имя можно найти в I</"
"proc/[pid]/wchan>."

#. type: TP
#: man-pages/man5/proc.5:2295
#, no-wrap
msgid "(36) I<nswap> \\ %lu"
msgstr "(36) I<nswap> \\ %lu"

#.  nswap was added in 2.0
#. type: Plain text
#: man-pages/man5/proc.5:2299
msgid "Number of pages swapped (not maintained)."
msgstr "() Количество страниц в подкачке (не сопровождается)."

#. type: TP
#: man-pages/man5/proc.5:2299
#, no-wrap
msgid "(37) I<cnswap> \\ %lu"
msgstr "(37) I<cnswap> \\ %lu"

#.  cnswap was added in 2.0
#. type: Plain text
#: man-pages/man5/proc.5:2303
msgid "Cumulative I<nswap> for child processes (not maintained)."
msgstr ""
"() Суммарное значение I<nswap> для процессов-потомков (не сопровождается)."

#. type: TP
#: man-pages/man5/proc.5:2303
#, no-wrap
msgid "(38) I<exit_signal> \\ %d \\ (since Linux 2.1.22)"
msgstr "(38) I<exit_signal> \\ %d \\ (since Linux 2.1.22)"

#. type: Plain text
#: man-pages/man5/proc.5:2306
msgid "Signal to be sent to parent when we die."
msgstr "Сигнал, который будет послан родителю, когда процесс завершит работу."

#. type: TP
#: man-pages/man5/proc.5:2306
#, no-wrap
msgid "(39) I<processor> \\ %d \\ (since Linux 2.2.8)"
msgstr "(39) I<processor> \\ %d \\ (начиная с Linux 2.2.8)"

#. type: Plain text
#: man-pages/man5/proc.5:2309
msgid "CPU number last executed on."
msgstr "Номер процессора, на котором последний раз выполнялся процесс."

#. type: TP
#: man-pages/man5/proc.5:2309
#, no-wrap
msgid "(40) I<rt_priority> \\ %u \\ (since Linux 2.5.19)"
msgstr "(40) I<rt_priority> \\ %u \\ (начиная с Linux 2.5.19)"

#. type: Plain text
#: man-pages/man5/proc.5:2315
msgid ""
"Real-time scheduling priority, a number in the range 1 to 99 for processes "
"scheduled under a real-time policy, or 0, for non-real-time processes (see "
"B<sched_setscheduler>(2))."
msgstr ""
"Приоритет выполнения в реальном времени, число из диапазона от 1 до 99 для "
"процессов запланированных выполняться согласно политике реального времени "
"или 0 для процессов, выполняющихся не в реальном времени (см. "
"B<sched_setscheduler>(2))."

#. type: TP
#: man-pages/man5/proc.5:2315
#, no-wrap
msgid "(41) I<policy> \\ %u \\ (since Linux 2.5.19)"
msgstr "(41) I<policy> \\ %u \\ (начиная с Linux 2.5.19)"

#. type: Plain text
#: man-pages/man5/proc.5:2321
msgid ""
"Scheduling policy (see B<sched_setscheduler>(2)).  Decode using the SCHED_* "
"constants in I<linux/sched.h>."
msgstr ""
"Политика планирования (смотрите B<sched_setscheduler>(2)). Декодируется с "
"помощью констант SCHED_* из I<linux/sched.h>."

#. type: Plain text
#: man-pages/man5/proc.5:2323
msgid "The format for this field was %lu before Linux 2.6.22."
msgstr "Формат данного поля был %lu до Linux 2.6.22."

#. type: TP
#: man-pages/man5/proc.5:2323
#, no-wrap
msgid "(42) I<delayacct_blkio_ticks> \\ %llu \\ (since Linux 2.6.18)"
msgstr "(42) I<delayacct_blkio_ticks> \\ %llu \\ (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:2326
msgid "Aggregated block I/O delays, measured in clock ticks (centiseconds)."
msgstr ""
"Суммарная задержка блочного ввода-вывода, измеряется в тиках (сотых долях "
"секунды)."

#. type: TP
#: man-pages/man5/proc.5:2326
#, no-wrap
msgid "(43) I<guest_time> \\ %lu \\ (since Linux 2.6.24)"
msgstr "(43) I<guest_time> \\ %lu \\ (начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:2331
msgid ""
"Guest time of the process (time spent running a virtual CPU for a guest "
"operating system), measured in clock ticks (divide by "
"I<sysconf(_SC_CLK_TCK)>)."
msgstr ""
"Гостевое время процесса (время, потраченное на работу виртуального ЦП "
"гостевой операционной системы), измеряется в тиках (поделённых на "
"I<sysconf(_SC_CLK_TCK)>)."

#. type: TP
#: man-pages/man5/proc.5:2331
#, no-wrap
msgid "(44) I<cguest_time> \\ %ld \\ (since Linux 2.6.24)"
msgstr "(44) I<cguest_time> \\ %ld \\ (начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:2335
msgid ""
"Guest time of the process's children, measured in clock ticks (divide by "
"I<sysconf(_SC_CLK_TCK)>)."
msgstr ""
"Гостевое время потомка процесса, измеряется в тиках (поделённых на "
"I<sysconf(_SC_CLK_TCK)>)."

#. type: TP
#: man-pages/man5/proc.5:2335
#, no-wrap
msgid "(45) I<start_data> \\ %lu \\ (since Linux 3.3) \\ [PT]"
msgstr "(45) I<start_data> \\ %lu \\ (начиная с Linux 3.3) \\ [PT]"

#.  commit b3f7f573a20081910e34e99cbc91831f4f02f1ff
#. type: Plain text
#: man-pages/man5/proc.5:2340
msgid ""
"Address above which program initialized and uninitialized (BSS) data are "
"placed."
msgstr ""
"Адрес, выше которого располагаются инициализированные и не "
"инициализированные (BSS) данные."

#. type: TP
#: man-pages/man5/proc.5:2340
#, no-wrap
msgid "(46) I<end_data> \\ %lu \\ (since Linux 3.3) \\ [PT]"
msgstr "(46) I<end_data> \\ %lu \\ (начиная с Linux 3.3) \\ [PT]"

#.  commit b3f7f573a20081910e34e99cbc91831f4f02f1ff
#. type: Plain text
#: man-pages/man5/proc.5:2345
msgid ""
"Address below which program initialized and uninitialized (BSS) data are "
"placed."
msgstr ""
"Адрес, ниже которого располагаются инициализированные и не "
"инициализированные (BSS) данные."

#. type: TP
#: man-pages/man5/proc.5:2345
#, no-wrap
msgid "(47) I<start_brk> \\ %lu \\ (since Linux 3.3) \\ [PT]"
msgstr "(47) I<start_brk> \\ %lu \\ (начиная с Linux 3.3) \\ [PT]"

#.  commit b3f7f573a20081910e34e99cbc91831f4f02f1ff
#. type: Plain text
#: man-pages/man5/proc.5:2350
msgid "Address above which program heap can be expanded with B<brk>(2)."
msgstr ""
"Адрес, выше которого программа может расширять кучу с помощью B<brk>(2)."

#. type: TP
#: man-pages/man5/proc.5:2350
#, no-wrap
msgid "(48) I<arg_start> \\ %lu \\ (since Linux 3.5) \\ [PT]"
msgstr "(48) I<arg_start> \\ %lu \\ (начиная с Linux 3.5) \\ [PT]"

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:2356
msgid ""
"Address above which program command-line arguments (I<argv>)  are placed."
msgstr ""
"Адрес, выше которого располагаются аргументы командной строки программы "
"(I<argv>)."

#. type: TP
#: man-pages/man5/proc.5:2356
#, no-wrap
msgid "(49) I<arg_end> \\ %lu \\ (since Linux 3.5) \\ [PT]"
msgstr "(49) I<arg_end> \\ %lu \\ (начиная с Linux 3.5) \\ [PT]"

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:2362
msgid "Address below program command-line arguments (I<argv>)  are placed."
msgstr ""
"Адрес, ниже которого располагаются аргументы командной строки программы "
"(I<argv>)."

#. type: TP
#: man-pages/man5/proc.5:2362
#, no-wrap
msgid "(50) I<env_start> \\ %lu \\ (since Linux 3.5) \\ [PT]"
msgstr "(50) I<env_start> \\ %lu \\ (начиная с Linux 3.5) \\ [PT]"

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:2366
msgid "Address above which program environment is placed."
msgstr "Адрес, выше которого располагается окружение программы."

#. type: TP
#: man-pages/man5/proc.5:2366
#, no-wrap
msgid "(51) I<env_end> \\ %lu \\ (since Linux 3.5) \\ [PT]"
msgstr "(51) I<env_end> \\ %lu \\ (начиная с Linux 3.5) \\ [PT]"

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:2370
msgid "Address below which program environment is placed."
msgstr "Адрес, ниже которого располагается окружение программы."

#. type: TP
#: man-pages/man5/proc.5:2370
#, no-wrap
msgid "(52) I<exit_code> \\ %d \\ (since Linux 3.5) \\ [PT]"
msgstr "(52) I<exit_code> \\ %d \\ (начиная с Linux 3.5) \\ [PT]"

#.  commit 5b172087f99189416d5f47fd7ab5e6fb762a9ba3
#. type: Plain text
#: man-pages/man5/proc.5:2375
msgid "The thread's exit status in the form reported by B<waitpid>(2)."
msgstr "Состояние завершения нити в виде, выдаваемом B<waitpid>(2)."

#. type: TP
#: man-pages/man5/proc.5:2376
#, no-wrap
msgid "I</proc/[pid]/statm>"
msgstr "I</proc/[pid]/statm>"

#. type: Plain text
#: man-pages/man5/proc.5:2380
msgid ""
"Provides information about memory usage, measured in pages.  The columns are:"
msgstr ""
"Предоставляет информацию об использовании памяти, измеряется в страницах. "
"Колонки:"

#.  (not including libs; broken, includes data segment)
#.  (including libs; broken, includes library text)
#. type: Plain text
#: man-pages/man5/proc.5:2395
#, no-wrap
msgid ""
"size       (1) total program size\n"
"           (same as VmSize in I</proc/[pid]/status>)\n"
"resident   (2) resident set size\n"
"           (same as VmRSS in I</proc/[pid]/status>)\n"
"shared     (3) number of resident shared pages (i.e., backed by a file)\n"
"           (same as RssFile+RssShmem in I</proc/[pid]/status>)\n"
"text       (4) text (code)\n"
"lib        (5) library (unused since Linux 2.6; always 0)\n"
"data       (6) data + stack\n"
"dt         (7) dirty pages (unused since Linux 2.6; always 0)\n"
msgstr ""
"size       (1) полный размер программы\n"
"           (тоже что и VmSize в I</proc/[pid]/status>)\n"
"resident   (2) размер резидентной части\n"
"           (тоже что и VmRSS в I</proc/[pid]/status>)\n"
"shared     (3) количество резидентных общих страниц (т. е., отражаемых файлом)\n"
"           (тоже что и RssFile+RssShmem в I</proc/[pid]/status>)\n"
"text       (4) текст программы (код)\n"
"lib        (5) библиотека (не используется начиная с Linux 2.6; всегда 0)\n"
"data       (6) данные + стек\n"
"dt         (7) недостоверные страницы (не используется начиная\n"
"           с Linux 2.6; всегда 0)\n"

#. type: TP
#: man-pages/man5/proc.5:2397
#, no-wrap
msgid "I</proc/[pid]/status>"
msgstr "I</proc/[pid]/status>"

#. type: Plain text
#: man-pages/man5/proc.5:2405
msgid ""
"Provides much of the information in I</proc/[pid]/stat> and I</proc/[pid]/"
"statm> in a format that's easier for humans to parse.  Here's an example:"
msgstr ""
"В основном, предоставляет информацию из I</proc/[pid]/stat> и I</proc/[pid]/"
"statm> в более лёгком для прочтения человеком формате. Пример:"

#. type: Plain text
#: man-pages/man5/proc.5:2464
#, no-wrap
msgid ""
"$B< cat /proc/$$/status>\n"
"Name:   bash\n"
"Umask:  0022\n"
"State:  S (sleeping)\n"
"Tgid:   17248\n"
"Ngid:   0\n"
"Pid:    17248\n"
"PPid:   17200\n"
"TracerPid:      0\n"
"Uid:    1000    1000    1000    1000\n"
"Gid:    100     100     100     100\n"
"FDSize: 256\n"
"Groups: 16 33 100\n"
"NStgid: 17248\n"
"NSpid:  17248\n"
"NSpgid: 17248\n"
"NSsid:  17200\n"
"VmPeak:\t  131168 kB\n"
"VmSize:\t  131168 kB\n"
"VmLck:\t       0 kB\n"
"VmPin:\t       0 kB\n"
"VmHWM:\t   13484 kB\n"
"VmRSS:\t   13484 kB\n"
"RssAnon:\t   10264 kB\n"
"RssFile:\t    3220 kB\n"
"RssShmem:\t       0 kB\n"
"VmData:\t   10332 kB\n"
"VmStk:\t     136 kB\n"
"VmExe:\t     992 kB\n"
"VmLib:\t    2104 kB\n"
"VmPTE:\t      76 kB\n"
"VmPMD:\t      12 kB\n"
"VmSwap:\t       0 kB\n"
"HugetlbPages:          0 kB\t\t# 4.4\n"
"CoreDumping:\t0                       # 4.15\n"
"Threads:        1\n"
"SigQ:   0/3067\n"
"SigPnd: 0000000000000000\n"
"ShdPnd: 0000000000000000\n"
"SigBlk: 0000000000010000\n"
"SigIgn: 0000000000384004\n"
"SigCgt: 000000004b813efb\n"
"CapInh: 0000000000000000\n"
"CapPrm: 0000000000000000\n"
"CapEff: 0000000000000000\n"
"CapBnd: ffffffffffffffff\n"
"CapAmb:\t0000000000000000\n"
"NoNewPrivs:     0\n"
"Seccomp:        0\n"
"Speculation_Store_Bypass:       vulnerable\n"
"Cpus_allowed:   00000001\n"
"Cpus_allowed_list:      0\n"
"Mems_allowed:   1\n"
"Mems_allowed_list:      0\n"
"voluntary_ctxt_switches:        150\n"
"nonvoluntary_ctxt_switches:     545\n"
msgstr ""
"$B< cat /proc/$$/status>\n"
"Name:   bash\n"
"Umask:  0022\n"
"State:  S (sleeping)\n"
"Tgid:   17248\n"
"Ngid:   0\n"
"Pid:    17248\n"
"PPid:   17200\n"
"TracerPid:      0\n"
"Uid:    1000    1000    1000    1000\n"
"Gid:    100     100     100     100\n"
"FDSize: 256\n"
"Groups: 16 33 100\n"
"NStgid: 17248\n"
"NSpid:  17248\n"
"NSpgid: 17248\n"
"NSsid:  17200\n"
"VmPeak:\t  131168 kB\n"
"VmSize:\t  131168 kB\n"
"VmLck:\t       0 kB\n"
"VmPin:\t       0 kB\n"
"VmHWM:\t   13484 kB\n"
"VmRSS:\t   13484 kB\n"
"RssAnon:\t   10264 kB\n"
"RssFile:\t    3220 kB\n"
"RssShmem:\t       0 kB\n"
"VmData:\t   10332 kB\n"
"VmStk:\t     136 kB\n"
"VmExe:\t     992 kB\n"
"VmLib:\t    2104 kB\n"
"VmPTE:\t      76 kB\n"
"VmPMD:\t      12 kB\n"
"VmSwap:\t       0 kB\n"
"HugetlbPages:          0 kB\t\t# 4.4\n"
"CoreDumping:\t0                       # 4.15\n"
"Threads:        1\n"
"SigQ:   0/3067\n"
"SigPnd: 0000000000000000\n"
"ShdPnd: 0000000000000000\n"
"SigBlk: 0000000000010000\n"
"SigIgn: 0000000000384004\n"
"SigCgt: 000000004b813efb\n"
"CapInh: 0000000000000000\n"
"CapPrm: 0000000000000000\n"
"CapEff: 0000000000000000\n"
"CapBnd: ffffffffffffffff\n"
"CapAmb:\t0000000000000000\n"
"NoNewPrivs:     0\n"
"Seccomp:        0\n"
"Speculation_Store_Bypass:       vulnerable\n"
"Cpus_allowed:   00000001\n"
"Cpus_allowed_list:      0\n"
"Mems_allowed:   1\n"
"Mems_allowed_list:      0\n"
"voluntary_ctxt_switches:        150\n"
"nonvoluntary_ctxt_switches:     545\n"

#. type: Plain text
#: man-pages/man5/proc.5:2472
msgid "I<Name>: Command run by this process."
msgstr "I<Name>: Команда, выполняемая этим процессом."

#. type: Plain text
#: man-pages/man5/proc.5:2477
msgid ""
"I<Umask>: Process umask, expressed in octal with a leading zero; see "
"B<umask>(2).  (Since Linux 4.7.)"
msgstr ""
"I<Umask>: umask процесса, выражается восьмеричным числом с начальным нулём; "
"смотрите B<umask>(2) (начиная с Linux 4.7)."

#. type: Plain text
#: man-pages/man5/proc.5:2489
msgid ""
"I<State>: Current state of the process.  One of \"R (running)\", \"S "
"(sleeping)\", \"D (disk sleep)\", \"T (stopped)\", \"T (tracing stop)\", \"Z "
"(zombie)\", or \"X (dead)\"."
msgstr ""
"I<State>: Текущее состояние процесса. Может быть \"R (работает)\", \"S "
"(спит)\", \"D (спит на диске)\", \"T (остановлен)\", \"T (остановлен "
"трассировкой)\", \"Z (зомби)\" или \"X (завершён)\"."

#. type: Plain text
#: man-pages/man5/proc.5:2492
msgid "I<Tgid>: Thread group ID (i.e., Process ID)."
msgstr "I<Tgid>: Групповой ID нити (т.е., ID процесса)."

#. type: Plain text
#: man-pages/man5/proc.5:2495
msgid "I<Ngid>: NUMA group ID (0 if none; since Linux 3.13)."
msgstr ""
"I<Ngid>: идентификатор группы NUMA (0, если нет; начиная с Linux 3.13)."

#. type: Plain text
#: man-pages/man5/proc.5:2499
msgid "I<Pid>: Thread ID (see B<gettid>(2))."
msgstr "I<Pid>: ID нити (см. B<gettid>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:2502
msgid "I<PPid>: PID of parent process."
msgstr "I<PPid>: PID родительского процесса."

#. type: Plain text
#: man-pages/man5/proc.5:2505
msgid ""
"I<TracerPid>: PID of process tracing this process (0 if not being traced)."
msgstr ""
"I<TracerPid>: PID процесса, который выполняет трассировку данного процесса "
"(0, если трассировки нет)."

#. type: Plain text
#: man-pages/man5/proc.5:2508
msgid "I<Uid>, I<Gid>: Real, effective, saved set, and filesystem UIDs (GIDs)."
msgstr ""
"I<Uid>, I<Gid>: Реальный, эффективный, сохранённый и используемый в файловой "
"системе UID (GID)."

#. type: Plain text
#: man-pages/man5/proc.5:2511
msgid "I<FDSize>: Number of file descriptor slots currently allocated."
msgstr ""
"I<FDSize>: Количество слотов файловых дескрипторов выделенных в данный "
"момент."

#. type: Plain text
#: man-pages/man5/proc.5:2514
msgid "I<Groups>: Supplementary group list."
msgstr "I<Groups>: Список дополнительных групп."

#.  commit e4bc33245124db69b74a6d853ac76c2976f472d5
#. type: Plain text
#: man-pages/man5/proc.5:2525
msgid ""
"I<NStgid>: Thread group ID (i.e., PID) in each of the PID namespaces of "
"which I<[pid]> is a member.  The leftmost entry shows the value with respect "
"to the PID namespace of the process that mounted this procfs (or the root "
"namespace if mounted by the kernel), followed by the value in successively "
"nested inner namespaces.  (Since Linux 4.1.)"
msgstr ""
"I<NStgid>: Идентификатор группы нитей (т. е., PID) в каждом пространстве "
"имён PID, в которых I<[pid]> является членом. Крайняя левая запись "
"показывает значение в соответствии с пространством имён PID процесса, для "
"которого смонтирован этот procfs (или корневое пространство имён, если "
"смонтировало ядро), далее идёт значение в последующих вложенных внутрь "
"пространств имён (начиная с Linux 4.1)."

#. type: Plain text
#: man-pages/man5/proc.5:2533
msgid ""
"I<NSpid>: Thread ID in each of the PID namespaces of which I<[pid]> is a "
"member.  The fields are ordered as for I<NStgid>.  (Since Linux 4.1.)"
msgstr ""
"I<NSpid>: Идентификатор нити в каждом пространстве имён PID, в которых "
"I<[pid]> является членом. Поля представлены в том же порядке что и в "
"I<NStgid> (начиная с Linux 4.1)."

#. type: Plain text
#: man-pages/man5/proc.5:2541
msgid ""
"I<NSpgid>: Process group ID in each of the PID namespaces of which I<[pid]> "
"is a member.  The fields are ordered as for I<NStgid>.  (Since Linux 4.1.)"
msgstr ""
"I<NSpgid>: Идентификатор группы процессов в каждом пространстве имён PID, в "
"которых I<[pid]> является членом. Поля представлены в том же порядке что и в "
"I<NStgid> (начиная с Linux 4.1)."

#. type: Plain text
#: man-pages/man5/proc.5:2550
msgid ""
"I<NSsid>: descendant namespace session ID hierarchy Session ID in each of "
"the PID namespaces of which I<[pid]> is a member.  The fields are ordered as "
"for I<NStgid>.  (Since Linux 4.1.)"
msgstr ""
"I<NSsid>: идентификатор сеанса пространства имён потомка в иерархии "
"идентификаторов сеанса в каждом пространстве имён PID, в которых I<[pid]> "
"является членом. Поля представлены в том же порядке что и в I<NStgid> "
"(начиная с Linux 4.1)."

#. type: Plain text
#: man-pages/man5/proc.5:2553
msgid "I<VmPeak>: Peak virtual memory size."
msgstr "I<VmPeak>: Пик размера виртуальной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:2556
msgid "I<VmSize>: Virtual memory size."
msgstr "I<VmSize>: Размер виртуальной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:2560
msgid "I<VmLck>: Locked memory size (see B<mlock>(2))."
msgstr "I<VmLck>: Размер заблокированной памяти (смотрите B<mlock>(2))."

#.  commit bc3e53f682d93df677dbd5006a404722b3adfe18
#. type: Plain text
#: man-pages/man5/proc.5:2567
msgid ""
"I<VmPin>: Pinned memory size (since Linux 3.2).  These are pages that can't "
"be moved because something needs to directly access physical memory."
msgstr ""
"I<VmPin>: Размер закреплённой памяти (начиная с Linux 3.2). Эти страницы не "
"могут быть перемещены, так как для чего-то требуется прямой доступ к "
"физической памяти."

#. type: Plain text
#: man-pages/man5/proc.5:2570
msgid "I<VmHWM>: Peak resident set size (\"high water mark\")."
msgstr "I<VmHWM>: Пик размера резидентной памяти (\"отметка высоты прилива\")."

#. type: Plain text
#: man-pages/man5/proc.5:2578
msgid ""
"I<VmRSS>: Resident set size.  Note that the value here is the sum of "
"I<RssAnon>, I<RssFile>, and I<RssShmem>."
msgstr ""
"I<VmRSS>: Размер резидентной части. Заметим, что это значение является "
"суммой I<RssAnon>, I<RssFile> и I<RssShmem>."

#.  commit bf9683d6990589390b5178dafe8fd06808869293
#. type: Plain text
#: man-pages/man5/proc.5:2583
msgid "I<RssAnon>: Size of resident anonymous memory.  (since Linux 4.5)."
msgstr "I<RssAnon>: Размер резидентной анонимной памяти (начиная с Linux 4.5)."

#.  commit bf9683d6990589390b5178dafe8fd06808869293
#. type: Plain text
#: man-pages/man5/proc.5:2588
msgid "I<RssFile>: Size of resident file mappings.  (since Linux 4.5)."
msgstr ""
"I<RssFile>: Размер отображений резидентных файлов (начиная с Linux 4.5)."

#.  commit bf9683d6990589390b5178dafe8fd06808869293
#. type: Plain text
#: man-pages/man5/proc.5:2596
msgid ""
"I<RssShmem>: Size of resident shared memory (includes System V shared "
"memory, mappings from B<tmpfs>(5), and shared anonymous mappings).  (since "
"Linux 4.5)."
msgstr ""
"I<RssShmem>: Размер общей резидентной памяти (включая общую память System V, "
"отображения из B<tmpfs>(5) и общие анонимные отображения) (начиная с Linux "
"4.5)."

#. type: Plain text
#: man-pages/man5/proc.5:2599
msgid "I<VmData>, I<VmStk>, I<VmExe>: Size of data, stack, and text segments."
msgstr "I<VmData>, I<VmStk>, I<VmExe>: Размер сегментов данных, стека и кода."

#. type: Plain text
#: man-pages/man5/proc.5:2602
msgid "I<VmLib>: Shared library code size."
msgstr "I<VmLib>: Размер кода общей библиотеки."

#. type: Plain text
#: man-pages/man5/proc.5:2605
msgid "I<VmPTE>: Page table entries size (since Linux 2.6.10)."
msgstr ""
"I<VmPTE>: Размер элементов страничной таблицы (начиная с Linux 2.6.10)."

#.  commit dc6c9a35b66b520cf67e05d8ca60ebecad3b0479
#. type: Plain text
#: man-pages/man5/proc.5:2609
msgid ""
"I<VmPMD>: Size of second-level page tables (added in Linux 4.0; removed in "
"Linux 4.15)."
msgstr ""
"I<VmPMD>: Размер страничных таблиц второго уровня (добавлено в Linux 4.0; "
"удалено в Linux 4.15)."

#.  commit b084d4353ff99d824d3bc5a5c2c22c70b1fba722
#. type: Plain text
#: man-pages/man5/proc.5:2614
msgid ""
"I<VmSwap>: Swapped-out virtual memory size by anonymous private pages; shmem "
"swap usage is not included (since Linux 2.6.34)."
msgstr ""
"I<VmSwap>: Размер виртуальной памяти выгружаемых анонимных частных страниц; "
"подкачка shmem не учитывается (начиная с Linux 2.6.34)."

#.  commit 5d317b2b6536592a9b51fe65faed43d65ca9158e
#. type: Plain text
#: man-pages/man5/proc.5:2619
msgid "I<HugetlbPages>: Size of hugetlb memory portions (since Linux 4.4)."
msgstr "I<HugetlbPages>: Размер частей памяти hugetlb (начиная с Linux 4.4)."

#.  commit c643401218be0f4ab3522e0c0a63016596d6e9ca
#. type: Plain text
#: man-pages/man5/proc.5:2628
msgid ""
"I<CoreDumping>: Contains the value 1 if the process is currently dumping "
"core, and 0 if it is not (since Linux 4.15).  This information can be used "
"by a monitoring process to avoid killing a process that is currently dumping "
"core, which could result in a corrupted core dump file."
msgstr ""
"I<CoreDumping>: Содержит значение 1, если процесс выполняет создание дампа, "
"и 0, если нет (начиная с Linux 4.15). Это можно использовать для слежения за "
"процессом, чтобы случайно не завершить процесс, который выполняет дамп, что "
"приведёт к повреждению файла дампа."

#. type: Plain text
#: man-pages/man5/proc.5:2631
msgid "I<Threads>: Number of threads in process containing this thread."
msgstr "I<Threads>: Количество нитей в процессе, содержащем эту нить."

#. type: Plain text
#: man-pages/man5/proc.5:2642
msgid ""
"I<SigQ>: This field contains two slash-separated numbers that relate to "
"queued signals for the real user ID of this process.  The first of these is "
"the number of currently queued signals for this real user ID, and the second "
"is the resource limit on the number of queued signals for this process (see "
"the description of B<RLIMIT_SIGPENDING> in B<getrlimit>(2))."
msgstr ""
"I<SigQ>: В этом поле содержится два числа, разделённых косой чертой, которые "
"относятся к сигналам, имеющимся в очереди для реального пользовательского ID "
"этого процесса. Первое число показывает текущее количество сигналов в "
"очереди для реального пользовательского ID, а второе — ограничитель ресурса "
"на количество сигналов в очереди для этого процесса (смотрите описание "
"B<RLIMIT_SIGPENDING> в B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:2649
msgid ""
"I<SigPnd>, I<ShdPnd>: Mask (expressed in hexadecimal)  of signals pending "
"for thread and for process as a whole (see B<pthreads>(7)  and B<signal>(7))."
msgstr ""
"I<SigPnd>, I<ShdPnd>: Маска (шестнадцатеричное число) сигналов, ждущих "
"обработки нитью и всем процессом (смотрите B<pthreads>(7) и B<signal>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2654
msgid ""
"I<SigBlk>, I<SigIgn>, I<SigCgt>: Masks (expressed in hexadecimal)  "
"indicating signals being blocked, ignored, and caught (see B<signal>(7))."
msgstr ""
"I<SigBlk>, I<SigIgn>, I<SigCgt>: Маски (шестнадцатеричное число), отражающие "
"блокированные, игнорируемые и перехваченные сигналы (смотрите B<signal>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2660
msgid ""
"I<CapInh>, I<CapPrm>, I<CapEff>: Masks (expressed in hexadecimal)  of "
"capabilities enabled in inheritable, permitted, and effective sets (see "
"B<capabilities>(7))."
msgstr ""
"I<CapInh>, I<CapPrm>, I<CapEff>: Маски (шестнадцатеричное число) мандатов, "
"включённые в наследуемый, разрешающий и эффективный наборы (смотрите "
"B<capabilities>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2665
msgid ""
"I<CapBnd>: Capability bounding set, expressed in hexadecimal (since Linux "
"2.6.26, see B<capabilities>(7))."
msgstr ""
"I<CapBnd>: Ограничивающий набор мандатов, выраженный шестнадцатеричным "
"числом (начиная с Linux 2.6.26, смотрите B<capabilities>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2670
msgid ""
"I<CapAmb>: Ambient capability set, expressed in hexadecimal (since Linux "
"4.3, see B<capabilities>(7))."
msgstr ""
"I<CapAmb>: Набор наружных мандатов, выраженный шестнадцатеричным числом "
"(начиная с Linux 4.3, смотрите B<capabilities>(7))."

#.  commit af884cd4a5ae62fcf5e321fecf0ec1014730353d
#. type: Plain text
#: man-pages/man5/proc.5:2678
msgid ""
"I<NoNewPrivs>: Value of the I<no_new_privs> bit (since Linux 4.10, see "
"B<prctl>(2))."
msgstr ""
"I<NoNewPrivs>: Значение бита I<no_new_privs> (начиная с Linux 4.10, смотрите "
"B<prctl>(2))."

#.  commit 2f4b3bf6b2318cfaa177ec5a802f4d8d6afbd816
#. type: Plain text
#: man-pages/man5/proc.5:2693
msgid ""
"I<Seccomp>: Seccomp mode of the process (since Linux 3.8, see "
"B<seccomp>(2)).  0 means B<SECCOMP_MODE_DISABLED>; 1 means "
"B<SECCOMP_MODE_STRICT>; 2 means B<SECCOMP_MODE_FILTER>.  This field is "
"provided only if the kernel was built with the B<CONFIG_SECCOMP> kernel "
"configuration option enabled."
msgstr ""
"I<Seccomp>: Процесс в режиме seccomp (начиная с Linux 3.8, смотрите "
"B<seccomp>(2)). Значение 0 означает B<SECCOMP_MODE_DISABLED>; 1 — "
"B<SECCOMP_MODE_STRICT>; 2 — B<SECCOMP_MODE_FILTER>. Это поле существует "
"только, если ядро собрано с включённым параметром сборки ядра "
"B<CONFIG_SECCOMP>."

#.  commit fae1fa0fc6cca8beee3ab8ed71d54f9a78fa3f64
#. type: Plain text
#: man-pages/man5/proc.5:2699
msgid ""
"I<Speculation_Store_Bypass>: Speculation flaw mitigation state (since Linux "
"4.17, see B<prctl>(2))."
msgstr ""
"I<Speculation_Store_Bypass>: Состояние ослабления нежелательной "
"спекулятовности (начиная с Linux 4.17, смотрите B<prctl>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:2704
msgid ""
"I<Cpus_allowed>: Hexadecimal mask of CPUs on which this process may run "
"(since Linux 2.6.24, see B<cpuset>(7))."
msgstr ""
"I<Cpus_allowed>: Шестнадцатеричная маска процессоров, на которых может "
"выполняться процесс (начиная с Linux 2.6.24, смотрите B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2709
msgid ""
"I<Cpus_allowed_list>: Same as previous, but in \"list format\" (since Linux "
"2.6.26, see B<cpuset>(7))."
msgstr ""
"I<Cpus_allowed_list>: Тоже что предыдущий, но в \"формате списка\" (начиная "
"с Linux 2.6.26, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2714
msgid ""
"I<Mems_allowed>: Mask of memory nodes allowed to this process (since Linux "
"2.6.24, see B<cpuset>(7))."
msgstr ""
"I<Mems_allowed>: Маска узлов памяти, разрешённых для этого процесса (начиная "
"с Linux 2.6.24, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2719
msgid ""
"I<Mems_allowed_list>: Same as previous, but in \"list format\" (since Linux "
"2.6.26, see B<cpuset>(7))."
msgstr ""
"I<Mems_allowed_list>: Тоже что и предыдущее, но в \"формате списка"
"\" (начиная с Linux 2.6.26, см. B<cpuset>(7))."

#. type: Plain text
#: man-pages/man5/proc.5:2722
msgid ""
"I<voluntary_ctxt_switches>, I<nonvoluntary_ctxt_switches>: Number of "
"voluntary and involuntary context switches (since Linux 2.6.23)."
msgstr ""
"I<voluntary_ctxt_switches>, I<nonvoluntary_ctxt_switches>: Количество "
"намеренных и непреднамеренных переключений контекста (начиная с Linux "
"2.6.23)."

#. type: TP
#: man-pages/man5/proc.5:2723
#, no-wrap
msgid "I</proc/[pid]/syscall> (since Linux 2.6.27)"
msgstr "I</proc/[pid]/syscall> (начиная с Linux 2.6.27)"

#.  commit ebcb67341fee34061430f3367f2e507e52ee051b
#. type: Plain text
#: man-pages/man5/proc.5:2731
msgid ""
"This file exposes the system call number and argument registers for the "
"system call currently being executed by the process, followed by the values "
"of the stack pointer and program counter registers.  The values of all six "
"argument registers are exposed, although most system calls use fewer "
"registers."
msgstr ""
"Данный файл отражает аргументные регистры и номер системного вызова, который "
"выполняется процессом; далее указаны значения регистров указателя стека и "
"программного счётчика. Хотя большинство системных вызовов использует только "
"несколько регистров, видны значения всех шести аргументных регистров."

#. type: Plain text
#: man-pages/man5/proc.5:2736
msgid ""
"If the process is blocked, but not in a system call, then the file displays "
"-1 in place of the system call number, followed by just the values of the "
"stack pointer and program counter.  If process is not blocked, then the file "
"contains just the string \"running\"."
msgstr ""
"Если процесс заблокирован не системным вызовом, то в файле содержится -1 на "
"месте номера системного вызова, затем указаны только значения указателя "
"стека и программного счётчика. Если процесс не заблокирован, то файл "
"содержит строку «running»."

#. type: Plain text
#: man-pages/man5/proc.5:2739
msgid ""
"This file is present only if the kernel was configured with "
"B<CONFIG_HAVE_ARCH_TRACEHOOK>."
msgstr ""
"Данный файл доступен только, если ядро собрано с параметром "
"B<CONFIG_HAVE_ARCH_TRACEHOOK>."

#. type: TP
#: man-pages/man5/proc.5:2744
#, no-wrap
msgid "I</proc/[pid]/task> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/task> (начиная с Linux 2.6.0)"

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: man-pages/man5/proc.5:2753
msgid ""
"This is a directory that contains one subdirectory for each thread in the "
"process.  The name of each subdirectory is the numerical thread ID "
"(I<[tid]>)  of the thread (see B<gettid>(2))."
msgstr ""
"В этом каталоге содержатся подкаталоги, под одному на нить процесса. Имя "
"подкаталога задаётся числом, которое является ID (I<[tid]>) нити (смотрите "
"B<gettid>(2))."

#.  in particular: "children" :/
#. type: Plain text
#: man-pages/man5/proc.5:2781
msgid ""
"Within each of these subdirectories, there is a set of files with the same "
"names and contents as under the I</proc/[pid]> directories.  For attributes "
"that are shared by all threads, the contents for each of the files under the "
"I<task/[tid]> subdirectories will be the same as in the corresponding file "
"in the parent I</proc/[pid]> directory (e.g., in a multithreaded process, "
"all of the I<task/[tid]/cwd> files will have the same value as the I</proc/"
"[pid]/cwd> file in the parent directory, since all of the threads in a "
"process share a working directory).  For attributes that are distinct for "
"each thread, the corresponding files under I<task/[tid]> may have different "
"values (e.g., various fields in each of the I<task/[tid]/status> files may "
"be different for each thread), or they might not exist in I</proc/[pid]> at "
"all."
msgstr ""
"В каждом подкаталоге есть набор файлов с одинаковыми именами и содержимым "
"как у каталогов I</proc/[pid]>. Для общих атрибутов всех нитей содержимое "
"каждого файла в подкаталогах I<task/[tid]> будет одинаковым, как у "
"соответствующего файла в родительском каталоге I</proc/[pid]> (например, в "
"многонитевом процессе все файлы I<task/[tid]/cwd> будут иметь одинаковое "
"значение, совпадающее с содержимым файла I</proc/[pid]/cwd> в родительском "
"каталоге, так как все нити в процессе используют общий рабочий каталог). Для "
"отличающихся атрибутов нитей соответствующие файлы в I<task/[tid]> могут "
"иметь различные значения (например, различные поля в каждом файле I<task/"
"[tid]/status> могут отличаться в каждой нити) или вообще могут отсутствовать "
"в I</proc/[pid]>."

#.  The following was still true as at kernel 2.6.13
#. type: Plain text
#: man-pages/man5/proc.5:2788
msgid ""
"In a multithreaded process, the contents of the I</proc/[pid]/task> "
"directory are not available if the main thread has already terminated "
"(typically by calling B<pthread_exit>(3))."
msgstr ""
"В многонитевых процессах, содержимое каталога I</proc/[pid]/task> "
"недоступно, если главная нить уже завершила работу (обычно при помощи вызова "
"B<pthread_exit>(3))."

#. type: TP
#: man-pages/man5/proc.5:2789
#, no-wrap
msgid "I</proc/[pid]/task/[tid]/children> (since Linux 3.5)"
msgstr "I</proc/[pid]/task/[tid]/children> (начиная с Linux 3.5)"

#.  commit 818411616baf46ceba0cff6f05af3a9b294734f7
#. type: Plain text
#: man-pages/man5/proc.5:2794
msgid ""
"A space-separated list of child tasks of this task.  Each child task is "
"represented by its TID."
msgstr ""
"Разделённый пробелами список задач-потомков данной задачи. Каждая задача-"
"потомок представлена своим TID."

#.  see comments in get_children_pid() in fs/proc/array.c
#. type: Plain text
#: man-pages/man5/proc.5:2805
msgid ""
"This option is intended for use by the checkpoint-restore (CRIU) system, and "
"reliably provides a list of children only if all of the child processes are "
"stopped or frozen.  It does not work properly if children of the target task "
"exit while the file is being read! Exiting children may cause non-exiting "
"children to be omitted from the list.  This makes this interface even more "
"unreliable than classic PID-based approaches if the inspected task and its "
"children aren't frozen, and most code should probably not use this interface."
msgstr ""
"Этот параметр предназначен для использования системой восстановления из "
"контрольных точек (CRIU) и предоставляет достоверный список потомков, только "
"если дочерние процессы остановлены или заморожены. Он не работает правильно, "
"если потомки целевой задачи завершаются во время чтения файла! Завершающиеся "
"потомки могут привести к пропаже из списка не завершившихся потомков. Это "
"делает данный интерфейс ещё более ненадёжным чем классический на основе PID, "
"если просматриваемая задача и её потомки не заморожены, и вероятно, в "
"большинстве программ лучше не использовать данный интерфейс."

#.  commit 2e13ba54a2682eea24918b87ad3edf70c2cf085b
#. type: Plain text
#: man-pages/man5/proc.5:2814
msgid ""
"Until Linux 4.2, the presence of this file was governed by the "
"B<CONFIG_CHECKPOINT_RESTORE> kernel configuration option.  Since Linux 4.2, "
"it is governed by the B<CONFIG_PROC_CHILDREN> option."
msgstr ""
"До Linux 4.2 наличие этого файла управлялось параметром настройки ядра "
"B<CONFIG_CHECKPOINT_RESTORE>. Начиная с Linux 4.2, он управляется параметром "
"B<CONFIG_PROC_CHILDREN>."

#. type: TP
#: man-pages/man5/proc.5:2814
#, no-wrap
msgid "I</proc/[pid]/timers> (since Linux 3.10)"
msgstr "I</proc/[pid]/timers> (начиная с Linux 3.10)"

#.  commit 5ed67f05f66c41e39880a6d61358438a25f9fee5
#.  commit 48f6a7a511ef8823fdff39afee0320092d43a8a0
#. type: Plain text
#: man-pages/man5/proc.5:2821
msgid ""
"A list of the POSIX timers for this process.  Each timer is listed with a "
"line that starts with the string \"ID:\".  For example:"
msgstr ""
"Список таймеров POSIX этого процесса. Каждый таймер описывается в строке, "
"которая начинается со строки «ID:». Пример:"

#. type: Plain text
#: man-pages/man5/proc.5:2832
#, no-wrap
msgid ""
"ID: 1\n"
"signal: 60/00007fff86e452a8\n"
"notify: signal/pid.2634\n"
"ClockID: 0\n"
"ID: 0\n"
"signal: 60/00007fff86e452a8\n"
"notify: signal/pid.2634\n"
"ClockID: 1\n"
msgstr ""
"ID: 1\n"
"signal: 60/00007fff86e452a8\n"
"notify: signal/pid.2634\n"
"ClockID: 0\n"
"ID: 0\n"
"signal: 60/00007fff86e452a8\n"
"notify: signal/pid.2634\n"
"ClockID: 1\n"

#. type: Plain text
#: man-pages/man5/proc.5:2836
msgid "The lines shown for each timer have the following meanings:"
msgstr "Строки каждого таймера имеют следующее значение:"

#. type: TP
#: man-pages/man5/proc.5:2837
#, no-wrap
msgid "I<ID>"
msgstr "I<ID>"

#. type: Plain text
#: man-pages/man5/proc.5:2848
msgid ""
"The ID for this timer.  This is not the same as the timer ID returned by "
"B<timer_create>(2); rather, it is the same kernel-internal ID that is "
"available via the I<si_timerid> field of the I<siginfo_t> structure (see "
"B<sigaction>(2))."
msgstr ""
"Идентификатор таймера. Это не тоже самое, что возвращает B<timer_create>(2); "
"это внутренний идентификатор в ядре, который доступен в поле I<si_timerid> "
"структуры I<siginfo_t> (смотрите B<sigaction>(2))."

#. type: TP
#: man-pages/man5/proc.5:2848
#, no-wrap
msgid "I<signal>"
msgstr "I<signal>"

#. type: Plain text
#: man-pages/man5/proc.5:2855
msgid ""
"This is the signal number that this timer uses to deliver notifications "
"followed by a slash, and then the I<sigev_value> value supplied to the "
"signal handler.  Valid only for timers that notify via a signal."
msgstr ""
"Номер сигнала, который данный таймер использует для доставки уведомлений, "
"затем косая черта, а затем показано значение I<sigev_value>, передаваемое в "
"обработчик сигнала. Актуален только для таймеров, которые выполняют "
"уведомления посредством сигнала."

#. type: TP
#: man-pages/man5/proc.5:2855
#, no-wrap
msgid "I<notify>"
msgstr "I<notify>"

#. type: Plain text
#: man-pages/man5/proc.5:2867
msgid ""
"The part before the slash specifies the mechanism that this timer uses to "
"deliver notifications, and is one of \"thread\", \"signal\", or \"none\".  "
"Immediately following the slash is either the string \"tid\" for timers with "
"B<SIGEV_THREAD_ID> notification, or \"pid\" for timers that notify by other "
"mechanisms.  Following the \".\" is the PID of the process (or the kernel "
"thread ID of the thread)  that will be delivered a signal if the timer "
"delivers notifications via a signal."
msgstr ""
"Часть перед косой чертой определяет механизм, который данный таймер "
"использует для доставки уведомлений, и может быть одним из «thread», "
"«signal» или «none». Сразу за косой чертой может быть строка «tid» для "
"таймеров с уведомлением B<SIGEV_THREAD_ID>, или «pid» для таймеров, которые "
"уведомляют другими механизмами. Далее после «.»  указан PID процесса (или ID "
"ядерной нити для нити), которому будет доставлен сигнал, если таймер "
"доставляет уведомления через сигнал."

#. type: TP
#: man-pages/man5/proc.5:2867
#, no-wrap
msgid "I<ClockID>"
msgstr "I<ClockID>"

#. type: Plain text
#: man-pages/man5/proc.5:2880
msgid ""
"This field identifies the clock that the timer uses for measuring time.  For "
"most clocks, this is a number that matches one of the user-space B<CLOCK_*> "
"constants exposed via I<E<lt>time.hE<gt>>.  B<CLOCK_PROCESS_CPUTIME_ID> "
"timers display with a value of -6 in this field.  B<CLOCK_THREAD_CPUTIME_ID> "
"timers display with a value of -2 in this field."
msgstr ""
"В этом поле задаются часы, которые таймер использует для измерения времени. "
"Для большинства часов это номер, который совпадает с одной из констант "
"пользовательского окружения B<CLOCK_*>, располагающихся в I<E<lt>time."
"hE<gt>>. Таймеры B<CLOCK_PROCESS_CPUTIME_ID> показываются со значением -6 в "
"этом поле. Таймеры B<CLOCK_THREAD_CPUTIME_ID> показываются со значением -2 в "
"этом поле."

#. type: Plain text
#: man-pages/man5/proc.5:2884
msgid ""
"This file is available only when the kernel was configured with "
"B<CONFIG_CHECKPOINT_RESTORE>."
msgstr ""
"Данный файл доступен только, если ядро было собрано с параметром "
"B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man5/proc.5:2884
#, no-wrap
msgid "I</proc/[pid]/timerslack_ns> (since Linux 4.6)"
msgstr "I</proc/[pid]/timerslack_ns> (начиная с Linux 4.6)"

#.  commit da8b44d5a9f8bf26da637b7336508ca534d6b319
#.  commit 5de23d435e88996b1efe0e2cebe242074ce67c9e
#. type: Plain text
#: man-pages/man5/proc.5:2898
msgid ""
"This file exposes the process's \"current\" timer slack value, expressed in "
"nanoseconds.  The file is writable, allowing the process's timer slack value "
"to be changed.  Writing 0 to this file resets the \"current\" timer slack to "
"the \"default\" timer slack value.  For further details, see the discussion "
"of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""
"Данный файл отражает значение (в наносекундах) «текущего» допуска таймера "
"процесса. Файл доступен на запись, что позволяет изменить значение допуска "
"таймера процесса. Запись 0 сбрасывает «текущий» допуск таймера в значение "
"допуска таймера «по умолчанию». Дополнительную информацию смотрите в "
"описании B<PR_SET_TIMERSLACK> из B<prctl>(2)."

#.  commit 7abbaf94049914f074306d960b0f968ffe52e59f
#. type: Plain text
#: man-pages/man5/proc.5:2913
msgid ""
"Initially, permission to access this file was governed by a ptrace access "
"mode B<PTRACE_MODE_ATTACH_FSCREDS> check (see B<ptrace>(2)).  However, this "
"was subsequently deemed too strict a requirement (and had the side effect "
"that requiring a process to have the B<CAP_SYS_PTRACE> capability would also "
"allow it to view and change any process's memory).  Therefore, since Linux "
"4.9, only the (weaker)  B<CAP_SYS_NICE> capability is required to access "
"this file."
msgstr ""
"Первоначально, права доступа к этому файлу определялись проверкой режима "
"доступа ptrace B<PTRACE_MODE_ATTACH_FSCREDS> (смотрите B<ptrace>(2)). Однако "
"это впоследствии посчитали слишком строгим требованием (и имеющим побочный "
"эффект, выражающимся в требовании от процесса иметь мандат "
"B<CAP_SYS_PTRACE>, который также позволяет ему просматривать и изменять всю "
"память процесса). Поэтому, начиная с Linux 4.9, для доступа к этому файлу "
"требуется только мандат B<CAP_SYS_NICE> (маломощный)."

#. type: TP
#: man-pages/man5/proc.5:2913
#, no-wrap
msgid "I</proc/[pid]/uid_map>, I</proc/[pid]/gid_map> (since Linux 3.5)"
msgstr "I</proc/[pid]/uid_map>, I</proc/[pid]/gid_map> (начиная с Linux 3.5)"

#. type: TP
#: man-pages/man5/proc.5:2917
#, no-wrap
msgid "I</proc/[pid]/wchan> (since Linux 2.6.0)"
msgstr "I</proc/[pid]/wchan> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:2921
msgid ""
"The symbolic name corresponding to the location in the kernel where the "
"process is sleeping."
msgstr ""
"Символическое имя, соответствующее расположению, где процесс спит в ядре."

#. type: TP
#: man-pages/man5/proc.5:2926
#, no-wrap
msgid "I</proc/[tid]>"
msgstr "I</proc/[tid]>"

#. type: Plain text
#: man-pages/man5/proc.5:2938
msgid ""
"There is a numerical subdirectory for each running thread that is not a "
"thread group leader (i.e., a thread whose thread ID is not the same as its "
"process ID); the subdirectory is named by the thread ID.  Each one of these "
"subdirectories contains files and subdirectories exposing information about "
"the thread with the thread ID I<tid>.  The contents of these directories are "
"the same as the corresponding I</proc/[pid]/task/[tid]> directories."
msgstr ""
"Подкаталог с числовым названием для каждой выполняющейся нити, которая не "
"является лидером группы нитей (т. е., нить, чей ID нити не совпадает с ID её "
"процесса); подкаталог называется по ID нити. В подкаталоге содержатся файлы "
"и подкаталоги с информацией о нити с ID нити I<tid>. Содержимое этих "
"каталогов совпадает с соответствующими каталогами I</proc/[pid]/task/[tid]>."

#. type: Plain text
#: man-pages/man5/proc.5:2956
msgid ""
"The I</proc/[tid]> subdirectories are I<not> visible when iterating through "
"I</proc> with B<getdents>(2)  (and thus are I<not> visible when one uses "
"B<ls>(1)  to view the contents of I</proc>).  However, the pathnames of "
"these directories are visible to (i.e., usable as arguments in)  system "
"calls that operate on pathnames."
msgstr ""
"Подкаталоги I</proc/[tid]> I<невидимы> при обходе I</proc> с помощью "
"B<getdents>(2) (и поэтому I<невидимы> программам, подобным B<ls>(1), "
"отображающим содержимое I</proc>). Однако пути к этим каталогам видимы (т. "
"е., их можно использовать в качестве параметров) системным вызовам, "
"работающими с этими путями."

#. type: TP
#: man-pages/man5/proc.5:2956
#, no-wrap
msgid "I</proc/apm>"
msgstr "I</proc/apm>"

#. type: Plain text
#: man-pages/man5/proc.5:2961
msgid ""
"Advanced power management version and battery information when B<CONFIG_APM> "
"is defined at kernel compilation time."
msgstr ""
"Версия системы расширенного управления питанием и информация о батарее, если "
"ядро собрано с поддержкой B<CONFIG_APM>."

#. type: TP
#: man-pages/man5/proc.5:2961
#, no-wrap
msgid "I</proc/buddyinfo>"
msgstr "I</proc/buddyinfo>"

#. type: Plain text
#: man-pages/man5/proc.5:2971
msgid ""
"This file contains information which is used for diagnosing memory "
"fragmentation issues.  Each line starts with the identification of the node "
"and the name of the zone which together identify a memory region This is "
"then followed by the count of available chunks of a certain order in which "
"these zones are split.  The size in bytes of a certain order is given by the "
"formula:"
msgstr ""
"В этом файле содержится информация, которую можно использовать при "
"диагностике проблем с фрагментацией памяти. Каждая строка начинается с "
"идентификатора узла и имени зоны, которые вместе определяют область памяти. "
"Далее следует количество доступных блоков (chunks) определённого порядка, в "
"котором разделялись зоны. Размер в байтах порядка задаётся формулой:"

#. type: Plain text
#: man-pages/man5/proc.5:2973
#, no-wrap
msgid "    (2^order)\\ *\\ PAGE_SIZE\n"
msgstr "    (2^order)\\ *\\ PAGE_SIZE\n"

#. type: Plain text
#: man-pages/man5/proc.5:2980
msgid ""
"The binary buddy allocator algorithm inside the kernel will split one chunk "
"into two chunks of a smaller order (thus with half the size) or combine two "
"contiguous chunks into one larger chunk of a higher order (thus with double "
"the size) to satisfy allocation requests and to counter memory "
"fragmentation.  The order matches the column number, when starting to count "
"at zero."
msgstr ""
"Алгоритм двоичных близнецов (binary buddy allocator) внутри ядра разделит "
"один блок на несколько меньшего размера (например, пополам) или объединит "
"два рядом стоящих блока в один большего размера (например удвоенного), чтобы "
"выполнить запрос выделения и подсчёта фрагментации памяти. Порядок совпадает "
"с номером столбца, при начале отсчёта от нуля."

#. type: Plain text
#: man-pages/man5/proc.5:2982
msgid "For example on an x86-64 system:"
msgstr "Пример для системы x86-64:"

#. type: Plain text
#: man-pages/man5/proc.5:2988
#, no-wrap
msgid ""
"Node 0, zone     DMA     1    1    1    0    2    1    1    0    1    1    3\n"
"Node 0, zone   DMA32    65   47    4   81   52   28   13   10    5    1  404\n"
"Node 0, zone  Normal   216   55  189  101   84   38   37   27    5    3  587\n"
msgstr ""
"Node 0, zone     DMA     1    1    1    0    2    1    1    0    1    1    3\n"
"Node 0, zone   DMA32    65   47    4   81   52   28   13   10    5    1  404\n"
"Node 0, zone  Normal   216   55  189  101   84   38   37   27    5    3  587\n"

#. type: Plain text
#: man-pages/man5/proc.5:2997
msgid ""
"In this example, there is one node containing three zones and there are 11 "
"different chunk sizes.  If the page size is 4 kilobytes, then the first zone "
"called I<DMA> (on x86 the first 16 megabyte of memory) has 1 chunk of 4 "
"kilobytes (order 0) available and has 3 chunks of 4 megabytes (order 10) "
"available."
msgstr ""
"В этом примере показан один узел, содержащий три зоны и 11 блоков разного "
"размера. Если размер страницы равен 4 КБ, то первая зона с именем I<DMA> (в "
"x86 — первые 16 МБ памяти) содержит 1 блок по 4 КБ (порядок 0) и 3 блока по "
"4 МБ (порядок 10)."

#. type: Plain text
#: man-pages/man5/proc.5:3001
msgid ""
"If the memory is heavily fragmented, the counters for higher order chunks "
"will be zero and allocation of large contiguous areas will fail."
msgstr ""
"Если памяти сильно фрагментирована, то счётчики блоков высшего порядка будут "
"равны нулю и выделение больших непрерывных областей будет завершаться с "
"ошибкой."

#. type: Plain text
#: man-pages/man5/proc.5:3004
msgid "Further information about the zones can be found in I</proc/zoneinfo>."
msgstr "Дополнительную информацию о зонах смотрите I</proc/zoneinfo>."

#. type: TP
#: man-pages/man5/proc.5:3004
#, no-wrap
msgid "I</proc/bus>"
msgstr "I</proc/bus>"

#. type: Plain text
#: man-pages/man5/proc.5:3007
msgid "Contains subdirectories for installed busses."
msgstr "Содержит подкаталоги для установленных шин."

#. type: TP
#: man-pages/man5/proc.5:3007
#, no-wrap
msgid "I</proc/bus/pccard>"
msgstr "I</proc/bus/pccard>"

#. type: Plain text
#: man-pages/man5/proc.5:3012
msgid ""
"Subdirectory for PCMCIA devices when B<CONFIG_PCMCIA> is set at kernel "
"compilation time."
msgstr ""
"Подкаталог для устройств PCMCIA, если ядро собрано с поддержкой "
"B<CONFIG_PCMCIA>."

#. type: TP
#: man-pages/man5/proc.5:3012
#, no-wrap
msgid "I</proc/bus/pccard/drivers>"
msgstr "I</proc/bus/pccard/drivers>"

#. type: TP
#: man-pages/man5/proc.5:3014
#, no-wrap
msgid "I</proc/bus/pci>"
msgstr "I</proc/bus/pci>"

#. type: Plain text
#: man-pages/man5/proc.5:3020
msgid ""
"Contains various bus subdirectories and pseudo-files containing information "
"about PCI busses, installed devices, and device drivers.  Some of these "
"files are not ASCII."
msgstr ""
"Содержит различные подкаталоги шин и псевдо-файлы, содержащие информацию о "
"шинах PCI, установленных устройствах и драйверах устройств. Некоторые из "
"этих файлов не являются текстовыми."

#. type: TP
#: man-pages/man5/proc.5:3020
#, no-wrap
msgid "I</proc/bus/pci/devices>"
msgstr "I</proc/bus/pci/devices>"

#. type: Plain text
#: man-pages/man5/proc.5:3027
msgid ""
"Information about PCI devices.  They may be accessed through B<lspci>(8)  "
"and B<setpci>(8)."
msgstr ""
"Информация о устройствах PCI. К ним можно получить доступ через B<lspci>(8) "
"и B<setpci>(8)."

#. type: TP
#: man-pages/man5/proc.5:3027
#, no-wrap
msgid "I</proc/cgroups> (since Linux 2.6.24)"
msgstr "I</proc/cgroups> (начиная с Linux 2.6.24)"

#. type: TP
#: man-pages/man5/proc.5:3031
#, no-wrap
msgid "I</proc/cmdline>"
msgstr "I</proc/cmdline>"

#. type: Plain text
#: man-pages/man5/proc.5:3038
msgid ""
"Arguments passed to the Linux kernel at boot time.  Often done via a boot "
"manager such as B<lilo>(8)  or B<grub>(8)."
msgstr ""
"Аргументы, переданные ядру Linux во время начальной загрузки. Часто это "
"делается через менеджер начальной загрузки, такой как B<lilo>(8) или "
"B<grub>(8)."

#. type: TP
#: man-pages/man5/proc.5:3038
#, no-wrap
msgid "I</proc/config.gz> (since Linux 2.6)"
msgstr "I</proc/config.gz> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man5/proc.5:3056
msgid ""
"This file exposes the configuration options that were used to build the "
"currently running kernel, in the same format as they would be shown in the "
"I<.config> file that resulted when configuring the kernel (using I<make "
"xconfig>, I<make config>, or similar).  The file contents are compressed; "
"view or search them using B<zcat>(1)  and B<zgrep>(1).  As long as no "
"changes have been made to the following file, the contents of I</proc/config."
"gz> are the same as those provided by:"
msgstr ""
"В этом файле представлены параметры настройки, которые использовались при "
"сборке выполняющегося в данный момент ядра. Его формат одинаков с файлом I<."
"config>, который создаётся после настройки ядра (с помощью I<make xconfig>, "
"I<make config> и подобных команд). Содержимое файла сжато; для просмотра и "
"поиска используйте B<zcat>(1) и B<zgrep>(1). Пока не внесены изменения в "
"настройку ядра, содержимое I</proc/config.gz> и показываемого по команде "
"файла одинаково:"

#. type: Plain text
#: man-pages/man5/proc.5:3060
#, no-wrap
msgid "cat /lib/modules/$(uname -r)/build/.config\n"
msgstr "cat /lib/modules/$(uname -r)/build/.config\n"

#. type: Plain text
#: man-pages/man5/proc.5:3066
msgid ""
"I</proc/config.gz> is provided only if the kernel is configured with "
"B<CONFIG_IKCONFIG_PROC>."
msgstr ""
"Файл I</proc/config.gz> доступен только, если ядро собрано с поддержкой "
"B<CONFIG_IKCONFIG_PROC>."

#. type: TP
#: man-pages/man5/proc.5:3066
#, no-wrap
msgid "I</proc/crypto>"
msgstr "I</proc/crypto>"

#.  commit 3b72c814a8e8cd638e1ba0da4dfce501e9dff5af
#. type: Plain text
#: man-pages/man5/proc.5:3080
msgid ""
"A list of the ciphers provided by the kernel crypto API.  For details, see "
"the kernel I<Linux Kernel Crypto API> documentation available under the "
"kernel source directory I<Documentation/crypto/> (or I<Documentation/"
"DocBook> before 4.10; the documentation can be built using a command such as "
"I<make htmldocs> in the root directory of the kernel source tree)."
msgstr ""
"Список алгоритмов шифрования, предоставляемых ядерным программным "
"интерфейсом crypto. Подробности смотрите в документации ядра I<Linux Kernel "
"Crypto API> из каталога исходного кода ядра I<Documentation/crypto/> (или в "
"I<Documentation/DocBook> до версии 4.10; эта документация может быть создана "
"по команде I<make htmldocs> в корневом каталоге дерева исходного кода ядра)."

#. type: TP
#: man-pages/man5/proc.5:3080
#, no-wrap
msgid "I</proc/cpuinfo>"
msgstr "I</proc/cpuinfo>"

#. type: Plain text
#: man-pages/man5/proc.5:3092
msgid ""
"This is a collection of CPU and system architecture dependent items, for "
"each supported architecture a different list.  Two common entries are "
"I<processor> which gives CPU number and I<bogomips>; a system constant that "
"is calculated during kernel initialization.  SMP machines have information "
"for each CPU.  The B<lscpu>(1)  command gathers its information from this "
"file."
msgstr ""
"Это коллекция элементов, зависящих от процессора и системной архитектуры; "
"для каждой поддерживаемой архитектуры список различен. Имеются только две "
"общих записи: I<processor> \\(em обозначает номер процессора и I<bogomips>"
"\\(em системная константа, которая высчитывается во время инициализации "
"ядра. Для многопроцессорных машин информация предоставляется по каждому "
"процессору. Команда B<lscpu>(1) берёт информацию из этого файла."

#. type: TP
#: man-pages/man5/proc.5:3092
#, no-wrap
msgid "I</proc/devices>"
msgstr "I</proc/devices>"

#. type: Plain text
#: man-pages/man5/proc.5:3096
msgid ""
"Text listing of major numbers and device groups.  This can be used by "
"MAKEDEV scripts for consistency with the kernel."
msgstr ""
"Текстовый список старших (major) номеров устройств и групп устройств. Он "
"может быть использован сценариями MAKEDEV для того, чтобы создать "
"устройства, поддерживаемые ядром."

#. type: TP
#: man-pages/man5/proc.5:3096
#, no-wrap
msgid "I</proc/diskstats> (since Linux 2.5.69)"
msgstr "I</proc/diskstats> (начиная с Linux 2.5.69)"

#. type: Plain text
#: man-pages/man5/proc.5:3102
msgid ""
"This file contains disk I/O statistics for each disk device.  See the Linux "
"kernel source file I<Documentation/iostats.txt> for further information."
msgstr ""
"Файл со статистикой дискового ввода-вывода по каждому устройству. "
"Дополнительная информация доступна в файле I<Documentation/iostats.txt> из "
"исходного кода ядра Linux."

#. type: TP
#: man-pages/man5/proc.5:3102
#, no-wrap
msgid "I</proc/dma>"
msgstr "I</proc/dma>"

#. type: Plain text
#: man-pages/man5/proc.5:3106
msgid ""
"This is a list of the registered I<ISA> DMA (direct memory access)  channels "
"in use."
msgstr ""
"Список рабочих зарегистрированных каналов DMA (прямого доступа в память) "
"I<ISA>."

#. type: TP
#: man-pages/man5/proc.5:3106
#, no-wrap
msgid "I</proc/driver>"
msgstr "I</proc/driver>"

#. type: Plain text
#: man-pages/man5/proc.5:3109
msgid "Empty subdirectory."
msgstr "Пустой подкаталог."

#. type: TP
#: man-pages/man5/proc.5:3109
#, no-wrap
msgid "I</proc/execdomains>"
msgstr "I</proc/execdomains>"

#. type: Plain text
#: man-pages/man5/proc.5:3112
msgid "List of the execution domains (ABI personalities)."
msgstr "Список доменов исполнения (индивидуально для ABI)."

#. type: TP
#: man-pages/man5/proc.5:3112
#, no-wrap
msgid "I</proc/fb>"
msgstr "I</proc/fb>"

#. type: Plain text
#: man-pages/man5/proc.5:3117
msgid ""
"Frame buffer information when B<CONFIG_FB> is defined during kernel "
"compilation."
msgstr ""
"Информация о фрейм-буфере, если ядро собрано с поддержкой B<CONFIG_FB>."

#. type: TP
#: man-pages/man5/proc.5:3117
#, no-wrap
msgid "I</proc/filesystems>"
msgstr "I</proc/filesystems>"

#. type: Plain text
#: man-pages/man5/proc.5:3127
msgid ""
"A text listing of the filesystems which are supported by the kernel, namely "
"filesystems which were compiled into the kernel or whose kernel modules are "
"currently loaded.  (See also B<filesystems>(5).)  If a filesystem is marked "
"with \"nodev\", this means that it does not require a block device to be "
"mounted (e.g., virtual filesystem, network filesystem)."
msgstr ""
"Текстовый список файловых систем, которые поддерживаются ядром, а именно "
"файловые системы, вкомпилированные в ядро или загруженные в данный момент "
"модулями (смотрите также B<filesystems>(5)). Если файловая система помечена "
"как «nodev», то это означает, что для неё не требуется монтировать блочное "
"устройство (например, виртуальная и сетевая файловые системы)."

#. type: Plain text
#: man-pages/man5/proc.5:3134
msgid ""
"Incidentally, this file may be used by B<mount>(8)  when no filesystem is "
"specified and it didn't manage to determine the filesystem type.  Then "
"filesystems contained in this file are tried (excepted those that are marked "
"with \"nodev\")."
msgstr ""
"В частности, этот файл может использоваться программой B<mount>(8) для "
"поиска нужной файловой системы, если она не указана при монтировании и её "
"тип невозможно определить. При этом пробуются все файловые системы из этого "
"файла (за исключением помеченных как «nodev»)."

#. type: TP
#: man-pages/man5/proc.5:3134
#, no-wrap
msgid "I</proc/fs>"
msgstr "I</proc/fs>"

#.  FIXME Much more needs to be said about /proc/fs
#. type: Plain text
#: man-pages/man5/proc.5:3140
msgid ""
"Contains subdirectories that in turn contain files with information about "
"(certain) mounted filesystems."
msgstr ""
"Содержит подкаталоги, которые, в свою очередь, содержат файлы с информацией "
"о (некоторых) смонтированных файловых системах."

#. type: TP
#: man-pages/man5/proc.5:3140
#, no-wrap
msgid "I</proc/ide>"
msgstr "I</proc/ide>"

#. type: Plain text
#: man-pages/man5/proc.5:3146
msgid ""
"This directory exists on systems with the IDE bus.  There are directories "
"for each IDE channel and attached device.  Files include:"
msgstr ""
"Данный подкаталог существует в системах с шиной IDE. Для каждого канала IDE "
"и подключенных устройств имеется отдельный каталог. Файлы каталога:"

#. type: Plain text
#: man-pages/man5/proc.5:3159
#, no-wrap
msgid ""
"cache              buffer size in KB\n"
"capacity           number of sectors\n"
"driver             driver version\n"
"geometry           physical and logical geometry\n"
"identify           in hexadecimal\n"
"media              media type\n"
"model              manufacturer's model number\n"
"settings           drive settings\n"
"smart_thresholds   in hexadecimal\n"
"smart_values       in hexadecimal\n"
msgstr ""
"cache              размер буфера в KБ\n"
"capacity           количество секторов\n"
"driver             версия драйвера\n"
"geometry           физическая и логическая геометрия\n"
"identify           в шестнадцатеричном виде\n"
"media              тип носителя\n"
"model              номер модели производителя\n"
"settings           настройки драйвера\n"
"smart_thresholds   в шестнадцатеричном виде\n"
"smart_values       в шестнадцатеричном виде\n"

#. type: Plain text
#: man-pages/man5/proc.5:3165
msgid ""
"The B<hdparm>(8)  utility provides access to this information in a friendly "
"format."
msgstr ""
"Утилита B<hdparm>(8) предоставляет доступ к этой информации в дружественном "
"формате."

#. type: TP
#: man-pages/man5/proc.5:3165
#, no-wrap
msgid "I</proc/interrupts>"
msgstr "I</proc/interrupts>"

#. type: Plain text
#: man-pages/man5/proc.5:3175
msgid ""
"This is used to record the number of interrupts per CPU per IO device.  "
"Since Linux 2.6.24, for the i386 and x86-64 architectures, at least, this "
"also includes interrupts internal to the system (that is, not associated "
"with a device as such), such as NMI (nonmaskable interrupt), LOC (local "
"timer interrupt), and for SMP systems, TLB (TLB flush interrupt), RES "
"(rescheduling interrupt), CAL (remote function call interrupt), and possibly "
"others.  Very easy to read formatting, done in ASCII."
msgstr ""
"Используется для записи количества прерываний по каждому процессору и по "
"каждому устройству ввода-вывода. Начиная с Linux 2.6.24 для архитектур i386- "
"и x86-64 (по крайней мере), также включены внутренние прерывания системы (то "
"есть, не связанные с устройством как таковым), такими как NMI (немаскируемые "
"прерывания), LOC (прерывание локального таймера) и для многопроцессорных "
"систем: TLB (прерывание сброса TLB), RES (прерывание перепланирования), CAL "
"(прерывание вызова удалённой функции), и, возможно другие. Очень легко "
"понять, так как записи в ASCII."

#. type: TP
#: man-pages/man5/proc.5:3175
#, no-wrap
msgid "I</proc/iomem>"
msgstr "I</proc/iomem>"

#. type: Plain text
#: man-pages/man5/proc.5:3178
msgid "I/O memory map in Linux 2.4."
msgstr "Карта памяти ввода/вывода в Linux 2.4."

#. type: TP
#: man-pages/man5/proc.5:3178
#, no-wrap
msgid "I</proc/ioports>"
msgstr "I</proc/ioports>"

#. type: Plain text
#: man-pages/man5/proc.5:3182
msgid ""
"This is a list of currently registered Input-Output port regions that are in "
"use."
msgstr ""
"Список зарегистрированных областей портов ввода-вывода, которые используются "
"в данный момент."

#. type: TP
#: man-pages/man5/proc.5:3182
#, no-wrap
msgid "I</proc/kallsyms> (since Linux 2.5.71)"
msgstr "I</proc/kallsyms> (начиная с Linux 2.5.71)"

#. type: Plain text
#: man-pages/man5/proc.5:3190
msgid ""
"This holds the kernel exported symbol definitions used by the B<modules>(X)  "
"tools to dynamically link and bind loadable modules.  In Linux 2.5.47 and "
"earlier, a similar file with slightly different syntax was named I<ksyms>."
msgstr ""
"Содержит определения экспортируемых ядром символов, используемые "
"инструментами B<modules>(X) для динамической компоновки и связывания "
"загружаемых модулей. В Linux 2.5.47 и ранее был подобный файл I<ksyms>, но "
"имел немного другой синтаксис."

#. type: TP
#: man-pages/man5/proc.5:3190
#, no-wrap
msgid "I</proc/kcore>"
msgstr "I</proc/kcore>"

#. type: Plain text
#: man-pages/man5/proc.5:3199
msgid ""
"This file represents the physical memory of the system and is stored in the "
"ELF core file format.  With this pseudo-file, and an unstripped kernel (I</"
"usr/src/linux/vmlinux>)  binary, GDB can be used to examine the current "
"state of any kernel data structures."
msgstr ""
"Этот файл отображает физическую память системы и хранится в формате ELF "
"core. С помощью этого псевдо-файла и ядра, из которого не убраны таблицы "
"символов (I</usr/src/linux/vmlinux>), можно использовать GDB для проверки "
"текущего состояния любых структур данных ядра."

#. type: Plain text
#: man-pages/man5/proc.5:3202
msgid ""
"The total length of the file is the size of physical memory (RAM) plus 4\\ "
"KiB."
msgstr ""
"Полная длина этого файла \\(em это размер физической памяти (RAM) плюс 4\\ "
"КиБ."

#. type: TP
#: man-pages/man5/proc.5:3202
#, no-wrap
msgid "I</proc/keys> (since Linux 2.6.10)"
msgstr "I</proc/keys> (начиная с Linux 2.6.10)"

#. type: Plain text
#: man-pages/man5/proc.5:3206 man-pages/man5/proc.5:3210
msgid "See B<keyrings>(7)."
msgstr "Смотрите B<keyrings>(7)."

#. type: TP
#: man-pages/man5/proc.5:3206
#, no-wrap
msgid "I</proc/key-users> (since Linux 2.6.10)"
msgstr "I</proc/key-users> (начиная с Linux 2.6.10)"

#. type: TP
#: man-pages/man5/proc.5:3210
#, no-wrap
msgid "I</proc/kmsg>"
msgstr "I</proc/kmsg>"

#. type: Plain text
#: man-pages/man5/proc.5:3222
msgid ""
"This file can be used instead of the B<syslog>(2)  system call to read "
"kernel messages.  A process must have superuser privileges to read this "
"file, and only one process should read this file.  This file should not be "
"read if a syslog process is running which uses the B<syslog>(2)  system call "
"facility to log kernel messages."
msgstr ""
"Этот файл может быть использован вместо системного вызова B<syslog>(2) для "
"чтения сообщений ядра. Процесс должен иметь привилегии суперпользователя, "
"чтобы читать этот файл, причём делать это может только один процесс. Данный "
"файл невозможно прочесть, если запущен процесс syslog, который использует "
"системный вызов B<syslog>(2) для протоколирования сообщений ядра."

#. type: Plain text
#: man-pages/man5/proc.5:3226
msgid "Information in this file is retrieved with the B<dmesg>(1)  program."
msgstr "Информация из этого файла извлекается с помощью программы B<dmesg>(1)."

#. type: TP
#: man-pages/man5/proc.5:3226
#, no-wrap
msgid "I</proc/kpagecgroup> (since Linux 4.3)"
msgstr "I</proc/kpagecgroup> (начиная с Linux 4.3)"

#.  commit 80ae2fdceba8313b0433f899bdd9c6c463291a17
#. type: Plain text
#: man-pages/man5/proc.5:3233
msgid ""
"This file contains a 64-bit inode number of the memory cgroup each page is "
"charged to, indexed by page frame number (see the discussion of I</proc/"
"[pid]/pagemap>)."
msgstr ""
"В этом файле содержится 64-битный номер иноды, относящийся к каждой странице "
"памяти cgroup, проиндексированные по номеру страничного кадра (смотрите "
"описание I</proc/[pid]/pagemap>)."

#. type: Plain text
#: man-pages/man5/proc.5:3239
msgid ""
"The I</proc/kpagecgroup> file is present only if the B<CONFIG_MEMCG> kernel "
"configuration option is enabled."
msgstr ""
"Файл I</proc/kpagecgroup> существует только, если включён параметр настройки "
"ядра B<CONFIG_MEMCG>."

#. type: TP
#: man-pages/man5/proc.5:3239
#, no-wrap
msgid "I</proc/kpagecount> (since Linux 2.6.25)"
msgstr "I</proc/kpagecount> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man5/proc.5:3245
msgid ""
"This file contains a 64-bit count of the number of times each physical page "
"frame is mapped, indexed by page frame number (see the discussion of I</proc/"
"[pid]/pagemap>)."
msgstr ""
"В этом файле содержится 64-битный счётчик, который показывает сколько раз "
"отображался каждый физический страничный кадр (physical page frame). "
"Индексация счётчиков выполнена по номеру страничного кадра (смотрите "
"описание I</proc/[pid]/pagemap>)."

#. type: Plain text
#: man-pages/man5/proc.5:3251
msgid ""
"The I</proc/kpagecount> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""
"Файл I</proc/kpagecount> существует только, если включён параметр настройки "
"ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:3251
#, no-wrap
msgid "I</proc/kpageflags> (since Linux 2.6.25)"
msgstr "I</proc/kpageflags> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man5/proc.5:3257
msgid ""
"This file contains 64-bit masks corresponding to each physical page frame; "
"it is indexed by page frame number (see the discussion of I</proc/[pid]/"
"pagemap>).  The bits are as follows:"
msgstr ""
"В этом файле содержится 64-битная маска каждого физического страничного "
"кадра (physical page frame); Индексация масок выполнена по номеру "
"страничного кадра (смотрите описание I</proc/[pid]/pagemap>). Биты маски:"

#.  KPF_BALLOON: commit 09316c09dde33aae14f34489d9e3d243ec0d5938
#.  KPF_ZERO_PAGE: commit 56873f43abdcd574b25105867a990f067747b2f4
#.  KPF_IDLE: commit f074a8f49eb87cde95ac9d040ad5e7ea4f029738
#. type: Plain text
#: man-pages/man5/proc.5:3287
#, no-wrap
msgid ""
"     0 - KPF_LOCKED\n"
"     1 - KPF_ERROR\n"
"     2 - KPF_REFERENCED\n"
"     3 - KPF_UPTODATE\n"
"     4 - KPF_DIRTY\n"
"     5 - KPF_LRU\n"
"     6 - KPF_ACTIVE\n"
"     7 - KPF_SLAB\n"
"     8 - KPF_WRITEBACK\n"
"     9 - KPF_RECLAIM\n"
"    10 - KPF_BUDDY\n"
"    11 - KPF_MMAP           (since Linux 2.6.31)\n"
"    12 - KPF_ANON           (since Linux 2.6.31)\n"
"    13 - KPF_SWAPCACHE      (since Linux 2.6.31)\n"
"    14 - KPF_SWAPBACKED     (since Linux 2.6.31)\n"
"    15 - KPF_COMPOUND_HEAD  (since Linux 2.6.31)\n"
"    16 - KPF_COMPOUND_TAIL  (since Linux 2.6.31)\n"
"    17 - KPF_HUGE           (since Linux 2.6.31)\n"
"    18 - KPF_UNEVICTABLE    (since Linux 2.6.31)\n"
"    19 - KPF_HWPOISON       (since Linux 2.6.31)\n"
"    20 - KPF_NOPAGE         (since Linux 2.6.31)\n"
"    21 - KPF_KSM            (since Linux 2.6.32)\n"
"    22 - KPF_THP            (since Linux 3.4)\n"
"    23 - KPF_BALLOON        (since Linux 3.18)\n"
"    24 - KPF_ZERO_PAGE      (since Linux 4.0)\n"
"    25 - KPF_IDLE           (since Linux 4.3)\n"
msgstr ""
"     0 - KPF_LOCKED\n"
"     1 - KPF_ERROR\n"
"     2 - KPF_REFERENCED\n"
"     3 - KPF_UPTODATE\n"
"     4 - KPF_DIRTY\n"
"     5 - KPF_LRU\n"
"     6 - KPF_ACTIVE\n"
"     7 - KPF_SLAB\n"
"     8 - KPF_WRITEBACK\n"
"     9 - KPF_RECLAIM\n"
"    10 - KPF_BUDDY\n"
"    11 - KPF_MMAP           (начиная с Linux 2.6.31)\n"
"    12 - KPF_ANON           (начиная с Linux 2.6.31)\n"
"    13 - KPF_SWAPCACHE      (начиная с Linux 2.6.31)\n"
"    14 - KPF_SWAPBACKED     (начиная с Linux 2.6.31)\n"
"    15 - KPF_COMPOUND_HEAD  (начиная с Linux 2.6.31)\n"
"    16 - KPF_COMPOUND_TAIL  (начиная с Linux 2.6.31)\n"
"    17 - KPF_HUGE           (начиная с Linux 2.6.31)\n"
"    18 - KPF_UNEVICTABLE    (начиная с Linux 2.6.31)\n"
"    19 - KPF_HWPOISON       (начиная с Linux 2.6.31)\n"
"    20 - KPF_NOPAGE         (начиная с Linux 2.6.31)\n"
"    21 - KPF_KSM            (начиная с Linux 2.6.32)\n"
"    22 - KPF_THP            (начиная с Linux 3.4)\n"
"    23 - KPF_BALLOON        (начиная с Linux 3.18)\n"
"    24 - KPF_ZERO_PAGE      (начиная с Linux 4.0)\n"
"    25 - KPF_IDLE           (начиная с Linux 4.3)\n"

#.  commit ad3bdefe877afb47480418fdb05ecd42842de65e
#.  commit e07a4b9217d1e97d2f3a62b6b070efdc61212110
#. type: Plain text
#: man-pages/man5/proc.5:3300
msgid ""
"For further details on the meanings of these bits, see the kernel source "
"file I<Documentation/admin-guide/mm/pagemap.rst>.  Before kernel 2.6.29, "
"B<KPF_WRITEBACK>, B<KPF_RECLAIM>, B<KPF_BUDDY>, and B<KPF_LOCKED> did not "
"report correctly."
msgstr ""
"Информацию по отдельным битам смотрите в файле исходного кода ядра "
"I<Documentation/admin-guide/mm/pagemap.rst>. До версии ядра 2.6.29, биты "
"B<KPF_WRITEBACK>, B<KPF_RECLAIM>, B<KPF_BUDDY> и B<KPF_LOCKED> показывались "
"некорректно."

#. type: Plain text
#: man-pages/man5/proc.5:3306
msgid ""
"The I</proc/kpageflags> file is present only if the "
"B<CONFIG_PROC_PAGE_MONITOR> kernel configuration option is enabled."
msgstr ""
"Файл I</proc/kpageflags> существует только, если включён параметр настройки "
"ядра B<CONFIG_PROC_PAGE_MONITOR>."

#. type: TP
#: man-pages/man5/proc.5:3306
#, no-wrap
msgid "I</proc/ksyms> (Linux 1.1.23\\(en2.5.47)"
msgstr "I</proc/ksyms> (Linux 1.1.23\\(en2.5.47)"

#. type: Plain text
#: man-pages/man5/proc.5:3310
msgid "See I</proc/kallsyms>."
msgstr "Смотрите I</proc/kallsyms>."

#. type: TP
#: man-pages/man5/proc.5:3310
#, no-wrap
msgid "I</proc/loadavg>"
msgstr "I</proc/loadavg>"

#. type: Plain text
#: man-pages/man5/proc.5:3325
msgid ""
"The first three fields in this file are load average figures giving the "
"number of jobs in the run queue (state R)  or waiting for disk I/O (state D) "
"averaged over 1, 5, and 15 minutes.  They are the same as the load average "
"numbers given by B<uptime>(1)  and other programs.  The fourth field "
"consists of two numbers separated by a slash (/).  The first of these is the "
"number of currently runnable kernel scheduling entities (processes, "
"threads).  The value after the slash is the number of kernel scheduling "
"entities that currently exist on the system.  The fifth field is the PID of "
"the process that was most recently created on the system."
msgstr ""
"Первые три поля в этом файле содержат параметры средней загрузки, которые "
"предоставляют собой количество заданий в очереди выполнения (состояние R) "
"или ожидают дискового ввода-вывода (состояние D) в среднем за 1, 5 и 15 "
"минут. Это то же самое, что и средняя загрузка, которую выдаёт B<uptime>(1) "
"и другие программы. Четвёртое поле состоит из двух чисел, разделённых косой "
"чертой (/). Первое из них показывает количество исполняемых планируемых "
"ядерных элементов в данный момент (процессы, нити). Значение после косой "
"черты показывает количество планируемых ядерных элементов, существующих в "
"системе. В пятом поле содержится PID процесса, который был создан системой "
"последним."

#. type: TP
#: man-pages/man5/proc.5:3325
#, no-wrap
msgid "I</proc/locks>"
msgstr "I</proc/locks>"

#. type: Plain text
#: man-pages/man5/proc.5:3331
msgid ""
"This file shows current file locks (B<flock>(2) and B<fcntl>(2))  and leases "
"(B<fcntl>(2))."
msgstr ""
"Этот файл показывает текущие файловые блокировки (B<flock>(2) и B<fcntl>(2)) "
"параметры (B<fcntl>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:3333
msgid "An example of the content shown in this file is the following:"
msgstr "Пример содержимого этого файла:"

#. type: Plain text
#: man-pages/man5/proc.5:3344
#, no-wrap
msgid ""
"1: POSIX  ADVISORY  READ  5433 08:01:7864448 128 128\n"
"2: FLOCK  ADVISORY  WRITE 2001 08:01:7864554 0 EOF\n"
"3: FLOCK  ADVISORY  WRITE 1568 00:2f:32388 0 EOF\n"
"4: POSIX  ADVISORY  WRITE 699 00:16:28457 0 EOF\n"
"5: POSIX  ADVISORY  WRITE 764 00:16:21448 0 0\n"
"6: POSIX  ADVISORY  READ  3548 08:01:7867240 1 1\n"
"7: POSIX  ADVISORY  READ  3548 08:01:7865567 1826 2335\n"
"8: OFDLCK ADVISORY  WRITE -1 08:01:8713209 128 191\n"
msgstr ""
"1: POSIX  ADVISORY  READ  5433 08:01:7864448 128 128\n"
"2: FLOCK  ADVISORY  WRITE 2001 08:01:7864554 0 EOF\n"
"3: FLOCK  ADVISORY  WRITE 1568 00:2f:32388 0 EOF\n"
"4: POSIX  ADVISORY  WRITE 699 00:16:28457 0 EOF\n"
"5: POSIX  ADVISORY  WRITE 764 00:16:21448 0 0\n"
"6: POSIX  ADVISORY  READ  3548 08:01:7867240 1 1\n"
"7: POSIX  ADVISORY  READ  3548 08:01:7865567 1826 2335\n"
"8: OFDLCK ADVISORY  WRITE -1 08:01:8713209 128 191\n"

#. type: Plain text
#: man-pages/man5/proc.5:3348
msgid "The fields shown in each line are as follows:"
msgstr "Поля каждой строки имеют следующее назначение:"

#. type: Plain text
#: man-pages/man5/proc.5:3351
msgid "The ordinal position of the lock in the list."
msgstr "Порядковая позиция блокировки в списке."

#. type: Plain text
#: man-pages/man5/proc.5:3354
msgid "The lock type.  Values that may appear here include:"
msgstr "Тип блокировки. Возможные значения:"

#. type: TP
#: man-pages/man5/proc.5:3355
#, no-wrap
msgid "B<FLOCK>"
msgstr "B<FLOCK>"

#. type: Plain text
#: man-pages/man5/proc.5:3359
msgid "This is a BSD file lock created using B<flock>(2)."
msgstr "Файловая блокировка BSD, созданная B<flock>(2)."

#. type: TP
#: man-pages/man5/proc.5:3359
#, no-wrap
msgid "B<OFDLCK>"
msgstr "B<OFDLCK>"

#. type: Plain text
#: man-pages/man5/proc.5:3363
msgid "This is an open file description (OFD) lock created using B<fcntl>(2)."
msgstr "Блокировка открытого файлового описания (OFD), созданная B<fcntl>(2)."

#. type: TP
#: man-pages/man5/proc.5:3363
#, no-wrap
msgid "B<POSIX>"
msgstr "B<POSIX>"

#. type: Plain text
#: man-pages/man5/proc.5:3367
msgid "This is a POSIX byte-range lock created using B<fcntl>(2)."
msgstr "Блокировка байтового диапазона POSIX, созданная B<fcntl>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:3370
msgid "Among the strings that can appear here are the following:"
msgstr "Здесь могут появляться следующие строки:"

#. type: TP
#: man-pages/man5/proc.5:3371
#, no-wrap
msgid "B<ADVISORY>"
msgstr "B<ADVISORY>"

#. type: Plain text
#: man-pages/man5/proc.5:3374
msgid "This is an advisory lock."
msgstr "Консультативная блокировка."

#. type: TP
#: man-pages/man5/proc.5:3374
#, no-wrap
msgid "B<MANDATORY>"
msgstr "B<MANDATORY>"

#. type: Plain text
#: man-pages/man5/proc.5:3377
msgid "This is a mandatory lock."
msgstr "Обязательная блокировка."

#. type: Plain text
#: man-pages/man5/proc.5:3381
msgid "The type of lock.  Values that can appear here are:"
msgstr "Тип блокировки. Возможные значения:"

#. type: TP
#: man-pages/man5/proc.5:3382
#, no-wrap
msgid "B<READ>"
msgstr "B<READ>"

#. type: Plain text
#: man-pages/man5/proc.5:3385
msgid "This is a POSIX or OFD read lock, or a BSD shared lock."
msgstr "Блокировка POSIX или OFD на чтение или общая блокировка BSD."

#. type: TP
#: man-pages/man5/proc.5:3385
#, no-wrap
msgid "B<WRITE>"
msgstr "B<WRITE>"

#. type: Plain text
#: man-pages/man5/proc.5:3388
msgid "This is a POSIX or OFD write lock, or a BSD exclusive lock."
msgstr "Блокировка POSIX или OFD на запись или исключительная блокировка BSD."

#. type: Plain text
#: man-pages/man5/proc.5:3391
msgid "The PID of the process that owns the lock."
msgstr "PID процесса, которому принадлежит блокировка."

#.  commit 9d5b86ac13c573795525ecac6ed2db39ab23e2a8
#. type: Plain text
#: man-pages/man5/proc.5:3400
msgid ""
"Because OFD locks are not owned by a single process (since multiple "
"processes may have file descriptors that refer to the same open file "
"description), the value -1 is displayed in this field for OFD locks.  "
"(Before kernel 4.14, a bug meant that the PID of the process that initially "
"acquired the lock was displayed instead of the value -1.)"
msgstr ""
"Так как блокировки OFD принадлежат не одному процессу (так как несколько "
"процессов могут иметь файловые дескрипторы, которые указывают на одно "
"открытое файловое описание), для блокировок OFD в этом поле показывается "
"значение -1 (до ядра 4.14 вместо значения -1 показывался PID процесса, "
"который первым захватил блокировку)."

#. type: Plain text
#: man-pages/man5/proc.5:3404
msgid ""
"Three colon-separated subfields that identify the major and minor device ID "
"of the device containing the filesystem where the locked file resides, "
"followed by the inode number of the locked file."
msgstr ""
"Три разделённых двоеточием значения: старший и младший идентификаторы "
"устройства, содержащего файловую систему, в которой расположен "
"заблокированный файл, и номер иноды заблокированного файла."

#. type: Plain text
#: man-pages/man5/proc.5:3407
msgid ""
"The byte offset of the first byte of the lock.  For BSD locks, this value is "
"always 0."
msgstr ""
"Байтовое смещение первого байта блокировки. Для блокировок BSD это значение "
"всегда равно 0."

#. type: Plain text
#: man-pages/man5/proc.5:3413
msgid ""
"The byte offset of the last byte of the lock.  B<EOF> in this field means "
"that the lock extends to the end of the file.  For BSD locks, the value "
"shown is always I<EOF>."
msgstr ""
"Байтовое смещение последнего байта блокировки. Значение B<EOF> в этом поле "
"означает, что блокировка распространяется до конца файла. Для блокировок BSD "
"это значение всегда равно I<EOF>."

#.  commit d67fd44f697dff293d7cdc29af929241b669affe
#. type: Plain text
#: man-pages/man5/proc.5:3427
msgid ""
"Since Linux 4.9, the list of locks shown in I</proc/locks> is filtered to "
"show just the locks for the processes in the PID namespace (see "
"B<pid_namespaces>(7))  for which the I</proc> filesystem was mounted.  (In "
"the initial PID namespace, there is no filtering of the records shown in "
"this file.)"
msgstr ""
"Начиная с Linux 4.9, список блокировок, показываемых в I</proc/locks>, "
"фильтруется: показываются только блокировки процессов в пространстве имён "
"PID (смотрите B<pid_namespaces>(7)), для которых была смонтирована файловая "
"система I</proc> (в начальном пространстве имён PID записи этого файла не "
"фильтруются)."

#. type: Plain text
#: man-pages/man5/proc.5:3431
msgid ""
"The B<lslocks>(8)  command provides a bit more information about each lock."
msgstr "Команда B<lslocks>(8) выводит больше информации о каждой блокировке."

#. type: TP
#: man-pages/man5/proc.5:3431
#, no-wrap
msgid "I</proc/malloc> (only up to and including Linux 2.2)"
msgstr "I</proc/malloc> (только до Linux 2.2 включительно)"

#.  It looks like this only ever did something back in 1.0 days
#. type: Plain text
#: man-pages/man5/proc.5:3437
msgid ""
"This file is present only if B<CONFIG_DEBUG_MALLOC> was defined during "
"compilation."
msgstr ""
"Данный файл существует только, если ядро собрано с поддержкой "
"B<CONFIG_DEBUG_MALLOC>."

#. type: TP
#: man-pages/man5/proc.5:3437
#, no-wrap
msgid "I</proc/meminfo>"
msgstr "I</proc/meminfo>"

#. type: Plain text
#: man-pages/man5/proc.5:3453
msgid ""
"This file reports statistics about memory usage on the system.  It is used "
"by B<free>(1)  to report the amount of free and used memory (both physical "
"and swap)  on the system as well as the shared memory and buffers used by "
"the kernel.  Each line of the file consists of a parameter name, followed by "
"a colon, the value of the parameter, and an option unit of measurement (e."
"g., \"kB\").  The list below describes the parameter names and the format "
"specifier required to read the field value.  Except as noted below, all of "
"the fields have been present since at least Linux 2.6.0.  Some fields are "
"displayed only if the kernel was configured with various options; those "
"dependencies are noted in the list."
msgstr ""
"Этот файл содержит статистику по использованию памяти системы. Он "
"используется программой B<free>(1) для формирования отчёта о свободной и "
"используемой памяти (как физической, так и подкачки), а также общей памяти и "
"памяти под буферы, которую использует ядро. В каждой строке файла содержится "
"имя параметра, двоеточие, значение параметра и необязательная единица "
"измерения (например, «kB»). В списке далее описываются параметры и "
"определитель формата, требуемый для чтения значения поля. За исключением "
"замечаний, представленных ниже, все показанные поля имеются начиная с Linux "
"2.6.0. Некоторые поля появляются только, если ядро собрано с определёнными "
"параметрами; это зависимости также показаны в списке."

#. type: TP
#: man-pages/man5/proc.5:3454
#, no-wrap
msgid "I<MemTotal> %lu"
msgstr "I<MemTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3458
msgid ""
"Total usable RAM (i.e., physical RAM minus a few reserved bits and the "
"kernel binary code)."
msgstr ""
"Общее количество используемой RAM (т.е. физической RAM минус несколько "
"зарезервированных бит и исполняемый код ядра)."

#. type: TP
#: man-pages/man5/proc.5:3458
#, no-wrap
msgid "I<MemFree> %lu"
msgstr "I<MemFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3462
msgid "The sum of I<LowFree>+I<HighFree>."
msgstr "Сумма I<LowFree>+I<HighFree>."

#. type: TP
#: man-pages/man5/proc.5:3462
#, no-wrap
msgid "I<MemAvailable> %lu (since Linux 3.14)"
msgstr "I<MemAvailable> %lu (начиная с Linux 3.14)"

#. type: Plain text
#: man-pages/man5/proc.5:3466
msgid ""
"An estimate of how much memory is available for starting new applications, "
"without swapping."
msgstr ""
"Предполагаемое количество памяти, доступное для запуска новых приложений, "
"без обращения к подкачке."

#. type: TP
#: man-pages/man5/proc.5:3466
#, no-wrap
msgid "I<Buffers> %lu"
msgstr "I<Buffers> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3470
msgid ""
"Relatively temporary storage for raw disk blocks that shouldn't get "
"tremendously large (20MB or so)."
msgstr ""
"Относительно временное хранилище сырых дисковых блоков, которое не должно "
"быть очень велико (порядка 20МБ)."

#. type: TP
#: man-pages/man5/proc.5:3470
#, no-wrap
msgid "I<Cached> %lu"
msgstr "I<Cached> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3475
msgid ""
"In-memory cache for files read from the disk (the page cache).  Doesn't "
"include I<SwapCached>."
msgstr ""
"Кэш в памяти для прочитанных дисковых файлов (страничный кэш). Не включает "
"I<SwapCached>."

#. type: TP
#: man-pages/man5/proc.5:3475
#, no-wrap
msgid "I<SwapCached> %lu"
msgstr "I<SwapCached> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3483
msgid ""
"Memory that once was swapped out, is swapped back in but still also is in "
"the swap file.  (If memory pressure is high, these pages don't need to be "
"swapped out again because they are already in the swap file.  This saves I/"
"O.)"
msgstr ""
"Память, которая однажды попала в подкачку, выгрузилась обратно в память, но "
"всё равно остаётся в файле подкачки (если нагрузка на память велика, эти "
"страницы не придётся снова выгружать, так как они уже в файле подкачки — "
"предотвращается ввод-вывод)."

#. type: TP
#: man-pages/man5/proc.5:3483
#, no-wrap
msgid "I<Active> %lu"
msgstr "I<Active> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3487
msgid ""
"Memory that has been used more recently and usually not reclaimed unless "
"absolutely necessary."
msgstr ""
"Память, которая часто использовалась и обычно не высвобождается без сильной "
"необходимости."

#. type: TP
#: man-pages/man5/proc.5:3487
#, no-wrap
msgid "I<Inactive> %lu"
msgstr "I<Inactive> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3491
msgid ""
"Memory which has been less recently used.  It is more eligible to be "
"reclaimed for other purposes."
msgstr ""
"Память, которая редко использовалась. Кандидат на высвобождение для других "
"нужд."

#. type: TP
#: man-pages/man5/proc.5:3491
#, no-wrap
msgid "I<Active(anon)> %lu (since Linux 2.6.28)"
msgstr "I<Active(anon)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:3494
#, no-wrap
msgid "I<Inactive(anon)> %lu (since Linux 2.6.28)"
msgstr "I<Inactive(anon)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:3497
#, no-wrap
msgid "I<Active(file)> %lu (since Linux 2.6.28)"
msgstr "I<Active(file)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:3500
#, no-wrap
msgid "I<Inactive(file)> %lu (since Linux 2.6.28)"
msgstr "I<Inactive(file)> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:3503
#, no-wrap
msgid "I<Unevictable> %lu (since Linux 2.6.28)"
msgstr "I<Unevictable> %lu (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man5/proc.5:3508 man-pages/man5/proc.5:3513
msgid ""
"(From Linux 2.6.28 to 2.6.30, B<CONFIG_UNEVICTABLE_LRU> was required.)  [To "
"be documented.]"
msgstr ""
"(В Linux с версии 2.6.28 по 2.6.30, требовался параметр "
"B<CONFIG_UNEVICTABLE_LRU>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:3508
#, no-wrap
msgid "I<Mlocked> %lu (since Linux 2.6.28)"
msgstr "I<Mlocked> %lu (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:3513
#, no-wrap
msgid "I<HighTotal> %lu"
msgstr "I<HighTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3522
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Total amount "
"of highmem.  Highmem is all memory above ~860MB of physical memory.  Highmem "
"areas are for use by user-space programs, or for the page cache.  The kernel "
"must use tricks to access this memory, making it slower to access than "
"lowmem."
msgstr ""
"(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Общее "
"количество highmem. Highmem — это вся память выше ~860МБ физической памяти. "
"Области highmem используются программами пользовательского пространства или "
"страничным кэшем. Ядро должно применять специальные методы для получения "
"доступа к этой памяти, что делает её более медленной по сравнению с lowmem."

#. type: TP
#: man-pages/man5/proc.5:3522
#, no-wrap
msgid "I<HighFree> %lu"
msgstr "I<HighFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3526
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Amount of free "
"highmem."
msgstr ""
"(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Количество "
"свободной highmem."

#. type: TP
#: man-pages/man5/proc.5:3526
#, no-wrap
msgid "I<LowTotal> %lu"
msgstr "I<LowTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3538
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Total amount "
"of lowmem.  Lowmem is memory which can be used for everything that highmem "
"can be used for, but it is also available for the kernel's use for its own "
"data structures.  Among many other things, it is where everything from "
"I<Slab> is allocated.  Bad things happen when you're out of lowmem."
msgstr ""
"(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Общее "
"количество lowmem. Lowmem — это память, используемая для всего, что и "
"highmem, но также доступна и для структур ядра. Среди прочего, выделяется "
"для I<Slab>. Когда заканчивается lowmem происходят нехорошие вещи."

#. type: TP
#: man-pages/man5/proc.5:3538
#, no-wrap
msgid "I<LowFree> %lu"
msgstr "I<LowFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3542
msgid ""
"(Starting with Linux 2.6.19, B<CONFIG_HIGHMEM> is required.)  Amount of free "
"lowmem."
msgstr ""
"(Начиная с Linux 2.6.19, требуется параметр B<CONFIG_HIGHMEM>.) Количество "
"свободной lowmem."

#. type: TP
#: man-pages/man5/proc.5:3542
#, no-wrap
msgid "I<MmapCopy> %lu (since Linux 2.6.29)"
msgstr "I<MmapCopy> %lu (начиная с Linux 2.6.29)"

#. type: Plain text
#: man-pages/man5/proc.5:3547
msgid "(B<CONFIG_MMU> is required.)  [To be documented.]"
msgstr "(Требуется параметр B<CONFIG_MMU>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:3547
#, no-wrap
msgid "I<SwapTotal> %lu"
msgstr "I<SwapTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3550
msgid "Total amount of swap space available."
msgstr "Общее количество доступного пространства подкачки."

#. type: TP
#: man-pages/man5/proc.5:3550
#, no-wrap
msgid "I<SwapFree> %lu"
msgstr "I<SwapFree> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3553
msgid "Amount of swap space that is currently unused."
msgstr "Общее количество неиспользуемого пространства подкачки."

#. type: TP
#: man-pages/man5/proc.5:3553
#, no-wrap
msgid "I<Dirty> %lu"
msgstr "I<Dirty> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3556
msgid "Memory which is waiting to get written back to the disk."
msgstr "Память, которая ждёт записи обратно на диск."

#. type: TP
#: man-pages/man5/proc.5:3556
#, no-wrap
msgid "I<Writeback> %lu"
msgstr "I<Writeback> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3559
msgid "Memory which is actively being written back to the disk."
msgstr "Память, которая переписывается обратно на диск."

#. type: TP
#: man-pages/man5/proc.5:3559
#, no-wrap
msgid "I<AnonPages> %lu (since Linux 2.6.18)"
msgstr "I<AnonPages> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:3562
msgid "Non-file backed pages mapped into user-space page tables."
msgstr ""
"Не файловые фоновые (backed) страницы, отображённые в страничные таблицы "
"пользовательского пространства."

#. type: TP
#: man-pages/man5/proc.5:3562
#, no-wrap
msgid "I<Mapped> %lu"
msgstr "I<Mapped> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3567
msgid ""
"Files which have been mapped into memory (with B<mmap>(2)), such as "
"libraries."
msgstr ""
"Отображённые в память файлы (с помощью B<mmap>(2)), например библиотеки."

#. type: TP
#: man-pages/man5/proc.5:3567
#, no-wrap
msgid "I<Shmem> %lu (since Linux 2.6.32)"
msgstr "I<Shmem> %lu (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man5/proc.5:3572
msgid "Amount of memory consumed in B<tmpfs>(5)  filesystems."
msgstr "Объём памяти, использованной в файловых системах B<tmpfs>(5)."

#. type: TP
#: man-pages/man5/proc.5:3572
#, no-wrap
msgid "I<KReclaimable> %lu (since Linux 4.20)"
msgstr "I<KReclaimable> %lu (начиная с Linux 4.20)"

#. type: Plain text
#: man-pages/man5/proc.5:3579
msgid ""
"Kernel allocations that the kernel will attempt to reclaim under memory "
"pressure.  Includes I<SReclaimable> (below), and other direct allocations "
"with a shrinker."
msgstr ""
"Выделения ядра, которые оно будет пытаться отозвать при нехватки памяти. "
"Включают I<SReclaimable> (смотрите ниже) и другие непосредственные выделения "
"сокращателя (shrinker)."

#. type: TP
#: man-pages/man5/proc.5:3579
#, no-wrap
msgid "I<Slab> %lu"
msgstr "I<Slab> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3584
msgid "In-kernel data structures cache.  (See B<slabinfo>(5).)"
msgstr "Кэш ядерных структур данных (смотрите B<slabinfo>(5))."

#. type: TP
#: man-pages/man5/proc.5:3584
#, no-wrap
msgid "I<SReclaimable> %lu (since Linux 2.6.19)"
msgstr "I<SReclaimable> %lu (начиная с Linux 2.6.19)"

#. type: Plain text
#: man-pages/man5/proc.5:3589
msgid "Part of I<Slab>, that might be reclaimed, such as caches."
msgstr "Часть I<Slab>, которая может быть высвобождена, например кэши."

#. type: TP
#: man-pages/man5/proc.5:3589
#, no-wrap
msgid "I<SUnreclaim> %lu (since Linux 2.6.19)"
msgstr "I<SUnreclaim> %lu (начиная с Linux 2.6.19)"

#. type: Plain text
#: man-pages/man5/proc.5:3594
msgid "Part of I<Slab>, that cannot be reclaimed on memory pressure."
msgstr "Часть I<Slab>, которая не может быть высвобождена при нехватке памяти."

#. type: TP
#: man-pages/man5/proc.5:3594
#, no-wrap
msgid "I<KernelStack> %lu (since Linux 2.6.32)"
msgstr "I<KernelStack> %lu (начиная с Linux 2.6.32)"

#.  commit c6a7f5728a1db45d30df55a01adc130b4ab0327c
#. type: Plain text
#: man-pages/man5/proc.5:3597 man-pages/man5/proc.5:6014
msgid "Amount of memory allocated to kernel stacks."
msgstr "Количество памяти, выделенное под стеки ядра."

#. type: TP
#: man-pages/man5/proc.5:3597
#, no-wrap
msgid "I<PageTables> %lu (since Linux 2.6.18)"
msgstr "I<PageTables> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:3600
msgid "Amount of memory dedicated to the lowest level of page tables."
msgstr ""
"Количество памяти, выделенное под страничные таблицы на самом нижнем уровне."

#. type: TP
#: man-pages/man5/proc.5:3600
#, no-wrap
msgid "I<Quicklists> %lu (since Linux 2.6.27)"
msgstr "I<Quicklists> %lu (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man5/proc.5:3604
msgid "(B<CONFIG_QUICKLIST> is required.)  [To be documented.]"
msgstr "(Требуется параметр B<CONFIG_QUICKLIST>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:3604
#, no-wrap
msgid "I<NFS_Unstable> %lu (since Linux 2.6.18)"
msgstr "I<NFS_Unstable> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:3607
msgid "NFS pages sent to the server, but not yet committed to stable storage."
msgstr ""
"Страницы NFS, полученные сервером, но ещё не записанные в стабильное "
"хранилище."

#. type: TP
#: man-pages/man5/proc.5:3607
#, no-wrap
msgid "I<Bounce> %lu (since Linux 2.6.18)"
msgstr "I<Bounce> %lu (начиная с Linux 2.6.18)"

#. type: Plain text
#: man-pages/man5/proc.5:3610
msgid "Memory used for block device \"bounce buffers\"."
msgstr "Память, используемая для блочного устройства «bounce buffers»."

#. type: TP
#: man-pages/man5/proc.5:3610
#, no-wrap
msgid "I<WritebackTmp> %lu (since Linux 2.6.26)"
msgstr "I<WritebackTmp> %lu (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man5/proc.5:3613
msgid "Memory used by FUSE for temporary writeback buffers."
msgstr "Память, используемая FUSE для временных буферов обратной записи."

#. type: TP
#: man-pages/man5/proc.5:3613
#, no-wrap
msgid "I<CommitLimit> %lu (since Linux 2.6.10)"
msgstr "I<CommitLimit> %lu (начиная с Linux 2.6.10)"

#. type: Plain text
#: man-pages/man5/proc.5:3624
msgid ""
"This is the total amount of memory currently available to be allocated on "
"the system, expressed in kilobytes.  This limit is adhered to only if strict "
"overcommit accounting is enabled (mode 2 in I</proc/sys/vm/"
"overcommit_memory>).  The limit is calculated according to the formula "
"described under I</proc/sys/vm/overcommit_memory>.  For further details, see "
"the kernel source file I<Documentation/vm/overcommit-accounting.rst>."
msgstr ""
"Общее количество памяти, доступное в данный момент в системе для выделения, "
"выражается в байтах. Данное ограничение соблюдается только, если включён "
"жёсткий учёт перерасчёта (strict overcommit accounting) (режим 2 в I</proc/"
"sys/vm/overcommit_memory>). Ограничение вычисляется по формуле, описанной в "
"разделе про I</proc/sys/vm/overcommit_memory>. Подробности смотрите в файле "
"исходного кода ядра I<Documentation/vm/overcommit-accounting.rst>."

#. type: TP
#: man-pages/man5/proc.5:3624
#, no-wrap
msgid "I<Committed_AS> %lu"
msgstr "I<Committed_AS> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3635
msgid ""
"The amount of memory presently allocated on the system.  The committed "
"memory is a sum of all of the memory which has been allocated by processes, "
"even if it has not been \"used\" by them as of yet.  A process which "
"allocates 1GB of memory (using B<malloc>(3)  or similar), but touches only "
"300MB of that memory will show up as using only 300MB of memory even if it "
"has the address space allocated for the entire 1GB."
msgstr ""
"Количество памяти, распределённое в системе в данный момент. Задействованная "
"память (committed memory) — это сумма всей памяти, распределённая среди всех "
"процессов, даже если она ими ещё не «используется». Для процесса, взявшего "
"1ГБ памяти (например, с помощью B<malloc>(3)), но задействовавшего только "
"300МБ этой памяти, будет показано что используются только 300МБ, даже если "
"ему отдано адресное пространство 1ГБ."

#. type: Plain text
#: man-pages/man5/proc.5:3645
msgid ""
"This 1GB is memory which has been \"committed\" to by the VM and can be used "
"at any time by the allocating application.  With strict overcommit enabled "
"on the system (mode 2 in I</proc/sys/vm/overcommit_memory>), allocations "
"which would exceed the I<CommitLimit> will not be permitted.  This is useful "
"if one needs to guarantee that processes will not fail due to lack of memory "
"once that memory has been successfully allocated."
msgstr ""
"Этот 1ГБ памяти «задействован» VM и может быть использован запросившим "
"приложением в любое время. При включённом режиме жёсткого учёта перерасхода "
"(режим 2 в I</proc/sys/vm/overcommit_memory>), запросы, которые превысили бы "
"I<CommitLimit> (подробности выше), выполнены не будут. Это полезно, если "
"нужно гарантировать, что процессы не завершатся из-за нехватки памяти после "
"того, как память им будет успешно выделена."

#. type: TP
#: man-pages/man5/proc.5:3645
#, no-wrap
msgid "I<VmallocTotal> %lu"
msgstr "I<VmallocTotal> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3648
msgid "Total size of vmalloc memory area."
msgstr "Общий размер области памяти vmalloc."

#. type: TP
#: man-pages/man5/proc.5:3648
#, no-wrap
msgid "I<VmallocUsed> %lu"
msgstr "I<VmallocUsed> %lu"

#.  commit a5ad88ce8c7fae7ddc72ee49a11a75aa837788e0
#. type: Plain text
#: man-pages/man5/proc.5:3656
msgid ""
"Amount of vmalloc area which is used.  Since Linux 4.4, this field is no "
"longer calculated, and is hard coded as 0.  See I</proc/vmallocinfo>."
msgstr ""
"Размер используемой области vmalloc. Начиная с Linux 4.4 это поле не "
"вычисляется и всегда равно 0. Смотрите I</proc/vmallocinfo>."

#. type: TP
#: man-pages/man5/proc.5:3656
#, no-wrap
msgid "I<VmallocChunk> %lu"
msgstr "I<VmallocChunk> %lu"

#.  commit a5ad88ce8c7fae7ddc72ee49a11a75aa837788e0
#. type: Plain text
#: man-pages/man5/proc.5:3664
msgid ""
"Largest contiguous block of vmalloc area which is free.  Since Linux 4.4, "
"this field is no longer calculated and is hard coded as 0.  See I</proc/"
"vmallocinfo>."
msgstr ""
"Самый большой свободный непрерывный блок области vmalloc. Начиная с Linux "
"4.4 это поле не вычисляется и всегда равно 0. Смотрите I</proc/vmallocinfo>."

#. type: TP
#: man-pages/man5/proc.5:3664
#, no-wrap
msgid "I<HardwareCorrupted> %lu (since Linux 2.6.32)"
msgstr "I<HardwareCorrupted> %lu (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man5/proc.5:3668
msgid "(B<CONFIG_MEMORY_FAILURE> is required.)  [To be documented.]"
msgstr "(Требуется параметр B<CONFIG_MEMORY_FAILURE>.)  [Будет описано.]"

#. type: TP
#: man-pages/man5/proc.5:3668
#, no-wrap
msgid "I<LazyFree> %lu (since Linux 4.12)"
msgstr "I<LazyFree> %lu (начиная с Linux 4.12)"

#. type: Plain text
#: man-pages/man5/proc.5:3673
msgid "Shows the amount of memory marked by B<madvise>(2)  B<MADV_FREE>."
msgstr ""
"Отражает количество памяти, помеченной вызовом B<madvise>(2) B<MADV_FREE>."

#. type: TP
#: man-pages/man5/proc.5:3673
#, no-wrap
msgid "I<AnonHugePages> %lu (since Linux 2.6.38)"
msgstr "I<AnonHugePages> %lu (начиная с Linux 2.6.38)"

#. type: Plain text
#: man-pages/man5/proc.5:3677
msgid ""
"(B<CONFIG_TRANSPARENT_HUGEPAGE> is required.)  Non-file backed huge pages "
"mapped into user-space page tables."
msgstr ""
"(Требуется параметр B<CONFIG_TRANSPARENT_HUGEPAGE>.) Не файловые фоновые "
"огромные страницы, отображённые в страничные таблицы пользовательского "
"пространства."

#. type: TP
#: man-pages/man5/proc.5:3677
#, no-wrap
msgid "I<ShmemHugePages> %lu (since Linux 4.8)"
msgstr "I<ShmemHugePages> %lu (начиная с Linux 4.8)"

#. type: Plain text
#: man-pages/man5/proc.5:3683
msgid ""
"(B<CONFIG_TRANSPARENT_HUGEPAGE> is required.)  Memory used by shared memory "
"(shmem) and B<tmpfs>(5)  allocated with huge pages"
msgstr ""
"(требуется B<CONFIG_TRANSPARENT_HUGEPAGE>) Память, используемая для "
"выделения огромных страниц под общую память (shmem) и B<tmpfs>(5)."

#. type: TP
#: man-pages/man5/proc.5:3683
#, no-wrap
msgid "I<ShmemPmdMapped> %lu (since Linux 4.8)"
msgstr "I<ShmemPmdMapped> %lu (начиная с Linux 4.8)"

#. type: Plain text
#: man-pages/man5/proc.5:3687
msgid ""
"(B<CONFIG_TRANSPARENT_HUGEPAGE> is required.)  Shared memory mapped into "
"user space with huge pages."
msgstr ""
"(Требуется B<CONFIG_TRANSPARENT_HUGEPAGE>.) Общая память, отображённая в "
"пользовательское пространство огромными страницами."

#. type: TP
#: man-pages/man5/proc.5:3687
#, no-wrap
msgid "I<CmaTotal> %lu (since Linux 3.1)"
msgstr "I<CmaTotal> %lu (начиная с Linux 3.1)"

#. type: Plain text
#: man-pages/man5/proc.5:3691
msgid ""
"Total CMA (Contiguous Memory Allocator) pages.  (B<CONFIG_CMA> is required.)"
msgstr ""
"(Требуется B<CONFIG_CMA>.) Общее количество страниц CMA (выделитель "
"непрерывной памяти)."

#. type: TP
#: man-pages/man5/proc.5:3691
#, no-wrap
msgid "I<CmaFree> %lu (since Linux 3.1)"
msgstr "I<CmaFree> %lu (начиная с Linux 3.1)"

#. type: Plain text
#: man-pages/man5/proc.5:3695
msgid ""
"Free CMA (Contiguous Memory Allocator) pages.  (B<CONFIG_CMA> is required.)"
msgstr ""
"(Требуется B<CONFIG_CMA>.) Количество свободных страниц CMA (выделитель "
"непрерывной памяти)."

#. type: TP
#: man-pages/man5/proc.5:3695
#, no-wrap
msgid "I<HugePages_Total> %lu"
msgstr "I<HugePages_Total> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3699
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  The size of the pool of huge pages."
msgstr ""
"(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Размер пула огромных страниц."

#. type: TP
#: man-pages/man5/proc.5:3699
#, no-wrap
msgid "I<HugePages_Free> %lu"
msgstr "I<HugePages_Free> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3703
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  The number of huge pages in the pool "
"that are not yet allocated."
msgstr ""
"(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Количество нераспределённых "
"огромных страниц в пуле."

#. type: TP
#: man-pages/man5/proc.5:3703
#, no-wrap
msgid "I<HugePages_Rsvd> %lu (since Linux 2.6.17)"
msgstr "I<HugePages_Rsvd> %lu (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man5/proc.5:3712
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  This is the number of huge pages for "
"which a commitment to allocate from the pool has been made, but no "
"allocation has yet been made.  These reserved huge pages guarantee that an "
"application will be able to allocate a huge page from the pool of huge pages "
"at fault time."
msgstr ""
"(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Количество огромных страниц, "
"для которых есть обязательство по распределению в пуле, но которые ещё не "
"распределены. Эти зарезервированные огромные страницы гарантируют, что "
"приложение сможет получить огромную страницу из пула огромных страниц при "
"нехватке памяти."

#. type: TP
#: man-pages/man5/proc.5:3712
#, no-wrap
msgid "I<HugePages_Surp> %lu (since Linux 2.6.24)"
msgstr "I<HugePages_Surp> %lu (начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:3720
msgid ""
"(B<CONFIG_HUGETLB_PAGE> is required.)  This is the number of huge pages in "
"the pool above the value in I</proc/sys/vm/nr_hugepages>.  The maximum "
"number of surplus huge pages is controlled by I</proc/sys/vm/"
"nr_overcommit_hugepages>."
msgstr ""
"(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Количество огромных страниц в "
"пуле выше значения в I</proc/sys/vm/nr_hugepages>. Максимальное число "
"избыточных огромных страниц настраивается в I</proc/sys/vm/"
"nr_overcommit_hugepages>."

#. type: TP
#: man-pages/man5/proc.5:3720
#, no-wrap
msgid "I<Hugepagesize> %lu"
msgstr "I<Hugepagesize> %lu"

#. type: Plain text
#: man-pages/man5/proc.5:3724
msgid "(B<CONFIG_HUGETLB_PAGE> is required.)  The size of huge pages."
msgstr "(Требуется параметр B<CONFIG_HUGETLB_PAGE>.) Размер огромных страниц."

#. type: TP
#: man-pages/man5/proc.5:3724
#, no-wrap
msgid "I<DirectMap4k> %lu (since Linux 2.6.27)"
msgstr "I<DirectMap4k> %lu (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man5/proc.5:3728
msgid "Number of bytes of RAM linearly mapped by kernel in 4kB pages.  (x86.)"
msgstr "Количество байт RAM линейно отображаемых ядром в 4КБ страницы. (x86.)"

#. type: TP
#: man-pages/man5/proc.5:3728
#, no-wrap
msgid "I<DirectMap4M> %lu (since Linux 2.6.27)"
msgstr "I<DirectMap4M> %lu (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man5/proc.5:3736
msgid ""
"Number of bytes of RAM linearly mapped by kernel in 4MB pages.  (x86 with "
"B<CONFIG_X86_64> or B<CONFIG_X86_PAE> enabled.)"
msgstr ""
"Количество байт RAM линейно отображаемых ядром в 4МБ страницы. (x86 с "
"включённым B<CONFIG_X86_64> или B<CONFIG_X86_PAE>)."

#. type: TP
#: man-pages/man5/proc.5:3736
#, no-wrap
msgid "I<DirectMap2M> %lu (since Linux 2.6.27)"
msgstr "I<DirectMap2M> %lu (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man5/proc.5:3744
msgid ""
"Number of bytes of RAM linearly mapped by kernel in 2MB pages.  (x86 with "
"neither B<CONFIG_X86_64> nor B<CONFIG_X86_PAE> enabled.)"
msgstr ""
"Количество байт RAM линейно отображаемых ядром в 2МБ страницы. (x86 с "
"выключенными B<CONFIG_X86_64> и B<CONFIG_X86_PAE>)."

#. type: TP
#: man-pages/man5/proc.5:3744
#, no-wrap
msgid "I<DirectMap1G> %lu (since Linux 2.6.27)"
msgstr "I<DirectMap1G> %lu (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man5/proc.5:3751
msgid "(x86 with B<CONFIG_X86_64> and B<CONFIG_X86_DIRECT_GBPAGES> enabled.)"
msgstr "(x86 с включёнными B<CONFIG_X86_64> и B<CONFIG_X86_DIRECT_GBPAGES>)"

#. type: TP
#: man-pages/man5/proc.5:3752
#, no-wrap
msgid "I</proc/modules>"
msgstr "I</proc/modules>"

#. type: Plain text
#: man-pages/man5/proc.5:3757
msgid ""
"A text list of the modules that have been loaded by the system.  See also "
"B<lsmod>(8)."
msgstr ""
"Текстовый список модулей, которые были загружены системой. Смотрите также "
"B<lsmod>(8)."

#. type: TP
#: man-pages/man5/proc.5:3757
#, no-wrap
msgid "I</proc/mounts>"
msgstr "I</proc/mounts>"

#. type: Plain text
#: man-pages/man5/proc.5:3768
msgid ""
"Before kernel 2.4.19, this file was a list of all the filesystems currently "
"mounted on the system.  With the introduction of per-process mount "
"namespaces in Linux 2.4.19 (see B<mount_namespaces>(7)), this file became a "
"link to I</proc/self/mounts>, which lists the mount points of the process's "
"own mount namespace.  The format of this file is documented in B<fstab>(5)."
msgstr ""
"До ядра версии 2.4.19, в этом файле содержался список всех файловых систем, "
"которые примонтированы в настоящий момент. С введением попроцессных "
"пространств имён монтирования в Linux 2.4.19 (смотрите "
"B<mount_namespaces>(7)), этот файл стал указывать на I</proc/self/mounts>, в "
"котором представлен список точек монтирования из пространства монтирования "
"процесса. Формат этого файла описан в B<fstab>(5)."

#. type: TP
#: man-pages/man5/proc.5:3768
#, no-wrap
msgid "I</proc/mtrr>"
msgstr "I</proc/mtrr>"

#.  commit 7225e75144b9718cbbe1820d9c011c809d5773fd
#. type: Plain text
#: man-pages/man5/proc.5:3778
msgid ""
"Memory Type Range Registers.  See the Linux kernel source file "
"I<Documentation/x86/mtrr.txt> (or I<Documentation/mtrr.txt> before Linux "
"2.6.28)  for details."
msgstr ""
"Диапазонные регистры типа памяти. Подробности смотрите в файле дерева "
"исходного кода ядра Linux I<Documentation/x86/mtrr.txt> (или I<Documentation/"
"mtrr.txt> до Linux 2.6.28)."

#. type: TP
#: man-pages/man5/proc.5:3778
#, no-wrap
msgid "I</proc/net>"
msgstr "I</proc/net>"

#. type: Plain text
#: man-pages/man5/proc.5:3788
msgid ""
"This directory contains various files and subdirectories containing "
"information about the networking layer.  The files contain ASCII structures "
"and are, therefore, readable with B<cat>(1).  However, the standard "
"B<netstat>(8)  suite provides much cleaner access to these files."
msgstr ""
"Данный каталог хранит различные файлы и подкаталоги, содержащие информацию о "
"сетевой подсистеме. В файлах используются структуры в ASCII и поэтому их "
"можно читать утилитой B<cat>(1). Однако, стандартная комплект B<netstat>(8) "
"предоставляет более понятную информацию из этих файлов."

#.  commit e9720acd728a46cb40daa52c99a979f7c4ff195c
#. type: Plain text
#: man-pages/man5/proc.5:3800
msgid ""
"With the advent of network namespaces, various information relating to the "
"network stack is virtualized (see B<namespaces>(7)).  Thus, since Linux "
"2.6.25, I</proc/net> is a symbolic link to the directory I</proc/self/net>, "
"which contains the same files and directories as listed below.  However, "
"these files and directories now expose information for the network namespace "
"of which the process is a member."
msgstr ""
"С появлением сетевых пространств имён различная информация о сетевом стеке "
"стала виртуализированной (смотрите B<namespaces>(7)). То есть, начиная с "
"Linux 2.6.25 файл I</proc/net> — это символическая ссылка на каталог I</proc/"
"self/net>, в котором содержатся те же файлы и каталоги, перечисленные ниже. "
"Однако эти файлы и каталоги теперь отражают информацию для сетевого "
"пространства имён, в котором числится процесс."

#. type: TP
#: man-pages/man5/proc.5:3800
#, no-wrap
msgid "I</proc/net/arp>"
msgstr "I</proc/net/arp>"

#. type: Plain text
#: man-pages/man5/proc.5:3806
msgid ""
"This holds an ASCII readable dump of the kernel ARP table used for address "
"resolutions.  It will show both dynamically learned and preprogrammed ARP "
"entries.  The format is:"
msgstr ""
"Файл содержит читабельный ASCII-дамп ARP таблицы ядра, которая используется "
"для определения адресов. Она покажет как полученные динамически, так и "
"заданные явно записи ARP. Формат файла:"

#. type: Plain text
#: man-pages/man5/proc.5:3812
#, no-wrap
msgid ""
"IP address     HW type   Flags     HW address          Mask   Device\n"
"192.168.0.50   0x1       0x2       00:50:BF:25:68:F3   *      eth0\n"
"192.168.0.250  0x1       0xc       00:00:00:00:00:00   *      eth0\n"
msgstr ""
"IP address     HW type   Flags     HW address          Mask   Device\n"
"192.168.0.50   0x1       0x2       00:50:BF:25:68:F3   *      eth0\n"
"192.168.0.250  0x1       0xc       00:00:00:00:00:00   *      eth0\n"

#. type: Plain text
#: man-pages/man5/proc.5:3823
msgid ""
"Here \"IP address\" is the IPv4 address of the machine and the \"HW type\" "
"is the hardware type of the address from RFC\\ 826.  The flags are the "
"internal flags of the ARP structure (as defined in I</usr/include/linux/"
"if_arp.h>)  and the \"HW address\" is the data link layer mapping for that "
"IP address if it is known."
msgstr ""
"Здесь \"IP-адрес\" это адрес машины в нотации IPv4, \"Тип обор.\" это тип "
"аппаратного обеспечения для этого адреса согласно RFC\\ 826. Флаги \\(em это "
"внутренние флаги структуры ARP(определённые в I</usr/include/linux/if_arp."
"h>), а \"Аппарат. адрес\" \\(em это адрес канального уровня для IP-адреса, "
"если он известен."

#. type: TP
#: man-pages/man5/proc.5:3823
#, no-wrap
msgid "I</proc/net/dev>"
msgstr "I</proc/net/dev>"

#. type: Plain text
#: man-pages/man5/proc.5:3834
msgid ""
"The dev pseudo-file contains network device status information.  This gives "
"the number of received and sent packets, the number of errors and collisions "
"and other basic statistics.  These are used by the B<ifconfig>(8)  program "
"to report device status.  The format is:"
msgstr ""
"Псевдо-файл dev содержит информацию о состоянии сетевых устройств. Она "
"представляет собой количество принятых и отправленных пакетов, количество "
"ошибок и коллизий и другую базовую статистику. Эта информация используется "
"программой B<ifconfig>(8) для вывода отчёта о состоянии устройства. Формат "
"информации:"

#. type: Plain text
#: man-pages/man5/proc.5:3843
#, no-wrap
msgid ""
"Inter-|   Receive                                                |  Transmit\n"
" face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n"
"    lo: 2776770   11307    0    0    0     0          0         0  2776770   11307    0    0    0     0       0          0\n"
"  eth0: 1215645    2751    0    0    0     0          0         0  1782404    4324    0    0    0   427       0          0\n"
"  ppp0: 1622270    5552    1    0    0     0          0         0   354130    5669    0    0    0     0       0          0\n"
"  tap0:    7714      81    0    0    0     0          0         0     7714      81    0    0    0     0       0          0\n"
msgstr ""
"Inter-|   Receive                                                |  Transmit\n"
" face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed\n"
"    lo: 2776770   11307    0    0    0     0          0         0  2776770   11307    0    0    0     0       0          0\n"
"  eth0: 1215645    2751    0    0    0     0          0         0  1782404    4324    0    0    0   427       0          0\n"
"  ppp0: 1622270    5552    1    0    0     0          0         0   354130    5669    0    0    0     0       0          0\n"
"  tap0:    7714      81    0    0    0     0          0         0     7714      81    0    0    0     0       0          0\n"

#. type: TP
#: man-pages/man5/proc.5:3851
#, no-wrap
msgid "I</proc/net/dev_mcast>"
msgstr "I</proc/net/dev_mcast>"

#. type: Plain text
#: man-pages/man5/proc.5:3855
msgid "Defined in I</usr/src/linux/net/core/dev_mcast.c>:"
msgstr "Определено в I</usr/src/linux/net/core/dev_mcast.c>:"

#. type: Plain text
#: man-pages/man5/proc.5:3862
#, no-wrap
msgid ""
"indx interface_name  dmi_u dmi_g dmi_address\n"
"2    eth0            1     0     01005e000001\n"
"3    eth1            1     0     01005e000001\n"
"4    eth2            1     0     01005e000001\n"
msgstr ""
"индекс имя_интерфейса  dmi_u dmi_g адрес_dmi\n"
"2      eth0            1     0     01005e000001\n"
"3      eth1            1     0     01005e000001\n"
"4      eth2            1     0     01005e000001\n"

#. type: TP
#: man-pages/man5/proc.5:3864
#, no-wrap
msgid "I</proc/net/igmp>"
msgstr "I</proc/net/igmp>"

#. type: Plain text
#: man-pages/man5/proc.5:3869
msgid ""
"Internet Group Management Protocol.  Defined in I</usr/src/linux/net/core/"
"igmp.c>."
msgstr ""
"Internet Group Management Protocol (протокол управления группами Интернета). "
"Определён в I</usr/src/linux/net/core/igmp.c>."

#. type: TP
#: man-pages/man5/proc.5:3869
#, no-wrap
msgid "I</proc/net/rarp>"
msgstr "I</proc/net/rarp>"

#. type: Plain text
#: man-pages/man5/proc.5:3879
msgid ""
"This file uses the same format as the I<arp> file and contains the current "
"reverse mapping database used to provide B<rarp>(8)  reverse address lookup "
"services.  If RARP is not configured into the kernel, this file will not be "
"present."
msgstr ""
"Данный файл использует тот же формат, что и файл I<arp> и содержит текущую "
"обратную базу данных адресов ARP, используемую при работе служб обратного "
"поиска адресов B<rarp>(8). Если поддержки RARP нет в ядре, то этот файл не "
"существует."

#. type: TP
#: man-pages/man5/proc.5:3879
#, no-wrap
msgid "I</proc/net/raw>"
msgstr "I</proc/net/raw>"

#.  .TP
#.  .I /proc/net/route
#.  No information, but looks similar to
#.  .BR route (8).
#. type: Plain text
#: man-pages/man5/proc.5:3899
msgid ""
"Holds a dump of the RAW socket table.  Much of the information is not of use "
"apart from debugging.  The \"sl\" value is the kernel hash slot for the "
"socket, the \"local_address\" is the local address and protocol number "
"pair.  \\&\"St\" is the internal status of the socket.  The \"tx_queue\" and "
"\"rx_queue\" are the outgoing and incoming data queue in terms of kernel "
"memory usage.  The \"tr\", \"tm-E<gt>when\", and \"rexmits\" fields are not "
"used by RAW.  The \"uid\" field holds the effective UID of the creator of "
"the socket."
msgstr ""
"Содержит дамп таблицы неструктурированных (RAW) сокетов. Большая часть этой "
"информации не используется ни для чего, кроме отладки. Значение «s»\" \\(em "
"это хэшируемый слот ядра для сокета, «local_address» \\(em это пара "
"локальный адрес, номер протокола. \\&«St» \\(em это внутреннее состояние "
"сокета. «tx_queue» и «rx_queue» \\(em это исходящая и входящая очереди "
"данных в том, виде в каком они используются в памяти ядра. Поля «tr», «tm-"
"E<gt>when» и «rexmits» не используются в RAW. Поле «uid» содержит "
"эффективный UID создателя сокета."

#. type: TP
#: man-pages/man5/proc.5:3899
#, no-wrap
msgid "I</proc/net/snmp>"
msgstr "I</proc/net/snmp>"

#. type: Plain text
#: man-pages/man5/proc.5:3904
msgid ""
"This file holds the ASCII data needed for the IP, ICMP, TCP, and UDP "
"management information bases for an SNMP agent."
msgstr ""
"Этот файл содержит ASCII данные, необходимые SNMP-агенту для баз управляющей "
"информации IP, ICMP, TCP и UDP."

#. type: TP
#: man-pages/man5/proc.5:3904
#, no-wrap
msgid "I</proc/net/tcp>"
msgstr "I</proc/net/tcp>"

#. type: Plain text
#: man-pages/man5/proc.5:3920
msgid ""
"Holds a dump of the TCP socket table.  Much of the information is not of use "
"apart from debugging.  The \"sl\" value is the kernel hash slot for the "
"socket, the \"local_address\" is the local address and port number pair.  "
"The \"rem_address\" is the remote address and port number pair (if "
"connected).  \\&\"St\" is the internal status of the socket.  The \"tx_queue"
"\" and \"rx_queue\" are the outgoing and incoming data queue in terms of "
"kernel memory usage.  The \"tr\", \"tm-E<gt>when\", and \"rexmits\" fields "
"hold internal information of the kernel socket state and are useful only for "
"debugging.  The \"uid\" field holds the effective UID of the creator of the "
"socket."
msgstr ""
"Содержит дамп таблицы TCP-сокетов. Большая часть этой информации не "
"используется ни для чего, кроме отладки. Значение «sl» — это хэшируемый слот "
"ядра для сокета, «local_address» — это пара локальный адрес и номер порта. "
"«rem_address» — это пара удалённого локального адреса и номера порта. «st» — "
"это внутреннее состояние сокета. «tx_queue» и «rx_queue» — это исходящая и "
"входящая очереди данных в том, виде в каком они используются в памяти ядра. "
"Поля «tr», «tm-E<gt>when» и «rexmits» содержат внутреннюю информацию ядра о "
"состоянии сокета и полезны только для отладки. Поле «uid» содержит "
"эффективный UID создателя сокета."

#. type: TP
#: man-pages/man5/proc.5:3920
#, no-wrap
msgid "I</proc/net/udp>"
msgstr "I</proc/net/udp>"

#. type: Plain text
#: man-pages/man5/proc.5:3937
msgid ""
"Holds a dump of the UDP socket table.  Much of the information is not of use "
"apart from debugging.  The \"sl\" value is the kernel hash slot for the "
"socket, the \"local_address\" is the local address and port number pair.  "
"The \"rem_address\" is the remote address and port number pair (if "
"connected).  \"St\" is the internal status of the socket.  The \"tx_queue\" "
"and \"rx_queue\" are the outgoing and incoming data queue in terms of kernel "
"memory usage.  The \"tr\", \"tm-E<gt>when\", and \"rexmits\" fields are not "
"used by UDP.  The \"uid\" field holds the effective UID of the creator of "
"the socket.  The format is:"
msgstr ""
"Содержит дамп таблицы UDP-сокетов. Большая часть этой информации не "
"используется ни для чего, кроме отладки. Значение «sl» — это хэшируемый слот "
"ядра для сокета, «local_address» — это пара локальный адрес и номер порта. "
"«rem_address» — это пара удалённого локального адреса и номера порта. «st» — "
"это внутреннее состояние сокета. «tx_queue» и «rx_queue» — это исходящая и "
"входящая очереди данных в том, виде в каком они используются в памяти ядра. "
"Поля «tr», «tm-E<gt>when» и «rexmits» не используются в UDP. Поле «uid» "
"содержит эффективный UID создателя сокета. Формат:"

#. type: Plain text
#: man-pages/man5/proc.5:3944
#, no-wrap
msgid ""
"sl  local_address rem_address   st tx_queue rx_queue tr rexmits  tm-E<gt>when uid\n"
" 1: 01642C89:0201 0C642C89:03FF 01 00000000:00000001 01:000071BA 00000000 0\n"
" 1: 00000000:0801 00000000:0000 0A 00000000:00000000 00:00000000 6F000100 0\n"
" 1: 00000000:0201 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0\n"
msgstr ""
"sl  local_address rem_address   st tx_queue rx_queue tr rexmits  tm-E<gt>when uid\n"
" 1: 01642C89:0201 0C642C89:03FF 01 00000000:00000001 01:000071BA 00000000 0\n"
" 1: 00000000:0801 00000000:0000 0A 00000000:00000000 00:00000000 6F000100 0\n"
" 1: 00000000:0201 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0\n"

#. type: TP
#: man-pages/man5/proc.5:3947
#, no-wrap
msgid "I</proc/net/unix>"
msgstr "I</proc/net/unix>"

#. type: Plain text
#: man-pages/man5/proc.5:3952
msgid ""
"Lists the UNIX domain sockets present within the system and their status.  "
"The format is:"
msgstr ""
"Показывает список доменных сокетов UNIX, присутствующих в системе, а также "
"их состояния. Формат:"

#. type: Plain text
#: man-pages/man5/proc.5:3958
#, no-wrap
msgid ""
"Num RefCount Protocol Flags    Type St Inode Path\n"
" 0: 00000002 00000000 00000000 0001 03    42\n"
" 1: 00000001 00000000 00010000 0001 01  1948 /dev/printer\n"
msgstr ""
"Num RefCount Protocol Flags    Type St Inode Path\n"
" 0: 00000002 00000000 00000000 0001 03    42\n"
" 1: 00000001 00000000 00010000 0001 01  1948 /dev/printer\n"

#. type: TP
#: man-pages/man5/proc.5:3963
#, no-wrap
msgid "I<Num>:"
msgstr "I<Num>:"

#. type: Plain text
#: man-pages/man5/proc.5:3966
msgid "the kernel table slot number."
msgstr "Номер слота таблицы ядра."

#. type: TP
#: man-pages/man5/proc.5:3966
#, no-wrap
msgid "I<RefCount>:"
msgstr "I<RefCount>:"

#. type: Plain text
#: man-pages/man5/proc.5:3969
msgid "the number of users of the socket."
msgstr "Количество пользователей сокета."

#. type: TP
#: man-pages/man5/proc.5:3969
#, no-wrap
msgid "I<Protocol>:"
msgstr "I<Protocol>:"

#. type: Plain text
#: man-pages/man5/proc.5:3972
msgid "currently always 0."
msgstr "Пока всегда 0."

#. type: TP
#: man-pages/man5/proc.5:3972
#, no-wrap
msgid "I<Flags>:"
msgstr "I<Flags>:"

#. type: Plain text
#: man-pages/man5/proc.5:3975
msgid "the internal kernel flags holding the status of the socket."
msgstr "Внутренние флаги ядра, содержащие состояние сокета."

#. type: TP
#: man-pages/man5/proc.5:3975
#, no-wrap
msgid "I<Type>:"
msgstr "I<Type>:"

#. type: Plain text
#: man-pages/man5/proc.5:3985
msgid ""
"the socket type.  For B<SOCK_STREAM> sockets, this is 0001; for "
"B<SOCK_DGRAM> sockets, it is 0002; and for B<SOCK_SEQPACKET> sockets, it is "
"0005."
msgstr ""
"Тип сокета. Для сокетов B<SOCK_STREAM> значение равно 0001; для сокетов "
"B<SOCK_DGRAM> — 0002, для сокетов B<SOCK_SEQPACKET> — 0005."

#. type: TP
#: man-pages/man5/proc.5:3985
#, no-wrap
msgid "I<St>:"
msgstr "I<St>:"

#. type: Plain text
#: man-pages/man5/proc.5:3988
msgid "the internal state of the socket."
msgstr "Внутреннее состояние сокета."

#. type: TP
#: man-pages/man5/proc.5:3988
#, no-wrap
msgid "I<Inode>:"
msgstr "I<Inode>:"

#. type: Plain text
#: man-pages/man5/proc.5:3991
msgid "the inode number of the socket."
msgstr "Номер иноды сокета."

#. type: TP
#: man-pages/man5/proc.5:3991
#, no-wrap
msgid "I<Path>:"
msgstr "I<Path>:"

#. type: Plain text
#: man-pages/man5/proc.5:3998
msgid ""
"the bound pathname (if any) of the socket.  Sockets in the abstract "
"namespace are included in the list, and are shown with a I<Path> that "
"commences with the character '@'."
msgstr ""
"Путь привязки (если есть) сокета. Сокеты в абстрактном пространстве имён "
"заключаются в список и показаны в I<Path> начинающимися с символа @."

#. type: TP
#: man-pages/man5/proc.5:3999
#, no-wrap
msgid "I</proc/net/netfilter/nfnetlink_queue>"
msgstr "I</proc/net/netfilter/nfnetlink_queue>"

#. type: Plain text
#: man-pages/man5/proc.5:4005
msgid ""
"This file contains information about netfilter user-space queueing, if "
"used.  Each line represents a queue.  Queues that have not been subscribed "
"to by user space are not shown."
msgstr ""
"В этом файле содержится информация об очередях netfilter в пользовательском "
"пространстве (если используется). Каждая строка описывает очередь. Очередь, "
"на которые которые не было подписок из пространства пользователя, не "
"показываются."

#. type: Plain text
#: man-pages/man5/proc.5:4010
#, no-wrap
msgid ""
"   1   4207     0  2 65535     0     0        0  1\n"
"  (1)   (2)    (3)(4)  (5)    (6)   (7)      (8)\n"
msgstr ""
"   1   4207     0  2 65535     0     0        0  1\n"
"  (1)   (2)    (3)(4)  (5)    (6)   (7)      (8)\n"

#. type: Plain text
#: man-pages/man5/proc.5:4028
msgid ""
"The ID of the queue.  This matches what is specified in the B<--queue-num> "
"or B<--queue-balance> options to the B<iptables>(8)  NFQUEUE target.  See "
"B<iptables-extensions>(8)  for more information."
msgstr ""
"Идентификатор очереди. Совпадает с указанным в параметрах B<--queue-num> или "
"B<--queue-balance> B<iptables>(8) для цели NFQUEUE. Подробности смотрите в "
"B<iptables-extensions>(8)."

#. type: Plain text
#: man-pages/man5/proc.5:4031
msgid "The netlink port ID subscribed to the queue."
msgstr "Идентификатор порта netlink, подписанного на очередь."

#. type: Plain text
#: man-pages/man5/proc.5:4035
msgid ""
"The number of packets currently queued and waiting to be processed by the "
"application."
msgstr ""
"Количество пакетов, находящихся сейчас в очереди и ожидающих обработки "
"приложением."

#. type: Plain text
#: man-pages/man5/proc.5:4040
msgid ""
"The copy mode of the queue.  It is either 1 (metadata only) or 2 (also copy "
"payload data to user space)."
msgstr ""
"Режим копирования очереди. Равен 1 (только метаданные) или 2 (также "
"копировать в пространство пользователя данные полезной нагрузки)."

#. type: Plain text
#: man-pages/man5/proc.5:4044
msgid ""
"Copy range; that is, how many bytes of packet payload should be copied to "
"user space at most."
msgstr ""
"Диапазон копирования; то есть не более скольких байт полезной нагрузки "
"пакета должно быть скопировано в пространство пользователя."

#. type: Plain text
#: man-pages/man5/proc.5:4050
msgid ""
"queue dropped.  Number of packets that had to be dropped by the kernel "
"because too many packets are already waiting for user space to send back the "
"mandatory accept/drop verdicts."
msgstr ""
"Очередь отброшена. Количество пакетов, которое было отброшено ядром из-за "
"слишком большого количества пакетов уже ожидающих в пространстве "
"пользователя для обратной отправки согласно обязательного решения приёма/"
"отброса."

#. type: Plain text
#: man-pages/man5/proc.5:4057
msgid ""
"queue user dropped.  Number of packets that were dropped within the netlink "
"subsystem.  Such drops usually happen when the corresponding socket buffer "
"is full; that is, user space is not able to read messages fast enough."
msgstr ""
"Очередь пользователя отброшена. Количество пакетов, которое было отброшено "
"внутри подсистемы netlink. Обычно такое отбрасывание происходит когда "
"переполнен соответствующий буфер сокета; то есть пространство пользователя "
"не способно читать сообщения достаточно быстро."

#. type: Plain text
#: man-pages/man5/proc.5:4063
msgid ""
"sequence number.  Every queued packet is associated with a (32-bit)  "
"monotonically-increasing sequence number.  This shows the ID of the most "
"recent packet queued."
msgstr ""
"Последовательный номер. Каждый пакет в очереди связывается с (32-битным) "
"постоянно увеличивающимся последовательным номером. Поле отображает ID "
"самого нового пакета в очереди."

#. type: Plain text
#: man-pages/man5/proc.5:4066
msgid "The last number exists only for compatibility reasons and is always 1."
msgstr "Последний номер существует только для совместимости и всегда равен 1."

#. type: TP
#: man-pages/man5/proc.5:4066
#, no-wrap
msgid "I</proc/partitions>"
msgstr "I</proc/partitions>"

#. type: Plain text
#: man-pages/man5/proc.5:4070
msgid ""
"Contains the major and minor numbers of each partition as well as the number "
"of 1024-byte blocks and the partition name."
msgstr ""
"Содержит старший (major) и младший (minor) номер каждого раздела, а также "
"количество 1024-байтных блоков и имя раздела."

#. type: TP
#: man-pages/man5/proc.5:4070
#, no-wrap
msgid "I</proc/pci>"
msgstr "I</proc/pci>"

#. type: Plain text
#: man-pages/man5/proc.5:4074
msgid ""
"This is a listing of all PCI devices found during kernel initialization and "
"their configuration."
msgstr ""
"Это список всех устройств PCI, найденных во время инициализации ядра, а "
"также их конфигурация."

#.  FIXME Document /proc/sched_debug (since Linux 2.6.23)
#.  See also /proc/[pid]/sched
#. type: Plain text
#: man-pages/man5/proc.5:4088
msgid ""
"This file has been deprecated in favor of a new I</proc> interface for PCI "
"(I</proc/bus/pci>).  It became optional in Linux 2.2 (available with "
"B<CONFIG_PCI_OLD_PROC> set at kernel compilation).  It became once more "
"nonoptionally enabled in Linux 2.4.  Next, it was deprecated in Linux 2.6 "
"(still available with B<CONFIG_PCI_LEGACY_PROC> set), and finally removed "
"altogether since Linux 2.6.17."
msgstr ""
"Этот файл устарел и был заменён на новый интерфейс I</proc> для PCI (I</proc/"
"bus/pci>). Он стал необязательным в Linux 2.2 (доступен, если установлен "
"параметр сборки ядра B<CONFIG_PCI_OLD_PROC>). Он стал ещё более "
"необязательным в Linux 2.4. В Linux 2.6 он стал не рекомендуемым (но ещё "
"доступным через параметр B<CONFIG_PCI_LEGACY_PROC>), и, наконец, был "
"полностью удалён в Linux 2.6.17."

#. type: TP
#: man-pages/man5/proc.5:4088
#, no-wrap
msgid "I</proc/profile> (since Linux 2.4)"
msgstr "I</proc/profile> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:4100
msgid ""
"This file is present only if the kernel was booted with the I<profile=1> "
"command-line option.  It exposes kernel profiling information in a binary "
"format for use by B<readprofile>(1).  Writing (e.g., an empty string) to "
"this file resets the profiling counters; on some architectures, writing a "
"binary integer \"profiling multiplier\" of size I<sizeof(int)> sets the "
"profiling interrupt frequency."
msgstr ""
"Данный файл существует только, если ядро загружено с параметром командной "
"строки I<profile=1>. В нём содержится профилирующая информация ядра в "
"двоичном формате, которую использует B<readprofile>(1). Запись (например, "
"пустой строки) в этот файл обнуляет счётчики профилирования; на некоторых "
"архитектурах запись двоичного целого «профилирующего умножителя» размером с "
"I<sizeof(int)> устанавливает частоту профилирующего прерывания."

#. type: TP
#: man-pages/man5/proc.5:4100
#, no-wrap
msgid "I</proc/scsi>"
msgstr "I</proc/scsi>"

#. type: Plain text
#: man-pages/man5/proc.5:4110
msgid ""
"A directory with the I<scsi> mid-level pseudo-file and various SCSI low-"
"level driver directories, which contain a file for each SCSI host in this "
"system, all of which give the status of some part of the SCSI IO subsystem.  "
"These files contain ASCII structures and are, therefore, readable with "
"B<cat>(1)."
msgstr ""
"Каталог с псевдо-файлом I<scsi> и различными каталогами низкоуровневых "
"драйверов SCSI, которые содержат по одному файлу на каждый SCSI-узел в "
"системе, и которые представляют некоторую информацию о части подсистемы "
"ввода/вывода SCSI. Данные файлы содержат ASCII структуры и прекрасно "
"читаются утилитой B<cat>(1)."

#. type: Plain text
#: man-pages/man5/proc.5:4113
msgid ""
"You can also write to some of the files to reconfigure the subsystem or "
"switch certain features on or off."
msgstr ""
"Также вы можете писать в некоторые из этих файлов для перенастройки "
"подсистемы или включения/выключения некоторых возможностей."

#. type: TP
#: man-pages/man5/proc.5:4113
#, no-wrap
msgid "I</proc/scsi/scsi>"
msgstr "I</proc/scsi/scsi>"

#. type: Plain text
#: man-pages/man5/proc.5:4119
msgid ""
"This is a listing of all SCSI devices known to the kernel.  The listing is "
"similar to the one seen during bootup.  scsi currently supports only the "
"I<add-single-device> command which allows root to add a hotplugged device to "
"the list of known devices."
msgstr ""
"Это список всех SCSI-устройств, которые известны ядру. Список похож на тот, "
"что выдается при начальной загрузке. scsi в настоящий момент поддерживает "
"только команду I<add-single-device>, которая позволяет суперпользователю "
"добавлять устройства на ходу, без выключения машины."

#. type: Plain text
#: man-pages/man5/proc.5:4125
#, no-wrap
msgid "echo \\(aqscsi add-single-device 1 0 5 0\\(aq E<gt> /proc/scsi/scsi\n"
msgstr "echo \\(aqscsi add-single-device 1 0 5 0\\(aq E<gt> /proc/scsi/scsi\n"

#. type: Plain text
#: man-pages/man5/proc.5:4133
msgid ""
"will cause host scsi1 to scan on SCSI channel 0 for a device on ID 5 LUN 0.  "
"If there is already a device known on this address or the address is "
"invalid, an error will be returned."
msgstr ""
"заставит адаптер scsi1 просканировать SCSI канал 0, чтобы найти устройство с "
"ID 5 и LUN 0. Если по этому адресу уже есть известное устройство или если "
"заданный адрес неправилен, то будет возвращена ошибка."

#. type: TP
#: man-pages/man5/proc.5:4133
#, no-wrap
msgid "I</proc/scsi/[drivername]>"
msgstr "I</proc/scsi/[имя_драйвера]>"

#. type: Plain text
#: man-pages/man5/proc.5:4143
msgid ""
"I<[drivername]> can currently be NCR53c7xx, aha152x, aha1542, aha1740, "
"aic7xxx, buslogic, eata_dma, eata_pio, fdomain, in2000, pas16, qlogic, "
"scsi_debug, seagate, t128, u15-24f, ultrastore, or wd7000.  These "
"directories show up for all drivers that registered at least one SCSI HBA.  "
"Every directory contains one file per registered host.  Every host-file is "
"named after the number the host was assigned during initialization."
msgstr ""
"I<[Именем_драйвера]> в настоящий момент могут быть: NCR53c7xx, aha152x, "
"aha1542, aha1740, aic7xxx, buslogic, eata_dma, eata_pio, fdomain, in2000, "
"pas16, qlogic, scsi_debug, seagate, t128, u15-24f, ultrastore или wd7000. "
"Эти каталоги показывают все драйверы, который зарегистрированы хотя бы одним "
"SCSI HBA. Каждый каталог содержит по одному файлу на каждый "
"зарегистрированный узел. Имя каждого узла соответствует номеру, который был "
"получен этим узлом во время инициализации."

#. type: Plain text
#: man-pages/man5/proc.5:4146
msgid ""
"Reading these files will usually show driver and host configuration, "
"statistics, and so on."
msgstr ""
"Чтение данных файлов обычно показывает информацию о конфигурации драйвера и "
"узла, статистику и т. п."

#. type: Plain text
#: man-pages/man5/proc.5:4153
msgid ""
"Writing to these files allows different things on different hosts.  For "
"example, with the I<latency> and I<nolatency> commands, root can switch on "
"and off command latency measurement code in the eata_dma driver.  With the "
"I<lockup> and I<unlock> commands, root can control bus lockups simulated by "
"the scsi_debug driver."
msgstr ""
"Записывая в эти файлы, можно добиться различных результатов от разных узлов. "
"Например, командами I<latency> и I<nolatency> суперпользователь может "
"включить и выключить команду кода вычисления задержки в драйвере eata_dma. "
"Командами I<lockup> и I<unlock> суперпользователь может управлять "
"блокировками шины, которые симулирует драйвер scsi_debug."

#. type: Plain text
#: man-pages/man5/proc.5:4161
msgid ""
"This directory refers to the process accessing the I</proc> filesystem, and "
"is identical to the I</proc> directory named by the process ID of the same "
"process."
msgstr ""
"Этот каталог указывает на процесс, обращающийся к файловой системе I</proc>, "
"и идентичен каталогу I</proc>, соответствующему номеру этого процесса."

#. type: TP
#: man-pages/man5/proc.5:4161
#, no-wrap
msgid "I</proc/slabinfo>"
msgstr "I</proc/slabinfo>"

#. type: Plain text
#: man-pages/man5/proc.5:4167
msgid "Information about kernel caches.  See B<slabinfo>(5)  for details."
msgstr "Информация о кэшах ядра. Подробности в B<slabinfo>(5)."

#. type: TP
#: man-pages/man5/proc.5:4167
#, no-wrap
msgid "I</proc/stat>"
msgstr "I</proc/stat>"

#. type: Plain text
#: man-pages/man5/proc.5:4173
msgid ""
"kernel/system statistics.  Varies with architecture.  Common entries include:"
msgstr ""
"Статистика ядра/системы. Различается для разных архитектур. Общие элементы:"

#. type: TP
#: man-pages/man5/proc.5:4174
#, no-wrap
msgid "I<cpu 10132153 290696 3084719 46828483 16683 0 25195 0 175628 0>"
msgstr "I<cpu 10132153 290696 3084719 46828483 16683 0 25195 0 175628 0>"

#. type: TQ
#: man-pages/man5/proc.5:4176
#, no-wrap
msgid "I<cpu0 1393280 32966 572056 13343292 6130 0 17875 0 23933 0>"
msgstr "I<cpu0 1393280 32966 572056 13343292 6130 0 17875 0 23933 0>"

#.  1024 on Alpha and ia64
#. type: Plain text
#: man-pages/man5/proc.5:4185
msgid ""
"The amount of time, measured in units of USER_HZ (1/100ths of a second on "
"most architectures, use I<sysconf(_SC_CLK_TCK)> to obtain the right value), "
"that the system (\"cpu\" line) or the specific CPU (\"cpuI<N>\" line)  spent "
"in various states:"
msgstr ""
"Количество времени, измеряемое в единицах USER_HZ (на большинстве архитектур "
"— 1/100-я секунды; чтобы получить правильное значение используйте "
"I<sysconf(_SC_CLK_TCK)>), которые система (строка «cpu») или определённый ЦП "
"(строка «cpuI<N>») потратила в различных режимах:"

#. type: TP
#: man-pages/man5/proc.5:4186
#, no-wrap
msgid "I<user>"
msgstr "I<пользовательский>"

#. type: Plain text
#: man-pages/man5/proc.5:4189
msgid "(1) Time spent in user mode."
msgstr "(1) Время, проведённое в пользовательском режиме."

#. type: TP
#: man-pages/man5/proc.5:4189
#, no-wrap
msgid "I<nice>"
msgstr "I<nice>"

#. type: Plain text
#: man-pages/man5/proc.5:4192
msgid "(2) Time spent in user mode with low priority (nice)."
msgstr ""
"(2) Время, проведённое в пользовательском режиме с низким приоритетом (nice)."

#. type: TP
#: man-pages/man5/proc.5:4192
#, no-wrap
msgid "I<system>"
msgstr "I<системный>"

#. type: Plain text
#: man-pages/man5/proc.5:4195
msgid "(3) Time spent in system mode."
msgstr "(3) Время, проведённое в системном режиме."

#. type: TP
#: man-pages/man5/proc.5:4195
#, no-wrap
msgid "I<idle>"
msgstr "I<простой>"

#.  FIXME . Actually, the following info about the /proc/stat 'cpu' field
#.        does not seem to be quite right (at least in 2.6.12 or 3.6):
#.        the idle time in /proc/uptime does not quite match this value
#. type: Plain text
#: man-pages/man5/proc.5:4205
msgid ""
"(4) Time spent in the idle task.  This value should be USER_HZ times the "
"second entry in the I</proc/uptime> pseudo-file."
msgstr ""
"(4) Время, проведённое в ожидании. Это значение совпадает с значением "
"второго поля в псевдо-файле I</proc/uptime>."

#. type: TP
#: man-pages/man5/proc.5:4205
#, no-wrap
msgid "I<iowait> (since Linux 2.5.41)"
msgstr "I<iowait> (начиная с Linux 2.5.41)"

#.  See kernel commit 9c240d757658a3ae9968dd309e674c61f07c7f48
#. type: Plain text
#: man-pages/man5/proc.5:4210
msgid ""
"(5) Time waiting for I/O to complete.  This value is not reliable, for the "
"following reasons:"
msgstr ""
"(5) Время ожидания завершения операций ввода-вывода. Это значение ненадёжно "
"по следующим причинам:"

#. type: Plain text
#: man-pages/man5/proc.5:4216
msgid ""
"The CPU will not wait for I/O to complete; iowait is the time that a task is "
"waiting for I/O to complete.  When a CPU goes into idle state for "
"outstanding task I/O, another task will be scheduled on this CPU."
msgstr ""
"ЦП не будет ждать завершения ввода-вывода; iowait это время, которое задача "
"ждёт завершения ввода-вывода. Когда ЦП переходит в состояние простоя из-за "
"ожидания задачей ввода-вывода, на этом ЦП будет запланирована к выполнению "
"другая задача."

#. type: Plain text
#: man-pages/man5/proc.5:4220
msgid ""
"On a multi-core CPU, the task waiting for I/O to complete is not running on "
"any CPU, so the iowait of each CPU is difficult to calculate."
msgstr ""
"На многоядерных ЦП задача, ожидающая завершения ввода-вывода, не выполняется "
"на каком-либо ЦП, поэтому iowait каждого ЦП трудно подсчитать."

#. type: Plain text
#: man-pages/man5/proc.5:4224
msgid "The value in this field may I<decrease> in certain conditions."
msgstr "Значение этого поля при определённых условиях может I<уменьшаться>."

#. type: TP
#: man-pages/man5/proc.5:4225
#, no-wrap
msgid "I<irq> (since Linux 2.6.0)"
msgstr "I<irq> (начиная с Linux 2.6.0)"

#.  Precisely: Linux 2.6.0-test4
#. type: Plain text
#: man-pages/man5/proc.5:4229
msgid "(6) Time servicing interrupts."
msgstr "(6) Время обслуживания прерываний."

#. type: TP
#: man-pages/man5/proc.5:4229
#, no-wrap
msgid "I<softirq> (since Linux 2.6.0"
msgstr "I<softirq> (начиная с Linux 2.6.0)"

#.  Precisely: Linux 2.6.0-test4
#. type: Plain text
#: man-pages/man5/proc.5:4233
msgid "(7) Time servicing softirqs."
msgstr "(7) Время обслуживания softirq."

#. type: TP
#: man-pages/man5/proc.5:4233
#, no-wrap
msgid "I<steal> (since Linux 2.6.11)"
msgstr "I<steal> (начиная с Linux 2.6.11)"

#. type: Plain text
#: man-pages/man5/proc.5:4237
msgid ""
"(8) Stolen time, which is the time spent in other operating systems when "
"running in a virtualized environment"
msgstr ""
"(8) Упущенное время — время, потраченное в других операционных системах при "
"работе в виртуализованном окружении."

#. type: TP
#: man-pages/man5/proc.5:4237
#, no-wrap
msgid "I<guest> (since Linux 2.6.24)"
msgstr "I<guest> (начиная с Linux 2.6.24)"

#.  See Changelog entry for 5e84cfde51cf303d368fcb48f22059f37b3872de
#. type: Plain text
#: man-pages/man5/proc.5:4242
msgid ""
"(9) Time spent running a virtual CPU for guest operating systems under the "
"control of the Linux kernel."
msgstr ""
"(9) Время, потраченное на работу виртуального процессора для гостевых "
"операционных системах, управляемых ядром Linux."

#. type: TP
#: man-pages/man5/proc.5:4242
#, no-wrap
msgid "I<guest_nice> (since Linux 2.6.33)"
msgstr "I<guest_nice> (начиная с Linux 2.6.33)"

#.  commit ce0e7b28fb75cb003cfc8d0238613aaf1c55e797
#. type: Plain text
#: man-pages/man5/proc.5:4247
msgid ""
"(10) Time spent running a niced guest (virtual CPU for guest operating "
"systems under the control of the Linux kernel)."
msgstr ""
"(10) Время, потраченное на работу гостевого niced (виртуального процессора "
"для гостевых операционных системах, управляемых ядром Linux)."

#. type: TP
#: man-pages/man5/proc.5:4248
#, no-wrap
msgid "I<page 5741 1808>"
msgstr "I<page 5741 1808>"

#. type: Plain text
#: man-pages/man5/proc.5:4252
msgid ""
"The number of pages the system paged in and the number that were paged out "
"(from disk)."
msgstr ""
"Количество страниц, которые система загрузила с диска и выгрузила на диск."

#. type: TP
#: man-pages/man5/proc.5:4252
#, no-wrap
msgid "I<swap 1 0>"
msgstr "I<swap 1 0>"

#. type: Plain text
#: man-pages/man5/proc.5:4255
msgid "The number of swap pages that have been brought in and out."
msgstr "Количество страниц подкачки, которые загружены и выгружены."

#.  FIXME . The following is not the full picture for the 'intr' of
#.        /proc/stat on 2.6:
#. type: TP
#: man-pages/man5/proc.5:4255
#, no-wrap
msgid "I<intr 1462898>"
msgstr "I<intr 1462898>"

#. type: Plain text
#: man-pages/man5/proc.5:4265
msgid ""
"This line shows counts of interrupts serviced since boot time, for each of "
"the possible system interrupts.  The first column is the total of all "
"interrupts serviced including unnumbered architecture specific interrupts; "
"each subsequent column is the total for that particular numbered interrupt.  "
"Unnumbered interrupts are not shown, only summed into the total."
msgstr ""
"В этой строке содержится счётчик прерываний, обработанных с момента загрузки "
"системы, по каждому возможному системному прерыванию. В первом столбце "
"содержится общее количество всех обработанных прерываний, включая "
"ненумерованные, специфичные для архитектуры; в каждом последующем столбце "
"содержится общее количество по конкретному прерыванию. Ненумерованные "
"прерывания не показываются, выдаётся только их общее количество."

#. type: TP
#: man-pages/man5/proc.5:4265
#, no-wrap
msgid "I<disk_io: (2,0):(31,30,5764,1,2) (3,0):>..."
msgstr "I<disk_io: (2,0):(31,30,5764,1,2) (3,0):>…"

#. type: Plain text
#: man-pages/man5/proc.5:4268
msgid ""
"(major,disk_idx):(noinfo, read_io_ops, blks_read, write_io_ops, blks_written)"
msgstr ""
"(major,minor):(noinfo, read_io_ops, blks_read, write_io_ops, blks_written)"

#. type: Plain text
#: man-pages/man5/proc.5:4270
msgid "(Linux 2.4 only)"
msgstr "(только в Linux 2.4)"

#. type: TP
#: man-pages/man5/proc.5:4270
#, no-wrap
msgid "I<ctxt 115315>"
msgstr "I<ctxt 115315>"

#. type: Plain text
#: man-pages/man5/proc.5:4273
msgid "The number of context switches that the system underwent."
msgstr "Количество переключений контекста, произошедших в системе."

#. type: TP
#: man-pages/man5/proc.5:4273
#, no-wrap
msgid "I<btime 769041601>"
msgstr "I<btime 769041601>"

#. type: Plain text
#: man-pages/man5/proc.5:4276
msgid "boot time, in seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""
"Время начальной загрузки прошедшее с начала эпохи, 1970-01-01 00:00:00 +0000 "
"(UTC), в секундах."

#. type: TP
#: man-pages/man5/proc.5:4276
#, no-wrap
msgid "I<processes 86031>"
msgstr "I<processes 86031>"

#. type: Plain text
#: man-pages/man5/proc.5:4279
msgid "Number of forks since boot."
msgstr "Количество разветвлений (вызовов fork) с момента начальной загрузки."

#. type: TP
#: man-pages/man5/proc.5:4279
#, no-wrap
msgid "I<procs_running 6>"
msgstr "I<procs_running 6>"

#. type: Plain text
#: man-pages/man5/proc.5:4283
msgid "Number of processes in runnable state.  (Linux 2.5.45 onward.)"
msgstr "Количество процессов в состоянии работы (Linux 2.5.45 и новее)."

#. type: TP
#: man-pages/man5/proc.5:4283
#, no-wrap
msgid "I<procs_blocked 2>"
msgstr "I<procs_blocked 2>"

#. type: Plain text
#: man-pages/man5/proc.5:4287
msgid ""
"Number of processes blocked waiting for I/O to complete.  (Linux 2.5.45 "
"onward.)"
msgstr ""
"Количество заблокированных процессов, ожидающих завершения ввода-вывода "
"(Linux 2.5.45 и новее)."

#. type: TP
#: man-pages/man5/proc.5:4287
#, no-wrap
msgid "I<softirq 229245889 94 60001584 13619 5175704 2471304 28 51212741 59130143 0 51240672>"
msgstr "I<softirq 229245889 94 60001584 13619 5175704 2471304 28 51212741 59130143 0 51240672>"

#.  commit d3d64df21d3d0de675a0d3ffa7c10514f3644b30
#. type: Plain text
#: man-pages/man5/proc.5:4294
msgid ""
"This line shows the number of softirq for all CPUs.  The first column is the "
"total of all softirqs and each subsequent column is the total for particular "
"softirq.  (Linux 2.6.31 onward.)"
msgstr ""
"В этой строке показывается количество softirq для всех ЦП. В первой колонке "
"содержится общее количество всех softirq, а в каждой следующей колонке "
"содержится общее количество определённых softirq (начиная с Linux 2.6.31)."

#. type: TP
#: man-pages/man5/proc.5:4295
#, no-wrap
msgid "I</proc/swaps>"
msgstr "I</proc/swaps>"

#. type: Plain text
#: man-pages/man5/proc.5:4300
msgid "Swap areas in use.  See also B<swapon>(8)."
msgstr "Используемое пространство подкачки. См. также B<swapon>(8)."

#. type: TP
#: man-pages/man5/proc.5:4300
#, no-wrap
msgid "I</proc/sys>"
msgstr "I</proc/sys>"

#. type: Plain text
#: man-pages/man5/proc.5:4308
msgid ""
"This directory (present since 1.3.57) contains a number of files and "
"subdirectories corresponding to kernel variables.  These variables can be "
"read and sometimes modified using the I</proc> filesystem, and the "
"(deprecated)  B<sysctl>(2)  system call."
msgstr ""
"Этот каталог (присутствующий, начиная с версии 1.3.57) содержит несколько "
"файлов и подкаталогов, которые соответствуют переменным ядра. Эти переменные "
"могут быть прочитаны и иногда изменены через файловую систему I</proc>, а "
"также с помощью (не рекомендуется) системного вызова B<sysctl>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:4310
msgid ""
"String values may be terminated by either \\(aq\\e0\\(aq or \\(aq\\en\\(aq."
msgstr ""
"Строковые значения могут заканчиваться \\(aq\\e0\\(aq или \\(aq\\en\\(aq."

#. type: Plain text
#: man-pages/man5/proc.5:4318
msgid ""
"Integer and long values may be written either in decimal or in hexadecimal "
"notation (e.g. 0x3FFF).  When writing multiple integer or long values, these "
"may be separated by any of the following whitespace characters: \\(aq\\ "
"\\(aq, \\(aq\\et\\(aq, or \\(aq\\en\\(aq.  Using other separators leads to "
"the error B<EINVAL>."
msgstr ""
"Целые и длинные целые значения могут записываться в десятичной или "
"шестнадцатеричной системе счисления (например, 0x3FFF). При записи "
"нескольких значений их можно разделять любым из следующих пробельных "
"символов: \\(aq\\ \\(aq, \\(aq\\et\\(aq или \\(aq\\en\\(aq. При "
"использовании других разделителей возникает ошибка B<EINVAL>."

#. type: TP
#: man-pages/man5/proc.5:4318
#, no-wrap
msgid "I</proc/sys/abi> (since Linux 2.4.10)"
msgstr "I</proc/sys/abi> (начиная с Linux 2.4.10)"

#.  On some systems, it is not present.
#. type: Plain text
#: man-pages/man5/proc.5:4325
msgid ""
"This directory may contain files with application binary information.  See "
"the Linux kernel source file I<Documentation/sysctl/abi.txt> for more "
"information."
msgstr ""
"Этот каталог может содержать файлы информацию об исполнении приложений "
"(application binary information). Дополнительную информацию смотрите в файле "
"исходного кода ядра Linux I<Documentation/sysctl/abi.txt>."

#. type: TP
#: man-pages/man5/proc.5:4325
#, no-wrap
msgid "I</proc/sys/debug>"
msgstr "I</proc/sys/debug>"

#. type: Plain text
#: man-pages/man5/proc.5:4328 man-pages/man5/proc.5:5409
msgid "This directory may be empty."
msgstr "Данный каталог может быть пуст."

#. type: TP
#: man-pages/man5/proc.5:4328
#, no-wrap
msgid "I</proc/sys/dev>"
msgstr "I</proc/sys/dev>"

#. type: Plain text
#: man-pages/man5/proc.5:4334
msgid ""
"This directory contains device-specific information (e.g., I<dev/cdrom/"
"info>).  On some systems, it may be empty."
msgstr ""
"Данный каталог содержит информацию, специфичную для устройств (например, "
"I<dev/cdrom/info>). В некоторых системах он может быть пуст."

#. type: TP
#: man-pages/man5/proc.5:4334
#, no-wrap
msgid "I</proc/sys/fs>"
msgstr "I</proc/sys/fs>"

#. type: Plain text
#: man-pages/man5/proc.5:4338
msgid ""
"This directory contains the files and subdirectories for kernel variables "
"related to filesystems."
msgstr ""
"Подкаталог, содержащий файлы и подкаталоги с переменными ядра, касающиеся "
"файловых систем."

#. type: TP
#: man-pages/man5/proc.5:4338
#, no-wrap
msgid "I</proc/sys/fs/binfmt_misc>"
msgstr "I</proc/sys/fs/binfmt_misc>"

#. type: Plain text
#: man-pages/man5/proc.5:4346
msgid ""
"Documentation for files in this directory can be found in the Linux kernel "
"source in the file I<Documentation/admin-guide/binfmt-misc.rst> (or in "
"I<Documentation/binfmt_misc.txt> on older kernels)."
msgstr ""
"Документацию по файлам в этом каталоге можно найти в файле исходного кода "
"ядра Linux I<Documentation/admin-guide/binfmt-misc.rst> (в старых ядрах — в "
"I<Documentation/binfmt_misc.txt>)."

#. type: TP
#: man-pages/man5/proc.5:4346
#, no-wrap
msgid "I</proc/sys/fs/dentry-state> (since Linux 2.2)"
msgstr "I</proc/sys/fs/dentry-state> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:4354
msgid ""
"This file contains information about the status of the directory cache "
"(dcache).  The file contains six numbers, I<nr_dentry>, I<nr_unused>, "
"I<age_limit> (age in seconds), I<want_pages> (pages requested by system) and "
"two dummy values."
msgstr ""
"Файл содержит информацию о состоянии кэша каталогов (dcache). В нём есть "
"шесть чисел, I<nr_dentry>, I<nr_unused>, I<age_limit> (возраст в секундах), "
"I<want_pages> (страниц, запрошенных системой) и два пустых значения."

#. type: Plain text
#: man-pages/man5/proc.5:4359
msgid ""
"I<nr_dentry> is the number of allocated dentries (dcache entries).  This "
"field is unused in Linux 2.2."
msgstr ""
"I<nr_dentry> содержит количество отведённых dentries (элементов dcache). Это "
"поле не используется в Linux 2.2."

#. type: Plain text
#: man-pages/man5/proc.5:4362
msgid "I<nr_unused> is the number of unused dentries."
msgstr "I<nr_unused> содержит количество неиспользуемых dentries."

#.  looks like this is unused in kernels 2.2 to 2.6
#. type: Plain text
#: man-pages/man5/proc.5:4367
msgid ""
"I<age_limit> is the age in seconds after which dcache entries can be "
"reclaimed when memory is short."
msgstr ""
"I<age_limit> \\(em  это возраст в секундах по истечении которого элементы "
"dcache могут быть отозваны, когда памяти становится мало."

#.  looks like this is unused in kernels 2.2 to 2.6
#. type: Plain text
#: man-pages/man5/proc.5:4372
msgid ""
"I<want_pages> is nonzero when the kernel has called shrink_dcache_pages() "
"and the dcache isn't pruned yet."
msgstr ""
"I<want_pages> не равно нулю, если ядро вызвало shrink_dcache_pages(), а "
"dcache ещё не сокращён (pruned)."

#. type: TP
#: man-pages/man5/proc.5:4373
#, no-wrap
msgid "I</proc/sys/fs/dir-notify-enable>"
msgstr "I</proc/sys/fs/dir-notify-enable>"

#. type: Plain text
#: man-pages/man5/proc.5:4382
msgid ""
"This file can be used to disable or enable the I<dnotify> interface "
"described in B<fcntl>(2)  on a system-wide basis.  A value of 0 in this file "
"disables the interface, and a value of 1 enables it."
msgstr ""
"Этот файл может быть использован для включения и выключения интерфейса "
"I<dnotify>, описанного в B<fcntl>(2), во всей системе. Значение 0 в этом "
"файле отключает интерфейс, а значение 1 включает его."

#. type: TP
#: man-pages/man5/proc.5:4382
#, no-wrap
msgid "I</proc/sys/fs/dquot-max>"
msgstr "I</proc/sys/fs/dquot-max>"

#. type: Plain text
#: man-pages/man5/proc.5:4389
msgid ""
"This file shows the maximum number of cached disk quota entries.  On some "
"(2.4) systems, it is not present.  If the number of free cached disk quota "
"entries is very low and you have some awesome number of simultaneous system "
"users, you might want to raise the limit."
msgstr ""
"Этот файл показывает максимальное количество кэшируемых элементов дисковых "
"квот. В некоторых (2.4) системах его нет. Если число свободных кэшируемых "
"дисковых квот является очень маленьким, а у вас в системе одновременно "
"работает большое количество пользователей, то вам, возможно, захочется "
"увеличить этот лимит."

#. type: TP
#: man-pages/man5/proc.5:4389
#, no-wrap
msgid "I</proc/sys/fs/dquot-nr>"
msgstr "I</proc/sys/fs/dquot-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:4393
msgid ""
"This file shows the number of allocated disk quota entries and the number of "
"free disk quota entries."
msgstr ""
"Этот файл показывает количество выделенных в использование элементов "
"дисковых квот и количество свободных элементов дисковых квот."

#. type: TP
#: man-pages/man5/proc.5:4393
#, no-wrap
msgid "I</proc/sys/fs/epoll> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll> (начиная с Linux 2.6.28)"

#. type: Plain text
#: man-pages/man5/proc.5:4402
msgid ""
"This directory contains the file I<max_user_watches>, which can be used to "
"limit the amount of kernel memory consumed by the I<epoll> interface.  For "
"further details, see B<epoll>(7)."
msgstr ""
"В этом каталоге содержится файл I<max_user_watches>, который можно "
"использовать для ограничения количества памяти ядра, потребляемой "
"интерфейсом I<epoll>. Подробности смотрите в B<epoll>(7)."

#. type: TP
#: man-pages/man5/proc.5:4402
#, no-wrap
msgid "I</proc/sys/fs/file-max>"
msgstr "I</proc/sys/fs/file-max>"

#. type: Plain text
#: man-pages/man5/proc.5:4417
msgid ""
"This file defines a system-wide limit on the number of open files for all "
"processes.  System calls that fail when encountering this limit fail with "
"the error B<ENFILE>.  (See also B<setrlimit>(2), which can be used by a "
"process to set the per-process limit, B<RLIMIT_NOFILE>, on the number of "
"files it may open.)  If you get lots of error messages in the kernel log "
"about running out of file handles (look for \"VFS: file-max limit "
"E<lt>numberE<gt> reached\"), try increasing this value:"
msgstr ""
"Этот файл показывает системный лимит на количество открытых файлов для всех "
"процессов. Системные вызовы, возвращающие ошибку при достижении этого лимита "
"возвращают B<ENFILE> (смотрите также B<setrlimit>(2), который можно "
"использовать, чтобы установить ограничение B<RLIMIT_NOFILE> на количество "
"открытых файлов файлов на процесс). Если вы получаете большое количество "
"сообщений в журнале ядра об ошибках о невозможности открыть файловые "
"дескрипторы (такие как «VFS: file-max limit E<lt>numberE<gt> reached»), "
"попытайтесь увеличить это значение:"

#. type: Plain text
#: man-pages/man5/proc.5:4421
#, no-wrap
msgid "echo 100000 E<gt> /proc/sys/fs/file-max\n"
msgstr "echo 100000 E<gt> /proc/sys/fs/file-max\n"

#. type: Plain text
#: man-pages/man5/proc.5:4429
msgid ""
"Privileged processes (B<CAP_SYS_ADMIN>)  can override the I<file-max> limit."
msgstr ""
"Привилегированный процесс (с B<CAP_SYS_ADMIN>) может изменять ограничение "
"I<file-max>."

#. type: TP
#: man-pages/man5/proc.5:4429
#, no-wrap
msgid "I</proc/sys/fs/file-nr>"
msgstr "I</proc/sys/fs/file-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:4448
msgid ""
"This (read-only) file contains three numbers: the number of allocated file "
"handles (i.e., the number of files presently opened); the number of free "
"file handles; and the maximum number of file handles (i.e., the same value "
"as I</proc/sys/fs/file-max>).  If the number of allocated file handles is "
"close to the maximum, you should consider increasing the maximum.  Before "
"Linux 2.6, the kernel allocated file handles dynamically, but it didn't free "
"them again.  Instead the free file handles were kept in a list for "
"reallocation; the \"free file handles\" value indicates the size of that "
"list.  A large number of free file handles indicates that there was a past "
"peak in the usage of open file handles.  Since Linux 2.6, the kernel does "
"deallocate freed file handles, and the \"free file handles\" value is always "
"zero."
msgstr ""
"Этот файл (доступный только для чтения) содержит три числа: количество "
"выделенных файловых дескрипторов (handles), количество свободных файловых "
"дескрипторов (handles) и максимальное количество файловых дескрипторов "
"(handles). Ядро выделяет файловые дескрипторы динамически, но оно не "
"освобождает их сразу же. Если количество выделенных файловых дескрипторов "
"приближается к максимальному, то вам необходимо увеличить максимальное "
"значение. До Linux 2.6 ядро выделяло файловые дескрипторы динамически, но не "
"освобождало их. Вместо этого свободные файловые дескрипторы оставались в "
"списке для повторного выделения; значение «количество свободных файловых "
"дескрипторов» показывает размер этого списка. Большое когда количество "
"свободных файловых дескрипторов указывает на то, что ранее был пик "
"использования свободных файловых дескрипторов. Начиная с Linux 2.6 ядро "
"освобождает свободные файловые дескрипторы и «количество свободных файловых "
"дескрипторов» всегда равно 0."

#. type: TP
#: man-pages/man5/proc.5:4448
#, no-wrap
msgid "I</proc/sys/fs/inode-max> (only present until Linux 2.2)"
msgstr "I</proc/sys/fs/inode-max> (только до Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:4457
msgid ""
"This file contains the maximum number of in-memory inodes.  This value "
"should be 3\\(en4 times larger than the value in I<file-max>, since "
"I<stdin>, I<stdout> and network sockets also need an inode to handle them.  "
"When you regularly run out of inodes, you need to increase this value."
msgstr ""
"Этот файл содержит максимальное количество индексных дескрипторов, "
"находящихся в памяти. Это значение должно быть в 3\\(en4 раза больше, чем "
"максимальное значение в I<file-max>, так как I<stdin>, I<stdout> и сетевым "
"сокетам также необходимы индексные дескрипторы. Если вам регулярно не "
"хватает индексных дескрипторов, то вам необходимо увеличить это значение."

#. type: Plain text
#: man-pages/man5/proc.5:4461
msgid ""
"Starting with Linux 2.4, there is no longer a static limit on the number of "
"inodes, and this file is removed."
msgstr ""
"Начиная с Linux 2.4, больше не существует статического ограничения на "
"количество индексных дескрипторов и этот файл удалён."

#. type: TP
#: man-pages/man5/proc.5:4461
#, no-wrap
msgid "I</proc/sys/fs/inode-nr>"
msgstr "I</proc/sys/fs/inode-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:4465
msgid "This file contains the first two values from I<inode-state>."
msgstr "Этот файл содержит первые два значения из I<inode-state>."

#. type: TP
#: man-pages/man5/proc.5:4465
#, no-wrap
msgid "I</proc/sys/fs/inode-state>"
msgstr "I</proc/sys/fs/inode-state>"

#. type: Plain text
#: man-pages/man5/proc.5:4473
msgid ""
"This file contains seven numbers: I<nr_inodes>, I<nr_free_inodes>, "
"I<preshrink>, and four dummy values (always zero)."
msgstr ""
"Этот файл содержит сем чисел: I<nr_inodes>, I<nr_free_inodes>, I<preshrink> "
"и четыре заглушки (всегда равные нулю)."

#.  This can be slightly more than
#.  .I inode-max
#.  because Linux allocates them one page full at a time.
#. type: Plain text
#: man-pages/man5/proc.5:4481
msgid ""
"I<nr_inodes> is the number of inodes the system has allocated.  "
"I<nr_free_inodes> represents the number of free inodes."
msgstr ""
"В I<nr_inodes> содержится количество выделенных системой индексных "
"дескрипторов. В I<nr_free_inodes> содержится количество свободных индексных "
"дескрипторов."

#. type: Plain text
#: man-pages/man5/proc.5:4489
msgid ""
"I<preshrink> is nonzero when the I<nr_inodes> E<gt> I<inode-max> and the "
"system needs to prune the inode list instead of allocating more; since Linux "
"2.4, this field is a dummy value (always zero)."
msgstr ""
"Значение I<preshrink> не равно нулю, если I<nr_inodes> E<gt> I<inode-max> и "
"системе нужно сократить список индексных дескрипторов, а не выделять новые; "
"начиная с Linux 2.4 это значение не используется (всегда равно нулю)."

#. type: TP
#: man-pages/man5/proc.5:4489
#, no-wrap
msgid "I</proc/sys/fs/inotify> (since Linux 2.6.13)"
msgstr "I</proc/sys/fs/inotify> (начиная с Linux 2.6.13)"

#. type: Plain text
#: man-pages/man5/proc.5:4498
msgid ""
"This directory contains files I<max_queued_events>, I<max_user_instances>, "
"and I<max_user_watches>, that can be used to limit the amount of kernel "
"memory consumed by the I<inotify> interface.  For further details, see "
"B<inotify>(7)."
msgstr ""
"Этот каталог содержит файлы I<max_queued_events>, I<max_user_instances>, и "
"I<max_user_watches>, которые можно использовать для ограничения количества "
"памяти ядра, потребляемом интерфейсом I<inotify>. Подробней смотрите в "
"B<inotify>(7)."

#. type: TP
#: man-pages/man5/proc.5:4498
#, no-wrap
msgid "I</proc/sys/fs/lease-break-time>"
msgstr "I</proc/sys/fs/lease-break-time>"

#. type: Plain text
#: man-pages/man5/proc.5:4507
msgid ""
"This file specifies the grace period that the kernel grants to a process "
"holding a file lease (B<fcntl>(2))  after it has sent a signal to that "
"process notifying it that another process is waiting to open the file.  If "
"the lease holder does not remove or downgrade the lease within this grace "
"period, the kernel forcibly breaks the lease."
msgstr ""
"В этом файле задаётся период, в течении которого, ядро предоставляет "
"процессу возможность удерживать файл (B<fcntl>(2)), по окончании которого "
"оно посылает сигнал процессу, извещая его о том, что другой процесс ожидает "
"открытия этого файла. Если удерживающий файл процесс не удалит или не "
"отменит удержание файла в течении указанного периода, то ядро принудительно "
"снимет удержание."

#. type: TP
#: man-pages/man5/proc.5:4507
#, no-wrap
msgid "I</proc/sys/fs/leases-enable>"
msgstr "I</proc/sys/fs/leases-enable>"

#. type: Plain text
#: man-pages/man5/proc.5:4514
msgid ""
"This file can be used to enable or disable file leases (B<fcntl>(2))  on a "
"system-wide basis.  If this file contains the value 0, leases are disabled.  "
"A nonzero value enables leases."
msgstr ""
"Этот файл можно использовать, чтобы разрешить или запретить в системе "
"возможность удержания файла (B<fcntl>(2)). Если файл содержит 0, удержание "
"запрещено. Если не ноль \\(em разрешено."

#. type: TP
#: man-pages/man5/proc.5:4514
#, no-wrap
msgid "I</proc/sys/fs/mount-max> (since Linux 4.9)"
msgstr "I</proc/sys/fs/mount-max> (начиная с Linux 4.9)"

#.  commit d29216842a85c7970c536108e093963f02714498
#. type: Plain text
#: man-pages/man5/proc.5:4520
msgid ""
"The value in this file specifies the maximum number of mounts that may exist "
"in a mount namespace.  The default value in this file is 100,000."
msgstr ""
"Значение в этом файле задаёт максимальное количество монтирований, которые "
"могут существовать в пространстве имён монтирования. Значения файла по "
"умолчанию равно 100000."

#. type: TP
#: man-pages/man5/proc.5:4520
#, no-wrap
msgid "I</proc/sys/fs/mqueue> (since Linux 2.6.6)"
msgstr "I</proc/sys/fs/mqueue> (начиная с Linux 2.6.6)"

#. type: Plain text
#: man-pages/man5/proc.5:4528
msgid ""
"This directory contains files I<msg_max>, I<msgsize_max>, and I<queues_max>, "
"controlling the resources used by POSIX message queues.  See "
"B<mq_overview>(7)  for details."
msgstr ""
"В этом каталоге содержатся файлы I<msg_max>, I<msgsize_max> и I<queues_max>, "
"которые контролируют ресурсы, используемые очередями сообщений POSIX. "
"Подробней смотрите в B<mq_overview>(7)."

#. type: TP
#: man-pages/man5/proc.5:4528
#, no-wrap
msgid "I</proc/sys/fs/nr_open> (since Linux 2.6.25)"
msgstr "I</proc/sys/fs/nr_open> (начиная с Linux 2.6.25)"

#.  commit 9cfe015aa424b3c003baba3841a60dd9b5ad319b
#. type: Plain text
#: man-pages/man5/proc.5:4540
msgid ""
"This file imposes ceiling on the value to which the B<RLIMIT_NOFILE> "
"resource limit can be raised (see B<getrlimit>(2)).  This ceiling is "
"enforced for both unprivileged and privileged process.  The default value in "
"this file is 1048576.  (Before Linux 2.6.25, the ceiling for "
"B<RLIMIT_NOFILE> was hard-coded to the same value.)"
msgstr ""
"Этот файл налагает потолок на значение, до которого может быть повышен "
"ограничитель ресурса B<RLIMIT_NOFILE> (смотрите B<getrlimit>(2)). Этот "
"потолок применяется к непривилегированным и привилегированным процессам. "
"Значение по умолчанию в этом файле равно 1048576 (до Linux 2.6.25 потолок "
"для B<RLIMIT_NOFILE> был неизменяемым с этим же значением)."

#. type: TP
#: man-pages/man5/proc.5:4540
#, no-wrap
msgid "I</proc/sys/fs/overflowgid> and I</proc/sys/fs/overflowuid>"
msgstr "I</proc/sys/fs/overflowgid> и I</proc/sys/fs/overflowuid>"

#. type: Plain text
#: man-pages/man5/proc.5:4550
msgid ""
"These files allow you to change the value of the fixed UID and GID.  The "
"default is 65534.  Some filesystems support only 16-bit UIDs and GIDs, "
"although in Linux UIDs and GIDs are 32 bits.  When one of these filesystems "
"is mounted with writes enabled, any UID or GID that would exceed 65535 is "
"translated to the overflow value before being written to disk."
msgstr ""
"Эти файлы позволяют вам изменить значение фиксированных UID и GID. По "
"умолчанию оно равно 65534. Некоторые файловые системы поддерживают только 16-"
"битные UID и GID, в то время как в Linux UID и GID являются 32-битными. "
"Когда монтируется одна из таких файловых систем с правами, позволяющими "
"запись, все UID или GID, которые превышают 65535, транслируются перед "
"записью на диск в значения переполнения."

#. type: Plain text
#: man-pages/man5/proc.5:4554 man-pages/man5/proc.5:4558
#: man-pages/man5/proc.5:4562
msgid "See B<pipe>(7)."
msgstr "Смотрите B<pipe>(7)."

#. type: TP
#: man-pages/man5/proc.5:4562
#, no-wrap
msgid "I</proc/sys/fs/protected_hardlinks> (since Linux 3.6)"
msgstr "I</proc/sys/fs/protected_hardlinks> (начиная с Linux 3.6)"

#.  commit 800179c9b8a1e796e441674776d11cd4c05d61d7
#. type: Plain text
#: man-pages/man5/proc.5:4571
msgid ""
"When the value in this file is 0, no restrictions are placed on the creation "
"of hard links (i.e., this is the historical behavior before Linux 3.6).  "
"When the value in this file is 1, a hard link can be created to a target "
"file only if one of the following conditions is true:"
msgstr ""
"Если значение в файле равно 0, то на создание жёстких ссылок не "
"накладываются ограничения (соответствует поведению до Linux 3.6). Если "
"значение в файле равно 1, то жёсткая ссылка может быть создана, если "
"соблюдается одно из следующих условий:"

#. type: Plain text
#: man-pages/man5/proc.5:4577
msgid ""
"The calling process has the B<CAP_FOWNER> capability in its user namespace "
"and the file UID has a mapping in the namespace."
msgstr ""
"Вызывающий процесс имеет мандат B<CAP_FOWNER> в своём пользовательском "
"пространстве имён и UID файла отображён в пространстве имён."

#. type: Plain text
#: man-pages/man5/proc.5:4583
msgid ""
"The filesystem UID of the process creating the link matches the owner (UID) "
"of the target file (as described in B<credentials>(7), a process's "
"filesystem UID is normally the same as its effective UID)."
msgstr ""
"UID файловой системы процесса, создающего ссылку, совпадает с владельцем "
"(UID) файла, на который создаётся ссылка (как описано в B<credentials>(7), "
"UID файловой системы процесса обычно совпадает с эффективным UID)."

#. type: Plain text
#: man-pages/man5/proc.5:4585
msgid "All of the following conditions are true:"
msgstr "Все следующие условия выполняются:"

#. type: Plain text
#: man-pages/man5/proc.5:4588
msgid "the target is a regular file;"
msgstr "целевой файл является обычным;"

#. type: Plain text
#: man-pages/man5/proc.5:4590
msgid "the target file does not have its set-user-ID mode bit enabled;"
msgstr "на целевом файле не установлен бит режима set-user-ID;"

#. type: Plain text
#: man-pages/man5/proc.5:4593
msgid ""
"the target file does not have both its set-group-ID and group-executable "
"mode bits enabled; and"
msgstr ""
"на целевом файле не установлены биты режима set-group-ID и group-executable; "
"и"

#. type: Plain text
#: man-pages/man5/proc.5:4597
msgid ""
"the caller has permission to read and write the target file (either via the "
"file's permissions mask or because it has suitable capabilities)."
msgstr ""
"вызывающий имеет право на чтение и запись целевого файла (согласно маске "
"прав на файл или из-за имеющихся мандатов)."

#. type: Plain text
#: man-pages/man5/proc.5:4613
msgid ""
"The default value in this file is 0.  Setting the value to 1 prevents a "
"longstanding class of security issues caused by hard-link-based time-of-"
"check, time-of-use races, most commonly seen in world-writable directories "
"such as I</tmp>.  The common method of exploiting this flaw is to cross "
"privilege boundaries when following a given hard link (i.e., a root process "
"follows a hard link created by another user).  Additionally, on systems "
"without separated partitions, this stops unauthorized users from \"pinning\" "
"vulnerable set-user-ID and set-group-ID files against being upgraded by the "
"administrator, or linking to special files."
msgstr ""
"Значение по умолчанию в файле равно 0. Установка значения в 1 закрывает "
"долголетний класс проблем с безопасностью, вызванных проверкой времени на "
"основе жёсткой ссылки, состязательностью при использовании времени, наиболее "
"часто встречающейся в каталогах доступным на запись всем, таким как I</tmp>. "
"Распространённый метод использования этой уязвимости — присвоение прав при "
"переходе по жёсткой ссылке (т.е., процесс суперпользователя переходит по "
"жёсткой ссылке, созданной другим пользователем). Также, в системах без "
"выделенных разделов это останавливает неправомочных пользователей от "
"«закрепления» уязвимых файлов с битами set-user-ID и set-group-ID при "
"выполнении администратором обновления, или компоновки со специальными "
"файлами."

#. type: TP
#: man-pages/man5/proc.5:4613
#, no-wrap
msgid "I</proc/sys/fs/protected_symlinks> (since Linux 3.6)"
msgstr "I</proc/sys/fs/protected_symlinks> (начиная с Linux 3.6)"

#.  commit 800179c9b8a1e796e441674776d11cd4c05d61d7
#. type: Plain text
#: man-pages/man5/proc.5:4621
msgid ""
"When the value in this file is 0, no restrictions are placed on following "
"symbolic links (i.e., this is the historical behavior before Linux 3.6).  "
"When the value in this file is 1, symbolic links are followed only in the "
"following circumstances:"
msgstr ""
"Если значение в этом файле равно 0, то на переход по символьным ссылкам "
"никаких ограничений не накладывается (т. е., обычное поведение ядра Linux до "
"версии 3.6). Если значение в файле равно 1, то переход по символьным ссылкам "
"происходит только при следующих условиях:"

#. type: Plain text
#: man-pages/man5/proc.5:4628
msgid ""
"the filesystem UID of the process following the link matches the owner (UID) "
"of the symbolic link (as described in B<credentials>(7), a process's "
"filesystem UID is normally the same as its effective UID);"
msgstr ""
"UID файловой системы процесса, переходящего по ссылке, совпадает с "
"владельцем (UID) символьной ссылки (как описано в B<credentials>(7), UID "
"файловой системы процесса обычно совпадает с эффективным UID);"

#. type: Plain text
#: man-pages/man5/proc.5:4630
msgid "the link is not in a sticky world-writable directory; or"
msgstr ""
"ссылка не является «прилипшим» (sticky) каталогом, доступным на запись всем; "
"или"

#. type: Plain text
#: man-pages/man5/proc.5:4632
msgid "the symbolic link and its parent directory have the same owner (UID)"
msgstr ""
"символьная ссылка и её родительский каталог имеют одного владельца (UID)"

#. type: Plain text
#: man-pages/man5/proc.5:4639
msgid ""
"A system call that fails to follow a symbolic link because of the above "
"restrictions returns the error B<EACCES> in I<errno>."
msgstr ""
"Системный вызов, который не может перейти по символьной ссылке из-за "
"перечисленных выше ограничений, возвращает ошибку B<EACCES> в I<errno>."

#. type: Plain text
#: man-pages/man5/proc.5:4643
msgid ""
"The default value in this file is 0.  Setting the value to 1 avoids a "
"longstanding class of security issues based on time-of-check, time-of-use "
"races when accessing symbolic links."
msgstr ""
"Значение по умолчанию в файле равно 0. Установка значения в 1 закрывает "
"долголетний класс проблем с безопасностью, вызванных проверкой времени, "
"состязательностью при использовании времени при доступе к символьным ссылкам."

#. type: TP
#: man-pages/man5/proc.5:4643
#, no-wrap
msgid "I</proc/sys/fs/suid_dumpable> (since Linux 2.6.13)"
msgstr "I</proc/sys/fs/suid_dumpable> (начиная с Linux 2.6.13)"

#.  The following is based on text from Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:4655
msgid ""
"The value in this file is assigned to a process's \"dumpable\" flag in the "
"circumstances described in B<prctl>(2).  In effect, the value in this file "
"determines whether core dump files are produced for set-user-ID or otherwise "
"protected/tainted binaries.  The \"dumpable\" setting also affects the "
"ownership of files in a process's I</proc/[pid]> directory, as described "
"above."
msgstr ""
"Значение из этого файла присваивается флагу «возможность создания дампа» "
"процесса в случаях, описанных в B<prctl>(2). Фактически, значение в этом "
"файле определяет будут ли создаваться файлы дампа памяти для файлов с "
"установленным битом set-user-ID или других защищённых/с добавкой (tainted) "
"исполняемых файлов. Настройка «возможность создания дампа» также влияет на "
"владение файлами в каталоге процесса I</proc/[pid]> как описано выше."

#. type: Plain text
#: man-pages/man5/proc.5:4657
msgid "Three different integer values can be specified:"
msgstr "Можно указать три разных целых значения:"

#. type: TP
#: man-pages/man5/proc.5:4658
#, no-wrap
msgid "I<0\\ (default)>"
msgstr "I<0\\ (default)>"

#.  In kernel source: SUID_DUMP_DISABLE
#. type: Plain text
#: man-pages/man5/proc.5:4668
msgid ""
"This provides the traditional (pre-Linux 2.6.13) behavior.  A core dump will "
"not be produced for a process which has changed credentials (by calling "
"B<seteuid>(2), B<setgid>(2), or similar, or by executing a set-user-ID or "
"set-group-ID program)  or whose binary does not have read permission enabled."
msgstr ""
"Традиционное поведение ( до Linux 2.6.13). Дамп памяти не создаётся для "
"процесса, у которого изменены учётные данные (вызовом B<seteuid>(2), "
"B<setgid>(2) и подобным или при исполнении программы с установленными битами "
"set-user-ID или set-group-ID) или если для исполняемого файла нет права на "
"чтение."

#. type: TP
#: man-pages/man5/proc.5:4668
#, no-wrap
msgid "I<1\\ (\"debug\")>"
msgstr "I<1\\ (\"debug\")>"

#.  In kernel source: SUID_DUMP_USER
#. type: Plain text
#: man-pages/man5/proc.5:4679
msgid ""
"All processes dump core when possible.  (Reasons why a process might "
"nevertheless not dump core are described in B<core>(5).)  The core dump is "
"owned by the filesystem user ID of the dumping process and no security is "
"applied.  This is intended for system debugging situations only: this mode "
"is insecure because it allows unprivileged users to examine the memory "
"contents of privileged processes."
msgstr ""
"Все процессы создают дамп памяти, если это возможно (причины невозможности "
"создания дампа описаны в B<core>(5)). Дамп памяти принадлежит ID "
"пользователя файловой системы выполнявшегося процесса и никаких мер "
"безопасности не предпринимается. Предназначено только для системной отладки: "
"данный режим небезопасен, так как позволяет непривилегированным "
"пользователями просматривать содержимое памяти привилегированных процессов."

#. type: TP
#: man-pages/man5/proc.5:4679
#, no-wrap
msgid "I<2\\ (\"suidsafe\")>"
msgstr "I<2\\ (\"suidsafe\")>"

#.  In kernel source: SUID_DUMP_ROOT
#. type: Plain text
#: man-pages/man5/proc.5:4689
msgid ""
"Any binary which normally would not be dumped (see \"0\" above)  is dumped "
"readable by root only.  This allows the user to remove the core dump file "
"but not to read it.  For security reasons core dumps in this mode will not "
"overwrite one another or other files.  This mode is appropriate when "
"administrators are attempting to debug problems in a normal environment."
msgstr ""
"Дамп памяти будет выполняться для любого исполняемого файла, для которого "
"обычно это не происходит (см. «0» ранее) и будет доступен на чтение только "
"суперпользователю. Файл с дампом памяти обычный пользователь может удалять, "
"но не читать. По соображениям безопасности дампы памяти в этом режиме не "
"будут перезаписываться новыми или другими файлами. Этот режим подходит для "
"администраторов, когда администраторы пытаются разобраться с проблемами в "
"обычном окружении."

#.  9520628e8ceb69fa9a4aee6b57f22675d9e1b709
#.  54b501992dd2a839e94e76aa392c392b55080ce8
#. type: Plain text
#: man-pages/man5/proc.5:4700
msgid ""
"Additionally, since Linux 3.6, I</proc/sys/kernel/core_pattern> must either "
"be an absolute pathname or a pipe command, as detailed in B<core>(5).  "
"Warnings will be written to the kernel log if I<core_pattern> does not "
"follow these rules, and no core dump will be produced."
msgstr ""
"Также, начиная с Linux 3.6, значение I</proc/sys/kernel/core_pattern> должно "
"быть абсолютным путём или командой с каналом, как это описано в B<core>(5). "
"В ядерный журнал будет выдано предупреждение, если значение I<core_pattern> "
"отступает от этих правил, и дамп создан не будет."

#. type: Plain text
#: man-pages/man5/proc.5:4705
msgid ""
"For details of the effect of a process's \"dumpable\" setting on ptrace "
"access mode checking, see B<ptrace>(2)."
msgstr ""
"О том, как влияет флаг «возможности создания дампа» процесса на проверку "
"режима доступа ptrace, смотрите в B<ptrace>(2)."

#. type: TP
#: man-pages/man5/proc.5:4705
#, no-wrap
msgid "I</proc/sys/fs/super-max>"
msgstr "I</proc/sys/fs/super-max>"

#. type: Plain text
#: man-pages/man5/proc.5:4716
msgid ""
"This file controls the maximum number of superblocks, and thus the maximum "
"number of mounted filesystems the kernel can have.  You need increase only "
"I<super-max> if you need to mount more filesystems than the current value in "
"I<super-max> allows you to."
msgstr ""
"Этот файл управляет максимальным значением суперблоков и таким образом "
"максимальным количеством файловых систем, которое может смонтировать ядро. "
"Вам необходимо увеличивать I<super-max> только в том случае, если нужно "
"смонтировать больше файловых систем, чем это позволяет значение в файле "
"I<super-max>."

#. type: TP
#: man-pages/man5/proc.5:4716
#, no-wrap
msgid "I</proc/sys/fs/super-nr>"
msgstr "I</proc/sys/fs/super-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:4720
msgid "This file contains the number of filesystems currently mounted."
msgstr ""
"Этот файл содержит количество файловых систем, которое смонтировано в данный "
"момент."

#. type: TP
#: man-pages/man5/proc.5:4720
#, no-wrap
msgid "I</proc/sys/kernel>"
msgstr "I</proc/sys/kernel>"

#. type: Plain text
#: man-pages/man5/proc.5:4724
msgid ""
"This directory contains files controlling a range of kernel parameters, as "
"described below."
msgstr ""
"В этом каталоге содержатся файлы, контролирующие набор параметров ядра, "
"описанных далее."

#. type: TP
#: man-pages/man5/proc.5:4724
#, no-wrap
msgid "I</proc/sys/kernel/acct>"
msgstr "I</proc/sys/kernel/acct>"

#. type: Plain text
#: man-pages/man5/proc.5:4748
msgid ""
"This file contains three numbers: I<highwater>, I<lowwater>, and "
"I<frequency>.  If BSD-style process accounting is enabled, these values "
"control its behavior.  If free space on filesystem where the log lives goes "
"below I<lowwater> percent, accounting suspends.  If free space gets above "
"I<highwater> percent, accounting resumes.  I<frequency> determines how often "
"the kernel checks the amount of free space (value is in seconds).  Default "
"values are 4, 2 and 30.  That is, suspend accounting if 2% or less space is "
"free; resume it if 4% or more space is free; consider information about "
"amount of free space valid for 30 seconds."
msgstr ""
"В этом файле содержатся три числа: I<highwater>, I<lowwater> и I<frequency>. "
"Если включён учёт процессов в стиле BSD, то эти значения управляют его "
"поведением. Если свободного места на файловой системе, куда осуществляется "
"протоколирование учёта, становится меньше, чем I<lowwater> процентов, то "
"учёт процессов приостанавливается. Если свободного места становится больше, "
"чем I<highwater> процентов, то учёт процессов возобновляется. Значение "
"I<frequency> определяет как часто ядро проверяет свободное место (в "
"секундах). По умолчанию значения соответственно составляют 4, 2 и 30. Таким "
"образом, приостановка учёта осуществляется, если свободно менее 2% места на "
"диске; возобновление если места больше или равно 4%; информация о свободном "
"месте обновляется каждые 30 секунд."

#. type: TP
#: man-pages/man5/proc.5:4748
#, no-wrap
msgid "I</proc/sys/kernel/auto_msgmni> (Linux 2.6.27 to 3.18)"
msgstr "I</proc/sys/kernel/auto_msgmni> (Linux с 2.6.27 по 3.18)"

#.  commit 9eefe520c814f6f62c5d36a2ddcd3fb99dfdb30e (introduces feature)
#.  commit 0050ee059f7fc86b1df2527aaa14ed5dc72f9973 (rendered redundant)
#. type: Plain text
#: man-pages/man5/proc.5:4767
msgid ""
"From Linux 2.6.27 to 3.18, this file was used to control recomputing of the "
"value in I</proc/sys/kernel/msgmni> upon the addition or removal of memory "
"or upon IPC namespace creation/removal.  Echoing \"1\" into this file "
"enabled I<msgmni> automatic recomputing (and triggered a recomputation of "
"I<msgmni> based on the current amount of available memory and number of IPC "
"namespaces).  Echoing \"0\" disabled automatic recomputing.  (Automatic "
"recomputing was also disabled if a value was explicitly assigned to I</proc/"
"sys/kernel/msgmni>.)  The default value in I<auto_msgmni> was 1."
msgstr ""
"С Linux 2.6.27 по 3.18 этот файл использовался для управления перерасчётом "
"значения в I</proc/sys/kernel/msgmni> при добавлении или удалении памяти или "
"при создании/удалении пространства имён IPC. Запись «1» в этот файл включает "
"автоматический перерасчёт I<msgmni> (и возбуждает перерасчёт I<msgmni> на "
"основе текущего количества доступной памяти и количества пространств имён "
"IPC). Запись «0» отключает автоматический перерасчёт (также автоматический "
"перерасчёт отключается, если значение I</proc/sys/kernel/msgmni> было "
"назначено явно). Значением I<auto_msgmni> по умолчанию было 1."

#.  FIXME Must document the 3.19 'msgmni' changes.
#. type: Plain text
#: man-pages/man5/proc.5:4773
msgid ""
"Since Linux 3.19, the content of this file has no effect (because I<msgmni> "
"defaults to near the maximum value possible), and reads from this file "
"always return the value \"0\"."
msgstr ""
"Начиная с Linux 3.19 содержимое этого файла не учитывается (так как значение "
"I<msgmni> по умолчанию близко к максимально возможному), а чтение из этого "
"файла всегда возвращает «0»."

#. type: TP
#: man-pages/man5/proc.5:4773
#, no-wrap
msgid "I</proc/sys/kernel/cap_last_cap> (since Linux 3.2)"
msgstr "I</proc/sys/kernel/cap_last_cap> (начиная с Linux 3.2)"

#. type: Plain text
#: man-pages/man5/proc.5:4777
msgid "See B<capabilities>(7)."
msgstr "Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man5/proc.5:4777
#, no-wrap
msgid "I</proc/sys/kernel/cap-bound> (from Linux 2.2 to 2.6.24)"
msgstr "I</proc/sys/kernel/cap-bound> (с Linux 2.2 до 2.6.24)"

#. type: Plain text
#: man-pages/man5/proc.5:4789
msgid ""
"This file holds the value of the kernel I<capability bounding set> "
"(expressed as a signed decimal number).  This set is ANDed against the "
"capabilities permitted to a process during B<execve>(2).  Starting with "
"Linux 2.6.25, the system-wide capability bounding set disappeared, and was "
"replaced by a per-thread bounding set; see B<capabilities>(7)."
msgstr ""
"Этот файл содержит I<набор привязанных мандатов> ядра (выражаемый как "
"десятичные числа со знаком). Этот набор мандатов, предоставляемых процессу "
"во время B<execve>(2), которые складываются посредством битового умножения "
"(AND). Начиная с Linux 2.6.25, глобального набора привязанных мандатов "
"больше нет, теперь свой набор привязанных мандатов есть у каждой нити; "
"смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man5/proc.5:4789
#, no-wrap
msgid "I</proc/sys/kernel/core_pattern>"
msgstr "I</proc/sys/kernel/core_pattern>"

#. type: TP
#: man-pages/man5/proc.5:4793
#, no-wrap
msgid "I</proc/sys/kernel/core_pipe_limit>"
msgstr "I</proc/sys/kernel/core_pipe_limit>"

#. type: TP
#: man-pages/man5/proc.5:4797
#, no-wrap
msgid "I</proc/sys/kernel/core_uses_pid>"
msgstr "I</proc/sys/kernel/core_uses_pid>"

#. type: TP
#: man-pages/man5/proc.5:4801
#, no-wrap
msgid "I</proc/sys/kernel/ctrl-alt-del>"
msgstr "I</proc/sys/kernel/ctrl-alt-del>"

#. type: Plain text
#: man-pages/man5/proc.5:4816
msgid ""
"This file controls the handling of Ctrl-Alt-Del from the keyboard.  When the "
"value in this file is 0, Ctrl-Alt-Del is trapped and sent to the B<init>(1)  "
"program to handle a graceful restart.  When the value is greater than zero, "
"Linux's reaction to a Vulcan Nerve Pinch (tm) will be an immediate reboot, "
"without even syncing its dirty buffers.  Note: when a program (like dosemu) "
"has the keyboard in \"raw\" mode, the ctrl-alt-del is intercepted by the "
"program before it ever reaches the kernel tty layer, and it's up to the "
"program to decide what to do with it."
msgstr ""
"Этот файл управляет обработкой нажатия клавиш Ctrl-Alt-Del. Когда значение в "
"этом файле равно 0, Ctrl-Alt-Del обрабатывается и производит вызов программы "
"B<init>(1) для выполнения контролируемого перезапуска системы. Когда "
"значение в файле больше 0, реакция Linux соответствует Vulcan Nerve Pinch "
"(tm) [коронный приём расы Vulcan, см. сериал Star Trek], согласно которому "
"произойдёт немедленная перезагрузка, даже без синхронизации буферов дисков. "
"Замечание: когда какая-либо программа (типа dosemu) работает с клавиатурой в "
"режиме «без обработки», нажатие ctrl-alt-del обработается этой программой, "
"до того как оно достигнет уровня tty ядра и, таким образом, именно эта "
"программа будет решать, что делать."

#. type: TP
#: man-pages/man5/proc.5:4816
#, no-wrap
msgid "I</proc/sys/kernel/dmesg_restrict> (since Linux 2.6.37)"
msgstr "I</proc/sys/kernel/dmesg_restrict> (начиная с Linux 2.6.37)"

#.  commit 620f6e8e855d6d447688a5f67a4e176944a084e8
#. type: Plain text
#: man-pages/man5/proc.5:4829
msgid ""
"The value in this file determines who can see kernel syslog contents.  A "
"value of 0 in this file imposes no restrictions.  If the value is 1, only "
"privileged users can read the kernel syslog.  (See B<syslog>(2)  for more "
"details.)  Since Linux 3.4, only users with the B<CAP_SYS_ADMIN> capability "
"may change the value in this file."
msgstr ""
"Значение этого файла определяет, кто может видеть содержимое syslog от ядра. "
"Значение 0 снимает все ограничения. Если значение равно 1,то только "
"привилегированные пользователи могут читать syslog от ядра (подробности "
"смотрите B<syslog>(2) в). Начиная с Linux 3.4, только пользователи с "
"мандатом B<CAP_SYS_ADMIN> могут изменять содержимое этого файла."

#. type: TP
#: man-pages/man5/proc.5:4829
#, no-wrap
msgid "I</proc/sys/kernel/domainname> and I</proc/sys/kernel/hostname>"
msgstr "I</proc/sys/kernel/domainname> и I</proc/sys/kernel/hostname>"

#. type: Plain text
#: man-pages/man5/proc.5:4837
msgid ""
"can be used to set the NIS/YP domainname and the hostname of your box in "
"exactly the same way as the commands B<domainname>(1)  and B<hostname>(1), "
"that is:"
msgstr ""
"могут быть использованы для установки имени домена службы NIS/YP и имени "
"узла вашей машины точно таким же образом как и командами B<domainname>(1) и "
"B<hostname>(1), т.е.:"

#. type: Plain text
#: man-pages/man5/proc.5:4842
#, no-wrap
msgid ""
"#B< echo \\(aqdarkstar\\(aq E<gt> /proc/sys/kernel/hostname>\n"
"#B< echo \\(aqmydomain\\(aq E<gt> /proc/sys/kernel/domainname>\n"
msgstr ""
"#B< echo \\(aqdarkstar\\(aq E<gt> /proc/sys/kernel/hostname>\n"
"#B< echo \\(aqmydomain\\(aq E<gt> /proc/sys/kernel/domainname>\n"

#. type: Plain text
#: man-pages/man5/proc.5:4846
msgid "has the same effect as"
msgstr "выполнят тоже самое, что и команды"

#. type: Plain text
#: man-pages/man5/proc.5:4851
#, no-wrap
msgid ""
"#B< hostname \\(aqdarkstar\\(aq>\n"
"#B< domainname \\(aqmydomain\\(aq>\n"
msgstr ""
"#B< hostname \\(aqdarkstar\\(aq>\n"
"#B< domainname \\(aqmydomain\\(aq>\n"

#. type: Plain text
#: man-pages/man5/proc.5:4864
msgid ""
"Note, however, that the classic darkstar.frop.org has the hostname \"darkstar"
"\" and DNS (Internet Domain Name Server)  domainname \"frop.org\", not to be "
"confused with the NIS (Network Information Service) or YP (Yellow Pages) "
"domainname.  These two domain names are in general different.  For a "
"detailed discussion see the B<hostname>(1)  man page."
msgstr ""
"Однако заметим, что классический darkstar.frop.org имеет имя узла \"darkstar"
"\" и доменное имя DNS (Сервера Доменных Имен) \"frop.org\", не путайте с "
"доменным именем NIS (Службы Сетевой Информации) или как она раньше "
"называлась YP (Yellow Pages). Эти два доменных имени полностью различны по "
"своей сути. Подробности об это можно найти в справочной странице "
"B<hostname>(1)."

#. type: TP
#: man-pages/man5/proc.5:4864
#, no-wrap
msgid "I</proc/sys/kernel/hotplug>"
msgstr "I</proc/sys/kernel/hotplug>"

#. type: Plain text
#: man-pages/man5/proc.5:4870
msgid ""
"This file contains the pathname for the hotplug policy agent.  The default "
"value in this file is I</sbin/hotplug>."
msgstr ""
"Этот файл содержит путь для агента политики устройств. По умолчанию это файл "
"I</sbin/hotplug>."

#.  Removed in commit 87f504e5c78b910b0c1d6ffb89bc95e492322c84 (tglx/history.git)
#. type: TP
#: man-pages/man5/proc.5:4870
#, no-wrap
msgid "I</proc/sys/kernel/htab-reclaim> (before Linux 2.4.9.2)"
msgstr "I</proc/sys/kernel/htab-reclaim> (до Linux 2.4.9.2)"

#.  removed in commit 1b483a6a7b2998e9c98ad985d7494b9b725bd228, before 2.6.28
#. type: Plain text
#: man-pages/man5/proc.5:4880
msgid ""
"(PowerPC only) If this file is set to a nonzero value, the PowerPC htab (see "
"kernel file I<Documentation/powerpc/ppc_htab.txt>)  is pruned each time the "
"system hits the idle loop."
msgstr ""
"(только для PowerPC) Если значение в этом файле установлено в ненулевое "
"значение, то PowerPC htab (см. файл I<Documentation/powerpc/ppc_htab.txt> в "
"исходном коде ядра) сокращается каждый раз, когда система входит в цикл "
"простоя."

#. type: TP
#: man-pages/man5/proc.5:4880
#, no-wrap
msgid "I</proc/sys/kernel/keys/*>"
msgstr "I</proc/sys/kernel/keys/*>"

#. type: Plain text
#: man-pages/man5/proc.5:4886
msgid ""
"This directory contains various files that define parameters and limits for "
"the key-management facility.  These files are described in B<keyrings>(7)."
msgstr ""
"В этом каталоге содержатся различные файлы, определяющие параметры и "
"ограничения инфраструктуры управления ключами. Эти файлы описаны в "
"B<keyrings>(7)."

#. type: TP
#: man-pages/man5/proc.5:4886
#, no-wrap
msgid "I</proc/sys/kernel/kptr_restrict> (since Linux 2.6.38)"
msgstr "I</proc/sys/kernel/kptr_restrict> (начиная с Linux 2.6.38)"

#.  455cd5ab305c90ffc422dd2e0fb634730942b257
#.  commit 411f05f123cbd7f8aa1edcae86970755a6e2a9d9
#.  commit 620f6e8e855d6d447688a5f67a4e176944a084e8
#. type: Plain text
#: man-pages/man5/proc.5:4911
msgid ""
"The value in this file determines whether kernel addresses are exposed via "
"I</proc> files and other interfaces.  A value of 0 in this file imposes no "
"restrictions.  If the value is 1, kernel pointers printed using the I<%pK> "
"format specifier will be replaced with zeros unless the user has the "
"B<CAP_SYSLOG> capability.  If the value is 2, kernel pointers printed using "
"the I<%pK> format specifier will be replaced with zeros regardless of the "
"user's capabilities.  The initial default value for this file was 1, but the "
"default was changed to 0 in Linux 2.6.39.  Since Linux 3.4, only users with "
"the B<CAP_SYS_ADMIN> capability can change the value in this file."
msgstr ""
"Значением этого файла определяется будут ли видны ядра ядра, показываемые в "
"файлах I</proc> и других интерфейсах. Значение 0 снимает все ограничения. "
"Если значение равно 1, то указатели ядра, выводимые по формату I<%pK>, будут "
"заменены на нули, если пользователь не имеет мандата B<CAP_SYSLOG>. Если "
"значение равно 2, то указатели ядра, выводимые по формату I<%pK>, будут "
"заменены на нули, независимо от наличия мандатов у пользователя. В начале "
"значение по умолчанию было равно 1, но изменилось на 0 в Linux 2.6.39. "
"Начиная с Linux 3.4, только пользователи с мандатом B<CAP_SYS_ADMIN> могут "
"изменять значение в этом файле."

#. type: TP
#: man-pages/man5/proc.5:4911
#, no-wrap
msgid "I</proc/sys/kernel/l2cr>"
msgstr "I</proc/sys/kernel/l2cr>"

#. type: Plain text
#: man-pages/man5/proc.5:4918
msgid ""
"(PowerPC only) This file contains a flag that controls the L2 cache of G3 "
"processor boards.  If 0, the cache is disabled.  Enabled if nonzero."
msgstr ""
"(только для PowerPC) Этот файл содержит флаг, который управляет кэшем L2 на "
"процессорных платах G3. Если 0, кэш выключен. Если не ноль, то включён."

#. type: TP
#: man-pages/man5/proc.5:4918
#, no-wrap
msgid "I</proc/sys/kernel/modprobe>"
msgstr "I</proc/sys/kernel/modprobe>"

#. type: Plain text
#: man-pages/man5/proc.5:4931
msgid ""
"This file contains the pathname for the kernel module loader.  The default "
"value is I</sbin/modprobe>.  The file is present only if the kernel is built "
"with the B<CONFIG_MODULES> (B<CONFIG_KMOD> in Linux 2.6.26 and earlier)  "
"option enabled.  It is described by the Linux kernel source file "
"I<Documentation/kmod.txt> (present only in kernel 2.4 and earlier)."
msgstr ""
"В этом файле содержится путь к загрузчику модулей ядра. Значение по "
"умолчанию равно I</sbin/modprobe>. Файл существует только, если ядро собрано "
"с параметром B<CONFIG_MODULES> (B<CONFIG_KMOD> — в Linux 2.6.26 и более "
"ранних). Он описан в файле I<Documentation/kmod.txt> из дерева исходного "
"кода ядра Linux (есть только в ядре версии 2.4 и более ранних)."

#. type: TP
#: man-pages/man5/proc.5:4931
#, no-wrap
msgid "I</proc/sys/kernel/modules_disabled> (since Linux 2.6.31)"
msgstr "I</proc/sys/kernel/modules_disabled> (начиная с Linux 2.6.31)"

#.  3d43321b7015387cfebbe26436d0e9d299162ea1
#.  From Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:4943
msgid ""
"A toggle value indicating if modules are allowed to be loaded in an "
"otherwise modular kernel.  This toggle defaults to off (0), but can be set "
"true (1).  Once true, modules can be neither loaded nor unloaded, and the "
"toggle cannot be set back to false.  The file is present only if the kernel "
"is built with the B<CONFIG_MODULES> option enabled."
msgstr ""
"Значение-переключатель, показывающий, можно ли загружать модули в модульное "
"ядро. Значение по умолчанию равно 0 (можно загружать), но может быть "
"установлено в 1 (нельзя загружать). При значении 1 модули нельзя не "
"загружать не выгружать, и значение-переключатель тоже нельзя изменить. "
"Данный файл появляется только, если ядро собрано с включённым параметром "
"B<CONFIG_MODULES>."

#. type: TP
#: man-pages/man5/proc.5:4943
#, no-wrap
msgid "I</proc/sys/kernel/msgmax> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/msgmax> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:4948
msgid ""
"This file defines a system-wide limit specifying the maximum number of bytes "
"in a single message written on a System V message queue."
msgstr ""
"Этот файл определяет системный лимит на максимальное число байт в одном "
"сообщении, которое пишется в очередь сообщений System\\ V."

#. type: TP
#: man-pages/man5/proc.5:4948
#, no-wrap
msgid "I</proc/sys/kernel/msgmni> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/msgmni> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:4954
msgid ""
"This file defines the system-wide limit on the number of message queue "
"identifiers.  See also I</proc/sys/kernel/auto_msgmni>."
msgstr ""
"Этот файл определяет системное ограничение на количество идентификаторов в "
"очереди сообщений. Смотрите также I</proc/sys/kernel/auto_msgmni>."

#. type: TP
#: man-pages/man5/proc.5:4954
#, no-wrap
msgid "I</proc/sys/kernel/msgmnb> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/msgmnb> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:4963
msgid ""
"This file defines a system-wide parameter used to initialize the "
"I<msg_qbytes> setting for subsequently created message queues.  The "
"I<msg_qbytes> setting specifies the maximum number of bytes that may be "
"written to the message queue."
msgstr ""
"Этот файл определяет системный параметр, используемый при начальной "
"настройке I<msg_qbytes> для последовательно создаваемых очередей сообщений. "
"Настройка I<msg_qbytes> задаёт максимальное число байт, которые могут быть "
"записаны в очередь сообщений."

#. type: TP
#: man-pages/man5/proc.5:4963
#, no-wrap
msgid "I</proc/sys/kernel/ngroups_max> (since Linux 2.6.4)"
msgstr "I</proc/sys/kernel/ngroups_max> (начиная с Linux 2.6.4)"

#. type: Plain text
#: man-pages/man5/proc.5:4967
msgid ""
"This is a read-only file that displays the upper limit on the number of a "
"process's group memberships."
msgstr ""
"Этот файл только для чтения, отображает верхний предел на количество членов "
"группы процесса."

#. type: TP
#: man-pages/man5/proc.5:4967
#, no-wrap
msgid "I</proc/sys/kernel/ns_last_pid> (since Linux 3.3)"
msgstr "I</proc/sys/kernel/ns_last_pid> (начиная с Linux 3.3)"

#. type: Plain text
#: man-pages/man5/proc.5:4971
msgid "See B<pid_namespaces>(7)."
msgstr "Смотрите B<pid_namespaces>(7)."

#. type: TP
#: man-pages/man5/proc.5:4971
#, no-wrap
msgid "I</proc/sys/kernel/ostype> and I</proc/sys/kernel/osrelease>"
msgstr "I</proc/sys/kernel/ostype> и I</proc/sys/kernel/osrelease>"

#. type: Plain text
#: man-pages/man5/proc.5:4976
msgid "These files give substrings of I</proc/version>."
msgstr "Эти файлы содержат подстроки из I</proc/version>."

#. type: TP
#: man-pages/man5/proc.5:4976
#, no-wrap
msgid "I</proc/sys/kernel/overflowgid> and I</proc/sys/kernel/overflowuid>"
msgstr "I</proc/sys/kernel/overflowgid> и I</proc/sys/kernel/overflowuid>"

#. type: Plain text
#: man-pages/man5/proc.5:4982
msgid ""
"These files duplicate the files I</proc/sys/fs/overflowgid> and I</proc/sys/"
"fs/overflowuid>."
msgstr ""
"Эти файлы дублируют файлы I</proc/sys/fs/overflowgid> и I</proc/sys/fs/"
"overflowuid>."

#. type: TP
#: man-pages/man5/proc.5:4982
#, no-wrap
msgid "I</proc/sys/kernel/panic>"
msgstr "I</proc/sys/kernel/panic>"

#. type: Plain text
#: man-pages/man5/proc.5:4991
msgid ""
"This file gives read/write access to the kernel variable I<panic_timeout>.  "
"If this is zero, the kernel will loop on a panic; if nonzero, it indicates "
"that the kernel should autoreboot after this number of seconds.  When you "
"use the software watchdog device driver, the recommended setting is 60."
msgstr ""
"Этот файл предоставляет доступ на чтение и запись к переменной ядра "
"I<panic_timeout>. Если значение в файле равно нулю, ядро будет зацикливаться "
"при крахе системы по panic; если не ноль, то это означает, что ядро должно "
"выполнить автоматическую перезагрузку после этого количества секунд. Когда "
"вы используете программный драйвер устройства watchdog (устройство, "
"периодически делающее проверку, что система функционирует), то рекомендуется "
"установить значение 60."

#. type: TP
#: man-pages/man5/proc.5:4991
#, no-wrap
msgid "I</proc/sys/kernel/panic_on_oops> (since Linux 2.5.68)"
msgstr "I</proc/sys/kernel/panic_on_oops> (начиная с Linux 2.5.68)"

#. type: Plain text
#: man-pages/man5/proc.5:5003
msgid ""
"This file controls the kernel's behavior when an oops or BUG is "
"encountered.  If this file contains 0, then the system tries to continue "
"operation.  If it contains 1, then the system delays a few seconds (to give "
"klogd time to record the oops output)  and then panics.  If the I</proc/sys/"
"kernel/panic> file is also nonzero, then the machine will be rebooted."
msgstr ""
"Этот файл управляет поведением ядра, когда случается oops или BUG. Если файл "
"содержит 0, то система пытается продолжить работу. Если содержит 1, то "
"система выполняет задержку на несколько секунд (чтобы дать время klogd "
"записать вывод oops) и затем генерирует крах системы через panic. Если файл "
"I</proc/sys/kernel/panic> также содержит ненулевое значение, то машина будет "
"перезагружена."

#. type: TP
#: man-pages/man5/proc.5:5003
#, no-wrap
msgid "I</proc/sys/kernel/pid_max> (since Linux 2.5.34)"
msgstr "I</proc/sys/kernel/pid_max> (начиная с Linux 2.5.34)"

#.  Prior to 2.6.10, pid_max could also be raised above 32768 on 32-bit
#.  platforms, but this broke /proc/[pid]
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=109513010926152&w=2
#. type: Plain text
#: man-pages/man5/proc.5:5022
msgid ""
"This file specifies the value at which PIDs wrap around (i.e., the value in "
"this file is one greater than the maximum PID).  PIDs greater than this "
"value are not allocated; thus, the value in this file also acts as a system-"
"wide limit on the total number of processes and threads.  The default value "
"for this file, 32768, results in the same range of PIDs as on earlier "
"kernels.  On 32-bit platforms, 32768 is the maximum value for I<pid_max>.  "
"On 64-bit systems, I<pid_max> can be set to any value up to 2^22 "
"(B<PID_MAX_LIMIT>, approximately 4 million)."
msgstr ""
"Этот файл задаёт значение, после которого идентификаторы процессов "
"(PID)начинают использоваться с начала (т. е., значение в этом файле на "
"единицу больше,чем максимальный PID). Значения PID больше этого значения не "
"выделяются; то есть значение в этом файле также служит системным "
"ограничением общего количества процессов и нитей. По умолчанию, значение в "
"этом файле составляет 32768, т. е. означает тот же самый диапазон PID-ов, "
"что и в ранних ядрах. На 32-битных платформах максимальное значение "
"I<pid_max> равно 32768. На 64-битных платформах I<pid_max> может принимать "
"любое значение до 2^22 (B<PID_MAX_LIMIT>, приблизительно 4 миллиона)."

#. type: TP
#: man-pages/man5/proc.5:5022
#, no-wrap
msgid "I</proc/sys/kernel/powersave-nap> (PowerPC only)"
msgstr "I</proc/sys/kernel/powersave-nap> (только на PowerPC)"

#. type: Plain text
#: man-pages/man5/proc.5:5028
msgid ""
"This file contains a flag.  If set, Linux-PPC will use the \"nap\" mode of "
"powersaving, otherwise the \"doze\" mode will be used."
msgstr ""
"Этот файл содержит флаг. Если он установлен Linux-PPC будет использовать "
"режим \"nap\" для энергосбережения, в противном случае будет использоваться "
"режим \"doze\"."

#. type: TP
#: man-pages/man5/proc.5:5028
#, no-wrap
msgid "I</proc/sys/kernel/printk>"
msgstr "I</proc/sys/kernel/printk>"

#. type: Plain text
#: man-pages/man5/proc.5:5032
msgid "See B<syslog>(2)."
msgstr "Смотрите B<syslog>(2)."

#. type: TP
#: man-pages/man5/proc.5:5032
#, no-wrap
msgid "I</proc/sys/kernel/pty> (since Linux 2.6.4)"
msgstr "I</proc/sys/kernel/pty> (начиная с Linux 2.6.4)"

#. type: Plain text
#: man-pages/man5/proc.5:5038
msgid ""
"This directory contains two files relating to the number of UNIX 98 "
"pseudoterminals (see B<pts>(4))  on the system."
msgstr ""
"В этом каталоге содержится два файла, отражающих количество псевдо-"
"терминалов UNIX 98 (см. B<pts>(4)) в системе."

#. type: TP
#: man-pages/man5/proc.5:5038
#, no-wrap
msgid "I</proc/sys/kernel/pty/max>"
msgstr "I</proc/sys/kernel/pty/max>"

#.  FIXME Document /proc/sys/kernel/pty/reserve
#.      New in Linux 3.3
#.      commit e9aba5158a80098447ff207a452a3418ae7ee386
#. type: Plain text
#: man-pages/man5/proc.5:5044
msgid "This file defines the maximum number of pseudoterminals."
msgstr "Этот файл определяет максимальное количество псевдо-терминалов."

#. type: TP
#: man-pages/man5/proc.5:5044
#, no-wrap
msgid "I</proc/sys/kernel/pty/nr>"
msgstr "I</proc/sys/kernel/pty/nr>"

#. type: Plain text
#: man-pages/man5/proc.5:5048
msgid ""
"This read-only file indicates how many pseudoterminals are currently in use."
msgstr ""
"Файл доступен только для чтения, показывает количество используемых в данный "
"момент псевдо-терминалов."

#. type: TP
#: man-pages/man5/proc.5:5048
#, no-wrap
msgid "I</proc/sys/kernel/random>"
msgstr "I</proc/sys/kernel/random>"

#. type: Plain text
#: man-pages/man5/proc.5:5056
msgid ""
"This directory contains various parameters controlling the operation of the "
"file I</dev/random>.  See B<random>(4)  for further information."
msgstr ""
"Этот каталог содержит различные параметры, управляющие работой файла I</dev/"
"random>. Дополнительную информацию смотрите в B<random>(4)."

#. type: TP
#: man-pages/man5/proc.5:5056
#, no-wrap
msgid "I</proc/sys/kernel/random/uuid> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/random/uuid> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:5060
msgid ""
"Each read from this read-only file returns a randomly generated 128-bit "
"UUID, as a string in the standard UUID format."
msgstr ""
"При каждом чтении из этого, доступного только для чтения файла, возвращается "
"генерируемый случайным образом 128-битный UUID в виде строки в стандартном "
"формате UUID."

#. type: TP
#: man-pages/man5/proc.5:5060
#, no-wrap
msgid "I</proc/sys/kernel/randomize_va_space> (since Linux 2.6.12)"
msgstr "I</proc/sys/kernel/randomize_va_space> (начиная с Linux 2.6.12)"

#.  Some further details can be found in Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:5066
msgid ""
"Select the address space layout randomization (ASLR) policy for the system "
"(on architectures that support ASLR).  Three values are supported for this "
"file:"
msgstr ""
"Выбирает политику случайного выбора адресного пространства (ASLR) в системе "
"(на архитектурах с поддержкой ASLR). Возможны три значения:"

#. type: Plain text
#: man-pages/man5/proc.5:5073
msgid ""
"Turn ASLR off.  This is the default for architectures that don't support "
"ASLR, and when the kernel is booted with the I<norandmaps> parameter."
msgstr ""
"Отключить ASLR. Значение по умолчанию на архитектурах без поддержки ASLR, и "
"если ядро загружено с параметром I<norandmaps>."

#. type: Plain text
#: man-pages/man5/proc.5:5083
msgid ""
"Make the addresses of B<mmap>(2)  allocations, the stack, and the VDSO page "
"randomized.  Among other things, this means that shared libraries will be "
"loaded at randomized addresses.  The text segment of PIE-linked binaries "
"will also be loaded at a randomized address.  This value is the default if "
"the kernel was configured with B<CONFIG_COMPAT_BRK>."
msgstr ""
"Выполнять выделение адресов B<mmap>(2), стека и страниц VDSO случайным "
"образом. Помимо прочего, это означает, что общие библиотеки будут "
"загружаться по случайным адресам. Текстовый сегмент PIE-скомпонованных "
"библиотек будет также загружен по случайному адресу. Является значением по "
"умолчанию, если ядро собрано с параметром B<CONFIG_COMPAT_BRK>."

#.  commit c1d171a002942ea2d93b4fbd0c9583c56fce0772
#. type: Plain text
#: man-pages/man5/proc.5:5089
msgid ""
"(Since Linux 2.6.25)  Also support heap randomization.  This value is the "
"default if the kernel was not configured with B<CONFIG_COMPAT_BRK>."
msgstr ""
"(начиная с Linux 2.6.25) Также выполнять выделение кучи случайным образом. "
"Является значением по умолчанию, если ядро не собрано с параметром "
"B<CONFIG_COMPAT_BRK>."

#. type: TP
#: man-pages/man5/proc.5:5090
#, no-wrap
msgid "I</proc/sys/kernel/real-root-dev>"
msgstr "I</proc/sys/kernel/real-root-dev>"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: man-pages/man5/proc.5:5098
msgid ""
"This file is documented in the Linux kernel source file I<Documentation/"
"admin-guide/initrd.rst> (or I<Documentation/initrd.txt> before Linux 4.10)."
msgstr ""
"Этот файл описывается в файле исходного кода ядра Linux I<Documentation/"
"admin-guide/initrd.rst> (или I<Documentation/initrd.txt> до Linux 4.10)."

#. type: TP
#: man-pages/man5/proc.5:5098
#, no-wrap
msgid "I</proc/sys/kernel/reboot-cmd> (Sparc only) "
msgstr "I</proc/sys/kernel/reboot-cmd> (только на Sparc)"

#. type: Plain text
#: man-pages/man5/proc.5:5104
msgid ""
"This file seems to be a way to give an argument to the SPARC ROM/Flash boot "
"loader.  Maybe to tell it what to do after rebooting?"
msgstr ""
"Этот файл, вероятно, является способом задания аргументов для начального "
"загрузчика SPARC ROM/Flash. Способ сказать ему, что делать после "
"перезагрузки?"

#. type: TP
#: man-pages/man5/proc.5:5104
#, no-wrap
msgid "I</proc/sys/kernel/rtsig-max>"
msgstr "I</proc/sys/kernel/rtsig-max>"

#. type: Plain text
#: man-pages/man5/proc.5:5111
msgid ""
"(Only in kernels up to and including 2.6.7; see B<setrlimit>(2))  This file "
"can be used to tune the maximum number of POSIX real-time (queued) signals "
"that can be outstanding in the system."
msgstr ""
"(Только в ядре 2.6.7 и более ранних; см. B<setrlimit>(2)) Этот файл может "
"быть использован для настройки максимального количества сигналов реального "
"времени POSIX (в очереди), которое может воспринять система."

#. type: TP
#: man-pages/man5/proc.5:5111
#, no-wrap
msgid "I</proc/sys/kernel/rtsig-nr>"
msgstr "I</proc/sys/kernel/rtsig-nr>"

#. type: Plain text
#: man-pages/man5/proc.5:5115
msgid ""
"(Only in kernels up to and including 2.6.7.)  This file shows the number of "
"POSIX real-time signals currently queued."
msgstr ""
"(Только в ядре 2.6.7 и более ранних) Этот файл показывает количество "
"сигналов реального времени POSIX, которые в настоящий момент находятся в "
"очереди."

#. type: TP
#: man-pages/man5/proc.5:5115
#, no-wrap
msgid "I</proc/[pid]/sched_autogroup_enabled> (since Linux 2.6.38)"
msgstr "I</proc/[pid]/sched_autogroup_enabled> (начиная с Linux 2.6.38)"

#. type: TP
#: man-pages/man5/proc.5:5120
#, no-wrap
msgid "I</proc/sys/kernel/sched_child_runs_first> (since Linux 2.6.23)"
msgstr "I</proc/sys/kernel/sched_child_runs_first> (начиная с Linux 2.6.23)"

#. type: Plain text
#: man-pages/man5/proc.5:5129
msgid ""
"If this file contains the value zero, then, after a B<fork>(2), the parent "
"is first scheduled on the CPU.  If the file contains a nonzero value, then "
"the child is scheduled first on the CPU.  (Of course, on a multiprocessor "
"system, the parent and the child might both immediately be scheduled on a "
"CPU.)"
msgstr ""
"Если этот файл содержит нулевое значение, то после B<fork>(2) первым на ЦП "
"планируется выполнение родителя. Если файл содержит ненулевое значение, то "
"первым на ЦП планируется выполнение потомка (естественно, на "
"многопроцессорной системе может быть запланировано немедленное одновременное "
"выполнение и родителя и потомка)."

#. type: TP
#: man-pages/man5/proc.5:5129
#, no-wrap
msgid "I</proc/sys/kernel/sched_rr_timeslice_ms> (since Linux 3.9)"
msgstr "I</proc/sys/kernel/sched_rr_timeslice_ms> (начиная с Linux 3.9)"

#. type: Plain text
#: man-pages/man5/proc.5:5133
msgid "See B<sched_rr_get_interval>(2)."
msgstr "Смотрите B<sched_rr_get_interval>(2)."

#. type: TP
#: man-pages/man5/proc.5:5133
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_period_us> (since Linux 2.6.25)"
msgstr "I</proc/sys/kernel/sched_rt_period_us> (начиная с Linux 2.6.25)"

#. type: TP
#: man-pages/man5/proc.5:5137
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_runtime_us> (since Linux 2.6.25)"
msgstr "I</proc/sys/kernel/sched_rt_runtime_us> (начиная с Linux 2.6.25)"

#. type: TP
#: man-pages/man5/proc.5:5141
#, no-wrap
msgid "I</proc/sys/kernel/seccomp> (since Linux 4.14)"
msgstr "I</proc/sys/kernel/seccomp> (начиная с Linux 4.14)"

#.  commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af
#. type: Plain text
#: man-pages/man5/proc.5:5149
msgid ""
"This directory provides additional seccomp information and configuration.  "
"See B<seccomp>(2)  for further details."
msgstr ""
"Этот каталог содержит дополнительную информацию и настройки seccomp. "
"Подробней смотрите в B<seccomp>(2)."

#. type: TP
#: man-pages/man5/proc.5:5149
#, no-wrap
msgid "I</proc/sys/kernel/sem> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/sem> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:5153
msgid ""
"This file contains 4 numbers defining limits for System V IPC semaphores.  "
"These fields are, in order:"
msgstr ""
"Этот файл содержит 4 значения, описывающих ограничения семафоров System V "
"IPC. Вот эти значения по порядку:"

#. type: IP
#: man-pages/man5/proc.5:5154
#, no-wrap
msgid "SEMMSL"
msgstr "SEMMSL"

#. type: Plain text
#: man-pages/man5/proc.5:5156
msgid "The maximum semaphores per semaphore set."
msgstr "Максимальное количество семафоров в одном списке семафоров."

#. type: IP
#: man-pages/man5/proc.5:5156
#, no-wrap
msgid "SEMMNS"
msgstr "SEMMNS"

#. type: Plain text
#: man-pages/man5/proc.5:5158
msgid "A system-wide limit on the number of semaphores in all semaphore sets."
msgstr "Системный лимит на количество семафоров во всех списках семафоров."

#. type: IP
#: man-pages/man5/proc.5:5158
#, no-wrap
msgid "SEMOPM"
msgstr "SEMOPM"

#. type: Plain text
#: man-pages/man5/proc.5:5162
msgid ""
"The maximum number of operations that may be specified in a B<semop>(2)  "
"call."
msgstr ""
"Максимальное количество операций, которое может быть указано в вызове "
"B<semop>(2)."

#. type: IP
#: man-pages/man5/proc.5:5162
#, no-wrap
msgid "SEMMNI"
msgstr "SEMMNI"

#. type: Plain text
#: man-pages/man5/proc.5:5164
msgid "A system-wide limit on the maximum number of semaphore identifiers."
msgstr "Системный лимит на максимальное количество идентификаторов семафоров."

#. type: TP
#: man-pages/man5/proc.5:5165
#, no-wrap
msgid "I</proc/sys/kernel/sg-big-buff>"
msgstr "I</proc/sys/kernel/sg-big-buff>"

#. type: Plain text
#: man-pages/man5/proc.5:5176
msgid ""
"This file shows the size of the generic SCSI device (sg) buffer.  You can't "
"tune it just yet, but you could change it at compile time by editing "
"I<include/scsi/sg.h> and changing the value of B<SG_BIG_BUFF>.  However, "
"there shouldn't be any reason to change this value."
msgstr ""
"Этот файл показывает размер буфера стандартного SCSI устройства (sg). Вы не "
"можете пока настраивать его, но его можно изменить при компиляции ядра, "
"исправив I<include/scsi/sg.h>, изменив в нём значение B<SG_BIG_BUFF>. "
"Однако, в этом, как правило, нет необходимости."

#. type: TP
#: man-pages/man5/proc.5:5176
#, no-wrap
msgid "I</proc/sys/kernel/shm_rmid_forced> (since Linux 3.1)"
msgstr "I</proc/sys/kernel/shm_rmid_forced> (начиная с Linux 3.1)"

#.  commit b34a6b1da371ed8af1221459a18c67970f7e3d53
#.  See also Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:5185
msgid ""
"If this file is set to 1, all System V shared memory segments will be marked "
"for destruction as soon as the number of attached processes falls to zero; "
"in other words, it is no longer possible to create shared memory segments "
"that exist independently of any attached process."
msgstr ""
"Если значение в файле равно 1, то все общие сегменты памяти System V будут "
"помечены на уничтожение сразу после сокращения присоединённых процессов до "
"нуля; другими словами становится невозможно создать сегмент общей памяти, "
"существующий независимо от присоединённого процесса."

#. type: Plain text
#: man-pages/man5/proc.5:5197
msgid ""
"The effect is as though a B<shmctl>(2)  B<IPC_RMID> is performed on all "
"existing segments as well as all segments created in the future (until this "
"file is reset to 0).  Note that existing segments that are attached to no "
"process will be immediately destroyed when this file is set to 1.  Setting "
"this option will also destroy segments that were created, but never "
"attached, upon termination of the process that created the segment with "
"B<shmget>(2)."
msgstr ""
"Это подобно тому, как если бы выполнили B<shmctl>(2) B<IPC_RMID> для всех "
"существующих сегментов, а также выполняли бы для всех сегментов, создаваемых "
"в будущем (пока значение в файле не будет сброшено в 0). Заметим, что при "
"задании в файле значения 1 существующие сегменты, не присоединённые к "
"процессу, будут немедленно уничтожены. Установка этого значения также будет "
"уничтожать сегменты, которые были созданы, но не присоединены — при "
"завершении процесса, который создал эти сегменты с помощью B<shmget>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:5205
msgid ""
"Setting this file to 1 provides a way of ensuring that all System V shared "
"memory segments are counted against the resource usage and resource limits "
"(see the description of B<RLIMIT_AS> in B<getrlimit>(2))  of at least one "
"process."
msgstr ""
"Установка значения в 1 позволяет быть уверенным, что все общие сегменты "
"памяти System V подсчитаны и следуют заданным ограничениям ресурсов, как "
"минимум, в одном процессе (смотрите описание B<RLIMIT_AS> в B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man5/proc.5:5212
msgid ""
"Because setting this file to 1 produces behavior that is nonstandard and "
"could also break existing applications, the default value in this file is "
"0.  Set this file to 1 only if you have a good understanding of the "
"semantics of the applications using System V shared memory on your system."
msgstr ""
"Так как установка в этом файле значения 1 вызывает нестандартное поведение и "
"может привести к неработоспособности приложений, значение по умолчанию равно "
"0. Указывайте значение 1 только, если хорошо понимаете работу приложений, "
"использующих общую память System V."

#. type: TP
#: man-pages/man5/proc.5:5212
#, no-wrap
msgid "I</proc/sys/kernel/shmall> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/shmall> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:5217
msgid ""
"This file contains the system-wide limit on the total number of pages of "
"System V shared memory."
msgstr ""
"Этот файл содержит системный лимит на общее количество страниц общей памяти "
"по стандарту System\\ V."

#. type: TP
#: man-pages/man5/proc.5:5217
#, no-wrap
msgid "I</proc/sys/kernel/shmmax> (since Linux 2.2)"
msgstr "I</proc/sys/kernel/shmmax> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man5/proc.5:5227
msgid ""
"This file can be used to query and set the run-time limit on the maximum "
"(System V IPC) shared memory segment size that can be created.  Shared "
"memory segments up to 1GB are now supported in the kernel.  This value "
"defaults to B<SHMMAX>."
msgstr ""
"Этот файл может быть использован для опроса и установки ограничения "
"максимального размера сегмента общей памяти по стандарту System\\ V во время "
"выполнения. В настоящий момент ядро поддерживает сегменты общей памяти до "
"1ГБ. Значение по умолчанию равно B<SHMMAX>."

#. type: TP
#: man-pages/man5/proc.5:5227
#, no-wrap
msgid "I</proc/sys/kernel/shmmni> (since Linux 2.4)"
msgstr "I</proc/sys/kernel/shmmni> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man5/proc.5:5232
msgid ""
"This file specifies the system-wide maximum number of System V shared memory "
"segments that can be created."
msgstr ""
"Задаёт максимальное системное ограничение на количество создаваемых общих "
"сегментов памяти по стандарту System V."

#. type: TP
#: man-pages/man5/proc.5:5232
#, no-wrap
msgid "I</proc/sys/kernel/sysctl_writes_strict> (since Linux 3.16)"
msgstr "I</proc/sys/kernel/sysctl_writes_strict> (начиная с Linux 3.16)"

#.  commit f88083005ab319abba5d0b2e4e997558245493c8
#.  commit 2ca9bb456ada8bcbdc8f77f8fc78207653bbaa92
#.  commit f4aacea2f5d1a5f7e3154e967d70cf3f711bcd61
#.  commit 24fe831c17ab8149413874f2fd4e5c8a41fcd294
#. type: Plain text
#: man-pages/man5/proc.5:5242
msgid ""
"The value in this file determines how the file offset affects the behavior "
"of updating entries in files under I</proc/sys>.  The file has three "
"possible values:"
msgstr ""
"Значением в этом файле определяется как учитывать файловое смещение при "
"обновлении записей в файле I</proc/sys>. Есть три возможных значения:"

#. type: Plain text
#: man-pages/man5/proc.5:5251
msgid ""
"This provides legacy handling, with no printk warnings.  Each B<write>(2)  "
"must fully contain the value to be written, and multiple writes on the same "
"file descriptor will overwrite the entire value, regardless of the file "
"position."
msgstr ""
"Старый вариант работы, без предупреждения printk. Каждый B<write>(2) должен "
"записывать значение целиком, а повторная запись в тот же файловый дескриптор "
"переписывает значение целиком, независимо от смещения в файле."

#. type: Plain text
#: man-pages/man5/proc.5:5256
msgid ""
"(default) This provides the same behavior as for -1, but printk warnings are "
"written for processes that perform writes when the file offset is not 0."
msgstr ""
"(по умолчанию) Такая же работа, как при -1, но выдаёт предупреждение printk "
"для процессов, которые выполняют запись, если файловое смещение не равно 0."

#.  FIXME .
#.      With /proc/sys/kernel/sysctl_writes_strict==1, writes at an
#.      offset other than 0 do not generate an error. Instead, the
#.      write() succeeds, but the file is left unmodified.
#.      This is surprising. The behavior may change in the future.
#.      See thread.gmane.org/gmane.linux.man/9197
#. 		From: Michael Kerrisk (man-pages <mtk.manpages@...>
#. 		Subject: sysctl_writes_strict documentation + an oddity?
#. 		Newsgroups: gmane.linux.man, gmane.linux.kernel
#. 		Date: 2015-05-09 08:54:11 GMT
#. type: Plain text
#: man-pages/man5/proc.5:5281
msgid ""
"Respect the file offset when writing strings into I</proc/sys> files.  "
"Multiple writes will I<append> to the value buffer.  Anything written beyond "
"the maximum length of the value buffer will be ignored.  Writes to numeric "
"I</proc/sys> entries must always be at file offset 0 and the value must be "
"fully contained in the buffer provided to B<write>(2)."
msgstr ""
"Учитывать файловое смещение при записи строк в файлы I</proc/sys>. Повторная "
"запись I<добавляет> значение в буфер. Всё записанное, но превышающее длину "
"буфера будет игнорироваться. Запись чисел в I</proc/sys> всегда должна "
"выполняться по файловому смещению 0 и значение должно полностью помещаться в "
"буфер, предоставленный B<write>(2)."

#. type: TP
#: man-pages/man5/proc.5:5282
#, no-wrap
msgid "I</proc/sys/kernel/sysrq>"
msgstr "I</proc/sys/kernel/sysrq>"

#. type: Plain text
#: man-pages/man5/proc.5:5291
msgid ""
"This file controls the functions allowed to be invoked by the SysRq key.  By "
"default, the file contains 1 meaning that every possible SysRq request is "
"allowed (in older kernel versions, SysRq was disabled by default, and you "
"were required to specifically enable it at run-time, but this is not the "
"case any more).  Possible values in this file are:"
msgstr ""
"Этот файл контролирует функции, которые можно вызывать по клавише SysRq. По "
"умолчанию в нём содержится 1, которая означает, что разрешены любые "
"возможные запросы SysRq (в старых ядрах SysRq по умолчанию выключена, и её "
"требовалось явно включать при работе, но теперь этого больше не требуется.). "
"Возможные значения:"

#. type: Plain text
#: man-pages/man5/proc.5:5295
msgid "Disable sysrq completely"
msgstr "Полностью выключить sysrq"

#. type: Plain text
#: man-pages/man5/proc.5:5298
msgid "Enable all functions of sysrq"
msgstr "Включить все функции sysrq"

#. type: TP
#: man-pages/man5/proc.5:5298
#, no-wrap
msgid "E<gt> 1"
msgstr "E<gt> 1"

#. type: Plain text
#: man-pages/man5/proc.5:5301
msgid "Bit mask of allowed sysrq functions, as follows:"
msgstr "Битовая маска разрешённых функций sysrq:"

#. type: TP
#: man-pages/man5/proc.5:5303
#, no-wrap
msgid "\\ \\ 2"
msgstr "\\ \\ 2"

#. type: Plain text
#: man-pages/man5/proc.5:5306
msgid "Enable control of console logging level"
msgstr "Включить управление уровнем протоколирования консоли"

#. type: TP
#: man-pages/man5/proc.5:5306
#, no-wrap
msgid "\\ \\ 4"
msgstr "\\ \\ 4"

#. type: Plain text
#: man-pages/man5/proc.5:5309
msgid "Enable control of keyboard (SAK, unraw)"
msgstr "Включить управление клавиатурой (SAK, unraw)"

#. type: TP
#: man-pages/man5/proc.5:5309
#, no-wrap
msgid "\\ \\ 8"
msgstr "\\ \\ 8"

#. type: Plain text
#: man-pages/man5/proc.5:5312
msgid "Enable debugging dumps of processes etc."
msgstr "Включить отладочные дампы процессов."

#. type: TP
#: man-pages/man5/proc.5:5312
#, no-wrap
msgid "\\ 16"
msgstr "\\ 16"

#. type: Plain text
#: man-pages/man5/proc.5:5315
msgid "Enable sync command"
msgstr "Включить команду sync"

#. type: TP
#: man-pages/man5/proc.5:5315
#, no-wrap
msgid "\\ 32"
msgstr "\\ 32"

#. type: Plain text
#: man-pages/man5/proc.5:5318
msgid "Enable remount read-only"
msgstr "Включить перемонтирование в режим только для чтения"

#. type: TP
#: man-pages/man5/proc.5:5318
#, no-wrap
msgid "\\ 64"
msgstr "\\ 64"

#. type: Plain text
#: man-pages/man5/proc.5:5321
msgid "Enable signaling of processes (term, kill, oom-kill)"
msgstr "Включить передачу сигналов процессам (term, kill, oom-kill)"

#. type: TP
#: man-pages/man5/proc.5:5321
#, no-wrap
msgid "128"
msgstr "128"

#. type: Plain text
#: man-pages/man5/proc.5:5324
msgid "Allow reboot/poweroff"
msgstr "Включить выполнение перезагрузки/выключения питания"

#. type: TP
#: man-pages/man5/proc.5:5324
#, no-wrap
msgid "256"
msgstr "256"

#. type: Plain text
#: man-pages/man5/proc.5:5327
msgid "Allow nicing of all real-time tasks"
msgstr "Разрешить изменять уступчивость всех задач реального времени"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: man-pages/man5/proc.5:5340
msgid ""
"This file is present only if the B<CONFIG_MAGIC_SYSRQ> kernel configuration "
"option is enabled.  For further details see the Linux kernel source file "
"I<Documentation/admin-guide/sysrq.rst> (or I<Documentation/sysrq.txt> before "
"Linux 4.10)."
msgstr ""
"Этот файл существует только, если включён параметр сборки ядра "
"B<CONFIG_MAGIC_SYSRQ>. Дополнительную информацию можно найти в исходном коде "
"ядра Linux в файле I<Documentation/admin-guide/sysrq.rst> (или "
"I<Documentation/sysrq.txt> до Linux 4.10)."

#. type: TP
#: man-pages/man5/proc.5:5340
#, no-wrap
msgid "I</proc/sys/kernel/version>"
msgstr "I</proc/sys/kernel/version>"

#. type: Plain text
#: man-pages/man5/proc.5:5343
msgid "This file contains a string such as:"
msgstr "Этот файл содержит строку, такую как:"

#. type: Plain text
#: man-pages/man5/proc.5:5345
#, no-wrap
msgid "    #5 Wed Feb 25 21:49:24 MET 1998\n"
msgstr "    #5 Wed Feb 25 21:49:24 MET 1998\n"

#. type: Plain text
#: man-pages/man5/proc.5:5349
msgid ""
"The \"#5\" means that this is the fifth kernel built from this source base "
"and the date following it indicates the time the kernel was built."
msgstr ""
"Часть «#5» означает, что это пятая сборка ядра от исходной базы, а далее "
"указана дата и время сборки ядра."

#. type: TP
#: man-pages/man5/proc.5:5349
#, no-wrap
msgid "I</proc/sys/kernel/threads-max> (since Linux 2.3.11)"
msgstr "I</proc/sys/kernel/threads-max> (начиная с Linux 2.3.11)"

#.  The following is based on Documentation/sysctl/kernel.txt
#. type: Plain text
#: man-pages/man5/proc.5:5354
msgid ""
"This file specifies the system-wide limit on the number of threads (tasks) "
"that can be created on the system."
msgstr ""
"Этот файл определяет системный лимит на количество нитей (задач), которое "
"может быть создано в системе."

#.  commit 230633d109e35b0a24277498e773edeb79b4a331
#. type: Plain text
#: man-pages/man5/proc.5:5370
msgid ""
"Since Linux 4.1, the value that can be written to I<threads-max> is "
"bounded.  The minimum value that can be written is 20.  The maximum value "
"that can be written is given by the constant B<FUTEX_TID_MASK> "
"(0x3fffffff).  If a value outside of this range is written to I<threads-"
"max>, the error B<EINVAL> occurs."
msgstr ""
"Начиная с Linux 4.1, значение, которое можно записать в I<threads-max> "
"ограничено. Минимальное значение равно 20. Максимальное значение "
"определяется константой B<FUTEX_TID_MASK> (0x3fffffff). Если в I<threads-"
"max> записывается значение вне этого диапазона, то возвращается ошибка "
"B<EINVAL>."

#. type: Plain text
#: man-pages/man5/proc.5:5376
msgid ""
"The value written is checked against the available RAM pages.  If the thread "
"structures would occupy too much (more than 1/8th)  of the available RAM "
"pages, I<threads-max> is reduced accordingly."
msgstr ""
"По записываемому значению проверяется доступные страницы RAM. Если структуры "
"нити заняли бы слишком много (более 1/8й) доступных страниц RAM, то "
"I<threads-max> сокращается соответствующим образом."

#. type: TP
#: man-pages/man5/proc.5:5376
#, no-wrap
msgid "I</proc/sys/kernel/yama/ptrace_scope> (since Linux 3.5)"
msgstr "I</proc/sys/kernel/yama/ptrace_scope> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man5/proc.5:5380
msgid "See B<ptrace>(2)."
msgstr "Смотрите B<ptrace>(2)."

#. type: TP
#: man-pages/man5/proc.5:5380
#, no-wrap
msgid "I</proc/sys/kernel/zero-paged> (PowerPC only) "
msgstr "I</proc/sys/kernel/zero-paged> (только на PowerPC)"

#. type: Plain text
#: man-pages/man5/proc.5:5386
msgid ""
"This file contains a flag.  When enabled (nonzero), Linux-PPC will pre-zero "
"pages in the idle loop, possibly speeding up get_free_pages."
msgstr ""
"Этот файл содержит флаг. Когда он установлен (не ноль), Linux-PPC будет "
"размещать заранее обнулённые страницы в цикле простоя, что возможно увеличит "
"скорость выполнения get_free_pages."

#. type: TP
#: man-pages/man5/proc.5:5386
#, no-wrap
msgid "I</proc/sys/net>"
msgstr "I</proc/sys/net>"

#. type: Plain text
#: man-pages/man5/proc.5:5393
msgid ""
"This directory contains networking stuff.  Explanations for some of the "
"files under this directory can be found in B<tcp>(7)  and B<ip>(7)."
msgstr ""
"Этот каталог содержит некоторую информацию по функционированию сетевой "
"подсистемы. Описание некоторых файлов в этом каталоге можно найти в "
"B<tcp>(7) и B<ip>(7)."

#. type: TP
#: man-pages/man5/proc.5:5393
#, no-wrap
msgid "I</proc/sys/net/core/bpf_jit_enable>"
msgstr "I</proc/sys/net/core/bpf_jit_enable>"

#. type: Plain text
#: man-pages/man5/proc.5:5397
msgid "See B<bpf>(2)."
msgstr "Смотрите B<bpf>(2)."

#. type: TP
#: man-pages/man5/proc.5:5397
#, no-wrap
msgid "I</proc/sys/net/core/somaxconn>"
msgstr "I</proc/sys/net/core/somaxconn>"

#. type: Plain text
#: man-pages/man5/proc.5:5406
msgid ""
"This file defines a ceiling value for the I<backlog> argument of "
"B<listen>(2); see the B<listen>(2)  manual page for details."
msgstr ""
"Этот файл определяет наименьшее значение параметра I<backlog> системного "
"вызова B<listen>(2); подробности смотрите в справочной странице B<listen>(2)."

#. type: TP
#: man-pages/man5/proc.5:5406
#, no-wrap
msgid "I</proc/sys/proc>"
msgstr "I</proc/sys/proc>"

#. type: TP
#: man-pages/man5/proc.5:5409
#, no-wrap
msgid "I</proc/sys/sunrpc>"
msgstr "I</proc/sys/sunrpc>"

#. type: Plain text
#: man-pages/man5/proc.5:5414
msgid ""
"This directory supports Sun remote procedure call for network filesystem "
"(NFS).  On some systems, it is not present."
msgstr ""
"Данный каталог поддерживает удалённый вызов процедур Sun для сетевой "
"файловой системы (NFS). В некоторых системах его нет."

#. type: TP
#: man-pages/man5/proc.5:5414
#, no-wrap
msgid "I</proc/sys/user> (since Linux 4.9)"
msgstr "I</proc/sys/user> (начиная с Linux 4.9)"

#. type: Plain text
#: man-pages/man5/proc.5:5418
msgid "See B<namespaces>(7)."
msgstr "Смотрите в B<namespaces>(7)."

#. type: TP
#: man-pages/man5/proc.5:5418
#, no-wrap
msgid "I</proc/sys/vm>"
msgstr "I</proc/sys/vm>"

#. type: Plain text
#: man-pages/man5/proc.5:5422
msgid ""
"This directory contains files for memory management tuning, buffer and cache "
"management."
msgstr ""
"Этот каталог содержит файлы для тонкой настройки управления памятью, "
"буферами и кэшем."

#. type: TP
#: man-pages/man5/proc.5:5422
#, no-wrap
msgid "I</proc/sys/vm/admin_reserve_kbytes> (since Linux 3.10)"
msgstr "I</proc/sys/vm/overcommit_kbytes> (начиная с Linux 3.10)"

#.  commit 4eeab4f5580d11bffedc697684b91b0bca0d5009
#. type: Plain text
#: man-pages/man5/proc.5:5428
msgid ""
"This file defines the amount of free memory (in KiB) on the system that "
"should be reserved for users with the capability B<CAP_SYS_ADMIN>."
msgstr ""
"В данном файле задаётся количество свободной памяти (в КиБ) в системе, "
"которое должно быть зарезервировано для пользователей с мандатом "
"B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man5/proc.5:5435
msgid ""
"The default value in this file is the minimum of [3% of free pages, 8MiB] "
"expressed as KiB.  The default is intended to provide enough for the "
"superuser to log in and kill a process, if necessary, under the default "
"overcommit 'guess' mode (i.e., 0 in I</proc/sys/vm/overcommit_memory>)."
msgstr ""
"Значение по умолчанию равно минимум от [3% свободных страниц, 8МиБ], "
"выраженное в КиБ. Этого достаточно для того, чтобы суперпользователь смог "
"войти и удалить процесс, если нужно, когда система работает в режиме по "
"умолчанию — «угадывание» перерасхода (т. е., 0 в I</proc/sys/vm/"
"overcommit_memory>)."

#. type: Plain text
#: man-pages/man5/proc.5:5446
msgid ""
"Systems running in \"overcommit never\" mode (i.e., 2 in I</proc/sys/vm/"
"overcommit_memory>)  should increase the value in this file to account for "
"the full virtual memory size of the programs used to recover (e.g., "
"B<login>(1)  B<ssh>(1), and B<top>(1))  Otherwise, the superuser may not be "
"able to log in to recover the system.  For example, on x86-64 a suitable "
"value is 131072 (128MiB reserved)."
msgstr ""
"Для систем, работающих в режиме «без перерасхода» (overcommit never) (т. е., "
"2 в I</proc/sys/vm/overcommit_memory>) нужно увеличить значение в этом файле "
"с учётом полного размера виртуальной памяти для программ, используемых при "
"восстановлении (например, B<login>(1)  B<ssh>(1) и B<top>(1)). В противном "
"случае суперпользователь не сможет войти для восстановления системы. "
"Например, на x86-64 подходящим значением будет 131072 (резервируется 128 "
"МиБ)."

#. type: Plain text
#: man-pages/man5/proc.5:5449 man-pages/man5/proc.5:5774
msgid ""
"Changing the value in this file takes effect whenever an application "
"requests memory."
msgstr ""
"Изменение этого значения влияет на последующие запросы памяти приложениями."

#. type: TP
#: man-pages/man5/proc.5:5449
#, no-wrap
msgid "I</proc/sys/vm/compact_memory> (since Linux 2.6.35)"
msgstr "I</proc/sys/vm/compact_memory> (начиная с Linux 2.6.35)"

#. type: Plain text
#: man-pages/man5/proc.5:5455
msgid ""
"When 1 is written to this file, all zones are compacted such that free "
"memory is available in contiguous blocks where possible.  The effect of this "
"action can be seen by examining I</proc/buddyinfo>."
msgstr ""
"При записи в этот файл 1 все зоны уплотняются так, чтобы свободная память "
"была непрерывными блоками насколько это возможно. Результат этого действия "
"можно оценить по файлу I</proc/buddyinfo>."

#. type: Plain text
#: man-pages/man5/proc.5:5458
msgid "Present only if the kernel was configured with B<CONFIG_COMPACTION>."
msgstr "Доступен только, если ядро собрано с параметром B<CONFIG_COMPACTION>."

#. type: TP
#: man-pages/man5/proc.5:5458
#, no-wrap
msgid "I</proc/sys/vm/drop_caches> (since Linux 2.6.16)"
msgstr "I</proc/sys/vm/drop_caches> (начиная с Linux 2.6.16)"

#. type: Plain text
#: man-pages/man5/proc.5:5466
msgid ""
"Writing to this file causes the kernel to drop clean caches, dentries, and "
"inodes from memory, causing that memory to become free.  This can be useful "
"for memory management testing and performing reproducible filesystem "
"benchmarks.  Because writing to this file causes the benefits of caching to "
"be lost, it can degrade overall system performance."
msgstr ""
"Запись в этот файл заставляет ядро сбросить чистые кэши, dentries и "
"индексные дескрипторы из памяти, тем самым освобождая её. Это может быть "
"полезно для тестирования управления памятью и выполнения воспроизводимых "
"тестов производительности файловой системы. Так как запись в этот файл "
"вызывает потерю преимуществ кэширования, это может снизить "
"производительность системы в целом."

#. type: Plain text
#: man-pages/man5/proc.5:5468
msgid "To free pagecache, use:"
msgstr "Для освобождения страничного кэша (pagecache) используйте:"

#. type: Plain text
#: man-pages/man5/proc.5:5470
#, no-wrap
msgid "    echo 1 E<gt> /proc/sys/vm/drop_caches\n"
msgstr "    echo 1 E<gt> /proc/sys/vm/drop_caches\n"

#. type: Plain text
#: man-pages/man5/proc.5:5472
msgid "To free dentries and inodes, use:"
msgstr "Для освобождения dentries и индексных дескрипторов используйте:"

#. type: Plain text
#: man-pages/man5/proc.5:5474
#, no-wrap
msgid "    echo 2 E<gt> /proc/sys/vm/drop_caches\n"
msgstr "    echo 2 E<gt> /proc/sys/vm/drop_caches\n"

#. type: Plain text
#: man-pages/man5/proc.5:5476
msgid "To free pagecache, dentries and inodes, use:"
msgstr ""
"Для освобождения страничного кэша, dentries и индексных дескрипторов "
"используйте:"

#. type: Plain text
#: man-pages/man5/proc.5:5478
#, no-wrap
msgid "    echo 3 E<gt> /proc/sys/vm/drop_caches\n"
msgstr "    echo 3 E<gt> /proc/sys/vm/drop_caches\n"

#. type: Plain text
#: man-pages/man5/proc.5:5484
msgid ""
"Because writing to this file is a nondestructive operation and dirty objects "
"are not freeable, the user should run B<sync>(1)  first."
msgstr ""
"Так как запись в этот файл — неразрушающая операция и изменившиеся (dirty) "
"объекты не свободны, пользователь сначала должен запустить команду "
"B<sync>(1)."

#. type: TP
#: man-pages/man5/proc.5:5484
#, no-wrap
msgid "I</proc/sys/vm/legacy_va_layout> (since Linux 2.6.9)"
msgstr "I</proc/sys/vm/legacy_va_layout> (начиная с Linux 2.6.9)"

#.  The following is from Documentation/filesystems/proc.txt
#. type: Plain text
#: man-pages/man5/proc.5:5489
msgid ""
"If nonzero, this disables the new 32-bit memory-mapping layout; the kernel "
"will use the legacy (2.4) layout for all processes."
msgstr ""
"Если не равно нулю, то новая раскладка 32-битного отображения памяти "
"выключается; ядро будет использовать старую (2.4) раскладку для всех "
"процессов."

#. type: TP
#: man-pages/man5/proc.5:5489
#, no-wrap
msgid "I</proc/sys/vm/memory_failure_early_kill> (since Linux 2.6.32)"
msgstr "I</proc/sys/vm/memory_failure_early_kill> (начиная с Linux 2.6.32)"

#.  The following is based on the text in Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:5501
msgid ""
"Control how to kill processes when an uncorrected memory error (typically a "
"2-bit error in a memory module)  that cannot be handled by the kernel is "
"detected in the background by hardware.  In some cases (like the page still "
"having a valid copy on disk), the kernel will handle the failure "
"transparently without affecting any applications.  But if there is no other "
"up-to-date copy of the data, it will kill processes to prevent any data "
"corruptions from propagating."
msgstr ""
"Управляет, как завершать процессы, когда неисправленная ошибка памяти "
"(обычно, 2-битная ошибка в модуле памяти), которая не может быть обработана "
"ядром, обнаружена в фоновом режиме аппаратным обеспечением. В некоторых "
"случаях (например, когда страница имеет правильную копию на диске), ядро "
"может может прозрачно исправить ошибку без влияния на приложения. Но если "
"актуальной копии данных нет, то ядро завершит процесс, чтобы остановить "
"распространение повреждения данных."

#. type: Plain text
#: man-pages/man5/proc.5:5503
msgid "The file has one of the following values:"
msgstr "В файле содержатся следующие значения:"

#. type: IP
#: man-pages/man5/proc.5:5504 man-pages/man5/proc.5:5542
#, no-wrap
msgid "1:"
msgstr "1:"

#. type: Plain text
#: man-pages/man5/proc.5:5510
msgid ""
"Kill all processes that have the corrupted-and-not-reloadable page mapped as "
"soon as the corruption is detected.  Note that this is not supported for a "
"few types of pages, such as kernel internally allocated data or the swap "
"cache, but works for the majority of user pages."
msgstr ""
"При обнаружении завершать все процессы, у которых есть повреждённые и не "
"восстановимые с диска страницы. Заметим, что это поддерживается не для всех "
"типов страниц, например для внутренних данных ядра или кэша подкачки, но "
"работает для большинства пользовательских страниц."

#. type: IP
#: man-pages/man5/proc.5:5510 man-pages/man5/proc.5:5544
#, no-wrap
msgid "0:"
msgstr "0:"

#. type: Plain text
#: man-pages/man5/proc.5:5513
msgid ""
"Unmap the corrupted page from all processes and kill a process only if it "
"tries to access the page."
msgstr ""
"Отключить отображение повреждённой страницы у всех процессов и завершать "
"процессы, только если они пытаются к ней обратиться."

#. type: Plain text
#: man-pages/man5/proc.5:5524
msgid ""
"The kill is performed using a B<SIGBUS> signal with I<si_code> set to "
"B<BUS_MCEERR_AO>.  Processes can handle this if they want to; see "
"B<sigaction>(2)  for more details."
msgstr ""
"Такое завершение выполняется с использованием сигнала B<SIGBUS> с "
"установления значения I<si_code> равным B<BUS_MCEERR_AO>. Процессы могут "
"обработать такую ситуацию, если захотят; подробней см. B<sigaction>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:5527
msgid ""
"This feature is active only on architectures/platforms with advanced machine "
"check handling and depends on the hardware capabilities."
msgstr ""
"Это свойство активно только на архитектурах/платформах с дополнительными "
"проверки и зависит от возможностей аппаратного обеспечения."

#. type: Plain text
#: man-pages/man5/proc.5:5534
msgid ""
"Applications can override the I<memory_failure_early_kill> setting "
"individually with the B<prctl>(2)  B<PR_MCE_KILL> operation."
msgstr ""
"Приложения могут изменить настройку I<memory_failure_early_kill> для себя с "
"помощью операции B<PR_MCE_KILL> вызова B<prctl>(2)."

#. type: Plain text
#: man-pages/man5/proc.5:5537 man-pages/man5/proc.5:5550
msgid ""
"Present only if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr ""
"Доступен только, если ядро собрано с параметром B<CONFIG_MEMORY_FAILURE>."

#. type: TP
#: man-pages/man5/proc.5:5537
#, no-wrap
msgid "I</proc/sys/vm/memory_failure_recovery> (since Linux 2.6.32)"
msgstr "I</proc/sys/vm/memory_failure_recovery> (начиная с Linux 2.6.32)"

#.  The following is based on the text in Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:5541
msgid "Enable memory failure recovery (when supported by the platform)"
msgstr ""
"Включает восстановление отказов памяти (если поддерживается платформой)"

#. type: Plain text
#: man-pages/man5/proc.5:5544
msgid "Attempt recovery."
msgstr "Пытаться восстановить."

#. type: Plain text
#: man-pages/man5/proc.5:5546
msgid "Always panic on a memory failure."
msgstr "При отказе памяти всегда доводить до паники."

#. type: TP
#: man-pages/man5/proc.5:5550
#, no-wrap
msgid "I</proc/sys/vm/oom_dump_tasks> (since Linux 2.6.25)"
msgstr "I</proc/sys/vm/oom_dump_tasks> (начиная с Linux 2.6.25)"

#.  The following is from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:5565
msgid ""
"Enables a system-wide task dump (excluding kernel threads) to be produced "
"when the kernel performs an OOM-killing.  The dump includes the following "
"information for each task (thread, process): thread ID, real user ID, thread "
"group ID (process ID), virtual memory size, resident set size, the CPU that "
"the task is scheduled on, oom_adj score (see the description of I</proc/"
"[pid]/oom_adj>), and command name.  This is helpful to determine why the OOM-"
"killer was invoked and to identify the rogue task that caused it."
msgstr ""
"Включает системный дамп задач (исключая ядерные нити), который создаётся "
"когда ядро выполняет OOM-killing. Дамп включает следующую информацию по "
"каждой задаче (нити, процессу): ID нити, реальный ID пользователя, ID группы "
"нитей (ID процесса), размер виртуальной памяти, размер резидентной "
"настройки, процессор, на котором работала задача, счётчик oom_adj (описание "
"смотрите в I</proc/[pid]/oom_adj>) и имя команды. Эти данные полезны для "
"определения того, почему был вызван OOM-killer и нахождения экземпляра "
"задачи, его вызвавшего."

#. type: Plain text
#: man-pages/man5/proc.5:5571
msgid ""
"If this contains the value zero, this information is suppressed.  On very "
"large systems with thousands of tasks, it may not be feasible to dump the "
"memory state information for each one.  Such systems should not be forced to "
"incur a performance penalty in OOM situations when the information may not "
"be desired."
msgstr ""
"Если в файле содержится нулевое значение, то информация не выдаётся. На "
"очень больших системах с тысячами задач дамп информации о состоянии памяти "
"может быть неосуществим по каждой задаче. Системы не должны страдать от "
"потери производительности из-за возникновения ситуаций с OOM, если такая "
"информация ненужна."

#. type: Plain text
#: man-pages/man5/proc.5:5574
msgid ""
"If this is set to nonzero, this information is shown whenever the OOM-killer "
"actually kills a memory-hogging task."
msgstr ""
"Если задано ненулевое значение, то эта информация показывается в момент "
"когда OOM-killer завершает захватившую память задачу."

#. type: Plain text
#: man-pages/man5/proc.5:5576 man-pages/man5/proc.5:5597
msgid "The default value is 0."
msgstr "Значение по умолчанию равно 0."

#. type: TP
#: man-pages/man5/proc.5:5576
#, no-wrap
msgid "I</proc/sys/vm/oom_kill_allocating_task> (since Linux 2.6.24)"
msgstr "I</proc/sys/vm/oom_kill_allocating_task> (начиная с Linux 2.6.24)"

#.  The following is from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:5581
msgid ""
"This enables or disables killing the OOM-triggering task in out-of-memory "
"situations."
msgstr ""
"Включает или выключает задачу завершения при OOM (исчерпание свободной "
"памяти)."

#. type: Plain text
#: man-pages/man5/proc.5:5586
msgid ""
"If this is set to zero, the OOM-killer will scan through the entire tasklist "
"and select a task based on heuristics to kill.  This normally selects a "
"rogue memory-hogging task that frees up a large amount of memory when killed."
msgstr ""
"Если это значение равно нулю, то OOM-killer будет сканировать весь список "
"задач и выбирать задачу для завершения на основе набора эвристических "
"правил. Обычно выбирается задача, которая больше всех захватила памяти, что "
"при её завершении позволит освободить огромное количество памяти."

#. type: Plain text
#: man-pages/man5/proc.5:5590
msgid ""
"If this is set to nonzero, the OOM-killer simply kills the task that "
"triggered the out-of-memory condition.  This avoids a possibly expensive "
"tasklist scan."
msgstr ""
"Если это значение не равно нулю, то OOM-killer просто завершит задачу, из-за "
"которой возникла ситуация нехватки памяти. Это позволяет избежать затратной "
"операции сканирования списка задач."

#. type: Plain text
#: man-pages/man5/proc.5:5595
msgid ""
"If I</proc/sys/vm/panic_on_oom> is nonzero, it takes precedence over "
"whatever value is used in I</proc/sys/vm/oom_kill_allocating_task>."
msgstr ""
"Если I</proc/sys/vm/panic_on_oom> не равно нулю, то оно имеет приоритет над "
"значением из I</proc/sys/vm/oom_kill_allocating_task>."

#. type: TP
#: man-pages/man5/proc.5:5597
#, no-wrap
msgid "I</proc/sys/vm/overcommit_kbytes> (since Linux 3.14)"
msgstr "I</proc/sys/vm/overcommit_kbytes> (начиная с Linux 3.14)"

#.  commit 49f0ce5f92321cdcf741e35f385669a421013cb7
#. type: Plain text
#: man-pages/man5/proc.5:5614
msgid ""
"This writable file provides an alternative to I</proc/sys/vm/"
"overcommit_ratio> for controlling the I<CommitLimit> when I</proc/sys/vm/"
"overcommit_memory> has the value 2.  It allows the amount of memory "
"overcommitting to be specified as an absolute value (in kB), rather than as "
"a percentage, as is done with I<overcommit_ratio>.  This allows for finer-"
"grained control of I<CommitLimit> on systems with extremely large memory "
"sizes."
msgstr ""
"Данный, доступный на запись файл является альтернативой управлению "
"I<CommitLimit> через I</proc/sys/vm/overcommit_ratio>, когда I</proc/sys/vm/"
"overcommit_memory> содержит значение 2. Это позволяет задать количество "
"перерасходуемой памяти (memory overcommitting) абсолютным значением (в КБ), "
"а не в виде процента, как это делается через I<overcommit_ratio>. Это "
"предоставляет более точный контроль I<CommitLimit> в системах с очень "
"большим объёмом памяти."

#. type: Plain text
#: man-pages/man5/proc.5:5629
msgid ""
"Only one of I<overcommit_kbytes> or I<overcommit_ratio> can have an effect: "
"if I<overcommit_kbytes> has a nonzero value, then it is used to calculate "
"I<CommitLimit>, otherwise I<overcommit_ratio> is used.  Writing a value to "
"either of these files causes the value in the other file to be set to zero."
msgstr ""
"Может задействовать либо I<overcommit_kbytes>, либо I<overcommit_ratio>: "
"если значение I<overcommit_kbytes> не равно нулю, то оно используется для "
"вычисления, в противном случае используется I<overcommit_ratio>. Запись "
"значения в один из этих файлов приводит к обнулению значения в другом файле."

#. type: TP
#: man-pages/man5/proc.5:5629
#, no-wrap
msgid "I</proc/sys/vm/overcommit_memory>"
msgstr "I</proc/sys/vm/overcommit_memory>"

#. type: Plain text
#: man-pages/man5/proc.5:5633
msgid ""
"This file contains the kernel virtual memory accounting mode.  Values are:"
msgstr ""
"Этот файл содержит значение режима учёта виртуальной памяти ядра. Значения:"

#. type: Plain text
#: man-pages/man5/proc.5:5636
msgid "0: heuristic overcommit (this is the default)"
msgstr "0: эвристический перерасход (значение по умолчанию)"

#. type: Plain text
#: man-pages/man5/proc.5:5638
msgid "1: always overcommit, never check"
msgstr "1: всегда разрешать перерасход, не проверять"

#. type: Plain text
#: man-pages/man5/proc.5:5640
msgid "2: always check, never overcommit"
msgstr "2: всегда проверять, запретить перерасход"

#. type: Plain text
#: man-pages/man5/proc.5:5648
msgid ""
"In mode 0, calls of B<mmap>(2)  with B<MAP_NORESERVE> are not checked, and "
"the default check is very weak, leading to the risk of getting a process "
"\"OOM-killed\"."
msgstr ""
"В режиме 0 вызов B<mmap>(2) с B<MAP_NORESERVE> не проверяется, и проверка по "
"умолчанию очень поверхностная, что может привести к завершению процесса с "
"помощью OOM-killer."

#. type: Plain text
#: man-pages/man5/proc.5:5654
msgid ""
"In mode 1, the kernel pretends there is always enough memory, until memory "
"actually runs out.  One use case for this mode is scientific computing "
"applications that employ large sparse arrays.  In Linux kernel versions "
"before 2.6.0, any nonzero value implies mode 1."
msgstr ""
"В режиме 1, ядро притворяется, что памяти всегда достаточно, пока помять "
"действительно не закончится. Одним из вариантов использования для этого "
"режима являются приложения для научных вычислений, в которые используются "
"большие разреженные массивы. В ядрах Linux до версии 2.6.0 любое ненулевое "
"значение подразумевает режим 1."

#. type: Plain text
#: man-pages/man5/proc.5:5661
msgid ""
"In mode 2 (available since Linux 2.6), the total virtual address space that "
"can be allocated (I<CommitLimit> in I</proc/meminfo>)  is calculated as"
msgstr ""
"В режиме 2 (доступен начиная с Linux 2.6), общее виртуальное адресное "
"пространство, которое можно выделить (I<CommitLimit> в I</proc/meminfo>) "
"вычисляется по формуле"

#. type: Plain text
#: man-pages/man5/proc.5:5664
#, no-wrap
msgid ""
"    CommitLimit = (total_RAM - total_huge_TLB) *\n"
"                  overcommit_ratio / 100 + total_swap\n"
msgstr ""
"    CommitLimit = (total_RAM - total_huge_TLB) *\n"
"                  overcommit_ratio / 100 + total_swap\n"

#. type: Plain text
#: man-pages/man5/proc.5:5666
msgid "where:"
msgstr "где:"

#. type: Plain text
#: man-pages/man5/proc.5:5670
msgid "I<total_RAM> is the total amount of RAM on the system;"
msgstr "I<total_RAM> — общее количество физической памяти в системе;"

#. type: Plain text
#: man-pages/man5/proc.5:5673
msgid "I<total_huge_TLB> is the amount of memory set aside for huge pages;"
msgstr "I<total_huge_TLB> — количество памяти без учёта огромных страниц;"

#. type: Plain text
#: man-pages/man5/proc.5:5678
msgid ""
"I<overcommit_ratio> is the value in I</proc/sys/vm/overcommit_ratio>; and"
msgstr "I<overcommit_ratio> — значение в I</proc/sys/vm/overcommit_ratio>; и"

#. type: Plain text
#: man-pages/man5/proc.5:5681
msgid "I<total_swap> is the amount of swap space."
msgstr "I<total_swap> — размер пространства подкачки."

#. type: Plain text
#: man-pages/man5/proc.5:5689
msgid ""
"For example, on a system with 16GB of physical RAM, 16GB of swap, no space "
"dedicated to huge pages, and an I<overcommit_ratio> of 50, this formula "
"yields a I<CommitLimit> of 24GB."
msgstr ""
"Например, в системе с 16ГБ физической памяти, 16ГБ подкачки, без выделения "
"огромных страниц и с I<overcommit_ratio> равным 50 по этой формуле значение "
"I<CommitLimit> равно 24ГБ."

#. type: Plain text
#: man-pages/man5/proc.5:5695
msgid ""
"Since Linux 3.14, if the value in I</proc/sys/vm/overcommit_kbytes> is "
"nonzero, then I<CommitLimit> is instead calculated as:"
msgstr ""
"Начиная с Linux 3.14, если значение в I</proc/sys/vm/overcommit_kbytes> не "
"равно нулю, то I<CommitLimit> вычисляется так:"

#. type: Plain text
#: man-pages/man5/proc.5:5697
#, no-wrap
msgid "    CommitLimit = overcommit_kbytes + total_swap\n"
msgstr "    CommitLimit = overcommit_kbytes + total_swap\n"

#. type: Plain text
#: man-pages/man5/proc.5:5702
msgid ""
"See also the description of I</proc/sys/vm/admin_reserve_kbytes> and I</proc/"
"sys/vm/user_reserve_kbytes>."
msgstr ""
"Также смотрите описание I</proc/sys/vm/admin_reserve_kbytes> и I</proc/sys/"
"vm/user_reserve_kbytes>."

#. type: TP
#: man-pages/man5/proc.5:5702
#, no-wrap
msgid "I</proc/sys/vm/overcommit_ratio> (since Linux 2.6.0)"
msgstr "I</proc/sys/vm/overcommit_ratio> (начиная с Linux 2.6.0)"

#. type: Plain text
#: man-pages/man5/proc.5:5709
msgid ""
"This writable file defines a percentage by which memory can be "
"overcommitted.  The default value in the file is 50.  See the description of "
"I</proc/sys/vm/overcommit_memory>."
msgstr ""
"Доступный на запись файл содержит процент памяти, который может быть "
"перерасходован (overcommitted). Значение по умолчанию равно 50. Смотрите "
"описание I</proc/sys/vm/overcommit_memory>."

#. type: TP
#: man-pages/man5/proc.5:5709
#, no-wrap
msgid "I</proc/sys/vm/panic_on_oom> (since Linux 2.6.18)"
msgstr "I</proc/sys/vm/panic_on_oom> (начиная с Linux 2.6.18)"

#.  The following is adapted from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:5714
msgid "This enables or disables a kernel panic in an out-of-memory situation."
msgstr "Включает или отключает панику ядра при нехватке памяти."

#. type: Plain text
#: man-pages/man5/proc.5:5719
msgid ""
"If this file is set to the value 0, the kernel's OOM-killer will kill some "
"rogue process.  Usually, the OOM-killer is able to kill a rogue process and "
"the system will survive."
msgstr ""
"Если значение равно 0, то ядерный OOM-killer завершит какой-нибудь вышедший "
"из подчинения процесс. Обычно, OOM-killer способен завершить такой процесс и "
"система продолжит работу."

#. type: Plain text
#: man-pages/man5/proc.5:5734
msgid ""
"If this file is set to the value 1, then the kernel normally panics when out-"
"of-memory happens.  However, if a process limits allocations to certain "
"nodes using memory policies (B<mbind>(2)  B<MPOL_BIND>)  or cpusets "
"(B<cpuset>(7))  and those nodes reach memory exhaustion status, one process "
"may be killed by the OOM-killer.  No panic occurs in this case: because "
"other nodes' memory may be free, this means the system as a whole may not "
"have reached an out-of-memory situation yet."
msgstr ""
"Если значение в файле равно 1, то ядро, обычно, переходит в состояние паники "
"при нехватке памяти. Однако, если процесс ограничен в выделении определённых "
"элементов (nodes) согласно политике памяти (B<mbind>(2) B<MPOL_BIND>) или "
"процессора (B<cpuset>(7)) и предел таких элементов памяти был достигнут, то "
"такой процесс может быть завершён OOM-killer. В этом случае состояние паники "
"не возникнет, так как другие элементы памяти могут освободиться, что "
"означает, что система в целом может не прийти к ситуации нехватки памяти."

#. type: Plain text
#: man-pages/man5/proc.5:5737
msgid ""
"If this file is set to the value 2, the kernel always panics when an out-of-"
"memory condition occurs."
msgstr ""
"Если значение в файле равно 2, то ядро всегда переходит в состояние паники, "
"когда возникает нехватка памяти."

#. type: Plain text
#: man-pages/man5/proc.5:5741
msgid ""
"The default value is 0.  1 and 2 are for failover of clustering.  Select "
"either according to your policy of failover."
msgstr ""
"Значение по умолчанию равно 0. Значение 1 и 2 используются для "
"отказоустойчивости кластеров. Выберите любое согласно вашей политике "
"отказоустойчивости."

#. type: TP
#: man-pages/man5/proc.5:5741
#, no-wrap
msgid "I</proc/sys/vm/swappiness>"
msgstr "I</proc/sys/vm/swappiness>"

#.  The following is from Documentation/sysctl/vm.txt
#. type: Plain text
#: man-pages/man5/proc.5:5749
msgid ""
"The value in this file controls how aggressively the kernel will swap memory "
"pages.  Higher values increase aggressiveness, lower values decrease "
"aggressiveness.  The default value is 60."
msgstr ""
"Значение в этом файле определяет, насколько активно ядро будет вытеснять "
"страницы в пространство подкачки. Большие значения увеличивают активность, "
"меньшие значения сокращают активность. По умолчанию значение равно 60."

#. type: TP
#: man-pages/man5/proc.5:5749
#, no-wrap
msgid "I</proc/sys/vm/user_reserve_kbytes> (since Linux 3.10)"
msgstr "I</proc/sys/vm/user_reserve_kbytes> (начиная с Linux 3.10)"

#.  commit c9b1d0981fcce3d9976d7b7a56e4e0503bc610dd
#. type: Plain text
#: man-pages/man5/proc.5:5761
msgid ""
"Specifies an amount of memory (in KiB) to reserve for user processes, This "
"is intended to prevent a user from starting a single memory hogging process, "
"such that they cannot recover (kill the hog).  The value in this file has an "
"effect only when I</proc/sys/vm/overcommit_memory> is set to 2 (\"overcommit "
"never\" mode).  In this case, the system reserves an amount of memory that "
"is the minimum of [3% of current process size, I<user_reserve_kbytes>]."
msgstr ""
"Задаёт количество памяти (в КиБ), которая резервируется под процессы "
"пользователя. Предназначена для предотвращения запуска пользовательского "
"процесса, который бы один съел всю память и это нельзя прекратить (завершить "
"такой процесс). Это значение учитывается только, если значение в I</proc/sys/"
"vm/overcommit_memory> равно 2 (режим «без перерасхода»). В этом случае "
"система резервирует количество памяти, равное, минимум [3% от размера "
"текущего процесса, I<user_reserve_kbytes>]."

#. type: Plain text
#: man-pages/man5/proc.5:5764
msgid ""
"The default value in this file is the minimum of [3% of free pages, 128MiB] "
"expressed as KiB."
msgstr ""
"Значение по умолчанию равно минимум [3% свободных страниц, 128 МиБ], "
"выражается в  КиБ."

#. type: Plain text
#: man-pages/man5/proc.5:5771
msgid ""
"If the value in this file is set to zero, then a user will be allowed to "
"allocate all free memory with a single process (minus the amount reserved by "
"I</proc/sys/vm/admin_reserve_kbytes>).  Any subsequent attempts to execute a "
"command will result in \"fork: Cannot allocate memory\"."
msgstr ""
"Если значение в файле равно нулю, то пользователю разрешено выделять всю "
"память под один процесс (за минусом резерва из I</proc/sys/vm/"
"admin_reserve_kbytes>). Любая последующая попытка  выполнить команду будет "
"завершаться «fork: невозможно выделить память»."

#. type: TP
#: man-pages/man5/proc.5:5774
#, no-wrap
msgid "I</proc/sysrq-trigger> (since Linux 2.4.21)"
msgstr "I</proc/sysrq-trigger> (начиная с Linux 2.4.21)"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: man-pages/man5/proc.5:5787
msgid ""
"Writing a character to this file triggers the same SysRq function as typing "
"ALT-SysRq-E<lt>characterE<gt> (see the description of I</proc/sys/kernel/"
"sysrq>).  This file is normally writable only by I<root>.  For further "
"details see the Linux kernel source file I<Documentation/admin-guide/sysrq."
"rst> (or I<Documentation/sysrq.txt> before Linux 4.10)."
msgstr ""
"Запись символа в этот файл приводит к вызову функции SysRq, как если бы была "
"нажата E<lt>клавишаE<gt> ALT-SysRq (смотрите описание I</proc/sys/kernel/"
"sysrq>). Обычно, этот файл доступен на запись только I<root>. Дополнительную "
"информацию смотрите в исходном коде ядра Linux в файле I<Documentation/admin-"
"guide/sysrq.rst> (или I<Documentation/sysrq.txt> до Linux 4.10)."

#. type: TP
#: man-pages/man5/proc.5:5787
#, no-wrap
msgid "I</proc/sysvipc>"
msgstr "I</proc/sysvipc>"

#. type: Plain text
#: man-pages/man5/proc.5:5800
msgid ""
"Subdirectory containing the pseudo-files I<msg>, I<sem> and I<shm>.  These "
"files list the System V Interprocess Communication (IPC) objects "
"(respectively: message queues, semaphores, and shared memory)  that "
"currently exist on the system, providing similar information to that "
"available via B<ipcs>(1).  These files have headers and are formatted (one "
"IPC object per line)  for easy understanding.  B<sysvipc>(7)  provides "
"further background on the information shown by these files."
msgstr ""
"Подкаталог содержит псевдо-файлы I<msg>, I<sem> и I<shm>.Эти файлы описывают "
"объекты межпроцессного взаимодействия (System V Interprocess Communication "
"(IPC)) (соответственно: очереди сообщений, семафоры и общую память), которые "
"существуют в системе в настоящий момент. Похожая информация предоставляется "
"через B<ipcs>(1). Эти файлы имеют заголовки и форматируются (по одному IPC "
"объекту на строку) для более лёгкого понимания. В B<sysvipc>(7) представлена "
"подробное описание информации в этих файлах."

#. type: TP
#: man-pages/man5/proc.5:5800
#, no-wrap
msgid "I</proc/thread-self> (since Linux 3.17)"
msgstr "I</proc/thread-self> (начиная с Linux 3.17)"

#.  commit 0097875bd41528922fb3bb5f348c53f17e00e2fd
#. type: Plain text
#: man-pages/man5/proc.5:5811
msgid ""
"This directory refers to the thread accessing the I</proc> filesystem, and "
"is identical to the I</proc/self/task/[tid]> directory named by the process "
"thread ID (I<[tid]>)  of the same thread."
msgstr ""
"Этот каталог ссылает на нить, обращающуюся к файловой системе I</proc>, и он "
"идентичен каталогу I</proc/self/task/[tid]>, где в имени ID нити процесса "
"(I<[tid]>)  — эта же нить."

#. type: TP
#: man-pages/man5/proc.5:5811
#, no-wrap
msgid "I</proc/timer_list> (since Linux 2.6.21)"
msgstr "I</proc/timer_list> (начиная с Linux 2.6.21)"

#.  commit 289f480af87e45f7a6de6ba9b4c061c2e259fe98
#. type: Plain text
#: man-pages/man5/proc.5:5817
msgid ""
"This read-only file exposes a list of all currently pending (high-"
"resolution) timers, all clock-event sources, and their parameters in a human-"
"readable form."
msgstr ""
"Этот файл, доступный только для чтения, содержит список всех ожидающих в "
"данный момент таймеров (высокой точности), всех источников событий часов и "
"их параметры."

#. type: TP
#: man-pages/man5/proc.5:5817
#, no-wrap
msgid "I</proc/timer_stats> (from  Linux 2.6.21 until Linux 4.10)"
msgstr "I</proc/timer_stats> (Linux 2.6.21 по Linux 4.10)"

#.  commit 82f67cd9fca8c8762c15ba7ed0d5747588c1e221
#. 	Date:   Fri Feb 16 01:28:13 2007 -0800
#.  Text largely derived from Documentation/timers/timer_stats.txt
#.  removed in commit dfb4357da6ddbdf57d583ba64361c9d792b0e0b1
#.      Date:   Wed Feb 8 11:26:59 2017 -0800
#. type: Plain text
#: man-pages/man5/proc.5:5830
msgid ""
"This is a debugging facility to make timer (ab)use in a Linux system visible "
"to kernel and user-space developers.  It can be used by kernel and user-"
"space developers to verify that their code does not make undue use of "
"timers.  The goal is to avoid unnecessary wakeups, thereby optimizing power "
"consumption."
msgstr ""
"Это отладочное средство делает таймер, используемый в системе Linux, видимым "
"разработчикам ядра и в пользовательском пространстве. Оно может "
"использоваться для проверки отсутствия чрезмерной нагрузки на таймеры. Цель "
"— для оптимизации потребления энергии избежать ненужных пробуждений."

#. type: Plain text
#: man-pages/man5/proc.5:5838
msgid ""
"If enabled in the kernel (B<CONFIG_TIMER_STATS>), but not used, it has "
"almost zero run-time overhead and a relatively small data-structure "
"overhead.  Even if collection is enabled at run time, overhead is low: all "
"the locking is per-CPU and lookup is hashed."
msgstr ""
"Если включено в ядре (B<CONFIG_TIMER_STATS>) и не используется, то почти не "
"задействует процессор и потребляет относительно малое количество памяти под "
"структуры данных. Даже включённый в время выполнения сбор статистики не даёт "
"высокой нагрузки: все блокировки относятся к ЦП, а поиск хэшируется."

#. type: Plain text
#: man-pages/man5/proc.5:5843
msgid ""
"The I</proc/timer_stats> file is used both to control sampling facility and "
"to read out the sampled information."
msgstr ""
"Файл I</proc/timer_stats> используется для управления функцией сборки и "
"чтения полученных результатов."

#. type: Plain text
#: man-pages/man5/proc.5:5848
msgid ""
"The I<timer_stats> functionality is inactive on bootup.  A sampling period "
"can be started using the following command:"
msgstr ""
"Средство I<timer_stats> при запуске системы неактивно. Период тестирования "
"может быть запущен командой:"

#. type: Plain text
#: man-pages/man5/proc.5:5852
#, no-wrap
msgid "# echo 1 E<gt> /proc/timer_stats\n"
msgstr "# echo 1 E<gt> /proc/timer_stats\n"

#. type: Plain text
#: man-pages/man5/proc.5:5856
msgid "The following command stops a sampling period:"
msgstr "Следующая команда остановит период тестирования:"

#. type: Plain text
#: man-pages/man5/proc.5:5860
#, no-wrap
msgid "# echo 0 E<gt> /proc/timer_stats\n"
msgstr "# echo 0 E<gt> /proc/timer_stats\n"

#. type: Plain text
#: man-pages/man5/proc.5:5864
msgid "The statistics can be retrieved by:"
msgstr "Статистику можно получить так:"

#. type: Plain text
#: man-pages/man5/proc.5:5868
#, no-wrap
msgid "$ cat /proc/timer_stats\n"
msgstr "$ cat /proc/timer_stats\n"

#. type: Plain text
#: man-pages/man5/proc.5:5878
msgid ""
"While sampling is enabled, each readout from I</proc/timer_stats> will see "
"newly updated statistics.  Once sampling is disabled, the sampled "
"information is kept until a new sample period is started.  This allows "
"multiple readouts."
msgstr ""
"На время действия периода сбора каждым чтением I</proc/timer_stats> можно "
"получить обновлённую статистику. После выключения сбора статистика останется "
"доступной до следующего начала периода сбора. Это позволяет читать несколько "
"раз."

#. type: Plain text
#: man-pages/man5/proc.5:5881
msgid "Sample output from I</proc/timer_stats>:"
msgstr "Пример статистики из I</proc/timer_stats>:"

#. type: Plain text
#: man-pages/man5/proc.5:5897
#, no-wrap
msgid ""
"$B< cat /proc/timer_stats>\n"
"Timer Stats Version: v0.3\n"
"Sample period: 1.764 s\n"
"Collection: active\n"
"  255,     0 swapper/3        hrtimer_start_range_ns (tick_sched_timer)\n"
"   71,     0 swapper/1        hrtimer_start_range_ns (tick_sched_timer)\n"
"   58,     0 swapper/0        hrtimer_start_range_ns (tick_sched_timer)\n"
"    4,  1694 gnome-shell      mod_delayed_work_on (delayed_work_timer_fn)\n"
"   17,     7 rcu_sched        rcu_gp_kthread (process_timeout)\n"
"\\&...\n"
"    1,  4911 kworker/u16:0    mod_delayed_work_on (delayed_work_timer_fn)\n"
"   1D,  2522 kworker/0:0      queue_delayed_work_on (delayed_work_timer_fn)\n"
"1029 total events, 583.333 events/sec\n"
msgstr ""
"$B< cat /proc/timer_stats>\n"
"Timer Stats Version: v0.3\n"
"Sample period: 1.764 s\n"
"Collection: active\n"
"  255,     0 swapper/3        hrtimer_start_range_ns (tick_sched_timer)\n"
"   71,     0 swapper/1        hrtimer_start_range_ns (tick_sched_timer)\n"
"   58,     0 swapper/0        hrtimer_start_range_ns (tick_sched_timer)\n"
"    4,  1694 gnome-shell      mod_delayed_work_on (delayed_work_timer_fn)\n"
"   17,     7 rcu_sched        rcu_gp_kthread (process_timeout)\n"
"\\&...\n"
"    1,  4911 kworker/u16:0    mod_delayed_work_on (delayed_work_timer_fn)\n"
"   1D,  2522 kworker/0:0      queue_delayed_work_on (delayed_work_timer_fn)\n"
"1029 total events, 583.333 events/sec\n"

#. type: Plain text
#: man-pages/man5/proc.5:5901
msgid "The output columns are:"
msgstr "Выводимые столбцы:"

#.  commit c5c061b8f9726bc2c25e19dec227933a13d1e6b7 deferrable timers
#. type: Plain text
#: man-pages/man5/proc.5:5907
msgid ""
"a count of the number of events, optionally (since Linux 2.6.23) followed by "
"the letter \\(aqD\\(aq if this is a deferrable timer;"
msgstr ""
"счётчик событий, за которым следует (начиная с Linux 2.6.23) необязательная "
"буква «D», если это отложенный таймер;"

#. type: Plain text
#: man-pages/man5/proc.5:5909
msgid "the PID of the process that initialized the timer;"
msgstr "PID процесса, который инициализировал таймер;"

#. type: Plain text
#: man-pages/man5/proc.5:5911
msgid "the name of the process that initialized the timer;"
msgstr "имя процесса, который инициализировал таймер;"

#. type: Plain text
#: man-pages/man5/proc.5:5913
msgid "the function where the timer was initialized; and"
msgstr "функция, откуда был инициализирован таймер, и"

#. type: Plain text
#: man-pages/man5/proc.5:5916
msgid ""
"(in parentheses)  the callback function that is associated with the timer."
msgstr "(в скобках) функция обратного вызова, которая связана с таймером."

#. type: Plain text
#: man-pages/man5/proc.5:5923
msgid ""
"During the Linux 4.11 development cycle, this file was removed because of "
"security concerns, as it exposes information across namespaces.  "
"Furthermore, it is possible to obtain the same information via in-kernel "
"tracing facilities such as ftrace."
msgstr ""
"В течении цикла разработки Linux 4.11 этот файл был удалён из-за проблем с "
"безопасностью, так как выдавал информацию всем пространствам имён. Кроме "
"этого, подобную информацию можно получить через встроенные в ядро "
"возможности трассировки, например через ftrace."

#. type: TP
#: man-pages/man5/proc.5:5923
#, no-wrap
msgid "I</proc/tty>"
msgstr "I</proc/tty>"

#. type: Plain text
#: man-pages/man5/proc.5:5927
msgid ""
"Subdirectory containing the pseudo-files and subdirectories for tty drivers "
"and line disciplines."
msgstr ""
"Подкаталог, содержащий псевдо-файлы и подкаталоги драйверов tty и параметры "
"линий."

#. type: TP
#: man-pages/man5/proc.5:5927
#, no-wrap
msgid "I</proc/uptime>"
msgstr "I</proc/uptime>"

#. type: Plain text
#: man-pages/man5/proc.5:5932
msgid ""
"This file contains two numbers (values in seconds): the uptime of the system "
"(including time spent in suspend) and the amount of time spent in the idle "
"process."
msgstr ""
"Этот файл содержит два числа (значения в секундах): время работы системы с "
"момента загрузки (включая время, проведённой режиме приостанова) и время, "
"которое система провела в состоянии простоя."

#. type: TP
#: man-pages/man5/proc.5:5932
#, no-wrap
msgid "I</proc/version>"
msgstr "I</proc/version>"

#. type: Plain text
#: man-pages/man5/proc.5:5941
msgid ""
"This string identifies the kernel version that is currently running.  It "
"includes the contents of I</proc/sys/kernel/ostype>, I</proc/sys/kernel/"
"osrelease> and I</proc/sys/kernel/version>.  For example:"
msgstr ""
"Строка, идентифицирующая версию ядра, которое запущено в данный момент. Она "
"включает содержимое I</proc/sys/kernel/ostype>, I</proc/sys/kernel/"
"osrelease> и I</proc/sys/kernel/version>. Пример:"

#. type: Plain text
#: man-pages/man5/proc.5:5945
#, no-wrap
msgid "Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994\n"
msgstr "Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994\n"

#. type: TP
#: man-pages/man5/proc.5:5952
#, no-wrap
msgid "I</proc/vmstat> (since Linux 2.6.0)"
msgstr "I</proc/vmstat> (начиная с Linux 2.6.0)"

#.  FIXME We need explanations for each of the following fields...
#. type: Plain text
#: man-pages/man5/proc.5:5964
msgid ""
"This file displays various virtual memory statistics.  Each line of this "
"file contains a single name-value pair, delimited by white space.  Some "
"lines are present only if the kernel was configured with suitable options.  "
"(In some cases, the options required for particular files have changed "
"across kernel versions, so they are not listed here.  Details can be found "
"by consulting the kernel source code.)  The following fields may be present:"
msgstr ""
"Этот файл отражает различную статистику виртуальной памяти. Каждая строка "
"файла содержит одну пару имя-значение (через пробел). Некоторые строки "
"присутствуют только, если ядро собрано с соответствующим параметром (в "
"некоторых случаях требуемые параметры в различные в разных версиях ядер и не "
"перечислены здесь. Подробности можно найти в исходном коде ядра). Существуют "
"следующие поля:"

#. type: TP
#: man-pages/man5/proc.5:5965
#, no-wrap
msgid "I<nr_free_pages> (since Linux 2.6.31)"
msgstr "I<nr_free_pages> (начиная с Linux 2.6.31)"

#. type: TP
#: man-pages/man5/proc.5:5968
#, no-wrap
msgid "I<nr_alloc_batch> (since Linux 3.12)"
msgstr "I<nr_alloc_batch> (начиная с Linux 3.12)"

#. type: TP
#: man-pages/man5/proc.5:5971
#, no-wrap
msgid "I<nr_inactive_anon> (since Linux 2.6.28)"
msgstr "I<nr_inactive_anon> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:5974
#, no-wrap
msgid "I<nr_active_anon> (since Linux 2.6.28)"
msgstr "I<nr_active_anon> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:5977
#, no-wrap
msgid "I<nr_inactive_file> (since Linux 2.6.28)"
msgstr "I<nr_inactive_file> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:5980
#, no-wrap
msgid "I<nr_active_file> (since Linux 2.6.28)"
msgstr "I<nr_active_file> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:5983
#, no-wrap
msgid "I<nr_unevictable> (since Linux 2.6.28)"
msgstr "I<nr_unevictable> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:5986
#, no-wrap
msgid "I<nr_mlock> (since Linux 2.6.28)"
msgstr "I<nr_mlock> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:5989
#, no-wrap
msgid "I<nr_anon_pages> (since Linux 2.6.18)"
msgstr "I<nr_anon_pages> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:5992
#, no-wrap
msgid "I<nr_mapped> (since Linux 2.6.0)"
msgstr "I<nr_mapped> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:5994
#, no-wrap
msgid "I<nr_file_pages> (since Linux 2.6.18)"
msgstr "I<nr_file_pages> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:5997
#, no-wrap
msgid "I<nr_dirty> (since Linux 2.6.0)"
msgstr "I<nr_dirty> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:5999
#, no-wrap
msgid "I<nr_writeback> (since Linux 2.6.0)"
msgstr "I<nr_writeback> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6001
#, no-wrap
msgid "I<nr_slab_reclaimable> (since Linux 2.6.19)"
msgstr "I<nr_slab_reclaimable> (начиная с Linux 2.6.19)"

#. type: TP
#: man-pages/man5/proc.5:6005
#, no-wrap
msgid "I<nr_slab_unreclaimable> (since Linux 2.6.19)"
msgstr "I<nr_slab_unreclaimable> (начиная с Linux 2.6.19)"

#. type: TP
#: man-pages/man5/proc.5:6008
#, no-wrap
msgid "I<nr_page_table_pages> (since Linux 2.6.0)"
msgstr "I<nr_page_table_pages> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6010
#, no-wrap
msgid "I<nr_kernel_stack> (since Linux 2.6.32)"
msgstr "I<nr_kernel_stack> (начиная с Linux 2.6.32)"

#. type: TP
#: man-pages/man5/proc.5:6014
#, no-wrap
msgid "I<nr_unstable> (since Linux 2.6.0)"
msgstr "I<nr_unstable> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6016
#, no-wrap
msgid "I<nr_bounce> (since Linux 2.6.12)"
msgstr "I<nr_bounce> (начиная с Linux 2.6.12)"

#. type: TP
#: man-pages/man5/proc.5:6019
#, no-wrap
msgid "I<nr_vmscan_write> (since Linux 2.6.19)"
msgstr "I<nr_vmscan_write> (начиная с Linux 2.6.19)"

#. type: TP
#: man-pages/man5/proc.5:6022
#, no-wrap
msgid "I<nr_vmscan_immediate_reclaim> (since Linux 3.2)"
msgstr "I<nr_vmscan_immediate_reclaim> (начиная с Linux 3.2)"

#. type: TP
#: man-pages/man5/proc.5:6025
#, no-wrap
msgid "I<nr_writeback_temp> (since Linux 2.6.26)"
msgstr "I<nr_writeback_temp> (начиная с Linux 2.6.26)"

#. type: TP
#: man-pages/man5/proc.5:6028
#, no-wrap
msgid "I<nr_isolated_anon> (since Linux 2.6.32)"
msgstr "I<nr_isolated_anon> (начиная с Linux 2.6.32)"

#. type: TP
#: man-pages/man5/proc.5:6031
#, no-wrap
msgid "I<nr_isolated_file> (since Linux 2.6.32)"
msgstr "I<nr_isolated_file> (начиная с Linux 2.6.32)"

#. type: TP
#: man-pages/man5/proc.5:6034
#, no-wrap
msgid "I<nr_shmem> (since Linux 2.6.32)"
msgstr "I<nr_shmem> (начиная с Linux 2.6.32)"

#.  commit 4b02108ac1b3354a22b0d83c684797692efdc395
#. type: Plain text
#: man-pages/man5/proc.5:6039
msgid "Pages used by shmem and B<tmpfs>(5)."
msgstr "Страницы, используемые shmem и B<tmpfs>(5)."

#. type: TP
#: man-pages/man5/proc.5:6039
#, no-wrap
msgid "I<nr_dirtied> (since Linux 2.6.37)"
msgstr "I<nr_dirtied> (начиная с Linux 2.6.37)"

#. type: TP
#: man-pages/man5/proc.5:6042
#, no-wrap
msgid "I<nr_written> (since Linux 2.6.37)"
msgstr "I<nr_written> (начиная с Linux 2.6.37)"

#. type: TP
#: man-pages/man5/proc.5:6045
#, no-wrap
msgid "I<nr_pages_scanned> (since Linux 3.17)"
msgstr "I<nr_pages_scanned> (начиная с Linux 3.17)"

#. type: TP
#: man-pages/man5/proc.5:6048
#, no-wrap
msgid "I<numa_hit> (since Linux 2.6.18)"
msgstr "I<numa_hit> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:6053
#, no-wrap
msgid "I<numa_miss> (since Linux 2.6.18)"
msgstr "I<numa_miss> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:6058
#, no-wrap
msgid "I<numa_foreign> (since Linux 2.6.18)"
msgstr "I<numa_foreign> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:6063
#, no-wrap
msgid "I<numa_interleave> (since Linux 2.6.18)"
msgstr "I<numa_interleave> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:6068
#, no-wrap
msgid "I<numa_local> (since Linux 2.6.18)"
msgstr "I<numa_local> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:6073
#, no-wrap
msgid "I<numa_other> (since Linux 2.6.18)"
msgstr "I<numa_other> (начиная с Linux 2.6.18)"

#. type: TP
#: man-pages/man5/proc.5:6078
#, no-wrap
msgid "I<workingset_refault> (since Linux 3.15)"
msgstr "I<workingset_refault> (начиная с Linux 3.15)"

#. type: TP
#: man-pages/man5/proc.5:6083
#, no-wrap
msgid "I<workingset_activate> (since Linux 3.15)"
msgstr "I<workingset_activate> (начиная с Linux 3.15)"

#. type: TP
#: man-pages/man5/proc.5:6088
#, no-wrap
msgid "I<workingset_nodereclaim> (since Linux 3.15)"
msgstr "I<workingset_nodereclaim> (начиная с Linux 3.15)"

#. type: TP
#: man-pages/man5/proc.5:6093
#, no-wrap
msgid "I<nr_anon_transparent_hugepages> (since Linux 2.6.38)"
msgstr "I<nr_anon_transparent_hugepages> (начиная с Linux 2.6.38)"

#. type: TP
#: man-pages/man5/proc.5:6097
#, no-wrap
msgid "I<nr_free_cma> (since Linux 3.7)"
msgstr "I<nr_free_cma> (начиная с Linux 3.7)"

#.  commit d1ce749a0db12202b711d1aba1d29e823034648d
#.  Present only if the kernel was configured with
#.  .BR CONFIG_VM_EVENT_COUNTERS .
#. type: Plain text
#: man-pages/man5/proc.5:6103
msgid "Number of free CMA (Contiguous Memory Allocator) pages."
msgstr "Количество свободных страниц CMA (выделитель непрерывной памяти)."

#. type: TP
#: man-pages/man5/proc.5:6103
#, no-wrap
msgid "I<nr_dirty_threshold> (since Linux 2.6.37)"
msgstr "I<nr_dirty_threshold> (начиная с Linux 2.6.37)"

#. type: TP
#: man-pages/man5/proc.5:6108
#, no-wrap
msgid "I<nr_dirty_background_threshold> (since Linux 2.6.37)"
msgstr "I<nr_dirty_background_threshold> (начиная с Linux 2.6.37)"

#. type: TP
#: man-pages/man5/proc.5:6113
#, no-wrap
msgid "I<pgpgin> (since Linux 2.6.0)"
msgstr "I<pgpgin> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6117
#, no-wrap
msgid "I<pgpgout> (since Linux 2.6.0)"
msgstr "I<pgpgout> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6121
#, no-wrap
msgid "I<pswpin> (since Linux 2.6.0)"
msgstr "I<pswpin> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6125
#, no-wrap
msgid "I<pswpout> (since Linux 2.6.0)"
msgstr "I<pswpout> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6129
#, no-wrap
msgid "I<pgalloc_dma> (since Linux 2.6.5)"
msgstr "I<pgalloc_dma> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6134
#, no-wrap
msgid "I<pgalloc_dma32> (since Linux 2.6.16)"
msgstr "I<pgalloc_dma32> (начиная с Linux 2.6.16)"

#. type: TP
#: man-pages/man5/proc.5:6139
#, no-wrap
msgid "I<pgalloc_normal> (since Linux 2.6.5)"
msgstr "I<pgalloc_normal> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6143
#, no-wrap
msgid "I<pgalloc_high> (since Linux 2.6.5)"
msgstr "I<pgalloc_high> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6149
#, no-wrap
msgid "I<pgalloc_movable> (since Linux 2.6.23)"
msgstr "I<pgalloc_movable> (начиная с Linux 2.6.23)"

#. type: TP
#: man-pages/man5/proc.5:6154
#, no-wrap
msgid "I<pgfree> (since Linux 2.6.0)"
msgstr "I<pgfree> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6158
#, no-wrap
msgid "I<pgactivate> (since Linux 2.6.0)"
msgstr "I<pgactivate> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6162
#, no-wrap
msgid "I<pgdeactivate> (since Linux 2.6.0)"
msgstr "I<pgdeactivate> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6166
#, no-wrap
msgid "I<pgfault> (since Linux 2.6.0)"
msgstr "I<pgfault> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6170
#, no-wrap
msgid "I<pgmajfault> (since Linux 2.6.0)"
msgstr "I<pgmajfault> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6174
#, no-wrap
msgid "I<pgrefill_dma> (since Linux 2.6.5)"
msgstr "I<pgrefill_dma> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6179
#, no-wrap
msgid "I<pgrefill_dma32> (since Linux 2.6.16)"
msgstr "I<pgrefill_dma32> (начиная с Linux 2.6.16)"

#. type: TP
#: man-pages/man5/proc.5:6184
#, no-wrap
msgid "I<pgrefill_normal> (since Linux 2.6.5)"
msgstr "I<pgrefill_normal> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6188
#, no-wrap
msgid "I<pgrefill_high> (since Linux 2.6.5)"
msgstr "I<pgrefill_high> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6194
#, no-wrap
msgid "I<pgrefill_movable> (since Linux 2.6.23)"
msgstr "I<pgrefill_movable> (начиная с Linux 2.6.23)"

#. type: TP
#: man-pages/man5/proc.5:6206
#, no-wrap
msgid "I<pgsteal_kswapd_dma> (since Linux 3.4)"
msgstr "I<pgsteal_kswapd_dma> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6212
#, no-wrap
msgid "I<pgsteal_kswapd_dma32> (since Linux 3.4)"
msgstr "I<pgsteal_kswapd_dma32> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6218
#, no-wrap
msgid "I<pgsteal_kswapd_normal> (since Linux 3.4)"
msgstr "I<pgsteal_kswapd_normal> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6223
#, no-wrap
msgid "I<pgsteal_kswapd_high> (since Linux 3.4)"
msgstr "I<pgsteal_kswapd_high> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6230
#, no-wrap
msgid "I<pgsteal_kswapd_movable> (since Linux 3.4)"
msgstr "I<pgsteal_kswapd_movable> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6235
#, no-wrap
msgid "I<pgsteal_direct_dma>"
msgstr "I<pgsteal_direct_dma>"

#. type: TP
#: man-pages/man5/proc.5:6239
#, no-wrap
msgid "I<pgsteal_direct_dma32> (since Linux 3.4)"
msgstr "I<pgsteal_direct_dma32> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6244
#, no-wrap
msgid "I<pgsteal_direct_normal> (since Linux 3.4)"
msgstr "I<pgsteal_direct_normal> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6249
#, no-wrap
msgid "I<pgsteal_direct_high> (since Linux 3.4)"
msgstr "I<pgsteal_direct_high> (начиная с Linux 3.4)"

#. type: TP
#: man-pages/man5/proc.5:6256
#, no-wrap
msgid "I<pgsteal_direct_movable> (since Linux 2.6.23)"
msgstr "I<pgsteal_direct_movable> (начиная с Linux 2.6.23)"

#. type: TP
#: man-pages/man5/proc.5:6261
#, no-wrap
msgid "I<pgscan_kswapd_dma>"
msgstr "I<pgscan_kswapd_dma>"

#. type: TP
#: man-pages/man5/proc.5:6266
#, no-wrap
msgid "I<pgscan_kswapd_dma32> (since Linux 2.6.16)"
msgstr "I<pgscan_kswapd_dma32> (начиная с Linux 2.6.16)"

#. type: TP
#: man-pages/man5/proc.5:6271
#, no-wrap
msgid "I<pgscan_kswapd_normal> (since Linux 2.6.5)"
msgstr "I<pgscan_kswapd_normal> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6275
#, no-wrap
msgid "I<pgscan_kswapd_high>"
msgstr "I<pgscan_kswapd_high>"

#. type: TP
#: man-pages/man5/proc.5:6281
#, no-wrap
msgid "I<pgscan_kswapd_movable> (since Linux 2.6.23)"
msgstr "I<pgscan_kswapd_movable> (начиная с Linux 2.6.23)"

#. type: TP
#: man-pages/man5/proc.5:6286
#, no-wrap
msgid "I<pgscan_direct_dma>"
msgstr "I<pgscan_direct_dma>"

#. type: TP
#: man-pages/man5/proc.5:6290
#, no-wrap
msgid "I<pgscan_direct_dma32> (since Linux 2.6.16)"
msgstr "I<pgscan_direct_dma32> (начиная с Linux 2.6.16)"

#. type: TP
#: man-pages/man5/proc.5:6295
#, no-wrap
msgid "I<pgscan_direct_normal>"
msgstr "I<pgscan_direct_normal>"

#. type: TP
#: man-pages/man5/proc.5:6299
#, no-wrap
msgid "I<pgscan_direct_high>"
msgstr "I<pgscan_direct_high>"

#. type: TP
#: man-pages/man5/proc.5:6305
#, no-wrap
msgid "I<pgscan_direct_movable> (since Linux 2.6.23)"
msgstr "I<pgscan_direct_movable> (начиная с Linux 2.6.23)"

#. type: TP
#: man-pages/man5/proc.5:6310
#, no-wrap
msgid "I<pgscan_direct_throttle> (since Linux 3.6)"
msgstr "I<pgscan_direct_throttle> (начиная с Linux 3.6)"

#. type: TP
#: man-pages/man5/proc.5:6315
#, no-wrap
msgid "I<zone_reclaim_failed> (since linux 2.6.31)"
msgstr "I<zone_reclaim_failed> (начиная с Linux 2.6.31)"

#. type: TP
#: man-pages/man5/proc.5:6322
#, no-wrap
msgid "I<pginodesteal> (since linux 2.6.0)"
msgstr "I<pginodesteal> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6326
#, no-wrap
msgid "I<slabs_scanned> (since linux 2.6.5)"
msgstr "I<slabs_scanned> (начиная с Linux 2.6.5)"

#. type: TP
#: man-pages/man5/proc.5:6330
#, no-wrap
msgid "I<kswapd_inodesteal> (since linux 2.6.0)"
msgstr "I<kswapd_inodesteal> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6334
#, no-wrap
msgid "I<kswapd_low_wmark_hit_quickly> (since 2.6.33)"
msgstr "I<kswapd_low_wmark_hit_quickly> (начиная с Linux 2.6.33)"

#. type: TP
#: man-pages/man5/proc.5:6339
#, no-wrap
msgid "I<kswapd_high_wmark_hit_quickly> (since 2.6.33)"
msgstr "I<kswapd_high_wmark_hit_quickly> (начиная с Linux 2.6.33)"

#. type: TP
#: man-pages/man5/proc.5:6344
#, no-wrap
msgid "I<pageoutrun> (since Linux 2.6.0)"
msgstr "I<pageoutrun> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6348
#, no-wrap
msgid "I<allocstall> (since Linux 2.6.0)"
msgstr "I<allocstall> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6352
#, no-wrap
msgid "I<pgrotated> (since Linux 2.6.0)"
msgstr "I<pgrotated> (начиная с Linux 2.6.0)"

#. type: TP
#: man-pages/man5/proc.5:6356
#, no-wrap
msgid "I<drop_pagecache> (since Linux 3.15)"
msgstr "I<drop_pagecache> (начиная с Linux 3.15)"

#. type: TP
#: man-pages/man5/proc.5:6361
#, no-wrap
msgid "I<drop_slab> (since Linux 3.15)"
msgstr "I<drop_slab> (начиная с Linux 3.15)"

#. type: TP
#: man-pages/man5/proc.5:6366
#, no-wrap
msgid "I<numa_pte_updates> (since Linux 3.8)"
msgstr "I<numa_pte_updates> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6373
#, no-wrap
msgid "I<numa_huge_pte_updates> (since Linux 3.13)"
msgstr "I<numa_huge_pte_updates> (начиная с Linux 3.13)"

#. type: TP
#: man-pages/man5/proc.5:6380
#, no-wrap
msgid "I<numa_hint_faults> (since Linux 3.8)"
msgstr "I<numa_hint_faults> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6387
#, no-wrap
msgid "I<numa_hint_faults_local> (since Linux 3.8)"
msgstr "I<numa_hint_faults_local> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6394
#, no-wrap
msgid "I<numa_pages_migrated> (since Linux 3.8)"
msgstr "I<numa_pages_migrated> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6403
#, no-wrap
msgid "I<pgmigrate_success> (since Linux 3.8)"
msgstr "I<pgmigrate_success> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6410
#, no-wrap
msgid "I<pgmigrate_fail> (since Linux 3.8)"
msgstr "I<pgmigrate_fail> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6417
#, no-wrap
msgid "I<compact_migrate_scanned> (since Linux 3.8)"
msgstr "I<compact_migrate_scanned> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6426
#, no-wrap
msgid "I<compact_free_scanned> (since Linux 3.8)"
msgstr "I<compact_free_scanned> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6433
#, no-wrap
msgid "I<compact_isolated> (since Linux 3.8)"
msgstr "I<compact_isolated> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6440
#, no-wrap
msgid "I<compact_stall> (since Linux 2.6.35)"
msgstr "I<compact_stall> (начиная с Linux 2.6.35)"

#.  commit d8a8e1f0da3d29d7268b3300c96a059d63901b76
#.  Present only if the kernel was configured with
#.  .BR CONFIG_VM_EVENT_COUNTERS
#.  and
#.  .BR CONFIG_TRANSPARENT_HUGEPAGE .
#. type: Plain text
#: man-pages/man5/proc.5:6449 man-pages/man5/proc.5:6458
#: man-pages/man5/proc.5:6467 man-pages/man5/proc.5:6526
#: man-pages/man5/proc.5:6535 man-pages/man5/proc.5:6544
#: man-pages/man5/proc.5:6553 man-pages/man5/proc.5:6562
#: man-pages/man5/proc.5:6571 man-pages/man5/proc.5:6580
msgid ""
"See the kernel source file I<Documentation/admin-guide/mm/transhuge.rst>."
msgstr ""
"Смотрите файл исходного кода ядра I<Documentation/admin-guide/mm/transhuge."
"rst>."

#. type: TP
#: man-pages/man5/proc.5:6449
#, no-wrap
msgid "I<compact_fail> (since Linux 2.6.35)"
msgstr "I<compact_fail> (начиная с Linux 2.6.35)"

#. type: TP
#: man-pages/man5/proc.5:6458
#, no-wrap
msgid "I<compact_success> (since Linux 2.6.35)"
msgstr "I<compact_success> (начиная с Linux 2.6.35)"

#. type: TP
#: man-pages/man5/proc.5:6467
#, no-wrap
msgid "I<htlb_buddy_alloc_success> (since Linux 2.6.26)"
msgstr "I<htlb_buddy_alloc_success> (начиная с Linux 2.6.26)"

#. type: TP
#: man-pages/man5/proc.5:6474
#, no-wrap
msgid "I<htlb_buddy_alloc_fail> (since Linux 2.6.26)"
msgstr "I<htlb_buddy_alloc_fail> (начиная с Linux 2.6.26)"

#. type: TP
#: man-pages/man5/proc.5:6481
#, no-wrap
msgid "I<unevictable_pgs_culled> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_culled> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6486
#, no-wrap
msgid "I<unevictable_pgs_scanned> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_scanned> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6491
#, no-wrap
msgid "I<unevictable_pgs_rescued> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_rescued> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6496
#, no-wrap
msgid "I<unevictable_pgs_mlocked> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_mlocked> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6501
#, no-wrap
msgid "I<unevictable_pgs_munlocked> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_munlocked> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6506
#, no-wrap
msgid "I<unevictable_pgs_cleared> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_cleared> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6511
#, no-wrap
msgid "I<unevictable_pgs_stranded> (since Linux 2.6.28)"
msgstr "I<unevictable_pgs_stranded> (начиная с Linux 2.6.28)"

#. type: TP
#: man-pages/man5/proc.5:6517
#, no-wrap
msgid "I<thp_fault_alloc> (since Linux 2.6.39)"
msgstr "I<thp_fault_alloc> (начиная с Linux 2.6.39)"

#. type: TP
#: man-pages/man5/proc.5:6526
#, no-wrap
msgid "I<thp_fault_fallback> (since Linux 2.6.39)"
msgstr "I<thp_fault_fallback> (начиная с Linux 2.6.39)"

#. type: TP
#: man-pages/man5/proc.5:6535
#, no-wrap
msgid "I<thp_collapse_alloc> (since Linux 2.6.39)"
msgstr "I<thp_collapse_alloc> (начиная с Linux 2.6.39)"

#. type: TP
#: man-pages/man5/proc.5:6544
#, no-wrap
msgid "I<thp_collapse_alloc_failed> (since Linux 2.6.39)"
msgstr "I<thp_collapse_alloc_failed> (начиная с Linux 2.6.39)"

#. type: TP
#: man-pages/man5/proc.5:6553
#, no-wrap
msgid "I<thp_split> (since Linux 2.6.39)"
msgstr "I<thp_split> (начиная с Linux 2.6.39)"

#. type: TP
#: man-pages/man5/proc.5:6562
#, no-wrap
msgid "I<thp_zero_page_alloc> (since Linux 3.8)"
msgstr "I<thp_zero_page_alloc> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6571
#, no-wrap
msgid "I<thp_zero_page_alloc_failed> (since Linux 3.8)"
msgstr "I<thp_zero_page_alloc_failed> (начиная с Linux 3.8)"

#. type: TP
#: man-pages/man5/proc.5:6580
#, no-wrap
msgid "I<balloon_inflate> (since Linux 3.18)"
msgstr "I<balloon_inflate> (начиная с Linux 3.18)"

#. type: TP
#: man-pages/man5/proc.5:6587
#, no-wrap
msgid "I<balloon_deflate> (since Linux 3.18)"
msgstr "I<balloon_deflate> (начиная с Linux 3.18)"

#. type: TP
#: man-pages/man5/proc.5:6594
#, no-wrap
msgid "I<balloon_migrate> (since Linux 3.18)"
msgstr "I<balloon_migrate> (начиная с Linux 3.18)"

#. type: TP
#: man-pages/man5/proc.5:6602
#, no-wrap
msgid "I<nr_tlb_remote_flush> (since Linux 3.12)"
msgstr "I<nr_tlb_remote_flush> (начиная с Linux 3.12)"

#. type: TP
#: man-pages/man5/proc.5:6609
#, no-wrap
msgid "I<nr_tlb_remote_flush_received> (since Linux 3.12)"
msgstr "I<nr_tlb_remote_flush_received> (начиная с Linux 3.12)"

#. type: TP
#: man-pages/man5/proc.5:6616
#, no-wrap
msgid "I<nr_tlb_local_flush_all> (since Linux 3.12)"
msgstr "I<nr_tlb_local_flush_all> (начиная с Linux 3.12)"

#. type: TP
#: man-pages/man5/proc.5:6621
#, no-wrap
msgid "I<nr_tlb_local_flush_one> (since Linux 3.12)"
msgstr "I<nr_tlb_local_flush_one> (начиная с Linux 3.12)"

#. type: TP
#: man-pages/man5/proc.5:6626
#, no-wrap
msgid "I<vmacache_find_calls> (since Linux 3.16)"
msgstr "I<vmacache_find_calls> (начиная с Linux 3.16)"

#. type: TP
#: man-pages/man5/proc.5:6631
#, no-wrap
msgid "I<vmacache_find_hits> (since Linux 3.16)"
msgstr "I<vmacache_find_hits> (начиная с Linux 3.16)"

#. type: TP
#: man-pages/man5/proc.5:6636
#, no-wrap
msgid "I<vmacache_full_flushes> (since Linux 3.19)"
msgstr "I<vmacache_full_flushes> (начиная с Linux 3.19)"

#. type: TP
#: man-pages/man5/proc.5:6642
#, no-wrap
msgid "I</proc/zoneinfo> (since Linux 2.6.13)"
msgstr "I</proc/zoneinfo> (начиная с Linux 2.6.13)"

#.  FIXME more should be said about /proc/zoneinfo
#. type: Plain text
#: man-pages/man5/proc.5:6647
msgid ""
"This file display information about memory zones.  This is useful for "
"analyzing virtual memory behavior."
msgstr ""
"Этот файл содержит информацию о зонах памяти. Он полезен при анализе "
"поведения виртуальной памяти."

#. type: Plain text
#: man-pages/man5/proc.5:6653
msgid ""
"Many files contain strings (e.g., the environment and command line)  that "
"are in the internal format, with subfields terminated by null bytes (\\(aq"
"\\e0\\(aq).  When inspecting such files, you may find that the results are "
"more readable if you use a command of the following form to display them:"
msgstr ""
"Многие файлы со строками (например, окружение и командная строка), хранят "
"данные во внутреннем формате с полями, завершающимися нулевыми байтами (\\(aq"
"\\e0\\(aq). При просмотре таких файлов данные будут более читаемыми, если "
"воспользоваться следующей командой вывода."

#. type: Plain text
#: man-pages/man5/proc.5:6657
#, no-wrap
msgid "$B< cat >I<file>B< | tr \\(aq\\e000\\(aq \\(aq\\en\\(aq>\n"
msgstr "$B< cat >I<file>B< | tr \\(aq\\e000\\(aq \\(aq\\en\\(aq>\n"

#.  .SH ACKNOWLEDGEMENTS
#.  The material on /proc/sys/fs and /proc/sys/kernel is closely based on
#.  kernel source documentation files written by Rik van Riel.
#. type: Plain text
#: man-pages/man5/proc.5:6665
msgid ""
"This manual page is incomplete, possibly inaccurate, and is the kind of "
"thing that needs to be updated very often."
msgstr ""
"Данная справочная страница неполна, в ней могут быть неточности и является "
"одной из страниц, которую требуется обновлять очень часто."

#. type: Plain text
#: man-pages/man5/proc.5:6695
msgid ""
"B<cat>(1), B<dmesg>(1), B<find>(1), B<free>(1), B<htop>(1), B<init>(1), "
"B<ps>(1), B<pstree>(1), B<tr>(1), B<uptime>(1), B<chroot>(2), B<mmap>(2), "
"B<readlink>(2), B<syslog>(2), B<slabinfo>(5), B<sysfs>(5), B<hier>(7), "
"B<namespaces>(7), B<time>(7), B<arp>(8), B<hdparm>(8), B<ifconfig>(8), "
"B<lsmod>(8), B<lspci>(8), B<mount>(8), B<netstat>(8), B<procinfo>(8), "
"B<route>(8), B<sysctl>(8)"
msgstr ""
"B<cat>(1), B<dmesg>(1), B<find>(1), B<free>(1), B<htop>(1), B<init>(1), "
"B<ps>(1), B<pstree>(1), B<tr>(1), B<uptime>(1), B<chroot>(2), B<mmap>(2), "
"B<readlink>(2), B<syslog>(2), B<slabinfo>(5), B<sysfs>(5), B<hier>(7), "
"B<namespaces>(7), B<time>(7), B<arp>(8), B<hdparm>(8), B<ifconfig>(8), "
"B<lsmod>(8), B<lspci>(8), B<mount>(8), B<netstat>(8), B<procinfo>(8), "
"B<route>(8), B<sysctl>(8)"

#. type: Plain text
#: man-pages/man5/proc.5:6702
msgid ""
"The Linux kernel source files: I<Documentation/filesystems/proc.txt>, "
"I<Documentation/sysctl/fs.txt>, I<Documentation/sysctl/kernel.txt>, "
"I<Documentation/sysctl/net.txt>, and I<Documentation/sysctl/vm.txt>."
msgstr ""
"Файлы исходного кода ядра Linux: I<Documentation/filesystems/proc.txt>, "
"I<Documentation/sysctl/fs.txt>, I<Documentation/sysctl/kernel.txt>, "
"I<Documentation/sysctl/net.txt> и I<Documentation/sysctl/vm.txt>."

#. type: TH
#: man-pages/man5/passwd.5:30
#, no-wrap
msgid "PASSWD"
msgstr "PASSWD"

#. type: Plain text
#: man-pages/man5/passwd.5:33
msgid "passwd - password file"
msgstr "passwd - файл паролей"

#. type: Plain text
#: man-pages/man5/passwd.5:41
msgid ""
"The I</etc/passwd> file is a text file that describes user login accounts "
"for the system.  It should have read permission allowed for all users (many "
"utilities, like B<ls>(1)  use it to map user IDs to usernames), but write "
"access only for the superuser."
msgstr ""
"В текстовом файле I</etc/passwd> содержится список учётных записей "
"пользователей в системе. Файл должен быть доступен для чтения всем "
"пользователям (многие утилиты, такие как B<ls>(1), используют его, чтобы "
"преобразовывать идентификаторы пользователей в их имена), но доступ на "
"запись должен предоставляться только суперпользователю."

#. type: Plain text
#: man-pages/man5/passwd.5:53
msgid ""
"In the good old days there was no great problem with this general read "
"permission.  Everybody could read the encrypted passwords, but the hardware "
"was too slow to crack a well-chosen password, and moreover the basic "
"assumption used to be that of a friendly user-community.  These days many "
"people run some version of the shadow password suite, where I</etc/passwd> "
"has an \\(aqx\\(aq character in the password field, and the encrypted "
"passwords are in I</etc/shadow>, which is readable by the superuser only."
msgstr ""
"В старые добрые времена не существовало большой проблемы, связанной с "
"доступностью этого файла на чтение для всех. Любой мог прочитать "
"зашифрованные пароли, но мощности компьютеров не хватало для подбора "
"грамотно выбранных паролей, а кроме того, наивно предполагалось, что сеть "
"используется дружественным сообществом пользователей. В наши дни, многие "
"пользователи стали использовать механизм теневых паролей, где файл I</etc/"
"passwd> содержит \\(aqx\\(aq в поле пароля, а зашифрованные пароли хранятся "
"в файле I</etc/shadow>, который доступен на чтение только суперпользователю."

#. type: Plain text
#: man-pages/man5/passwd.5:62
msgid ""
"If the encrypted password, whether in I</etc/passwd> or in I</etc/shadow>, "
"is an empty string, login is allowed without even asking for a password.  "
"Note that this functionality may be intentionally disabled in applications, "
"or configurable (for example using the \"nullok\" or \"nonull\" arguments to "
"pam_unix.so)."
msgstr ""
"Если значение шифрованного пароля, в I</etc/passwd> или I</etc/shadow>, "
"равно пустой строке, то вход будет разрешён без запроса пароля. Заметим, что "
"данной свойство может быть специально отключено в приложениях или может "
"настраиваться (например, с помощью аргументов «nullok» или «nonull»модуля "
"pam_unix.so)."

#. type: Plain text
#: man-pages/man5/passwd.5:67
msgid ""
"If the encrypted password in I</etc/passwd> is \"I<*NP*>\" (without the "
"quotes), the shadow record should be obtained from an NIS+ server."
msgstr ""
"Если значение шифрованного пароля в I</etc/passwd> равно «I<*NP*>» (без "
"кавычек), то теневая запись запрашивается с сервера NIS+."

#. type: Plain text
#: man-pages/man5/passwd.5:73
msgid ""
"Regardless of whether shadow passwords are used, many system administrators "
"use an asterisk (*) in the encrypted password field to make sure that this "
"user can not authenticate themself using a password.  (But see NOTES below.)"
msgstr ""
"Вне зависимости от того, применяется ли механизм теневых паролей или нет, "
"многие системные администраторы ставят звёздочку (*) в поле зашифрованного "
"пароля, чтобы быть уверенными, что данный пользователь не пройдёт "
"аутентификацию, используя какой-либо пароль (но смотри раздел ЗАМЕЧАНИЯ "
"далее)."

#. type: Plain text
#: man-pages/man5/passwd.5:78
msgid ""
"If you create a new login, first put an asterisk (*) in the password field, "
"then use B<passwd>(1)  to set it."
msgstr ""
"Если вы создаёте новую учётную запись, сперва в поле пароля помещается "
"звёздочка (*), а затем с помощью команды B<passwd>(1) вы можете задать "
"пароль."

#. type: Plain text
#: man-pages/man5/passwd.5:81
msgid ""
"Each line of the file describes a single user, and contains seven colon-"
"separated fields:"
msgstr ""
"Каждая строка файла состоит из семи полей, разделённых двоеточием и "
"описывает одного пользователя:"

#. type: Plain text
#: man-pages/man5/passwd.5:85
#, no-wrap
msgid "name:password:UID:GID:GECOS:directory:shell\n"
msgstr "name:password:UID:GID:GECOS:directory:shell\n"

#. type: Plain text
#: man-pages/man5/passwd.5:89
msgid "The field are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man5/passwd.5:89
#, no-wrap
msgid "I<name>"
msgstr "I<имя>"

#. type: Plain text
#: man-pages/man5/passwd.5:93
msgid "This is the user's login name.  It should not contain capital letters."
msgstr ""
"Имя пользователя в системе. Оно не должно содержать букв в верхнем регистре."

#. type: TP
#: man-pages/man5/passwd.5:93
#, no-wrap
msgid "I<password>"
msgstr "I<пароль>"

#. type: Plain text
#: man-pages/man5/passwd.5:100
msgid ""
"This is either the encrypted user password, an asterisk (*), or the letter "
"\\(aqx\\(aq.  (See B<pwconv>(8)  for an explanation of \\(aqx\\(aq.)"
msgstr ""
"Может содержать шифрованный пароль пользователя, звёздочку (*) или букву "
"\\(aqx\\(aq (про \\(aqx\\(aq см. в B<pwconv>(8))."

#. type: TP
#: man-pages/man5/passwd.5:100
#, no-wrap
msgid "I<UID>"
msgstr "I<UID>"

#. type: Plain text
#: man-pages/man5/passwd.5:105
msgid "The privileged I<root> login account (superuser) has the user ID 0."
msgstr ""
"Привилегированная учётная запись I<root> (суперпользователь) имеет "
"идентификатор пользователя равный 0."

#. type: TP
#: man-pages/man5/passwd.5:105
#, no-wrap
msgid "I<GID>"
msgstr "I<GID>"

#. type: Plain text
#: man-pages/man5/passwd.5:110
msgid ""
"This is the numeric primary group ID for this user.  (Additional groups for "
"the user are defined in the system group file; see B<group>(5))."
msgstr ""
"Числовой идентификатор первичной группы (GID) пользователя. Дополнительные "
"группы пользователя могут быть заданы в файле групп системы; смотрите "
"B<group>(5)."

#. type: TP
#: man-pages/man5/passwd.5:110
#, no-wrap
msgid "I<GECOS>"
msgstr "I<GECOS>"

#. type: Plain text
#: man-pages/man5/passwd.5:118
msgid ""
"This field (sometimes called the \"comment field\")  is optional and used "
"only for informational purposes.  Usually, it contains the full username.  "
"Some programs (for example, B<finger>(1))  display information from this "
"field."
msgstr ""
"Данное поле является необязательным и используется только для информационных "
"целей. Обычно, оно содержит полное имя пользователя. Некоторые программы "
"(например, B<finger>(1)) показывают значение этого поля."

#. type: Plain text
#: man-pages/man5/passwd.5:127
msgid ""
"GECOS stands for \"General Electric Comprehensive Operating System\", which "
"was renamed to GCOS when GE's large systems division was sold to Honeywell.  "
"Dennis Ritchie has reported: \"Sometimes we sent printer output or batch "
"jobs to the GCOS machine.  The gcos field in the password file was a place "
"to stash the information for the $IDENTcard.  Not elegant.\""
msgstr ""
"GECOS — это аббревиатура от General Electric Comprehensive Operating System, "
"которая была переименована в GCOS, когда подразделение больших систем "
"компании GE было продано компании Honeywell. Денис Ритчи писал: «Иногда мы "
"направляем вывод печати или пачку заданий на GCOS машину. Поле gcos в файле "
"паролей было местом, где хранилась информация для $IDENTcard. Не элегантно.»"

#. type: TP
#: man-pages/man5/passwd.5:127
#, no-wrap
msgid "I<directory>"
msgstr "I<каталог>"

#. type: Plain text
#: man-pages/man5/passwd.5:134
msgid ""
"This is the user's home directory: the initial directory where the user is "
"placed after logging in.  The value in this field is used to set the B<HOME> "
"environment variable."
msgstr ""
"Домашний каталог пользователя: начальный каталог, куда попадает пользователь "
"после входа в систему. Значение данного поля используется для настройки "
"переменной окружения B<HOME>."

#. type: TP
#: man-pages/man5/passwd.5:134
#, no-wrap
msgid "I<shell>"
msgstr "I<оболочка>"

#. type: Plain text
#: man-pages/man5/passwd.5:144
msgid ""
"This is the program to run at login (if empty, use I</bin/sh>).  If set to a "
"nonexistent executable, the user will be unable to login through "
"B<login>(1).  The value in this field is used to set the B<SHELL> "
"environment variable."
msgstr ""
"Это программа, которая запускается после входа в систему (если это поле "
"пустое, то используется I</bin/sh>). Если в поле указан несуществующий "
"исполняемый файл, то пользователь не сможет войти в систему с помощью "
"B<login>(1). Значение данного поля используется для настройки переменной "
"окружения B<SHELL>."

#. type: Plain text
#: man-pages/man5/passwd.5:146
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: man-pages/man5/passwd.5:150
msgid ""
"If you want to create user groups, there must be an entry in I</etc/group>, "
"or no group will exist."
msgstr ""
"Если вы хотите создать группу пользователя, то такая группа должна "
"существовать в файле I</etc/group>, иначе группа не будет существовать."

#. type: Plain text
#: man-pages/man5/passwd.5:164
msgid ""
"If the encrypted password is set to an asterisk (*), the user will be unable "
"to login using B<login>(1), but may still login using B<rlogin>(1), run "
"existing processes and initiate new ones through B<rsh>(1), B<cron>(8), "
"B<at>(1), or mail filters, etc.  Trying to lock an account by simply "
"changing the shell field yields the same result and additionally allows the "
"use of B<su>(1)."
msgstr ""
"Если вместо зашифрованного пароля установлена звёздочка (*), то пользователь "
"не сможет войти в систему, используя команду B<login>(1), но сможет войти в "
"систему, используя B<rlogin>(1), запустить существующие процессы и "
"инициировать новые, используя B<rsh>(1), B<cron>(8), B<at>(1) или почтовые "
"фильтры и т.д. Попытка заблокировать учётную запись простым изменением поля "
"shell, даст тот же результат и в дополнении разрешит использование B<su>(1)."

#. type: Plain text
#: man-pages/man5/passwd.5:175
msgid ""
"B<chfn>(1), B<chsh>(1), B<login>(1), B<passwd>(1), B<su>(1), B<crypt>(3), "
"B<getpwent>(3), B<getpwnam>(3), B<group>(5), B<shadow>(5), B<vipw>(8)"
msgstr ""
"B<chfn>(1), B<chsh>(1), B<login>(1), B<passwd>(1), B<su>(1), B<crypt>(3), "
"B<getpwent>(3), B<getpwnam>(3), B<group>(5), B<shadow>(5), B<vipw>(8)"

#. type: TH
#: man-pages/man3/pthread_detach.3:26
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr "PTHREAD_DETACH"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:29
msgid "pthread_detach - detach a thread"
msgstr "pthread_detach - отсоединяет нить"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:32
#, no-wrap
msgid "B<#include E<lt>pthread.hE<gt>>\n"
msgstr "B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:34
#, no-wrap
msgid "B<int pthread_detach(pthread_t >I<thread>B<);>\n"
msgstr "B<int pthread_detach(pthread_t >I<thread>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:37
msgid "Compile and link with I<-pthread>."
msgstr "Компилируется и компонуется вместе с I<-pthread>."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:46
msgid ""
"The B<pthread_detach>()  function marks the thread identified by I<thread> "
"as detached.  When a detached thread terminates, its resources are "
"automatically released back to the system without the need for another "
"thread to join with the terminated thread."
msgstr ""
"Функция B<pthread_detach>() помечает нить, указанную I<thread>, как "
"отсоединённую. Когда отсоединённая нить завершается, её ресурсы "
"автоматически отдаются обратно системе и не нужно объединять другую нить с "
"завершившей работу."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:49
msgid ""
"Attempting to detach an already detached thread results in unspecified "
"behavior."
msgstr ""
"Попытка отсоединить уже отсоединённую нить приводит к непредсказуемым "
"последствиям."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:54
msgid ""
"On success, B<pthread_detach>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"При успешном выполнении B<pthread_detach>() возвращается 0; при ошибке "
"возвращается номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:59
msgid "I<thread> is not a joinable thread."
msgstr "Нить I<thread> не является присоединяемой."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:64
msgid "No thread with the ID I<thread> could be found."
msgstr "Нить с идентификатором I<thread> не найдена."

#. type: SH
#: man-pages/man3/pthread_detach.3:64
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:67
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man3/pthread_detach.3:71
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man3/pthread_detach.3:71
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man3/pthread_detach.3:71
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man3/pthread_detach.3:74
#, no-wrap
msgid "B<pthread_detach>()"
msgstr "B<pthread_detach>()"

#. type: tbl table
#: man-pages/man3/pthread_detach.3:74
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man3/pthread_detach.3:74
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:83
msgid ""
"Once a thread has been detached, it can't be joined with B<pthread_join>(3)  "
"or be made joinable again."
msgstr ""
"После отсоединения нить её нельзя обратно присоединить с помощью "
"B<pthread_join>(3) или снова сделать присоединяемой."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:90
msgid ""
"A new thread can be created in a detached state using "
"B<pthread_attr_setdetachstate>(3)  to set the detached attribute of the "
"I<attr> argument of B<pthread_create>(3)."
msgstr ""
"Новую нить можно создать в отсоединённом состоянии с помощью "
"B<pthread_attr_setdetachstate>(3), установив атрибут отсоединения у "
"аргумента I<attr> при B<pthread_create>(3)."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:97
msgid ""
"The detached attribute merely determines the behavior of the system when the "
"thread terminates; it does not prevent the thread from being terminated if "
"the process terminates using B<exit>(3)  (or equivalently, if the main "
"thread returns)."
msgstr ""
"Атрибут отсоединения просто определяет поведение системы при завершении "
"нити; он не препятствует завершению нити при завершении работы процесс с "
"помощью B<exit>(3) (или эквивалента, если завершается основная нить)."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:106
msgid ""
"Either B<pthread_join>(3)  or B<pthread_detach>()  should be called for each "
"thread that an application creates, so that system resources for the thread "
"can be released.  (But note that the resources of any threads for which one "
"of these actions has not been done will be freed when the process "
"terminates.)"
msgstr ""
"Функция B<pthread_join>(3) или B<pthread_detach>() должна вызываться для "
"каждой нити, созданной приложением, для того, чтобы можно было освободить "
"системные ресурсы нити (но, заметим, что ресурсы всех нитей, для которых "
"выполняется одно из этих действий, освобождаются при завершении процесса)."

#. type: Plain text
#: man-pages/man3/pthread_detach.3:108
msgid "The following statement detaches the calling thread:"
msgstr "Следующее выражение отсоединяет вызвавшую нить:"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:110
#, no-wrap
msgid "    pthread_detach(pthread_self());\n"
msgstr "    pthread_detach(pthread_self());\n"

#. type: Plain text
#: man-pages/man3/pthread_detach.3:116
msgid ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), "
"B<pthread_create>(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), "
"B<pthread_create>(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_spin_lock.3:25
#, no-wrap
msgid "PTHREAD_SPIN_LOCK"
msgstr "PTHREAD_SPIN_LOCK"

#. type: TH
#: man-pages/man3/pthread_spin_lock.3:25
#, no-wrap
msgid "2017-09-30"
msgstr "2017-09-30"

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:29
msgid ""
"pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock - lock and "
"unlock a spin lock"
msgstr ""
"pthread_spin_lock, pthread_spin_trylock, pthread_spin_unlock - блокирует и "
"разблокирует блокировку циклически (spin lock)"

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:36
#, no-wrap
msgid ""
"B<int pthread_spin_lock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_trylock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_unlock(pthread_spinlock_t *>I<lock>B<);>\n"
msgstr ""
"B<int pthread_spin_lock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_trylock(pthread_spinlock_t *>I<lock>B<);>\n"
"B<int pthread_spin_unlock(pthread_spinlock_t *>I<lock>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:47
msgid "B<pthread_spin_lock>(), B<pthread_spin_trylock>():"
msgstr "B<pthread_spin_lock>(), B<pthread_spin_trylock>():"

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:51
msgid "_POSIX_C_SOURCE E<gt>= 200112L"
msgstr "_POSIX_C_SOURCE E<gt>= 200112L"

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:63
msgid ""
"The B<pthread_spin_lock>()  function locks the spin lock referred to by "
"I<lock>.  If the spin lock is currently unlocked, the calling thread "
"acquires the lock immediately.  If the spin lock is currently locked by "
"another thread, the calling thread spins, testing the lock until it becomes "
"available, at which point the calling thread acquires the lock."
msgstr ""
"Функция B<pthread_spin_lock>() блокирует циклическую блокировку (spin lock), "
"на которую указывает I<lock>. Если циклическая блокировка разблокирована, то "
"вызывающая нить сразу же захватывает блокировку. Если циклическая блокировка "
"заблокирована, то проверка блокировки продолжается до тех пор, пока она не "
"освободится, и в этот момент вызывающая нить захватит блокировку."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:70
msgid ""
"Calling B<pthread_spin_lock>()  on a lock that is already held by the caller "
"or a lock that has not been initialized with B<pthread_spin_init>(3)  "
"results in undefined behavior."
msgstr ""
"Вызов B<pthread_spin_lock>() для блокировки, которая уже захвачена "
"вызывающим или не была инициализирована с помощью B<pthread_spin_init>(3), "
"приводит к непредсказуемому поведению."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:80
msgid ""
"The B<pthread_spin_trylock>()  function is like B<pthread_spin_lock>(), "
"except that if the spin lock referred to by I<lock> is currently locked, "
"then, instead of spinning, the call returns immediately with the error "
"B<EBUSY>."
msgstr ""
"Функция B<pthread_spin_trylock>() подобна B<pthread_spin_lock>(), за "
"исключением того, что если циклическая блокировка, на которую указывает "
"I<lock> заблокирована, то вместо зацикливания вызов завершается с ошибкой "
"B<EBUSY>."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:87
msgid ""
"The B<pthread_spin_unlock>()  function unlocks the spin lock referred to "
"I<lock>.  If any threads are spinning on the lock, one of those threads will "
"then acquire the lock."
msgstr ""
"Функция B<pthread_spin_unlock>() разблокирует циклическую блокировку, на "
"которую указывает I<lock>. Если какая-то нить зациклена в ожидании "
"блокировки, то она захватит блокировку."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:91
msgid ""
"Calling B<pthread_spin_unlock>()  on a lock that is not held by the caller "
"results in undefined behavior."
msgstr ""
"Вызов B<pthread_spin_unlock>() для блокировки, которая не была захвачена "
"вызывающим, приводит к непредсказуемому поведению."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:94
msgid ""
"On success, these functions return zero.  On failure, they return an error "
"number."
msgstr ""
"При успешном выполнении эти функции возвращают ноль. При ошибке возвращается "
"номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:97
msgid "B<pthread_spin_lock>()  may fail with the following errors:"
msgstr ""
"Функция B<pthread_spin_lock>() может завершаться со следующими ошибками:"

#. type: TP
#: man-pages/man3/pthread_spin_lock.3:97
#, no-wrap
msgid "B<EDEADLOCK>"
msgstr "B<EDEADLOCK>"

#.  Not detected in glibc
#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:101
msgid "The system detected a deadlock condition."
msgstr "Система обнаружила условие взаимной блокировки."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:104
msgid "B<pthread_spin_trylock>()  fails with the following errors:"
msgstr ""
"Функция B<pthread_spin_trylock>() может завершаться со следующими ошибками:"

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:107
msgid "The spin lock is currently locked by another thread."
msgstr "Циклическая блокировка уже заблокирована другой нитью."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:109
msgid "These functions first appeared in glibc in version 2.2."
msgstr "Эти функции впервые появились в glibc 2.2."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:111
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:114
msgid ""
"Applying any of the functions described on this page to an uninitialized "
"spin lock results in undefined behavior."
msgstr ""
"Применение любой из описанных в этой странице функций к не "
"инициализированной циклической блокировке приведёт к непредсказуемому "
"поведению."

#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:117
msgid "Carefully read NOTES in B<pthread_spin_init>(3)."
msgstr "Внимательно прочитайте ЗАМЕЧАНИЯ в B<pthread_spin_init>(3)."

#.  FIXME . .BR pthread_mutex_lock (3),
#. type: Plain text
#: man-pages/man3/pthread_spin_lock.3:123
msgid "B<pthread_spin_destroy>(3), B<pthread_spin_init>(3), B<pthreads>(7)"
msgstr "B<pthread_spin_destroy>(3), B<pthread_spin_init>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_mutexattr_setrobust.3:26
#, no-wrap
msgid "PTHREAD_MUTEXATTR_SETROBUST"
msgstr "PTHREAD_MUTEXATTR_SETROBUST"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:30
msgid ""
"pthread_mutexattr_getrobust, pthread_mutexattr_setrobust - get and set the "
"robustness attribute of a mutex attributes object"
msgstr ""
"pthread_mutexattr_getrobust, pthread_mutexattr_setrobust - возвращает и "
"изменяет атрибут устойчивости в объекте мьютексных атрибутов"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:38
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int >I<robustness>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_getrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                int >I<robustness>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:49
msgid "B<pthread_mutexattr_getrobust>(), B<pthread_mutexattr_setrobust>():"
msgstr "B<pthread_mutexattr_getrobust>(), B<pthread_mutexattr_setrobust>():"

#.  FIXME .
#.  But see https://sourceware.org/bugzilla/show_bug.cgi?id=22125
#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:55
msgid "_POSIX_C_SOURCE E<gt>= 200809L"
msgstr "_POSIX_C_SOURCE E<gt>= 200809L"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:72
msgid ""
"The B<pthread_mutexattr_getrobust>()  function places the value of the "
"robustness attribute of the mutex attributes object referred to by I<attr> "
"in I<*robustness>.  The B<pthread_mutexattr_setrobust>()  function sets the "
"value of the robustness attribute of the mutex attributes object referred to "
"by I<attr> to the value specified in I<*robustness>."
msgstr ""
"Функция B<pthread_mutexattr_getrobust>() помещает значение атрибута "
"устойчивости (robustness) из объекта мьютексных атрибутов, на который "
"указывает I<attr>, в I<*robustness>. Функция "
"B<pthread_mutexattr_setrobust>() изменяет значение атрибута устойчивости в "
"объекте мьютексных атрибутов, на который указывает I<attr>, на значение, "
"заданное в I<*robustness>."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:77
msgid ""
"The robustness attribute specifies the behavior of the mutex when the owning "
"thread dies without unlocking the mutex.  The following values are valid for "
"I<robustness>:"
msgstr ""
"Атрибут устойчивости определяет поведение мьютекса после того как владеющая "
"нить завершает работу, но не разблокировала мьютекс. Для I<robustness> "
"возможны следующие значения:"

#. type: TP
#: man-pages/man3/pthread_mutexattr_setrobust.3:77
#, no-wrap
msgid "B<PTHREAD_MUTEX_STALLED>"
msgstr "B<PTHREAD_MUTEX_STALLED>"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:86
msgid ""
"This is the default value for a mutex attributes object.  If a mutex is "
"initialized with the B<PTHREAD_MUTEX_STALLED> attribute and its owner dies "
"without unlocking it, the mutex remains locked afterwards and any future "
"attempts to call B<pthread_mutex_lock>(3)  on the mutex will block "
"indefinitely."
msgstr ""
"Значение по умолчанию для объекта мьютексных атрибутов. Если мьютекс "
"инициализирован с атрибутом B<PTHREAD_MUTEX_STALLED> и его владелец "
"завершает работу без его разблокировки, то после этого мьютекс остаётся "
"заблокированным и все последующие попытки вызова B<pthread_mutex_lock>(3) "
"для этого мьютекса будут заблокированы навсегда."

#. type: TP
#: man-pages/man3/pthread_mutexattr_setrobust.3:86
#, no-wrap
msgid "B<PTHREAD_MUTEX_ROBUST>"
msgstr "B<PTHREAD_MUTEX_ROBUST>"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:102
msgid ""
"If a mutex is initialized with the B<PTHREAD_MUTEX_ROBUST> attribute and its "
"owner dies without unlocking it, any future attempts to call "
"B<pthread_mutex_lock>(3)  on this mutex will succeed and return "
"B<EOWNERDEAD> to indicate that the original owner no longer exists and the "
"mutex is in an inconsistent state.  Usually after B<EOWNERDEAD> is returned, "
"the next owner should call B<pthread_mutex_consistent>(3)  on the acquired "
"mutex to make it consistent again before using it any further."
msgstr ""
"Если мьютекса инициализирован с атрибутом B<PTHREAD_MUTEX_ROBUST> и и его "
"владелец завершает работу без его разблокировки,то все последующие попытки "
"вызова B<pthread_mutex_lock>(3) для этого мьютекса будут успешно выполнены "
"возвращается B<EOWNERDEAD>, чтобы показать, что первоначальный владелец не "
"существует и мьютекс находится в неопределенном состоянии. Обычно, после "
"возврата B<EOWNERDEAD> перед началом использования следующий владелец должен "
"вызвать B<pthread_mutex_consistent>(3) над полученным мьютексом, чтобы снова "
"сделать его согласованным."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:112
msgid ""
"If the next owner unlocks the mutex using B<pthread_mutex_unlock>(3)  before "
"making it consistent, the mutex will be permanently unusable and any "
"subsequent attempts to lock it using B<pthread_mutex_lock>(3)  will fail "
"with the error B<ENOTRECOVERABLE>.  The only permitted operation on such a "
"mutex is B<pthread_mutex_destroy>(3)."
msgstr ""
"Если следующий владелец разблокирует мьютекс с помощью "
"B<pthread_mutex_unlock>(3) до того, как сделать его согласованным, мьютекс "
"станет необратимо неработоспособен и последующие попытки заблокировать его с "
"помощью B<pthread_mutex_lock>(3) будут завершаться ошибкой "
"B<ENOTRECOVERABLE>. Для такого мьютекса доступна только одна операция — "
"B<pthread_mutex_destroy>(3)."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:119
msgid ""
"If the next owner terminates before calling B<pthread_mutex_consistent>(3), "
"further B<pthread_mutex_lock>(3)  operations on this mutex will still return "
"B<EOWNERDEAD>."
msgstr ""
"Если следующий владелец завершит работу до вызова "
"B<pthread_mutex_consistent>(3), то последующие операций "
"B<pthread_mutex_lock>(3) с этим мьютексом будут по прежнему возвращать "
"B<EOWNERDEAD>."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:129
msgid ""
"Note that the I<attr> argument of B<pthread_mutexattr_getrobust>()  and "
"B<pthread_mutexattr_setrobust>()  should refer to a mutex attributes object "
"that was initialized by B<pthread_mutexattr_init>(3), otherwise the behavior "
"is undefined."
msgstr ""
"Заметим, что аргумент I<attr> у B<pthread_mutexattr_getrobust>() и "
"B<pthread_mutexattr_setrobust>() должен указывать на объект мьютексных "
"атрибутов, который был инициализирован B<pthread_mutexattr_init>(3), в "
"противном случае поведение не определено."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:132
msgid ""
"On success, these functions return 0.  On error, they return a positive "
"error number."
msgstr ""
"При успешном выполнении эти функции возвращают 0. При ошибке возвращается "
"положительный номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:136
msgid ""
"In the glibc implementation, B<pthread_mutexattr_getrobust>()  always return "
"zero."
msgstr ""
"В реализации glibc функция B<pthread_mutexattr_getrobust>() всегда "
"возвращает ноль."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:145
msgid ""
"A value other than B<PTHREAD_MUTEX_STALLED> or B<PTHREAD_MUTEX_ROBUST> was "
"passed to B<pthread_mutexattr_setrobust>()."
msgstr ""
"Помимо B<PTHREAD_MUTEX_STALLED> или B<PTHREAD_MUTEX_ROBUST> в "
"B<pthread_mutexattr_setrobust>() передано что-то ещё."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:150
msgid ""
"B<pthread_mutexattr_getrobust>()  and B<pthread_mutexattr_setrobust>()  were "
"added to glibc in version 2.12."
msgstr ""
"Функции B<pthread_mutexattr_getrobust>() и B<pthread_mutexattr_setrobust>() "
"добавлены в glibc версии 2.12."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:152
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#.  E.g., Solaris, according to its manual page
#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:163
msgid ""
"In the Linux implementation, when using process-shared robust mutexes, a "
"waiting thread also receives the B<EOWNERDEAD> notification if the owner of "
"a robust mutex performs an B<execve>(2)  without first unlocking the mutex.  "
"POSIX.1 does not specify this detail, but the same behavior also occurs in "
"at least some other implementations."
msgstr ""
"В реализации Linux при использовании общих для процессов устойчивых "
"мьютексов ожидающая нить также получает уведомление B<EOWNERDEAD>, если "
"владелец устойчивого мьютекса выполняет B<execve>(2) без предварительной "
"разблокировки мьютекса. В POSIX.1 не указана данная подробность, но такое же "
"поведение также встречается и в нескольких других реализациях."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:172
msgid ""
"Before the addition of B<pthread_mutexattr_getrobust>()  and "
"B<pthread_mutexattr_setrobust>()  to POSIX, glibc defined the following "
"equivalent nonstandard functions if B<_GNU_SOURCE> was defined:"
msgstr ""
"До появления B<pthread_mutexattr_getrobust>() и "
"B<pthread_mutexattr_setrobust>() в POSIX, в glibc определись следующие "
"эквиваленты нестандартных функций, если определён B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:178
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int >I<robustness>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<robustness>B<);>\n"
"B<int pthread_mutexattr_setrobust_np(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                   int >I<robustness>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:185
msgid ""
"Correspondingly, the constants B<PTHREAD_MUTEX_STALLED_NP> and "
"B<PTHREAD_MUTEX_ROBUST_NP> were also defined."
msgstr ""
"Соответственно, также определены константы B<PTHREAD_MUTEX_STALLED_NP> и "
"B<PTHREAD_MUTEX_ROBUST_NP>."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:188
msgid ""
"These GNU-specific APIs, which first appeared in glibc 2.4, are nowadays "
"obsolete and should not be used in new programs."
msgstr ""
"Данный имеющийся только в GNU программный интерфейс, впервые появившийся в "
"glibc 2.4, в настоящее время устарел и не должен использоваться в новых "
"программах."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:198
msgid ""
"The program below demonstrates the use of the robustness attribute of a "
"mutex attributes object.  In this program, a thread holding the mutex dies "
"prematurely without unlocking the mutex.  The main thread subsequently "
"acquires the mutex successfully and gets the error B<EOWNERDEAD>, after "
"which it makes the mutex consistent."
msgstr ""
"В программе, представленной далее, показывается использование атрибута "
"устойчивости в объекте мьютексных атрибутов. В этой программе нить, "
"удерживающая мьютекс, завершает работу без разблокировки мьютекса. После "
"этого главная нить захватывает мьютекс и получает ошибку B<EOWNERDEAD>, "
"после чего делает мьютекс согласованным."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:200
msgid ""
"The following shell session shows what we see when running this program:"
msgstr "Пример сеанса работы с программой:"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:210
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"[original owner] Setting lock...\n"
"[original owner] Locked. Now exiting without unlocking.\n"
"[main thread] Attempting to lock the robust mutex.\n"
"[main thread] pthread_mutex_lock() returned EOWNERDEAD\n"
"[main thread] Now make the mutex consistent\n"
"[main thread] Mutex is now consistent; unlocking\n"
msgstr ""
"$ B<./a.out>\n"
"[первый владелец] Установка блокировки…\n"
"[первый владелец] Готово. Теперь выходим без разблокировки.\n"
"[главная нить] Пытаемся получить заблокировать устойчивый мьютекс.\n"
"[главная нить] pthread_mutex_lock() вернула EOWNERDEAD\n"
"[главная нить] Теперь делаем мьютекс согласованным\n"
"[главная нить] Мьютекс согласован; разблокируем\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:219
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:222
#, no-wrap
msgid ""
"#define handle_error_en(en, msg) \\e\n"
"               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error_en(en, msg) \\e\n"
"               do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:224
#, no-wrap
msgid "static pthread_mutex_t mtx;\n"
msgstr "static pthread_mutex_t mtx;\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:233
#, no-wrap
msgid ""
"static void *\n"
"original_owner_thread(void *ptr)\n"
"{\n"
"    printf(\"[original owner] Setting lock...\\en\");\n"
"    pthread_mutex_lock(&mtx);\n"
"    printf(\"[original owner] Locked. Now exiting without unlocking.\\en\");\n"
"    pthread_exit(NULL);\n"
"}\n"
msgstr ""
"static void *\n"
"original_owner_thread(void *ptr)\n"
"{\n"
"    printf(\"[первый владелец] Установка блокировки…\\en\");\n"
"    pthread_mutex_lock(&mtx);\n"
"    printf(\"[original owner] Готово. Теперь выходим без разблокировки.\\en\");\n"
"    pthread_exit(NULL);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:240
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_mutexattr_t attr;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_mutexattr_t attr;\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:245
#, no-wrap
msgid ""
"    pthread_mutexattr_init(&attr);\n"
"                                /* initialize the attributes object */\n"
"    pthread_mutexattr_setrobust(&attr, PTHREAD_MUTEX_ROBUST);\n"
"                               /* set robustness */\n"
msgstr ""
"    pthread_mutexattr_init(&attr);\n"
"                                /* инициализируем объект атрибутов */\n"
"    pthread_mutexattr_setrobust(&attr, PTHREAD_MUTEX_ROBUST);\n"
"                               /* задаём устойчивость */\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:247
#, no-wrap
msgid "    pthread_mutex_init(&mtx, &attr);   /* initialize the mutex */\n"
msgstr "    pthread_mutex_init(&mtx, &attr);   /* инициализируем мьютекс */\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:249
#, no-wrap
msgid "    pthread_create(&thr, NULL, original_owner_thread, NULL);\n"
msgstr "    pthread_create(&thr, NULL, original_owner_thread, NULL);\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:251
#, no-wrap
msgid "    sleep(2);\n"
msgstr "    sleep(2);\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:253
#, no-wrap
msgid "    /* \"original_owner_thread\" should have exited by now */\n"
msgstr "    /* «нить_первый_владелец» к этому моменту должна завершиться */\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:266
#, no-wrap
msgid ""
"    printf(\"[main thread] Attempting to lock the robust mutex.\\en\");\n"
"    s = pthread_mutex_lock(&mtx);\n"
"    if (s == EOWNERDEAD) {\n"
"        printf(\"[main thread] pthread_mutex_lock() returned EOWNERDEAD\\en\");\n"
"        printf(\"[main thread] Now make the mutex consistent\\en\");\n"
"        s = pthread_mutex_consistent(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_consistent\");\n"
"        printf(\"[main thread] Mutex is now consistent; unlocking\\en\");\n"
"        s = pthread_mutex_unlock(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_unlock\");\n"
msgstr ""
"    printf(\"[главная нить] Пытаемся получить заблокировать устойчивый мьютекс.\\en\");\n"
"    s = pthread_mutex_lock(&mtx);\n"
"    if (s == EOWNERDEAD) {\n"
"        printf(\"[главная нить] pthread_mutex_lock() вернула EOWNERDEAD\\en\");\n"
"        printf(\"[главная нить] Теперь делаем мьютекс согласованным\\en\");\n"
"        s = pthread_mutex_consistent(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_consistent\");\n"
"        printf(\"[главная нить] Мьютекс согласован; разблокируем\\en\");\n"
"        s = pthread_mutex_unlock(&mtx);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_mutex_unlock\");\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:276
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    } else if (s == 0) {\n"
"        printf(\"[main thread] pthread_mutex_lock() unexpectedly succeeded\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    } else {\n"
"        printf(\"[main thread] pthread_mutex_lock() unexpectedly failed\\en\");\n"
"        handle_error_en(s, \"pthread_mutex_lock\");\n"
"    }\n"
"}\n"
msgstr ""
"        exit(EXIT_SUCCESS);\n"
"    } else if (s == 0) {\n"
"        printf(\"[главная нить] pthread_mutex_lock() неожиданно завершилась успешно\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    } else {\n"
"        printf(\"[главная нить] pthread_mutex_lock() завершилась с ошибкой\\en\");\n"
"        handle_error_en(s, \"pthread_mutex_lock\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_setrobust.3:285
msgid ""
"B<get_robust_list>(2), B<set_robust_list>(2), B<pthread_mutex_init>(3), "
"B<pthread_mutex_consistent>(3), B<pthread_mutex_lock>(3), B<pthreads>(7)"
msgstr ""
"B<get_robust_list>(2), B<set_robust_list>(2), B<pthread_mutex_init>(3), "
"B<pthread_mutex_consistent>(3), B<pthread_mutex_lock>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/posix_fallocate.3:25
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr "POSIX_FALLOCATE"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:28
msgid "posix_fallocate - allocate file space"
msgstr "posix_fallocate - выделяет пространство для файла"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:33
#, no-wrap
msgid "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:42
msgid "B<posix_fallocate>():"
msgstr "B<posix_fallocate>():"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:61
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the file descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr ""
"Функция B<posix_fallocate>() гарантирует, что дисковое пространство, "
"выделено для файла, на который указывает файловый дескриптор I<fd>, для байт "
"в диапазоне начиная с I<offset> и длиной I<len> байт. После успешного "
"выполнения B<posix_fallocate>() последующие операции записи в байты "
"указанного диапазона гарантировано не закончатся ошибкой из-за нехватки "
"места на диске."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:66
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""
"Если размер файла меньше чем I<offset>+I<len>, то файл увеличится до своего "
"размера; в противном случае размер файла останется не изменённым."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:72
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""
"При успешном выполнении функции B<posix_fallocate>()  возвращается 0, а при "
"ошибке возвращается её номер. Заметим, что I<errno> не изменяется."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:77
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""
"I<fd> не является допустимым файловым дескриптором или не открыт на запись."

#. type: TP
#: man-pages/man3/posix_fallocate.3:77
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:81
msgid "I<offset+len> exceeds the maximum file size."
msgstr "Сумма I<offset+len> превышает максимальный размер файла."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:84
msgid "A signal was caught during execution."
msgstr "При выполнении поступил сигнал."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:91
msgid ""
"I<offset> was less than 0, or I<len> was less than or equal to 0, or the "
"underlying filesystem does not support the operation."
msgstr ""
"Значение I<offset> меньше, или I<len> меньше или равно 0, или используемая "
"файловая система, хранящая файл, не поддерживает операцию."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:95
msgid "I<fd> does not refer to a regular file."
msgstr "Дескриптор I<fd> не указывает на обычный файл."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:100
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr ""
"Недостаточно дискового пространства на устройстве, на котором расположен "
"файл, указанный в I<fd>."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:104
msgid "I<fd> refers to a pipe."
msgstr "Значение I<fd> указывает на канал."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:107
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr "Функция B<posix_fallocate>() доступна в glibc начиная с версии 2.1.94."

#. type: tbl table
#: man-pages/man3/posix_fallocate.3:117
#, no-wrap
msgid "B<posix_fallocate>()"
msgstr "B<posix_fallocate>()"

#. type: tbl table
#: man-pages/man3/posix_fallocate.3:117
#, no-wrap
msgid "MT-Safe (but see NOTES)"
msgstr "MT-Safe (но смотрите ДЕФЕКТЫ)"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:144
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""
"В POSIX.1-2008 указано, что реализация I<должна> возвращать ошибку "
"B<EINVAL>, если I<len> равно 0 или I<offset> меньше 0. В POSIX.1-2001 "
"сказано, что реализация I<должна> возвращать ошибку B<EINVAL>, если I<len> "
"меньше 0 или I<offset> меньше 0, и I<может> возвращать ошибку, если I<len> "
"равно 0."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:153
msgid ""
"In the glibc implementation, B<posix_fallocate>()  is implemented using the "
"B<fallocate>(2)  system call, which is MT-safe.  If the underlying "
"filesystem does not support B<fallocate>(2), then the operation is emulated "
"with the following caveats:"
msgstr ""
"В glibc функция B<posix_fallocate>() реализована с помощью системного вызова "
"B<fallocate>(2), который является нитебезопасным. Если подлежащая файловая "
"система не поддерживает B<fallocate>(2), то операция эмулируется со "
"следующими оговорками:"

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:155
msgid "The emulation is inefficient."
msgstr "Эмуляция не считается эффективной."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:158
msgid ""
"There is a race condition where concurrent writes from another thread or "
"process could be overwritten with null bytes."
msgstr ""
"Существует состязательность, где одновременные записи из другой нити или "
"процесса могут быть перезаписаны null байтами."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:162
msgid ""
"There is a race condition where concurrent file size increases by another "
"thread or process could result in a file whose size is smaller than expected."
msgstr ""
"Существует состязательность, где одновременное увеличение размера файла из "
"другой нити или процесса могут привести к тому, что размер файл будет меньше "
"ожидаемого."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:171
msgid ""
"If I<fd> has been opened with the B<O_APPEND> or B<O_WRONLY> flags, the "
"function fails with the error B<EBADF>."
msgstr ""
"Если I<fd> был открыт с флагом B<O_APPEND> или B<O_WRONLY>, то функция "
"завершается ошибкой B<EBADF>."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:181
msgid ""
"In general, the emulation is not MT-safe.  On Linux, applications may use "
"B<fallocate>(2)  if they cannot tolerate the emulation caveats.  In general, "
"this is only recommended if the application plans to terminate the operation "
"if B<EOPNOTSUPP> is returned, otherwise the application itself will need to "
"implement a fallback with all the same problems as the emulation provided by "
"glibc."
msgstr ""
"Таким образом, эмуляция не является нитебезопасной. В Linux приложения могут "
"использовать B<fallocate>(2), если для них неприемлемы оговорки эмуляции. В "
"общем, функцию рекомендуется использовать только, если приложение планирует "
"завершить операцию, если возвращается B<EOPNOTSUPP>, в противном случае в "
"приложении нужно реализовать обходное решение проблем эмуляции, "
"предоставляемой glibc."

#. type: Plain text
#: man-pages/man3/posix_fallocate.3:185
msgid "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"

#. type: TH
#: man-pages/man3/pthread_cancel.3:26
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr "PTHREAD_CANCEL"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:29
msgid "pthread_cancel - send a cancellation request to a thread"
msgstr "pthread_cancel - посылает нити запрос отмены"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:34
#, no-wrap
msgid "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"
msgstr "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:36
#, no-wrap
msgid "Compile and link with I<-pthread>.\n"
msgstr "Компилируется и компонуется вместе с I<-pthread>.\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:49
msgid ""
"The B<pthread_cancel>()  function sends a cancellation request to the thread "
"I<thread>.  Whether and when the target thread reacts to the cancellation "
"request depends on two attributes that are under the control of that thread: "
"its cancelability I<state> and I<type>."
msgstr ""
"Функция B<pthread_cancel>() посылает нити I<thread> запрос отмены. "
"Отреагирует нити назначения и когда на запрос отмены зависит от двух "
"атрибутов, которые управляют этой нитью: I<состояние> и I<тип> возможности "
"отмены."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:61
msgid ""
"A thread's cancelability state, determined by B<pthread_setcancelstate>(3), "
"can be I<enabled> (the default for new threads) or I<disabled>.  If a thread "
"has disabled cancellation, then a cancellation request remains queued until "
"the thread enables cancellation.  If a thread has enabled cancellation, then "
"its cancelability type determines when cancellation occurs."
msgstr ""
"Состояние отменяемости нити, определённое в B<pthread_setcancelstate>(3), "
"может быть I<включено> (по умолчанию у новых нитей) или I<выключено>. Если "
"отменяемость у нити выключена, то запрос отменяемости остаётся в очереди до "
"тех пор, пока нить не включит отменяемость. Если отменяемость у нити "
"включена, то когда произойдёт отмена определяется типом отменяемости."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:77
msgid ""
"A thread's cancellation type, determined by B<pthread_setcanceltype>(3), may "
"be either I<asynchronous> or I<deferred> (the default for new threads).  "
"Asynchronous cancelability means that the thread can be canceled at any time "
"(usually immediately, but the system does not guarantee this).  Deferred "
"cancelability means that cancellation will be delayed until the thread next "
"calls a function that is a I<cancellation point>.  A list of functions that "
"are or may be cancellation points is provided in B<pthreads>(7)."
msgstr ""
"Тип отменяемости нити, определённый в B<pthread_setcanceltype>(3), может "
"быть I<асинхронным> или I<отложенным> (по умолчанию у новых нитей). "
"Асинхронная отменяемость означает, что нить может быть отменена в любое "
"время (обычно, немедленно, но система не гарантирует этого). Отложенная "
"отменяемость означает, что отмена будет задержана до тех пор, пока нить не "
"вызовет функцию, являющуюся I<точкой отмены>. Список функций, которые могут "
"быть точками отмены, представлен в B<pthreads>(7)."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:81
msgid ""
"When a cancellation requested is acted on, the following steps occur for "
"I<thread> (in this order):"
msgstr ""
"Когда выполняется запрошенная отмена, для I<thread> выполняются следующие "
"шаги (в таком порядке):"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:86
msgid ""
"Cancellation clean-up handlers are popped (in the reverse of the order in "
"which they were pushed) and called.  (See B<pthread_cleanup_push>(3).)"
msgstr ""
"Отмена поднимает очищающие обработчики (в обратном порядке их регистрации) и "
"они вызываются (смотрите B<pthread_cleanup_push>(3))."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:91
msgid ""
"Thread-specific data destructors are called, in an unspecified order.  (See "
"B<pthread_key_create>(3).)"
msgstr ""
"Вызываются деструкторы данных нити, в неопределённом порядке (смотрите "
"B<pthread_key_create>(3))."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:95
msgid "The thread is terminated.  (See B<pthread_exit>(3).)"
msgstr "Нить завершается (смотрите B<pthread_exit>(3))."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:103
msgid ""
"The above steps happen asynchronously with respect to the "
"B<pthread_cancel>()  call; the return status of B<pthread_cancel>()  merely "
"informs the caller whether the cancellation request was successfully queued."
msgstr ""
"Приведённые выше шаги выполняются асинхронно по отношению к вызову "
"B<pthread_cancel>(); возвращаемое B<pthread_cancel>() состояние всего лишь "
"информирует вызывающего, что  запрос отмены успешно попал в очередь."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:112
msgid ""
"After a canceled thread has terminated, a join with that thread using "
"B<pthread_join>(3)  obtains B<PTHREAD_CANCELED> as the thread's exit "
"status.  (Joining with a thread is the only way to know that cancellation "
"has completed.)"
msgstr ""
"После завершения отменённой нити, при объединении с этой нитью с помощью "
"B<pthread_join>(3) возвращается B<PTHREAD_CANCELED> в качестве состояния "
"выхода (объединение с нитью — единственный способ узнать о завершении "
"отмены)."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:117
msgid ""
"On success, B<pthread_cancel>()  returns 0; on error, it returns a nonzero "
"error number."
msgstr ""
"При успешном выполнении B<pthread_cancel>() возвращается 0; при ошибке "
"возвращается ненулевой номер ошибки."

#. type: tbl table
#: man-pages/man3/pthread_cancel.3:135
#, no-wrap
msgid "B<pthread_cancel>()"
msgstr "B<pthread_cancel>()"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:148
msgid ""
"On Linux, cancellation is implemented using signals.  Under the NPTL "
"threading implementation, the first real-time signal (i.e., signal 32) is "
"used for this purpose.  On LinuxThreads, the second real-time signal is "
"used, if real-time signals are available, otherwise B<SIGUSR2> is used."
msgstr ""
"В Linux отменяемость реализована с помощью сигналов. В реализации нитей NPTL "
"для этой цели используется первый сигнал реального времени (т. е., сигнал). "
"В LinuxThreads используется второй сигнал реального времени (если сигналы "
"реального времени доступны, в противном случае используется B<SIGUSR2>)."

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:154
msgid ""
"The program below creates a thread and then cancels it.  The main thread "
"joins with the canceled thread to check that its exit status was "
"B<PTHREAD_CANCELED>.  The following shell session shows what happens when we "
"run the program:"
msgstr ""
"Программа, представленная ниже, создаёт нить и затем отменяет её. Главная "
"нить объединяется с отменённой нитью, чтобы получить состояние выхода "
"B<PTHREAD_CANCELED>. Далее представлен сеанс работы программы:"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:162
#, no-wrap
msgid ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"
msgstr ""
"$ ./a.out\n"
"thread_func(): запущена; отмена выключена\n"
"main(): отправляем запрос отмены\n"
"thread_func(): для включения отмены\n"
"main(): нить была отменена\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:172
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:175
#, no-wrap
msgid ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:180
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"
msgstr ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:183
#, no-wrap
msgid ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"
msgstr ""
"    /* выключаем отмена на некоторое время для того, чтобы\n"
"       запрос на отмену не сработал сразу же */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:187
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:191
#, no-wrap
msgid ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"
msgstr ""
"    printf(\"thread_func(): запущена; отмена выключена\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): для включения отмены\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:195
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:197
#, no-wrap
msgid "    /* sleep() is a cancellation point */\n"
msgstr "    /* sleep() является точкой отмены */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:199
#, no-wrap
msgid "    sleep(1000);        /* Should get canceled while we sleep */\n"
msgstr "    sleep(1000);        /* должна произойти отмена во время сна */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:201
#, no-wrap
msgid "    /* Should never get here */\n"
msgstr "    /* не должно до сюда дойти */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:205
#, no-wrap
msgid ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    printf(\"thread_func(): не отменена!\\en\");\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:212
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:214
#, no-wrap
msgid "    /* Start a thread and then send it a cancellation request */\n"
msgstr "    /* запускаем нить, а затем посылаем ей запрос отмены */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:218
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:220
#, no-wrap
msgid "    sleep(2);           /* Give thread a chance to get started */\n"
msgstr "    sleep(2);           /* даём время нити запуститься */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:225
#, no-wrap
msgid ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"
msgstr ""
"    printf(\"main(): посылаем запрос отмены\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:227
#, no-wrap
msgid "    /* Join with thread to see what its exit status was */\n"
msgstr "    /* присоединяемся к нити для получения её кода выхода */\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:231
#, no-wrap
msgid ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:238
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): нить была отменена\\en\");\n"
"    else\n"
"        printf(\"main(): нить не была отменена, чего быть не должно!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_cancel.3:250
msgid ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/program_invocation_name.3:24
#, no-wrap
msgid "INVOCATION_NAME"
msgstr "INVOCATION_NAME"

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:28
msgid ""
"program_invocation_name, program_invocation_short_name - obtain name used to "
"invoke calling program"
msgstr ""
"program_invocation_name, program_invocation_short_name - имя, использованное "
"для запуска вызвавшей программы"

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>errno.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>errno.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:35
#, no-wrap
msgid ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"
msgstr ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:46
msgid ""
"I<program_invocation_name> contains the name that was used to invoke the "
"calling program.  This is the same as the value of I<argv[0]> in I<main>(), "
"with the difference that the scope of I<program_invocation_name> is global."
msgstr ""
"Переменная I<program_invocation_name> содержит имя, которое было "
"использовано для запуска вызвавшей программы. Это значение совпадает с "
"I<argv[0]> в I<main>(); отличие в том, что I<program_invocation_name> — "
"глобальная переменная."

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:53
msgid ""
"I<program_invocation_short_name> contains the basename component of name "
"that was used to invoke the calling program.  That is, it is the same value "
"as I<program_invocation_name>, with all text up to and including the final "
"slash (/), if any, removed."
msgstr ""
"Переменная I<program_invocation_short_name> содержит базовую часть имени, "
"которое было использовано для запуска вызвавшей программы. То есть её "
"значение совпадает с началом I<program_invocation_name> до последней косой "
"черты (/)."

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:56
msgid ""
"These variables are automatically initialized by the glibc run-time startup "
"code."
msgstr ""
"Эти переменные автоматически инициализируются glibc при запуске программы."

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:59
msgid ""
"These variables are GNU extensions, and should not be used in programs "
"intended to be portable."
msgstr ""
"Эти переменные являются расширениями GNU, и они не должны использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:63
msgid ""
"The Linux-specific I</proc/[number]/cmdline> file provides access to similar "
"information."
msgstr "В Linux файл I</proc/[number]/cmdline> содержит подобную информацию."

#. type: Plain text
#: man-pages/man3/program_invocation_name.3:64
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: man-pages/man3/pthread_testcancel.3:26
#, no-wrap
msgid "PTHREAD_TESTCANCEL"
msgstr "PTHREAD_TESTCANCEL"

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:29
msgid ""
"pthread_testcancel - request delivery of any pending cancellation request"
msgstr "pthread_testcancel - доставляет ожидающий запрос отмены"

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:34
#, no-wrap
msgid "B<void pthread_testcancel(void);>\n"
msgstr "B<void pthread_testcancel(void);>\n"

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:43
msgid ""
"Calling B<pthread_testcancel>()  creates a cancellation point within the "
"calling thread, so that a thread that is otherwise executing code that "
"contains no cancellation points will respond to a cancellation request."
msgstr ""
"Вызов B<pthread_testcancel>() создаёт точку отмены в вызвавшей нити, из-за "
"чего нить, в выполняемом коде которой нет точек отмены, ответит на запрос "
"отмены."

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:50
msgid ""
"If cancelability is disabled (using B<pthread_setcancelstate>(3)), or no "
"cancellation request is pending, then a call to B<pthread_testcancel>()  has "
"no effect."
msgstr ""
"Если отменяемость выключена (с помощью B<pthread_setcancelstate>(3)) или нет "
"ожидающего запроса отмены, то функция B<pthread_testcancel>() ничего не "
"делает."

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:54
msgid ""
"This function does not return a value.  If the calling thread is canceled as "
"a consequence of a call to this function, then the function does not return."
msgstr ""
"Эта функция не возвращает значения. Если вызвавшая нить отменяется из-за "
"вызова этой функции, то функция не возвращает управление."

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:58
msgid "This function always succeeds."
msgstr "Данная функция всегда завершается успешно."

#. type: tbl table
#: man-pages/man3/pthread_testcancel.3:68
#, no-wrap
msgid "B<pthread_testcancel>()"
msgstr "B<pthread_testcancel>()"

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:75
msgid "See B<pthread_cleanup_push>(3)."
msgstr "See B<pthread_cleanup_push>(3)."

#. type: Plain text
#: man-pages/man3/pthread_testcancel.3:79
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_mutexattr_getpshared.3:25
#, no-wrap
msgid "PTHREAD_MUTEXATTR_GETPSHARED"
msgstr "PTHREAD_MUTEXATTR_GETPSHARED"

#. type: TH
#: man-pages/man3/pthread_mutexattr_getpshared.3:25
#, no-wrap
msgid "2017-09-13"
msgstr "2017-09-13"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:29
msgid ""
"pthread_mutexattr_getpshared, pthread_mutexattr_setpshared - get/set process-"
"shared mutex attribute"
msgstr ""
"pthread_mutexattr_getpshared, pthread_mutexattr_setpshared - возвращает/"
"изменяет общепроцессный атрибут мьютекса"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:37
#, no-wrap
msgid ""
"B<int pthread_mutexattr_getpshared(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int *>I<pshared>B<);>\n"
"B<int pthread_mutexattr_setpshared(pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int >I<pshared>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_getpshared(const pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int *>I<pshared>B<);>\n"
"B<int pthread_mutexattr_setpshared(pthread_mutexattr_t *>I<attr>B<,>\n"
"B<                                 int >I<pshared>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:45
msgid ""
"These functions get and set the process-shared attribute in a mutex "
"attributes object.  This attribute must be appropriately set to ensure "
"correct, efficient operation of a mutex created using this attributes object."
msgstr ""
"Эти функции возвращают и изменяют общепроцессный атрибут мьютекса в объекте "
"атрибутов мьютекса. Данный атрибут должен быть установлен соответствующим "
"образом для обеспечения правильной, эффективной работы мьютекса, созданного "
"с использованием данного объекта атрибутов."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:47
msgid "The process-shared attribute can have one of the following values:"
msgstr "В общепроцессном аргументе можно указать одно из следующих значений:"

#. type: TP
#: man-pages/man3/pthread_mutexattr_getpshared.3:47
#, no-wrap
msgid "B<PTHREAD_PROCESS_PRIVATE>"
msgstr "B<PTHREAD_PROCESS_PRIVATE>"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:52
msgid ""
"Mutexes created with this attributes object are to be shared only among "
"threads in the same process that initialized the mutex.  This is the default "
"value for the process-shared mutex attribute."
msgstr ""
"Мьютексы, созданные с таким объектом атрибутов, будут считаться общими "
"только для нитей одного процесса, инициализировавшего мьютекс. Это значение "
"используется по умолчанию для общепроцессного атрибута мьютекса."

#. type: TP
#: man-pages/man3/pthread_mutexattr_getpshared.3:52
#, no-wrap
msgid "B<PTHREAD_PROCESS_SHARED>"
msgstr "B<PTHREAD_PROCESS_SHARED>"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:57
msgid ""
"Mutexes created with this attributes object can be shared between any "
"threads that have access to the memory containing the object, including "
"threads in different processes."
msgstr ""
"Мьютексы, созданные с таким объектом атрибутов, будут считаться общими между "
"всеми нитями, имеющими доступ к памяти, содержащей объект, даже нити разных "
"процессов."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:64
msgid ""
"B<pthread_mutexattr_getpshared>()  places the value of the process-shared "
"attribute of the mutex attributes object referred to by I<attr> in the "
"location pointed to by I<pshared>."
msgstr ""
"Функция B<pthread_mutexattr_getpshared>() помещает значения общепроцессного "
"атрибута объекта атрибутов мьютекса, на который указывает I<attr>, в "
"расположение, указанное в I<pshared>."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:71
msgid ""
"B<pthread_mutexattr_setpshared>()  sets the value of the process-shared "
"attribute of the mutex attributes object referred to by I<attr> to the value "
"specified in B<pshared>."
msgstr ""
"Функция B<pthread_mutexattr_setpshared>() изменяет значения общепроцессного "
"атрибута объекта атрибутов мьютекса, на который указывает I<attr>, на "
"значение, заданное в B<pshared>."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:76
msgid ""
"If I<attr> does not refer to an initialized mutex attributes object, the "
"behavior is undefined."
msgstr ""
"Если I<attr> не ссылается на инициализированный объект атрибутов мьютекса, "
"то поведение не определено."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:82
msgid "B<pthread_mutexattr_setpshared>()  can fail with the following errors:"
msgstr ""
"Функция B<pthread_mutexattr_setpshared>() может завершаться со следующими "
"ошибками:"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:87
msgid "The value specified in I<pshared> is invalid."
msgstr "Неверное значение в I<pshared>."

#. type: TP
#: man-pages/man3/pthread_mutexattr_getpshared.3:87
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:92
msgid ""
"I<pshared is> B<PTHREAD_PROCESS_SHARED> but the implementation does not "
"support process-shared mutexes."
msgstr ""
"Значение I<pshared> равно B<PTHREAD_PROCESS_SHARED>, но реализация не "
"поддерживает общепроцессные мьютексы."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_getpshared.3:98
msgid "B<pthread_mutexattr_init>(3), B<pthreads>(7)"
msgstr "B<pthread_mutexattr_init>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:25
#, no-wrap
msgid "PTHREAD_RWLOCKATTR_SETKIND_NP"
msgstr "PTHREAD_RWLOCKATTR_SETKIND_NP"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:29
msgid ""
"pthread_rwlockattr_setkind_np, pthread_rwlockattr_getkind_np - set/get the "
"read-write lock kind of the thread read-write lock attribute object"
msgstr ""
"pthread_rwlockattr_setkind_np, pthread_rwlockattr_getkind_np - изменяет/"
"возвращает вид блокировки чтения-записи у объекта-атрибута блокировки чтения-"
"записи нити"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:37
#, no-wrap
msgid ""
"B<int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int >I<pref>B<);>\n"
"B<int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<pref>B<);>\n"
msgstr ""
"B<int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int >I<pref>B<);>\n"
"B<int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *>I<attr>B<,>\n"
"B<                                   int *>I<pref>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:48
msgid "B<pthread_rwlockattr_setkind_np>(), B<pthread_rwlockattr_getkind_np>():"
msgstr ""
"B<pthread_rwlockattr_setkind_np>(), B<pthread_rwlockattr_getkind_np>():"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:52
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE E<gt>= 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE E<gt>= 200809L"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:65
msgid ""
"The B<pthread_rwlockattr_setkind_np>()  function sets the \"lock kind\" "
"attribute of the read-write lock attribute object referred to by I<attr> to "
"the value specified in I<pref>.  The argument I<pref> may be set to one of "
"the following:"
msgstr ""
"Функция B<pthread_rwlockattr_setkind_np>() изменяет атрибут «вида "
"блокировки» у объекта-атрибута блокировки чтения-записи, на который "
"указывает I<attr>, в значение I<pref>. Значением I<pref> может быть одно из:"

#. type: TP
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:65
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_READER_NP>"
msgstr "B<PTHREAD_RWLOCK_PREFER_READER_NP>"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:78
msgid ""
"This is the default.  A thread may hold multiple read locks; that is, read "
"locks are recursive.  According to The Single Unix Specification, the "
"behavior is unspecified when a reader tries to place a lock, and there is no "
"write lock but writers are waiting.  Giving preference to the reader, as is "
"set by B<PTHREAD_RWLOCK_PREFER_READER_NP>, implies that the reader will "
"receive the requested lock, even if a writer is waiting.  As long as there "
"are readers, the writer will be starved."
msgstr ""
"Значение по умолчанию. Нить может удерживать многократную блокировку чтения; "
"то есть блокировки чтения рекурсивны. Согласно Single Unix Specification, "
"поведение не определено, если читатель пытается установить блокировку и "
"отсутствует блокировка записи, но писатели ждут. Давая преимущество читателю "
"установкой B<PTHREAD_RWLOCK_PREFER_READER_NP> подразумевается, что читатель "
"будет получать запрашиваемую блокировку даже, если ждёт писатель. Пока есть "
"читатели писатель будет ждать."

#. type: TP
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:78
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_WRITER_NP>"
msgstr "B<PTHREAD_RWLOCK_PREFER_WRITER_NP>"

#.  ---
#.  Here is the relevant wording:
#.      A thread may hold multiple concurrent read locks on rwlock (that is,
#.      successfully call the pthread_rwlock_rdlock() function n times). If
#.      so, the thread must perform matching unlocks (that is, it must call
#.      the pthread_rwlock_unlock() function n times).
#.  By making write-priority work correctly, I broke the above requirement,
#.  because I had no clue that recursive read locks are permissible.
#.  If a thread which holds a read lock tries to acquire another read lock,
#.  and now one or more writers is waiting for a write lock, then the algorithm
#.  will lead to an obvious deadlock. The reader will be suspended, waiting for
#.  the writers to acquire and release the lock, and the writers will be
#.  suspended waiting for every existing read lock to be released.
#.  ---
#.  http://sources.redhat.com/ml/libc-alpha/2000-01/msg00055.html
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=7057
#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:107
msgid ""
"This is intended as the write lock analog of "
"B<PTHREAD_RWLOCK_PREFER_READER_NP>.  This is ignored by glibc because the "
"POSIX requirement to support recursive writer locks would cause this option "
"to create trivial deadlocks; instead use "
"B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP> which ensures the "
"application developer will not take recursive read locks thus avoiding "
"deadlocks."
msgstr ""
"Аналог B<PTHREAD_RWLOCK_PREFER_READER_NP>, но для блокировки записи. "
"Игнорируется glibc, так как с учётом требований POSIX рекурсивная блокировка "
"записи, привела был к созданию вечной блокировки (deadlocks); вместо неё "
"используется B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP>, которая не "
"позволяет разработчику приложения получить рекурсивную блокировку чтения, и "
"поэтому вечной блокировки не случится."

#. type: TP
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:107
#, no-wrap
msgid "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP>"
msgstr "B<PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP>"

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:112
msgid ""
"Setting the lock kind to this avoids writer starvation as long as any read "
"locking is not done in a recursive fashion."
msgstr ""
"Данный вид блокировки помогает избежать ожидания писателя всё время пока не "
"освободится рекурсивная блокировка чтения."

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:120
msgid ""
"The B<pthread_rwlockattr_getkind_np>()  function returns the value of the "
"lock kind attribute of the read-write lock attribute object referred to by "
"I<attr> in the pointer I<pref>."
msgstr ""
"Функция B<pthread_rwlockattr_getkind_np>() сохраняет атрибут «вида "
"блокировки» у объекта-атрибута блокировки чтения-записи, на который "
"указывает I<attr>, в указатель I<pref>."

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:128
msgid ""
"On success, these functions return 0.  Given valid pointer arguments, "
"B<pthread_rwlockattr_getkind_np>()  always succeeds.  On error, "
"B<pthread_rwlockattr_setkind_np>()  returns a nonzero error number."
msgstr ""
"При успешном выполнении эти функции возвращают 0. При корректных аргументах "
"указателей B<pthread_rwlockattr_getkind_np>() всегда выполняется успешно. "
"При ошибке B<pthread_rwlockattr_setkind_np>() возвращает ненулевой номер "
"ошибки."

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:133
msgid "I<pref> specifies an unsupported value."
msgstr "Неподдерживаемое значение I<pref>."

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:139
msgid ""
"The B<pthread_rwlockattr_getkind_np>()  and "
"B<pthread_rwlockattr_setkind_np>()  functions first appeared in glibc 2.1."
msgstr ""
"Функции B<pthread_rwlockattr_getkind_np>() и "
"B<pthread_rwlockattr_setkind_np>() впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:142
msgid ""
"These functions are non-standard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in the names."
msgstr ""
"Данные функции являются не стандартизированными расширениями GNU, о чем "
"свидетельствует суффикс «_np» (nonportable)."

#. type: Plain text
#: man-pages/man3/pthread_rwlockattr_setkind_np.3:143
msgid "B<pthreads>(7)"
msgstr "B<pthreads>(7)"

#. type: TH
#: man-pages/man3/ptsname.3:7
#, no-wrap
msgid "PTSNAME"
msgstr "PTSNAME"

#. type: Plain text
#: man-pages/man3/ptsname.3:10
msgid "ptsname, ptsname_r - get the name of the slave pseudoterminal"
msgstr "ptsname, ptsname_r - возвращает имя подчинённого псевдо-терминала"

#. type: Plain text
#: man-pages/man3/ptsname.3:12
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/ptsname.3:14
msgid "B<char *ptsname(int >I<fd>B<);>"
msgstr "B<char *ptsname(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man3/ptsname.3:16
msgid "B<int ptsname_r(int >I<fd>B<, char *>I<buf>B<, size_t >I<buflen>B<);>"
msgstr "B<int ptsname_r(int >I<fd>B<, char *>I<buf>B<, size_t >I<buflen>B<);>"

#. type: Plain text
#: man-pages/man3/ptsname.3:24
msgid "B<ptsname>():"
msgstr "B<ptsname>():"

#. type: Plain text
#: man-pages/man3/ptsname.3:29
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"
msgstr ""
"начиная с glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"

#. type: Plain text
#: man-pages/man3/ptsname.3:32
#, no-wrap
msgid ""
"Glibc 2.23 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""
"glibc 2.23 и старее:\n"
"    _XOPEN_SOURCE\n"

#. type: Plain text
#: man-pages/man3/ptsname.3:36
#, no-wrap
msgid ""
"B<ptsname_r>():\n"
"    _GNU_SOURCE\n"
msgstr ""
"B<ptsname_r>():\n"
"    _GNU_SOURCE\n"

#. type: Plain text
#: man-pages/man3/ptsname.3:43
msgid ""
"The B<ptsname>()  function returns the name of the slave pseudoterminal "
"device corresponding to the master referred to by I<fd>."
msgstr ""
"Функция B<ptsname>() возвращает имя устройства подчинённого псевдо-"
"терминала, соответствующего главному, который указан в I<fd>."

#. type: Plain text
#: man-pages/man3/ptsname.3:55
msgid ""
"The B<ptsname_r>()  function is the reentrant equivalent of B<ptsname>().  "
"It returns the name of the slave pseudoterminal device as a null-terminated "
"string in the buffer pointed to by I<buf>.  The I<buflen> argument specifies "
"the number of bytes available in I<buf>."
msgstr ""
"Функция B<ptsname_r>() является реентерабельным эквивалентном B<ptsname>(). "
"Она сохраняет имя устройства подчинённого псевдо-терминала в виде строки "
"(завершающейся null) в буфер, указанный в I<buf>. В аргументе I<buflen> "
"задаётся количество байт, доступных в I<buf>."

#. type: Plain text
#: man-pages/man3/ptsname.3:62
msgid ""
"On success, B<ptsname>()  returns a pointer to a string in static storage "
"which will be overwritten by subsequent calls.  This pointer must not be "
"freed.  On failure, NULL is returned."
msgstr ""
"При успешном выполнении B<ptsname>() возвращает указатель на строку в "
"статическом хранилище, которая будет перезаписана последующими вызовами. "
"Данный указатель не нужно освобождать. При ошибке возвращается NULL."

#.  In fact the errno value is also returned as the function
#.  result -- MTK, Dec 04
#. type: Plain text
#: man-pages/man3/ptsname.3:72
msgid ""
"On success, B<ptsname_r>()  returns 0.  On failure, a nonzero value is "
"returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<ptsname_r>() возвращает 0. При ошибке возвращается "
"ненулевое значение и в I<errno> записывается номер ошибки."

#.  glibc commit 8f0a947cf55f3b0c4ebdf06953c57eff67a22fa9
#. type: Plain text
#: man-pages/man3/ptsname.3:82
msgid ""
"(B<ptsname_r>()  only)  I<buf> is NULL.  (This error is returned only for "
"glibc 2.25 and earlier.)"
msgstr ""
"(только B<ptsname_r>()) Значение I<buf> равно NULL (эта ошибка возвращается "
"только в glibc 2.25 и старее)."

#. type: TP
#: man-pages/man3/ptsname.3:82
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: man-pages/man3/ptsname.3:86
msgid "I<fd> does not refer to a pseudoterminal master device."
msgstr "Значение I<fd> не ссылается на устройство главного псевдо-терминала."

#. type: Plain text
#: man-pages/man3/ptsname.3:92
msgid "(B<ptsname_r>()  only)  I<buf> is too small."
msgstr "(только B<ptsname_r>()) Значение I<buf> слишком мало."

#. type: Plain text
#: man-pages/man3/ptsname.3:95
msgid "B<ptsname>()  is provided in glibc since version 2.1."
msgstr "Функция B<ptsname>() появилась в glibc версии 2.1."

#. type: tbl table
#: man-pages/man3/ptsname.3:105
#, no-wrap
msgid "B<ptsname>()"
msgstr "B<ptsname>()"

#. type: tbl table
#: man-pages/man3/ptsname.3:105
#, no-wrap
msgid "MT-Unsafe race:ptsname"
msgstr "MT-Unsafe race:ptsname"

#. type: tbl table
#: man-pages/man3/ptsname.3:108
#, no-wrap
msgid "B<ptsname_r>()"
msgstr "B<ptsname_r>()"

#. type: Plain text
#: man-pages/man3/ptsname.3:113
#, no-wrap
msgid ""
"B<ptsname>():\n"
" POSIX.1-2001, POSIX.1-2008.\n"
msgstr ""
"B<ptsname>():\n"
" POSIX.1-2001, POSIX.1-2008.\n"

#. type: Plain text
#: man-pages/man3/ptsname.3:117
msgid ""
"B<ptsname>()  is part of the UNIX 98 pseudoterminal support (see B<pts>(4))."
msgstr ""
"Функция B<ptsname>() является частью поддержки псевдо-терминалов UNIX 98 "
"(смотрите B<pts>(4))."

#.  FIXME . for later review when Issue 8 is one day released
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=508
#. type: Plain text
#: man-pages/man3/ptsname.3:129
msgid ""
"B<ptsname_r>()  is a Linux extension, that is proposed for inclusion in the "
"next major revision of POSIX.1 (Issue 8).  A version of this function is "
"documented on Tru64 and HP-UX, but on those implementations, -1 is returned "
"on error, with I<errno> set to indicate the error.  Avoid using this "
"function in portable programs."
msgstr ""
"Функция B<ptsname_r>() является расширением Linux, которую предполагается "
"включить в следующую большую версию POSIX.1 (Issue 8). Версия этой функции "
"описана в Tru64 и HP-UX, но в их реализациях при ошибке возвращается -1, а в "
"I<errno> записывается номер ошибки. Не используйте эту функцию в переносимых "
"программах."

#. type: Plain text
#: man-pages/man3/ptsname.3:135
msgid ""
"B<grantpt>(3), B<posix_openpt>(3), B<ttyname>(3), B<unlockpt>(3), B<pts>(4), "
"B<pty>(7)"
msgstr ""
"B<grantpt>(3), B<posix_openpt>(3), B<ttyname>(3), B<unlockpt>(3), B<pts>(4), "
"B<pty>(7)"

#. type: TH
#: man-pages/man3/pthread_getattr_np.3:26
#, no-wrap
msgid "PTHREAD_GETATTR_NP"
msgstr "PTHREAD_GETATTR_NP"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:29
msgid "pthread_getattr_np - get attributes of created thread"
msgstr "pthread_getattr_np - возвращает атрибуты созданной нити"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:35
#, no-wrap
msgid "B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t *>I<attr>B<);>\n"
msgstr "B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:45
msgid ""
"The B<pthread_getattr_np>()  function initializes the thread attributes "
"object referred to by I<attr> so that it contains actual attribute values "
"describing the running thread I<thread>."
msgstr ""
"Функция B<pthread_getattr_np>() инициализирует объект атрибутов нити, на "
"который указывает I<attr>, так, чтобы он содержал актуальные значения "
"атрибутов выполняющейся нити I<thread>."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:52
msgid ""
"The returned attribute values may differ from the corresponding attribute "
"values passed in the I<attr> object that was used to create the thread using "
"B<pthread_create>(3).  In particular, the following attributes may differ:"
msgstr ""
"Возвращаемые значения атрибутов могут отличаться от соответствующих значений "
"атрибутов переданных в объекте I<attr>, который использовался при создании "
"нити с помощью  B<pthread_create>(3). В частности, могут отличаться "
"следующие атрибуты:"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:55
msgid ""
"the detach state, since a joinable thread may have detached itself after "
"creation;"
msgstr ""
"состояние отсоединения, так как присоединяемая нить могла сама отсоединиться "
"после создания;"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:58
msgid ""
"the stack size, which the implementation may align to a suitable boundary."
msgstr ""
"размер стека, так как реализация нитей могла выронить значение по уместной "
"границе."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:63
msgid ""
"and the guard size, which the implementation may round upward to a multiple "
"of the page size, or ignore (i.e., treat as 0), if the application is "
"allocating its own stack."
msgstr ""
"размер защиты, так как реализация нитей могла округлить значение в большую "
"сторону до кратного размера страницы, или проигнорировать (т. е., посчитать "
"за 0), если приложение само выделяет себе стек."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:68
msgid ""
"Furthermore, if the stack address attribute was not set in the thread "
"attributes object used to create the thread, then the returned thread "
"attributes object will report the actual stack address that the "
"implementation selected for the thread."
msgstr ""
"Кроме этого, если атрибут адреса стека не был указан в объекте атрибутов "
"нити при создании нити, то возвращаемый объект атрибутов нити будет "
"содержать актуальный адрес стека, который был выбран реализацией для нити."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:73
msgid ""
"When the thread attributes object returned by B<pthread_getattr_np>()  is no "
"longer required, it should be destroyed using B<pthread_attr_destroy>(3)."
msgstr ""
"Когда объект атрибутов нити, возвращаемый B<pthread_getattr_np>(), больше не "
"требуется, то он должен быть удалён с помощью B<pthread_attr_destroy>(3)."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:76
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number."
msgstr ""
"При успешном выполнении функция возвращает 0; при ошибке возвращается "
"ненулевой номер ошибки."

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:81
msgid "Insufficient memory."
msgstr "Недостаточно памяти."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:96
msgid ""
"In addition, if I<thread> refers to the main thread, then "
"B<pthread_getattr_np>()  can fail because of errors from various underlying "
"calls: B<fopen>(3), if I</proc/self/maps> can't be opened; and "
"B<getrlimit>(2), if the B<RLIMIT_STACK> resource limit is not supported."
msgstr ""
"Также, если I<thread> указывает на главную нить, то B<pthread_getattr_np>() "
"может завершиться с ошибкой из-за ошибок различных используемых вызовов: "
"B<fopen>(3), если невозможно открыть I</proc/self/maps>; B<getrlimit>(2), "
"если не поддерживается ограничение ресурса B<RLIMIT_STACK>."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:98
msgid "This function is available in glibc since version 2.2.3."
msgstr "Эта функция доступна в glibc начиная с версии 2.2.3."

#. type: tbl table
#: man-pages/man3/pthread_getattr_np.3:109
#, no-wrap
msgid "B<pthread_getattr_np>()"
msgstr "B<pthread_getattr_np>()"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:115
msgid ""
"This function is a nonstandard GNU extension; hence the suffix \"_np"
"\" (nonportable) in the name."
msgstr ""
"Эта функция является нестандартным расширением GNU, о чём свидетельствует "
"наличие суффикса «_np» (nonportable)."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:125
msgid ""
"The program below demonstrates the use of B<pthread_getattr_np>().  The "
"program creates a thread that then uses B<pthread_getattr_np>()  to retrieve "
"and display its guard size, stack address, and stack size attributes.  "
"Command-line arguments can be used to set these attributes to values other "
"than the default when creating the thread.  The shell sessions below "
"demonstrate the use of the program."
msgstr ""
"В программе, показанной далее, демонстрируется использование "
"B<pthread_getattr_np>(). Программа создаёт нить, которая, затем, использует "
"B<pthread_getattr_np>() для получения и показа своих атрибутов размера "
"защиты, адреса стека и размера стека. Аргументами командной строки можно "
"изменить эти атрибуты. Работа программы показана далее."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:128
msgid ""
"In the first run, on an x86-32 system, a thread is created using default "
"attributes:"
msgstr ""
"В этом запуске на системе x86-32 нить создаётся со значениями атрибутов по "
"умолчанию:"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:138
#, no-wrap
msgid ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""
"$B< ulimit -s>      # Без ограничения стека ==E<gt>\n"
"                 # размер стека по умолчанию 2 МБ\n"
"unlimited\n"
"$B< ./a.out>\n"
"Атрибуты созданной нити:\n"
"        Размер защиты      = 4096 байт\n"
"        Адрес стека        = 0x40196000 (EOS = 0x40397000)\n"
"        Размер стека       = 0x201000 (2101248) байт\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:144
msgid ""
"In the following run, we see that if a guard size is specified, it is "
"rounded up to the next multiple of the system page size (4096 bytes on "
"x86-32):"
msgstr ""
"В этом запуске мы видим, что при задании размера защиты его значение "
"округляется до значение следующего кратного размера системной страницы (4096 "
"байт на x86-32):"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:152
#, no-wrap
msgid ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"
msgstr ""
"$B< ./a.out -g 4097>\n"
"Объект атрибутов нити после инициализации:\n"
"        Размер защиты      = 4097 байт\n"
"        Адрес стека        = (nil)\n"
"        Размер стека       = 0x0 (0) байт\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:157
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""
"Атрибуты созданной нити:\n"
"        Размер защиты      = 8192 байт\n"
"        Адрес стека        = 0x40196000 (EOS = 0x40397000)\n"
"        Размер стека       = 0x201000 (2101248) байт\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:176
msgid ""
"In the last run, the program manually allocates a stack for the thread.  In "
"this case, the guard size attribute is ignored."
msgstr ""
"В этом запуске программа вручную выделяет стек для нити. В этом случае "
"атрибут размера защиты игнорируется."

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:181
#, no-wrap
msgid ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"
msgstr ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Выделен стек нити по адресу 0x804d000\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:186
#, no-wrap
msgid ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""
"Объект атрибутов нити после инициализации:\n"
"        Размер защиты      = 4096 байт\n"
"        Адрес стека        = 0x804d000 (EOS = 0x8055000)\n"
"        Размер стека       = 0x8000 (32768) байт\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:191
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""
"Атрибуты созданной нити:\n"
"        Размер защиты      = 0 байт\n"
"        Адрес стека        = 0x804d000 (EOS = 0x8055000)\n"
"        Размер стека       = 0x8000 (32768) байт\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:202
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* для объявления pthread_getattr_np() */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:212
#, no-wrap
msgid ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
msgstr ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:217
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, guard_size);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sРазмер защиты            = %d байт\\en\", prefix, guard_size);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:228
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = 0x%x (%d) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"
msgstr ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sАдрес стека       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sРазмер стека          = 0x%x (%d) байт\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:234
#, no-wrap
msgid ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:238
#, no-wrap
msgid ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:240
#, no-wrap
msgid "    display_stack_related_attributes(&attr, prefix);\n"
msgstr "    display_stack_related_attributes(&attr, prefix);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:245
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"
msgstr ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:251
#, no-wrap
msgid ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"
msgstr ""
"static void *           /* Начальная функция создаваемой нити */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Атрибуты созданной нити:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:254
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);         /* Завершить все нити */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:265
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Использование: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a означает, что программа выделяет стек\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:278
#, no-wrap
msgid ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    long stack_size, guard_size;\n"
"            void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"
msgstr ""
"static pthread_attr_t *   /* получить атрибуты нити из ком. строки */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    long stack_size, guard_size;\n"
"            void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* задаёт attrp, если мы\n"
"                                           инициализируем объект\n"
"                                           атрибутов нити */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:287
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:290
#, no-wrap
msgid ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"
msgstr ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Указывать -a без -s не имеет смысла\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:293
#, no-wrap
msgid ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"
msgstr ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Посторонние аргументы в командной строке\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:296
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"
msgstr ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:301
#, no-wrap
msgid ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:313
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"
msgstr ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Выделен стек нити по адресу %p\\en\\en\", stack_addr);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:319
#, no-wrap
msgid ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"
msgstr ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:325
#, no-wrap
msgid ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:328
#, no-wrap
msgid ""
"    return ret_attrp;\n"
"}\n"
msgstr ""
"    return ret_attrp;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:337
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* задаёт &attr, если мы\n"
"                                        инициализируем объект\n"
"                                        атрибутов нити */\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:339
#, no-wrap
msgid "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"
msgstr "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:345
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        printf(\"Объект атрибутов нити после инициализации:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:349
#, no-wrap
msgid ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:355
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:358
#, no-wrap
msgid ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"
msgstr ""
"    pause();    /* Завершается, когда другая нить вызывает exit() */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_np.3:374
msgid ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_SETAFFINITY_NP"
msgstr "PTHREAD_SETAFFINITY_NP"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:30
msgid ""
"pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a "
"thread"
msgstr ""
"pthread_setaffinity_np, pthread_getaffinity_np - получить/назначить "
"увязываемый ЦП для нити"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:54
msgid ""
"The B<pthread_setaffinity_np>()  function sets the CPU affinity mask of the "
"thread I<thread> to the CPU set pointed to by I<cpuset>.  If the call is "
"successful, and the thread is not currently running on one of the CPUs in "
"I<cpuset>, then it is migrated to one of those CPUs."
msgstr ""
"Функция B<pthread_setaffinity_np>() устанавливает маску увязывания ЦП для "
"нити I<thread> равной набору ЦП, указанному в I<cpuset>. Если вызов "
"выполняется без ошибок и нить не запущена ни на одном из ЦП в I<cpuset>, то "
"она перемещается на один из этих ЦП."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:61
msgid ""
"The B<pthread_getaffinity_np>()  function returns the CPU affinity mask of "
"the thread I<thread> in the buffer pointed to by I<cpuset>."
msgstr ""
"Функция B<pthread_getaffinity_np>() помещает маску увязывания ЦП для нити "
"I<thread> в буфер, на который указывает I<cpuset>."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:67
msgid ""
"For more details on CPU affinity masks, see B<sched_setaffinity>(2).  For a "
"description of a set of macros that can be used to manipulate and inspect "
"CPU sets, see B<CPU_SET>(3)."
msgstr ""
"Дополнительную информацию по маскам увязывания ЦП смотрите в "
"B<sched_setaffinity>(2). Описание набора макросов, которые можно "
"использовать для просмотра и изменения наборов ЦП, смотрите в B<CPU_SET>(3)."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:77
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>.  (It may be some other value, if using the macros "
"described in B<CPU_SET>(3)  for dynamically allocating a CPU set.)"
msgstr ""
"В аргументе I<cpusetsize> указывается длина буфера (в байтах), на который "
"указывает I<cpuset>. Обычно, этот аргумент должен задаваться как "
"I<sizeof(cpu_set_t)> (он может иметь и другое значение, если используются "
"макросы динамического выделения набора ЦП, описанные в B<CPU_SET>(3))."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:80
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number."
msgstr ""
"При успешном выполнении эти функции возвращают 0; при ошибке возвращается "
"ненулевой номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:84
msgid "A supplied memory address was invalid."
msgstr "Указан некорректный адрес памяти."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:93
msgid ""
"(B<pthread_setaffinity_np>())  The affinity bit mask I<mask> contains no "
"processors that are currently physically on the system and permitted to the "
"thread according to any restrictions that may be imposed by the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""
"(B<pthread_setaffinity_np>()) В маске увязывания ЦП I<mask> указаны "
"процессоры, которых физически нет в системе, и которые разрешены нити "
"согласно любым ограничениям, которые могут налагаться механизмом «cpuset», "
"описанном в B<cpuset>(7)."

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:105
msgid ""
"(B<pthread_setaffinity_np>())  I<cpuset> specified a CPU that was outside "
"the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""
"(B<pthread_setaffinity_np>()) В I<cpuset> указан ЦП, который находится вне "
"набора поддерживаемых ядром (в параметре сборки ядра B<CONFIG_NR_CPUS> "
"определён диапазон для набора, поддерживаемого типом данных ядра, который "
"используется для представления наборов ЦП)."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:110
msgid ""
"(B<pthread_getaffinity_np>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""
"(B<pthread_getaffinity_np>()) Значение I<cpusetsize> меньше размера маски "
"увязывания, используемой в ядре."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:117
msgid "These functions are provided by glibc since version 2.3.4."
msgstr "Эти функции определены в glibc начиная с версии 2.3.4."

#. type: tbl table
#: man-pages/man3/pthread_setaffinity_np.3:128
#, no-wrap
msgid ""
"B<pthread_setaffinity_np>(),\n"
"B<pthread_getaffinity_np>()"
msgstr ""
"B<pthread_setaffinity_np>(),\n"
"B<pthread_getaffinity_np>()"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:133
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in the names."
msgstr ""
"Данные функции являются не стандартизированными расширениями GNU, о чём "
"свидетельствует наличие суффикса «_np» (nonportable)."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:146
msgid ""
"After a call to B<pthread_setaffinity_np>(), the set of CPUs on which the "
"thread will actually run is the intersection of the set specified in the "
"I<cpuset> argument and the set of CPUs actually present on the system.  The "
"system may further restrict the set of CPUs on which the thread runs if the "
"\"cpuset\" mechanism described in B<cpuset>(7)  is being used.  These "
"restrictions on the actual set of CPUs on which the thread will run are "
"silently imposed by the kernel."
msgstr ""
"После вызова B<pthread_setaffinity_np>() набор процессоров, на которых "
"действительно будет выполняться нить, вычисляется пересечением набора из "
"аргумента I<cpuset> и набором процессоров, присутствующих в системе. В "
"дальнейшем, система может ограничить набор процессоров нити, если "
"задействован механизм «cpuset», описанный в B<cpuset>(7). Эти ограничения на "
"действительный набор процессоров, используемых для нити, без уведомления "
"налагаются ядром."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:152
msgid ""
"These functions are implemented on top of the B<sched_setaffinity>(2)  and "
"B<sched_getaffinity>(2)  system calls."
msgstr ""
"Эти функции реализованы через системные вызовы B<sched_setaffinity>(2) и "
"B<sched_getaffinity>(2)."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:159
msgid ""
"In glibc 2.3.3 only, versions of these functions were provided that did not "
"have a I<cpusetsize> argument.  Instead the CPU set size given to the "
"underlying system calls was always I<sizeof(cpu_set_t)>."
msgstr ""
"В glibc 2.3.3 версии этих функций не имеют аргумента I<cpusetsize>. Вместо "
"него размер набора ЦП, передаваемый используемым системным вызовам, всегда "
"равен I<sizeof(cpu_set_t)>."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:163
msgid ""
"A new thread created by B<pthread_create>(3)  inherits a copy of its "
"creator's CPU affinity mask."
msgstr ""
"Новая нить, созданная B<pthread_create>(3), наследует копию маски увязывания "
"ЦП своего создателя."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:171
msgid ""
"In the following program, the main thread uses B<pthread_setaffinity_np>()  "
"to set its CPU affinity mask to include CPUs 0 to 7 (which may not all be "
"available on the system), and then calls B<pthread_getaffinity_np>()  to "
"check the resulting CPU affinity mask of the thread."
msgstr ""
"В этой программе главная нить использует B<pthread_setaffinity_np>() для "
"включения в свою маску увязывания ЦП  процессоры с 0 по 7 (которых может не "
"быть в системе), а затем вызывает B<pthread_getaffinity_np>() для проверки "
"получившейся маски увязывания ЦП у нити."

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:178
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:188
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, j;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, j;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:190
#, no-wrap
msgid "    thread = pthread_self();\n"
msgstr "    thread = pthread_self();\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:192
#, no-wrap
msgid "    /* Set affinity mask to include CPUs 0 to 7 */\n"
msgstr "    /* включаем ЦП с 0 по 7 в маску увязывания */\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:196
#, no-wrap
msgid ""
"    CPU_ZERO(&cpuset);\n"
"    for (j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"
msgstr ""
"    CPU_ZERO(&cpuset);\n"
"    for (j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:200
#, no-wrap
msgid ""
"    s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"
msgstr ""
"    s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:202
#, no-wrap
msgid "    /* Check the actual affinity mask assigned to the thread */\n"
msgstr "    /* проверяем маску увязывания, назначенную нити */\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:206
#, no-wrap
msgid ""
"    s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"
msgstr ""
"    s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:211
#, no-wrap
msgid ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"
msgstr ""
"    printf(\"Набор, возвращённый pthread_getaffinity_np(), содержит:\\en\");\n"
"    for (j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    ЦП %d\\en\", j);\n"

#. type: Plain text
#: man-pages/man3/pthread_setaffinity_np.3:223
msgid ""
"B<sched_setaffinity>(2), B<CPU_SET>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_self>(3), B<sched_getcpu>(3), B<cpuset>(7), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<CPU_SET>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_self>(3), B<sched_getcpu>(3), B<cpuset>(7), B<pthreads>(7), "
"B<sched>(7)"

#. type: TH
#: man-pages/man3/pthread_cleanup_push.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH"
msgstr "PTHREAD_CLEANUP_PUSH"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:30
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation "
"clean-up handlers"
msgstr ""
"pthread_cleanup_push, pthread_cleanup_pop - помещает и выталкивает очищающие "
"обработчики при отмене нити"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"
msgstr ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:48
msgid ""
"These functions manipulate the calling thread's stack of thread-cancellation "
"clean-up handlers.  A clean-up handler is a function that is automatically "
"executed when a thread is canceled (or in various other circumstances "
"described below); it might, for example, unlock a mutex so that it becomes "
"available to other threads in the process."
msgstr ""
"Данные функции управляют стеком нити, вызывающим очищающие обработчики при "
"отмене нити. Очищающий обработчик — это функция, которая автоматически "
"вызывается при отмене нити (или в при других обстоятельствах, описанных "
"ниже); это может быть, например, отмена блокировки мьютекса, при которой он "
"становится доступным другим нитям процесса."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:59
msgid ""
"The B<pthread_cleanup_push>()  function pushes I<routine> onto the top of "
"the stack of clean-up handlers.  When I<routine> is later invoked, it will "
"be given I<arg> as its argument."
msgstr ""
"Функция B<pthread_cleanup_push>() помещает обработчик I<routine> наверх "
"стека очищающих обработчиков. Позднее, при вызове I<routine>, ему будет "
"передан I<arg> в качестве аргумента."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:66
msgid ""
"The B<pthread_cleanup_pop>()  function removes the routine at the top of the "
"stack of clean-up handlers, and optionally executes it if I<execute> is "
"nonzero."
msgstr ""
"Функция B<pthread_cleanup_pop>() удаляет обработчик с вершины стека "
"очищающих обработчиков, и, возможно, выполняет его, если I<execute> не равно "
"нулю."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:69
msgid ""
"A cancellation clean-up handler is popped from the stack and executed in the "
"following circumstances:"
msgstr ""
"Очищающий обработчик при отмене выталкивается из стека и выполняется при "
"следующих условиях:"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:73
msgid ""
"When a thread is canceled, all of the stacked clean-up handlers are popped "
"and executed in the reverse of the order in which they were pushed onto the "
"stack."
msgstr ""
"Когда нить отменяется, все очищающие обработчики из стека выталкиваются и "
"вызываются в обратном порядке их помещения в стек."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:83
msgid ""
"When a thread terminates by calling B<pthread_exit>(3), all clean-up "
"handlers are executed as described in the preceding point.  (Clean-up "
"handlers are I<not> called if the thread terminates by performing a "
"I<return> from the thread start function.)"
msgstr ""
"Когда нить завершается вызовом B<pthread_exit>(3), все очищающие обработчики "
"выполняются как описано в предыдущем пункте (очищающие обработчики I<не> "
"вызываются, если нить завершается I<возвратом> из начальной функции нити)."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:89
msgid ""
"When a thread calls B<pthread_cleanup_pop>()  with a nonzero I<execute> "
"argument, the top-most clean-up handler is popped and executed."
msgstr ""
"Когда нить вызывает B<pthread_cleanup_pop>() с ненулевым значением аргумента "
"I<execute>, самый верхний очищающий обработчик выталкивается и выполняется."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:101
msgid ""
"POSIX.1 permits B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  to "
"be implemented as macros that expand to text containing \\(aqB<{>\\(aq and "
"\\(aqB<}>\\(aq, respectively.  For this reason, the caller must ensure that "
"calls to these functions are paired within the same function, and at the "
"same lexical nesting level.  (In other words, a clean-up handler is "
"established only during the execution of a specified section of code.)"
msgstr ""
"В POSIX.1 допускается реализация B<pthread_cleanup_push>() и "
"B<pthread_cleanup_pop>() в виде макросов, которые раскрывают текст, "
"содержащий \\(aqB<{>\\(aq и \\(aqB<}>\\(aq, соответственно. По этой причине, "
"вызывающий должен убедиться, что вызовы этих функций используются парно в "
"одной функции и на одном лексическом уровне вложенности (другими словами, "
"очищающий обработчик устанавливается только во время выполнения определённой "
"секции кода)."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:121
msgid ""
"Calling B<longjmp>(3)  (B<siglongjmp>(3))  produces undefined results if any "
"call has been made to B<pthread_cleanup_push>()  or "
"B<pthread_cleanup_pop>()  without the matching call of the pair since the "
"jump buffer was filled by B<setjmp>(3)  (B<sigsetjmp>(3)).  Likewise, "
"calling B<longjmp>(3)  (B<siglongjmp>(3))  from inside a clean-up handler "
"produces undefined results unless the jump buffer was also filled by "
"B<setjmp>(3)  (B<sigsetjmp>(3))  inside the handler."
msgstr ""
"Вызов B<longjmp>(3)  (B<siglongjmp>(3)) приводит к непредсказуемым "
"результатам, если был сделан любой вызов в B<pthread_cleanup_push>() или "
"B<pthread_cleanup_pop>() без соответствующего вызову пары, так как буфер "
"перехода (jump buffer) был заполнен B<setjmp>(3)  (B<sigsetjmp>(3)). "
"Подобным образом, вызов B<longjmp>(3)  (B<siglongjmp>(3)) изнутри очищающего "
"обработчика приводит к непредсказуемым результатам, если буфер перехода "
"также не был заполнен B<setjmp>(3) (B<sigsetjmp>(3)) внутри обработчика."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:123
msgid "These functions do not return a value."
msgstr "Данные функции не возвращают никаких значений."

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:127
msgid "There are no errors."
msgstr "Эти функции не вызывают ошибок."

#. type: tbl table
#: man-pages/man3/pthread_cleanup_push.3:138
#, no-wrap
msgid ""
"B<pthread_cleanup_push>(),\n"
"B<pthread_cleanup_pop>()"
msgstr ""
"B<pthread_cleanup_push>(),\n"
"B<pthread_cleanup_pop>()"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:154
msgid ""
"On Linux, the B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  "
"functions I<are> implemented as macros that expand to text containing "
"\\(aqB<{>\\(aq and \\(aqB<}>\\(aq, respectively.  This means that variables "
"declared within the scope of paired calls to these functions will be visible "
"within only that scope."
msgstr ""
"В Linux, функции B<pthread_cleanup_push>() и B<pthread_cleanup_pop>() "
"реализованы в виде макросов, которые расширяются до текста, содержащего "
"\\(aqB<{>\\(aq и \\(aqB<}>\\(aq, соответственно. Это означает, что "
"переменные, объявленные внутри области парных вызовов этих функций, будут "
"видимы внутри только этой области."

#.  The text was actually added in the 2004 TC2
#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:169
msgid ""
"POSIX.1 says that the effect of using I<return>, I<break>, I<continue>, or "
"I<goto> to prematurely leave a block bracketed B<pthread_cleanup_push>()  "
"and B<pthread_cleanup_pop>()  is undefined.  Portable applications should "
"avoid doing this."
msgstr ""
"В POSIX.1 сказано, что результат использования I<return>, I<break>, "
"I<continue> или I<goto> для преждевременного оставления блока, окружающего "
"B<pthread_cleanup_push>()  и B<pthread_cleanup_pop>(), не определён. В "
"переносимых приложениях не нужно так делать."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:184
msgid ""
"The program below provides a simple example of the use of the functions "
"described in this page.  The program creates a thread that executes a loop "
"bracketed by B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>().  This "
"loop increments a global variable, I<cnt>, once each second.  Depending on "
"what command-line arguments are supplied, the main thread sends the other "
"thread a cancellation request, or sets a global variable that causes the "
"other thread to exit its loop and terminate normally (by doing a I<return>)."
msgstr ""
"Далее показан простой пример использования функций, описанных на этой "
"странице. Программа создаёт нить, которая выполняет цикл обрамлённый "
"B<pthread_cleanup_push>() и B<pthread_cleanup_pop>(). В этом цикле каждую "
"секунду увеличивается глобальная переменная I<cnt>. В зависимости от "
"аргументов командной строки главная нить посылает другой нити запрос на "
"отмену или изменяет глобальную переменную, что заставляет другую нить выйти "
"из цикла и завершить работу (с помощью I<return>)."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:187
msgid ""
"In the following shell session, the main thread sends a cancellation request "
"to the other thread:"
msgstr "В этом сеансе главная нить посылает запрос отмены другой нити:"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:197
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"
msgstr ""
"$ B<./a.out>\n"
"Запущена новая нить\n"
"cnt = 0\n"
"cnt = 1\n"
"Отменяем нить\n"
"Вызван очищающий обработчик\n"
"Нить отменена; cnt = 0\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:205
msgid ""
"From the above, we see that the thread was canceled, and that the "
"cancellation clean-up handler was called and it reset the value of the "
"global variable I<cnt> to 0."
msgstr ""
"Здесь мы видим, что нить была отменена и что был вызван очищающий обработчик "
"и он сбросил значение глобальной переменной I<cnt> в 0."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:208
msgid ""
"In the next run, the main program sets a global variable that causes other "
"thread to terminate normally:"
msgstr ""
"В следующем сеансе главная программа изменяет глобальную переменную, что "
"вызывает штатное завершение другой нити:"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:216
#, no-wrap
msgid ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"
msgstr ""
"$ B<./a.out x>\n"
"Запущена новая нить\n"
"cnt = 0\n"
"cnt = 1\n"
"Нить завершилась штатным образом; cnt = 2\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:224
msgid ""
"From the above, we see that the clean-up handler was not executed (because "
"I<cleanup_pop_arg> was 0), and therefore the value of I<cnt> was not reset."
msgstr ""
"Здесь мы видим, что очищающий обработчик не вызывался (так как "
"I<cleanup_pop_arg> равно 0), и поэтому значение I<cnt> не сброшено."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:229
msgid ""
"In the next run, the main program sets a global variable that causes the "
"other thread to terminate normally, and supplies a nonzero value for "
"I<cleanup_pop_arg>:"
msgstr ""
"В следующем сеансе главная программа изменяет глобальную переменную, что "
"вызывает штатное завершение другой нити, передаёт ненулевое значение в "
"I<cleanup_pop_arg>:"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:238
#, no-wrap
msgid ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"
msgstr ""
"$ B<./a.out x 1>\n"
"Запущена новая нить\n"
"cnt = 0\n"
"cnt = 1\n"
"Вызван очищающий обработчик\n"
"Нить завершилась штатным образом; cnt = 0\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:245
msgid ""
"In the above, we see that although the thread was not canceled, the clean-up "
"handler was executed, because the argument given to "
"B<pthread_cleanup_pop>()  was nonzero."
msgstr ""
"Здесь мы видим, что хотя нить не отменена, всё же вызван очищающий "
"обработчик, так как в B<pthread_cleanup_pop>() передан ненулевой аргумент."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:254
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:261
#, no-wrap
msgid ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"
msgstr ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:268
#, no-wrap
msgid ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"
msgstr ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Вызван очищающий обработчик\\en\");\n"
"    cnt = 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:273
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:275
#, no-wrap
msgid "    printf(\"New thread started\\en\");\n"
msgstr "    printf(\"Запущена новая нить\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:277
#, no-wrap
msgid "    pthread_cleanup_push(cleanup_handler, NULL);\n"
msgstr "    pthread_cleanup_push(cleanup_handler, NULL);\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:279
#, no-wrap
msgid "    curr = start = time(NULL);\n"
msgstr "    curr = start = time(NULL);\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:288
#, no-wrap
msgid ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (!done) {\n"
"        pthread_testcancel();           /* точка отмены */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* точка отмены */\n"
"            cnt++;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:292
#, no-wrap
msgid ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:299
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:303
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:305
#, no-wrap
msgid "    sleep(2);           /* Allow new thread to run a while */\n"
msgstr "    sleep(2);           /* даём время нити запуститься */\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:310
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:317
#, no-wrap
msgid ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"
msgstr ""
"    } else {\n"
"        printf(\"Отменяем нить\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:328
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Нить была отменена; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Нить завершилась штатным образом; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push.3:334
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_equal.3:26
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr "PTHREAD_EQUAL"

#. type: Plain text
#: man-pages/man3/pthread_equal.3:29
msgid "pthread_equal - compare thread IDs"
msgstr "pthread_equal - сравнивает идентификаторы нитей"

#. type: Plain text
#: man-pages/man3/pthread_equal.3:34
#, no-wrap
msgid "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"
msgstr "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_equal.3:41
msgid "The B<pthread_equal>()  function compares two thread identifiers."
msgstr "Функция B<pthread_equal>() два идентификатора нитей."

#. type: Plain text
#: man-pages/man3/pthread_equal.3:45
msgid ""
"If the two thread IDs are equal, B<pthread_equal>()  returns a nonzero "
"value; otherwise, it returns 0."
msgstr ""
"Если два идентификатора нитей одинаковы, то B<pthread_equal>() возвращает "
"ненулевое значение; в противном случае возвращается 0."

#. type: tbl table
#: man-pages/man3/pthread_equal.3:57
#, no-wrap
msgid "B<pthread_equal>()"
msgstr "B<pthread_equal>()"

#. type: Plain text
#: man-pages/man3/pthread_equal.3:68
msgid ""
"The B<pthread_equal>()  function is necessary because thread IDs should be "
"considered opaque: there is no portable way for applications to directly "
"compare two I<pthread_t> values."
msgstr ""
"Функция B<pthread_equal>() необходима, так как формат идентификаторов нитей "
"следует считать «чёрным ящиком»: не существует переносимого способа "
"сравнения двух непосредственно значений I<pthread_t> из приложения."

#. type: Plain text
#: man-pages/man3/pthread_equal.3:71
msgid "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/psignal.3:30
#, no-wrap
msgid "PSIGNAL"
msgstr "PSIGNAL"

#. type: Plain text
#: man-pages/man3/psignal.3:33
msgid "psignal, psiginfo - print signal message"
msgstr "psignal, psiginfo - выводит сообщение о сигнале"

#. type: Plain text
#: man-pages/man3/psignal.3:36
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/psignal.3:39
#, no-wrap
msgid ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"
msgstr ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/psignal.3:41
#, no-wrap
msgid "B<extern const char *const >I<sys_siglist>B<[];>\n"
msgstr "B<extern const char *const >I<sys_siglist>B<[];>\n"

#. type: Plain text
#: man-pages/man3/psignal.3:53
#, no-wrap
msgid ""
"B<psignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<psignal>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/psignal.3:56
msgid "B<psiginfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "B<psiginfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man3/psignal.3:62
#, no-wrap
msgid ""
"I<sys_siglist>:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<sys_siglist>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/psignal.3:71
msgid ""
"The B<psignal>()  function displays a message on I<stderr> consisting of the "
"string I<s>, a colon, a space, a string describing the signal number I<sig>, "
"and a trailing newline.  If the string I<s> is NULL or empty, the colon and "
"space are omitted.  If I<sig> is invalid, the message displayed will "
"indicate an unknown signal."
msgstr ""
"Функция B<psignal>() выводит сообщение в I<stderr>, состоящее из строки "
"I<s>, двоеточия, пробела, строки описания номера сигнала I<sig> и конечного "
"символа новой строки. Если строка I<s> равна NULL или пуста, то двоеточие и "
"пробел не выводятся. Если значение I<sig> некорректно, то выводится "
"сообщение о неизвестном сигнале."

#. type: Plain text
#: man-pages/man3/psignal.3:92
msgid ""
"The B<psiginfo>()  function is like B<psignal>(), except that it displays "
"information about the signal described by I<pinfo>, which should point to a "
"valid I<siginfo_t> structure.  As well as the signal description, "
"B<psiginfo>()  displays information about the origin of the signal, and "
"other information relevant to the signal (e.g., the relevant memory address "
"for hardware-generated signals, the child process ID for B<SIGCHLD>, and the "
"user ID and process ID of the sender, for signals set using B<kill>(2)  or "
"B<sigqueue>(3))."
msgstr ""
"Функция B<psiginfo>() подобна B<psignal>(), но выводит информацию о сигнале, "
"указанном в аргументе I<pinfo>, который должен указывать на корректную "
"структуры I<siginfo_t>. Кроме описания сигнала B<psiginfo>() выводит "
"информацию об источнике сигнала и другую информацию о сигнале (например, "
"соответствующий адрес памяти, в случае аппаратных сигналов, идентификатор "
"процесса-потомка для B<SIGCHLD> и идентификаторы пользователя и процесса "
"отправителя для сигналов, посланных с помощью B<kill>(2) или B<sigqueue>(3))."

#. type: Plain text
#: man-pages/man3/psignal.3:95
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number."
msgstr ""
"В массиве I<sys_siglist> содержатся строки описаний сигналов, упорядоченные "
"по номеру сигнала."

#. type: Plain text
#: man-pages/man3/psignal.3:101
msgid "The B<psignal>()  and B<psiginfo>()  functions return no value."
msgstr "Функции B<psignal>() и B<psiginfo>() ничего не возвращают."

#. type: Plain text
#: man-pages/man3/psignal.3:105
msgid "The B<psiginfo>()  function was added to glibc in version 2.10."
msgstr "Функция B<psiginfo>() впервые появилась в glibc 2.10."

#. type: tbl table
#: man-pages/man3/psignal.3:116
#, no-wrap
msgid ""
"B<psignal>(),\n"
"B<psiginfo>()"
msgstr ""
"B<psignal>(),\n"
"B<psiginfo>()"

#. type: tbl table
#: man-pages/man3/psignal.3:116
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: man-pages/man3/psignal.3:121
msgid "POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: man-pages/man3/psignal.3:125
msgid "In glibc versions up to 2.12, B<psiginfo>()  had the following bugs:"
msgstr "В glibc до версии 2.12, в B<psiginfo>() были следующие дефекты:"

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12107
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: man-pages/man3/psignal.3:129
msgid "In some circumstances, a trailing newline is not printed."
msgstr "При определённых условиях не выводился символ новой строки."

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=12108
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: man-pages/man3/psignal.3:133
msgid "Additional details are not displayed for real-time signals."
msgstr ""
"Для сигналов реального времени не выводилась дополнительная информация."

#. type: Plain text
#: man-pages/man3/psignal.3:137
msgid "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/pow.3:35
#, no-wrap
msgid "POW"
msgstr "POW"

#. type: Plain text
#: man-pages/man3/pow.3:38
msgid "pow, powf, powl - power functions"
msgstr "pow, powf, powl - функции возведения в степень"

#. type: Plain text
#: man-pages/man3/pow.3:41
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pow.3:45
#, no-wrap
msgid ""
"B<double pow(double >I<x>B<, double >I<y>B<);>\n"
"B<float powf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double powl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"B<double pow(double >I<x>B<, double >I<y>B<);>\n"
"B<float powf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double powl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow.3:48
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/pow.3:57
msgid "B<powf>(), B<powl>():"
msgstr "B<powf>(), B<powl>():"

#. type: Plain text
#: man-pages/man3/pow.3:61
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/pow.3:69
msgid "These functions return the value of I<x> raised to the power of I<y>."
msgstr "Данные функции возвращают значение I<x>, возведённое в степень I<y>."

#. type: Plain text
#: man-pages/man3/pow.3:74
msgid ""
"On success, these functions return the value of I<x> to the power of I<y>."
msgstr ""
"При успешном выполнении данные функции возвращают значение I<x>, возведённое "
"в степень I<y>."

#.  The domain error is generated at least as far back as glibc 2.4
#. type: Plain text
#: man-pages/man3/pow.3:82
msgid ""
"If I<x> is a finite value less than 0, and I<y> is a finite noninteger, a "
"domain error occurs, and a NaN is returned."
msgstr ""
"Если I<x> — конечное значение меньшее 0 и I<y> — конечное не целое, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата "
"будет возвращено NaN."

#.  The range error is generated at least as far back as glibc 2.4
#. type: Plain text
#: man-pages/man3/pow.3:92
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the "
"mathematically correct sign."
msgstr ""
"Если происходит переполнение результата, возникает ошибка диапазона, а "
"функция возвращает B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, "
"соответственно, с математически правильным знаком."

#.  POSIX.1 does not specify the sign of the zero,
#.  but http://sources.redhat.com/bugzilla/show_bug.cgi?id=2678
#.  points out that the zero has the wrong sign in some cases.
#. type: Plain text
#: man-pages/man3/pow.3:99
msgid ""
"If result underflows, and is not representable, a range error occurs, and "
"0.0 is returned."
msgstr ""
"Если в результате исчерпана степень числа и оно не представимо, то возникает "
"ошибка диапазона и возвращается 0.0."

#. type: Plain text
#: man-pages/man3/pow.3:105
msgid ""
"Except as specified below, if I<x> or I<y> is a NaN, the result is a NaN."
msgstr ""
"За исключениями, указанными далее, если значение I<x> или I<y> равно NaN, то "
"результат равен NaN."

#. type: Plain text
#: man-pages/man3/pow.3:111
msgid "If I<x> is +1, the result is 1.0 (even if I<y> is a NaN)."
msgstr "Если I<x> равно +1, то результат равен 1.0 (даже если I<y> равно NaN)."

#. type: Plain text
#: man-pages/man3/pow.3:117
msgid "If I<y> is 0, the result is 1.0 (even if I<x> is a NaN)."
msgstr "Если I<y> равно 0, то результат равен 1.0 (даже если I<x> равно NaN)."

#. type: Plain text
#: man-pages/man3/pow.3:125
msgid ""
"If I<x> is +0 (-0), and I<y> is an odd integer greater than 0, the result is "
"+0 (-0)."
msgstr ""
"Если I<x> равно +0 (-0) и I<y> — нечётное целое большее 0, то результат "
"равен +0 (-0)."

#. type: Plain text
#: man-pages/man3/pow.3:133
msgid ""
"If I<x> is 0, and I<y> greater than 0 and not an odd integer, the result is "
"+0."
msgstr ""
"Если I<x> равно 0 и I<y> больше 0 и не чётное целое, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:141
msgid ""
"If I<x> is -1, and I<y> is positive infinity or negative infinity, the "
"result is 1.0."
msgstr ""
"Если I<x> равно -1 и I<y> стремится к плюс или минус бесконечности, то "
"результат равен 1.0."

#. type: Plain text
#: man-pages/man3/pow.3:149
msgid ""
"If the absolute value of I<x> is less than 1, and I<y> is negative infinity, "
"the result is positive infinity."
msgstr ""
"Если абсолютное значение I<x> меньше 1 и I<y> стремится к минус "
"бесконечности, то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:157
msgid ""
"If the absolute value of I<x> is greater than 1, and I<y> is negative "
"infinity, the result is +0."
msgstr ""
"Если абсолютное значение I<x> больше 1 и I<y> стремится к минус "
"бесконечности, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:165
msgid ""
"If the absolute value of I<x> is less than 1, and I<y> is positive infinity, "
"the result is +0."
msgstr ""
"Если абсолютное значение I<x> меньше 1 и I<y> стремится к плюс "
"бесконечности, то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:173
msgid ""
"If the absolute value of I<x> is greater than 1, and I<y> is positive "
"infinity, the result is positive infinity."
msgstr ""
"Если абсолютное значение I<x> больше 1 и I<y> стремится к плюс "
"бесконечности, то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:181
msgid ""
"If I<x> is negative infinity, and I<y> is an odd integer less than 0, the "
"result is -0."
msgstr ""
"Если I<x> стремится к минус бесконечности и I<y> — нечётное целое меньшее 0, "
"то результат равен -0."

#. type: Plain text
#: man-pages/man3/pow.3:189
msgid ""
"If I<x> is negative infinity, and I<y> less than 0 and not an odd integer, "
"the result is +0."
msgstr ""
"Если I<x> стремится к минус бесконечности и I<y> — меньше 0 и чётное целое, "
"то результат равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:197
msgid ""
"If I<x> is negative infinity, and I<y> is an odd integer greater than 0, the "
"result is negative infinity."
msgstr ""
"Если I<x> стремится к минус бесконечности и I<y> — нечётное целое большее 0, "
"то результат стремится к минус бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:205
msgid ""
"If I<x> is negative infinity, and I<y> greater than 0 and not an odd "
"integer, the result is positive infinity."
msgstr ""
"Если I<x> стремится к минус бесконечности и I<y> — больше 0 и чётное целое, "
"то результат стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:213
msgid "If I<x> is positive infinity, and I<y> less than 0, the result is +0."
msgstr ""
"Если I<x> стремится к плюс бесконечности и I<y> — меньше 0, то результат "
"равен +0."

#. type: Plain text
#: man-pages/man3/pow.3:221
msgid ""
"If I<x> is positive infinity, and I<y> greater than 0, the result is "
"positive infinity."
msgstr ""
"Если I<x> стремится к плюс бесконечности и I<y> — больше 0, то результат "
"стремится к плюс бесконечности."

#. type: Plain text
#: man-pages/man3/pow.3:236
msgid ""
"If I<x> is +0 or -0, and I<y> is an odd integer less than 0, a pole error "
"occurs and B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, is returned, with the "
"same sign as I<x>."
msgstr ""
"Если I<x> равно +0 или -0 и I<y> — нечётное целое меньшее 0, то генерируется "
"ошибка особой точки и возвращается B<HUGE_VAL>, B<HUGE_VALF> или "
"B<HUGE_VALL>с тем же знаком что и у I<x>."

#.  The pole error is generated at least as far back as glibc 2.4
#. type: Plain text
#: man-pages/man3/pow.3:250
msgid ""
"If I<x> is +0 or -0, and I<y> is less than 0 and not an odd integer, a pole "
"error occurs and +B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, is returned."
msgstr ""
"Если I<x> равно + или -0 и I<y> — меньше 0 и чётное целое, то генерируется "
"ошибка особой точки и возвращается +B<HUGE_VAL>, +B<HUGE_VALF> или "
"+B<HUGE_VALL>."

#.  FIXME . review status of this error
#.  longstanding bug report for glibc:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=369
#.  For negative x, and -large and +large y, glibc 2.8 gives incorrect
#.  results
#.  pow(-0.5,-DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-overflow (ERANGE, FE_OVERFLOW); +INF)
#.  pow(-1.5,-DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-underflow (ERANGE, FE_UNDERFLOW); +0)
#.  pow(-0.5,DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-underflow (ERANGE, FE_UNDERFLOW); +0)
#.  pow(-1.5,DBL_MAX)=nan
#.  EDOM FE_INVALID nan; fail-errno fail-except fail-result;
#.  FAIL (expected: range-error-overflow (ERANGE, FE_OVERFLOW); +INF)
#. type: Plain text
#: man-pages/man3/pow.3:275
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, где возникла ошибка при вызове "
"этих функций."

#. type: Plain text
#: man-pages/man3/pow.3:277
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/pow.3:277
#, no-wrap
msgid "Domain error: I<x> is negative, and I<y> is a finite noninteger"
msgstr "Ошибка области: I<x> является отрицательным и I<y> конечное нецелое"

#. type: Plain text
#: man-pages/man3/pow.3:285
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM>. Возникает исключение неправильной "
"плавающей запятой (B<FE_INVALID>)."

#. type: TP
#: man-pages/man3/pow.3:285
#, no-wrap
msgid "Pole error: I<x> is zero, and I<y> is negative"
msgstr "Ошибка особой точки: I<x> равно нулю и I<y> отрицательно"

#. type: Plain text
#: man-pages/man3/pow.3:294
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  A divide-by-zero floating-"
"point exception (B<FE_DIVBYZERO>)  is raised."
msgstr ""
"I<errno> устанавливается в B<ERANGE> (но смотрите ДЕФЕКТЫ). Возникает "
"исключение деления плавающей запятой на ноль (B<FE_DIVBYZERO>)."

#. type: TP
#: man-pages/man3/pow.3:294
#, no-wrap
msgid "Range error: the result overflows"
msgstr "Ошибка диапазона: результат превысил разрядность"

#. type: Plain text
#: man-pages/man3/pow.3:302
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"переполнения плавающей запятой (B<FE_OVERFLOW>)."

#. type: TP
#: man-pages/man3/pow.3:302
#, no-wrap
msgid "Range error: the result underflows"
msgstr "Ошибка диапазона: результат исчерпал степень"

#. type: Plain text
#: man-pages/man3/pow.3:310
msgid ""
"I<errno> is set to B<ERANGE>.  An underflow floating-point exception "
"(B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"исчерпания степени чисел с плавающей запятой (B<FE_UNDERFLOW>)."

#. type: tbl table
#: man-pages/man3/pow.3:322
#, no-wrap
msgid ""
"B<pow>(),\n"
"B<powf>(),\n"
"B<powl>()"
msgstr ""
"B<pow>(),\n"
"B<powf>(),\n"
"B<powl>()"

#. type: Plain text
#: man-pages/man3/pow.3:326
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/pow.3:331
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""
"Вариант, возвращающий значение типа I<double>, также соответствует SVr4, "
"4.3BSD, C89."

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=13932
#. type: Plain text
#: man-pages/man3/pow.3:344
msgid ""
"On 64-bits, B<pow>()  may be more than 10,000 times slower for some (rare) "
"inputs than for other nearby inputs.  This affects only B<pow>(), and not "
"B<powf>()  nor B<powl>()."
msgstr ""
"На 64-битных архитектурах B<pow>() может быть медленнее более чем в 10000 "
"раз для некоторых значений (очень редких). Это происходит только с B<pow>(), "
"и отсутствует у B<powf>() и B<powl>()."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6776
#.  or possibly 2.9, I haven't found the source code change
#.  and I don't have a 2.9 system to test
#. type: Plain text
#: man-pages/man3/pow.3:358
msgid ""
"In glibc 2.9 and earlier, when a pole error occurs, I<errno> is set to "
"B<EDOM> instead of the POSIX-mandated B<ERANGE>.  Since version 2.10, glibc "
"does the right thing."
msgstr ""
"В glibc 2.9 и ранее при возникновении ошибки особой точки, значению I<errno> "
"присваивается B<EDOM> вместо B<ERANGE> согласно POSIX. Начиная с версии "
"2.10, в glibc это исправлено."

#.  see bug http://sources.redhat.com/bugzilla/show_bug.cgi?id=3866
#.  and http://sources.redhat.com/bugzilla/show_bug.cgi?id=369
#. type: Plain text
#: man-pages/man3/pow.3:378
msgid ""
"If I<x> is negative, then large negative or positive I<y> values yield a NaN "
"as the function result, with I<errno> set to B<EDOM>, and an invalid "
"(B<FE_INVALID>)  floating-point exception.  For example, with B<pow>(), one "
"sees this behavior when the absolute value of I<y> is greater than about "
"9.223373e18."
msgstr ""
"Если I<x> отрицательно, то большие отрицательные или положительные значения "
"I<y> приводят к результату NaN, с присвоением I<errno> значения B<EDOM> или  "
"исключению неправильной плавающей запятой (B<FE_INVALID>). Например для "
"B<pow>() такое случает когда абсолютное значение I<y> больше 9.223373e18."

#.  FIXME . Actually, 2.3.2 is the earliest test result I have; so yet
#.  to confirm if this error occurs only in 2.3.2.
#. type: Plain text
#: man-pages/man3/pow.3:387
msgid ""
"In version 2.3.2 and earlier, when an overflow or underflow error occurs, "
"glibc's B<pow>()  generates a bogus invalid floating-point exception "
"(B<FE_INVALID>)  in addition to the overflow or underflow exception."
msgstr ""
"В glibc версии 2.3.2 или старее при возникновении ошибки переполнения или "
"исчерпания, функция B<pow>() в дополнение к исключениям переполнения и "
"исчерпания генерирует необоснованное исключение неправильной плавающей "
"запятой (B<FE_INVALID>) "

#. type: Plain text
#: man-pages/man3/pow.3:390
msgid "B<cbrt>(3), B<cpow>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cpow>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/pthread_attr_setstacksize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKSIZE"
msgstr "PTHREAD_ATTR_SETSTACKSIZE"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:30
msgid ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - изменяет/возвращает "
"атрибут размера стека у объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(const pthread_attr_t *>I<attr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(const pthread_attr_t *>I<attr>B<, size_t *>I<stacksize>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:49
msgid ""
"The B<pthread_attr_setstacksize>()  function sets the stack size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<stacksize>."
msgstr ""
"Функция B<pthread_attr_setstacksize>() изменяет атрибут размера стека у "
"объекта атрибутов нити, на который указывает I<attr>, в значение "
"I<stacksize>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:53
msgid ""
"The stack size attribute determines the minimum size (in bytes) that will be "
"allocated for threads created using the thread attributes object I<attr>."
msgstr ""
"Атрибутом размера стека определяется минимальный размер (в байтах), который "
"будет выделен для нитей, созданных с учётом объекта атрибутов нити I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:61
msgid ""
"The B<pthread_attr_getstacksize>()  function returns the stack size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stacksize>."
msgstr ""
"Функция B<pthread_attr_getstacksize>() возвращает атрибут размера стека у "
"объекта атрибутов нити, на который указывает I<attr>, в буфер на который "
"указывает I<stacksize>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:67
msgid "B<pthread_attr_setstacksize>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_attr_setstacksize>() может завершиться со следующей "
"ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:72
msgid "The stack size is less than B<PTHREAD_STACK_MIN> (16384) bytes."
msgstr "Размер стека меньше B<PTHREAD_STACK_MIN> (16384) байт."

#.  e.g., MacOS
#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:81
msgid ""
"On some systems, B<pthread_attr_setstacksize>()  can fail with the error "
"B<EINVAL> if I<stacksize> is not a multiple of the system page size."
msgstr ""
"В некоторых системах B<pthread_attr_setstacksize>() может завершиться "
"ошибкой B<EINVAL>, если значение I<stacksize> не кратно размеру системной "
"страницы."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:83
msgid "These functions are provided by glibc since version 2.1."
msgstr "Эти функции доступны в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/pthread_attr_setstacksize.3:94
#, no-wrap
msgid ""
"B<pthread_attr_setstacksize>(),\n"
"B<pthread_attr_getstacksize>()"
msgstr ""
"B<pthread_attr_setstacksize>(),\n"
"B<pthread_attr_getstacksize>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:101
msgid ""
"For details on the default stack size of new threads, see "
"B<pthread_create>(3)."
msgstr ""
"Подробную информацию о размере стека по умолчанию для новых нитей смотрите в "
"B<pthread_create>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:104
msgid ""
"A thread's stack size is fixed at the time of thread creation.  Only the "
"main thread can dynamically grow its stack."
msgstr ""
"Размер стека нити не изменяется во время создания нити. Только главная нить "
"может динамически увеличивать свой стек."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:109
msgid ""
"The B<pthread_attr_setstack>(3)  function allows an application to set both "
"the size and location of a caller-allocated stack that is to be used by a "
"thread."
msgstr ""
"Функция B<pthread_attr_setstack>(3) позволяет приложению изменять размер и "
"положение стека вызывающего, который будет использован нитью."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:121
msgid ""
"As at glibc 2.8, if the specified I<stacksize> is not a multiple of "
"B<STACK_ALIGN> (16 bytes on most architectures), it may be rounded "
"I<downward>, in violation of POSIX.1, which says that the allocated stack "
"will be at least I<stacksize> bytes."
msgstr ""
"Как указано в glibc 2.8, если указанное значение I<stacksize> не кратно "
"B<STACK_ALIGN> (для большинства архитектур 16 байт), то оно может быть "
"округлено I<в меньшую сторону>, нарушая при этом POSIX.1, где говорится, что "
"выделенный стек должен быть не менее I<stacksize> байт."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:124
msgid "See B<pthread_create>(3)."
msgstr "Смотрите B<pthread_create>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstacksize.3:130
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_atfork.3:26
#, no-wrap
msgid "PTHREAD_ATFORK"
msgstr "PTHREAD_ATFORK"

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:29
msgid "pthread_atfork - register fork handlers"
msgstr "pthread_atfork - регистрирует обработчики ветвления"

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:35
#, no-wrap
msgid ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void (*>I<parent>B<)(void),>\n"
"B<                   void (*>I<child>B<)(void));>\n"
msgstr ""
"B<int pthread_atfork(void (*>I<prepare>B<)(void), void (*>I<parent>B<)(void),>\n"
"B<                   void (*>I<child>B<)(void));>\n"

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:38
msgid "Link with I<-pthread>."
msgstr "Компонуется при указании параметра I<-pthread>."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:46
msgid ""
"The B<pthread_atfork>()  function registers fork handlers that are to be "
"executed when B<fork>(2)  is called by this thread.  The handlers are "
"executed in the context of the thread that calls B<fork>(2)."
msgstr ""
"Функция B<pthread_atfork>() регистрирует обработчик ветвления, которые будут "
"запускаться при вызове B<fork>(2) этой нитью. Обработчики запускаются в "
"контексте нити, которая вызвала B<fork>(2)."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:48
msgid "Three kinds of handler can be registered:"
msgstr "Можно регистрировать три типа обработчиков:"

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:53
msgid ""
"I<prepare> specifies a handler that is executed before B<fork>(2)  "
"processing starts."
msgstr ""
"Типом I<prepare> задаётся обработчик, который выполняется од начала работы "
"B<fork>(2)."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:58
msgid ""
"I<parent> specifies a handler that is executed in the parent process after "
"B<fork>(2)  processing completes."
msgstr ""
"Типом I<parent> задаётся обработчик, который выполняется в родительском "
"процессе после завершения работы B<fork>(2)."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:63
msgid ""
"I<child> specifies a handler that is executed in the child process after "
"B<fork>(2)  processing completes."
msgstr ""
"Типом I<child> задаётся обработчик, который выполняется в потомке после "
"завершения работы B<fork>(2)."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:68
msgid ""
"Any of the three arguments may be NULL if no handler is needed in the "
"corresponding phase of B<fork>(2)  processing."
msgstr ""
"Любой из трёх аргументов может быть равен NULL, если обработчик не требуется "
"на соответствующем шаге работы B<fork>(2)."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:84
msgid ""
"On success, B<pthread_atfork>()  returns zero.  On error, it returns an "
"error number.  B<pthread_atfork>()  may be called multiple times by a "
"thread, to register multiple handlers for each phase.  The handlers for each "
"phase are called in a specified order: the I<prepare> handlers are called in "
"reverse order of registration; the I<parent> and I<child> handlers are "
"called in the order of registration."
msgstr ""
"При успешном выполнении B<pthread_atfork>() возвращается ноль. При ошибке "
"возвращается номер ошибки. Функция B<pthread_atfork>() может быть вызвана "
"нитью несколько раз для регистрации нескольких обработчиков каждого шага. "
"Обработчики каждого шага вызываются в определённом порядке: обработчики "
"I<prepare> вызываются в порядке обратном регистрации; обработчики I<parent> "
"и I<child> вызываются в порядке их регистрации."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:88
msgid "Could not allocate memory to record the form handler entry."
msgstr "Невозможно выделить память для записи элемента обработчика."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:110
msgid ""
"When B<fork>(2)  is called in a multithreaded process, only the calling "
"thread is duplicated in the child process.  The original intention of "
"B<pthread_atfork>()  was to allow the calling thread to be returned to a "
"consistent state.  For example, at the time of the call to B<fork>(2), other "
"threads may have locked mutexes that are visible in the user-space memory "
"duplicated in the child.  Such mutexes would never be unlocked, since the "
"threads that placed the locks are not duplicated in the child.  The intent "
"of B<pthread_atfork>()  was to provide a mechanism whereby the application "
"(or a library)  could ensure that mutexes and other process and thread state "
"would be restored to a consistent state.  In practice, this task is "
"generally too difficult to be practicable."
msgstr ""
"При вызове B<fork>(2) в многонитевом процессе в дочернем процессе делается "
"копия только вызвавшей нити. Первоначальной целью B<pthread_atfork>() было "
"позволить возвращаться в вызывающей нити в целостном состоянии. Например, на "
"момент вызова B<fork>(2) другие нити могут заблокировать мьютексы, которые "
"видимы в памяти пользовательского пространства копии в потомке. Такие "
"мьютексы никогда не разблокируются, так как нити, создавшие блокировку, не "
"копируются в потомок. Целью B<pthread_atfork>() было предоставить механизм, "
"позволяющий приложению (или библиотеке) сделать так, чтобы мьютексы, другой "
"процесс и состояние нити восстанавливались бы в целостном состоянии. На "
"практике, эта задача очень сложна для реализации."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:119
msgid ""
"After a B<fork>(2)  in a multithreaded process returns in the child, the "
"child should call only async-signal-safe functions (see B<signal-"
"safety>(7))  until such time as it calls B<execve>(2)  to execute a new "
"program."
msgstr ""
"В многонитевом процессе B<fork>(2) возвращает управление в потомок; потомок "
"должен вызывать только функции async-signal-safe (смотрите B<signal-"
"safety>(7)) до момента, пока не вызовет B<execve>(2) для выполнения новой "
"программы."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:124
msgid ""
"POSIX.1 specifies that B<pthread_atfork>()  shall not fail with the error "
"B<EINTR>."
msgstr ""
"В POSIX.1 указано, что B<pthread_atfork>() не должен завершаться ошибкой "
"B<EINTR>."

#. type: Plain text
#: man-pages/man3/pthread_atfork.3:127
msgid "B<fork>(2), B<atexit>(3), B<pthreads>(7)"
msgstr "B<fork>(2), B<atexit>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pow10.3:25
#, no-wrap
msgid "POW10"
msgstr "POW10"

#. type: Plain text
#: man-pages/man3/pow10.3:28
msgid "pow10, pow10f, pow10l - base-10 power functions"
msgstr "pow10, pow10f, pow10l - функция возведения числа 10 в степень"

#. type: Plain text
#: man-pages/man3/pow10.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pow10.3:36
#, no-wrap
msgid ""
"B<double pow10(double >I<x>B<);>\n"
"B<float pow10f(float >I<x>B<);>\n"
"B<long double pow10l(long double >I<x>B<);>\n"
msgstr ""
"B<double pow10(double >I<x>B<);>\n"
"B<float pow10f(float >I<x>B<);>\n"
"B<long double pow10l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/pow10.3:42
msgid "These functions return the value of 10 raised to the power I<x>."
msgstr "Данные функции возвращают значение 10, возведённое в степень I<x>."

#. type: Plain text
#: man-pages/man3/pow10.3:50
msgid ""
"B<Note well>: These functions perform exactly the same task as the functions "
"described in B<exp10>(3), with the difference that the latter functions are "
"now standardized in TS\\ 18661-4:2015.  Those latter functions should be "
"used in preference to the functions described in this page."
msgstr ""
"B<Примечание>: Эти функции выполняют те же задачи, что и функции, описанные "
"в B<exp10>(3), с той разницей, что последние описаны в TS\\ 18661-4:2015. "
"Рекомендуется использовать последние функции, а не описанные в этой странице."

#.  glibc commit 5a80d39d0d2587e9bd8e72f19e92eeb2a66fbe9e
#. type: Plain text
#: man-pages/man3/pow10.3:55
msgid ""
"These functions first appeared in glibc in version 2.1.  Since glibc 2.27, "
"the use of these functions in new programs is no longer supported."
msgstr ""
"Эти функции впервые появились в glibc 2.1. Начиная с glibc 2.27, "
"использование данных функций в новых программах больше не поддерживается."

#. type: tbl table
#: man-pages/man3/pow10.3:67
#, no-wrap
msgid ""
"B<pow10>(),\n"
"B<pow10f>(),\n"
"B<pow10l>()"
msgstr ""
"B<pow10>(),\n"
"B<pow10f>(),\n"
"B<pow10l>()"

#. type: Plain text
#: man-pages/man3/pow10.3:71
msgid "This functions are nonstandard GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/pow10.3:73
msgid "B<exp10>(3), B<pow>(3)"
msgstr "B<exp10>(3), B<pow>(3)"

#. type: TH
#: man-pages/man3/pthread_attr_setstackaddr.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKADDR"
msgstr "PTHREAD_ATTR_SETSTACKADDR"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:30
msgid ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - изменяет/возвращает "
"атрибут адреса стека у объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(const pthread_attr_t *>I<attr>B<, void **>I<stackaddr>B<);>\n"
msgstr ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(const pthread_attr_t *>I<attr>B<, void **>I<stackaddr>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:49
msgid ""
"These functions are obsolete: B<do not use them.> Use "
"B<pthread_attr_setstack>(3)  and B<pthread_attr_getstack>(3)  instead."
msgstr ""
"Данные функции устарели: B<не используйте их>. Используйте "
"B<pthread_attr_setstack>(3) и B<pthread_attr_getstack>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:60
msgid ""
"The B<pthread_attr_setstackaddr>()  function sets the stack address "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<stackaddr>.  This attribute specifies the location of "
"the stack that should be used by a thread that is created using the thread "
"attributes object I<attr>."
msgstr ""
"Функция B<pthread_attr_setstackaddr>() изменяет атрибут адреса стека нити в "
"объекте атрибутов нити, на который указывает I<attr>, в значение "
"I<stackaddr>. Данным атрибутом задаётся расположение стека, который будет "
"использоваться нитью, созданной с учётом объекта атрибутов нити I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:66
msgid ""
"I<stackaddr> should point to a buffer of at least B<PTHREAD_STACK_MIN> bytes "
"that was allocated by the caller.  The pages of the allocated buffer should "
"be both readable and writable."
msgstr ""
"Значение I<stackaddr> должно указывать на буфер из, по крайней мере, "
"B<PTHREAD_STACK_MIN> байт, который был выделен вызывающим. Страницы "
"выделенного буфера должны быть доступны на чтение и запись."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:74
msgid ""
"The B<pthread_attr_getstackaddr>()  function returns the stack address "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stackaddr>."
msgstr ""
"Функция B<pthread_attr_getstackaddr>() возвращает атрибут адреса стека у "
"объекта атрибутов нити, на который указывает I<attr>, в буфер на который "
"указывает I<stackaddr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:81
msgid ""
"No errors are defined (but applications should nevertheless handle a "
"possible error return)."
msgstr ""
"Ошибок не предполагается (тем не менее, приложения должны обрабатывать "
"возможную ошибку возврата)."

#. type: tbl table
#: man-pages/man3/pthread_attr_setstackaddr.3:94
#, no-wrap
msgid ""
"B<pthread_attr_setstackaddr>(),\n"
"B<pthread_attr_getstackaddr>()"
msgstr ""
"B<pthread_attr_setstackaddr>(),\n"
"B<pthread_attr_getstackaddr>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:99
msgid ""
"POSIX.1-2001 specifies these functions but marks them as obsolete.  "
"POSIX.1-2008 removes the specification of these functions."
msgstr ""
"В POSIX.1-2001 эта функция определена, но объявлена устаревшей. В "
"POSIX.1-2008 спецификация этих функций удалена."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:123
msgid ""
"I<Do not use these functions!> They cannot be portably used, since they "
"provide no way of specifying the direction of growth or the range of the "
"stack.  For example, on architectures with a stack that grows downward, "
"I<stackaddr> specifies the next address past the I<highest> address of the "
"allocated stack area.  However, on architectures with a stack that grows "
"upward, I<stackaddr> specifies the I<lowest> address in the allocated stack "
"area.  By contrast, the I<stackaddr> used by B<pthread_attr_setstack>(3)  "
"and B<pthread_attr_getstack>(3), is always a pointer to the lowest address "
"in the allocated stack area (and the I<stacksize> argument specifies the "
"range of the stack)."
msgstr ""
"I<Не используйте эти функции!> Они не являются переносимыми, так как не "
"предоставляют возможности указать направление роста или диапазон стека. "
"Например, для архитектур со стеком растущим вниз, в I<stackaddr> указывается "
"следующий адрес за I<самым верхним> адресом выделяемой области стека, Однако "
"для архитектур со стеком растущим вверх, в I<stackaddr> указывается I<самый "
"нижний> адрес выделяемой области стека. area. В отличие от этого, значение "
"I<stackaddr>, используемое B<pthread_attr_setstack>(3) и "
"B<pthread_attr_getstack>(3), всегда является указателем на самый нижний "
"адрес в выделяемой области стека (а в аргументе I<stacksize> указывается "
"диапазон стека)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstackaddr.3:128
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/posix_spawn.3:31
#, no-wrap
msgid "POSIX_SPAWN"
msgstr "POSIX_SPAWN"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:34
msgid "posix_spawn, posix_spawnp - spawn a process"
msgstr "posix_spawn, posix_spawnp - порождает процесс"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:37
#, no-wrap
msgid "B<#include E<lt>spawn.hE<gt>>\n"
msgstr "B<#include E<lt>spawn.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:42
#, no-wrap
msgid ""
"B<int posix_spawn(pid_t *>I<pid>B<, const char *>I<path>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"
msgstr ""
"B<int posix_spawn(pid_t *>I<pid>B<, const char *>I<path>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:47
#, no-wrap
msgid ""
"B<int posix_spawnp(pid_t *>I<pid>B<, const char *>I<file>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"
msgstr ""
"B<int posix_spawnp(pid_t *>I<pid>B<, const char *>I<file>B<,>\n"
"B<                const posix_spawn_file_actions_t *>I<file_actions>B<,>\n"
"B<                const posix_spawnattr_t *>I<attrp>B<,>\n"
"B<                char *const >I<argv[]>B<, char *const >I<envp[]>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:61
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions are used to create a "
"new child process that executes a specified file.  These functions were "
"specified by POSIX to provide a standardized method of creating new "
"processes on machines that lack the capability to support the B<fork>(2)  "
"system call.  These machines are generally small, embedded systems lacking "
"MMU support."
msgstr ""
"Функции B<posix_spawn>() и B<posix_spawnp>() используются для создания новых "
"дочерних процессов, которые выполняют указываемый файл. Эти функции были "
"определены в POSIX для стандартизации метода создания новых процессов на "
"машинах, у которых нет возможности поддержки системного вызова B<fork>(2). К "
"таким машинах, обычно, относятся встраиваемые системы без поддержки MMU."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:79
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions provide the "
"functionality of a combined B<fork>(2)  and B<exec>(3), with some optional "
"housekeeping steps in the child process before the B<exec>(3).  These "
"functions are not meant to replace the B<fork>(2)  and B<execve>(2)  system "
"calls.  In fact, they provide only a subset of the functionality that can be "
"achieved by using the system calls."
msgstr ""
"Функции B<posix_spawn>() и B<posix_spawnp>() предоставляют комбинацию "
"возможностей B<fork>(2) и B<exec>(3) с некоторыми необязательными "
"обслуживающими действиями в дочернем процессе перед B<exec>(3). Эти функции "
"не служат заменой системных вызовов B<fork>(2) и B<execve>(2). Фактически, "
"они предоставляют только часть функций системных вызовов."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:102
msgid ""
"The only difference between B<posix_spawn>()  and B<posix_spawnp>()  is the "
"manner in which they specify the file to be executed by the child process.  "
"With B<posix_spawn>(), the executable file is specified as a pathname (which "
"can be absolute or relative).  With B<posix_spawnp>(), the executable file "
"is specified as a simple filename; the system searches for this file in the "
"list of directories specified by B<PATH> (in the same way as for "
"B<execvp>(3)).  For the remainder of this page, the discussion is phrased in "
"terms of B<posix_spawn>(), with the understanding that B<posix_spawnp>()  "
"differs only on the point just described."
msgstr ""
"Единственным отличием между B<posix_spawnp>() и B<posix_spawnp>() является "
"способ, которым в них указывается исполняемый дочерним процессом файл. В "
"B<posix_spawn>() исполняемый файл задаётся в виде пути (которое может быть "
"абсолютным или относительным). В B<posix_spawnp>() исполняемый файл задаётся "
"в виде имени файла; система ищет этот файл в списке каталогов, указанных в "
"B<PATH> (также, как это делает B<execvp>(3)). Кроме данного отличия далее на "
"этой странице всё описание B<posix_spawn>() также относится и к "
"B<posix_spawnp>()."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:104
msgid "The remaining arguments to these two functions are as follows:"
msgstr "Остальные аргументы функций:"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:109
msgid ""
"The I<pid> argument points to a buffer that is used to return the process ID "
"of the new child process."
msgstr ""
"Аргумент I<pid> указывает на буфер, в котором возвращается ID нового "
"дочернего процесса."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:127
msgid ""
"The I<file_actions> argument points to a I<spawn file actions object> that "
"specifies file-related actions to be performed in the child between the "
"B<fork>(2)  and B<exec>(3)  steps.  This object is initialized and populated "
"before the B<posix_spawn>()  call using B<posix_spawn_file_actions_init>(3)  "
"and the B<posix_spawn_file_actions_*>()  functions."
msgstr ""
"Аргумент I<file_actions> указывает на I<объект файловых действий при "
"создании>, в котором задаются действия с файлом, выполняемые в потомке между "
"шагами B<fork>(2) и B<exec>(3). Данный объект инициализируется и заполняется "
"перед вызовом B<posix_spawn>() с помощью функций "
"B<posix_spawn_file_actions_init>(3) и B<posix_spawn_file_actions_*>()."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:140
msgid ""
"The I<attrp> argument points to an I<attributes objects> that specifies "
"various attributes of the created child process.  This object is initialized "
"and populated before the B<posix_spawn>()  call using "
"B<posix_spawnattr_init>(3)  and the B<posix_spawnattr_*>()  functions."
msgstr ""
"Аргумент I<attrp> указывает на I<объект атрибутов>, в котором задаются "
"различные атрибуты создаваемого дочернего процесса. Данный объект "
"инициализируется и заполняется перед вызовом B<posix_spawn>() с помощью "
"функций B<posix_spawnattr_init>(3) и B<posix_spawnattr_*>()."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:148
msgid ""
"The I<argv> and I<envp> arguments specify the argument list and environment "
"for the program that is executed in the child process, as for B<execve>(2)."
msgstr ""
"В аргументах I<argv> и I<envp> задаётся список аргументов и окружения для "
"программы, выполняемой в дочернем процессе, как для B<execve>(2)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:157
msgid ""
"Below, the functions are described in terms of a three-step process: the "
"B<fork>()  step, the pre-B<exec>()  step (executed in the child), and the "
"B<exec>()  step (executed in the child)."
msgstr ""
"Далее функции описаны в виде трёх ступенчатого процесса: шаг B<fork>(), шаг "
"перед B<exec>() (выполняется в потомке) и шаг B<exec>() (выполняется в "
"потомке)."

#. type: SS
#: man-pages/man3/posix_spawn.3:157
#, no-wrap
msgid "fork() step"
msgstr "Шаг fork()"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:165
msgid ""
"The B<posix_spawn>()  function commences by calling B<fork>(2), or possibly "
"B<vfork>(2)  (see below)."
msgstr ""
"Функция B<posix_spawn>() начинает работу с вызова B<fork>(2) или, возможно, "
"B<vfork>(2) (смотрите ниже)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:171
msgid ""
"The PID of the new child process is placed in I<*pid>.  The "
"B<posix_spawn>()  function then returns control to the parent process."
msgstr ""
"PID нового дочернего процесса помещается в I<*pid>. После этого функция "
"B<posix_spawn>() возвращает управление родительскому процессу."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:178
msgid ""
"Subsequently, the parent can use one of the system calls described in "
"B<wait>(2)  to check the status of the child process.  If the child fails in "
"any of the housekeeping steps described below, or fails to execute the "
"desired file, it exits with a status of 127."
msgstr ""
"Соответственно, родитель может использовать один из системных вызовов, "
"описанных в B<wait>(2), для проверки состояния дочернего процесса. Если "
"потомок завершится с ошибкой в любом из служебных шагов, описанных далее, "
"или возникнет ошибка при выполнении желаемого файла, то он завершит работу с "
"кодом состояния 127."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:184
msgid ""
"The child process is created using B<vfork>(2)  instead of B<fork>(2)  when "
"either of the following is true:"
msgstr ""
"Дочерний процесс создаётся с помощью B<vfork>(2), а не B<fork>(2) в любом из "
"следующих случаев:"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:192
msgid ""
"the I<spawn-flags> element of the attributes object pointed to by I<attrp> "
"contains the GNU-specific flag B<POSIX_SPAWN_USEVFORK>; or"
msgstr ""
"элемент I<spawn-flags> объекта атрибутов, на который указывает I<attrp>, "
"содержит определённый в GNU флаг B<POSIX_SPAWN_USEVFORK>; или"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:206
msgid ""
"I<file_actions> is NULL and the I<spawn-flags> element of the attributes "
"object pointed to by I<attrp> does I<not> contain B<POSIX_SPAWN_SETSIGMASK>, "
"B<POSIX_SPAWN_SETSIGDEF>, B<POSIX_SPAWN_SETSCHEDPARAM>, "
"B<POSIX_SPAWN_SETSCHEDULER>, B<POSIX_SPAWN_SETPGROUP>, or "
"B<POSIX_SPAWN_RESETIDS>."
msgstr ""
"I<file_actions> равно NULL и элемент I<spawn-flags> объекта атрибутов, на "
"который указывает I<attrp>, I<не> содержит B<POSIX_SPAWN_SETSIGMASK>, "
"B<POSIX_SPAWN_SETSIGDEF>, B<POSIX_SPAWN_SETSCHEDPARAM>, "
"B<POSIX_SPAWN_SETSCHEDULER>, B<POSIX_SPAWN_SETPGROUP> или "
"B<POSIX_SPAWN_RESETIDS>."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:213
msgid ""
"In other words, B<vfork>(2)  is used if the caller requests it, or if there "
"is no cleanup expected in the child before it B<exec>(3)s the requested file."
msgstr ""
"Иначе говоря, B<vfork>(2) используется, если это запросил вызывающий или не "
"нужна очистка в потомке перед выполнением B<exec>(3) запрашиваемого файла."

#. type: SS
#: man-pages/man3/posix_spawn.3:214
#, no-wrap
msgid "pre-exec() step: housekeeping"
msgstr "Шаг перед exec(): служебные действия"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:231
msgid ""
"In between the B<fork>(2)  and the B<exec>(3), a child process may need to "
"perform a set of housekeeping actions.  The B<posix_spawn>()  and "
"B<posix_spawnp>()  functions support a small, well-defined set of system "
"tasks that the child process can accomplish before it executes the "
"executable file.  These operations are controlled by the attributes object "
"pointed to by I<attrp> and the file actions object pointed to by "
"I<file_actions>.  In the child, processing is done in the following sequence:"
msgstr ""
"Между B<fork>(2) и B<exec>(3) дочерний процесс может выполнить набор "
"служебных действий. Функции B<posix_spawn>() и B<posix_spawnp>() "
"поддерживают маленький, хорошо спроектированный набор системных задач, "
"которые дочерний процесс может выполнить перед запуском исполняемого файла. "
"Эти операции управляются объектом атрибутов, на который указывает I<attrp> и "
"объект файловых действий, на который указывает I<file_actions>. В потомке "
"обработка выполняются в следующей последовательности:"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:237
msgid ""
"Process attribute actions: signal mask, signal default handlers, scheduling "
"algorithm and parameters, process group, and effective user and group IDs "
"are changed as specified by the attributes object pointed to by I<attrp>."
msgstr ""
"Действия с атрибутами процесса: маска сигналов, обработчики сигналов по "
"умолчанию, алгоритм планирования и параметры, ID группы процесса, "
"эффективного пользователя и группы изменяются согласно объекту атрибутов, на "
"который указывает I<attrp>."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:244
msgid ""
"File actions, as specified in the I<file_actions> argument, are performed in "
"the order that they were specified using calls to the "
"B<posix_spawn_file_actions_add*>()  functions."
msgstr ""
"Файловые действия, указываемые в аргументе I<file_actions>, выполняются в "
"порядке их определения вызовами функций B<posix_spawn_file_actions_add*>()."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:248
msgid "File descriptors with the B<FD_CLOEXEC> flag set are closed."
msgstr "Закрываются файловые дескрипторы, имеющие флаг B<FD_CLOEXEC>."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:259
msgid ""
"All process attributes in the child, other than those affected by attributes "
"specified in the object pointed to by I<attrp> and the file actions in the "
"object pointed to by I<file_actions>, will be affected as though the child "
"was created with B<fork>(2)  and it executed the program with B<execve>(2)."
msgstr ""
"Все атрибуты процесса-потомка, отличные от атрибутов в объекте, на который "
"указывает I<attrp> и файловые действия в объекте, на который указывает "
"I<file_actions>, будут изменены как если бы потомок создавался с помощью "
"B<fork>(2) и выполнял программу с помощью B<execve>(2)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:270
msgid ""
"The process attributes actions are defined by the attributes object pointed "
"to by I<attrp>.  The I<spawn-flags> attribute (set using "
"B<posix_spawnattr_setflags>(3))  controls the general actions that occur, "
"and other attributes in the object specify values to be used during those "
"actions."
msgstr ""
"Действия атрибутов процесса определяются атрибутами объекта, на который "
"указывает I<attrp>. Атрибут I<spawn-flags> (устанавливается с помощью "
"B<posix_spawnattr_setflags>(3)) управляет общими действиями, а остальные "
"атрибуты объекта хранят значения, которые будут использованы в этих "
"действиях."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:274
msgid ""
"The effects of the flags that may be specified in I<spawn-flags> are as "
"follows:"
msgstr "Влияние флагов, которые могут быть указаны в I<spawn-flags>:"

#. type: TP
#: man-pages/man3/posix_spawn.3:274
#, no-wrap
msgid "B<POSIX_SPAWN_SETSIGMASK>"
msgstr "B<POSIX_SPAWN_SETSIGMASK>"

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setsigmask (3))
#. type: Plain text
#: man-pages/man3/posix_spawn.3:287
msgid ""
"Set the signal mask to the signal set specified in the I<spawn-sigmask> "
"attribute of the object pointed to by I<attrp>.  If the "
"B<POSIX_SPAWN_SETSIGMASK> flag is not set, then the child inherits the "
"parent's signal mask."
msgstr ""
"Назначить маску сигналов равной набору сигналов, определённой в атрибуте "
"I<spawn-sigmask> объекта, на который указывает I<attrp>. Если не установлен "
"флаг B<POSIX_SPAWN_SETSIGMASK>, то потомок наследует маску сигналов родителя."

#. type: TP
#: man-pages/man3/posix_spawn.3:287
#, no-wrap
msgid "B<POSIX_SPAWN_SETSIGDEF>"
msgstr "B<POSIX_SPAWN_SETSIGDEF>"

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setsigdefault (3))
#. type: Plain text
#: man-pages/man3/posix_spawn.3:304
msgid ""
"Reset the disposition of all signals in the set specified in the I<spawn-"
"sigdefault> attribute of the object pointed to by I<attrp> to the default.  "
"For the treatment of the dispositions of signals not specified in the "
"I<spawn-sigdefault> attribute, or the treatment when "
"B<POSIX_SPAWN_SETSIGDEF> is not specified, see B<execve>(2)."
msgstr ""
"Сбрасывает обработчики всех сигналов в наборе, заданном в атрибуте I<spawn-"
"sigdefault> объекта, на который указывает I<attrp>, в значения по умолчанию. "
"О том, что происходит с обработчиками сигналов не указанных в атрибуте  "
"I<spawn-sigdefault> или когда не указан B<POSIX_SPAWN_SETSIGDEF>, смотрите "
"B<execve>(2)."

#. type: TP
#: man-pages/man3/posix_spawn.3:304
#, no-wrap
msgid "B<POSIX_SPAWN_SETSCHEDPARAM>"
msgstr "B<POSIX_SPAWN_SETSCHEDPARAM>"

#.  (POSIX_PRIORITY_SCHEDULING only)
#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setschedparam (3))
#. type: Plain text
#: man-pages/man3/posix_spawn.3:318
msgid ""
"If this flag is set, and the B<POSIX_SPAWN_SETSCHEDULER> flag is not set, "
"then set the scheduling parameters to the parameters specified in the "
"I<spawn-schedparam> attribute of the object pointed to by I<attrp>."
msgstr ""
"Если этот флаг установлен, а B<POSIX_SPAWN_SETSCHEDULER> нет, то изменяет "
"параметры планирования на значения, указанные в атрибуте I<spawn-schedparam> "
"объекта, на который указывает I<attrp>."

#. type: TP
#: man-pages/man3/posix_spawn.3:318
#, no-wrap
msgid "B<POSIX_SPAWN_SETSCHEDULER>"
msgstr "B<POSIX_SPAWN_SETSCHEDULER>"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:322
msgid ""
"Set the scheduling policy algorithm and parameters of the child, as follows:"
msgstr "Назначает алгоритм планирования и параметры потомка:"

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setpolicy (3))
#. type: Plain text
#: man-pages/man3/posix_spawn.3:332
msgid ""
"The scheduling policy is set to the value specified in the I<spawn-"
"schedpolicy> attribute of the object pointed to by I<attrp>."
msgstr ""
"Алгоритму планирования присваивается значение, указанное в атрибуте I<spawn-"
"schedpolicy> объекта, на который указывает I<attrp>."

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setschedparam (3))
#. type: Plain text
#: man-pages/man3/posix_spawn.3:342
msgid ""
"The scheduling parameters are set to the value specified in the I<spawn-"
"schedparam> attribute of the object pointed to by I<attrp> (but see BUGS)."
msgstr ""
"Параметрам планирования присваивается значение, указанное в атрибуте I<spawn-"
"schedparam> объекта, на который указывает I<attrp> (но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:349
msgid ""
"If the B<POSIX_SPAWN_SETSCHEDPARAM> and B<POSIX_SPAWN_SETSCHEDPOLICY> flags "
"are not specified, the child inherits the corresponding scheduling "
"attributes from the parent."
msgstr ""
"Если не указаны флаги B<POSIX_SPAWN_SETSCHEDPARAM> и "
"B<POSIX_SPAWN_SETSCHEDPOLICY>, то потомок наследует соответствующие атрибуты "
"планирования от родителя."

#. type: TP
#: man-pages/man3/posix_spawn.3:350
#, no-wrap
msgid "B<POSIX_SPAWN_RESETIDS>"
msgstr "B<POSIX_SPAWN_RESETIDS>"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:361
msgid ""
"If this flag is set, reset the effective UID and GID to the real UID and GID "
"of the parent process.  If this flag is not set, then the child retains the "
"effective UID and GID of the parent.  In either case, if the set-user-ID and "
"set-group-ID permission bits are enabled on the executable file, their "
"effect will override the setting of the effective UID and GID (se "
"B<execve>(2))."
msgstr ""
"Если этот флаг установлен, то сбрасываются эффективный UID и GID в реальный "
"UID и GID родительского процесса. Если флаг не установлен, то потомок "
"сохраняет эффективный UID и GID родителя. В любом случае, если биты прав set-"
"user-ID и set-group-ID включены на исполняемом файле, то это заменяет "
"значения эффективного UID и GID (смотрите B<execve>(2))."

#. type: TP
#: man-pages/man3/posix_spawn.3:361
#, no-wrap
msgid "B<POSIX_SPAWN_SETPGROUP>"
msgstr "B<POSIX_SPAWN_SETPGROUP>"

#.  FIXME .
#.  (see
#.  .BR posix_spawnattr_setpgroup (3))
#. type: Plain text
#: man-pages/man3/posix_spawn.3:378
msgid ""
"Set the process group to the value specified in the I<spawn-pgroup> "
"attribute of the object pointed to by I<attrp>.  If the I<spawn-pgroup> "
"attribute has the value 0, the child's process group ID is made the same as "
"its process ID.  If the B<POSIX_SPAWN_SETPGROUP> flag is not set, the child "
"inherits the parent's process group ID."
msgstr ""
"Назначает группе процесса значение, указанное в атрибуте I<spawn-pgroup> "
"объекта, на который указывает I<attrp>. Если атрибут I<spawn-pgroup> равен "
"0, то ID группы потомка становится равным его ID процесса. Если флаг "
"B<POSIX_SPAWN_SETPGROUP> не установлен, то потомок наследует ID группы "
"процесса родителя."

#.  mtk: I think we probably don't want to say the following, since it
#.       could lead people to do the wrong thing
#.  The POSIX standard tells you to call
#.  this function to de-initialize the attributes object pointed to by
#.  .I attrp
#.  when you are done with it;
#.  however, on Linux systems this operation is a no-op.
#. type: Plain text
#: man-pages/man3/posix_spawn.3:389
msgid ""
"If I<attrp> is NULL, then the default behaviors described above for each "
"flag apply."
msgstr ""
"Если I<attrp> равно NULL, то выполняются действия по умолчанию, которые "
"описаны выше по каждому флагу."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:406
msgid ""
"The I<file_actions> argument specifies a sequence of file operations that "
"are performed in the child process after the general processing described "
"above, and before it performs the B<exec>(3).  If I<file_actions> is NULL, "
"then no special action is taken, and standard B<exec>(3)  semantics apply--"
"file descriptors open before the exec remain open in the new process, except "
"those for which the B<FD_CLOEXEC> flag has been set.  File locks remain in "
"place."
msgstr ""
"Аргумент I<file_actions> задаёт последовательность файловых операций, "
"которые выполняются в дочернем процессе после общей обработки, описанной "
"выше, и перед выполнением B<exec>(3). Если I<file_actions> равно NULL, то "
"никаких специальных действий не производится и выполняются стандартные "
"действия B<exec>(3) — файловые дескрипторы, открытые до выполнения exec, "
"остаются открытыми и в новом процессе, за исключением тех, у которых "
"установлен флаг B<FD_CLOEXEC>. Файловые блокировки остаются как были."

#.  FIXME . I think the following is best placed in the
#.  posix_spawn_file_actions_adddup2(3) page, and a similar statement is
#.  also needed in posix_spawn_file_actions_addclose(3)
#.  Note that you can specify file descriptors in
#.  .I posix_spawn_file_actions_adddup2 (3)
#.  which would not be usable if you called
#.  .BR dup2 (2)
#.  at that time--i.e., file descriptors that are opened or
#.  closed by the earlier operations
#.  added to
#.  .I file_actions .
#. type: Plain text
#: man-pages/man3/posix_spawn.3:435
msgid ""
"If I<file_actions> is not NULL, then it contains an ordered set of requests "
"to B<open>(2), B<close>(2), and B<dup2>(2)  files.  These requests are added "
"to the I<file_actions> by B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_addclose>(3), and "
"B<posix_spawn_file_actions_adddup2>(3).  The requested operations are "
"performed in the order they were added to I<file_actions>."
msgstr ""
"Если I<file_actions> не равно NULL, то в нём содержится упорядоченный набор "
"запросов B<open>(2), B<close>(2) и B<dup2>(2) на файлы. Эти запросы "
"добавляются в I<file_actions> с помощью "
"B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_addclose>(3) и "
"B<posix_spawn_file_actions_adddup2>(3). Запрашиваемые операции выполняются в "
"порядке их добавления в I<file_actions>."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:441
msgid ""
"If any of the housekeeping actions fails (due to bogus values being passed "
"or other reasons why signal handling, process scheduling, process group ID "
"functions, and file descriptor operations might fail), the child process "
"exits with exit value 127."
msgstr ""
"Если какая-либо обслуживающая операция завершается с ошибкой, (из-за "
"переданных некорректных значений или по другим причинам, из-за которых "
"обработка сигналов, планирование процесса, функции изменения ID группы "
"процесса и операции с файловыми дескрипторами завершается с ошибкой), "
"дочерний процесс завершается с кодом выхода 127."

#. type: SS
#: man-pages/man3/posix_spawn.3:441
#, no-wrap
msgid "exec() step"
msgstr "Шаг exec()"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:445
msgid ""
"Once the child has successfully forked and performed all requested pre-exec "
"steps, the child runs the requested executable."
msgstr ""
"После того как потомок создан (fork) и выполнены все запрошенные шаги до "
"exec, потомок выполняет запуск запрошенного исполняемого файла."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:454
msgid ""
"The child process takes its environment from the I<envp> argument, which is "
"interpreted as if it had been passed to B<execve>(2).  The arguments to the "
"created process come from the I<argv> argument, which is processed as for "
"B<execve>(2)."
msgstr ""
"Дочерний процесс берёт своё окружение из аргумента I<envp>, которое "
"рассматривается также как если бы оно передавалось в B<execve>(2). Аргументы "
"созданного процесса выбираются из аргумента I<argv>, который обрабатывается "
"также как для B<execve>(2)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:469
msgid ""
"Upon successful completion, B<posix_spawn>()  and B<posix_spawnp>()  place "
"the PID of the child process in I<pid>, and return 0.  If there is an error "
"before or during the B<fork>(2), then no child is created, the contents of "
"I<*pid> are unspecified, and these functions return an error number as "
"described below."
msgstr ""
"При успешном завершении B<posix_spawn>() и B<posix_spawnp>() помещают PID "
"дочернего процесса в I<pid> и возвращают 0. Если перед или во время "
"B<fork>(2) возникла ошибка, то потомок не создаётся, содержимое I<*pid> "
"неопределенно и функции возвращают номер ошибки (описано далее)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:477
msgid ""
"Even when these functions return a success status, the child process may "
"still fail for a plethora of reasons related to its pre-B<exec>() "
"initialization.  In addition, the B<exec>(3)  may fail.  In all of these "
"cases, the child process will exit with the exit value of 127."
msgstr ""
"Даже когда эти функции выполняются без ошибок, дочерний процесс всё ещё "
"может завершиться с ошибкой по многим причинам, касающимся инициализации до "
"B<exec>(). Также, может завершиться ошибкой и B<exec>(3). Во всех этих "
"случаях дочерний процесс завершается с кодом ошибки 127."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:491
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions fail only in the case "
"where the underlying B<fork>(2)  or B<vfork>(2)  call fails; in these cases, "
"these functions return an error number, which will be one of the errors "
"described for B<fork>(2)  or B<vfork>(2)."
msgstr ""
"Функции B<posix_spawn>() и B<posix_spawnp>() завершаются с ошибкой, только "
"из-за ошибок в используемых вызовах B<fork>(2) и B<vfork>(2); в этих случаях "
"эти функции возвращают номер ошибки, который может быть одним из описанных в "
"B<fork>(2) или B<vfork>(2)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:493
msgid "In addition, these functions fail if:"
msgstr "Также, эти функции завершаются с ошибкой если:"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:496
msgid "Function not supported on this system."
msgstr "Функции не поддерживаются в этой системе."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:502
msgid ""
"The B<posix_spawn>()  and B<posix_spawnp>()  functions are available since "
"glibc 2.2."
msgstr ""
"Функции B<posix_spawn>() и B<posix_spawnp>() доступны в glibc начиная с "
"версии 2.2."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:529
msgid ""
"The housekeeping activities in the child are controlled by the objects "
"pointed to by I<attrp> (for non-file actions) and I<file_actions> In POSIX "
"parlance, the I<posix_spawnattr_t> and I<posix_spawn_file_actions_t> data "
"types are referred to as objects, and their elements are not specified by "
"name.  Portable programs should initialize these objects using only the "
"POSIX-specified functions.  (In other words, although these objects may be "
"implemented as structures containing fields, portable programs must avoid "
"dependence on such implementation details.)"
msgstr ""
"Обслуживающие действия в потомке управляются объектами, на который указывает "
"I<attrp> (для не файловых действий) и I<file_actions>. В описании POSIX типы "
"данных I<posix_spawnattr_t> и I<posix_spawn_file_actions_t> указываются как "
"объекты, а их элементам не даны имена. Переносимые программы должны "
"инициализировать эти объекты с только помощью функций, определённых в POSIX "
"(другими словами, хотя эти объекты могут быть реализованы как структуры с "
"полями, в переносимых программах нельзя привязываться к такой реализации)."

#.  Tested on glibc 2.12
#. type: Plain text
#: man-pages/man3/posix_spawn.3:539
msgid ""
"According to POSIX, it unspecified whether fork handlers established with "
"B<pthread_atfork>(3)  are called when B<posix_spawn>()  is invoked.  On "
"glibc, fork handlers are called only if the child is created using "
"B<fork>(2)."
msgstr ""
"В POSIX не определено вызывать ли обработчики fork, установленные с помощью "
"B<pthread_atfork>(3), при вызове B<posix_spawn>(). В glibc обработчики fork "
"вызываются только, если потомок создан с помощью B<fork>(2)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:551
msgid ""
"There is no \"posix_fspawn\" function (i.e., a function that is to "
"B<posix_spawn>()  as B<fexecve>(3)  is to B<execve>(2)).  However, this "
"functionality can be obtained by specifying the I<path> argument as one of "
"the files in the caller's I</proc/self/fd> directory."
msgstr ""
"Не существует функции «posix_fspawn» (т. е., функции типа B<posix_spawn>(), "
"которая вызывала бы B<fexecve>(3) вместо B<execve>(2)). Однако, подобное "
"поведение можно получить указав аргумент I<path> как один из файлов в "
"каталоге I</proc/self/fd> вызывающего."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12052
#. type: Plain text
#: man-pages/man3/posix_spawn.3:566
msgid ""
"POSIX.1 says that when B<POSIX_SPAWN_SETSCHEDULER> is specified in I<spawn-"
"flags>, then the B<POSIX_SPAWN_SETSCHEDPARAM> (if present) is ignored.  "
"However, before glibc 2.14, calls to B<posix_spawn>()  failed with an error "
"if B<POSIX_SPAWN_SETSCHEDULER> was specified without also specifying "
"B<POSIX_SPAWN_SETSCHEDPARAM>."
msgstr ""
"В POSIX.1 указано, что когда в I<spawn-flags> определён "
"B<POSIX_SPAWN_SETSCHEDULER>, флаг B<POSIX_SPAWN_SETSCHEDPARAM> (если есть) "
"игнорируется. Однако до glibc 2.14 вызов B<posix_spawn>() завершался с "
"ошибкой, если B<POSIX_SPAWN_SETSCHEDULER> был указан, а "
"B<POSIX_SPAWN_SETSCHEDPARAM> отсутствовал."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:573
msgid ""
"The program below demonstrates the use of various functions in the POSIX "
"spawn API.  The program accepts command-line attributes that can be used to "
"create file actions and attributes objects.  The remaining command-line "
"arguments are used as the executable name and command-line arguments of the "
"program that is executed in the child."
msgstr ""
"Представленная далее программа показывает использование различных функций "
"программного интерфейса POSIX для создания процессов. Она принимает атрибуты "
"из командной строки, которые позволяют задать файловые действия и атрибуты "
"объектов при создании. В остальных аргументах командной строки задаются имя "
"исполняемого файла и аргументы командной строки для программы, исполняемой в "
"потомке."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:579
msgid ""
"In the first run, the B<date>(1)  command is executed in the child, and the "
"B<posix_spawn>()  call employs no file actions or attributes objects."
msgstr ""
"Здесь для исполнения в потомке указана команда B<date>(1) и вызов "
"B<posix_spawn>() не использует каких-либо файловых действий и атрибутов "
"объекта."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:586
#, no-wrap
msgid ""
"$ B<./a.out date>\n"
"PID of child: 7634\n"
"Tue Feb  1 19:47:50 CEST 2011\n"
"Child status: exited, status=0\n"
msgstr ""
"$ B<./a.out date>\n"
"PID потомка: 7634\n"
"Tue Feb  1 19:47:50 CEST 2011\n"
"Состояние потомка: завершился, состояние=0\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:596
msgid ""
"In the next run, the I<-c> command-line option is used to create a file "
"actions object that closes standard output in the child.  Consequently, "
"B<date>(1)  fails when trying to perform output and exits with a status of 1."
msgstr ""
"Здесь параметром командной строки I<-c> передаётся объект файловых действий, "
"которые закрывают стандартный вывод в потомке. В результате этого B<date>(1) "
"завершается с ошибкой, когда пытается выполнить вывод данных и завершается с "
"кодом состояния 1."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:603
#, no-wrap
msgid ""
"$ B<./a.out -c date>\n"
"PID of child: 7636\n"
"date: write error: Bad file descriptor\n"
"Child status: exited, status=1\n"
msgstr ""
"$ B<./a.out -c date>\n"
"PID потомка: 7636\n"
"date: write error: Bad file descriptor\n"
"Состояние потомка: завершился, состояние=1\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:620
msgid ""
"In the next run, the I<-s> command-line option is used to create an "
"attributes object that specifies that all (blockable) signals in the child "
"should be blocked.  Consequently, trying to kill child with the default "
"signal sent by B<kill>(1)  (i.e., B<SIGTERM>)  fails, because that signal is "
"blocked.  Therefore, to kill the child, B<SIGKILL> is necessary (B<SIGKILL> "
"can't be blocked)."
msgstr ""
"Здесь используется параметр командной строки I<-s> для создания объекта "
"атрибутов, который используется для блокировки всех сигналов (блокируемых) в "
"потомке. В результате этого попытка убить потомка сигналом по умолчанию (т. "
"е., B<SIGTERM>) с помощью B<kill>(1) завершается ошибкой, так как этот "
"сигнал заблокирован. Теперь, чтобы убить потомка, требуется сигнал "
"B<SIGKILL> (B<SIGKILL> невозможно заблокировать)."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:626
#, no-wrap
msgid ""
"$ B<./a.out -s sleep 60 &>\n"
"[1] 7637\n"
"$ PID of child: 7638\n"
msgstr ""
"$ B<./a.out -s sleep 60 &>\n"
"[1] 7637\n"
"$ PID потомка: 7638\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:631
#, no-wrap
msgid ""
"$ B<kill 7638>\n"
"$ B<kill -KILL 7638>\n"
"$ Child status: killed by signal 9\n"
"[1]+  Done                    ./a.out -s sleep 60\n"
msgstr ""
"$ B<kill 7638>\n"
"$ B<kill -KILL 7638>\n"
"$ Состояние потомка: убит по сигналу 9\n"
"[1]+  Done                    ./a.out -s sleep 60\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:637
msgid ""
"When we try to execute a nonexistent command in the child, the B<exec>(3)  "
"fails and the child exits with a status of 127."
msgstr ""
"Когда мы пытаемся выполнить в потомке несуществующую команду, B<exec>(3) "
"завершается с ошибкой и потомок завершается с кодом 127."

#. type: Plain text
#: man-pages/man3/posix_spawn.3:643
#, no-wrap
msgid ""
"$ B<./a.out xxxxx\n"
"PID of child: 10190\n"
"Child status: exited, status=127>\n"
msgstr ""
"$ B<./a.out xxxxx\n"
"PID потомка: 10190\n"
"Состояние потомка: завершился, состояние=127>\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:655
#, no-wrap
msgid ""
"#include E<lt>spawn.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>wait.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>spawn.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>wait.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:658
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:662
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define errExitEN(en, msg) \\e\n"
"                        do { errno = en; perror(msg); \\e\n"
"                             exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:664
#, no-wrap
msgid "char **environ;\n"
msgstr "char **environ;\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:675
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t child_pid;\n"
"    int s, opt, status;\n"
"    sigset_t mask;\n"
"    posix_spawnattr_t attr;\n"
"    posix_spawnattr_t *attrp;\n"
"    posix_spawn_file_actions_t file_actions;\n"
"    posix_spawn_file_actions_t *file_actionsp;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t child_pid;\n"
"    int s, opt, status;\n"
"    sigset_t mask;\n"
"    posix_spawnattr_t attr;\n"
"    posix_spawnattr_t *attrp;\n"
"    posix_spawn_file_actions_t file_actions;\n"
"    posix_spawn_file_actions_t *file_actionsp;\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:678
#, no-wrap
msgid ""
"    /* Parse command-line options, which can be used to specify an\n"
"       attributes object and file actions object for the child. */\n"
msgstr ""
"    /* разбор параметров командной строки, которые можно использовать\n"
"       в потомке в качестве объекта атрибутов и файловых действий */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:681
#, no-wrap
msgid ""
"    attrp = NULL;\n"
"    file_actionsp = NULL;\n"
msgstr ""
"    attrp = NULL;\n"
"    file_actionsp = NULL;\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:685
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"sc\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq:       /* -c: close standard output in child */\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"sc\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqc\\(aq:       /* -c: закрыть стандартный вывод в потомке */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:688
#, no-wrap
msgid ""
"            /* Create a file actions object and add a \"close\"\n"
"               action to it */\n"
msgstr ""
"            /* создаём объект файловых действий и добавляем в него\n"
"               действие «закрыть» */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:692
#, no-wrap
msgid ""
"            s = posix_spawn_file_actions_init(&file_actions);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_init\");\n"
msgstr ""
"            s = posix_spawn_file_actions_init(&file_actions);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_init\");\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:697
#, no-wrap
msgid ""
"            s = posix_spawn_file_actions_addclose(&file_actions,\n"
"                                                  STDOUT_FILENO);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_addclose\");\n"
msgstr ""
"            s = posix_spawn_file_actions_addclose(&file_actions,\n"
"                                                  STDOUT_FILENO);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawn_file_actions_addclose\");\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:700
#, no-wrap
msgid ""
"            file_actionsp = &file_actions;\n"
"            break;\n"
msgstr ""
"            file_actionsp = &file_actions;\n"
"            break;\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:702
#, no-wrap
msgid "        case \\(aqs\\(aq:       /* -s: block all signals in child */\n"
msgstr "        case \\(aqs\\(aq:       /* -s: блокировать все сигналы в потомке */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:705
#, no-wrap
msgid ""
"            /* Create an attributes object and add a \"set signal mask\"\n"
"               action to it */\n"
msgstr ""
"            /* создаём объект атрибутов и добавляем в него действие \n"
"               «назначения сигнальной маски» */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:712
#, no-wrap
msgid ""
"            s = posix_spawnattr_init(&attr);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_init\");\n"
"            s = posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGMASK);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setflags\");\n"
msgstr ""
"            s = posix_spawnattr_init(&attr);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_init\");\n"
"            s = posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGMASK);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setflags\");\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:717
#, no-wrap
msgid ""
"            sigfillset(&mask);\n"
"            s = posix_spawnattr_setsigmask(&attr, &mask);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setsigmask\");\n"
msgstr ""
"            sigfillset(&mask);\n"
"            s = posix_spawnattr_setsigmask(&attr, &mask);\n"
"            if (s != 0)\n"
"                errExitEN(s, \"posix_spawnattr_setsigmask\");\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:722
#, no-wrap
msgid ""
"            attrp = &attr;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"            attrp = &attr;\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:727
#, no-wrap
msgid ""
"    /* Spawn the child. The name of the program to execute and the\n"
"       command-line arguments are taken from the command-line arguments\n"
"       of this program. The environment of the program execed in the\n"
"       child is made the same as the parent\\(aqs environment. */\n"
msgstr ""
"    /* Порождение потомка. Имя исполняемой программы и аргументы\n"
"       командной строки берутся из аргументов командной строки\n"
"       этой программы. Окружение исполняемой программы в потомке\n"
"       делается таким же как у родителя. */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:732
#, no-wrap
msgid ""
"    s = posix_spawnp(&child_pid, argv[optind], file_actionsp, attrp,\n"
"                     &argv[optind], environ);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"posix_spawn\");\n"
msgstr ""
"    s = posix_spawnp(&child_pid, argv[optind], file_actionsp, attrp,\n"
"                     &argv[optind], environ);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"posix_spawn\");\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:734
#, no-wrap
msgid "    /* Destroy any objects that we created earlier */\n"
msgstr "    /* уничтожаем все объекты, которые мы создали ранее */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:740
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = posix_spawnattr_destroy(attrp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawnattr_destroy\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = posix_spawnattr_destroy(attrp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawnattr_destroy\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:746
#, no-wrap
msgid ""
"    if (file_actionsp != NULL) {\n"
"        s = posix_spawn_file_actions_destroy(file_actionsp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawn_file_actions_destroy\");\n"
"    }\n"
msgstr ""
"    if (file_actionsp != NULL) {\n"
"        s = posix_spawn_file_actions_destroy(file_actionsp);\n"
"        if (s != 0)\n"
"            errExitEN(s, \"posix_spawn_file_actions_destroy\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:748
#, no-wrap
msgid "    printf(\"PID of child: %ld\\en\", (long) child_pid);\n"
msgstr "    printf(\"PID потомка: %ld\\en\", (long) child_pid);\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:750
#, no-wrap
msgid "    /* Monitor status of the child until it terminates */\n"
msgstr "    /* отслеживаем состояние потомка до его завершения */\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:755
#, no-wrap
msgid ""
"    do {\n"
"        s = waitpid(child_pid, &status, WUNTRACED | WCONTINUED);\n"
"        if (s == -1)\n"
"            errExit(\"waitpid\");\n"
msgstr ""
"    do {\n"
"        s = waitpid(child_pid, &status, WUNTRACED | WCONTINUED);\n"
"        if (s == -1)\n"
"            errExit(\"waitpid\");\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:767
#, no-wrap
msgid ""
"        printf(\"Child status: \");\n"
"        if (WIFEXITED(status)) {\n"
"            printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"        } else if (WIFSIGNALED(status)) {\n"
"            printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"        } else if (WIFSTOPPED(status)) {\n"
"            printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"        } else if (WIFCONTINUED(status)) {\n"
"            printf(\"continued\\en\");\n"
"        }\n"
"    } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"
msgstr ""
"        printf(\"Состояние потомка: \");\n"
"        if (WIFEXITED(status)) {\n"
"            printf(\"завершился, состояние=%d\\en\", WEXITSTATUS(status));\n"
"        } else if (WIFSIGNALED(status)) {\n"
"            printf(\"убит по сигналу %d\\en\", WTERMSIG(status));\n"
"        } else if (WIFSTOPPED(status)) {\n"
"            printf(\"остановлен по сигналу %d\\en\", WSTOPSIG(status));\n"
"        } else if (WIFCONTINUED(status)) {\n"
"            printf(\"выполняется\\en\");\n"
"        }\n"
"    } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"

#. type: Plain text
#: man-pages/man3/posix_spawn.3:808
msgid ""
"B<close>(2), B<dup2>(2), B<execl>(2), B<execlp>(2), B<fork>(2), B<open>(2), "
"B<sched_setparam>(2), B<sched_setscheduler>(2), B<setpgid>(2), B<setuid>(2), "
"B<sigaction>(2), B<sigprocmask>(2), B<posix_spawn_file_actions_addclose>(3), "
"B<posix_spawn_file_actions_adddup2>(3), "
"B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_destroy>(3), B<posix_spawn_file_actions_init>(3), "
"B<posix_spawnattr_destroy>(3), B<posix_spawnattr_getflags>(3), "
"B<posix_spawnattr_getpgroup>(3), B<posix_spawnattr_getschedparam>(3), "
"B<posix_spawnattr_getschedpolicy>(3), B<posix_spawnattr_getsigdefault>(3), "
"B<posix_spawnattr_getsigmask>(3), B<posix_spawnattr_init>(3), "
"B<posix_spawnattr_setflags>(3), B<posix_spawnattr_setpgroup>(3), "
"B<posix_spawnattr_setschedparam>(3), B<posix_spawnattr_setschedpolicy>(3), "
"B<posix_spawnattr_setsigdefault>(3), B<posix_spawnattr_setsigmask>(3), "
"B<pthread_atfork>(3), I<E<lt>spawn.hE<gt>>, Base Definitions volume of "
"POSIX.1-2001, I<http://www.opengroup.org/unix/online.html>"
msgstr ""
"B<close>(2), B<dup2>(2), B<execl>(2), B<execlp>(2), B<fork>(2), B<open>(2), "
"B<sched_setparam>(2), B<sched_setscheduler>(2), B<setpgid>(2), B<setuid>(2), "
"B<sigaction>(2), B<sigprocmask>(2), B<posix_spawn_file_actions_addclose>(3), "
"B<posix_spawn_file_actions_adddup2>(3), "
"B<posix_spawn_file_actions_addopen>(3), "
"B<posix_spawn_file_actions_destroy>(3), B<posix_spawn_file_actions_init>(3), "
"B<posix_spawnattr_destroy>(3), B<posix_spawnattr_getflags>(3), "
"B<posix_spawnattr_getpgroup>(3), B<posix_spawnattr_getschedparam>(3), "
"B<posix_spawnattr_getschedpolicy>(3), B<posix_spawnattr_getsigdefault>(3), "
"B<posix_spawnattr_getsigmask>(3), B<posix_spawnattr_init>(3), "
"B<posix_spawnattr_setflags>(3), B<posix_spawnattr_setpgroup>(3), "
"B<posix_spawnattr_setschedparam>(3), B<posix_spawnattr_setschedpolicy>(3), "
"B<posix_spawnattr_setsigdefault>(3), B<posix_spawnattr_setsigmask>(3), "
"B<pthread_atfork>(3), I<E<lt>spawn.hE<gt>>, Base Definitions volume of "
"POSIX.1-2001, I<http://www.opengroup.org/unix/online.html>"

#. type: TH
#: man-pages/man3/pthread_setconcurrency.3:25
#, no-wrap
msgid "PTHREAD_SETCONCURRENCY"
msgstr "PTHREAD_SETCONCURRENCY"

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:29
msgid ""
"pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency "
"level"
msgstr ""
"pthread_setconcurrency, pthread_getconcurrency - изменяет/возвращает уровень "
"распараллеливания"

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:35
#, no-wrap
msgid ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(void);>\n"
msgstr ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(void);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:48
msgid ""
"The B<pthread_setconcurrency>()  function informs the implementation of the "
"application's desired concurrency level, specified in I<new_level>.  The "
"implementation takes this only as a hint: POSIX.1 does not specify the level "
"of concurrency that should be provided as a result of calling "
"B<pthread_setconcurrency>()."
msgstr ""
"Функция B<pthread_setconcurrency>() информирует реализацию приложения о "
"желаемом уровне распараллеливания (concurrency level), задаваемом в "
"I<new_level>. Реализация принимает это только как рекомендацию: в POSIX.1 не "
"указан уровень распараллеливания, который должен получиться в результате "
"вызова B<pthread_setconcurrency>()."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:53
msgid ""
"Specifying I<new_level> as 0 instructs the implementation to manage the "
"concurrency level as it deems appropriate."
msgstr ""
"Значение I<new_level> равное 0 указывает реализации использовать уровень "
"распараллеливания по своему усмотрению."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:56
msgid ""
"B<pthread_getconcurrency>()  returns the current value of the concurrency "
"level for this process."
msgstr ""
"Функция B<pthread_getconcurrency>() возвращает текущее значение уровня "
"распараллеливания для этого процесса."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:61
msgid ""
"On success, B<pthread_setconcurrency>()  returns 0; on error, it returns a "
"nonzero error number."
msgstr ""
"При успешном выполнении B<pthread_setconcurrency>() возвращается 0; при "
"ошибке возвращается ненулевой номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:68
msgid ""
"B<pthread_getconcurrency>()  always succeeds, returning the concurrency "
"level set by a previous call to B<pthread_setconcurrency>(), or 0, if "
"B<pthread_setconcurrency>()  has not previously been called."
msgstr ""
"Функция B<pthread_getconcurrency>() всегда завершается успешно, возвращая "
"уровень распараллеливания, заданный предыдущим вызовом "
"B<pthread_setconcurrency>(), или 0, если функция B<pthread_setconcurrency>() "
"не вызывалась."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:71
msgid "B<pthread_setconcurrency>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_setconcurrency>() может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:75
msgid "I<new_level> is negative."
msgstr "Значение I<new_level> отрицательно."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:81
msgid ""
"POSIX.1 also documents an B<EAGAIN> error (\"the value specified by "
"I<new_level> would cause a system resource to be exceeded\")."
msgstr ""
"В POSIX.1 также описана ошибка B<EAGAIN> («значение, указанное в "
"I<new_level>, привело бы к превышению системного ограничения»)."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:83
msgid "These functions are available in glibc since version 2.1."
msgstr "Эти функции доступны в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/pthread_setconcurrency.3:94
#, no-wrap
msgid ""
"B<pthread_setconcurrency>(),\n"
"B<pthread_getconcurrency>()"
msgstr ""
"B<pthread_setconcurrency>(),\n"
"B<pthread_getconcurrency>()"

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:100
msgid "The default concurrency level is 0."
msgstr "Значение уровня распараллеливания по умолчанию равно 0."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:107
msgid ""
"Concurrency levels are meaningful only for M:N threading implementations, "
"where at any moment a subset of a process's set of user-level threads may be "
"bound to a smaller number of kernel-scheduling entities.  Setting the "
"concurrency level allows the application to give the system a hint as to the "
"number of kernel-scheduling entities that should be provided for efficient "
"execution of the application."
msgstr ""
"Уровни распараллеливания имеют смысл только в реализациях нитей M:N, где в "
"любой момент времени поднабор из набора пользовательских нитей процесса "
"может быть ограничен меньшим количеством единиц планирования ядра. "
"Назначение уровня распараллеливания позволяет приложению дать системе "
"подсказку о количестве единиц планирования ядра для эффективного выполнения "
"приложения."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:113
msgid ""
"Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the "
"concurrency level has no meaning.  In other words, on Linux these functions "
"merely exist for compatibility with other systems, and they have no effect "
"on the execution of a program."
msgstr ""
"В реализациях нитей LinuxThreads и NPTL используется отношение 1:1, поэтому "
"назначение уровня распараллеливания не имеет смысла. Другими словами, в "
"Linux эти функции существуют только лишь для совместимости с другими "
"системами и никак не влияют на выполнение программы."

#. type: Plain text
#: man-pages/man3/pthread_setconcurrency.3:115
msgid "B<pthread_attr_setscope>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_setscope>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_init.3:26
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr "PTHREAD_ATTR_INIT"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:30
msgid ""
"pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
"attributes object"
msgstr ""
"pthread_attr_init, pthread_attr_destroy - инициализирует и уничтожает объект "
"атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:50
msgid ""
"The B<pthread_attr_init>()  function initializes the thread attributes "
"object pointed to by I<attr> with default attribute values.  After this "
"call, individual attributes of the object can be set using various related "
"functions (listed under SEE ALSO), and then the object can be used in one or "
"more B<pthread_create>(3)  calls that create threads."
msgstr ""
"Функция B<pthread_attr_init>() инициализирует объект атрибутов нити, на "
"который указывает I<attr>, значениями атрибутов по умолчанию. После этого "
"вызова отдельные атрибуты объекта можно изменять с помощью различных "
"соответствующих функций (перечислены в разделе СМОТРИТЕ ТАКЖЕ, а после этого "
"объект можно использовать в одном или нескольких вызовах "
"B<pthread_create>(3) для создания нитей."

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:55
msgid ""
"Calling B<pthread_attr_init>()  on a thread attributes object that has "
"already been initialized results in undefined behavior."
msgstr ""
"Вызов B<pthread_attr_init>() с уже инициализированным объектом атрибутов "
"нити приводит к непредсказуемому поведению."

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:62
msgid ""
"When a thread attributes object is no longer required, it should be "
"destroyed using the B<pthread_attr_destroy>()  function.  Destroying a "
"thread attributes object has no effect on threads that were created using "
"that object."
msgstr ""
"Когда объект атрибутов нити больше не нужен, он должен быть уничтожен с "
"помощью функции B<pthread_attr_destroy>(). Уничтожение объекта атрибутов "
"нити не влияет на нить, которая была создана с использованием этого объекта."

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:68
msgid ""
"Once a thread attributes object has been destroyed, it can be reinitialized "
"using B<pthread_attr_init>().  Any other use of a destroyed thread "
"attributes object has undefined results."
msgstr ""
"После уничтожения объекта атрибутов нити его можно инициализировать с "
"помощью B<pthread_attr_init>() повторно. При использовании уничтоженного "
"объекта атрибутов нити другим способом приводит непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:79
msgid ""
"POSIX.1 documents an B<ENOMEM> error for B<pthread_attr_init>(); on Linux "
"these functions always succeed (but portable and future-proof applications "
"should nevertheless handle a possible error return)."
msgstr ""
"В POSIX.1 описана ошибка B<ENOMEM> для B<pthread_attr_init>(); в Linux эти "
"функции всегда выполняются успешно (тем не менее, в переносимых приложениях "
"нужно учитывать возможность возврата ошибки)."

#. type: tbl table
#: man-pages/man3/pthread_attr_init.3:91
#, no-wrap
msgid ""
"B<pthread_attr_init>(),\n"
"B<pthread_attr_destroy>()"
msgstr ""
"B<pthread_attr_init>(),\n"
"B<pthread_attr_destroy>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:102
msgid ""
"The I<pthread_attr_t> type should be treated as opaque: any access to the "
"object other than via pthreads functions is nonportable and produces "
"undefined results."
msgstr ""
"Тип I<pthread_attr_t> должен считаться со скрытым форматом: любой доступ к "
"объекту помимо функций pthreads является непереносимым и приводит к "
"непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:111
msgid ""
"The program below optionally makes use of B<pthread_attr_init>()  and "
"various related functions to initialize a thread attributes object that is "
"used to create a single thread.  Once created, the thread uses the "
"B<pthread_getattr_np>(3)  function (a nonstandard GNU extension) to retrieve "
"the thread's attributes, and then displays those attributes."
msgstr ""
"В программе, представленной ниже, для создания одной нити используется "
"B<pthread_attr_init>() и другие функции, относящиеся к инициализации объекта "
"атрибутов нити. После создания в нити используется функция "
"B<pthread_getattr_np>(3) (нестандартное расширение GNU) для получения "
"атрибутов нити, а затем показываются эти атрибуты."

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:120
msgid ""
"If the program is run with no command-line argument, then it passes NULL as "
"the I<attr> argument of B<pthread_create>(3), so that the thread is created "
"with default attributes.  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""
"Если программа запускается без аргументов командной строки, то аргумент "
"I<attr> функции B<pthread_create>(3) равен NULL, и поэтому нить создаётся с "
"атрибутами по умолчанию. При запуске программы на Linux/x86-32 с реализацией "
"нитей NPTL мы увидим следующее:"

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:136
#, no-wrap
msgid ""
"$B< ulimit -s>       # No stack limit ==E<gt> default stack size is 2 MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"
msgstr ""
"$B< ulimit -s>       # стек не ограничен ==E<gt> размер стека по умолчанию 2 МБ\n"
"unlimited\n"
"$B< ./a.out>\n"
"Атрибуты нити:\n"
"        Состояние отсоединения     = PTHREAD_CREATE_JOINABLE\n"
"        Область                    = PTHREAD_SCOPE_SYSTEM\n"
"        Унаследованный планировщик = PTHREAD_INHERIT_SCHED\n"
"        Алгоритм планирования      = SCHED_OTHER\n"
"        Приоритет планирования     = 0\n"
"        Размер защиты              = 4096 байт\n"
"        Адрес стека                = 0x40196000\n"
"        Размер стека               = 0x201000 байт\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:146
msgid ""
"When we supply a stack size as a command-line argument, the program "
"initializes a thread attributes object, sets various attributes in that "
"object, and passes a pointer to the object in the call to "
"B<pthread_create>(3).  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""
"Если в командной строке мы укажем размер стека, то программа инициализирует "
"объект атрибутов нити, задаёт различные атрибуты в этом объекте и передаёт "
"указатель на объект в вызов B<pthread_create>(3). При запуске программы на "
"Linux/x86-32 с реализацией нитей NPTL мы увидим следующее:"

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:161
#, no-wrap
msgid ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"
msgstr ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() выделен по адресу 0x40197000\n"
"Атрибуты нити:\n"
"        Состояние отсоединения     = PTHREAD_CREATE_DETACHED\n"
"        Область                    = PTHREAD_SCOPE_SYSTEM\n"
"        Унаследованный планировщик = PTHREAD_EXPLICIT_SCHED\n"
"        Алгоритм планирования      = SCHED_OTHER\n"
"        Приоритет планирования     = 0\n"
"        Размер защиты              = 0 байт\n"
"        Адрес стека                = 0x40197000\n"
"        Размер стека               = 0x3000000 байт\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:183
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"
msgstr ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:191
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sСостояние отсоединения     = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:199
#, no-wrap
msgid ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sОбласть                    = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:207
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sУнаследованный планировщик = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:216
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sАлгоритм планирования      = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:221
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"
msgstr ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sПриоритет планирования     = %d\\en\", prefix, sp.sched_priority);\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:226
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %zu bytes\\en\", prefix, v);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sРазмер защиты          = %zu bytes\\en\", prefix, v);\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:233
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = 0x%zx bytes\\en\", prefix, v);\n"
"}\n"
msgstr ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sАдрес стека                = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sРазмер стека               = 0x%zx байт\\en\", prefix, v);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:239
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:243
#, no-wrap
msgid ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"
msgstr ""
"    /* pthread_getattr_np() — нестандартное расширение GNU,\n"
"       возвращает атрибуты нити, указанной в её\n"
"       первом аргументе */\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:247
#, no-wrap
msgid ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:250
#, no-wrap
msgid ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"
msgstr ""
"    printf(\"Атрибуты нити:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:261
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL или &attr */\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:263
#, no-wrap
msgid "    attrp = NULL;\n"
msgstr "    attrp = NULL;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:267
#, no-wrap
msgid ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"
msgstr ""
"    /* Если в командной строке есть аргумент, то использовать его\n"
"       для задания атрибута размера стека и ещё некоторых других атрибутов\n"
"       нити, и attrp будет указывать на объект атрибутов нити */\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:271
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        int stack_size;\n"
"        void *sp;\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        int stack_size;\n"
"        void *sp;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:273
#, no-wrap
msgid "        attrp = &attr;\n"
msgstr "        attrp = &attr;\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:277
#, no-wrap
msgid ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:281
#, no-wrap
msgid ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"
msgstr ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:285
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
msgstr ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:287
#, no-wrap
msgid "        stack_size = strtoul(argv[1], NULL, 0);\n"
msgstr "        stack_size = strtoul(argv[1], NULL, 0);\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:291
#, no-wrap
msgid ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"
msgstr ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:293
#, no-wrap
msgid "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"
msgstr "        printf(\"posix_memalign() выделен по адресу %p\\en\", sp);\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:298
#, no-wrap
msgid ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_init.3:328
msgid ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthread_getattr_np>(3), "
"B<pthread_setattr_default_np>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthread_getattr_np>(3), "
"B<pthread_setattr_default_np>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/perror.3:31
#, no-wrap
msgid "PERROR"
msgstr "PERROR"

#. type: Plain text
#: man-pages/man3/perror.3:34
msgid "perror - print a system error message"
msgstr "perror - печатает системное сообщение об ошибке"

#. type: Plain text
#: man-pages/man3/perror.3:36
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/perror.3:38
msgid "B<void perror(const char *>I<s>B<);>"
msgstr "B<void perror(const char *>I<s>B<);>"

#. type: Plain text
#: man-pages/man3/perror.3:40
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr "B<#include E<lt>errno.hE<gt>>"

#. type: Plain text
#: man-pages/man3/perror.3:42
msgid "B<const char * const >I<sys_errlist>B<[];>"
msgstr "B<const char * const >I<sys_errlist>B<[];>"

#. type: Plain text
#: man-pages/man3/perror.3:44
msgid "B<int >I<sys_nerr>B<;>"
msgstr "B<int >I<sys_nerr>B<;>"

#. type: Plain text
#: man-pages/man3/perror.3:46
msgid "B<int >I<errno>B<; >/* Not really declared this way; see errno(3) */"
msgstr ""
"B<int >I<errno>B<; >/* в реальности объявлено не так; смотрите errno(3) */"

#. type: Plain text
#: man-pages/man3/perror.3:58
#, no-wrap
msgid ""
"I<sys_errlist>,\n"
"I<sys_nerr>:\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"I<sys_errlist>,\n"
"I<sys_nerr>:\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/perror.3:63
msgid ""
"The B<perror>()  function produces a message on standard error describing "
"the last error encountered during a call to a system or library function."
msgstr ""
"Функция B<perror>() выводит сообщение в стандартный поток ошибок, "
"описывающее последнюю ошибку, возникшую при вызове системной или "
"библиотечной функции."

#. type: Plain text
#: man-pages/man3/perror.3:74
msgid ""
"First (if I<s> is not NULL and I<*s> is not a null byte (\\(aq\\e0\\(aq)), "
"the argument string I<s> is printed, followed by a colon and a blank.  Then "
"an error message corresponding to the current value of I<errno> and a new-"
"line."
msgstr ""
"Сначала печатается строка из аргумента I<s> (если I<s> не равно NULL и I<*s> "
"не указывает на байт null (\\(aq\\e0\\(aq)), после неё двоеточие и пробел. "
"Затем выводится сообщение о ошибке, соответствующее текущему значению "
"I<errno>, а после этого символ новой строки."

#. type: Plain text
#: man-pages/man3/perror.3:77
msgid ""
"To be of most use, the argument string should include the name of the "
"function that incurred the error."
msgstr ""
"Для большей информативности в строке параметра должно быть имя функции, в "
"которой произошла ошибка."

#. type: Plain text
#: man-pages/man3/perror.3:93
msgid ""
"The global error list I<sys_errlist>[], which can be indexed by I<errno>, "
"can be used to obtain the error message without the newline.  The largest "
"message number provided in the table is I<sys_nerr>-1.  Be careful when "
"directly accessing this list, because new error values may not have been "
"added to I<sys_errlist>[].  The use of I<sys_errlist>[] is nowadays "
"deprecated; use B<strerror>(3)  instead."
msgstr ""
"Глобальный список ошибок I<sys_errlist>[], к которым можно обращаться по "
"номеру I<errno>, можно использовать для получения сообщения об ошибке без "
"символа новой строки. Самый большой номер сообщения в таблице равен "
"I<sys_nerr>-1. Будьте внимательны при прямом доступе к этому списку, так как "
"новые значения ошибок могут быть ещё не добавлены в I<sys_errlist>[]. В "
"настоящее время использование I<sys_errlist>[] не рекомендуется; вместо "
"этого используйте B<strerror>(3)."

#. type: Plain text
#: man-pages/man3/perror.3:114
msgid ""
"When a system call fails, it usually returns -1 and sets the variable "
"I<errno> to a value describing what went wrong.  (These values can be found "
"in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The function "
"B<perror>()  serves to translate this error code into human-readable form.  "
"Note that I<errno> is undefined after a successful system call or library "
"function call: this call may well change this variable, even though it "
"succeeds, for example because it internally used some other library function "
"that failed.  Thus, if a failing call is not immediately followed by a call "
"to B<perror>(), the value of I<errno> should be saved."
msgstr ""
"Когда завершается ошибкой системный вызов, обычно возвращается -1 и "
"изменяется переменная I<errno> для указания что пошло не так (её значения "
"можно найти в I<E<lt>errno.hE<gt>>). Многие библиотечные функции работают "
"также. Функция B<perror>() служит для перевода этого кода ошибки в форму, "
"понятную человеку. Заметим, что значение I<errno> не определено после "
"успешного выполнения системного вызова или библиотечной функции: этот вызов "
"может также изменить эту переменную даже при успешном выполнении, например "
"из-за ошибки другой библиотечной функции, которая вызывалась при работе. То "
"есть, если после вызова функции сразу не вызывается B<perror>(), значение "
"I<errno> нужно куда-нибудь сохранить."

#. type: tbl table
#: man-pages/man3/perror.3:124
#, no-wrap
msgid "B<perror>()"
msgstr "B<perror>()"

#. type: tbl table
#: man-pages/man3/perror.3:124
#, no-wrap
msgid "MT-Safe race:stderr"
msgstr "MT-Safe race:stderr"

#. type: Plain text
#: man-pages/man3/perror.3:131
msgid "B<perror>(), I<errno>: POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr "B<perror>(), I<errno>: POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."

#. type: Plain text
#: man-pages/man3/perror.3:137
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> derive from BSD, but are not "
"specified in POSIX.1."
msgstr ""
"Внешние I<sys_nerr> и I<sys_errlist> появились из BSD, и не описаны в "
"POSIX.1."

#.  and only when _BSD_SOURCE is defined.
#.  When
#.  .B _GNU_SOURCE
#.  is defined, the symbols
#.  .I _sys_nerr
#.  and
#.  .I _sys_errlist
#.  are provided.
#. type: Plain text
#: man-pages/man3/perror.3:152
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""
"Внешние I<sys_nerr> и I<sys_errlist> определены в glibc, но в файле "
"I<E<lt>stdio.hE<gt>>."

#. type: Plain text
#: man-pages/man3/perror.3:156
msgid "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"
msgstr "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/putgrent.3:7
#, no-wrap
msgid "PUTGRENT"
msgstr "PUTGRENT"

#. type: Plain text
#: man-pages/man3/putgrent.3:10
msgid "putgrent - write a group database entry to a file"
msgstr "putgrent - записывает базу данных групп в файл"

#. type: Plain text
#: man-pages/man3/putgrent.3:12
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man3/putgrent.3:14
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr "B<#include E<lt>grp.hE<gt>>"

#. type: Plain text
#: man-pages/man3/putgrent.3:16
msgid "B<int putgrent(const struct group *>I<grp>B<, FILE *>I<stream>B<);>"
msgstr "B<int putgrent(const struct group *>I<grp>B<, FILE *>I<stream>B<);>"

#. type: Plain text
#: man-pages/man3/putgrent.3:26
msgid ""
"The B<putgrent>()  function is the counterpart for B<fgetgrent>(3).  The "
"function writes the content of the provided I<struct group> into the "
"I<stream>.  The list of group members must be NULL-terminated or NULL-"
"initialized."
msgstr ""
"Функция B<putgrent>() ответная часть B<fgetgrent>(3). Она записывает "
"содержимое переданной I<struct group> в I<stream>. Список членов группы "
"должен завершаться NULL или быть инициализированным NULL."

#. type: Plain text
#: man-pages/man3/putgrent.3:30
msgid "The I<struct group> is defined as follows:"
msgstr "Структура I<struct group> определена следующим образом:"

#. type: Plain text
#: man-pages/man3/putgrent.3:39
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;      /* group name */\n"
"    char   *gr_passwd;    /* group password */\n"
"    gid_t   gr_gid;       /* group ID */\n"
"    char  **gr_mem;       /* group members */\n"
"};\n"
msgstr ""
"struct group {\n"
"    char   *gr_name;      /* имя группы */\n"
"    char   *gr_passwd;    /* пароль группы */\n"
"    gid_t   gr_gid;       /* идентификатор группы */\n"
"    char  **gr_mem;       /* члены группы */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/putgrent.3:43
msgid "The function returns zero on success, and a nonzero value on error."
msgstr ""
"Функция возвращает ноль при успешном выполнении и ненулевое значение при "
"ошибке."

#. type: tbl table
#: man-pages/man3/putgrent.3:53
#, no-wrap
msgid "B<putgrent>()"
msgstr "B<putgrent>()"

#. type: Plain text
#: man-pages/man3/putgrent.3:58
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/putgrent.3:61
msgid "B<fgetgrent>(3), B<getgrent>(3), B<group>(5)"
msgstr "B<fgetgrent>(3), B<getgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/pthread_attr_setaffinity_np.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETAFFINITY_NP"
msgstr "PTHREAD_ATTR_SETAFFINITY_NP"

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:30
msgid ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU "
"affinity attribute in thread attributes object"
msgstr ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - изменяет/"
"возвращает атрибут увязывания ЦП из объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:39
#, no-wrap
msgid ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(const pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:54
msgid ""
"The B<pthread_attr_setaffinity_np>()  function sets the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<cpuset>.  This attribute determines the CPU affinity "
"mask of a thread created using the thread attributes object I<attr>."
msgstr ""
"Функция B<pthread_attr_setaffinity_np>() изменяет атрибут маски увязывания "
"ЦП в объекте атрибутов нити, на который указывает I<attr>, в значение "
"I<cpuset>. Данным атрибутом определяется маска увязывания ЦП у нити, "
"созданной с учётом объекта атрибутов нити I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:63
msgid ""
"The B<pthread_attr_getaffinity_np>()  function returns the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<cpuset>."
msgstr ""
"Функция B<pthread_attr_getaffinity_np>() возвращает атрибут маски увязывания "
"ЦП из объекта атрибутов нити, на который указывает I<attr>, в буфер на "
"который указывает I<cpuset>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:70
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as "
"I<sizeof(cpu_set_t)>."
msgstr ""
"В аргументе I<cpusetsize> указывается длина буфера (в байтах), на который "
"указывает I<cpuset>. Обычно, этот аргумент должен задаваться как "
"I<sizeof(cpu_set_t)>."

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:92
msgid ""
"(B<pthread_attr_setaffinity_np>())  I<cpuset> specified a CPU that was "
"outside the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""
"(B<pthread_attr_setaffinity_np>()) В I<cpuset> указан ЦП, который находится "
"вне набора поддерживаемых ядром (в параметре сборки ядра B<CONFIG_NR_CPUS> "
"определён диапазон для набора, поддерживаемого типом данных ядра, который "
"используется для представления наборов ЦП)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:102
msgid ""
"(B<pthread_attr_getaffinity_np>())  A CPU in the affinity mask of the thread "
"attributes object referred to by I<attr> lies outside the range specified by "
"I<cpusetsize> (i.e., I<cpuset>/I<cpusetsize> is too small)."
msgstr ""
"(B<pthread_attr_getaffinity_np>()) ЦП в маске увязывания из объекта "
"атрибутов нити, на который указывает I<attr>, находится вне диапазона, "
"задаваемого I<cpusetsize> (т. е., I<cpuset>/I<cpusetsize> слишком мал)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:106
msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgstr "(B<pthread_attr_setaffinity_np>()) Невозможно выделить память."

#. type: tbl table
#: man-pages/man3/pthread_attr_setaffinity_np.3:119
#, no-wrap
msgid ""
"B<pthread_attr_setaffinity_np>(),\n"
"B<pthread_attr_getaffinity_np>()"
msgstr ""
"B<pthread_attr_setaffinity_np>(),\n"
"B<pthread_attr_getaffinity_np>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setaffinity_np.3:137
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setscope.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCOPE"
msgstr "PTHREAD_ATTR_SETSCOPE"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:30
msgid ""
"pthread_attr_setscope, pthread_attr_getscope - set/get contention scope "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setscope, pthread_attr_getscope - изменяет/возвращает атрибут "
"области конкурирования из объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"
msgstr ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(const pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:53
msgid ""
"The B<pthread_attr_setscope>()  function sets the contention scope attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<scope>.  The contention scope attribute defines the set of "
"threads against which a thread competes for resources such as the CPU.  "
"POSIX.1 specifies two possible values for I<scope>:"
msgstr ""
"Функция B<pthread_attr_setscope>() изменяет атрибут области конкурирования "
"(contention scope) в объекте атрибутов нити, на который указывает I<attr>, в "
"значение I<scope>. Данным атрибутом определяется набор нитей, с которыми "
"нить конкурирует за ресурсы (например ЦП). В POSIX.1 указаны два возможных "
"значения I<scope>:"

#. type: TP
#: man-pages/man3/pthread_attr_setscope.3:53
#, no-wrap
msgid "B<PTHREAD_SCOPE_SYSTEM>"
msgstr "B<PTHREAD_SCOPE_SYSTEM>"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:61
msgid ""
"The thread competes for resources with all other threads in all processes on "
"the system that are in the same scheduling allocation domain (a group of one "
"or more processors).  B<PTHREAD_SCOPE_SYSTEM> threads are scheduled relative "
"to one another according to their scheduling policy and priority."
msgstr ""
"Нить конкурирует за ресурсы со всеми нитями всех процессов системы, которые "
"находятся в том же домене планирования выделения (группа из одного или "
"нескольких процессоров). Нити с B<PTHREAD_SCOPE_SYSTEM> запланированы друг "
"относительно друга согласно их политике планирования и приоритета."

#. type: TP
#: man-pages/man3/pthread_attr_setscope.3:61
#, no-wrap
msgid "B<PTHREAD_SCOPE_PROCESS>"
msgstr "B<PTHREAD_SCOPE_PROCESS>"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:76
msgid ""
"The thread competes for resources with all other threads in the same process "
"that were also created with the B<PTHREAD_SCOPE_PROCESS> contention scope.  "
"B<PTHREAD_SCOPE_PROCESS> threads are scheduled relative to other threads in "
"the process according to their scheduling policy and priority.  POSIX.1 "
"leaves it unspecified how these threads contend with other threads in other "
"process on the system or with other threads in the same process that were "
"created with the B<PTHREAD_SCOPE_SYSTEM> contention scope."
msgstr ""
"Нить конкурирует за ресурсы со всеми нитями процесса, в котором она создана, "
"и которые также созданы с областью конкурирования B<PTHREAD_SCOPE_PROCESS>. "
"Нити с B<PTHREAD_SCOPE_PROCESS> запланированы относительно других нитей "
"процесса согласно их политике планирования и приоритета. В POSIX.1 не "
"указано как эти нити конкурируют с нитями из других процессов системы или с "
"другими нитями того же процесса, которые созданы с областью конкурирования "
"B<PTHREAD_SCOPE_SYSTEM>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:83
msgid ""
"POSIX.1 requires that an implementation support at least one of these "
"contention scopes.  Linux supports B<PTHREAD_SCOPE_SYSTEM>, but not "
"B<PTHREAD_SCOPE_PROCESS>."
msgstr ""
"В POSIX.1 от реализации требуется поддерживать, как минимум,  одну из этих "
"областей конкурирования. В Linux поддерживается B<PTHREAD_SCOPE_SYSTEM> и не "
"поддерживается B<PTHREAD_SCOPE_PROCESS>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:95
msgid ""
"On systems that support multiple contention scopes, then, in order for the "
"parameter setting made by B<pthread_attr_setscope>()  to have effect when "
"calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""
"В системах, где есть поддержка нескольких областей конкурирования, для учёта "
"значения параметра, заданного B<pthread_attr_setscope>(), при вызове "
"B<pthread_create>(3), вызывающий должен использовать "
"B<pthread_attr_setinheritsched>(3) для присвоения атрибуту inherit-scheduler "
"объекта атрибутов I<attr> значения B<PTHREAD_EXPLICIT_SCHED>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:103
msgid ""
"The B<pthread_attr_getscope>()  function returns the contention scope "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<scope>."
msgstr ""
"Функция B<pthread_attr_getscope>() возвращает атрибут области конкурирования "
"из объекта атрибутов нити, на который указывает I<attr>, в буфер на который "
"указывает I<scope>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:109
msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgstr ""
"Вызов B<pthread_attr_setscope>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:113
msgid "An invalid value was specified in I<scope>."
msgstr "Указано неверное значение в I<scope>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:119
msgid ""
"I<scope> specified the value B<PTHREAD_SCOPE_PROCESS>, which is not "
"supported on Linux."
msgstr ""
"Значение I<scope> равно B<PTHREAD_SCOPE_PROCESS>, которое не поддерживается "
"в Linux."

#. type: tbl table
#: man-pages/man3/pthread_attr_setscope.3:130
#, no-wrap
msgid ""
"B<pthread_attr_setscope>(),\n"
"B<pthread_attr_getscope>()"
msgstr ""
"B<pthread_attr_setscope>(),\n"
"B<pthread_attr_getscope>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:142
msgid ""
"The B<PTHREAD_SCOPE_SYSTEM> contention scope typically indicates that a user-"
"space thread is bound directly to a single kernel-scheduling entity.  This "
"is the case on Linux for the obsolete LinuxThreads implementation and the "
"modern NPTL implementation, which are both 1:1 threading implementations."
msgstr ""
"Область конкурирования B<PTHREAD_SCOPE_SYSTEM> обычно означает, что нить "
"пространства пользователя явно привязана к одной единице планирования ядра. "
"В Linux это относится как к устаревшей реализации LinuxThreads так и к новой "
"NPTL, в которых используется привязка нитей 1:1."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:145
msgid ""
"POSIX.1 specifies that the default contention scope is implementation-"
"defined."
msgstr ""
"В POSIX.1 сказано, что значение по умолчанию для области конкурирования "
"оставляется за реализацией."

#. type: Plain text
#: man-pages/man3/pthread_attr_setscope.3:154
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_mutexattr_init.3:25
#, no-wrap
msgid "PTHREAD_MUTEXATTR_INIT"
msgstr "PTHREAD_MUTEXATTR_INIT"

#. type: TH
#: man-pages/man3/pthread_mutexattr_init.3:25
#, no-wrap
msgid "2017-08-20"
msgstr "2017-08-20"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:29
msgid ""
"pthread_mutexattr_init, pthread_mutexattr_destroy - initialize and destroy a "
"mutex attributes object"
msgstr ""
"pthread_mutexattr_init, pthread_mutexattr_destroy - инициализирует и "
"уничтожает объект атрибутов мьютекса"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:35
#, no-wrap
msgid ""
"B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>\n"
"B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_mutexattr_init(pthread_mutexattr_t *>I<attr>B<);>\n"
"B<int pthread_mutexattr_destroy(pthread_mutexattr_t *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:44
msgid ""
"The B<pthread_mutexattr_init>()  function initializes the mutex attributes "
"object pointed to by I<attr> with default values for all attributes defined "
"by the implementation."
msgstr ""
"Функция B<pthread_mutexattr_init>() инициализирует объект атрибутов "
"мьютекса, на который указывает I<attr>, значениями по умолчанию для всех "
"атрибутов, определённых реализацией."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:47
msgid ""
"The results of initializing an already initialized mutex attributes object "
"are undefined."
msgstr ""
"Если для инициализации указан уже инициализированный объект атрибутов "
"мьютекса, то результат не определён."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:53
msgid ""
"The B<pthread_mutexattr_destroy>()  function destroys a mutex attribute "
"object (making it uninitialized).  Once a mutex attributes object has been "
"destroyed, it can be reinitialized with B<pthread_mutexattr_init>()."
msgstr ""
"Функция B<pthread_mutexattr_destroy>() уничтожает объект атрибутов мьютекса "
"(делает его не инициализированным). После уничтожения объекта атрибутов "
"мьютекса, его можно инициализировать с помощью B<pthread_mutexattr_init>()."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:56
msgid ""
"The results of destroying an uninitialized mutex attributes object are "
"undefined."
msgstr ""
"Если для уничтожения указан не инициализированный объект атрибутов мьютекса, "
"то результат не определён."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:64
msgid ""
"Subsequent changes to a mutex attributes object do not affect mutex that "
"have already been initialized using that object."
msgstr ""
"Изменения объекта атрибутов мьютекса не влияют на мьютексы, которые уже были "
"инициализированы с помощью этого объекта."

#. type: Plain text
#: man-pages/man3/pthread_mutexattr_init.3:70
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutexattr_getrobust>(3), "
"B<pthread_mutexattr_getpshared>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_mutex_init>(3), B<pthread_mutexattr_getrobust>(3), "
"B<pthread_mutexattr_getpshared>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_exit.3:26
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr "PTHREAD_EXIT"

#. type: Plain text
#: man-pages/man3/pthread_exit.3:29
msgid "pthread_exit - terminate calling thread"
msgstr "pthread_exit - завершает работу вызвавшей нити"

#. type: Plain text
#: man-pages/man3/pthread_exit.3:34
#, no-wrap
msgid "B<void pthread_exit(void *>I<retval>B<);>\n"
msgstr "B<void pthread_exit(void *>I<retval>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_exit.3:45
msgid ""
"The B<pthread_exit>()  function terminates the calling thread and returns a "
"value via I<retval> that (if the thread is joinable)  is available to "
"another thread in the same process that calls B<pthread_join>(3)."
msgstr ""
"Функция B<pthread_exit>() завершает работу вызвавшей нити и возвращает "
"значение через I<retval>, доступное (если к нити можно присоединиться) "
"другой нити в том же процессе, вызвавшей B<pthread_join>(3)."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:55
msgid ""
"Any clean-up handlers established by B<pthread_cleanup_push>(3)  that have "
"not yet been popped, are popped (in the reverse of the order in which they "
"were pushed)  and executed.  If the thread has any thread-specific data, "
"then, after the clean-up handlers have been executed, the corresponding "
"destructor functions are called, in an unspecified order."
msgstr ""
"Если есть какие-либо невызванные очищающие обработчики, установленные "
"B<pthread_cleanup_push>(3), то они выполняются (в обратном регистрации "
"порядке). Если у нити есть какие-либо свои данные, то после выполнения "
"очищающих обработчиков вызываются соответствующие функции удаления, в "
"неопределённом порядке."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:62
msgid ""
"When a thread terminates, process-shared resources (e.g., mutexes, condition "
"variables, semaphores, and file descriptors) are not released, and functions "
"registered using B<atexit>(3)  are not called."
msgstr ""
"Когда нить завершает выполнение связанные с процессом ресурсы (например, "
"мьютексы, условные переменные, семафоры и файловые дескрипторы) не "
"освобождаются и функции, зарегистрированные через B<atexit>(3), не "
"вызываются."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:71
msgid ""
"After the last thread in a process terminates, the process terminates as by "
"calling B<exit>(3)  with an exit status of zero; thus, process-shared "
"resources are released and functions registered using B<atexit>(3)  are "
"called."
msgstr ""
"После завершения последней нити процесса, процесс завершает работу как при "
"вызове B<exit>(3) с нулевых кодом выхода; то есть ресурсы процесса "
"освобождаются и вызываются функции, зарезервированные с помощью B<atexit>(3)."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:73
msgid "This function does not return to the caller."
msgstr "Данная функция не возвращает выполнение вызвавшему."

#. type: tbl table
#: man-pages/man3/pthread_exit.3:85
#, no-wrap
msgid "B<pthread_exit>()"
msgstr "B<pthread_exit>()"

#. type: Plain text
#: man-pages/man3/pthread_exit.3:94
msgid ""
"Performing a return from the start function of any thread other than the "
"main thread results in an implicit call to B<pthread_exit>(), using the "
"function's return value as the thread's exit status."
msgstr ""
"Выполнение возврата из начальной функции любой не главной нити приводит к "
"неявному вызову B<pthread_exit>(), возвращаемое значение которой является "
"кодом выхода нити."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:100
msgid ""
"To allow other threads to continue execution, the main thread should "
"terminate by calling B<pthread_exit>()  rather than B<exit>(3)."
msgstr ""
"Чтобы продолжить выполнение других нитей, главная нить должна завершаться "
"вызовом B<pthread_exit>(), а не B<exit>(3)."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:105
msgid ""
"The value pointed to by I<retval> should not be located on the calling "
"thread's stack, since the contents of that stack are undefined after the "
"thread terminates."
msgstr ""
"Значение, на которое указывает I<retval>, не должно располагаться в стеки "
"вызывающей нити, так как содержимое этого стека не определено после "
"завершения работы нити."

#.  Linux 2.6.27
#.  FIXME . review a later kernel to see if this gets fixed
#.  http://thread.gmane.org/gmane.linux.kernel/611611
#.  http://marc.info/?l=linux-kernel&m=122525468300823&w=2
#. type: Plain text
#: man-pages/man3/pthread_exit.3:117
msgid ""
"Currently, there are limitations in the kernel implementation logic for "
"B<wait>(2)ing on a stopped thread group with a dead thread group leader.  "
"This can manifest in problems such as a locked terminal if a stop signal is "
"sent to a foreground process whose thread group leader has already called "
"B<pthread_exit>()."
msgstr ""
"В настоящее время в реализуемой ядром логики есть ограничения для "
"остановленных групп нитей с помощью B<wait>(2) с мёртвым лидером группы "
"нитей. Из-за этого могут возникнуть такие проблемы как заблокированный "
"терминал, если сигнал останова посылается фоновому процессу, у которого "
"лидер группы нитей уже вызвал B<pthread_exit>()."

#. type: Plain text
#: man-pages/man3/pthread_exit.3:120
msgid "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_setname_np.3:26
#, no-wrap
msgid "PTHREAD_SETNAME_NP"
msgstr "PTHREAD_SETNAME_NP"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:29
msgid "pthread_setname_np, pthread_getname_np - set/get the name of a thread"
msgstr "pthread_setname_np, pthread_getname_np - изменяет/возвращает имя нити"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:36
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
"B<int pthread_setname_np(pthread_t >I<thread>B<, const char *>I<name>B<);>\n"
"B<int pthread_getname_np(pthread_t >I<thread>B<,>\n"
"B<                       char *>I<name>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
"B<int pthread_setname_np(pthread_t >I<thread>B<, const char *>I<name>B<);>\n"
"B<int pthread_getname_np(pthread_t >I<thread>B<,>\n"
"B<                       char *>I<name>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:55
msgid ""
"By default, all the threads created using B<pthread_create>()  inherit the "
"program name.  The B<pthread_setname_np>()  function can be used to set a "
"unique name for a thread, which can be useful for debugging multithreaded "
"applications.  The thread name is a meaningful C language string, whose "
"length is restricted to 16 characters, including the terminating null byte "
"(\\(aq\\e0\\(aq).  The I<thread> argument specifies the thread whose name is "
"to be changed; I<name> specifies the new name."
msgstr ""
"По умолчанию, все нити, созданные B<pthread_create>(), наследуют имя "
"программы. Функция B<pthread_setname_np>() позволяет задать уникальное имя "
"нити, которое можно использовать при отладки многонитевых приложений. Имя "
"нити задаётся по правилам строк языка C, его длина ограничена 16 символами, "
"включая конечный байт null (\\(aq\\e0\\(aq). В аргументе I<thread> "
"указывается нить, чьё имя будет изменено; в I<name> указывается новое имя."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:72
msgid ""
"The B<pthread_getname_np>()  function can be used to retrieve the name of "
"the thread.  The I<thread> argument specifies the thread whose name is to be "
"retrieved.  The buffer I<name> is used to return the thread name; I<len> "
"specifies the number of bytes available in I<name>.  The buffer specified by "
"I<name> should be at least 16 characters in length.  The returned thread "
"name in the output buffer will be null terminated."
msgstr ""
"Функция B<pthread_getname_np>() возвращает имя нити. В аргументе I<thread> "
"указывает нить, чьё имя будет возвращено. В буфер I<name> возвращается имя "
"нити; в аргументе I<len> указывается количество байт, доступное в I<name>. "
"Длина буфера I<name> должна быть не менее 16 символов. Возвращаемое имя в "
"выходном буфере завершается байтом null."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:79
msgid ""
"The B<pthread_setname_np>()  function can fail with the following error:"
msgstr ""
"Функция B<pthread_setname_np>() может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:84
msgid ""
"The length of the string specified pointed to by I<name> exceeds the allowed "
"limit."
msgstr "Длина строки, на которую ссылается I<name>, превышает разрешённую."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:88
msgid ""
"The B<pthread_getname_np>()  function can fail with the following error:"
msgstr ""
"Функция B<pthread_getname_np>() может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:95
msgid ""
"The buffer specified by I<name> and I<len> is too small to hold the thread "
"name."
msgstr "Буфер, задаваемый I<name> и I<len>, слишком мал для имени нити."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:100
msgid ""
"If either of these functions fails to open I</proc/self/task/[tid]/comm>, "
"then the call may fail with one of the errors described in B<open>(2)."
msgstr ""
"Если одна из этих функций завершается с ошибкой открытия I</proc/self/task/"
"[tid]/comm>, то вызов может завершиться одной из ошибок, описанных в "
"B<open>(2)."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:102
msgid "These functions first appeared in glibc in version 2.12."
msgstr "Эти функции впервые появились в glibc 2.12."

#. type: tbl table
#: man-pages/man3/pthread_setname_np.3:113
#, no-wrap
msgid ""
"B<pthread_setname_np>(),\n"
"B<pthread_getname_np>()"
msgstr ""
"B<pthread_setname_np>(),\n"
"B<pthread_getname_np>()"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:129
msgid ""
"B<pthread_setname_np>()  internally writes to the thread-specific I<comm> "
"file under the I</proc> filesystem: I</proc/self/task/[tid]/comm>.  "
"B<pthread_getname_np>()  retrieves it from the same location."
msgstr ""
"Запись B<pthread_setname_np>() выполняет через файл нити I<comm> из файловой "
"системы I</proc>: I</proc/self/task/[tid]/comm>. Функция "
"B<pthread_getname_np>() также используется его для возврата имени."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:135
msgid ""
"The program below demonstrates the use of B<pthread_setname_np>()  and "
"B<pthread_getname_np>()."
msgstr ""
"Представленная ниже программа показывает использование "
"B<pthread_setname_np>() и B<pthread_getname_np>()."

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:137
msgid "The following shell session shows a sample run of the program:"
msgstr "Пример сеанса работы с программой:"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:153
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Created a thread. Default name is: a.out\n"
"The thread name after setting it is THREADFOO.\n"
"B<^Z>                           # Suspend the program\n"
"[1]+  Stopped           ./a.out\n"
"$ B<ps H -C a.out -o 'pid tid cmd comm'>\n"
"  PID   TID CMD                         COMMAND\n"
" 5990  5990 ./a.out                     a.out\n"
" 5990  5991 ./a.out                     THREADFOO\n"
"$ B<cat /proc/5990/task/5990/comm>\n"
"a.out\n"
"$ B<cat /proc/5990/task/5991/comm>\n"
"THREADFOO\n"
msgstr ""
"$B< ./a.out>\n"
"Нить создана. Имя по умолчанию: a.out\n"
"Имя нити после изменения — THREADFOO.\n"
"B<^Z>                           # Приостановка программы\n"
"[1]+  Stopped           ./a.out\n"
"$ B<ps H -C a.out -o 'pid tid cmd comm'>\n"
"  PID   TID CMD                         COMMAND\n"
" 5990  5990 ./a.out                     a.out\n"
" 5990  5991 ./a.out                     THREADFOO\n"
"$ B<cat /proc/5990/task/5990/comm>\n"
"a.out\n"
"$ B<cat /proc/5990/task/5991/comm>\n"
"THREADFOO\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:165
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:167
#, no-wrap
msgid "#define NAMELEN 16\n"
msgstr "#define NAMELEN 16\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:171
#, no-wrap
msgid ""
"#define errExitEN(en, msg) \\e\n"
"            do { errno = en; perror(msg); exit(EXIT_FAILURE); \\e\n"
"        } while (0)\n"
msgstr ""
"#define errExitEN(en, msg) \\e\n"
"            do { errno = en; perror(msg); exit(EXIT_FAILURE); \\e\n"
"        } while (0)\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:178
#, no-wrap
msgid ""
"static void *\n"
"threadfunc(void *parm)\n"
"{\n"
"    sleep(5);          // allow main program to set the thread name\n"
"    return NULL;\n"
"}\n"
msgstr ""
"static void *\n"
"threadfunc(void *parm)\n"
"{\n"
"    sleep(5);          // позволить главной программе изменить имя нити\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:185
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    pthread_t thread;\n"
"    int rc;\n"
"    char thread_name[NAMELEN];\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    pthread_t thread;\n"
"    int rc;\n"
"    char thread_name[NAMELEN];\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:189
#, no-wrap
msgid ""
"    rc = pthread_create(&thread, NULL, threadfunc, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_create\");\n"
msgstr ""
"    rc = pthread_create(&thread, NULL, threadfunc, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:193
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name, NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
msgstr ""
"    rc = pthread_getname_np(thread, thread_name, NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:198
#, no-wrap
msgid ""
"    printf(\"Created a thread. Default name is: %s\\en\", thread_name);\n"
"    rc = pthread_setname_np(thread, (argc E<gt> 1) ? argv[1] : \"THREADFOO\");\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_setname_np\");\n"
msgstr ""
"    printf(\"Нить создана. Имя по умолчанию: %s\\en\", thread_name);\n"
"    rc = pthread_setname_np(thread, (argc E<gt> 1) ? argv[1] : \"THREADFOO\");\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_setname_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:206
#, no-wrap
msgid ""
"    rc = pthread_getname_np(thread, thread_name,\n"
"                            (argc E<gt> 2) ? atoi(argv[1]) : NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
"    printf(\"The thread name after setting it is %s.\\en\", thread_name);\n"
msgstr ""
"    rc = pthread_getname_np(thread, thread_name,\n"
"                            (argc E<gt> 2) ? atoi(argv[1]) : NAMELEN);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_getname_np\");\n"
"    printf(\"Имя нити после изменения — %s.\\en\", thread_name);\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:210
#, no-wrap
msgid ""
"    rc = pthread_join(thread, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_join\");\n"
msgstr ""
"    rc = pthread_join(thread, NULL);\n"
"    if (rc != 0)\n"
"        errExitEN(rc, \"pthread_join\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:214
#, no-wrap
msgid ""
"    printf(\"Done\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Done\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setname_np.3:220
msgid "B<prctl>(2), B<pthread_create>(3), B<pthreads>(7)"
msgstr "B<prctl>(2), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_getattr_default_np.3:25
#, no-wrap
msgid "PTHREAD_GETATTR_DEFAULT_NP"
msgstr "PTHREAD_GETATTR_DEFAULT_NP"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:29
msgid ""
"pthread_getattr_default_np, pthread_setattr_default_np, - get or set default "
"thread-creation attributes"
msgstr ""
"pthread_getattr_default_np, pthread_setattr_default_np - возврат или "
"изменение атрибутов создания нити по умолчанию"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:36
#, no-wrap
msgid ""
"B<int pthread_getattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_setattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_getattr_default_np(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_setattr_default_np(pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:50
msgid ""
"The B<pthread_setattr_default_np>()  function sets the default attributes "
"used for creation of a new thread\\(emthat is, the attributes that are used "
"when B<pthread_create>(3)  is called with a second argument that is NULL.  "
"The default attributes are set using the attributes supplied in I<*attr>, a "
"previously initialized thread attributes object.  Note the following details "
"about the supplied attributes object:"
msgstr ""
"Функция B<pthread_setattr_default_np>() изменяет атрибуты по умолчанию, "
"используемые при создании новой нити — то есть атрибуты, которые "
"используются при вызове B<pthread_create>(3) со вторым аргументом, равным "
"NULL. Атрибуты по умолчанию изменяются в соответствии с атрибутами, "
"переданными в I<*attr> — объекте атрибутов нити, инициализированном ранее. "
"Вот, что нужно знать об объекте атрибутов:"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:52
msgid "The attribute settings in the object must be valid."
msgstr "Значения атрибутов в объекте должны быть корректными."

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:56
msgid "The I<stack address> attribute must not be set in the object."
msgstr "Атрибут I<stack address> не должен быть указан в объекте."

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:60
msgid ""
"Setting the I<stack size> attribute to zero means leave the default stack "
"size unchanged."
msgstr ""
"Значение нуля в I<stack size> означает, что размер стека по умолчанию "
"остаётся без изменения."

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:66
msgid ""
"The B<pthread_getattr_default_np>()  function initializes the thread "
"attributes object referred to by I<attr> so that it contains the default "
"attributes used for thread creation."
msgstr ""
"Функция B<pthread_getattr_default_np>() инициализирует объект атрибутов "
"нити, на который указывает I<attr>, так, что он содержит значения атрибутов "
"по умолчанию, использованные при создании нити."

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:74
msgid ""
"(B<pthread_setattr_default_np>())  One of the attribute settings in I<attr> "
"is invalid, or the stack address attribute is set in I<attr>."
msgstr ""
"(B<pthread_setattr_default_np>()) Одно из значений атрибутов в I<attr> "
"неверно или в I<attr> изменён атрибут адреса стека."

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:79
msgid "(B<pthread_setattr_default_np>())  Insufficient memory."
msgstr "(B<pthread_setattr_default_np>())  Недостаточно памяти."

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:81
msgid "These functions are available in glibc since version 2.18."
msgstr "Эти функции доступны в glibc начиная с версии 2.18."

#. type: tbl table
#: man-pages/man3/pthread_getattr_default_np.3:93
#, no-wrap
msgid ""
"B<pthread_getattr_default_np>(),\n"
"B<pthread_setattr_default_np>()"
msgstr ""
"B<pthread_getattr_default_np>(),\n"
"B<pthread_setattr_default_np>()"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:99
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in their names."
msgstr ""
"Данные функции являются не стандартизированными расширениями GNU, о чём "
"свидетельствует наличие суффикса «_np» (nonportable)."

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:105
msgid ""
"The program below uses B<pthread_getattr_default_np>()  to fetch the default "
"thread-creation attributes and then displays various settings from the "
"returned thread attributes object.  When running the program, we see the "
"following output:"
msgstr ""
"В программе, показанной далее, используется B<pthread_getattr_default_np()> "
"для получения атрибутов создания нити по умолчанию, а затем выводятся "
"различные параметры полученного объекта. Вывод работы программы:"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:115
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Stack size:          8388608\n"
"Guard size:          4096\n"
"Scheduling policy:   SCHED_OTHER\n"
"Scheduling priority: 0\n"
"Detach state:        JOINABLE\n"
"Inherit scheduler:   INHERIT\n"
msgstr ""
"$ B<./a.out>\n"
"Размер стека:          8388608\n"
"Размер защиты:          4096\n"
"Алгоритм планирования:   SCHED_OTHER\n"
"Приоритет планирования: 0\n"
"Состояние отсоединения:        JOINABLE\n"
"Наследование планировщика:   INHERIT\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:141
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr)\n"
"{\n"
"    int s;\n"
"    size_t stacksize;\n"
"    size_t guardsize;\n"
"    int policy;\n"
"    struct sched_param schedparam;\n"
"    int detachstate;\n"
"    int inheritsched;\n"
msgstr ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr)\n"
"{\n"
"    int s;\n"
"    size_t stacksize;\n"
"    size_t guardsize;\n"
"    int policy;\n"
"    struct sched_param schedparam;\n"
"    int detachstate;\n"
"    int inheritsched;\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:146
#, no-wrap
msgid ""
"    s = pthread_attr_getstacksize(attr, &stacksize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getstacksize\");\n"
"    printf(\"Stack size:          %zd\\en\", stacksize);\n"
msgstr ""
"    s = pthread_attr_getstacksize(attr, &stacksize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getstacksize\");\n"
"    printf(\"Размер стека:          %zd\\en\", stacksize);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:151
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guardsize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"Guard size:          %zd\\en\", guardsize);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &guardsize);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"Размер защиты:          %zd\\en\", guardsize);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:159
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &policy);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"Scheduling policy:   %s\\en\",\n"
"            (policy == SCHED_FIFO) ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR) ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" : \"[unknown]\");\n"
msgstr ""
"    s = pthread_attr_getschedpolicy(attr, &policy);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"Алгоритм планирования:   %s\\en\",\n"
"            (policy == SCHED_FIFO) ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR) ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" : \"[неизвестно]\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:164
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &schedparam);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"Scheduling priority: %d\\en\", schedparam.sched_priority);\n"
msgstr ""
"    s = pthread_attr_getschedparam(attr, &schedparam);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"Приоритет планирования: %d\\en\", schedparam.sched_priority);\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:172
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &detachstate);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"Detach state:        %s\\en\",\n"
"            (detachstate == PTHREAD_CREATE_DETACHED) ? \"DETACHED\" :\n"
"            (detachstate == PTHREAD_CREATE_JOINABLE) ? \"JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getdetachstate(attr, &detachstate);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"Состояние отсоединения:        %s\\en\",\n"
"            (detachstate == PTHREAD_CREATE_DETACHED) ? \"DETACHED\" :\n"
"            (detachstate == PTHREAD_CREATE_JOINABLE) ? \"JOINABLE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:181
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &inheritsched);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"Inherit scheduler:   %s\\en\",\n"
"            (inheritsched == PTHREAD_INHERIT_SCHED) ? \"INHERIT\" :\n"
"            (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""
"    s = pthread_attr_getinheritsched(attr, &inheritsched);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"Наследование планировщика:   %s\\en\",\n"
"            (inheritsched == PTHREAD_INHERIT_SCHED) ? \"INHERIT\" :\n"
"            (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"            \"???\");\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:187
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:191
#, no-wrap
msgid ""
"    s = pthread_getattr_default_np(&attr);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_getattr_default_np\");\n"
msgstr ""
"    s = pthread_getattr_default_np(&attr);\n"
"    if (s != 0)\n"
"        errExitEN(s, \"pthread_getattr_default_np\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getattr_default_np.3:193
#, no-wrap
msgid "    display_pthread_attr(&attr);\n"
msgstr "    display_pthread_attr(&attr);\n"

#. type: TH
#: man-pages/man3/pthread_join.3:26
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr "PTHREAD_JOIN"

#. type: Plain text
#: man-pages/man3/pthread_join.3:29
msgid "pthread_join - join with a terminated thread"
msgstr "pthread_join - присоединение к завершённой нити"

#. type: Plain text
#: man-pages/man3/pthread_join.3:34
#, no-wrap
msgid "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_join.3:49
msgid ""
"The B<pthread_join>()  function waits for the thread specified by I<thread> "
"to terminate.  If that thread has already terminated, then "
"B<pthread_join>()  returns immediately.  The thread specified by I<thread> "
"must be joinable."
msgstr ""
"Функция B<pthread_join>() ждёт завершения нити, указанной в I<thread>. Если "
"нить уже завершила работу, то B<pthread_join>() завершается сразу. Нить, "
"задаваемая в I<thread>, должна позволять присоединение."

#. type: Plain text
#: man-pages/man3/pthread_join.3:63
msgid ""
"If I<retval> is not NULL, then B<pthread_join>()  copies the exit status of "
"the target thread (i.e., the value that the target thread supplied to "
"B<pthread_exit>(3))  into the location pointed to by I<retval>.  If the "
"target thread was canceled, then B<PTHREAD_CANCELED> is placed in the "
"location pointed to by I<retval>."
msgstr ""
"Если I<retval> не равно NULL, то B<pthread_join>() копирует код выхода нити "
"назначения (т. е., значение, которое нить назначения передала через "
"B<pthread_exit>(3)) в расположение по указателю I<retval>.  Если нить "
"назначения была отменена, то в расположение по указателю I<retval> "
"помещается значение B<PTHREAD_CANCELED>."

#. type: Plain text
#: man-pages/man3/pthread_join.3:70
msgid ""
"If multiple threads simultaneously try to join with the same thread, the "
"results are undefined.  If the thread calling B<pthread_join>()  is "
"canceled, then the target thread will remain joinable (i.e., it will not be "
"detached)."
msgstr ""
"Если к одной нити одновременно пытаются присоединиться несколько нитей, то "
"результат не определён. Если нити вызвавшая B<pthread_join>(), отменяется, "
"то нить назначения остаётся доступной для присоединения (т. е., не будет "
"отсоединена)."

#. type: Plain text
#: man-pages/man3/pthread_join.3:75
msgid ""
"On success, B<pthread_join>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"При успешном выполнении B<pthread_join>() возвращается 0; при ошибке "
"возвращается номер ошибки."

#. type: TP
#: man-pages/man3/pthread_join.3:76
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#.  The following verified by testing on glibc 2.8/NPTL:
#.  The following verified by testing on glibc 2.8/NPTL:
#. type: Plain text
#: man-pages/man3/pthread_join.3:85
msgid ""
"A deadlock was detected (e.g., two threads tried to join with each other); "
"or I<thread> specifies the calling thread."
msgstr ""
"Обнаружена взаимная блокировка (например, когда две нити пытаются "
"присоединиться друг к другу); или в I<thread> указана вызывающая нить."

#.  POSIX.1-2001 does not specify this error case.
#. type: Plain text
#: man-pages/man3/pthread_join.3:93
msgid "Another thread is already waiting to join with this thread."
msgstr "Другая нить уже ждёт присоединения к этой нити."

#. type: tbl table
#: man-pages/man3/pthread_join.3:108
#, no-wrap
msgid "B<pthread_join>()"
msgstr "B<pthread_join>()"

#. type: Plain text
#: man-pages/man3/pthread_join.3:120
msgid ""
"After a successful call to B<pthread_join>(), the caller is guaranteed that "
"the target thread has terminated.  The caller may then choose to do any "
"clean-up that is required after termination of the thread (e.g., freeing "
"memory or other resources that were allocated to the target thread)."
msgstr ""
"После успешного выполнения B<pthread_join>() вызывающему гарантируется, что "
"целевая нить завершила работу. Вызывающий теперь может сделать нужные после "
"завершения нити операции по очистке (например, освободить память или другие "
"ресурсы, которые использовались целевой нитью)."

#. type: Plain text
#: man-pages/man3/pthread_join.3:123
msgid ""
"Joining with a thread that has previously been joined results in undefined "
"behavior."
msgstr ""
"Присоединение к нити, из которой уже был получен результат присоединения, "
"приводит к непредсказуемым последствиям."

#. type: Plain text
#: man-pages/man3/pthread_join.3:131
msgid ""
"Failure to join with a thread that is joinable (i.e., one that is not "
"detached), produces a \"zombie thread\".  Avoid doing this, since each "
"zombie thread consumes some system resources, and when enough zombie threads "
"have accumulated, it will no longer be possible to create new threads (or "
"processes)."
msgstr ""
"Ошибка присоединения к нити, доступной для присоединения (т. е., не "
"отсоединённой), создаёт «нить-зомби». Лучше их избегать, так как нить-зомби "
"потребляет некоторые системные ресурсы, и когда накапливается много нитей-"
"зомби становится невозможно создание новых нитей (или процессов)."

#. type: Plain text
#: man-pages/man3/pthread_join.3:137
msgid ""
"There is no pthreads analog of I<waitpid(-1,\\ &status,\\ 0)>, that is, "
"\"join with any terminated thread\".  If you believe you need this "
"functionality, you probably need to rethink your application design."
msgstr ""
"Аналога I<waitpid(-1,\\ &status,\\ 0)> в pthreads не существует, то есть "
"присоединиться к любой завершившейся нити». Если вы уверены, что вам нужна "
"такая возможность, то, вероятно, стоит пересмотреть проект приложения."

#. type: Plain text
#: man-pages/man3/pthread_join.3:140
msgid ""
"All of the threads in a process are peers: any thread can join with any "
"other thread in the process."
msgstr ""
"Все нити в процессе равноправны: любая нить может присоединиться к любой "
"другой нити процесса."

#. type: Plain text
#: man-pages/man3/pthread_join.3:149
msgid ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPARAM"
msgstr "PTHREAD_ATTR_SETSCHEDPARAM"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:30
msgid ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling "
"parameter attributes in thread attributes object"
msgstr ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - изменяет/возвращает "
"атрибуты параметров планирования из объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(const pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:52
msgid ""
"The B<pthread_attr_setschedparam>()  function sets the scheduling parameter "
"attributes of the thread attributes object referred to by I<attr> to the "
"values specified in the buffer pointed to by I<param>.  These attributes "
"determine the scheduling parameters of a thread created using the thread "
"attributes object I<attr>."
msgstr ""
"Функция B<pthread_attr_setschedparam>() изменяет атрибуты параметров "
"планирования в объекте атрибутов нити, на который указывает I<attr>, в "
"значения из буфера, на который указывает I<param>. Данными атрибутами "
"определяются параметры планирования нити, созданной с учётом объекта "
"атрибутов нити I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:59
msgid ""
"The B<pthread_attr_getschedparam>()  returns the scheduling parameter "
"attributes of the thread attributes object I<attr> in the buffer pointed to "
"by I<param>."
msgstr ""
"Функция B<pthread_attr_getschedparam>() возвращает атрибуты параметров "
"планирования у объекта атрибутов нити, на который указывает I<attr>, в буфер "
"на который указывает I<param>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:61
msgid "Scheduling parameters are maintained in the following structure:"
msgstr "Параметры планирования хранятся в структуре следующего вида:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:67
#, no-wrap
msgid ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"
msgstr ""
"struct sched_param {\n"
"    int sched_priority;     /* планируемый приоритет */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:74
msgid ""
"As can be seen, only one scheduling parameter is supported.  For details of "
"the permitted ranges for scheduling priorities in each scheduling policy, "
"see B<sched>(7)."
msgstr ""
"Из той структуры видно, что поддерживается только один параметр. Подробности "
"о разрешённых диапазонах планируемых приоритетов для каждого алгоритма "
"планирования смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:85
msgid ""
"In order for the parameter setting made by B<pthread_attr_setschedparam>()  "
"to have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""
"Для учёта значения параметра, заданного B<pthread_attr_setschedparam>(), при "
"вызове B<pthread_create>(3), вызывающий должен использовать "
"B<pthread_attr_setinheritsched>(3) для присвоения атрибуту inherit-scheduler "
"объекта атрибутов I<attr> значения B<PTHREAD_EXPLICIT_SCHED>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:91
msgid "B<pthread_attr_setschedparam>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_attr_setschedparam>() может завершиться со следующей "
"ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:97
msgid ""
"The priority specified in I<param> does not make sense for the current "
"scheduling policy of I<attr>."
msgstr ""
"Приоритет, указанный в I<param>, не имеет смысла при текущей политике "
"планирования I<attr>."

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:107
msgid ""
"POSIX.1 also documents an B<ENOTSUP> error for "
"B<pthread_attr_setschedparam>().  This value is never returned on Linux (but "
"portable and future-proof applications should nevertheless handle this error "
"return value)."
msgstr ""
"В POSIX.1 также описана ошибка B<ENOTSUP> для "
"B<pthread_attr_setschedparam>(). Это значение никогда не возвращается Linux "
"(тем не менее, в переносимых и новых приложениях нужно учитывать возможность "
"возврата этого значения ошибки)."

#. type: tbl table
#: man-pages/man3/pthread_attr_setschedparam.3:118
#, no-wrap
msgid ""
"B<pthread_attr_setschedparam>(),\n"
"B<pthread_attr_getschedparam>()"
msgstr ""
"B<pthread_attr_setschedparam>(),\n"
"B<pthread_attr_getschedparam>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:126
msgid ""
"See B<pthread_attr_setschedpolicy>(3)  for a list of the thread scheduling "
"policies supported on Linux."
msgstr ""
"Список алгоритмов планирования для нитей, поддерживаемых в Linux смотрите в "
"B<pthread_attr_setschedpolicy>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:129
msgid "See B<pthread_setschedparam>(3)."
msgstr "Смотрите B<pthread_setschedparam>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedparam.3:140
msgid ""
"B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: man-pages/man3/pthread_self.3:26
#, no-wrap
msgid "PTHREAD_SELF"
msgstr "PTHREAD_SELF"

#. type: Plain text
#: man-pages/man3/pthread_self.3:29
msgid "pthread_self - obtain ID of the calling thread"
msgstr "pthread_self - возвращает ID вызвавшей нити"

#. type: Plain text
#: man-pages/man3/pthread_self.3:34
#, no-wrap
msgid "B<pthread_t pthread_self(void);>\n"
msgstr "B<pthread_t pthread_self(void);>\n"

#. type: Plain text
#: man-pages/man3/pthread_self.3:46
msgid ""
"The B<pthread_self>()  function returns the ID of the calling thread.  This "
"is the same value that is returned in I<*thread> in the "
"B<pthread_create>(3)  call that created this thread."
msgstr ""
"Функция B<pthread_self>() возвращает идентификатор вызвавшей нити. Это "
"значение совпадает с возвращаемым в I<*thread> вызовом B<pthread_create>(3) "
"при создании этой нити."

#. type: Plain text
#: man-pages/man3/pthread_self.3:48
msgid "This function always succeeds, returning the calling thread's ID."
msgstr ""
"Данная функция всегда завершается успешно, возвращая идентификатор вызвавшей "
"нити."

#. type: tbl table
#: man-pages/man3/pthread_self.3:60
#, no-wrap
msgid "B<pthread_self>()"
msgstr "B<pthread_self>()"

#. type: Plain text
#: man-pages/man3/pthread_self.3:75
msgid ""
"POSIX.1 allows an implementation wide freedom in choosing the type used to "
"represent a thread ID; for example, representation using either an "
"arithmetic type or a structure is permitted.  Therefore, variables of type "
"I<pthread_t> can't portably be compared using the C equality operator "
"(B<==>); use B<pthread_equal>(3)  instead."
msgstr ""
"В POSIX.1 предоставляет реализации большую свободу выбора типа, "
"используемого под идентификатор нити; например, допускается представление "
"как виде целого числа так и структуры. Поэтому переменные типа I<pthread_t> "
"нельзя сравнивать оператором равенства C (B<==>); для этого предназначена "
"функция B<pthread_equal>(3)."

#. type: Plain text
#: man-pages/man3/pthread_self.3:79
msgid ""
"Thread identifiers should be considered opaque: any attempt to use a thread "
"ID other than in pthreads calls is nonportable and can lead to unspecified "
"results."
msgstr ""
"Состав идентификаторов нити следует считать «чёрным ящиком»: все попытки "
"использовать ID нити кроме как в вызовах pthreads являются непереносимыми и "
"могут приводить к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/pthread_self.3:83
msgid ""
"Thread IDs are guaranteed to be unique only within a process.  A thread ID "
"may be reused after a terminated thread has been joined, or a detached "
"thread has terminated."
msgstr ""
"Для идентификаторов нити гарантируется их уникальность только внутри "
"процесса. Идентификатор нити может использоваться повторно после "
"присоединения завершённой нити или завершения отключённой нити."

#. type: Plain text
#: man-pages/man3/pthread_self.3:88
msgid ""
"The thread ID returned by B<pthread_self>()  is not the same thing as the "
"kernel thread ID returned by a call to B<gettid>(2)."
msgstr ""
"Идентификатор нити, возвращаемый B<pthread_self>() не тоже самое что "
"идентификатор нити возвращаемый вызовом ядра B<gettid>(2)."

#. type: Plain text
#: man-pages/man3/pthread_self.3:91
msgid "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_sigmask.3:26
#, no-wrap
msgid "PTHREAD_SIGMASK"
msgstr "PTHREAD_SIGMASK"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:29
msgid "pthread_sigmask - examine and change mask of blocked signals"
msgstr "pthread_sigmask - проверяет и изменяет маску заблокированных сигналов"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:35
#, no-wrap
msgid "B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"
msgstr "B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:46
msgid "B<pthread_sigmask>():"
msgstr "B<pthread_sigmask>():"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:48
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 199506L || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 199506L || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:58
msgid ""
"The B<pthread_sigmask>()  function is just like B<sigprocmask>(2), with the "
"difference that its use in multithreaded programs is explicitly specified by "
"POSIX.1.  Other differences are noted in this page."
msgstr ""
"Функция B<pthread_sigmask>() подобна B<sigprocmask>(2), но используется в "
"многонитевых программах, что явно указано в POSIX.1. Другие отличия "
"приведены в этой странице."

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:61
msgid ""
"For a description of the arguments and operation of this function, see "
"B<sigprocmask>(2)."
msgstr "Описание аргументов и работы функции смотрите в B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:66
msgid ""
"On success, B<pthread_sigmask>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"При успешном выполнении B<pthread_sigmask>() возвращается 0; при ошибке "
"возвращается номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:69
msgid "See B<sigprocmask>(2)."
msgstr "Смотрите B<sigprocmask>(2)."

#. type: tbl table
#: man-pages/man3/pthread_sigmask.3:79
#, no-wrap
msgid "B<pthread_sigmask>()"
msgstr "B<pthread_sigmask>()"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:85
msgid "A new thread inherits a copy of its creator's signal mask."
msgstr "Новая нить наследует копию маски сигналов своего создателя."

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:93
msgid ""
"The glibc B<pthread_sigmask>()  function silently ignores attempts to block "
"the two real-time signals that are used internally by the NPTL threading "
"implementation.  See B<nptl>(7)  for details."
msgstr ""
"Функция glibc B<pthread_sigmask>() просто игнорирует попытки блокирования "
"двух сигналов реального времени, которые используются внутри реализации "
"NPTL. Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:98
msgid ""
"The program below blocks some signals in the main thread, and then creates a "
"dedicated thread to fetch those signals via B<sigwait>(3).  The following "
"shell session demonstrates its use:"
msgstr ""
"Показанная далее программа блокирует некоторые сигналы в главной нити, а "
"затем создаёт отдельную нить для получения этих сигналов с помощью "
"B<sigwait>(3). Пример работы программы:"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:109
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"
msgstr ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Нить обработки сигналов получила сигнал 3\n"
"$B< kill -USR1 %1>\n"
"Нить обработки сигналов получила сигнал 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:120
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:122
#, no-wrap
msgid "/* Simple error handling functions */\n"
msgstr "/* Простая функция обработки сигналов */\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:131
#, no-wrap
msgid ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = arg;\n"
"    int s, sig;\n"
msgstr ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = arg;\n"
"    int s, sig;\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:139
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"
msgstr ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Нить обработки сигналов получила сигнал %d\\en\", sig);\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:146
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:149
#, no-wrap
msgid ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"
msgstr ""
"    /* Блокируем SIGQUIT и SIGUSR1; нити, созданные main(),\n"
"       унаследуют копию маски сигналов. */\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:156
#, no-wrap
msgid ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"
msgstr ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:160
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:163
#, no-wrap
msgid ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"
msgstr ""
"    /* Главная нить служит для создания других нитей и/или\n"
"       выполняет другую работу */\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:166
#, no-wrap
msgid ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"
msgstr ""
"    pause();            /* Просто пауза, чтобы мы могли протестировать\n"
"                           программу */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_sigmask.3:175
msgid ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<pthread_create>(3), "
"B<pthread_kill>(3), B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<pthread_create>(3), "
"B<pthread_kill>(3), B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: man-pages/man3/posix_memalign.3:29
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr "POSIX_MEMALIGN"

#. type: TH
#: man-pages/man3/posix_memalign.3:29
#, no-wrap
msgid "2019-05-09"
msgstr "2019-05-09"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:32
msgid ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - allocate aligned "
"memory"
msgstr ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - выделяет "
"выровненную область памяти"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"
msgstr ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:41
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr "B<#include E<lt>malloc.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:44
#, no-wrap
msgid ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"
msgstr ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:54
msgid "B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:57
msgid "B<aligned_alloc>(): _ISOC11_SOURCE"
msgstr "B<aligned_alloc>(): _ISOC11_SOURCE"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:59
msgid "B<valloc>():"
msgstr "B<valloc>():"

#. type: TP
#: man-pages/man3/posix_memalign.3:62
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:68
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: TP
#: man-pages/man3/posix_memalign.3:70
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/posix_memalign.3:74
msgid "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:81
msgid ""
"(The (nonstandard) header file I<E<lt>malloc.hE<gt>> also exposes the "
"declaration of B<valloc>(); no feature test macros are required.)"
msgstr ""
"(Заголовочный файл I<E<lt>malloc.hE<gt>> (нестандартный) также содержит "
"объявление B<valloc>(); макросов тестирования свойств не требуется)"

#.  glibc does this:
#. type: Plain text
#: man-pages/man3/posix_memalign.3:103
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated "
"memory will be a multiple of I<alignment>, which must be a power of two and "
"a multiple of I<sizeof(void\\ *)>.  If I<size> is 0, then the value placed "
"in I<*memptr> is either NULL, or a unique pointer value that can later be "
"successfully passed to B<free>(3)."
msgstr ""
"Функция B<posix_memalign>() выделяет I<size> байт и помещает адрес "
"выделенной памяти в I<*memptr>. Этот адрес будет кратен значению "
"I<alignment>, которое должно быть степенью двойки и кратно I<sizeof(void\\ "
"*)>. Если I<size> равно 0, то значение, помещаемое в I<*memptr>, равно NULL, "
"или является уникальным значением указателя, который позднее можно "
"передавать в B<free>(3)."

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: man-pages/man3/posix_memalign.3:114
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<alignment>, which must be a power of two."
msgstr ""
"Устаревшая функция B<memalign>() выделяет I<size> байт и возвращает "
"указатель на выделенную память. Адрес памяти будет кратен значению "
"I<alignment>, которое должны быть степенью двойки."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:123
msgid ""
"The function B<aligned_alloc>()  is the same as B<memalign>(), except for "
"the added restriction that I<size> should be a multiple of I<alignment>."
msgstr ""
"Функция B<aligned_alloc>() подобна B<memalign>(), но добавляет ограничение "
"для значения I<size>, которое должно быть кратно I<alignment>."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:132
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""
"Устаревшая функция B<valloc>() выделяет I<size> байт и возвращает указатель "
"на выделенную память. Адрес памяти будет кратен размеру страницы. Она "
"эквивалентна вызову I<memalign(sysconf(_SC_PAGESIZE),size)>."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:139
msgid ""
"The obsolete function B<pvalloc>()  is similar to B<valloc>(), but rounds "
"the size of the allocation up to the next multiple of the system page size."
msgstr ""
"Устаревшая функция B<pvalloc>() подобна B<valloc>(), но округляет выделяемый "
"размер до следующего кратного значения системной страницы."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:141
msgid "For all of these functions, the memory is not zeroed."
msgstr "Эти функции не обнуляют выделяемую память."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:150
msgid ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return a "
"pointer to the allocated memory on success.  On error, NULL is returned, and "
"I<errno> is set to indicate the cause of the error."
msgstr ""
"Функции B<aligned_alloc>(), B<memalign>(), B<valloc>() и B<pvalloc>() при "
"успешном выполнении возвращают указатель на выделенную память. При ошибке "
"возвращается NULL, а I<errno> присваивается номер ошибки."

#.  http://austingroupbugs.net/view.php?id=520
#. type: Plain text
#: man-pages/man3/posix_memalign.3:164
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  The value of I<errno> is not set.  "
"On Linux (and other systems), B<posix_memalign>()  does not modify I<memptr> "
"on failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2016."
msgstr ""
"При успешном выполнении функция B<posix_memalign>()  возвращает ноль и одно "
"из значений, перечисленных в далее, при ошибке. Значение I<errno> не "
"изменяется. В Linux (и других системах) B<posix_memalign>() при ошибке не "
"изменяет I<memptr>. Требование стандартизации такого поведения было "
"добавлено в POSIX.1-2016."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:171
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void\\ *)>."
msgstr ""
"Аргумент I<alignment> не является степенью двойки или не кратен I<sizeof(void"
"\\ *)>."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:174
msgid "There was insufficient memory to fulfill the allocation request."
msgstr "Недостаточно памяти для выполнения запроса о выделении."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:181
msgid ""
"The functions B<memalign>(), B<valloc>(), and B<pvalloc>()  have been "
"available in all Linux libc libraries."
msgstr ""
"Функции B<memalign>(), B<valloc>() и B<pvalloc>() доступны во всех "
"библиотеках Linux libc."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:185
msgid "The function B<aligned_alloc>()  was added to glibc in version 2.16."
msgstr "Функция B<aligned_alloc>() впервые появилась в glibc 2.16."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:189
msgid "The function B<posix_memalign>()  is available since glibc 2.1.91."
msgstr "Функция B<posix_memalign>() доступна в glibc начиная с версии 2.1.91."

#. type: tbl table
#: man-pages/man3/posix_memalign.3:199
#, no-wrap
msgid "B<aligned_alloc>(),\n"
msgstr "B<aligned_alloc>(),\n"

#. type: tbl table
#: man-pages/man3/posix_memalign.3:199 man-pages/man3/posix_memalign.3:201
#: man-pages/man3/posix_memalign.3:206
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/posix_memalign.3:201
#, no-wrap
msgid "B<memalign>(),\n"
msgstr "B<memalign>(),\n"

#. type: tbl table
#: man-pages/man3/posix_memalign.3:203
#, no-wrap
msgid "B<posix_memalign>()"
msgstr "B<posix_memalign>()"

#. type: tbl table
#: man-pages/man3/posix_memalign.3:206
#, no-wrap
msgid "B<valloc>(),\n"
msgstr "B<valloc>(),\n"

#. type: tbl table
#: man-pages/man3/posix_memalign.3:208
#, no-wrap
msgid "B<pvalloc>()"
msgstr "B<pvalloc>()"

#. type: tbl table
#: man-pages/man3/posix_memalign.3:208
#, no-wrap
msgid "MT-Unsafe init"
msgstr "MT-Unsafe init"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:218
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in POSIX.1."
msgstr ""
"Функция B<valloc>() появилась из 3.0BSD. Она описана как устаревшая в 4.3BSD "
"и в SUSv2. Отсутствует в POSIX.1."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:222
msgid "The function B<pvalloc>()  is a GNU extension."
msgstr "Функция B<pvalloc>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:226
msgid "The function B<memalign>()  appears in SunOS 4.1.3 but not in 4.4BSD."
msgstr ""
"Функция B<memalign>() появилась из SunOS 4.1.3, но отсутствует в 4.4BSD."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:230
msgid ""
"The function B<posix_memalign>()  comes from POSIX.1d and is specified in "
"POSIX.1-2001 and POSIX.1-2008."
msgstr ""
"Функция B<posix_memalign>() появилась из POSIX.1d и описана в POSIX.1-2001 и "
"POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:235
msgid "The function B<aligned_alloc>()  is specified in the C11 standard."
msgstr "Функция B<aligned_alloc>() описана в стандарте C11."

#. type: SS
#: man-pages/man3/posix_memalign.3:235
#, no-wrap
msgid "Headers"
msgstr "Заголовки"

#. type: Plain text
#: man-pages/man3/posix_memalign.3:239
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in I<E<lt>stdlib."
"hE<gt>>."
msgstr "Функция B<posix_memalign>() везде объявлена в I<E<lt>stdlib.hE<gt>>."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:243
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""
"В некоторых системах B<memalign>() объявлена в I<E<lt>stdlib.hE<gt>>, а не в "
"I<E<lt>malloc.hE<gt>>."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:250
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Libc4,5 and glibc declare it in I<E<lt>malloc.hE<gt>>, and also in "
"I<E<lt>stdlib.hE<gt>> if suitable feature test macros are defined (see "
"above)."
msgstr ""
"В SUSv2 функция B<valloc>() объявлена в I<E<lt>stdlib.hE<gt>>. В Libc4,5 и "
"glibc она объявлена в I<E<lt>malloc.hE<gt>>, а также в I<E<lt>stdlib."
"hE<gt>>, если определены соответствующие макросы тестирования свойств "
"(смотрите выше)."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:259
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the I<pathconf(path,"
"_PC_REC_XFER_ALIGN)> call that tells what alignment is needed.  Now one can "
"use B<posix_memalign>()  to satisfy this requirement."
msgstr ""
"Во многих системах накладываются ограничения по выравниванию, например, на "
"буферы, используемые для прямого ввода-вывода в блочные устройства. В POSIX "
"определён вызов I<pathconf(path,_PC_REC_XFER_ALIGN)>, показывающий "
"необходимость выравнивания. В настоящее время можно использовать "
"B<posix_memalign>() для удовлетворения этого требования."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:268
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<alignment> argument "
"is correct."
msgstr ""
"Функция B<posix_memalign>() проверяет, что I<alignment> удовлетворяет "
"требованиям, описанным выше. Функция B<memalign>() может не проверять "
"корректность аргумента I<alignment>."

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: man-pages/man3/posix_memalign.3:296
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can pass to B<free>(3)  "
"only a pointer obtained from B<malloc>(3), while, for example, "
"B<memalign>()  would call B<malloc>(3)  and then align the obtained value).  "
"The glibc implementation allows memory obtained from any of these functions "
"to be reclaimed with B<free>(3)."
msgstr ""
"В POSIX требуется, чтобы память, полученная через B<posix_memalign>(), могла "
"освобождаться с помощью B<free>(3). В некоторых системах отсутствует "
"механизм освобождения памяти, выделенной B<memalign>() или B<valloc>() (так "
"как в них во B<free>(3) передаётся только указатель, полученный из "
"B<malloc>(3), но, например, B<memalign>() выполняет вызов B<malloc>(3) и "
"затем выравнивает полученное значение). Реализация glibc позволяет "
"освобождать память, полученную через эти функции, с помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:301
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these functions are needed only if you require larger alignment values."
msgstr ""
"Функция glibc B<malloc>(3) всегда возвращает адреса памяти, выровненные по 8-"
"байтовой границе, поэтому данные функции требуются только, если нужны "
"значения с большим выравниванием."

#. type: Plain text
#: man-pages/man3/posix_memalign.3:305
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"

#. type: TH
#: man-pages/man3/printf.3:34
#, no-wrap
msgid "PRINTF"
msgstr "PRINTF"

#. type: Plain text
#: man-pages/man3/printf.3:38
msgid ""
"printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, "
"vsprintf, vsnprintf - formatted output conversion"
msgstr ""
"printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, "
"vsprintf, vsnprintf - преобразование форматированного вывода"

#. type: Plain text
#: man-pages/man3/printf.3:41
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/printf.3:47
#, no-wrap
msgid ""
"B<int printf(const char *>I<format>B<, ...);>\n"
"B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>\n"
"B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>\n"
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, ...);>\n"
msgstr ""
"B<int printf(const char *>I<format>B<, ...);>\n"
"B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>\n"
"B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>\n"
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/printf.3:49
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/printf.3:56
#, no-wrap
msgid ""
"B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""
"B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"

#. type: Plain text
#: man-pages/man3/printf.3:66
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr "B<snprintf>(), B<vsnprintf>():"

#. type: Plain text
#: man-pages/man3/printf.3:69
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/printf.3:73
msgid "B<dprintf>(), B<vdprintf>():"
msgstr "B<dprintf>(), B<vdprintf>():"

#. type: TP
#: man-pages/man3/printf.3:75
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man3/printf.3:78
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man3/printf.3:78
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man3/printf.3:81
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/printf.3:109
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>()  and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""
"Функции семейства B<printf>() выводят данные в соответствии с параметром "
"I<format>, описанным ниже. Функции B<printf>() и B<vprintf>() направляют "
"данные в стандартный поток вывода I<stdout>; функции B<fprintf>() и "
"B<vfprintf>() направляют данные в заданный поток вывода I<stream>; функции "
"B<sprintf>(), B<snprintf>(), B<vsprintf>() и B<vsnprintf>() направляют "
"данные в символьную строку I<str>."

#. type: Plain text
#: man-pages/man3/printf.3:119
msgid ""
"The function B<dprintf>()  is the same as B<fprintf>()  except that it "
"outputs to a file descriptor, I<fd>, instead of to a I<stdio> stream."
msgstr ""
"Функция B<dprintf>() подобна B<fprintf>() за исключением того, что выводит "
"данные в файловый дескриптор I<fd>, а не в поток I<stdio>."

#. type: Plain text
#: man-pages/man3/printf.3:128
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes "
"(including the terminating null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""
"Функции B<snprintf>() и B<vsnprintf>() записывают не более I<size> байт "
"(включая конечный байт null (\\(aq\\e0\\(aq)) в I<str>."

#. type: Plain text
#: man-pages/man3/printf.3:154
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vdprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  are equivalent to the functions B<printf>(), B<fprintf>(), "
"B<dprintf>(), B<sprintf>(), B<snprintf>(), respectively, except that they "
"are called with a I<va_list> instead of a variable number of arguments.  "
"These functions do not call the I<va_end> macro.  Because they invoke the "
"I<va_arg> macro, the value of I<ap> is undefined after the call.  See "
"B<stdarg>(3)."
msgstr ""
"Функции B<vprintf>(), B<vfprintf>(), B<vdprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  эквивалентны B<printf>(), B<fprintf>(), B<dprintf>(), "
"B<sprintf>(), B<snprintf>(), соответственно, за исключением того, что они "
"вызываются с I<va_list>, а не переменным числом аргументов. Эти функции не "
"вызывают макрос I<va_end>. Так как они вызывают макрос I<va_arg>, значение "
"I<ap> не определено после вызова. Смотрите B<stdarg>(3)."

#. type: Plain text
#: man-pages/man3/printf.3:161
msgid ""
"All of these functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr ""
"Все эти функции выводят данные в соответствии со строкой I<format>, которая "
"определяет, каким образом последующие параметры (или доступные параметры "
"переменной длины из B<stdarg>(3)) преобразуют поток вывода."

#. type: Plain text
#: man-pages/man3/printf.3:172
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""
"В C99 и POSIX.1-2001 указано, что результат не определён, если вызов "
"B<sprintf>(), B<snprintf>(), B<vsprintf>() или B<vsnprintf>() привёл бы "
"копированию между перекрывающимися объектами (например, если массив строк "
"назначения и один из указанных входных аргументов ссылаются на один буфер). "
"Смотрите ЗАМЕЧАНИЯ."

#. type: SS
#: man-pages/man3/printf.3:172
#, no-wrap
msgid "Format of the format string"
msgstr "Структура строки параметров"

#. type: Plain text
#: man-pages/man3/printf.3:194
msgid ""
"The format string is a character string, beginning and ending in its initial "
"shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional "
"I<length modifier>."
msgstr ""
"Строка параметров — это строка символов, начинающаяся и заканчивающаяся в "
"своём начальном состоянии сдвига, если оно есть. Строка может состоять из "
"нуля или более директив: обычных символов (кроме B<%>), которые неизменно "
"копируются в поток выхода; и спецификаторов преобразования, по каждому из "
"которых выбирается ноль или более последующих параметров. Каждый "
"спецификатор преобразований начинается с символа B<%> и заканчивается "
"I<спецификатором преобразования>. Между ними могут находиться (в "
"определённом порядке) ноль или более I<флагов>, необязательная минимальная "
"I<ширина поля>,  необязательная I<точность> и необязательный I<модификатор "
"длины>."

#. type: Plain text
#: man-pages/man3/printf.3:211
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq (see I<Field width> and I<Precision> below) "
"and each conversion specifier asks for the next argument (and it is an error "
"if insufficiently many arguments are given).  One can also specify "
"explicitly which argument is taken, at each place where an argument is "
"required, by writing \"%m$\" instead of \\(aq%\\(aq and \"*m$\" instead of "
"\\(aq*\\(aq, where the decimal integer I<m> denotes the position in the "
"argument list of the desired argument, indexed starting from 1.  Thus,"
msgstr ""
"Параметры должны точно соответствовать (после преобразования типа) "
"спецификаторам преобразований. По умолчанию параметры используются в порядке "
"поступления, где каждая «*» (смотрите I<Ширина поля> и I<Точность> ниже) и "
"каждый спецификатор преобразования требуют последующего параметра (если "
"указано недостаточно параметров, то это приведёт к ошибке). Возможно явное "
"указание на то, какой параметр будет следующим, с помощью записи «%m$» "
"вместо «%» и «*m$» вместо «*ю, где десятичная цифра I<m> означает позицию "
"нужного параметра в их списке; список начинается с единицы. Таким образом,"

#. type: Plain text
#: man-pages/man3/printf.3:215
#, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr "printf(\"%*d\", width, num);\n"

#. type: Plain text
#: man-pages/man3/printf.3:219
msgid "and"
msgstr "и"

#. type: Plain text
#: man-pages/man3/printf.3:223
#, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr "printf(\"%2$*1$d\", width, num);\n"

#. type: Plain text
#: man-pages/man3/printf.3:239
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using \\(aq$"
"\\(aq is used, it must be used throughout for all conversions taking an "
"argument and all width and precision arguments, but it may be mixed with \"%%"
"\" formats, which do not consume an argument.  There may be no gaps in the "
"numbers of arguments specified using \\(aq$\\(aq; for example, if arguments "
"1 and 3 are specified, argument 2 must also be specified somewhere in the "
"format string."
msgstr ""
"означают одно и то же. Вторая форма записи позволяет производить указание на "
"тот же параметр несколько раз. Стандарт C99 не поддерживает использование "
"«$», который пришёл из Single UNIX Specification. Если используется «$», то "
"он должен использоваться для всех преобразований аргументов и во всех "
"аргументах ширины и точности, но он может быть смешан с форматами «%%», "
"которые не поглощают аргументы. Там может не быть пробелов между числами "
"аргументов, обусловленные использованием «$». Например, если аргументы 1 и 3 "
"определены, то аргумент 2 должен также быть определён где-то в строке "
"параметров."

#. type: Plain text
#: man-pages/man3/printf.3:251
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on "
"the B<LC_NUMERIC> part of the locale.  (See B<setlocale>(3).)  The POSIX "
"locale uses \\(aq.\\(aq as radix character, and does not have a grouping "
"character.  Thus,"
msgstr ""
"В некоторых цифровых преобразованиях используется символ разделения целой и "
"дробной частей или символ разделения тысяч. Текущий символ зависит от "
"локали, а именно от значения переменной B<LC_NUMERIC> (смотрите "
"B<setlocale>(3)).В локали POSIX по умолчанию используется символ «.» и не "
"отсутствует символ разделения. Таким образом,"

#. type: Plain text
#: man-pages/man3/printf.3:255
#, no-wrap
msgid "    printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr "    printf(\"%\\(aq.2f\", 1234567.89);\n"

#. type: Plain text
#: man-pages/man3/printf.3:260
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""
"выводит «1234567.89» при локали POSIX, «1234567,89» при локали nl_NL и "
"«1.234.567,89» при локали da_DK."

#. type: SS
#: man-pages/man3/printf.3:260
#, no-wrap
msgid "Flag characters"
msgstr "Флаги"

#. type: Plain text
#: man-pages/man3/printf.3:262
msgid "The character % is followed by zero or more of the following flags:"
msgstr "За символом % может быть указано ноль или несколько следующих флагов:"

#. type: TP
#: man-pages/man3/printf.3:262
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#: man-pages/man3/printf.3:296
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a "
"nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""
"Значение преобразуется в «альтернативную форму». Для преобразования типа "
"B<o> первый символ выходного потока будет нуль (префикс 0, если до этого его "
"не было указано). Для преобразований типа B<x> и B<X> к ненулевому "
"результату добавляется «0x» (или «0X» для преобразования типа B<X>). При "
"преобразованиях типа B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g> и B<G> "
"результат всегда будет содержать десятичную точку, даже если за ней не "
"следует цифр (обычно десятичная точка присутствует в результате таких "
"преобразований только, если за ними следуют цифры). Для преобразований B<g> "
"и B<G> завершающие нули не удаляются из результата, как это обычно "
"случается. Результат для других преобразований не определён."

#. type: TP
#: man-pages/man3/printf.3:296
#, no-wrap
msgid "B<\\&0>"
msgstr "B<\\&0>"

#. type: Plain text
#: man-pages/man3/printf.3:336
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the "
"B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior "
"is undefined."
msgstr ""
"В значение добавляются нули. При преобразованиях типа B<d>, B<i>, B<o>, "
"B<u>, B<x>, B<X>, B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g> и B<G> "
"преобразуемое значение слева дополняется нулями (вместо пробелов). Если "
"присутствуют флаги B<\\&0> и B<->, то флаг B<\\&0> игнорируется. Если в "
"числовом преобразовании указана точность (B<d>, B<i>, B<o>, B<u>, B<x>, и "
"B<X>), то флаг B<\\&0> игнорируется. Поведение флага при других "
"преобразованиях не определено."

#. type: TP
#: man-pages/man3/printf.3:336
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#: man-pages/man3/printf.3:347
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  The converted value is padded on the right "
"with blanks, rather than on the left with blanks or zeros.  A B<-> overrides "
"a B<\\&0> if both are given."
msgstr ""
"Выравнивает результат преобразования по левой границе поля (по умолчанию "
"выравнивание выполняется справа). Преобразованное значение дополняется "
"справа пробелами, а не пробелами или нулями слева. Флаг B<-> отменяет флаг "
"«0», если было указано оба флага."

#. type: TP
#: man-pages/man3/printf.3:347
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr "B<\\(aq \\(aq>"

#. type: Plain text
#: man-pages/man3/printf.3:351
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(пробел). Устанавливает слева перед положительными числами (или пустой "
"строкой) знак пробела при знаковых преобразованиях."

#. type: TP
#: man-pages/man3/printf.3:351
#, no-wrap
msgid "B<+>"
msgstr "B<+>"

#. type: Plain text
#: man-pages/man3/printf.3:359
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed "
"conversion.  By default, a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""
"Знак + или - всегда помещается перед преобразованным числом со знаком. По "
"умолчанию знак используется только для отрицательных чисел. Флаг B<+> "
"отменяет действие пробела, если указаны оба флага."

#. type: Plain text
#: man-pages/man3/printf.3:362
msgid ""
"The five flag characters above are defined in the C99 standard.  The Single "
"UNIX Specification specifies one further flag character."
msgstr ""
"Пять флагов, описанных выше, определены в стандарте C99. В стандарте Single "
"UNIX Specification определён ещё один дополнительный флаг."

#. type: TP
#: man-pages/man3/printf.3:362
#, no-wrap
msgid "B<\\(aq>"
msgstr "B<\\(aq>"

#. type: Plain text
#: man-pages/man3/printf.3:381
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  (See B<setlocale>(3).)  Note that many versions "
"of B<gcc>(1)  cannot parse this option and will issue a warning.  (SUSv2 did "
"not include I<%\\(aqF>, but SUSv3 added it.)"
msgstr ""
"При десятичных преобразованиях (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>) "
"результат группируется символом разделителя тысяч, если информация "
"локализации указывает на это (смотрите B<setlocale>(3)). Заметим, что многие "
"версии B<gcc>(1) не могут распознать этот флаг и выводят соответствующее "
"предупреждение (SUSv2 не содержи I<%\\(aqF>, но в SUSv3 его добавили)."

#. type: Plain text
#: man-pages/man3/printf.3:383
msgid "glibc 2.2 adds one further flag character."
msgstr "В glibc 2.2 добавлен ещё один флаг."

#. type: TP
#: man-pages/man3/printf.3:383
#, no-wrap
msgid "B<I>"
msgstr "B<I>"

#.  outdigits keyword in locale file
#. type: Plain text
#: man-pages/man3/printf.3:393
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""
"При преобразовании целых десятичных чисел  (B<i>, B<d>, B<u>) в результате "
"используется альтернативное представление цифр согласно локали. Например, "
"начиная с glibc 2.2.3 это даёт арабско-индийские цифры для персидской локали "
"(«fa_IR»)."

#. type: SS
#: man-pages/man3/printf.3:393
#, no-wrap
msgid "Field width"
msgstr "Ширина поля"

#. type: Plain text
#: man-pages/man3/printf.3:409
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one "
"may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken "
"as a \\(aq-\\(aq flag followed by a positive field width.  In no case does a "
"nonexistent or small field width cause truncation of a field; if the result "
"of a conversion is wider than the field width, the field is expanded to "
"contain the conversion result."
msgstr ""
"Необязательная строка из десятичных цифр (с первой цифрой, отличной от нуля) "
"определяет минимальную ширину поля. Если преобразованное значение имеет "
"меньшее количество знаков, чем ширина поля, то оно слева дополняется "
"пробелами (или справа, если указан флаг выравнивания по левому краю). Вместо "
"строки десятичных цифр можно указать «*» или «*m$» (для некоторого "
"десятичного числа I<m>), чтобы определить ширину поля по ширине следующего "
"аргумента или аргумента с номером I<m> (должен быть типа I<int>), "
"соответственно. Отрицательная ширина поля принимается как флаг «-», "
"устанавливающий положительную ширину поля. Несуществующая или небольшая "
"ширина поля не делает его усечённым; если результат преобразования больше "
"ширины поля, то поле расширяется, чтобы вместить в себя преобразованное "
"значение."

#. type: SS
#: man-pages/man3/printf.3:409
#, no-wrap
msgid "Precision"
msgstr "Точность"

#. type: Plain text
#: man-pages/man3/printf.3:446
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an "
"optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that the "
"precision is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, the precision is taken to be zero.  A negative precision "
"is taken as if the precision were omitted.  This gives the minimum number of "
"digits to appear for B<d>, B<i>, B<o>, B<u>, B<x>, and B<X> conversions, the "
"number of digits to appear after the radix character for B<a>, B<A>, B<e>, "
"B<E>, B<f>, and B<F> conversions, the maximum number of significant digits "
"for B<g> and B<G> conversions, or the maximum number of characters to be "
"printed from a string for B<s> and B<S> conversions."
msgstr ""
"Необязательный параметр точности в виде знака точки («.») сопровождается "
"необязательной строкой десятичных цифр. Вместо строки десятичных цифр можно "
"указать «*» или «*m$» (для некоторого десятичного числа I<m>), чтобы "
"определить значение точности по следующему аргументу или аргументу с номером "
"I<m> (должен быть типа I<int>), соответственно. Если точность указана как "
"«.», то она обрабатывается как нулевая. Отрицательная точность "
"обрабатывается как если не указывалась совсем. Это позволяет ограничивать "
"количество выводимых символов для преобразований B<d>, B<i>, B<o>, B<u>, "
"B<x> и B<X>; показывать определённое количество цифр после десятичной точки "
"для преобразований B<a>, B<A>, B<e>, B<E>, B<f> и B<F>; показывать "
"максимальное количество значащих цифр для преобразований B<g> и B<G> или "
"максимальное количество символов для печати строк при преобразованиях B<s> и "
"B<S>."

#. type: SS
#: man-pages/man3/printf.3:446
#, no-wrap
msgid "Length modifier"
msgstr "Модификатор длины"

#. type: Plain text
#: man-pages/man3/printf.3:456
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""
"Устанавливаются для следующих «преобразований целого» B<d>, B<i>, B<o>, "
"B<u>, B<x> или B<X>."

#. type: TP
#: man-pages/man3/printf.3:456
#, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#: man-pages/man3/printf.3:467
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned "
"char> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<signed char> argument."
msgstr ""
"Преобразование целого числа соответствует аргументам I<signed char> или "
"I<unsigned char>, а также тип преобразования B<n> соответствует указателю на "
"аргумент I<signed char>."

#. type: TP
#: man-pages/man3/printf.3:467
#, no-wrap
msgid "B<h>"
msgstr "B<h>"

#. type: Plain text
#: man-pages/man3/printf.3:478
msgid ""
"A following integer conversion corresponds to a I<short int> or I<unsigned "
"short int> argument, or a following B<n> conversion corresponds to a pointer "
"to a I<short int> argument."
msgstr ""
"Преобразование целого числа соответствует аргументам I<short int> или "
"I<unsigned short int>, а также тип преобразования B<n> соответствует "
"указателю на аргумент I<short int>."

#. type: TP
#: man-pages/man3/printf.3:478
#, no-wrap
msgid "B<l>"
msgstr "B<l>"

#. type: Plain text
#: man-pages/man3/printf.3:497
msgid ""
"(ell) A following integer conversion corresponds to a I<long int> or "
"I<unsigned long int> argument, or a following B<n> conversion corresponds to "
"a pointer to a I<long int> argument, or a following B<c> conversion "
"corresponds to a I<wint_t> argument, or a following B<s> conversion "
"corresponds to a pointer to I<wchar_t> argument."
msgstr ""
"(эль) Преобразование целого числа соответствует аргументам  I<long int> или "
"I<unsigned long int>; тип преобразования B<n> соответствует указателю на "
"аргумент I<long int>; тип преобразования B<c> соответствует аргументу "
"I<wint_t>; тип преобразования B<s> соответствует указателю на аргумент "
"I<wchar_t>."

#. type: TP
#: man-pages/man3/printf.3:497
#, no-wrap
msgid "B<ll>"
msgstr "B<ll>"

#. type: Plain text
#: man-pages/man3/printf.3:509
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long int> "
"or I<unsigned long long int> argument, or a following B<n> conversion "
"corresponds to a pointer to a I<long long int> argument."
msgstr ""
"(эль-эль) Преобразование целого числа соответствует аргументам I<long long "
"int> или I<unsigned long long int>, а также тип преобразования B<n> "
"соответствует указателю на аргумент I<long long int>."

#. type: TP
#: man-pages/man3/printf.3:509
#, no-wrap
msgid "B<q>"
msgstr "B<q>"

#. type: Plain text
#: man-pages/man3/printf.3:515
msgid ""
"A synonym for B<ll>.  This is a nonstandard extension, derived from BSD; "
"avoid its use in new code."
msgstr ""
"Синоним B<ll>. Является нестандартным расширением, унаследовано от BSD; не "
"используйте в новом коде."

#. type: TP
#: man-pages/man3/printf.3:515
#, no-wrap
msgid "B<L>"
msgstr "B<L>"

#. type: Plain text
#: man-pages/man3/printf.3:531
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)"
msgstr ""
"Типы преобразования B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g> или B<G> "
"соответствуют аргументу I<long double> (в C99 допускается %LF, но в SUSv2 "
"нет)."

#. type: TP
#: man-pages/man3/printf.3:531
#, no-wrap
msgid "B<j>"
msgstr "B<j>"

#. type: Plain text
#: man-pages/man3/printf.3:542
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t> "
"argument, or a following B<n> conversion corresponds to a pointer to an "
"I<intmax_t> argument."
msgstr ""
"Преобразование целого числа соответствует аргументам I<intmax_t> или "
"I<uintmax_t>, а также тип преобразования B<n> соответствует указателю на "
"аргумент I<intmax_t>."

#. type: TP
#: man-pages/man3/printf.3:542
#, no-wrap
msgid "B<z>"
msgstr "B<z>"

#. type: Plain text
#: man-pages/man3/printf.3:553
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument, or a following B<n> conversion corresponds to a pointer to a "
"I<size_t> argument."
msgstr ""
"Преобразование целого числа соответствует аргументам I<size_t> или "
"I<ssize_t>, а также тип преобразования B<n> соответствует указателю на "
"аргумент I<size_t>."

#. type: TP
#: man-pages/man3/printf.3:553
#, no-wrap
msgid "B<Z>"
msgstr "B<Z>"

#. type: Plain text
#: man-pages/man3/printf.3:560
msgid ""
"A nonstandard synonym for B<z> that predates the appearance of B<z>.  Do not "
"use in new code."
msgstr ""
"Нестандартный синоним B<z>,  который появился до B<z>. Не используйте в "
"новом коде."

#. type: TP
#: man-pages/man3/printf.3:560
#, no-wrap
msgid "B<t>"
msgstr "B<t>"

#. type: Plain text
#: man-pages/man3/printf.3:569
msgid ""
"A following integer conversion corresponds to a I<ptrdiff_t> argument, or a "
"following B<n> conversion corresponds to a pointer to a I<ptrdiff_t> "
"argument."
msgstr ""
"Преобразование целого числа соответствует аргументам I<ptrdiff_t> или тип "
"преобразования B<n> соответствует указателю на аргумент I<ptrdiff_t>."

#. type: Plain text
#: man-pages/man3/printf.3:600
msgid ""
"SUSv3 specifies all of the above, except for those modifiers explicitly "
"noted as being nonstandard extensions.  SUSv2 specified only the length "
"modifiers B<h> (in B<hd>, B<hi>, B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> (in "
"B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, B<ls>)  and B<L> (in B<Le>, "
"B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""
"В SUSv3 определено всё вышеперечисленное, за исключением указанных как "
"нестандартное расширение. В SUSv2 определены только модификаторы длины B<h> "
"(в B<hd>, B<hi>, B<ho>, B<hx>, B<hX>, B<hn>) и B<l> (в B<ld>, B<li>, B<lo>, "
"B<lx>, B<lX>, B<ln>, B<lc>, B<ls>) и B<L> (в B<Le>, B<LE>, B<Lf>, B<Lg>, "
"B<LG>)."

#. type: Plain text
#: man-pages/man3/printf.3:615
msgid ""
"As a nonstandard extension, the GNU implementations treats B<ll> and B<L> as "
"synonyms, so that one can, for example, write B<llg> (as a synonym for the "
"standards-compliant LgB<)> and B<Ld> (as a synonym for the standards "
"compliant B<lld>).  Such usage is nonportable."
msgstr ""
"Не по стандарту реализации GNU считают B<ll> и B<L> синонимами, поэтому, "
"например, можно написать B<llg> (синоним стандартного LgB<)> и B<Ld> "
"(синоним стандартного B<lld>). Такое использование не переносимо."

#. type: SS
#: man-pages/man3/printf.3:615
#, no-wrap
msgid "Conversion specifiers"
msgstr "Тип преобразования"

#. type: Plain text
#: man-pages/man3/printf.3:618
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""
"Символы, которые определены как типы преобразования. Типы преобразования и "
"их значения:"

#. type: TP
#: man-pages/man3/printf.3:618
#, no-wrap
msgid "B<d>, B<i>"
msgstr "B<d>, B<i>"

#. type: Plain text
#: man-pages/man3/printf.3:628
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision, "
"if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros.  "
"The default precision is 1.  When 0 is printed with an explicit precision 0, "
"the output is empty."
msgstr ""
"Параметр I<int> преобразует символы в их знаковое десятичное отображение. "
"Точность (если указана) задаёт минимальное количество цифр в изображении "
"результата; если результат можно показать с помощью меньшего количества "
"цифр, то слева добавляются незначащие нули. По умолчанию значение точности "
"равно единице. При выводе нуля с нулевой точностью выходной поток будет пуст."

#. type: TP
#: man-pages/man3/printf.3:628
#, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr "B<o>, B<u>, B<x>, B<X>"

#. type: Plain text
#: man-pages/man3/printf.3:655
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned "
"decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it "
"is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""
"Параметр I<unsigned int>  преобразуется в беззнаковое восьмеричное число "
"(B<o>), беззнаковое десятичное (B<u>) или беззнаковое шестнадцатеричное "
"(B<x> и B<X>). Буквы B<abcdef> используются в преобразованиях B<x>; буквы "
"B<ABCDEF> используются в преобразованиях B<X>. Точность (если указана) "
"задаёт минимальное количество цифр в изображении результата; если результат "
"можно показать с помощью меньшего количества цифр, то слева добавляются "
"незначащие нули. По умолчанию значение точности равно единице. При выводе "
"нуля с нулевой точностью выходной поток будет пуст."

#. type: TP
#: man-pages/man3/printf.3:655
#, no-wrap
msgid "B<e>, B<E>"
msgstr "B<e>, B<E>"

#. type: Plain text
#: man-pages/man3/printf.3:675
msgid ""
"The I<double> argument is rounded and converted in the style [-]dB<\\&."
">dddB<e>\\(+-dd where there is one digit (which is nonzero if the argument "
"is nonzero)  before the decimal-point character and the number of digits "
"after it is equal to the precision; if the precision is missing, it is taken "
"as 6; if the precision is zero, no decimal-point character appears.  An B<E> "
"conversion uses the letter B<E> (rather than B<e>)  to introduce the "
"exponent.  The exponent always contains at least two digits; if the value is "
"zero, the exponent is 00."
msgstr ""
"Параметр I<double> округляется и преобразуется в вид [-]dB<\\&.>dddB<e>\\(+-"
"dd, в котором есть одна цифра (не равная нулю, если аргумент не равен нулю) "
"до символа десятичной точки и количество цифр после, указывающих на "
"требуемую точность. Если точность отсутствует, она принимается равной 6; "
"если точность равна нулю, десятичная точка не показывается. В преобразовании "
"для представление экспоненты B<E> используется буква B<E> (а не B<e>). В "
"экспоненте всегда не менее двух цифр; если значение ноль, то экспонента "
"выводится как 00."

#. type: TP
#: man-pages/man3/printf.3:675
#, no-wrap
msgid "B<f>, B<F>"
msgstr "B<f>, B<F>"

#. type: Plain text
#: man-pages/man3/printf.3:686
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no decimal-"
"point character appears.  If a decimal point appears, at least one digit "
"appears before it."
msgstr ""
"Параметр I<double> округляется и преобразуется в десятичное выражение в виде "
"[-]dddB<\\&.>ddd,  где количество цифр после десятичной точки указывает на "
"требуемую точность. Если точность отсутствует, она принимается равной 6-и; "
"если точность равна нулю, десятичная точка не показывается. Если десятичная "
"точка есть, перед ней должна быть минимум одна цифра"

#. type: Plain text
#: man-pages/man3/printf.3:699
msgid ""
"(SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  SUSv3 adds a "
"specification for B<F>.  The C99 standard specifies \"[-]inf\" or "
"\"[-]infinity\" for infinity, and a string starting with \"nan\" for NaN, in "
"the case of B<f> conversion, and \"[-]INF\" or \"[-]INFINITY\" or \"NAN\" in "
"the case of B<F> conversion.)"
msgstr ""
"(в SUSv2 отсутствует информация о B<F> и указано, что этот символ "
"предназначен для отображения символов бесконечности и NaN. В SUSv3 добавлен "
"тип B<F>. В стандарте C99 определены «[-]inf» или «[-]infinity» для указания "
"бесконечности, и строка начинающаяся с «nan» для NaN в случае, если тип "
"преобразования равен B<f>, а начинающаяся с «[-]INF», «[-]INFINITY» или "
"«NAN» в случае, если тип преобразования равен B<F>)."

#. type: TP
#: man-pages/man3/printf.3:699
#, no-wrap
msgid "B<g>, B<G>"
msgstr "B<g>, B<G>"

#. type: Plain text
#: man-pages/man3/printf.3:724
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal "
"point appears only if it is followed by at least one digit."
msgstr ""
"Параметр I<double> преобразуется в стиле B<f> или B<e> (или B<F> или B<E>, "
"для преобразования B<G>). Точность определяется количеством значащих цифр. "
"Если точность отсутствует, то она определяется равной 6-и цифрам; если "
"точность равна нулю, то она трактуется как 1. Стиль B<e> используется, если "
"экспонента преобразования меньше -4, или больше или равна ей. Завершающие "
"нули удаляются из дробной части результата; десятичная точка стоит, только "
"если за ней следует, по крайней мере, одна цифра."

#. type: TP
#: man-pages/man3/printf.3:724
#, no-wrap
msgid "B<a>, B<A>"
msgstr "B<a>, B<A>"

#. type: Plain text
#: man-pages/man3/printf.3:749
msgid ""
"(C99; not in SUSv2, but added in SUSv3)  For B<a> conversion, the I<double> "
"argument is converted to hexadecimal notation (using the letters abcdef)  in "
"the style [-]B<0x>hB<\\&.>hhhhB<p>\\(+-; for B<A> conversion the prefix "
"B<0X>, the letters ABCDEF, and the exponent separator B<P> is used.  There "
"is one hexadecimal digit before the decimal point, and the number of digits "
"after it is equal to the precision.  The default precision suffices for an "
"exact representation of the value if an exact representation in base 2 "
"exists and otherwise is sufficiently large to distinguish values of type "
"I<double>.  The digit before the decimal point is unspecified for "
"nonnormalized numbers, and nonzero but otherwise unspecified for normalized "
"numbers."
msgstr ""
"(C99; отсутствует в SUSv2, до добавлено в SUSv3) Для преобразования типа "
"B<a>  параметр I<double> отображается в шестнадцатеричной форме (с помощью "
"букв abcdef) вида [-]B<0x>hB<\\&.>hhhhB<p>\\(+-; для преобразований типа "
"B<A> используется префикс B<0X>,  буквы ABCDEF и и разделитель экспоненты "
"B<P>. Точность равна шестнадцатеричному разряду перед десятичной точкой и "
"количеству цифр после неё. По умолчанию точность принимается равной точному "
"значению разряда, если оно соответствует ему по основанию 2, и в противном "
"случае размер её является достаточным для определения значения типа "
"I<double>. Разряд перед десятичной точкой не определён для ненормализованных "
"чисел и не равен нулю, но не определён для нормализованных чисел."

#. type: TP
#: man-pages/man3/printf.3:749
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#: man-pages/man3/printf.3:767
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to "
"a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""
"Если модификатор B<l> не указан, то параметр I<int>  преобразуется в "
"I<unsigned char> и выводится как результирующее значение. Если B<l> указан, "
"то параметр I<wint_t> (широкий символ) преобразуется в многобайтовую "
"последовательность вызовом функции B<wcrtomb>(3); первое его значение "
"преобразуется в начальное значение и выводится в виде многобайтовой строки."

#. type: TP
#: man-pages/man3/printf.3:767
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#: man-pages/man3/printf.3:782
msgid ""
"If no B<l> modifier is present: the I<const char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more "
"than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""
"Если модификатор B<l> не указан: параметр I<const char\\ *> преобразуется в "
"указатель на массив символьного типа (строковый указатель). Символы из "
"массива выводятся до конечного байта null (\\(aq\\e0\\(aq, не включая его); "
"если указана точность, то выводится не более установленного количества "
"символов. Если точность указана, то байт null не нужен. Если точность не "
"указана или она больше, чем размер массива, то массив должен содержать "
"конечный байт null."

#. type: Plain text
#: man-pages/man3/printf.3:809
msgid ""
"If an B<l> modifier is present: the I<const wchar_t\\ *> argument is "
"expected to be a pointer to an array of wide characters.  Wide characters "
"from the array are converted to multibyte characters (each by a call to the "
"B<wcrtomb>(3)  function, with a conversion state starting in the initial "
"state before the first wide character), up to and including a terminating "
"null wide character.  The resulting multibyte characters are written up to "
"(but not including) the terminating null byte.  If a precision is specified, "
"no more bytes than the number specified are written, but no partial "
"multibyte characters are written.  Note that the precision determines the "
"number of I<bytes> written, not the number of I<wide characters> or I<screen "
"positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""
"Если модификатор B<l> указан: параметр I<const wchar_t\\ *> должен быть "
"указателем на массив широких символов. Широкие символы из массива "
"преобразуются в многобайтовые символы (каждый вызовом функции B<wcrtomb>(3), "
"при этом первое значение преобразуется в начальное значение первого широкого "
"символа) и так до конечного широкого символа null. Результирующие "
"многобайтовые символы выводятся до конечного байта null (не включая его). "
"Если указана точность, то выводится количество байтов, не превышающее это "
"значение, а оставшаяся часть многобайтовых символов не выводится. Заметим, "
"что точность определяется количеством выведенных I<байт>, не I<широких "
"символов> или I<положением на экране>. Массив должен содержать конечный "
"широкий символ null, если точность не указана, и содержать количество байт, "
"меньше размера массива."

#. type: TP
#: man-pages/man3/printf.3:809
#, no-wrap
msgid "B<C>"
msgstr "B<C>"

#. type: Plain text
#: man-pages/man3/printf.3:815
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<lc>.  "
"Don't use."
msgstr ""
"(отсутствует в C99 или C11, но есть в SUSv2, SUSv3 и SUSv4) Синоним B<lc>. "
"Не используйте."

#. type: TP
#: man-pages/man3/printf.3:815
#, no-wrap
msgid "B<S>"
msgstr "B<S>"

#. type: Plain text
#: man-pages/man3/printf.3:821
msgid ""
"(Not in C99 or C11, but in SUSv2, SUSv3, and SUSv4.)  Synonym for B<ls>.  "
"Don't use."
msgstr ""
"(отсутствует в C99 или C11, но есть в SUSv2, SUSv3 и SUSv4) Синоним B<ls>. "
"Не используйте."

#. type: TP
#: man-pages/man3/printf.3:821
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: man-pages/man3/printf.3:829
msgid ""
"The I<void\\ *> pointer argument is printed in hexadecimal (as if by B<%#x> "
"or B<%#lx>)."
msgstr ""
"Параметр указателя I<void\\ *>, выводящийся в шестнадцатеричном виде (также "
"как при B<%#x> или B<%#lx>)."

#. type: TP
#: man-pages/man3/printf.3:829
#, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#: man-pages/man3/printf.3:841
msgid ""
"The number of characters written so far is stored into the integer pointed "
"to by the corresponding argument.  That argument shall be an I<int\\ *>, or "
"variant whose size matches the (optionally)  supplied integer length "
"modifier.  No argument is converted.  (This specifier is not supported by "
"the bionic C library.)  The behavior is undefined if the conversion "
"specification includes any flags, a field width, or a precision."
msgstr ""
"Количество символов, выводящихся в целом типе int * (или других) без "
"преобразующих параметров. Данный параметр должен быть I<int\\ *> или его "
"вариантом, размер которого совпадает с (необязательно) указываемым целым "
"модификатором длины. Параметр не преобразуется (данный тип не поддерживается "
"библиотекой bionic C). Поведение не определено, если тип преобразования "
"содержит флаги, ширину поля или точность."

#. type: TP
#: man-pages/man3/printf.3:841
#, no-wrap
msgid "B<m>"
msgstr "B<m>"

#. type: Plain text
#: man-pages/man3/printf.3:847
msgid ""
"(Glibc extension; supported by uClibc and musl.)  Print output of "
"I<strerror(errno)>.  No argument is required."
msgstr ""
"(расширение glibc; поддерживается uClibc и musl) Выводит содержимое "
"I<strerror(errno)>. Параметр не требуется."

#. type: TP
#: man-pages/man3/printf.3:847
#, no-wrap
msgid "B<%>"
msgstr "B<%>"

#. type: Plain text
#: man-pages/man3/printf.3:853
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""
"Выводит символ \\(aq%\\(aq. Параметр не требуется. Полный спецификатор "
"преобразования — \\(aq%%\\(aq."

#. type: Plain text
#: man-pages/man3/printf.3:856
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (excluding the null byte used to end output to strings)."
msgstr ""
"При успешном выполнении данные функции возвращают количество напечатанных "
"символов (не включая байт null, используемый в конце выводимых строк)."

#. type: Plain text
#: man-pages/man3/printf.3:872
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the terminating null byte (\\(aq\\e0\\(aq)).  If "
"the output was truncated due to this limit, then the return value is the "
"number of characters (excluding the terminating null byte)  which would have "
"been written to the final string if enough space had been available.  Thus, "
"a return value of I<size> or more means that the output was truncated.  (See "
"also below under NOTES.)"
msgstr ""
"Функции B<snprintf>() и B<vsnprintf>() записывают не более I<size> байт "
"(включая конечный байт null (\\(aq\\e0\\(aq)). Если вывод был обрезан из-за "
"данного ограничения, то возвращаемое значение это количество символов (не "
"включая конечный байт null), которое было бы записано в результирующую "
"строку, если бы было достаточно места. Таким образом, если возвращённое "
"значение больше или равно I<size>, то вывод был обрезан (также смотрите "
"ЗАМЕЧАНИЯ ниже)."

#. type: Plain text
#: man-pages/man3/printf.3:874
msgid "If an output error is encountered, a negative value is returned."
msgstr "Если возникла ошибка, то возвращается отрицательное значение."

#. type: tbl table
#: man-pages/man3/printf.3:885
#, no-wrap
msgid ""
"B<printf>(),\n"
"B<fprintf>(),\n"
msgstr ""
"B<printf>(),\n"
"B<fprintf>(),\n"

#. type: tbl table
#: man-pages/man3/printf.3:888
#, no-wrap
msgid ""
"B<sprintf>(),\n"
"B<snprintf>(),\n"
msgstr ""
"B<sprintf>(),\n"
"B<snprintf>(),\n"

#. type: tbl table
#: man-pages/man3/printf.3:891
#, no-wrap
msgid ""
"B<vprintf>(),\n"
"B<vfprintf>(),\n"
msgstr ""
"B<vprintf>(),\n"
"B<vfprintf>(),\n"

#. type: tbl table
#: man-pages/man3/printf.3:894
#, no-wrap
msgid ""
"B<vsprintf>(),\n"
"B<vsnprintf>()"
msgstr ""
"B<vsprintf>(),\n"
"B<vsnprintf>()"

#. type: Plain text
#: man-pages/man3/printf.3:905
msgid ""
"B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"B<vsprintf>(): POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""
"B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"B<vsprintf>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man3/printf.3:909
msgid "B<snprintf>(), B<vsnprintf>(): POSIX.1-2001, POSIX.1-2008, C99."
msgstr "B<snprintf>(), B<vsnprintf>(): POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/printf.3:916
msgid ""
"The B<dprintf>()  and B<vdprintf>()  functions were originally GNU "
"extensions that were later standardized in POSIX.1-2008."
msgstr ""
"Функции B<dprintf>() и B<vdprintf>() изначально являлись расширениями GNU, "
"но позже были стандартизованы в POSIX.1-2008."

#.  .PP
#.  Linux libc4 knows about the five C standard flags.
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  and the conversions
#.  \fBc\fP, \fBd\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP,
#.  \fBg\fP, \fBG\fP, \fBi\fP, \fBn\fP, \fBo\fP, \fBp\fP,
#.  \fBs\fP, \fBu\fP, \fBx\fP, and \fBX\fP,
#.  where \fBF\fP is a synonym for \fBf\fP.
#.  Additionally, it accepts \fBD\fP, \fBO\fP, and \fBU\fP as synonyms
#.  for \fBld\fP, \fBlo\fP, and \fBlu\fP.
#.  (This is bad, and caused serious bugs later, when
#.  support for \fB%D\fP disappeared.)
#.  No locale-dependent radix character,
#.  no thousands' separator, no NaN or infinity, no "%m$" and "*m$".
#.  .PP
#.  Linux libc5 knows about the five C standard flags and the \(aq flag,
#.  locale, "%m$" and "*m$".
#.  It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
#.  \fBZ\fP, and \fBq\fP, but accepts \fBL\fP and \fBq\fP
#.  both for \fIlong double\fP and for \fIlong long int\fP (this is a bug).
#.  It no longer recognizes \fBF\fP, \fBD\fP, \fBO\fP, and \fBU\fP,
#.  but adds the conversion character
#.  .BR m ,
#.  which outputs
#.  .IR strerror(errno) .
#.  .PP
#.  glibc 2.0 adds conversion characters \fBC\fP and \fBS\fP.
#. type: Plain text
#: man-pages/man3/printf.3:959
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an "
"unspecified return value less than 1, while C99 allows I<str> to be NULL in "
"this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough.  POSIX.1-2001 and later align their specification of "
"B<snprintf>()  with C99."
msgstr ""
"Что касается возвращаемого значения B<snprintf>(), то стандарты SUSv2 и C99 "
"противоречат друг другу: когда B<snprintf>() вызывается с I<size>=0, то "
"SUSv2 предусматривает возврат неопределённого значения меньше единицы, а C99 "
"устанавливает в этом случае I<str> равным NULL и возвращает значение (как "
"обычно) в виде количества символов, достаточного для выходной строки. В "
"POSIX.1-2001 и новее поведение B<snprintf>() совпадает с C99."

#. type: Plain text
#: man-pages/man3/printf.3:962
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""
"В glibc 2.1 добавлены модификаторы длины B<hh>, B<j>, B<t> и B<z> и символы "
"преобразования B<a> и B<A>."

#. type: Plain text
#: man-pages/man3/printf.3:965
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""
"В glibc 2.2 добавлен символ преобразования B<F> с семантикой C99, а также "
"флаг B<I>."

#. type: Plain text
#: man-pages/man3/printf.3:967
msgid "Some programs imprudently rely on code such as the following"
msgstr "В некоторых программах неосмотрительно используется код"

#. type: Plain text
#: man-pages/man3/printf.3:969
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr "    sprintf(buf, \"%s some further text\", buf);\n"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
#: man-pages/man3/printf.3:985
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""
"для добавления текста в I<buf>. Однако в стандартах явно сказано, что "
"результат не определён, если буферы источника и приёмника перекрываются при "
"вызовах B<sprintf>(), B<snprintf>(), B<vsprintf>() и B<vsnprintf>(). В "
"зависимости о версии B<gcc>(1) и указанных параметрах компилятора, подобные "
"вызовы B<не> приводят к ожидаемым результатам."

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
#: man-pages/man3/printf.3:1027
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()  "
"conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6, they would return -1 when the output "
"was truncated."
msgstr ""
"Реализация функций B<snprintf>() и B<vsnprintf>() в glibc 2.1 соответствует "
"стандарту C99 как было описано выше. До glibc 2.0.6, они возвращали -1 при "
"обрезанном выводе."

#.  .PP
#.  Linux libc4.[45] does not have a
#.  .BR snprintf (),
#.  but provides a libbsd that contains an
#.  .BR snprintf ()
#.  equivalent to
#.  .BR sprintf (),
#.  that is, one that ignores the
#.  .I size
#.  argument.
#.  Thus, the use of
#.  .BR snprintf ()
#.  with early libc4 leads to serious security problems.
#. type: Plain text
#: man-pages/man3/printf.3:1057
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""
"Так как B<sprintf>() и B<vsprintf>() работают со строкой произвольной длины, "
"вызывающие должны стараться не переполнить реальное пространство; часто это "
"невозможно гарантировать. Заметим, что длина получаемых строк зависит от "
"локали и её сложно предсказать. Вместо них используйте B<snprintf>() и "
"B<vsnprintf>() (или B<asprintf>(3) и B<vasprintf>(3))."

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#: man-pages/man3/printf.3:1071
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating "
"a security hole."
msgstr ""
"Код, подобный B<printf(>I<foo>B<);> часто означает ошибку, так как I<foo> "
"может содержать символ %. Если содержимое I<foo> пришло из недоверительного "
"пользовательского ввода, то в нём может содержаться B<%n>, из-за чего вызов "
"B<printf>() сделать запись в память и создаст дыру в безопасности."

#. type: Plain text
#: man-pages/man3/printf.3:1075
msgid "To print I<Pi> to five decimal places:"
msgstr "Печать I<Pi> с пятью знаками:"

#. type: Plain text
#: man-pages/man3/printf.3:1081
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"

#. type: Plain text
#: man-pages/man3/printf.3:1090
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""
"Печать даты и времени в виде «Sunday, July 3, 10:02», где I<weekday> и "
"I<month> указатели на строки:"

#. type: Plain text
#: man-pages/man3/printf.3:1096
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"

#. type: Plain text
#: man-pages/man3/printf.3:1102
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""
"Во многих странах используется порядок день-месяц-год. Вот печать аргументов "
"в формате с учётом интернациональности:"

#. type: Plain text
#: man-pages/man3/printf.3:1108
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"

#. type: Plain text
#: man-pages/man3/printf.3:1115
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""
"где I<format> зависит от локали и может переставлять аргументы. Со значением:"

#. type: Plain text
#: man-pages/man3/printf.3:1119
#, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"

#. type: Plain text
#: man-pages/man3/printf.3:1123
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr "получается «Sonntag, 3. Juli, 10:02»."

#. type: Plain text
#: man-pages/man3/printf.3:1126
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""
"Выделение достаточно большой строки и печать в неё (код работает и с glibc "
"2.0, и с glibc 2.1):"

#. type: Plain text
#: man-pages/man3/printf.3:1131
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/printf.3:1138
#, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int size = 0;\n"
"    char *p = NULL;\n"
"    va_list ap;\n"
msgstr ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int size = 0;\n"
"    char *p = NULL;\n"
"    va_list ap;\n"

#. type: Plain text
#: man-pages/man3/printf.3:1140
#, no-wrap
msgid "    /* Determine required size */\n"
msgstr "    /* определим требуемый размер */\n"

#. type: Plain text
#: man-pages/man3/printf.3:1144 man-pages/man3/printf.3:1156
#, no-wrap
msgid ""
"    va_start(ap, fmt);\n"
"    size = vsnprintf(p, size, fmt, ap);\n"
"    va_end(ap);\n"
msgstr ""
"    va_start(ap, fmt);\n"
"    size = vsnprintf(p, size, fmt, ap);\n"
"    va_end(ap);\n"

#. type: Plain text
#: man-pages/man3/printf.3:1147
#, no-wrap
msgid ""
"    if (size E<lt> 0)\n"
"        return NULL;\n"
msgstr ""
"    if (size E<lt> 0)\n"
"        return NULL;\n"

#. type: Plain text
#: man-pages/man3/printf.3:1152
#, no-wrap
msgid ""
"    size++;             /* For '\\e0' */\n"
"    p = malloc(size);\n"
"    if (p == NULL)\n"
"        return NULL;\n"
msgstr ""
"    size++;             /* для '\\e0' */\n"
"    p = malloc(size);\n"
"    if (p == NULL)\n"
"        return NULL;\n"

#. type: Plain text
#: man-pages/man3/printf.3:1161
#, no-wrap
msgid ""
"    if (size E<lt> 0) {\n"
"        free(p);\n"
"        return NULL;\n"
"    }\n"
msgstr ""
"    if (size E<lt> 0) {\n"
"        free(p);\n"
"        return NULL;\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/printf.3:1164
#, no-wrap
msgid ""
"    return p;\n"
"}\n"
msgstr ""
"    return p;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/printf.3:1168
msgid ""
"If truncation occurs in glibc versions prior to 2.0.6, this is treated as an "
"error instead of being handled gracefully."
msgstr ""
"Если происходит обрезание в версиях glibc до 2.0.6, то это считается ошибкой."

#. type: Plain text
#: man-pages/man3/printf.3:1177
msgid ""
"B<printf>(1), B<asprintf>(3), B<puts>(3), B<scanf>(3), B<setlocale>(3), "
"B<strfromd>(3), B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr ""
"B<printf>(1), B<asprintf>(3), B<puts>(3), B<scanf>(3), B<setlocale>(3), "
"B<strfromd>(3), B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"

#. type: TH
#: man-pages/man3/puts.3:26
#, no-wrap
msgid "PUTS"
msgstr "PUTS"

#. type: Plain text
#: man-pages/man3/puts.3:29
msgid "fputc, fputs, putc, putchar, puts - output of characters and strings"
msgstr "fputc, fputs, putc, putchar, puts - вывод символов и строк"

#. type: Plain text
#: man-pages/man3/puts.3:34
#, no-wrap
msgid "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/puts.3:36
#, no-wrap
msgid "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/puts.3:38
#, no-wrap
msgid "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/puts.3:40
#, no-wrap
msgid "B<int putchar(int >I<c>B<);>\n"
msgstr "B<int putchar(int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/puts.3:42
#, no-wrap
msgid "B<int puts(const char *>I<s>B<);>\n"
msgstr "B<int puts(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/puts.3:51
msgid ""
"B<fputc>()  writes the character I<c>, cast to an I<unsigned char>, to "
"I<stream>."
msgstr ""
"Функция B<fputc>() записывает символ I<c>, преобразуя его в I<unsigned "
"char>, в I<stream>."

#. type: Plain text
#: man-pages/man3/puts.3:58
msgid ""
"B<fputs>()  writes the string I<s> to I<stream>, without its terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""
"Функция B<fputs>() записывает строку I<s> в I<stream> без добавления "
"нулевого байта (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/puts.3:65
msgid ""
"B<putc>()  is equivalent to B<fputc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""
"Функция B<putc>() является эквивалентом B<fputc>() за исключением того, что "
"она может быть реализована в качестве макрокоманды, которая проверяет "
"I<stream> более одного раза."

#. type: Plain text
#: man-pages/man3/puts.3:69
msgid "B<putchar(>I<c>B<)> is equivalent to B<putc(>I<c>B<, >I<stdout>B<)>."
msgstr ""
"Вызов B<putchar(>I<c>B<)> является эквивалентом B<putc(>I<c>B<, "
">I<stdout>B<)>."

#. type: Plain text
#: man-pages/man3/puts.3:76
msgid "B<puts>()  writes the string I<s> and a trailing newline to I<stdout>."
msgstr ""
"Функция B<puts>() записывает строку I<s> и завершающую новую строку в "
"I<stdout>."

#. type: Plain text
#: man-pages/man3/puts.3:81
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other output functions from the I<stdio> library for the same "
"output stream."
msgstr ""
"Вызовы описанных здесь функций могут быть смешаны между собой и вызовами "
"других функций вывода из библиотеки I<stdio> в пределах одного и того же "
"потока вывода."

#. type: Plain text
#: man-pages/man3/puts.3:84
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr "Для неблокирующих аналогов, см. B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/puts.3:96
msgid ""
"B<fputc>(), B<putc>()  and B<putchar>()  return the character written as an "
"I<unsigned char> cast to an I<int> or B<EOF> on error."
msgstr ""
"Функции B<fputc>(), B<putc>()  and B<putchar>() возвращают записанный "
"символ, преобразованный из I<unsigned char> в I<int> или B<EOF> в случае "
"ошибки."

#. type: Plain text
#: man-pages/man3/puts.3:103
msgid ""
"B<puts>()  and B<fputs>()  return a nonnegative number on success, or B<EOF> "
"on error."
msgstr ""
"Функции B<puts>() и B<fputs>() возвращают неотрицательное число в случае "
"успеха или B<EOF> в случае ошибки."

#. type: tbl table
#: man-pages/man3/puts.3:117
#, no-wrap
msgid ""
"B<fputc>(),\n"
"B<fputs>(),\n"
"B<putc>(),\n"
"B<putchar>(),\n"
"B<puts>()"
msgstr ""
"B<fputc>(),\n"
"B<fputs>(),\n"
"B<putc>(),\n"
"B<putchar>(),\n"
"B<puts>()"

#. type: Plain text
#: man-pages/man3/puts.3:121
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man3/puts.3:128
msgid ""
"It is not advisable to mix calls to output functions from the I<stdio> "
"library with low-level calls to B<write>(2)  for the file descriptor "
"associated with the same output stream; the results will be undefined and "
"very probably not what you want."
msgstr ""
"Не рекомендуется смешивать вызовы функций вывода из библиотеки I<stdio> с "
"вызовами B<write>(2) для файлового дескриптора, связанного с одним и тем же "
"потоком вывода. Результаты могут быть непредсказуемыми и, очень вероятно, "
"совсем не теми, что вы ожидали увидеть."

#. type: Plain text
#: man-pages/man3/puts.3:139
msgid ""
"B<write>(2), B<ferror>(3), B<fgets>(3), B<fopen>(3), B<fputwc>(3), "
"B<fputws>(3), B<fseek>(3), B<fwrite>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"
msgstr ""
"B<write>(2), B<ferror>(3), B<fgets>(3), B<fopen>(3), B<fputwc>(3), "
"B<fputws>(3), B<fseek>(3), B<fwrite>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/pthread_kill.3:26
#, no-wrap
msgid "PTHREAD_KILL"
msgstr "PTHREAD_KILL"

#. type: Plain text
#: man-pages/man3/pthread_kill.3:29
msgid "pthread_kill - send a signal to a thread"
msgstr "pthread_kill - посылает сигнал в нить"

#. type: Plain text
#: man-pages/man3/pthread_kill.3:34
#, no-wrap
msgid "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"
msgstr "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_kill.3:45
msgid "B<pthread_kill>():"
msgstr "B<pthread_kill>():"

#. type: Plain text
#: man-pages/man3/pthread_kill.3:59
msgid ""
"The B<pthread_kill>()  function sends the signal I<sig> to I<thread>, a "
"thread in the same process as the caller.  The signal is asynchronously "
"directed to I<thread>."
msgstr ""
"Функция B<pthread_kill>() посылает сигнал I<sig> в I<thread> — нить из того "
"же процесса, что и вызвавший функцию. Сигнал доставляется I<thread> "
"асинхронно."

#. type: Plain text
#: man-pages/man3/pthread_kill.3:63
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed."
msgstr ""
"Если I<sig> равно 0, то сигнал не посылается, но выполняется проверка на "
"ошибки."

#. type: Plain text
#: man-pages/man3/pthread_kill.3:68
msgid ""
"On success, B<pthread_kill>()  returns 0; on error, it returns an error "
"number, and no signal is sent."
msgstr ""
"При успешном выполнении B<pthread_kill>() возвращается 0; при ошибке "
"возвращается номер ошибки и сигнал не посылается."

#. type: Plain text
#: man-pages/man3/pthread_kill.3:72
msgid "An invalid signal was specified."
msgstr "Указан некорректный сигнал. "

#. type: tbl table
#: man-pages/man3/pthread_kill.3:82
#, no-wrap
msgid "B<pthread_kill>()"
msgstr "B<pthread_kill>()"

#. type: Plain text
#: man-pages/man3/pthread_kill.3:93
msgid ""
"Signal dispositions are process-wide: if a signal handler is installed, the "
"handler will be invoked in the thread I<thread>, but if the disposition of "
"the signal is \"stop\", \"continue\", or \"terminate\", this action will "
"affect the whole process."
msgstr ""
"Область действия сигнала — весь процесс: если установлен обработчик сигнала, "
"то он будет вызван в нити I<thread>, но если этот сигнал «stop», «continue» "
"или «terminate», то это действие повлияет на весь процесс."

#. type: Plain text
#: man-pages/man3/pthread_kill.3:103
msgid ""
"The glibc implementation of B<pthread_kill>()  gives an error (B<EINVAL>)  "
"on attempts to send either of the real-time signals used internally by the "
"NPTL threading implementation.  See B<nptl>(7)  for details."
msgstr ""
"Реализация B<sigaction>() в glibc выдаёт ошибку (B<EINVAL>) при попытке "
"послать сигналы реального времени, которые используются внутри реализации "
"NPTL. Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man3/pthread_kill.3:116
msgid ""
"POSIX.1-2008 recommends that if an implementation detects the use of a "
"thread ID after the end of its lifetime, B<pthread_kill>()  should return "
"the error B<ESRCH>.  The glibc implementation returns this error in the "
"cases where an invalid thread ID can be detected.  But note also that POSIX "
"says that an attempt to use a thread ID whose lifetime has ended produces "
"undefined behavior, and an attempt to use an invalid thread ID in a call to "
"B<pthread_kill>()  can, for example, cause a segmentation fault."
msgstr ""
"В POSIX.1-2008 рекомендуется, что если реализация обнаруживает использование "
"ID нити после её срока жизни, то B<pthread_kill>() должна возвращать ошибку "
"B<ESRCH>. Реализация glibc возвращает эту ошибку в случае, когда "
"обнаруживается некорректный ID нити. Но также заметим, что в POSIX "
"говорится, что попытка использовать ID нити с завершённым сроком жизни "
"приводит к непредсказуемому поведению, и попытка использовать некорректный "
"ID нити в вызове B<pthread_kill>() может приводить, например, к ошибке "
"сегментирования."

#. type: Plain text
#: man-pages/man3/pthread_kill.3:124
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: man-pages/man3/pthread_sigqueue.3:25
#, no-wrap
msgid "PTHREAD_SIGQUEUE"
msgstr "PTHREAD_SIGQUEUE"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:28
msgid "pthread_sigqueue - queue a signal and data to a thread"
msgstr "pthread_sigqueue - вставляет сигнал и данные в очередь нити"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:32
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:35
#, no-wrap
msgid ""
"B<int pthread_sigqueue(pthread_t >I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"
msgstr ""
"B<int pthread_sigqueue(pthread_t >I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:46
msgid "B<pthread_sigqueue>(): _GNU_SOURCE"
msgstr "B<pthread_sigqueue>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:54
msgid ""
"The B<pthread_sigqueue>()  function performs a similar task to "
"B<sigqueue>(3), but, rather than sending a signal to a process, it sends a "
"signal to a thread in the same process as the calling thread."
msgstr ""
"Функция B<pthread_sigqueue>() выполняет схожу с B<sigqueue>(3) задачу, но "
"посылает сигнал не процессу, а нити из того же процесса, что и вызвавшая "
"функцию нить."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:66
msgid ""
"The I<thread> argument is the ID of a thread in the same process as the "
"caller.  The I<sig> argument specifies the signal to be sent.  The I<value> "
"argument specifies data to accompany the signal; see B<sigqueue>(3)  for "
"details."
msgstr ""
"В аргументе I<thread> указывается ID нити в том же процессе, что и "
"вызывающий. В аргументе I<sig> задаётся отправляемый сигнал. В аргументе "
"I<value> указываются данные, прилагаемые к сигналу; подробности смотрите в "
"B<sigqueue>(3)."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:71
msgid ""
"On success, B<pthread_sigqueue>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"При успешном выполнении B<pthread_sigqueue>() возвращается 0; при ошибке "
"возвращается номер ошибки."

#. type: TP
#: man-pages/man3/pthread_sigqueue.3:72
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:78
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""
"Достигнуто ограничение на количество сигналов в очереди (подробней об этом "
"смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:82
msgid "I<sig> was invalid."
msgstr "Значение I<sig> некорректно."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:86
msgid "B<pthread_sigqueue>()  is not supported on this system."
msgstr "Функция B<pthread_sigqueue>() не поддерживается в этой системе."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:90
msgid "I<thread> is not valid."
msgstr "Некорректное значение I<thread>."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:94
msgid "The B<pthread_sigqueue>()  function first appeared in glibc 2.11."
msgstr "Функция B<pthread_sigqueue>() впервые появилась в glibc 2.11."

#. type: tbl table
#: man-pages/man3/pthread_sigqueue.3:104
#, no-wrap
msgid "B<pthread_sigqueue>()"
msgstr "B<pthread_sigqueue>()"

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:118
msgid ""
"The glibc implementation of B<pthread_sigqueue>()  gives an error "
"(B<EINVAL>)  on attempts to send either of the real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""
"Реализация B<pthread_sigqueue>() в glibc выдаёт ошибку (B<EINVAL>) при "
"попытке послать сигналы реального времени, которые используются внутри "
"реализации NPTL. Подробности смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man3/pthread_sigqueue.3:125
msgid ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), "
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), "
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: man-pages/man3/pthread_tryjoin_np.3:26
#, no-wrap
msgid "PTHREAD_TRYJOIN_NP"
msgstr "PTHREAD_TRYJOIN_NP"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:30
msgid ""
"pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated "
"thread"
msgstr ""
"pthread_tryjoin_np, pthread_timedjoin_np - пытается присоединиться к "
"завершённой нити"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:36
#, no-wrap
msgid "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:39
#, no-wrap
msgid ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"
msgstr ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:46
msgid ""
"These functions operate in the same way as B<pthread_join>(3), except for "
"the differences described on this page."
msgstr ""
"Эти функции работают также как B<pthread_join>(3) за исключением различий, "
"описанных в данной справочной странице."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:58
msgid ""
"The B<pthread_tryjoin_np>()  function performs a nonblocking join with the "
"thread I<thread>, returning the exit status of the thread in I<*retval>.  If "
"I<thread> has not yet terminated, then instead of blocking, as is done by "
"B<pthread_join>(3), the call returns an error."
msgstr ""
"Функция B<pthread_tryjoin_np>() выполняет неблокирующую присоединение к нити "
"I<thread>, возвращая в I<*retval> код выхода нити. Если I<thread> ещё не "
"завершилась, то вместо блокировки, как это делает B<pthread_join>(3), вызов "
"возвращает ошибку."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:76
msgid ""
"The B<pthread_timedjoin_np>()  function performs a join-with-timeout.  If "
"I<thread> has not yet terminated, then the call blocks until a maximum time, "
"specified in I<abstime>.  If the timeout expires before I<thread> "
"terminates, the call returns an error.  The I<abstime> argument is a "
"structure of the following form, specifying an absolute time measured since "
"the Epoch (see B<time>(2)):"
msgstr ""
"Функция B<pthread_timedjoin_np>() выполняет присоединение-с-ожиданием. Если "
"I<thread> ещё не завершилась, то вызов блокируется на максимальное время, "
"заданное в I<abstime>. Если время истекло до завершения I<thread>, то вызов "
"возвращает ошибку. Аргумент I<abstime> представляет собой структуру "
"представления абсолютного времени, измеряемого с начала Эпохи (смотрите "
"B<time>(2)):"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:83
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;     /* секунды */\n"
"    long   tv_nsec;    /* наносекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:89
msgid ""
"On success, these functions return 0; on error, they return an error number."
msgstr ""
"При успешном выполнении эти функции возвращают 0; при ошибке возвращается "
"номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:94
msgid ""
"These functions can fail with the same errors as B<pthread_join>(3).  "
"B<pthread_tryjoin_np>()  can in addition fail with the following error:"
msgstr ""
"Эти функции могут завершиться с теми же ошибками что и B<pthread_join>(3). "
"Дополнительно, функция B<pthread_tryjoin_np>() может завершиться со "
"следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:98
msgid "I<thread> had not yet terminated at the time of the call."
msgstr "Нить I<thread> не завершилась на момент вызова."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:101
msgid ""
"B<pthread_timedjoin_np>()  can in addition fail with the following errors:"
msgstr ""
"Дополнительно, функция B<pthread_timedjoin_np>() может завершиться со "
"следующими ошибками:"

#. type: TP
#: man-pages/man3/pthread_tryjoin_np.3:101
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:106
msgid "The call timed out before I<thread> terminated."
msgstr "Истёк период ожидания раньше завершения I<thread>."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:114
msgid ""
"I<abstime> value is invalid (I<tv_sec> is less than 0 or I<tv_nsec> is "
"greater than 1e9)."
msgstr ""
"Некорректное значение I<abstime> (I<tv_sec> меньше 0 или I<tv_nsec> больше "
"1e9)."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:118
msgid "B<pthread_timedjoin_np>()  never returns the error B<EINTR>."
msgstr ""
"Функция B<pthread_timedjoin_np>() никогда не возвращает ошибку B<EINTR>."

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:120
msgid "These functions first appeared in glibc in version 2.3.3."
msgstr "Эти функции впервые появились в glibc 2.3.3."

#. type: tbl table
#: man-pages/man3/pthread_tryjoin_np.3:132
#, no-wrap
msgid ""
"B<pthread_tryjoin_np>(),\n"
"B<pthread_timedjoin_np>()"
msgstr ""
"B<pthread_tryjoin_np>(),\n"
"B<pthread_timedjoin_np>()"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:140
msgid "The following code waits to join for up to 5 seconds:"
msgstr "Следующий код ждёт присоединения к нити не более 5 секунд:"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:145
#, no-wrap
msgid ""
"struct timespec ts;\n"
"int s;\n"
msgstr ""
"struct timespec ts;\n"
"int s;\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:147
#, no-wrap
msgid "\\&...\n"
msgstr "\\&...\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:151
#, no-wrap
msgid ""
"if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"    /* Handle error */\n"
"}\n"
msgstr ""
"if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"    /* обработка ошибки */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:153
#, no-wrap
msgid "ts.tv_sec += 5;\n"
msgstr "ts.tv_sec += 5;\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:158
#, no-wrap
msgid ""
"s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"if (s != 0) {\n"
"    /* Handle error */\n"
"}\n"
msgstr ""
"s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"if (s != 0) {\n"
"    /* обработка ошибки */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_tryjoin_np.3:164
msgid ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setschedpolicy.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPOLICY"
msgstr "PTHREAD_ATTR_SETSCHEDPOLICY"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:30
msgid ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - set/get "
"scheduling policy attribute in thread attributes object"
msgstr ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - изменяет/"
"возвращает атрибут политики планирования из объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"
msgstr ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(const pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:52
msgid ""
"The B<pthread_attr_setschedpolicy>()  function sets the scheduling policy "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<policy>.  This attribute determines the scheduling "
"policy of a thread created using the thread attributes object I<attr>."
msgstr ""
"Функция B<pthread_attr_setschedpolicy>() изменяет атрибут политики "
"планирования в объекте атрибутов нити, на который указывает I<attr>, в "
"значение I<policy>. Данным атрибутом определяется политика планирования у "
"нити, созданной с учётом объекта атрибутов нити I<attr>."

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:65
msgid ""
"The supported values for I<policy> are B<SCHED_FIFO>, B<SCHED_RR>, and "
"B<SCHED_OTHER>, with the semantics described in B<sched>(7)."
msgstr ""
"Поддерживаемые значения I<policy>: B<SCHED_FIFO>, B<SCHED_RR> и "
"B<SCHED_OTHER>, с семантикой, описанной в B<sched>(7)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:72
msgid ""
"The B<pthread_attr_getschedpolicy>()  returns the scheduling policy "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<policy>."
msgstr ""
"Функция B<pthread_attr_getschedpolicy>() возвращает атрибут планирования "
"нити у объекта атрибутов нити, на который указывает I<attr>, в буфер на "
"который указывает I<policy>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:83
msgid ""
"In order for the policy setting made by B<pthread_attr_setschedpolicy>()  to "
"have effect when calling B<pthread_create>(3), the caller must use "
"B<pthread_attr_setinheritsched>(3)  to set the inherit-scheduler attribute "
"of the attributes object I<attr> to B<PTHREAD_EXPLICIT_SCHED>."
msgstr ""
"Для учёта значения политики, заданной B<pthread_attr_setschedpolicy>(), при "
"вызове B<pthread_create>(3), вызывающий должен использовать "
"B<pthread_attr_setinheritsched>(3) для присвоения атрибуту inherit-scheduler "
"объекта атрибутов I<attr> значения B<PTHREAD_EXPLICIT_SCHED>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:89
msgid "B<pthread_attr_setschedpolicy>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_attr_setschedpolicy>() может завершиться со следующей "
"ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:93
msgid "Invalid value in I<policy>."
msgstr "Некорректное значение I<policy>."

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:100
msgid ""
"POSIX.1 also documents an optional B<ENOTSUP> error (\"attempt was made to "
"set the attribute to an unsupported value\") for "
"B<pthread_attr_setschedpolicy>()."
msgstr ""
"Для B<pthread_attr_setschedpolicy>() в POSIX.1 также описана необязательная "
"ошибка B<ENOTSUP> («попытка изменить атрибут на не поддерживаемое значение»)."

#. type: tbl table
#: man-pages/man3/pthread_attr_setschedpolicy.3:111
#, no-wrap
msgid ""
"B<pthread_attr_setschedpolicy>(),\n"
"B<pthread_attr_getschedpolicy>()"
msgstr ""
"B<pthread_attr_setschedpolicy>(),\n"
"B<pthread_attr_getschedpolicy>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setschedpolicy.3:128
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_create>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<pthreads>(7), "
"B<sched>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_create>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<pthreads>(7), "
"B<sched>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setguardsize.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETGUARDSIZE"
msgstr "PTHREAD_ATTR_SETGUARDSIZE"

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:30
msgid ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - изменяет/возвращает "
"атрибут размера защиты у объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(const pthread_attr_t *>I<attr>B<, size_t *>I<guardsize>B<);>\n"
msgstr ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(const pthread_attr_t *>I<attr>B<, size_t *>I<guardsize>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:49
msgid ""
"The B<pthread_attr_setguardsize>()  function sets the guard size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<guardsize>."
msgstr ""
"Функция B<pthread_attr_setguardsize>() изменяет атрибут размера защиты у "
"объекта атрибутов нити, на который указывает I<attr>, в значение "
"I<guardsize>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:59
msgid ""
"If I<guardsize> is greater than 0, then for each new thread created using "
"I<attr> the system allocates an additional region of at least I<guardsize> "
"bytes at the end of the thread's stack to act as the guard area for the "
"stack (but see BUGS)."
msgstr ""
"Если I<guardsize> больше 0, то для каждой новой нити, созданной с "
"использованием атрибута I<attr>, система выделяет дополнительную область не "
"менее I<guardsize> байт в конце стека нити, которая служит как защитная "
"область стека (но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:65
msgid ""
"If I<guardsize> is 0, then new threads created with I<attr> will not have a "
"guard area."
msgstr ""
"Если I<guardsize> равно 0, то новые нити, создаваемые с использованием "
"I<attr>, не будут иметь защитной области."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:67
msgid "The default guard size is the same as the system page size."
msgstr "Размер защиты по умолчанию совпадает с размером системной страницы."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:82
msgid ""
"If the stack address attribute has been set in I<attr> (using "
"B<pthread_attr_setstack>(3)  or B<pthread_attr_setstackaddr>(3)), meaning "
"that the caller is allocating the thread's stack, then the guard size "
"attribute is ignored (i.e., no guard area is created by the system): it is "
"the application's responsibility to handle stack overflow (perhaps by using "
"B<mprotect>(2)  to manually define a guard area at the end of the stack that "
"it has allocated)."
msgstr ""
"Если в I<attr> установлен атрибут адреса стека (с помощью "
"B<pthread_attr_setstack>(3) или B<pthread_attr_setstackaddr>(3)), "
"означающий, что вызывающий выделяет стек для нити, то атрибут размера защиты "
"игнорируется (т. е., система не создаёт защитную область): само приложение "
"должно обрабатывать переполнение стека (возможно, с помощью B<mprotect>(2), "
"для задания защитной области в конце выделенного стека)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:90
msgid ""
"The B<pthread_attr_getguardsize>()  function returns the guard size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<guardsize>."
msgstr ""
"Функция B<pthread_attr_getguardsize>() возвращает атрибут размера защиты у "
"объекта атрибутов нити, на который указывает I<attr>, в буфер на который "
"указывает I<guardsize>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:104
msgid ""
"POSIX.1 documents an B<EINVAL> error if I<attr> or I<guardsize> is invalid.  "
"On Linux these functions always succeed (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""
"В POSIX.1 описана ошибка B<EINVAL> при некорректном значении I<attr> или "
"I<guardsize>. В Linux эти функции всегда выполняются успешно (тем не менее, "
"в переносимых приложениях нужно учитывать возможность возврата ошибки)."

#. type: tbl table
#: man-pages/man3/pthread_attr_setguardsize.3:117
#, no-wrap
msgid ""
"B<pthread_attr_setguardsize>(),\n"
"B<pthread_attr_getguardsize>()"
msgstr ""
"B<pthread_attr_setguardsize>(),\n"
"B<pthread_attr_getguardsize>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:135
msgid ""
"A guard area consists of virtual memory pages that are protected to prevent "
"read and write access.  If a thread overflows its stack into the guard area, "
"then, on most hard architectures, it receives a B<SIGSEGV> signal, thus "
"notifying it of the overflow.  Guard areas start on page boundaries, and the "
"guard size is internally rounded up to the system page size when creating a "
"thread.  (Nevertheless, B<pthread_attr_getguardsize>()  returns the guard "
"size that was set by B<pthread_attr_setguardsize>().)"
msgstr ""
"Защитная область состоит из страниц виртуальной памяти, которые защищены от "
"чтения и записи. Если нить переполнит свой стек и попадёт в защитную "
"область, то на большинстве аппаратных архитектур она получит сигнал "
"B<SIGSEGV> и таким образом узнает о переполнении. Защитные области "
"начинаются на границах страниц, а размер защиты внутри округляется до "
"размера системной страницы при создании нити (тем не менее, функция "
"B<pthread_attr_getguardsize>() возвращает размер защиты, установленный  "
"B<pthread_attr_setguardsize>())."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:139
msgid ""
"Setting a guard size of 0 may be useful to save memory in an application "
"that creates many threads and knows that stack overflow can never occur."
msgstr ""
"Установка размера защиты в нулевое значение полезно для экономии памяти в "
"приложениях, которые создают много нитей и знают, что переполнение стека "
"никогда не произойдёт."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:143
msgid ""
"Choosing a guard size larger than the default size may be necessary for "
"detecting stack overflows if a thread allocates large data structures on the "
"stack."
msgstr ""
"Указание размера защиты больше чем размер по умолчанию может потребоваться "
"для обнаружения переполнений стека при выделении в нити больших структур "
"данных в стеке."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:154
msgid ""
"As at glibc 2.8, the NPTL threading implementation includes the guard area "
"within the stack size allocation, rather than allocating extra space at the "
"end of the stack, as POSIX.1 requires.  (This can result in an B<EINVAL> "
"error from B<pthread_create>(3)  if the guard size value is too large, "
"leaving no space for the actual stack.)"
msgstr ""
"В glibc 2.8 реализация нитей NPTL добавляет защитную область к размеру "
"выделяемого стека, а не выделяет дополнительное пространство в конце стека "
"как требуется POSIX.1 (это может приводить к ошибке B<EINVAL> в "
"B<pthread_create>(3), если значение размера защиты слишком большое и не "
"оставляет место именно под стек)."

#.  glibc includes the guardsize within the allocated stack size,
#.  which looks pretty clearly to be in violation of POSIX.
#.  Filed bug, 22 Oct 2008:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6973
#.  Older reports:
#.  https//bugzilla.redhat.com/show_bug.cgi?id=435337
#.  Reportedly, LinuxThreads did the right thing, allocating
#.  extra space at the end of the stack:
#.  http://sourceware.org/ml/libc-alpha/2008-05/msg00086.html
#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:168
msgid ""
"The obsolete LinuxThreads implementation did the right thing, allocating "
"extra space at the end of the stack for the guard area."
msgstr ""
"Устаревшая реализация LinuxThreads делает это правильно, выделяя "
"дополнительное пространство в конце стека под защитную область."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:171
msgid "See B<pthread_getattr_np>(3)."
msgstr "См. B<pthread_getattr_np>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setguardsize.3:178
msgid ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setstack>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/popen.3:40
#, no-wrap
msgid "POPEN"
msgstr "POPEN"

#. type: Plain text
#: man-pages/man3/popen.3:43
msgid "popen, pclose - pipe stream to or from a process"
msgstr "popen, pclose - конвейерный поток в или из процесса"

#. type: Plain text
#: man-pages/man3/popen.3:48
#, no-wrap
msgid "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/popen.3:50
#, no-wrap
msgid "B<int pclose(FILE *>I<stream>B<);>\n"
msgstr "B<int pclose(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/popen.3:60
msgid "B<popen>(), B<pclose>():"
msgstr "B<popen>(), B<pclose>():"

#. type: Plain text
#: man-pages/man3/popen.3:63
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/popen.3:74
msgid ""
"The B<popen>()  function opens a process by creating a pipe, forking, and "
"invoking the shell.  Since a pipe is by definition unidirectional, the "
"I<type> argument may specify only reading or writing, not both; the "
"resulting stream is correspondingly read-only or write-only."
msgstr ""
"Функция B<popen>() открывает процесс следующим образом: создаёт канал, "
"выполняет fork и вызывает командную оболочку. Так как канал задается "
"однонаправленным, в аргументе I<type> может быть задан один режим: либо "
"чтение либо запись."

#. type: Plain text
#: man-pages/man3/popen.3:84
msgid ""
"The I<command> argument is a pointer to a null-terminated string containing "
"a shell command line.  This command is passed to I</bin/sh> using the B<-c> "
"flag; interpretation, if any, is performed by the shell."
msgstr ""
"Аргумент I<command> представляет собой указатель на строку с null в конце, "
"которая содержит командную строку оболочки. Эта команда передаётся в I</bin/"
"sh> с помощью флага B<-c>; все подстановке в ней выполняются оболочкой."

#. type: Plain text
#: man-pages/man3/popen.3:99
msgid ""
"The I<type> argument is a pointer to a null-terminated string which must "
"contain either the letter \\(aqr\\(aq for reading or the letter \\(aqw\\(aq "
"for writing.  Since glibc 2.9, this argument can additionally include the "
"letter \\(aqe\\(aq, which causes the close-on-exec flag (B<FD_CLOEXEC>)  to "
"be set on the underlying file descriptor; see the description of the "
"B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"Аргумент I<type> представляет собой указатель на строку с null в конце, "
"которая содержит или букву \\(aqr\\(aq (чтение) или букву \\(aqw\\(aq "
"(запись). Начиная с glibc 2.9 в этом аргументе также может быть буква \\(aqe"
"\\(aq, которая указывает на необходимость установки флага закрытия при "
"выполнении (B<FD_CLOEXEC>) в используемом файловом дескрипторе; про "
"полезность флага B<O_CLOEXEC> смотрите в B<open>(2)."

#. type: Plain text
#: man-pages/man3/popen.3:115
msgid ""
"The return value from B<popen>()  is a normal standard I/O stream in all "
"respects save that it must be closed with B<pclose>()  rather than "
"B<fclose>(3).  Writing to such a stream writes to the standard input of the "
"command; the command's standard output is the same as that of the process "
"that called B<popen>(), unless this is altered by the command itself.  "
"Conversely, reading from the stream reads the command's standard output, and "
"the command's standard input is the same as that of the process that called "
"B<popen>()."
msgstr ""
"Возвращаемое B<popen>() значение является стандартным потоком ввода-вывода, "
"за исключением того, что его нужно закрывать с помощью B<pclose>(), а не "
"B<fclose>(3). Запись в такой поток выполняет запись в стандартный поток "
"ввода команды; стандартного потока вывода команды тот же, что и у процесса, "
"вызвавшего B<popen>(), если он не был изменён самой командой. При чтении из "
"потока выполняется чтение из  стандартного потока вывода команды, а "
"стандартный поток ввода тот же, что и у процесса, вызвавшего B<popen>(), "
"если он не был изменён самой командой. "

#. type: Plain text
#: man-pages/man3/popen.3:119
msgid "Note that output B<popen>()  streams are block buffered by default."
msgstr ""
"Заметим, что потоки вывода B<popen>() по умолчанию блокируемые и "
"буферизированные."

#. type: Plain text
#: man-pages/man3/popen.3:125
msgid ""
"The B<pclose>()  function waits for the associated process to terminate and "
"returns the exit status of the command as returned by B<wait4>(2)."
msgstr ""
"Функция B<pclose>() ожидает завершения ассоциированного процесса и "
"возвращает код выхода команды, возвращаемый функцией B<wait4>(2)."

#. type: Plain text
#: man-pages/man3/popen.3:135
msgid ""
"B<popen>(): on success, returns a pointer to an open stream that can be used "
"to read or write to the pipe; if the B<fork>(2)  or B<pipe>(2)  calls fail, "
"or if the function cannot allocate memory, NULL is returned."
msgstr ""
"B<popen>(): при успешном выполнении возвращается указатель на открытый "
"поток, его можно использовать для чтения или записи в канал; если вызов "
"B<fork>(2) или B<pipe>(2) завершается с ошибкой или если функция не может "
"выделить память, то возвращается NULL."

#.  These conditions actually give undefined results, so I commented
#.  them out.
#.  .I stream
#.  is not associated with a "popen()ed" command, if
#. .I stream
#.  already "pclose()d", or if
#. type: Plain text
#: man-pages/man3/popen.3:147
msgid ""
"B<pclose>(): on success, returns the exit status of the command; if "
"B<wait4>(2)  returns an error, or some other error is detected, -1 is "
"returned."
msgstr ""
"B<pclose>(): при успешном выполнении возвращает код завершения команды; если "
"B<wait4>(2) возвращает ошибку или возникает какая-то другая ошибка, то "
"возвращается -1."

#. type: Plain text
#: man-pages/man3/popen.3:151
msgid ""
"Both functions set I<errno> to an appropriate value in the case of an error."
msgstr "Обе функции записывают в I<errno> соответствующее значение ошибки."

#. type: Plain text
#: man-pages/man3/popen.3:170
msgid ""
"The B<popen>()  function does not set I<errno> if memory allocation fails.  "
"If the underlying B<fork>(2)  or B<pipe>(2)  fails, I<errno> is set "
"appropriately.  If the I<type> argument is invalid, and this condition is "
"detected, I<errno> is set to B<EINVAL>."
msgstr ""
"Функция B<popen>() не изменяет I<errno>, если не удалось выделить память. "
"Если завершаются с ошибкой вызовы B<fork>(2) или B<pipe>(2), то в I<errno> "
"содержится номер ошибки. Если значение I<type> некорректно и это обнаружено, "
"то I<errno> присваивается B<EINVAL>."

#. type: Plain text
#: man-pages/man3/popen.3:177
msgid ""
"If B<pclose>()  cannot obtain the child status, I<errno> is set to B<ECHILD>."
msgstr ""
"Если B<pclose>() не удаётся получить код выхода потомка, то I<errno> "
"присваивается B<ECHILD>."

#. type: tbl table
#: man-pages/man3/popen.3:188
#, no-wrap
msgid ""
"B<popen>(),\n"
"B<pclose>()"
msgstr ""
"B<popen>(),\n"
"B<pclose>()"

#. type: Plain text
#: man-pages/man3/popen.3:197
msgid "The \\(aqe\\(aq value for I<type> is a Linux extension."
msgstr "Значение \\(aqe\\(aq для I<type> есть только в Linux."

#. type: Plain text
#: man-pages/man3/popen.3:201
msgid "B<Note>: carefully read Caveats in B<system>(3)."
msgstr "B<Примечание>: внимательно прочитайте ЗАМЕЧАНИЯ в B<system>(3)."

#. type: Plain text
#: man-pages/man3/popen.3:214
msgid ""
"Since the standard input of a command opened for reading shares its seek "
"offset with the process that called B<popen>(), if the original process has "
"done a buffered read, the command's input position may not be as expected.  "
"Similarly, the output from a command opened for writing may become "
"intermingled with that of the original process.  The latter can be avoided "
"by calling B<fflush>(3)  before B<popen>()."
msgstr ""
"Так как смещение поиска у открытого для чтения стандартного ввода команды "
"доступным процессу, вызвавшему B<popen>(), и исходный процесс выполнял "
"буферное чтение, то позиция ввода команды может быть не той, что ожидается. "
"Подобным образом, вывод из команды, открытой на запись, может будет спутан с "
"выводом из исходного процесса. Последнего можно избежать, если вызывать "
"B<fflush>(3) перед B<popen>()."

#.  .SH HISTORY
#.  A
#.  .BR popen ()
#.  and a
#.  .BR pclose ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: man-pages/man3/popen.3:224
msgid ""
"Failure to execute the shell is indistinguishable from the shell's failure "
"to execute command, or an immediate exit of the command.  The only hint is "
"an exit status of 127."
msgstr ""
"Ошибка при попытке запуска оболочки неотличима от ошибки оболочки при "
"попытке запуска программы или от ошибки при немедленном выходе команды. "
"Единственное отличие это код выхода 127."

#. type: Plain text
#: man-pages/man3/popen.3:233
msgid ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"
msgstr ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"

#. type: TH
#: man-pages/man3/pthread_create.3:26
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr "PTHREAD_CREATE"

#. type: Plain text
#: man-pages/man3/pthread_create.3:29
msgid "pthread_create - create a new thread"
msgstr "pthread_create - создаёт новую нить"

#. type: Plain text
#: man-pages/man3/pthread_create.3:35
#, no-wrap
msgid ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"
msgstr ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:47
msgid ""
"The B<pthread_create>()  function starts a new thread in the calling "
"process.  The new thread starts execution by invoking I<start_routine>(); "
"I<arg> is passed as the sole argument of I<start_routine>()."
msgstr ""
"Функция B<pthread_create>() запускает новую нить в вызвавшем процессе. Новая "
"нить начинает выполнение вызовом I<start_routine>(); значение I<arg> "
"является единственным аргументом I<start_routine>()."

#. type: Plain text
#: man-pages/man3/pthread_create.3:49
msgid "The new thread terminates in one of the following ways:"
msgstr "Новая нить завершает работу в одном из следующих случаев:"

#. type: Plain text
#: man-pages/man3/pthread_create.3:55
msgid ""
"It calls B<pthread_exit>(3), specifying an exit status value that is "
"available to another thread in the same process that calls "
"B<pthread_join>(3)."
msgstr ""
"Она вызывает B<pthread_exit>(3), указывая код выхода, доступное другой нити "
"в том же процессе, вызвавшей B<pthread_join>(3)."

#. type: Plain text
#: man-pages/man3/pthread_create.3:63
msgid ""
"It returns from I<start_routine>().  This is equivalent to calling "
"B<pthread_exit>(3)  with the value supplied in the I<return> statement."
msgstr ""
"При возврате из I<start_routine>(). Это эквивалентно вызову "
"B<pthread_exit>(3) со значением, переданным в операторе I<return>."

#. type: Plain text
#: man-pages/man3/pthread_create.3:66
msgid "It is canceled (see B<pthread_cancel>(3))."
msgstr "При её отмене (смотрите B<pthread_cancel>(3))."

#. type: Plain text
#: man-pages/man3/pthread_create.3:72
msgid ""
"Any of the threads in the process calls B<exit>(3), or the main thread "
"performs a return from I<main>().  This causes the termination of all "
"threads in the process."
msgstr ""
"При вызове из любой нити процесса функции B<exit>(3), или если главная нить "
"выполняет возврат из I<main>(). Это вызывает завершение всех нитей процесса."

#. type: Plain text
#: man-pages/man3/pthread_create.3:86
msgid ""
"The I<attr> argument points to a I<pthread_attr_t> structure whose contents "
"are used at thread creation time to determine attributes for the new thread; "
"this structure is initialized using B<pthread_attr_init>(3)  and related "
"functions.  If I<attr> is NULL, then the thread is created with default "
"attributes."
msgstr ""
"Аргумент I<attr> указывает на структуру I<pthread_attr_t>, чьё содержимое "
"используется при создании нити для определения атрибутов новой нити; эта "
"структура инициализируется с помощью B<pthread_attr_init>(3) и подобными "
"функциями. Если значение I<attr> равно NULL, то нити создаётся с атрибутами "
"по умолчанию."

#. type: Plain text
#: man-pages/man3/pthread_create.3:93
msgid ""
"Before returning, a successful call to B<pthread_create>()  stores the ID of "
"the new thread in the buffer pointed to by I<thread>; this identifier is "
"used to refer to the thread in subsequent calls to other pthreads functions."
msgstr ""
"Перед возвратом успешный вызов B<pthread_create>() сохраняет ID новой нити в "
"буфер, на который указывает I<thread>; этот идентификатор используется для "
"ссылки на нить в последующих вызовах других функций pthreads."

#. type: Plain text
#: man-pages/man3/pthread_create.3:101
msgid ""
"The new thread inherits a copy of the creating thread's signal mask "
"(B<pthread_sigmask>(3)).  The set of pending signals for the new thread is "
"empty (B<sigpending>(2)).  The new thread does not inherit the creating "
"thread's alternate signal stack (B<sigaltstack>(2))."
msgstr ""
"Новая нить наследует копию сигнальной маски создавшей нити "
"(B<pthread_sigmask>(3)). Набор ожидающих сигналов новой нити пуст "
"(B<sigpending>(2)). Новая нить не наследует альтернативный стек сигналов "
"создавшей нити (B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man3/pthread_create.3:104
msgid ""
"The new thread inherits the calling thread's floating-point environment "
"(B<fenv>(3))."
msgstr ""
"Новая нить наследует окружение плавающей запятой вызвавшей нити (B<fenv>(3))."

#.  CLOCK_THREAD_CPUTIME_ID in clock_gettime(2)
#. type: Plain text
#: man-pages/man3/pthread_create.3:109
msgid ""
"The initial value of the new thread's CPU-time clock is 0 (see "
"B<pthread_getcpuclockid>(3))."
msgstr ""
"Начальное значение часов ЦП новой нити равно 0 (смотрите "
"B<pthread_getcpuclockid>(3))."

#. type: SS
#: man-pages/man3/pthread_create.3:109
#, no-wrap
msgid "Linux-specific details"
msgstr "Информация, касающаяся только Linux"

#. type: Plain text
#: man-pages/man3/pthread_create.3:115
msgid ""
"The new thread inherits copies of the calling thread's capability sets (see "
"B<capabilities>(7))  and CPU affinity mask (see B<sched_setaffinity>(2))."
msgstr ""
"Новая нить наследует копию набора мандатов вызвавшей нити (смотрите "
"B<capabilities>(7)) и маску увязывания ЦП (смотрите B<sched_setaffinity>(2))."

#. type: Plain text
#: man-pages/man3/pthread_create.3:122
msgid ""
"On success, B<pthread_create>()  returns 0; on error, it returns an error "
"number, and the contents of I<*thread> are undefined."
msgstr ""
"При успешном выполнении B<pthread_create>() возвращается 0; при ошибке "
"возвращается номер ошибки, а содержимое I<*thread> не определено."

#. type: Plain text
#: man-pages/man3/pthread_create.3:126
msgid "Insufficient resources to create another thread."
msgstr "Недостаточно ресурсов для создания другой нити."

#.  NOTE! The following should match the description in fork(2)
#. type: Plain text
#: man-pages/man3/pthread_create.3:144
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error: the B<RLIMIT_NPROC> soft "
"resource limit (set via B<setrlimit>(2)), which limits the number of "
"processes and threads for a real user ID, was reached; the kernel's system-"
"wide limit on the number of processes and threads, I</proc/sys/kernel/"
"threads-max>, was reached (see B<proc>(5)); or the maximum number of PIDs, "
"I</proc/sys/kernel/pid_max>, was reached (see B<proc>(5))."
msgstr ""
"Возникло системного ограничение на количество нитей. Есть несколько "
"ограничений, которые могут вызвать эту ошибку: был достигнут мягкий "
"ограничитель B<RLIMIT_NPROC> (задаётся с помощью B<setrlimit>(2)), который "
"ограничивает количество процессов и ните для реального ID пользователя; был "
"достигнут ядерный системный ограничитель на количество процессов и нитей, I</"
"proc/sys/kernel/threads-max> (смотрите B<proc>(5)); был достигнуто "
"максимальное количество PID, I</proc/sys/kernel/pid_max> (смотрите "
"B<proc>(5))."

#. type: Plain text
#: man-pages/man3/pthread_create.3:148
msgid "Invalid settings in I<attr>."
msgstr "Некорректные значения в I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_create.3:153
msgid ""
"No permission to set the scheduling policy and parameters specified in "
"I<attr>."
msgstr ""
"Нет прав на изменение алгоритма планирования и параметров, указанных в "
"I<attr>."

#. type: tbl table
#: man-pages/man3/pthread_create.3:163
#, no-wrap
msgid "B<pthread_create>()"
msgstr "B<pthread_create>()"

#. type: Plain text
#: man-pages/man3/pthread_create.3:180
msgid ""
"See B<pthread_self>(3)  for further information on the thread ID returned in "
"I<*thread> by B<pthread_create>().  Unless real-time scheduling policies are "
"being employed, after a call to B<pthread_create>(), it is indeterminate "
"which thread\\(emthe caller or the new thread\\(emwill next execute."
msgstr ""
"Дополнительную информацию об идентификаторе нити, возвращаемом "
"B<pthread_create>() в I<*thread> смотрите в B<pthread_self>(3). Если не "
"используются алгоритмы планирования реального времени после вызова "
"B<pthread_create>() невозможно сказать какая нить — создавшая или новая — "
"будет выполняться далее первой."

#. type: Plain text
#: man-pages/man3/pthread_create.3:200
msgid ""
"A thread may either be I<joinable> or I<detached>.  If a thread is joinable, "
"then another thread can call B<pthread_join>(3)  to wait for the thread to "
"terminate and fetch its exit status.  Only when a terminated joinable thread "
"has been joined are the last of its resources released back to the system.  "
"When a detached thread terminates, its resources are automatically released "
"back to the system: it is not possible to join with the thread in order to "
"obtain its exit status.  Making a thread detached is useful for some types "
"of daemon threads whose exit status the application does not need to care "
"about.  By default, a new thread is created in a joinable state, unless "
"I<attr> was set to create the thread in a detached state (using "
"B<pthread_attr_setdetachstate>(3))."
msgstr ""
"Нить может быть I<присоединяема> (joinable) или I<отключённой> (detached). "
"Если нить присоединяема, то другая нить может вызвать B<pthread_join>(3) для "
"ожидания завершения нити и получения её кода выхода. Освобождение ресурсов "
"обратно в систему у завершённой присоединяемой нити происходит только после "
"её присоединения. При завершении отключённой нити, её ресурсы автоматически "
"освобождаются обратно в систему: к ней невозможно присоединиться для "
"получения её кода выхода. Создание отключённых нитей полезно в некоторых "
"типах служебных нитей, чей код выхода не нужен приложению. По умолчанию "
"новая нить создаётся в присоединяемом состоянии, если в I<attr> не указано "
"создание нити в отключённом состоянии (с помощью "
"B<pthread_attr_setdetachstate>(3))."

#. type: Plain text
#: man-pages/man3/pthread_create.3:218
msgid ""
"Under the NPTL threading implementation, if the B<RLIMIT_STACK> soft "
"resource limit I<at the time the program started> has any value other than "
"\"unlimited\", then it determines the default stack size of new threads.  "
"Using B<pthread_attr_setstacksize>(3), the stack size attribute can be "
"explicitly set in the I<attr> argument used to create a thread, in order to "
"obtain a stack size other than the default.  If the B<RLIMIT_STACK> resource "
"limit is set to \"unlimited\", a per-architecture value is used for the "
"stack size.  Here is the value for a few architectures:"
msgstr ""
"В реализации нитей NPTL, если  мягкое  ограничение  ресурса B<RLIMIT_STACK> "
"I<в момент запуска программы> не равно «unlimited», то им задаётся размер "
"стека по умолчанию для новых нитей. Чтобы получить размер стека, отличный от "
"умолчательного при создании новой нити, можно изменить атрибут размера стека "
"в аргументе I<attr> с помощью B<pthread_attr_setstacksize>(3). Если ресурс "
"B<RLIMIT_STACK> равен «unlimited», то для размера используется значение, "
"определённое для архитектуры. Вот значения для некоторых архитектур:"

#. type: tbl table
#: man-pages/man3/pthread_create.3:223
#, no-wrap
msgid "Architecture"
msgstr "Архитектура"

#. type: tbl table
#: man-pages/man3/pthread_create.3:223
#, no-wrap
msgid "Default stack size"
msgstr "Размер стека умолчанию"

#. type: tbl table
#: man-pages/man3/pthread_create.3:224
#, no-wrap
msgid "i386"
msgstr "i386"

#. type: tbl table
#: man-pages/man3/pthread_create.3:224 man-pages/man3/pthread_create.3:227
#: man-pages/man3/pthread_create.3:228 man-pages/man3/pthread_create.3:230
#, no-wrap
msgid "2 MB"
msgstr "2 МБ"

#. type: tbl table
#: man-pages/man3/pthread_create.3:225
#, no-wrap
msgid "IA-64"
msgstr "IA-64"

#. type: tbl table
#: man-pages/man3/pthread_create.3:225
#, no-wrap
msgid "32 MB"
msgstr "32 МБ"

#. type: tbl table
#: man-pages/man3/pthread_create.3:226
#, no-wrap
msgid "PowerPC"
msgstr "PowerPC"

#. type: tbl table
#: man-pages/man3/pthread_create.3:226 man-pages/man3/pthread_create.3:229
#, no-wrap
msgid "4 MB"
msgstr "4 МБ"

#. type: tbl table
#: man-pages/man3/pthread_create.3:227
#, no-wrap
msgid "S/390"
msgstr "S/390"

#. type: tbl table
#: man-pages/man3/pthread_create.3:228
#, no-wrap
msgid "Sparc-32"
msgstr "Sparc-32"

#. type: tbl table
#: man-pages/man3/pthread_create.3:229
#, no-wrap
msgid "Sparc-64"
msgstr "Sparc-64"

#. type: tbl table
#: man-pages/man3/pthread_create.3:230
#, no-wrap
msgid "x86_64"
msgstr "x86_64"

#. type: Plain text
#: man-pages/man3/pthread_create.3:239
msgid ""
"In the obsolete LinuxThreads implementation, each of the threads in a "
"process has a different process ID.  This is in violation of the POSIX "
"threads specification, and is the source of many other nonconformances to "
"the standard; see B<pthreads>(7)."
msgstr ""
"В устаревшей реализации LinuxThreads каждая нить процесса имеет свой "
"неодинаковый ID процесса. Это нарушает спецификацию нитей POSIX и является "
"источником многих других несоответствий стандарту; смотрите B<pthreads>(7)."

#. type: Plain text
#: man-pages/man3/pthread_create.3:243
msgid ""
"The program below demonstrates the use of B<pthread_create>(), as well as a "
"number of other functions in the pthreads API."
msgstr ""
"Представленная ниже программа показывает использование B<pthread_create>(), "
"а также других функций программного интерфейса pthreads."

#. type: Plain text
#: man-pages/man3/pthread_create.3:248
msgid ""
"In the following run, on a system providing the NPTL threading "
"implementation, the stack size defaults to the value given by the \"stack "
"size\" resource limit:"
msgstr ""
"В этом сеансе в системе с реализацией нитей NPTL размер стека по умолчанию "
"берётся из значения ограничения ресурса на «размер стека»:"

#. type: Plain text
#: man-pages/man3/pthread_create.3:260
#, no-wrap
msgid ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x800000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""
"$B< ulimit -s>\n"
"8192            # ограничение на размер стека 8 МБ (0x800000 байт)\n"
"$B< ./a.out hola salut servus>\n"
"Нить 1: вершина стека около 0xb7dd03b8; argv_string=hola\n"
"Нить 2: вершина стека около 0xb75cf3b8; argv_string=salut\n"
"Нить 3: вершина стека около 0xb6dce3b8; argv_string=servus\n"
"Присоединение нити 1; получено значение возврата HOLA\n"
"Присоединение нити 2; получено значение возврата SALUT\n"
"Присоединение нити 3; получено значение возврата SERVUS\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:266
msgid ""
"In the next run, the program explicitly sets a stack size of 1\\ MB (using "
"B<pthread_attr_setstacksize>(3))  for the created threads:"
msgstr ""
"В этом сеансе программа явно устанавливает размер стека в 1\\ МБ (с помощью "
"B<pthread_attr_setstacksize>(3)) для создаваемых нитей:"

#. type: Plain text
#: man-pages/man3/pthread_create.3:276
#, no-wrap
msgid ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Нить 1: вершина стека около 0xb7d723b8; argv_string=hola\n"
"Нить 2: вершина стека около 0xb7c713b8; argv_string=salut\n"
"Нить 3: вершина стека около 0xb7b703b8; argv_string=servus\n"
"Присоединение нити 1; получено значение возврата HOLA\n"
"Присоединение нити 2; получено значение возврата SALUT\n"
"Присоединение нити 3; получено значение возврата SERVUS\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:288
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:294
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:300
#, no-wrap
msgid ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"
msgstr ""
"struct thread_info {    /* используется как аргумент thread_start() */\n"
"    pthread_t thread_id;        /* ID, полученный от pthread_create() */\n"
"    int       thread_num;       /* номер нити, определяемый\n"
"                                   приложением */\n"
"    char     *argv_string;      /* аргумент из командой строки */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:303
#, no-wrap
msgid ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"
msgstr ""
"/* Начальная функция нити: показывает адрес около вершины нашего стека,\n"
"   и возвращает копию argv_string заглавными буквами */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:309
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = arg;\n"
"    char *uargv, *p;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = arg;\n"
"    char *uargv, *p;\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:312
#, no-wrap
msgid ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"
msgstr ""
"    printf(\"Нить %d: вершина стека около %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:316
#, no-wrap
msgid ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"
msgstr ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:319
#, no-wrap
msgid ""
"    for (p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"
msgstr ""
"    for (p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:322
#, no-wrap
msgid ""
"    return uargv;\n"
"}\n"
msgstr ""
"    return uargv;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:331
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, tnum, opt, num_threads;\n"
"    struct thread_info *tinfo;\n"
"    pthread_attr_t attr;\n"
"    int stack_size;\n"
"    void *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, tnum, opt, num_threads;\n"
"    struct thread_info *tinfo;\n"
"    pthread_attr_t attr;\n"
"    int stack_size;\n"
"    void *res;\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:333
#, no-wrap
msgid "    /* The \"-s\" option specifies a stack size for our threads */\n"
msgstr "    /* Параметром «-s» определяется размер стека в наших нитях */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:340
#, no-wrap
msgid ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"
msgstr ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:347
#, no-wrap
msgid ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"        default:\n"
"            fprintf(stderr, \"Исп.: %s [-s размер стека] арг...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:349
#, no-wrap
msgid "    num_threads = argc - optind;\n"
msgstr "    num_threads = argc - optind;\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:351
#, no-wrap
msgid "    /* Initialize thread creation attributes */\n"
msgstr "    /* инициализация атрибутов создания нити */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:355
#, no-wrap
msgid ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:361
#, no-wrap
msgid ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:363
#, no-wrap
msgid "    /* Allocate memory for pthread_create() arguments */\n"
msgstr "    /* выделение памяти для аргументов pthread_create() */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:367
#, no-wrap
msgid ""
"    tinfo = calloc(num_threads, sizeof(struct thread_info));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"
msgstr ""
"    tinfo = calloc(num_threads, sizeof(struct thread_info));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:369
#, no-wrap
msgid "    /* Create one thread for each command-line argument */\n"
msgstr "    /* создание по одной нити на каждый аргумент командной строки */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:373
#, no-wrap
msgid ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"
msgstr ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:376
#, no-wrap
msgid ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"
msgstr ""
"        /* вызов pthread_create() сохраняет ID нити в\n"
"           соответствующий элемент tinfo[] */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:382
#, no-wrap
msgid ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"
msgstr ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:385
#, no-wrap
msgid ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"
msgstr ""
"    /* уничтожение объекта атрибутов нити, так как он\n"
"       больше не нужен */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:389
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
msgstr ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:391
#, no-wrap
msgid "    /* Now join with each thread, and display its returned value */\n"
msgstr ""
"    /* теперь присоединяем каждую нить и показываем значение,\n"
"       возвращённое ею */\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:396
#, no-wrap
msgid ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:401
#, no-wrap
msgid ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"
msgstr ""
"        printf(\"Присоединение нити %d; получено значение возврата %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* освобождаем память, выделенную нитью */\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:405
#, no-wrap
msgid ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_create.3:419
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), "
"B<pthread_setattr_default_np>(3), B<pthreads>(7)"
msgstr ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), "
"B<pthread_setattr_default_np>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setdetachstate.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETDETACHSTATE"
msgstr "PTHREAD_ATTR_SETDETACHSTATE"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:30
msgid ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach "
"state attribute in thread attributes object"
msgstr ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - изменяет/"
"возвращает из объекта атрибутов нити атрибут отключённости"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<, int *>I<detachstate>B<);>\n"
msgstr ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(const pthread_attr_t *>I<attr>B<, int *>I<detachstate>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:53
msgid ""
"The B<pthread_attr_setdetachstate>()  function sets the detach state "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<detachstate>.  The detach state attribute determines "
"whether a thread created using the thread attributes object I<attr> will be "
"created in a joinable or a detached state."
msgstr ""
"Функция B<pthread_attr_setdetachstate>() изменяет атрибут состояния "
"отключённости у объекта атрибутов нити, на который указывает I<attr>, на "
"значение, заданное в I<detachstate>. Атрибутом состояния отключённости "
"определяется, будет ли нить, созданная с объектом атрибутов нити I<attr>, "
"находиться в присоединяемом или отключённом состоянии."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:56
msgid "The following values may be specified in I<detachstate>:"
msgstr "В I<detachstate> можно указать следующие значения:"

#. type: TP
#: man-pages/man3/pthread_attr_setdetachstate.3:56
#, no-wrap
msgid "B<PTHREAD_CREATE_DETACHED>"
msgstr "B<PTHREAD_CREATE_DETACHED>"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:61
msgid ""
"Threads that are created using I<attr> will be created in a detached state."
msgstr "Нити, создаваемые с I<attr>, будут созданы в отключённом состоянии."

#. type: TP
#: man-pages/man3/pthread_attr_setdetachstate.3:61
#, no-wrap
msgid "B<PTHREAD_CREATE_JOINABLE>"
msgstr "B<PTHREAD_CREATE_JOINABLE>"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:66
msgid ""
"Threads that are created using I<attr> will be created in a joinable state."
msgstr "Нити, создаваемые с I<attr>, будут созданы в присоединяемом состоянии."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:70
msgid ""
"The default setting of the detach state attribute in a newly initialized "
"thread attributes object is B<PTHREAD_CREATE_JOINABLE>."
msgstr ""
"Значением по умолчанию для атрибута состояния отключённости в "
"инициализируемом объекте атрибутов нити является B<PTHREAD_CREATE_JOINABLE>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:77
msgid ""
"The B<pthread_attr_getdetachstate>()  returns the detach state attribute of "
"the thread attributes object I<attr> in the buffer pointed to by "
"I<detachstate>."
msgstr ""
"Функция B<pthread_attr_getdetachstate>() возвращает атрибут состояния "
"отключённости нити у объекта атрибутов нити, на который указывает I<attr>, в "
"буфер на который указывает I<detachstate>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:83
msgid "B<pthread_attr_setdetachstate>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_attr_setdetachstate>() может завершиться со следующей "
"ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:87
msgid "An invalid value was specified in I<detachstate>."
msgstr "Указано неверное значение в I<detachstate>."

#. type: tbl table
#: man-pages/man3/pthread_attr_setdetachstate.3:98
#, no-wrap
msgid ""
"B<pthread_attr_setdetachstate>(),\n"
"B<pthread_attr_getdetachstate>()"
msgstr ""
"B<pthread_attr_setdetachstate>(),\n"
"B<pthread_attr_getdetachstate>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:106
msgid ""
"See B<pthread_create>(3)  for more details on detached and joinable threads."
msgstr ""
"Дополнительную информацию об отключённых и присоединяемых нитях смотрите в "
"B<pthread_create>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:114
msgid ""
"A thread that is created in a joinable state should eventually either be "
"joined using B<pthread_join>(3)  or detached using B<pthread_detach>(3); see "
"B<pthread_create>(3)."
msgstr ""
"Нить, созданная в присоединяемом состоянии, должна быть в последствии "
"присоединена с помощью B<pthread_join>(3) или отключена с помощью "
"B<pthread_detach>(3); смотрите B<pthread_create>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:121
msgid ""
"It is an error to specify the thread ID of a thread that was created in a "
"detached state in a later call to B<pthread_detach>(3)  or "
"B<pthread_join>(3)."
msgstr ""
"Если указать ID нити, которая была создана в отключённом состоянии в вызове "
"B<pthread_detach>(3) или B<pthread_join>(3), то возникает ошибка."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:124
msgid "See B<pthread_attr_init>(3)."
msgstr "Смотрите B<pthread_attr_init>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setdetachstate.3:129
msgid ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_yield.3:25
#, no-wrap
msgid "PTHREAD_YIELD"
msgstr "PTHREAD_YIELD"

#. type: Plain text
#: man-pages/man3/pthread_yield.3:28
msgid "pthread_yield - yield the processor"
msgstr "pthread_yield - освобождает процессор"

#. type: Plain text
#: man-pages/man3/pthread_yield.3:34
#, no-wrap
msgid "B<int pthread_yield(void);>\n"
msgstr "B<int pthread_yield(void);>\n"

#. type: Plain text
#: man-pages/man3/pthread_yield.3:44
msgid ""
"B<pthread_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is placed at the end of the run queue for its static priority and "
"another thread is scheduled to run.  For further details, see "
"B<sched_yield>(2)"
msgstr ""
"Функция B<pthread_yield>() заставляет вызывающую нить освободить процессор. "
"Нить помещается в конец очереди выполнения согласно её статическому "
"приоритету, и управление передаётся другой нити. Дополнительную информацию "
"можно найти в B<sched_yield>(2)."

#. type: Plain text
#: man-pages/man3/pthread_yield.3:49
msgid ""
"On success, B<pthread_yield>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"При успешном выполнении B<pthread_yield>() возвращается 0; при ошибке "
"возвращается номер ошибки."

#. type: Plain text
#: man-pages/man3/pthread_yield.3:53
msgid ""
"On Linux, this call always succeeds (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""
"В Linux эта функция всегда выполняется успешно (но в переносимых приложениях "
"нужно учитывать возможность возврата ошибки)."

#. type: tbl table
#: man-pages/man3/pthread_yield.3:63
#, no-wrap
msgid "B<pthread_yield>()"
msgstr "B<pthread_yield>()"

#.  e.g., the BSDs, Tru64, AIX, and Irix.
#. type: Plain text
#: man-pages/man3/pthread_yield.3:71
msgid ""
"This call is nonstandard, but present on several other systems.  Use the "
"standardized B<sched_yield>(2)  instead."
msgstr ""
"Эта функция является нестандартной, но присутствует в некоторых других "
"системах. Вместо неё используйте стандартный вызов B<sched_yield>(2)."

#. type: Plain text
#: man-pages/man3/pthread_yield.3:74
msgid "On Linux, this function is implemented as a call to B<sched_yield>(2)."
msgstr "В Linux эта функция реализована как вызов B<sched_yield>(2)."

#. type: Plain text
#: man-pages/man3/pthread_yield.3:85
msgid ""
"B<pthread_yield>()  is intended for use with real-time scheduling policies "
"(i.e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<pthread_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""
"Функция B<pthread_yield>() предназначена для использования с алгоритмами "
"планирования реального времени (т. е., B<SCHED_FIFO> или B<SCHED_RR>). "
"Использование B<pthread_yield>() с недерминированными алгоритмами "
"планирования, такими как B<SCHED_OTHER>, не определено и указывает на, "
"вероятно, неправильно разработанное приложение."

#.  FIXME . .BR pthread_cond_wait (3),
#. type: Plain text
#: man-pages/man3/pthread_yield.3:89
msgid "B<sched_yield>(2), B<pthreads>(7), B<sched>(7)"
msgstr "B<sched_yield>(2), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: man-pages/man3/posix_openpt.3:25
#, no-wrap
msgid "POSIX_OPENPT"
msgstr "POSIX_OPENPT"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:28
msgid "posix_openpt - open a pseudoterminal device"
msgstr "posix_openpt - открывает псевдо-терминальное устройство"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:32
#, no-wrap
msgid ""
"B<#include E<lt>stdlib.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdlib.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:34
#, no-wrap
msgid "B<int posix_openpt(int >I<flags>B<);>\n"
msgstr "B<int posix_openpt(int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:44
msgid "B<posix_openpt>(): _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "B<posix_openpt>(): _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:50
msgid ""
"The B<posix_openpt>()  function opens an unused pseudoterminal master "
"device, returning a file descriptor that can be used to refer to that device."
msgstr ""
"Функция B<posix_openpt>() открывает неиспользуемое главное псевдо-"
"терминальное устройство, возвращая файловый дескриптор, который можно "
"использовать для работы с устройством."

#. type: Plain text
#: man-pages/man3/posix_openpt.3:55
msgid ""
"The I<flags> argument is a bit mask that ORs together zero or more of the "
"following flags:"
msgstr ""
"Аргумент I<flags> представляет собой битовую маску из комбинации (OR) нуля "
"или более следующих флагов:"

#. type: TP
#: man-pages/man3/posix_openpt.3:55
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:59
msgid ""
"Open the device for both reading and writing.  It is usual to specify this "
"flag."
msgstr "Открыть устройство для чтения и записи. Обычно, указывается этот флаг."

#. type: TP
#: man-pages/man3/posix_openpt.3:59
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr "B<O_NOCTTY>"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:62
msgid "Do not make this device the controlling terminal for the process."
msgstr "Не делать данное устройство управляющим терминалом процесса."

#. type: Plain text
#: man-pages/man3/posix_openpt.3:70
msgid ""
"On success, B<posix_openpt>()  returns a nonnegative file descriptor which "
"is the lowest numbered unused file descriptor.  On failure, -1 is returned, "
"and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<posix_openpt>() возвращает неотрицательный "
"файловый дескриптор с наименьшим номером неиспользуемого файлового "
"дескриптора. При ошибке возвращается -1, и в I<errno> записывается номер "
"ошибки."

#. type: Plain text
#: man-pages/man3/posix_openpt.3:73
msgid "See B<open>(2)."
msgstr "Смотрите B<open>(2)."

#. type: Plain text
#: man-pages/man3/posix_openpt.3:77
msgid ""
"Glibc support for B<posix_openpt>()  has been provided since version 2.2.1."
msgstr "Поддержка B<posix_openpt>() в glibc появилась в версии 2.2.1."

#. type: tbl table
#: man-pages/man3/posix_openpt.3:87
#, no-wrap
msgid "B<posix_openpt>()"
msgstr "B<posix_openpt>()"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:95
msgid ""
"B<posix_openpt>()  is part of the UNIX 98 pseudoterminal support (see "
"B<pts>(4))."
msgstr ""
"Функция B<posix_openpt>() является частью поддержки псевдо-терминалов UNIX "
"98 (смотрите B<pts>(4))."

#. type: Plain text
#: man-pages/man3/posix_openpt.3:99
msgid ""
"Some older UNIX implementations that support System V (aka UNIX 98) "
"pseudoterminals don't have this function, but it is easy to implement:"
msgstr ""
"В некоторых старых реализациях UNIX, поддерживающих System V (также "
"называемом UNIX 98), для псевдо-терминалов нет этой функции, но её легко "
"написать:"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:107
#, no-wrap
msgid ""
"int\n"
"posix_openpt(int flags)\n"
"{\n"
"    return open(\"/dev/ptmx\", flags);\n"
"}\n"
msgstr ""
"int\n"
"posix_openpt(int flags)\n"
"{\n"
"    return open(\"/dev/ptmx\", flags);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/posix_openpt.3:116
msgid ""
"Calling B<posix_openpt>()  creates a pathname for the corresponding "
"pseudoterminal slave device.  The pathname of the slave device can be "
"obtained using B<ptsname>(3).  The slave device pathname exists only as long "
"as the master device is open."
msgstr ""
"При вызове B<posix_openpt>() создаётся путь для соответствующего "
"подчинённого псевдо-терминального устройства. Путь подчинённого устройства "
"можно получить с помощью B<ptsname>(3). Путь подчинённого устройства "
"существует только пока открыто главное устройство."

#. type: Plain text
#: man-pages/man3/posix_openpt.3:123
msgid ""
"B<open>(2), B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), "
"B<pts>(4), B<pty>(7)"
msgstr ""
"B<open>(2), B<getpt>(3), B<grantpt>(3), B<ptsname>(3), B<unlockpt>(3), "
"B<pts>(4), B<pty>(7)"

#. type: TH
#: man-pages/man3/pthread_setschedprio.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPRIO"
msgstr "PTHREAD_SETSCHEDPRIO"

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:29
msgid "pthread_setschedprio - set scheduling priority of a thread"
msgstr "pthread_setschedprio - изменяет приоритет планирования нити"

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:34
#, no-wrap
msgid "B<int pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"
msgstr "B<int pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"

#.  FIXME . nptl/pthread_setschedprio.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#.  nptl/pthread_setschedparam.c has a similar case.
#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:53
msgid ""
"The B<pthread_setschedprio>()  function sets the scheduling priority of the "
"thread I<thread> to the value specified in I<prio>.  (By contrast "
"B<pthread_setschedparam>(3)  changes both the scheduling policy and priority "
"of a thread.)"
msgstr ""
"Функция B<pthread_setschedprio>() изменяет приоритет планирования нити "
"I<thread> на значение, указанное в I<prio> (по сравнению с "
"B<pthread_setschedparam>(3), которая изменяет сразу алгоритм планирования и "
"приоритет нити)."

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:61
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number.  If B<pthread_setschedprio>()  fails, the scheduling priority of "
"I<thread> is not changed."
msgstr ""
"При успешном выполнении функция возвращает 0; при ошибке возвращается "
"ненулевой номер ошибки. Если B<pthread_setschedprio>() завершается ошибкой, "
"то приоритет планирования I<thread> не изменяется."

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:66
msgid "I<prio> is not valid for the scheduling policy of the specified thread."
msgstr ""
"Значение I<prio> некорректно для приоритета планирования указанной нити."

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:70
msgid ""
"The caller does not have appropriate privileges to set the specified "
"priority."
msgstr ""
"Вызывающий не имеет соответствующих прав для установки указанного приоритета."

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:81
msgid ""
"POSIX.1 also documents an B<ENOTSUP> (\"attempt was made to set the priority "
"to an unsupported value\") error for B<pthread_setschedparam>(3)."
msgstr ""
"Для B<pthread_setschedparam>(3) в POSIX.1 также описана необязательная "
"ошибка B<ENOTSUP> («попытка изменить приоритет на не поддерживаемое "
"значение»)."

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:83
msgid "This function is available in glibc since version 2.3.4."
msgstr "Эта функция доступна в glibc начиная с версии 2.3.4."

#. type: tbl table
#: man-pages/man3/pthread_setschedprio.3:93
#, no-wrap
msgid "B<pthread_setschedprio>()"
msgstr "B<pthread_setschedprio>()"

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:103
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling priority, and details of the permitted ranges "
"for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""
"Список требуемых прав, результат, изменение приоритета планирования нити и "
"подробности разрешённых диапазонов приоритетов для каждого алгоритма "
"планирования смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man3/pthread_setschedprio.3:116
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedparam>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedparam>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: man-pages/man3/putenv.3:36
#, no-wrap
msgid "PUTENV"
msgstr "PUTENV"

#. type: Plain text
#: man-pages/man3/putenv.3:39
msgid "putenv - change or add an environment variable"
msgstr "putenv - изменяет или добавляет переменную окружения"

#.  Not: const char *
#. type: Plain text
#: man-pages/man3/putenv.3:45
#, no-wrap
msgid "B<int putenv(char *>I<string>B<);>\n"
msgstr "B<int putenv(char *>I<string>B<);>\n"

#. type: Plain text
#: man-pages/man3/putenv.3:56
#, no-wrap
msgid ""
"B<putenv>():\n"
"_XOPEN_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""
"B<putenv>():\n"
"_XOPEN_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/putenv.3:69
msgid ""
"The B<putenv>()  function adds or changes the value of environment "
"variables.  The argument I<string> is of the form I<name>=I<value>.  If "
"I<name> does not already exist in the environment, then I<string> is added "
"to the environment.  If I<name> does exist, then the value of I<name> in the "
"environment is changed to I<value>.  The string pointed to by I<string> "
"becomes part of the environment, so altering the string changes the "
"environment."
msgstr ""
"Функция B<putenv>() добавляет или изменяет значение переменных окружения. "
"Аргумент I<string> должен быть представлен в форме I<name>=I<value>. Если "
"переменной с именем I<name> нет в окружении, то I<string> добавляется к "
"окружению. Если переменная I<name> уже существует, то значение I<name> в "
"окружении изменяется на I<value>. Строка, на которую указывает I<string>, "
"становится частью окружения, так что её изменение приведёт к изменению "
"окружения."

#. type: Plain text
#: man-pages/man3/putenv.3:77
msgid ""
"The B<putenv>()  function returns zero on success, or nonzero if an error "
"occurs.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<putenv>() возвращает ноль при успешном выполнении и не ноль в "
"противном случае. При ошибке I<errno> отражает причину ошибки."

#. type: Plain text
#: man-pages/man3/putenv.3:81
msgid "Insufficient space to allocate new environment."
msgstr "Недостаточно памяти под новое окружение."

#. type: tbl table
#: man-pages/man3/putenv.3:91
#, no-wrap
msgid "B<putenv>()"
msgstr "B<putenv>()"

#. type: tbl table
#: man-pages/man3/putenv.3:91
#, no-wrap
msgid "MT-Unsafe const:env"
msgstr "MT-Unsafe const:env"

#.  .LP
#.  Description for libc4, libc5, glibc:
#.  If the argument \fIstring\fP is of the form \fIname\fP,
#.  and does not contain an \(aq=\(aq character, then the variable \fIname\fP
#.  is removed from the environment.
#.  If
#.  .BR putenv ()
#.  has to allocate a new array \fIenviron\fP,
#.  and the previous array was also allocated by
#.  .BR putenv (),
#.  then it will be freed.
#.  In no case will the old storage associated
#.  to the environment variable itself be freed.
#. type: Plain text
#: man-pages/man3/putenv.3:113
msgid ""
"The B<putenv>()  function is not required to be reentrant, and the one in "
"glibc 2.0 is not, but the glibc 2.1 version is."
msgstr ""
"От функции B<putenv>() не требуется быть реентерабельной, и она такова в "
"glibc 2.0, но в glibc 2.1 она реентерабельна."

#. type: Plain text
#: man-pages/man3/putenv.3:128
msgid ""
"Since version 2.1.2, the glibc implementation conforms to SUSv2: the pointer "
"I<string> given to B<putenv>()  is used.  In particular, this string becomes "
"part of the environment; changing it later will change the environment.  "
"(Thus, it is an error to call B<putenv>()  with an automatic variable as the "
"argument, then return from the calling function while I<string> is still "
"part of the environment.)  However, glibc versions 2.0 to 2.1.1 differ: a "
"copy of the string is used.  On the one hand this causes a memory leak, and "
"on the other hand it violates SUSv2."
msgstr ""
"Начиная с версии 2.1.2 glibc соответствует SUSv2: используется указатель "
"I<string>, передаваемый B<putenv>(). В частности, эта строка становится "
"частью окружения; последующее её изменение приводит к изменению окружения. "
"Таким образом, ошибочным будет вызывать B<putenv>() с автоматической "
"переменной в качестве аргумента, так как после возврата из вызвавшей функции "
"строка I<string> является частью окружения. Однако, версии glibc 2.0 по "
"2.1.1 работают по-другому: используется копия строки. С одной стороны, это "
"вызывает утечку памяти, с другой стороны, это не соответствует SUSv2."

#. type: Plain text
#: man-pages/man3/putenv.3:130
msgid "The 4.4BSD version, like glibc 2.0, uses a copy."
msgstr "В версии 4.4BSD как и в glibc 2.0 используется копия."

#. type: Plain text
#: man-pages/man3/putenv.3:132
msgid "SUSv2 removes the I<const> from the prototype, and so does glibc 2.1.3."
msgstr "В SUSv2 удалено I<const> из прототипа и это сделано в glibc 2.1.3."

#. type: Plain text
#: man-pages/man3/putenv.3:137
msgid ""
"The GNU C library implementation provides a nonstandard extension.  If "
"I<string> does not include an equal sign:"
msgstr ""
"Реализация библиотеки GNU C предоставляет нестандартное расширение. Если "
"I<string> не включает знака равно:"

#. type: Plain text
#: man-pages/man3/putenv.3:141
#, no-wrap
msgid "putenv(\"NAME\");\n"
msgstr "putenv(\"NAME\");\n"

#. type: Plain text
#: man-pages/man3/putenv.3:145
msgid "then the named variable is removed from the caller's environment."
msgstr "то именованная переменная удаляется из окружения вызывающего."

#. type: Plain text
#: man-pages/man3/putenv.3:150
msgid ""
"B<clearenv>(3), B<getenv>(3), B<setenv>(3), B<unsetenv>(3), B<environ>(7)"
msgstr ""
"B<clearenv>(3), B<getenv>(3), B<setenv>(3), B<unsetenv>(3), B<environ>(7)"

#. type: TH
#: man-pages/man3/putwchar.3:17
#, no-wrap
msgid "PUTWCHAR"
msgstr "PUTWCHAR"

#. type: Plain text
#: man-pages/man3/putwchar.3:20
msgid "putwchar - write a wide character to standard output"
msgstr "putwchar - записывает широкий символ в стандартный выходной поток"

#. type: Plain text
#: man-pages/man3/putwchar.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/putwchar.3:25
#, no-wrap
msgid "B<wint_t putwchar(wchar_t >I<wc>B<);>\n"
msgstr "B<wint_t putwchar(wchar_t >I<wc>B<);>\n"

#. type: Plain text
#: man-pages/man3/putwchar.3:49
msgid ""
"The B<putwchar>()  function is the wide-character equivalent of the "
"B<putchar>(3)  function.  It writes the wide character I<wc> to I<stdout>.  "
"If I<ferror(stdout)> becomes true, it returns B<WEOF>.  If a wide character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>.  "
"Otherwise, it returns I<wc>."
msgstr ""
"Функция B<putwchar> — это эквивалент функции B<putchar>(3), но для широких "
"символов. Она записывает широкий символ I<wc> в поток I<stdout>. Если "
"значение I<ferror(stdout)> истинно, то возвращается B<WEOF>. Если при "
"преобразовании в широкий символ возникает ошибка, то значение переменной "
"I<errno> устанавливается равным B<EILSEQ> и возвращается B<WEOF>. В любом "
"другом случае возвращается I<wc>."

#. type: Plain text
#: man-pages/man3/putwchar.3:52
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr "Неблокирующий аналог смотрите в B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/putwchar.3:60
msgid ""
"The B<putwchar>()  function returns I<wc> if no error occurred, or B<WEOF> "
"to indicate an error."
msgstr ""
"При успешном выполнении B<putwchar>() возвращается I<wc>; при ошибке "
"возвращается B<WEOF>."

#. type: tbl table
#: man-pages/man3/putwchar.3:70
#, no-wrap
msgid "B<putwchar>()"
msgstr "B<putwchar>()"

#. type: Plain text
#: man-pages/man3/putwchar.3:74
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/putwchar.3:81
msgid ""
"The behavior of B<putwchar>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""
"Поведение B<putwchar>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/putwchar.3:87
msgid ""
"It is reasonable to expect that B<putwchar>()  will actually write the "
"multibyte sequence corresponding to the wide character I<wc>."
msgstr ""
"Закономерно ожидать, что B<putwchar>() на самом деле пишет многобайтовую "
"последовательность, соответствующую широкому символу I<wc>."

#. type: Plain text
#: man-pages/man3/putwchar.3:89
msgid "B<fputwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fputwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/posix_madvise.3:20
#, no-wrap
msgid "POSIX_MADVISE"
msgstr "POSIX_MADVISE"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:23
msgid "posix_madvise - give advice about patterns of memory usage"
msgstr "posix_madvise - отсылает предложения по шаблонам использования памяти"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:26
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:28
#, no-wrap
msgid "B<int posix_madvise(void *>I<addr>B<, size_t >I<len>B<, int >I<advice>B<);>\n"
msgstr "B<int posix_madvise(void *>I<addr>B<, size_t >I<len>B<, int >I<advice>B<);>\n"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:36
msgid "B<posix_madvise>():"
msgstr "B<posix_madvise>():"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:55
msgid ""
"The B<posix_madvise>()  function allows an application to advise the system "
"about its expected patterns of usage of memory in the address range starting "
"at I<addr> and continuing for I<len> bytes.  The system is free to use this "
"advice in order to improve the performance of memory accesses (or to ignore "
"the advice altogether), but calling B<posix_madvise>()  shall not affect the "
"semantics of access to memory in the specified range."
msgstr ""
"Функция B<posix_madvise>() позволяет приложению показывать системе свои "
"ожидания при использовании памяти в диапазоне начиная с адреса I<addr> и "
"длиной I<len> байт. Система может использовать это предложение для улучшения "
"производительности доступа к памяти (или игнорировать), но вызов "
"B<posix_madvise>() не повлияет на семантику доступа к памяти в указанном "
"диапазоне."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:59
msgid "The I<advice> argument is one of the following:"
msgstr "В аргументе I<advice> указывается одно из следующих значений:"

#. type: TP
#: man-pages/man3/posix_madvise.3:59
#, no-wrap
msgid "B<POSIX_MADV_NORMAL>"
msgstr "B<POSIX_MADV_NORMAL>"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:64
msgid ""
"The application has no special advice regarding its memory usage patterns "
"for the specified address range.  This is the default behavior."
msgstr ""
"Приложение не даёт каких-либо предложений о том, как будет использована "
"память в указанном диапазоне. Поведение по умолчанию."

#. type: TP
#: man-pages/man3/posix_madvise.3:64
#, no-wrap
msgid "B<POSIX_MADV_SEQUENTIAL>"
msgstr "B<POSIX_MADV_SEQUENTIAL>"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:70
msgid ""
"The application expects to access the specified address range sequentially, "
"running from lower addresses to higher addresses.  Hence, pages in this "
"region can be aggressively read ahead, and may be freed soon after they are "
"accessed."
msgstr ""
"Приложение будет последовательно обращаться к памяти в указанном диапазоне "
"адресов, от младшего адреса к старшему. Следовательно, все страницы в этом "
"диапазоне можно заранее прочитать и освободить сразу после доступа к ним."

#. type: TP
#: man-pages/man3/posix_madvise.3:70
#, no-wrap
msgid "B<POSIX_MADV_RANDOM>"
msgstr "B<POSIX_MADV_RANDOM>"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:74
msgid ""
"The application expects to access the specified address range randomly.  "
"Thus, read ahead may be less useful than normally."
msgstr ""
"Приложение будет обращаться по указанному диапазону адресов в случайном "
"порядке. То есть упреждающее чтение может быть менее эффективным, чем обычно."

#. type: TP
#: man-pages/man3/posix_madvise.3:74
#, no-wrap
msgid "B<POSIX_MADV_WILLNEED>"
msgstr "B<POSIX_MADV_WILLNEED>"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:79
msgid ""
"The application expects to access the specified address range in the near "
"future.  Thus, read ahead may be beneficial."
msgstr ""
"Приложение обратится по указанному диапазону адресов в в ближайшем будущем. "
"То есть от упреждающего чтения можно выиграть."

#. type: TP
#: man-pages/man3/posix_madvise.3:79
#, no-wrap
msgid "B<POSIX_MADV_DONTNEED>"
msgstr "B<POSIX_MADV_DONTNEED>"

#. type: Plain text
#: man-pages/man3/posix_madvise.3:83
msgid ""
"The application expects that it will not access the specified address range "
"in the near future."
msgstr ""
"Приложение не будет обращаться по указанному диапазону адресов в в ближайшем "
"будущем."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:88
msgid ""
"On success, B<posix_madvise>()  returns 0.  On failure, it returns a "
"positive error number."
msgstr ""
"При успешном выполнении B<posix_madvise>() возвращает 0. При ошибке "
"возвращается положительный номер ошибки."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:95
msgid ""
"I<addr> is not a multiple of the system page size or I<len> is negative."
msgstr ""
"Значение I<addr> не кратно размеру системной страницы или значение I<len> "
"отрицательно."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:99
msgid "I<advice> is invalid."
msgstr "Неверное значение I<advice>."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:103
msgid ""
"Addresses in the specified range are partially or completely outside the "
"caller's address space."
msgstr ""
"Адреса в указанном диапазоне частично или полностью лежат вне адресного "
"пространства вызывающего."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:107
msgid "Support for B<posix_madvise>()  first appeared in glibc version 2.2."
msgstr "Поддержка B<posix_madvise>() появилась в glibc  2.2."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:116
msgid ""
"POSIX.1 permits an implementation to generate an error if I<len> is 0.  On "
"Linux, specifying I<len> as 0 is permitted (as a successful no-op)."
msgstr ""
"В POSIX.1 допускается, что реализация генерирует ошибку, если I<len> равно "
"0. В Linux допустимо значение I<len> равное 0 (ничего не делается)."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:126
msgid ""
"In glibc, this function is implemented using B<madvise>(2).  However, since "
"glibc 2.6, B<POSIX_MADV_DONTNEED> is treated as a no-op, because the "
"corresponding B<madvise>(2)  value, B<MADV_DONTNEED>, has destructive "
"semantics."
msgstr ""
"В glibc эта функция реализована через вызов B<madvise>(2). Однако, начиная с "
"glibc 2.6, B<POSIX_MADV_DONTNEED> для ничего не делается, так как "
"соответствующее значение в B<madvise>(2), B<MADV_DONTNEED>, имеет "
"разрушительную семантику."

#. type: Plain text
#: man-pages/man3/posix_madvise.3:128
msgid "B<madvise>(2), B<posix_fadvise>(2)"
msgstr "B<madvise>(2), B<posix_fadvise>(2)"

#. type: TH
#: man-pages/man3/pthread_getcpuclockid.3:26
#, no-wrap
msgid "PTHREAD_GETCPUCLOCKID"
msgstr "PTHREAD_GETCPUCLOCKID"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:29
msgid "pthread_getcpuclockid - retrieve ID of a thread's CPU time clock"
msgstr "pthread_getcpuclockid - возвращает ID таймера времени ЦП у нити"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:33
#, no-wrap
msgid ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:35
#, no-wrap
msgid "B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t *>I<clock_id>B<);>\n"
msgstr "B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t *>I<clock_id>B<);>\n"

#.  The clockid is constructed as follows:
#.  *clockid = CLOCK_THREAD_CPUTIME_ID | (pd->tid << CLOCK_IDFIELD_SIZE)
#.  where CLOCK_IDFIELD_SIZE is 3.
#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:46
msgid ""
"The B<pthread_getcpuclockid>()  function returns the clock ID for the CPU "
"time clock of the thread I<thread>."
msgstr ""
"Функция B<pthread_getcpuclockid>() возвращает ID таймера времени ЦП у нити "
"I<thread>."

#.  CLOCK_THREAD_CPUTIME_ID not defined
#.  Looking at nptl/pthread_getcpuclockid.c an ERANGE error would
#.  be possible if kernel thread IDs took more than 29 bits (which
#.  they currently cannot).
#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:58
msgid "Per-thread CPU time clocks are not supported by the system."
msgstr ""
"В системе не поддерживаются выделенные таймеры времени ЦП для каждой нити."

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:65
msgid "This function is available in glibc since version 2.2."
msgstr "Эта функция доступна в glibc начиная с версии 2.2."

#. type: tbl table
#: man-pages/man3/pthread_getcpuclockid.3:75
#, no-wrap
msgid "B<pthread_getcpuclockid>()"
msgstr "B<pthread_getcpuclockid>()"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:90
msgid ""
"When I<thread> refers to the calling thread, this function returns an "
"identifier that refers to the same clock manipulated by B<clock_gettime>(2)  "
"and B<clock_settime>(2)  when given the clock ID B<CLOCK_THREAD_CPUTIME_ID>."
msgstr ""
"Если I<thread> указывает на вызвавшую нить, то функция возвращает "
"идентификатор, указывающий на таймер, управляемый B<clock_gettime>(2) и "
"B<clock_settime>(2), если ID таймера равно B<CLOCK_THREAD_CPUTIME_ID>."

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:96
msgid ""
"The program below creates a thread and then uses B<clock_gettime>(2)  to "
"retrieve the total process CPU time, and the per-thread CPU time consumed by "
"the two threads.  The following shell session shows an example run:"
msgstr ""
"Программа, показанная далее, создаёт нить и используя B<clock_gettime>(2) "
"показывает общее время ЦП и время ЦП, затраченное на работу нитей по "
"отдельности. Пример сеанса работы:"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:106
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"
msgstr ""
"$ B<./a.out>\n"
"Главная нить спит\n"
"Вторая нить входит в бесконечный цикл\n"
"Главная нить использует немного времени ЦП…\n"
"Общее время ЦП для процесса:    1.368\n"
"Время ЦП для главной нити:      0.376\n"
"Время ЦП для второй нити:       0.992\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:112
#, no-wrap
msgid "/* Link with \"-lrt\" */\n"
msgstr "/* компоновка с \"-lrt\" */\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:120
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:134
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Вторая нить входит в бесконечный цикл\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:139
#, no-wrap
msgid ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"
msgstr ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:145
#, no-wrap
msgid ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4ld.%03ld\\en\", ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"
msgstr ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4ld.%03ld\\en\", ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:152
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int j, s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int j, s;\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:156
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:159
#, no-wrap
msgid ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"
msgstr ""
"    printf(\"Главная нить спит\\en\");\n"
"    sleep(1);\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:163
#, no-wrap
msgid ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"
msgstr ""
"    printf(\"Главная нить использует немного времени ЦП…\\en\");\n"
"    for (j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:165
#, no-wrap
msgid "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"
msgstr "    pclock(\"Общее время ЦП для процесса: \", CLOCK_PROCESS_CPUTIME_ID);\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:170
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"
msgstr ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Время ЦП для главной нити:   \", cid);\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:173
#, no-wrap
msgid ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"
msgstr ""
"    /* предыдущие 4 строки можно заменить на:\n"
"       pclock(\"Время ЦП для главной нити:\", CLOCK_THREAD_CPUTIME_ID); */\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:178
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"
msgstr ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Время ЦП для второй нити:     \", cid);\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:181
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);         /* завершаем обе нити */\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_getcpuclockid.3:189
msgid ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"

#. type: TH
#: man-pages/man3/pthread_setcancelstate.3:26
#, no-wrap
msgid "PTHREAD_SETCANCELSTATE"
msgstr "PTHREAD_SETCANCELSTATE"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:30
msgid ""
"pthread_setcancelstate, pthread_setcanceltype - set cancelability state and "
"type"
msgstr ""
"pthread_setcancelstate, pthread_setcanceltype - изменяет состояния и тип "
"отменяемости"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:36
#, no-wrap
msgid ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"
msgstr ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:51
msgid ""
"The B<pthread_setcancelstate>()  sets the cancelability state of the calling "
"thread to the value given in I<state>.  The previous cancelability state of "
"the thread is returned in the buffer pointed to by I<oldstate>.  The "
"I<state> argument must have one of the following values:"
msgstr ""
"Функция B<pthread_setcancelstate>() изменяет состояние отменяемости "
"вызывающий нити на значение I<state>. Предыдущее состояние отменяемости нити "
"возвращается в буфер, на который указывает I<oldstate>. Аргументом I<state> "
"должно быть одно из следующих значений:"

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:51
#, no-wrap
msgid "B<PTHREAD_CANCEL_ENABLE>"
msgstr "B<PTHREAD_CANCEL_ENABLE>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:58
msgid ""
"The thread is cancelable.  This is the default cancelability state in all "
"new threads, including the initial thread.  The thread's cancelability type "
"determines when a cancelable thread will respond to a cancellation request."
msgstr ""
"Нить является отменяемой. Для всех новых нитей, включая начальную, это "
"состояние является основным по умолчанию. Тип отменяемости нити определяет, "
"когда нить будет отвечать на запрос об отмене."

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:58
#, no-wrap
msgid "B<PTHREAD_CANCEL_DISABLE>"
msgstr "B<PTHREAD_CANCEL_DISABLE>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:63
msgid ""
"The thread is not cancelable.  If a cancellation request is received, it is "
"blocked until cancelability is enabled."
msgstr ""
"Нить является неотменяемой. Если был получен запрос об отмене, он будет "
"блокироваться до тех пор, пока не будет включена отменяемость."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:75
msgid ""
"The B<pthread_setcanceltype>()  sets the cancelability type of the calling "
"thread to the value given in I<type>.  The previous cancelability type of "
"the thread is returned in the buffer pointed to by I<oldtype>.  The I<type> "
"argument must have one of the following values:"
msgstr ""
"Функция B<pthread_setcanceltype>() изменяет тип отменяемости вызывающий нити "
"на значение I<type>. Предыдущий тип отменяемости нити возвращается в буфер, "
"на который указывает I<oldstate>. Аргументом I<type> должно быть одно из "
"следующих значений:"

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:75
#, no-wrap
msgid "B<PTHREAD_CANCEL_DEFERRED>"
msgstr "B<PTHREAD_CANCEL_DEFERRED>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:82
msgid ""
"A cancellation request is deferred until the thread next calls a function "
"that is a cancellation point (see B<pthreads>(7)).  This is the default "
"cancelability type in all new threads, including the initial thread."
msgstr ""
"Запрос отменяемости откладывается до тех пор, пока нить не вызовет функцию, "
"являющуюся точкой отмены (смотрите B<pthreads>(7)). Данный тип является "
"умолчательным для всех нитей, включая начальную."

#. type: TP
#: man-pages/man3/pthread_setcancelstate.3:82
#, no-wrap
msgid "B<PTHREAD_CANCEL_ASYNCHRONOUS>"
msgstr "B<PTHREAD_CANCEL_ASYNCHRONOUS>"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:88
msgid ""
"The thread can be canceled at any time.  (Typically, it will be canceled "
"immediately upon receiving a cancellation request, but the system doesn't "
"guarantee this.)"
msgstr ""
"Нить может быть отменена в любой момент (практически сразу же после "
"получения запроса об отмене, однако система не гарантирует этого)."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:92
msgid ""
"The set-and-get operation performed by each of these functions is atomic "
"with respect to other threads in the process calling the same function."
msgstr ""
"Операции установки и получения (set-and-get), выполняемые каждой из этих "
"функций, являются атомарными для предотвращения пересечения с другими "
"процессами, вызывающими ту же функцию."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:99
msgid "The B<pthread_setcancelstate>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_setcancelstate>() может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:103
msgid "Invalid value for I<state>."
msgstr "Неправильное значение для I<state>."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:107
msgid "The B<pthread_setcanceltype>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_setcanceltype>() может завершиться со следующей ошибкой:"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:113
msgid "Invalid value for I<type>."
msgstr "Неправильное значение для I<type>."

#. type: tbl table
#: man-pages/man3/pthread_setcancelstate.3:125
#: man-pages/man3/pthread_setcancelstate.3:131
#, no-wrap
msgid ""
"B<pthread_setcancelstate>(),\n"
"B<pthread_setcanceltype>()"
msgstr ""
"B<pthread_setcancelstate>(),\n"
"B<pthread_setcanceltype>()"

#. type: tbl table
#: man-pages/man3/pthread_setcancelstate.3:131
#, no-wrap
msgid "Async-cancel-safety"
msgstr "Async-cancel-safety"

#. type: tbl table
#: man-pages/man3/pthread_setcancelstate.3:133
#, no-wrap
msgid "AC-Safe"
msgstr "AC-Safe"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:142
msgid ""
"For details of what happens when a thread is canceled, see "
"B<pthread_cancel>(3)."
msgstr ""
"Информацию о том, что происходит с отменяемой нитью, смотрите в "
"B<pthread_cancel>(3)."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:149
msgid ""
"Briefly disabling cancelability is useful if a thread performs some critical "
"action that must not be interrupted by a cancellation request.  Beware of "
"disabling cancelability for long periods, or around operations that may "
"block for long periods, since that will render the thread unresponsive to "
"cancellation requests."
msgstr ""
"Запрет отмены на короткое время полезен, если нить выполняет какое-то важное "
"действие, которое не должно прерываться запросом отмены. Остерегайтесь "
"запретов отмены на длительный срок или для операций, которые могут занять "
"много времени, так как нить при этом перестанет отвечать на запросы отмены."

#. type: SS
#: man-pages/man3/pthread_setcancelstate.3:149
#, no-wrap
msgid "Asynchronous cancelability"
msgstr "Асинхронная отменяемость"

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:168
msgid ""
"Setting the cancelability type to B<PTHREAD_CANCEL_ASYNCHRONOUS> is rarely "
"useful.  Since the thread could be canceled at I<any> time, it cannot safely "
"reserve resources (e.g., allocating memory with B<malloc>(3)), acquire "
"mutexes, semaphores, or locks, and so on.  Reserving resources is unsafe "
"because the application has no way of knowing what the state of these "
"resources is when the thread is canceled; that is, did cancellation occur "
"before the resources were reserved, while they were reserved, or after they "
"were released? Furthermore, some internal data structures (e.g., the linked "
"list of free blocks managed by the B<malloc>(3)  family of functions) may be "
"left in an inconsistent state if cancellation occurs in the middle of the "
"function call.  Consequently, clean-up handlers cease to be useful."
msgstr ""
"Задание типа отменяемости B<PTHREAD_CANCEL_ASYNCHRONOUS> полезно редко. Так "
"как нить может быть отменена в I<любой> момент, невозможно безопасно "
"резервировать ресурсы (например, выделять память с помощью B<malloc>(3)), "
"захватывать мьютексы, семафоры или блокировки и так далее. Резервирование "
"ресурсов небезопасно, так как приложение не может узнать состояние этих "
"ресурсов при отмене нити; то есть, произошла ли отмена до резервирования "
"ресурсов, во время из резервирования или после их освобождения? Кроме того, "
"некоторые внутренние структуры данных (например, связные списки свободных "
"блоков, управляемые семейством функций B<malloc>(3)) могут остаться в не "
"целостном состоянии, если отмена происходит в середине вызова функции. "
"Следовательно, обработчики очистки перестают быть полезными."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:179
msgid ""
"Functions that can be safely asynchronously canceled are called I<async-"
"cancel-safe functions>.  POSIX.1-2001 and POSIX.1-2008 require only that "
"B<pthread_cancel>(3), B<pthread_setcancelstate>(), and "
"B<pthread_setcanceltype>()  be async-cancel-safe.  In general, other library "
"functions can't be safely called from an asynchronously cancelable thread."
msgstr ""
"Функции, которые можно безопасно асинхронно отменять называются I<функциями "
"async-cancel-safe>. В POSIX.1-2001 и POSIX.1-2008 требуется, чтобы такими "
"функция были только B<pthread_cancel>(3), B<pthread_setcancelstate>() и "
"B<pthread_setcanceltype>(). В общем, другие функции библиотеки нельзя "
"безопасно вызывать из асинхронно отменяемой нити."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:182
msgid ""
"One of the few circumstances in which asynchronous cancelability is useful "
"is for cancellation of a thread that is in a pure compute-bound loop."
msgstr ""
"Одной из нескольких ситуаций, в которых асинхронная отменяемость полезна, "
"является отменяемость нити, которая находится в цикле, занимающимся только "
"вычислениями."

#.  It looks like at least Solaris, FreeBSD and Tru64 support this.
#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:200
msgid ""
"The Linux threading implementations permit the I<oldstate> argument of "
"B<pthread_setcancelstate>()  to be NULL, in which case the information about "
"the previous cancelability state is not returned to the caller.  Many other "
"implementations also permit a NULL I<oldstat> argument, but POSIX.1 does not "
"specify this point, so portable applications should always specify a non-"
"NULL value in I<oldstate>.  A precisely analogous set of statements applies "
"for the I<oldtype> argument of B<pthread_setcanceltype>()."
msgstr ""
"Реализации нитей в Linux позволяют присваивать аргументу I<oldstate> функции "
"B<pthread_setcancelstate>()  значение NULL; в этом случае информация о "
"предыдущем состоянии отмены не возвращается вызывающему. Многие другие "
"реализации также допускают NULL в качестве значения I<oldstat>, но POSIX.1 "
"этот случай не рассматривается, поэтому переносимые приложения должны всегда "
"указывать в I<oldstate> значение, отличное от NULL. Эти утверждения "
"относятся и к аргументу I<oldtype> функции B<pthread_setcanceltype>()."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:203
msgid "See B<pthread_cancel>(3)."
msgstr "Смотрите B<pthread_cancel>(3)."

#. type: Plain text
#: man-pages/man3/pthread_setcancelstate.3:207
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setstack.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACK"
msgstr "PTHREAD_ATTR_SETSTACK"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:30
msgid ""
"pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in "
"thread attributes object"
msgstr ""
"pthread_attr_setstack, pthread_attr_getstack - изменяет/возвращает атрибуты "
"стека из объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(const pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(const pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:50
msgid "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"
msgstr "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:68
msgid ""
"The B<pthread_attr_setstack>()  function sets the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> to "
"the values specified in I<stackaddr> and I<stacksize>, respectively.  These "
"attributes specify the location and size of the stack that should be used by "
"a thread that is created using the thread attributes object I<attr>."
msgstr ""
"Функция B<pthread_attr_setstack>() изменяет атрибуты адреса и размера стека "
"в объекте атрибутов нити, на который указывает I<attr>, на значения, "
"задаваемые в I<stackaddr> и I<stacksize>, соответственно. Данными атрибутами "
"задаёт расположение и размер стека, который будет использоваться нитью, "
"создаваемой с использованием объекта атрибутов нити I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:74
msgid ""
"I<stackaddr> should point to the lowest addressable byte of a buffer of "
"I<stacksize> bytes that was allocated by the caller.  The pages of the "
"allocated buffer should be both readable and writable."
msgstr ""
"Значение I<stackaddr> должно указывать на самый младший адресуемый байт "
"буфера из I<stacksize> байт, выделенного вызывающим. Страницы выделенного "
"буфера должны быть доступны на чтение и запись."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:85
msgid ""
"The B<pthread_attr_getstack>()  function returns the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> in "
"the buffers pointed to by I<stackaddr> and I<stacksize>, respectively."
msgstr ""
"Функция B<pthread_attr_getstack>() возвращает атрибуты адреса и размера "
"стека  из объекта атрибутов нити, на который указывает I<attr>, в буфер, на "
"который указывает I<stackaddr> и I<stacksize>, соответственно."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:91
msgid "B<pthread_attr_setstack>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_attr_setstack>() может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:102
msgid ""
"I<stacksize> is less than B<PTHREAD_STACK_MIN> (16384) bytes.  On some "
"systems, this error may also occur if I<stackaddr> or I<stackaddr\\ +\\ "
"stacksize> is not suitably aligned."
msgstr ""
"Значение I<stacksize> меньше B<PTHREAD_STACK_MIN> (16384) байт. В некоторых "
"системах эта ошибка также может возникать, если значения I<stackaddr> или "
"I<stackaddr\\ +\\ stacksize> не выровнены правильным образом."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:110
msgid ""
"POSIX.1 also documents an B<EACCES> error if the stack area described by "
"I<stackaddr> and I<stacksize> is not both readable and writable by the "
"caller."
msgstr ""
"В POSIX.1 также описана ошибка B<EACCES>, которая возникает, если область "
"стека, определённая I<stackaddr> и I<stacksize>, недоступна вызывающему на "
"чтение и запись."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:112
msgid "These functions are provided by glibc since version 2.2."
msgstr "Эти функции определены в glibc начиная с версии 2.2."

#. type: tbl table
#: man-pages/man3/pthread_attr_setstack.3:123
#, no-wrap
msgid ""
"B<pthread_attr_setstack>(),\n"
"B<pthread_attr_getstack>()"
msgstr ""
"B<pthread_attr_setstack>(),\n"
"B<pthread_attr_getstack>()"

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:135
msgid ""
"These functions are provided for applications that must ensure that a "
"thread's stack is placed in a particular location.  For most applications, "
"this is not necessary, and the use of these functions should be avoided.  "
"(Use B<pthread_attr_setstacksize>(3)  if an application simply requires a "
"stack size other than the default.)"
msgstr ""
"Эти функции нужны приложениям, в которых нужно размещать стек в определённом "
"месте. В большинстве приложений это не нужно и эти функции использовать не "
"стоит (используйте B<pthread_attr_setstacksize>(3), если приложению нужно "
"задать только размер стека, отличный от умолчательного)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:146
msgid ""
"When an application employs B<pthread_attr_setstack>(), it takes over the "
"responsibility of allocating the stack.  Any guard size value that was set "
"using B<pthread_attr_setguardsize>(3)  is ignored.  If deemed necessary, it "
"is the application's responsibility to allocate a guard area (one or more "
"pages protected against reading and writing)  to handle the possibility of "
"stack overflow."
msgstr ""
"Когда приложение использует B<pthread_attr_setstack>(), оно самостоятельно "
"выделяет место под стек. Защитный размер, задаваемый "
"B<pthread_attr_setguardsize>(3), игнорируется. Если его учитывать "
"необходимо, то приложение должно самостоятельно выделять защитную область "
"(одну или несколько страниц, защищённых от чтения и записи) для обработки "
"возможного переполнения стека."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:157
msgid ""
"The address specified in I<stackaddr> should be suitably aligned: for full "
"portability, align it on a page boundary (I<sysconf(_SC_PAGESIZE)>).  "
"B<posix_memalign>(3)  may be useful for allocation.  Probably, I<stacksize> "
"should also be a multiple of the system page size."
msgstr ""
"Адрес, указанный в I<stackaddr>, должен быть выровнен соответствующим "
"образом: для полной переносимости выравнивайте его по границе страницы "
"(I<sysconf(_SC_PAGESIZE)>). Для выделения полезно использовать функцию "
"B<posix_memalign>(3). Вероятно, значение I<stacksize> также должно быть "
"кратно размеру системной страницы."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:165
msgid ""
"If I<attr> is used to create multiple threads, then the caller must change "
"the stack address attribute between calls to B<pthread_create>(3); "
"otherwise, the threads will attempt to use the same memory area for their "
"stacks, and chaos will ensue."
msgstr ""
"Если I<attr> используется при создании нескольких нитей, то вызывающий "
"должен изменять атрибут адреса стека между вызовами B<pthread_create>(3); в "
"противном случае нити будут пытаться использовать одну и ту же область "
"памяти для стека и возникнет хаос."

#. type: Plain text
#: man-pages/man3/pthread_attr_setstack.3:179
msgid ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_attr_setinheritsched.3:26
#, no-wrap
msgid "PTHREAD_ATTR_SETINHERITSCHED"
msgstr "PTHREAD_ATTR_SETINHERITSCHED"

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:30
msgid ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get inherit-"
"scheduler attribute in thread attributes object"
msgstr ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - изменяет/"
"возвращает атрибут наследования планировщика из объекта атрибутов нити"

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:38
#, no-wrap
msgid ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"
msgstr ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(const pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:55
msgid ""
"The B<pthread_attr_setinheritsched>()  function sets the inherit-scheduler "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<inheritsched>.  The inherit-scheduler attribute "
"determines whether a thread created using the thread attributes object "
"I<attr> will inherit its scheduling attributes from the calling thread or "
"whether it will take them from I<attr>."
msgstr ""
"Функция B<pthread_attr_setinheritsched>() изменяет атрибут наследования "
"планировщика у объекта атрибутов нити, на которую указывает I<attr>, на "
"значение, заданное в I<inheritsched>. Атрибут наследования планировщика "
"определяет будет ли нить, создаваемая с учётом объекта атрибутов нити "
"I<attr>, наследовать свои атрибуты планировщика от вызывающей нити или для "
"этого будут использованы значения из I<attr>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:64
msgid ""
"The following scheduling attributes are affected by the inherit-scheduler "
"attribute: scheduling policy (B<pthread_attr_setschedpolicy>(3)), scheduling "
"priority (B<pthread_attr_setschedparam>(3)), and contention scope "
"(B<pthread_attr_setscope>(3))."
msgstr ""
"Атрибуты планирования, на которые влияет атрибут наследования планировщика: "
"алгоритм планирования (B<pthread_attr_setschedpolicy>(3)), приоритет "
"планирования (B<pthread_attr_setschedparam>(3)) и область конкурирования "
"(B<pthread_attr_setscope>(3))."

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:67
msgid "The following values may be specified in I<inheritsched>:"
msgstr "В I<inheritsched> можно указать следующие значения:"

#. type: TP
#: man-pages/man3/pthread_attr_setinheritsched.3:67
#, no-wrap
msgid "B<PTHREAD_INHERIT_SCHED>"
msgstr "B<PTHREAD_INHERIT_SCHED>"

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:75
msgid ""
"Threads that are created using I<attr> inherit scheduling attributes from "
"the creating thread; the scheduling attributes in I<attr> are ignored."
msgstr ""
"Нити, создаваемые с учётом I<attr>, наследуют атрибуты планирования от "
"создающей нити; атрибуты планирования I<attr> игнорируются."

#. type: TP
#: man-pages/man3/pthread_attr_setinheritsched.3:75
#, no-wrap
msgid "B<PTHREAD_EXPLICIT_SCHED>"
msgstr "B<PTHREAD_EXPLICIT_SCHED>"

#.  FIXME Document the defaults for scheduler settings
#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:82
msgid ""
"Threads that are created using I<attr> take their scheduling attributes from "
"the values specified by the attributes object."
msgstr ""
"Нити, создаваемые с учётом I<attr>, берут значения атрибутов планирования из "
"указанного объекта атрибутов."

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:86
msgid ""
"The default setting of the inherit-scheduler attribute in a newly "
"initialized thread attributes object is B<PTHREAD_INHERIT_SCHED>."
msgstr ""
"Значением по умолчанию для атрибута наследования планировщика в "
"инициализируемом объекте атрибутов нити является B<PTHREAD_INHERIT_SCHED>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:93
msgid ""
"The B<pthread_attr_getinheritsched>()  returns the inherit-scheduler "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<inheritsched>."
msgstr ""
"Функция B<pthread_attr_getinheritsched>() возвращает атрибут наследования "
"планировщика у объекта атрибутов нити, на который указывает I<attr>, в буфер "
"на который указывает I<inheritsched>."

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:99
msgid "B<pthread_attr_setinheritsched>()  can fail with the following error:"
msgstr ""
"Функция B<pthread_attr_setinheritsched>() может завершиться со следующей "
"ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:103
msgid "Invalid value in I<inheritsched>."
msgstr "Некорректное значение I<inheritsched>."

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:110
msgid ""
"POSIX.1 also documents an optional B<ENOTSUP> error (\"attempt was made to "
"set the attribute to an unsupported value\") for "
"B<pthread_attr_setinheritsched>()."
msgstr ""
"Для B<pthread_attr_setinheritsched>() в POSIX.1 также описана необязательная "
"ошибка B<ENOTSUP> («попытка изменить атрибут на не поддерживаемое значение»)."

#. type: tbl table
#: man-pages/man3/pthread_attr_setinheritsched.3:121
#, no-wrap
msgid ""
"B<pthread_attr_setinheritsched>(),\n"
"B<pthread_attr_getinheritsched>()"
msgstr ""
"B<pthread_attr_setinheritsched>(),\n"
"B<pthread_attr_getinheritsched>()"

#.  FIXME . Track status of the following bug:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7007
#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:141
msgid ""
"As at glibc 2.8, if a thread attributes object is initialized using "
"B<pthread_attr_init>(3), then the scheduling policy of the attributes object "
"is set to B<SCHED_OTHER> and the scheduling priority is set to 0.  However, "
"if the inherit-scheduler attribute is then set to B<PTHREAD_EXPLICIT_SCHED>, "
"then a thread created using the attribute object wrongly inherits its "
"scheduling attributes from the creating thread.  This bug does not occur if "
"either the scheduling policy or scheduling priority attribute is explicitly "
"set in the thread attributes object before calling B<pthread_create>(3)."
msgstr ""
"По состоянию на glibc 2.8, если объект атрибутов нити инициализирован с "
"помощью B<pthread_attr_init>(3), то алгоритму планирования в объекте "
"атрибутов присваивается B<SCHED_OTHER>, а приоритет планирования равен 0. "
"Однако, если затем атрибут наследования планировщика устанавливается в "
"B<PTHREAD_EXPLICIT_SCHED>, то нить, создаваемая с учётом объекта атрибутов, "
"неправильно наследует свои атрибуты планирования от создающей нити. Этот "
"дефект не проявляется, если значение атрибута алгоритма планирования или "
"приоритета планирования назначается явно в объекте атрибутов нити до вызова "
"B<pthread_create>(3)."

#. type: Plain text
#: man-pages/man3/pthread_attr_setinheritsched.3:155
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_attr_setscope>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"

#. type: TH
#: man-pages/man3/pthread_kill_other_threads_np.3:26
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr "PTHREAD_KILL_OTHER_THREADS_NP"

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:29
msgid "pthread_kill_other_threads_np - terminate all other threads in process"
msgstr "pthread_kill_other_threads_np - завершает все остальные нити процесса"

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:34
#, no-wrap
msgid "B<void pthread_kill_other_threads_np(void);>\n"
msgstr "B<void pthread_kill_other_threads_np(void);>\n"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:47
msgid ""
"B<pthread_kill_other_threads_np>()  has an effect only in the LinuxThreads "
"threading implementation.  On that implementation, calling this function "
"causes the immediate termination of all threads in the application, except "
"the calling thread.  The cancellation state and cancellation type of the to-"
"be-terminated threads are ignored, and the cleanup handlers are not called "
"in those threads."
msgstr ""
"Функция B<pthread_kill_other_threads_np>() эффективна только в реализации "
"нитей LinuxThreads. В этой реализации вызов данной функции приводит к "
"немедленному завершению всех нитей приложения, кроме той, из которой вызвана "
"функция. Состояние и тип отмены завершаемых нитей игнорируются, а очищающие "
"обработчики не вызываются."

#. type: tbl table
#: man-pages/man3/pthread_kill_other_threads_np.3:57
#, no-wrap
msgid "B<pthread_kill_other_threads_np>()"
msgstr "B<pthread_kill_other_threads_np>()"

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:71
msgid ""
"B<pthread_kill_other_threads_np>()  is intended to be called just before a "
"thread calls B<execve>(2)  or a similar function.  This function is designed "
"to address a limitation in the obsolete LinuxThreads implementation whereby "
"the other threads of an application are not automatically terminated (as "
"POSIX.1-2001 requires) during B<execve>(2)."
msgstr ""
"Функция B<pthread_kill_other_threads_np>() предназначена для вызова из нити "
"B<execve>(2) или подобной функции. Она разработана для преодоления "
"ограничения в устаревшей реализации LinuxThreads, где нити приложения не "
"завершаются автоматически (как того требуется в POSIX.1-2001) при "
"B<execve>(2)."

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:78
msgid ""
"In the NPTL threading implementation, B<pthread_kill_other_threads_np>()  "
"exists, but does nothing.  (Nothing needs to be done, because the "
"implementation does the right thing during an B<execve>(2).)"
msgstr ""
"В реализации нитей NPTL функция B<pthread_kill_other_threads_np>() также "
"существует, но ничего не делает (делать ничего не нужно, так как реализация "
"правильно работает во время B<execve>(2))."

#. type: Plain text
#: man-pages/man3/pthread_kill_other_threads_np.3:83
msgid ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"
msgstr ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_cleanup_push_defer_np.3:26
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH_DEFER_NP"
msgstr "PTHREAD_CLEANUP_PUSH_DEFER_NP"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:30
msgid ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - push and pop "
"thread cancellation clean-up handlers while saving cancelability type"
msgstr ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - добавляет и "
"удаляет очищающие обработчики отмены нити при сохранении типа отмены"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:37
#, no-wrap
msgid ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"
msgstr ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:49
msgid "B<pthread_cleanup_push_defer_np>(), B<pthread_cleanup_pop_defer_np>():"
msgstr "B<pthread_cleanup_push_defer_np>(), B<pthread_cleanup_pop_defer_np>():"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:59
msgid ""
"These functions are the same as B<pthread_cleanup_push>(3)  and "
"B<pthread_cleanup_pop>(3), except for the differences noted on this page."
msgstr ""
"Эти функции работают также как B<pthread_cleanup_push>(3) и "
"B<pthread_cleanup_pop>(3), за исключением различий, описанных в данной "
"справочной странице."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:72
msgid ""
"Like B<pthread_cleanup_push>(3), B<pthread_cleanup_push_defer_np>()  pushes "
"I<routine> onto the thread's stack of cancellation clean-up handlers.  In "
"addition, it also saves the thread's current cancelability type, and sets "
"the cancelability type to \"deferred\" (see B<pthread_setcanceltype>(3)); "
"this ensures that cancellation clean-up will occur even if the thread's "
"cancelability type was \"asynchronous\" before the call."
msgstr ""
"Подобно B<pthread_cleanup_push>(3), B<pthread_cleanup_push_defer_np>() "
"добавляет I<routine> в стек нити к очищающим обработчикам отмены. Кроме "
"этого, она также сохраняет текущий тип отмены нити, и изменяет тип отмены на "
"«отложенный» (смотрите B<pthread_setcanceltype>(3)); это гарантирует, что "
"очистка при отмене произойдёт даже, если тип отмены нити перед вызовом был "
"«асинхронный»."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:81
msgid ""
"Like B<pthread_cleanup_pop>(3), B<pthread_cleanup_pop_restore_np>()  pops "
"the top-most clean-up handler from the thread's stack of cancellation clean-"
"up handlers.  In addition, it restores the thread's cancelability type to "
"its value at the time of the matching B<pthread_cleanup_push_defer_np>()."
msgstr ""
"Подобно B<pthread_cleanup_pop>(3), B<pthread_cleanup_pop_restore_np>() "
"удаляет самый верхний очищающий обработчик из стека нити очищающих "
"обработчиков отмены. Кроме этого, она восстанавливает тип отмены нити в "
"значение на момент, когда была вызвана B<pthread_cleanup_push_defer_np>()."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:87
msgid ""
"The caller must ensure that calls to these functions are paired within the "
"same function, and at the same lexical nesting level.  Other restrictions "
"apply, as described in B<pthread_cleanup_push>(3)."
msgstr ""
"Вызывающий должен гарантировать, что вызовы этих функций будут попарными "
"внутри одной функции, и на одном лексическом уровне вложенности. Остальные "
"ограничения описаны в B<pthread_cleanup_push>(3)."

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:89
msgid "This sequence of calls:"
msgstr "Последовательность вызовов:"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:94
#, no-wrap
msgid ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"
msgstr ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:98
msgid "is equivalent to (but shorter and more efficient than):"
msgstr "эквивалентна (но короче и эффективнее):"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:104
#, no-wrap
msgid "int oldtype;\n"
msgstr "int oldtype;\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:110
#, no-wrap
msgid ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"
msgstr ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"

#. type: Plain text
#: man-pages/man3/pthread_cleanup_push_defer_np.3:122
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/profil.3:28
#, no-wrap
msgid "PROFIL"
msgstr "PROFIL"

#. type: Plain text
#: man-pages/man3/profil.3:31
msgid "profil - execution time profile"
msgstr "profil - профилирование времени работы"

#. type: Plain text
#: man-pages/man3/profil.3:37
#, no-wrap
msgid ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<,>\n"
"B<           size_t >I<offset>B<, unsigned int >I<scale>B<);>\n"
msgstr ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<,>\n"
"B<           size_t >I<offset>B<, unsigned int >I<scale>B<);>\n"

#. type: Plain text
#: man-pages/man3/profil.3:45
msgid "B<profil>():"
msgstr "B<profil>():"

#.              commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: man-pages/man3/profil.3:53
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""
"    Начиная с glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    В glibc 2.19 и 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    По glibc 2.19 включительно:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"

#. type: Plain text
#: man-pages/man3/profil.3:76
msgid ""
"This routine provides a means to find out in what areas your program spends "
"most of its time.  The argument I<buf> points to I<bufsiz> bytes of core.  "
"Every virtual 10 milliseconds, the user's program counter (PC)  is examined: "
"I<offset> is subtracted and the result is multiplied by I<scale> and divided "
"by 65536.  If the resulting value is less than I<bufsiz>, then the "
"corresponding entry in I<buf> is incremented.  If I<buf> is NULL, profiling "
"is disabled."
msgstr ""
"Эта функция позволяет выяснить какие области вашей программы работают больше "
"всего. В аргументе I<buf> указывается I<bufsiz> байт ядра. Каждые 10 "
"виртуальных миллисекунд проверяется пользовательский программный счётчик "
"(PC): из него вычитается I<offset>, умножается на I<scale> и делится на "
"65536. Если полученное значение меньше I<bufsiz>, то в I<buf> увеличивается "
"соответствующая запись. Если I<buf> равно NULL, профилирование выключено."

#. type: Plain text
#: man-pages/man3/profil.3:78
msgid "Zero is always returned."
msgstr "Всегда возвращается ноль."

#. type: tbl table
#: man-pages/man3/profil.3:88
#, no-wrap
msgid "B<profil>()"
msgstr "B<profil>()"

#. type: tbl table
#: man-pages/man3/profil.3:88
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: man-pages/man3/profil.3:93
msgid "Similar to a call in SVr4 (but not POSIX.1)."
msgstr "Подобно вызову в SVr4 (но не POSIX.1)."

#. type: Plain text
#: man-pages/man3/profil.3:99
msgid ""
"B<profil>()  cannot be used on a program that also uses B<ITIMER_PROF> "
"interval timers (see B<setitimer>(2))."
msgstr ""
"Функцию B<profil>() нельзя использовать на программе, которая также "
"использует таймеры интервалов B<ITIMER_PROF> (смотрите B<setitimer>(2))."

#. type: Plain text
#: man-pages/man3/profil.3:102
msgid ""
"True kernel profiling provides more accurate results.  Libc 4.4 contained a "
"kernel patch providing a system call profil."
msgstr ""
"При профилировании настоящим ядром получаются более точные результаты. В "
"libc 4.4 есть заплата к ядру, добавляющая системный вызов profil."

#. type: Plain text
#: man-pages/man3/profil.3:107
msgid ""
"B<gprof>(1), B<sprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"
msgstr ""
"B<gprof>(1), B<sprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"

#. type: TH
#: man-pages/man3/putpwent.3:30
#, no-wrap
msgid "PUTPWENT"
msgstr "PUTPWENT"

#. type: Plain text
#: man-pages/man3/putpwent.3:33
msgid "putpwent - write a password file entry"
msgstr "putpwent - записывает элемент в файл паролей"

#. type: Plain text
#: man-pages/man3/putpwent.3:38
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/putpwent.3:40
#, no-wrap
msgid "B<int putpwent(const struct passwd *>I<p>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putpwent(const struct passwd *>I<p>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/putpwent.3:52
#, no-wrap
msgid ""
"B<putpwent>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""
"B<putpwent>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/putpwent.3:57
msgid ""
"The B<putpwent>()  function writes a password entry from the structure I<p> "
"in the file associated with I<stream>."
msgstr ""
"Функция B<putpwent>() выполняет запись элемента пароля из структуры I<p> в "
"файл, связанный с I<stream>."

#. type: Plain text
#: man-pages/man3/putpwent.3:59
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr "Структура I<passwd> определена в I<E<lt>pwd.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/putpwent.3:71
#, no-wrap
msgid ""
"struct passwd {\n"
"    char    *pw_name;        /* username */\n"
"    char    *pw_passwd;      /* user password */\n"
"    uid_t    pw_uid;         /* user ID */\n"
"    gid_t    pw_gid;         /* group ID */\n"
"    char    *pw_gecos;       /* real name */\n"
"    char    *pw_dir;         /* home directory */\n"
"    char    *pw_shell;       /* shell program */\n"
"};\n"
msgstr ""
"struct passwd {\n"
"    char    *pw_name;        /* имя пользователя */\n"
"    char    *pw_passwd;      /* пароль пользователя */\n"
"    uid_t    pw_uid;         /* идентификатор пользователя */\n"
"    gid_t    pw_gid;         /* идентификатор группы */\n"
"    char    *pw_gecos;       /* настоящее имя */\n"
"    char    *pw_dir;         /* домашний каталог */\n"
"    char    *pw_shell;       /* программная оболочка */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/putpwent.3:81
msgid ""
"The B<putpwent>()  function returns 0 on success, or -1 if an error occurs.  "
"In the event of an error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<putpwent>() возвращает ноль при успешном выполнении и -1 в "
"противном случае. При ошибке I<errno> отражает причину ошибки."

#. type: Plain text
#: man-pages/man3/putpwent.3:85
msgid "Invalid (NULL) argument given."
msgstr "Неверное значение (NULL) аргумента."

#. type: tbl table
#: man-pages/man3/putpwent.3:95
#, no-wrap
msgid "B<putpwent>()"
msgstr "B<putpwent>()"

#. type: Plain text
#: man-pages/man3/putpwent.3:100
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man3/putpwent.3:107
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<getpwuid>(3), B<setpwent>(3)"
msgstr ""
"B<endpwent>(3), B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), "
"B<getpwnam>(3), B<getpwuid>(3), B<setpwent>(3)"

#. type: TH
#: man-pages/man3/pthread_spin_init.3:25
#, no-wrap
msgid "PTHREAD_SPIN_INIT"
msgstr "PTHREAD_SPIN_INIT"

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:28
msgid ""
"pthread_spin_init, pthread_spin_destroy - initialize or destroy a spin lock"
msgstr ""
"pthread_spin_init, pthread_spin_destroy - инициализирует или уничтожает "
"циклическую блокировку"

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:34
#, no-wrap
msgid ""
"B<int pthread_spin_init(pthread_spinlock_t *>I<lock>B<, int >I<pshared>B<);>\n"
"B<int pthread_spin_destroy(pthread_spinlock_t *>I<lock>B<);>\n"
msgstr ""
"B<int pthread_spin_init(pthread_spinlock_t *>I<lock>B<, int >I<pshared>B<);>\n"
"B<int pthread_spin_destroy(pthread_spinlock_t *>I<lock>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:45
msgid "B<pthread_spin_init>(), B<pthread_spin_destroy>():"
msgstr "B<pthread_spin_init>(), B<pthread_spin_destroy>():"

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:58
msgid ""
"I<General note>: Most programs should use mutexes instead of spin locks.  "
"Spin locks are primarily useful in conjunction with real-time scheduling "
"policies.  See NOTES."
msgstr ""
"I<Общее замечание>: Большинству программ достаточно использования мьютексов, "
"а не циклических блокировок. В основном, циклические блокировки полезны при "
"применении алгоритмов планирования реального времени. Смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:68
msgid ""
"The B<pthread_spin_init>()  function allocates any resources required for "
"the use of the spin lock referred to by I<lock> and initializes the lock to "
"be in the unlocked state.  The I<pshared> argument must have one of the "
"following values:"
msgstr ""
"Функция B<pthread_spin_init>() выделяет ресурсы, требуемые для работы "
"циклической блокировки, на которую указывает I<lock>, и инициализирует "
"блокировку в неблокированном состоянии. В аргументе I<pshared> должно быть "
"одно из следующих значений:"

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:75
msgid ""
"The spin lock is to be operated on only by threads in the same process as "
"the thread that calls B<pthread_spin_init>().  (Attempting to share the spin "
"lock between processes results in undefined behavior.)"
msgstr ""
"Циклическая блокировка будет использоваться только нитями одного процесса, "
"которому принадлежит вызвавшая B<pthread_spin_init>() нить (попытка "
"использования такой циклической блокировки между процессами приводит к "
"непредсказуемому поведению)."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:81
msgid ""
"The spin lock may be operated on by any thread in any process that has "
"access to the memory containing the lock (i.e., the lock may be in a shared "
"memory object that is shared among multiple processes)."
msgstr ""
"Циклическая блокировка может использоваться любой нитью любого процесса, "
"который имеет доступ к памяти, содержащей блокировку (т. е., блокировка "
"может находиться в объекте общей памяти, который используется несколькими "
"процессами)."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:86
msgid ""
"Calling B<pthread_spin_init>()  on a spin lock that has already been "
"initialized results in undefined behavior."
msgstr ""
"Вызов B<pthread_spin_init>() с уже инициализированной циклической "
"блокировкой приводит к непредсказуемому поведению."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:94
msgid ""
"The B<pthread_spin_destroy>()  function destroys a previously initialized "
"spin lock, freeing any resources that were allocated for that lock.  "
"Destroying a spin lock that has not been previously been initialized or "
"destroying a spin lock while another thread holds the lock results in "
"undefined behavior."
msgstr ""
"Функция B<pthread_spin_destroy>() уничтожает ранее инициализированную "
"циклическую блокировку, освобождая все выделенные ей ресурсы. Уничтожение "
"ещё не инициализированной циклической блокировки или уничтожение циклической "
"блокировки, которая захвачена другой нитью,приводит к непредсказуемым "
"результатам."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:100
msgid ""
"Once a spin lock has been destroyed, performing any operation on the lock "
"other than once more initializing it with B<pthread_spin_init>()  results in "
"undefined behavior."
msgstr ""
"После того, как циклическая блокировка уничтожена, выполнение с ней любой "
"операции кроме инициализации B<pthread_spin_init>() приводит к "
"непредсказуемому поведению."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:111
msgid ""
"The result of performing operations such as B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), and B<pthread_spin_destroy>(3)  on I<copies> of "
"the object referred to by I<lock> is undefined."
msgstr ""
"Результат выполнения операций B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3) и B<pthread_spin_destroy>(3) с I<копией> объекта, "
"на который указывает I<lock>, не определён."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:117
msgid ""
"On success, there functions return zero.  On failure, they return an error "
"number.  In the event that B<pthread_spin_init>()  fails, the lock is not "
"initialized."
msgstr ""
"При успешном выполнении эти функции возвращают ноль. При ошибке возвращается "
"номер ошибки. Если ошибкой завершается B<pthread_spin_init>(), то "
"инициализация блокировки не происходит."

#.  These errors don't occur on the glibc implementation
#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:121
msgid "B<pthread_spin_init>()  may fail with the following errors:"
msgstr ""
"Функция B<pthread_spin_init>() может завершаться со следующими ошибками:"

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:125
msgid "The system has insufficient resources to initialize a new spin lock."
msgstr ""
"В системе не хватает ресурсов для инициализации новой циклической блокировки."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:128
msgid "Insufficient memory to initialize the spin lock."
msgstr "Недостаточно памяти для инициализации циклической блокировки."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:135
msgid ""
"Support for process-shared spin locks is a POSIX option.  The option is "
"supported in the glibc implementation."
msgstr ""
"Поддержка общих для процессов циклических блокировок указана в POSIX. Она "
"поддерживается реализацией glibc."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:148
msgid ""
"Spin locks should be employed in conjunction with real-time scheduling "
"policies (B<SCHED_FIFO>, or possibly B<SCHED_RR>).  Use of spin locks with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> probably "
"indicates a design mistake.  The problem is that if a thread operating under "
"such a policy is scheduled off the CPU while it holds a spin lock, then "
"other threads will waste time spinning on the lock until the lock holder is "
"once more rescheduled and releases the lock."
msgstr ""
"Циклические блокировки должны использоваться вместе с алгоритмами выполнения "
"реального времени (B<SCHED_FIFO> или, возможно, B<SCHED_RR>). Использование "
"циклических блокировок с недерминированными алгоритмами планирования, такими "
"как B<SCHED_OTHER>, вероятно, указывают на ошибки при проектировании. "
"Проблема в том, что если нить, выполняющаяся по такому алгоритму, вытеснится "
"с ЦП в момент когда она удерживает циклическую блокировку, остальные нити "
"будут впустую тратить время на ожидание блокировки, пока держатель не будет "
"запланирован к выполнению и не освободит блокировку."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:151
msgid ""
"If threads create a deadlock situation while employing spin locks, those "
"threads will spin forever consuming CPU time."
msgstr ""
"Если нити создают ситуацию взаимной блокировки при работе с циклическими "
"блокировками, то эти нити будут ждать блокировку бесконечно потребляя время "
"ЦП."

#.  FIXME . When PTHREAD_MUTEX_ADAPTIVE_NP is one day document
#.  make reference to it here
#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:162
msgid ""
"User-space spin locks are I<not> applicable as a general locking solution.  "
"They are, by definition, prone to priority inversion and unbounded spin "
"times.  A programmer using spin locks must be exceptionally careful not only "
"in the code, but also in terms of system configuration, thread placement, "
"and priority assignment."
msgstr ""
"Циклические блокировки пользовательского пространства I<не> применяются в "
"качестве обычного решения по блокировкам. Они, по определению, подвержены "
"смене приоритетов и неограниченны по времени ожидания. Программист, "
"использующий циклические блокировки, должен быть исключительно осмотрителен "
"не только с кодом, но и с настройкой системы, размещением нити и назначением "
"приоритета."

#. type: Plain text
#: man-pages/man3/pthread_spin_init.3:169
msgid ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_mutex_init>(3), B<pthread_mutex_lock>(3), B<pthread_spin_lock>(3), "
"B<pthread_spin_unlock>(3), B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_mutex_consistent.3:26
#, no-wrap
msgid "PTHREAD_MUTEX_CONSISTENT"
msgstr "PTHREAD_MUTEX_CONSISTENT"

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:29
msgid "pthread_mutex_consistent - make a robust mutex consistent"
msgstr "pthread_mutex_consistent - делает устойчивый мьютекс согласованным"

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:34
#, no-wrap
msgid "B<int pthread_mutex_consistent(pthread_mutex_t *>I<mutex>B<);>\n"
msgstr "B<int pthread_mutex_consistent(pthread_mutex_t *>I<mutex>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:44
msgid "B<pthread_mutex_consistent>():"
msgstr "B<pthread_mutex_consistent>():"

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:59
msgid ""
"This function makes a robust mutex consistent if it is in an inconsistent "
"state.  A mutex can be left in an inconsistent state if its owner terminates "
"while holding the mutex, in which case the next owner who acquires the mutex "
"will succeed and be notified by a return value of B<EOWNERDEAD> from a call "
"to B<pthread_mutex_lock>()."
msgstr ""
"Данная функция делает устойчивый мьютекс согласованным, если он находится в "
"рассогласованном состоянии. Мьютекс может остаться в рассогласованном "
"состоянии, если владелец завершил работу, удерживая мьютекс; в этом случае "
"следующий владелец, захвативший мьютекс вызовом B<pthread_mutex_lock>(), "
"получит уведомление возвращаемым значением B<EOWNERDEAD> ."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:65
msgid ""
"On success, I<pthread_mutex_consistent>()  returns 0.  Otherwise, it returns "
"a positive error number to indicate the cause of the error."
msgstr ""
"При успешном выполнении I<pthread_mutex_consistent>() возвращает 0. В "
"противном случае возвращается положительный номер, указывающий на причину "
"ошибки."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:69
msgid "The mutex is either not robust or is not in an inconsistent state."
msgstr ""
"Мьютекс находит не в согласованном состоянии и не в рассогласованном "
"состоянии."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:72
msgid "B<pthread_mutex_consistent>()  was added to glibc in version 2.12."
msgstr "Функция B<pthread_mutex_consistent>() впервые появилась в glibc 2.12."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:82
msgid ""
"B<pthread_mutex_consistent>()  simply informs the implementation that the "
"state (shared data)  guarded by the mutex has been restored to a consistent "
"state and that normal operations can now be performed with the mutex.  It is "
"the application's responsibility to ensure that the shared data has been "
"restored to a consistent state before calling B<pthread_mutex_consistent>()."
msgstr ""
"Функция B<pthread_mutex_consistent>() просто информирует реализацию, что "
"состояние (общие данные) защищаемые мьютексом, были восстановлены в "
"согласованное состояние и что теперь с мьютексом можно выполнять обычные "
"операции. Перед вызовом B<pthread_mutex_consistent>() приложение само должно "
"приводить данные в согласованное состояние."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:89
msgid ""
"Before the addition of B<pthread_mutex_consistent>()  to POSIX, glibc "
"defined the following equivalent nonstandard function if B<_GNU_SOURCE> was "
"defined:"
msgstr ""
"До появления B<pthread_mutex_consistent>() в POSIX, в glibc определялся "
"следующий эквивалент нестандартной функции, если определён B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:92
#, no-wrap
msgid "B<int pthread_mutex_consistent(const pthread_mutex_t *>I<mutex>B<);>\n"
msgstr "B<int pthread_mutex_consistent(const pthread_mutex_t *>I<mutex>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:96
msgid ""
"This GNU-specific API, which first appeared in glibc 2.4, is nowadays "
"obsolete and should not be used in new programs."
msgstr ""
"Данный имеющийся только в GNU программный интерфейс, впервые появившийся в "
"glibc 2.4, в настоящее время устарел и не должен использоваться в новых "
"программах."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:99
msgid "See B<pthread_mutexattr_setrobust>(3)."
msgstr "Смотрите B<pthread_mutexattr_setrobust>(3)."

#. type: Plain text
#: man-pages/man3/pthread_mutex_consistent.3:106
msgid ""
"B<pthread_mutexattr_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutexattr_setrobust>(3), B<pthread_mutexattr_getrobust>(3), "
"B<pthreads>(7)"
msgstr ""
"B<pthread_mutexattr_init>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutexattr_setrobust>(3), B<pthread_mutexattr_getrobust>(3), "
"B<pthreads>(7)"

#. type: TH
#: man-pages/man3/pthread_setschedparam.3:26
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr "PTHREAD_SETSCHEDPARAM"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:30
msgid ""
"pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and "
"parameters of a thread"
msgstr ""
"pthread_setschedparam, pthread_getschedparam - изменяет/возвращает параметры "
"и алгоритм планирования нити"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:38
#, no-wrap
msgid ""
"B<int pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                          const struct sched_param *>I<param>B<);>\n"
"B<int pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                          struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<int pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                          const struct sched_param *>I<param>B<);>\n"
"B<int pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                          struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:46
msgid ""
"The B<pthread_setschedparam>()  function sets the scheduling policy and "
"parameters of the thread I<thread>."
msgstr ""
"Функция B<pthread_setschedparam>() назначает параметры и алгоритм "
"планирования нити I<thread>."

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:57
msgid ""
"I<policy> specifies the new scheduling policy for I<thread>.  The supported "
"values for I<policy>, and their semantics, are described in B<sched>(7)."
msgstr ""
"В I<policy> указывается новый алгоритм планирования I<thread>. "
"Поддерживаемые значения I<policy> и их семантика описана в B<sched>(7)."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:63
msgid ""
"The structure pointed to by I<param> specifies the new scheduling parameters "
"for I<thread>.  Scheduling parameters are maintained in the following "
"structure:"
msgstr ""
"Структура, на которую указывает I<param> определяет новые параметры "
"планирования I<thread>. Параметры планирования хранятся в структуре "
"следующего вида:"

#.  FIXME . nptl/pthread_setschedparam.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:104
msgid ""
"The B<pthread_getschedparam>()  function returns the scheduling policy and "
"parameters of the thread I<thread>, in the buffers pointed to by I<policy> "
"and I<param>, respectively.  The returned priority value is that set by the "
"most recent B<pthread_setschedparam>(), B<pthread_setschedprio>(3), or "
"B<pthread_create>(3)  call that affected I<thread>.  The returned priority "
"does not reflect any temporary priority adjustments as a result of calls to "
"any priority inheritance or priority ceiling functions (see, for example, "
"B<pthread_mutexattr_setprioceiling>(3)  and "
"B<pthread_mutexattr_setprotocol>(3))."
msgstr ""
"Функция B<pthread_getschedparam>() возвращает параметры и алгоритм "
"планирования нити I<thread> в буфер, указанный I<policy> и I<param>, "
"соответственно. Возвращаемое значение приоритета совпадает с заданным с "
"помощью последнего вызова B<pthread_setschedparam>(), "
"B<pthread_setschedprio>(3) или B<pthread_create>(3), относящегося к "
"I<thread>. Возвращаемые приоритет не отражает каких-либо временных подстроек "
"приоритета в результате вызовов функций наследования приоритета или потолка "
"(например, смотрите B<pthread_mutexattr_setprioceiling>(3) и "
"B<pthread_mutexattr_setprotocol>(3))."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:112
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number.  If B<pthread_setschedparam>()  fails, the scheduling policy and "
"parameters of I<thread> are not changed."
msgstr ""
"При успешном выполнении эти функции возвращают 0; при ошибке возвращается "
"ненулевой номер ошибки. Если B<pthread_setschedparam>() завершается ошибкой, "
"то параметры и алгоритм планирования I<thread> не изменяется."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:114
msgid "Both of these functions can fail with the following error:"
msgstr "Это функции могут завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:122
msgid ""
"B<pthread_setschedparam>()  may additionally fail with the following errors:"
msgstr ""
"Функция B<pthread_setschedparam>() может также завершиться со следующими "
"ошибками:"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:129
msgid ""
"I<policy> is not a recognized policy, or I<param> does not make sense for "
"the I<policy>."
msgstr ""
"Неизвестное значение I<policy> или значение I<param> не имеет смысла для "
"I<policy>."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:133
msgid ""
"The caller does not have appropriate privileges to set the specified "
"scheduling policy and parameters."
msgstr ""
"Вызывающий не имеет соответствующих прав для установки указанного алгоритма "
"планирования и параметров."

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:141
msgid ""
"POSIX.1 also documents an B<ENOTSUP> (\"attempt was made to set the policy "
"or scheduling parameters to an unsupported value\") error for "
"B<pthread_setschedparam>()."
msgstr ""
"Для B<pthread_setschedparam>() в POSIX.1 также описана необязательная ошибка "
"B<ENOTSUP> («попытка изменить параметры и алгоритм планирования на не "
"поддерживаемое значение»)."

#. type: tbl table
#: man-pages/man3/pthread_setschedparam.3:152
#, no-wrap
msgid ""
"B<pthread_setschedparam>(),\n"
"B<pthread_getschedparam>()"
msgstr ""
"B<pthread_setschedparam>(),\n"
"B<pthread_getschedparam>()"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:162
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling policy and priority, and details of the "
"permitted ranges for priorities in each scheduling policy, see B<sched>(7)."
msgstr ""
"Список требуемых прав, результат, изменение алгоритма и приоритета "
"планирования нити и подробности разрешённых диапазонов приоритетов для "
"каждого алгоритма планирования смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:169
msgid ""
"The program below demonstrates the use of B<pthread_setschedparam>()  and "
"B<pthread_getschedparam>(), as well as the use of a number of other "
"scheduling-related pthreads functions."
msgstr ""
"Представленная ниже программа показывает использование "
"B<pthread_setschedparam>() и B<pthread_getschedparam>(), а также других "
"относящихся к планированию функций программного интерфейса pthreads."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:185
msgid ""
"In the following run, the main thread sets its scheduling policy to "
"B<SCHED_FIFO> with a priority of 10, and initializes a thread attributes "
"object with a scheduling policy attribute of B<SCHED_RR> and a scheduling "
"priority attribute of 20.  The program then sets (using "
"B<pthread_attr_setinheritsched>(3))  the inherit scheduler attribute of the "
"thread attributes object to B<PTHREAD_EXPLICIT_SCHED>, meaning that threads "
"created using this attributes object should take their scheduling attributes "
"from the thread attributes object.  The program then creates a thread using "
"the thread attributes object, and that thread displays its scheduling policy "
"and priority."
msgstr ""
"В этом сеансе, главная нить изменяет свой алгоритм планирования на "
"B<SCHED_FIFO> с приоритетом 10, и инициализирует объект атрибутов нити с "
"атрибутом алгоритма планирования B<SCHED_RR> и атрибутом приоритета "
"планирования 20. Затем программа изменяет (с помощью "
"B<pthread_attr_setinheritsched>(3)) атрибут наследования планировщика в "
"объекте атрибутов нити на B<PTHREAD_EXPLICIT_SCHED>, из-за чего создаваемые "
"с использованием данного объекта атрибутов нити получат значения атрибуты "
"планирования из объекта атрибутов нити. Затем программа создаёт нить с "
"учётом объекта атрибутов нити, после чего эта нить выводит значения своего "
"алгоритма и приоритета планирования."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:193
#, no-wrap
msgid ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"$ B<su>      # требуются права для назначения алгоритмов\n"
"            планирования реального времени\n"
"Пароль:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Настройки планировщика главной нити\n"
"    алгоритм=SCHED_FIFO, приоритет=10\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:197
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"
msgstr ""
"Настройки планировщика в \\(aqattr\\(aq\n"
"    алгоритм=SCHED_RR, приоритет=20\n"
"    наследование планировщика ЯВНОЕ\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:200
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"
msgstr ""
"Атрибуты планировщика в новой нити\n"
"    алгоритм=SCHED_RR, приоритет=20\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:205
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the values specified in the thread attributes object."
msgstr ""
"В показанном выше выводе можно видеть приоритет и алгоритм планирования, "
"которые были взяты из объекта атрибутов нити."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:212
msgid ""
"The next run is the same as the previous, except that the inherit scheduler "
"attribute is set to B<PTHREAD_INHERIT_SCHED>, meaning that threads created "
"using the thread attributes object should ignore the scheduling attributes "
"specified in the attributes object and instead take their scheduling "
"attributes from the creating thread."
msgstr ""
"Следующий сеанс похож на предыдущий, то в нём атрибут наследования "
"планировщика равен B<PTHREAD_INHERIT_SCHED>, то есть создаваемые с "
"использованием объекта атрибутов нити игнорируют значения параметров и "
"алгоритм планирования, заданные в объекте атрибутов нити, и берут их от "
"создавшей нити."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:218
#, no-wrap
msgid ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Настройки планировщика главной нити\n"
"    алгоритм=SCHED_FIFO, приоритет=10\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:222
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"
msgstr ""
"Настройки планировщика в \\(aqattr\\(aq\n"
"    алгоритм=SCHED_RR, приоритет=20\n"
"    наследование планировщика ВКЛЮЧЕНО\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:225
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"Атрибуты планировщика в новой нити\n"
"    алгоритм=SCHED_FIFO, приоритет=10\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:231
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the creating thread, rather than the thread attributes "
"object."
msgstr ""
"В показанном выше выводе можно видеть приоритет и алгоритм планирования, "
"которые были взяты из создаваемой нити, а не из объекта атрибутов нити."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:237
msgid ""
"Note that if we had omitted the I<-i\\ i> option, the output would have been "
"the same, since B<PTHREAD_INHERIT_SCHED> is the default for the inherit "
"scheduler attribute."
msgstr ""
"Заметим, чти если не указать параметр I<-i\\ i>, то вывод будет тем же "
"самым, так как B<PTHREAD_INHERIT_SCHED> является значением по умолчанию для "
"атрибута наследования планировщика."

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:241
#, no-wrap
msgid "/* pthreads_sched_test.c */\n"
msgstr "/* pthreads_sched_test.c */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:247
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:256
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:273
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|i}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    fprintf(stderr, \"Использование: %s [параметры]\\en\", prog_name);\n"
"    fprintf(stderr, \"Параметры:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);       /* для краткости */\n"
"    fpe(\"-aE<lt>алгоритмE<gt>E<lt>приоритетE<gt> Алгоритм и приоритет планирования\\en\");\n"
"    fpe(\"                 объекте атрибутов нити\\en\");\n"
"    fpe(\"                 значения для E<lt>алгоритмE<gt>:\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Исп. объект атрибутов нити по умолчанию\\en\");\n"
"    fpe(\"-i {e|i}         Атрибут наследования планировщика\\en\");\n"
"    fpe(\"                 \\(aqявный\\(aq or \\(aqунаследованный\\(aq\\en\");\n"
"    fpe(\"-mE<lt>алгоритмE<gt>E<lt>приоритетE<gt> Алгоритм и приоритет планирования\\en\");\n"
"    fpe(\"               главной нити перед вызовом pthread_create()\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:284
#, no-wrap
msgid ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"
msgstr ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:295
#, no-wrap
msgid ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"
msgstr ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    алгоритм=%s, приоритет=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:301
#, no-wrap
msgid ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"
msgstr ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:305
#, no-wrap
msgid ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"
msgstr ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:309
#, no-wrap
msgid ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"
msgstr ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:314
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Атрибуты планировщика в новой нити\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:317
#, no-wrap
msgid ""
"    return NULL;\n"
"}\n"
msgstr ""
"    return NULL;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:327
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:329
#, no-wrap
msgid "    /* Process command-line options */\n"
msgstr "    /* обработка параметров командной строки */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:334
#, no-wrap
msgid ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"
msgstr ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:344
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Неизвестный параметр\\en\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:348
#, no-wrap
msgid ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"
msgstr ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Нельзя указывать -A вместе с -i или -a\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:351
#, no-wrap
msgid ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"
msgstr ""
"    /* необязательная установка атрибутов планирования главной нити\n"
"       вывод этих атрибутов */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:356
#, no-wrap
msgid ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-m)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"
msgstr ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Некоррект. алгоритм для главной нити (-m)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:361
#, no-wrap
msgid ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"
msgstr ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:364
#, no-wrap
msgid ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"
msgstr ""
"    display_thread_sched_attr(\"Настройки планировщика главной нити\");\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:366
#, no-wrap
msgid "    /* Initialize thread attributes object according to options */\n"
msgstr "    /* инициализация объекта атрибутов нити согласно параметрам */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:375
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"
msgstr ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:383
#, no-wrap
msgid ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or \\(aqi\\(aq\\en\");\n"
msgstr ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Значение -i должно быть \\(aqe\\(aq или \\(aqi\\(aq\\en\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:388
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:394
#, no-wrap
msgid ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"
msgstr ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Некорректный алгоритм для \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:402
#, no-wrap
msgid ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:405
#, no-wrap
msgid ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"
msgstr ""
"    /* если мы инициализируем объект атрибутов нити, то покажем\n"
"       атрибуты планирования, установленные в объекте */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:413
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:416
#, no-wrap
msgid ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"
msgstr ""
"        printf(\"Настройки планировщика в \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:424
#, no-wrap
msgid ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    наследование планировщика %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"ВКЛЮЧЕНО\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"ЯВНОЕ\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:426
#, no-wrap
msgid "    /* Create a thread that will display its scheduling attributes */\n"
msgstr "    /* создаём нить, которая покажет свои атрибуты планирования */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:430
#, no-wrap
msgid ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:432
#, no-wrap
msgid "    /* Destroy unneeded thread attributes object */\n"
msgstr "    /* уничтожаем ненужный объект атрибутов нити */\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:438
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"      s = pthread_attr_destroy(&attr);\n"
"      if (s != 0)\n"
"          handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""
"    if (!use_null_attrib) {\n"
"      s = pthread_attr_destroy(&attr);\n"
"      if (s != 0)\n"
"          handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:442
#, no-wrap
msgid ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: man-pages/man3/pthread_setschedparam.3:459
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
msgstr ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthread_self>(3), "
"B<pthread_setschedprio>(3), B<pthreads>(7), B<sched>(7)"
