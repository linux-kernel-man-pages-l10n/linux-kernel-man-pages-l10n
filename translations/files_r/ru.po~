# Copyright (C) 2014 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# aereiae <aereiae@gmail.com>, 2014.
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2013-2014.
# Dmitriy S. Seregin <dseregin@59.ru>, 2013.
# Lockal <lockalsash@gmail.com>, 2013.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2014.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2013-06-06 21:43+0400\n"
"PO-Revision-Date: 2014-08-17 08:50+0400\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<"
"=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#. type: TH
#: man-pages/man4/random.4:19
#, no-wrap
msgid "RANDOM"
msgstr "RANDOM"

#. type: TH
#: man-pages/man4/random.4:19
#, no-wrap
msgid "2013-03-15"
msgstr "2013-03-15"

#. type: TH
#: man-pages/man4/random.4:19
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/random.4:19
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/random.4:20
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/random.4:22
msgid "random, urandom - kernel random number source devices"
msgstr "random, urandom - ядерные устройства-источники случайных чисел"

#. type: SH
#: man-pages/man4/random.4:22
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man4/random.4:24
msgid "#include E<lt>linux/random.hE<gt>"
msgstr "#include E<lt>linux/random.hE<gt>"

#. type: Plain text
#: man-pages/man4/random.4:26
msgid "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"
msgstr "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"

#. type: SH
#: man-pages/man4/random.4:26
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/random.4:33
msgid ""
"The character special files I</dev/random> and I</dev/urandom> (present "
"since Linux 1.3.30)  provide an interface to the kernel's random number "
"generator.  File I</dev/random> has major device number 1 and minor device "
"number 8.  File I</dev/urandom> has major device number 1 and minor device "
"number 9."
msgstr ""
"Специальные символьные файлы I</dev/random> и I</dev/urandom> (появились в "
"Linux 1.3.30) предоставляют интерфейс к генератору случайных чисел, "
"встроенному в ядро. Файл I</dev/random> имеет старший номер устройства 1 и "
"младший номер устройства 8. Файл I</dev/urandom> имеет старший номер "
"устройства 1 и младший номер устройства 9."

#. type: Plain text
#: man-pages/man4/random.4:39
msgid ""
"The random number generator gathers environmental noise from device drivers "
"and other sources into an entropy pool.  The generator also keeps an "
"estimate of the number of bits of noise in the entropy pool.  From this "
"entropy pool random numbers are created."
msgstr ""
"Генератор случайных чисел собирает окружающий шум от работы драйверов "
"устройств и из других источников в пул энтропии. Генератор также постоянно "
"оценивает количество битов шума в пуле энтропии. Именно с помощью этого пула "
"создаются случайные числа."

#. type: Plain text
#: man-pages/man4/random.4:47
msgid ""
"When read, the I</dev/random> device will only return random bytes within "
"the estimated number of bits of noise in the entropy pool.  I</dev/random> "
"should be suitable for uses that need very high quality randomness such as "
"one-time pad or key generation.  When the entropy pool is empty, reads from "
"I</dev/random> will block until additional environmental noise is gathered."
msgstr ""
"При чтении из устройства I</dev/random> возвращаются произвольные байты, "
"количество битов шума в которых равно количеству битов шума в пуле энтропии. "
"I</dev/random> следует использовать, если требуется высокий коэффициент "
"случайности, например, в качестве данных однократного заполнения или при "
"генерации ключа. Если пул энтропии пуст, попытка чтения I</dev/random> "
"приведёт к задержке, пока не будет собран дополнительный окружающий шум."

#. type: Plain text
#: man-pages/man4/random.4:58
msgid ""
"A read from the I</dev/urandom> device will not block waiting for more "
"entropy.  As a result, if there is not sufficient entropy in the entropy "
"pool, the returned values are theoretically vulnerable to a cryptographic "
"attack on the algorithms used by the driver.  Knowledge of how to do this is"
" not available in the current unclassified literature, but it is "
"theoretically possible that such an attack may exist.  If this is a concern "
"in your application, use I</dev/random> instead."
msgstr ""
"При чтении из устройства I</dev/urandom> блокирования в ожидании данных не "
"происходит. Как результат, если в пуле недостаточная энтропия, то "
"возвращённые значения теоретически нестойки к криптографической атаке на "
"алгоритмы, используемые драйвером. О том, как это сделать, не сказано в "
"современной не секретной литературе, но теоретически возможно, что такая "
"атака может существовать. Если это важно для вашего приложения, используйте "
"лучше /dev/random."

#. type: Plain text
#: man-pages/man4/random.4:65
msgid ""
"Writing to I</dev/random> or I</dev/urandom> will update the entropy pool "
"with the data written, but this will not result in a higher entropy count.  "
"This means that it will impact the contents read from both files, but it "
"will not make reads from I</dev/random> faster."
msgstr ""
"При записи в I</dev/random> или I</dev/urandom> выполняется обновление пула "
"энтропии записываемыми данными, но при этом не увеличивается счётчик "
"энтропии. Это означает, что изменения отразятся в обоих файлах, но это не "
"ускорит процесс чтения из I</dev/random>."

#. type: SS
#: man-pages/man4/random.4:65
#, no-wrap
msgid "Usage"
msgstr "Использование"

#. type: Plain text
#: man-pages/man4/random.4:74
msgid ""
"If you are unsure about whether you should use I</dev/random> or "
"I</dev/urandom>, then probably you want to use the latter.  As a general "
"rule, I</dev/urandom> should be used for everything except long-lived "
"GPG/SSL/SSH keys."
msgstr ""
"Если вы не знаете, что выбрать \\(em I</dev/random> или I</dev/urandom>, то "
"лучше использовать последнее. Как правило, I</dev/urandom> нужно использовать "
"везде, за исключением создания долго существующих ключей GPG/SSL/SSH."

#. type: Plain text
#: man-pages/man4/random.4:86
msgid ""
"If a seed file is saved across reboots as recommended below (all major Linux"
" distributions have done this since 2000 at least), the output is "
"cryptographically secure against attackers without local root access as soon"
" as it is reloaded in the boot sequence, and perfectly adequate for network "
"encryption session keys.  Since reads from I</dev/random> may block, users "
"will usually want to open it in nonblocking mode (or perform a read with "
"timeout), and provide some sort of user notification if the desired entropy "
"is not immediately available."
msgstr ""
"Если файл начальных чисел (seed file) сохраняется между перезагрузками как "
"рекомендуется далее (во всех основных дистрибутивах Linux это делается "
"начиная с 2000 года), то результат шифрования стоек от атакующего, не "
"имеющего локально привилегированного доступа, до перезагрузки машины, и "
"вполне подходит для ключей шифрования сетевых сеансов. Так как чтение из I<"
"/dev/random> может привести к блокировке, пользователи хотели бы открывать "
"его в неблокирующем режиме (или выполнять чтение с задержкой), и иметь "
"механизм оповещения, если желаемый уровень энтропии в данный момент "
"недоступен."

#. type: Plain text
#: man-pages/man4/random.4:99
msgid ""
"The kernel random-number generator is designed to produce a small amount of "
"high-quality seed material to seed a cryptographic pseudo-random number "
"generator (CPRNG).  It is designed for security, not speed, and is poorly "
"suited to generating large amounts of random data.  Users should be very "
"economical in the amount of seed material that they read from "
"I</dev/urandom> (and I</dev/random>); unnecessarily reading large quantities"
" of data from this device will have a negative impact on other users of the "
"device."
msgstr ""
"Генератор случайных чисел ядра проектировался для создания небольших объёмов "
"высококачественного начального материала для генератора псевдослучайных чисел "
"(CPRNG). Целью ставилась безопасность, а не скорость, и поэтому он плохо "
"подходит для генерации большого количества произвольных данных. Пользователи "
"должны быть очень экономны при чтении начального материала из I</dev/urandom> "
"(и I</dev/random>); ненужное чтение большого количества данных из этого "
"устройства негативно отразится на других пользователях устройства."

#. type: Plain text
#: man-pages/man4/random.4:107
msgid ""
"The amount of seed material required to generate a cryptographic key equals "
"the effective key size of the key.  For example, a 3072-bit RSA or Diffie-"
"Hellman private key has an effective key size of 128 bits (it requires about"
" 2^128 operations to break) so a key generator only needs 128 bits (16 "
"bytes) of seed material from I</dev/random>."
msgstr ""
"Количество начального материала, требуемое для генерации ключей шифрования, "
"равно эффективному размеру ключа. Например, 3072-битный закрытый ключ RSA или "
"Diffie-Hellman имеет эффективный размер ключа 128 бит (для его подбора "
"требуется просмотреть 2^128 значений), поэтому генератору ключа нужно только "
"128 бит (16 байт) начального материала из I</dev/random>."

#. type: Plain text
#: man-pages/man4/random.4:116
msgid ""
"While some safety margin above that minimum is reasonable, as a guard "
"against flaws in the CPRNG algorithm, no cryptographic primitive available "
"today can hope to promise more than 256 bits of security, so if any program "
"reads more than 256 bits (32 bytes) from the kernel random pool per "
"invocation, or per reasonable reseed interval (not less than one minute), "
"that should be taken as a sign that its cryptography is I<not> skillfully "
"implemented."
msgstr ""
"Так как разумно добавить некоторый запас прочности к выше указанному минимуму "
"как защиту против недостатков в алгоритме CPRNG, никакой доступный "
"криптографический примитив сегодня не может обещать больше чем 256 бит "
"безопасности, поэтому если какая-то программа читает больше чем 256 бит (32 "
"байта) из пула случайных чисел ядра за вызов, или за разумный интервал "
"повторного посева (не менее одной минуты), то это нужно считать признаком "
"того, что шифрование в ней реализовано I<НЕДОСТАТОЧНО> продуманно."

#. type: SS
#: man-pages/man4/random.4:116
#, no-wrap
msgid "Configuration"
msgstr "Настройка"

#. type: Plain text
#: man-pages/man4/random.4:120
msgid ""
"If your system does not have I</dev/random> and I</dev/urandom> created "
"already, they can be created with the following commands:"
msgstr ""
"Если в системе нет I</dev/random> и I</dev/urandom>, то их можно создать "
"следующими командами:"

#. type: Plain text
#: man-pages/man4/random.4:125
#, no-wrap
msgid ""
"    mknod -m 644 /dev/random c 1 8\n"
"    mknod -m 644 /dev/urandom c 1 9\n"
"    chown root:root /dev/random /dev/urandom\n"
msgstr ""
"    mknod -m 644 /dev/random c 1 8\n    mknod -m 644 /dev/urandom c 1 9\n    "
"chown root:root /dev/random /dev/urandom\n"

#. type: Plain text
#: man-pages/man4/random.4:135
msgid ""
"When a Linux system starts up without much operator interaction, the entropy"
" pool may be in a fairly predictable state.  This reduces the actual amount "
"of noise in the entropy pool below the estimate.  In order to counteract "
"this effect, it helps to carry entropy pool information across shut-downs "
"and start-ups.  To do this, add the following lines to an appropriate script"
" which is run during the Linux system start-up sequence:"
msgstr ""
"Когда Linux-система запускается без участия человека, пул энтропии может "
"оказаться в довольно предсказуемом состоянии. Это снижает значимый объём шума "
"в пуле энтропии ниже оцениваемого. Для преодоления этого эффекта можно "
"сохранять информацию пула энтропии во время выключения и восстанавливать во "
"время запуска системы. Для этого добавьте следующие строки в сценарий, "
"который выполняется при запуске Linux-системы:"

#. type: Plain text
#: man-pages/man4/random.4:150
#, no-wrap
msgid ""
"    echo \"Initializing random number generator...\"\n"
"    random_seed=/var/run/random-seed\n"
"    # Carry a random seed from start-up to start-up\n"
"    # Load and then save the whole entropy pool\n"
"    if [ -f $random_seed ]; then\n"
"        cat $random_seed E<gt>/dev/urandom\n"
"    else\n"
"        touch $random_seed\n"
"    fi\n"
"    chmod 600 $random_seed\n"
"    poolfile=/proc/sys/kernel/random/poolsize\n"
"    [ -r $poolfile ] && bytes=\\`cat $poolfile\\` || bytes=512\n"
"    dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""
"    echo \"Initializing random number generator...\"\n    "
"random_seed=/var/run/random-seed\n    # Carry a random seed from start-up to "
"start-up\n    # Load and then save the whole entropy pool\n    if [ -f "
"$random_seed ]; then\n        cat $random_seed E<gt>/dev/urandom\n    else\n  "
"      touch $random_seed\n    fi\n    chmod 600 $random_seed\n    "
"poolfile=/proc/sys/kernel/random/poolsize\n    [ -r $poolfile ] && "
"bytes=\\`cat $poolfile\\` || bytes=512\n    dd if=/dev/urandom "
"of=$random_seed count=1 bs=$bytes\n"

#. type: Plain text
#: man-pages/man4/random.4:154
msgid ""
"Also, add the following lines in an appropriate script which is run during "
"the Linux system shutdown:"
msgstr ""
"Также добавьте следующие строки в сценарий, который выполняется при "
"завершении работы Linux-системы:"

#. type: Plain text
#: man-pages/man4/random.4:165
#, no-wrap
msgid ""
"    # Carry a random seed from shut-down to start-up\n"
"    # Save the whole entropy pool\n"
"    echo \"Saving random seed...\"\n"
"    random_seed=/var/run/random-seed\n"
"    touch $random_seed\n"
"    chmod 600 $random_seed\n"
"    poolfile=/proc/sys/kernel/random/poolsize\n"
"    [ -r $poolfile ] && bytes=\\`cat $poolfile\\` || bytes=512\n"
"    dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""
"    # Carry a random seed from shut-down to start-up\n    # Save the whole "
"entropy pool\n    echo \"Saving random seed...\"\n    "
"random_seed=/var/run/random-seed\n    touch $random_seed\n    chmod 600 "
"$random_seed\n    poolfile=/proc/sys/kernel/random/poolsize\n    [ -r "
"$poolfile ] && bytes=\\`cat $poolfile\\` || bytes=512\n    dd if=/dev/urandom "
"of=$random_seed count=1 bs=$bytes\n"

#. type: SS
#: man-pages/man4/random.4:166
#, no-wrap
msgid "/proc Interface"
msgstr "Интерфейс в /proc"

#. type: Plain text
#: man-pages/man4/random.4:172
msgid ""
"The files in the directory I</proc/sys/kernel/random> (present since 2.3.16)"
" provide an additional interface to the I</dev/random> device."
msgstr ""
"Файлы в каталоге I</proc/sys/kernel/random> (начиная с 2.3.16) предоставляют "
"дополнительный интерфейс к устройству I</dev/random>."

#. type: Plain text
#: man-pages/man4/random.4:178
msgid ""
"The read-only file I<entropy_avail> gives the available entropy.  Normally, "
"this will be 4096 (bits), a full entropy pool."
msgstr ""
"Файл I<entropy_avail>, доступный только для чтения, показывает количество "
"доступной энтропии. Обычно для заполненного пула энтропии значение равно 4096 "
"(бит)."

#. type: Plain text
#: man-pages/man4/random.4:183
msgid ""
"The file I<poolsize> gives the size of the entropy pool.  The semantics of "
"this file vary across kernel versions:"
msgstr ""
"Файл I<poolsize> содержит размер пула энтропии. Формат файла зависит от "
"версии ядра:"

#. type: TP
#: man-pages/man4/random.4:184
#, no-wrap
msgid "Linux 2.4:"
msgstr "Linux 2.4:"

#. type: Plain text
#: man-pages/man4/random.4:191
msgid ""
"This file gives the size of the entropy pool in I<bytes>.  Normally, this "
"file will have the value 512, but it is writable, and can be changed to any "
"value for which an algorithm is available.  The choices are 32, 64, 128, "
"256, 512, 1024, or 2048."
msgstr ""
"В файле содержится размер пула энтропии в I<байтах>. Обычно это число 512, но "
"так как файл доступен на запись, значение можно изменить, подстроив его под "
"доступный алгоритм. Возможные значения \\(em 32, 64, 128, 256, 512, 1024 или "
"2048."

#. type: TP
#: man-pages/man4/random.4:191
#, no-wrap
msgid "Linux 2.6:"
msgstr "Linux 2.6:"

#. type: Plain text
#: man-pages/man4/random.4:196
msgid ""
"This file is read-only, and gives the size of the entropy pool in I<bits>.  "
"It contains the value 4096."
msgstr ""
"Файл доступен только на чтение и содержит размер пула энтропии в I<битах>. "
"Значение равно 4096."

#. type: Plain text
#: man-pages/man4/random.4:214
msgid ""
"The file I<read_wakeup_threshold> contains the number of bits of entropy "
"required for waking up processes that sleep waiting for entropy from "
"I</dev/random>.  The default is 64.  The file I<write_wakeup_threshold> "
"contains the number of bits of entropy below which we wake up processes that"
" do a B<select>(2)  or B<poll>(2)  for write access to I</dev/random>.  "
"These values can be changed by writing to the files."
msgstr ""
"В файле I<read_wakeup_threshold> содержится количество бит энтропии, "
"требуемое для пробуждения процессов, которые спят в ожидании энтропии из I<"
"/dev/random>. Значение по умолчанию равно 64. В файле I<"
"write_wakeup_threshold> содержится количество бит энтропии, менее которого мы "
"пробуждаем процессы, которые выполнили вызовы B<select>(2) или B<poll>(2) для "
"ожидания записи в I</dev/random>. Эти значения можно изменить, записав новые "
"числа в эти файлы."

#. type: Plain text
#: man-pages/man4/random.4:222
msgid ""
"The read-only files I<uuid> and I<boot_id> contain random strings like "
"6fd5a44b-35f4-4ad4-a9b9-6b9be13e1fe9.  The former is generated afresh for "
"each read, the latter was generated once."
msgstr ""
"Файлы I<uuid> и I<boot_id>, доступные только для чтения, содержат "
"произвольные строки вида 6fd5a44b-35f4-4ad4-a9b9-6b9be13e1fe9. Значение "
"первого генерируется заново при каждом чтении, а значение второго "
"генерируется только один раз."

#. type: SS
#: man-pages/man4/random.4:222
#, no-wrap
msgid "ioctl(2) interface"
msgstr "Интерфейс ioctl(2)"

#. type: Plain text
#: man-pages/man4/random.4:233
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to either I</dev/random> or I</dev/urandom>.  All requests "
"performed will interact with the input entropy pool impacting both "
"I</dev/random> and I</dev/urandom>.  The B<CAP_SYS_ADMIN> capability is "
"required for all requests except B<RNDGETENTCNT>."
msgstr ""
"Для файловых дескрипторов, соединённых с файлами I</dev/random> и I<"
"/dev/urandom>, определены запросы B<ioctl>(2), перечисленные ниже. Все "
"выполняемые запросы обращаются к входному пулу энтропии, который относится к "
"и к I</dev/random>, и к I</dev/urandom>. Для выполнения всех запросов (кроме "
"B<RNDGETENTCNT>) требуется мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man4/random.4:233
#, no-wrap
msgid "B<RNDGETENTCNT>"
msgstr "B<RNDGETENTCNT>"

#. type: Plain text
#: man-pages/man4/random.4:240
msgid ""
"Retrieve the entropy count of the input pool, the contents will be the same "
"as the I<entropy_avail> file under proc.  The result will be stored in the "
"int pointed to by the argument."
msgstr ""
"Возвращает счётчик энтропии входного пула, возвращается содержимое из файла "
"I<entropy_avail> в proc. Результат сохраняется в int, указанный в параметре."

#. type: TP
#: man-pages/man4/random.4:240
#, no-wrap
msgid "B<RNDADDTOENTCNT>"
msgstr "B<RNDADDTOENTCNT>"

#. type: Plain text
#: man-pages/man4/random.4:244
msgid ""
"Increment or decrement the entropy count of the input pool by the value "
"pointed to by the argument."
msgstr ""
"Увеличивает или уменьшает счётчик энтропии входного пула на значение "
"аргумента."

#. type: TP
#: man-pages/man4/random.4:244
#, no-wrap
msgid "B<RNDGETPOOL>"
msgstr "B<RNDGETPOOL>"

#. type: Plain text
#: man-pages/man4/random.4:247
msgid "Removed in Linux 2.6.9."
msgstr "Удалён из Linux 2.6.9."

#. type: TP
#: man-pages/man4/random.4:247
#, no-wrap
msgid "B<RNDADDENTROPY>"
msgstr "B<RNDADDENTROPY>"

#. type: Plain text
#: man-pages/man4/random.4:255
msgid ""
"Add some additional entropy to the input pool, incrementing the entropy "
"count.  This differs from writing to I</dev/random> or I</dev/urandom>, "
"which only adds some data but does not increment the entropy count.  The "
"following structure is used:"
msgstr ""
"Вносит дополнительную энтропию во входной пул, увеличивая счётчик энтропии. "
"Запись в I</dev/random> или I</dev/urandom> добавляет только данные, но не "
"увеличивает счётчик энтропии (в этом отличие). Используется следующая "
"структура:"

#. type: Plain text
#: man-pages/man4/random.4:262
#, no-wrap
msgid ""
"    struct rand_pool_info {\n"
"        int    entropy_count;\n"
"        int    buf_size;\n"
"        __u32  buf[0];\n"
"    };\n"
msgstr ""
"    struct rand_pool_info {\n        int    entropy_count;\n        int    "
"buf_size;\n        __u32  buf[0];\n    };\n"

#. type: Plain text
#: man-pages/man4/random.4:271
msgid ""
"Here I<entropy_count> is the value added to (or subtracted from) the entropy"
" count, and I<buf> is the buffer of size I<buf_size> which gets added to the"
" entropy pool."
msgstr ""
"Здесь I<entropy_count> — добавляемое (или вычитаемое) значение к счётчику "
"энтропии, а I<buf> — буфер с размером I<buf_size>, из которого в пул энтропии "
"добавляются данные."

#. type: TP
#: man-pages/man4/random.4:271
#, no-wrap
msgid "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"
msgstr "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"

#. type: Plain text
#: man-pages/man4/random.4:275
msgid ""
"Zero the entropy count of all pools and add some system data (such as wall "
"clock) to the pools."
msgstr ""
"Обнуляет счётчики всех пулов и добавляет в них некоторые системные данные "
"(такие как время)."

#. type: SH
#: man-pages/man4/random.4:275
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/random.4:277
msgid "/dev/random"
msgstr "/dev/random"

#.  .SH AUTHOR
#.  The kernel's random number generator was written by
#.  Theodore Ts'o (tytso@athena.mit.edu).
#. type: Plain text
#: man-pages/man4/random.4:282
msgid "/dev/urandom"
msgstr "/dev/urandom"

#. type: SH
#: man-pages/man4/random.4:282
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/random.4:284
msgid "B<mknod>(1)"
msgstr "B<mknod>(1)"

#. type: Plain text
#: man-pages/man4/random.4:285
msgid "RFC\\ 1750, \"Randomness Recommendations for Security\""
msgstr "RFC\\ 1750, \"Randomness Recommendations for Security\""

#. type: TH
#: man-pages/man4/rtc.4:30
#, no-wrap
msgid "RTC"
msgstr "RTC"

#. type: TH
#: man-pages/man4/rtc.4:30
#, no-wrap
msgid "2010-02-25"
msgstr "2010-02-25"

#. type: Plain text
#: man-pages/man4/rtc.4:33
msgid "rtc - real-time clock"
msgstr "rtc - часы реального времени"

#. type: Plain text
#: man-pages/man4/rtc.4:35
msgid "#include E<lt>linux/rtc.hE<gt>"
msgstr "#include E<lt>linux/rtc.hE<gt>"

#. type: Plain text
#: man-pages/man4/rtc.4:37
msgid "B<int ioctl(>I<fd>B<, RTC_>I<request>B<, >I<param>B<);>"
msgstr "B<int ioctl(>I<fd>B<, RTC_>I<request>B<, >I<param>B<);>"

#. type: Plain text
#: man-pages/man4/rtc.4:39
msgid "This is the interface to drivers for real-time clocks (RTCs)."
msgstr ""
"Данное устройство представляет собой интерфейс к драйверам часов реального "
"времени (RTC)."

#. type: Plain text
#: man-pages/man4/rtc.4:46
msgid ""
"Most computers have one or more hardware clocks which record the current "
"\"wall clock\" time.  These are called \"Real Time Clocks\" (RTCs).  One of "
"these usually has battery backup power so that it tracks the time even while"
" the computer is turned off.  RTCs often provide alarms and other "
"interrupts."
msgstr ""
"В большинстве компьютеров есть одни и более аппаратных часов,  ведущих отчёт "
"\"обычного\" времени. Они называются \"часами реального времени\" (Real Time "
"Clock, RTC). Некоторые из них имеют батарею резервного питания для "
"продолжения работы в периоды, когда компьютер выключен. В RTC часто встроены "
"будильники и другие прерывания."

#. type: Plain text
#: man-pages/man4/rtc.4:51
msgid ""
"All i386 PCs, and ACPI-based systems, have an RTC that is compatible with "
"the Motorola MC146818 chip on the original PC/AT.  Today such an RTC is "
"usually integrated into the mainboard's chipset (south bridge), and uses a "
"replaceable coin-sized backup battery."
msgstr ""
"Все ПК i386 и системы с ACPI содержат RTC, которые совместимы с микросхемой "
"Motorola MC146818 из первоначальной модели PC/AT. Сегодня такие RTC обычно "
"встраивают в чипсет материнской платы (в южный мост), и они используют "
"заменяемую резервную батарею (типа «таблетки»)."

#. type: Plain text
#: man-pages/man4/rtc.4:55
msgid ""
"Non-PC systems, such as embedded systems built around system-on-chip "
"processors, use other implementations.  They usually won't offer the same "
"functionality as the RTC from a PC/AT."
msgstr ""
"В системах, несовместимых с PC (например, встраиваемые системы, собираемые на "
"процессоре \"всё в одном\"), используются другие варианты. Обычно, они не "
"предоставляют таких возможностей, как RTC в PC/AT."

#. type: SS
#: man-pages/man4/rtc.4:55
#, no-wrap
msgid "RTC vs system clock"
msgstr "RTC и системные часы"

#. type: Plain text
#: man-pages/man4/rtc.4:67
msgid ""
"RTCs should not be confused with the system clock, which is a software clock"
" maintained by the kernel and used to implement B<gettimeofday>(2)  and "
"B<time>(2), as well as setting timestamps on files, and so on.  The system "
"clock reports seconds and microseconds since a start point, defined to be "
"the POSIX Epoch: 1970-01-01 00:00:00 +0000 (UTC).  (One common "
"implementation counts timer interrupts, once per \"jiffy\", at a frequency "
"of 100, 250, or 1000 Hz.)  That is, it is supposed to report wall clock "
"time, which RTCs also do."
msgstr ""
"Не нужно путать RTC с системными часами, которые представляют собой часы, "
"реализованные в ядре программно и используемые для работы B<gettimeofday>(2) "
"и B<time>(2), а также при указании временных меток файлов и т. п. Системные "
"часы выдают секунды и микросекунды, начиная отсчёт от эпохи POSIX: 1970-01-01 "
"00:00:00 +0000 (UTC) (в основном, реализуется на основе таймера прерываний "
"ведя подсчёт «мигов» (jiffy) c частотой 100, 250 или 1000 Гц). То есть, "
"предполагается, что они показывают обычное время как и RTC."

#. type: Plain text
#: man-pages/man4/rtc.4:77
msgid ""
"A key difference between an RTC and the system clock is that RTCs run even "
"when the system is in a low power state (including \"off\"), and the system "
"clock can't.  Until it is initialized, the system clock can only report time"
" since system boot ... not since the POSIX Epoch.  So at boot time, and "
"after resuming from a system low power state, the system clock will often be"
" set to the current wall clock time using an RTC.  Systems without an RTC "
"need to set the system clock using another clock, maybe across the network "
"or by entering that data manually."
msgstr ""
"Ключевым отличием RTC от системных часов, является то, что RTC работают даже "
"когда система находится в состоянии пониженного энергопотребления (даже в "
"выключенном), а для системных часов такое недоступно. До своей инициализации "
"системные часы показывают время, прошедшее с момента запуска системы, а не с "
"начала эпохи POSIX. Поэтому при загрузке и после восстановления из состояния "
"пониженного энергопотребления в системных часах часто подстраивают текущее "
"время с помощью RTC. Системам без RTC требуется установить свои системные "
"часы с помощью других часов, возможно через сеть или ручного ввода данных."

#. type: SS
#: man-pages/man4/rtc.4:77
#, no-wrap
msgid "RTC functionality"
msgstr "Назначение RTC"

#. type: Plain text
#: man-pages/man4/rtc.4:81
msgid ""
"RTCs can be read and written with B<hwclock>(8), or directly with the ioctl "
"requests listed below."
msgstr ""
"Из RTC можно читать или писать с помощью B<hwclock>(8) или через вызовы "
"ioctl, перечисленные ниже."

#. type: Plain text
#: man-pages/man4/rtc.4:84
msgid ""
"Besides tracking the date and time, many RTCs can also generate interrupts"
msgstr ""
"Помимо контроля даты и времени многие RTC также позволяют генерировать "
"прерывания"

#. type: IP
#: man-pages/man4/rtc.4:84 man-pages/man4/rtc.4:86 man-pages/man4/rtc.4:89
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man4/rtc.4:86
msgid "on every clock update (i.e., once per second);"
msgstr "при каждом обновлении часов (т.е. раз в секунду);"

#. type: Plain text
#: man-pages/man4/rtc.4:89
msgid ""
"at periodic intervals with a frequency that can be set to any power-of-2 "
"multiple in the range 2 Hz to 8192 Hz;"
msgstr ""
"через периодические интервалы с частотой, значение которой может быть любой "
"степенью 2 в диапазоне от 2 Гц до 8192 Гц;"

#. type: Plain text
#: man-pages/man4/rtc.4:91
msgid "on reaching a previously specified alarm time."
msgstr "по достижению указанного времени будильника."

#. type: Plain text
#: man-pages/man4/rtc.4:100
msgid ""
"Each of those interrupt sources can be enabled or disabled separately.  On "
"many systems, the alarm interrupt can be configured as a system wakeup "
"event, which can resume the system from a low power state such as Suspend-"
"to-RAM (STR, called S3 in ACPI systems), Hibernation (called S4 in ACPI "
"systems), or even \"off\" (called S5 in ACPI systems).  On some systems, the"
" battery backed RTC can't issue interrupts, but another one can."
msgstr ""
"Каждый из этих источников прерываний можно включать или выключать независимо "
"друг от друга. Во многих системах прерывание будильника можно настроить как "
"событие пробуждения системы, для вывода системы из состояний пониженного "
"энергопотребления таких как: ждущего режима (Suspend-to-RAM (STR), S3 в "
"терминологии ACPI), спящего режима (hibernation, S4 в терминологии ACPI) или "
"даже из \"выключенного\" состояния (S5 в терминологии ACPI). Но в некоторых "
"системах RTC с резервной батареей не могут генерировать прерывания."

#. type: Plain text
#: man-pages/man4/rtc.4:120
msgid ""
"The I</dev/rtc> (or I</dev/rtc0>, I</dev/rtc1>, etc.)  device can be opened "
"only once (until it is closed) and it is read-only.  On B<read>(2)  and "
"B<select>(2)  the calling process is blocked until the next interrupt from "
"that RTC is received.  Following the interrupt, the process can read a long "
"integer, of which the least significant byte contains a bit mask encoding "
"the types of interrupt that occurred, while the remaining 3 bytes contain "
"the number of interrupts since the last B<read>(2)."
msgstr ""
"Устройство I</dev/rtc> (или I</dev/rtc0>, I</dev/rtc1> и т.д.) можно открыть "
"только один раз (до тех пор, пока не будет закрыто) и только для чтения. При "
"вызове B<read>(2) и B<select>(2) вызывающий процесс блокируется до следующего "
"приёма прерывания от RTC. После прерывания процесс может прочитать длинное "
"целое, в котором наименее значимый байт содержит битовую маску типа "
"произошедшего прерывания, а остальные 3 байта содержат количество прерываний, "
"произошедших с последнего вызова B<read>(2)."

#. type: Plain text
#: man-pages/man4/rtc.4:124
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to RTC devices:"
msgstr ""
"Для файловых дескрипторов, указывающих на открытые устройства RTC, доступны "
"следующие запросы B<ioctl>(2):"

#. type: TP
#: man-pages/man4/rtc.4:124
#, no-wrap
msgid "B<RTC_RD_TIME>"
msgstr "B<RTC_RD_TIME>"

#. type: Plain text
#: man-pages/man4/rtc.4:127
msgid "Returns this RTC's time in the following structure:"
msgstr "Получить время RTC в виде следующей структуры:"

#. type: Plain text
#: man-pages/man4/rtc.4:141
#, no-wrap
msgid ""
"struct rtc_time {\n"
"    int tm_sec;\n"
"    int tm_min;\n"
"    int tm_hour;\n"
"    int tm_mday;\n"
"    int tm_mon;\n"
"    int tm_year;\n"
"    int tm_wday;     /* unused */\n"
"    int tm_yday;     /* unused */\n"
"    int tm_isdst;    /* unused */\n"
"};\n"
msgstr ""
"struct rtc_time {\n    int tm_sec;\n    int tm_min;\n    int tm_hour;\n    "
"int tm_mday;\n    int tm_mon;\n    int tm_year;\n    int tm_wday;     /* не "
"используется */\n    int tm_yday;     /* не используется */\n    int "
"tm_isdst;    /* не используется */\n};\n"

#. type: Plain text
#: man-pages/man4/rtc.4:151
msgid ""
"The fields in this structure have the same meaning and ranges as for the "
"I<tm> structure described in B<gmtime>(3).  A pointer to this structure "
"should be passed as the third B<ioctl>(2)  argument."
msgstr ""
"Поля структуры имеют те же значения и диапазоны что и у структуры I<tm>, "
"описанной в B<gmtime>(3). Указатель на эту структуру должен передаваться в "
"третьем аргументе B<ioctl>(2)."

#. type: TP
#: man-pages/man4/rtc.4:151
#, no-wrap
msgid "B<RTC_SET_TIME>"
msgstr "B<RTC_SET_TIME>"

#. type: Plain text
#: man-pages/man4/rtc.4:162
msgid ""
"Sets this RTC's time to the time specified by the I<rtc_time> structure "
"pointed to by the third B<ioctl>(2)  argument.  To set the RTC's time the "
"process must be privileged (i.e., have the B<CAP_SYS_TIME> capability)."
msgstr ""
"Установить время RTC в значение, заданное в структуре I<rtc_time>, на которую "
"указывает третий аргумент B<ioctl>(2). Для установки времени RTC процесс "
"должен иметь права (т.е., мандат B<CAP_SYS_TIME>)."

#. type: TP
#: man-pages/man4/rtc.4:162
#, no-wrap
msgid "B<RTC_ALM_READ>, B<RTC_ALM_SET>"
msgstr "B<RTC_ALM_READ>, B<RTC_ALM_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:179
msgid ""
"Read and set the alarm time, for RTCs that support alarms.  The alarm "
"interrupt must be separately enabled or disabled using the B<RTC_AIE_ON>, "
"B<RTC_AIE_OFF> requests.  The third B<ioctl>(2)  argument is a pointer to an"
" I<rtc_time> structure.  Only the I<tm_sec>, I<tm_min>, and I<tm_hour> "
"fields of this structure are used."
msgstr ""
"Получить и установить время будильника, если он поддерживается RTC. "
"Прерывание будильника должно быть включено или выключено отдельно с помощью "
"запросов B<RTC_AIE_ON>, B<RTC_AIE_OFF>. Третий аргумент B<ioctl>(2) является "
"указателем на структуру I<rtc_time>. В структуре используются только поля I<"
"tm_sec>, I<tm_min> и I<tm_hour>."

#. type: TP
#: man-pages/man4/rtc.4:179
#, no-wrap
msgid "B<RTC_IRQP_READ>, B<RTC_IRQP_SET>"
msgstr "B<RTC_IRQP_READ>, B<RTC_IRQP_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:201
msgid ""
"Read and set the frequency for periodic interrupts, for RTCs that support "
"periodic interrupts.  The periodic interrupt must be separately enabled or "
"disabled using the B<RTC_PIE_ON>, B<RTC_PIE_OFF> requests.  The third "
"B<ioctl>(2)  argument is an I<unsigned long\\ *> or an I<unsigned long>, "
"respectively.  The value is the frequency in interrupts per second.  The set"
" of allowable frequencies is the multiples of two in the range 2 to 8192.  "
"Only a privileged process (i.e., one having the B<CAP_SYS_RESOURCE> "
"capability) can set frequencies above the value specified in "
"I</proc/sys/dev/rtc/max-user-freq>.  (This file contains the value 64 by "
"default.)"
msgstr ""
"Получить и установить частоту периодических прерываний, если они "
"поддерживаются RTC. Периодическое прерывание должно быть включено или "
"выключено отдельно с помощью запросов B<RTC_PIE_ON>, B<RTC_PIE_OFF>. Третий "
"аргумент B<ioctl>(2) имеет тип I<unsigned long\\ *> или I<unsigned long>, "
"соответственно. Значение задаёт частоту прерываний в секунду. Можно указывать "
"частоты кратны степени 2 в диапазоне от 2 до 8192. Только привилегированный "
"процесс (т.е., имеющий мандат B<CAP_SYS_RESOURCE>) может устанавливать "
"частоты выше значения, указанного в I</proc/sys/dev/rtc/max-user-freq>. (По "
"умолчанию в этом файле содержится значение 64.)"

#. type: TP
#: man-pages/man4/rtc.4:201
#, no-wrap
msgid "B<RTC_AIE_ON>, B<RTC_AIE_OFF>"
msgstr "B<RTC_AIE_ON>, B<RTC_AIE_OFF>"

#. type: Plain text
#: man-pages/man4/rtc.4:207
msgid ""
"Enable or disable the alarm interrupt, for RTCs that support alarms.  The "
"third B<ioctl>(2)  argument is ignored."
msgstr ""
"Включить или выключить прерывание от будильника, если RTC поддерживает "
"будильники. Третий аргумент B<ioctl>(2) игнорируется."

#. type: TP
#: man-pages/man4/rtc.4:207
#, no-wrap
msgid "B<RTC_UIE_ON>, B<RTC_UIE_OFF>"
msgstr "B<RTC_UIE_ON>, B<RTC_UIE_OFF>"

#. type: Plain text
#: man-pages/man4/rtc.4:214
msgid ""
"Enable or disable the interrupt on every clock update, for RTCs that support"
" this once-per-second interrupt.  The third B<ioctl>(2)  argument is "
"ignored."
msgstr ""
"Включить или выключить прерывание при каждом обновлении часов, если RTC "
"поддерживает создание прерываний один раз в секунду. Третий аргумент B<ioctl>"
"(2) игнорируется."

#. type: TP
#: man-pages/man4/rtc.4:214
#, no-wrap
msgid "B<RTC_PIE_ON>, B<RTC_PIE_OFF>"
msgstr "B<RTC_PIE_ON>, B<RTC_PIE_OFF>"

#. type: Plain text
#: man-pages/man4/rtc.4:226
msgid ""
"Enable or disable the periodic interrupt, for RTCs that support these "
"periodic interrupts.  The third B<ioctl>(2)  argument is ignored.  Only a "
"privileged process (i.e., one having the B<CAP_SYS_RESOURCE> capability) can"
" enable the periodic interrupt if the frequency is currently set above the "
"value specified in I</proc/sys/dev/rtc/max-user-freq>."
msgstr ""
"Включить или выключить периодическое прерывание, если RTC поддерживает "
"периодические прерывания. Третий аргумент B<ioctl>(2) игнорируется. Только "
"привилегированный процесс (т.е., имеющий мандат B<CAP_SYS_RESOURCE>) может "
"устанавливать частоты выше значения, указанного в I<"
"/proc/sys/dev/rtc/max-user-freq>."

#. type: TP
#: man-pages/man4/rtc.4:226
#, no-wrap
msgid "B<RTC_EPOCH_READ>, B<RTC_EPOCH_SET>"
msgstr "B<RTC_EPOCH_READ>, B<RTC_EPOCH_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:249
msgid ""
"Many RTCs encode the year in an 8-bit register which is either interpreted "
"as an 8-bit binary number or as a BCD number.  In both cases, the number is "
"interpreted relative to this RTC's Epoch.  The RTC's Epoch is initialized to"
" 1900 on most systems but on Alpha and MIPS it might also be initialized to "
"1952, 1980, or 2000, depending on the value of an RTC register for the year."
"  With some RTCs, these operations can be used to read or to set the RTC's "
"Epoch, respectively.  The third B<ioctl>(2)  argument is a I<unsigned long\\"
" *> or a I<unsigned long>, respectively, and the value returned (or "
"assigned) is the Epoch.  To set the RTC's Epoch the process must be "
"privileged (i.e., have the B<CAP_SYS_TIME> capability)."
msgstr ""
"В многих RTC год кодируется в 8-битном регистре, значение которого может "
"учитываться как 8-битное двоичное число или как число в двоично-десятичном "
"коде (BCD). В обоих случаях, число учитывается относительно начала эпохи RTC. "
"Эпоха RTC на большинстве систем начинается с 1900 года, но на Alpha и MIPS "
"также она может начинаться с 1952, 1980 или 2000 года, в зависимости от "
"значения годового регистра RTC. С некоторыми RTC эти операции можно "
"использовать для чтения или установки эпохи RTC, соответственно. Третий "
"аргумент B<ioctl>(2) имеет тип I<unsigned long\\ *> или I<unsigned long>, "
"соответственно, а возвращаемое значение (или назначаемое) является эпохой. "
"Чтобы установить эпоху RTC процесс должен быть привилегированным (т.е., иметь "
"мандат B<CAP_SYS_TIME>)."

#. type: TP
#: man-pages/man4/rtc.4:249
#, no-wrap
msgid "B<RTC_WKALM_RD>, B<RTC_WKALM_SET>"
msgstr "B<RTC_WKALM_RD>, B<RTC_WKALM_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:253
msgid ""
"Some RTCs support a more powerful alarm interface, using these ioctls to "
"read or write the RTC's alarm time (respectively) with this structure:"
msgstr ""
"Некоторые RTC поддерживают более универсальный интерфейс будильника, в "
"котором эти ioctl используются для чтения и записи времени будильника RTC "
"(соответственно) с помощью структуры:"

#. type: Plain text
#: man-pages/man4/rtc.4:262
#, no-wrap
msgid ""
"struct rtc_wkalrm {\n"
"    unsigned char enabled;\n"
"    unsigned char pending;\n"
"    struct rtc_time time;\n"
"};\n"
msgstr ""
"struct rtc_wkalrm {\n    unsigned char enabled;\n    unsigned char pending;\n "
"   struct rtc_time time;\n};\n"

#. type: Plain text
#: man-pages/man4/rtc.4:294
msgid ""
"The I<enabled> flag is used to enable or disable the alarm interrupt, or to "
"read its current status; when using these calls, B<RTC_AIE_ON> and "
"B<RTC_AIE_OFF> are not used.  The I<pending> flag is used by B<RTC_WKALM_RD>"
" to report a pending interrupt (so it's mostly useless on Linux, except when"
" talking to the RTC managed by EFI firmware).  The I<time> field is as used "
"with B<RTC_ALM_READ> and B<RTC_ALM_SET> except that the I<tm_mday>, "
"I<tm_mon>, and I<tm_year> fields are also valid.  A pointer to this "
"structure should be passed as the third B<ioctl>(2)  argument."
msgstr ""
"Флаг I<enabled> используется для включения или отключения прерывания "
"будильника, или для чтения его текущего состояния; когда совершаются данные "
"вызовы B<RTC_AIE_ON> и B<RTC_AIE_OFF> не используются. Флаг I<pending> "
"используется B<RTC_WKALM_RD> для сообщения об ожидающем прерывании (хотя это "
"практически бесполезно в Linux, за исключением RTC, управляемого "
"микропрограммой EFI). Поле I<time> используется B<RTC_ALM_READ> и B<"
"RTC_ALM_SET>, но поля I<tm_mday>, I<tm_mon> и I<tm_year> также учитываются. "
"Указатель на эту структуру должен передаваться в третьем аргументе B<ioctl>"
"(2)."

#. type: Plain text
#: man-pages/man4/rtc.4:299
msgid ""
"I</dev/rtc>, I</dev/rtc0>, I</dev/rtc1>, etc: RTC special character device "
"files."
msgstr ""
"I</dev/rtc>, I</dev/rtc0>, I</dev/rtc1> и т.д.: специальные файлы символьных "
"устройств RTC."

#. type: Plain text
#: man-pages/man4/rtc.4:302
msgid "I</proc/driver/rtc>: status of the (first) RTC."
msgstr "I</proc/driver/rtc>: состояние (первого) RTC."

#. type: SH
#: man-pages/man4/rtc.4:302
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/rtc.4:309
msgid ""
"When the kernel's system time is synchronized with an external reference "
"using B<adjtimex>(2)  it will update a designated RTC periodically every 11 "
"minutes.  To do so, the kernel has to briefly turn off periodic interrupts; "
"this might affect programs using that RTC."
msgstr ""
"Когда системное время ядра синхронизируется с внешним источником с помощью B<"
"adjtimex>(2), оно будет обновляться назначенным RTC с периодичностью каждые "
"11 минут. Для этого ядро на время отключает периодические прерывания; это "
"может повлиять на программы, использующие RTC."

#. type: Plain text
#: man-pages/man4/rtc.4:312
msgid ""
"An RTC's Epoch has nothing to do with the POSIX Epoch which is used only for"
" the system clock."
msgstr ""
"Эпоха RTC не имеет ничего общего с эпохой POSIX, которая используется только "
"в системных часах."

#. type: Plain text
#: man-pages/man4/rtc.4:316
msgid ""
"If the year according to the RTC's Epoch and the year register is less than "
"1970 it is assumed to be 100 years later, that is, between 2000 and 2069."
msgstr ""
"Если год, согласно эпохи RTC и регистр года меньше чем 1970, то "
"предполагается, что время на 100 лет позже, то есть, между 2000 и 2069 годами."

#. type: Plain text
#: man-pages/man4/rtc.4:323
msgid ""
"Some RTCs support \"wildcard\" values in alarm fields, to support scenarios "
"like periodic alarms at fifteen minutes after every hour, or on the first "
"day of each month.  Such usage is nonportable; portable user-space code only"
" expects a single alarm interrupt, and will either disable or reinitialize "
"the alarm after receiving it."
msgstr ""
"Некоторые RTC поддерживают значения «шаблона» в полях будильника, чтобы "
"обеспечить поддержку сценариев, например периодические будильники, через "
"первые 15 минут в начале каждого часа, или первый день каждого месяца. Но это "
"непереносимо; переносимый код пользовательского пространства только ожидает "
"единичное прерывание от будильника, и будет или отключать, или "
"реинициализировать будильник после приёма."

#. type: Plain text
#: man-pages/man4/rtc.4:331
msgid ""
"Some RTCs support periodic interrupts with periods that are multiples of a "
"second rather than fractions of a second; multiple alarms; programmable "
"output clock signals; nonvolatile memory; and other hardware capabilities "
"that are not currently exposed by this API."
msgstr ""
"Некоторые RTC поддерживают периодические прерывания с периодами кратными "
"степени 2, а не дробной секунде; несколько будильников; программируемые "
"выходные сигналы часов; энергонезависимую память; другие аппаратные свойства, "
"для которых пока ещё не предусмотрено программного интерфейса."

#. type: Plain text
#: man-pages/man4/rtc.4:341
msgid ""
"B<date>(1), B<adjtimex>(2), B<gettimeofday>(2), B<settimeofday>(2), "
"B<stime>(2), B<time>(2), B<gmtime>(3), B<time>(7), B<hwclock>(8)"
msgstr ""
"B<date>(1), B<adjtimex>(2), B<gettimeofday>(2), B<settimeofday>(2), B<stime>"
"(2), B<time>(2), B<gmtime>(3), B<time>(7), B<hwclock>(8)"

#. type: Plain text
#: man-pages/man4/rtc.4:343
msgid "I<Documentation/rtc.txt> in the Linux kernel source tree"
msgstr "Файл I<Documentation/rtc.txt> в дереве исходного кода ядра Linux"

#. type: TH
#: man-pages/man4/ram.4:26
#, no-wrap
msgid "RAM"
msgstr "RAM"

#. type: TH
#: man-pages/man4/ram.4:26
#, no-wrap
msgid "1992-11-21"
msgstr "1992-11-21"

#. type: Plain text
#: man-pages/man4/ram.4:29
msgid "ram - ram disk device"
msgstr "ram - устройство для диска в памяти"

#. type: Plain text
#: man-pages/man4/ram.4:33
msgid "The I<ram> device is a block device to access the ram disk in raw mode."
msgstr ""
"Устройство I<ram> представляет собой блочное устройство, предоставляющее "
"прямой доступ к диску в памяти (ram disk)."

#. type: Plain text
#: man-pages/man4/ram.4:35
msgid "It is typically created by:"
msgstr "Обычно, этот файл создается так:"

#. type: Plain text
#: man-pages/man4/ram.4:38
msgid "mknod -m 660 /dev/ram b 1 1"
msgstr "mknod -m 660 /dev/ram b 1 1"

#. type: Plain text
#: man-pages/man4/ram.4:40
msgid "chown root:disk /dev/ram"
msgstr "chown root:disk /dev/ram"

#. type: Plain text
#: man-pages/man4/ram.4:43
msgid "/dev/ram"
msgstr "/dev/ram"

#. type: Plain text
#: man-pages/man4/ram.4:46
msgid "B<chown>(1), B<mknod>(1), B<mount>(8)"
msgstr "B<chown>(1), B<mknod>(1), B<mount>(8)"

#. type: TH
#: man-pages/man7/rtnetlink.7:15
#, no-wrap
msgid "RTNETLINK"
msgstr "RTNETLINK"

#. type: TH
#: man-pages/man7/rtnetlink.7:15
#, no-wrap
msgid "2013-03-05"
msgstr "2013-03-05"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:18
msgid "rtnetlink - Linux IPv4 routing socket"
msgstr "rtnetlink - сокет маршрутизации IPv4 в Linux"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:20
msgid "B<#include E<lt>asm/types.hE<gt>>"
msgstr "B<#include E<lt>asm/types.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:22
msgid "B<#include E<lt>linux/netlink.hE<gt>>"
msgstr "B<#include E<lt>linux/netlink.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:24
msgid "B<#include E<lt>linux/rtnetlink.hE<gt>>"
msgstr "B<#include E<lt>linux/rtnetlink.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:26
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:28
msgid ""
"B<rtnetlink_socket = socket(AF_NETLINK, int >I<socket_type>B<, "
"NETLINK_ROUTE);>"
msgstr ""
"B<rtnetlink_socket = socket(AF_NETLINK, int >I<socket_type>B<, "
"NETLINK_ROUTE);>"

#.  FIXME ? all these macros could be moved to rtnetlink(3)
#. type: Plain text
#: man-pages/man7/rtnetlink.7:42
msgid ""
"Rtnetlink allows the kernel's routing tables to be read and altered.  It is "
"used within the kernel to communicate between various subsystems, though "
"this usage is not documented here, and for communication with user-space "
"programs.  Network routes, IP addresses, link parameters, neighbor setups, "
"queueing disciplines, traffic classes and packet classifiers may all be "
"controlled through B<NETLINK_ROUTE> sockets.  It is based on netlink "
"messages; see B<netlink>(7)  for more information."
msgstr ""
"Rtnetlink позволяет читать и изменять таблицы маршрутизации ядра. Он "
"используется для взаимодействия различных подсистем внутри ядра (это здесь не "
"описано), а также для взаимодействия пользовательских программ. Сетевыми "
"маршрутами, IP-адресами, параметрами связи (link parameters), настройками "
"соседства (neighbor setups), алгоритмами планирования очереди (queueing "
"disciplines), классификацией трафика и  и пакетными классификаторами можно "
"управлять через сокеты B<NETLINK_ROUTE>. Они основываются на сообщениях "
"netlink; подробности смотрите в B<netlink>(7)."

#. type: SS
#: man-pages/man7/rtnetlink.7:42
#, no-wrap
msgid "Routing attributes"
msgstr "Атрибуты маршрутизации"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:44
msgid ""
"Some rtnetlink messages have optional attributes after the initial header:"
msgstr ""
"Некоторые сообщения rtnetlink содержат необязательные атрибуты после "
"начального заголовка:"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:52
#, no-wrap
msgid ""
"struct rtattr {\n"
"    unsigned short rta_len;    /* Length of option */\n"
"    unsigned short rta_type;   /* Type of option */\n"
"    /* Data follows */\n"
"};\n"
msgstr ""
"struct rtattr {\n    unsigned short rta_len;    /* длина параметра */\n    "
"unsigned short rta_type;   /* тип параметра */\n    /* данные … */\n};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:58
msgid ""
"These attributes should be manipulated using only the RTA_* macros or "
"libnetlink, see B<rtnetlink>(3)."
msgstr ""
"Этими атрибутами нужно управлять только с помощью макросов RTA_* или "
"libnetlink, смотрите B<rtnetlink>(3)."

#. type: SS
#: man-pages/man7/rtnetlink.7:58
#, no-wrap
msgid "Messages"
msgstr "Сообщения"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:61
msgid ""
"Rtnetlink consists of these message types (in addition to standard netlink "
"messages):"
msgstr ""
"Rtnetlink поддерживает следующие типы сообщений (в дополнении к стандартным "
"сообщениям netlink):"

#. type: TP
#: man-pages/man7/rtnetlink.7:61
#, no-wrap
msgid "B<RTM_NEWLINK>, B<RTM_DELLINK>, B<RTM_GETLINK>"
msgstr "B<RTM_NEWLINK>, B<RTM_DELLINK>, B<RTM_GETLINK>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:69
msgid ""
"Create, remove or get information about a specific network interface.  These"
" messages contain an I<ifinfomsg> structure followed by a series of "
"I<rtattr> structures."
msgstr ""
"Создание, удаление и получение информации об определённом сетевом интерфейсе. "
"Эти сообщения содержат структуру I<ifinfomsg>, за которой следует ряд "
"структур I<rtattr>."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:78
#, no-wrap
msgid ""
"struct ifinfomsg {\n"
"    unsigned char  ifi_family; /* AF_UNSPEC */\n"
"    unsigned short ifi_type;   /* Device type */\n"
"    int            ifi_index;  /* Interface index */\n"
"    unsigned int   ifi_flags;  /* Device flags  */\n"
"    unsigned int   ifi_change; /* change mask */\n"
"};\n"
msgstr ""
"struct ifinfomsg {\n    unsigned char  ifi_family; /* AF_UNSPEC */\n    "
"unsigned short ifi_type;   /* тип устройства */\n    int            "
"ifi_index;  /* индекс интерфейса */\n    unsigned int   ifi_flags;  /* флаги "
"устройства */\n    unsigned int   ifi_change; /* маска изменения */\n};\n"

#.  FIXME ifi_type
#. type: Plain text
#: man-pages/man7/rtnetlink.7:92
msgid ""
"I<ifi_flags> contains the device flags, see B<netdevice>(7); I<ifi_index> is"
" the unique interface index (since Linux 3.7, it is possible to feed a "
"nonzero value with the B<RTM_NEWLINK> message, thus creating a link with the"
" given I<ifindex>); I<ifi_change> is reserved for future use and should be "
"always set to 0xFFFFFFFF."
msgstr ""
"В I<ifi_flags> содержатся флаги устройства, смотрите B<netdevice>(7); в I<"
"ifi_index> — уникальный индекс интерфейса (начиная с Linux 3.7 возможно "
"передать ненулевое значение в сообщении B<RTM_NEWLINK>; в этом случае "
"создаётся связь (link) с заданным I<ifindex>); элемент I<ifi_change> "
"зарезервирован на будущее и его значение всегда должно быть равно 0xFFFFFFFF."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:96
#, no-wrap
msgid "Routing attributes\n"
msgstr "Атрибуты маршрутизации\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313
#, no-wrap
msgid "rta_type:value type:description\n"
msgstr "rta_type:тип значения:описание\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:98 man-pages/man7/rtnetlink.7:165
#: man-pages/man7/rtnetlink.7:215 man-pages/man7/rtnetlink.7:239
#: man-pages/man7/rtnetlink.7:314 man-pages/man7/rtnetlink.7:432
#, no-wrap
msgid "_\n"
msgstr "_\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99
#, no-wrap
msgid "IFLA_UNSPEC:-:unspecified.\n"
msgstr "IFLA_UNSPEC:-:не определено\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100
#, no-wrap
msgid "IFLA_ADDRESS:hardware address:interface L2 address\n"
msgstr "IFLA_ADDRESS:аппаратный адрес:адрес интерфейса L2\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "IFLA_BROADCAST:hardware address:L2 broadcast address.\n"
msgstr "IFLA_BROADCAST:аппаратный адрес:широковещательный адрес L2\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102
#, no-wrap
msgid "IFLA_IFNAME:asciiz string:Device name.\n"
msgstr "IFLA_IFNAME:строка asciiz:имя устройства\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "IFLA_MTU:unsigned int:MTU of the device.\n"
msgstr "IFLA_MTU:unsigned int:MTU устройства\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104
#, no-wrap
msgid "IFLA_LINK:int:Link type.\n"
msgstr "IFLA_LINK:int:тип связи\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:105
#, no-wrap
msgid "IFLA_QDISC:asciiz string:Queueing discipline.\n"
msgstr "IFLA_QDISC:строка asciiz:алгоритм очереди\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:106
#, no-wrap
msgid "IFLA_STATS:T{\n"
msgstr "IFLA_STATS:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:107
#, no-wrap
msgid "see below\n"
msgstr "см. ниже\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:108
#, no-wrap
msgid "T}:Interface Statistics.\n"
msgstr "T}:статистика интерфейса\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:117
msgid ""
"The value type for B<IFLA_STATS> is I<struct rtnl_link_stats> (I<struct "
"net_device_stats> in Linux 2.4 and earlier)."
msgstr ""
"Тип значения для B<IFLA_STATS> — I<struct rtnl_link_stats> (в Linux 2.4 и "
"старее — I<struct net_device_stats>)."

#. type: TP
#: man-pages/man7/rtnetlink.7:117
#, no-wrap
msgid "B<RTM_NEWADDR>, B<RTM_DELADDR>, B<RTM_GETADDR>"
msgstr "B<RTM_NEWADDR>, B<RTM_DELADDR>, B<RTM_GETADDR>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:130
msgid ""
"Add, remove or receive information about an IP address associated with an "
"interface.  In Linux 2.2, an interface can carry multiple IP addresses, this"
" replaces the alias device concept in 2.0.  In Linux 2.2, these messages "
"support IPv4 and IPv6 addresses.  They contain an I<ifaddrmsg> structure, "
"optionally followed by I<rtattr> routing attributes."
msgstr ""
"Добавление, удаление или получение информации об IP-адресе, назначенном "
"интерфейсу. В Linux 2.2 интерфейс может иметь несколько IP-адресов; эта "
"концепция пришла на смену псевдонимам устройства, использовавшимся в версии "
"2.0. В Linux 2.2 эти сообщения поддерживают адреса IPv4 и IPv6. В них "
"содержится структура I<ifaddrmsg>, которая может быть указана после атрибутов "
"маршрутизации I<rtattr>."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:139
#, no-wrap
msgid ""
"struct ifaddrmsg {\n"
"    unsigned char ifa_family;    /* Address type */\n"
"    unsigned char ifa_prefixlen; /* Prefixlength of address */\n"
"    unsigned char ifa_flags;     /* Address flags */\n"
"    unsigned char ifa_scope;     /* Address scope */\n"
"    int           ifa_index;     /* Interface index */\n"
"};\n"
msgstr ""
"struct ifaddrmsg {\n    unsigned char ifa_family;    /* тип адреса */\n    "
"unsigned char ifa_prefixlen; /* длина префикса адреса */\n    unsigned char "
"ifa_flags;     /* флаги адреса */\n    unsigned char ifa_scope;     /* "
"область адреса */\n    int           ifa_index;     /* индекс интерфейса "
"*/\n};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:159
msgid ""
"I<ifa_family> is the address family type (currently B<AF_INET> or "
"B<AF_INET6>), I<ifa_prefixlen> is the length of the address mask of the "
"address if defined for the family (like for IPv4), I<ifa_scope> is the "
"address scope, I<ifa_index> is the interface index of the interface the "
"address is associated with.  I<ifa_flags> is a flag word of "
"B<IFA_F_SECONDARY> for secondary address (old alias interface), "
"B<IFA_F_PERMANENT> for a permanent address set by the user and other "
"undocumented flags."
msgstr ""
"Поле I<ifa_family> представляет тип адресного семейства (B<AF_INET> или B<"
"AF_INET6>), I<ifa_prefixlen> — длину адресной маски адреса, если это "
"применимо для семейства (в IPv4), I<ifa_scope> — область адреса, I<ifa_index> "
"— индекс интерфейса, которому назначен адрес. Поле I<ifa_flags> — слово "
"флагов: B<IFA_F_SECONDARY> — вторичный адрес (старый псевдоним интерфейса), "
"B<IFA_F_PERMANENT> — постоянный адрес, назначенный пользователем и другие "
"недокументированные флаги."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:163 man-pages/man7/rtnetlink.7:312
#: man-pages/man7/rtnetlink.7:430
#, no-wrap
msgid "Attributes\n"
msgstr "Атрибуты\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:166
#, no-wrap
msgid "IFA_UNSPEC:-:unspecified.\n"
msgstr "IFA_UNSPEC:-:не определено\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167
#, no-wrap
msgid "IFA_ADDRESS:raw protocol address:interface address\n"
msgstr "IFA_ADDRESS:адрес raw-протокола:адрес интерфейса\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:168
#, no-wrap
msgid "IFA_LOCAL:raw protocol address:local address\n"
msgstr "IFA_LOCAL:адрес raw-протокола:локальный адрес\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:169
#, no-wrap
msgid "IFA_LABEL:asciiz string:name of the interface\n"
msgstr "IFA_LABEL:строка asciiz:название интерфейса\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:170
#, no-wrap
msgid "IFA_BROADCAST:raw protocol address:broadcast address.\n"
msgstr "IFA_BROADCAST:адрес raw-протокола:широковещательный адрес\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "IFA_ANYCAST:raw protocol address:anycast address\n"
msgstr "IFA_ANYCAST:адрес raw-протокола:адрес anycast\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "IFA_CACHEINFO:struct ifa_cacheinfo:Address information.\n"
msgstr "IFA_CACHEINFO:struct ifa_cacheinfo:информация об адресе\n"

#. type: TP
#: man-pages/man7/rtnetlink.7:175
#, no-wrap
msgid "B<RTM_NEWROUTE>, B<RTM_DELROUTE>, B<RTM_GETROUTE>"
msgstr "B<RTM_NEWROUTE>, B<RTM_DELROUTE>, B<RTM_GETROUTE>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:195
msgid ""
"Create, remove or receive information about a network route.  These messages"
" contain an I<rtmsg> structure with an optional sequence of I<rtattr> "
"structures following.  For B<RTM_GETROUTE>, setting I<rtm_dst_len> and "
"I<rtm_src_len> to 0 means you get all entries for the specified routing "
"table.  For the other fields, except I<rtm_table> and I<rtm_protocol>, 0 is "
"the wildcard."
msgstr ""
"Создание, удаление или получение информации о сетевом маршруте. Эти сообщения "
"содержат структуру I<rtmsg> с необязательными дополнительными структурами I<"
"rtattr>. Для B<RTM_GETROUTE>, если I<rtm_dst_len> и I<rtm_src_len> задать "
"значение 0, то вы получите все записи определённой таблицы маршрутизации. В "
"других полях, кроме I<rtm_table> и I<rtm_protocol>, 0 считается шаблоном "
"(wildcard)."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:202
#, no-wrap
msgid ""
"struct rtmsg {\n"
"    unsigned char rtm_family;   /* Address family of route */\n"
"    unsigned char rtm_dst_len;  /* Length of destination */\n"
"    unsigned char rtm_src_len;  /* Length of source */\n"
"    unsigned char rtm_tos;      /* TOS filter */\n"
msgstr ""
"struct rtmsg {\n    unsigned char rtm_family;   /* адресное семейство "
"маршрута */\n    unsigned char rtm_dst_len;  /* длина назначения */\n    "
"unsigned char rtm_src_len;  /* длина источника */\n    unsigned char rtm_tos; "
"     /* фильтр TOS */\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:207
#, no-wrap
msgid ""
"    unsigned char rtm_table;    /* Routing table ID */\n"
"    unsigned char rtm_protocol; /* Routing protocol; see below */\n"
"    unsigned char rtm_scope;    /* See below */\n"
"    unsigned char rtm_type;     /* See below */\n"
msgstr ""
"    unsigned char rtm_table;    /* ID таблицы маршрутизации */\n    unsigned "
"char rtm_protocol; /* протокол марш-ции; см. ниже */\n    unsigned char "
"rtm_scope;    /* см. ниже */\n    unsigned char rtm_type;     /* см. ниже */\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:210
#, no-wrap
msgid ""
"    unsigned int  rtm_flags;\n"
"};\n"
msgstr "    unsigned int  rtm_flags;\n};\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:214
#, no-wrap
msgid "rtm_type:Route type\n"
msgstr "rtm_type:Тип маршрута\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:216
#, no-wrap
msgid "RTN_UNSPEC:unknown route\n"
msgstr "RTN_UNSPEC:неизвестный маршрут\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:217
#, no-wrap
msgid "RTN_UNICAST:a gateway or direct route\n"
msgstr "RTN_UNICAST:шлюз или прямой маршрут\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:218
#, no-wrap
msgid "RTN_LOCAL:a local interface route\n"
msgstr "RTN_LOCAL:маршрут локального интерфейса\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:219
#, no-wrap
msgid "RTN_BROADCAST:T{\n"
msgstr "RTN_BROADCAST:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:220
#, no-wrap
msgid "a local broadcast route (sent as a broadcast)\n"
msgstr "локальный широковещательный маршрут (широковещательная отправка)\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:221 man-pages/man7/rtnetlink.7:224
#: man-pages/man7/rtnetlink.7:233 man-pages/man7/rtnetlink.7:243
#: man-pages/man7/rtnetlink.7:266 man-pages/man7/rtnetlink.7:286
#, no-wrap
msgid "T}\n"
msgstr "T}\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:222
#, no-wrap
msgid "RTN_ANYCAST:T{\n"
msgstr "RTN_ANYCAST:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:223
#, no-wrap
msgid "a local broadcast route (sent as a unicast)\n"
msgstr "локальный широковещательный маршрут (однонаправленная отправка)\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:225
#, no-wrap
msgid "RTN_MULTICAST:a multicast route\n"
msgstr "RTN_MULTICAST:многоадресный маршрут\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:226
#, no-wrap
msgid "RTN_BLACKHOLE:a packet dropping route\n"
msgstr "RTN_BLACKHOLE:маршрут для отброса пакетов\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:227
#, no-wrap
msgid "RTN_UNREACHABLE:an unreachable destination\n"
msgstr "RTN_UNREACHABLE:недостижимый пункт назначения\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:228
#, no-wrap
msgid "RTN_PROHIBIT:a packet rejection route\n"
msgstr "RTN_PROHIBIT:маршрут для отклонения пакетов\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:229
#, no-wrap
msgid "RTN_THROW:continue routing lookup in another table\n"
msgstr "RTN_THROW:продолжение поиска маршрута в другой таблице\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:230
#, no-wrap
msgid "RTN_NAT:a network address translation rule\n"
msgstr "RTN_NAT:правило трансляции сетевого адреса\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:231
#, no-wrap
msgid "RTN_XRESOLVE:T{\n"
msgstr "RTN_XRESOLVE:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:232
#, no-wrap
msgid "refer to an external resolver (not implemented)\n"
msgstr "ссылка на внешний решатель (не реализовано)\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:238
#, no-wrap
msgid "rtm_protocol:Route origin.\n"
msgstr "rtm_protocol:Происхождение маршрута\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:240
#, no-wrap
msgid "RTPROT_UNSPEC:unknown\n"
msgstr "RTPROT_UNSPEC:неизвестно\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:241
#, no-wrap
msgid "RTPROT_REDIRECT:T{\n"
msgstr "RTPROT_REDIRECT:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:242
#, no-wrap
msgid "by an ICMP redirect (currently unused)\n"
msgstr "из-за перенаправления полученном по ICMP (не используется)\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:244
#, no-wrap
msgid "RTPROT_KERNEL:by the kernel\n"
msgstr "RTPROT_KERNEL:из ядра\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:245
#, no-wrap
msgid "RTPROT_BOOT:during boot\n"
msgstr "RTPROT_BOOT:при загрузке машины\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:246
#, no-wrap
msgid "RTPROT_STATIC:by the administrator\n"
msgstr "RTPROT_STATIC:указан администратором\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:257
msgid ""
"Values larger than B<RTPROT_STATIC> are not interpreted by the kernel, they "
"are just for user information.  They may be used to tag the source of a "
"routing information or to distinguish between multiple routing daemons.  See"
" I<E<lt>linux/rtnetlink.hE<gt>> for the routing daemon identifiers which are"
" already assigned."
msgstr ""
"Значения больше B<RTPROT_STATIC> не учитываются ядром, они предназначены "
"только для пользовательской информации. Они могут использоваться для пометки "
"источника информации о маршрутизации или для отличения различных служб "
"маршрутизации друг от друга. Уже назначенные идентификаторы для служб "
"маршрутизации можно найти в I<E<lt>linux/rtnetlink.hE<gt>>."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:260
msgid "I<rtm_scope> is the distance to the destination:"
msgstr "I<rtm_scope> — расстояние до назначения:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:263
#, no-wrap
msgid "RT_SCOPE_UNIVERSE:global route\n"
msgstr "RT_SCOPE_UNIVERSE:глобальный маршрут\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:264
#, no-wrap
msgid "RT_SCOPE_SITE:T{\n"
msgstr "RT_SCOPE_SITE:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:265
#, no-wrap
msgid "interior route in the local autonomous system\n"
msgstr "внутренний маршрут в локальной автономной системе\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:267
#, no-wrap
msgid "RT_SCOPE_LINK:route on this link\n"
msgstr "RT_SCOPE_LINK:маршрут на эту связи\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:268
#, no-wrap
msgid "RT_SCOPE_HOST:route on the local host\n"
msgstr "RT_SCOPE_HOST:маршрут на локальный узел\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:269
#, no-wrap
msgid "RT_SCOPE_NOWHERE:destination doesn't exist\n"
msgstr "RT_SCOPE_NOWHERE:назначение не существует\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:277
msgid ""
"The values between B<RT_SCOPE_UNIVERSE> and B<RT_SCOPE_SITE> are available "
"to the user."
msgstr ""
"Значения от B<RT_SCOPE_UNIVERSE> и до B<RT_SCOPE_SITE> доступны пользователю."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:281
msgid "The I<rtm_flags> have the following meanings:"
msgstr "Поле I<rtm_flags> может иметь следующие значения:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:284
#, no-wrap
msgid "RTM_F_NOTIFY:T{\n"
msgstr "RTM_F_NOTIFY:T{\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:285
#, no-wrap
msgid "if the route changes, notify the user via rtnetlink\n"
msgstr "если маршрут изменился — уведомить пользователя через rtnetlink\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:287
#, no-wrap
msgid "RTM_F_CLONED:route is cloned from another route\n"
msgstr "RTM_F_CLONED:маршрут склонирован из другого маршрута\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:288
#, no-wrap
msgid "RTM_F_EQUALIZE:a multipath equalizer (not yet implemented)\n"
msgstr "RTM_F_EQUALIZE:многопутевой уравниватель (не реализовано)\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:293
msgid "I<rtm_table> specifies the routing table"
msgstr "В I<rtm_table> задаётся таблица маршрутизации:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:296
#, no-wrap
msgid "RT_TABLE_UNSPEC:an unspecified routing table\n"
msgstr "RT_TABLE_UNSPEC:таблица маршрутизации не задана\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:297
#, no-wrap
msgid "RT_TABLE_DEFAULT:the default table\n"
msgstr "RT_TABLE_DEFAULT:таблица по умолчанию\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:298
#, no-wrap
msgid "RT_TABLE_MAIN:the main table\n"
msgstr "RT_TABLE_MAIN:главная таблица\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:299
#, no-wrap
msgid "RT_TABLE_LOCAL:the local table\n"
msgstr "RT_TABLE_LOCAL:локальная таблица\n"

#.  Keep table on same page
#. type: Plain text
#: man-pages/man7/rtnetlink.7:307
msgid ""
"The user may assign arbitrary values between B<RT_TABLE_UNSPEC> and "
"B<RT_TABLE_DEFAULT>."
msgstr ""
"Пользователь может назначать произвольные значения от B<RT_TABLE_UNSPEC> и до "
"B<RT_TABLE_DEFAULT>."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:315
#, no-wrap
msgid "RTA_UNSPEC:-:ignored.\n"
msgstr "RTA_UNSPEC:-:игнорируется\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316
#, no-wrap
msgid "RTA_DST:protocol address:Route destination address.\n"
msgstr "RTA_DST:адрес протокола:адрес маршрута назначения\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:317
#, no-wrap
msgid "RTA_SRC:protocol address:Route source address.\n"
msgstr "RTA_SRC:адрес протокола:адрес маршрута источника\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:318
#, no-wrap
msgid "RTA_IIF:int:Input interface index.\n"
msgstr "RTA_IIF:int:индекс входного интерфейса\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:319
#, no-wrap
msgid "RTA_OIF:int:Output interface index.\n"
msgstr "RTA_OIF:int:индекс выходного интерфейса\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "RTA_GATEWAY:protocol address:The gateway of the route\n"
msgstr "RTA_GATEWAY:адрес протокола:шлюз маршрута\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:321
#, no-wrap
msgid "RTA_PRIORITY:int:Priority of route.\n"
msgstr "RTA_PRIORITY:int:приоритет маршрута\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:322
#, no-wrap
msgid "RTA_PREFSRC::\n"
msgstr "RTA_PREFSRC::\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "RTA_METRICS:int:Route metric\n"
msgstr "RTA_METRICS:int:метрика маршрута\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:324
#, no-wrap
msgid "RTA_MULTIPATH::\n"
msgstr "RTA_MULTIPATH::\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:325
#, no-wrap
msgid "RTA_PROTOINFO::\n"
msgstr "RTA_PROTOINFO::\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:326
#, no-wrap
msgid "RTA_FLOW::\n"
msgstr "RTA_FLOW::\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:327
#, no-wrap
msgid "RTA_CACHEINFO::\n"
msgstr "RTA_CACHEINFO::\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:331
msgid "B<Fill these values in!>"
msgstr "B<Заполнить эти значения!>"

#. type: TP
#: man-pages/man7/rtnetlink.7:331
#, no-wrap
msgid "B<RTM_NEWNEIGH>, B<RTM_DELNEIGH>, B<RTM_GETNEIGH>"
msgstr "B<RTM_NEWNEIGH>, B<RTM_DELNEIGH>, B<RTM_GETNEIGH>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:338
msgid ""
"Add, remove or receive information about a neighbor table entry (e.g., an "
"ARP entry).  The message contains an I<ndmsg> structure."
msgstr ""
"Добавление, удаление или получение информации о записи соседей по таблице "
"(например, запись ARP). В сообщении содержится структура I<ndmsg>:"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:347
#, no-wrap
msgid ""
"struct ndmsg {\n"
"    unsigned char ndm_family;\n"
"    int           ndm_ifindex;  /* Interface index */\n"
"    __u16         ndm_state;    /* State */\n"
"    __u8          ndm_flags;    /* Flags */\n"
"    __u8          ndm_type;\n"
"};\n"
msgstr ""
"struct ndmsg {\n    unsigned char ndm_family;\n    int           ndm_ifindex; "
" /* индекс интерфейса */\n    __u16         ndm_state;    /* состояние */\n   "
" __u8          ndm_flags;    /* флаги */\n    __u8          ndm_type;\n};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:354
#, no-wrap
msgid ""
"struct nda_cacheinfo {\n"
"    __u32         ndm_confirmed;\n"
"    __u32         ndm_used;\n"
"    __u32         ndm_updated;\n"
"    __u32         ndm_refcnt;\n"
"};\n"
msgstr ""
"struct nda_cacheinfo {\n    __u32         ndm_confirmed;\n    __u32         "
"ndm_used;\n    __u32         ndm_updated;\n    __u32         ndm_refcnt;\n};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:358
msgid "I<ndm_state> is a bit mask of the following states:"
msgstr "В I<ndm_state> содержится битовая маска следующих состояний:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:361
#, no-wrap
msgid "NUD_INCOMPLETE:a currently resolving cache entry\n"
msgstr "NUD_INCOMPLETE:запись кэша в данный момент определяется\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:362
#, no-wrap
msgid "NUD_REACHABLE:a confirmed working cache entry\n"
msgstr "NUD_REACHABLE:подтверждённая рабочая запись кэша\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:363
#, no-wrap
msgid "NUD_STALE:an expired cache entry\n"
msgstr "NUD_STALE:устаревшая запись кэша\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:364
#, no-wrap
msgid "NUD_DELAY:an entry waiting for a timer\n"
msgstr "NUD_DELAY:запись ожидает срабатывания таймера\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:365
#, no-wrap
msgid "NUD_PROBE:a cache entry that is currently reprobed\n"
msgstr "NUD_PROBE:запись кэша в данный момент проверяется повторно\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:366
#, no-wrap
msgid "NUD_FAILED:an invalid cache entry\n"
msgstr "NUD_FAILED:некорректная запись кэша\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:367
#, no-wrap
msgid "NUD_NOARP:a device with no destination cache\n"
msgstr "NUD_NOARP:устройство без кэша назначений\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:368
#, no-wrap
msgid "NUD_PERMANENT:a static entry\n"
msgstr "NUD_PERMANENT:статическая запись\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:374
msgid "Valid I<ndm_flags> are:"
msgstr "Допустимые значения I<ndm_flags>:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:377
#, no-wrap
msgid "NTF_PROXY:a proxy arp entry\n"
msgstr "NTF_PROXY:запись прокси arp\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:378
#, no-wrap
msgid "NTF_ROUTER:an IPv6 router\n"
msgstr "NTF_ROUTER:маршрутизатор IPv6\n"

#.  FIXME
#.  document the members of the struct better
#. type: Plain text
#: man-pages/man7/rtnetlink.7:388
msgid ""
"The I<rtattr> struct has the following meanings for the I<rta_type> field:"
msgstr "Структура I<rtattr> имеет следующие значения для поля I<rta_type>:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:391
#, no-wrap
msgid "NDA_UNSPEC:unknown type\n"
msgstr "NDA_UNSPEC:неизвестный тип\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:392
#, no-wrap
msgid "NDA_DST:a neighbor cache n/w layer destination address\n"
msgstr "NDA_DST:кэш адресов назначения соседей на сетевом уровне\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:393
#, no-wrap
msgid "NDA_LLADDR:a neighbor cache link layer address\n"
msgstr "NDA_LLADDR:кэш адресов соседей на уровне связей\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:394
#, no-wrap
msgid "NDA_CACHEINFO:cache statistics.\n"
msgstr "NDA_CACHEINFO:статистика кэша\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:404
msgid ""
"If the I<rta_type> field is B<NDA_CACHEINFO>, then a I<struct nda_cacheinfo>"
" header follows"
msgstr ""
"Если значение поля I<rta_type> равно B<NDA_CACHEINFO>, то присутствует "
"заголовок I<struct nda_cacheinfo>."

#. type: TP
#: man-pages/man7/rtnetlink.7:404
#, no-wrap
msgid "B<RTM_NEWRULE>, B<RTM_DELRULE>, B<RTM_GETRULE>"
msgstr "B<RTM_NEWRULE>, B<RTM_DELRULE>, B<RTM_GETRULE>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:409
msgid "Add, delete or retrieve a routing rule.  Carries a I<struct rtmsg>"
msgstr ""
"Добавление, удаление или получение правила маршрутизации. Содержит I<struct "
"rtmsg>."

#. type: TP
#: man-pages/man7/rtnetlink.7:409
#, no-wrap
msgid "B<RTM_NEWQDISC>, B<RTM_DELQDISC>, B<RTM_GETQDISC>"
msgstr "B<RTM_NEWQDISC>, B<RTM_DELQDISC>, B<RTM_GETQDISC>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:416
msgid ""
"Add, remove or get a queueing discipline.  The message contains a I<struct "
"tcmsg> and may be followed by a series of attributes."
msgstr ""
"Добавление, удаление или получение планирования очереди. В сообщении "
"содержится I<struct tcmsg>, а также может быть серия атрибутов."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:425
#, no-wrap
msgid ""
"struct tcmsg {\n"
"    unsigned char    tcm_family;\n"
"    int              tcm_ifindex;   /* interface index */\n"
"    __u32            tcm_handle;    /* Qdisc handle */\n"
"    __u32            tcm_parent;    /* Parent qdisc */\n"
"    __u32            tcm_info;\n"
"};\n"
msgstr ""
"struct tcmsg {\n    unsigned char    tcm_family;\n    int              "
"tcm_ifindex;   /* индекс интерфейса */\n    __u32            tcm_handle;    "
"/* описатель qdisc */\n    __u32            tcm_parent;    /* предок qdisc "
"*/\n    __u32            tcm_info;\n};\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "rta_type:value type:Description\n"
msgstr "rta_type:тип значения:описание\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "TCA_UNSPEC:-:unspecified\n"
msgstr "TCA_UNSPEC:-:не определено\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "TCA_KIND:asciiz string:Name of queueing discipline\n"
msgstr "TCA_KIND:строка asciiz:имя план-ания очереди\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "TCA_OPTIONS:byte sequence:Qdisc-specific options follow\n"
msgstr "TCA_OPTIONS:байтовая последовательность:есть параметры qdisc\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "TCA_STATS:struct tc_stats:Qdisc statistics.\n"
msgstr "TCA_STATS:struct tc_stats:статистика qdisc\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "TCA_XSTATS:qdisc-specific:Module-specific statistics.\n"
msgstr "TCA_XSTATS:qdisc specific:стат-ка по опр. модулю\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "TCA_RATE:struct tc_estimator:Rate limit.\n"
msgstr "TCA_RATE:struct tc_estimator:ограничение по скорости\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:443
msgid ""
"In addition, various other qdisc-module-specific attributes are allowed.  "
"For more information see the appropriate include files."
msgstr ""
"Также, разрешены дополнительные атрибуты модуля qdisc. Дополнительную "
"информацию можно получить из соответствующих заголовочных файлов."

#. type: TP
#: man-pages/man7/rtnetlink.7:443
#, no-wrap
msgid "B<RTM_NEWTCLASS>, B<RTM_DELTCLASS>, B<RTM_GETTCLASS>"
msgstr "B<RTM_NEWTCLASS>, B<RTM_DELTCLASS>, B<RTM_GETTCLASS>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:449
msgid ""
"Add, remove or get a traffic class.  These messages contain a I<struct "
"tcmsg> as described above."
msgstr ""
"Добавление, удаление или получение класса трафика. В этих сообщениях "
"содержится структура I<struct tcmsg>, описанная ранее."

#. type: TP
#: man-pages/man7/rtnetlink.7:449
#, no-wrap
msgid "B<RTM_NEWTFILTER>, B<RTM_DELTFILTER>, B<RTM_GETTFILTER>"
msgstr "B<RTM_NEWTFILTER>, B<RTM_DELTFILTER>, B<RTM_GETTFILTER>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:455
msgid ""
"Add, remove or receive information about a traffic filter.  These messages "
"contain a I<struct tcmsg> as described above."
msgstr ""
"Добавление, удаление или получение информации о фильтре трафика. В этих "
"сообщениях содержится структура I<struct tcmsg>, описанная ранее."

#. type: SH
#: man-pages/man7/rtnetlink.7:455
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:458
msgid "B<rtnetlink> is a new feature of Linux 2.2."
msgstr "Свойство B<rtnetlink> появилось в Linux 2.2."

#. type: SH
#: man-pages/man7/rtnetlink.7:458
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:460
msgid "This manual page is incomplete."
msgstr "Данная справочная страница не полна."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:464
msgid "B<cmsg>(3), B<rtnetlink>(3), B<ip>(7), B<netlink>(7)"
msgstr "B<cmsg>(3), B<rtnetlink>(3), B<ip>(7), B<netlink>(7)"

#. type: TH
#: man-pages/man7/regex.7:37
#, no-wrap
msgid "REGEX"
msgstr "REGEX"

#. type: TH
#: man-pages/man7/regex.7:37
#, no-wrap
msgid "2009-01-12"
msgstr "2009-01-12"

#. type: Plain text
#: man-pages/man7/regex.7:40
msgid "regex - POSIX.2 regular expressions"
msgstr "regex - регулярные выражения POSIX.2"

#. type: Plain text
#: man-pages/man7/regex.7:54
msgid ""
"Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forms: "
"modern REs (roughly those of I<egrep>; POSIX.2 calls these \"extended\" REs)"
"  and obsolete REs (roughly those of B<ed>(1); POSIX.2 \"basic\" REs).  "
"Obsolete REs mostly exist for backward compatibility in some old programs; "
"they will be discussed at the end.  POSIX.2 leaves some aspects of RE syntax"
" and semantics open; \"\\*(dg\" marks decisions on these aspects that may "
"not be fully portable to other POSIX.2 implementations."
msgstr ""
"Регулярные выражения (РВ) стандарта POSIX.2 могут быть двух видов: новые РВ "
"(по сути, использующиеся в I<egrep>; в POSIX.2 их называют ещё «расширенными» "
"РВ) и устаревшие РВ (по сути, использующиеся в B<ed>(1); в POSIX.2 их "
"называют ещё «основными» РВ). Устаревшие РВ существуют, в основном, для "
"совместимости с некоторыми старыми программами (они будут подробнее "
"рассмотрены в конце этого документа). В POSIX.2 не разъяснены некоторые "
"вопросы синтаксиса РВ; знаком \\*(dg отмечаются описания, которые могут быть "
"не полностью совместимы с другими реализациями POSIX.2."

#. type: Plain text
#: man-pages/man7/regex.7:58
msgid ""
"A (modern) RE is one\\*(dg or more nonempty\\*(dg I<branches>, separated by "
"\\(aq|\\(aq.  It matches anything that matches one of the branches."
msgstr ""
"Новое РВ — одна\\*(dg или более непустых\\*(dg I<ветвей>, разделённых "
"\\(aq|\\(aq. Соответствием считается, если есть совпадение для любой из её "
"ветвей."

#. type: Plain text
#: man-pages/man7/regex.7:62
msgid ""
"A branch is one\\*(dg or more I<pieces>, concatenated.  It matches a match "
"for the first, followed by a match for the second, and so on."
msgstr ""
"Ветвь состоит из одной\\*(dg или более I<частей>. Ветвь сначала ведёт поиск "
"соответствий с первой, затем с второй (и т. п.) её частями."

#. type: Plain text
#: man-pages/man7/regex.7:71
msgid ""
"A piece is an I<atom> possibly followed by a single\\*(dg \\(aq*\\(aq, "
"\\(aq+\\(aq, \\(aq?\\(aq, or I<bound>.  An atom followed by \\(aq*\\(aq "
"matches a sequence of 0 or more matches of the atom.  An atom followed by "
"\\(aq+\\(aq matches a sequence of 1 or more matches of the atom.  An atom "
"followed by \\(aq?\\(aq matches a sequence of 0 or 1 matches of the atom."
msgstr ""
"Часть — это I<атом>, за которым может следовать одиночный\\*(dg символ "
"\\(aq*\\(aq, \\(aq+\\(aq, \\(aq?\\(aq или I<интервал>. Если за атомом следует "
"символ \\(aq*\\(aq, это означает, что совпадающая с атомом последовательность "
"может встречаться 0 или более раз. Если за атомом следует символ \\(aq+\\(aq, "
"это означает, что совпадающая с атомом последовательность может встречаться 1 "
"или более раз. Если за атомом следует символ \\(aq?\\(aq, это означает, что "
"совпадающая с атомом последовательность может встречаться 0 или 1 раз."

#. type: Plain text
#: man-pages/man7/regex.7:89
msgid ""
"A I<bound> is \\(aq{\\(aq followed by an unsigned decimal integer, possibly "
"followed by \\(aq,\\(aq possibly followed by another unsigned decimal "
"integer, always followed by \\(aq}\\(aq.  The integers must lie between 0 "
"and B<RE_DUP_MAX> (255\\*(dg) inclusive, and if there are two of them, the "
"first may not exceed the second.  An atom followed by a bound containing one"
" integer I<i> and no comma matches a sequence of exactly I<i> matches of the"
" atom.  An atom followed by a bound containing one integer I<i> and a comma "
"matches a sequence of I<i> or more matches of the atom.  An atom followed by"
" a bound containing two integers I<i> and I<j> matches a sequence of I<i> "
"through I<j> (inclusive) matches of the atom."
msgstr ""
"I<Интервал> — это символ \\(aq{\\(aq, после которого стоит беззнаковое целое "
"десятичное число, за которым может следовать символ \\(aq,\\(aq, далее, "
"возможно, находится ещё одно беззнаковое целое десятичное число, и в конце "
"интервала обязательно стоит символ \\(aq}\\(aq. Числа должны находиться в "
"промежутке от 0 до B<RE_DUP_MAX> (255\\*(dg) включительно, а если указано два "
"числа, то первое не должно превышать второе. Атом с интервалом, в котором "
"есть одно число I<i> и нет запятой, соответствует последовательности, "
"повторяющейся точно I<i> раз. Атом с интервалом, содержащим число I<i> и "
"запятую, соответствует последовательности, повторяющейся I<i> и более раз. "
"Атом с интервалом, содержащим два числа I<i> и I<j>, соответствует "
"последовательности, повторяющейся от I<i> до I<j> раз включительно."

#. type: Plain text
#: man-pages/man7/regex.7:106
msgid ""
"An atom is a regular expression enclosed in \"I<()>\" (matching a match for "
"the regular expression), an empty set of \"I<()>\" (matching the null "
"string)\\*(dg, a I<bracket expression> (see below), \\(aq.\\(aq (matching "
"any single character), \\(aq^\\(aq (matching the null string at the "
"beginning of a line), \\(aq$\\(aq (matching the null string at the end of a "
"line), a \\(aq\\e\\(aq followed by one of the characters "
"\"I<^.[$()|*+?{\\e>\" (matching that character taken as an ordinary "
"character), a \\(aq\\e\\(aq followed by any other character\\*(dg (matching "
"that character taken as an ordinary character, as if the \\(aq\\e\\(aq had "
"not been present\\*(dg), or a single character with no other significance "
"(matching that character).  A \\(aq{\\(aq followed by a character other than"
" a digit is an ordinary character, not the beginning of a bound\\*(dg.  It "
"is illegal to end an RE with \\(aq\\e\\(aq."
msgstr ""
"Атом — это регулярное выражение, заключённое в «I<()>» (соответствующее "
"регулярному выражению), пустые скобки «I<()>» (соответствуют строке "
"null)\\*(dg, I<выражение в квадратных скобках> (см. ниже), \\(aq.\\(aq "
"(соответствует любому одному символу), \\(aq^\\(aq (соответствует строке null "
"в начале строки), \\(aq$\\(aq (соответствует строке null в конце строки), "
"\\(aq\\e\\(aq со следующим после него одним из символов «I<^.[$()|*+?{\\e>» "
"(соответствует этому символу, как он есть), символ \\(aq\\e\\(aq с "
"последующим символом, отличным от предыдущего\\*(dg (соответствует этому "
"символу, как он есть, как если бы \\(aq\\e\\(aq отсутствовал\\*(dg), или "
"одиночный символ без специального назначения (соответствует этому символу). "
"Символ \\(aq{\\(aq с последующим символом, не являющимся цифрой, "
"соответствует символу, а не началу интервала\\*(dg. Нельзя заканчивать РВ "
"символом \\(aq\\e\\(aq."

#. type: Plain text
#: man-pages/man7/regex.7:120
msgid ""
"A I<bracket expression> is a list of characters enclosed in \"I<[]>\".  It "
"normally matches any single character from the list (but see below).  If the"
" list begins with \\(aq^\\(aq, it matches any single character (but see "
"below) I<not> from the rest of the list.  If two characters in the list are "
"separated by \\(aq-\\(aq, this is shorthand for the full I<range> of "
"characters between those two (inclusive) in the collating sequence, for "
"example, \"I<[0-9]>\" in ASCII matches any decimal digit.  It is "
"illegal\\*(dg for two ranges to share an endpoint, for example, "
"\"I<a-c-e>\".  Ranges are very collating-sequence-dependent, and portable "
"programs should avoid relying on them."
msgstr ""
"I<Выражение в квадратных скобках> — список символов, заключенный в «I<[]>». "
"Обычно, оно соответствует любому отдельному символу из списка (но см. ниже). "
"Если список начинается с \\(aq^\\(aq, то он соответствует любому отдельному "
"символу (но см. ниже) I<не> из приведённого списка. Если два символа в списке "
"разделены \\(aq-\\(aq, то это считается сокращением полного I<диапазона> "
"символов, заключённого между этими двумя символами (включая и их) "
"объединяющей последовательности, например, «I<[0-9]>» в кодах ASCII "
"соответствует любой десятичной цифре. Нельзя\\*(dg в двух диапазонах "
"указывать один и тот же символ, например, «a-c-e». Диапазоны сильно зависят "
"от объединяющей последовательности, и в переносимых программах их лучше не "
"использовать."

#. type: Plain text
#: man-pages/man7/regex.7:131
msgid ""
"To include a literal \\(aq]\\(aq in the list, make it the first character "
"(following a possible \\(aq^\\(aq).  To include a literal \\(aq-\\(aq, make "
"it the first or last character, or the second endpoint of a range.  To use a"
" literal \\(aq-\\(aq as the first endpoint of a range, enclose it in "
"\"I<[.>\" and \"I<.]>\" to make it a collating element (see below).  With "
"the exception of these and some combinations using \\(aq[\\(aq (see next "
"paragraphs), all other special characters, including \\(aq\\e\\(aq, lose "
"their special significance within a bracket expression."
msgstr ""
"Для того, чтобы включить в список символ \\(aq]\\(aq, вам следует поставить "
"его в начало списка (после символа \\(aq^\\(aq, если он присутствует). Для "
"того, чтобы включить в список символ \\(aq-\\(aq, поставьте его первым или "
"последним символом или вторым символом конца диапазона. Для того, чтобы "
"обозначить символом \\(aq-\\(aq начало диапазона, заключите его в «I<[.>» и "
"«I<.]>», сделав его объединяющим элементом (смотрите далее). За исключением "
"этих и некоторых других комбинаций, использующих \\(aq[\\(aq  (см. следующие "
"параграфы), все остальные специальные символы, включая \\(aq\\e\\(aq, теряют "
"своё особое назначение в квадратных скобках."

#. type: Plain text
#: man-pages/man7/regex.7:143
msgid ""
"Within a bracket expression, a collating element (a character, a "
"multicharacter sequence that collates as if it were a single character, or a"
" collating-sequence name for either)  enclosed in \"I<[.>\" and \"I<.]>\" "
"stands for the sequence of characters of that collating element.  The "
"sequence is a single element of the bracket expression's list.  A bracket "
"expression containing a multicharacter collating element can thus match more"
" than one character, for example, if the collating sequence includes a "
"\"ch\" collating element, then the RE \"I<[[.ch.]]*c>\" matches the first "
"five characters of \"chchcc\"."
msgstr ""
"Если внутри квадратных скобок объединяющий элемент (одиночный символ, "
"многосимвольная последовательность, которая действует как одиночный символ "
"или имя объединяющей последовательности) заключен в «I<[.>» и «I<.]>», то он "
"обозначает последовательность символов как один объединяющий элемент. "
"Последовательность выражается одиночным элементом списка внутри квадратных "
"скобок. Таким образом, выражение в скобках, содержащее многосимвольный "
"объединяющий элемент, может соответствовать более чем одному символу; "
"например, если последовательность содержит объединяющий элемент «ch», то РВ "
"«I<[[.ch.]]*c>» соответствует первым пяти символам «chchcc»."

#. type: Plain text
#: man-pages/man7/regex.7:155
msgid ""
"Within a bracket expression, a collating element enclosed in \"I<[=>\" and "
"\"I<=]>\" is an equivalence class, standing for the sequences of characters "
"of all collating elements equivalent to that one, including itself.  (If "
"there are no other equivalent collating elements, the treatment is as if the"
" enclosing delimiters were \"I<[.>\" and \"I<.]>\".)  For example, if o and "
"\\o'o^' are the members of an equivalence class, then \"I<[[=o=]]>\", "
"\"I<[[=\\o'o^'=]]>\", and \"I<[o\\o'o^']>\" are all synonymous.  An "
"equivalence class may not\\*(dg be an endpoint of a range."
msgstr ""
"Объединяющий элемент в квадратных скобках, заключенный в «I<[=>» и «I<=]>» — "
"это класс-эквивалент, делающий последовательности символов всех объединяющих "
"элементов эквивалентными одной, включая её саму (если нет больше "
"эквивалентных объединяющих элементов, то это аналогично выражению, "
"заключенному в «I<[.>» и «I<.]>»). Например, если o и \\o'o^' являются "
"членами класса-эквивалента, то «I<[[=o=]]>», «I<[[=\\o'o^'=]]>» и «I<"
"[o\\o'o^']>» являются синонимами. Класс-эквивалент не\\*(dg может служить "
"границей диапазона."

#. type: Plain text
#: man-pages/man7/regex.7:161
msgid ""
"Within a bracket expression, the name of a I<character class> enclosed in "
"\"I<[:>\" and \"I<:]>\" stands for the list of all characters belonging to "
"that class.  Standard character class names are:"
msgstr ""
"В выражении в квадратных скобках, имя I<символьного класса>, заключенное в "
"«I<[:>» и «I<:]>», соответствует списку всех символов, принадлежащих этому "
"классу. Существуют стандартные символьные классы:"

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "alnum\tdigit\tpunct\n"
msgstr "alnum\tdigit\tpunct\n"

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "alpha\tgraph\tspace\n"
msgstr "alpha\tgraph\tspace\n"

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "blank\tlower\tupper\n"
msgstr "blank\tlower\tupper\n"

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "cntrl\tprint\txdigit\n"
msgstr "cntrl\tprint\txdigit\n"

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  There are two special cases\*(dg of bracket expressions:
#.  the bracket expressions "\fI[[:<:]]\fP" and "\fI[[:>:]]\fP" match
#.  the null string at the beginning and end of a word respectively.
#.  A word is defined as a sequence of
#.  word characters
#.  which is neither preceded nor followed by
#.  word characters.
#.  A word character is an
#.  .I alnum
#.  character (as defined by
#.  .BR wctype (3))
#.  or an underscore.
#.  This is an extension,
#.  compatible with but not specified by POSIX.2,
#.  and should be used with
#.  caution in software intended to be portable to other systems.
#. type: Plain text
#: man-pages/man7/regex.7:195
msgid ""
"These stand for the character classes defined in B<wctype>(3).  A locale may"
" provide others.  A character class may not be used as an endpoint of a "
"range."
msgstr ""
"Эти символьные классы определены в B<wctype>(3). В локали могут быть "
"определены свои классы. Символьный класс не может использоваться в качестве "
"границы диапазона."

#. type: Plain text
#: man-pages/man7/regex.7:207
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string.  If the RE "
"could match more than one substring starting at that point, it matches the "
"longest.  Subexpressions also match the longest possible substrings, subject"
" to the constraint that the whole match be as long as possible, with "
"subexpressions starting earlier in the RE taking priority over ones starting"
" later.  Note that higher-level subexpressions thus take priority over their"
" lower-level component subexpressions."
msgstr ""
"В случае, если РВ совпадает более чем с одной подстрокой заданной строки, то "
"оно считается совпадающим с первой подстрокой строки. Если РВ совпадает более "
"чем с одной подстрокой начинающейся в этой точке, то оно совпадет с самой "
"длинной подстрокой. Подвыражения также соответствуют самой длинной "
"совпадающей подстроке, полное соответствие должно быть наиболее длинным, и "
"подвыражения, стоящие в РВ первыми, имеют приоритет над остальными, "
"находящимися далее. Заметим, что высокоуровневые подвыражения имеют приоритет "
"над низкоуровневыми компонентами подвыражений."

#. type: Plain text
#: man-pages/man7/regex.7:219
msgid ""
"Match lengths are measured in characters, not collating elements.  A null "
"string is considered longer than no match at all.  For example, \"I<bb*>\" "
"matches the three middle characters of \"abbbc\", "
"\"I<(wee|week)(knights|nights)>\" matches all ten characters of "
"\"weeknights\", when \"I<(.*).*>\" is matched against \"abc\" the "
"parenthesized subexpression matches all three characters, and when "
"\"I<(a*)*>\" is matched against \"bc\" both the whole RE and the "
"parenthesized subexpression match the null string."
msgstr ""
"Длина совпадений измеряется в символах, а не в объединяющих элементах. Строка "
"null считается длиннее чем не имеющая совпадений. Например, «I<bb*>» "
"совпадает с тремя средними символами «abbbc», «I<(wee|week)(knights|nights)>» "
"совпадает со всеми десятью символами «weeknights», а когда «I<(.*).*>» "
"сравнивается с «abc», подвыражение в скобках совпадает со всеми тремя "
"символами; при сравнении «I<(a*)*>» с «bc» получается, что РВ и подвыражение "
"в скобках соответствуют строке null."

#. type: Plain text
#: man-pages/man7/regex.7:230
msgid ""
"If case-independent matching is specified, the effect is much as if all case"
" distinctions had vanished from the alphabet.  When an alphabetic that "
"exists in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, for example, \\(aqx\\(aq becomes \"I<[xX]>\".  When "
"it appears inside a bracket expression, all case counterparts of it are "
"added to the bracket expression, so that, for example, \"I<[x]>\" becomes "
"\"I<[xX]>\" and \"I<[^x]>\" becomes \"I<[^xX]>\"."
msgstr ""
"Если указано учитывать совпадение независимо от регистра, то все различия по "
"регистру удаляются из алфавита. Когда буква присутствует в различных "
"регистрах вне квадратных скобок, то она трансформируется в выражение в "
"квадратных скобках, содержащее оба регистра, например, \\(aqx\\(aq становится "
"«I<[xX]>». Если буква уже заключена в скобки, то к ней добавляется и другой "
"регистр, например, «I<[x]>» становится «I<[xX]>» , а «I<[^x]>» превращается в "
"«I<[^xX]>»."

#. type: Plain text
#: man-pages/man7/regex.7:236
msgid ""
"No particular limit is imposed on the length of REs\\*(dg.  Programs "
"intended to be portable should not employ REs longer than 256 bytes, as an "
"implementation can refuse to accept such REs and remain POSIX-compliant."
msgstr ""
"Конкретного ограничения длины РВ\\*(dg не существует. Однако, в переносимых "
"программах не следует использовать РВ более 256 байтов, так как реализация "
"может не принимать таких РВ, но оставаться соответствующей POSIX."

#. type: Plain text
#: man-pages/man7/regex.7:252
msgid ""
"Obsolete (\"basic\") regular expressions differ in several respects.  "
"\\(aq|\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq are ordinary characters and there "
"is no equivalent for their functionality.  The delimiters for bounds are "
"\"I<\\e{>\" and \"I<\\e}>\", with \\(aq{\\(aq and \\(aq}\\(aq by themselves "
"ordinary characters.  The parentheses for nested subexpressions are "
"\"I<\\e(>\" and \"I<\\e)>\", with \\(aq(\\(aq and \\(aq)\\(aq by themselves "
"ordinary characters.  \\(aq^\\(aq is an ordinary character except at the "
"beginning of the RE or\\*(dg the beginning of a parenthesized subexpression,"
" \\(aq$\\(aq is an ordinary character except at the end of the RE or\\*(dg "
"the end of a parenthesized subexpression, and \\(aq*\\(aq is an ordinary "
"character if it appears at the beginning of the RE or the beginning of a "
"parenthesized subexpression (after a possible leading \\(aq^\\(aq)."
msgstr ""
"Устаревшие («основные») РВ отличаются по нескольким аспектам. Символы "
"\\(aq|\\(aq, \\(aq+\\(aq и \\(aq?\\(aq считаются обычными символами. Для "
"обозначения границ интервалов используются «I<\\e{>» и «I<\\e}>», а "
"\\(aq{\\(aq и \\(aq}\\(aq сами по себе являются обычными символами. Для "
"обособления подвыражений используются «I<\\e(>» и «I<\\e)>», а \\(aq(\\(aq и "
"\\(aq)\\(aq сами по себе являются обычными символами. Символ \\(aq^\\(aq "
"является обычным символом за исключением того случая, когда он стоит в начале "
"РВ или\\*(dg в начале подвыражения в круглых скобках; символ \\(aq$\\(aq "
"является обычным символом, кроме того случая, когда он стоит в конце РВ "
"или\\*(dg в конце подвыражения в круглых скобках; символ \\(aq*\\(aq является "
"обычным, если он стоит в начале РВ или в начале подвыражения в круглых "
"скобках (возможно, после символа \\(aq^\\(aq в самом начале)."

#. type: Plain text
#: man-pages/man7/regex.7:260
msgid ""
"Finally, there is one new type of atom, a I<back reference>: \\(aq\\e\\(aq "
"followed by a nonzero decimal digit I<d> matches the same sequence of "
"characters matched by the I<d>th parenthesized subexpression (numbering "
"subexpressions by the positions of their opening parentheses, left to "
"right), so that, for example, \"I<\\e([bc]\\e)\\e1>\" matches \"bb\" or "
"\"cc\" but not \"bc\"."
msgstr ""
"Кроме этого, существует ещё один тип атома — I<обратная ссылка>: "
"\\(aq\\e\\(aq с последующей за ней ненулевой десятичной цифрой I<d> "
"соответствует той самой последовательности, что и I<d>-е подвыражение в "
"скобках (нумерация подвыражений считается по их открывающим круглым скобкам, "
"слева направо). Пример: «I<\\e([bc]\\e)\\e1>» соответствует «bb» или «cc», но "
"не «bc»."

#. type: Plain text
#: man-pages/man7/regex.7:262
msgid "Having two kinds of REs is a botch."
msgstr "Наличие двух видов РВ — вынужденная мера."

#. type: Plain text
#: man-pages/man7/regex.7:268
msgid ""
"The current POSIX.2 spec says that \\(aq)\\(aq is an ordinary character in "
"the absence of an unmatched \\(aq(\\(aq; this was an unintentional result of"
" a wording error, and change is likely.  Avoid relying on it."
msgstr ""
"В имеющейся на данный момент документации POSIX.2 указано, что символ "
"\\(aq)\\(aq при отсутствии \\(aq(\\(aq; считается обычным; это "
"непреднамеренная опечатка, которая будет исправлена. Не полагайтесь на это."

#. type: Plain text
#: man-pages/man7/regex.7:275
msgid ""
"Back references are a dreadful botch, posing major problems for efficient "
"implementations.  They are also somewhat vaguely defined (does "
"\"I<a\\e(\\e(b\\e)*\\e2\\e)*d>\" match \"abbbd\"?).  Avoid using them."
msgstr ""
"Обратные ссылки — также вынужденная мера, вызывают серьёзные проблемы "
"эффективности в реализациях. Также они не имеют подробного определения "
"(например, «I<a\\e(\\e(b\\e)*\\e2\\e)*d>» соответствует «abbbd»?)."

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  The syntax for word boundaries is incredibly ugly.
#. type: Plain text
#: man-pages/man7/regex.7:283
msgid ""
"POSIX.2's specification of case-independent matching is vague.  The \"one "
"case implies all cases\" definition given above is current consensus among "
"implementors as to the right interpretation."
msgstr ""
"Определение в POSIX.2 совпадения при отключении учёта регистра тоже очень "
"туманное. Определение типа «один регистр замещает все остальные», по мнению "
"некоторых специалистов, не является правильным."

#. type: SH
#: man-pages/man7/regex.7:283
#, no-wrap
msgid "AUTHOR"
msgstr "АВТОР"

#.  Sigh... The page license means we must have the author's name
#.  in the formatted output.
#. type: Plain text
#: man-pages/man7/regex.7:287
msgid "This page was taken from Henry Spencer's regex package."
msgstr ""
"Эта страница взята из пакета regex, написанного Генри Спенсером (Henry "
"Spencer)."

#. type: Plain text
#: man-pages/man7/regex.7:290
msgid "B<grep>(1), B<regex>(3)"
msgstr "B<grep>(1), B<regex>(3)"

#. type: Plain text
#: man-pages/man7/regex.7:291
msgid "POSIX.2, section 2.8 (Regular Expression Notation)."
msgstr "POSIX.2, раздел 2.8 (запись регулярных выражений)."

#. type: TH
#: man-pages/man7/rtld-audit.7:28
#, no-wrap
msgid "RTLD-AUDIT"
msgstr "RTLD-AUDIT"

#. type: TH
#: man-pages/man7/rtld-audit.7:28
#, no-wrap
msgid "2012-07-07"
msgstr "2012-07-07"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:31
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""
"rtld-audit - программный интерфейс слежения за динамическим компоновщиком"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:35
msgid "B<#include E<lt>link.hE<gt>>"
msgstr "B<#include E<lt>link.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:43
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined"
" by including I<E<lt>link.hE<gt>>."
msgstr ""
"Динамический компоновщик GNU (компоновщик времени выполнения) предоставляет "
"API слежения, который позволяет приложению получать уведомления о различных "
"событиях динамической компоновки. Данный API очень похож на интерфейс "
"слежения, предоставляемый компоновщиком времени выполнения из Solaris. "
"Необходимые константы и прототипы определены в I<E<lt>link.hE<gt>>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:50
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""
"Чтобы использовать этот интерфейс, программист создаёт общую библиотеку "
"функций со стандартизованными именами. Не все функции нужно реализовывать: в "
"большинстве случаев, если программист не заинтересован в конкретном классе "
"отслеживаемых событий, то нет нужды в создании соответствующей отслеживающей "
"функции."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:58
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""
"Для применения интерфейса слежения переменная окружения B<LD_AUDIT> должна "
"содержать разделённый двоеточиями список общих библиотек, каждая из которых "
"может реализовывать (частично) API слежения. Когда возникает отслеживаемое "
"событие, из каждой библиотеки вызывается соответствующая функция в том "
"порядке, в котором эти библиотеки были перечислены."

#. type: SS
#: man-pages/man7/rtld-audit.7:58
#, no-wrap
msgid "la_version()"
msgstr "la_version()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:62
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr "B<unsigned int la_version(unsigned int >I<version>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:74
msgid ""
"This is the only function that I<must> be defined by an auditing library: it"
" performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports.  If necessary, the auditing library can check that this version is"
" sufficient for its requirements."
msgstr ""
"Это единственная функция, которая I<должна> быть определена в отслеживающей "
"библиотеке: она осуществляет первичную связь между динамическим компоновщиком "
"и отслеживающей библиотекой. При вызове этой функции динамический компоновщик "
"передаёт в I<version> максимальную версию интерфейса слежения, которую "
"поддерживает сам компоновщик. При необходимости, отслеживающая библиотека "
"может проверить, что эта версия удовлетворяет её требованиям."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:83
msgid ""
"As its function result, this function should return the version of the "
"auditing interface that this auditing library expects to use (returning "
"I<version> is acceptable).  If the returned value is 0, or a version that is"
" greater than that supported by the dynamic linker, then the audit library "
"is ignored."
msgstr ""
"Данная функция должна возвращать версию интерфейса слежения, которую "
"отслеживающая библиотека собирается использовать (возврат I<version> "
"приемлем). Если возвращаемое значение равно 0 или больше чем максимальная "
"версия, поддерживаемая динамическим компоновщиком, то отслеживающая "
"библиотека игнорируется."

#. type: SS
#: man-pages/man7/rtld-audit.7:83
#, no-wrap
msgid "la_objsearch()"
msgstr "la_objsearch()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:88
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\nB<    "
"               unsigned int >I<flag>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:99
msgid ""
"The dynamic linker invokes this function to inform the auditing library that"
" it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""
"Динамический компоновщик вызывает эту функцию для информирования "
"отслеживающей библиотеки при поиске общего объекта. Аргумент I<name> содержит "
"имя файла или путь, который будет разыскиваться. В I<cookie> указывается "
"общий объект, который начал поиск. Аргумент I<flag> устанавливается в одно из "
"следующих значений:"

#. type: TP
#: man-pages/man7/rtld-audit.7:99
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr "B<LA_SER_ORIG>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:108
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""
"Это оригинальное имя, которое будет разыскиваться. Как правило, это имя "
"хранится в записи ELF B<DT_NEEDED> или был передан в аргументе I<filename> "
"при вызове B<dlopen>(3)."

#. type: TP
#: man-pages/man7/rtld-audit.7:108
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr "B<LA_SER_LIBPATH>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:113
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""
"Значение I<name> было создано с использованием каталога из B<LD_LIBRARY_PATH>."

#. type: TP
#: man-pages/man7/rtld-audit.7:113
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr "B<LA_SER_RUNPATH>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:121
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""
"Значение I<name> было создано с использованием каталога из списка ELF B<"
"DT_RPATH> или B<DT_RUNPATH>."

#. type: TP
#: man-pages/man7/rtld-audit.7:121
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr "B<LA_SER_CONFIG>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:128
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""
"Значение I<name> было найдено в кэше B<ldconfig>(8) (I</etc/ld.so.cache>)."

#. type: TP
#: man-pages/man7/rtld-audit.7:128
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr "B<LA_SER_DEFAULT>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:132
msgid "I<name> was found via a search of one of the default directories."
msgstr ""
"Значение I<name> было найдено при поиске в одном из каталогов по умолчанию."

#. type: TP
#: man-pages/man7/rtld-audit.7:132
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr "B<LA_SER_SECURE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:136
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""
"Значение I<name> относится к объекту безопасности (не используется в Linux)."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:145
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then"
" this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""
"Функция B<la_objsearch>() возвращает путь, который динамический компоновщик "
"должен использовать в дальнейшей работе. Если возвращается NULL, то путь "
"игнорируется в дальнейшей работе. Если данная отслеживающая библиотека "
"создана для простого слежения за путями поиска, то должно возвращаться I<name>"
"."

#. type: SS
#: man-pages/man7/rtld-audit.7:145
#, no-wrap
msgid "la_activity()"
msgstr "la_activity()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:149
#, no-wrap
msgid ""
"B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr ""
"B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:158
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head"
" of the link map.  When the dynamic linker invokes this function, I<flag> is"
" set to one of the following values:"
msgstr ""
"Динамический компоновщик вызывает эту функцию для информирования библиотеки "
"слежения о выполнении действия с картой ссылок (link-map). В I<cookie> "
"задаётся объект, находящийся в начале карты ссылок. Когда динамический "
"компоновщик вызывает эту функцию, аргумент I<flag> устанавливается в одно из "
"следующих значений:"

#. type: TP
#: man-pages/man7/rtld-audit.7:158
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr "B<LA_ACT_ADD>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:161
msgid "New objects are being added to the link map."
msgstr "В карту ссылок добавляется новый объект."

#. type: TP
#: man-pages/man7/rtld-audit.7:161
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr "B<LA_ACT_DELETE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:164
msgid "Objects are being removed from the link map."
msgstr "Из карты ссылок удаляется объект."

#. type: TP
#: man-pages/man7/rtld-audit.7:164
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr "B<LA_ACT_CONSISTENT>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:167
msgid "Link-map activity has been completed: the map is once again consistent."
msgstr ""
"Действие с картой ссылок завершено: карта снова корректна (consistent)."

#. type: SS
#: man-pages/man7/rtld-audit.7:167
#, no-wrap
msgid "la_objopen()"
msgstr "la_objopen()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:172
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\nB< "
"                       uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:181
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""
"Динамический компоновщик вызывает эту функцию при загрузке нового общего "
"объекта. Аргумент I<map> является указателем на структуру карты ссылок "
"(link-map), которая описывает объект. Поле I<lmid> устанавливается в одно из "
"следующих значений:"

#. type: TP
#: man-pages/man7/rtld-audit.7:181
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr "B<LM_ID_BASE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:184
msgid "Link map is part of the initial namespace."
msgstr "Карта ссылок является частью начального пространства имён (namespace)."

#. type: TP
#: man-pages/man7/rtld-audit.7:184
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr "B<LM_ID_NEWLM>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:188
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""
"Карта ссылок является частью нового пространства имён, запрошенного через B<"
"dlmopen>(3)."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:196
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""
"Аргумент I<cookie> — указатель на идентификатор этого объекта. Идентификатор "
"используется при последующих вызовах функций отслеживающей библиотеки для "
"идентификации этого объекта. Данный идентификатор инициализируется указателем "
"на карту ссылок объекта, но отслеживающая библиотека может изменить "
"идентификатор на другое значение, которое ей удобней использовать для "
"обращения к объекту."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:203
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to"
" select the objects to be monitored by B<la_symbind*>():"
msgstr ""
"Функция B<la_objopen>() возвращает битовую маску, созданное с помощью "
"сложения (OR) нуля или более следующих констант, которые позволяют "
"отслеживающей библиотеке выбирать наблюдаемые объекты через B<la_symbind*>():"

#. type: TP
#: man-pages/man7/rtld-audit.7:203
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr "B<LA_FLG_BINDTO>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:206
msgid "Audit symbol bindings to this object."
msgstr "Следить за символьными привязками этого объекта."

#. type: TP
#: man-pages/man7/rtld-audit.7:206
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr "B<LA_FLG_BINDFROM>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:209
msgid "Audit symbol bindings from this object."
msgstr "Следить за символьными привязками из этого объекта."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:213
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""
"Возвращаемое значение 0 из B<la_objopen>() указывает на то, что не нужно "
"отслеживать символьные привязки этого объекта."

#. type: SS
#: man-pages/man7/rtld-audit.7:213
#, no-wrap
msgid "la_objclose()"
msgstr "la_objclose()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:217
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"
msgstr "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:226
msgid ""
"The dynamic linker invokes this function after any finalization code for the"
" object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""
"Динамический компоновщик вызывает эту функцию после выполнения конечного кода "
"(finalization code), но до выгрузки объекта. В I<cookie> задаётся "
"идентификатор, полученный ранее из вызова B<la_objopen>()."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:230
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""
"В текущей реализации значение, возвращаемое B<la_objclose>(), игнорируется."

#. type: SS
#: man-pages/man7/rtld-audit.7:230
#, no-wrap
msgid "la_preinit()"
msgstr "la_preinit()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:234
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:244
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""
"Динамический компоновщик вызывает эту функцию после загрузки всех общих "
"объектов, но до передачи управления приложению (то есть, до вызова I<main>"
"()). Заметим, что I<main>() позднее всё ещё может динамически загрузить "
"объекты с помощью B<dlopen>(3)."

#. type: SS
#: man-pages/man7/rtld-audit.7:244
#, no-wrap
msgid "la_symbind*()"
msgstr "la_symbind*()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:253
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>"
"\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<"
");>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>"
"\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<"
");>\n"
msgstr ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\nB<   "
"                    uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\nB<  "
"                     unsigned int *>I<flags>B<, const char *>I<symname>B<);>"
"\nB<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\nB< "
"                      uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>"
"\nB<                       unsigned int *>I<flags>B<, const char *>I<symname>"
"B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:265
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on"
" 64-bit platforms."
msgstr ""
"Динамический компоновщик вызывает одну из этих функций при выполнении "
"символьной привязки между двумя общими объектами, которые были помечены для "
"уведомления функцией B<la_objopen>(). Функция B<la_symbind32>() применяется "
"на 32-битных платформах; B<la_symbind64>() применяется на 64-битных "
"платформах."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:275
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""
"Аргумент I<sym> является указателем на структуру, которая содержит информацию "
"о привязываемом символе. Определение структуры находится в I<E<lt>elf.hE<gt>>"
". Среди полей структуры есть поле I<st_value>, которое содержит адрес "
"привязываемого символа."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:280
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the"
" bound shared object."
msgstr ""
"В аргументе I<ndx> указывается индекс символа в таблице символов "
"привязываемого общего объекта."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:295
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""
"В аргументе I<refcook> указывается общий объект, который ссылается на символ; "
"это тот же идентификатор, который указывается в функции B<la_objopen>(), "
"возвращающей B<LA_FLG_BINDFROM>. В аргументе I<defcook> указывается общий "
"объект, который определяет символ, на который производится ссылка; это тот же "
"идентификатор, который указывается в функции B<la_objopen>(), возвращающей  "
"B<LA_FLG_BINDTO>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:299
msgid ""
"The I<symname> argument points a string containing the name of the symbol."
msgstr "В аргументе I<symname> задаётся строка, содержащая имя символа."

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: man-pages/man7/rtld-audit.7:307
msgid ""
"The I<flags> argument is a bit mask that both provides information about the"
" symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""
"Аргумент I<flags> представляет собой битовую маску, которая содержит "
"информацию о символе и может использоваться для изменения дальнейшего "
"отслеживания этой записи PLT (Procedure Linkage Table). Динамический "
"компоновщик может передавать следующие битовые значения в этом аргументе:"

#. type: TP
#: man-pages/man7/rtld-audit.7:307
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr "B<LA_SYMB_DLSYM>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:311
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr "Привязка возникла из-за вызова B<dlsym>(3)."

#. type: TP
#: man-pages/man7/rtld-audit.7:311
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr "B<LA_SYMB_ALTVALUE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:316
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""
"Предыдущий вызов B<la_symbind*>() вернул альтернативное значение для этого "
"символа."

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: man-pages/man7/rtld-audit.7:330
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced."
"  The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""
"По умолчанию, если в отслеживающей библиотеке реализованы функции B<"
"la_pltenter>() и B<la_pltexit>() (смотрите ниже), то эти функции вызываются "
"после B<la_symbind>() для записей PLT каждый раз при ссылке на символ. "
"Следующие флаги могут объединяться с помощью OR в I<*flags> для изменения "
"данного поведения по умолчанию:"

#. type: TP
#: man-pages/man7/rtld-audit.7:330
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr "B<LA_SYMB_NOPLTENTER>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:335
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr "Не вызывать B<la_pltenter>() для этого символа."

#. type: TP
#: man-pages/man7/rtld-audit.7:335
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr "B<LA_SYMB_NOPLTEXIT>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:340
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr "Не вызывать B<la_pltexit>() для этого символа."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:351
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address"
" to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return"
" I<sym-E<gt>st_value>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""
"Возвращаемое значение B<la_symbind32>() и B<la_symbind64>() представляет "
"собой адрес, по которому нужно передать управление после возврата функций. "
"Если отслеживающая библиотека просто наблюдает за привязкой символов, то "
"должно возвращаться I<sym-E<gt>st_value>. Может возвращаться другое значение, "
"если библиотека хочет передать управление в другое место."

#. type: SS
#: man-pages/man7/rtld-audit.7:351
#, no-wrap
msgid "la_pltenter()"
msgstr "la_pltenter()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:357 man-pages/man7/rtld-audit.7:417
msgid ""
"The precise name and argument types for this function depend on the hardware"
" platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)"
"  Here is the definition for x86-32:"
msgstr ""
"Точное имя и типы аргументов данной функции зависят от аппаратной платформы "
"(подходящее определение приведено в I<E<lt>link.hE<gt>>). Ниже показано "
"определение для x86-32:"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:363
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<"
",>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long int *>I<framesizep>B<);>\n"
msgstr ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<"
",>\nB<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>"
"\nB<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\nB< "
"                const char *>I<symname>B<, long int *>I<framesizep>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:367
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""
"Эта функция вызывается до вызова записи PLT между двумя общими объектами, "
"которые помечены для уведомления о привязке."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:377 man-pages/man7/rtld-audit.7:440
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""
"Значение аргументов I<sym>, I<ndx>, I<refcook>, I<defcook> и I<symname> такое "
"же как у B<la_symbind*>()."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:384
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)"
"  containing the values of registers to be used for the call to this PLT "
"entry."
msgstr ""
"Аргумент I<regs> указывает на структуру (определена в I<E<lt>link.hE<gt>>), "
"содержащую значения регистров, которые будут использованы для вызова этой "
"записи PLT."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:390
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""
"Аргумент I<flags> указывает на битовую маску, которая сообщает информацию и "
"может использоваться для изменения последующего слежения за этой записью PLT; "
"значения как у B<la_symbind*>()."

#.  FIXME is the following correct?
#. type: Plain text
#: man-pages/man7/rtld-audit.7:406
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used"
" to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltenter>()  "
"function is called only if this buffer is explicitly set to a suitable "
"value."
msgstr ""
"Аргумент I<framesizep> указывает на буфер I<long\\ int>, который можно "
"использовать для явного определения размера фрейма, используемого для вызова "
"этой записи PLT. Если другие вызовы B<la_pltenter>() для этого символа "
"возвращают другие значения, то используется максимальное полученное значение. "
"Функция B<la_pltenter>() вызывается только, если этот буфер явно "
"устанавливает подходящее значение."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:411
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr "Возвращаемое B<la_pltenter>() значение подобно B<la_symbind*>()."

#. type: SS
#: man-pages/man7/rtld-audit.7:411
#, no-wrap
msgid "la_pltexit()"
msgstr "la_pltexit()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:423
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>"
"B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>"
"B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>"
"B<,>\nB<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>"
"\nB<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<"
"outregs>B<,>\nB<                 const char *>I<symname>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:430
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""
"Эта функция вызывается после завершения вызова записи PLT, выполняемой между "
"двумя общими объектами, которые были помечены для уведомления при привязке. "
"Функция вызывается перед передачей управления из записи PLT вызывающему."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:453
msgid ""
"The I<inregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing the values of registers used for the call "
"to this PLT entry.  The I<outregs> argument points to a structure (defined "
"in I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""
"Аргумент I<inregs> указывает на структуру (определена в I<E<lt>link.hE<gt>>), "
"содержащую значения регистров, используемых для вызова этой записи PLT. "
"Аргумент I<outregs> указывает на структуру (определена в I<E<lt>link.hE<gt>>"
"), содержащую значения для вызова в эту запись PLT. Эти значения могут "
"изменяться вызывающим и изменения будут видимы вызывающему запись PLT."

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: man-pages/man7/rtld-audit.7:461
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""
"В текущей реализации GNU возвращаемое значение B<la_pltexit>() игнорируется."

#. type: SH
#: man-pages/man7/rtld-audit.7:461
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:467
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""
"Данный API не стандартен, но очень похож на Solaris API, описанный в Solaris "
"I<Linker and Libraries Guide> в главе I<Runtime Linker Auditing Interface>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:470
msgid ""
"Note the following differences from the Solaris dynamic linker auditing API:"
msgstr "Отметим следующие отличия API динамического компоновщика в Solaris:"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:474
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""
"Интерфейс Solaris B<la_objfilter>() не поддерживается в реализации GNU."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:482
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide"
" a I<symname> argument."
msgstr ""
"В функциях Solaris B<la_symbind32>() и B<la_pltexit>() нет аргумента I<"
"symname>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:492
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""
"В функции Solaris B<la_pltexit>() нет аргументов I<inregs> и I<outregs> (но "
"есть аргумент I<retval> со значением, возвращаемым функцией)."

#.  FIXME Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: man-pages/man7/rtld-audit.7:502
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""
"В glibc до версии 2.9 включительно, указание более одной отслеживающей "
"библиотеки в B<LD_AUDIT> приводит к падению во время выполнения. Это "
"исправлено в glibc 2.10."

#. type: SH
#: man-pages/man7/rtld-audit.7:502
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:506
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>link.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:511
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): %d\\en\", version);\n"
msgstr ""
"unsigned int\nla_version(unsigned int version)\n{\n    printf(\"la_version(): "
"%d\\en\", version);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:514
#, no-wrap
msgid ""
"    return version;\n"
"}\n"
msgstr "    return version;\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:527
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %x\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""
"char *\nla_objsearch(const char *name, uintptr_t *cookie, unsigned int "
"flag)\n{\n    printf(\"la_objsearch(): name = %s; cookie = %x\", name, "
"cookie);\n    printf(\"; flag = %s\\en\",\n            (flag == LA_SER_ORIG) "
"?    \"LA_SER_ORIG\" :\n            (flag == LA_SER_LIBPATH) ? "
"\"LA_SER_LIBPATH\" :\n            (flag == LA_SER_RUNPATH) ? "
"\"LA_SER_RUNPATH\" :\n            (flag == LA_SER_DEFAULT) ? "
"\"LA_SER_DEFAULT\" :\n            (flag == LA_SER_CONFIG) ?  "
"\"LA_SER_CONFIG\" :\n            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" "
":\n            \"???\");\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:530
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr "    return name;\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:540
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %x; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""
"void\nla_activity (uintptr_t *cookie, unsigned int flag)\n{\n    "
"printf(\"la_activity(): cookie = %x; flag = %s\\en\", cookie,\n            "
"(flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n            (flag == "
"LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n            (flag == LA_ACT_DELETE) ?  "
"   \"LA_ACT_DELETE\" :\n            \"???\");\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:550
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%x\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""
"unsigned int\nla_objopen(struct link_map *map, Lmid_t lmid, uintptr_t "
"*cookie)\n{\n    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; "
"cookie=%x\\en\",\n            map-E<gt>l_name,\n            (lmid == "
"LM_ID_BASE) ?  \"LM_ID_BASE\" :\n            (lmid == LM_ID_NEWLM) ? "
"\"LM_ID_NEWLM\" :\n            \"???\",\n            cookie);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:553
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr "    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:558
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %x\\en\", cookie);\n"
msgstr ""
"unsigned int\nla_objclose (uintptr_t *cookie)\n{\n    printf(\"la_objclose(): "
"%x\\en\", cookie);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:561
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr "    return 0;\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:567
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %x\\en\", cookie);\n"
"}\n"
msgstr ""
"void\nla_preinit(uintptr_t *cookie)\n{\n    printf(\"la_preinit(): %x\\en\", "
"cookie);\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:576
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %x; defcook = %x\\en\", refcook, defcook);\n"
msgstr ""
"uintptr_t\nla_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t "
"*refcook,\n        uintptr_t *defcook, unsigned int *flags, const char "
"*symname)\n{\n    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %"
"p\\en\",\n            symname, sym-E<gt>st_value);\n    printf(\"        ndx "
"= %d; flags = 0x%x\", ndx, *flags);\n    printf(\"; refcook = %x; defcook = %"
"x\\en\", refcook, defcook);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:579 man-pages/man7/rtld-audit.7:591
#: man-pages/man7/rtld-audit.7:601
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr "    return sym-E<gt>st_value;\n}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:588
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %x; defcook = %x\\en\", refcook, defcook);\n"
msgstr ""
"uintptr_t\nla_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t "
"*refcook,\n        uintptr_t *defcook, unsigned int *flags, const char "
"*symname)\n{\n    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %"
"p\\en\",\n            symname, sym-E<gt>st_value);\n    printf(\"        ndx "
"= %d; flags = 0x%x\", ndx, *flags);\n    printf(\"; refcook = %x; defcook = %"
"x\\en\", refcook, defcook);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:598
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long int *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>"
"st_value);\n"
msgstr ""
"Elf32_Addr\nla_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n        "
"uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n        unsigned "
"int *flags, const char *symname, long int *framesizep)\n{\n    "
"printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:606
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: man-pages/man7/raw.7:13
#, no-wrap
msgid "RAW"
msgstr "RAW"

#. type: TH
#: man-pages/man7/raw.7:13
#, no-wrap
msgid "2012-05-10"
msgstr "2012-05-10"

#. type: Plain text
#: man-pages/man7/raw.7:16
msgid "raw - Linux IPv4 raw sockets"
msgstr "raw - неструктурированные сокеты IPv4 в Linux"

#. type: Plain text
#: man-pages/man7/raw.7:20
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr "B<#include E<lt>netinet/in.hE<gt>>"

#. type: Plain text
#: man-pages/man7/raw.7:22
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"

#. type: Plain text
#: man-pages/man7/raw.7:26
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw"
" socket receives or sends the raw datagram not including link level headers."
msgstr ""
"Неструктурированные (raw) сокеты позволяют реализовать новые протоколы IPv4 в "
"пространстве пользователя. Через неструктурированный сокет получают или "
"посылают необработанные датаграммы, не включающие в себя заголовки уровня "
"соединения (link level)."

#. type: Plain text
#: man-pages/man7/raw.7:32
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving the IP header is always"
" included in the packet."
msgstr ""
"Уровень IPv4 генерирует заголовок IP при посылке пакета, если только для "
"сокета не включён параметр B<IP_HDRINCL>. Если он включён, то пакет должен "
"содержать заголовок IP. Принимаемые пакеты всегда содержат заголовок IP."

#. type: Plain text
#: man-pages/man7/raw.7:36
msgid ""
"Only processes with an effective user ID of 0 or the B<CAP_NET_RAW> "
"capability are allowed to open raw sockets."
msgstr ""
"Открывать неструктурированные сокеты могут только процессы с идентификатором "
"эффективного пользователя, равным 0, или имеющие мандат B<CAP_NET_RAW>."

#. type: Plain text
#: man-pages/man7/raw.7:43
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols see "
"RFC\\ 1700 assigned numbers and B<getprotobyname>(3)."
msgstr ""
"Все пакеты или ошибки, совпадающие с номером протокола I<protocol>, указанным "
"неструктурированному сокету, передаются этому сокету. Список возможных "
"протоколов и назначенных им номеров указан в RFC\\ 1700 и в B<getprotobyname>"
"(3)."

#. type: Plain text
#: man-pages/man7/raw.7:53
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""
"Протокол B<IPPROTO_RAW> подразумевает включённый параметр B<IP_HDRINCL> и "
"позволяет отправлять любой протокол IP, который указан в передаваемом "
"заголовке. Приём любых протоколов IP посредством B<IPPROTO_RAW> через "
"неструктурированные сокеты невозможен."

#. type: tbl table
#: man-pages/man7/raw.7:58
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>\n"
msgstr "Поля заголовка IP, изменяемые B<IP_HDRINCL> при передаче\n"

#. type: tbl table
#: man-pages/man7/raw.7:59
#, no-wrap
msgid "IP Checksum:Always filled in.\n"
msgstr "IP Checksum:всегда заполняется\n"

#. type: tbl table
#: man-pages/man7/raw.7:60
#, no-wrap
msgid "Source Address:Filled in when zero.\n"
msgstr "Source Address:заполняется, если значение равно нулю\n"

#. type: tbl table
#: man-pages/man7/raw.7:61
#, no-wrap
msgid "Packet Id:Filled in when zero.\n"
msgstr "Packet Id:заполняется, если значение равно нулю\n"

#. type: tbl table
#: man-pages/man7/raw.7:62
#, no-wrap
msgid "Total Length:Always filled in.\n"
msgstr "Total Length:всегда заполняется\n"

#. type: Plain text
#: man-pages/man7/raw.7:76
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address, then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""
"Если указан B<IP_HDRINCL> и заголовок IP имеет ненулевой адрес назначения, то "
"для маршрутизации пакета используется адрес назначения сокета. Если указан B<"
"MSG_DONTROUTE>, то адрес назначения должен ссылаться на локальный интерфейс, "
"иначе в любом случае будет производиться поиск в таблице маршрутизации, но "
"маршруты со шлюзами будут игнорироваться."

#. type: Plain text
#: man-pages/man7/raw.7:84
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets"
" with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""
"Если B<IP_HDRINCL> не указан, то параметры заголовка IP в неструктурированных "
"сокетах могут быть установлены с помощью B<setsockopt>(2); более подробная "
"информация приведена в B<ip>(7)."

#. type: Plain text
#: man-pages/man7/raw.7:89
msgid ""
"In Linux 2.2, all IP header fields and options can be set using IP socket "
"options.  This means raw sockets are usually needed only for new protocols "
"or protocols with no user interface (like ICMP)."
msgstr ""
"В Linux 2.2 все поля заголовка IP и параметры могут быть заданы с помощью "
"параметров сокета IP. Это означает, что неструктурированные сокеты, как "
"правило, необходимы лишь для новых протоколов или протоколов без интерфейса "
"пользователя (например, ICMP)."

#. type: Plain text
#: man-pages/man7/raw.7:93
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""
"Принятый пакет передаётся всем подключенным (bound) к этому протоколу "
"неструктурированным сокетам до того, как он будет передан другим обработчикам "
"протоколов (например, протокольным модулям ядра)."

#. type: SS
#: man-pages/man7/raw.7:93
#, no-wrap
msgid "Address format"
msgstr "Формат адреса"

#. type: Plain text
#: man-pages/man7/raw.7:109
msgid ""
"Raw sockets use the standard I<sockaddr_in> address structure defined in "
"B<ip>(7).  The I<sin_port> field could be used to specify the IP protocol "
"number, but it is ignored for sending in Linux 2.2 and should be always set "
"to 0 (see BUGS).  For incoming packets, I<sin_port> is set to the protocol "
"of the packet.  See the I<E<lt>netinet/in.hE<gt>> include file for valid IP "
"protocols."
msgstr ""
"Неструктурированные сокеты используют стандартную адресную структуру I<"
"sockaddr_in>, определённую в B<ip>(7). Поле I<sin_port> может быть "
"использовано для указания номера протокола IP, но в Linux 2.2 при отправке "
"оно игнорируется и всегда должно быть равно нулю (смотрите ДЕФЕКТЫ). У "
"входящих пакетов значение I<sin_port> равно номеру протокола пакета. "
"Возможные протоколы IP описаны в файле I<E<lt>netinet/in.hE<gt>>."

#. type: SS
#: man-pages/man7/raw.7:109
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокета"

#.  Or SOL_RAW on Linux
#. type: Plain text
#: man-pages/man7/raw.7:118
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""
"Параметры неструктурированных сокетов могут быть установлены с помощью B<"
"setsockopt>(2) и прочитаны с помощью B<getsockopt>(2) с указанием флага "
"семейства B<IPPROTO_RAW>."

#. type: TP
#: man-pages/man7/raw.7:118
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr "B<ICMP_FILTER>"

#. type: Plain text
#: man-pages/man7/raw.7:126
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""
"Запускает специальный фильтр для неструктурированных сокетов, подключенных к "
"протоколу B<IPPROTO_ICMP>. Значение представляет собой набор бит — по "
"установленному биту для каждого типа сообщений ICMP, который должен быть "
"отфильтрован. По умолчанию сообщения ICMP не фильтруются."

#. type: Plain text
#: man-pages/man7/raw.7:131
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""
"Кроме этого, поддерживаются все датаграммные параметры сокетов B<ip>(7) для "
"B<IPPROTO_IP>."

#. type: SS
#: man-pages/man7/raw.7:131
#, no-wrap
msgid "Error handling"
msgstr "Обработка ошибок"

#. type: Plain text
#: man-pages/man7/raw.7:144
msgid ""
"Errors originating from the network are passed to the user only when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""
"Ошибки, возникающие в сети, передаются пользователю только, если сокет "
"подключён или установлен флаг B<IP_RECVERR>. В целях совместимости в "
"подключенные сокеты передаются только B<EMSGSIZE> и B<EPROTO>. При указании "
"B<IP_RECVERR> в очереди ошибок сохраняются все сетевые ошибки."

#. type: SH
#: man-pages/man7/raw.7:144
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/raw.7:145
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man7/raw.7:149
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""
"Пользователь попытался передать пакет по широковещательному адресу без "
"указания на сокете флага широковещательной передачи."

#. type: TP
#: man-pages/man7/raw.7:149
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man7/raw.7:152
msgid "An invalid memory address was supplied."
msgstr "Указан неправильный адрес памяти."

#. type: TP
#: man-pages/man7/raw.7:152
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/raw.7:155
msgid "Invalid argument."
msgstr "Hеверный аргумент."

#. type: TP
#: man-pages/man7/raw.7:155
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man7/raw.7:162
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64KB."
msgstr ""
"Размер пакета слишком велик, либо включён Path MTU Discovery (флаг сокета B<"
"IP_PMTU_DISCOVER>), либо размер пакета превышает максимально разрешенный для "
"IPv4 размер, равный 64КБ."

#. type: TP
#: man-pages/man7/raw.7:162
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man7/raw.7:166
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr "Сокетному вызову был передан неверный флаг (например, B<MSG_OOB>)."

#. type: TP
#: man-pages/man7/raw.7:166
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man7/raw.7:172
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""
"Пользователь не имеет прав на открытие неструктурированных сокетов. Это могут "
"делать только процессы с идентификатором эффективного пользователя равным 0, "
"или имеющие мандат B<CAP_NET_RAW>."

#. type: TP
#: man-pages/man7/raw.7:172
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: man-pages/man7/raw.7:175
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr "Получена ошибка ICMP, сообщающая о проблеме с параметром."

#. type: Plain text
#: man-pages/man7/raw.7:181
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""
"Значения B<IP_RECVERR> и B<ICMP_FILTER> появились в Linux 2.2. Они являются "
"расширениями Linux и не должны использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man7/raw.7:187
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set \\(em since Linux 2.2, "
"this option no longer has that effect."
msgstr ""
"Код неструктурированных сокетов в версии Linux 2.0 при установленном "
"параметре B<SO_BSDCOMPAT> был специально сделан совместимым с BSD «вплоть до "
"ошибок». Из Linux 2.2 это было удалено."

#. type: Plain text
#: man-pages/man7/raw.7:205
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"По умолчанию, для неструктурированных сокетов выполняется обнаружение MTU "
"(Maximum Transmission Unit) пути. Это означает, что ядро будет следить за MTU "
"до IP-адреса назначения и возвращать B<EMSGSIZE>, если запись "
"неструктурированного пакета превысит это значение. Когда это происходит, "
"приложение должно уменьшить размер пакета. Также обнаружение MTU пути можно "
"выключить с помощью параметра сокета B<IP_MTU_DISCOVER> или в файле I<"
"/proc/sys/net/ipv4/ip_no_pmtu_disc>; подробней смотрите в B<ip>(7). При "
"отключении обнаружения неструктурированные сокеты фрагментируют исходящие "
"пакеты, размер которых превышает MTU интерфейса. Однако по соображениям "
"производительности и надёжности отключение не рекомендуется."

#. type: Plain text
#: man-pages/man7/raw.7:214
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a RAW socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""
"Неструктурированный сокет может быть подключён к определённому локальному "
"адресу с помощью вызова B<bind>(2). Если он не подключён, то принимаются все "
"пакеты указанного протокола IP. Кроме того, неструктурированный сокет может "
"быть подключён к определённому сетевому устройству с помощью B<"
"SO_BINDTODEVICE>; смотрите B<socket>(7)."

#. type: Plain text
#: man-pages/man7/raw.7:225
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP"
" packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""
"Сокет B<IPPROTO_RAW> предназначен только для отправки. Если вы хотите "
"получать все пакеты IP, используйте сокет B<packet>(7) с протоколом B<"
"ETH_P_IP>. Заметим, что пакетные сокеты, в отличие от неструктурированных "
"сокетов, не собирают пакеты из фрагментов IP."

#. type: Plain text
#: man-pages/man7/raw.7:231
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""
"Если вы хотите получать все пакеты ICMP для датаграммного сокета, то лучше "
"использовать B<IP_RECVERR> на определённом сокете; смотрите B<ip>(7)."

#. type: Plain text
#: man-pages/man7/raw.7:238
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not"
" be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""
"Неструктурированные сокеты могут перехватывать в Linux все протоколы IP, даже "
"имеющие протокольный модуль в ядре (такие, как ICMP или TCP). В этом случае "
"пакеты передаются как модулю ядра, так и неструктурированным сокетам. На это "
"нельзя закладываться в переносимых программах, так как многие другие "
"реализации сокетов BSD так не делают."

#. type: Plain text
#: man-pages/man7/raw.7:243
msgid ""
"Linux never changes headers passed from the user (except for filling in some"
" zeroed fields as described for B<IP_HDRINCL>).  This differs from many "
"other implementations of raw sockets."
msgstr ""
"Linux никогда не изменяет заголовки, полученные от пользователя (за "
"исключением обнуления некоторых полей, как описано в случае с B<IP_HDRINCL>). "
"Такое поведение отличается от поведения многих других реализаций "
"неструктурированных сокетов."

#. type: Plain text
#: man-pages/man7/raw.7:246
msgid ""
"RAW sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""
"Неструктурированные сокеты, в общем случае, не являются переносимыми, поэтому "
"следует избегать их использования в переносимых программах."

#. type: Plain text
#: man-pages/man7/raw.7:252
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""
"Передача через неструктурированный сокет должна осуществляться с помощью "
"протокола IP из I<sin_port>; эта возможность исчезла в Linux 2.2. Метод "
"обхода — использовать B<IP_HDRINCL>."

#. type: Plain text
#: man-pages/man7/raw.7:254
msgid "Transparent proxy extensions are not described."
msgstr "Не описаны расширения прозрачного прокси."

#. type: Plain text
#: man-pages/man7/raw.7:259
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""
"Если установлен параметр B<IP_HDRINCL>, датаграммы не будут фрагментированы и "
"их размер будет ограничен MTU интерфейса."

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/raw.7:269
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""
"В Linux 2.2 отсутствует настройка протокола IP для отправки  I<sin_port> — "
"всегда используется тот протокол, к которому был подключён сокет или который "
"был указан при первом вызове B<socket>(2)."

#. type: Plain text
#: man-pages/man7/raw.7:275
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"

#. type: Plain text
#: man-pages/man7/raw.7:281
msgid ""
"B<RFC\\ 1191> for path MTU discovery.  B<RFC\\ 791> and the "
"I<E<lt>linux/ip.hE<gt>> header file for the IP protocol."
msgstr ""
"В B<RFC\\ 1191> описан процесс обнаружения маршрута MTU. В B<RFC\\ 791> и "
"заголовочном файле I<E<lt>linux/ip.hE<gt>> описан протокол IP."

#. type: TH
#: man-pages/man2/request_key.2:11
#, no-wrap
msgid "REQUEST_KEY"
msgstr "REQUEST_KEY"

#. type: TH
#: man-pages/man2/request_key.2:11
#, no-wrap
msgid "Linux Key Management Calls"
msgstr "Вызовы системы управления ключами Linux"

#. type: Plain text
#: man-pages/man2/request_key.2:14
msgid "request_key - request a key from the kernel's key management facility"
msgstr "request_key - запрашивает ключ из системы управления ключами ядра"

#. type: Plain text
#: man-pages/man2/request_key.2:17
#, no-wrap
msgid "B<#include E<lt>keyutils.hE<gt>>\n"
msgstr "B<#include E<lt>keyutils.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/request_key.2:21
#, no-wrap
msgid ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>"
"B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<keyring>B<);>\n"
msgstr ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>"
"B<,>\nB<                         const char *>I<callout_info>B<,>\nB<         "
"                key_serial_t >I<keyring>B<);>\n"

#. type: Plain text
#: man-pages/man2/request_key.2:31
msgid ""
"B<request_key>()  asks the kernel to find a key of the given I<type> that "
"matches the specified I<description> and, if successful, to attach it to the"
" nominated I<keyring> and to return its serial number."
msgstr ""
"B<request_key>() подает запрос ядру на поиск ключа заданного I<type>, который "
"соответствует указанному описанию I<description> и, если поиск успешен, "
"присоединяет его к указанному I<keyring> и возвращает его серийный номер."

#. type: Plain text
#: man-pages/man2/request_key.2:36
msgid ""
"B<request_key>()  first recursively searches all the keyrings attached to "
"the calling process in the order thread-specific keyring, process-specific "
"keyring and then session keyring for a matching key."
msgstr ""
"Вызов B<request_key>() выполняет рекурсивный поиск ключа во всех связках "
"ключей в следующем порядке: связки каждой нити, присоединённые к вызвавшему "
"процессу, связки, относящиеся к процессу и связки ключей сеанса."

#. type: Plain text
#: man-pages/man2/request_key.2:44
msgid ""
"If B<request_key>()  is called from a program invoked by B<request_key>()  "
"on behalf of some other process to generate a key, then the keyrings of that"
" other process will be searched next, using that other process's UID, GID, "
"groups, and security context to control access."
msgstr ""
"Если B<request_key>() вызван из программы, вызвавшей B<request_key>() от "
"имени какого-то другого процесс для генерации ключа, то в дальнейшем будет "
"осуществлён поиск по связкам ключей этого другого процесса, используя его "
"UID, GID, группы и контекст безопасности для контроля доступа."

#. type: Plain text
#: man-pages/man2/request_key.2:52
msgid ""
"The keys in each keyring searched are checked for a match before any child "
"keyrings are recursed into.  Only keys that are B<searchable> for the caller"
" may be found, and only B<searchable> keyrings may be searched."
msgstr ""
"Ключи в каждой связке ищутся и проверяются на совпадение до рекурсивного "
"перехода в дочерние связки. Найдены могут быть только те ключи, которые "
"доступны вызывающему для B<поиска>, и поиск может осуществляться только в "
"доступных для B<поиска> связках ключей."

#. type: Plain text
#: man-pages/man2/request_key.2:61
msgid ""
"If the key is not found, then, if I<callout_info> is set, this function will"
" attempt to look further afield.  In such a case, the I<callout_info> is "
"passed to a user-space service such as B</sbin/request-key> to generate the "
"key."
msgstr ""
"Если ключ не найден, то, если задан I<callout_info>, эта функция попытается "
"осуществить дальнейший поиск. В этом случае I<callout_info> передаётся службе "
"из пространства пользователя, такой как B</sbin/request-key>, для генерации "
"ключа."

#. type: Plain text
#: man-pages/man2/request_key.2:69
msgid ""
"If that is unsuccessful also, then an error will be returned, and a "
"temporary negative key will be installed in the nominated I<keyring>.  This "
"will expire after a few seconds, but will cause subsequent calls to "
"B<request_key>()  to fail until it does."
msgstr ""
"Если и она завершилась неудачно, то возвращается ошибка, и временный "
"отрицательный ключ будет установлен в назначенную I<keyring>. Он утратит силу "
"через несколько секунд, но пока существует, все последующие вызовы B<"
"request_key>() будут приводить к ошибке."

#. type: Plain text
#: man-pages/man2/request_key.2:74
msgid ""
"The I<keyring> serial number may be that of a valid keyring to which the "
"caller has write permission, or it may be a special keyring ID:"
msgstr ""
"Серийный номер I<keyring> может задаваться действующей связкой ключей, на "
"которую вызывающий имеет право на запись, или может быть задан специальным ID "
"связки ключей:"

#. type: TP
#: man-pages/man2/request_key.2:74
#, no-wrap
msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgstr "B<KEY_SPEC_THREAD_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:77
msgid "This specifies the caller's thread-specific keyring."
msgstr "Задаёт связку ключей нити вызывающего процесса."

#. type: TP
#: man-pages/man2/request_key.2:77
#, no-wrap
msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgstr "B<KEY_SPEC_PROCESS_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:80
msgid "This specifies the caller's process-specific keyring."
msgstr "Задаёт связку ключей процесса."

#. type: TP
#: man-pages/man2/request_key.2:80
#, no-wrap
msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_SESSION_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:83
msgid "This specifies the caller's session-specific keyring."
msgstr "Задаёт связку ключей сеанса вызывающего процесса."

#. type: TP
#: man-pages/man2/request_key.2:83
#, no-wrap
msgid "B<KEY_SPEC_USER_KEYRING>"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:86
msgid "This specifies the caller's UID-specific keyring."
msgstr "Задаёт связку ключей по UID вызывающего процесса."

#. type: TP
#: man-pages/man2/request_key.2:86
#, no-wrap
msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:89
msgid "This specifies the caller's UID-session keyring."
msgstr "Задаёт связку ключей по UID сеанса вызывающего процесса."

#. type: Plain text
#: man-pages/man2/request_key.2:94
msgid ""
"If a key is created, no matter whether it's a valid key or a negative key, "
"it will displace any other key of the same type and description from the "
"destination I<keyring>."
msgstr ""
"Если ключ создан, то неважно рабочий он или отрицательный, он будет вытеснять "
"любой другой ключ с тем же типом и описанием из указанной I<keyring>."

#. type: SH
#: man-pages/man2/request_key.2:94
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/request_key.2:100
msgid ""
"On success B<request_key>()  returns the serial number of the key it found."
"  On error, the value -1 will be returned and errno will have been set to an"
" appropriate error."
msgstr ""
"При успешном выполнении B<request_key>() возвращается серийный номер "
"найденного ключа. В случае ошибки возвращается значение -1, а в errno "
"устанавливается код соответствующей ошибки."

#. type: Plain text
#: man-pages/man2/request_key.2:104
msgid "The keyring wasn't available for modification by the user."
msgstr "Изменение связки ключей пользователю недоступно."

#. type: TP
#: man-pages/man2/request_key.2:104
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/request_key.2:107
msgid "The request was interrupted by a signal."
msgstr "Запрос был прерван сигналом."

#. type: TP
#: man-pages/man2/request_key.2:107
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/request_key.2:111
msgid ""
"The key quota for this user would be exceeded by creating this key or "
"linking it to the keyring."
msgstr ""
"Квота на ключи для данного пользователя была бы превышена, если бы этот ключ "
"создался или был бы прицеплен в связку ключей."

#. type: TP
#: man-pages/man2/request_key.2:111
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr "B<EKEYEXPIRED>"

#. type: Plain text
#: man-pages/man2/request_key.2:114
msgid "An expired key was found, but no replacement could be obtained."
msgstr "Найден просроченный ключ, и замена не может быть получена."

#. type: TP
#: man-pages/man2/request_key.2:114
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr "B<EKEYREJECTED>"

#. type: Plain text
#: man-pages/man2/request_key.2:117
msgid "The attempt to generate a new key was rejected."
msgstr "Попытка генерации нового ключа была отвергнута."

#. type: TP
#: man-pages/man2/request_key.2:117
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr "B<EKEYREVOKED>"

#. type: Plain text
#: man-pages/man2/request_key.2:120
msgid "A revoked key was found, but no replacement could be obtained."
msgstr "Найден отозванный ключ, и замена не может быть получена."

#. type: TP
#: man-pages/man2/request_key.2:120
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/request_key.2:123
msgid "Insufficient memory to create a key."
msgstr "Недостаточно памяти для создания ключа."

#. type: TP
#: man-pages/man2/request_key.2:123
#, no-wrap
msgid "B<ENOKEY>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: man-pages/man2/request_key.2:126
msgid "No matching key was found."
msgstr "Искомый ключ не найден."

#. type: SH
#: man-pages/man2/request_key.2:126
#, no-wrap
msgid "LINKING"
msgstr "КОМПОНОВКА"

#. type: Plain text
#: man-pages/man2/request_key.2:134
msgid ""
"Although this is a Linux system call, it is not present in I<libc> but can "
"be found rather in I<libkeyutils>.  When linking, B<-lkeyutils> should be "
"specified to the linker."
msgstr ""
"Хотя это и системный вызов Linux, его нет в I<libc>, но его можно найти в I<"
"libkeyutils>. При сборке программы компоновщику нужно указать параметр B<"
"-lkeyutils>."

#. type: Plain text
#: man-pages/man2/request_key.2:138
msgid "B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<request-key>(8)"
msgstr "B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<request-key>(8)"

#. type: TH
#: man-pages/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr "RECVMMSG"

#. type: TH
#: man-pages/man2/recvmmsg.2:31
#, no-wrap
msgid "2014-06-13"
msgstr "2014-06-13"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr "recvmmsg - получает несколько сообщений из сокета"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE          /* See feature_test_macros(7) */>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE          /* Смотрите feature_test_macros(7) */>\nB<"
"#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:41
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
msgstr ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >"
"I<vlen>B<,>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:43
#, no-wrap
msgid ""
"B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:55
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows"
" the caller to receive multiple messages from a socket using a single system"
" call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""
"Системный вызов B<recvmmsg>() является расширенной версией B<recvmsg>(2), "
"позволяя вызывающему получать несколько сообщений из сокета, используя только "
"один системный вызов (в некоторых приложениях это позволяет получить выигрыш "
"в производительности). Ещё одно улучшение B<recvmsg>(2) — настройка времени "
"ожидания для операции получения."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:59
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""
"Аргумент I<sockfd> представляет собой файловый дескриптор сокета приёма "
"данных."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:67
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""
"Аргумент I<msgvec> является указателем на массив структур I<mmsghdr>. Размер "
"этого массива указывается в I<vlen>."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:73
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""
"Структура I<mmsghdr> определена в I<E<lt>sys/socket.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:80
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""
"struct mmsghdr {\n    struct msghdr msg_hdr;  /* Заголовок сообщения */\n    "
"unsigned int  msg_len;  /* Количество полученных байт\n                       "
"        для заголовка */\n};\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:95
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the"
" message in the entry.  This field has the same value as the return value of"
" a single B<recvmsg>(2)  on the header."
msgstr ""
"Поле I<msg_hdr> представляет собой структуру I<msghdr>, которая описана в B<"
"recvmsg>(2). В поле I<msg_len> содержится количество байт возвращаемого "
"сообщения в записи. Это поле имеет такое же значение, что и возвращаемое "
"значение одиночного вызова B<recvmsg>(2) в заголовке."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:102
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""
"Аргумент I<flags> содержит объединённые с помощью OR флаги. Флаги те же, что "
"и у B<recvmsg>(2), но со следующим дополнением:"

#. type: TP
#: man-pages/man2/recvmmsg.2:102
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr "B<MSG_WAITFORONE> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:107
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr "Включить B<MSG_DONTWAIT> после получения первого сообщения."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:122
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation (I<but see BUGS!>).  (This interval will be rounded up to "
"the system clock granularity, and kernel scheduling delays mean that the "
"blocking interval may overrun by a small amount.)  If I<timeout> is NULL, "
"then the operation blocks indefinitely."
msgstr ""
"Аргумент I<timeout> указывает на I<struct timespec> (смотрите B<clock_gettime>"
"(2)), задающую время ожидания (в секундах и наносекундах) операции приёма (I<"
"но смотрите ДЕФЕКТЫ!>; (этот интервал будет округлён до точности системных "
"часов, и из-за задержек планировщика ядра интервал блокировки может быть "
"немного больше). Если I<timeout> равно NULL, то операция блокируется на "
"неопределённое время."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:133
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""
"Блокирование вызова B<recvmmsg>() происходит до тех пор, пока не будет "
"получено I<vlen> сообщений или не истечёт интервал блокировки. Неблокирующий "
"вызов читает все доступные сообщения (максимальное количество указано в I<"
"vlen>) и сразу завершает работу."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:148
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""
"При выходе из B<recvmmsg>() последующие элементы I<msgvec> обновляются "
"информацией о каждом полученном сообщении: в I<msg_len> содержится размер "
"принятого сообщения; подполя I<msg_hdr> обновляются согласно описанию в B<"
"recvmsg>(2). Возвращаемое значение вызова означает количество обновлённых "
"элементов I<msgvec>."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:156
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""
"При успешном выполнении B<recvmmsg>() возвращает количество принятых в I<"
"msgvec> сообщений; при ошибке возвращается -1 и в I<errno> устанавливается "
"код ошибки."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:160
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can "
"occur:"
msgstr ""
"Возникают те же ошибки что и для B<recvmsg>(2). Кроме этого, случается "
"следующая ошибка:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:164
msgid "I<timeout> is invalid."
msgstr "Значение I<timeout> неверно."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:169
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""
"Системный вызов B<recvmmsg>() был добавлен в Linux 2.6.33. Поддержка в glibc "
"появилась в версии 2.12."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:172
msgid "B<recvmmsg>()  is Linux-specific."
msgstr "Вызов B<recvmmsg>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:180
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers"
" are filled or if the timeout specified has expired."
msgstr ""
"Следующая программа использует B<recvmmsg>() для получения нескольких "
"сообщений через сокет и сохранения их в несколько буферов. Вызов завершается "
"при заполнении всех буферов, либо по окончании заданного временного интервала."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:183
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""
"Следующий отрывок периодически генерирует датаграммы UDP с произвольным "
"номером внутри:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:188
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\n"
"B<sleep 0.25; done>\n"
msgstr ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\nB<sleep "
"0.25; done>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:193
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr "Эти датаграммы читаются примером приложения, который выдаёт:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:203
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""
"$B< ./a.out>\n5 сообщений получено\n1 11782\n2 11345\n3 304\n4 13514\n5 "
"28421\n"

#. type: SS
#: man-pages/man2/recvmmsg.2:205
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:214
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n#include E<lt>netinet/ip.hE<gt>\n#include E<lt>stdio.hE<"
"gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>"
"sys/socket.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:227
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval, i;\n"
"    struct sockaddr_in sa;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""
"int\nmain(void)\n{\n#define VLEN 10\n#define BUFSIZE 200\n#define TIMEOUT 1\n "
"   int sockfd, retval, i;\n    struct sockaddr_in sa;\n    struct mmsghdr "
"msgs[VLEN];\n    struct iovec iovecs[VLEN];\n    char "
"bufs[VLEN][BUFSIZE+1];\n    struct timespec timeout;\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:233
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd == -1) {\n       "
" perror(\"socket()\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:241
#, no-wrap
msgid ""
"    sa.sin_family = AF_INET;\n"
"    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    sa.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sa.sin_family = AF_INET;\n    sa.sin_addr.s_addr = "
"htonl(INADDR_LOOPBACK);\n    sa.sin_port = htons(1234);\n    if (bind(sockfd, "
"(struct sockaddr *) &sa, sizeof(sa)) == -1) {\n        perror(\"bind()\");\n  "
"      exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:249
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""
"    memset(msgs, 0, sizeof(msgs));\n    for (i = 0; i E<lt> VLEN; i++) {\n    "
"    iovecs[i].iov_base         = bufs[i];\n        iovecs[i].iov_len          "
"= BUFSIZE;\n        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n        "
"msgs[i].msg_hdr.msg_iovlen = 1;\n    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:252
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr "    timeout.tv_sec = TIMEOUT;\n    timeout.tv_nsec = 0;\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:258
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n    if (retval == "
"-1) {\n        perror(\"recvmmsg()\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:266
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%d сообщений получено\\en\", retval);\n    for (i = 0; i E<lt> "
"retval; i++) {\n        bufs[i][msgs[i].msg_len] = 0;\n        printf(\"%d %"
"s\", i+1, bufs[i]);\n    }\n    exit(EXIT_SUCCESS);\n}\n"

#.  FIXME https://bugzilla.kernel.org/show_bug.cgi?id=75371
#.  http://thread.gmane.org/gmane.linux.man/5677
#. type: Plain text
#: man-pages/man2/recvmmsg.2:278
msgid ""
"The I<timeout> argument does not work as intended.  The timeout is checked "
"only after the receipt of each datagram, so that if up to I<vlen-1> "
"datagrams are received before the timeout expires, but then no further "
"datagrams are received, the call will block forever."
msgstr ""
"Аргумент I<timeout> работает не так, как планировалось. Время ожидания "
"проверяется только после приёма каждой дейтаграммы, поэтому, если до "
"истечения срока будет получено до I<vlen-1> дейтаграмм, но затем дейтаграммы "
"не поступят, то вызов заблокируется навсегда."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:284
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), B<socket>"
"(2), B<socket>(7)"

#. type: TH
#: man-pages/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr "RT_SIGQUEUEINFO"

#. type: TH
#: man-pages/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:28
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr "rt_sigqueueinfo, rt_tgsigqueueinfo - ставит сигнал и данные в очередь"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:31
#, no-wrap
msgid ""
"B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t "
"*>I<uinfo>B<);>\n"
msgstr ""
"B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<uinfo>B<"
");>\n"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:34
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"
msgstr ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>"
"\nB<                      siginfo_t *>I<uinfo>B<);>\n"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:38
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточных функций для этих системных вызовов; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:50
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or thread."
"  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""
"Системные вызовы B<rt_sigqueueinfo>() и B<rt_tgsigqueueinfo>() предоставляют "
"низкоуровневый интерфейс для отправки сигнала с данными процессу или нити. "
"Приёмник сигнала может получить сопутствующие данные, установив обработчик "
"сигнала с помощью B<sigaction>(2) с флагом B<SA_SIGINFO>."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:56
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""
"Данные системные вызовы не предназначены для использования непосредственно из "
"приложения; они нужны для реализации библиотечных функций B<sigqueue>(3) и B<"
"pthread_sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:68
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group "
"(i.e., one of the threads that is not currently blocking the signal)."
msgstr ""
"Системный вызов B<rt_sigqueueinfo>() отправляет сигнал I<sig> группе нитей с "
"идентификатором I<tgid> (термин «группа нитей» является синонимом «процесс», "
"а I<tid> соответствует обычному идентификатору процесса UNIX). Сигнал будет "
"доставлен произвольному члену группы нитей (т. е., одной из нитей, которая в "
"этот момент не блокирует сигнал)."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:79
msgid ""
"The I<uinfo> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""
"В аргументе I<uinfo> задаются сопутствующие сигналу данные. Этот аргумент "
"является указателем на структуру типа I<siginfo_t>, описанную в B<sigaction>"
"(2) (и определённую в I<E<lt>sigaction.hE<gt>>). Вызывающий должен заполнить "
"следующие поля структуры:"

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:79
#, no-wrap
msgid "I<si_code>"
msgstr "I<si_code>"

#.  tkill(2) or
#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:95
msgid ""
"This must be one of the B<SI_*> codes in the Linux kernel source file "
"I<include/asm-generic/siginfo.h>, with the restriction that the code must be"
" negative (i.e., cannot be B<SI_USER>, which is used by the kernel to "
"indicate a signal sent by B<kill>(2))  and cannot (since Linux 2.6.39) be "
"B<SI_TKILL> (which is used by the kernel to indicate a signal sent using "
"B<tgkill>(2))."
msgstr ""
"Значением должен быть один из кодов B<SI_*>, перечисленных в файле исходного "
"кода ядра Linux I<include/asm-generic/siginfo.h>, имеющих отрицательное "
"значение (т. е., нельзя указать B<SI_USER>, используемый ядром для "
"обозначения того, что сигнал послан B<kill>(2)) и нельзя указать (начиная с "
"Linux 2.6.39) B<SI_TKILL> (используется ядром для обозначения того, что "
"сигнал послан B<tgkill>(2))."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:95
#, no-wrap
msgid "I<si_pid>"
msgstr "I<si_pid>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:99
msgid ""
"This should be set to a process ID, typically the process ID of the sender."
msgstr "Должно хранить идентификатор процесса, обычно PID отправителя."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:99
#, no-wrap
msgid "I<si_uid>"
msgstr "I<si_uid>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:103
msgid ""
"This should be set to a user ID, typically the real user ID of the sender."
msgstr ""
"Должно хранить идентификатор пользователя, обычно UID реального пользователя "
"отправителя."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:103
#, no-wrap
msgid "I<si_value>"
msgstr "I<si_value>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:110
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""
"Это поле хранит пользовательские данные, сопровождающие сигнал. Подробности "
"смотрите в описании последнего аргумента (I<union sigval>) функции B<sigqueue>"
"(3)."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:117
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number"
" via that field."
msgstr ""
"Внутри ядра полю I<si_signo> устанавливается значение, переданное в I<sig>, "
"так что получатель сигнала может также получить его номер через это поле."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:129
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""
"Системный вызов B<rt_tgsigqueueinfo>() похож на B<rt_sigqueueinfo>(), но "
"посылает сигнал и данные одной нити, указываемой комбинацией I<tgid> — "
"идентификатором группы нитей — и I<tid> — нити из этой группы."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:134
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении эти системные вызовы возвращают 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение ошибки."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:135
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:141
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""
"Достигнуто ограничение на количество сигналов в очереди (подробней об этом "
"смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:148
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr "Некорректное значение I<sig>, I<tgid> или I<tid>."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:156
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2).  Or: I<uinfo-E<gt>si_code> is "
"invalid."
msgstr ""
"Вызывающий не имеет прав для отправки сигнала по назначению. Требуемые права "
"смотрите в B<kill>(2). Или некорректное значение I<uinfo-E<gt>si_code>."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:156
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:162
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr "B<rt_sigqueueinfo>(): Группа нитей I<tgid> не найдена."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:169
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr "B<rt_tgsigqueinfo>(): Нить I<tid> из I<tgid> не найдена."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:176
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version "
"2.6.31."
msgstr ""
"Системный вызов B<rt_sigqueueinfo>() был добавлен в Linux версии 2.2. "
"Системный вызов B<rt_tgsigqueueinfo>() был добавлен в Linux версии 2.6.31."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:178
msgid "These system calls are Linux-specific."
msgstr "Данные системные вызовы есть только в Linux."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:183
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""
"Поскольку системные вызовы не предназначены для приложений, в glibc для них "
"нет обёрточных функций. Используйте B<syscall>(2) в том маловероятном случае, "
"если вы хотите вызывать их напрямую."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:188
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""
"Как и в случае с B<kill>(2), может быть использован сигнал null (0), чтобы "
"проверить, существует ли указанный процесс или нить."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:195
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), B<"
"pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/restart_syscall.2:33
#, no-wrap
msgid "RESTART_SYSCALL"
msgstr "RESTART_SYSCALL"

#. type: TH
#: man-pages/man2/restart_syscall.2:33
#, no-wrap
msgid "2014-02-11"
msgstr "2014-02-11"

#. type: Plain text
#: man-pages/man2/restart_syscall.2:36
msgid ""
"restart_syscall - restart a system call after interruption by a stop signal"
msgstr ""
"restart_syscall - перезапускает системный вызов после прерывания сигналом "
"останова"

#. type: Plain text
#: man-pages/man2/restart_syscall.2:38
msgid "B<int restart_syscall(void);>"
msgstr "B<int restart_syscall(void);>"

#. type: Plain text
#: man-pages/man2/restart_syscall.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>:В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:53
msgid ""
"The B<restart_syscall>()  system call is used to restart certain system "
"calls after a process that was stopped by a signal (e.g., B<SIGSTOP> or "
"B<SIGTSTP>)  is later resumed after receiving a B<SIGCONT> signal.  This "
"system call is designed only for internal use by the kernel."
msgstr ""
"Системный вызов B<restart_syscall>() предназначен для перезапуска некоторых "
"системных вызовов после того, как процесс, остановленный сигналом (например, "
"B<SIGSTOP> или B<SIGTSTP>), продолжил выполнение после получения сигнала B<"
"SIGCONT>. Этот системный вызов создан только для внутреннего использования "
"ядром."

#.  These system calls correspond to the special internal errno value
#.  ERESTART_RESTARTBLOCK. Each of the system calls has a "restart"
#.  helper function that is invoked by restart_syscall().
#. type: Plain text
#: man-pages/man2/restart_syscall.2:84
msgid ""
"B<restart_syscall>()  is used for restarting only those system calls that, "
"when restarted, should adjust their time-related parameters\\(emnamely "
"B<poll>(2)  (since Linux 2.6.24), B<nanosleep>(2)  (since Linux 2.6), "
"B<clock_nanosleep>(2)  (since Linux 2.6), and B<futex>(2), when employed "
"with the B<FUTEX_WAIT> (since Linux 2.6.22)  and B<FUTEX_WAIT_BITSET> (since"
" Linux 2.6.31)  operations.  B<restart_syscall>()  restarts the interrupted "
"system call with a time argument that is suitably adjusted to account for "
"the time that has already elapsed (including the time where the process was "
"stopped by a signal).  Without the B<restart_syscall>()  mechanism, "
"restarting these system calls would not correctly deduce the already elapsed"
" time when the process continued execution."
msgstr ""
"Вызов B<restart_syscall>() используется только для тех системных вызовов, "
"которые при перезапуске должны обновить свои параметры, относящиеся к "
"времени, а именно — B<poll>(2) (начиная с Linux 2.6.24), B<nanosleep>(2) "
"(начиная с Linux 2.6), B<clock_nanosleep>(2) (начиная с Linux 2.6), B<futex>"
"(2) при использовании с B<FUTEX_WAIT> (начиная с Linux 2.6.22) и B<"
"FUTEX_WAIT_BITSET> (начиная с Linux 2.6.31). Вызов B<restart_syscall>() "
"перезапускает прерванный системный вызов с аргументом времени, который "
"позволят рассчитать прошедшее время (включая время, когда процесс был "
"остановлен сигналом). Без механизма B<restart_syscall>() при перезапуске этих "
"системных вызовов было бы невозможно правильно оценить время, прошедшее на "
"момент продолжения выполнение процесса."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:88
msgid ""
"The return value of B<restart_syscall>()  is the return value of whatever "
"system call is being restarted."
msgstr ""
"Возвращаемым значением B<restart_syscall>() является возвращаемое значение "
"перезапущенного системного вызова."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:92
msgid ""
"I<errno> is set as per the errors for whatever system call is being "
"restarted by B<restart_syscall>()."
msgstr ""
"Значение I<errno> устанавливается в соответствии с ошибками системного "
"вызова, перезапущенного B<restart_systemcall>()."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:96
msgid "The B<restart_syscall>()  system call is present since Linux 2.6."
msgstr "Системный вызов B<restart_systemcall>() появился в Linux 2.6."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:98
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:102
msgid ""
"There is no glibc wrapper for this system call, because it is intended for "
"use only by the kernel and should never be called by applications."
msgstr ""
"Для этого системного вызова в glibc нет обёрточной функции, потому что он "
"используется только ядром и не должен вызываться приложениями."

#.  FIXME
#.  There is one oddness in the implementation though, with respect to
#.  nanosleep() (and probably also clock_nanosleep()). The scenario
#.  is as follows:
#.     1. Start a nanosleep() for (say) 30 seconds,
#.     2. Stop the process with (say) SIGTSTP (^Z).
#.     3. Resume the process with SIGCONT,
#.     4. Upon return, the 'rem' argument of nanosleep() will contain the
#.        remaining unslept time **at the time when SIGTSTP was delivered**.
#.  The behavior at point 4 is odd, but doesn't violate the standards, which
#.  specify the treatment of 'rem' only when the system call returns with
#.  the error EINTR (i.e., the call was interrupted by a signal handler).
#. type: Plain text
#: man-pages/man2/restart_syscall.2:123
msgid ""
"From user space, the operation of B<restart_syscall>(2)  is largely "
"invisible: to the process that made the system call that is restarted, it "
"appears as though that system call executed and returned in the usual "
"fashion."
msgstr ""
"Из пользовательского пространства работа B<restart_syscall>(2), в большинстве "
"случаев, невидима: процессу, выполняющему системный вызов, который "
"перезапускался, кажется, что системный вызов выполнился как обычно."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:126
msgid "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"
msgstr "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "READ"
msgstr "READ"

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "2014-05-04"
msgstr "2014-05-04"

#. type: Plain text
#: man-pages/man2/read.2:38
msgid "read - read from a file descriptor"
msgstr "read - читает из файлового дескриптора"

#. type: Plain text
#: man-pages/man2/read.2:41
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/read.2:43
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/read.2:52
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""
"Вызов B<read>() пытается прочитать I<count> байт из файлового дескриптора I<"
"fd> в буфер, начинающийся по адресу I<buf>."

#. type: Plain text
#: man-pages/man2/read.2:60
msgid ""
"On files that support seeking, the read operation commences at the current "
"file offset, and the file offset is incremented by the number of bytes read."
"  If the current file offset is at or past the end of file, no bytes are "
"read, and B<read>()  returns zero."
msgstr ""
"Для файлов, поддерживающих смещения, операция чтения начинается с текущего "
"файлового смещения, и файловое смещение увеличивается на количество "
"прочитанных байт. Если текущее файловое смещение находится за концом файла, "
"то ничего не читается и B<read>() возвращает ноль."

#. type: Plain text
#: man-pages/man2/read.2:75
msgid ""
"If I<count> is zero, B<read>()  I<may> detect the errors described below.  "
"In the absence of any errors, or if B<read>()  does not check for errors, a "
"B<read>()  with a I<count> of 0 returns zero and has no other effects."
msgstr ""
"Если значение I<count> равно 0, то B<read>() I<может> обнаружить ошибки, "
"описанные далее. При отсутствии ошибок, или если B<read>() не выполняет "
"проверки, то B<read>() с I<count> равным 0 возвращает 0 и ничего не меняет."

#. type: Plain text
#: man-pages/man2/read.2:81
msgid "If I<count> is greater than B<SSIZE_MAX>, the result is unspecified."
msgstr "Если значение I<count> больше B<SSIZE_MAX>, то результат не определён."

#. type: Plain text
#: man-pages/man2/read.2:95
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error"
" if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  On error, -1 is returned, and I<errno> is set appropriately.  In "
"this case, it is left unspecified whether the file position (if any) "
"changes."
msgstr ""
"При успешном выполнении возвращается количество прочитанных байт (ноль "
"означает конец файла), а позиция в файле увеличивается на это значение. Если "
"количество прочитанных байт меньше, чем количество запрошенных, то это не "
"считается ошибкой: например, это могло произойти из-за того, что прямо сейчас "
"доступно меньшее количество байт (может быть из-за того, что позиция ближе к "
"концу файла, или потому что выполняется чтение из канала или терминала), или "
"потому что работа B<read>() была прервана сигналом. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение. В "
"этом случае изменение позиции файла остаётся неопределённым (если это вообще "
"происходило)."

#. type: Plain text
#: man-pages/man2/read.2:103
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block."
msgstr ""
"Файловый дескриптор I<fd> указывает на файл, не являющийся сокетом и который "
"помечен как неблокирующий (B<O_NONBLOCK>), а чтение вызвало бы блокировку."

#. type: TP
#: man-pages/man2/read.2:103
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> или B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/read.2:114
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking"
" (B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""
"Файловый дескриптор I<fd> указывает на сокет и он помечен как неблокирующий "
"(B<O_NONBLOCK>), а чтение вызвало бы блокировку. POSIX.1-2001 позволяет "
"вернуть любую ошибку в этом случае и не требует, чтобы эти константы имели "
"одинаковое значение, поэтому переносимое приложение должно проверять обе эти "
"возможности."

#. type: TP
#: man-pages/man2/read.2:114
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/read.2:118
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""
"I<fd> не является допустимым файловым дескриптором или не открыт на чтение."

#. type: Plain text
#: man-pages/man2/read.2:122
msgid "I<buf> is outside your accessible address space."
msgstr "I<buf> находится за пределами доступного вам адресного пространства."

#. type: Plain text
#: man-pages/man2/read.2:126
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""
"Вызов был прерван сигналом до того как были прочитаны данные; см. B<signal>"
"(7)."

#. type: Plain text
#: man-pages/man2/read.2:137
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the current file offset is not "
"suitably aligned."
msgstr ""
"I<fd> связан с объектом, не приспособленным для чтения; или файл был открыт с "
"использованием флага B<O_DIRECT>, и адрес, указанный в I<buf>, значение, "
"указанное в I<count> или текущее смещение в файле, имеет недопустимое "
"выравнивание."

#. type: Plain text
#: man-pages/man2/read.2:147
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""
"I<fd> был создан вызовом B<timerfd_create>(2), а в B<read>() был передан "
"неверный размер буфера; подробней см. в B<timerfd_create>(2)."

#. type: TP
#: man-pages/man2/read.2:147
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/read.2:158
msgid ""
"I/O error.  This will happen for example when the process is in a background"
" process group, tries to read from its controlling terminal, and either it "
"is ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may"
" also occur when there is a low-level I/O error while reading from a disk or"
" tape."
msgstr ""
"Ошибка ввода/вывода. Например, это происходит когда процесс, находящийся в "
"фоновой группе процессов, пытается выполнить чтение из своего управляющего "
"терминала, и игнорирует или блокирует сигнал B<SIGTTIN> или же его группа "
"процессов осталась без родителя. Это также может случиться, если произошла "
"низкоуровневая ошибка ввода-вывода при чтения с диска или ленты."

#. type: TP
#: man-pages/man2/read.2:158
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: man-pages/man2/read.2:162
msgid "I<fd> refers to a directory."
msgstr "I<fd> указывает на каталог."

#. type: Plain text
#: man-pages/man2/read.2:173
msgid ""
"Other errors may occur, depending on the object connected to I<fd>.  POSIX "
"allows a B<read>()  that is interrupted after reading some data to return -1"
" (with I<errno> set to B<EINTR>)  or to return the number of bytes already "
"read."
msgstr ""
"Могут также возникнуть другие ошибки, в зависимости от объекта, связанного с "
"I<fd>. POSIX позволяет системному вызову B<read>(), который был прерван после "
"чтения первого куска запрошенных данных, возвращать -1 (с I<errno>, "
"установленной в B<EINTR>) или количество уже прочитанных байт."

#. type: Plain text
#: man-pages/man2/read.2:175
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/read.2:187
msgid ""
"On NFS filesystems, reading small amounts of data will update the timestamp "
"only the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"st_atime (last file access time)  updates to the server and client side "
"reads satisfied from the client's cache will not cause st_atime updates on "
"the server as there are no server side reads.  UNIX semantics can be "
"obtained by disabling client side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""
"На файловых системах NFS чтение небольших порций данных обновляет отметки "
"времени только в первый раз, последующие вызовы не делают этого. Это вызвано "
"кэшированием атрибутов с клиентской стороны, потому что большинство (если не "
"все) клиентов NFS предоставляют серверу обновлять st_atime (время последнего "
"доступа), а запросы на чтение, которые удовлетворяются из клиентского кэша, "
"не вызывают обновления st_atime, потому что данные не читаются с сервера. "
"Семантика UNIX может быть достигнута запретом кэширования атрибутов на "
"стороне клиента, но в большинстве случаев это увеличит нагрузку на сервер и "
"снизит производительность."

#. type: Plain text
#: man-pages/man2/read.2:190
msgid ""
"According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions "
"with Regular File Operations\"):"
msgstr ""
"Согласно POSIX.1-2008/SUSv4 раздел XSI 2.9.7 («Thread Interactions with "
"Regular File Operations»):"

#. type: Plain text
#: man-pages/man2/read.2:195
msgid ""
"All of the following functions shall be atomic with respect to each other in"
" the effects specified in POSIX.1-2008 when they operate on regular files or"
" symbolic links: ..."
msgstr ""
"Следующие функции должны выполняться атомарно по отношению друг к другу, "
"чтобы работать с обычными файлами или символическими ссылками так, как "
"указано в POSIX.1-2008: …"

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: man-pages/man2/read.2:226
msgid ""
"Among the APIs subsequently listed are B<read>()  and B<readv>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was"
" not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<read>()  (or B<readv>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the reads in the two processes might (incorrectly) "
"overlap in the blocks of data that they obtained.  This problem was fixed in"
" Linux 3.14."
msgstr ""
"Среди перечисленных в программном интерфейсе есть B<read>() и B<readv>(2). И "
"среди действий, которые должны выполняться атомарно между нитями (и "
"процессами), если обновление файлового смещения. Однако в Linux до версии "
"3.14 это было не так: если два процесса с общим открытым файловым описанием "
"(смотрите B<open>(2)) выполняют B<read>() (или B<readv>(2)) одновременно, то "
"операции ввода-вывода не атомарны при обновлении файлового смещения; в "
"результате прочитанные двумя процессами блоки данных могут (некорректно) "
"перекрываться. Эта ошибка исправлена в Linux 3.14."

#. type: Plain text
#: man-pages/man2/read.2:238
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2),"
" B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), B<"
"fread>(3)"

#. type: TH
#: man-pages/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr "READAHEAD"

#. type: TH
#: man-pages/man2/readahead.2:28
#, no-wrap
msgid "2014-03-15"
msgstr "2014-03-15"

#. type: Plain text
#: man-pages/man2/readahead.2:31
msgid "readahead - initiate file readahead into page cache"
msgstr "readahead - включает упреждающее чтение файла в кэш страниц"

#. type: Plain text
#: man-pages/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\nB<"
"#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/readahead.2:37
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>"
"\n"

#. type: Plain text
#: man-pages/man2/readahead.2:44
msgid ""
"B<readahead>()  initiates readahead on a file so that subsequent reads from "
"that file will be satisfied from the cache, and not block on disk I/O "
"(assuming the readahead was initiated early enough and that other activity "
"on the system did not in the meantime flush pages from the cache)."
msgstr ""
"Вызов B<readahead>() включает упреждающее чтение (initiates readahead) из "
"файла таким образом, что последующие операции чтения этого файла будут брать "
"данные их кэша и не блокировать дисковый ввод-вывод (предполагается, что "
"упреждающее чтение началось раньше и что другие действия в системе не "
"выбросили страницы из кэша)."

#. type: Plain text
#: man-pages/man2/readahead.2:66
msgid ""
"The I<fd> argument is a file descriptor identifying the file which is to be "
"read.  The I<offset> argument specifies the starting point from which data "
"is to be read and I<count> specifies the number of bytes to be read.  I/O is"
" performed in whole pages, so that I<offset> is effectively rounded down to "
"a page boundary and bytes are read up to the next page boundary greater than"
" or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the "
"end of the file.  The current file offset of the open file referred to by "
"I<fd> is left unchanged."
msgstr ""
"Аргумент I<fd> — это файловый дескриптор файла для чтения. В аргументе I<"
"offset> указывает начальная точка, от которой нужно читать данные и в I<count>"
" задаётся количество читаемых байт. Ввод-вывод выполняется во все страницы, "
"так что I<offset> эффективно округляется в меньшую сторону к границе страницы "
"и байты читаются до границы следующей страницы, большей или равной I<"
"(offset+count)>. B<readahead>() не выполняет чтения за концом файла. Текущее "
"файловое смещение открытого файла, на который указывает I<fd>, остаётся "
"неизменным."

#. type: Plain text
#: man-pages/man2/readahead.2:72
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<readahead>() возвращает 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/readahead.2:83
msgid ""
"I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""
"I<fd> указывает на файл с типом, который нельзя использовать в B<readahead>()."

#. type: Plain text
#: man-pages/man2/readahead.2:88
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""
"Системный вызов B<readahead>() появился в Linux 2.4.13; поддержка в glibc "
"началась с версии 2.3."

#. type: Plain text
#: man-pages/man2/readahead.2:93
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""
"Системный вызов B<readahead>() есть только в Linux, и не должен "
"использоваться в переносимых приложениях."

#. type: Plain text
#: man-pages/man2/readahead.2:98
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""
"На некоторых 32-битных архитектурах интерфейс системного вызова отличается от "
"описанного выше, по причинам указанным в B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/readahead.2:107
msgid ""
"B<readahead>()  attempts to schedule the reads in the background and return "
"immediately.  However, it may block while it reads the filesystem metadata "
"needed to locate the requested blocks.  This occurs frequently with ext[234]"
" on large files using indirect blocks instead of extents, giving the "
"appearance that the call blocks until the requested data has been read."
msgstr ""
"Вызов B<readahead>() пытается запланировать чтение в фоновом режиме и сразу "
"завершается. Однако, он может заблокироваться на время чтения метаданных "
"файловой системы, необходимых для обнаружения запрашиваемых блоков. Это часто "
"происходит  ext[234] для больших файлов, у которых используются косвенные "
"(indirect) блоки вместо непрерывных (extents), что приводит к блокировке "
"вызова на время прочтения нужных данных."

#. type: Plain text
#: man-pages/man2/readahead.2:112
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""
"B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"

#. type: TH
#: man-pages/man2/readlink.2:44
#, no-wrap
msgid "READLINK"
msgstr "READLINK"

#. type: TH
#: man-pages/man2/readlink.2:44
#, no-wrap
msgid "2014-05-10"
msgstr "2014-05-10"

#. type: Plain text
#: man-pages/man2/readlink.2:47
msgid "readlink, readlinkat - read value of a symbolic link"
msgstr "readlink, readlinkat - считывает значение символьной ссылки"

#. type: Plain text
#: man-pages/man2/readlink.2:53
#, no-wrap
msgid ""
"B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>\n"
msgstr ""
"B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t >I<"
"bufsiz>B<);>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:56
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант of AT_* "
"*/\nB<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:59
#, no-wrap
msgid ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\nB<        "
"           char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:64
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>"
"(7)):"

#. type: Plain text
#: man-pages/man2/readlink.2:68
msgid "B<readlink>():"
msgstr "B<readlink>():"

#. type: Plain text
#: man-pages/man2/readlink.2:71
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/readlink.2:74
msgid "B<readlinkat>():"
msgstr "B<readlinkat>():"

#. type: TP
#: man-pages/man2/readlink.2:77
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/readlink.2:80
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/readlink.2:80
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/readlink.2:83
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/readlink.2:100
msgid ""
"B<readlink>()  places the contents of the symbolic link I<pathname> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will truncate the contents (to a length of "
"I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr ""
"Вызов B<readlink>() помещает содержимое символьной ссылки I<pathname> в буфер "
"I<buf> размером I<bufsiz>. B<readlink>() не добавляет в I<buf> байт null. "
"Если буфер слишком мал для хранения всего содержимого, то содержимое будет "
"урезано (до длины в I<bufsiz> символов)."

#. type: SS
#: man-pages/man2/readlink.2:100
#, no-wrap
msgid "readlinkat()"
msgstr "readlinkat()"

#. type: Plain text
#: man-pages/man2/readlink.2:106
msgid ""
"The B<readlinkat>()  system call operates in exactly the same way as "
"B<readlink>(), except for the differences described here."
msgstr ""
"Системный вызов B<readlinkat>() работает также как системный вызов B<readlink>"
"(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/readlink.2:116
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<readlink>()  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<readlink>())."

#. type: Plain text
#: man-pages/man2/readlink.2:128
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<readlink>())."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<readlink>())."

#. type: Plain text
#: man-pages/man2/readlink.2:134
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: man-pages/man2/readlink.2:148
msgid ""
"Since Linux 2.6.39, I<pathname> can be an empty string, in which case the "
"call operates on the file referred to by I<dirfd> (which may have been "
"obtained using the B<open>(2)  B<O_PATH> flag).  In this case, I<dirfd> can "
"refer to any type of file, not just a directory."
msgstr ""
"Начиная с Linux 2.6.39, I<pathname> может быть пустой строкой; при этом вызов "
"выполняет действие с файлом, на который ссылается I<dirfd> (может быть "
"получен с помощью B<open>(2) с флагом B<O_PATH>). В этом случае I<dirfd> "
"может ссылаться на файл любого типа, а не только на каталог."

#. type: Plain text
#: man-pages/man2/readlink.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<readlinkat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<readlinkat>()."

#. type: Plain text
#: man-pages/man2/readlink.2:159
msgid ""
"On success, these calls return the number of bytes placed in I<buf>.  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении эти вызовы возвращают количество байт, помещённых в "
"I<buf>. В случае ошибки возвращается -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/readlink.2:165
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"В одном из каталогов префикса пути не разрешён поиск (см. также B<"
"path_resolution>(7)."

#. type: Plain text
#: man-pages/man2/readlink.2:169
msgid "I<buf> extends outside the process's allocated address space."
msgstr ""
"I<buf> выходит за пределы адресного пространства, выделенного процессу."

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: man-pages/man2/readlink.2:178
msgid "I<bufsiz> is not positive."
msgstr "Аргумент I<bufsiz> содержит отрицательное значение."

#. type: Plain text
#: man-pages/man2/readlink.2:181
msgid "The named file is not a symbolic link."
msgstr "Указанный файл не является символьной ссылкой."

#. type: Plain text
#: man-pages/man2/readlink.2:184
msgid "An I/O error occurred while reading from the filesystem."
msgstr "При чтении файловой системы произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/readlink.2:184
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/readlink.2:187
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""
"Во время определения pathname встретилось слишком много символьных ссылок."

#. type: TP
#: man-pages/man2/readlink.2:187
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/readlink.2:190
msgid "A pathname, or a component of a pathname, was too long."
msgstr "Слишком длинное значение аргумента pathname или его части."

#. type: TP
#: man-pages/man2/readlink.2:190
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/readlink.2:193
msgid "The named file does not exist."
msgstr "Указанный файл не существует."

#. type: Plain text
#: man-pages/man2/readlink.2:196
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: TP
#: man-pages/man2/readlink.2:196 man-pages/man2/readlink.2:206
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/readlink.2:199
msgid "A component of the path prefix is not a directory."
msgstr "Компонент в префиксе пути не является каталогом."

#. type: Plain text
#: man-pages/man2/readlink.2:202
msgid "The following additional errors can occur for B<readlinkat>():"
msgstr "В B<readlinkat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/readlink.2:206
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/readlink.2:212
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит файловый "
"дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/readlink.2:216
msgid ""
"B<readlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Системный вызов B<readlinkat>() был добавлен в ядро Linux версии 2.6.16; "
"поддержка в glibc доступна с версии 2.4."

#. type: Plain text
#: man-pages/man2/readlink.2:222
msgid ""
"B<readlink>(): 4.4BSD (B<readlink>()  first appeared in 4.2BSD), "
"POSIX.1-2001, POSIX.1-2008."
msgstr ""
"B<readlink>(): 4.4BSD (B<readlink>() появился в 4.2BSD), POSIX.1-2001, "
"POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/readlink.2:225
msgid "B<readlinkat>(): POSIX.1-2008."
msgstr "B<readlinkat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/readlink.2:233
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""
"В версиях glibc до glibc 2.4 включительно, тип результата B<readlink>() был "
"объявлен как I<int>. В настоящее время типом возвращаемого результата "
"является I<ssize_t>, как (теперь) это требуется по POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/readlink.2:256
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  and "
"B<readlinkat>()  should be checked to make sure that the size of the "
"symbolic link did not increase between the calls.  Dynamically allocating "
"the buffer for B<readlink>()  and B<readlinkat>()  also addresses a common "
"portability problem when using I<PATH_MAX> for the buffer size, as this "
"constant is not guaranteed to be defined per POSIX if the system does not "
"have such limit."
msgstr ""
"Буфера с фиксированным размером может не хватить для хранения содержимого "
"символьной ссылки. Требуемый размер буфера можно получить как значение I<"
"stat.st_size>, возвращаемое на ссылку вызовом B<lstat>(2). Однако, количество "
"байт, записанное B<readlink>() и B<readlinkat>(), должно быть проверено, так "
"как требуется убедиться, что размер символьной ссылки не увеличился между "
"вызовами. Динамическое выделение буфера для B<readlink>() и B<readlinkat>() "
"также поможет решить проблему с переносимостью, которая возникает, когда для "
"размера буфера используется I<PATH_MAX>, но согласно POSIX для этой константы "
"не гарантируется, что она определена , если система не имеет такого "
"ограничения."

#. type: Plain text
#: man-pages/man2/readlink.2:262
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(), making sure there's"
" no race condition between the calls."
msgstr ""
"Следующая программа динамически выделяет буфер, необходимый B<readlink>(), из "
"информации, предоставленной B<lstat>() и проверяет, что при работы вызовов не "
"возникло состязательности."

#. type: Plain text
#: man-pages/man2/readlink.2:269
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/stat.hE<gt>\n#include E<lt>"
"stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:276
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *linkname;\n"
"    ssize_t r;\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    struct stat sb;\n    char "
"*linkname;\n    ssize_t r;\n"

#. type: Plain text
#: man-pages/man2/readlink.2:281
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>путьE<"
"gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:286
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (lstat(argv[1], &sb) == -1) {\n        perror(\"lstat\");\n        "
"exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:292
#, no-wrap
msgid ""
"    linkname = malloc(sb.st_size + 1);\n"
"    if (linkname == NULL) {\n"
"        fprintf(stderr, \"insufficient memory\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    linkname = malloc(sb.st_size + 1);\n    if (linkname == NULL) {\n        "
"fprintf(stderr, \"недостаточно памяти\\en\");\n        exit(EXIT_FAILURE);\n  "
"  }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:294
#, no-wrap
msgid "    r = readlink(argv[1], linkname, sb.st_size + 1);\n"
msgstr "    r = readlink(argv[1], linkname, sb.st_size + 1);\n"

#. type: Plain text
#: man-pages/man2/readlink.2:299
#, no-wrap
msgid ""
"    if (r == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (r == -1) {\n        perror(\"readlink\");\n        "
"exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:305
#, no-wrap
msgid ""
"    if (r E<gt> sb.st_size) {\n"
"        fprintf(stderr, \"symlink increased in size \"\n"
"                        \"between lstat() and readlink()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (r E<gt> sb.st_size) {\n        fprintf(stderr, \"ссылка увеличилась в "
"размере \"\n                        \"между lstat() и readlink()\\en\");\n    "
"    exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:307
#, no-wrap
msgid "    linkname[r] = \\(aq\\e0\\(aq;\n"
msgstr "    linkname[r] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: man-pages/man2/readlink.2:309
#, no-wrap
msgid ""
"    printf(\"\\(aq%s\\(aq points to \\(aq%s\\(aq\\en\", argv[1], linkname);\n"
msgstr ""
"    printf(\"\\(aq%s\\(aq указывает на \\(aq%s\\(aq\\en\", argv[1], "
"linkname);\n"

#. type: Plain text
#: man-pages/man2/readlink.2:312
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/readlink.2:319
msgid ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<path_resolution>"
"(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr "REMAP_FILE_PAGES"

#. type: TH
#: man-pages/man2/remap_file_pages.2:28
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr "remap_file_pages - создаёт нелинейное файловое отображение"

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* Смотрите feature_test_macros(7) */\nB<"
"#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>"
"\nB<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"

#.  commit 33041a0d76d3c3e0aff28ac95a2ffdedf1282dbc
#.  http://lwn.net/Articles/597632/
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:47
msgid ""
"B<Note>: this system call is (since Linux 3.16) deprecated and will "
"eventually be replaced by a slower in-kernel emulation.  Those few "
"applications that use this system call should consider migrating to "
"alternatives."
msgstr ""
"B<Замечание>: данный системный вызов (начиная с Linux 3.16) устарел и "
"вскоре будет заменён на более медленную эмуляцию ядром. "
"В приложениях, где он используется, нужно применять альтернативные вызовы."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:59
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a"
" nonsequential order in memory.  The advantage of using "
"B<remap_file_pages>()  over using repeated calls to B<mmap>(2)  is that the "
"former approach does not require the kernel to create additional VMA "
"(Virtual Memory Area) data structures."
msgstr ""
"Системный вызов B<remap_file_pages>() используется для создания нелинейного "
"отображения, то есть отображения, в котором страницы файла отображаются в "
"память непоследовательно. Преимущество использования B<remap_file_pages>() по "
"сравнению с повторением вызовов B<mmap>(2) в том, что первый не требует от "
"ядра создания дополнительных структур данных VMA (областей виртуальной "
"памяти)."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:61
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr "Для создания нелинейного отображения выполните следующее:"

#. type: TP
#: man-pages/man2/remap_file_pages.2:61
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:69
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""
"Создайте отображение (пока линейное) с помощью B<mmap>(2). Данное отображение "
"должно создаваться с флагом B<MAP_SHARED>."

#. type: TP
#: man-pages/man2/remap_file_pages.2:69
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:77
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within"
" the mapped region."
msgstr ""
"Выполните переупорядочивание соответствия между страницами отображения и "
"страницами файла с помощью одного или нескольких вызовов B<remap_file_pages>"
"(). Возможно отображать одну страницу файла в несколько мест отображаемой "
"области."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:88
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to"
" be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""
"В аргументах I<pgoff> и I<size> указывается область файла, которая будет "
"перенесёна  в отображение: в I<pgoff> задаётся смещение в файле, измеряемое в "
"размерах системных страниц; в I<size> задаётся длина области в байтах."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:106
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff>"
" and I<size> will be placed."
msgstr ""
"Аргумент I<addr> предназначен для двух целей. Во-первых, им определяется "
"отображение, чьи страницы мы хотим перенести. То есть в I<addr> должен быть "
"указан адрес в области, которая была ранее отображена с помощью вызова B<mmap>"
"(2). Во-вторых, в I<addr> указывается адрес, по которому должны быть помещены "
"файловые страницы, заданные I<pgoff> и I<size>."

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:120
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""
"Значения, указанные в I<addr> и I<size>, должны быть кратны размеру системной "
"страницы. Если это не так, то ядро округляет I<оба> значения I<в меньшую "
"сторону> до ближайшего числа, кратного размеру страницы."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:124
msgid "The I<prot> argument must be specified as 0."
msgstr "Значение аргумента I<prot> должно быть 0."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:132
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""
"Аргумент I<flags> предназначен для того же, что и в B<mmap>(2), но все флаги, "
"кроме B<MAP_NONBLOCK>, игнорируются."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:139
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and"
" I<errno> is set appropriately."
msgstr ""
"При удачном выполнении B<remap_file_pages>() возвращается 0. При ошибке "
"возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:147
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""
"Значение I<addr> не ссылается на допустимое отображение, созданное с флагом "
"B<MAP_SHARED>."

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:156
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr "Некорректное значение в I<addr>, I<size>, I<prot> или I<pgoff>."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:161
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""
"Системный вызов B<remap_file_pages>() появился в Linux 2.5.46; поддержка в "
"glibc началась с версии 2.3.3."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:165
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr "Системный вызов B<remap_file_pages>() есть только в Linux."

#.  commit 3ee6dafc677a68e461a7ddafc94a580ebab80735
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:176
msgid ""
"Since Linux 2.6.23, B<remap_file_pages>()  creates non-linear mappings only "
"on in-memory file systems such as tmpfs, hugetlbfs or ramfs.  On filesystems"
" with a backing store, B<remap_file_pages>()  is not much more efficient "
"than using B<mmap>(2)  to adjust which parts of the file are mapped to which"
" addresses."
msgstr ""
"Начиная с Linux 2.6.23, B<remap_file_pages>() создаёт нелинейные отображения "
"только для файловых систем в оперативной памяти, таких как tmpfs, hugetlbfs "
"или ramfs. Для файловых систем с хранилищем B<remap_file_pages>() не намного "
"эффективнее чем B<mmap>(2), так как рассчитывает адреса для частей файла."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:182
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<"
"msync>(2)"

#. type: TH
#: man-pages/man2/rename.2:33
#, no-wrap
msgid "RENAME"
msgstr "RENAME"

#. type: TH
#: man-pages/man2/rename.2:33
#, no-wrap
msgid "2014-05-08"
msgstr "2014-05-08"

#. type: Plain text
#: man-pages/man2/rename.2:36
msgid "rename, renameat, renameat2 - change the name or location of a file"
msgstr "rename, renameat, renameat2 - изменяет имя или расположение файла"

#. type: Plain text
#: man-pages/man2/rename.2:39
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/rename.2:41
#, no-wrap
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/rename.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант AT_* */\nB<"
"#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/rename.2:47
#, no-wrap
msgid ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"
msgstr ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\nB<            "
" int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/rename.2:51
#, no-wrap
msgid ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >"
"I<flags>B<);>\n"
msgstr ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\nB<           "
"   int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >I<flags>B<);>"
"\n"

#. type: Plain text
#: man-pages/man2/rename.2:59
msgid "B<renameat>():"
msgstr "B<renameat>():"

#. type: Plain text
#: man-pages/man2/rename.2:81
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any"
" other hard links to the file (as created using B<link>(2))  are unaffected."
"  Open file descriptors for I<oldpath> are also unaffected."
msgstr ""
"Вызов B<rename>() переименовывает файл и, если требуется, перемещает его из "
"одного каталога в другой. Все прочие жёсткие ссылки на файл (созданные с "
"помощью B<link>(2)), не изменяются. Открытые файловые дескрипторы на I<"
"oldpath> также не изменяются."

#. type: Plain text
#: man-pages/man2/rename.2:89
msgid ""
"If I<newpath> already exists, it will be atomically replaced (subject to a "
"few conditions; see ERRORS below), so that there is no point at which "
"another process attempting to access I<newpath> will find it missing."
msgstr ""
"Если I<newpath> уже существует, то он будет атомарно перезаписан (при "
"определённых условиях, смотрите ОШИБКИ ниже) так, что другой процесс, "
"пытающийся обратиться к I<newpath>, не сможет определить его временное "
"отсутствие."

#. type: Plain text
#: man-pages/man2/rename.2:97
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""
"Если I<oldpath> и I<newpath> являются жёсткими ссылками на один и тот же "
"файл, то B<rename>() ничего не делает и возвращает код успешного выполнения."

#. type: Plain text
#: man-pages/man2/rename.2:105
msgid ""
"If I<newpath> exists but the operation fails for some reason, B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""
"Если I<newpath> существует, но операция завершается ошибкой, то B<rename>() "
"гарантирует, что I<newpath> останется нетронутым."

#. type: Plain text
#: man-pages/man2/rename.2:111
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""
"В I<oldpath> может быть указан каталог. В этом случае каталог в I<newpath> "
"должен или не существовать, или должен быть пуст."

#. type: Plain text
#: man-pages/man2/rename.2:118
msgid ""
"However, when overwriting there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""
"Однако, при перезаписи, вероятно, будет временной промежуток, в котором оба "
"значения, I<oldpath> и I<newpath>, ссылаются на переименовываемый файл."

#. type: Plain text
#: man-pages/man2/rename.2:124
msgid ""
"If I<oldpath> refers to a symbolic link, the link is renamed; if I<newpath> "
"refers to a symbolic link, the link will be overwritten."
msgstr ""
"Если I<oldpath> является символьной ссылкой, то она переименовывается; если "
"I<newpath> является символьной ссылкой, то будет вновь записан файл, на "
"который она указывает."

#. type: SS
#: man-pages/man2/rename.2:124
#, no-wrap
msgid "renameat ()"
msgstr "renameat ()"

#. type: Plain text
#: man-pages/man2/rename.2:130
msgid ""
"The B<renameat>()  system call operates in exactly the same way as "
"B<rename>(), except for the differences described here."
msgstr ""
"Системный вызов B<renameat>() работает также как системный вызов B<rename>(), "
"за исключением случаев, описанных далее."

#. type: Plain text
#: man-pages/man2/rename.2:140
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<rename>()  for a relative pathname)."
msgstr ""
"Если в I<oldpath> указан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<olddirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<rename>())."

#. type: Plain text
#: man-pages/man2/rename.2:152
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<rename>())."
msgstr ""
"Если в I<oldpath> указан относительный путь и I<olddirfd> равно специальному "
"значению B<AT_FDCWD>, то I<oldpath> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<rename>())."

#. type: Plain text
#: man-pages/man2/rename.2:158
msgid "If I<oldpath> is absolute, then I<olddirfd> is ignored."
msgstr "Если в I<oldpath> указан абсолютный путь, то I<olddirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/rename.2:166
msgid ""
"The interpretation of I<newpath> is as for I<oldpath>, except that a "
"relative pathname is interpreted relative to the directory referred to by "
"the file descriptor I<newdirfd>."
msgstr ""
"Значение I<newpath> интерпретируется как I<oldpath>, за исключением того, что "
"относительный путь интерпретируется относительно каталога, на который "
"ссылается файловый дескриптор I<newdirfd>."

#. type: Plain text
#: man-pages/man2/rename.2:171
msgid "See B<openat>(2)  for an explanation of the need for B<renameat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<renameat>()."

#. type: SS
#: man-pages/man2/rename.2:171
#, no-wrap
msgid "renameat2()"
msgstr "renameat2()"

#. type: Plain text
#: man-pages/man2/rename.2:182
msgid ""
"B<renameat2>()  has an additional I<flags> argument.  A B<renameat2>()  call"
" with a zero I<flags> argument is equivalent to B<renameat>()."
msgstr ""
"Вызов B<renameat2>() имеет дополнительный аргумент I<flags>. Если значение I<"
"flags> равно нулю, то B<renameat2>() эквивалентен B<renameat>()."

#. type: Plain text
#: man-pages/man2/rename.2:186
msgid ""
"The I<flags> argument is a bit mask consisting of zero or more of the "
"following flags:"
msgstr ""
"Аргумент I<flags> является битовой маской, состоящей из нуля или более "
"следующих флагов:"

#. type: TP
#: man-pages/man2/rename.2:186
#, no-wrap
msgid "B<RENAME_NOREPLACE>"
msgstr "B<RENAME_NOREPLACE>"

#. type: Plain text
#: man-pages/man2/rename.2:194
msgid ""
"Don't overwrite I<newpath>.  of the rename.  Return an error if I<newpath> "
"already exists."
msgstr ""
"Не перезаписывать I<newpath>. Возвращать ошибку, если I<newpath> уже "
"существует."

#. type: TP
#: man-pages/man2/rename.2:194
#, no-wrap
msgid "B<RENAME_EXCHANGE>"
msgstr "B<RENAME_EXCHANGE>"

#. type: Plain text
#: man-pages/man2/rename.2:203
msgid ""
"Atomically exchange I<oldpath> and I<newpath>.  Both pathnames must exist "
"but may be of different types (e.g., one could be a non-empty directory and "
"the other a symbolic link)."
msgstr ""
"Атомарно обменять I<oldpath> и I<newpath>. Оба пути должны существовать, но "
"могут быть различных типов (например, один может быть непустым каталогом, а "
"другой символической ссылкой)."

#. type: Plain text
#: man-pages/man2/rename.2:208
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<"
"errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/rename.2:228
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""
"Запись в каталог, содержащий I<oldpath> или I<newpath>, запрещена, или в "
"одном из каталогов пути I<oldpath> или I<newpath> нельзя производить поиск, "
"или I<oldpath> является каталогом, в который запрещена запись (требует "
"обновления элемента I<..>); смотрите также B<path_resolution>(7))."

#. type: TP
#: man-pages/man2/rename.2:228
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/rename.2:245
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such "
"cases\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""
"Переименование завершилось неудачно, так как I<oldpath> или I<newpath> "
"является каталогом, который используется другим процессом (возможно в "
"качестве текущего рабочего каталога или в качестве корневого каталога, или он "
"открыт на чтение), или используется системой (например, в качестве точки "
"монтирования), и система считает это ошибкой (заметим, что нет требования "
"возвращать B<EBUSY> в таких случаях — нет ничего неправильного в таком "
"переименовании — но разрешается возвращать B<EBUSY>, если система не может "
"иначе обработать такие ситуации)."

#. type: Plain text
#: man-pages/man2/rename.2:248
msgid "The user's quota of disk blocks on the filesystem has been exhausted."
msgstr "Исчерпана пользовательская квота на дисковые блоки файловой системы."

#. type: Plain text
#: man-pages/man2/rename.2:251
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""
"Значения I<oldpath> и I<newpath> указывают за пределы доступного адресного "
"пространства."

#. type: Plain text
#: man-pages/man2/rename.2:255
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""
"Новый путь содержит префикс старого пути или, в более общем смысле, "
"выполняется попытка сделать каталог подкаталогом самого себя."

#. type: Plain text
#: man-pages/man2/rename.2:261
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""
"Каталог I<newpath> уже существует, но I<oldpath> не является каталогом."

#. type: Plain text
#: man-pages/man2/rename.2:265
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""
"Во время определения I<oldpath> или I<newpath> встретилось слишком много "
"символьных ссылок."

#. type: TP
#: man-pages/man2/rename.2:265
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: man-pages/man2/rename.2:272
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""
"В I<oldpath> уже имеется максимальное количество ссылок, или каталог, "
"содержащий I<newpath>, уже имеет максимальное количество ссылок."

#. type: Plain text
#: man-pages/man2/rename.2:275
msgid "I<oldpath> or I<newpath> was too long."
msgstr "Слишком длинное значение аргумента I<oldpath> или I<newpath>."

#. type: Plain text
#: man-pages/man2/rename.2:288
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""
"Ссылка, на которую ссылается I<oldpath>, не существует; компонент каталога в "
"I<newpath> не существует; в I<oldpath> или I<newpath> указана пустая строка."

#. type: TP
#: man-pages/man2/rename.2:291
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/rename.2:295
msgid "The device containing the file has no room for the new directory entry."
msgstr ""
"На устройстве, содержащем файл, нет места для создания нового элемента "
"каталога."

#. type: Plain text
#: man-pages/man2/rename.2:305
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact,"
" a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""
"Компонент, используемый как каталог в I<oldpath> или I<newpath>, в "
"действительности не является каталогом. Или I<oldpath> является каталогом и "
"существует I<newpath>, который не является каталогом."

#. type: TP
#: man-pages/man2/rename.2:305
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr "B<ENOTEMPTY> или B<EEXIST>"

#. type: Plain text
#: man-pages/man2/rename.2:309
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than "
"\".\" and \"..\"."
msgstr ""
"Значение I<newpath> является непустым каталогом, то есть содержит элементы, "
"отличные от «.» и «..»."

#. type: TP
#: man-pages/man2/rename.2:309
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr "B<EPERM> или B<EACCES>"

#. type: Plain text
#: man-pages/man2/rename.2:333
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and"
" the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of"
" the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the filesystem containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""
"Каталог, содержащийся в I<oldpath>, имеет закрепляющий бит (B<S_ISVTX>) и "
"эффективный идентификатор процесса не совпадает с идентификатором "
"пользователя удаляемого файла или каталога, его содержащего, и процесс не "
"имеет прав (Linux: нет мандата B<CAP_FOWNER>); или I<newpath> является "
"существующим файлом и каталог, содержащий его, имеет закрепляющий бит и "
"эффективный идентификатор процесса не совпадает с идентификатором "
"пользователя замещаемого файла или каталога, его содержащего, и процесс не "
"имеет прав (Linux: нет мандата B<CAP_FOWNER>); или файловая система, "
"содержащая I<pathname>, не поддерживает переименования запрашиваемого типа."

#. type: TP
#: man-pages/man2/rename.2:333
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man2/rename.2:336
msgid "The file is on a read-only filesystem."
msgstr "Файл расположен в файловой системе, доступной только для чтения."

#. type: TP
#: man-pages/man2/rename.2:336
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: man-pages/man2/rename.2:344
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<rename>()  does"
" not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""
"Элементы I<oldpath> и I<newpath> находятся не в одной смонтированной файловой "
"системе (Linux позволяет монтировать файловую систему в несколько точек, но "
"B<rename>() не работает с различающимися точками монтирования, даже если в "
"них смонтирована идентичная файловая система)."

#. type: Plain text
#: man-pages/man2/rename.2:349
msgid ""
"The following additional errors can occur for B<renameat>()  and "
"B<renameat2>():"
msgstr ""
"В B<renameat>() и B<renameat2>() дополнительно могут возникнуть следующие "
"ошибки:"

#. type: Plain text
#: man-pages/man2/rename.2:355
msgid "I<olddirfd> or I<newdirfd> is not a valid file descriptor."
msgstr ""
"Значение I<olddirfd> или I<newdirfd> не является правильным файловым "
"дескриптором."

#. type: Plain text
#: man-pages/man2/rename.2:365
msgid ""
"I<oldpath> is relative and I<olddirfd> is a file descriptor referring to a "
"file other than a directory; or similar for I<newpath> and I<newdirfd>"
msgstr ""
"Значение I<oldpath> содержит относительный путь и I<olddirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог; или произошло тоже "
"самое с I<newpath> и I<newdirfd>."

#. type: Plain text
#: man-pages/man2/rename.2:368
msgid "The following additional errors can occur for B<renameat2>():"
msgstr "В B<renameat2>() дополнительно могут возникнуть следующие ошибки:"

#. type: TP
#: man-pages/man2/rename.2:368
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: man-pages/man2/rename.2:376
msgid "I<flags> contains B<RENAME_NOREPLACE> and I<newpath> already exists."
msgstr ""
"Значение I<flags> содержит B<RENAME_NOREPLACE>, а I<newpath> уже существует."

#. type: Plain text
#: man-pages/man2/rename.2:385
msgid ""
"An invalid flag was specified in I<flags>, or both B<RENAME_NOREPLACE> and "
"B<RENAME_EXCHANGE> were specified."
msgstr ""
"В I<flags> указан некорректный флаг, или указаны сразу B<RENAME_NOREPLACE> и "
"B<RENAME_EXCHANGE>."

#. type: Plain text
#: man-pages/man2/rename.2:389
msgid "The filesystem does not support one of the flags in I<flags>."
msgstr "Файловая система не поддерживает один из флагов в I<flags>."

#. type: Plain text
#: man-pages/man2/rename.2:397
msgid "I<flags> contains B<RENAME_EXCHANGE> and I<newpath> does not exist."
msgstr "В I<flags> содержится B<RENAME_EXCHANGE>, но I<newpath> не существует."

#. type: Plain text
#: man-pages/man2/rename.2:401
msgid ""
"B<renameat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Системный вызов B<renameat>() был добавлен в ядро Linux версии 2.6.16; "
"поддержка в glibc доступна с версии 2.4."

#.  FIXME glibc support is pending.
#. type: Plain text
#: man-pages/man2/rename.2:405
msgid "B<renameat2>()  was added to Linux in kernel 3.15."
msgstr "Вызов B<renameat2>() был добавлен в ядро Linux 3.15."

#. type: Plain text
#: man-pages/man2/rename.2:408
msgid "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/rename.2:411
msgid "B<renameat>(): POSIX.1-2008."
msgstr "B<renameat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/rename.2:414
msgid "B<renameat2()> is Linux-specific."
msgstr "Вызов B<renameat2()> есть только в Linux."

#. type: Plain text
#: man-pages/man2/rename.2:425
msgid ""
"On NFS filesystems, you can not assume that if the operation failed, the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up"
" again causes a failure.  The application is expected to deal with this.  "
"See B<link>(2)  for a similar problem."
msgstr ""
"При работе с файловыми системами NFS нельзя считать, что если операция "
"завершилась неудачно, то имя файла не изменилось. Если сервер производит "
"операцию переименования, а затем аварийно останавливает свою работу, то "
"перепосланный пакет RPC будет вновь обработан при восстановлении работы "
"сервера, что вызовет сообщение об ошибке. Приложение в этой ситуации должно "
"работать корректно. Смотрите B<link>(2), где описывается подобная проблема."

#. type: Plain text
#: man-pages/man2/rename.2:432
msgid ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), B<"
"path_resolution>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr "RMDIR"

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "2008-05-08"
msgstr "2008-05-08"

#. type: Plain text
#: man-pages/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr "rmdir - удалить каталог"

#. type: Plain text
#: man-pages/man2/rmdir.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr "B<int rmdir(const char *>I<pathname>B<);>"

#. type: Plain text
#: man-pages/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr "B<rmdir>() удаляет каталог, который должен быть пуст."

#. type: Plain text
#: man-pages/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one"
" of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""
"Нет прав на запись в каталог, содержащийся в I<pathname>, или в одном из "
"каталогов в I<pathname> не разрешён поиск (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""
"В данный момент I<pathname> используется системой или одним из процессов, что "
"предотвращает удаление. В Linux это означает, что I<pathname> используется в "
"качестве точки монтирования или является корневым каталогом вызвавшего "
"процесса."

#. type: Plain text
#: man-pages/man2/rmdir.2:67
msgid "I<pathname> points outside your accessible address space."
msgstr ""
"Аргумент I<pathname> указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr "I<pathname> содержит I<.> в качестве последнего компонента."

#. type: Plain text
#: man-pages/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""
"Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/rmdir.2:80
msgid "I<pathname> was too long."
msgstr "I<pathname> слишком длинен."

#. type: Plain text
#: man-pages/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"Один из каталогов в I<pathname> не существует или является повисшей "
"символьной ссылкой."

#. type: Plain text
#: man-pages/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""
"I<pathname>, или его компонент, используемый в качестве каталога в I<pathname>"
", фактически, не является каталогом."

#. type: TP
#: man-pages/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr "B<ENOTEMPTY>"

#. type: Plain text
#: man-pages/man2/rmdir.2:107
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has"
" I<..> as its final component.  POSIX.1-2001 also allows B<EEXIST> for this "
"condition."
msgstr ""
"I<pathname> содержит элементы, отличные от I<.> и I<..> ; или последним "
"компонентом I<pathname> является I<..>. POSIX.1-2001 также позволяет "
"возвращать B<EEXIST> в такой ситуации."

#. type: Plain text
#: man-pages/man2/rmdir.2:118
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be"
" deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"На каталоге, содержащемся в I<pathname>, установлен закрепляющий (sticky) бит "
"(B<S_ISVTX>) и эффективный идентификатор пользователя не совпадает с "
"пользовательским ID файла или каталога, его содержащего, что требуется для "
"удаления, и процесс не имеет прав (Linux: не имеет мандата B<CAP_FOWNER>)."

#. type: Plain text
#: man-pages/man2/rmdir.2:123
msgid ""
"The filesystem containing I<pathname> does not support the removal of "
"directories."
msgstr ""
"Файловая система, содержащая I<pathname>, не поддерживает удаление каталогов."

#. type: Plain text
#: man-pages/man2/rmdir.2:127
msgid "I<pathname> refers to a directory on a read-only filesystem."
msgstr ""
"I<pathname> указывает на файл в файловой системе, доступной только для чтения."

#. type: Plain text
#: man-pages/man2/rmdir.2:132
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""
"Неточности в протоколе NFS могут приводить к неожиданному исчезновению "
"каталогов, которые всё ещё используются."

#. type: Plain text
#: man-pages/man2/rmdir.2:140
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"

#. type: TH
#: man-pages/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr "RECV"

#. type: Plain text
#: man-pages/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr "recv, recvfrom, recvmsg - принимает сообщение из сокета"

#. type: Plain text
#: man-pages/man2/recv.2:49
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/recv.2:51
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/recv.2:53
#, no-wrap
msgid ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<);>\n"
msgstr ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<"
"flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/recv.2:56
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >"
"I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<"
");>\n"
msgstr ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >"
"I<flags>B<,>\nB<                 struct sockaddr *>I<src_addr>B<, socklen_t *>"
"I<addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/recv.2:58
#, no-wrap
msgid ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<"
");>\n"

#. type: Plain text
#: man-pages/man2/recv.2:70
msgid ""
"The B<recv>(), B<recvfrom>(), and B<recvmsg>()  calls are used to receive "
"messages from a socket.  They may be used to receive data on both "
"connectionless and connection-oriented sockets.  This page first describes "
"common features of all three system calls, and then describes the "
"differences between the calls."
msgstr ""
"Системные вызовы B<recv>(), B<recvfrom>() и B<recvmsg>() используются для "
"получения сообщений из сокета. Они могут использоваться для получения данных, "
"независимо от того, является ли сокет ориентированным на соединения или нет. "
"В этой странице сперва описаны общие свойства всех трёх системных вызовов, а "
"затем описываются различия между ними."

#. type: Plain text
#: man-pages/man2/recv.2:76
msgid ""
"All three calls return the length of the message on successful completion.  "
"If a message is too long to fit in the supplied buffer, excess bytes may be "
"discarded depending on the type of socket the message is received from."
msgstr ""
"При успешном выполнении все три вызова возвращают длину сообщения. Если "
"сообщение слишком длинное и не поместилось в предоставленный буфер, лишние "
"байты могут быть отброшены, в зависимости от типа сокета, на котором "
"принимаются сообщения."

#. type: Plain text
#: man-pages/man2/recv.2:86
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""
"Если на сокете не доступно ни одного сообщения, то обсуждаемые вызовы ожидают "
"их прибытия, если сокет не помечен как неблокирующий (см. B<fcntl>(2)), в "
"противном случае возвращается значение -1, а внешняя переменная I<errno> "
"устанавливается в значение B<EAGAIN> или B<EWOULDBLOCK>. Все эти вызовы "
"обычно сразу возвращают все доступные данные вплоть до запрошенного объема, а "
"не ждут, пока появятся данные полной запрошенной длины."

#. type: Plain text
#: man-pages/man2/recv.2:93
msgid ""
"An application can use B<select>(2), B<poll>(2), or B<epoll>(7)  to "
"determine when more data arrives on a socket."
msgstr ""
"Для определения появления новых данных в сокете приложение может использовать "
"B<select>(2), B<poll>(2) или B<epoll>(7)."

#. type: SS
#: man-pages/man2/recv.2:93
#, no-wrap
msgid "The flags argument"
msgstr "Аргумент флагов"

#. type: Plain text
#: man-pages/man2/recv.2:97
msgid ""
"The I<flags> argument is formed by ORing one or more of the following "
"values:"
msgstr ""
"Аргумент I<flags> формируется с помощью объединения логической операцией ИЛИ "
"одного или более следующих значений:"

#. type: TP
#: man-pages/man2/recv.2:97
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr "B<MSG_CMSG_CLOEXEC> (только для B<recvmsg>(); начиная с Linux 2.6.23)"

#. type: Plain text
#: man-pages/man2/recv.2:108
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""
"Установить флаг close-on-exec для файлового дескриптора, полученного через "
"доменный файловый дескриптор UNIX, с помощью операции B<SCM_RIGHTS> (описана "
"в B<unix>(7)). Этот флаг полезен по тем же причинам что и флаг B<O_CLOEXEC> у "
"B<open>(2)."

#. type: TP
#: man-pages/man2/recv.2:108
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr "B<MSG_DONTWAIT> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:118
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK> (this can also be enabled using "
"the B<O_NONBLOCK> flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""
"Включить неблокирующий режим. Если операция могла бы привести к блокировке, "
"возвращается B<EAGAIN> или B<EWOULDBLOCK> (этот режим можно также включить с "
"помощью флага B<O_NONBLOCK> и операции B<F_SETFL> через вызов B<fcntl>(2))."

#. type: TP
#: man-pages/man2/recv.2:118
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr "B<MSG_ERRQUEUE> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:137
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of"
" the datagram that caused the error is supplied via I<msg_name>."
msgstr ""
"Указание этого флага позволяет получить из очереди ошибок сокета накопившиеся "
"ошибки. Ошибка передаётся в вспомогательном сообщении тип которого зависит от "
"протокола (для IPv4 это B<IP_RECVERR>). Вызывающий должен предоставить буфер "
"достаточного размера. Дополнительная информация приведена в B<cmsg>(3) и B<ip>"
"(7). Содержимое исходного пакета, который привёл к ошибке, передаётся в виде "
"обычных данных через I<msg_iovec>. Исходный адрес назначения датаграммы, "
"которая привела к ошибке, передаётся через I<msg_name>."

#. type: Plain text
#: man-pages/man2/recv.2:149 man-pages/man2/recv.2:212
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> is set in the I<msghdr>.  After an error has been passed, "
"the pending socket error is regenerated based on the next queued error and "
"will be passed on the next socket operation."
msgstr ""
"Для локальных ошибок адрес не передаётся (это можно выяснить, проверив поле "
"I<cmsg_len> структуры I<cmsghdr>). Для ошибок при приёме устанавливается флаг "
"B<MSG_ERRQUEUE> в I<msghdr>. После того, как ошибка передана программе, "
"следующая ошибка в очереди ошибок становится ожидающей ошибкой и передается "
"программе при следующей операции на сокете."

#. type: Plain text
#: man-pages/man2/recv.2:153
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr "Ошибка передаётся в виде структуры I<sock_extended_err>:"

#. type: Plain text
#: man-pages/man2/recv.2:160
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""
"#define SO_EE_ORIGIN_NONE    0\n#define SO_EE_ORIGIN_LOCAL   1\n#define "
"SO_EE_ORIGIN_ICMP    2\n#define SO_EE_ORIGIN_ICMP6   3\n"

#. type: Plain text
#: man-pages/man2/recv.2:172
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;     /* padding */\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""
"struct sock_extended_err\n{\n    uint32_t ee_errno;   /* номер ошибки */\n    "
"uint8_t  ee_origin;  /* источник её происхождения */\n    uint8_t  ee_type;   "
" /* тип */\n    uint8_t  ee_code;    /* код */\n    uint8_t  ee_pad;     /* "
"заполнение для выравнивания */\n    uint32_t ee_info;    /* дополнительная "
"информация */\n    uint32_t ee_data;    /* прочие данные */\n    /* далее "
"могут содержаться ещё данные */\n};\n"

#. type: Plain text
#: man-pages/man2/recv.2:174
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"

#. type: Plain text
#: man-pages/man2/recv.2:198
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""
"В I<ee_errno> содержится значение I<errno> для ожидающей ошибки. В I<"
"ee_origin> содержится источник происхождения ошибки. Смысл остальных полей "
"зависит от протокола. Макрос B<SOCK_EE_OFFENDER> возвращает указатель на "
"адрес сетевого объекта, породившего ошибку. Если этот адрес неизвестен, то "
"поле I<sa_family> структуры I<sockaddr> содержит значение B<AF_UNSPEC>, а "
"прочие поля структуры I<sockaddr> не определены. Содержимое пакета, "
"вызвавшего ошибку, передаётся в виде обычных данных."

#. type: TP
#: man-pages/man2/recv.2:212 man-pages/man2/recv.2:401
#, no-wrap
msgid "B<MSG_OOB>"
msgstr "B<MSG_OOB>"

#. type: Plain text
#: man-pages/man2/recv.2:219
msgid ""
"This flag requests receipt of out-of-band data that would not be received in"
" the normal data stream.  Some protocols place expedited data at the head of"
" the normal data queue, and thus this flag cannot be used with such "
"protocols."
msgstr ""
"Этот флаг запрашивает приём внеполосных данных, которые в противном случае не "
"были бы получены в обычном потоке данных. Некоторые протоколы помещают данные "
"повышенной срочности в начало очереди с обычными данными, и поэтому этот флаг "
"не может использоваться с такими протоколами."

#. type: TP
#: man-pages/man2/recv.2:219
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr "B<MSG_PEEK>"

#. type: Plain text
#: man-pages/man2/recv.2:226
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""
"Этот флаг заставляет выбрать данные из начала очереди приёма, но не удалять "
"их оттуда. Таким образом, последующий вызов вернёт те же самые данные."

#. type: TP
#: man-pages/man2/recv.2:226
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr "B<MSG_TRUNC> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:234
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22), and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer."
msgstr ""
"Для «сырых» данных (B<AF_PACKET>), дейтаграмм Интернета (начиная с Linux "
"2.4.27/2.6.8), netlink (начиная с Linux 2.6.22) и дейтаграмм UNIX (начиная с "
"Linux 3.4) возвращает реальную длину пакета или дейтаграммы, даже если она "
"была больше, чем предоставленный буфер."

#. type: Plain text
#: man-pages/man2/recv.2:237
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""
"Описание использования с потоковым сокетами Интернета смотрите в B<tcp>(7)."

#. type: TP
#: man-pages/man2/recv.2:237
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr "B<MSG_WAITALL> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:245
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a"
" signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned."
msgstr ""
"Этим флагом включается блокирование операции до полной обработки запроса. "
"Однако, этот вызов всё равно может вернуть меньше данных, чем было запрошено, "
"если был пойман сигнал, произошла ошибка или разрыв соединения, или если "
"начали поступать данные другого типа, не того, который был сначала."

#. type: SS
#: man-pages/man2/recv.2:245
#, no-wrap
msgid "recvfrom()"
msgstr "recvfrom()"

#. type: Plain text
#: man-pages/man2/recv.2:251
msgid ""
"B<recvfrom>()  places the received message into the buffer I<buf>.  The "
"caller must specify the size of the buffer in I<len>."
msgstr ""
"Вызов B<recvfrom>() помещает принятое сообщение в буфер I<buf>. Вызывающий "
"должен указать размер буфера в I<len>."

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: man-pages/man2/recv.2:279
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address of the message, that source address is placed in the buffer pointed "
"to by I<src_addr>.  In this case, I<addrlen> is a value-result argument.  "
"Before the call, it should be initialized to the size of the buffer "
"associated with I<src_addr>.  Upon return, I<addrlen> is updated to contain "
"the actual size of the source address.  The returned address is truncated if"
" the buffer provided is too small; in this case, I<addrlen> will return a "
"value greater than was supplied to the call."
msgstr ""
"Если значение I<src_addr> не равно NULL, и в нижележащем протоколе "
"используется адрес источника сообщения, то адрес источника помещается в "
"буфер, указанный в I<src_addr>. В этом случае I<addrlen> является "
"аргументом-результатом. Перед вызовом ему должно быть присвоено значение "
"длины буфера, связанного с I<src_addr>. При возврате I<addrlen> обновляется и "
"содержит действительный размер адреса источника. Возвращаемый адрес "
"обрезается, если предоставленный буфер слишком мал; в этом случае I<addrlen> "
"будет содержать значение большее, чем указывалось в вызове."

#. type: Plain text
#: man-pages/man2/recv.2:286
msgid ""
"If the caller is not interested in the source address, I<src_addr> and "
"I<addrlen> should be specified as NULL."
msgstr ""
"Если вызывающему адрес источника не нужен, то значение I<src_addr> "
"и I<addrlen> должно быть равно NULL."

#. type: SS
#: man-pages/man2/recv.2:286
#, no-wrap
msgid "recv()"
msgstr "recv()"

#. type: Plain text
#: man-pages/man2/recv.2:294
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2)).  It is equivalent to the call:"
msgstr ""
"Вызов B<recv>(), обычно, используется только на I<соединённом> сокете "
"(смотрите B<connect>(2)). Он идентичен вызову:"

#. type: Plain text
#: man-pages/man2/recv.2:297
#, no-wrap
msgid "    recvfrom(fd, buf, len, flags, NULL, 0));\n"
msgstr "    recvfrom(fd, buf, len, flags, NULL, 0));\n"

#. type: SS
#: man-pages/man2/recv.2:297
#, no-wrap
msgid "recvmsg()"
msgstr "recvmsg()"

#. type: Plain text
#: man-pages/man2/recv.2:305
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""
"Для минимизации количества передаваемых аргументов в вызов B<recvmsg>() "
"используется структура I<msghdr>. Она определена в I<E<lt>sys/socket.hE<gt>> "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/recv.2:312
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {                    /* массив элементов приёма/передачи */\n    "
"void  *iov_base;              /* начальный адрес */\n    size_t iov_len;      "
"         /* количество передаваемых байт */\n};\n"

#. type: Plain text
#: man-pages/man2/recv.2:322
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* optional address */\n"
"    socklen_t     msg_namelen;    /* size of address */\n"
"    struct iovec *msg_iov;        /* scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* ancillary data, see below */\n"
"    size_t        msg_controllen; /* ancillary data buffer len */\n"
"    int           msg_flags;      /* flags on received message */\n"
"};\n"
msgstr ""
"struct msghdr {\n    void         *msg_name;       /* необязательный адрес "
"*/\n    socklen_t     msg_namelen;    /* размер адреса */\n    struct iovec "
"*msg_iov;        /* массив приёма/передачи */\n    size_t        msg_iovlen;  "
"   /* количество элементов в msg_iov */\n    void         *msg_control;    /* "
"вспомогательные данные,\n                                     см. ниже */\n   "
" size_t        msg_controllen; /* размер буфера вспомогательных\n             "
"                        данных */\n    int           msg_flags;      /* флаги "
"принятого сообщения */\n};\n"

#. type: Plain text
#: man-pages/man2/recv.2:338
msgid ""
"The I<msg_name> field points to a caller-allocated buffer that is used to "
"return the source address if the socket is unconnected.  The caller should "
"set I<msg_namelen> to the size of this buffer before this call; upon return "
"from a successful call, I<msg_name> will contain the length of the returned "
"address.  If the application does not need to know the source address, "
"I<msg_name> can be specified as NULL."
msgstr ""
"Поле I<msg_name> указывает на выделенный вызывающим буфер, который "
"используется для возврата адреса источника, если сокет не соединён. "
"Вызывающий должен указать в I<msg_namelen> размер этого буфера перед вызовом; "
"при успешном выполнении вызова в I<msg_name> будет содержаться длина "
"возвращаемого адреса. Если приложению не нужно знать адрес источника, то в I<"
"msg_name> можно указать NULL."

#. type: Plain text
#: man-pages/man2/recv.2:345
msgid ""
"The fields I<msg_iov> and I<msg_iovlen> describe scatter-gather locations, "
"as discussed in B<readv>(2)."
msgstr ""
"В полях I<msg_iov> и I<msg_iovlen> описываются место приёма/передачи, "
"обсуждаемые в B<readv>(2)."

#. type: Plain text
#: man-pages/man2/recv.2:360
msgid ""
"The field I<msg_control>, which has length I<msg_controllen>, points to a "
"buffer for other protocol control-related messages or miscellaneous "
"ancillary data.  When B<recvmsg>()  is called, I<msg_controllen> should "
"contain the length of the available buffer in I<msg_control>; upon return "
"from a successful call it will contain the length of the control message "
"sequence."
msgstr ""
"Поле I<msg_control> длиной I<msg_controllen> указывает на буфер для других "
"сообщений, связанных с управлением протоколом или на буфер для разнообразных "
"вспомогательных данных. При вызове B<recvmsg>() в поле I<msg_controllen> "
"должен указываться размер доступного буфера, чей адрес передан в I<"
"msg_control>; при успешном выполнении вызова в этом параметре будет "
"находиться длина последовательности контрольных сообщений."

#. type: Plain text
#: man-pages/man2/recv.2:362
msgid "The messages are of the form:"
msgstr "Сообщения имеют следующий вид:"

#. type: Plain text
#: man-pages/man2/recv.2:372
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    socklen_t     cmsg_len;     /* data byte count, including hdr */\n"
"    int           cmsg_level;   /* originating protocol */\n"
"    int           cmsg_type;    /* protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""
"struct cmsghdr {\n    socklen_t     cmsg_len;     /* количество байт данных, "
"включая hdr */\n    int           cmsg_level;   /* изначальный протокол */\n  "
"  int           cmsg_type;    /* тип, зависящий от протокола */\n/* дальше "
"следует\n    unsigned char cmsg_data[]; */\n};\n"

#. type: Plain text
#: man-pages/man2/recv.2:377
msgid ""
"Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""
"К вспомогательным данным нужно обращаться только с помощью макросов, "
"определённых в B<cmsg>(3)."

#. type: Plain text
#: man-pages/man2/recv.2:380
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""
"Например, этот механизм вспомогательных данных используется в Linux для "
"передачи расширенных ошибок, флагов IP и файловых дескрипторов через доменные "
"сокеты Unix."

#. type: Plain text
#: man-pages/man2/recv.2:388
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""
"При возврате из B<recvmsg>() устанавливается значение поля I<msg_flags> в I<"
"msghdr>. Оно может содержать несколько флагов:"

#. type: TP
#: man-pages/man2/recv.2:388
#, no-wrap
msgid "B<MSG_EOR>"
msgstr "B<MSG_EOR>"

#. type: Plain text
#: man-pages/man2/recv.2:393
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""
"означает конец записи: возвращённые данные заканчивают запись (обычно "
"используется вместе с сокетами типа B<SOCK_SEQPACKET>)."

#. type: TP
#: man-pages/man2/recv.2:393
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr "B<MSG_TRUNC>"

#. type: Plain text
#: man-pages/man2/recv.2:397
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""
"означает, что хвостовая часть датаграммы была отброшена, потому что "
"датаграмма была больше, чем предоставленный буфер."

#. type: TP
#: man-pages/man2/recv.2:397
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr "B<MSG_CTRUNC>"

#. type: Plain text
#: man-pages/man2/recv.2:401
msgid ""
"indicates that some control data were discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""
"означает, что часть управляющих данных была отброшена из-за недостатка места "
"в буфере вспомогательных данных."

#. type: Plain text
#: man-pages/man2/recv.2:404
msgid ""
"is returned to indicate that expedited or out-of-band data were received."
msgstr "возвращается для индикации получения внеполосных данных."

#. type: TP
#: man-pages/man2/recv.2:404
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr "B<MSG_ERRQUEUE>"

#. type: Plain text
#: man-pages/man2/recv.2:408
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""
"означает, что были получены не данные, а расширенное сообщение об ошибке из "
"очереди ошибок сокета."

#. type: Plain text
#: man-pages/man2/recv.2:414
msgid ""
"These calls return the number of bytes received, or -1 if an error occurred."
"  In the event of an error, I<errno> is set to indicate the error."
msgstr ""
"Эти вызовы возвращают количество принятых байт или -1, если произошла ошибка. "
"В случае ошибки в I<errno> записывается код ошибки."

#. type: Plain text
#: man-pages/man2/recv.2:417
msgid ""
"When a stream socket peer has performed an orderly shutdown, the return "
"value will be 0 (the traditional \"end-of-file\" return)."
msgstr ""
"Когда ответная сторона потока выполняет корректное отключение (shutdown), то "
"возвращается 0 (обычный возврат «конец файла»)."

#. type: Plain text
#: man-pages/man2/recv.2:421
msgid ""
"Datagram sockets in various domains (e.g., the UNIX and Internet domains)  "
"permit zero-length datagrams.  When such a datagram is received, the return "
"value is 0."
msgstr ""
"В датаграмных сокетах некоторых доменов (например, доменах UNIX и Internet) "
"разрешены датаграммы нулевой длины. При получении такой датаграммы "
"возвращается значение 0."

#. type: Plain text
#: man-pages/man2/recv.2:424
msgid ""
"The value 0 may also be returned if the requested number of bytes to receive"
" from a stream socket was 0."
msgstr ""
"Также значение 0 может возвращаться, если запрошенное количество принимаемых "
"байт из потокового сокета равно 0."

#. type: Plain text
#: man-pages/man2/recv.2:429
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""
"Здесь представлено несколько стандартных ошибок, возвращаемых с уровня "
"сокетов. Могут также появиться другие ошибки, возвращаемые из соответствующих "
"протокольных модулей; их описание находится в соответствующих справочных "
"страницах."

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/recv.2:438
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a"
" receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""
"Сокет помечен как неблокируемый, а операция приёма привела бы к блокировке, "
"или установлено время ожидания данных и это время истекло до получения "
"данных. Согласно POSIX.1-2001 в этом случае может возвращаться любая ошибка и "
"не требуется, чтобы эти константы имели одинаковое значение, поэтому "
"переносимое приложение должно проверить оба случая."

#. type: Plain text
#: man-pages/man2/recv.2:443
msgid "The argument I<sockfd> is an invalid descriptor."
msgstr "Аргумент I<sockfd> содержит неверный дескриптор."

#. type: TP
#: man-pages/man2/recv.2:443
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: man-pages/man2/recv.2:447
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""
"Удалённый узел отказался устанавливать сетевое соединение (обычно потому, что "
"там не работает запрошенная служба)."

#. type: Plain text
#: man-pages/man2/recv.2:451
msgid ""
"The receive buffer pointer(s) point outside the process's address space."
msgstr ""
"Указатель на приёмный буфер указывает вне адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/recv.2:456
msgid ""
"The receive was interrupted by delivery of a signal before any data were "
"available; see B<signal>(7)."
msgstr ""
"Приём данных был прерван сигналом, а данные ещё не были доступны; см. B<"
"signal>(7)."

#.  e.g., msg_namelen < 0 for recvmsg() or addrlen < 0 for recvfrom()
#. type: Plain text
#: man-pages/man2/recv.2:460
msgid "Invalid argument passed."
msgstr "Передан неверный аргумент."

#. type: Plain text
#: man-pages/man2/recv.2:464
msgid "Could not allocate memory for B<recvmsg>()."
msgstr "Не удалось выдели память для B<recvmsg>()."

#. type: TP
#: man-pages/man2/recv.2:464
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man2/recv.2:471
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""
"Сокет, связанный с протоколом, ориентированным на соединение, не был соединён "
"(см. B<connect>(2) и B<accept>(2))."

#. type: TP
#: man-pages/man2/recv.2:471
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/recv.2:476
msgid "The argument I<sockfd> does not refer to a socket."
msgstr "Аргумент I<sockfd> не указывает на сокет."

#. type: Plain text
#: man-pages/man2/recv.2:479
msgid "4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""
"4.4BSD (эти системные вызовы впервые появились в 4.2BSD), POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/recv.2:486
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""
"В POSIX.1-2001 описаны только флаги B<MSG_OOB>, B<MSG_PEEK> и B<MSG_WAITALL>."

#. type: Plain text
#: man-pages/man2/recv.2:502
msgid ""
"The prototypes given above follow glibc2.  The Single UNIX Specification "
"agrees, except that it has return values of type I<ssize_t> (while 4.x BSD "
"and libc4 and libc5 all have I<int>).  The I<flags> argument is I<int> in "
"4.x BSD, but I<unsigned int> in libc4 and libc5.  The I<len> argument is "
"I<int> in 4.x BSD, but I<size_t> in libc4 and libc5.  The I<addrlen> "
"argument is I<int\\ *> in 4.x BSD, libc4 and libc5.  The present "
"I<socklen_t\\ *> was invented by POSIX.  See also B<accept>(2)."
msgstr ""
"Вышеприведенные прототипы соответствуют glibc2. Они соответствуют стандарту "
"Single UNIX Specification, за исключением того, что там возвращаемые значения "
"имеют тип I<ssize_t> (тогда как в BSD 4.x, libc4 и libc5 имеют тип I<int>). "
"Аргумент I<flags> в BSD 4.x имеет тип I<int>, а в libc4 и libc5 \\(em I<"
"unsigned int>. Аргумент I<len> в BSD 4.x имеет тип I<int>, а в libc4 и libc5 "
"\\(em I<size_t>. В 4.x BSD, libc4 и libc5 аргумент I<addrlen> имеет тип I<"
"int\\ *>. Для соответствия POSIX у данных вызовов он имеет тип I<socklen_t\\ "
"*>. Смотрите также B<accept>(2)."

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/recv.2:516
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr ""
"В соответствие с POSIX.1-2001 поле I<msg_controllen> структуры I<msghdr> "
"должно иметь тип I<socklen_t>, но в настоящее время в glibc оно имеет тип I<"
"size_t>."

#. type: Plain text
#: man-pages/man2/recv.2:521
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""
"В B<recvmmsg>(2) можно найти информацию о специальном системном вызове Linux, "
"который можно использовать для приёма нескольких датаграмм за один вызов."

#. type: Plain text
#: man-pages/man2/recv.2:526
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr "Пример использования B<recvfrom>() показан в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man2/recv.2:536
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<socket>(7)"
msgstr ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), B<"
"shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<socket>(7)"

#. type: TH
#: man-pages/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr "REMOVEXATTR"

#. type: TH
#: man-pages/man2/removexattr.2:25
#, no-wrap
msgid "2014-02-06"
msgstr "2014-02-06"

#. type: Plain text
#: man-pages/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr ""
"removexattr, lremovexattr, fremovexattr - удаление расширенных атрибутов"

#. type: Plain text
#: man-pages/man2/removexattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\nB<"
"int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\nB<int "
"fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man2/removexattr.2:49
msgid ""
"Extended attributes are I<name>:value pairs associated with inodes (files, "
"directories, symbolic links, etc.).  They are extensions to the normal "
"attributes which are associated with all inodes in the system (i.e., the "
"B<stat>(2)  data).  A complete overview of extended attributes concepts can "
"be found in B<attr>(5)."
msgstr ""
"Расширенные атрибуты представляют собой пару I<имя>:значение и связываются с "
"записями inode (файлы, каталоги, символьные ссылки и т.п.). Они являются "
"расширениями к обычным атрибутам, связанным со всеми записями inode в системе "
"(например, данные B<stat>(2)). Полное описание модели расширенных атрибутов "
"можно найти в B<attr>(5)."

#. type: Plain text
#: man-pages/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""
"Вызов B<removexattr>() удаляет расширенный атрибут с именем, заданным в I<"
"name> и связанный с заданным I<path> в файловой системе."

#. type: Plain text
#: man-pages/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a"
" symbolic link, where the extended attribute is removed from the link "
"itself, not the file that it refers to."
msgstr ""
"Вызов B<lremovexattr>() идентичен B<removexattr>(), за исключением случая "
"работы с символьными ссылками; он удаляет расширенный атрибут на ссылке, а не "
"на файле, на который она указывает."

#. type: Plain text
#: man-pages/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by"
" B<open>(2))  in place of I<path>."
msgstr ""
"Вызов B<fremovexattr>() идентичен B<removexattr>(), отличием является то, что "
"расширенный атрибут удаляется у открытого файла, на который указывает I<fd> "
"(возвращаемый B<open>(2)), а не на указанном в I<path>."

#. type: Plain text
#: man-pages/man2/removexattr.2:78
msgid ""
"An extended attribute name is a simple null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""
"Имя расширенного атрибута представляет собой строку, заканчивающуюся NULL. "
"Имя I<name> включает префикс пространства имён; их может быть несколько, "
"разрозненные пространства ассоциируются с разными inode."

#. type: Plain text
#: man-pages/man2/removexattr.2:83
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/removexattr.2:84
#, no-wrap
msgid "B<ENOATTR>"
msgstr "B<ENOATTR>"

#. type: Plain text
#: man-pages/man2/removexattr.2:92
msgid ""
"The named attribute does not exist.  (B<ENOATTR> is defined to be a synonym "
"for B<ENODATA> in I<E<lt>attr/xattr.hE<gt>>.)"
msgstr ""
"Атрибут с таким именем не существует (B<ENOATTR> определена как синоним B<"
"ENODATA> в I<E<lt>attr/xattr.hE<gt>>)."

#. type: TP
#: man-pages/man2/removexattr.2:92
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man2/removexattr.2:95
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""
"Расширенные атрибуты не поддерживаются файловой системой или отключены."

#. type: Plain text
#: man-pages/man2/removexattr.2:99
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "Также могут возникать ошибки, описанные в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/removexattr.2:102
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""
"Данные системные вызовы доступны в Linux начиная с ядра версии 2.4; поддержка "
"в glibc появилась в версии 2.3."

#. type: Plain text
#: man-pages/man2/removexattr.2:119
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2),"
" B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: man-pages/man2/readdir.2:30
#, no-wrap
msgid "READDIR"
msgstr "READDIR"

#. type: TH
#: man-pages/man2/readdir.2:30
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: man-pages/man2/readdir.2:33
msgid "readdir - read directory entry"
msgstr "readdir - читает элемент каталога"

#. type: Plain text
#: man-pages/man2/readdir.2:38
#, no-wrap
msgid ""
"B<int readdir(unsigned int >I<fd>B<, struct old_linux_dirent *>I<dirp>B<,>\n"
"B<            unsigned int >I<count>B<);>\n"
msgstr ""
"B<int readdir(unsigned int >I<fd>B<, struct old_linux_dirent *>I<dirp>B<,>"
"\nB<            unsigned int >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/readdir.2:50
msgid ""
"This is not the function you are interested in.  Look at B<readdir>(3)  for "
"the POSIX conforming C library interface.  This page documents the bare "
"kernel system call interface, which is superseded by B<getdents>(2)."
msgstr ""
"Эта не та функция, которая должна представлять для вас интерес. Смотрите "
"описание функции B<readdir>(3), которая является интерфейсом библиотеки языка "
"C, соответствующим стандарту POSIX. В этой странице описан минимальный "
"интерфейс системного вызова ядра, который заменён на B<getdents>(2)."

#. type: Plain text
#: man-pages/man2/readdir.2:64
msgid ""
"B<readdir>()  reads one I<old_linux_dirent> structure from the directory "
"referred to by the file descriptor I<fd> into the buffer pointed to by "
"I<dirp>.  The argument I<count> is ignored; at most one I<old_linux_dirent> "
"structure is read."
msgstr ""
"Вызов B<readdir>() читает структуру I<old_linux_dirent> из каталога, "
"заданного файловым дескриптором I<fd>, в буфер, указываемый в I<dirp>. "
"Аргумент I<count> игнорируется; всегда считывается только одна структура I<"
"old_linux_dirent>."

#. type: Plain text
#: man-pages/man2/readdir.2:68
msgid "The I<old_linux_dirent> structure is declared as follows:"
msgstr "Структура I<old_linux_dirent> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/readdir.2:77
#, no-wrap
msgid ""
"struct old_linux_dirent {\n"
"    long  d_ino;              /* inode number */\n"
"    off_t d_off;              /* offset to this I<old_linux_dirent> */\n"
"    unsigned short d_reclen;  /* length of this I<d_name> */\n"
"    char  d_name[NAME_MAX+1]; /* filename (null-terminated) */\n"
"}\n"
msgstr ""
"struct old_linux_dirent {\n    long  d_ino;              /* номер inode */\n  "
"  off_t d_off;              /* смещение на данную I<old_linux_dirent> */\n    "
"unsigned short d_reclen;  /* длина данной I<d_name> */\n    char  "
"d_name[NAME_MAX+1]; /* имя файла (завершается null) */\n}\n"

#. type: Plain text
#: man-pages/man2/readdir.2:91
msgid ""
"I<d_ino> is an inode number.  I<d_off> is the distance from the start of the"
" directory to this I<old_linux_dirent>.  I<d_reclen> is the size of "
"I<d_name>, not counting the terminating null byte (\\(aq\\e0\\(aq).  "
"I<d_name> is a null-terminated filename."
msgstr ""
"Значением I<d_ino> является номер inode В I<d_off> задаётся смещение данной "
"I<old_linux_dirent> от начала каталога. В I<d_reclen> задаётся размер I<"
"d_name> без учета завершающего байта null (\\(aq\\e0\\(aq). В I<d_name> "
"указывается имя файла, завершающееся null."

#. type: Plain text
#: man-pages/man2/readdir.2:97
msgid ""
"On success, 1 is returned.  On end of directory, 0 is returned.  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении возвращается 1. Если каталог закончился возвращается "
"0. При ошибке возвращается -1, а переменной I<errno> присваивается номер "
"ошибки."

#. type: Plain text
#: man-pages/man2/readdir.2:102
msgid "Invalid file descriptor I<fd>."
msgstr "Неверный файловый дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/readdir.2:105
msgid "Argument points outside the calling process's address space."
msgstr ""
"Аргумент указывает за пределы адресного пространства вызывающего процесса."

#. type: Plain text
#: man-pages/man2/readdir.2:108
msgid "Result buffer is too small."
msgstr "Буфер результата слишком мал."

#. type: Plain text
#: man-pages/man2/readdir.2:111
msgid "No such directory."
msgstr "Заданный каталог не существует."

#. type: Plain text
#: man-pages/man2/readdir.2:114
msgid "File descriptor does not refer to a directory."
msgstr "Файловый дескриптор указывает не на каталог."

#. type: Plain text
#: man-pages/man2/readdir.2:125
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  You will need to define the I<old_linux_dirent> structure "
"yourself.  However, probably you should use B<readdir>(3)  instead."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2). Структуру I<old_linux_dirent> нужно определить самостоятельно. "
"Однако лучше использовать B<readdir>(3)."

#. type: Plain text
#: man-pages/man2/readdir.2:127
msgid "This system call does not exist on x86-64."
msgstr "Этот системный вызов отсутствует на x86-64."

#. type: Plain text
#: man-pages/man2/readdir.2:129
msgid "B<getdents>(2), B<readdir>(3)"
msgstr "B<getdents>(2), B<readdir>(3)"

#. type: TH
#: man-pages/man2/reboot.2:28
#, no-wrap
msgid "REBOOT"
msgstr "REBOOT"

#. type: TH
#: man-pages/man2/reboot.2:28
#, no-wrap
msgid "2013-12-28"
msgstr "2013-12-28"

#. type: Plain text
#: man-pages/man2/reboot.2:31
msgid "reboot - reboot or enable/disable Ctrl-Alt-Del"
msgstr ""
"reboot - перезагружает систему и разрешает/запрещает использование комбинации "
"Ctrl-Alt-Del"

#. type: Plain text
#: man-pages/man2/reboot.2:36
#, no-wrap
msgid ""
"/* For libc4 and libc5 the library call and the system call\n"
"   are identical, and since kernel version 2.1.30 there are\n"
"   symbolic names LINUX_REBOOT_* for the constants and a\n"
"   fourth argument to the call: */\n"
msgstr ""
"/* Библиотечная функция в libc4, libc5 и системный вызов\n   одинаковы, и "
"начиная с версии ядра 2.1.30 появились\n   символьные имена LINUX_REBOOT_* "
"для констант и четвёртый\n   аргумент вызова */\n"

#. type: Plain text
#: man-pages/man2/reboot.2:40
msgid "B<#include E<lt>linux/reboot.hE<gt>>"
msgstr "B<#include E<lt>linux/reboot.hE<gt>>"

#. type: Plain text
#: man-pages/man2/reboot.2:42
msgid ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"
msgstr ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void *>I<arg>"
"B<);>"

#. type: Plain text
#: man-pages/man2/reboot.2:46
#, no-wrap
msgid ""
"/* Under glibc some of the constants involved have gotten\n"
"   symbolic names RB_*, and the library call is a 1-argument\n"
"   wrapper around the 3-argument system call: */\n"
msgstr ""
"/* В glibc некоторым константам присвоены символьные имена\n   RB_*, а "
"библиотечная функция является обёрткой с одним\n   аргументом вокруг "
"системного вызова с тремя аргументами */\n"

#. type: Plain text
#: man-pages/man2/reboot.2:50
msgid "B<#include E<lt>sys/reboot.hE<gt>>"
msgstr "B<#include E<lt>sys/reboot.hE<gt>>"

#. type: Plain text
#: man-pages/man2/reboot.2:52
msgid "B<int reboot(int >I<cmd>B<);>"
msgstr "B<int reboot(int >I<cmd>B<);>"

#. type: Plain text
#: man-pages/man2/reboot.2:59
msgid ""
"The B<reboot>()  call reboots the system, or enables/disables the reboot "
"keystroke (abbreviated CAD, since the default is Ctrl-Alt-Delete; it can be "
"changed using B<loadkeys>(1))."
msgstr ""
"Вызов B<reboot>() перезагружает систему или разрешает/запрещает использование "
"для перезагрузки специального сочетания клавиш (сокращённо CAD, от комбинации "
"по умолчанию \\(em Ctrl-Alt-Delete; может быть изменена с помощью B<loadkeys>"
"(1))."

#. type: Plain text
#: man-pages/man2/reboot.2:86
msgid ""
"This system call will fail (with B<EINVAL>)  unless I<magic> equals "
"B<LINUX_REBOOT_MAGIC1> (that is, 0xfee1dead) and I<magic2> equals "
"B<LINUX_REBOOT_MAGIC2> (that is, 672274793).  However, since 2.1.17 also "
"B<LINUX_REBOOT_MAGIC2A> (that is, 85072278)  and since 2.1.97 also "
"B<LINUX_REBOOT_MAGIC2B> (that is, 369367448)  and since 2.5.71 also "
"B<LINUX_REBOOT_MAGIC2C> (that is, 537993216)  are permitted as value for "
"I<magic2>.  (The hexadecimal values of these constants are meaningful.)  The"
" I<cmd> argument can have the following values:"
msgstr ""
"Данный системный вызов завершается с ошибкой (B<EINVAL>), если I<magic> не "
"равен B<LINUX_REBOOT_MAGIC1> (0xfee1dead) и I<magic2> не равен B<"
"LINUX_REBOOT_MAGIC2> (672274793). Однако, начиная с 2.1.17 в I<magic2> также "
"можно использовать B<LINUX_REBOOT_MAGIC2A> (85072278)  и начиная с 2.1.97 "
"\\(em B<LINUX_REBOOT_MAGIC2B> (369367448) и начиная с 2.5.71 \\(em B<"
"LINUX_REBOOT_MAGIC2C> (537993216) (шестнадцатеричные значения этих констант "
"говорят сами за себя). Аргумент I<cmd> может принимать следующие значения:"

#. type: TP
#: man-pages/man2/reboot.2:86
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_OFF>"
msgstr "B<LINUX_REBOOT_CMD_CAD_OFF>"

#. type: Plain text
#: man-pages/man2/reboot.2:96
msgid ""
"(B<RB_DISABLE_CAD>, 0).  CAD is disabled.  This means that the CAD keystroke"
" will cause a B<SIGINT> signal to be sent to init (process 1), whereupon "
"this process may decide upon a proper action (maybe: kill all processes, "
"sync, reboot)."
msgstr ""
"(B<RB_DISABLE_CAD>, 0). Запретить использование сочетания клавиш для "
"перезагрузки системы (CAD). Это означает, что нажатие комбинации клавиш CAD "
"приведёт к тому, что процессу init (с идентификатором 1) будет послан сигнал "
"B<SIGINT>, после чего этот процесс может сам решить какие действия выполнять "
"(возможно, послать сигналы процессам, выполнить команду sync, reboot)."

#. type: TP
#: man-pages/man2/reboot.2:96
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_ON>"
msgstr "B<LINUX_REBOOT_CMD_CAD_ON>"

#. type: Plain text
#: man-pages/man2/reboot.2:104
msgid ""
"(B<RB_ENABLE_CAD>, 0x89abcdef).  CAD is enabled.  This means that the CAD "
"keystroke will immediately cause the action associated with "
"B<LINUX_REBOOT_CMD_RESTART>."
msgstr ""
"(B<RB_ENABLE_CAD>, 0x89abcdef). Разрешить использование сочетания клавиш для "
"перезагрузки (CAD). Это означает, что нажатие комбинации клавиш CAD приведёт "
"к немедленному выполнению действия, связанного с B<LINUX_REBOOT_CMD_RESTART>."

#. type: TP
#: man-pages/man2/reboot.2:104
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_HALT>"
msgstr "B<LINUX_REBOOT_CMD_HALT>"

#. type: Plain text
#: man-pages/man2/reboot.2:113
msgid ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; since Linux 1.1.76).  The message \"System "
"halted.\" is printed, and the system is halted.  Control is given to the ROM"
" monitor, if there is one.  If not preceded by a B<sync>(2), data will be "
"lost."
msgstr ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; начиная с Linux 1.1.76) Выводится сообщение "
"«System halted.» и система останавливается. Управление передается монитору в "
"ПЗУ, если таковой имеется. Если вызову этой функции не предшествует B<sync>"
"(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:113
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_KEXEC>"
msgstr "B<LINUX_REBOOT_CMD_KEXEC>"

#. type: Plain text
#: man-pages/man2/reboot.2:121
msgid ""
"(B<RB_KEXEC>, 0x45584543, since Linux 2.6.13).  Execute a kernel that has "
"been loaded earlier with B<kexec_load>(2).  This option is available only if"
" the kernel was configured with B<CONFIG_KEXEC>."
msgstr ""
"(B<RB_KEXEC>, 0x45584543, начиная с Linux 2.6.13) Выполняет ядро, которое "
"было загружено ранее с помощью B<kexec_load>(2). Этот параметр доступен "
"только, если ядро собрано с параметром B<CONFIG_KEXEC>."

#. type: TP
#: man-pages/man2/reboot.2:121
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>"
msgstr "B<LINUX_REBOOT_CMD_POWER_OFF>"

#. type: Plain text
#: man-pages/man2/reboot.2:130
msgid ""
"(B<RB_POWER_OFF>, 0x4321fedc; since Linux 2.1.30).  The message \"Power "
"down.\" is printed, the system is stopped, and all power is removed from the"
" system, if possible.  If not preceded by a B<sync>(2), data will be lost."
msgstr ""
"(B<RB_POWER_OFF>, 0x4321fedc; начиная с Linux 2.1.30) Выводится сообщение "
"«Power down.», система останавливается, и у системы отключаются все источники "
"питания, если это возможно. Если вызову этой функции не предшествует B<sync>"
"(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:130
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>"
msgstr "B<LINUX_REBOOT_CMD_RESTART>"

#. type: Plain text
#: man-pages/man2/reboot.2:139
msgid ""
"(B<RB_AUTOBOOT>, 0x1234567).  The message \"Restarting system.\" is printed,"
" and a default restart is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""
"(B<RB_AUTOBOOT>, 0x1234567) Выводится сообщение «Restarting system.», и по "
"умолчанию сразу выполняется перезагрузка системы. Если вызову этой функции не "
"предшествует команда B<sync>(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:139
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART2>"
msgstr "B<LINUX_REBOOT_CMD_RESTART2>"

#. type: Plain text
#: man-pages/man2/reboot.2:149
msgid ""
"(0xa1b2c3d4; since Linux 2.1.30).  The message \"Restarting system with "
"command \\(aq%s\\(aq\" is printed, and a restart (using the command string "
"given in I<arg>)  is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""
"(0xa1b2c3d4; начиная с Linux 2.1.30) Выводится сообщение «Restarting system "
"with command \\(aq%s\\(aq» и немедленно выполняется перезагрузка системы (с "
"использованием командной строки, заданной в I<arg>). Если вызову этой функции "
"не предшествует B<sync>(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:149
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_SW_SUSPEND>"
msgstr "B<LINUX_REBOOT_CMD_SW_SUSPEND>"

#. type: Plain text
#: man-pages/man2/reboot.2:156
msgid ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; since Linux 2.5.18).  The system is suspended"
" (hibernated) to disk.  This option is available only if the kernel was "
"configured with B<CONFIG_HIBERNATION>."
msgstr ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; начиная с Linux 2.5.18) Система переводится в "
"режим ожидания (suspended, hibernated) на диск. Этот параметр доступен "
"только, если ядро собрано с параметром B<CONFIG_HIBERNATION>."

#. type: Plain text
#: man-pages/man2/reboot.2:159
msgid "Only the superuser may call B<reboot>()."
msgstr "Только суперпользователь может вызывать B<reboot>()."

#. type: Plain text
#: man-pages/man2/reboot.2:165
msgid ""
"The precise effect of the above actions depends on the architecture.  For "
"the i386 architecture, the additional argument does not do anything at "
"present (2.1.122), but the type of reboot can be determined by kernel "
"command-line arguments (\"reboot=...\") to be either warm or cold, and "
"either hard or through the BIOS."
msgstr ""
"Конкретное действие описанных выше команд зависит от архитектуры системы. Что "
"касается i386, то дополнительный аргумент в данное время ничего не даёт "
"(2.1.122), а тип перезагрузки можно задать в командной строке ядра "
"(\"reboot=...\"), определив, будет ли перезагрузка \"тёплой\" или "
"\"холодной\", а также аппаратной или посредством BIOS."

#. type: Plain text
#: man-pages/man2/reboot.2:178
msgid ""
"For the values of I<cmd> that stop or restart the system, a successful call "
"to B<reboot>()  does not return.  For the other I<cmd> values, zero is "
"returned on success.  In all cases, -1 is returned on failure, and I<errno> "
"is set appropriately."
msgstr ""
"При значениях I<cmd>, по которым система останавливается или перезагружается, "
"в случае успешной работы B<reboot>() ничего не возвращается. При других "
"значений I<cmd> в случае успешной работы возвращается ноль. При ошибке всегда "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/reboot.2:183
msgid ""
"Problem with getting user-space data under B<LINUX_REBOOT_CMD_RESTART2>."
msgstr ""
"Проблема получения данных пользовательского пространства при B<"
"LINUX_REBOOT_CMD_RESTART2>."

#. type: Plain text
#: man-pages/man2/reboot.2:186
msgid "Bad magic numbers or I<cmd>."
msgstr "Неправильные идентификационные числа или I<cmd>."

#. type: Plain text
#: man-pages/man2/reboot.2:193
msgid ""
"The calling process has insufficient privilege to call B<reboot>(); the "
"B<CAP_SYS_BOOT> capability is required."
msgstr ""
"У вызывающего процесса недостаточно прав для вызова B<reboot>(); требуется "
"мандат B<CAP_SYS_BOOT>."

#. type: Plain text
#: man-pages/man2/reboot.2:197
msgid ""
"B<reboot>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"Вызов B<reboot>() есть только в Linux, и он не должен использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man2/reboot.2:203
msgid ""
"B<sync>(2), B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), "
"B<halt>(8), B<reboot>(8)"
msgstr ""
"B<sync>(2), B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>"
"(8), B<reboot>(8)"

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "READV"
msgstr "READV"

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "2010-11-17"
msgstr "2010-11-17"

#. type: Plain text
#: man-pages/man2/readv.2:35
msgid ""
"readv, writev, preadv, pwritev - read or write data into multiple buffers"
msgstr ""
"readv, writev, preadv, pwritev - чтение или запись данных в несколько буферов"

#. type: Plain text
#: man-pages/man2/readv.2:38
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/readv.2:40
#, no-wrap
msgid ""
"B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""
"B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<"
");>\n"

#. type: Plain text
#: man-pages/man2/readv.2:42
#, no-wrap
msgid ""
"B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""
"B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>"
"B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:45
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>"
"B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>"
"B<,>\nB<               off_t >I<offset>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:48
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>"
"B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>"
"B<,>\nB<                off_t >I<offset>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:58
msgid "B<preadv>(), B<pwritev>(): _BSD_SOURCE"
msgstr "B<preadv>(), B<pwritev>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man2/readv.2:68
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated"
" with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""
"Системный вызов B<readv>() считывает I<iovcnt> буферов из файла, связанного с "
"файловым дескриптором I<fd>, в буферы, описываемые I<iov> («разнесённый "
"ввод»)."

#. type: Plain text
#: man-pages/man2/readv.2:78
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather "
"output\")."
msgstr ""
"Системный вызов B<writev>() записывает I<iovcnt> буферов, описанных I<iov>, в "
"файл, связанный с файловым дескриптором I<fd> («сборный вывод»)."

#. type: Plain text
#: man-pages/man2/readv.2:87
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""
"Указатель I<iov> указывает на массив структур I<iovec> (определён в I<E<lt>"
"sys/uio.hE<gt>>:"

#. type: Plain text
#: man-pages/man2/readv.2:95
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {\n    void  *iov_base;    /* начальный адрес */\n    size_t "
"iov_len;     /* количество передаваемых байт */\n};\n"

#. type: Plain text
#: man-pages/man2/readv.2:103
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple"
" buffers are filled."
msgstr ""
"Системный вызов B<readv>() работает также как B<read>(2), но считывает "
"несколько буферов."

#. type: Plain text
#: man-pages/man2/readv.2:109
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""
"Системный вызов B<writev>() работает также как B<write>(2), но записывает "
"несколько буферов."

#. type: Plain text
#: man-pages/man2/readv.2:128
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov>[0] before proceeding to I<iov>[1], and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be"
" filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov>[0] before proceeding to I<iov>[1], and so on."
msgstr ""
"Буферы выбираются в порядке, в каком они указаны в массиве. Это означает, что "
"B<readv>() сначала полностью заполнит I<iov>[0], и только потом перейдёт к I<"
"iov>[1], и так далее. (Если данных недостаточно, то могут быть заполнены не "
"все буферы, на которые указывает I<iov>.) Подобным образом B<writev>() "
"запишет сначала всё содержимое I<iov>[0], затем I<iov>[1], и так далее."

#. type: Plain text
#: man-pages/man2/readv.2:146
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the"
" data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)"
"  for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring"
" to the same open file description (see B<open>(2))."
msgstr ""
"Выполняемые вызовами B<readv>() и B<writev>() пересылки данных атомарны: "
"данные записываются B<writev>() единичным блоком, который не перемешивается с "
"выводом других процессов (см. исключения в B<pipe>(7)); аналогично, B<readv>"
"() гарантированно считывает непрерывный блок данных из файла, независимо от "
"операций чтения из других нитей или процессов, которые имеют файловые "
"дескрипторы, ссылающиеся на это же открытое файловое описание (см. B<open>"
"(2))."

#. type: SS
#: man-pages/man2/readv.2:146
#, no-wrap
msgid "preadv() and pwritev()"
msgstr "preadv() и pwritev()"

#. type: Plain text
#: man-pages/man2/readv.2:159
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""
"В системном вызове B<preadv>() объединены возможности B<readv>() и B<pread>"
"(2). Он выполняет ту же задачу что и B<readv>(), но имеет четвёртый аргумент "
"I<offset>, задающий файловое смещение, по которому нужно выполнить операцию "
"чтения."

#. type: Plain text
#: man-pages/man2/readv.2:172
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and"
" B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""
"В системном вызове B<pwritev>() объединены возможности B<readv>() и B<pwrite>"
"(2). Он выполняет ту же задачу что и B<writev>(), но имеет четвёртый аргумент "
"I<offset>, задающий файловое смещение, по которому нужно выполнить операцию "
"записи."

#. type: Plain text
#: man-pages/man2/readv.2:177
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""
"Файловое смещение не изменяется данными вызовами. Файл, заданный в I<fd>, "
"должен позволять изменение смещения."

#. type: Plain text
#: man-pages/man2/readv.2:188
msgid ""
"On success, B<readv>()  and B<preadv>()  return the number of bytes read; "
"B<writev>()  and B<pwritev>()  return the number of bytes written.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<readv>() и B<preadv>() возвращается количество "
"считанных байт; вызовы B<writev>() и B<pwritev>() возвращают количество "
"записанных байт. При ошибке возвращается -1, а значение I<errno> "
"устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/readv.2:200
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>()  and B<pwritev>()  can also fail for the same reasons as "
"B<lseek>(2).  Additionally, the following error is defined:"
msgstr ""
"Вызовы могут возвращать те же ошибки что и B<read>(2) и B<write>(2). Кроме "
"этого, B<preadv>() и B<pwritev>() также могут завершаться с ошибками как B<"
"lseek>(2). Дополнительно, определены следующие ошибки:"

#. type: Plain text
#: man-pages/man2/readv.2:209
msgid ""
"The sum of the I<iov_len> values overflows an I<ssize_t> value.  Or, the "
"vector count I<iovcnt> is less than zero or greater than the permitted "
"maximum."
msgstr ""
"Сумма значений I<iov_len> превышает значение I<ssize_t>. Или количество "
"векторов I<iovcnt> меньше нуля или больше разрешённого максимума."

#. type: Plain text
#: man-pages/man2/readv.2:214
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""
"Вызовы B<preadv>() и B<pwritev>() впервые появились в Linux 2.6.30; поддержка "
"в библиотеке добавлена в glibc 2.10."

#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: man-pages/man2/readv.2:222
msgid ""
"B<readv>(), B<writev>(): 4.4BSD (these system calls first appeared in "
"4.2BSD), POSIX.1-2001.  Linux libc5 used I<size_t> as the type of the "
"I<iovcnt> argument, and I<int> as the return type."
msgstr ""
"B<readv>(), B<writev>(): 4.4BSD (впервые появились в 4.2BSD), POSIX.1-2001. В "
"Linux libc5 в качестве типа аргумента I<iovcnt> используется I<size_t>, и I<"
"int> в качестве возвращаемого типа."

#. type: Plain text
#: man-pages/man2/readv.2:226
msgid ""
"B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr "B<preadv>(), B<pwritev>(): нет в стандарте, но есть в современных BSD."

#. type: SS
#: man-pages/man2/readv.2:227
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#. type: Plain text
#: man-pages/man2/readv.2:258
msgid ""
"POSIX.1-2001 allows an implementation to place a limit on the number of "
"items that can be passed in I<iov>.  An implementation can advertise its "
"limit by defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the"
" return value from I<sysconf(_SC_IOV_MAX)>.  On Linux, the limit advertised "
"by these mechanisms is 1024, which is the true kernel limit.  However, the "
"glibc wrapper functions do some extra work if they detect that the "
"underlying kernel system call failed because this limit was exceeded.  In "
"the case of B<readv>().  the wrapper function allocates a temporary buffer "
"large enough for all of the items specified by I<iov>, passes that buffer in"
" a call to B<read>(2), copies data from the buffer to the locations "
"specified by the I<iov_base> fields of the elements of I<iov>, and then "
"frees the buffer.  The wrapper function for B<writev>()  performs the "
"analogous task using a temporary buffer and a call to B<write>(2)."
msgstr ""
"POSIX.1-2001 позволяет реализации устанавливать ограничение на количество "
"элементов, которые можно передать в I<iov>. Реализация может объявить это "
"ограничение в B<IOV_MAX> (в файле I<E<lt>limits.hE<gt>>) или во время "
"выполнения в виде возвращаемого значения I<sysconf(_SC_IOV_MAX)>. В Linux "
"данное ограничение, возвращаемое этими механизмами, равно 1024, что равно "
"ограничению ядра. Однако обёрточные функции glibc выполняют дополнительные "
"действия, если обнаруживается, что используемый системный вызов завершился "
"неудачно из-за превышения этого ограничения. В случае B<readv>() обёрточная "
"функция выделяет временный буфер, достаточный для всех элементов, указанных в "
"I<iov>, передаёт этот буфер в вызов B<read>(2), копирует данные из буфера в "
"места, указанные в полях I<iov_base> элемента I<iov>, а затем освобождает "
"буфер. Обёрточная функция B<writev>() выполняет аналогичную задачу с помощью "
"временного буфера и вызова B<write>(2)."

#. type: Plain text
#: man-pages/man2/readv.2:265
msgid ""
"It is not advisable to mix calls to B<readv>()  or B<writev>(), which "
"operate on file descriptors, with the functions from the stdio library; the "
"results will be undefined and probably not what you want."
msgstr ""
"Неразумно смешивать вызовы B<readv>() или B<writev>(), работающих с "
"дескрипторами файлов, вместе с функциями из библиотеки stdio; результат "
"непредсказуем и точно не тот, которого вы ожидаете."

#. type: Plain text
#: man-pages/man2/readv.2:268
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr "Следующий пример кода демонстрирует использование B<writev>():"

#. type: Plain text
#: man-pages/man2/readv.2:275
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""
"char *str0 = \"hello \";\nchar *str1 = \"world\\en\";\nstruct iovec "
"iov[2];\nssize_t nwritten;\n"

#. type: Plain text
#: man-pages/man2/readv.2:280
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""
"iov[0].iov_base = str0;\niov[0].iov_len = strlen(str0);\niov[1].iov_base = "
"str1;\niov[1].iov_len = strlen(str1);\n"

#. type: Plain text
#: man-pages/man2/readv.2:282
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr "nwritten = writev(STDOUT_FILENO, iov, 2);\n"

#. type: Plain text
#: man-pages/man2/readv.2:287
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr "B<pread>(2), B<read>(2), B<write>(2)"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "REPERTOIREMAP"
msgstr "REPERTOIREMAP"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "2014-06-02"
msgstr "2014-06-02"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "Linux User Manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:26
msgid "repertoiremap - map symbolic character names to Unicode code points"
msgstr ""
"repertoiremap - отображает символические имена символов в кодовые точки "
"Юникода"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:32
msgid ""
"A repertoire map defines mappings between symbolic character names and "
"Unicode code points when compiling a locale with B<localedef>(1).  Using a "
"repertoire map is optional, it is only needed when symbolic names are used "
"instead of now preferred Unicode code points."
msgstr ""
"Карта набора (repertoire map) определяет отображение между символическими "
"именами символов и кодовыми точками Юникода (Unicode code points) при "
"компиляции локали с помощью B<localedef>(1). Использование карты набора "
"необязательно, она требуется только при использовании символических имён "
"вместо предпочтительных теперь кодовых точек Юникода."

#. type: SS
#: man-pages/man5/repertoiremap.5:32
#, no-wrap
msgid "Syntax"
msgstr "Синтаксис"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:35
msgid ""
"The repertoiremap file starts with a header that may consist of the "
"following keywords:"
msgstr ""
"Файл repertoiremap начинается с заголовка, который может содержать следующие "
"ключевые слова:"

#. type: TP
#: man-pages/man5/repertoiremap.5:35
#, no-wrap
msgid "I<E<lt>comment_charE<gt>>"
msgstr "I<E<lt>comment_charE<gt>>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:40
msgid ""
"is followed by a character that will be used as the comment character for "
"the rest of the file.  It defaults to the number sign (#)."
msgstr ""
"за которым указывается символ, использующийся в оставшихся строках файла как "
"символ комментария. По умолчанию это символ решётки (#)."

#. type: TP
#: man-pages/man5/repertoiremap.5:40
#, no-wrap
msgid "I<E<lt>escape_charE<gt>>"
msgstr "I<E<lt>escape_charE<gt>>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:46
msgid ""
"is followed by a character that should be used as the escape character for "
"the rest of the file to mark characters that should be interpreted in a "
"special way.  It defaults to the backslash (\\e)."
msgstr ""
"за которым указывается символ, использующийся в оставшихся строках файла как "
"символ экранирования для пометки символов, которые должны обрабатываться "
"особым образом. По умолчанию это символ обратной косой черты (\\e)."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:50
msgid ""
"The mapping section starts with the keyword B<CHARIDS> in the first column."
msgstr ""
"Раздел отображения начинается с ключевого слова B<CHARIDS> в первом столбце."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:52
msgid "The mapping lines have the following form:"
msgstr "Строки отображения имеют следующий вид:"

#. type: TP
#: man-pages/man5/repertoiremap.5:52
#, no-wrap
msgid "I<E<lt>symbolic-nameE<gt> E<lt>code-pointE<gt> E<lt>commentE<gt>>"
msgstr ""
"I<E<lt>символическое-имяE<gt> E<lt>кодовая-точкаE<gt> E<lt>комментарийE<gt>>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:57
msgid "This defines exactly one mapping, I<E<lt>commentE<gt>> being optional."
msgstr ""
"Одной строкой определяется одно отображение, I<E<lt>комментарийE<gt>> не "
"обязателен."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:60
msgid "The mapping section ends with the string I<END CHARIDS>."
msgstr "Раздел отображения заканчивается строкой I<END CHARIDS>."

#. type: TP
#: man-pages/man5/repertoiremap.5:61
#, no-wrap
msgid "I</usr/share/i18n/repertoiremaps>"
msgstr "I</usr/share/i18n/repertoiremaps>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:64
msgid "Usual default repertoire map path."
msgstr "Обычный путь по умолчанию для файла карты набора."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:66
msgid "POSIX.2."
msgstr "POSIX.2."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:68
msgid "Repertoire maps are deprecated in favor of Unicode code points."
msgstr "Вместо карт набора следует использовать кодовые точки Юникода."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:72
msgid "B<locale>(1), B<localedef>(1), B<charmap>(5), B<locale>(5)"
msgstr "B<locale>(1), B<localedef>(1), B<charmap>(5), B<locale>(5)"

#. type: TH
#: man-pages/man5/rpc.5:8
#, no-wrap
msgid "RPC"
msgstr "RPC"

#. type: TH
#: man-pages/man5/rpc.5:8
#, no-wrap
msgid "1985-09-26"
msgstr "1985-09-26"

#. type: Plain text
#: man-pages/man5/rpc.5:11
msgid "rpc - RPC program number data base"
msgstr "rpc - база данных программных номеров RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:13
msgid "B</etc/rpc>"
msgstr "B</etc/rpc>"

#. type: Plain text
#: man-pages/man5/rpc.5:19
msgid ""
"The I<rpc> file contains user readable names that can be used in place of "
"RPC program numbers.  Each line has the following information:"
msgstr ""
"В файле I<rpc> содержатся в понятном для человека виде имена, которые можно "
"использовать вместо программных номеров RPC. Каждая строка содержит следующую "
"информацию:"

#. type: Plain text
#: man-pages/man5/rpc.5:21
msgid "name of server for the RPC program"
msgstr "имя сервера RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:25
msgid "RPC program number"
msgstr "программный номер RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:29
msgid "aliases"
msgstr "псевдонимы"

#. type: Plain text
#: man-pages/man5/rpc.5:35
msgid ""
"Items are separated by any number of blanks and/or tab characters.  A "
"\\(aq#\\(aq indicates the beginning of a comment; characters from the "
"\\(aq#\\(aq to the end of the line are not interpreted by routines which "
"search the file."
msgstr ""
"Поля в файле отделяются друг от друга пробелами и/или символами табуляции. "
"Символом \\(aq#\\(aq отмечается начало комментария; символы начиная с "
"\\(aq#\\(aq до конца строки не интерпретируются процедурами, которые "
"производят поиск в данном файле."

#. type: Plain text
#: man-pages/man5/rpc.5:38
msgid ""
"Here is an example of the I</etc/rpc> file from the Sun RPC Source "
"distribution."
msgstr "Вот пример файла I</etc/rpc>, взятый из дистрибутива Sun RPC Source."

#. type: Plain text
#: man-pages/man5/rpc.5:73
#, no-wrap
msgid ""
"CW<#\n"
"# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n"
"#\n"
"portmapper      100000  portmap sunrpc\n"
"rstatd          100001  rstat rstat_svc rup perfmeter\n"
"rusersd         100002  rusers\n"
"nfs             100003  nfsprog\n"
"ypserv          100004  ypprog\n"
"mountd          100005  mount showmount\n"
"ypbind          100007\n"
"walld           100008  rwall shutdown\n"
"yppasswdd       100009  yppasswd\n"
"etherstatd      100010  etherstat\n"
"rquotad         100011  rquotaprog quota rquota\n"
"sprayd          100012  spray\n"
"3270_mapper     100013\n"
"rje_mapper      100014\n"
"selection_svc   100015  selnsvc\n"
"database_svc    100016\n"
"rexd            100017  rex\n"
"alis            100018\n"
"sched           100019\n"
"llockmgr        100020\n"
"nlockmgr        100021\n"
"x25.inr         100022\n"
"statmon         100023\n"
"status          100024\n"
"bootparam       100026\n"
"ypupdated       100028  ypupdate\n"
"keyserv         100029  keyserver\n"
"tfsd            100037\n"
"nsed            100038\n"
"nsemntd         100039>\n"
msgstr ""
"CW<#\n# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n#\nportmapper      "
"100000  portmap sunrpc\nrstatd          100001  rstat rstat_svc rup "
"perfmeter\nrusersd         100002  rusers\nnfs             100003  "
"nfsprog\nypserv          100004  ypprog\nmountd          100005  mount "
"showmount\nypbind          100007\nwalld           100008  rwall "
"shutdown\nyppasswdd       100009  yppasswd\netherstatd      100010  "
"etherstat\nrquotad         100011  rquotaprog quota rquota\nsprayd          "
"100012  spray\n3270_mapper     100013\nrje_mapper      100014\nselection_svc  "
" 100015  selnsvc\ndatabase_svc    100016\nrexd            100017  rex\nalis   "
"         100018\nsched           100019\nllockmgr        100020\nnlockmgr     "
"   100021\nx25.inr         100022\nstatmon         100023\nstatus          "
"100024\nbootparam       100026\nypupdated       100028  ypupdate\nkeyserv     "
"    100029  keyserver\ntfsd            100037\nnsed            "
"100038\nnsemntd         100039>\n"

#. type: TP
#: man-pages/man5/rpc.5:77
#, no-wrap
msgid "I</etc/rpc>"
msgstr "I</etc/rpc>"

#. type: Plain text
#: man-pages/man5/rpc.5:80
msgid "RPC program number data base"
msgstr "база данных программных номеров RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:81
msgid "B<getrpcent>(3)"
msgstr "B<getrpcent>(3)"

#. type: TH
#: man-pages/man5/resolv.conf.5:23
#, no-wrap
msgid "RESOLV.CONF"
msgstr "RESOLV.CONF"

#. type: TH
#: man-pages/man5/resolv.conf.5:23
#, no-wrap
msgid "2014-02-22"
msgstr "2014-02-22"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:27
msgid "resolv.conf - resolver configuration file"
msgstr "resolv.conf - файл настройки для процедур определения имён (resolver)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:29
msgid "B</etc/resolv.conf>"
msgstr "B</etc/resolv.conf>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:41
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to"
" the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information.  The configuration file is considered a trusted source"
" of DNS information (e.g., DNSSEC AD-bit information will be returned "
"unmodified from this source)."
msgstr ""
"I<resolver> — это набор функций из библиотеки Си, который предоставляет "
"доступ к системе доменных имён интернет (DNS). Файл настройки определителя "
"(resolver) содержит информацию, которая читается функциями разрешения имён "
"при первом их вызове процессом. Файл разрабатывался в понятном человеку "
"формате, и содержит список ключевых слов со значениями, которые предоставляют "
"различного рода информацию для функций разрешения имён. Файл настройки "
"считается надёжным источником информации DNS (например, информация об AD-бите "
"DNSSEC будет возвращаться в неизменном виде из этого источника)."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:46
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried; the domain name is determined from the hostname and the domain "
"search path is constructed from the domain name."
msgstr ""
"Если этот файл не существует, то будет опрашиваться только служба имён на "
"локальной машине; доменное имя определяется из имени узла, а домен поиска "
"создаётся из имени домена."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:48
msgid "The different configuration options are:"
msgstr "Поддерживаются следующие параметры настройки:"

#. type: TP
#: man-pages/man5/resolv.conf.5:48
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr "B<nameserver> IP-адрес сервера имён"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:65
msgid ""
"Internet address of a name server that the resolver should query, either an "
"IPv4 address (in dot notation), or an IPv6 address in colon (and possibly "
"dot) notation as per RFC 2373.  Up to B<MAXNS> (currently 3, see "
"I<E<lt>resolv.hE<gt>>) name servers may be listed, one per keyword.  If "
"there are multiple servers, the resolver library queries them in the order "
"listed.  If no B<nameserver> entries are present, the default is to use the "
"name server on the local machine.  (The algorithm used is to try a name "
"server, and if the query times out, try the next, until out of name servers,"
" then repeat trying all the name servers until a maximum number of retries "
"are made.)"
msgstr ""
"Задает интернет-адрес сервера имён, на который надо переправлять все запросы, "
"или в виде адреса IPv4 (в точечном формате), или в виде адреса IPv6 в формате "
"с двоеточиями (и, возможно, точками), определённом в RFC 2373. Может быть "
"указано до B<MAXNS> (в настоящее время 3, см. I<E<lt>resolv.hE<gt>>) серверов "
"имён, повторяя каждый раз ключевое слово. Если указано несколько серверов, "
"функции разрешения имён будут обращаться к серверам имен в порядке "
"перечисления. Если в файле нет строк B<nameserver>, то функции разрешения "
"имён используют сервер имён на локальной машине. (Функции разрешения имён "
"работают по следующему алгоритму: попробовать обратиться к первому указанному "
"серверу имён. Если нет ответа в отведённое время, попробовать обратиться к "
"следующему серверу, и т.д. пока не будет исчерпан список серверов.)"

#. type: TP
#: man-pages/man5/resolv.conf.5:65
#, no-wrap
msgid "B<domain> Local domain name."
msgstr "B<domain> локальное доменное имя"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:76
msgid ""
"Most queries for names within this domain can use short names relative to "
"the local domain.  If set to \\(aq.\\(aq, the root domain is considered.  If"
" no B<domain> entry is present, the domain is determined from the local "
"hostname returned by B<gethostname>(2); the domain part is taken to be "
"everything after the first \\(aq.\\(aq.  Finally, if the hostname does not "
"contain a domain part, the root domain is assumed."
msgstr ""
"Для большинства запросов имён с доменом можно использовать короткие имена "
"относительно локального домена. Если значение равно \\(aq.\\(aq, то это "
"считается корневым доменом. Если строки B<domain> в файле настройки нет, "
"домен определяется из локального имени узла, возвращаемого B<gethostname>(2); "
"доменной частью считается всё после первой точки \\(aq.\\(aq. Наконец, если "
"имя узла не содержит доменной части, то предполагается корневой домен."

#. type: TP
#: man-pages/man5/resolv.conf.5:76
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr "B<search> список поиска"

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: man-pages/man5/resolv.conf.5:106
msgid ""
"The search list is normally determined from the local domain name; by "
"default, it contains only the local domain name.  This may be changed by "
"listing the desired domain search path following the I<search> keyword with "
"spaces or tabs separating the names.  Resolver queries having fewer than "
"I<ndots> dots (default is 1) in them will be attempted using each component "
"of the search path in turn until a match is found.  For environments with "
"multiple subdomains please read B<options ndots:>I<n> below to avoid man-in-"
"the-middle attacks and unnecessary traffic for the root-dns-servers.  Note "
"that this process may be slow and will generate a lot of network traffic if "
"the servers for the listed domains are not local, and that queries will time"
" out if no server is available for one of the domains."
msgstr ""
"Список поиска обычно определяется по имени локального домена; по умолчанию он "
"содержит только имя локального домена. Это можно изменить, перечислив имена "
"доменов, в которых нужно вести поиск, с ключевым полем I<search> через пробел "
"или символ табуляции. При разрешении запросов имён, в которых меньше точек "
"чем указано в I<ndots> (по умолчанию 1), будет использован каждый компонент "
"пути поиска пока не будет найдено соответствующее имя."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:109
msgid ""
"The search list is currently limited to six domains with a total of 256 "
"characters."
msgstr ""
"Список поиска сейчас может содержать не более шести доменов и не может быть "
"длиннее 256 символов."

#. type: TP
#: man-pages/man5/resolv.conf.5:109
#, no-wrap
msgid "B<sortlist>"
msgstr "B<sortlist>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:122
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted."
"  A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and"
" optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""
"Вызывает сортировку адресов, возвращаемых функцией B<gethostbyname>(3). "
"Список сортировки задается в виде пар IP-адрес/маска сети. Маску сети "
"указывать не обязательно \\(em по умолчанию используется естественная маска "
"сети. IP-адрес и необязательная маска сети разделяются косой чертой. В списке "
"можно указывать до 10 пар. Пример:"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:125
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"

#. type: TP
#: man-pages/man5/resolv.conf.5:127
#, no-wrap
msgid "B<options>"
msgstr "B<options>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:131
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""
"С помощью параметров изменяются некоторые внутренние переменные функций "
"определения имён. Синтаксис"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:134
msgid "B<options> I<option> I<...>"
msgstr "B<options> I<параметр> I<...>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:136
msgid "where I<option> is one of the following:"
msgstr "где I<параметр> может иметь следующие значения:"

#. type: TP
#: man-pages/man5/resolv.conf.5:136
#, no-wrap
msgid "B<debug>"
msgstr "B<debug>"

#.  Since glibc 2.2?
#. type: Plain text
#: man-pages/man5/resolv.conf.5:145
msgid ""
"sets B<RES_DEBUG> in I<_res.options> (effective only if glibc was built with"
" debug support; see B<resolver>(3))."
msgstr ""
"Задаёт B<RES_DEBUG> в I<_res.options> (только, если glibc собрана с "
"поддержкой отладки; смотрите B<resolver>(3))."

#. type: TP
#: man-pages/man5/resolv.conf.5:145
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr "B<ndots:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:159
msgid ""
"sets a threshold for the number of dots which must appear in a name given to"
" B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots"
" in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""
"Задаёт минимальное количество точек, которые должны обязательно "
"присутствовать в имени, переданном функции B<res_query>(3) (см. B<resolver>"
"(3)) прежде чем будет выполнен I<начальный абсолютный запрос>. По умолчанию "
"I<n> равно 1, поэтому если в имени есть точки, сначала имя пытаются разрешить "
"как абсолютное, прежде чем добавлять к нему элементы из I<списка поиска>. "
"Значение этого параметра внутренне доходит до 15."

#. type: TP
#: man-pages/man5/resolv.conf.5:159
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr "B<timeout:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:170
msgid ""
"sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server.  Measured"
" in seconds, the default is B<RES_TIMEOUT> (currently 5, see "
"I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""
"Задаёт промежуток времени, который функции определения имён будут ждать "
"ответа от удалённого сервера имён перед тем как повторить запрос другому "
"серверу имён. Измеряется в секундах, по умолчанию B<RES_TIMEOUT> (в настоящее "
"время равно 5, см. I<E<lt>resolv.hE<gt>>). Значение этого параметра внутренне "
"доходит до 30."

#. type: TP
#: man-pages/man5/resolv.conf.5:170
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr "B<attempts:>I<n>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:179
msgid ""
"sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""
"Задаёт количество раз, которое функции определения имён будут посылать запрос "
"серверам имён перед тем как закончить работу и вернуть ошибку вызывавшему их "
"приложению. По умолчанию равно B<RES_DFLRETRY> (в настоящее время 2, см. I<"
"E<lt>resolv.hE<gt>>). Значение этого параметра внутренне доходит до 5."

#. type: TP
#: man-pages/man5/resolv.conf.5:179
#, no-wrap
msgid "B<rotate>"
msgstr "B<rotate>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:189
msgid ""
"sets B<RES_ROTATE> in I<_res.options>, which causes round-robin selection of"
" name servers from among those listed.  This has the effect of spreading the"
" query load among all listed servers, rather than having all clients try the"
" first listed server first every time."
msgstr ""
"Задаёт значение B<RES_ROTATE> в I<_res.options>, что приводит к циклическому "
"выбору указанных серверов имён. Это приводит к распределению нагрузки среди "
"серверов, чтобы исключить использование каждый раз только первого сервера "
"всеми клиентами."

#. type: TP
#: man-pages/man5/resolv.conf.5:189
#, no-wrap
msgid "B<no-check-names>"
msgstr "B<no-check-names>"

#.  since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:199
msgid ""
"sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as"
" underscore (_), non-ASCII, or control characters."
msgstr ""
"Задаёт значение B<RES_NOCHECKNAME> в I<_res.options>, что приводит к "
"выключению в современном BIND проверки в поступающих именах узлов и почтовых "
"именах недопустимых символов, таких как символы подчёркивания (_), не-ASCII "
"или управляющие символы."

#. type: TP
#: man-pages/man5/resolv.conf.5:199
#, no-wrap
msgid "B<inet6>"
msgstr "B<inet6>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:210
msgid ""
"sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying a "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists."
msgstr ""
"Задаёт значение B<RES_USE_INET6> в I<_res.options>. Это приводит к выполнению "
"запроса AAAA раньше запроса A внутри функции B<gethostbyname>(3), и "
"отображению ответов IPv4 в \"туннелированную форму\" IPv6, если записи AAAA "
"не были обнаружены, но есть запись типа A."

#. type: TP
#: man-pages/man5/resolv.conf.5:210
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4)"
msgstr "B<ip6-bytestring> (начиная с glibc 2.3.4)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:219
msgid ""
"sets B<RES_USE_BSTRING> in I<_res.options>.  This causes reverse IPv6 "
"lookups to be made using the bit-label format described in RFC\\ 2673; if "
"this option is not set, then nibble format is used."
msgstr ""
"Задаёт значение B<RES_USE_BSTRING> в I<_res.options>. Это приводит к поиску "
"обратной записи IPv6, используя формат значимых битов, описанный в RFC\\ "
"2673; если этот параметр не задан, то используется полубайтовый формат."

#. type: TP
#: man-pages/man5/resolv.conf.5:219
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (since glibc 2.3.4)"
msgstr "B<ip6-dotint>/B<no-ip6-dotint> (начиная с glibc 2.3.4)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:236
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  "
"I<ip6.int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 "
"lookups are made in the I<ip6.arpa> zone by default.  This option is set by "
"default."
msgstr ""
"Устанавливает/сбрасывает значение B<RES_NOIP6DOTINT> в I<_res.options>. Если "
"указан сброс (B<ip6-dotint>), то выполняется поиск обратной записи IPv6 "
"(устарел) в зоне I<ip6.int>; если задана установка (B<no-ip6-dotint>), то по "
"умолчанию выполняется поиск обратной записи IPv6 в зоне I<ip6.arpa>. По "
"умолчанию этот параметр установлен."

#. type: TP
#: man-pages/man5/resolv.conf.5:236
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr "B<edns0> (начиная с glibc 2.6)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:243
msgid ""
"sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""
"Задаёт значение B<RES_USE_EDNSO> в I<_res.options>. Включает поддержку "
"расширений DNS, описанных в RFC\\ 2671."

#. type: TP
#: man-pages/man5/resolv.conf.5:243
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr "B<single-request> (начиная с glibc 2.10)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:256
msgid ""
"sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and"
" IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""
"Задаёт значение B<RES_SNGLKUP> в I<_res.options>. По умолчанию, glibc начиная "
"с версии 2.9 выполняет поиск по IPv4 и IPv6 параллельно. Некоторые приложения "
"DNS-серверов не могут обработать такие запросы должным образом и делают паузу "
"между ответами на запрос. Этот параметр отключает данное поведение, что "
"заставляет glibc делать запросы IPv6 и IPv4 последовательно (что замедляет "
"процесс определения имени)."

#. type: TP
#: man-pages/man5/resolv.conf.5:256
#, no-wrap
msgid "B<single-request-reopen> (since glibc 2.9)"
msgstr "B<single-request-reopen> (начиная с glibc 2.9)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:264
msgid ""
"The resolver uses the same socket for the A and AAAA requests.  Some "
"hardware mistakenly sends back only one reply.  When that happens the client"
" system will sit and wait for the second reply.  Turning this option on "
"changes this behavior so that if two requests from the same port are not "
"handled correctly it will close the socket and open a new one before sending"
" the second request."
msgstr ""
"Для разрешения имён используется единый сокет для запросов A а AAAA. "
"Некоторая аппаратура ошибочно посылает обратно только один ответ. Когда это "
"происходит, клиент остаётся ждать второго ответа. Указание этого параметра "
"изменяет такое поведение так, что если два запроса с одного порта не "
"обрабатываются правильно, то сокет будет закрыт и открыт новый перед посылкой "
"второго запроса."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:269
msgid ""
"The I<domain> and I<search> keywords are mutually exclusive.  If more than "
"one instance of these keywords is present, the last instance wins."
msgstr ""
"Ключевые слова I<domain> и I<search> являются взаимоисключающими. Если они "
"указаны более одного раза, то используется значение последнего."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:274
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on"
" a per-process basis by setting the environment variable B<LOCALDOMAIN> to a"
" space-separated list of search domains."
msgstr ""
"Значение ключевого слова I<search> в системном файле I<resolv.conf> может "
"быть изменено назначением переменной окружения для определённого процесса B<"
"LOCALDOMAIN> списка доменов, разделённых пробелами."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:280
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a"
" per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under "
"B<options>."
msgstr ""
"Значение ключевого слова I<options> в системном файле I<resolv.conf> может "
"быть дополнено назначением переменной окружения для определённого процесса B<"
"RES_OPTIONS> списка вышеописанных в B<options> параметров настройки функций "
"определения имён."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:284
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""
"Ключевое слово и значение должны быть в одной строке, и кроме того, ключевое "
"слово(например, B<nameserver>), должно быть в начале строки. Значение должно "
"отделяться от ключевого слова пробельным символом."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:287
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr ""
"Строки, в которых в первой колонке содержится точка с запятой (;) или символ "
"решётки (#), считаются комментариями."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:290
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:295
msgid "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"
msgstr "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:296
msgid "Name Server Operations Guide for BIND"
msgstr "Руководство по работе с сервером имён BIND"

#. type: TH
#: man-pages/man3/random.3:33
#, no-wrap
msgid "2014-03-25"
msgstr "2014-03-25"

#. type: Plain text
#: man-pages/man3/random.3:36
msgid "random, srandom, initstate, setstate - random number generator"
msgstr "random, srandom, initstate, setstate - генератор случайных чисел"

#. type: Plain text
#: man-pages/man3/random.3:39
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/random.3:41
#, no-wrap
msgid "B<long int random(void);>\n"
msgstr "B<long int random(void);>\n"

#. type: Plain text
#: man-pages/man3/random.3:43
#, no-wrap
msgid "B<void srandom(unsigned int >I<seed>B<);>\n"
msgstr "B<void srandom(unsigned int >I<seed>B<);>\n"

#. type: Plain text
#: man-pages/man3/random.3:45
#, no-wrap
msgid ""
"B<char *initstate(unsigned int >I<seed>B<, char *>I<state>B<, size_t "
">I<n>B<);>\n"
msgstr ""
"B<char *initstate(unsigned int >I<seed>B<, char *>I<state>B<, size_t >I<n>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/random.3:47
#, no-wrap
msgid "B<char *setstate(char *>I<state>B<);>\n"
msgstr "B<char *setstate(char *>I<state>B<);>\n"

#. type: Plain text
#: man-pages/man3/random.3:59
msgid "B<random>(), B<srandom>(), B<initstate>(), B<setstate>():"
msgstr "B<random>(), B<srandom>(), B<initstate>(), B<setstate>():"

#. type: Plain text
#: man-pages/man3/random.3:62
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/random.3:73
msgid ""
"The B<random>()  function uses a nonlinear additive feedback random number "
"generator employing a default table of size 31 long integers to return "
"successive pseudo-random numbers in the range from 0 to B<RAND_MAX>.  The "
"period of this random number generator is very large, approximately I<16\\ "
"*\\ ((2^31)\\ -\\ 1)>."
msgstr ""
"Функция B<random>() использует нелинейный возвратно-аддитивный генератор "
"случайных чисел, используя по умолчанию таблицу из 31-ого длинного целого "
"числа и возвращает очередное псевдослучайное число в промежутке от 0 до B<"
"RAND_MAX>. Период этого генератора очень велик, приблизительно I<16\\ *\\ "
"((2^31)\\ -\\ 1)>."

#. type: Plain text
#: man-pages/man3/random.3:87
msgid ""
"The B<srandom>()  function sets its argument as the seed for a new sequence "
"of pseudo-random integers to be returned by B<random>().  These sequences "
"are repeatable by calling B<srandom>()  with the same seed value.  If no "
"seed value is provided, the B<random>()  function is automatically seeded "
"with a value of 1."
msgstr ""
"Функция B<srandom>() устанавливает свой аргумент в качестве семени для новой "
"последовательности псевдослучайных чисел, которые будут возвращаться функцией "
"B<random>(). Эти последовательности повторяются, если вызывать B<srandom>() с "
"тем же значением семени. Если значение семени не указано, то функция B<random>"
"() автоматически устанавливает его равным 1."

#. type: Plain text
#: man-pages/man3/random.3:102
msgid ""
"The B<initstate>()  function allows a state array I<state> to be initialized"
" for use by B<random>().  The size of the state array I<n> is used by "
"B<initstate>()  to decide how sophisticated a random number generator it "
"should use\\(emthe larger the state array, the better the random numbers "
"will be.  I<seed> is the seed for the initialization, which specifies a "
"starting point for the random number sequence, and provides for restarting "
"at the same point."
msgstr ""
"Функция B<initstate>() позволяет инициализировать массив состояния I<state> "
"для использования в функции B<random>(). Размер массива состояния I<n> "
"используется B<initstate>() для определения, какой сложности генератор "
"случайных чисел необходимо использовать. Чем больше массив, тем полученные "
"числа будут более случайными. I<seed> — это семя последовательности для "
"инициализации, которое определяет стартовую точку последовательности "
"псевдослучайных чисел и позволяет перезапустить последовательность с той же "
"точки."

#. type: Plain text
#: man-pages/man3/random.3:118
msgid ""
"The B<setstate>()  function changes the state array used by the B<random>()"
"  function.  The state array I<state> is used for random number generation "
"until the next call to B<initstate>()  or B<setstate>().  I<state> must "
"first have been initialized using B<initstate>()  or be the result of a "
"previous call of B<setstate>()."
msgstr ""
"Функция B<setstate>() изменяет состояние массива состояния, используемого в "
"B<random>(). Массив состояния I<state> используется для генерации случайных "
"чисел до следующего вызова B<initstate>() или B<setstate>(). Значение I<state>"
" должно быть инициализировано с помощью функции B<initstate>() или "
"результатом предыдущего вызова B<setstate>()."

#. type: Plain text
#: man-pages/man3/random.3:126
msgid ""
"The B<random>()  function returns a value between 0 and B<RAND_MAX>.  The "
"B<srandom>()  function returns no value."
msgstr ""
"Функция B<random>() возвращает значение в промежутке от 0 до B<RAND_MAX>. "
"Функция B<srandom>() не возвращает значение."

#. type: Plain text
#: man-pages/man3/random.3:133
msgid ""
"The B<initstate>()  function returns a pointer to the previous state array."
"  On error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<initstate>() возвращает указатель на предыдущий массив состояния. "
"При ошибке в I<errno> записывается соответствующий код."

#. type: Plain text
#: man-pages/man3/random.3:140
msgid ""
"On success, B<setstate>()  returns a pointer to the previous state array.  "
"On error, it returns NULL, with I<errno> set to indicate the cause of the "
"error."
msgstr ""
"При успешном выполнении функция B<setstate>() возвращает указатель на "
"предыдущий массив состояния. При ошибке она возвращает NULL и в I<errno> "
"записывает соответствующий код."

#. type: Plain text
#: man-pages/man3/random.3:148
msgid "The I<state> argument given to B<setstate>()  was NULL."
msgstr "Аргумент I<state>, указанный B<setstate>(), равен NULL."

#. type: Plain text
#: man-pages/man3/random.3:152
msgid "A state array of less than 8 bytes was specified to B<initstate>()."
msgstr "Функции B<initstate>() передан массив состояния меньше 8 байт."

#. type: SH
#: man-pages/man3/random.3:152
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/random.3:153
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/random.3:161
msgid ""
"The B<random>(), B<srandom>(), B<initstate>(), and B<setstate>()  functions "
"are thread-safe."
msgstr ""
"Функции B<random>(), B<srandom>(), B<initstate>() и B<setstate>() можно "
"использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/random.3:163
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/random.3:169
msgid ""
"Current \"optimal\" values for the size of the state array I<n> are 8, 32, "
"64, 128, and 256 bytes; other amounts will be rounded down to the nearest "
"known amount.  Using less than 8 bytes will cause an error."
msgstr ""
"В настоящее время «оптимальными» размерами массива состояния I<n> считаются "
"8, 32, 64, 128 и 256 байтов; все остальные значения будут округляться до "
"ближайшего известного меньшего количества. Использование размера менее 8 "
"байтов приводит к ошибке."

#. type: Plain text
#: man-pages/man3/random.3:176
msgid ""
"This function should not be used in cases where multiple threads use "
"B<random>()  and the behavior should be reproducible.  Use B<random_r>(3)  "
"for that purpose."
msgstr ""
"Эта функция не должна использоваться, если B<random>() используется в "
"нескольких нитях и её поведение должно быть повторимо. Для этих целей "
"используйте B<random_r>(3)."

#. type: Plain text
#: man-pages/man3/random.3:183
msgid ""
"Random-number generation is a complex topic.  I<Numerical Recipes in C: The "
"Art of Scientific Computing> (William H. Press, Brian P. Flannery, Saul A. "
"Teukolsky, William T. Vetterling; New York: Cambridge University Press, "
"2007, 3rd ed.)  provides an excellent discussion of practical random-number "
"generation issues in Chapter 7 (Random Numbers)."
msgstr ""
"Генерация случайных чисел является сложной проблемой. В главе 7 (Random "
"Numbers) I<Numerical Recipes in C: The Art of Scientific Computing> (William "
"H. Press, Brian P. Flannery, Saul A. Teukolsky, William T. Vetterling; New "
"York: Cambridge University Press, 2007, 3rd ed.) приведено великолепное "
"обсуждение проблем практического применения генерации случайных чисел."

#. type: Plain text
#: man-pages/man3/random.3:189
msgid ""
"For a more theoretical discussion which also covers many practical issues in"
" depth, see Chapter 3 (Random Numbers) in Donald E. Knuth's I<The Art of "
"Computer Programming>, volume 2 (Seminumerical Algorithms), 2nd ed.; "
"Reading, Massachusetts: Addison-Wesley Publishing Company, 1981."
msgstr ""
"Также вы можете обратиться к теоретическому обсуждению, которое также "
"объясняет многие практические проблемы, приведенному в главе 3 (Random "
"Numbers) второго тома I<Искусства программирования> Дональда Кнута (The Art "
"of Computer Programming, volume 2 (Seminumerical Algorithms), 2nd ed.; "
"Reading, Massachusetts: Addison-Wesley Publishing Company, 1981)."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=15380
#. type: Plain text
#: man-pages/man3/random.3:197
msgid ""
"According to POSIX, B<initstate>()  should return NULL on error.  In the "
"glibc implementation, I<errno> is (as specified) set on error, but the "
"function does not return NULL."
msgstr ""
"Согласно POSIX, B<initstate>() должна возвращать NULL при ошибке. Реализация "
"glibc в I<errno> записывает код ошибки (как по стандарту), но не возвращает "
"NULL."

#. type: Plain text
#: man-pages/man3/random.3:201
msgid "B<drand48>(3), B<rand>(3), B<random_r>(3), B<srand>(3)"
msgstr "B<drand48>(3), B<rand>(3), B<random_r>(3), B<srand>(3)"

#. type: TH
#: man-pages/man3/rcmd.3:43
#, no-wrap
msgid "RCMD"
msgstr "RCMD"

#. type: Plain text
#: man-pages/man3/rcmd.3:48
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - процедуры возврата потока в удалённую команду"

#. type: Plain text
#: man-pages/man3/rcmd.3:51
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems"
" */\n"
msgstr ""
"B<#include E<lt>netdb.hE<gt> \\ \\ >/* или E<lt>unistd.hE<gt> в некоторых "
"системах */\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:54
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<"
"locuser>B<, >\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<"
");>\n"
msgstr ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<"
"locuser>B<, >\nB<         const char *>I<remuser>B<, const char *>I<cmd>B<, "
"int *>I<fd2p>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:56
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr "B<int rresvport(int *>I<port>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:59
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\nB<             "
"const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:62
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\nB<            "
"const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:66
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>"
"I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>"
"B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>"
"I<locuser>B<, >\nB<            const char *>I<remuser>B<, const char *>I<cmd>"
"B<, int *>I<fd2p>B<,>\nB<            sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:68
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:72
#, no-wrap
msgid ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, "
"sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<, >\nB<         "
"       const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:76
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, "
"sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\nB<          "
"     const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>"
"\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:92
msgid ""
"B<rcmd>(), B<rcmd_af>(), B<rresvport>(), B<rresvport_af>(), B<iruserok>(), "
"B<iruserok_af>(), B<ruserok>(), B<ruserok_af>(): _BSD_SOURCE"
msgstr ""
"B<rcmd>(), B<rcmd_af>(), B<rresvport>(), B<rresvport_af>(), B<iruserok>(), B<"
"iruserok_af>(), B<ruserok>(), B<ruserok_af>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/rcmd.3:113
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a descriptor to a socket with"
" an address in the privileged port space.  The B<iruserok>()  and "
"B<ruserok>()  functions are used by servers to authenticate clients "
"requesting service with B<rcmd>().  All four functions are used by the "
"B<rshd>(8)  server (among others)."
msgstr ""
"Функция B<rcmd>() применяется суперпользователем для исполнения команды на "
"удалённой машине при помощи схемы аутентификации, основанной на "
"зарезервированных номерах портов. Функция B<rresvport>() возвращает "
"дескриптор сокета с адресом в привилегированном пространстве портов. Функции "
"B<iruserok>() и B<ruserok>() используются серверами для аутентификации "
"клиентов, запрашивающих сервис B<rcmd>(). Все четыре функции используются "
"сервером B<rshd>(8) (среди прочих)."

#. type: SS
#: man-pages/man3/rcmd.3:113
#, no-wrap
msgid "rcmd()"
msgstr "rcmd()"

#. type: Plain text
#: man-pages/man3/rcmd.3:129
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host and a connection is "
"established to a server residing at the well-known Internet port I<inport>."
msgstr ""
"Функция B<rcmd>() ищет узел I<*ahost>, используя B<gethostbyname>(3) и "
"возвращает -1, если узел не существует. Иначе I<*ahost> устанавливается "
"равным стандартному имени узла, при этом создаётся соединение с сервером на "
"хорошо известном порту Интернет I<inport>."

#. type: Plain text
#: man-pages/man3/rcmd.3:158
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as"
" I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel "
"to a control process will be set up, and a descriptor for it will be placed "
"in I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel"
" as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote command)"
" will be made the same as the I<stdout> and no provision is made for sending"
" arbitrary signals to the remote process, although you may be able to get "
"its attention by using out-of-band data."
msgstr ""
"Если соединение успешно установлено, то вызывающему возвращается сокет в "
"домене Интернет типа B<SOCK_STREAM>, который для удалённой команды считается "
"I<stdin> и I<stdout>. Если I<fd2p> не равно нулю, то устанавливается "
"вспомогательный канал до управляющего процесса, а его дескриптор будет "
"помещён в I<*fd2p>. Управляющий процесс возвращает диагностический вывод из "
"команды (устройства 2) в этот канал, а также принимает байты из этого канала, "
"считая их номерами сигналов UNIX, для их пересылки группе процессов команды. "
"Если I<fd2p> равно 0, то I<stderr> (устройство 2 удалённой команды) будет "
"работать аналогично I<stdout> и для отправки произвольных сигналов в "
"удалённый процесс не будет создано никаких ходов, хотя вы сможете привлечь к "
"себе внимание, используя внеполосную передачу данных."

#. type: Plain text
#: man-pages/man3/rcmd.3:161
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr "Протокол подробно описан в B<rshd>(8)."

#. type: SS
#: man-pages/man3/rcmd.3:161
#, no-wrap
msgid "rresvport()"
msgstr "rresvport()"

#. type: Plain text
#: man-pages/man3/rcmd.3:183
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several"
" other functions.  Privileged ports are those in the range 0 to 1023.  Only "
"a privileged process (B<CAP_NET_BIND_SERVICE>)  is allowed to bind to a "
"privileged port.  In the glibc implementation, this function restricts its "
"search to the ports from 512 to 1023.  The I<port> argument is value-result:"
" the value it supplies to the call is used as the starting point for a "
"circular search of the port range; on (successful) return, it contains the "
"port number that was bound to."
msgstr ""
"Функция B<rresvport>() используется для получения сокета с привязанным "
"привилегированным портом. Этот сокет подходит для использования функцией B<"
"rcmd>() и некоторыми другими. Привилегированные порты Интернет — это порты с "
"номерами от 0 до 1023. Только привилегированный процесс (B<"
"CAP_NET_BIND_SERVICE>) может привязаться к привилегированному порту. В "
"реализации glibc эта функция ограничена в использовании портов номерами с 512 "
"по 1023. Аргумент I<port> является значением-результатом: передаваемое в "
"вызов значение используется в качестве начальной точки кругового поиска в "
"диапазоне портов; при (успешном) возврате, он содержит номер порта, к "
"которому была осуществлена привязка."

#. type: SS
#: man-pages/man3/rcmd.3:183
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr "iruserok() и ruserok()"

#. type: Plain text
#: man-pages/man3/rcmd.3:201
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not>"
" the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""
"Параметрами функций B<iruserok>() и B<ruserok>() являются, соответственно, "
"IP-адрес или имя удалённого узла, два имени пользователя и флаг, указывающий, "
"является ли имя локального пользователя именем суперпользователя. Далее, если "
"пользователь I<не> является суперпользователем, они проверяют файл I<"
"/etc/hosts.equiv>. Если ничего не находится или завершается с ошибкой, то "
"проверяется I<.rhosts> в домашнем каталоге пользователя (для получения "
"информации о том, разрешены ли запросы к службе)."

#. type: Plain text
#: man-pages/man3/rcmd.3:217
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other"
" than the user or the superuser, or is writable by anyone other than the "
"owner, the check automatically fails.  Zero is returned if the machine name "
"is listed in the I<hosts.equiv> file, or the host and remote username are "
"found in the I<.rhosts> file; otherwise B<iruserok>()  and B<ruserok>()  "
"return -1.  If the local domain (as obtained from B<gethostname>(2))  is the"
" same as the remote domain, only the machine name need be specified."
msgstr ""
"Если этот файл не существует, не является обычным файлом, если его владельцем "
"является не текущий пользователь или не суперпользователь, или если он "
"доступен для записи кому-то помимо владельца, то проверка завершается с "
"ошибкой. Если имя машины указано в файле I<hosts.equiv>, или если узел и имя "
"пользователя для удалённого доступа найдены в файле I<.rhosts>, то "
"возвращается 0; иначе B<iruserok>() и B<ruserok>() возвращают -1. Если имя "
"локального домена (полученное вызовом B<gethostname>(2)) совпадает с именем "
"удалённого домена, то может указываться только имя машины."

#. type: Plain text
#: man-pages/man3/rcmd.3:223
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used"
" in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""
"Если IP-адрес удалённого узла известен, то должна использоваться B<iruserok>"
"() вместо B<ruserok>(), так как при этом не требуется доверия к DNS-серверу "
"для домена удалённого узла."

#. type: SS
#: man-pages/man3/rcmd.3:223
#, no-wrap
msgid "*_af() variants"
msgstr "Варианты *_af()"

#. type: Plain text
#: man-pages/man3/rcmd.3:239
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports"
" the use of B<AF_UNSPEC>."
msgstr ""
"Все описанные ранее функции работают с сокетами IPv4 (B<AF_INET>). Варианты "
"«_af»  имеют дополнительный аргумент, который позволяет указать адресное "
"семейство сокета. Для этих функций значением аргумента I<af> может быть B<"
"AF_INET> или B<AF_INET6>. Также B<rcmd_af>() поддерживает использование B<"
"AF_UNSPEC>."

#. type: Plain text
#: man-pages/man3/rcmd.3:245
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""
"Функция B<rcmd>() при успешном выполнении возвращает корректный номер "
"дескриптора сокета. При ошибках возвращается -1 и в стандартный поток ошибок "
"выводится диагностическое сообщение."

#. type: Plain text
#: man-pages/man3/rcmd.3:256
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded"
" to mean \"All network ports in use.\""
msgstr ""
"Функция B<rresvport>() при успешном выполнении возвращает корректный "
"привязанный дескриптор сокета. При ошибках возвращается -1 и в глобальную "
"переменную I<errno> записывается код ошибки. Код ошибки B<EAGAIN> означает "
"«Все сетевые порты заняты»."

#. type: Plain text
#: man-pages/man3/rcmd.3:262
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr "Информацию о результатах B<ruserok>() и B<iruserok>() смотрите выше."

#. type: Plain text
#: man-pages/man3/rcmd.3:270
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""
"Функции B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>() и B<ruserok_af>() "
"появились в glibc начиная с версии 2.2."

#. type: Plain text
#: man-pages/man3/rcmd.3:278
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems."
"  These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""
"Отсутствуют в POSIX.1-2001. Есть в BSD, Solaris и многих других системах. "
"Данные функции впервые появились в 4.2BSD. Варианты «_af» были добавлены "
"позднее и распространены не так широко."

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: man-pages/man3/rcmd.3:285
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""
"Функции B<iruserok>() и B<iruserok_af>() объявляются в заголовках glibc "
"только начиная с версии 2.12."

#. type: Plain text
#: man-pages/man3/rcmd.3:292
msgid ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), "
"B<rlogind>(8), B<rshd>(8)"
msgstr ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), B<rlogind>"
"(8), B<rshd>(8)"

#. type: TH
#: man-pages/man3/round.3:27
#, no-wrap
msgid "ROUND"
msgstr "ROUND"

#. type: Plain text
#: man-pages/man3/round.3:30
msgid "round, roundf, roundl - round to nearest integer, away from zero"
msgstr ""
"round, roundf, roundl - округление до ближайшего целого в направлении от нуля"

#. type: Plain text
#: man-pages/man3/round.3:33
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/round.3:35
#, no-wrap
msgid "B<double round(double >I<x>B<);>\n"
msgstr "B<double round(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/round.3:37
#, no-wrap
msgid "B<float roundf(float >I<x>B<);>\n"
msgstr "B<float roundf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/round.3:39
#, no-wrap
msgid "B<long double roundl(long double >I<x>B<);>\n"
msgstr "B<long double roundl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/round.3:42
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/round.3:52
msgid "B<round>(), B<roundf>(), B<roundl>():"
msgstr "B<round>(), B<roundf>(), B<roundl>():"

#. type: Plain text
#: man-pages/man3/round.3:55
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\"
" 200112L;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"

#. type: Plain text
#: man-pages/man3/round.3:58
msgid "or I<cc\\ -std=c99>"
msgstr "или I<cc\\ -std=c99>"

#. type: Plain text
#: man-pages/man3/round.3:69
msgid ""
"These functions round I<x> to the nearest integer, but round halfway cases "
"away from zero (regardless of the current rounding direction, see "
"B<fenv>(3)), instead of to the nearest even integer like B<rint>(3)."
msgstr ""
"Эти функции округляют аргумент I<x> до ближайшего целого значения, но при "
"округлении в половине случаев используют направление округления от нуля "
"(независимо от текущего направления округления, смотрите B<fenv>(3)), вместо "
"округления до ближайшего чётного целого, как это делает функция B<rint>(3)."

#. type: Plain text
#: man-pages/man3/round.3:75
msgid "For example, I<round(0.5)> is 1.0, and I<round(-0.5)> is -1.0."
msgstr ""
"Например, результат I<round(0.5)> будет равен 1.0, а I<round(-0.5)> будет "
"равен -1.0."

#. type: Plain text
#: man-pages/man3/round.3:77
msgid "These functions return the rounded integer value."
msgstr "Данные функции возвращают округлённое целое число."

#. type: Plain text
#: man-pages/man3/round.3:83
msgid "If I<x> is integral, +0, -0, NaN, or infinite, I<x> itself is returned."
msgstr ""
"Если I<x> целое, +0, -0, NaN или стремится к бесконечности, то будет "
"возвращено значение I<x>."

#. type: Plain text
#: man-pages/man3/round.3:86
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""
"Ошибки не возникают. В документах POSIX.1-2001 описывается ошибка диапазона "
"при переполнениях, однако смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man3/round.3:88
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/round.3:96
msgid ""
"The B<round>(), B<roundf>(), and B<roundl>()  functions are thread-safe."
msgstr ""
"Функции B<round>(), B<roundf>() и B<roundl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/round.3:98
msgid "C99, POSIX.1-2001."
msgstr "C99, POSIX.1-2001."

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: man-pages/man3/round.3:114
msgid ""
"POSIX.1-2001 contains text about overflow (which might set I<errno> to "
"B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the result "
"cannot overflow on any current machine, so this error-handling stuff is just"
" nonsense.  (More precisely, overflow can happen only when the maximum value"
" of the exponent is smaller than the number of mantissa bits.  For the "
"IEEE-754 standard 32-bit and 64-bit floating-point numbers the maximum value"
" of the exponent is 128 (respectively, 1024), and the number of mantissa "
"bits is 24 (respectively, 53).)"
msgstr ""
"В POSIX.1-2001 есть текст о переполнении (которое может установить I<errno> в "
"B<ERANGE> или вызвать исключение B<FE_OVERFLOW>). На практике, результат не "
"может выйти за диапазон ни на каком компьютере, поэтому обработка этой ошибки "
"не имеет смысла (точнее говоря, переполнение возможно только в том случае, "
"когда максимальное значение экспоненты меньше числа бит мантиссы. В стандарте "
"IEEE-754 для 32- и 64-битных чисел с плавающей точкой максимальное значение "
"экспоненты равно 128 и 1024 соответственно, а число бит мантиссы — 24 и 53 "
"соответственно)."

#. type: Plain text
#: man-pages/man3/round.3:119
msgid ""
"If you want to store the rounded value in an integer type, you probably want"
" to use one of the functions described in B<lround>(3)  instead."
msgstr ""
"Если вы хотите сохранить округлённое значение в целочисленном типе, то лучше "
"использовать одну из функций, описанных в B<lround>(3)."

#. type: Plain text
#: man-pages/man3/round.3:125
msgid ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), "
"B<trunc>(3)"
msgstr ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), B<trunc>"
"(3)"

#. type: TH
#: man-pages/man3/rand.3:41
#, no-wrap
msgid "RAND"
msgstr "RAND"

#. type: TH
#: man-pages/man3/rand.3:41
#, no-wrap
msgid "2014-01-18"
msgstr "2014-01-18"

#. type: Plain text
#: man-pages/man3/rand.3:44
msgid "rand, rand_r, srand - pseudo-random number generator"
msgstr "rand, rand_r, srand - генератор псевдослучайных чисел"

#. type: Plain text
#: man-pages/man3/rand.3:49
#, no-wrap
msgid "B<int rand(void);>\n"
msgstr "B<int rand(void);>\n"

#. type: Plain text
#: man-pages/man3/rand.3:51
#, no-wrap
msgid "B<int rand_r(unsigned int *>I<seedp>B<);>\n"
msgstr "B<int rand_r(unsigned int *>I<seedp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rand.3:53
#, no-wrap
msgid "B<void srand(unsigned int >I<seed>B<);>\n"
msgstr "B<void srand(unsigned int >I<seed>B<);>\n"

#. type: Plain text
#: man-pages/man3/rand.3:62
msgid ""
"B<rand_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<rand_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/rand.3:68
msgid ""
"The B<rand>()  function returns a pseudo-random integer in the range 0 to "
"B<RAND_MAX> inclusive (i.e., the mathematical range [0,\\ B<RAND_MAX>])."
msgstr ""
"Функция B<rand>() возвращает псевдослучайное целое число в диапазоне от нуля "
"до B<RAND_MAX> включительно (т. е., из математического диапазона [0,\\ B<"
"RAND_MAX>])."

#. type: Plain text
#: man-pages/man3/rand.3:77
msgid ""
"The B<srand>()  function sets its argument as the seed for a new sequence of"
" pseudo-random integers to be returned by B<rand>().  These sequences are "
"repeatable by calling B<srand>()  with the same seed value."
msgstr ""
"Функция B<srand>() устанавливает свой аргумент как основу (seed) для новой "
"последовательности псевдослучайных целых чисел, возвращаемых функцией B<rand>"
"(). Эту последовательность можно воспроизвести. Для этого необходимо вызвать "
"B<srand>() с той же величиной основы."

#. type: Plain text
#: man-pages/man3/rand.3:81
msgid ""
"If no seed value is provided, the B<rand>()  function is automatically "
"seeded with a value of 1."
msgstr ""
"Если основа не задана, то функция B<rand>() автоматически устанавливает её "
"равной 1."

#. type: Plain text
#: man-pages/man3/rand.3:92
msgid ""
"The function B<rand>()  is not reentrant or thread-safe, since it uses "
"hidden state that is modified on each call.  This might just be the seed "
"value to be used by the next call, or it might be something more elaborate."
"  In order to get reproducible behavior in a threaded application, this "
"state must be made explicit; this can be done using the reentrant function "
"B<rand_r>()."
msgstr ""
"Функция B<rand>() не реентерабельная и её нельзя использовать в нитях, так "
"как она использует скрытое состояние, которое изменяется с каждым вызовом. "
"Это может быть как просто значение основы, так и что-то более сложное. Чтобы "
"получить воспроизводимое поведение в многонитевом приложении такое состояние "
"нужно создать явным образом; это можно сделать с помощью реентерабельной "
"функции B<rand_r>()."

#. type: Plain text
#: man-pages/man3/rand.3:108
msgid ""
"Like B<rand>(), B<rand_r>()  returns a pseudo-random integer in the range "
"[0,\\ B<RAND_MAX>].  The I<seedp> argument is a pointer to an I<unsigned "
"int> that is used to store state between calls.  If B<rand_r>()  is called "
"with the same initial value for the integer pointed to by I<seedp>, and that"
" value is not modified between calls, then the same pseudo-random sequence "
"will result."
msgstr ""
"Как и B<rand>(), B<rand_r>() возвращает псевдослучайное целое число из "
"диапазона [0,\\ B<RAND_MAX>]. Аргумент I<seedp> является указателем на число "
"I<unsigned int>, которое используется для хранения состояния между вызовами. "
"Если B<rand_r>() вызывается с одинаковым начальным значением целого, на "
"которое указывает I<seedp>, и это значение не изменяется между вызовами, то "
"результатом будет одинаковая псевдослучайная последовательность."

#. type: Plain text
#: man-pages/man3/rand.3:118
msgid ""
"The value pointed to by the I<seedp> argument of B<rand_r>()  provides only "
"a very small amount of state, so this function will be a weak pseudo-random "
"generator.  Try B<drand48_r>(3)  instead."
msgstr ""
"Значение, на которое указывает аргумент I<seedp> для B<rand_r>(), "
"предоставляет только очень малую часть состояния, поэтому данная функция "
"будет очень не случайным псевдослучайным генератором. Используйте вместо неё "
"B<drand48_r>(3)."

#. type: Plain text
#: man-pages/man3/rand.3:129
msgid ""
"The B<rand>()  and B<rand_r>()  functions return a value between 0 and "
"B<RAND_MAX> (inclusive).  The B<srand>()  function returns no value."
msgstr ""
"Функции B<rand>() и B<rand_r>() возвращают значение в промежутке от 0 до B<"
"RAND_MAX> (включительно). Функция B<srand>() не возвращает результат."

#. type: Plain text
#: man-pages/man3/rand.3:141
msgid ""
"The functions B<rand>()  and B<srand>()  conform to SVr4, 4.3BSD, C89, C99, "
"POSIX.1-2001.  The function B<rand_r>()  is from POSIX.1-2001.  POSIX.1-2008"
" marks B<rand_r>()  as obsolete."
msgstr ""
"Функции B<rand>() и B<srand>() описаны в SVr4, 4.3BSD, C89, C99, "
"POSIX.1-2001. Функция B<rand_r>() описана в POSIX.1-2001. В POSIX.1-2008 "
"функция B<rand_r>() помечена как устаревшая."

#. type: Plain text
#: man-pages/man3/rand.3:160
msgid ""
"The versions of B<rand>()  and B<srand>()  in the Linux C Library use the "
"same random number generator as B<random>(3)  and B<srandom>(3), so the "
"lower-order bits should be as random as the higher-order bits.  However, on "
"older B<rand>()  implementations, and on current implementations on "
"different systems, the lower-order bits are much less random than the "
"higher-order bits.  Do not use this function in applications intended to be "
"portable when good randomness is needed.  (Use B<random>(3)  instead.)"
msgstr ""
"Версия функций B<rand>() и B<srand>() в библиотеке Си для Linux использует "
"тот же генератор чисел, что и в функциях B<random>(3) и B<srandom>(3), так "
"что младшие биты в числе случайны настолько, насколько и старшие. В то же "
"время, в старых реализациях B<rand>() и в текущих реализациях на других "
"системах младшие биты являются гораздо менее случайными, чем старшие. Не "
"используйте эту функцию в переносимых приложениях, для которых требуется "
"большая случайность (вместо неё используйте B<random>(3))."

#. type: Plain text
#: man-pages/man3/rand.3:166
msgid ""
"POSIX.1-2001 gives the following example of an implementation of B<rand>()  "
"and B<srand>(), possibly useful when one needs the same sequence on two "
"different machines."
msgstr ""
"В POSIX.1-2001 приведён следующий пример реализации B<rand>() и B<srand>(), "
"возможно полезный, если требуется одинаковая последовательность на двух "
"разных машинах."

#. type: Plain text
#: man-pages/man3/rand.3:170
#, no-wrap
msgid "static unsigned long next = 1;\n"
msgstr "static unsigned long next = 1;\n"

#. type: Plain text
#: man-pages/man3/rand.3:176
#, no-wrap
msgid ""
"/* RAND_MAX assumed to be 32767 */\n"
"int myrand(void) {\n"
"    next = next * 1103515245 + 12345;\n"
"    return((unsigned)(next/65536) % 32768);\n"
"}\n"
msgstr ""
"/* предполагается, что RAND_MAX равно 32767 */\nint myrand(void) {\n    next "
"= next * 1103515245 + 12345;\n    return((unsigned)(next/65536) % 32768);\n}\n"

#. type: Plain text
#: man-pages/man3/rand.3:180
#, no-wrap
msgid ""
"void mysrand(unsigned int seed) {\n"
"    next = seed;\n"
"}\n"
msgstr "void mysrand(unsigned int seed) {\n    next = seed;\n}\n"

#. type: Plain text
#: man-pages/man3/rand.3:187
msgid ""
"The following program can be used to display the pseudo-random sequence "
"produced by B<rand>()  when given a particular seed."
msgstr ""
"Следующая программа может использоваться для отображения псевдослучайной "
"последовательности, созданной B<rand>() при указании определённой основы."

#. type: Plain text
#: man-pages/man3/rand.3:192
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rand.3:198
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, r, nloops;\n"
"    unsigned int seed;\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    int j, r, nloops;\n    unsigned int "
"seed;\n"

#. type: Plain text
#: man-pages/man3/rand.3:203
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>seedE<gt> E<lt>nloopsE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n        fprintf(stderr, \"Использование: %s E<lt>seedE<"
"gt> E<lt>nloopsE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/rand.3:206
#, no-wrap
msgid ""
"    seed = atoi(argv[1]);\n"
"    nloops = atoi(argv[2]);\n"
msgstr "    seed = atoi(argv[1]);\n    nloops = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/rand.3:212
#, no-wrap
msgid ""
"    srand(seed);\n"
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        r =  rand();\n"
"        printf(\"%d\\en\", r);\n"
"    }\n"
msgstr ""
"    srand(seed);\n    for (j = 0; j E<lt> nloops; j++) {\n        r =  "
"rand();\n        printf(\"%d\\en\", r);\n    }\n"

#. type: Plain text
#: man-pages/man3/rand.3:219
msgid "B<drand48>(3), B<random>(3)"
msgstr "B<drand48>(3), B<random>(3)"

#. type: TH
#: man-pages/man3/rewinddir.3:31
#, no-wrap
msgid "REWINDDIR"
msgstr "REWINDDIR"

#. type: TH
#: man-pages/man3/rewinddir.3:31
#, no-wrap
msgid "2013-09-02"
msgstr "2013-09-02"

#. type: Plain text
#: man-pages/man3/rewinddir.3:34
msgid "rewinddir - reset directory stream"
msgstr "rewinddir - сброс потока каталога"

#. type: Plain text
#: man-pages/man3/rewinddir.3:39
#, no-wrap
msgid "B<#include E<lt>dirent.hE<gt>>\n"
msgstr "B<#include E<lt>dirent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/rewinddir.3:41
#, no-wrap
msgid "B<void rewinddir(DIR *>I<dirp>B<);>\n"
msgstr "B<void rewinddir(DIR *>I<dirp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rewinddir.3:49
msgid ""
"The B<rewinddir>()  function resets the position of the directory stream "
"I<dirp> to the beginning of the directory."
msgstr ""
"Функция B<rewinddir>() сбрасывает текущее положение потока каталога I<dirp> в "
"начало каталога."

#. type: Plain text
#: man-pages/man3/rewinddir.3:53
msgid "The B<rewinddir>()  function returns no value."
msgstr "Функция B<rewinddir>() ничего не возвращает."

#. type: Plain text
#: man-pages/man3/rewinddir.3:58
msgid "The B<rewinddir>()  function is thread-safe."
msgstr ""
"Функцию B<rewinddir>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/rewinddir.3:66
msgid ""
"B<closedir>(3), B<opendir>(3), B<readdir>(3), B<scandir>(3), B<seekdir>(3), "
"B<telldir>(3)"
msgstr ""
"B<closedir>(3), B<opendir>(3), B<readdir>(3), B<scandir>(3), B<seekdir>(3), "
"B<telldir>(3)"

#. type: TH
#: man-pages/man3/rtnetlink.3:12
#, no-wrap
msgid "2012-03-24"
msgstr "2012-03-24"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:15
msgid "rtnetlink - macros to manipulate rtnetlink messages"
msgstr "rtnetlink - макросы для обработки сообщений rtnetlink"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:28
msgid "B<int RTA_OK(struct rtattr *>I<rta>B<, int >I<rtabuflen>B<);>"
msgstr "B<int RTA_OK(struct rtattr *>I<rta>B<, int >I<rtabuflen>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:30
msgid "B<void *RTA_DATA(struct rtattr *>I<rta>B<);>"
msgstr "B<void *RTA_DATA(struct rtattr *>I<rta>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:32
msgid "B<unsigned int RTA_PAYLOAD(struct rtattr *>I<rta>B<);>"
msgstr "B<unsigned int RTA_PAYLOAD(struct rtattr *>I<rta>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:35
msgid ""
"B<struct rtattr *RTA_NEXT(struct rtattr *>I<rta>B<, unsigned int "
">I<rtabuflen>B<);>"
msgstr ""
"B<struct rtattr *RTA_NEXT(struct rtattr *>I<rta>B<, unsigned int >I<rtabuflen>"
"B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:37
msgid "B<unsigned int RTA_LENGTH(unsigned int >I<length>B<);>"
msgstr "B<unsigned int RTA_LENGTH(unsigned int >I<length>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:39
msgid "B<unsigned int RTA_SPACE(unsigned int >I<length>B<);>"
msgstr "B<unsigned int RTA_SPACE(unsigned int >I<length>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:46
msgid ""
"All B<rtnetlink>(7)  messages consist of a B<netlink>(7)  message header and"
" appended attributes.  The attributes should be manipulated only using the "
"macros provided here."
msgstr ""
"Все сообщения B<rtnetlink>(7) состоят из заголовка сообщений B<netlink>(7) и "
"дополнительных атрибутов. Атрибуты могут быть обработаны только описанными "
"здесь макросами."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:57
msgid ""
"B<RTA_OK(>I<rta>B<, >I<attrlen>B<)> returns true if I<rta> points to a valid"
" routing attribute; I<attrlen> is the running length of the attribute "
"buffer.  When not true then you must assume there are no more attributes in "
"the message, even if I<attrlen> is nonzero."
msgstr ""
"B<RTA_OK(>I<rta>B<, >I<attrlen>B<)> возвращает истинное значение в случае, "
"если I<rta> указывает на правильный атрибут маршрутизации; I<attrlen> — "
"рабочая длина буфера атрибутов. Если возвращаемое значение ложно, то в "
"сообщении больше нет атрибутов, даже если I<attrlen> не равно нулю."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:60
msgid ""
"B<RTA_DATA(>I<rta>B<)> returns a pointer to the start of this attribute's "
"data."
msgstr "B<RTA_DATA(>I<rta>B<)> возвращает указатель на начало данных атрибута."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:63
msgid "B<RTA_PAYLOAD(>I<rta>B<)> returns the length of this attribute's data."
msgstr "B<RTA_PAYLOAD(>I<rta>B<)> возвращает длину данных атрибута."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:72
msgid ""
"B<RTA_NEXT(>I<rta>B<, >I<attrlen>B<)> gets the next attribute after I<rta>."
"  Calling this macro will update I<attrlen>.  You should use B<RTA_OK> to "
"check the validity of the returned pointer."
msgstr ""
"B<RTA_NEXT(>I<rta>B<, >I<attrlen>B<)> считывает следующий за I<rta> атрибут. "
"Вызов этого макроса обновит I<attrlen>. Для проверки правильности полученного "
"указателя используйте B<RTA_OK>."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:77
msgid ""
"B<RTA_LENGTH(>I<len>B<)> returns the length which is required for I<len> "
"bytes of data plus the header."
msgstr ""
"B<RTA_LENGTH(>I<len>B<)> возвращает длину, которая требуется для I<len> "
"байтов данных плюс заголовок."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:82
msgid ""
"B<RTA_SPACE(>I<len>B<)> returns the amount of space which will be needed in "
"a message with I<len> bytes of data."
msgstr ""
"B<RTA_SPACE(>I<len>B<)> возвращает количество места, которое требуется для "
"сообщения с данными длиной I<len> байт."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:84
msgid "These macros are nonstandard Linux extensions."
msgstr "Данные макросы являются нестандартными расширениями Linux."

#.  FIXME ? would be better to use libnetlink in the EXAMPLE code here
#. type: Plain text
#: man-pages/man3/rtnetlink.3:90
msgid "Creating a rtnetlink message to set the MTU of a device:"
msgstr "Создание сообщения rtnetlink для установки MTU устройства:"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:92
#, no-wrap
msgid "    #include E<lt>linux/rtnetlink.hE<gt>\n"
msgstr "    #include E<lt>linux/rtnetlink.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:94
#, no-wrap
msgid "    ...\n"
msgstr "    ...\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:100
#, no-wrap
msgid ""
"    struct {\n"
"        struct nlmsghdr  nh;\n"
"        struct ifinfomsg if;\n"
"        char             attrbuf[512];\n"
"    } req;\n"
msgstr ""
"    struct {\n        struct nlmsghdr  nh;\n        struct ifinfomsg if;\n    "
"    char             attrbuf[512];\n    } req;\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:103
#, no-wrap
msgid ""
"    struct rtattr *rta;\n"
"    unsigned int mtu = 1000;\n"
msgstr "    struct rtattr *rta;\n    unsigned int mtu = 1000;\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:105
#, no-wrap
msgid "    int rtnetlink_sk = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n"
msgstr ""
"    int rtnetlink_sk = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:121
#, no-wrap
msgid ""
"    memset(&req, 0, sizeof(req));\n"
"    req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n"
"    req.nh.nlmsg_flags = NLM_F_REQUEST;\n"
"    req.nh.nlmsg_type = RTM_NEWLINK;\n"
"    req.if.ifi_family = AF_UNSPEC;\n"
"    req.if.ifi_index = INTERFACE_INDEX;\n"
"    req.if.ifi_change = 0xffffffff; /* ??? */\n"
"    rta = (struct rtattr *)(((char *) &req) +\n"
"                             NLMSG_ALIGN(req.nh.nlmsg_len));\n"
"    rta-E<gt>rta_type = IFLA_MTU;\n"
"    rta-E<gt>rta_len = RTA_LENGTH(sizeof(unsigned int));\n"
"    req.n.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) +\n"
"                                  RTA_LENGTH(sizeof(mtu));\n"
"    memcpy(RTA_DATA(rta), &mtu, sizeof(mtu));\n"
"    send(rtnetlink_sk, &req, req.nh.nlmsg_len);\n"
msgstr ""
"    memset(&req, 0, sizeof(req));\n    req.nh.nlmsg_len = "
"NLMSG_LENGTH(sizeof(struct ifinfomsg));\n    req.nh.nlmsg_flags = "
"NLM_F_REQUEST;\n    req.nh.nlmsg_type = RTM_NEWLINK;\n    req.if.ifi_family = "
"AF_UNSPEC;\n    req.if.ifi_index = INTERFACE_INDEX;\n    req.if.ifi_change = "
"0xffffffff; /* ??? */\n    rta = (struct rtattr *)(((char *) &req) +\n        "
"                     NLMSG_ALIGN(req.nh.nlmsg_len));\n    rta-E<gt>rta_type = "
"IFLA_MTU;\n    rta-E<gt>rta_len = RTA_LENGTH(sizeof(unsigned int));\n    "
"req.n.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) +\n                           "
"       RTA_LENGTH(sizeof(mtu));\n    memcpy(RTA_DATA(rta), &mtu, "
"sizeof(mtu));\n    send(rtnetlink_sk, &req, req.nh.nlmsg_len);\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:125
msgid "B<netlink>(3), B<netlink>(7), B<rtnetlink>(7)"
msgstr "B<netlink>(3), B<netlink>(7), B<rtnetlink>(7)"

#. type: TH
#: man-pages/man3/regex.3:30
#, no-wrap
msgid "2013-02-11"
msgstr "2013-02-11"

#. type: Plain text
#: man-pages/man3/regex.3:33
msgid "regcomp, regexec, regerror, regfree - POSIX regex functions"
msgstr ""
"regcomp, regexec, regerror, regfree - функции регулярных выражений POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>regex.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>regex.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/regex.3:39
#, no-wrap
msgid ""
"B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int "
">I<cflags>B<);>\n"
msgstr ""
"B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int >I<cflags>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/regex.3:43
#, no-wrap
msgid ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<"
"nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"
msgstr ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<"
"nmatch>B<,>\nB<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"

#. type: Plain text
#: man-pages/man3/regex.3:46
#, no-wrap
msgid ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<"
"errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"
msgstr ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<"
"errbuf>B<,>\nB<                size_t >I<errbuf_size>B<);>\n"

#. type: Plain text
#: man-pages/man3/regex.3:48
#, no-wrap
msgid "B<void regfree(regex_t *>I<preg>B<);>\n"
msgstr "B<void regfree(regex_t *>I<preg>B<);>\n"

#. type: SS
#: man-pages/man3/regex.3:50
#, no-wrap
msgid "POSIX regex compiling"
msgstr "Компилирование регулярных выражений POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:56
msgid ""
"B<regcomp>()  is used to compile a regular expression into a form that is "
"suitable for subsequent B<regexec>()  searches."
msgstr ""
"Функция B<regcomp>() используется для компиляции регулярного выражения в "
"формат, который подходит для последующих поисков с помощью B<regexec>()."

#. type: Plain text
#: man-pages/man3/regex.3:65
msgid ""
"B<regcomp>()  is supplied with I<preg>, a pointer to a pattern buffer "
"storage area; I<regex>, a pointer to the null-terminated string and "
"I<cflags>, flags used to determine the type of compilation."
msgstr ""
"B<regcomp>() передаётся указатель на область хранения буферного шаблона I<"
"preg>, указатель на заканчивающуюся null строку I<regex> и флаги I<cflags>, "
"используемые для определения типа компиляции."

#. type: Plain text
#: man-pages/man3/regex.3:72
msgid ""
"All regular expression searching must be done via a compiled pattern buffer,"
" thus B<regexec>()  must always be supplied with the address of a "
"B<regcomp>()  initialized pattern buffer."
msgstr ""
"Все поиски регулярных выражений должны выполняться с помощью "
"скомпилированного буферного шаблона, поэтому B<regexec>() должна всегда "
"вызываться с адресом буферного шаблона, инициализированного функцией B<"
"regcomp>()."

#. type: Plain text
#: man-pages/man3/regex.3:77
msgid "I<cflags> may be the bitwise-B<or> of one or more of the following:"
msgstr ""
"Значение I<cflags> может состоять из поразрядного ИЛИ одного или нескольких "
"следующих значений:"

#. type: TP
#: man-pages/man3/regex.3:77
#, no-wrap
msgid "B<REG_EXTENDED>"
msgstr "B<REG_EXTENDED>"

#. type: Plain text
#: man-pages/man3/regex.3:86
msgid ""
"Use B<POSIX> Extended Regular Expression syntax when interpreting I<regex>."
"  If not set, B<POSIX> Basic Regular Expression syntax is used."
msgstr ""
"Использовать синтаксис расширенных регулярных выражений POSIX во время "
"интерпретации I<regex>. Если не включён этот флаг, то используется синтаксис "
"простых регулярных выражений POSIX."

#. type: TP
#: man-pages/man3/regex.3:86
#, no-wrap
msgid "B<REG_ICASE>"
msgstr "B<REG_ICASE>"

#. type: Plain text
#: man-pages/man3/regex.3:92
msgid ""
"Do not differentiate case.  Subsequent B<regexec>()  searches using this "
"pattern buffer will be case insensitive."
msgstr ""
"Не учитывать регистр. Последующие поиски B<regexec>() с использованием "
"данного буферного шаблона не будут зависеть от регистра."

#. type: TP
#: man-pages/man3/regex.3:92
#, no-wrap
msgid "B<REG_NOSUB>"
msgstr "B<REG_NOSUB>"

#. type: Plain text
#: man-pages/man3/regex.3:102
msgid ""
"Do not report position of matches.  The I<nmatch> and I<pmatch> arguments to"
" B<regexec>()  are ignored if the pattern buffer supplied was compiled with "
"this flag set."
msgstr ""
"Не сообщать положение совпадений. Параметры I<nmatch> и I<pmatch> для B<"
"regexec>() игнорируются, если данный буферный шаблон был скомпилирован с этим "
"включённым флагом."

#. type: TP
#: man-pages/man3/regex.3:102
#, no-wrap
msgid "B<REG_NEWLINE>"
msgstr "B<REG_NEWLINE>"

#. type: Plain text
#: man-pages/man3/regex.3:105
msgid "Match-any-character operators don't match a newline."
msgstr ""
"Операторы совпадения с любым символом не совпадают с символом новой строки."

#. type: Plain text
#: man-pages/man3/regex.3:109
msgid ""
"A nonmatching list (B<[^...]>)  not containing a newline does not match a "
"newline."
msgstr ""
"Список несовпадающих символов (B<[^...]>) без символа новой строки не "
"совпадает с новой строкой."

#. type: Plain text
#: man-pages/man3/regex.3:119
msgid ""
"Match-beginning-of-line operator (B<^>)  matches the empty string "
"immediately after a newline, regardless of whether I<eflags>, the execution "
"flags of B<regexec>(), contains B<REG_NOTBOL>."
msgstr ""
"Оператор сравнения по началу строки (B<^>) совпадает с пустой строкой сразу "
"после новой строки независимо от того, что I<eflags>, флаги выполнения B<"
"regexec>(), содержат B<REG_NOTBOL>."

#. type: Plain text
#: man-pages/man3/regex.3:127
msgid ""
"Match-end-of-line operator (B<$>)  matches the empty string immediately "
"before a newline, regardless of whether I<eflags> contains B<REG_NOTEOL>."
msgstr ""
"Оператор сравнения по концу строки ($) совпадает с пустой строкой до символа "
"начала строки независимо от того, что I<eflags> содержит B<REG_NOTEOL>."

#. type: SS
#: man-pages/man3/regex.3:127
#, no-wrap
msgid "POSIX regex matching"
msgstr "Сравнение с регулярным выражением POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:144
msgid ""
"B<regexec>()  is used to match a null-terminated string against the "
"precompiled pattern buffer, I<preg>.  I<nmatch> and I<pmatch> are used to "
"provide information regarding the location of any matches.  I<eflags> may be"
" the bitwise-B<or> of one or both of B<REG_NOTBOL> and B<REG_NOTEOL> which "
"cause changes in matching behavior described below."
msgstr ""
"Функция B<regexec>() используется для сравнения строки, завершающейся null, с "
"предварительно обработанным буферным шаблоном I<preg>. Аргументы I<nmatch> и "
"I<pmatch> используются для предоставления информации о местонахождении любых "
"совпадений. Значение I<eflags> может быть поразрядным B<ИЛИ> одного или обоих "
"значений B<REG_NOTBOL> и B<REG_NOTEOL>. Данные значения определяют поведение "
"процесса сравнения так, как описано ниже."

#. type: TP
#: man-pages/man3/regex.3:144
#, no-wrap
msgid "B<REG_NOTBOL>"
msgstr "B<REG_NOTBOL>"

#. type: Plain text
#: man-pages/man3/regex.3:154
msgid ""
"The match-beginning-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above).  This flag may be used when "
"different portions of a string are passed to B<regexec>()  and the beginning"
" of the string should not be interpreted as the beginning of the line."
msgstr ""
"Оператор сравнения по началу строки всегда завершается с ошибкой (но смотрите "
"описанный выше флаг компиляции B<REG_NEWLINE>). Этот флаг может "
"использоваться, когда в B<regexec>() передаются отдельные части строки, и "
"начало такой строки в данном случае не должно интерпретироваться как начало "
"новой строки."

#. type: TP
#: man-pages/man3/regex.3:154
#, no-wrap
msgid "B<REG_NOTEOL>"
msgstr "B<REG_NOTEOL>"

#. type: Plain text
#: man-pages/man3/regex.3:160
msgid ""
"The match-end-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)."
msgstr ""
"Оператор сравнения по концу строки всегда завершается с ошибкой (но смотрите "
"описанный выше флаг компиляции B<REG_NEWLINE>)."

#. type: SS
#: man-pages/man3/regex.3:160
#, no-wrap
msgid "Byte offsets"
msgstr "Байтовые смещения"

#. type: Plain text
#: man-pages/man3/regex.3:185
msgid ""
"Unless B<REG_NOSUB> was set for the compilation of the pattern buffer, it is"
" possible to obtain match addressing information.  I<pmatch> must be "
"dimensioned to have at least I<nmatch> elements.  These are filled in by "
"B<regexec>()  with substring match addresses.  The offsets of the "
"subexpression starting at the I<i>th open parenthesis are stored in "
"I<pmatch[i]>.  The entire regular expression's match addresses are stored in"
" I<pmatch[0]>.  (Note that to return the offsets of I<N> subexpression "
"matches, I<nmatch> must be at least I<N+1>.)  Any unused structure elements "
"will contain the value -1."
msgstr ""
"Если B<REG_NOSUB> не установлен при компиляции буферного шаблона, то возможно "
"получать информацию о положении совпадений. Значение I<pmatch> должно быть "
"определено так, чтобы иметь, по крайней мере, I<nmatch> элементов. Они "
"заполняются B<regexec>() адресами внутристрочных совпадений. Смещения "
"подвыражения, начинающегося с I<i>-й открытой скобки, сохраняется в I<"
"pmatch[i]>. Адрес совпадения всего регулярного выражения сохраняется в I<"
"pmatch[0]> (заметим, что чтобы вернуть смещения совпадений I<N> подвыражений, "
"значение I<nmatch> должно быть не менее I<N+1>). Любые неиспользованные "
"элементы структуры будут содержать значение -1."

#. type: Plain text
#: man-pages/man3/regex.3:192
msgid ""
"The I<regmatch_t> structure which is the type of I<pmatch> is defined in "
"I<E<lt>regex.hE<gt>>."
msgstr ""
"Структура I<regmatch_t>, являющаяся типом I<pmatch>, определена в I<E<lt>"
"regex.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/regex.3:199
#, no-wrap
msgid ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"
msgstr ""
"typedef struct {\n    regoff_t rm_so;\n    regoff_t rm_eo;\n} regmatch_t;\n"

#. type: Plain text
#: man-pages/man3/regex.3:210
msgid ""
"Each I<rm_so> element that is not -1 indicates the start offset of the next "
"largest substring match within the string.  The relative I<rm_eo> element "
"indicates the end offset of the match, which is the offset of the first "
"character after the matching text."
msgstr ""
"Каждый элемент I<rm_so>, не равный -1, показывает начальное смещение "
"следующего совпадения наибольшей подстроки внутри заданной строки. "
"Относительный элемент I<rm_eo> указывает на смещение конца совпадения, "
"которое является первым символом после совпавшего текста."

#. type: SS
#: man-pages/man3/regex.3:210
#, no-wrap
msgid "POSIX error reporting"
msgstr "Сообщение об ошибках POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:217
msgid ""
"B<regerror>()  is used to turn the error codes that can be returned by both "
"B<regcomp>()  and B<regexec>()  into error message strings."
msgstr ""
"Функция B<regerror> используется для преобразования кодов ошибок, которые "
"могут быть получены от B<regcomp>() и B<regexec>(), в строки сообщений об "
"ошибках."

#. type: Plain text
#: man-pages/man3/regex.3:239
msgid ""
"B<regerror>()  is passed the error code, I<errcode>, the pattern buffer, "
"I<preg>, a pointer to a character string buffer, I<errbuf>, and the size of "
"the string buffer, I<errbuf_size>.  It returns the size of the I<errbuf> "
"required to contain the null-terminated error message string.  If both "
"I<errbuf> and I<errbuf_size> are nonzero, I<errbuf> is filled in with the "
"first I<errbuf_size - 1> characters of the error message and a terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""
"В B<regerror> передаются: код ошибки I<errcode>, буферный шаблон I<preg>, "
"указатель на символьный буфер строки I<errbuf> и размер буфера строки I<"
"errbuf_size>. Функция возвращает размер I<errbuf>, который требуется для "
"сохранения сообщения об ошибке в виде строки, оканчивающейся null. Если и I<"
"errbuf>, и I<errbuf_size> не равны нулю, то I<errbuf> заполняется первыми I<"
"errbuf_size - 1> символами сообщения об ошибке и завершается байтом null "
"(\\(aq\\e0\\(aq)."

#. type: SS
#: man-pages/man3/regex.3:239
#, no-wrap
msgid "POSIX pattern buffer freeing"
msgstr "Освобождение буфера шаблона POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:247
msgid ""
"Supplying B<regfree>()  with a precompiled pattern buffer, I<preg> will free"
" the memory allocated to the pattern buffer by the compiling process, "
"B<regcomp>()."
msgstr ""
"Функция B<regfree>() освобождает память, отведённую буферному шаблону I<preg> "
"во время процесса компиляции с помощью B<regcomp>()."

#. type: Plain text
#: man-pages/man3/regex.3:250
msgid ""
"B<regcomp>()  returns zero for a successful compilation or an error code for"
" failure."
msgstr ""
"Функция B<regcomp>() возвращает ноль при успешной компиляции или в противном "
"случае код ошибки."

#. type: Plain text
#: man-pages/man3/regex.3:255
msgid ""
"B<regexec>()  returns zero for a successful match or B<REG_NOMATCH> for "
"failure."
msgstr ""
"Функция B<regexec>() возвращает ноль при совпадении или B<REG_NOMATCH>, если "
"совпадений не было."

#. type: Plain text
#: man-pages/man3/regex.3:258
msgid "The following errors can be returned by B<regcomp>():"
msgstr "Функция B<regcomp>() может возвращать следующие ошибки:"

#. type: TP
#: man-pages/man3/regex.3:258
#, no-wrap
msgid "B<REG_BADBR>"
msgstr "B<REG_BADBR>"

#. type: Plain text
#: man-pages/man3/regex.3:261
msgid "Invalid use of back reference operator."
msgstr "Неправильное использование оператора обратных ссылок."

#. type: TP
#: man-pages/man3/regex.3:261
#, no-wrap
msgid "B<REG_BADPAT>"
msgstr "B<REG_BADPAT>"

#. type: Plain text
#: man-pages/man3/regex.3:264
msgid "Invalid use of pattern operators such as group or list."
msgstr ""
"Неправильное использование операторов шаблона, таких, как операторы группы "
"или списка."

#. type: TP
#: man-pages/man3/regex.3:264
#, no-wrap
msgid "B<REG_BADRPT>"
msgstr "B<REG_BADRPT>"

#. type: Plain text
#: man-pages/man3/regex.3:268
msgid ""
"Invalid use of repetition operators such as using \\(aq*\\(aq as the first "
"character."
msgstr ""
"Неправильное использование операторов повторения, например, использование «*» "
"в качестве первого символа."

#. type: TP
#: man-pages/man3/regex.3:268
#, no-wrap
msgid "B<REG_EBRACE>"
msgstr "B<REG_EBRACE>"

#. type: Plain text
#: man-pages/man3/regex.3:271
msgid "Un-matched brace interval operators."
msgstr "Непарные скобки в операторах интервала."

#. type: TP
#: man-pages/man3/regex.3:271
#, no-wrap
msgid "B<REG_EBRACK>"
msgstr "B<REG_EBRACK>"

#. type: Plain text
#: man-pages/man3/regex.3:274
msgid "Un-matched bracket list operators."
msgstr "Непарные квадратные скобки в операторах списка."

#. type: TP
#: man-pages/man3/regex.3:274
#, no-wrap
msgid "B<REG_ECOLLATE>"
msgstr "B<REG_ECOLLATE>"

#. type: Plain text
#: man-pages/man3/regex.3:277
msgid "Invalid collating element."
msgstr "Неправильный элемент сортировки."

#. type: TP
#: man-pages/man3/regex.3:277
#, no-wrap
msgid "B<REG_ECTYPE>"
msgstr "B<REG_ECTYPE>"

#. type: Plain text
#: man-pages/man3/regex.3:280
msgid "Unknown character class name."
msgstr "Неизвестное имя класса символов."

#. type: TP
#: man-pages/man3/regex.3:280
#, no-wrap
msgid "B<REG_EEND>"
msgstr "B<REG_EEND>"

#. type: Plain text
#: man-pages/man3/regex.3:284
msgid "Nonspecific error.  This is not defined by POSIX.2."
msgstr "Потенциальная ошибка. Не определена в POSIX.2."

#. type: TP
#: man-pages/man3/regex.3:284
#, no-wrap
msgid "B<REG_EESCAPE>"
msgstr "B<REG_EESCAPE>"

#. type: Plain text
#: man-pages/man3/regex.3:287
msgid "Trailing backslash."
msgstr "Конечная обратная косая черта."

#. type: TP
#: man-pages/man3/regex.3:287
#, no-wrap
msgid "B<REG_EPAREN>"
msgstr "B<REG_EPAREN>"

#. type: Plain text
#: man-pages/man3/regex.3:290
msgid "Un-matched parenthesis group operators."
msgstr "Непарные круглые скобки в операторах группировки."

#. type: TP
#: man-pages/man3/regex.3:290
#, no-wrap
msgid "B<REG_ERANGE>"
msgstr "B<REG_ERANGE>"

#. type: Plain text
#: man-pages/man3/regex.3:294
msgid ""
"Invalid use of the range operator; for example, the ending point of the "
"range occurs prior to the starting point."
msgstr ""
"Неправильное использование оператора области: например, конец области "
"появляется прежде её начала."

#. type: TP
#: man-pages/man3/regex.3:294
#, no-wrap
msgid "B<REG_ESIZE>"
msgstr "B<REG_ESIZE>"

#. type: Plain text
#: man-pages/man3/regex.3:298
msgid ""
"Compiled regular expression requires a pattern buffer larger than 64Kb.  "
"This is not defined by POSIX.2."
msgstr ""
"Скомпилированное регулярное выражение требует буферный шаблон размером, "
"большим 64 Кб. Это не определено в POSIX.2."

#. type: TP
#: man-pages/man3/regex.3:298
#, no-wrap
msgid "B<REG_ESPACE>"
msgstr "B<REG_ESPACE>"

#. type: Plain text
#: man-pages/man3/regex.3:301
msgid "The regex routines ran out of memory."
msgstr "Для процедур регулярных выражений закончилась память."

#. type: TP
#: man-pages/man3/regex.3:301
#, no-wrap
msgid "B<REG_ESUBREG>"
msgstr "B<REG_ESUBREG>"

#. type: Plain text
#: man-pages/man3/regex.3:304
msgid "Invalid back reference to a subexpression."
msgstr "Неправильная обратная ссылка на подвыражение."

#. type: Plain text
#: man-pages/man3/regex.3:306
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/regex.3:309
msgid "B<grep>(1), B<regex>(7)"
msgstr "B<grep>(1), B<regex>(7)"

#. type: Plain text
#: man-pages/man3/regex.3:311
msgid "The glibc manual section, I<Regular Expression Matching>"
msgstr "Раздел руководства glibc I<Regular Expression Matching>"

#. type: TH
#: man-pages/man3/resolver.3:32
#, no-wrap
msgid "RESOLVER"
msgstr "RESOLVER"

#. type: Plain text
#: man-pages/man3/resolver.3:36
msgid ""
"res_init, res_query, res_search, res_querydomain, res_mkquery, res_send, "
"dn_comp, dn_expand - resolver routines"
msgstr ""
"res_init, res_query, res_search, res_querydomain, res_mkquery, res_send, "
"dn_comp, dn_expand - процедуры определителя имён"

#. type: Plain text
#: man-pages/man3/resolver.3:42
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
"B<extern struct __res_state _res;>\n"
msgstr ""
"B<#include E<lt>netinet/in.hE<gt>>\nB<#include E<lt>arpa/nameser.hE<gt>>\nB<"
"#include E<lt>resolv.hE<gt>>\nB<extern struct __res_state _res;>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:44
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr "B<int res_init(void);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:46
#, no-wrap
msgid ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
msgstr ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:48 man-pages/man3/resolver.3:53
#: man-pages/man3/resolver.3:70
#, no-wrap
msgid "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:51
#, no-wrap
msgid ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int "
">I<type>B<,>\n"
msgstr ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:56
#, no-wrap
msgid ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
msgstr ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:59
#, no-wrap
msgid ""
"B<int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<int >I<anslen>B<);>\n"
msgstr ""
"B<int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\nB<int >I<"
"anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:62
#, no-wrap
msgid ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
msgstr ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:65
#, no-wrap
msgid ""
"B<int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<const unsigned char *>I<newrr>B<, unsigned char *>I<buf>B<, int >I<buflen>"
"B<);>\n"
msgstr ""
"B<int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\nB<"
"const unsigned char *>I<newrr>B<, unsigned char *>I<buf>B<, int >I<buflen>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:68
#, no-wrap
msgid "B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
msgstr "B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:73
#, no-wrap
msgid ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
msgstr ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:75
#, no-wrap
msgid ""
"B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char "
"**>I<lastdnptr>B<);>\n"
msgstr ""
"B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char **>I<"
"lastdnptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:78
#, no-wrap
msgid ""
"B<int dn_expand(const unsigned char *>I<msg>B<, const unsigned char "
"*>I<eomorig>B<,>\n"
msgstr ""
"B<int dn_expand(const unsigned char *>I<msg>B<, const unsigned char *>I<"
"eomorig>B<,>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:81
#, no-wrap
msgid ""
"B<const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<int >I<length>B<);>\n"
msgstr ""
"B<const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\nB<int >I<length>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:85
msgid "Link with I<-lresolv>."
msgstr "Компонуется при указании параметра I<-lresolv>."

#. type: Plain text
#: man-pages/man3/resolver.3:88
msgid ""
"These functions make queries to and interpret the responses from Internet "
"domain name servers."
msgstr ""
"Эти функции выполняют запросы и обрабатывают ответы, полученные от серверов "
"доменных имён Интернет."

#. type: Plain text
#: man-pages/man3/resolver.3:102
msgid ""
"The B<res_init>()  function reads the configuration files (see "
"B<resolv.conf>(5))  to get the default domain name, search order and name "
"server address(es).  If no server is given, the local host is tried.  If no "
"domain is given, that associated with the local host is used.  It can be "
"overridden with the environment variable B<LOCALDOMAIN>.  B<res_init>()  is "
"normally executed by the first call to one of the other functions."
msgstr ""
"Функция B<res_init>() считывает файлы настройки (смотрите B<resolv.conf>(5)) "
"для получения имени домена по умолчанию, порядка поиска и адреса(-ов) "
"серверов имён. Если серверы не заданы, то используется локальный узел. Если "
"не задан домен, то используется домен локального узла. Это может быть "
"изменено через переменную окружения B<LOCALDOMAIN>. Обычно, функция B<"
"res_init>() выполняется из первого вызова одной из других функций."

#. type: Plain text
#: man-pages/man3/resolver.3:110
msgid ""
"The B<res_query>()  function queries the name server for the fully qualified"
" domain name I<name> of specified I<type> and I<class>.  The reply is left "
"in the buffer I<answer> of length I<anslen> supplied by the caller."
msgstr ""
"Функция B<res_query>() запрашивает у сервера имён полное доменное имя I<name> "
"заданного типа I<type> и класса I<class>. Ответ помещается в буфер I<answer> "
"длиной I<anslen>, указанный вызывающим."

#. type: Plain text
#: man-pages/man3/resolver.3:123
msgid ""
"The B<res_search>()  function makes a query and waits for the response like "
"B<res_query>(), but in addition implements the default and search rules "
"controlled by B<RES_DEFNAMES> and B<RES_DNSRCH> (see description of I<_res> "
"options below)."
msgstr ""
"Функция B<res_search>() отправляет запрос и ждёт ответа, как и B<res_query>"
"(), но при этом ещё учитывает правила работы и поиска по умолчанию, "
"настраиваемые через B<RES_DEFNAMES> и B<RES_DNSRCH> (смотрите ниже описание "
"параметров I<_res>)."

#. type: Plain text
#: man-pages/man3/resolver.3:129
msgid ""
"The B<res_querydomain>()  function makes a query using B<res_query>()  on "
"the concatenation of I<name> and I<domain>."
msgstr ""
"Функция B<res_querydomain>() отправляет запрос с помощью B<res_query>() для "
"объединения имён I<name> и I<domain>."

#. type: Plain text
#: man-pages/man3/resolver.3:132
msgid ""
"The following functions are lower-level routines used by B<res_query>()."
msgstr ""
"Следующие функции являются процедурами низкого уровня, которые используются "
"B<res_query>()."

#. type: Plain text
#: man-pages/man3/resolver.3:143
msgid ""
"The B<res_mkquery>()  function constructs a query message in I<buf> of "
"length I<buflen> for the domain name I<dname>.  The query type I<op> is "
"usually B<QUERY>, but can be any of the types defined in "
"I<E<lt>arpa/nameser.hE<gt>>.  I<newrr> is currently unused."
msgstr ""
"Функция B<res_mkquery>() создаёт сообщение-запрос в I<buf> длиной I<buflen> "
"для имени домена I<dname>. Тип I<op> запроса обычно равен B<QUERY>, но может "
"содержать значение любого типа, которые определены в I<E<lt>arpa/nameser.hE<"
"gt>>. В данный момент I<newrr> не используется."

#. type: Plain text
#: man-pages/man3/resolver.3:153
msgid ""
"The B<res_send>()  function sends a preformatted query given in I<msg> of "
"length I<msglen> and returns the answer in I<answer> which is of length "
"I<anslen>.  It will call B<res_init>(), if it has not already been called."
msgstr ""
"Функция B<res_send>() посылает заранее созданный запрос, указанный в I<msg> "
"длиной I<msglen>, и возвращает ответ в I<answer> длиной I<anslen>. Вызывает "
"функцию B<res_init>(), если этого ещё не было."

#. type: Plain text
#: man-pages/man3/resolver.3:166
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""
"Функция B<dn_comp>() сжимает имя домена I<exp_dn> и сохраняет его в буфере I<"
"comp_dn> длиной I<length>. Сжатие использует массив указателей I<dnptrs> на "
"предварительно сжатые имена в текущем сообщении. Первый указатель обозначает "
"начало сообщения, а весь список оканчивается NULL. Предел массива "
"определяется в I<lastdnptr>. Если I<dnptr> равно NULL, то имя домена не "
"является сжатым. Если I<lastdnptr> равно NULL, то список меток не обновляется."

#. type: Plain text
#: man-pages/man3/resolver.3:175
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""
"Функция B<dn_expand>() раскрывает сжатое имя домена I<comp_dn> до полного "
"доменного имени, которое затем сохраняется в буфере I<exp_dn> длиной I<length>"
". Сжатое имя содержится в запросе или ответном сообщении, а I<msg> указывает "
"на начало сообщения."

#. type: Plain text
#: man-pages/man3/resolver.3:183
msgid ""
"The resolver routines use global configuration and state information "
"contained in the structure I<_res>, which is defined in "
"I<E<lt>resolv.hE<gt>>.  The only field that is normally manipulated by the "
"user is I<_res.options>.  This field can contain the bitwise \"OR\" of the "
"following options:"
msgstr ""
"Функции определения имени используют общие настройки и информацию о "
"состоянии, содержащиеся в структуре I<_res>, которая определена в I<E<lt>"
"resolv.hE<gt>>. Единственным полем, с которым, обычно, работает пользователь, "
"является I<_res.options>. Это поле содержит поразрядное ИЛИ следующих "
"параметров:"

#. type: TP
#: man-pages/man3/resolver.3:183
#, no-wrap
msgid "B<RES_INIT>"
msgstr "B<RES_INIT>"

#. type: Plain text
#: man-pages/man3/resolver.3:188
msgid "True if B<res_init>()  has been called."
msgstr "Истинно, если уже вызывалась B<res_init>()."

#. type: TP
#: man-pages/man3/resolver.3:188
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr "B<RES_DEBUG>"

#.  See resolv/README.
#.  Support for RES_DEBUG was made conditional in glibc 2.2.
#. type: Plain text
#: man-pages/man3/resolver.3:195
msgid ""
"Print debugging messages.  This option is available only if glibc was built "
"with debugging enabled, which is not the default."
msgstr ""
"Печатать отладочные сообщения. Этот параметр доступен только, если glibc "
"собрана с включённой отладкой, которая по умолчанию выключена."

#. type: TP
#: man-pages/man3/resolver.3:195
#, no-wrap
msgid "B<RES_AAONLY>"
msgstr "B<RES_AAONLY>"

#. type: Plain text
#: man-pages/man3/resolver.3:202
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  [Not currently implemented]."
msgstr ""
"Принимать только авторизованные ответы. Функция B<res_send>() продолжает "
"работу, пока не найдет авторизованный ответ, или возвращает ошибку (в данный "
"момент не реализовано)."

#. type: TP
#: man-pages/man3/resolver.3:202
#, no-wrap
msgid "B<RES_USEVC>"
msgstr "B<RES_USEVC>"

#. type: Plain text
#: man-pages/man3/resolver.3:205
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr "использовать TCP-соединение для запросов вместо датаграмм UDP."

#. type: TP
#: man-pages/man3/resolver.3:205
#, no-wrap
msgid "B<RES_PRIMARY>"
msgstr "B<RES_PRIMARY>"

#. type: Plain text
#: man-pages/man3/resolver.3:208
msgid "Query primary domain name server only."
msgstr "Запрашивать только первичный сервер доменных имён."

#. type: TP
#: man-pages/man3/resolver.3:208
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr "B<RES_IGNTC>"

#. type: Plain text
#: man-pages/man3/resolver.3:213
msgid ""
"Ignore truncation errors.  Don't retry with TCP.  [Not currently "
"implemented]."
msgstr ""
"Игнорировать ошибки обрезания. Не пытаться повторить запрос с помощью TCP (в "
"данный момент не реализовано)."

#. type: TP
#: man-pages/man3/resolver.3:213
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr "B<RES_RECURSE>"

#. type: Plain text
#: man-pages/man3/resolver.3:220
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""
"Установить в запросах бит рекурсии. Рекурсия выполняется сервером доменных "
"имён, а не функцией B<res_send>() (включено по умолчанию)."

#. type: TP
#: man-pages/man3/resolver.3:220
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr "B<RES_DEFNAMES>"

#. type: Plain text
#: man-pages/man3/resolver.3:227
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names\\(emthat is, those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""
"Если указан, то B<res_search>() будет добавлять имя домена по умолчанию к "
"именам с одним компонентом в имени (не содержащим точек) (включено по "
"умолчанию)."

#. type: TP
#: man-pages/man3/resolver.3:227
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr "B<RES_STAYOPEN>"

#. type: Plain text
#: man-pages/man3/resolver.3:232
msgid "Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr ""
"Используется вместе с B<RES_USEVC> для поддержания TCP-соединения запросов "
"между ответами."

#. type: TP
#: man-pages/man3/resolver.3:232
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr "B<RES_DNSRCH>"

#. type: Plain text
#: man-pages/man3/resolver.3:241
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and"
" in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled "
"by default]."
msgstr ""
"Если указан, то B<res_search>() будет искать имена узлов в текущем и "
"родительском домене. Этот параметр используется B<gethostbyname>(3) (включено "
"по умолчанию)."

#. type: Plain text
#: man-pages/man3/resolver.3:245
msgid ""
"This list is not complete.  You can find some other flags described in "
"B<resolv.conf>(5)."
msgstr ""
"Данный список не полон. Вы можете найти другие параметры в B<resolv.conf>(5)."

#. type: Plain text
#: man-pages/man3/resolver.3:250
msgid ""
"The B<res_init>()  function returns 0 on success, or -1 if an error occurs."
msgstr ""
"При успешном выполнении функция B<res_init>() возвращает 0, а при ошибках "
"возвращает -1."

#. type: Plain text
#: man-pages/man3/resolver.3:260
msgid ""
"The B<res_query>(), B<res_search>(), B<res_querydomain>(), B<res_mkquery>()"
"  and B<res_send>()  functions return the length of the response, or -1 if "
"an error occurs."
msgstr ""
"Функции B<res_query>(), B<res_search>(), B<res_querydomain>(), B<res_mkquery>"
"()  и B<res_send>() возвращают длину ответа или -1 при ошибках."

#. type: Plain text
#: man-pages/man3/resolver.3:267
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""
"Функции B<dn_comp>() и B<dn_expand>() возвращают длину сжатого имени, или -1 "
"при ошибках."

#. type: Plain text
#: man-pages/man3/resolver.3:271
#, no-wrap
msgid ""
"/etc/resolv.conf          resolver configuration file\n"
"/etc/host.conf            resolver configuration file\n"
msgstr ""
"/etc/resolv.conf          файл настройки определителя имён\n/etc/host.conf    "
"        файл настройки определителя имён\n"

#. type: Plain text
#: man-pages/man3/resolver.3:274
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: man-pages/man3/resolver.3:279
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), B<"
"named>(8)"

#. type: TH
#: man-pages/man3/rpmatch.3:29
#, no-wrap
msgid "RPMATCH"
msgstr "RPMATCH"

#. type: TH
#: man-pages/man3/rpmatch.3:29
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: man-pages/man3/rpmatch.3:32
msgid ""
"rpmatch - determine if the answer to a question is affirmative or negative"
msgstr ""
"rpmatch - определяет, является ли ответ на вопрос утвердительным или "
"отрицательным"

#. type: Plain text
#: man-pages/man3/rpmatch.3:37
#, no-wrap
msgid "B<int rpmatch(const char *>I<response>B<);>\n"
msgstr "B<int rpmatch(const char *>I<response>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:46
msgid "B<rpmatch>(): _SVID_SOURCE"
msgstr "B<rpmatch>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/rpmatch.3:50
msgid ""
"B<rpmatch>()  handles a user response to yes or no questions, with support "
"for internationalization."
msgstr ""
"Функция B<rpmatch>() обрабатывает ответ пользователя «да» или «нет» на "
"вопросы, учитывая интернационализацию."

#. type: Plain text
#: man-pages/man3/rpmatch.3:57
msgid ""
"I<response> should be a null-terminated string containing a user-supplied "
"response, perhaps obtained with B<fgets>(3)  or B<getline>(3)."
msgstr ""
"В аргументе I<response> должен указываться ответ пользователя в виде строки, "
"заканчивающейся null, полученной, например, с помощью B<fgets>(3) или B<"
"getline>(3)."

#. type: Plain text
#: man-pages/man3/rpmatch.3:67
msgid ""
"The user's language preference is taken into account per the environment "
"variables B<LANG>, B<LC_MESSAGES>, and B<LC_ALL>, if the program has called "
"B<setlocale>(3)  to effect their changes."
msgstr ""
"Пользовательские языковые настройки определяются с помощью переменных "
"окружения B<LANG>, B<LC_MESSAGES> и B<LC_ALL>, если для их учёта программа "
"вызывала B<setlocale>(3)."

#. type: Plain text
#: man-pages/man3/rpmatch.3:73
msgid ""
"Regardless of the locale, responses matching B<^[Yy]> are always accepted as"
" affirmative, and those matching B<^[Nn]> are always accepted as negative."
msgstr ""
"Вне зависимости от локали, ответы, соответствующие B<^[Yy]>, всегда считаются "
"утвердительными, а соответствующие B<^[Nn]>, всегда принимаются за "
"отрицательные."

#. type: Plain text
#: man-pages/man3/rpmatch.3:82
msgid ""
"After examining I<response>, B<rpmatch>()  returns 0 for a recognized "
"negative response (\"no\"), 1 for a recognized positive response (\"yes\"), "
"and -1 when the value of I<response> is unrecognized."
msgstr ""
"После проверки I<response>, функция B<rpmatch>() возвращает 0 при найденном "
"отрицательном ответе («нет»), 1 при положительном ответе («да») и -1, когда "
"значение I<response> не распознано."

#. type: Plain text
#: man-pages/man3/rpmatch.3:86
msgid ""
"A return value of -1 may indicate either an invalid input, or some other "
"error.  It is incorrect to only test if the return value is nonzero."
msgstr ""
"Возвращаемое значение -1 может указывать на неправильные входные данные, либо "
"какую-то другую ошибку. Не стоит проверять является ли возвращаемое значение "
"лишь отличным от нуля."

#. type: Plain text
#: man-pages/man3/rpmatch.3:99
msgid ""
"B<rpmatch>()  can fail for any of the reasons that B<regcomp>(3)  or "
"B<regexec>(3)  can fail; the cause of the error is not available from "
"I<errno> or anywhere else, but indicates a failure of the regex engine (but "
"this case is indistinguishable from that of an unrecognized value of "
"I<response>)."
msgstr ""
"Функция B<rpmatch>() может завершиться с ошибкой по любой из причин, по "
"которым могут не выполниться B<regcomp>(3) или B<regexec>(3); причина ошибки "
"не указывается в I<errno> или где-то ещё — это указывает на ошибку в самом "
"механизме regex (но этот случай не отличается от нераспознанных значений I<"
"response>)."

#.  It is available on at least AIX 5.1 and FreeBSD 6.0.
#. type: Plain text
#: man-pages/man3/rpmatch.3:104
msgid ""
"B<rpmatch>()  is not required by any standard, but is available on a few "
"other systems."
msgstr ""
"Функция B<rpmatch>() не является стандартной, но доступна в некоторых других "
"системах."

#. type: Plain text
#: man-pages/man3/rpmatch.3:119
msgid ""
"The B<rpmatch>()  implementation looks at only the first character of "
"I<response>.  As a consequence, \"nyes\" returns 0, and \"ynever; not in a "
"million years\" returns 1.  It would be preferable to accept input strings "
"much more strictly, for example (using the extended regular expression "
"notation described in B<regex>(7)): B<^([yY]|yes|YES)$> and "
"B<^([nN]|no|NO)$>."
msgstr ""
"Реализация B<rpmatch>() учитывает лишь первый символ I<response>. Так что, "
"«ну, да.» вернёт 0, а «да нет же, ни за что!» вернёт 1. Правильнее было бы "
"использовать расширенные правила для обработки входных строк (использования "
"дополненных регулярных выражений описано в B<regex>(7)): B<^([yY]|yes|YES)$> "
"и B<^([nN]|no|NO)$>."

#. type: Plain text
#: man-pages/man3/rpmatch.3:123
msgid ""
"The following program displays the results when B<rpmatch>()  is applied to "
"the string given in the program's command-line argument."
msgstr ""
"Следующая программа показывает результаты, когда в B<rpmatch>() передана "
"строка, полученная программой из командной строки."

#. type: Plain text
#: man-pages/man3/rpmatch.3:130
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"#include E<lt>locale.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _SVID_SOURCE\n#include E<lt>locale.hE<gt>\n#include E<lt>stdlib.hE<gt>"
"\n#include E<lt>string.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:138
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s response\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    if (argc != 2 || strcmp(argv[1], "
"\"--help\") == 0) {\n        fprintf(stderr, \"%s response\\en\", argv[0]);\n "
"       exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:143
#, no-wrap
msgid ""
"    setlocale(LC_ALL, \"\");\n"
"    printf(\"rpmatch() returns: %d\\en\", rpmatch(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    setlocale(LC_ALL, \"\");\n    printf(\"rpmatch() returns: %d\\en\", "
"rpmatch(argv[1]));\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:149
msgid ""
"B<fgets>(3), B<getline>(3), B<nl_langinfo>(3), B<regcomp>(3), "
"B<setlocale>(3)"
msgstr ""
"B<fgets>(3), B<getline>(3), B<nl_langinfo>(3), B<regcomp>(3), B<setlocale>(3)"

#. type: TH
#: man-pages/man3/remquo.3:12
#, no-wrap
msgid "REMQUO"
msgstr "REMQUO"

#. type: Plain text
#: man-pages/man3/remquo.3:15
msgid "remquo, remquof, remquol - remainder and part of quotient"
msgstr "remquo, remquof, remquol - остаток и неполное частное"

#. type: Plain text
#: man-pages/man3/remquo.3:20
#, no-wrap
msgid "B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"
msgstr "B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"

#. type: Plain text
#: man-pages/man3/remquo.3:22
#, no-wrap
msgid "B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"
msgstr "B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"

#. type: Plain text
#: man-pages/man3/remquo.3:24
#, no-wrap
msgid ""
"B<long double remquol(long double >I<x>B<, long double >I<y>B<, int "
"*>I<quo>B<);>\n"
msgstr ""
"B<long double remquol(long double >I<x>B<, long double >I<y>B<, int *>I<quo>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/remquo.3:37
msgid "B<remquo>(), B<remquof>(), B<remquol>():"
msgstr "B<remquo>(), B<remquof>(), B<remquol>():"

#. type: Plain text
#: man-pages/man3/remquo.3:55
msgid ""
"These functions compute the remainder and part of the quotient upon division"
" of I<x> by I<y>.  A few bits of the quotient are stored via the I<quo> "
"pointer.  The remainder is returned as the function result."
msgstr ""
"Эти функции вычисляют остаток и неполное частное при делении I<x> на I<y>. "
"Неполное частное сохраняется через указатель I<quo>. Остаток возвращается как "
"результат функции."

#. type: Plain text
#: man-pages/man3/remquo.3:59
msgid ""
"The value of the remainder is the same as that computed by the "
"B<remainder>(3)  function."
msgstr "Значение остатка тоже, что и при вычислении функцией B<remainder>(3)."

#. type: Plain text
#: man-pages/man3/remquo.3:65
msgid ""
"The value stored via the I<quo> pointer has the sign of I<x\\ /\\ y> and "
"agrees with the quotient in at least the low order 3 bits."
msgstr ""
"Значение, сохраняемое по указателю I<quo>, имеет знак I<x\\ /\\ y> и "
"сохраняет от частного не менее 3 младших бит."

#.  A possible application of this function might be the computation
#.  of sin(x). Compute remquo(x, pi/2, &quo) or so.
#.  glibc, UnixWare: return 3 bits
#.  MacOS 10: return 7 bits
#. type: Plain text
#: man-pages/man3/remquo.3:73
msgid ""
"For example, I<remquo(29.0,\\ 3.0)> returns -1.0 and might store 2.  Note "
"that the actual quotient might not fit in an integer."
msgstr ""
"Например, I<remquo(29.0,\\ 3.0)> возвращает -1.0 и может сохранить 2. "
"Заметим, что реальный остаток может не поместиться в integer."

#. type: Plain text
#: man-pages/man3/remquo.3:77
msgid ""
"On success, these functions return the same value as the analogous functions"
" described in B<remainder>(3)."
msgstr ""
"При успешном выполнении данные функции возвращают тоже значение, что и "
"аналогичные функции, описанные в B<remainder>(3)."

#. type: Plain text
#: man-pages/man3/remquo.3:83
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr "Если значение I<x> или I<y> равно NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/remquo.3:92
msgid ""
"If I<x> is an infinity, and I<y> is not a NaN, a domain error occurs, and a "
"NaN is returned."
msgstr ""
"Если I<x> стремится к бесконечности и I<y> не равно NaN, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата будет "
"возвращено NaN."

#. type: Plain text
#: man-pages/man3/remquo.3:101
msgid ""
"If I<y> is zero, and I<x> is not a NaN, a domain error occurs, and a NaN is "
"returned."
msgstr ""
"Если I<y> равно 0 и I<x> не равно NaN, то будет сгенерирована ошибка выхода "
"за пределы области, а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/remquo.3:106
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить возникшую ошибку при вызове этих "
"функций."

#. type: Plain text
#: man-pages/man3/remquo.3:108
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/remquo.3:108
#, no-wrap
msgid ""
"Domain error: I<x> is an infinity or I<y> is 0, and the other argument is "
"not a NaN"
msgstr ""
"Ошибка области: I<x> стремится к бесконечности или I<y> равно 0, и другой "
"аргумент не равен NaN."

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/remquo.3:117
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "Возникает исключение неправильной плавающей запятой (B<FE_INVALID>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6802
#. type: Plain text
#: man-pages/man3/remquo.3:122
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: Plain text
#: man-pages/man3/remquo.3:132
msgid ""
"The B<remquo>(), B<remquof>(), and B<remquol>()  functions are thread-safe."
msgstr ""
"Функции B<remquo>(), B<remquof>() и B<remquol>() можно использовать в "
"нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/remquo.3:137
msgid "B<fmod>(3), B<logb>(3), B<remainder>(3)"
msgstr "B<fmod>(3), B<logb>(3), B<remainder>(3)"

#. type: TH
#: man-pages/man3/remainder.3:37
#, no-wrap
msgid "REMAINDER"
msgstr "REMAINDER"

#. type: TH
#: man-pages/man3/remainder.3:37
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: man-pages/man3/remainder.3:41
msgid ""
"drem, dremf, dreml, remainder, remainderf, remainderl - floating-point "
"remainder function"
msgstr ""
"drem, dremf, dreml, remainder, remainderf, remainderl - функция получения "
"остатка от деления числа с плавающей запятой"

#. type: Plain text
#: man-pages/man3/remainder.3:49
#, no-wrap
msgid ""
"/* The C99 versions */\n"
"B<double remainder(double >I<x>B<, double >I<y>B<);>\n"
"B<float remainderf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double remainderl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"/* Версии C99 */\nB<double remainder(double >I<x>B<, double >I<y>B<);>\nB<"
"float remainderf(float >I<x>B<, float >I<y>B<);>\nB<long double "
"remainderl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/remainder.3:54
#, no-wrap
msgid ""
"/* Obsolete synonyms */\n"
"B<double drem(double >I<x>B<, double >I<y>B<);>\n"
"B<float dremf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double dreml(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"/* Устаревшие синонимы */\nB<double drem(double >I<x>B<, double >I<y>B<);>"
"\nB<float dremf(float >I<x>B<, float >I<y>B<);>\nB<long double dreml(long "
"double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/remainder.3:65
msgid "B<remainder>():"
msgstr "B<remainder>():"

#. type: Plain text
#: man-pages/man3/remainder.3:70
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/remainder.3:77
msgid "B<remainderf>(), B<remainderl>():"
msgstr "B<remainderf>(), B<remainderl>():"

#. type: Plain text
#: man-pages/man3/remainder.3:80
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE "
"|| _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/remainder.3:88
msgid "B<drem>(), B<dremf>(), B<dreml>():"
msgstr "B<drem>(), B<dremf>(), B<dreml>():"

#. type: Plain text
#: man-pages/man3/remainder.3:90
msgid "_SVID_SOURCE || _BSD_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/remainder.3:111
msgid ""
"The B<remainder>()  function computes the remainder of dividing I<x> by "
"I<y>.  The return value is I<x>-I<n>*I<y>, where I<n> is the value I<x\\ /\\"
" y>, rounded to the nearest integer.  If the absolute value of "
"I<x>-I<n>*I<y> is 0.5, I<n> is chosen to be even."
msgstr ""
"Функция B<remainder>() вычисляет остаток от деления I<x> на I<y>. "
"Возвращаемое значение равно I<x>-I<n>*I<y>, где I<n> равно значению I<x\\ /\\ "
"y>, округлённому до ближайшего целого. Если абсолютное значение I<x>-I<n>*I<y>"
" равно 0.5, то I<n> выбирается целым."

#. type: Plain text
#: man-pages/man3/remainder.3:114
msgid ""
"These functions are unaffected by the current rounding mode (see "
"B<fenv>(3))."
msgstr ""
"Эти функции не подвержены действующему режиму округления (смотрите B<fenv>"
"(3))."

#. type: Plain text
#: man-pages/man3/remainder.3:118
msgid "The B<drem>()  function does precisely the same thing."
msgstr "Функция B<drem>() выполняет тоже самое."

#. type: Plain text
#: man-pages/man3/remainder.3:124
msgid ""
"On success, these functions return the floating-point remainder, "
"I<x>-I<n>*I<y>.  If the return value is 0, it has the sign of I<x>."
msgstr ""
"При успешном выполнении данные функции возвращают остаток I<x>-I<n>*I<y> в "
"виде значения с плавающей запятой. Если возвращаемое значение равно 0, то оно "
"имеет знак I<x>."

#. type: TP
#: man-pages/man3/remainder.3:157
#, no-wrap
msgid "Domain error: I<x> is an infinity and I<y> is not a NaN"
msgstr "Ошибка области: I<x> стремится к бесконечности, а I<y> не равно NaN"

#.  FIXME . Is it intentional that these functions do not set errno?
#.  They do set errno for the y == 0 case, below.
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6783
#. type: Plain text
#: man-pages/man3/remainder.3:172
msgid "These functions do not set I<errno> for this case."
msgstr "В этом случае функции не изменяют I<errno>."

#.  [XXX see bug above] and \fIx\fP is not a NaN
#. type: TP
#: man-pages/man3/remainder.3:172
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr "Ошибка области: I<y> равно 0"

#. type: Plain text
#: man-pages/man3/remainder.3:180
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<EDOM>. Возникает исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#.  IEC 60559.
#. type: Plain text
#: man-pages/man3/remainder.3:188
msgid ""
"The functions B<remainder>(), B<remainderf>(), and B<remainderl>()  are "
"specified in C99 and POSIX.1-2001."
msgstr ""
"Функции B<remainder>(), B<remainderf>() и B<remainderl>() определены в C99 и "
"POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/remainder.3:204
msgid ""
"The function B<drem>()  is from 4.3BSD.  The I<float> and I<long double> "
"variants B<dremf>()  and B<dreml>()  exist on some systems, such as Tru64 "
"and glibc2.  Avoid the use of these functions in favor of B<remainder>()  "
"etc."
msgstr ""
"Функция B<drem>() появилась из 4.3BSD. Варианты функций B<dremf>() и B<dreml>"
"() с типами I<float> и I<long double> есть в некоторых системах, таких как "
"Tru64 и glibc2. Не используйте эти функции вместо B<remainder>() и ей "
"подобным."

#. type: Plain text
#: man-pages/man3/remainder.3:206
msgid "The call"
msgstr "Вызов"

#. type: Plain text
#: man-pages/man3/remainder.3:208
#, no-wrap
msgid "    remainder(nan(\"\"), 0);\n"
msgstr "    remainder(nan(\"\"), 0);\n"

#.  FIXME . this bug occurs as at glibc 2.8.
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6779
#. type: Plain text
#: man-pages/man3/remainder.3:213
msgid ""
"returns a NaN, as expected, but wrongly causes a domain error; it should "
"yield a silent NaN."
msgstr ""
"возвращает NaN, как и ожидается, но некорректно приводит к ошибке области; на "
"самом деле, просто должно возвращаться NaN."

#. type: Plain text
#: man-pages/man3/remainder.3:215
msgid "The call \"remainder(29.0, 3.0)\" returns -1."
msgstr "Вызов «remainder(29.0, 3.0)» возвращает -1."

#. type: Plain text
#: man-pages/man3/remainder.3:218
msgid "B<div>(3), B<fmod>(3), B<remquo>(3)"
msgstr "B<div>(3), B<fmod>(3), B<remquo>(3)"

#. type: TH
#: man-pages/man3/random_r.3:26
#, no-wrap
msgid "RANDOM_R"
msgstr "RANDOM_R"

#. type: Plain text
#: man-pages/man3/random_r.3:30
msgid ""
"random_r, srandom_r, initstate_r, setstate_r - reentrant random number "
"generator"
msgstr ""
"random_r, srandom_r, initstate_r, setstate_r - реентерабельный генератор "
"случайных чисел"

#. type: Plain text
#: man-pages/man3/random_r.3:35
#, no-wrap
msgid ""
"B<int random_r(struct random_data *>I<buf>B<, int32_t *>I<result>B<);>\n"
msgstr ""
"B<int random_r(struct random_data *>I<buf>B<, int32_t *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:37
#, no-wrap
msgid ""
"B<int srandom_r(unsigned int >I<seed>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""
"B<int srandom_r(unsigned int >I<seed>B<, struct random_data *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:40
#, no-wrap
msgid ""
"B<int initstate_r(unsigned int >I<seed>B<, char *>I<statebuf>B<,>\n"
"B<                size_t >I<statelen>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""
"B<int initstate_r(unsigned int >I<seed>B<, char *>I<statebuf>B<,>\nB<         "
"       size_t >I<statelen>B<, struct random_data *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:42
#, no-wrap
msgid ""
"B<int setstate_r(char *>I<statebuf>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""
"B<int setstate_r(char *>I<statebuf>B<, struct random_data *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:54
msgid "B<random_r>(), B<srandom_r>(), B<initstate_r>(), B<setstate_r>():"
msgstr "B<random_r>(), B<srandom_r>(), B<initstate_r>(), B<setstate_r>():"

#. type: Plain text
#: man-pages/man3/random_r.3:64
msgid ""
"These functions are the reentrant equivalents of the functions described in "
"B<random>(3).  They are suitable for use in multithreaded programs where "
"each thread needs to obtain an independent, reproducible sequence of random "
"numbers."
msgstr ""
"Эти функции являются реентрабельными эквивалентами функций, которые описаны в "
"B<random>(3). Они подходят для использования в многонитивых программах, где "
"каждой нити необходимо получить независимую, воспроизводимую "
"последовательность случайных чисел."

#. type: Plain text
#: man-pages/man3/random_r.3:75
msgid ""
"The B<random_r>()  function is like B<random>(3), except that instead of "
"using state information maintained in a global variable, it uses the state "
"information in the argument pointed to by I<buf>.  The generated random "
"number is returned in the argument I<result>."
msgstr ""
"Функция B<random_r>() подобна B<random>(3), но вместо использования "
"информации о состоянии, хранящейся в глобальный переменной, в ней "
"используется информация о состоянии в аргументе, указанном в I<buf>. "
"Сгенерированное случайное число возвращается в аргументе I<result>."

#. type: Plain text
#: man-pages/man3/random_r.3:84
msgid ""
"The B<srandom_r>()  function is like B<srandom>(3), except that it "
"initializes the seed for the random number generator whose state is "
"maintained in the object pointed to by I<buf>, instead of the seed "
"associated with the global state variable."
msgstr ""
"Функция B<srandom_r>() подобна B<srandom>(3), но инициализирует семя для "
"генератора случайных чисел, чьё состояние хранится в объекте, на который "
"указывает I<buf>, а не связывает семя с глобальной переменной состояния."

#. type: Plain text
#: man-pages/man3/random_r.3:92
msgid ""
"The B<initstate_r>()  function is like B<initstate>(3)  except that it "
"initializes the state in the object pointed to by I<buf>, rather than "
"initializing the global state variable."
msgstr ""
"Функция B<initstate_r>() подобна B<initstate>(3), но инициализирует состояние "
"в объекте, на который указывает I<buf>, а не в глобальной переменной "
"состояния."

#. type: Plain text
#: man-pages/man3/random_r.3:100
msgid ""
"The B<setstate_r>()  function is like B<setstate>(3)  except that it "
"modifies the state in the object pointer to by I<buf>, rather than modifying"
" the global state variable."
msgstr ""
"Функция B<setstate_r>() подобна B<setstate>(3), но изменяет состояние в "
"объекте, на который указывает I<buf>, а не в глобальной переменной состояния."

#. type: Plain text
#: man-pages/man3/random_r.3:105
msgid ""
"All of these functions return 0 on success.  On error, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении все функции возвращают 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/random_r.3:110
msgid "A state array of less than 8 bytes was specified to B<initstate_r>()."
msgstr "Функции B<initstate_r>() передан массив состояния меньше 8 байт."

#. type: Plain text
#: man-pages/man3/random_r.3:119
msgid "The I<statebuf> or I<buf> argument to B<setstate_r>()  was NULL."
msgstr "Аргумент I<statebuf> или I<buf> функции B<setstate_r>() равнялся NULL."

#. type: Plain text
#: man-pages/man3/random_r.3:128
msgid "The I<buf> or I<result> argument to B<random_r>()  was NULL."
msgstr "Аргумент I<buf> или I<result> функции B<random_r>() равнялся NULL."

#. type: Plain text
#: man-pages/man3/random_r.3:137
msgid ""
"The B<random_r>(), B<srandom_r>(), B<initstate_r>(), and B<setstate_r>()  "
"functions are thread-safe."
msgstr ""
"Функции B<random_r>(), B<srandom_r>(), B<initstate_r>() и B<setstate_r>() "
"можно использовать в нескольких нитях одновременно."

#.  These functions appear to be on Tru64, but don't seem to be on
#.  Solaris, HP-UX, or FreeBSD.
#. type: Plain text
#: man-pages/man3/random_r.3:141
msgid "These functions are nonstandard glibc extensions."
msgstr "Это функции являются расширениями glibc."

#. type: Plain text
#: man-pages/man3/random_r.3:144
msgid "B<drand48>(3), B<rand>(3), B<random>(3)"
msgstr "B<drand48>(3), B<rand>(3), B<random>(3)"

#. type: TH
#: man-pages/man3/rpc.3:11
#, no-wrap
msgid "2013-09-26"
msgstr "2013-09-26"

#. type: Plain text
#: man-pages/man3/rpc.3:14
msgid "rpc - library routines for remote procedure calls"
msgstr "rpc - библиотечные функции для вызова удалённых процедур"

#. type: SH
#: man-pages/man3/rpc.3:14
#, no-wrap
msgid "SYNOPSIS AND DESCRIPTION"
msgstr "СИНТАКСИС И ОПИСАНИЕ"

#.  .LP
#.  We don't have an rpc_secure.3 page at the moment -- MTK, 19 Sep 05
#.  Routines that are used for Secure RPC (DES authentication) are described
#. in
#.  .BR rpc_secure (3).
#.  Secure RPC can be used only if DES encryption is available.
#. type: Plain text
#: man-pages/man3/rpc.3:26
msgid ""
"These routines allow C programs to make procedure calls on other machines "
"across the network.  First, the client calls a procedure to send a data "
"packet to the server.  Upon receipt of the packet, the server calls a "
"dispatch routine to perform the requested service, and then sends back a "
"reply.  Finally, the procedure call returns to the client."
msgstr ""
"Эти функции позволяют программам, созданным на Си, вызывать удалённые "
"процедуры на других машинах в сети. Сначала, клиент вызывает процедуру путём "
"отправки пакета с данными на сервер. После принятия пакета сервер вызывает "
"функцию распределения (dispatch) для выполнения запрошенной службы и отсылает "
"ответ обратно. Последним действием результат выполнения процедуры "
"возвращается клиенту."

#. type: Plain text
#: man-pages/man3/rpc.3:29
msgid ""
"To take use of these routines, include the header file "
"I<E<lt>rpc/rpc.hE<gt>>."
msgstr ""
"Чтобы использовать эти функции, включите заголовочный файл I<E<lt>rpc/rpc.hE<"
"gt>>."

#. type: Plain text
#: man-pages/man3/rpc.3:31
msgid "The prototypes below make use of the following types:"
msgstr "Представленные ниже прототипы позволяют использовать следующие типы:"

#. type: Plain text
#: man-pages/man3/rpc.3:35
#, no-wrap
msgid "B<typedef int >I<bool_t>B<;>\n"
msgstr "B<typedef int >I<bool_t>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:37
#, no-wrap
msgid "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"
msgstr "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:40
#, no-wrap
msgid ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\n"
"B<                                struct sockaddr_in *>I<raddr>B<);>\n"
msgstr ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\nB<              "
"                  struct sockaddr_in *>I<raddr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:50
msgid ""
"See the header files for the declarations of the I<AUTH>, I<CLIENT>, "
"I<SVCXPRT>, and I<XDR> types."
msgstr ""
"Объявления типов I<AUTH>, I<CLIENT>, I<SVCXPRT> и I<XDR> смотрите в "
"заголовочных файлах."

#. type: Plain text
#: man-pages/man3/rpc.3:53
#, no-wrap
msgid "B<void auth_destroy(AUTH *>I<auth>B<);>\n"
msgstr "B<void auth_destroy(AUTH *>I<auth>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:62
msgid ""
"A macro that destroys the authentication information associated with "
"I<auth>.  Destruction usually involves deallocation of private data "
"structures.  The use of I<auth> is undefined after calling "
"B<auth_destroy>()."
msgstr ""
"Макрос, который уничтожает аутентификационную информацию, связанную с I<auth>"
". Уничтожение, обычно, вызывает высвобождение скрытых структур данных. Работа "
"с I<auth> после вызова B<auth_destroy>() не описана."

#. type: Plain text
#: man-pages/man3/rpc.3:65
#, no-wrap
msgid "B<AUTH *authnone_create(void);>\n"
msgstr "B<AUTH *authnone_create(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:71
msgid ""
"Create and return an RPC authentication handle that passes nonusable "
"authentication information with each remote procedure call.  This is the "
"default authentication used by RPC."
msgstr ""
"Создаёт и возвращает аутентификационный описатель RPC, который передаёт "
"непригодную аутентификационную информацию с каждым вызовом удалённой "
"процедуры. Данная аутентификация используется в RPC по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:75
#, no-wrap
msgid ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\n"
"B<                      int >I<len>B<, int *>I<aup_gids>B<);>\n"
msgstr ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\nB<  "
"                    int >I<len>B<, int *>I<aup_gids>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:91
msgid ""
"Create and return an RPC authentication handle that contains authentication "
"information.  The parameter I<host> is the name of the machine on which the "
"information was created; I<uid> is the user's user ID; I<gid> is the user's "
"current group ID; I<len> and I<aup_gids> refer to a counted array of groups "
"to which the user belongs.  It is easy to impersonate a user."
msgstr ""
"Создаёт и возвращает аутентификационный описатель RPC, который содержит "
"аутентификационную информацию. В параметре I<host> содержится имя машины, на "
"которой была создана информация; в I<uid> содержится пользовательский "
"идентификатор; в I<gid> содержится идентификатор текущей группы пользователя; "
"значения I<len> и I<aup_gids> описывают обновляемый (counted) массив групп, к "
"которым принадлежит пользователь. Это упрощает персонализацию пользователя."

#. type: Plain text
#: man-pages/man3/rpc.3:94
#, no-wrap
msgid "B<AUTH *authunix_create_default(void);>\n"
msgstr "B<AUTH *authunix_create_default(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:99
msgid "Calls B<authunix_create>()  with the appropriate parameters."
msgstr "Вызывает B<authunix_create>() с соответствующими параметрами."

#. type: Plain text
#: man-pages/man3/rpc.3:105
#, no-wrap
msgid ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<            unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<            xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<            xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\nB<            "
"unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\nB<            "
"xdrproc_t >I<inproc>B<, char *>I<in>B<,>\nB<            xdrproc_t >I<outproc>"
"B<, char *>I<out>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:129
msgid ""
"Call the remote procedure associated with I<prognum>, I<versnum>, and "
"I<procnum> on the machine, I<host>.  The parameter I<in> is the address of "
"the procedure's argument(s), and I<out> is the address of where to place the"
" result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results.  This routine returns "
"zero if it succeeds, or the value of B<enum clnt_stat> cast to an integer if"
" it fails.  The routine B<clnt_perrno>()  is handy for translating failure "
"statuses into messages."
msgstr ""
"Вызывает удалённую процедуру, связанную с I<prognum>, I<versnum> и I<procnum> "
"на машине I<host>. В параметре I<in> передаётся адрес параметров процедуры, в "
"I<out> — адрес, по которому должен помещаться результат; I<inproc> "
"используется для кодирования параметров процедуры, а I<outproc> — для "
"декодирования результатов. При успешном выполнении эта функция возвращает 0 "
"или целое значение в B<enum clnt_stat> при ошибке. Для перевода номера ошибки "
"в сообщение об ошибке можно использовать функцию B<clnt_perrno>()."

#. type: Plain text
#: man-pages/man3/rpc.3:135
msgid ""
"Warning: calling remote procedures with this routine uses UDP/IP as a "
"transport; see B<clntudp_create>()  for restrictions.  You do not have "
"control of timeouts or authentication using this routine."
msgstr ""
"Предупреждение: при вызове удалённой процедуры с помощью данной функции для "
"передачи используется протокол UDP/IP; ограничения смотрите в описании B<"
"clntudp_create>(). При использовании данной функции вы не можете управлять "
"задержкой или аутентификацией."

#. type: Plain text
#: man-pages/man3/rpc.3:142
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\n"
"B<                     unsigned long >I<versnum>B<, unsigned long >I<procnum>"
"B<,>\n"
"B<                     xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                     xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                     resultproc_t >I<eachresult>B<);>\n"
msgstr ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\nB<             "
"        unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\nB<        "
"             xdrproc_t >I<inproc>B<, char *>I<in>B<,>\nB<                     "
"xdrproc_t >I<outproc>B<, char *>I<out>B<,>\nB<                     "
"resultproc_t >I<eachresult>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:151
msgid ""
"Like B<callrpc>(), except the call message is broadcast to all locally "
"connected broadcast nets.  Each time it receives a response, this routine "
"calls B<eachresult>(), whose form is:"
msgstr ""
"Подобна B<callrpc>(), только сообщение посылается как широковещательное во "
"все локально подключённые сети. Каждый раз при получении ответа эта функция "
"вызывает B<eachresult>() следующего вида:"

#. type: Plain text
#: man-pages/man3/rpc.3:155
#, no-wrap
msgid "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:172
msgid ""
"where I<out> is the same as I<out> passed to B<clnt_broadcast>(), except "
"that the remote procedure's output is decoded there; I<addr> points to the "
"address of the machine that sent the results.  If B<eachresult>()  returns "
"zero, B<clnt_broadcast>()  waits for more replies; otherwise it returns with"
" appropriate status."
msgstr ""
"где I<out> — тот же самый параметр I<out>, переданный в B<clnt_broadcast>(), "
"за исключением того, что результат удалённой процедуры сразу же декодируется; "
"I<addr> указывает на адрес машины, которая послала результат. Если B<"
"eachresult>() возвращает 0, то B<clnt_broadcast>() продолжит ждать ответы; в "
"противном случае она возвращает соответствующий статус."

#. type: Plain text
#: man-pages/man3/rpc.3:176
msgid ""
"Warning: broadcast sockets are limited in size to the maximum transfer unit "
"of the data link.  For ethernet, this value is 1500 bytes."
msgstr ""
"Предупреждение: размер широковещательных сокетов ограничен максимальной "
"единицей передачи данных подключения. Для ethernet это значение равно 1500 "
"байтам."

#. type: Plain text
#: man-pages/man3/rpc.3:182
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<);>\n"
msgstr ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>"
"\nB<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\nB<          "
"          xdrproc_t >I<outproc>B<, char *>I<out>B<,>\nB<                    "
"struct timeval >I<tout>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:201
msgid ""
"A macro that calls the remote procedure I<procnum> associated with the "
"client handle, I<clnt>, which is obtained with an RPC client creation "
"routine such as B<clnt_create>().  The parameter I<in> is the address of the"
" procedure's argument(s), and I<out> is the address of where to place the "
"result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results; I<tout> is the time "
"allowed for results to come back."
msgstr ""
"Макрос, который вызывает удалённую процедуру I<procnum>, связанную с "
"клиентским описателем I<clnt>, полученным от функции создания клиента RPC, "
"такой как B<clnt_create>(). Параметр I<in> — адрес аргументов процедуры, а I<"
"out> —  адрес, по которому размещается результат; I<inproc> используется для "
"кодирования параметров процедуры, а I<outproc> используется для декодирования "
"её результатов; I<tout> — допустимое время ожидания результатов."

#. type: Plain text
#: man-pages/man3/rpc.3:204
#, no-wrap
msgid "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"
msgstr "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:217
msgid ""
"A macro that destroys the client's RPC handle.  Destruction usually involves"
" deallocation of private data structures, including I<clnt> itself.  Use of "
"I<clnt> is undefined after calling B<clnt_destroy>().  If the RPC library "
"opened the associated socket, it will close it also.  Otherwise, the socket "
"remains open."
msgstr ""
"Макрос, который уничтожает клиентский описатель RPC. Уничтожение, обычно, "
"затрагивает скрытые структуры данных, включая сам I<clnt>. Работа с I<clnt> "
"после вызова B<clnt_destroy>() не описана. Если библиотека RPC открывала "
"связанный сокет, он также будет закрыт. В противном случае сокет останется "
"открытым."

#. type: Plain text
#: man-pages/man3/rpc.3:221
#, no-wrap
msgid ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\n"
"B<                    unsigned long >I<vers>B<, char *>I<proto>B<);>\n"
msgstr ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\nB<        "
"            unsigned long >I<vers>B<, char *>I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:232
msgid ""
"Generic client creation routine.  I<host> identifies the name of the remote "
"host where the server is located.  I<proto> indicates which kind of "
"transport protocol to use.  The currently supported values for this field "
"are \\(lqudp\\(rq and \\(lqtcp\\(rq.  Default timeouts are set, but can be "
"modified using B<clnt_control>()."
msgstr ""
"Основная функция для создания клиента. В I<host> указывается имя удалённой "
"машины, где где расположен сервер. В I<proto> указывается тип протокола "
"передачи, который будет использован. Поддерживаемые значения этого поля: "
"«udp» и «tcp». Время задержки задаётся значением по умолчанию, но может быть "
"изменено с помощью B<clnt_control>()."

#. type: Plain text
#: man-pages/man3/rpc.3:237
msgid ""
"Warning: Using UDP has its shortcomings.  Since UDP-based RPC messages can "
"hold only up to 8 Kbytes of encoded data, this transport cannot be used for "
"procedures that take large arguments or return huge results."
msgstr ""
"Предупреждение: Использование UDP имеет недостатки. Так как в сообщениях RPC "
"на основе UDP может быть только 8 КБ закодированных данных, этот протокол не "
"может быть использован для процедур с большим количеством параметров или "
"которые возвращают результат большого размера."

#. type: Plain text
#: man-pages/man3/rpc.3:240
#, no-wrap
msgid ""
"B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"
msgstr ""
"B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:251
msgid ""
"A macro used to change or retrieve various information about a client "
"object.  I<req> indicates the type of operation, and I<info> is a pointer to"
" the information.  For both UDP and TCP, the supported values of I<req> and "
"their argument types and what they do are:"
msgstr ""
"Макрос, используемый для изменения или получения различной информации о "
"клиентском объекте. В I<req> указывается тип операции, а в I<info> — "
"указатель на информацию. Для UDP и TCP поддерживаются следующие значения I<"
"req> и их типы параметров:"

#. type: Plain text
#: man-pages/man3/rpc.3:256
#, no-wrap
msgid ""
"B<CLSET_TIMEOUT>  I<struct timeval> // set total timeout\n"
"B<CLGET_TIMEOUT>  I<struct timeval> // get total timeout\n"
msgstr ""
"// назначить общее время ожидания\nB<CLSET_TIMEOUT>  I<struct timeval>\n// "
"получить общее время ожидания\nB<CLGET_TIMEOUT>  I<struct timeval>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:264
msgid ""
"Note: if you set the timeout using B<clnt_control>(), the timeout parameter "
"passed to B<clnt_call>()  will be ignored in all future calls."
msgstr ""
"Замечание: если вы установили время ожидания с помощью B<clnt_control>(), то "
"параметр времени ожидания, передаваемый B<clnt_call>(), будет игнорироваться "
"во всех будущих вызовах."

#. type: Plain text
#: man-pages/man3/rpc.3:268
#, no-wrap
msgid "B<CLGET_SERVER_ADDR>  I<struct sockaddr_in > // get server's address\n"
msgstr ""
"// получить адрес сервера\nB<CLGET_SERVER_ADDR>  I<struct sockaddr_in >\n"

#. type: Plain text
#: man-pages/man3/rpc.3:272
msgid "The following operations are valid for UDP only:"
msgstr "Следующие операции действительны только для UDP:"

#. type: Plain text
#: man-pages/man3/rpc.3:277
#, no-wrap
msgid ""
"B<CLSET_RETRY_TIMEOUT>  I<struct timeval> // set the retry timeout\n"
"B<CLGET_RETRY_TIMEOUT>  I<struct timeval> // get the retry timeout\n"
msgstr ""
"// назначить повторное время ожидания\nB<CLSET_RETRY_TIMEOUT>  I<struct "
"timeval>\n// получить повторное время ожидания\nB<CLGET_RETRY_TIMEOUT>  I<"
"struct timeval>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:283
msgid ""
"The retry timeout is the time that \"UDP RPC\" waits for the server to reply"
" before retransmitting the request."
msgstr ""
"Повторное время — это время, в течение которого «UDP RPC» ждёт ответа от "
"сервера перед повторной отправкой запроса."

#. type: Plain text
#: man-pages/man3/rpc.3:286
#, no-wrap
msgid ""
"B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char "
"*>I<out>B<);>\n"
msgstr ""
"B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:297
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the results of an RPC call.  The parameter I<out> is the address of the "
"results, and I<outproc> is the XDR routine describing the results.  This "
"routine returns one if the results were successfully freed, and zero "
"otherwise."
msgstr ""
"Макрос, который освобождает любые данные, размещаемые системой RPC/XDR, когда "
"она декодирует результаты вызова RPC. Параметр I<out> — адрес результатов, а "
"I<outproc> — функция XDR, описывающая результаты. Эта функция возвращает 1, "
"если результаты были успешно освобождены и 0 в противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:300
#, no-wrap
msgid "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"
msgstr "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:305
msgid ""
"A macro that copies the error structure out of the client handle to the "
"structure at address I<errp>."
msgstr ""
"Макрос, который копирует структуру ошибки клиентского описателя в структуру "
"по адресу I<errp>."

#. type: Plain text
#: man-pages/man3/rpc.3:308
#, no-wrap
msgid "B<void clnt_pcreateerror(char *>I<s>B<);>\n"
msgstr "B<void clnt_pcreateerror(char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:322
msgid ""
"Print a message to standard error indicating why a client RPC handle could "
"not be created.  The message is prepended with string I<s> and a colon.  "
"Used when a B<clnt_create>(), B<clntraw_create>(), B<clnttcp_create>(), or "
"B<clntudp_create>()  call fails."
msgstr ""
"Выводит в стандартный поток ошибок сообщение, описывающее почему клиентский "
"описатель RPC не удалось создать. В начало сообщения добавляется строка I<s> "
"и знак двоеточия. Используется при ошибках в функциях B<clnt_create>(), B<"
"clntraw_create>(), B<clnttcp_create>() или B<clntudp_create>()."

#. type: Plain text
#: man-pages/man3/rpc.3:325
#, no-wrap
msgid "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"
msgstr "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:332
msgid ""
"Print a message to standard error corresponding to the condition indicated "
"by I<stat>.  Used after B<callrpc>()."
msgstr ""
"Выводит в стандартный поток ошибок сообщение согласно условию, указанному в "
"I<stat>. Используется после B<callrpc>()."

#. type: Plain text
#: man-pages/man3/rpc.3:335
#, no-wrap
msgid "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"
msgstr "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:345
msgid ""
"Print a message to standard error indicating why an RPC call failed; I<clnt>"
" is the handle used to do the call.  The message is prepended with string "
"I<s> and a colon.  Used after B<clnt_call>()."
msgstr ""
"Выводит в стандартный поток ошибок сообщение, описывающее почему вызов RPC "
"завершился с ошибкой. Значение I<clnt> — описатель, использовавшийся при "
"вызове. В начало сообщения добавляется строка I<s> и знак двоеточия. "
"Используется после B<clnt_call>()."

#. type: Plain text
#: man-pages/man3/rpc.3:348
#, no-wrap
msgid "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"
msgstr "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:353
msgid ""
"Like B<clnt_pcreateerror>(), except that it returns a string instead of "
"printing to the standard error."
msgstr ""
"Похожа на B<clnt_pcreateerror>(), но возвращает строку вместо вывода в "
"стандартный поток ошибок."

#. type: Plain text
#: man-pages/man3/rpc.3:355 man-pages/man3/rpc.3:395
msgid "Bugs: returns pointer to static data that is overwritten on each call."
msgstr ""
"Дефекты: возвращается указатель на статические данные, которые переписываются "
"при каждом вызове."

#. type: Plain text
#: man-pages/man3/rpc.3:358
#, no-wrap
msgid "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"
msgstr "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:365
msgid ""
"Take the same arguments as B<clnt_perrno>(), but instead of sending a "
"message to the standard error indicating why an RPC call failed, return a "
"pointer to a string which contains the message.  The string ends with a "
"NEWLINE."
msgstr ""
"Получает те же аргументы, что и B<clnt_perrno>(), но вместо отправки в "
"стандартный поток ошибок сообщения, которое показывает почему вызов RPC "
"завершился с ошибкой, возвращает указатель на строку с сообщением. Строка "
"заканчивается символом NEWLINE."

#. type: Plain text
#: man-pages/man3/rpc.3:383
msgid ""
"B<clnt_sperrno>()  is used instead of B<clnt_perrno>()  if the program does "
"not have a standard error (as a program running as a server quite likely "
"does not), or if the programmer does not want the message to be output with "
"B<printf>(3), or if a message format different than that supported by "
"B<clnt_perrno>()  is to be used.  Note: unlike B<clnt_sperror>()  and "
"B<clnt_spcreaterror>(), B<clnt_sperrno>()  returns pointer to static data, "
"but the result will not get overwritten on each call."
msgstr ""
"Функция B<clnt_sperrno>() используется вместо B<clnt_perrno>(), если "
"программа не имеет стандартного потока ошибок (для программ, запущенных как "
"сервер), или если программист не хочет выводить сообщения с помощью B<printf>"
"(3), или если формат сообщения отличается от формата, поддерживаемого B<"
"clnt_perrno>(). Замечание: в отличие от B<clnt_sperror>() и B<"
"clnt_spcreaterror>(), B<clnt_sperrno>() возвращает указатель на статические "
"данные, но результат не будет переписан при каждом вызове."

#. type: Plain text
#: man-pages/man3/rpc.3:386
#, no-wrap
msgid "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"
msgstr "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:393
msgid ""
"Like B<clnt_perror>(), except that (like B<clnt_sperrno>())  it returns a "
"string instead of printing to standard error."
msgstr ""
"Похожа на B<clnt_perror>(), но (подобно B<clnt_sperrno>()) возвращает строку "
"вместо вывода сообщения в стандартный поток ошибок."

#. type: Plain text
#: man-pages/man3/rpc.3:399
#, no-wrap
msgid ""
"B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long "
">I<versnum>B<);>\n"
msgstr ""
"B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long >I<"
"versnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:412
msgid ""
"This routine creates a toy RPC client for the remote program I<prognum>, "
"version I<versnum>.  The transport used to pass messages to the service is "
"actually a buffer within the process's address space, so the corresponding "
"RPC server should live in the same address space; see B<svcraw_create>().  "
"This allows simulation of RPC and acquisition of RPC overheads, such as "
"round trip times, without any kernel interference.  This routine returns "
"NULL if it fails."
msgstr ""
"Эта функция создаёт игрушечного клиента RPC для удалённой программы I<prognum>"
" версии I<versnum>. Протокол, используемый для пересылки сообщения службе, на "
"самом деле является буфером внутри адресного пространства процесса, поэтому "
"соответствующий сервер RPC должен находиться в том же адресном пространстве; "
"смотрите B<svcraw_create>(). Он позволяет имитировать RPC и временные "
"задержки без какого-либо участия ядра. При ошибке эта функция возвращает "
"NULL.."

#. type: Plain text
#: man-pages/man3/rpc.3:418
#, no-wrap
msgid ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >"
"I<recvsz>B<);>\n"
msgstr ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\nB<                "
"unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\nB<                "
"int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >I<recvsz>B<);>\n"

#. The following inline font conversion is necessary for the hyphen indicator
#. type: Plain text
#: man-pages/man3/rpc.3:448
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses TCP/IP as a transport.  The remote "
"program is located at Internet address I<*addr>.  If I<addr-E<gt>sin_port> "
"is zero, then it is set to the actual port that the remote program is "
"listening on (the remote B<portmap> service is consulted for this "
"information).  The parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, "
"then this routine opens a new one and sets I<sockp>.  Since TCP-based RPC "
"uses buffered I/O, the user may specify the size of the send and receive "
"buffers with the parameters I<sendsz> and I<recvsz>; values of zero choose "
"suitable defaults.  This routine returns NULL if it fails."
msgstr ""
"Эта функция создаёт клиента RPC для удалённой программы I<prognum>, версии I<"
"versnum>; для передачи клиент использует протокол TCP/IP. Удалённая программа "
"расположена по интернет-адресу I<*addr>. Если значение I<addr-E<gt>sin_port> "
"равно 0, тогда ему назначается реальный порт, который прослушивается "
"удалённой программой (эта информация запрашивается у удалённой службы I<"
"portmap>). Параметр I<sockp> — сокет; если его значение равно B<RPC_ANYSOCK>, "
"тогда эта функция открывает новый сокет и изменяет I<sockp>. Так как в RPC на "
"основе TCP используется буферизация ввода-вывода, пользователь может задать "
"размер посылаемых и получаемых буферов с помощью параметров I<sendsz> и I<"
"recvsz>; при значении 0 выбираются подходящие величины по умолчанию. При "
"ошибке эта функция возвращает NULL."

#. type: Plain text
#: man-pages/man3/rpc.3:453
#, no-wrap
msgid ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"
msgstr ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\nB<                "
"unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\nB<                "
"struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:479
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses use UDP/IP as a transport.  The remote "
"program is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is"
" zero, then it is set to actual port that the remote program is listening on"
" (the remote B<portmap> service is consulted for this information).  The "
"parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine "
"opens a new one and sets I<sockp>.  The UDP transport resends the call "
"message in intervals of I<wait> time until a response is received or until "
"the call times out.  The total time for the call to time out is specified by"
" B<clnt_call>()."
msgstr ""
"Эта функция создаёт клиента RPC для удалённой программы I<prognum> версии I<"
"versnum>; для передачи клиент использует протокол UDP/IP. Удалённая программа "
"расположена по интернет-адресу I<*addr>. Если I<addr-E<gt>sin_port> равно 0, "
"тогда ему назначается реальный порт, который прослушивается удалённой "
"программой (эта информация запрашивается у удалённой службы I<portmap>). "
"Параметр I<sockp> — сокет; если его значение равно B<RPC_ANYSOCK>, тогда эта "
"функция открывает новый сокет и изменяет I<sockp>. Протокол UDP повторяет "
"отправку сообщения через интервал, указанный в параметре I<wait>, пока не "
"будет получен ответ или не истечёт время ожидания. Полное время ожидания "
"вызова определяется B<clnt_call>()."

#. type: Plain text
#: man-pages/man3/rpc.3:483
msgid ""
"Warning: since UDP-based RPC messages can hold only up to 8 Kbytes of "
"encoded data, this transport cannot be used for procedures that take large "
"arguments or return huge results."
msgstr ""
"Предупреждение: так как в сообщениях RPC на основе UDP может быть только 8 КБ "
"закодированных данных, этот протокол не может быть использован для процедур с "
"большим количеством параметров или которые возвращают результат большого "
"размера."

#. type: Plain text
#: man-pages/man3/rpc.3:489
#, no-wrap
msgid ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\n"
"B<            unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<            struct timeval >I<wait>B<, int *>I<sockp>B<,>\n"
"B<            unsigned int >I<sendsize>B<, unsigned int >I<recosize>B<);>\n"
msgstr ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\nB<            "
"unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\nB<            "
"struct timeval >I<wait>B<, int *>I<sockp>B<,>\nB<            unsigned int >I<"
"sendsize>B<, unsigned int >I<recosize>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:515
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, on "
"I<versnum>; the client uses use UDP/IP as a transport.  The remote program "
"is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is zero, "
"then it is set to actual port that the remote program is listening on (the "
"remote B<portmap> service is consulted for this information).  The parameter"
" I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine opens a "
"new one and sets I<sockp>.  The UDP transport resends the call message in "
"intervals of I<wait> time until a response is received or until the call "
"times out.  The total time for the call to time out is specified by "
"B<clnt_call>()."
msgstr ""
"Эта функция создаёт клиента RPC для удалённой программы I<prognum> версии I<"
"versnum>; для передачи клиент использует протокол UDP/IP. Удалённая программа "
"расположена по интернет-адресу  I<*addr>. Если I<addr-E<gt>sin_port> равно 0, "
"тогда ему назначается реальный порт, который прослушивается удалённой "
"программой (эта информация запрашивается у удалённой службы I<portmap>). "
"Параметр I<sockp> — сокет; если его значение равно B<RPC_ANYSOCK>, тогда эта "
"функция открывает новый сокет и изменяет I<sockp>. Протокол UDP повторяет "
"отправку через интервал, указанный в параметре I<wait>, пока не будет получен "
"ответ или не истечёт время ожидания. Полное время ожидания вызова "
"определяется B<clnt_call>()."

#. type: Plain text
#: man-pages/man3/rpc.3:518 man-pages/man3/rpc.3:995
msgid ""
"This allows the user to specify the maximum packet size for sending and "
"receiving UDP-based RPC messages."
msgstr ""
"Эта функция позволяет пользователям задать максимальный размер пакета для "
"отправки и принятия сообщений RPC через UDP."

#. type: Plain text
#: man-pages/man3/rpc.3:521
#, no-wrap
msgid "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:529
msgid ""
"Stuff the machine's IP address into I<*addr>, without consulting the library"
" routines that deal with I</etc/hosts>.  The port number is always set to "
"B<htons(PMAPPORT)>."
msgstr ""
"Заполнить IP-адрес машины в I<*addr>, не используя библиотечные функции, "
"которые работают с I</etc/hosts>. Номер порта всегда устанавливается равным "
"B<htons(PMAPPORT)>."

#. type: Plain text
#: man-pages/man3/rpc.3:532
#, no-wrap
msgid "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:543
msgid ""
"A user interface to the B<portmap> service, which returns a list of the "
"current RPC program-to-port mappings on the host located at IP address "
"I<*addr>.  This routine can return NULL.  The command I<rpcinfo\\ -p> uses "
"this routine."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который возвращает текущий "
"список соответствий RPC-программа — порт, находящихся на машине с "
"определённым IP-адресом I<*addr>. Эта функция может возвратить NULL. Эту "
"функцию использует команда I<rpcinfo\\ -p>."

#. type: Plain text
#: man-pages/man3/rpc.3:548
#, no-wrap
msgid ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>"
"B<,>\n"
"B<                    unsigned int >I<protocol>B<);>\n"
msgstr ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\nB<            "
"        unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\nB<        "
"            unsigned int >I<protocol>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:572
msgid ""
"A user interface to the B<portmap> service, which returns the port number on"
" which waits a service that supports program number I<prognum>, version "
"I<versnum>, and speaks the transport protocol associated with I<protocol>.  "
"The value of I<protocol> is most likely B<IPPROTO_UDP> or B<IPPROTO_TCP>.  A"
" return value of zero means that the mapping does not exist or that the RPC "
"system failed to contact the remote B<portmap> service.  In the latter case,"
" the global variable I<rpc_createerr> contains the RPC status."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который возвращает номер порта, "
"на котором ожидает подключения служба, поддерживающая программный номер I<"
"prognum> версии I<versnum>, и отвечает по протоколу передачи, связанному с I<"
"protocol>. Обычно, значение I<protocol> равно B<IPPROTO_UDP> или B<"
"IPPROTO_TCP>. Возвращаемое значение 0 означает, что соответствия не "
"существует или что RPC системы не может соединиться с удалённой службой I<"
"portmap>. В последнем случае глобальная переменная I<rpc_createerr> содержит "
"состояние RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:580
#, no-wrap
msgid ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>"
"B<,>\n"
"B<                    unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<, unsigned long *>I<portp>B<);>"
"\n"
msgstr ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\nB<            "
"        unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\nB<        "
"            unsigned long >I<procnum>B<,>\nB<                    xdrproc_t >"
"I<inproc>B<, char *>I<in>B<,>\nB<                    xdrproc_t >I<outproc>B<, "
"char *>I<out>B<,>\nB<                    struct timeval >I<tout>B<, unsigned "
"long *>I<portp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:600
msgid ""
"A user interface to the B<portmap> service, which instructs B<portmap> on "
"the host at IP address I<*addr> to make an RPC call on your behalf to a "
"procedure on that host.  The parameter I<*portp> will be modified to the "
"program's port number if the procedure succeeds.  The definitions of other "
"parameters are discussed in B<callrpc>()  and B<clnt_call>().  This "
"procedure should be used for a \\(lqping\\(rq and nothing else.  See also "
"B<clnt_broadcast>()."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который указывает B<portmap> на "
"машине с IP-адресом I<*addr> выполнить вызов RPC от вашего имени к процедуре "
"на этой машине. При успешном выполнении процедуры параметр I<*portp> "
"заменяется на номер программного порта. Предназначение других параметров "
"описано в B<callrpc>() и B<clnt_call>(). Эта функция может быть использована "
"только для «ping». Смотрите также B<clnt_broadcast>()."

#. type: Plain text
#: man-pages/man3/rpc.3:604
#, no-wrap
msgid ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>\n"
msgstr ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>"
"\nB<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>"
"\n"

#. type: Plain text
#: man-pages/man3/rpc.3:624
msgid ""
"A user interface to the B<portmap> service, which establishes a mapping "
"between the triple [I<prognum>,I<versnum>,I<protocol>] and I<port> on the "
"machine's B<portmap> service.  The value of I<protocol> is most likely "
"B<IPPROTO_UDP> or B<IPPROTO_TCP>.  This routine returns one if it succeeds, "
"zero otherwise.  Automatically done by B<svc_register>()."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который устанавливает "
"соответствие между [I<prognum>,I<versnum>,I<protocol>] и I<port> на машине с "
"службой B<portmap>. Обычно, значение I<protocol> равно B<IPPROTO_UDP> или B<"
"IPPROTO_TCP>. При успешном выполнении эта функция возвращает 1 и 0 в "
"противном случае. Автоматически выполняется из B<svc_register>()."

#. type: Plain text
#: man-pages/man3/rpc.3:627
#, no-wrap
msgid ""
"B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long "
">I<versnum>B<);>\n"
msgstr ""
"B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:639
msgid ""
"A user interface to the B<portmap> service, which destroys all mapping "
"between the triple [I<prognum>,I<versnum>,I<*>] and B<ports> on the "
"machine's B<portmap> service.  This routine returns one if it succeeds, zero"
" otherwise."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который уничтожает все "
"соответствия между [I<prognum>,I<versnum>,I<*>] и B<ports> на машине с "
"службой B<portmap>. При успешном выполнении эта функция возвращает 1 и 0 в "
"противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:644
#, no-wrap
msgid ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char "
"*),>\n"
"B<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"
msgstr ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>"
"\nB<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char "
"*),>\nB<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:664
msgid ""
"Register procedure I<procname> with the RPC service package.  If a request "
"arrives for program I<prognum>, version I<versnum>, and procedure "
"I<procnum>, I<procname> is called with a pointer to its parameter(s); "
"I<progname> should return a pointer to its static result(s); I<inproc> is "
"used to decode the parameters while I<outproc> is used to encode the "
"results.  This routine returns zero if the registration succeeded, -1 "
"otherwise."
msgstr ""
"Регистрирует процедуру I<procname> в пакете служб RPC. Если запрос приходит "
"программе I<prognum> версии I<versnum> и процедуре I<procnum>, то I<procname> "
"вызывается с указателем на эти параметры; I<progname> должна возвращать "
"указатель на эти статические результаты; I<inproc> используется для "
"декодирования параметров, а I<outproc> — для кодирования результатов. При "
"успешной регистрации эта функция возвращает 0 и -1 в противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:669
msgid ""
"Warning: remote procedures registered in this form are accessed using the "
"UDP/IP transport; see B<svcudp_create>()  for restrictions."
msgstr ""
"Предупреждение: удалённые процедуры, зарегистрированные таким способом, "
"доступны по протоколу UDP/IP; информацию об ограничениях смотрите в B<"
"svcudp_create>()."

#. type: Plain text
#: man-pages/man3/rpc.3:672
#, no-wrap
msgid "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"
msgstr "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:679
msgid ""
"A global variable whose value is set by any RPC client creation routine that"
" does not succeed.  Use the routine B<clnt_pcreateerror>()  to print the "
"reason why."
msgstr ""
"Глобальная переменная, значение которой устанавливается любой функцией "
"создания клиента RPC при ошибке. Используйте функцию B<clnt_pcreateerror>() "
"для вывода сообщения о причине ошибки."

#. type: Plain text
#: man-pages/man3/rpc.3:682
#, no-wrap
msgid "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:693
msgid ""
"A macro that destroys the RPC service transport handle, I<xprt>.  "
"Destruction usually involves deallocation of private data structures, "
"including I<xprt> itself.  Use of I<xprt> is undefined after calling this "
"routine."
msgstr ""
"Макрос, который уничтожает описатель протокола службы RPC I<xprt>. "
"Уничтожение, обычно, освобождает скрытые структуры данных, включая сам I<xprt>"
". Работа с I<xprt> после вызова этой функции не описана."

#. type: Plain text
#: man-pages/man3/rpc.3:696
#, no-wrap
msgid "B<fd_set >I<svc_fdset>B<;>\n"
msgstr "B<fd_set >I<svc_fdset>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:710
msgid ""
"A global variable reflecting the RPC service side's read file descriptor bit"
" mask; it is suitable as a parameter to the B<select>(2)  system call.  This"
" is of interest only if a service implementor does their own asynchronous "
"event processing, instead of calling B<svc_run>().  This variable is read-"
"only (do not pass its address to B<select>(2)!), yet it may change after "
"calls to B<svc_getreqset>()  or any creation routines."
msgstr ""
"Глобальная переменная, отражающая битовую маску читаемого файлового "
"дескриптора службы RPC; она подходит в качестве параметра для системного "
"вызова B<select>(2). Полезна только, если реализация службы использует "
"собственный обработчик асинхронных событий, а не вызова B<svc_run>(). Эта "
"переменная доступна только для чтения (не передавайте её адрес в B<select>"
"(2)!), также она может измениться после вызова B<svc_getreqset>() или функций "
"создания."

#. type: Plain text
#: man-pages/man3/rpc.3:713
#, no-wrap
msgid "B<int >I<svc_fds>B<;>\n"
msgstr "B<int >I<svc_fds>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:720
msgid ""
"Similar to B<svc_fdset>, but limited to 32 descriptors.  This interface is "
"obsoleted by B<svc_fdset>."
msgstr ""
"Подобна B<svc_fdset>, но ограничена 32 дескрипторами. Устарела, используйте "
"B<svc_fdset>."

#. type: Plain text
#: man-pages/man3/rpc.3:723
#, no-wrap
msgid ""
"B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char "
"*>I<in>B<);>\n"
msgstr ""
"B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>"
"\n"

#. type: Plain text
#: man-pages/man3/rpc.3:730
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the arguments to a service procedure using B<svc_getargs>().  This routine "
"returns 1 if the results were successfully freed, and zero otherwise."
msgstr ""
"Макрос, который освобождает любые данные, выделенные системой RPC/XDR при "
"декодировании аргументов процедуры службы с помощью B<svc_getargs>(). Эта "
"функция возвращает 1, если результаты были успешно освобождены, и 0 в "
"противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:733
#, no-wrap
msgid ""
"B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char "
"*>I<in>B<);>\n"
msgstr ""
"B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:744
msgid ""
"A macro that decodes the arguments of an RPC request associated with the RPC"
" service transport handle, I<xprt>.  The parameter I<in> is the address "
"where the arguments will be placed; I<inproc> is the XDR routine used to "
"decode the arguments.  This routine returns one if decoding succeeds, and "
"zero otherwise."
msgstr ""
"Макрос, декодирующий параметры запроса RPC, связанного с описателем протокола "
"службы RPC I<xprt>. Параметр I<in> — адрес, по которому будут размещены "
"аргументы; I<inproc> — функция XDR, использующаяся для декодирования "
"аргументов. При успешном декодировании функция возвращает 1 и 0 в противном "
"случае."

#. type: Plain text
#: man-pages/man3/rpc.3:747
#, no-wrap
msgid "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:752
msgid ""
"The approved way of getting the network address of the caller of a procedure"
" associated with the RPC service transport handle, I<xprt>."
msgstr ""
"Правильный способ получения сетевого адреса вызвавшего процедуру, связанную с "
"описателем протокола службы RPC I<xprt>."

#. type: Plain text
#: man-pages/man3/rpc.3:755
#, no-wrap
msgid "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"
msgstr "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:769
msgid ""
"This routine is of interest only if a service implementor does not call "
"B<svc_run>(), but instead implements custom asynchronous event processing.  "
"It is called when the B<select>(2)  system call has determined that an RPC "
"request has arrived on some RPC socket(s); I<rdfds> is the resultant read "
"file descriptor bit mask.  The routine returns when all sockets associated "
"with the value of I<rdfds> have been serviced."
msgstr ""
"Функция представляет интерес, только если реализация службы не вызывает "
"функцию B<svc_run>(), а реализует собственную асинхронную обработку событий. "
"Вызывается, когда системный вызов B<select>(2) определил, что поступил запрос "
"RPC в какой-либо сокет RPC; I<rdfds> — битовая маска читаемого файлового "
"дескриптора. Функция завершается после обработки всех сокетов, связанных со "
"значением I<rdfds>."

#. type: Plain text
#: man-pages/man3/rpc.3:772
#, no-wrap
msgid "B<void svc_getreq(int >I<rdfds>B<);>\n"
msgstr "B<void svc_getreq(int >I<rdfds>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:779
msgid ""
"Similar to B<svc_getreqset>(), but limited to 32 descriptors.  This "
"interface is obsoleted by B<svc_getreqset>()."
msgstr ""
"Подобна B<svc_getreqset>(), но ограничена 32 дескрипторами. Устарела, "
"используйте B<svc_getreqset>()."

#. type: Plain text
#: man-pages/man3/rpc.3:785
#, no-wrap
msgid ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\n"
"B<                    unsigned long >I<versnum>B<,>\n"
"B<                    void (*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\n"
"B<                    unsigned long >I<protocol>B<);>\n"
msgstr ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\nB<  "
"                  unsigned long >I<versnum>B<,>\nB<                    void "
"(*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\nB<                    unsigned "
"long >I<protocol>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:815
msgid ""
"Associates I<prognum> and I<versnum> with the service dispatch procedure, "
"I<dispatch>.  If I<protocol> is zero, the service is not registered with the"
" B<portmap> service.  If I<protocol> is nonzero, then a mapping of the "
"triple [I<prognum>,I<versnum>,I<protocol>] to I<xprt-E<gt>xp_port> is "
"established with the local B<portmap> service (generally I<protocol> is "
"zero, B<IPPROTO_UDP> or B<IPPROTO_TCP>).  The procedure I<dispatch> has the "
"following form:"
msgstr ""
"Связывает I<prognum> и I<versnum> с функцией распределения служб I<dispatch>. "
"Если значение I<protocol> равно 0, то служба не регистрируется службой I<"
"portmap>. Если значение I<protocol> не равно 0, тогда соответствие [I<prognum>"
",I<versnum>,I<protocol>] и I<xprt-E<gt>xp_port> устанавливается локальной "
"службой I<portmap> (обычно, значение I<protocol> равно 0, B<IPPROTO_UDP> или "
"B<IPPROTO_TCP>). Функция I<dispatch> имеет следующий вид:"

#. type: Plain text
#: man-pages/man3/rpc.3:819
#, no-wrap
msgid "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"
msgstr "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"

#. type: Plain text
#: man-pages/man3/rpc.3:825
msgid ""
"The B<svc_register>()  routine returns one if it succeeds, and zero "
"otherwise."
msgstr ""
"При успешном выполнении функция B<svc_register>() возвращает 1 и 0 в "
"противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:828
#, no-wrap
msgid "B<void svc_run(void);>\n"
msgstr "B<void svc_run(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:838
msgid ""
"This routine never returns.  It waits for RPC requests to arrive, and calls "
"the appropriate service procedure using B<svc_getreq>()  when one arrives.  "
"This procedure is usually waiting for a B<select>(2)  system call to return."
msgstr ""
"Эта функция не возвращает управление. Она ждёт поступления запросов RPC и при "
"их появлении вызывает соответствующую процедуру службы с помощью B<svc_getreq>"
"(). Обычно, эта функция ждёт возврата из системного вызова  B<select>(2)."

#. type: Plain text
#: man-pages/man3/rpc.3:842
#, no-wrap
msgid ""
"B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char "
"*>I<out>B<);>\n"
msgstr ""
"B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char *>"
"I<out>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:854
msgid ""
"Called by an RPC service's dispatch routine to send the results of a remote "
"procedure call.  The parameter I<xprt> is the request's associated transport"
" handle; I<outproc> is the XDR routine which is used to encode the results; "
"and I<out> is the address of the results.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"Вызывается функцией распределения служб RPC для отправки результатов вызову "
"удалённой процедуры. Параметр I<xprt> — описатель протокола связанного "
"запроса; I<outproc> — функция XDR, которая используется для кодирования "
"результатов; I<out> — адрес, по которому находятся результаты. При успешном "
"выполнении эта функция возвращает 1 и 0 в противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:857
#, no-wrap
msgid ""
"B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long "
">I<versnum>B<);>\n"
msgstr ""
"B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long >I<versnum>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:864
msgid ""
"Remove all mapping of the double [I<prognum>,I<versnum>] to dispatch "
"routines, and of the triple [I<prognum>,I<versnum>,I<*>] to port number."
msgstr ""
"Удаляет все сопоставления [I<prognum>,I<versnum>] функциям распределения и "
"[I<prognum>,I<versnum>,I<*>] номеру порта."

#. type: Plain text
#: man-pages/man3/rpc.3:867
#, no-wrap
msgid "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"
msgstr "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:871
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to an authentication error."
msgstr ""
"Вызывается функцией распределения служб, которая отклоняет выполнение вызова "
"удалённой процедуры из ошибки аутентификации."

#. type: Plain text
#: man-pages/man3/rpc.3:874
#, no-wrap
msgid "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:880
msgid ""
"Called by a service dispatch routine that cannot successfully decode its "
"parameters.  See also B<svc_getargs>()."
msgstr ""
"Вызывается функцией распределения служб, если невозможно декодировать её "
"параметры. Смотрите также B<svc_getargs>()."

#. type: Plain text
#: man-pages/man3/rpc.3:883
#, no-wrap
msgid "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:887
msgid ""
"Called by a service dispatch routine that does not implement the procedure "
"number that the caller requests."
msgstr ""
"Вызывается функцией распределения служб, если не реализован номер процедуры, "
"указанный в полученном запросе."

#. type: Plain text
#: man-pages/man3/rpc.3:890
#, no-wrap
msgid "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:894
msgid ""
"Called when the desired program is not registered with the RPC package.  "
"Service implementors usually do not need this routine."
msgstr ""
"Вызывается, когда желаемая программа не зарегистрирована в пакете RPC. "
"Обычно, для реализации службы эта функция не требуется."

#. type: Plain text
#: man-pages/man3/rpc.3:897
#, no-wrap
msgid "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:902
msgid ""
"Called when the desired version of a program is not registered with the RPC "
"package.  Service implementors usually do not need this routine."
msgstr ""
"Вызывается, когда желаемая версия программы не зарегистрирована в пакете RPC. "
"Обычно, для реализации службы эта функция не требуется."

#. type: Plain text
#: man-pages/man3/rpc.3:905
#, no-wrap
msgid "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:911
msgid ""
"Called by a service dispatch routine when it detects a system error not "
"covered by any particular protocol.  For example, if a service can no longer"
" allocate storage, it may call this routine."
msgstr ""
"Вызывается функцией распределения служб при обнаружении системной ошибки, не "
"относящейся к какому-то конкретному протоколу. Например, служба может вызвать "
"эту функцию, если не удалось выделить память."

#. type: Plain text
#: man-pages/man3/rpc.3:914
#, no-wrap
msgid "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:920
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to insufficient authentication parameters.  The routine "
"calls B<svcerr_auth(xprt, AUTH_TOOWEAK)>."
msgstr ""
"Вызывается функцией распределения служб для отклонения вызова удалённой "
"процедуры из недостатка параметров аутентификации. Функция вызывает B<"
"svcerr_auth(xprt, AUTH_TOOWEAK)>."

#. type: Plain text
#: man-pages/man3/rpc.3:924
#, no-wrap
msgid ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\n"
"B<                      unsigned int >I<recvsize>B<);>\n"
msgstr ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\nB<       "
"               unsigned int >I<recvsize>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:934
msgid ""
"Create a service on top of any open descriptor.  Typically, this descriptor "
"is a connected socket for a stream protocol such as TCP.  I<sendsize> and "
"I<recvsize> indicate sizes for the send and receive buffers.  If they are "
"zero, a reasonable default is chosen."
msgstr ""
"Создаёт службу поверх любого открытого дескриптора. Обычно, этот дескриптор "
"является подключённым сокетом для поточного протокола, например TCP. В I<"
"sendsize> и I<recvsize> указываются размеры буферов отправки и приёма. Если "
"эти значения равны нулю, то выбирается приемлемое значение по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:937
#, no-wrap
msgid "B<SVCXPRT *svcraw_create(void);>\n"
msgstr "B<SVCXPRT *svcraw_create(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:947
msgid ""
"This routine creates a toy RPC service transport, to which it returns a "
"pointer.  The transport is really a buffer within the process's address "
"space, so the corresponding RPC client should live in the same address "
"space; see B<clntraw_create>().  This routine allows simulation of RPC and "
"acquisition of RPC overheads (such as round trip times), without any kernel "
"interference.  This routine returns NULL if it fails."
msgstr ""
"Эта функция создаёт игрушечный протокол службы RPC и возвращает указатель на "
"него. В действительности протокол представляет собой буфер внутри адресного "
"пространства процесса, поэтому соответствующие клиенты RPC должны находиться "
"в том же адресном пространстве; смотрите B<clntraw_create>(). Эта функция "
"позволяет имитировать RPC и создавать дополнительные нагрузки на RPC (как, "
"например, время пересылки туда и обратно) без какого-либо вмешательства ядра. "
"При ошибке функция возвращает NULL."

#. type: Plain text
#: man-pages/man3/rpc.3:951
#, no-wrap
msgid ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>\n"
"B<                       unsigned int >I<recv_buf_size>B<);>\n"
msgstr ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>"
"\nB<                       unsigned int >I<recv_buf_size>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:971
msgid ""
"This routine creates a TCP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local TCP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number."
"  This routine returns NULL if it fails.  Since TCP-based RPC uses buffered "
"I/O, users may specify the size of buffers; values of zero choose suitable "
"defaults."
msgstr ""
"Эта функция создаёт протокол службы RPC на основе TCP/IP и возвращает "
"указатель на него. Протокол связывается с сокетом I<sock>, значение которого "
"может быть равно B<RPC_ANYSOCK>; в этом случае создаётся новый сокет. Если "
"сокет не привязан к локальному порту TCP, то эта функция привязывает его к "
"произвольному порту. При завершении I<xprt-E<gt>xp_sock> содержит дескриптор "
"сокета протокола, а I<xprt-E<gt>xp_port> — номер порта протокола. При ошибке "
"эта функция возвращает NULL. Так как в RPC на основе TCP используется "
"буферизация ввода-вывода, пользователи могут задавать размер буферов; при "
"нулевом значении выбирается подходящий размер по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:975
#, no-wrap
msgid ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\n"
"B<                          unsigned int >I<recosize>B<);>\n"
msgstr ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\nB< "
"                         unsigned int >I<recosize>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:992
msgid ""
"This routine creates a UDP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local UDP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number."
"  This routine returns NULL if it fails."
msgstr ""
"Эта функция создаёт протокол службы RPC на основе UDP/IP и возвращает "
"указатель на него. Протокол связывается с сокетом I<sock>, значение которого "
"может быть равно B<RPC_ANYSOCK>; в этом случае создаётся новый сокет. Если "
"сокет не привязан к локальному порту UDP, то эта функция привязывает его к "
"произвольному порту. При завершении I<xprt-E<gt>xp_sock> содержит дескриптор "
"сокета протокола, а I<xprt-E<gt>xp_port> — номер порта протокола. При ошибке "
"эта функция возвращает NULL."

#. type: Plain text
#: man-pages/man3/rpc.3:998
#, no-wrap
msgid "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"
msgstr "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1004
msgid ""
"This call is equivalent to I<svcudp_bufcreate(sock,SZ,SZ)> for some default "
"size I<SZ>."
msgstr ""
"Этот вызов аналогичен I<svcudp_bufcreate(sock,SZ,SZ)> для некоторого размера "
"B<SZ> по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:1007
#, no-wrap
msgid ""
"B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply "
"*>I<ar>B<);>\n"
msgstr ""
"B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply *>I<ar>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1012
msgid ""
"Used for encoding RPC reply messages.  This routine is useful for users who "
"wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для кодирования ответных сообщений RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1015
#, no-wrap
msgid ""
"B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms "
"*>I<aupp>B<);>\n"
msgstr ""
"B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms *>I<aupp>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1021
msgid ""
"Used for describing UNIX credentials.  This routine is useful for users who "
"wish to generate these credentials without using the RPC authentication "
"package."
msgstr ""
"Используется для описания информации (credentials) UNIX. Эта функция полезна "
"для пользователей, которые хотят генерировать такую информацию без "
"использования пакета аутентификации RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1024
#, no-wrap
msgid "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"
msgstr "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1029
msgid ""
"Used for describing RPC call header messages.  This routine is useful for "
"users who wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для описания заголовка сообщений вызовов RPC. Эта функция "
"полезна для пользователей, которые хотят генерировать RPC-подобные сообщения "
"без использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1032
#, no-wrap
msgid "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"
msgstr "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1037
msgid ""
"Used for describing RPC call messages.  This routine is useful for users who"
" wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для описания сообщений вызовов RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1040
#, no-wrap
msgid ""
"B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"
msgstr ""
"B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1045
msgid ""
"Used for describing RPC authentication information messages.  This routine "
"is useful for users who wish to generate RPC-style messages without using "
"the RPC package."
msgstr ""
"Используется для описания информационных сообщений аутентификации RPC. Эта "
"функция полезна для пользователей, которые хотят генерировать RPC-подобные "
"сообщения без использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1048
#, no-wrap
msgid "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"
msgstr "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1057
msgid ""
"Used for describing parameters to various B<portmap> procedures, externally."
"  This routine is useful for users who wish to generate these parameters "
"without using the B<pmap> interface."
msgstr ""
"Используется для описания параметров различных функций B<portmap> извне. Эта "
"функция полезна для пользователей, которые хотят генерировать такие параметры "
"без использования интерфейса B<pmap>."

#. type: Plain text
#: man-pages/man3/rpc.3:1060
#, no-wrap
msgid "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"
msgstr "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1067
msgid ""
"Used for describing a list of port mappings, externally.  This routine is "
"useful for users who wish to generate these parameters without using the "
"B<pmap> interface."
msgstr ""
"Используется для описания списка соответствия портов извне. Эта функция "
"полезна для пользователей, которые хотят генерировать такие параметры без "
"использования интерфейса B<pmap>."

#. type: Plain text
#: man-pages/man3/rpc.3:1070
#, no-wrap
msgid ""
"B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply "
"*>I<rr>B<);>\n"
msgstr ""
"B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply *>I<rr>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1075
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для описания ответных сообщений RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1078
#, no-wrap
msgid "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"
msgstr "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1083
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC style messages without using the RPC package."
msgstr ""
"Используется для описания ответных сообщений RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1086
#, no-wrap
msgid "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1093
msgid ""
"After RPC service transport handles are created, they should register "
"themselves with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""
"После создания описателей протокола службы RPC они должны самостоятельно "
"зарегистрироваться в пакетом служб RPC. Эта функция изменяет глобальную "
"переменную I<svc_fds>. Обычно, для реализации служб эта функция не требуется."

#. type: Plain text
#: man-pages/man3/rpc.3:1096
#, no-wrap
msgid "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1103
msgid ""
"Before an RPC service transport handle is destroyed, it should unregister "
"itself with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""
"Перед уничтожением описателя протокола службы RPC он должен самостоятельно "
"отменить регистрацию в пакете службы RPC. Эта функция изменяет глобальную "
"переменную I<svc_fds>. Обычно, для реализации служб эта функция не требуется."

#.  We don't have an rpc_secure.3 page in the set at the moment -- MTK, 19 Sep
#. 05
#.  .BR rpc_secure (3),
#. type: Plain text
#: man-pages/man3/rpc.3:1107
msgid "B<xdr>(3)"
msgstr "B<xdr>(3)"

#. type: Plain text
#: man-pages/man3/rpc.3:1109
msgid "The following manuals:"
msgstr "Руководства:"

#. type: Plain text
#: man-pages/man3/rpc.3:1111
msgid "Remote Procedure Calls: Protocol Specification"
msgstr "Remote Procedure Calls: Protocol Specification"

#. type: Plain text
#: man-pages/man3/rpc.3:1113
msgid "Remote Procedure Call Programming Guide"
msgstr "Remote Procedure Call Programming Guide"

#. type: Plain text
#: man-pages/man3/rpc.3:1115
msgid "rpcgen Programming Guide"
msgstr "rpcgen Programming Guide"

#. type: Plain text
#: man-pages/man3/rpc.3:1120
msgid ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."
msgstr ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."

#. type: TH
#: man-pages/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr "REMOVE"

#. type: TH
#: man-pages/man3/remove.3:31
#, no-wrap
msgid "2014-03-10"
msgstr "2014-03-10"

#. type: Plain text
#: man-pages/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr "remove - удаляет файл или каталог"

#. type: Plain text
#: man-pages/man3/remove.3:36
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr "B<int remove(const char *>I<pathname>B<);>"

#. type: Plain text
#: man-pages/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the filesystem.  It calls B<unlink>(2)  for"
" files, and B<rmdir>(2)  for directories."
msgstr ""
"Функция B<remove>() удаляет имя из файловой системы. Она вызывает B<unlink>"
"(2) для файлов и B<rmdir>(2) для каталогов."

#. type: Plain text
#: man-pages/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""
"Если удалённое имя было последней ссылкой на файл и больше нет процессов, "
"которые держат этот файл открытым, то данный файл удаляется и место, которое "
"он занимает, освобождается для дальнейшего использования."

#. type: Plain text
#: man-pages/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"Если имя было последней ссылкой на файл, но какие-либо процессы всё ещё "
"держат этот файл открытым, файл будет существовать, пока последний файловый "
"дескриптор, указывающий на него, не будет закрыт."

#. type: Plain text
#: man-pages/man3/remove.3:57
msgid "If the name referred to a symbolic link, the link is removed."
msgstr "Если имя указывает на символьную ссылку, то будет удалена ссылка."

#. type: Plain text
#: man-pages/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""
"Если имя указывает на сокет, FIFO или устройство, то имя будет удалено, но "
"процессы, которые открыли объект, могут продолжать его использовать."

#. type: Plain text
#: man-pages/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr "Ошибки, которые возникают у B<unlink>(2) и B<rmdir>(2)."

#. type: Plain text
#: man-pages/man3/remove.3:75
msgid "The B<remove>()  function is thread-safe."
msgstr ""
"Функцию B<remove>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/remove.3:77
msgid "C89, C99, 4.3BSD, POSIX.1-2001."
msgstr "C89, C99, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/remove.3:83
msgid ""
"Under libc4 and libc5, B<remove>()  was an alias for B<unlink>(2)  (and "
"hence would not remove directories)."
msgstr ""
"В libc4 и libc5 функция B<remove>() являлась псевдонимом B<unlink>(2) (и "
"поэтому не удаляла каталоги)."

#. type: Plain text
#: man-pages/man3/remove.3:86
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""
"Неточности в протоколе NFS могут приводить к неожиданному исчезновению "
"файлов, которые всё ещё используются."

#. type: Plain text
#: man-pages/man3/remove.3:96
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), B<"
"rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"

#. type: Plain text
#: man-pages/man3/readdir.3:39
msgid "readdir, readdir_r - read a directory"
msgstr "readdir, readdir_r - чтение содержимого каталога"

#. type: Plain text
#: man-pages/man3/readdir.3:44
#, no-wrap
msgid "B<struct dirent *readdir(DIR *>I<dirp>B<);>\n"
msgstr "B<struct dirent *readdir(DIR *>I<dirp>B<);>\n"

#. type: Plain text
#: man-pages/man3/readdir.3:47
#, no-wrap
msgid ""
"B<int readdir_r(DIR *>I<dirp>B<, struct dirent *>I<entry>B<, struct dirent "
"**>I<result>B<);>\n"
msgstr ""
"B<int readdir_r(DIR *>I<dirp>B<, struct dirent *>I<entry>B<, struct dirent **>"
"I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/readdir.3:56
msgid "B<readdir_r>():"
msgstr "B<readdir_r>():"

#. type: Plain text
#: man-pages/man3/readdir.3:59
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"
" || _POSIX_SOURCE"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE "
"|| _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/readdir.3:69
msgid ""
"The B<readdir>()  function returns a pointer to a I<dirent> structure "
"representing the next directory entry in the directory stream pointed to by "
"I<dirp>.  It returns NULL on reaching the end of the directory stream or if "
"an error occurred."
msgstr ""
"Функция B<readdir>() возвращает указатель на структуру I<dirent>, "
"представляющую следующую запись каталога в потоке каталога, указанного в I<"
"dirp>. Функция возвращает NULL по достижении последней записи в потоке "
"каталога или если произошла ошибка."

#. type: Plain text
#: man-pages/man3/readdir.3:73
msgid "On Linux, the I<dirent> structure is defined as follows:"
msgstr "В Linux структура I<dirent> определена следующим образом:"

#. type: Plain text
#: man-pages/man3/readdir.3:84
#, no-wrap
msgid ""
"struct dirent {\n"
"    ino_t          d_ino;       /* inode number */\n"
"    off_t          d_off;       /* not an offset; see NOTES */\n"
"    unsigned short d_reclen;    /* length of this record */\n"
"    unsigned char  d_type;      /* type of file; not supported\n"
"                                   by all filesystem types */\n"
"    char           d_name[256]; /* filename */\n"
"};\n"
msgstr ""
"struct dirent {\n    ino_t          d_ino;       /* номер inode */\n    off_t "
"         d_off;       /* не смещение; смотрите ЗАМЕЧАНИЯ */\n    unsigned "
"short d_reclen;    /* длина этой записи */\n    unsigned char  d_type;      "
"/* тип файла; поддерживается\n                                   не всеми "
"типами файловых систем */\n    char           d_name[256]; /* имя файла "
"*/\n};\n"

#. type: Plain text
#: man-pages/man3/readdir.3:98
msgid ""
"The only fields in the I<dirent> structure that are mandated by POSIX.1 are:"
" I<d_name>[], of unspecified size, with at most B<NAME_MAX> characters "
"preceding the terminating null byte (\\(aq\\e0\\(aq); and (as an XSI "
"extension)  I<d_ino>.  The other fields are unstandardized, and not present "
"on all systems; see NOTES below for some further details."
msgstr ""
"В соответствие с POSIX.1, структура I<dirent> обязательно должна содержать "
"поле I<d_name>[] неопределённой длины с максимальным количеством символов B<"
"NAME_MAX>, предшествующих конечному байту null (\\(aq\\e0\\(aq), и I<d_ino> "
"(расширение XSI). Другие поля не стандартизованы и имеются не во всех "
"системах; подробней смотрите ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man3/readdir.3:104
msgid ""
"The data returned by B<readdir>()  may be overwritten by subsequent calls to"
" B<readdir>()  for the same directory stream."
msgstr ""
"Данные, возвращаемые B<readdir>(), могут быть переписаны последующими "
"вызовами B<readdir>() для того же потока каталога."

#. type: Plain text
#: man-pages/man3/readdir.3:119
msgid ""
"The B<readdir_r>()  function is a reentrant version of B<readdir>().  It "
"reads the next directory entry from the directory stream I<dirp>, and "
"returns it in the caller-allocated buffer pointed to by I<entry>.  (See "
"NOTES for information on allocating this buffer.)  A pointer to the returned"
" item is placed in I<*result>; if the end of the directory stream was "
"encountered, then NULL is instead returned in I<*result>."
msgstr ""
"Функция B<readdir_r>() является реентерабельной версией B<readdir>(). Она "
"читает следующую запись каталога из потока каталога I<dirp> и возвращает её в "
"созданном вызывающим буфере, на который указывает I<entry> (информацию о "
"выделении буфера смотрите далее в ЗАМЕЧАНИЯХ). Указатель на возвращаемый "
"элемент помещается в I<*result>; если достигнут конец потока каталога, то "
"возвращается NULL вместо значения I<*result>."

#. type: Plain text
#: man-pages/man3/readdir.3:134
msgid ""
"On success, B<readdir>()  returns a pointer to a I<dirent> structure.  (This"
" structure may be statically allocated; do not attempt to B<free>(3)  it.)  "
"If the end of the directory stream is reached, NULL is returned and I<errno>"
" is not changed.  If an error occurs, NULL is returned and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении функция B<readdir>() возвращает указатель на "
"структуру I<dirent> (эта структура может выделяться статически; не пытайтесь "
"освободить её). Если достигнут конец потока каталога, то возвращается NULL и "
"I<errno> не изменяется. Если произошла ошибка, то возвращается NULL, а I<"
"errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/readdir.3:143
msgid ""
"The B<readdir_r>()  function returns 0 on success.  On error, it returns a "
"positive error number (listed under ERRORS).  If the end of the directory "
"stream is reached, B<readdir_r>()  returns 0, and returns NULL in "
"I<*result>."
msgstr ""
"При успешном выполнении функция B<readdir_r>() возвращает 0. При ошибке она "
"возвращает положительный номер ошибки (перечислены в ОШИБКАХ). Если достигнут "
"конец потока каталога, то B<readdir_r>() возвращает 0 и NULL в I<*result>."

#. type: Plain text
#: man-pages/man3/readdir.3:147
msgid "Invalid directory stream descriptor I<dirp>."
msgstr "Неверный дескриптор потока каталога I<dirp>."

#. type: Plain text
#: man-pages/man3/readdir.3:152
msgid "The B<readdir>()  function is not thread-safe."
msgstr ""
"Функцию B<readdir>() нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/readdir.3:156
msgid "The B<readdir_r>()  function is thread-safe."
msgstr ""
"Функцию B<readdir_r>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/readdir.3:174
msgid ""
"Only the fields I<d_name> and I<d_ino> are specified in POSIX.1-2001.  The "
"remaining fields are available on many, but not all systems.  Under glibc, "
"programs can check for the availability of the fields not defined in POSIX.1"
" by testing whether the macros B<_DIRENT_HAVE_D_NAMLEN>, "
"B<_DIRENT_HAVE_D_RECLEN>, B<_DIRENT_HAVE_D_OFF>, or B<_DIRENT_HAVE_D_TYPE> "
"are defined."
msgstr ""
"В POSIX.1-2001 определены только поля I<d_name> и I<d_ino>. Остальные поля "
"доступны во многих, но не во всех системах. В glibc программы могут "
"определить доступность полей, не определённых в POSIX.1, по наличию макросов "
"B<_DIRENT_HAVE_D_NAMLEN>, B<_DIRENT_HAVE_D_RECLEN>, B<_DIRENT_HAVE_D_OFF> или "
"B<_DIRENT_HAVE_D_TYPE>."

#.  https://lwn.net/Articles/544298/
#. type: Plain text
#: man-pages/man3/readdir.3:187
msgid ""
"The value returned in I<d_off> is the same as would be returned by calling "
"B<telldir>(3)  at the current position in the directory stream.  Be aware "
"that despite its type and name, the I<d_off> field is seldom any kind of "
"directory offset on modern filesystems.  Applications should treat this "
"field as an opaque value, making no assumptions about its contents; see also"
" B<telldir>(3)."
msgstr ""
"Значение, возвращаемое в I<d_off>, тоже самое что и после вызова B<telldir>"
"(3) в текущем положении курсора в потоке каталога. Учтите, что не смотря на "
"тип и имя, в современных файловых системах поле I<d_off> мало похоже на "
"смещение в каталоге. Приложения должны считать, что это поле неизвестного "
"типа и не делать предположений о его содержимом; смотрите также B<telldir>(3)."

#. type: Plain text
#: man-pages/man3/readdir.3:200
msgid ""
"Other than Linux, the I<d_type> field is available mainly only on BSD "
"systems.  This field makes it possible to avoid the expense of calling "
"B<lstat>(2)  if further actions depend on the type of the file.  If the "
"B<_BSD_SOURCE> feature test macro is defined, then glibc defines the "
"following macro constants for the value returned in I<d_type>:"
msgstr ""
"Кроме Linux, поле I<d_type> доступно, в основном, только в системах BSD. Это "
"поле позволяет избежать затрат на вызов B<lstat>(2), если дальнейшие действия "
"зависят от типа файла. Если определён макрос тестирования свойств B<"
"_BSD_SOURCE>, то в glibc определены следующие макросы-константы значений, "
"возвращаемых в I<d_type>:"

#. type: TP
#: man-pages/man3/readdir.3:200
#, no-wrap
msgid "B<DT_BLK>"
msgstr "B<DT_BLK>"

#. type: Plain text
#: man-pages/man3/readdir.3:203
msgid "This is a block device."
msgstr "блочное устройство"

#. type: TP
#: man-pages/man3/readdir.3:203
#, no-wrap
msgid "B<DT_CHR>"
msgstr "B<DT_CHR>"

#. type: Plain text
#: man-pages/man3/readdir.3:206
msgid "This is a character device."
msgstr "символьное устройство"

#. type: TP
#: man-pages/man3/readdir.3:206
#, no-wrap
msgid "B<DT_DIR>"
msgstr "B<DT_DIR>"

#. type: Plain text
#: man-pages/man3/readdir.3:209
msgid "This is a directory."
msgstr "каталог"

#. type: TP
#: man-pages/man3/readdir.3:209
#, no-wrap
msgid "B<DT_FIFO>"
msgstr "B<DT_FIFO>"

#. type: Plain text
#: man-pages/man3/readdir.3:212
msgid "This is a named pipe (FIFO)."
msgstr "именованный канал (FIFO)"

#. type: TP
#: man-pages/man3/readdir.3:212
#, no-wrap
msgid "B<DT_LNK>"
msgstr "B<DT_LNK>"

#. type: Plain text
#: man-pages/man3/readdir.3:215
msgid "This is a symbolic link."
msgstr "символическая ссылка"

#. type: TP
#: man-pages/man3/readdir.3:215
#, no-wrap
msgid "B<DT_REG>"
msgstr "B<DT_REG>"

#. type: Plain text
#: man-pages/man3/readdir.3:218
msgid "This is a regular file."
msgstr "обычный файл"

#. type: TP
#: man-pages/man3/readdir.3:218
#, no-wrap
msgid "B<DT_SOCK>"
msgstr "B<DT_SOCK>"

#. type: Plain text
#: man-pages/man3/readdir.3:221
msgid "This is a UNIX domain socket."
msgstr "доменный сокет UNIX"

#. type: TP
#: man-pages/man3/readdir.3:221
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr "B<DT_UNKNOWN>"

#.  The glibc manual says that on some systems this is the only
#.  value returned
#. type: Plain text
#: man-pages/man3/readdir.3:226
msgid "The file type is unknown."
msgstr "неизвестный тип"

#. type: Plain text
#: man-pages/man3/readdir.3:231
msgid ""
"If the file type could not be determined, the value B<DT_UNKNOWN> is "
"returned in I<d_type>."
msgstr ""
"Если тип файла не определён, то I<d_type> присваивается значение B<DT_UNKNOWN>"
"."

#.  kernel 2.6.27
#.  The same sentence is in getdents.2
#. type: Plain text
#: man-pages/man3/readdir.3:240
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr ""
"В настоящее время, только файловые системы (среди которых: Btrfs, ext2, ext3 "
"и ext4) поддерживают возврат типа файла в I<d_type>. Все приложения должны "
"правильно обрабатывать возвращаемое значение B<DT_UNKNOWN>."

#. type: Plain text
#: man-pages/man3/readdir.3:250
msgid ""
"Since POSIX.1 does not specify the size of the I<d_name> field, and other "
"nonstandard fields may precede that field within the I<dirent> structure, "
"portable applications that use B<readdir_r>()  should allocate the buffer "
"whose address is passed in I<entry> as follows:"
msgstr ""
"Так как в POSIX.1 не определён размер поля I<d_name> и других нестандартных "
"полей, которые могут находиться перед этим полем в структуре I<dirent>, "
"переносимые приложения, использующие B<readdir_r>(), должны выделять буфер, "
"адрес которого передаётся в I<entry>, следующим образом:"

#. type: Plain text
#: man-pages/man3/readdir.3:258
#, no-wrap
msgid ""
"name_max = pathconf(dirpath, _PC_NAME_MAX);\n"
"if (name_max == -1)         /* Limit not defined, or error */\n"
"    name_max = 255;         /* Take a guess */\n"
"len = offsetof(struct dirent, d_name) + name_max + 1;\n"
"entryp = malloc(len);\n"
msgstr ""
"name_max = pathconf(dirpath, _PC_NAME_MAX);\nif (name_max == -1)         /* "
"ограничения нет или ошибка */\n    name_max = 255;         /* угадаем */\nlen "
"= offsetof(struct dirent, d_name) + name_max + 1;\nentryp = malloc(len);\n"

#. type: Plain text
#: man-pages/man3/readdir.3:265
msgid ""
"(POSIX.1 requires that I<d_name> is the last field in a I<struct dirent>.)"
msgstr ""
"(в POSIX.1 требуется, чтобы I<d_name> было последним полем в I<struct dirent>)"

#. type: Plain text
#: man-pages/man3/readdir.3:276
msgid ""
"B<getdents>(2), B<read>(2), B<closedir>(3), B<dirfd>(3), B<ftw>(3), "
"B<offsetof>(3), B<opendir>(3), B<rewinddir>(3), B<scandir>(3), "
"B<seekdir>(3), B<telldir>(3)"
msgstr ""
"B<getdents>(2), B<read>(2), B<closedir>(3), B<dirfd>(3), B<ftw>(3), B<"
"offsetof>(3), B<opendir>(3), B<rewinddir>(3), B<scandir>(3), B<seekdir>(3), "
"B<telldir>(3)"

#. type: TH
#: man-pages/man3/rint.3:27
#, no-wrap
msgid "RINT"
msgstr "RINT"

#. type: TH
#: man-pages/man3/rint.3:27
#, no-wrap
msgid "2013-08-26"
msgstr "2013-08-26"

#. type: Plain text
#: man-pages/man3/rint.3:31
msgid ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - round to nearest "
"integer"
msgstr ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - округление до "
"ближайшего целого"

#. type: Plain text
#: man-pages/man3/rint.3:36
#, no-wrap
msgid "B<double nearbyint(double >I<x>B<);>\n"
msgstr "B<double nearbyint(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:38
#, no-wrap
msgid "B<float nearbyintf(float >I<x>B<);>\n"
msgstr "B<float nearbyintf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:40
#, no-wrap
msgid "B<long double nearbyintl(long double >I<x>B<);>\n"
msgstr "B<long double nearbyintl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:42
#, no-wrap
msgid "B<double rint(double >I<x>B<);>\n"
msgstr "B<double rint(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:44
#, no-wrap
msgid "B<float rintf(float >I<x>B<);>\n"
msgstr "B<float rintf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:46
#, no-wrap
msgid "B<long double rintl(long double >I<x>B<);>\n"
msgstr "B<long double rintl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:59
msgid "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"
msgstr "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"

#. type: Plain text
#: man-pages/man3/rint.3:61
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || "
"_ISOC99_SOURCE;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || "
"_ISOC99_SOURCE;"

#. type: Plain text
#: man-pages/man3/rint.3:67
msgid "B<rint>():"
msgstr "B<rint>():"

#. type: Plain text
#: man-pages/man3/rint.3:71
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/rint.3:78
msgid "B<rintf>(), B<rintl>():"
msgstr "B<rintf>(), B<rintl>():"

#. type: Plain text
#: man-pages/man3/rint.3:98
msgid ""
"The B<nearbyint>(), B<nearbyintf>(), and B<nearbyintl>()  functions round "
"their argument to an integer value in floating-point format, using the "
"current rounding direction (see B<fesetround>(3))  and without raising the "
"I<inexact> exception."
msgstr ""
"Функции B<nearbyint>(), B<nearbyintf>() и B<nearbyintl>() округляют "
"переданный аргумент до целого значения в формате с плавающей запятой в "
"соответствии с текущим направлением округления (смотрите B<fesetround>(3)) и "
"не генерируют исключение о I<неточности>."

#. type: Plain text
#: man-pages/man3/rint.3:111
msgid ""
"The B<rint>(), B<rintf>(), and B<rintl>()  functions do the same, but will "
"raise the I<inexact> exception (B<FE_INEXACT>, checkable via "
"B<fetestexcept>(3))  when the result differs in value from the argument."
msgstr ""
"Функции B<rint>(), B<rintf>() и B<rintl>() делают то же самое, но генерируют "
"исключение о I<неточности> (B<FE_INEXACT>, проверяется с помощью B<"
"fetestexcept>(3)), если результат отличается в значении от аргумента."

#. type: Plain text
#: man-pages/man3/rint.3:133
msgid ""
"The B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>(), B<rint>(), B<rintf>(),"
" and B<rintl>()  functions are thread-safe."
msgstr ""
"Функции B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>(), B<rint>(), B<rintf>"
"() и B<rintl>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/rint.3:150
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno>"
" to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of"
" mantissa bits is 24 (respectively, 53).)"
msgstr ""
"В SUSv2 и POSIX.1-2001 есть текст о переполнении (которое может установить I<"
"errno> в B<ERANGE> или вызвать исключение B<FE_OVERFLOW>). На практике,  "
"результат не может выйти за диапазон ни на каком компьютере, поэтому "
"обработка этой ошибки не имеет смысла (точнее говоря, переполнение возможно "
"только в том случае, когда максимальное значение экспоненты меньше числа бит "
"мантиссы. В стандарте IEEE-754 для 32- и 64-битных чисел с плавающей точкой "
"максимальное значение экспоненты равно 128 и 1024 соответственно, а число бит "
"мантиссы \\(em 24 и 53 соответственно)."

#. type: Plain text
#: man-pages/man3/rint.3:155
msgid ""
"If you want to store the rounded value in an integer type, you probably want"
" to use one of the functions described in B<lrint>(3)  instead."
msgstr ""
"Если вы хотите сохранить округлённое значение в целочисленном типе, то лучше "
"использовать одну из функций, описанных в B<lrint>(3)."

#. type: Plain text
#: man-pages/man3/rint.3:160
msgid "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"
msgstr "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"

#. type: TH
#: man-pages/man3/recno.3:36
#, no-wrap
msgid "RECNO"
msgstr "RECNO"

#. type: TH
#: man-pages/man3/recno.3:36
#, no-wrap
msgid "2012-04-23"
msgstr "2012-04-23"

#. type: Plain text
#: man-pages/man3/recno.3:40
msgid "recno - record number database access method"
msgstr "recno - метод доступа к базам нумерованных данных"

#. type: Plain text
#: man-pages/man3/recno.3:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>\n#include E<lt>db.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/recno.3:54
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces."
"  Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""
"I<Примечание>: В этой странице описаны интерфейсы, предоставляемые glibc до "
"версии 2.1. Начиная с версии 2.2, glibc больше не поддерживает эти "
"интерфейсы. Вероятно, вы ищите API, предоставляемое библиотекой I<libdb>."

#. type: Plain text
#: man-pages/man3/recno.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is record number files.  The general "
"description of the database access methods is in B<dbopen>(3), this manual "
"page describes only the recno-specific information."
msgstr ""
"Функция B<dbopen>(3) — это библиотечный интерфейс к файлам баз данных. Один "
"из поддерживаемых форматов файлов — нумерованные данные. Общее описание "
"методов доступа к базам данных находится в B<dbopen>(3). Эта справочная "
"страница содержит только информацию, относящуюся к нумерованным данным."

#. type: Plain text
#: man-pages/man3/recno.3:71
msgid ""
"The record number data structure is either variable or fixed-length records "
"stored in a flat-file format, accessed by the logical record number.  The "
"existence of record number five implies the existence of records one through"
" four, and the deletion of record number one causes record number five to be"
" renumbered to record number four, as well as the cursor, if positioned "
"after record number one, to shift down one record."
msgstr ""
"Структура нумерованных данных может описывать записи переменной или "
"фиксированной длины, хранящиеся в файле в «плоском» формате, и доступные по "
"логическому номеру записи. Существование записи с номером пять подразумевает "
"существование записей от одного до четырёх и удаление записи с номером один "
"вызывает перенумеровывание записи с номером пять в запись с номером четыре, а "
"также сдвиг курсора вниз на одну запись, если он указывает на запись после "
"номера один."

#. type: Plain text
#: man-pages/man3/recno.3:77
msgid ""
"The recno access-method-specific data structure provided to B<dbopen>(3)  is"
" defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""
"Специальная структура метода доступа к данным recno, предоставляемая B<dbopen>"
"(3), определена в I<E<lt>db.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/recno.3:89
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    unsigned int  psize;\n"
"    int           lorder;\n"
"    size_t        reclen;\n"
"    unsigned char bval;\n"
"    char         *bfname;\n"
"} RECNOINFO;\n"
msgstr ""
"typedef struct {\n    unsigned long flags;\n    unsigned int  cachesize;\n    "
"unsigned int  psize;\n    int           lorder;\n    size_t        reclen;\n  "
"  unsigned char bval;\n    char         *bfname;\n} RECNOINFO;\n"

#. type: Plain text
#: man-pages/man3/recno.3:93
msgid "The elements of this structure are defined as follows:"
msgstr "Элементы этой структуры определены так:"

#. type: TP
#: man-pages/man3/recno.3:93
#, no-wrap
msgid "I<flags>"
msgstr "I<flags>"

#. type: Plain text
#: man-pages/man3/recno.3:97
msgid "The flag value is specified by ORing any of the following values:"
msgstr "Значение флага определяется логическим ИЛИ следующих значений:"

#. type: TP
#: man-pages/man3/recno.3:98
#, no-wrap
msgid "B<R_FIXEDLEN>"
msgstr "B<R_FIXEDLEN>"

#. type: Plain text
#: man-pages/man3/recno.3:109
msgid ""
"The records are fixed-length, not byte delimited.  The structure element "
"I<reclen> specifies the length of the record, and the structure element "
"I<bval> is used as the pad character.  Any records, inserted into the "
"database, that are less than I<reclen> bytes long are automatically padded."
msgstr ""
"Записи фиксированной длины без разделительного байта. Полем I<reclen> "
"определяется длина записи, а поле I<bval> используется как дополняющий "
"символ. Все вставляемые в базу данных записи, размер которых меньше I<reclen> "
"байт, автоматически дополняются."

#. type: TP
#: man-pages/man3/recno.3:109
#, no-wrap
msgid "B<R_NOKEY>"
msgstr "B<R_NOKEY>"

#. type: Plain text
#: man-pages/man3/recno.3:122
msgid ""
"In the interface specified by B<dbopen>(3), the sequential record retrieval "
"fills in both the caller's key and data structures.  If the B<R_NOKEY> flag "
"is specified, the I<cursor> routines are not required to fill in the key "
"structure.  This permits applications to retrieve records at the end of "
"files without reading all of the intervening records."
msgstr ""
"В интерфейсе, определённом B<dbopen>(3), последовательная выборка записей "
"заполняет структуры данных и ключа вызывающего. Если указан флаг B<R_NOKEY>, "
"то процедурам I<cursor> не обязательно заполнять структуру ключа. Это "
"позволяет приложениям извлекать записи из конца файлов без чтения всех "
"промежуточных записей."

#. type: TP
#: man-pages/man3/recno.3:122
#, no-wrap
msgid "B<R_SNAPSHOT>"
msgstr "B<R_SNAPSHOT>"

#. type: Plain text
#: man-pages/man3/recno.3:128
msgid ""
"This flag requires that a snapshot of the file be taken when B<dbopen>(3)  "
"is called, instead of permitting any unmodified records to be read from the "
"original file."
msgstr ""
"Этим флагом указывается, чтобы в момент вызова B<dbopen>(3) был сделан снимок "
"(snapshot) файла, а не выполнялось чтение каких-либо не изменённых записей из "
"оригинального файла."

#. type: TP
#: man-pages/man3/recno.3:129
#, no-wrap
msgid "I<cachesize>"
msgstr "I<cachesize>"

#. type: Plain text
#: man-pages/man3/recno.3:138
msgid ""
"A suggested maximum size, in bytes, of the memory cache.  This value is "
"B<only> advisory, and the access method will allocate more memory rather "
"than fail.  If I<cachesize> is 0 (no size is specified), a default cache is "
"used."
msgstr ""
"Предполагаемый максимальный размер кэша памяти в байтах. Эта величина I<"
"только рекомендация>, метод доступа скорее выделит больше памяти, чем "
"завершится с ошибкой. Если значение I<cachesize> равно 0 (размер не указан), "
"то используется кэш по умолчанию."

#. type: TP
#: man-pages/man3/recno.3:138
#, no-wrap
msgid "I<psize>"
msgstr "I<psize>"

#. type: Plain text
#: man-pages/man3/recno.3:150
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  This value is the size (in bytes) of the pages used for nodes in "
"that tree.  If I<psize> is 0 (no page size is specified), a page size is "
"chosen based on the underlying filesystem I/O block size.  See B<btree>(3)  "
"for more information."
msgstr ""
"Метод доступа recno хранит копии своих записей в памяти в виде дерева btree. "
"Это значение задаёт размер страниц (в байтах), используемых для узлов в этом "
"дереве. Если значение I<psize> равно 0 (размер страницы не указан), то размер "
"выбирается на основе размера блока ввода-вывода нижележащей файловой системы. "
"Подробней смотрите B<btree>(3)."

#. type: TP
#: man-pages/man3/recno.3:150
#, no-wrap
msgid "I<lorder>"
msgstr "I<lorder>"

#. type: Plain text
#: man-pages/man3/recno.3:158
msgid ""
"The byte order for integers in the stored database metadata.  The number "
"should represent the order as an integer; for example, big endian order "
"would be the number 4,321.  If I<lorder> is 0 (no order is specified), the "
"current host order is used."
msgstr ""
"Порядок расположения байтов, используемый при хранении целых чисел в "
"метаданных базы данных. Число должно отражать порядок размещения в виде "
"целого значения; например, порядок «big  endian» должен обозначаться числом "
"4321. Если I<lorder> равно 0 (порядок не определён), то используется значение "
"по умолчанию, принятое на машине."

#. type: TP
#: man-pages/man3/recno.3:158
#, no-wrap
msgid "I<reclen>"
msgstr "I<reclen>"

#. type: Plain text
#: man-pages/man3/recno.3:161
msgid "The length of a fixed-length record."
msgstr "Длина записи фиксированной длины."

#. type: TP
#: man-pages/man3/recno.3:161
#, no-wrap
msgid "I<bval>"
msgstr "I<bval>"

#. type: Plain text
#: man-pages/man3/recno.3:169
msgid ""
"The delimiting byte to be used to mark the end of a record for variable-"
"length records, and the pad character for fixed-length records.  If no value"
" is specified, newlines (\"\\en\") are used to mark the end of variable-"
"length records and fixed-length records are padded with spaces."
msgstr ""
"Разделительный байт, для использования в качестве отметки конца записи с "
"переменной длиной и как заполняющий символ для записи с фиксированной длиной. "
"Если значение не указано, то для отметки конца записи с переменной длиной "
"используется символ новой строки («\\en»), а записи с фиксированной длиной "
"дополняются пробелом."

#. type: TP
#: man-pages/man3/recno.3:169
#, no-wrap
msgid "I<bfname>"
msgstr "I<bfname>"

#. type: Plain text
#: man-pages/man3/recno.3:179
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  If I<bfname> is non-NULL, it specifies the name of the btree file, "
"as if specified as the filename for a B<dbopen>(3)  of a btree file."
msgstr ""
"Метод доступа recno хранит в памяти копии своих записей в дереве btree. Если "
"значение I<bfname> не равно NULL, то им задаётся имя btree-файла в том же "
"виде, что и при доступе B<dbopen>(3) для доступа к btree-файлу."

#. type: Plain text
#: man-pages/man3/recno.3:197
msgid ""
"The data part of the key/data pair used by the I<recno> access method is the"
" same as other access methods.  The key is different.  The I<data> field of "
"the key should be a pointer to a memory location of type I<recno_t>, as "
"defined in the I<E<lt>db.hE<gt>> include file.  This type is normally the "
"largest unsigned integral type available to the implementation.  The I<size>"
" field of the key should be the size of that type."
msgstr ""
"Часть «данные» из пары ключ/данные, используемая методом доступа I<recno>, "
"является такой же, как в других методах доступа. Ключ используется иначе. Как "
"следует из определения заголовочного файла I<E<lt>db.hE<gt>>, поле ключа I<"
"data> должно быть указателем на расположение памяти типа I<recno_t>. Этот "
"тип, обычно, является наибольшим беззнаковым целочисленным типом данных, "
"применяемым в реализации. Значение поля ключа I<size> должен задавать размер "
"этого типа."

#. type: Plain text
#: man-pages/man3/recno.3:202
msgid ""
"Because there can be no metadata associated with the underlying recno access"
" method files, any changes made to the default values (e.g., fixed record "
"length or byte separator value) must be explicitly specified each time the "
"file is opened."
msgstr ""
"Так как в файлах с данными в формате recno могут отсутствовать метаданные, то "
"любые изменения значений по умолчанию (например, длина фиксированной записи "
"или разделяющий байт) должны явно указываться каждый раз при открытии файла."

#. type: Plain text
#: man-pages/man3/recno.3:210
msgid ""
"In the interface specified by B<dbopen>(3), using the I<put> interface to "
"create a new record will cause the creation of multiple, empty records if "
"the record number is more than one greater than the largest record currently"
" in the database."
msgstr ""
"В интерфейсе, определённым B<dbopen>(3), использование интерфейса I<put> для "
"создания новой записи повлечёт за собой создание множества пустых записей, "
"если номер записи больше, чем номер наибольшей записи, имеющейся в базе "
"данных."

#. type: Plain text
#: man-pages/man3/recno.3:218
msgid ""
"The I<recno> access method routines may fail and set I<errno> for any of the"
" errors specified for the library routine B<dbopen>(3)  or the following:"
msgstr ""
"Функции метода доступа I<recno> могут завершиться с ошибкой и присвоить I<"
"errno> любое значение из определённых для библиотеки функций B<dbopen>(3), а "
"также:"

#. type: Plain text
#: man-pages/man3/recno.3:222
msgid ""
"An attempt was made to add a record to a fixed-length database that was too "
"large to fit."
msgstr ""
"Попытка добавить слишком большую запись в базу данных фиксированной длины."

#. type: Plain text
#: man-pages/man3/recno.3:224
msgid "Only big and little endian byte order is supported."
msgstr "Поддерживаются значения только с прямым и обратным порядком байт."

#. type: Plain text
#: man-pages/man3/recno.3:229
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"
msgstr "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"

#. type: Plain text
#: man-pages/man3/recno.3:232
msgid ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker,"
" Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No."
" UCB/ERL M82/32, May 1982."
msgstr ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker, "
"Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No. "
"UCB/ERL M82/32, May 1982."

#. type: TH
#: man-pages/man3/re_comp.3:27
#, no-wrap
msgid "RE_COMP"
msgstr "RE_COMP"

#. type: Plain text
#: man-pages/man3/re_comp.3:30
msgid "re_comp, re_exec - BSD regex functions"
msgstr "re_comp, re_exec - функции BSD для регулярных выражений"

#. type: Plain text
#: man-pages/man3/re_comp.3:32
msgid "B<#define _REGEX_RE_COMP>"
msgstr "B<#define _REGEX_RE_COMP>"

#. type: Plain text
#: man-pages/man3/re_comp.3:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man3/re_comp.3:36
msgid "B<#include E<lt>regex.hE<gt>>"
msgstr "B<#include E<lt>regex.hE<gt>>"

#. type: Plain text
#: man-pages/man3/re_comp.3:38
msgid "B<char *re_comp(const char *>I<regex>B<);>"
msgstr "B<char *re_comp(const char *>I<regex>B<);>"

#. type: Plain text
#: man-pages/man3/re_comp.3:40
msgid "B<int re_exec(const char *>I<string>B<);>"
msgstr "B<int re_exec(const char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/re_comp.3:52
msgid ""
"B<re_comp>()  is used to compile the null-terminated regular expression "
"pointed to by I<regex>.  The compiled pattern occupies a static area, the "
"pattern buffer, which is overwritten by subsequent use of B<re_comp>().  If "
"I<regex> is NULL, no operation is performed and the pattern buffer's "
"contents are not altered."
msgstr ""
"Функция B<re_comp>() используется для компиляции регулярного выражения "
"(завершающегося null), указанного I<regex>. Скомпилированный шаблон "
"располагается в статической области (буфере шаблонов), которая "
"перезаписывается заново каждый раз при вызове B<re_comp>(). Если значение I<"
"regex> равно NULL, то действие не выполняется и содержимое буфера шаблонов "
"остаётся неизменным."

#. type: Plain text
#: man-pages/man3/re_comp.3:58
msgid ""
"B<re_exec>()  is used to assess whether the null-terminated string pointed "
"to by I<string> matches the previously compiled I<regex>."
msgstr ""
"Функция B<re_exec>() используется для проверки совпадения строки (завершается "
"null), на которую указывает I<string>, с предварительно скомпилированным I<"
"regex>."

#. type: Plain text
#: man-pages/man3/re_comp.3:63
msgid ""
"B<re_comp>()  returns NULL on successful compilation of I<regex> otherwise "
"it returns a pointer to an appropriate error message."
msgstr ""
"Функция B<re_comp>() возвращает NULL при успешной компиляции I<regex> или "
"указатель на соответствующее сообщение об ошибке."

#. type: Plain text
#: man-pages/man3/re_comp.3:66
msgid "B<re_exec>()  returns 1 for a successful match, zero for failure."
msgstr ""
"Функция B<re_exec>() возвращает 1 при совпадении или 0, если совпадения не "
"было."

#. type: Plain text
#: man-pages/man3/re_comp.3:73
msgid "The B<re_comp>()  and B<re_exec>()  functions are not thread-safe."
msgstr ""
"Функции B<re_comp>() и B<re_exec>() нельзя использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/re_comp.3:79
msgid ""
"These functions are obsolete; the functions documented in B<regcomp>(3)  "
"should be used instead."
msgstr ""
"Эти функции устарели; вместо них следует использовать функции, описанные в B<"
"regcomp>(3)."

#. type: Plain text
#: man-pages/man3/re_comp.3:82
msgid "B<regcomp>(3), B<regex>(7), GNU regex manual"
msgstr "B<regcomp>(3), B<regex>(7), руководство по регулярным выражениям GNU"

#. type: TH
#: man-pages/man3/rexec.3:41
#, no-wrap
msgid "REXEC"
msgstr "REXEC"

#. type: Plain text
#: man-pages/man3/rexec.3:44
msgid "rexec, rexec_af - return stream to a remote command"
msgstr "rexec, rexec_af - возвращает поток удалённой команде"

#. type: Plain text
#: man-pages/man3/rexec.3:48
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""
"B<#define _BSD_SOURCE>             /* См. макрос feature_test(7) */\nB<"
"#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/rexec.3:51
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<"
");>\n"
msgstr ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >"
"\nB<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/rexec.3:55
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >"
"\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>"
"B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >"
"\nB<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<"
"fd2p>B<,>\nB<             sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rexec.3:59
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr "Этот интерфейс устарел, используйте B<rcmd>(3)."

#. type: Plain text
#: man-pages/man3/rexec.3:78
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host.  If a username and "
"password are both specified, then these are used to authenticate to the "
"foreign host; otherwise the environment and then the I<.netrc> file in "
"user's home directory are searched for appropriate information.  If all this"
" fails, the user is prompted for the information."
msgstr ""
"Функция B<rexec>() ищет узел I<*ahost>, используя B<gethostbyname>(3), и "
"возвращает -1, если узел не существует. В противном случае, I<*ahost> "
"присваивается стандартное имя узла. Если указаны имя пользователя и пароль, "
"то они используются для аутентификации на другом узле; иначе происходит поиск "
"соответствующей информации в окружении и затем в файле I<.netrc>, находящемся "
"в домашнем каталоге пользователя. Если всё это заканчивается с ошибкой, "
"пользователь извещается об этом."

#. type: Plain text
#: man-pages/man3/rexec.3:89
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for"
" the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""
"В I<inport> указывается, какой хорошо известный (well-known) порт DARPA "
"Internet нужно использовать для подключения; вызов I<getservbyname(\"exec\", "
"\"tcp\")> (смотрите B<getservent>(3)) вернёт указатель на структуру, которая "
"содержит необходимый порт. Протокол подключения подробно описан в B<rexecd>"
"(8)."

#. type: Plain text
#: man-pages/man3/rexec.3:122
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as"
" I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel "
"to a control process will be setup, and a descriptor for it will be placed "
"in I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel"
" as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  The diagnostic information returned does not include remote "
"authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr ""
"Если соединение успешно установлено, то вызывающему возвращается сокет в "
"Интернет-домене типа B<SOCK_STREAM>, который для удалённой команды считается "
"I<stdin> и I<stdout>. Если I<fd2p> не равно нулю, то устанавливается "
"вспомогательный канал до управляющего процесса, а его дескриптор будет "
"помещён в I<*fd2p>. Управляющий процесс возвращает диагностический вывод из "
"команды (устройства 2) в этот канал, а также принимает байты из этого канала, "
"считая их номерами сигналов UNIX, для их пересылки группе процессов команды. "
"Возвращаемая диагностическая информация не содержит ошибки удалённой "
"авторизации, так как второе подключение устанавливается после прохождения "
"авторизации. Если I<fd2p> равно 0, то I<stderr> (устройство 2 удалённой "
"команды) будет работать аналогично I<stdout> и для отправки произвольных "
"сигналов в удалённый процесс ничего не будет сделано, хотя вы сможете "
"привлечь к себе внимание, используя внеполосную передачу данных."

#. type: SS
#: man-pages/man3/rexec.3:122
#, no-wrap
msgid "rexec_af()"
msgstr "rexec_af()"

#. type: Plain text
#: man-pages/man3/rexec.3:138
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""
"Функция B<rexec>() работает по протоколу IPv4 (B<AF_INET>). В отличие от неё, "
"B<rexec_af>() предоставляет ещё один аргумент, I<af>, который позволяет "
"вызывающему выбрать протокол. В этом аргументе можно указать значения B<"
"AF_INET>, B<AF_INET6> или B<AF_UNSPEC> (чтобы позволить реализации выбирать "
"протокол)."

#. type: Plain text
#: man-pages/man3/rexec.3:142
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr "Функция B<rexec_af>() впервые появилась в glibc 2.2."

#. type: Plain text
#: man-pages/man3/rexec.3:149
msgid "The B<rexec>()  and B<rexec_af>()  functions are not thread-safe."
msgstr ""
"Функции B<rexec>() и B<rexec_af>() нельзя использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/rexec.3:158
msgid ""
"These functions are not in POSIX.1-2001.  The B<rexec>()  function first "
"appeared in 4.2BSD, and is present on the BSDs, Solaris, and many other "
"systems.  The B<rexec_af>()  function is more recent, and less widespread."
msgstr ""
"Данные функции отсутствуют в POSIX.1-2001. Функция B<rexec>() впервые "
"появилась в 4.2BSD, и есть в разных BSD, Solaris и других системах. Функция "
"B<rexec_af>() более новая и распространена гораздо меньше."

#. type: Plain text
#: man-pages/man3/rexec.3:162
msgid ""
"The B<rexec>()  function sends the unencrypted password across the network."
msgstr "Функция B<rexec>() посылает пароль через сеть в нешифрованном виде."

#. type: Plain text
#: man-pages/man3/rexec.3:167
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""
"Считается, что лежащая в основе служба является большой дырой в безопасности, "
"и поэтому не включена на большинстве сайтов; смотрите объяснение в B<rexecd>"
"(8)."

#. type: Plain text
#: man-pages/man3/rexec.3:169
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr "B<rcmd>(3), B<rexecd>(8)"

#. type: TH
#: man-pages/man3/rtime.3:12
#, no-wrap
msgid "RTIME"
msgstr "RTIME"

#. type: Plain text
#: man-pages/man3/rtime.3:15
msgid "rtime - get time from a remote machine"
msgstr "rtime - получение времени с удалённого узла"

#. type: Plain text
#: man-pages/man3/rtime.3:18
#, no-wrap
msgid "B<#include E<lt>rpc/auth_des.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/auth_des.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/rtime.3:21
#, no-wrap
msgid ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>"
"\n"
"B<          struct rpc_timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>"
"\nB<          struct rpc_timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/rtime.3:25
msgid ""
"This function uses the Time Server Protocol as described in RFC\\ 868 to "
"obtain the time from a remote machine."
msgstr ""
"Для получения времени с удалённого компьютера функция использует протокол "
"Time Server Protocol, описанный в RFC\\ 868."

#. type: Plain text
#: man-pages/man3/rtime.3:31
msgid ""
"The Time Server Protocol gives the time in seconds since 00:00:00 UTC, 1 Jan"
" 1900, and this function subtracts the appropriate constant in order to "
"convert the result to seconds since the Epoch, 1970-01-01 00:00:00 +0000 "
"(UTC)."
msgstr ""
"Time Server Protocol возвращает время в секундах начиная с 1 января 1900 года "
"00:00:00 UTC. Данная функция самостоятельно вычитает подходящую константу для "
"того, чтобы преобразовать результат в секундах от начала Эпохи \\(em "
"1970-01-01 00:00:00 +0000 (UTC)."

#. type: Plain text
#: man-pages/man3/rtime.3:36
msgid ""
"When I<timeout> is non-NULL, the udp/time socket (port 37) is used.  "
"Otherwise, the tcp/time socket (port 37) is used."
msgstr ""
"Если I<timeout> не равно NULL, то будет использоваться сокет udp/time (порт "
"37), иначе \\(em сокет tcp/time (порт 37)."

#. type: Plain text
#: man-pages/man3/rtime.3:42
msgid ""
"On success, 0 is returned, and the obtained 32-bit time value is stored in "
"I<timep-E<gt>tv_sec>.  In case of error -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0, а полученное 32-битное значение "
"времени сохраняется в I<timep-E<gt>tv_sec>. В случае ошибки возвращается -1, "
"а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/rtime.3:51
msgid ""
"All errors for underlying functions (B<sendto>(2), B<poll>(2), "
"B<recvfrom>(2), B<connect>(2), B<read>(2))  can occur.  Moreover:"
msgstr ""
"Могут возникнуть все ошибки задействованных в работе функций (B<sendto>(2), "
"B<poll>(2), B<recvfrom>(2), B<connect>(2), B<read>(2)), а также:"

#. type: Plain text
#: man-pages/man3/rtime.3:54
msgid "The number of returned bytes is not 4."
msgstr "Количество возвращённых байт не равно 4."

#. type: TP
#: man-pages/man3/rtime.3:54
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man3/rtime.3:57
msgid "The waiting time as defined in timeout has expired."
msgstr "Время ожидания, указанное в таймауте, превышено."

#. type: Plain text
#: man-pages/man3/rtime.3:62
msgid "The B<rtime>()  function is thread-safe."
msgstr "Функцию B<rtime>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/rtime.3:64
msgid "Only IPv4 is supported."
msgstr "Поддерживается только IPv4."

#. type: Plain text
#: man-pages/man3/rtime.3:71
msgid ""
"Some I<in.timed> versions support only TCP.  Try the example program with "
"I<use_tcp> set to 1."
msgstr ""
"Некоторые версии I<in.timed> поддерживают только TCP. Попробуйте пример "
"программы с установленной в 1 значением I<use_tcp>."

#. type: Plain text
#: man-pages/man3/rtime.3:73
msgid "Libc5 uses the prototype"
msgstr "В libc5 используется прототип"

#. type: Plain text
#: man-pages/man3/rtime.3:76
#, no-wrap
msgid ""
"    int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);\n"
msgstr ""
"    int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);\n"

#. type: Plain text
#: man-pages/man3/rtime.3:82
msgid ""
"and requires I<E<lt>sys/time.hE<gt>> instead of I<E<lt>rpc/auth_des.hE<gt>>."
msgstr ""
"для которого требуется I<E<lt>sys/time.hE<gt>> вместо I<E<lt>rpc/auth_des.hE<"
"gt>>."

#. type: Plain text
#: man-pages/man3/rtime.3:85
msgid ""
"B<rtime>()  in glibc 2.2.5 and earlier does not work properly on 64-bit "
"machines."
msgstr ""
"B<rtime>() в glibc 2.2.5 и ниже на 64-битных компьютерах работает некорректно."

#. type: Plain text
#: man-pages/man3/rtime.3:91
msgid ""
"This example requires that port 37 is up and open.  You may check that the "
"time entry within I</etc/inetd.conf> is not commented out."
msgstr ""
"Для этого примера требуется поднятие и открытие порта 37. Вы можете проверить "
"это, убедившись в том, что в файле I</etc/inetd.conf> запись time "
"раскомментирована."

#. type: Plain text
#: man-pages/man3/rtime.3:95
msgid ""
"The program connects to a computer called \"linux\".  Using \"localhost\" "
"does not work.  The result is the localtime of the computer \"linux\"."
msgstr ""
"Программа подключается к компьютеру с именем «linux». Использование "
"«localhost» не сработает. В качестве результата будет возвращено локальное "
"время компьютера «linux»."

#. type: Plain text
#: man-pages/man3/rtime.3:104
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>rpc/auth_des.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"errno.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>time.hE<gt>"
"\n#include E<lt>rpc/auth_des.hE<gt>\n#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rtime.3:107
#, no-wrap
msgid ""
"static int use_tcp = 0;\n"
"static char *servername = \"linux\";\n"
msgstr "static int use_tcp = 0;\nstatic char *servername = \"linux\";\n"

#. type: Plain text
#: man-pages/man3/rtime.3:116
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sockaddr_in name;\n"
"    struct rpc_timeval time1 = {0,0};\n"
"    struct rpc_timeval timeout = {1,0};\n"
"    struct hostent *hent;\n"
"    int ret;\n"
msgstr ""
"int\nmain(void)\n{\n    struct sockaddr_in name;\n    struct rpc_timeval "
"time1 = {0,0};\n    struct rpc_timeval timeout = {1,0};\n    struct hostent "
"*hent;\n    int ret;\n"

#. type: Plain text
#: man-pages/man3/rtime.3:121
#, no-wrap
msgid ""
"    memset(&name, 0, sizeof(name));\n"
"    sethostent(1);\n"
"    hent = gethostbyname(servername);\n"
"    memcpy(&name.sin_addr, hent-E<gt>h_addr, hent-E<gt>h_length);\n"
msgstr ""
"    memset(&name, 0, sizeof(name));\n    sethostent(1);\n    hent = "
"gethostbyname(servername);\n    memcpy(&name.sin_addr, hent-E<gt>h_addr, "
"hent-E<gt>h_length);\n"

#. type: Plain text
#: man-pages/man3/rtime.3:129
#, no-wrap
msgid ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n"
"    if (ret E<lt> 0)\n"
"        perror(\"rtime error\");\n"
"    else {\n"
"        time_t t = time1.tv_sec;\n"
"        printf(\"%s\\en\", ctime(&t));\n"
"    }\n"
msgstr ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n    if (ret E<lt> "
"0)\n        perror(\"ошибка rtime\");\n    else {\n        time_t t = "
"time1.tv_sec;\n        printf(\"%s\\en\", ctime(&t));\n    }\n"

#.  .BR netdate (1),
#.  .BR rdate (1),
#. type: Plain text
#: man-pages/man3/rtime.3:137
msgid "B<ntpdate>(1), B<inetd>(8)"
msgstr "B<ntpdate>(1), B<inetd>(8)"

#. type: TH
#: man-pages/man3/raise.3:29
#, no-wrap
msgid "RAISE"
msgstr "RAISE"

#. type: Plain text
#: man-pages/man3/raise.3:32
msgid "raise - send a signal to the caller"
msgstr "raise - посылает сигнал вызывающему"

#. type: Plain text
#: man-pages/man3/raise.3:35
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/raise.3:37
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr "B<int raise(int >I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/raise.3:43
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""
"Функция B<raise>() посылает сигнал вызвавшему процессу или нити. В "
"однонитевых программах это эквивалентно"

#. type: Plain text
#: man-pages/man3/raise.3:47
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr "kill(getpid(), sig);\n"

#. type: Plain text
#: man-pages/man3/raise.3:51
msgid "In a multithreaded program it is equivalent to"
msgstr "В многонитивых программах это эквивалентно"

#. type: Plain text
#: man-pages/man3/raise.3:55
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr "pthread_kill(pthread_self(), sig);\n"

#. type: Plain text
#: man-pages/man3/raise.3:61
msgid ""
"If the signal causes a handler to be called, B<raise>()  will return only "
"after the signal handler has returned."
msgstr ""
"Если из-за сигнала вызвался обработчик, то B<raise>() вернёт управление "
"только после завершения обработчика сигнала."

#. type: Plain text
#: man-pages/man3/raise.3:64
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr ""
"При успешном выполнении функция B<raise>() возвращает 0 или иное значение при "
"ошибке."

#. type: Plain text
#: man-pages/man3/raise.3:69
msgid "The B<raise>()  function is thread-safe."
msgstr "Функцию B<raise>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/raise.3:71
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#.  2.3.2 used the obsolete tkill(), if available.
#. type: Plain text
#: man-pages/man3/raise.3:82
msgid ""
"Since version 2.3.3, glibc implements B<raise>()  by calling B<tgkill>(2), "
"if the kernel supports that system call.  Older glibc versions implemented "
"B<raise>()  using B<kill>(2)."
msgstr ""
"Начиная с версии 2.3.3 glibc реализует B<raise>() с помощью B<tgkill>(2), "
"если ядро поддерживает этот системный вызов. Предыдущие версии glibc "
"реализовали B<raise>() с помощью B<kill>(2)."

#. type: Plain text
#: man-pages/man3/raise.3:88
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3),"
" B<signal>(7)"
msgstr ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"

#. type: TH
#: man-pages/man3/realpath.3:28
#, no-wrap
msgid "REALPATH"
msgstr "REALPATH"

#. type: Plain text
#: man-pages/man3/realpath.3:31
msgid "realpath - return the canonicalized absolute pathname"
msgstr "realpath - возвращает канонизированный абсолютный путь"

#. type: Plain text
#: man-pages/man3/realpath.3:35
#, no-wrap
msgid ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>limits.hE<gt>>\nB<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/realpath.3:37
#, no-wrap
msgid "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"
msgstr ""
"B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"

#. type: Plain text
#: man-pages/man3/realpath.3:45
msgid "B<realpath>():"
msgstr "B<realpath>():"

#. type: Plain text
#: man-pages/man3/realpath.3:49
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/realpath.3:71
msgid ""
"B<realpath>()  expands all symbolic links and resolves references to I</./>,"
" I</../> and extra \\(aq/\\(aq characters in the null-terminated string "
"named by I<path> to produce a canonicalized absolute pathname.  The "
"resulting pathname is stored as a null-terminated string, up to a maximum of"
" B<PATH_MAX> bytes, in the buffer pointed to by I<resolved_path>.  The "
"resulting path will have no symbolic link, I</./> or I</../> components."
msgstr ""
"Функция B<realpath>() раскрывает все символьные ссылки, конструкции I</./>, "
"I</../> и дополнительные символы «/» в строке I<path> (завершается null) для "
"создания канонического абсолютного пути. Получившееся имя сохраняется в виде "
"строки (с null на конце) не длиннее чем B<PATH_MAX> байт в буфере, указанном "
"в I<resolved_path>. Конечный путь не содержит символьных ссылок и компонентов "
"I</./> или I</../>."

#.  Even if we use resolved_path == NULL, then realpath() will still
#.  return ENAMETOOLONG if the resolved pathname would exceed PATH_MAX
#.  bytes -- MTK, Dec 04
#.  .SH HISTORY
#.  The
#.  .BR realpath ()
#.  function first appeared in 4.4BSD, contributed by Jan-Simon Pendry.
#. type: Plain text
#: man-pages/man3/realpath.3:91
msgid ""
"If I<resolved_path> is specified as NULL, then B<realpath>()  uses "
"B<malloc>(3)  to allocate a buffer of up to B<PATH_MAX> bytes to hold the "
"resolved pathname, and returns a pointer to this buffer.  The caller should "
"deallocate this buffer using B<free>(3)."
msgstr ""
"Если значение I<resolved_path> равно NULL, то B<realpath>() выделяет буфер "
"размером B<PATH_MAX> байт с помощью B<malloc>(3) для хранения полного пути и "
"возвращает указатель на этот буфер. Вызывающий должен освободить буфер с "
"помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/realpath.3:96
msgid ""
"If there is no error, B<realpath>()  returns a pointer to the "
"I<resolved_path>."
msgstr ""
"При успешном выполнении B<realpath>() возвращает указатель на I<resolved_path>"
"."

#. type: Plain text
#: man-pages/man3/realpath.3:103
msgid ""
"Otherwise, it returns NULL, the contents of the array I<resolved_path> are "
"undefined, and I<errno> is set to indicate the error."
msgstr ""
"При ошибках возвращается NULL, содержимое массива I<resolved_path> не "
"определено и в I<errno> указывается код ошибки."

#. type: Plain text
#: man-pages/man3/realpath.3:107
msgid ""
"Read or search permission was denied for a component of the path prefix."
msgstr "Запрещено чтение или поиск для компонента, содержащегося в пути."

#.  (In libc5 this would just cause a segfault.)
#. type: Plain text
#: man-pages/man3/realpath.3:116
msgid ""
"I<path> is NULL.  (In glibc versions before 2.3, this error is also returned"
" if I<resolved_path> is NULL.)"
msgstr ""
"Значение I<path> равно NULL (в glibc до версии 2.3 эта ошибка также "
"возвращалась и при I<resolved_path> равном NULL)."

#. type: Plain text
#: man-pages/man3/realpath.3:129
msgid ""
"A component of a pathname exceeded B<NAME_MAX> characters, or an entire "
"pathname exceeded B<PATH_MAX> characters."
msgstr ""
"Компонент имени пути более B<NAME_MAX> символов, или весь путь более B<"
"PATH_MAX> символов."

#. type: Plain text
#: man-pages/man3/realpath.3:137
msgid "On Linux, this function appeared in libc 4.5.21."
msgstr "В Linux эта функция появилась в libc 4.5.21."

#. type: Plain text
#: man-pages/man3/realpath.3:139
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/realpath.3:144
msgid ""
"POSIX.1-2001 says that the behavior if I<resolved_path> is NULL is "
"implementation-defined.  POSIX.1-2008 specifies the behavior described in "
"this page."
msgstr ""
"В POSIX.1-2001 сказано, что поведение при значении I<resolved_path> равном "
"NULL, зависит от реализации. В POSIX.1-2008 определено поведение, аналогичное "
"описанию на этой странице."

#. type: Plain text
#: man-pages/man3/realpath.3:156
msgid ""
"In 4.4BSD and Solaris, the limit on the pathname length is B<MAXPATHLEN> "
"(found in I<E<lt>sys/param.hE<gt>>).  SUSv2 prescribes B<PATH_MAX> and "
"B<NAME_MAX>, as found in I<E<lt>limits.hE<gt>> or provided by the "
"B<pathconf>(3)  function.  A typical source fragment would be"
msgstr ""
"В 4.4BSD и Solaris максимальная длина пути равна B<MAXPATHLEN> (находится в "
"I<E<lt>sys/param.hE<gt>>). В SUSv2 величины B<PATH_MAX> и B<NAME_MAX> "
"представлены в I<E<lt>limits.hE<gt>> или предоставляются функцией B<pathconf>"
"(3). Вот типичный фрагмент кода:"

#. type: Plain text
#: man-pages/man3/realpath.3:166
#, no-wrap
msgid ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"
msgstr ""
"#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = pathconf(path, "
"_PC_PATH_MAX);\n  if (path_max E<lt>= 0)\n    path_max = 4096;\n#endif\n"

#. type: Plain text
#: man-pages/man3/realpath.3:170
msgid "(But see the BUGS section.)"
msgstr "(Но смотрите раздел ДЕФЕКТЫ)"

#.      2012-05-05, According to Casper Dik, the statement about
#.      Solaris was not true at least as far back as 1997, and
#.      may never have been true.
#.  The 4.4BSD, Linux and SUSv2 versions always return an absolute
#.  pathname.
#.  Solaris may return a relative pathname when the
#.  .I path
#.  argument is relative.
#. type: Plain text
#: man-pages/man3/realpath.3:184
msgid ""
"The prototype of B<realpath>()  is given in I<E<lt>unistd.hE<gt>> in libc4 "
"and libc5, but in I<E<lt>stdlib.hE<gt>> everywhere else."
msgstr ""
"Прототип B<realpath>() для libc4 и libc5 находится в I<E<lt>unistd.hE<gt>>, "
"но везде он описан в I<E<lt>stdlib.hE<gt>>."

#. type: SS
#: man-pages/man3/realpath.3:184
#, no-wrap
msgid "GNU extensions"
msgstr "Расширения GNU"

#. type: Plain text
#: man-pages/man3/realpath.3:195
msgid ""
"If the call fails with either B<EACCES> or B<ENOENT> and I<resolved_path> is"
" not NULL, then the prefix of I<path> that is not readable or does not exist"
" is returned in I<resolved_path>."
msgstr ""
"Если вызов завершается с ошибкой B<EACCES> или B<ENOENT> и значение I<"
"resolved_path> не равно NULL, то в I<resolved_path> возвращается начало не "
"читаемой или не существующей части I<path>."

#. type: Plain text
#: man-pages/man3/realpath.3:220
msgid ""
"The POSIX.1-2001 standard version of this function is broken by design, "
"since it is impossible to determine a suitable size for the output buffer, "
"I<resolved_path>.  According to POSIX.1-2001 a buffer of size B<PATH_MAX> "
"suffices, but B<PATH_MAX> need not be a defined constant, and may have to be"
" obtained using B<pathconf>(3).  And asking B<pathconf>(3)  does not really "
"help, since, on the one hand POSIX warns that the result of B<pathconf>(3)  "
"may be huge and unsuitable for mallocing memory, and on the other hand "
"B<pathconf>(3)  may return -1 to signify that B<PATH_MAX> is not bounded.  "
"The I<resolved_path\\ ==\\ NULL> feature, not standardized in POSIX.1-2001, "
"but standardized in POSIX.1-2008, allows this design problem to be avoided."
msgstr ""
"Стандартная версия этой функции POSIX.1-2001 некорректна изначально, так как "
"невозможно определить подходящий размер для буфера результата. В соответствии "
"с POSIX.1-2001 буфера размером B<PATH_MAX> должно хватить, но B<PATH_MAX> "
"может не задаваться константой, а получаться через функцию B<pathconf>(3). И "
"запрос B<pathconf>(3) особо не поможет, так как с одной стороны POSIX "
"предупреждает, что результат B<pathconf>(3) может быть слишком велик и не "
"пригоден для выделения памяти. С другой стороны, B<pathconf>(3) может "
"возвратить -1 для обозначения того, что B<PATH_MAX> неограничен. Свойство I<"
"resolved_path\\ ==\\ NULL>, не стандартизованное в POSIX.1-2001, но "
"стандартизованное в POSIX.1-2008, позволяет избежать этой проблемы "
"проектирования."

#. type: Plain text
#: man-pages/man3/realpath.3:226
msgid ""
"The libc4 and libc5 implementation contained a buffer overflow (fixed in "
"libc-5.4.13).  Thus, set-user-ID programs like B<mount>(8)  needed a private"
" version."
msgstr ""
"Реализации libc4 и libc5 содержат ошибку, вызывающую переполнение буфера "
"(исправлено в libc-5.4.13). Поэтому программы с установленным битом "
"set-user-ID, такие как B<mount>(8), нуждаются в собственной версии."

#. type: Plain text
#: man-pages/man3/realpath.3:231
msgid ""
"B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), B<pathconf>(3), "
"B<sysconf>(3)"
msgstr ""
"B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), B<pathconf>(3), "
"B<sysconf>(3)"

