# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:26+0300\n"
"PO-Revision-Date: 2019-09-19 02:26+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Vietnamese (Viet Nam) (http://www.transifex.com/kruvalig/man-pages/language/vi_VN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: vi_VN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "RANDOM"
msgstr ""

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man4/random.4:18
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:20
msgid "random, urandom - kernel random number source devices"
msgstr ""

#. type: SH
#: man-pages/man4/random.4:20
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:22
msgid "#include E<lt>linux/random.hE<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:24
msgid "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"
msgstr ""

#. type: SH
#: man-pages/man4/random.4:24
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:34
msgid ""
"The character special files I</dev/random> and I</dev/urandom> (present "
"since Linux 1.3.30)  provide an interface to the kernel's random number "
"generator.  The file I</dev/random> has major device number 1 and minor "
"device number 8.  The file I</dev/urandom> has major device number 1 and "
"minor device number 9."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:40
msgid ""
"The random number generator gathers environmental noise from device drivers "
"and other sources into an entropy pool.  The generator also keeps an "
"estimate of the number of bits of noise in the entropy pool.  From this "
"entropy pool, random numbers are created."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:47
msgid ""
"Linux 3.17 and later provides the simpler and safer B<getrandom>(2)  "
"interface which requires no special files; see the B<getrandom>(2)  manual "
"page for details."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:54
msgid ""
"When read, the I</dev/urandom> device returns random bytes using a "
"pseudorandom number generator seeded from the entropy pool.  Reads from this"
" device do not block (i.e., the CPU is not yielded), but can incur an "
"appreciable delay when requesting large amounts of data."
msgstr ""

#.  This is a real problem; see
#.  commit 9b4d008787f864f17d008c9c15bbe8a0f7e2fc24
#. type: Plain text
#: man-pages/man4/random.4:63
msgid ""
"When read during early boot time, I</dev/urandom> may return data prior to "
"the entropy pool being initialized.  If this is of concern in your "
"application, use B<getrandom>(2)  or I</dev/random> instead."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:71
msgid ""
"The I</dev/random> device is a legacy interface which dates back to a time "
"where the cryptographic primitives used in the implementation of "
"I</dev/urandom> were not widely trusted.  It will return random bytes only "
"within the estimated number of bits of fresh noise in the entropy pool, "
"blocking if necessary.  I</dev/random> is suitable for applications that "
"need high quality randomness, and can afford indeterminate delays."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:90
msgid ""
"When the entropy pool is empty, reads from I</dev/random> will block until "
"additional environmental noise is gathered.  If B<open>(2)  is called for "
"I</dev/random> with the B<O_NONBLOCK> flag, a subsequent B<read>(2)  will "
"not block if the requested number of bytes is not available.  Instead, the "
"available bytes are returned.  If no byte is available, B<read>(2)  will "
"return -1 and I<errno> will be set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:105
msgid ""
"The B<O_NONBLOCK> flag has no effect when opening I</dev/urandom>.  When "
"calling B<read>(2)  for the device I</dev/urandom>, reads of up to 256 bytes"
" will return as many bytes as are requested and will not be interrupted by a"
" signal handler.  Reads with a buffer over this limit may return less than "
"the requested number of bytes or fail with the error B<EINTR>, if "
"interrupted by a signal handler."
msgstr ""

#.  commit 79a8468747c5f95ed3d5ce8376a3e82e0c5857fc
#.  SEC_XFER_SIZE in drivers/char/random.c
#. type: Plain text
#: man-pages/man4/random.4:120
msgid ""
"Since Linux 3.16, a B<read>(2)  from I</dev/urandom> will return at most "
"32\\ MB.  A B<read>(2)  from I</dev/random> will return at most 512 bytes "
"(340 bytes on Linux kernels before version 2.6.12)."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:127
msgid ""
"Writing to I</dev/random> or I</dev/urandom> will update the entropy pool "
"with the data written, but this will not result in a higher entropy count.  "
"This means that it will impact the contents read from both files, but it "
"will not make reads from I</dev/random> faster."
msgstr ""

#. type: SS
#: man-pages/man4/random.4:127
#, no-wrap
msgid "Usage"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:138
msgid ""
"The I</dev/random> interface is considered a legacy interface, and "
"I</dev/urandom> is preferred and sufficient in all use cases, with the "
"exception of applications which require randomness during early boot time; "
"for these applications, B<getrandom>(2)  must be used instead, because it "
"will block until the entropy pool is initialized."
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:151
msgid ""
"If a seed file is saved across reboots as recommended below (all major Linux"
" distributions have done this since 2000 at least), the output is "
"cryptographically secure against attackers without local root access as soon"
" as it is reloaded in the boot sequence, and perfectly adequate for network "
"encryption session keys.  Since reads from I</dev/random> may block, users "
"will usually want to open it in nonblocking mode (or perform a read with "
"timeout), and provide some sort of user notification if the desired entropy "
"is not immediately available."
msgstr ""

#. type: SS
#: man-pages/man4/random.4:151
#, no-wrap
msgid "Configuration"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:155
msgid ""
"If your system does not have I</dev/random> and I</dev/urandom> created "
"already, they can be created with the following commands:"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:161
#, no-wrap
msgid ""
"mknod -m 666 /dev/random c 1 8\n"
"mknod -m 666 /dev/urandom c 1 9\n"
"chown root:root /dev/random /dev/urandom\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:172
msgid ""
"When a Linux system starts up without much operator interaction, the entropy"
" pool may be in a fairly predictable state.  This reduces the actual amount "
"of noise in the entropy pool below the estimate.  In order to counteract "
"this effect, it helps to carry entropy pool information across shut-downs "
"and start-ups.  To do this, add the lines to an appropriate script which is "
"run during the Linux system start-up sequence:"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:189
#, no-wrap
msgid ""
"echo \"Initializing random number generator...\"\n"
"random_seed=/var/run/random-seed\n"
"# Carry a random seed from start-up to start-up\n"
"# Load and then save the whole entropy pool\n"
"if [ -f $random_seed ]; then\n"
"    cat $random_seed E<gt>/dev/urandom\n"
"else\n"
"    touch $random_seed\n"
"fi\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:194
msgid ""
"Also, add the following lines in an appropriate script which is run during "
"the Linux system shutdown:"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:207
#, no-wrap
msgid ""
"# Carry a random seed from shut-down to start-up\n"
"# Save the whole entropy pool\n"
"echo \"Saving random seed...\"\n"
"random_seed=/var/run/random-seed\n"
"touch $random_seed\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:214
msgid ""
"In the above examples, we assume Linux 2.6.0 or later, where "
"I</proc/sys/kernel/random/poolsize> returns the size of the entropy pool in "
"bits (see below)."
msgstr ""

#. type: SS
#: man-pages/man4/random.4:214
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:220
msgid ""
"The files in the directory I</proc/sys/kernel/random> (present since 2.3.16)"
" provide additional information about the I</dev/random> device:"
msgstr ""

#. type: TP
#: man-pages/man4/random.4:220
#, no-wrap
msgid "I<entropy_avail>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:224
msgid ""
"This read-only file gives the available entropy, in bits.  This will be a "
"number in the range 0 to 4096."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:224
#, no-wrap
msgid "I<poolsize>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:229
msgid ""
"This file gives the size of the entropy pool.  The semantics of this file "
"vary across kernel versions:"
msgstr ""

#. type: TP
#: man-pages/man4/random.4:230
#, no-wrap
msgid "Linux 2.4:"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:237
msgid ""
"This file gives the size of the entropy pool in I<bytes>.  Normally, this "
"file will have the value 512, but it is writable, and can be changed to any "
"value for which an algorithm is available.  The choices are 32, 64, 128, "
"256, 512, 1024, or 2048."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:237
#, no-wrap
msgid "Linux 2.6 and later:"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:242
msgid ""
"This file is read-only, and gives the size of the entropy pool in I<bits>.  "
"It contains the value 4096."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:243
#, no-wrap
msgid "I<read_wakeup_threshold>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:250
msgid ""
"This file contains the number of bits of entropy required for waking up "
"processes that sleep waiting for entropy from I</dev/random>.  The default "
"is 64."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:250
#, no-wrap
msgid "I<write_wakeup_threshold>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:261
msgid ""
"This file contains the number of bits of entropy below which we wake up "
"processes that do a B<select>(2)  or B<poll>(2)  for write access to "
"I</dev/random>.  These values can be changed by writing to the files."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:261
#, no-wrap
msgid "I<uuid> and I<boot_id>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:268
msgid ""
"These read-only files contain random strings like 6fd5a44b-"
"35f4-4ad4-a9b9-6b9be13e1fe9.  The former is generated afresh for each read, "
"the latter was generated once."
msgstr ""

#. type: SS
#: man-pages/man4/random.4:268
#, no-wrap
msgid "ioctl(2) interface"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:279
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to either I</dev/random> or I</dev/urandom>.  All requests "
"performed will interact with the input entropy pool impacting both "
"I</dev/random> and I</dev/urandom>.  The B<CAP_SYS_ADMIN> capability is "
"required for all requests except B<RNDGETENTCNT>."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:279
#, no-wrap
msgid "B<RNDGETENTCNT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:286
msgid ""
"Retrieve the entropy count of the input pool, the contents will be the same "
"as the I<entropy_avail> file under proc.  The result will be stored in the "
"int pointed to by the argument."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:286
#, no-wrap
msgid "B<RNDADDTOENTCNT>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:290
msgid ""
"Increment or decrement the entropy count of the input pool by the value "
"pointed to by the argument."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:290
#, no-wrap
msgid "B<RNDGETPOOL>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:293
msgid "Removed in Linux 2.6.9."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:293
#, no-wrap
msgid "B<RNDADDENTROPY>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:301
msgid ""
"Add some additional entropy to the input pool, incrementing the entropy "
"count.  This differs from writing to I</dev/random> or I</dev/urandom>, "
"which only adds some data but does not increment the entropy count.  The "
"following structure is used:"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:309
#, no-wrap
msgid ""
"struct rand_pool_info {\n"
"    int    entropy_count;\n"
"    int    buf_size;\n"
"    __u32  buf[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:319
msgid ""
"Here I<entropy_count> is the value added to (or subtracted from) the entropy"
" count, and I<buf> is the buffer of size I<buf_size> which gets added to the"
" entropy pool."
msgstr ""

#. type: TP
#: man-pages/man4/random.4:319
#, no-wrap
msgid "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:323
msgid ""
"Zero the entropy count of all pools and add some system data (such as wall "
"clock) to the pools."
msgstr ""

#. type: SH
#: man-pages/man4/random.4:323
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:325
msgid "I</dev/random>"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:327
msgid "I</dev/urandom>"
msgstr ""

#. type: SH
#: man-pages/man4/random.4:327
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:331
msgid ""
"For an overview and comparison of the various interfaces that can be used to"
" obtain randomness, see B<random>(7)."
msgstr ""

#. type: SH
#: man-pages/man4/random.4:331
#, no-wrap
msgid "BUGS"
msgstr ""

#.  .SH AUTHOR
#.  The kernel's random number generator was written by
#.  Theodore Ts'o (tytso@athena.mit.edu).
#. type: Plain text
#: man-pages/man4/random.4:338
msgid ""
"During early boot time, reads from I</dev/urandom> may return data prior to "
"the entropy pool being initialized."
msgstr ""

#. type: SH
#: man-pages/man4/random.4:338
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:342
msgid "B<mknod>(1), B<getrandom>(2), B<random>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man4/random.4:343
msgid "RFC\\ 1750, \"Randomness Recommendations for Security\""
msgstr ""

#. type: TH
#: man-pages/man4/rtc.4:30
#, no-wrap
msgid "RTC"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:33
msgid "rtc - real-time clock"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:35
msgid "#include E<lt>linux/rtc.hE<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:37
msgid "B<int ioctl(>I<fd>B<, RTC_>I<request>B<, >I<param>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:39
msgid "This is the interface to drivers for real-time clocks (RTCs)."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:46
msgid ""
"Most computers have one or more hardware clocks which record the current "
"\"wall clock\" time.  These are called \"Real Time Clocks\" (RTCs).  One of "
"these usually has battery backup power so that it tracks the time even while"
" the computer is turned off.  RTCs often provide alarms and other "
"interrupts."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:51
msgid ""
"All i386 PCs, and ACPI-based systems, have an RTC that is compatible with "
"the Motorola MC146818 chip on the original PC/AT.  Today such an RTC is "
"usually integrated into the mainboard's chipset (south bridge), and uses a "
"replaceable coin-sized backup battery."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:55
msgid ""
"Non-PC systems, such as embedded systems built around system-on-chip "
"processors, use other implementations.  They usually won't offer the same "
"functionality as the RTC from a PC/AT."
msgstr ""

#. type: SS
#: man-pages/man4/rtc.4:55
#, no-wrap
msgid "RTC vs system clock"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:67
msgid ""
"RTCs should not be confused with the system clock, which is a software clock"
" maintained by the kernel and used to implement B<gettimeofday>(2)  and "
"B<time>(2), as well as setting timestamps on files, and so on.  The system "
"clock reports seconds and microseconds since a start point, defined to be "
"the POSIX Epoch: 1970-01-01 00:00:00 +0000 (UTC).  (One common "
"implementation counts timer interrupts, once per \"jiffy\", at a frequency "
"of 100, 250, or 1000 Hz.)  That is, it is supposed to report wall clock "
"time, which RTCs also do."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:77
msgid ""
"A key difference between an RTC and the system clock is that RTCs run even "
"when the system is in a low power state (including \"off\"), and the system "
"clock can't.  Until it is initialized, the system clock can only report time"
" since system boot ... not since the POSIX Epoch.  So at boot time, and "
"after resuming from a system low power state, the system clock will often be"
" set to the current wall clock time using an RTC.  Systems without an RTC "
"need to set the system clock using another clock, maybe across the network "
"or by entering that data manually."
msgstr ""

#. type: SS
#: man-pages/man4/rtc.4:77
#, no-wrap
msgid "RTC functionality"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:81
msgid ""
"RTCs can be read and written with B<hwclock>(8), or directly with the ioctl "
"requests listed below."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:84
msgid ""
"Besides tracking the date and time, many RTCs can also generate interrupts"
msgstr ""

#. type: IP
#: man-pages/man4/rtc.4:84 man-pages/man4/rtc.4:86 man-pages/man4/rtc.4:89
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:86
msgid "on every clock update (i.e., once per second);"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:89
msgid ""
"at periodic intervals with a frequency that can be set to any power-of-2 "
"multiple in the range 2 Hz to 8192 Hz;"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:91
msgid "on reaching a previously specified alarm time."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:100
msgid ""
"Each of those interrupt sources can be enabled or disabled separately.  On "
"many systems, the alarm interrupt can be configured as a system wakeup "
"event, which can resume the system from a low power state such as Suspend-"
"to-RAM (STR, called S3 in ACPI systems), Hibernation (called S4 in ACPI "
"systems), or even \"off\" (called S5 in ACPI systems).  On some systems, the"
" battery backed RTC can't issue interrupts, but another one can."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:120
msgid ""
"The I</dev/rtc> (or I</dev/rtc0>, I</dev/rtc1>, etc.)  device can be opened "
"only once (until it is closed) and it is read-only.  On B<read>(2)  and "
"B<select>(2)  the calling process is blocked until the next interrupt from "
"that RTC is received.  Following the interrupt, the process can read a long "
"integer, of which the least significant byte contains a bit mask encoding "
"the types of interrupt that occurred, while the remaining 3 bytes contain "
"the number of interrupts since the last B<read>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:124
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to RTC devices:"
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:124
#, no-wrap
msgid "B<RTC_RD_TIME>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:127
msgid "Returns this RTC's time in the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:141
#, no-wrap
msgid ""
"struct rtc_time {\n"
"    int tm_sec;\n"
"    int tm_min;\n"
"    int tm_hour;\n"
"    int tm_mday;\n"
"    int tm_mon;\n"
"    int tm_year;\n"
"    int tm_wday;     /* unused */\n"
"    int tm_yday;     /* unused */\n"
"    int tm_isdst;    /* unused */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:151
msgid ""
"The fields in this structure have the same meaning and ranges as for the "
"I<tm> structure described in B<gmtime>(3).  A pointer to this structure "
"should be passed as the third B<ioctl>(2)  argument."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:151
#, no-wrap
msgid "B<RTC_SET_TIME>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:162
msgid ""
"Sets this RTC's time to the time specified by the I<rtc_time> structure "
"pointed to by the third B<ioctl>(2)  argument.  To set the RTC's time the "
"process must be privileged (i.e., have the B<CAP_SYS_TIME> capability)."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:162
#, no-wrap
msgid "B<RTC_ALM_READ>, B<RTC_ALM_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:179
msgid ""
"Read and set the alarm time, for RTCs that support alarms.  The alarm "
"interrupt must be separately enabled or disabled using the B<RTC_AIE_ON>, "
"B<RTC_AIE_OFF> requests.  The third B<ioctl>(2)  argument is a pointer to an"
" I<rtc_time> structure.  Only the I<tm_sec>, I<tm_min>, and I<tm_hour> "
"fields of this structure are used."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:179
#, no-wrap
msgid "B<RTC_IRQP_READ>, B<RTC_IRQP_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:201
msgid ""
"Read and set the frequency for periodic interrupts, for RTCs that support "
"periodic interrupts.  The periodic interrupt must be separately enabled or "
"disabled using the B<RTC_PIE_ON>, B<RTC_PIE_OFF> requests.  The third "
"B<ioctl>(2)  argument is an I<unsigned long\\ *> or an I<unsigned long>, "
"respectively.  The value is the frequency in interrupts per second.  The set"
" of allowable frequencies is the multiples of two in the range 2 to 8192.  "
"Only a privileged process (i.e., one having the B<CAP_SYS_RESOURCE> "
"capability) can set frequencies above the value specified in "
"I</proc/sys/dev/rtc/max-user-freq>.  (This file contains the value 64 by "
"default.)"
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:201
#, no-wrap
msgid "B<RTC_AIE_ON>, B<RTC_AIE_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:207
msgid ""
"Enable or disable the alarm interrupt, for RTCs that support alarms.  The "
"third B<ioctl>(2)  argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:207
#, no-wrap
msgid "B<RTC_UIE_ON>, B<RTC_UIE_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:214
msgid ""
"Enable or disable the interrupt on every clock update, for RTCs that support"
" this once-per-second interrupt.  The third B<ioctl>(2)  argument is "
"ignored."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:214
#, no-wrap
msgid "B<RTC_PIE_ON>, B<RTC_PIE_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:226
msgid ""
"Enable or disable the periodic interrupt, for RTCs that support these "
"periodic interrupts.  The third B<ioctl>(2)  argument is ignored.  Only a "
"privileged process (i.e., one having the B<CAP_SYS_RESOURCE> capability) can"
" enable the periodic interrupt if the frequency is currently set above the "
"value specified in I</proc/sys/dev/rtc/max-user-freq>."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:226
#, no-wrap
msgid "B<RTC_EPOCH_READ>, B<RTC_EPOCH_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:249
msgid ""
"Many RTCs encode the year in an 8-bit register which is either interpreted "
"as an 8-bit binary number or as a BCD number.  In both cases, the number is "
"interpreted relative to this RTC's Epoch.  The RTC's Epoch is initialized to"
" 1900 on most systems but on Alpha and MIPS it might also be initialized to "
"1952, 1980, or 2000, depending on the value of an RTC register for the year."
"  With some RTCs, these operations can be used to read or to set the RTC's "
"Epoch, respectively.  The third B<ioctl>(2)  argument is an I<unsigned "
"long\\ *> or an I<unsigned long>, respectively, and the value returned (or "
"assigned) is the Epoch.  To set the RTC's Epoch the process must be "
"privileged (i.e., have the B<CAP_SYS_TIME> capability)."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:249
#, no-wrap
msgid "B<RTC_WKALM_RD>, B<RTC_WKALM_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:253
msgid ""
"Some RTCs support a more powerful alarm interface, using these ioctls to "
"read or write the RTC's alarm time (respectively) with this structure:"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:262
#, no-wrap
msgid ""
"struct rtc_wkalrm {\n"
"    unsigned char enabled;\n"
"    unsigned char pending;\n"
"    struct rtc_time time;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:294
msgid ""
"The I<enabled> flag is used to enable or disable the alarm interrupt, or to "
"read its current status; when using these calls, B<RTC_AIE_ON> and "
"B<RTC_AIE_OFF> are not used.  The I<pending> flag is used by B<RTC_WKALM_RD>"
" to report a pending interrupt (so it's mostly useless on Linux, except when"
" talking to the RTC managed by EFI firmware).  The I<time> field is as used "
"with B<RTC_ALM_READ> and B<RTC_ALM_SET> except that the I<tm_mday>, "
"I<tm_mon>, and I<tm_year> fields are also valid.  A pointer to this "
"structure should be passed as the third B<ioctl>(2)  argument."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:295
#, no-wrap
msgid "I</dev/rtc>, I</dev/rtc0>, I</dev/rtc1>, etc."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:298
msgid "RTC special character device files."
msgstr ""

#. type: TP
#: man-pages/man4/rtc.4:298
#, no-wrap
msgid "I</proc/driver/rtc>"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:301
msgid "status of the (first) RTC."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:308
msgid ""
"When the kernel's system time is synchronized with an external reference "
"using B<adjtimex>(2)  it will update a designated RTC periodically every 11 "
"minutes.  To do so, the kernel has to briefly turn off periodic interrupts; "
"this might affect programs using that RTC."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:311
msgid ""
"An RTC's Epoch has nothing to do with the POSIX Epoch which is used only for"
" the system clock."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:315
msgid ""
"If the year according to the RTC's Epoch and the year register is less than "
"1970 it is assumed to be 100 years later, that is, between 2000 and 2069."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:322
msgid ""
"Some RTCs support \"wildcard\" values in alarm fields, to support scenarios "
"like periodic alarms at fifteen minutes after every hour, or on the first "
"day of each month.  Such usage is nonportable; portable user-space code "
"expects only a single alarm interrupt, and will either disable or "
"reinitialize the alarm after receiving it."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:330
msgid ""
"Some RTCs support periodic interrupts with periods that are multiples of a "
"second rather than fractions of a second; multiple alarms; programmable "
"output clock signals; nonvolatile memory; and other hardware capabilities "
"that are not currently exposed by this API."
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:340
msgid ""
"B<date>(1), B<adjtimex>(2), B<gettimeofday>(2), B<settimeofday>(2), "
"B<stime>(2), B<time>(2), B<gmtime>(3), B<time>(7), B<hwclock>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man4/rtc.4:342
msgid "I<Documentation/rtc.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man4/ram.4:26
#, no-wrap
msgid "RAM"
msgstr ""

#. type: TH
#: man-pages/man4/ram.4:26
#, no-wrap
msgid "1992-11-21"
msgstr ""

#. type: Plain text
#: man-pages/man4/ram.4:29
msgid "ram - ram disk device"
msgstr ""

#. type: Plain text
#: man-pages/man4/ram.4:33
msgid ""
"The I<ram> device is a block device to access the ram disk in raw mode."
msgstr ""

#. type: Plain text
#: man-pages/man4/ram.4:35
msgid "It is typically created by:"
msgstr ""

#. type: Plain text
#: man-pages/man4/ram.4:40
#, no-wrap
msgid ""
"mknod -m 660 /dev/ram b 1 1\n"
"chown root:disk /dev/ram\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/ram.4:44
msgid "I</dev/ram>"
msgstr ""

#. type: Plain text
#: man-pages/man4/ram.4:47
msgid "B<chown>(1), B<mknod>(1), B<mount>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/rtnetlink.7:15
#, no-wrap
msgid "RTNETLINK"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:18
msgid "rtnetlink - Linux IPv4 routing socket"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:20
msgid "B<#include E<lt>asm/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:22
msgid "B<#include E<lt>linux/netlink.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:24
msgid "B<#include E<lt>linux/rtnetlink.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:26
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:28
msgid ""
"B<rtnetlink_socket = socket(AF_NETLINK, int >I<socket_type>B<, "
"NETLINK_ROUTE);>"
msgstr ""

#.  FIXME . ? all these macros could be moved to rtnetlink(3)
#. type: Plain text
#: man-pages/man7/rtnetlink.7:42
msgid ""
"Rtnetlink allows the kernel's routing tables to be read and altered.  It is "
"used within the kernel to communicate between various subsystems, though "
"this usage is not documented here, and for communication with user-space "
"programs.  Network routes, IP addresses, link parameters, neighbor setups, "
"queueing disciplines, traffic classes and packet classifiers may all be "
"controlled through B<NETLINK_ROUTE> sockets.  It is based on netlink "
"messages; see B<netlink>(7)  for more information."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:42 man-pages/man7/rtnetlink.7:96
#, no-wrap
msgid "Routing attributes"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:44
msgid ""
"Some rtnetlink messages have optional attributes after the initial header:"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:52
#, no-wrap
msgid ""
"struct rtattr {\n"
"    unsigned short rta_len;    /* Length of option */\n"
"    unsigned short rta_type;   /* Type of option */\n"
"    /* Data follows */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:58
msgid ""
"These attributes should be manipulated using only the RTA_* macros or "
"libnetlink, see B<rtnetlink>(3)."
msgstr ""

#. type: SS
#: man-pages/man7/rtnetlink.7:58
#, no-wrap
msgid "Messages"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:61
msgid ""
"Rtnetlink consists of these message types (in addition to standard netlink "
"messages):"
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:61
#, no-wrap
msgid "B<RTM_NEWLINK>, B<RTM_DELLINK>, B<RTM_GETLINK>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:69
msgid ""
"Create, remove or get information about a specific network interface.  These"
" messages contain an I<ifinfomsg> structure followed by a series of "
"I<rtattr> structures."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:78
#, no-wrap
msgid ""
"struct ifinfomsg {\n"
"    unsigned char  ifi_family; /* AF_UNSPEC */\n"
"    unsigned short ifi_type;   /* Device type */\n"
"    int            ifi_index;  /* Interface index */\n"
"    unsigned int   ifi_flags;  /* Device flags  */\n"
"    unsigned int   ifi_change; /* change mask */\n"
"};\n"
msgstr ""

#.  FIXME Document ifinfomsg.ifi_type
#. type: Plain text
#: man-pages/man7/rtnetlink.7:92
msgid ""
"I<ifi_flags> contains the device flags, see B<netdevice>(7); I<ifi_index> is"
" the unique interface index (since Linux 3.7, it is possible to feed a "
"nonzero value with the B<RTM_NEWLINK> message, thus creating a link with the"
" given I<ifindex>); I<ifi_change> is reserved for future use and should be "
"always set to 0xFFFFFFFF."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313 man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "rta_type"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313 man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "value type"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313
#, no-wrap
msgid "description"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:98 man-pages/man7/rtnetlink.7:165
#: man-pages/man7/rtnetlink.7:215 man-pages/man7/rtnetlink.7:239
#: man-pages/man7/rtnetlink.7:314 man-pages/man7/rtnetlink.7:432
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99
#, no-wrap
msgid "IFLA_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99 man-pages/man7/rtnetlink.7:166
#: man-pages/man7/rtnetlink.7:315 man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "-"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99 man-pages/man7/rtnetlink.7:166
#, no-wrap
msgid "unspecified."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100
#, no-wrap
msgid "IFLA_ADDRESS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100 man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "hardware address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100
#, no-wrap
msgid "interface L2 address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "IFLA_BROADCAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "L2 broadcast address."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102
#, no-wrap
msgid "IFLA_IFNAME"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102 man-pages/man7/rtnetlink.7:105
#: man-pages/man7/rtnetlink.7:169 man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "asciiz string"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102
#, no-wrap
msgid "Device name."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "IFLA_MTU"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "unsigned int"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "MTU of the device."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104
#, no-wrap
msgid "IFLA_LINK"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104 man-pages/man7/rtnetlink.7:318
#: man-pages/man7/rtnetlink.7:319 man-pages/man7/rtnetlink.7:321
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "int"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104
#, no-wrap
msgid "Link type."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:105
#, no-wrap
msgid "IFLA_QDISC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:105
#, no-wrap
msgid "Queueing discipline."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:106
#, no-wrap
msgid "IFLA_STATS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:108
#, no-wrap
msgid "see below"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:108
#, no-wrap
msgid "Interface Statistics."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:117
msgid ""
"The value type for B<IFLA_STATS> is I<struct rtnl_link_stats> (I<struct "
"net_device_stats> in Linux 2.4 and earlier)."
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:117
#, no-wrap
msgid "B<RTM_NEWADDR>, B<RTM_DELADDR>, B<RTM_GETADDR>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:130
msgid ""
"Add, remove or receive information about an IP address associated with an "
"interface.  In Linux 2.2, an interface can carry multiple IP addresses, this"
" replaces the alias device concept in 2.0.  In Linux 2.2, these messages "
"support IPv4 and IPv6 addresses.  They contain an I<ifaddrmsg> structure, "
"optionally followed by I<rtattr> routing attributes."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:139
#, no-wrap
msgid ""
"struct ifaddrmsg {\n"
"    unsigned char ifa_family;    /* Address type */\n"
"    unsigned char ifa_prefixlen; /* Prefixlength of address */\n"
"    unsigned char ifa_flags;     /* Address flags */\n"
"    unsigned char ifa_scope;     /* Address scope */\n"
"    int           ifa_index;     /* Interface index */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:159
msgid ""
"I<ifa_family> is the address family type (currently B<AF_INET> or "
"B<AF_INET6>), I<ifa_prefixlen> is the length of the address mask of the "
"address if defined for the family (like for IPv4), I<ifa_scope> is the "
"address scope, I<ifa_index> is the interface index of the interface the "
"address is associated with.  I<ifa_flags> is a flag word of "
"B<IFA_F_SECONDARY> for secondary address (old alias interface), "
"B<IFA_F_PERMANENT> for a permanent address set by the user and other "
"undocumented flags."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:163 man-pages/man7/rtnetlink.7:312
#: man-pages/man7/rtnetlink.7:430
#, no-wrap
msgid "Attributes"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:166
#, no-wrap
msgid "IFA_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167
#, no-wrap
msgid "IFA_ADDRESS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167 man-pages/man7/rtnetlink.7:168
#: man-pages/man7/rtnetlink.7:170 man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "raw protocol address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167
#, no-wrap
msgid "interface address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:168
#, no-wrap
msgid "IFA_LOCAL"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:168
#, no-wrap
msgid "local address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:169
#, no-wrap
msgid "IFA_LABEL"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:169
#, no-wrap
msgid "name of the interface"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:170
#, no-wrap
msgid "IFA_BROADCAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:170
#, no-wrap
msgid "broadcast address."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "IFA_ANYCAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "anycast address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "IFA_CACHEINFO"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "struct ifa_cacheinfo"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "Address information."
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:175
#, no-wrap
msgid "B<RTM_NEWROUTE>, B<RTM_DELROUTE>, B<RTM_GETROUTE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:195
msgid ""
"Create, remove or receive information about a network route.  These messages"
" contain an I<rtmsg> structure with an optional sequence of I<rtattr> "
"structures following.  For B<RTM_GETROUTE>, setting I<rtm_dst_len> and "
"I<rtm_src_len> to 0 means you get all entries for the specified routing "
"table.  For the other fields, except I<rtm_table> and I<rtm_protocol>, 0 is "
"the wildcard."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:202
#, no-wrap
msgid ""
"struct rtmsg {\n"
"    unsigned char rtm_family;   /* Address family of route */\n"
"    unsigned char rtm_dst_len;  /* Length of destination */\n"
"    unsigned char rtm_src_len;  /* Length of source */\n"
"    unsigned char rtm_tos;      /* TOS filter */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:207
#, no-wrap
msgid ""
"    unsigned char rtm_table;    /* Routing table ID */\n"
"    unsigned char rtm_protocol; /* Routing protocol; see below */\n"
"    unsigned char rtm_scope;    /* See below */\n"
"    unsigned char rtm_type;     /* See below */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:210
#, no-wrap
msgid ""
"    unsigned int  rtm_flags;\n"
"};\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:214
#, no-wrap
msgid "rtm_type"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:214
#, no-wrap
msgid "Route type"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:216
#, no-wrap
msgid "RTN_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:216
#, no-wrap
msgid "unknown route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:217
#, no-wrap
msgid "RTN_UNICAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:217
#, no-wrap
msgid "a gateway or direct route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:218
#, no-wrap
msgid "RTN_LOCAL"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:218
#, no-wrap
msgid "a local interface route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:219
#, no-wrap
msgid "RTN_BROADCAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:221
#, no-wrap
msgid "a local broadcast route (sent as a broadcast)"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:222
#, no-wrap
msgid "RTN_ANYCAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:224
#, no-wrap
msgid "a local broadcast route (sent as a unicast)"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:225
#, no-wrap
msgid "RTN_MULTICAST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:225
#, no-wrap
msgid "a multicast route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:226
#, no-wrap
msgid "RTN_BLACKHOLE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:226
#, no-wrap
msgid "a packet dropping route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:227
#, no-wrap
msgid "RTN_UNREACHABLE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:227
#, no-wrap
msgid "an unreachable destination"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:228
#, no-wrap
msgid "RTN_PROHIBIT"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:228
#, no-wrap
msgid "a packet rejection route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:229
#, no-wrap
msgid "RTN_THROW"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:229
#, no-wrap
msgid "continue routing lookup in another table"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:230
#, no-wrap
msgid "RTN_NAT"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:230
#, no-wrap
msgid "a network address translation rule"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:231
#, no-wrap
msgid "RTN_XRESOLVE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:233
#, no-wrap
msgid "refer to an external resolver (not implemented)"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:238
#, no-wrap
msgid "rtm_protocol"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:238
#, no-wrap
msgid "Route origin."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:240
#, no-wrap
msgid "RTPROT_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:240
#, no-wrap
msgid "unknown"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:241
#, no-wrap
msgid "RTPROT_REDIRECT"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:243
#, no-wrap
msgid "by an ICMP redirect (currently unused)"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:244
#, no-wrap
msgid "RTPROT_KERNEL"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:244
#, no-wrap
msgid "by the kernel"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:245
#, no-wrap
msgid "RTPROT_BOOT"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:245
#, no-wrap
msgid "during boot"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:246
#, no-wrap
msgid "RTPROT_STATIC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:246
#, no-wrap
msgid "by the administrator"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:257
msgid ""
"Values larger than B<RTPROT_STATIC> are not interpreted by the kernel, they "
"are just for user information.  They may be used to tag the source of a "
"routing information or to distinguish between multiple routing daemons.  See"
" I<E<lt>linux/rtnetlink.hE<gt>> for the routing daemon identifiers which are"
" already assigned."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:260
msgid "I<rtm_scope> is the distance to the destination:"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:263
#, no-wrap
msgid "RT_SCOPE_UNIVERSE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:263
#, no-wrap
msgid "global route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:264
#, no-wrap
msgid "RT_SCOPE_SITE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:266
#, no-wrap
msgid "interior route in the local autonomous system"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:267
#, no-wrap
msgid "RT_SCOPE_LINK"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:267
#, no-wrap
msgid "route on this link"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:268
#, no-wrap
msgid "RT_SCOPE_HOST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:268
#, no-wrap
msgid "route on the local host"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:269
#, no-wrap
msgid "RT_SCOPE_NOWHERE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:269
#, no-wrap
msgid "destination doesn't exist"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:277
msgid ""
"The values between B<RT_SCOPE_UNIVERSE> and B<RT_SCOPE_SITE> are available "
"to the user."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:281
msgid "The I<rtm_flags> have the following meanings:"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:284
#, no-wrap
msgid "RTM_F_NOTIFY"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:286
#, no-wrap
msgid "if the route changes, notify the user via rtnetlink"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:287
#, no-wrap
msgid "RTM_F_CLONED"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:287
#, no-wrap
msgid "route is cloned from another route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:288
#, no-wrap
msgid "RTM_F_EQUALIZE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:288
#, no-wrap
msgid "a multipath equalizer (not yet implemented)"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:293
msgid "I<rtm_table> specifies the routing table"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:296
#, no-wrap
msgid "RT_TABLE_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:296
#, no-wrap
msgid "an unspecified routing table"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:297
#, no-wrap
msgid "RT_TABLE_DEFAULT"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:297
#, no-wrap
msgid "the default table"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:298
#, no-wrap
msgid "RT_TABLE_MAIN"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:298
#, no-wrap
msgid "the main table"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:299
#, no-wrap
msgid "RT_TABLE_LOCAL"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:299
#, no-wrap
msgid "the local table"
msgstr ""

#.  Keep table on same page
#. type: Plain text
#: man-pages/man7/rtnetlink.7:307
msgid ""
"The user may assign arbitrary values between B<RT_TABLE_UNSPEC> and "
"B<RT_TABLE_DEFAULT>."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:315
#, no-wrap
msgid "RTA_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:315
#, no-wrap
msgid "ignored."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316
#, no-wrap
msgid "RTA_DST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316 man-pages/man7/rtnetlink.7:317
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "protocol address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316
#, no-wrap
msgid "Route destination address."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:317
#, no-wrap
msgid "RTA_SRC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:317
#, no-wrap
msgid "Route source address."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:318
#, no-wrap
msgid "RTA_IIF"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:318
#, no-wrap
msgid "Input interface index."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:319
#, no-wrap
msgid "RTA_OIF"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:319
#, no-wrap
msgid "Output interface index."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "RTA_GATEWAY"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "The gateway of the route"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:321
#, no-wrap
msgid "RTA_PRIORITY"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:321
#, no-wrap
msgid "Priority of route."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:322
#, no-wrap
msgid "RTA_PREFSRC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "RTA_METRICS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "Route metric"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:324
#, no-wrap
msgid "RTA_MULTIPATH"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:325
#, no-wrap
msgid "RTA_PROTOINFO"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:326
#, no-wrap
msgid "RTA_FLOW"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:327
#, no-wrap
msgid "RTA_CACHEINFO"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:331
msgid "B<Fill these values in!>"
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:331
#, no-wrap
msgid "B<RTM_NEWNEIGH>, B<RTM_DELNEIGH>, B<RTM_GETNEIGH>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:338
msgid ""
"Add, remove or receive information about a neighbor table entry (e.g., an "
"ARP entry).  The message contains an I<ndmsg> structure."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:347
#, no-wrap
msgid ""
"struct ndmsg {\n"
"    unsigned char ndm_family;\n"
"    int           ndm_ifindex;  /* Interface index */\n"
"    __u16         ndm_state;    /* State */\n"
"    __u8          ndm_flags;    /* Flags */\n"
"    __u8          ndm_type;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:354
#, no-wrap
msgid ""
"struct nda_cacheinfo {\n"
"    __u32         ndm_confirmed;\n"
"    __u32         ndm_used;\n"
"    __u32         ndm_updated;\n"
"    __u32         ndm_refcnt;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:358
msgid "I<ndm_state> is a bit mask of the following states:"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:361
#, no-wrap
msgid "NUD_INCOMPLETE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:361
#, no-wrap
msgid "a currently resolving cache entry"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:362
#, no-wrap
msgid "NUD_REACHABLE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:362
#, no-wrap
msgid "a confirmed working cache entry"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:363
#, no-wrap
msgid "NUD_STALE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:363
#, no-wrap
msgid "an expired cache entry"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:364
#, no-wrap
msgid "NUD_DELAY"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:364
#, no-wrap
msgid "an entry waiting for a timer"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:365
#, no-wrap
msgid "NUD_PROBE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:365
#, no-wrap
msgid "a cache entry that is currently reprobed"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:366
#, no-wrap
msgid "NUD_FAILED"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:366
#, no-wrap
msgid "an invalid cache entry"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:367
#, no-wrap
msgid "NUD_NOARP"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:367
#, no-wrap
msgid "a device with no destination cache"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:368
#, no-wrap
msgid "NUD_PERMANENT"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:368
#, no-wrap
msgid "a static entry"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:374
msgid "Valid I<ndm_flags> are:"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:377
#, no-wrap
msgid "NTF_PROXY"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:377
#, no-wrap
msgid "a proxy arp entry"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:378
#, no-wrap
msgid "NTF_ROUTER"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:378
#, no-wrap
msgid "an IPv6 router"
msgstr ""

#.  FIXME .
#.  document the members of the struct better
#. type: Plain text
#: man-pages/man7/rtnetlink.7:388
msgid ""
"The I<rtattr> struct has the following meanings for the I<rta_type> field:"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:391
#, no-wrap
msgid "NDA_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:391
#, no-wrap
msgid "unknown type"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:392
#, no-wrap
msgid "NDA_DST"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:392
#, no-wrap
msgid "a neighbor cache n/w layer destination address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:393
#, no-wrap
msgid "NDA_LLADDR"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:393
#, no-wrap
msgid "a neighbor cache link layer address"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:394
#, no-wrap
msgid "NDA_CACHEINFO"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:394
#, no-wrap
msgid "cache statistics."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:404
msgid ""
"If the I<rta_type> field is B<NDA_CACHEINFO>, then a I<struct nda_cacheinfo>"
" header follows"
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:404
#, no-wrap
msgid "B<RTM_NEWRULE>, B<RTM_DELRULE>, B<RTM_GETRULE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:409
msgid "Add, delete or retrieve a routing rule.  Carries a I<struct rtmsg>"
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:409
#, no-wrap
msgid "B<RTM_NEWQDISC>, B<RTM_DELQDISC>, B<RTM_GETQDISC>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:416
msgid ""
"Add, remove or get a queueing discipline.  The message contains a I<struct "
"tcmsg> and may be followed by a series of attributes."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:425
#, no-wrap
msgid ""
"struct tcmsg {\n"
"    unsigned char    tcm_family;\n"
"    int              tcm_ifindex;   /* interface index */\n"
"    __u32            tcm_handle;    /* Qdisc handle */\n"
"    __u32            tcm_parent;    /* Parent qdisc */\n"
"    __u32            tcm_info;\n"
"};\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "Description"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "TCA_UNSPEC"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "unspecified"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "TCA_KIND"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "Name of queueing discipline"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "TCA_OPTIONS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "byte sequence"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "Qdisc-specific options follow"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "TCA_STATS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "struct tc_stats"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "Qdisc statistics."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "TCA_XSTATS"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "qdisc-specific"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "Module-specific statistics."
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "TCA_RATE"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "struct tc_estimator"
msgstr ""

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "Rate limit."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:443
msgid ""
"In addition, various other qdisc-module-specific attributes are allowed.  "
"For more information see the appropriate include files."
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:443
#, no-wrap
msgid "B<RTM_NEWTCLASS>, B<RTM_DELTCLASS>, B<RTM_GETTCLASS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:449
msgid ""
"Add, remove or get a traffic class.  These messages contain a I<struct "
"tcmsg> as described above."
msgstr ""

#. type: TP
#: man-pages/man7/rtnetlink.7:449
#, no-wrap
msgid "B<RTM_NEWTFILTER>, B<RTM_DELTFILTER>, B<RTM_GETTFILTER>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:455
msgid ""
"Add, remove or receive information about a traffic filter.  These messages "
"contain a I<struct tcmsg> as described above."
msgstr ""

#. type: SH
#: man-pages/man7/rtnetlink.7:455
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:458
msgid "B<rtnetlink> is a new feature of Linux 2.2."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:460
msgid "This manual page is incomplete."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtnetlink.7:464
msgid "B<cmsg>(3), B<rtnetlink>(3), B<ip>(7), B<netlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/regex.7:37
#, no-wrap
msgid "REGEX"
msgstr ""

#. type: TH
#: man-pages/man7/regex.7:37
#, no-wrap
msgid "2009-01-12"
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:40
msgid "regex - POSIX.2 regular expressions"
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:54
msgid ""
"Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forms: "
"modern REs (roughly those of I<egrep>; POSIX.2 calls these \"extended\" REs)"
"  and obsolete REs (roughly those of B<ed>(1); POSIX.2 \"basic\" REs).  "
"Obsolete REs mostly exist for backward compatibility in some old programs; "
"they will be discussed at the end.  POSIX.2 leaves some aspects of RE syntax"
" and semantics open; \"\\*(dg\" marks decisions on these aspects that may "
"not be fully portable to other POSIX.2 implementations."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:58
msgid ""
"A (modern) RE is one\\*(dg or more nonempty\\*(dg I<branches>, separated by "
"\\(aq|\\(aq.  It matches anything that matches one of the branches."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:62
msgid ""
"A branch is one\\*(dg or more I<pieces>, concatenated.  It matches a match "
"for the first, followed by a match for the second, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:71
msgid ""
"A piece is an I<atom> possibly followed by a single\\*(dg \\(aq*\\(aq, "
"\\(aq+\\(aq, \\(aq?\\(aq, or I<bound>.  An atom followed by \\(aq*\\(aq "
"matches a sequence of 0 or more matches of the atom.  An atom followed by "
"\\(aq+\\(aq matches a sequence of 1 or more matches of the atom.  An atom "
"followed by \\(aq?\\(aq matches a sequence of 0 or 1 matches of the atom."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:89
msgid ""
"A I<bound> is \\(aq{\\(aq followed by an unsigned decimal integer, possibly "
"followed by \\(aq,\\(aq possibly followed by another unsigned decimal "
"integer, always followed by \\(aq}\\(aq.  The integers must lie between 0 "
"and B<RE_DUP_MAX> (255\\*(dg) inclusive, and if there are two of them, the "
"first may not exceed the second.  An atom followed by a bound containing one"
" integer I<i> and no comma matches a sequence of exactly I<i> matches of the"
" atom.  An atom followed by a bound containing one integer I<i> and a comma "
"matches a sequence of I<i> or more matches of the atom.  An atom followed by"
" a bound containing two integers I<i> and I<j> matches a sequence of I<i> "
"through I<j> (inclusive) matches of the atom."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:106
msgid ""
"An atom is a regular expression enclosed in \"I<()>\" (matching a match for "
"the regular expression), an empty set of \"I<()>\" (matching the null "
"string)\\*(dg, a I<bracket expression> (see below), \\(aq.\\(aq (matching "
"any single character), \\(aq^\\(aq (matching the null string at the "
"beginning of a line), \\(aq$\\(aq (matching the null string at the end of a "
"line), a \\(aq\\e\\(aq followed by one of the characters "
"\"I<^.[$()|*+?{\\e>\" (matching that character taken as an ordinary "
"character), a \\(aq\\e\\(aq followed by any other character\\*(dg (matching "
"that character taken as an ordinary character, as if the \\(aq\\e\\(aq had "
"not been present\\*(dg), or a single character with no other significance "
"(matching that character).  A \\(aq{\\(aq followed by a character other than"
" a digit is an ordinary character, not the beginning of a bound\\*(dg.  It "
"is illegal to end an RE with \\(aq\\e\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:120
msgid ""
"A I<bracket expression> is a list of characters enclosed in \"I<[]>\".  It "
"normally matches any single character from the list (but see below).  If the"
" list begins with \\(aq^\\(aq, it matches any single character (but see "
"below) I<not> from the rest of the list.  If two characters in the list are "
"separated by \\(aq-\\(aq, this is shorthand for the full I<range> of "
"characters between those two (inclusive) in the collating sequence, for "
"example, \"I<[0-9]>\" in ASCII matches any decimal digit.  It is "
"illegal\\*(dg for two ranges to share an endpoint, for example, "
"\"I<a-c-e>\".  Ranges are very collating-sequence-dependent, and portable "
"programs should avoid relying on them."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:131
msgid ""
"To include a literal \\(aq]\\(aq in the list, make it the first character "
"(following a possible \\(aq^\\(aq).  To include a literal \\(aq-\\(aq, make "
"it the first or last character, or the second endpoint of a range.  To use a"
" literal \\(aq-\\(aq as the first endpoint of a range, enclose it in "
"\"I<[.>\" and \"I<.]>\" to make it a collating element (see below).  With "
"the exception of these and some combinations using \\(aq[\\(aq (see next "
"paragraphs), all other special characters, including \\(aq\\e\\(aq, lose "
"their special significance within a bracket expression."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:143
msgid ""
"Within a bracket expression, a collating element (a character, a "
"multicharacter sequence that collates as if it were a single character, or a"
" collating-sequence name for either)  enclosed in \"I<[.>\" and \"I<.]>\" "
"stands for the sequence of characters of that collating element.  The "
"sequence is a single element of the bracket expression's list.  A bracket "
"expression containing a multicharacter collating element can thus match more"
" than one character, for example, if the collating sequence includes a "
"\"ch\" collating element, then the RE \"I<[[.ch.]]*c>\" matches the first "
"five characters of \"chchcc\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:155
msgid ""
"Within a bracket expression, a collating element enclosed in \"I<[=>\" and "
"\"I<=]>\" is an equivalence class, standing for the sequences of characters "
"of all collating elements equivalent to that one, including itself.  (If "
"there are no other equivalent collating elements, the treatment is as if the"
" enclosing delimiters were \"I<[.>\" and \"I<.]>\".)  For example, if o and "
"\\o'o^' are the members of an equivalence class, then \"I<[[=o=]]>\", "
"\"I<[[=\\o'o^'=]]>\", and \"I<[o\\o'o^']>\" are all synonymous.  An "
"equivalence class may not\\*(dg be an endpoint of a range."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:161
msgid ""
"Within a bracket expression, the name of a I<character class> enclosed in "
"\"I<[:>\" and \"I<:]>\" stands for the list of all characters belonging to "
"that class.  Standard character class names are:"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "alnum"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "digit"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "punct"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "alpha"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "graph"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "space"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "blank"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "lower"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "upper"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "cntrl"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "print"
msgstr ""

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "xdigit"
msgstr ""

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  There are two special cases\*(dg of bracket expressions:
#.  the bracket expressions "\fI[[:<:]]\fP" and "\fI[[:>:]]\fP" match
#.  the null string at the beginning and end of a word respectively.
#.  A word is defined as a sequence of
#.  word characters
#.  which is neither preceded nor followed by
#.  word characters.
#.  A word character is an
#.  .I alnum
#.  character (as defined by
#.  .BR wctype (3))
#.  or an underscore.
#.  This is an extension,
#.  compatible with but not specified by POSIX.2,
#.  and should be used with
#.  caution in software intended to be portable to other systems.
#. type: Plain text
#: man-pages/man7/regex.7:195
msgid ""
"These stand for the character classes defined in B<wctype>(3).  A locale may"
" provide others.  A character class may not be used as an endpoint of a "
"range."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:207
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string.  If the RE "
"could match more than one substring starting at that point, it matches the "
"longest.  Subexpressions also match the longest possible substrings, subject"
" to the constraint that the whole match be as long as possible, with "
"subexpressions starting earlier in the RE taking priority over ones starting"
" later.  Note that higher-level subexpressions thus take priority over their"
" lower-level component subexpressions."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:219
msgid ""
"Match lengths are measured in characters, not collating elements.  A null "
"string is considered longer than no match at all.  For example, \"I<bb*>\" "
"matches the three middle characters of \"abbbc\", "
"\"I<(wee|week)(knights|nights)>\" matches all ten characters of "
"\"weeknights\", when \"I<(.*).*>\" is matched against \"abc\" the "
"parenthesized subexpression matches all three characters, and when "
"\"I<(a*)*>\" is matched against \"bc\" both the whole RE and the "
"parenthesized subexpression match the null string."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:230
msgid ""
"If case-independent matching is specified, the effect is much as if all case"
" distinctions had vanished from the alphabet.  When an alphabetic that "
"exists in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, for example, \\(aqx\\(aq becomes \"I<[xX]>\".  When "
"it appears inside a bracket expression, all case counterparts of it are "
"added to the bracket expression, so that, for example, \"I<[x]>\" becomes "
"\"I<[xX]>\" and \"I<[^x]>\" becomes \"I<[^xX]>\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:236
msgid ""
"No particular limit is imposed on the length of REs\\*(dg.  Programs "
"intended to be portable should not employ REs longer than 256 bytes, as an "
"implementation can refuse to accept such REs and remain POSIX-compliant."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:252
msgid ""
"Obsolete (\"basic\") regular expressions differ in several respects.  "
"\\(aq|\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq are ordinary characters and there "
"is no equivalent for their functionality.  The delimiters for bounds are "
"\"I<\\e{>\" and \"I<\\e}>\", with \\(aq{\\(aq and \\(aq}\\(aq by themselves "
"ordinary characters.  The parentheses for nested subexpressions are "
"\"I<\\e(>\" and \"I<\\e)>\", with \\(aq(\\(aq and \\(aq)\\(aq by themselves "
"ordinary characters.  \\(aq^\\(aq is an ordinary character except at the "
"beginning of the RE or\\*(dg the beginning of a parenthesized subexpression,"
" \\(aq$\\(aq is an ordinary character except at the end of the RE or\\*(dg "
"the end of a parenthesized subexpression, and \\(aq*\\(aq is an ordinary "
"character if it appears at the beginning of the RE or the beginning of a "
"parenthesized subexpression (after a possible leading \\(aq^\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:260
msgid ""
"Finally, there is one new type of atom, a I<back reference>: \\(aq\\e\\(aq "
"followed by a nonzero decimal digit I<d> matches the same sequence of "
"characters matched by the I<d>th parenthesized subexpression (numbering "
"subexpressions by the positions of their opening parentheses, left to "
"right), so that, for example, \"I<\\e([bc]\\e)\\e1>\" matches \"bb\" or "
"\"cc\" but not \"bc\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:262
msgid "Having two kinds of REs is a botch."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:268
msgid ""
"The current POSIX.2 spec says that \\(aq)\\(aq is an ordinary character in "
"the absence of an unmatched \\(aq(\\(aq; this was an unintentional result of"
" a wording error, and change is likely.  Avoid relying on it."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:275
msgid ""
"Back references are a dreadful botch, posing major problems for efficient "
"implementations.  They are also somewhat vaguely defined (does "
"\"I<a\\e(\\e(b\\e)*\\e2\\e)*d>\" match \"abbbd\"?).  Avoid using them."
msgstr ""

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  The syntax for word boundaries is incredibly ugly.
#. type: Plain text
#: man-pages/man7/regex.7:283
msgid ""
"POSIX.2's specification of case-independent matching is vague.  The \"one "
"case implies all cases\" definition given above is current consensus among "
"implementors as to the right interpretation."
msgstr ""

#. type: SH
#: man-pages/man7/regex.7:283
#, no-wrap
msgid "AUTHOR"
msgstr ""

#.  Sigh... The page license means we must have the author's name
#.  in the formatted output.
#. type: Plain text
#: man-pages/man7/regex.7:287
msgid "This page was taken from Henry Spencer's regex package."
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:290
msgid "B<grep>(1), B<regex>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man7/regex.7:291
msgid "POSIX.2, section 2.8 (Regular Expression Notation)."
msgstr ""

#. type: TH
#: man-pages/man7/rtld-audit.7:28
#, no-wrap
msgid "RTLD-AUDIT"
msgstr ""

#. type: TH
#: man-pages/man7/rtld-audit.7:28
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:31
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:44
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined"
" by including I<E<lt>link.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:51
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:59
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:59
#, no-wrap
msgid "la_version()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:63
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:75
msgid ""
"This is the only function that I<must> be defined by an auditing library: it"
" performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports.  If necessary, the auditing library can check that this version is"
" sufficient for its requirements."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:84
msgid ""
"As its function result, this function should return the version of the "
"auditing interface that this auditing library expects to use (returning "
"I<version> is acceptable).  If the returned value is 0, or a version that is"
" greater than that supported by the dynamic linker, then the audit library "
"is ignored."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:84
#, no-wrap
msgid "la_objsearch()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:89
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:100
msgid ""
"The dynamic linker invokes this function to inform the auditing library that"
" it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:100
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:109
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:109
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:114
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:114
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:122
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:122
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:129
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:129
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:133
msgid "I<name> was found via a search of one of the default directories."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:133
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:137
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:146
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then"
" this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:146
#, no-wrap
msgid "la_activity()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:150
#, no-wrap
msgid ""
"B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:159
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head"
" of the link map.  When the dynamic linker invokes this function, I<flag> is"
" set to one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:159
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:162
msgid "New objects are being added to the link map."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:162
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:165
msgid "Objects are being removed from the link map."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:165
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:168
msgid ""
"Link-map activity has been completed: the map is once again consistent."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:168
#, no-wrap
msgid "la_objopen()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:173
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:182
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:182
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:185
msgid "Link map is part of the initial namespace."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:185
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:189
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:197
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:204
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to"
" select the objects to be monitored by B<la_symbind*>():"
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:204
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:207
msgid "Audit symbol bindings to this object."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:207
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:210
msgid "Audit symbol bindings from this object."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:214
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:214
#, no-wrap
msgid "la_objclose()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:218
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:227
msgid ""
"The dynamic linker invokes this function after any finalization code for the"
" object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:231
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:231
#, no-wrap
msgid "la_preinit()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:235
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:245
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:245
#, no-wrap
msgid "la_symbind*()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:254
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:266
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on"
" 64-bit platforms."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:276
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:281
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the"
" bound shared object."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:296
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:300
msgid ""
"The I<symname> argument points a string containing the name of the symbol."
msgstr ""

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: man-pages/man7/rtld-audit.7:308
msgid ""
"The I<flags> argument is a bit mask that both provides information about the"
" symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:308
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:312
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:312
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:317
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: man-pages/man7/rtld-audit.7:331
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced."
"  The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:331
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:336
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr ""

#. type: TP
#: man-pages/man7/rtld-audit.7:336
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:341
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:352
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address"
" to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return"
" I<sym-E<gt>st_value>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:352
#, no-wrap
msgid "la_pltenter()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:358 man-pages/man7/rtld-audit.7:418
msgid ""
"The precise name and argument types for this function depend on the hardware"
" platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)"
"  Here is the definition for x86-32:"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:364
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long int *>I<framesizep>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:368
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:378 man-pages/man7/rtld-audit.7:441
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:385
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)"
"  containing the values of registers to be used for the call to this PLT "
"entry."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:391
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""

#.  FIXME . Is the following correct?
#. type: Plain text
#: man-pages/man7/rtld-audit.7:407
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used"
" to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltexit>()  "
"function is called only if this buffer is explicitly set to a suitable "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:412
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr ""

#. type: SS
#: man-pages/man7/rtld-audit.7:412
#, no-wrap
msgid "la_pltexit()"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:424
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:431
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:454
msgid ""
"The I<inregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing the values of registers used for the call "
"to this PLT entry.  The I<outregs> argument points to a structure (defined "
"in I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: man-pages/man7/rtld-audit.7:462
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""

#. type: SH
#: man-pages/man7/rtld-audit.7:462
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:468
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:471
msgid ""
"Note the following differences from the Solaris dynamic linker auditing API:"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:475
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:483
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide"
" a I<symname> argument."
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:493
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""

#.  FIXME . Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: man-pages/man7/rtld-audit.7:503
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""

#. type: SH
#: man-pages/man7/rtld-audit.7:503
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:507
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:512
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): %d\\en\", version);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:515
#, no-wrap
msgid ""
"    return version;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:528
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %p\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:531
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:541
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %p; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:551
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%p\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:554
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:559
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %p\\en\", cookie);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:562
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:568
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %p\\en\", cookie);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:577
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:580 man-pages/man7/rtld-audit.7:592
#: man-pages/man7/rtld-audit.7:602
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:589
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:599
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long int *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/rtld-audit.7:607
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/raw.7:13
#, no-wrap
msgid "RAW"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:16
msgid "raw - Linux IPv4 raw sockets"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:20
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:22
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:26
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw"
" socket receives or sends the raw datagram not including link level headers."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:32
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving, the IP header is "
"always included in the packet."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:36
msgid ""
"In order to create a raw socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:47
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols, see "
"the IANA list of assigned protocol numbers at E<.UR "
"http://www.iana.org/assignments/protocol-numbers/> E<.UE> and "
"B<getprotobyname>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:57
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:62
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>"
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:63
#, no-wrap
msgid "IP Checksum"
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:63 man-pages/man7/raw.7:66
#, no-wrap
msgid "Always filled in"
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:64
#, no-wrap
msgid "Source Address"
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:64 man-pages/man7/raw.7:65
#, no-wrap
msgid "Filled in when zero"
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:65
#, no-wrap
msgid "Packet ID"
msgstr ""

#. type: tbl table
#: man-pages/man7/raw.7:66
#, no-wrap
msgid "Total Length"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:80
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address, then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:88
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets"
" with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:93
msgid ""
"Starting with Linux 2.2, all IP header fields and options can be set using "
"IP socket options.  This means raw sockets are usually needed only for new "
"protocols or protocols with no user interface (like ICMP)."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:97
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""

#. type: SS
#: man-pages/man7/raw.7:97
#, no-wrap
msgid "Address format"
msgstr ""

#.  commit f59fc7f30b710d45aadf715460b3e60dbe9d3418
#. type: Plain text
#: man-pages/man7/raw.7:115
msgid ""
"For sending and receiving datagrams (B<sendto>(2), B<recvfrom>(2), and "
"similar), raw sockets use the standard I<sockaddr_in> address structure "
"defined in B<ip>(7).  The I<sin_port> field could be used to specify the IP "
"protocol number, but it is ignored for sending in Linux 2.2 and later, and "
"should be always set to 0 (see BUGS).  For incoming packets, I<sin_port> is "
"set to zero."
msgstr ""

#. type: SS
#: man-pages/man7/raw.7:115
#, no-wrap
msgid "Socket options"
msgstr ""

#.  Or SOL_RAW on Linux
#. type: Plain text
#: man-pages/man7/raw.7:124
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:124
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:132
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:137
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""

#. type: SS
#: man-pages/man7/raw.7:137
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:150
msgid ""
"Errors originating from the network are passed to the user only when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""

#. type: SH
#: man-pages/man7/raw.7:150
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:151
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:155
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:155
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:158
msgid "An invalid memory address was supplied."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:158
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:161
msgid "Invalid argument."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:161
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:168
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64\\ kB."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:168
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:172
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:172
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:178
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""

#. type: TP
#: man-pages/man7/raw.7:178
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:181
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:187
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:193
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set; since Linux 2.2, this "
"option no longer has that effect."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:211
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:220
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a raw socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:231
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP"
" packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:237
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:244
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not"
" be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:249
msgid ""
"Linux never changes headers passed from the user (except for filling in some"
" zeroed fields as described for B<IP_HDRINCL>).  This differs from many "
"other implementations of raw sockets."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:252
msgid ""
"Raw sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:258
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:260
msgid "Transparent proxy extensions are not described."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:265
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/raw.7:275
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:281
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/raw.7:287
msgid ""
"B<RFC\\ 1191> for path MTU discovery.  B<RFC\\ 791> and the "
"I<E<lt>linux/ip.hE<gt>> header file for the IP protocol."
msgstr ""

#. type: TH
#: man-pages/man7/random.7:31
#, no-wrap
msgid "2017-03-13"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:34
msgid "random - overview of interfaces for obtaining randomness"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:39
msgid ""
"The kernel random-number generator relies on entropy gathered from device "
"drivers and other sources of environmental noise to seed a cryptographically"
" secure pseudorandom number generator (CSPRNG).  It is designed for "
"security, rather than speed."
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:41
msgid ""
"The following interfaces provide access to output from the kernel CSPRNG:"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:50
msgid ""
"The I</dev/urandom> and I</dev/random> devices, both described in "
"B<random>(4).  These devices have been present on Linux since early times, "
"and are also available on many other systems."
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:76
msgid ""
"The Linux-specific B<getrandom>(2)  system call, available since Linux 3.17."
"  This system call provides access either to the same source as "
"I</dev/urandom> (called the I<urandom> source in this page)  or to the same "
"source as I</dev/random> (called the I<random> source in this page).  The "
"default is the I<urandom> source; the I<random> source is selected by "
"specifying the B<GRND_RANDOM> flag to the system call.  (The "
"B<getentropy>(3)  function provides a slightly more portable interface on "
"top of B<getrandom>(2).)"
msgstr ""

#. type: SS
#: man-pages/man7/random.7:76
#, no-wrap
msgid "Initialization of the entropy pool"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:80
msgid ""
"The kernel collects bits of entropy from the environment.  When a sufficient"
" number of random bits has been collected, the entropy pool is considered to"
" be initialized."
msgstr ""

#. type: SS
#: man-pages/man7/random.7:80
#, no-wrap
msgid "Choice of random source"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:99
msgid ""
"Unless you are doing long-term key generation (and most likely not even "
"then), you probably shouldn't be reading from the I</dev/random> device or "
"employing B<getrandom>(2)  with the B<GRND_RANDOM> flag.  Instead, either "
"read from the I</dev/urandom> device or employ B<getrandom>(2)  without the "
"B<GRND_RANDOM> flag.  The cryptographic algorithms used for the I<urandom> "
"source are quite conservative, and so should be sufficient for all purposes."
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:112
msgid ""
"The disadvantage of B<GRND_RANDOM> and reads from I</dev/random> is that the"
" operation can block for an indefinite period of time.  Furthermore, dealing"
" with the partially fulfilled requests that can occur when using "
"B<GRND_RANDOM> or when reading from I</dev/random> increases code "
"complexity."
msgstr ""

#. type: SS
#: man-pages/man7/random.7:112
#, no-wrap
msgid "Monte Carlo and other probabilistic sampling applications"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:122
msgid ""
"Using these interfaces to provide large quantities of data for Monte Carlo "
"simulations or other programs/algorithms which are doing probabilistic "
"sampling will be slow.  Furthermore, it is unnecessary, because such "
"applications do not need cryptographically secure random numbers.  Instead, "
"use the interfaces described in this page to obtain a small amount of data "
"to seed a user-space pseudorandom number generator for use by such "
"applications."
msgstr ""

#. type: SS
#: man-pages/man7/random.7:122
#, no-wrap
msgid "Comparison between getrandom, /dev/urandom, and /dev/random"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:130
msgid ""
"The following table summarizes the behavior of the various interfaces that "
"can be used to obtain randomness.  B<GRND_NONBLOCK> is a flag that can be "
"used to control the blocking behavior of B<getrandom>(2).  The final column "
"of the table considers the case that can occur in early boot time when the "
"entropy pool is not yet initialized."
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:135
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:135
#, no-wrap
msgid "Pool"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:138
#, no-wrap
msgid ""
"Blocking\n"
"\\%behavior"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:140
#, no-wrap
msgid "Behavior when pool is not yet ready"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:145
#, no-wrap
msgid "Blocking pool"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:147 man-pages/man7/random.7:177
#, no-wrap
msgid "If entropy too low, blocks until there is enough entropy again"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:149
#, no-wrap
msgid "Blocks until enough entropy gathered"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:154
#, no-wrap
msgid "CSPRNG output"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:156
#, no-wrap
msgid "Never blocks"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:158
#, no-wrap
msgid ""
"Returns output from uninitialized CSPRNG (may be low entropy and unsuitable "
"for cryptography)"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:161
#, no-wrap
msgid "B<getrandom>()"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:164 man-pages/man7/random.7:186
#, no-wrap
msgid ""
"Same as\n"
"I</dev/urandom>"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:166 man-pages/man7/random.7:188
#, no-wrap
msgid "Does not block once is pool ready"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:168 man-pages/man7/random.7:179
#, no-wrap
msgid "Blocks until pool ready"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:172
#, no-wrap
msgid ""
"B<getrandom>()\n"
"B<GRND_RANDOM>"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:175 man-pages/man7/random.7:199
#, no-wrap
msgid ""
"Same as\n"
"I</dev/random>"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:183
#, no-wrap
msgid ""
"B<getrandom>()\n"
"B<GRND_NONBLOCK>"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:190 man-pages/man7/random.7:204
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:196
#, no-wrap
msgid ""
"B<getrandom>()\n"
"B<GRND_RANDOM>\n"
"+\n"
"B<GRND_NONBLOCK>"
msgstr ""

#. type: tbl table
#: man-pages/man7/random.7:202
#, no-wrap
msgid ""
"B<EAGAIN>\n"
"if not enough entropy available"
msgstr ""

#. type: SS
#: man-pages/man7/random.7:208
#, no-wrap
msgid "Generating cryptographic keys"
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:216
msgid ""
"The amount of seed material required to generate a cryptographic key equals "
"the effective key size of the key.  For example, a 3072-bit RSA or Diffie-"
"Hellman private key has an effective key size of 128 bits (it requires about"
" 2^128 operations to break) so a key generator needs only 128 bits (16 "
"bytes) of seed material from I</dev/random>."
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:226
msgid ""
"While some safety margin above that minimum is reasonable, as a guard "
"against flaws in the CSPRNG algorithm, no cryptographic primitive available "
"today can hope to promise more than 256 bits of security, so if any program "
"reads more than 256 bits (32 bytes) from the kernel random pool per "
"invocation, or per reasonable reseed interval (not less than one minute), "
"that should be taken as a sign that its cryptography is I<not> skillfully "
"implemented."
msgstr ""

#. type: Plain text
#: man-pages/man7/random.7:232
msgid ""
"B<getrandom>(2), B<getauxval>(3), B<getentropy>(3), B<random>(4), "
"B<urandom>(4), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/request_key.2:12
#, no-wrap
msgid "REQUEST_KEY"
msgstr ""

#. type: TH
#: man-pages/man2/request_key.2:12
#, no-wrap
msgid "Linux Key Management Calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:15
msgid "request_key - request a key from the kernel's key management facility"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>keyutils.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:23
#, no-wrap
msgid ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<dest_keyring>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:26
msgid "No glibc wrapper is provided for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:38
msgid ""
"B<request_key>()  attempts to find a key of the given I<type> with a "
"description (name) that matches the specified I<description>.  If such a key"
" could not be found, then the key is optionally created.  If the key is "
"found or created, B<request_key>()  attaches it to the keyring whose ID is "
"specified in I<dest_keyring> and returns the key's serial number."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:44
msgid ""
"B<request_key>()  first recursively searches for a matching key in all of "
"the keyrings attached to the calling process.  The keyrings are searched in "
"the order: thread-specific keyring, process-specific keyring, and then "
"session keyring."
msgstr ""

#.  David Howells: we can then have an arbitrarily long sequence
#.  of "recursive" request-key upcalls. There is no limit, other
#.  than number of PIDs, etc.
#. type: Plain text
#: man-pages/man2/request_key.2:56
msgid ""
"If B<request_key>()  is called from a program invoked by B<request_key>()  "
"on behalf of some other process to generate a key, then the keyrings of that"
" other process will be searched next, using that other process's user ID, "
"group ID, supplementary group IDs, and security context to determine access."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:65
msgid ""
"The search of the keyring tree is breadth-first: the keys in each keyring "
"searched are checked for a match before any child keyrings are recursed "
"into.  Only keys for which the caller has I<search> permission be found, and"
" only keyrings for which the caller has I<search> permission may be "
"searched."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:70
msgid ""
"If the key is not found and I<callout> is NULL, then the call fails with the"
" error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:76
msgid ""
"If the key is not found and I<callout> is not NULL, then the kernel attempts"
" to invoke a user-space program to instantiate the key.  The details are "
"given below."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:82
msgid ""
"The I<dest_keyring> serial number may be that of a valid keyring for which "
"the caller has I<write> permission, or it may be one of the following "
"special keyring IDs:"
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:82
#, no-wrap
msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:86
msgid ""
"This specifies the caller's thread-specific keyring (see B<thread-"
"keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:86
#, no-wrap
msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:90
msgid ""
"This specifies the caller's process-specific keyring (see B<process-"
"keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:90
#, no-wrap
msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:94
msgid ""
"This specifies the caller's session-specific keyring (see B<session-"
"keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:94
#, no-wrap
msgid "B<KEY_SPEC_USER_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:98
msgid ""
"This specifies the caller's UID-specific keyring (see B<user-keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:98
#, no-wrap
msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:102
msgid ""
"This specifies the caller's UID-session keyring (see B<user-session-"
"keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:108
msgid ""
"When the I<dest_keyring> is specified as 0 and no key construction has been "
"performed, then no additional linking is done."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:121
msgid ""
"Otherwise, if I<dest_keyring> is 0 and a new key is constructed, the new key"
" will be linked to the \"default\" keyring.  More precisely, when the kernel"
" tries to determine to which keyring the newly constructed key should be "
"linked, it tries the following keyrings, beginning with the keyring set via "
"the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation and continuing in "
"the order shown below until it finds the first keyring that exists:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:121 man-pages/man2/request_key.2:131
#: man-pages/man2/request_key.2:136 man-pages/man2/request_key.2:141
#: man-pages/man2/request_key.2:146 man-pages/man2/request_key.2:152
#, no-wrap
msgid "\\(bu"
msgstr ""

#.  8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#.  FIXME
#.  Actually, is the preceding point correct?
#.  If I understand correctly, we'll only get here if
#.  'dest_keyring' is zero, in which case KEY_REQKEY_DEFL_REQUESTOR_KEYRING
#.  won't refer to a keyring. Have I misunderstood?
#. type: Plain text
#: man-pages/man2/request_key.2:131
msgid ""
"The requestor keyring (B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING>, since Linux "
"2.6.29)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:136
msgid ""
"The thread-specific keyring (B<KEY_REQKEY_DEFL_THREAD_KEYRING>; see B"
"<thread-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:141
msgid ""
"The process-specific keyring (B<KEY_REQKEY_DEFL_PROCESS_KEYRING>; see B"
"<process-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:146
msgid ""
"The session-specific keyring (B<KEY_REQKEY_DEFL_SESSION_KEYRING>; see B"
"<session-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:152
msgid ""
"The session keyring for the process's user ID "
"(B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>; see B<user-session-keyring>(7)).  "
"This keyring is expected to always exist."
msgstr ""

#.  mtk: Are there circumstances where the user sessions and UID-specific
#.  keyrings do not exist?
#.  David Howells:
#.      The uid keyrings don't exist until someone tries to access them -
#.      at which point they're both created.  When you log in, pam_keyinit
#.      creates a link to your user keyring in the session keyring it just
#.      created, thereby creating the user and user-session keyrings.
#.  and David elaborated that "access" means:
#.      It means lookup_user_key() was passed KEY_LOOKUP_CREATE.  So:
#.          add_key() - destination keyring
#.          request_key() - destination keyring
#.          KEYCTL_GET_KEYRING_ID - if create arg is true
#.          KEYCTL_CLEAR
#.          KEYCTL_LINK - both args
#.          KEYCTL_SEARCH - destination keyring
#.          KEYCTL_CHOWN
#.          KEYCTL_SETPERM
#.          KEYCTL_SET_TIMEOUT
#.          KEYCTL_INSTANTIATE - destination keyring
#.          KEYCTL_INSTANTIATE_IOV - destination keyring
#.          KEYCTL_NEGATE - destination keyring
#.          KEYCTL_REJECT - destination keyring
#.          KEYCTL_GET_PERSISTENT - destination keyring
#.      will all create a keyring under some circumstances.  Whereas the rest,
#.      such as KEYCTL_GET_SECURITY, KEYCTL_READ and KEYCTL_REVOKE, won't.
#. type: Plain text
#: man-pages/man2/request_key.2:188
msgid ""
"The UID-specific keyring (B<KEY_REQKEY_DEFL_USER_KEYRING>; see B<user-"
"keyring>(7)).  This keyring is also expected to always exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:200
msgid ""
"If the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation specifies "
"B<KEY_REQKEY_DEFL_DEFAULT> (or no B<KEYCTL_SET_REQKEY_KEYRING> operation is "
"performed), then the kernel looks for a keyring starting from the beginning "
"of the list."
msgstr ""

#. type: SS
#: man-pages/man2/request_key.2:200
#, no-wrap
msgid "Requesting user-space instantiation of a key"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:213
msgid ""
"If the kernel cannot find a key matching I<type> and I<description>, and "
"I<callout> is not NULL, then the kernel attempts to invoke a user-space "
"program to instantiate a key with the given I<type> and I<description>.  In "
"this case, the following steps are performed:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:213
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:218
msgid ""
"The kernel creates an uninstantiated key, U, with the requested I<type> and "
"I<description>."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:218
#, no-wrap
msgid "b)"
msgstr ""

#.  struct request_key_auth, defined in security/keys/internal.h
#. type: Plain text
#: man-pages/man2/request_key.2:224
msgid ""
"The kernel creates an authorization key, V, that refers to the key U and "
"records the facts that the caller of B<request_key>()  is:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:225
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:227
msgid "the context in which the key U should be instantiated and secured, and"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:227
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:229
msgid "the context from which associated key requests may be satisfied."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:232
msgid "The authorization key is constructed as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:236
msgid "The key type is I<\".request_key_auth\">."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:239
msgid ""
"The key's UID and GID are the same as the corresponding filesystem IDs of "
"the requesting process."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:248
msgid ""
"The key grants I<view>, I<read>, and I<search> permissions to the key "
"possessor as well as I<view> permission for the key user."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:252
msgid ""
"The description (name) of the key is the hexadecimal string representing the"
" ID of the key that is to be instantiated in the requesting program."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:255
msgid ""
"The payload of the key is taken from the data specified in I<callout_info>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:258
msgid ""
"Internally, the kernel also records the PID of the process that called "
"B<request_key>()."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:259
#, no-wrap
msgid "c)"
msgstr ""

#.  The request-key(8) program can be invoked in circumstances *other* than
#.  when triggered by request_key(2). For example, upcalls from places such
#.  as the DNS resolver.
#. type: Plain text
#: man-pages/man2/request_key.2:266
msgid ""
"The kernel creates a process that executes a user-space service such as B"
"<request-key>(8)  with a new session keyring that contains a link to the "
"authorization key, V."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:268
msgid "This program is supplied with the following command-line arguments:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:269
#, no-wrap
msgid "[0]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:272
msgid "The string I<\"/sbin/request-key\">."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:272
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:276
msgid "The string I<\"create\"> (indicating that a key is to be created)."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:276
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:278
msgid "The ID of the key that is to be instantiated."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:278
#, no-wrap
msgid "[3]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:281
msgid "The filesystem UID of the caller of B<request_key>()."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:281
#, no-wrap
msgid "[4]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:284
msgid "The filesystem GID of the caller of B<request_key>()."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:284
#, no-wrap
msgid "[5]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:288
msgid ""
"The ID of the thread keyring of the caller of B<request_key>().  This may be"
" zero if that keyring hasn't been created."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:288
#, no-wrap
msgid "[6]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:292
msgid ""
"The ID of the process keyring of the caller of B<request_key>().  This may "
"be zero if that keyring hasn't been created."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:292
#, no-wrap
msgid "[7]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:295
msgid "The ID of the session keyring of the caller of B<request_key>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:303
msgid ""
"I<Note>: each of the command-line arguments that is a key ID is encoded in "
"I<decimal> (unlike the key IDs shown in I</proc/keys>, which are shown as "
"hexadecimal values)."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:303
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:305
msgid "The program spawned in the previous step:"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:313
msgid ""
"Assumes the authority to instantiate the key U using the B<keyctl>(2)  "
"B<KEYCTL_ASSUME_AUTHORITY> operation (typically via the "
"B<keyctl_assume_authority>(3)  function)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:322
msgid ""
"Obtains the callout data from the payload of the authorization key V (using "
"the B<keyctl>(2)  B<KEYCTL_READ> operation (or, more commonly, the "
"B<keyctl_read>(3)  function) with a key ID value of "
"B<KEY_SPEC_REQKEY_AUTH_KEY>)."
msgstr ""

#.  Should an instantiating program be using KEY_SPEC_REQUESTOR_KEYRING?
#.  I couldn't find a use in the keyutils git repo.
#.  According to David Howells:
#.  * This feature is provided, but not used at the moment.
#.  * A key added to that ring is then owned by the requester
#. type: Plain text
#: man-pages/man2/request_key.2:344
msgid ""
"Instantiates the key (or execs another program that performs that task), "
"specifying the payload and destination keyring.  (The destination keyring "
"that the requestor specified when calling B<request_key>()  can be accessed "
"using the special key ID B<KEY_SPEC_REQUESTOR_KEYRING>.)  Instantiation is "
"performed using the B<keyctl>(2)  B<KEYCTL_INSTANTIATE> operation (or, more "
"commonly, the B<keyctl_instantiate>(3)  function).  At this point, the "
"B<request_key>()  call completes, and the requesting program can continue "
"execution."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:361
msgid ""
"If these steps are unsuccessful, then an B<ENOKEY> error will be returned to"
" the caller of B<request_key>()  and a temporary, negatively instantiated "
"key will be installed in the keyring specified by I<dest_keyring>.  This "
"will expire after a few seconds, but will cause subsequent calls to "
"B<request_key>()  to fail until it does.  The purpose of this negatively "
"instantiated key is to prevent (possibly different) processes making "
"repeated requests (that require expensive B<request-key>(8)  upcalls) for a "
"key that can't (at the moment) be positively instantiated."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:369
msgid ""
"Once the key has been instantiated, the authorization key "
"(B<KEY_SPEC_REQKEY_AUTH_KEY>)  is revoked, and the destination keyring "
"(B<KEY_SPEC_REQUESTOR_KEYRING>)  is no longer accessible from the B<request-"
"key>(8)  program."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:374
msgid ""
"If a key is created, then\\(emregardless of whether it is a valid key or a "
"negatively instantiated key\\(emit will displace any other key with the same"
" type and description from the keyring specified in I<dest_keyring>."
msgstr ""

#. type: SH
#: man-pages/man2/request_key.2:374
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:381
msgid ""
"On success, B<request_key>()  returns the serial number of the key it found "
"or caused to be created.  On error, -1 is returned and I<errno> is set to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:385
msgid "The keyring wasn't available for modification by the user."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:385
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:389
msgid ""
"The key quota for this user would be exceeded by creating this key or "
"linking it to the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:397
msgid ""
"One of I<type>, I<description>, or I<callout_info> points outside the "
"process's accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:397
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:401
msgid "The request was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:408
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<type> or I<description> exceeded the limit (32 bytes and 4096 bytes "
"respectively)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:413
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<callout_info> exceeded the system page size."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:413
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:416
msgid "An expired key was found, but no replacement could be obtained."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:416
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:419
msgid "The attempt to generate a new key was rejected."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:419
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:422
msgid "A revoked key was found, but no replacement could be obtained."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:422
#, no-wrap
msgid "B<ENOKEY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:425
msgid "No matching key was found."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:425
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:428
msgid "Insufficient memory to create a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:433
msgid "The I<type> argument started with a period (\\(aq.\\(aq)."
msgstr ""

#.  commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
#. type: Plain text
#: man-pages/man2/request_key.2:438
msgid ""
"This system call first appeared in Linux 2.6.10.  The ability to instantiate"
" keys upon request was added in Linux 2.6.13."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:440
msgid "This system call is a nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:447
msgid ""
"No wrapper for this system call is provided in glibc.  A wrapper is provided"
" in the I<libkeyutils> package.  When employing the wrapper in that library,"
" link with I<-lkeyutils>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:458
msgid ""
"The program below demonstrates the use of B<request_key>().  The I<type>, "
"I<description>, and I<callout_info> arguments for the system call are taken "
"from the values supplied in the command-line arguments.  The call specifies "
"the session keyring as the target keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:462
msgid ""
"In order to demonstrate this program, we first create a suitable entry in "
"the file I</etc/request-key.conf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:469
#, no-wrap
msgid ""
"$ sudo sh\n"
"# B<echo 'create user mtk:* *   /bin/keyctl instantiate %k %c %S' \\e>\n"
"          B<E<gt> /etc/request-key.conf>\n"
"# B<exit>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:496
msgid ""
"This entry specifies that when a new \"user\" key with the prefix \"mtk:\" "
"must be instantiated, that task should be performed via the B<keyctl>(1)  "
"command's B<instantiate> operation.  The arguments supplied to the "
"B<instantiate> operation are: the ID of the uninstantiated key (I<%k>); the "
"callout data supplied to the B<request_key>()  call (I<%c>); and the session"
" keyring (I<%S>)  of the requestor (i.e., the caller of B<request_key>()).  "
"See B<request-key.conf>(5)  for details of these I<%> specifiers."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:500
msgid ""
"Then we run the program and check the contents of I</proc/keys> to verify "
"that the requested key has been instantiated:"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:506
#, no-wrap
msgid ""
"$ B<./t_request_key user mtk:key1 \"Payload data\">\n"
"$ B<grep \\(aq2dddaf50\\(aq /proc/keys>\n"
"2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:511
msgid "For another example of the use of this program, see B<keyctl>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/request_key.2:511
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:515
#, no-wrap
msgid "/* t_request_key.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:521
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:526
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    key_serial_t key;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:532
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s type description callout-data\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:539
#, no-wrap
msgid ""
"    key = request_key(argv[1], argv[2], argv[3],\n"
"                      KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"request_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:541
#, no-wrap
msgid "    printf(\"Key ID is %lx\\en\", (long) key);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:544
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:562
msgid ""
"B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<keyctl>(3), B<capabilities>(7),"
" B<keyrings>(7), B<keyutils>(7), B<persistent-keyring>(7), B<process-"
"keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7), B<request-key>(8)"
msgstr ""

#.  commit b68101a1e8f0263dbc7b8375d2a7c57c6216fb76
#.  commit 3db38ed76890565772fcca3279cc8d454ea6176b
#. type: Plain text
#: man-pages/man2/request_key.2:572
msgid ""
"The kernel source files I<Documentation/security/keys/core.rst> and "
"I<Documentation/keys/request-key.rst> (or, before Linux 4.13, in the files "
"I<Documentation/security/keys.txt> and I<Documentation/security/keys-"
"request-key.txt>)."
msgstr ""

#. type: TH
#: man-pages/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:42
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:54
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows"
" the caller to receive multiple messages from a socket using a single system"
" call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:58
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:66
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:72
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:79
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:94
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the"
" message in the entry.  This field has the same value as the return value of"
" a single B<recvmsg>(2)  on the header."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:101
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""

#. type: TP
#: man-pages/man2/recvmmsg.2:101
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:106
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:121
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation (I<but see BUGS!>).  (This interval will be rounded up to "
"the system clock granularity, and kernel scheduling delays mean that the "
"blocking interval may overrun by a small amount.)  If I<timeout> is NULL, "
"then the operation blocks indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:132
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:147
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:155
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:159
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can "
"occur:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:163
msgid "I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:165
msgid "See also BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:170
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:173
msgid "B<recvmmsg>()  is Linux-specific."
msgstr ""

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=75371
#.  http://thread.gmane.org/gmane.linux.man/5677
#. type: Plain text
#: man-pages/man2/recvmmsg.2:184
msgid ""
"The I<timeout> argument does not work as intended.  The timeout is checked "
"only after the receipt of each datagram, so that if up to I<vlen-1> "
"datagrams are received before the timeout expires, but then no further "
"datagrams are received, the call will block forever."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:192
msgid ""
"If an error occurs after at least one message has been received, the call "
"succeeds, and returns the number of messages received.  The error code is "
"expected to be returned on a subsequent call to B<recvmmsg>().  In the "
"current implementation, however, the error code can be overwritten in the "
"meantime by an unrelated network event on a socket, for example an incoming "
"ICMP packet."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:200
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers"
" are filled or if the timeout specified has expired."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:203
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:208
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\n"
"B<sleep 0.25; done>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:213
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:223
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:234
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:247
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval, i;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:253
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:261
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:269
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:272
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:278
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:286
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:293
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:28
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:31
#, no-wrap
msgid ""
"B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t "
"*>I<uinfo>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:34
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:38
msgid ""
"I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:50
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or thread."
"  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:56
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:68
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group "
"(i.e., one of the threads that is not currently blocking the signal)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:79
msgid ""
"The I<uinfo> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:79
#, no-wrap
msgid "I<si_code>"
msgstr ""

#.  tkill(2) or
#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:95
msgid ""
"This must be one of the B<SI_*> codes in the Linux kernel source file "
"I<include/asm-generic/siginfo.h>, with the restriction that the code must be"
" negative (i.e., cannot be B<SI_USER>, which is used by the kernel to "
"indicate a signal sent by B<kill>(2))  and cannot (since Linux 2.6.39) be "
"B<SI_TKILL> (which is used by the kernel to indicate a signal sent using "
"B<tgkill>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:95
#, no-wrap
msgid "I<si_pid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:99
msgid ""
"This should be set to a process ID, typically the process ID of the sender."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:99
#, no-wrap
msgid "I<si_uid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:103
msgid ""
"This should be set to a user ID, typically the real user ID of the sender."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:103
#, no-wrap
msgid "I<si_value>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:110
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:117
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number"
" via that field."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:129
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:134
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:141
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:148
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:156
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2).  Or: I<uinfo-E<gt>si_code> is "
"invalid."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:156
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:162
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:169
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:176
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version "
"2.6.31."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:178
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:183
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:188
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:195
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/restart_syscall.2:33
#, no-wrap
msgid "RESTART_SYSCALL"
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:36
msgid ""
"restart_syscall - restart a system call after interruption by a stop signal"
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:38
msgid "B<int restart_syscall(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:53
msgid ""
"The B<restart_syscall>()  system call is used to restart certain system "
"calls after a process that was stopped by a signal (e.g., B<SIGSTOP> or "
"B<SIGTSTP>)  is later resumed after receiving a B<SIGCONT> signal.  This "
"system call is designed only for internal use by the kernel."
msgstr ""

#.  These system calls correspond to the special internal errno value
#.  ERESTART_RESTARTBLOCK. Each of the system calls has a "restart"
#.  helper function that is invoked by restart_syscall().
#.  Notable (as at Linux 3.17) is that poll() has such a "restart"
#.  function, but ppoll(), select(), and pselect() do not.
#.  This means that the latter system calls do not take account of the
#.  time spent in the stopped state when restarting.
#. type: Plain text
#: man-pages/man2/restart_syscall.2:88
msgid ""
"B<restart_syscall>()  is used for restarting only those system calls that, "
"when restarted, should adjust their time-related parameters\\(emnamely "
"B<poll>(2)  (since Linux 2.6.24), B<nanosleep>(2)  (since Linux 2.6), "
"B<clock_nanosleep>(2)  (since Linux 2.6), and B<futex>(2), when employed "
"with the B<FUTEX_WAIT> (since Linux 2.6.22)  and B<FUTEX_WAIT_BITSET> (since"
" Linux 2.6.31)  operations.  B<restart_syscall>()  restarts the interrupted "
"system call with a time argument that is suitably adjusted to account for "
"the time that has already elapsed (including the time where the process was "
"stopped by a signal).  Without the B<restart_syscall>()  mechanism, "
"restarting these system calls would not correctly deduct the already elapsed"
" time when the process continued execution."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:92
msgid ""
"The return value of B<restart_syscall>()  is the return value of whatever "
"system call is being restarted."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:96
msgid ""
"I<errno> is set as per the errors for whatever system call is being "
"restarted by B<restart_syscall>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:100
msgid "The B<restart_syscall>()  system call is present since Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:102
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:106
msgid ""
"There is no glibc wrapper for this system call, because it is intended for "
"use only by the kernel and should never be called by applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:128
msgid ""
"The kernel uses B<restart_syscall>()  to ensure that when a system call is "
"restarted after a process has been stopped by a signal and then resumed by "
"B<SIGCONT>, then the time that the process spent in the stopped state is "
"counted against the timeout interval specified in the original system call."
"  In the case of system calls that take a timeout argument and automatically"
" restart after a stop signal plus B<SIGCONT>, but which do not have the "
"B<restart_syscall>()  mechanism built in, then, after the process resumes "
"execution, the time that the process spent in the stop state is I<not> "
"counted against the timeout value.  Notable examples of system calls that "
"suffer this problem are B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:135
msgid ""
"From user space, the operation of B<restart_syscall>()  is largely "
"invisible: to the process that made the system call that is restarted, it "
"appears as though that system call executed and returned in the usual "
"fashion."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:138
msgid "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "READ"
msgstr ""

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "2018-02-02"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:38
msgid "read - read from a file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:41
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:43
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:52
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:60
msgid ""
"On files that support seeking, the read operation commences at the file "
"offset, and the file offset is incremented by the number of bytes read.  If "
"the file offset is at or past the end of file, no bytes are read, and "
"B<read>()  returns zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:75
msgid ""
"If I<count> is zero, B<read>()  I<may> detect the errors described below.  "
"In the absence of any errors, or if B<read>()  does not check for errors, a "
"B<read>()  with a I<count> of 0 returns zero and has no other effects."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:82
msgid ""
"According to POSIX.1, if I<count> is greater than B<SSIZE_MAX>, the result "
"is implementation-defined; see NOTES for the upper limit on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:92
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error"
" if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  See also NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:98
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately.  In this case, "
"it is left unspecified whether the file position (if any) changes."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:111
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr ""

#. type: TP
#: man-pages/man2/read.2:111
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/read.2:122
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking"
" (B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: TP
#: man-pages/man2/read.2:122
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:126
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:130
msgid "I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:134
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:145
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:155
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""

#. type: TP
#: man-pages/man2/read.2:155
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:175
msgid ""
"I/O error.  This will happen for example when the process is in a background"
" process group, tries to read from its controlling terminal, and either it "
"is ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may"
" also occur when there is a low-level I/O error while reading from a disk or"
" tape.  A further possible cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has"
" been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""

#. type: TP
#: man-pages/man2/read.2:175
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:179
msgid "I<fd> refers to a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:182
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:184
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:191
msgid ""
"The types I<size_t> and I<ssize_t> are, respectively, unsigned and signed "
"integer data types specified by POSIX.1."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: man-pages/man2/read.2:199
msgid ""
"On Linux, B<read>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:215
msgid ""
"On NFS filesystems, reading small amounts of data will update the timestamp "
"only the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"I<st_atime> (last file access time)  updates to the server, and client side "
"reads satisfied from the client's cache will not cause I<st_atime> updates "
"on the server as there are no server-side reads.  UNIX semantics can be "
"obtained by disabling client-side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:218
msgid ""
"According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions "
"with Regular File Operations\"):"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:223
msgid ""
"All of the following functions shall be atomic with respect to each other in"
" the effects specified in POSIX.1-2008 when they operate on regular files or"
" symbolic links: ..."
msgstr ""

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: man-pages/man2/read.2:254
msgid ""
"Among the APIs subsequently listed are B<read>()  and B<readv>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was"
" not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<read>()  (or B<readv>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the reads in the two processes might (incorrectly) "
"overlap in the blocks of data that they obtained.  This problem was fixed in"
" Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:266
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2),"
" B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:31
msgid "readahead - initiate file readahead into page cache"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:37
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:44
msgid ""
"B<readahead>()  initiates readahead on a file so that subsequent reads from "
"that file will be satisfied from the cache, and not block on disk I/O "
"(assuming the readahead was initiated early enough and that other activity "
"on the system did not in the meantime flush pages from the cache)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:66
msgid ""
"The I<fd> argument is a file descriptor identifying the file which is to be "
"read.  The I<offset> argument specifies the starting point from which data "
"is to be read and I<count> specifies the number of bytes to be read.  I/O is"
" performed in whole pages, so that I<offset> is effectively rounded down to "
"a page boundary and bytes are read up to the next page boundary greater than"
" or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the "
"end of the file.  The file offset of the open file description referred to "
"by the file descriptor I<fd> is left unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:72
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:83
msgid ""
"I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:88
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:93
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:98
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:107
msgid ""
"B<readahead>()  attempts to schedule the reads in the background and return "
"immediately.  However, it may block while it reads the filesystem metadata "
"needed to locate the requested blocks.  This occurs frequently with ext[234]"
" on large files using indirect blocks instead of extents, giving the "
"appearance that the call blocks until the requested data has been read."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:112
msgid ""
"B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/readlink.2:44
#, no-wrap
msgid "READLINK"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:47
msgid "readlink, readlinkat - read value of a symbolic link"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:53
#, no-wrap
msgid ""
"B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:56
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:59
#, no-wrap
msgid ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:64
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:68
msgid "B<readlink>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/readlink.2:72
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:75
msgid "B<readlinkat>():"
msgstr ""

#. type: TP
#: man-pages/man2/readlink.2:78
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:81
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: man-pages/man2/readlink.2:81
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:84
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:101
msgid ""
"B<readlink>()  places the contents of the symbolic link I<pathname> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will (silently) truncate the contents (to a length "
"of I<bufsiz> characters), in case the buffer is too small to hold all of the"
" contents."
msgstr ""

#. type: SS
#: man-pages/man2/readlink.2:101
#, no-wrap
msgid "readlinkat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:107
msgid ""
"The B<readlinkat>()  system call operates in exactly the same way as "
"B<readlink>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:117
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<readlink>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:129
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<readlink>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:135
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: man-pages/man2/readlink.2:149
msgid ""
"Since Linux 2.6.39, I<pathname> can be an empty string, in which case the "
"call operates on the symbolic link referred to by I<dirfd> (which should "
"have been obtained using B<open>(2)  with the B<O_PATH> and B<O_NOFOLLOW> "
"flags)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:154
msgid "See B<openat>(2)  for an explanation of the need for B<readlinkat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:163
msgid ""
"On success, these calls return the number of bytes placed in I<buf>.  (If "
"the returned value equals I<bufsiz>, then truncation may have occurred.)  On"
" error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:169
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:173
msgid "I<buf> extends outside the process's allocated address space."
msgstr ""

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: man-pages/man2/readlink.2:182
msgid "I<bufsiz> is not positive."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:187
msgid ""
"The named file (i.e., the final filename component of I<pathname>)  is not a"
" symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:190
msgid "An I/O error occurred while reading from the filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/readlink.2:190
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:193
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""

#. type: TP
#: man-pages/man2/readlink.2:193
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:196
msgid "A pathname, or a component of a pathname, was too long."
msgstr ""

#. type: TP
#: man-pages/man2/readlink.2:196
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:199
msgid "The named file does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:202
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: man-pages/man2/readlink.2:202 man-pages/man2/readlink.2:212
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:205
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:208
msgid "The following additional errors can occur for B<readlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:212
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:218
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:222
msgid ""
"B<readlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:228
msgid ""
"B<readlink>(): 4.4BSD (B<readlink>()  first appeared in 4.2BSD), "
"POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:231
msgid "B<readlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:239
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:262
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  and "
"B<readlinkat>()  should be checked to make sure that the size of the "
"symbolic link did not increase between the calls.  Dynamically allocating "
"the buffer for B<readlink>()  and B<readlinkat>()  also addresses a common "
"portability problem when using I<PATH_MAX> for the buffer size, as this "
"constant is not guaranteed to be defined per POSIX if the system does not "
"have such limit."
msgstr ""

#. type: SS
#: man-pages/man2/readlink.2:262
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:275
msgid ""
"On older kernels where B<readlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<readlink>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in"
" I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:285
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(2), falling back to a "
"buffer of size B<PATH_MAX> in cases where B<lstat>(2)  reports a size of "
"zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:293
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:300
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:305
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:310
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:313
#, no-wrap
msgid ""
"    /* Add one to the link size, so that we can determine whether\n"
"       the buffer returned by readlink() was truncated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:315
#, no-wrap
msgid "    bufsiz = sb.st_size + 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:319
#, no-wrap
msgid ""
"    /* Some magic symlinks under (for example) /proc and /sys\n"
"       report \\(aqst_size\\(aq as zero. In that case, take PATH_MAX as\n"
"       a \"good enough\" estimate. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:322
#, no-wrap
msgid ""
"    if (sb.st_size == 0)\n"
"        bufsiz = PATH_MAX;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:328
#, no-wrap
msgid ""
"    buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:334
#, no-wrap
msgid ""
"    nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:336
#, no-wrap
msgid ""
"    printf(\"\\(aq%s\\(aq points to \\(aq%.*s\\(aq\\en\", argv[1], (int) "
"nbytes, buf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:342
#, no-wrap
msgid ""
"    /* If the return value was equal to the buffer size, then the\n"
"       the link target was larger than expected (perhaps because the\n"
"       target was changed between the call to lstat() and the call to\n"
"       readlink()). Warn the user that the returned target may have\n"
"       been truncated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:345
#, no-wrap
msgid ""
"    if (nbytes == bufsiz)\n"
"        printf(\"(Returned buffer may have been truncated)\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:349
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:357
msgid ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""

#.  commit 33041a0d76d3c3e0aff28ac95a2ffdedf1282dbc
#.  http://lwn.net/Articles/597632/
#.  commit c8d78c1823f46519473949d33f0d1d33fe21ea16
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:53
msgid ""
"B<Note>: this system call was marked as deprecated starting with Linux 3.16."
"  In Linux 4.0, the implementation was replaced by a slower in-kernel "
"emulation.  Those few applications that use this system call should consider"
" migrating to alternatives.  This change was made because the kernel code "
"for this system call was complex, and it is believed to be little used or "
"perhaps even completely unused.  While it had some use cases in database "
"applications on 32-bit systems, those use cases don't exist on 64-bit "
"systems."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:65
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a"
" nonsequential order in memory.  The advantage of using "
"B<remap_file_pages>()  over using repeated calls to B<mmap>(2)  is that the "
"former approach does not require the kernel to create additional VMA "
"(Virtual Memory Area) data structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:67
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr ""

#. type: TP
#: man-pages/man2/remap_file_pages.2:67
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:75
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""

#. type: TP
#: man-pages/man2/remap_file_pages.2:75
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:83
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within"
" the mapped region."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:94
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to"
" be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:112
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff>"
" and I<size> will be placed."
msgstr ""

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:126
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:130
msgid "The I<prot> argument must be specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:138
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:145
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and"
" I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:153
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:162
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:167
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:171
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr ""

#.  commit 3ee6dafc677a68e461a7ddafc94a580ebab80735
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:184
msgid ""
"Since Linux 2.6.23, B<remap_file_pages>()  creates non-linear mappings only "
"on in-memory filesystems such as B<tmpfs>(5), hugetlbfs or ramfs.  On "
"filesystems with a backing store, B<remap_file_pages>()  is not much more "
"efficient than using B<mmap>(2)  to adjust which parts of the file are "
"mapped to which addresses."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:190
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/rename.2:33
#, no-wrap
msgid "RENAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:36
msgid "rename, renameat, renameat2 - change the name or location of a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:39
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:41
#, no-wrap
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:47
#, no-wrap
msgid ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:51
#, no-wrap
msgid ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:59
msgid "B<renameat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:71
msgid "B<renameat2>():"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:72
#, no-wrap
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:86
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any"
" other hard links to the file (as created using B<link>(2))  are unaffected."
"  Open file descriptors for I<oldpath> are also unaffected."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:89
msgid ""
"Various restrictions determine whether or not the rename operation succeeds:"
" see ERRORS below."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:101
msgid ""
"If I<newpath> already exists, it will be atomically replaced, so that there "
"is no point at which another process attempting to access I<newpath> will "
"find it missing.  However, there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:109
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:117
msgid ""
"If I<newpath> exists but the operation fails for some reason, B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:123
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:129
msgid ""
"If I<oldpath> refers to a symbolic link, the link is renamed; if I<newpath> "
"refers to a symbolic link, the link will be overwritten."
msgstr ""

#. type: SS
#: man-pages/man2/rename.2:129
#, no-wrap
msgid "renameat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:135
msgid ""
"The B<renameat>()  system call operates in exactly the same way as "
"B<rename>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:145
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<rename>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:157
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<rename>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:163
msgid "If I<oldpath> is absolute, then I<olddirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:171
msgid ""
"The interpretation of I<newpath> is as for I<oldpath>, except that a "
"relative pathname is interpreted relative to the directory referred to by "
"the file descriptor I<newdirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:176
msgid "See B<openat>(2)  for an explanation of the need for B<renameat>()."
msgstr ""

#. type: SS
#: man-pages/man2/rename.2:176
#, no-wrap
msgid "renameat2()"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:187
msgid ""
"B<renameat2>()  has an additional I<flags> argument.  A B<renameat2>()  call"
" with a zero I<flags> argument is equivalent to B<renameat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:191
msgid ""
"The I<flags> argument is a bit mask consisting of zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:191
#, no-wrap
msgid "B<RENAME_EXCHANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:200
msgid ""
"Atomically exchange I<oldpath> and I<newpath>.  Both pathnames must exist "
"but may be of different types (e.g., one could be a non-empty directory and "
"the other a symbolic link)."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:200
#, no-wrap
msgid "B<RENAME_NOREPLACE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:208
msgid ""
"Don't overwrite I<newpath> of the rename.  Return an error if I<newpath> "
"already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:212
msgid ""
"B<RENAME_NOREPLACE> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:216
msgid ""
"B<RENAME_NOREPLACE> requires support from the underlying filesystem.  "
"Support for various filesystems was added as follows:"
msgstr ""

#.  ext4: commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c
#. type: Plain text
#: man-pages/man2/rename.2:220
msgid "ext4 (Linux 3.15);"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:222
msgid "btrfs, shmem, and cifs (Linux 3.17);"
msgstr ""

#.  btrfs: commit 80ace85c915d0f41016f82917218997b72431258
#.  shmem: commit 3b69ff51d087d265aa4af3a532fc4f20bf33e718
#.  cifs: commit 7c33d5972ce382bcc506d16235f1e9b7d22cbef8
#.  gfs2 in 4.2?
#. type: Plain text
#: man-pages/man2/rename.2:229
msgid "xfs (Linux 4.0);"
msgstr ""

#.  Also affs, bfs, exofs, hfs, hfsplus, jffs2, logfs, msdos,
#.  nilfs2, omfs, sysvfs, ubifs, udf, ufs
#.  hugetlbfs, ramfs
#.  local filesystems: commit f03b8ad8d38634d13e802165cc15917481b47835
#.  libfs: commit e0e0be8a835520e2f7c89f214dfda570922a1b90
#. type: Plain text
#: man-pages/man2/rename.2:237
msgid ""
"Support for many other filesystems was added in Linux 4.9, including etx2, "
"minix, reiserfs, jfs, vfat, and bpf."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:238
#, no-wrap
msgid "B<RENAME_WHITEOUT> (since Linux 3.18)"
msgstr ""

#.  commit 0d7a855526dd672e114aff2ac22b60fc6f155b08
#.  commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
#. type: Plain text
#: man-pages/man2/rename.2:244
msgid ""
"This operation makes sense only for overlay/union filesystem "
"implementations."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:251
msgid ""
"Specifying B<RENAME_WHITEOUT> creates a \"whiteout\" object at the source of"
" the rename at the same time as performing the rename.  The whole operation "
"is atomic, so that if the rename succeeds then the whiteout will also have "
"been created."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:259
msgid ""
"A \"whiteout\" is an object that has special meaning in union/overlay "
"filesystem constructs.  In these constructs, multiple layers exist and only "
"the top one is ever modified.  A whiteout on an upper layer will effectively"
" hide a matching file in the lower layer, making it appear as if the file "
"didn't exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:267
msgid ""
"When a file that exists on the lower layer is renamed, the file is first "
"copied up (if not already on the upper layer)  and then renamed on the "
"upper, read-write layer.  At the same time, the source file needs to be "
"\"whiteouted\" (so that the version of the source file in the lower layer is"
" rendered invisible).  The whole operation needs to be done atomically."
msgstr ""

#. https://www.freebsd.org/cgi/man.cgi?query=mount_unionfs&manpath=FreeBSD+11.0-RELEASE
#. type: Plain text
#: man-pages/man2/rename.2:278
msgid ""
"When not part of a union/overlay, the whiteout appears as a character device"
" with a {0,0} device number.  (Note that other union/overlay implementations"
" may employ different methods for storing whiteout entries; specifically, "
"BSD union mount employs a separate inode type, B<DT_WHT>, which, while "
"supported by some filesystems available in Linux, such as CODA and XFS, is "
"ignored by the kernel's whiteout support code, as of Linux 4.19, at least.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:283
msgid ""
"B<RENAME_WHITEOUT> requires the same privileges as creating a device node "
"(i.e., the B<CAP_MKNOD> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:287
msgid "B<RENAME_WHITEOUT> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#.  tmpfs: commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df
#.  ext4: commit cd808deced431b66b5fa4e5c193cb7ec0059eaff
#.  XFS: commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00
#.  f2fs: commit 7e01e7ad746bc8198a8b46163ddc73a1c7d22339
#.  btrfs: commit cdd1fedf8261cd7a73c0596298902ff4f0f04492
#.  ubifs: commit 9e0a1fff8db56eaaebb74b4a3ef65f86811c4798
#. type: Plain text
#: man-pages/man2/rename.2:303
msgid ""
"B<RENAME_WHITEOUT> requires support from the underlying filesystem.  Among "
"the filesystems that provide that support are tmpfs (since Linux 3.18), ext4"
" (since Linux 3.18), XFS (since Linux 4.1), f2fs (since Linux 4.2).  btrfs "
"(since Linux 4.7), and ubifs (since Linux 4.9)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:308
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:328
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:328
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:345
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such "
"cases\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:348
msgid "The user's quota of disk blocks on the filesystem has been exhausted."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:351
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:355
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:361
msgid ""
"I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:365
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:365
#, no-wrap
msgid "B<EMLINK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:372
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:375
msgid "I<oldpath> or I<newpath> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:388
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:391
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:395
msgid ""
"The device containing the file has no room for the new directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:405
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact,"
" a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:405
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:409
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than "
"\".\" and \"..\"."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:409
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:433
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and"
" the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of"
" the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the filesystem containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:433
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:436
msgid "The file is on a read-only filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:436
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:444
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<rename>()  does"
" not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:449
msgid ""
"The following additional errors can occur for B<renameat>()  and "
"B<renameat2>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:455
msgid "I<olddirfd> or I<newdirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:465
msgid ""
"I<oldpath> is relative and I<olddirfd> is a file descriptor referring to a "
"file other than a directory; or similar for I<newpath> and I<newdirfd>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:468
msgid "The following additional errors can occur for B<renameat2>():"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:468
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:476
msgid "I<flags> contains B<RENAME_NOREPLACE> and I<newpath> already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:480
msgid "An invalid flag was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:488
msgid ""
"Both B<RENAME_NOREPLACE> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:496
msgid ""
"Both B<RENAME_WHITEOUT> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:500
msgid "The filesystem does not support one of the flags in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:508
msgid "I<flags> contains B<RENAME_EXCHANGE> and I<newpath> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:516
msgid ""
"B<RENAME_WHITEOUT> was specified in I<flags>, but the caller does not have "
"the B<CAP_MKNOD> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:520
msgid ""
"B<renameat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:523
msgid ""
"B<renameat2>()  was added to Linux in kernel 3.15; library support was added"
" in glibc 2.28."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:526
msgid "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:529
msgid "B<renameat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:532
msgid "B<renameat2>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:551
msgid ""
"On older kernels where B<renameat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<rename>().  When I<oldpath> and "
"I<newpath> are relative pathnames, glibc constructs pathnames based on the "
"symbolic links in I</proc/self/fd> that correspond to the I<olddirfd> and "
"I<newdirfd> arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:562
msgid ""
"On NFS filesystems, you can not assume that if the operation failed, the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up"
" again causes a failure.  The application is expected to deal with this.  "
"See B<link>(2)  for a similar problem."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:569
msgid ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr ""

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one"
" of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux, this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:67
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:80
msgid "I<pathname> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""

#. type: TP
#: man-pages/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/rmdir.2:108
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has"
" I<..> as its final component.  POSIX.1 also allows B<EEXIST> for this "
"condition."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:119
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be"
" deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:124
msgid ""
"The filesystem containing I<pathname> does not support the removal of "
"directories."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:128
msgid "I<pathname> refers to a directory on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:130
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:133
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:141
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:49
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:51
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:53
#, no-wrap
msgid ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:56
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:58
#, no-wrap
msgid ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:70
msgid ""
"The B<recv>(), B<recvfrom>(), and B<recvmsg>()  calls are used to receive "
"messages from a socket.  They may be used to receive data on both "
"connectionless and connection-oriented sockets.  This page first describes "
"common features of all three system calls, and then describes the "
"differences between the calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:85
msgid ""
"The only difference between B<recv>()  and B<read>(2)  is the presence of "
"I<flags>.  With a zero I<flags> argument, B<recv>()  is generally equivalent"
" to B<read>(2)  (but see NOTES).  Also, the following call"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:87
#, no-wrap
msgid "    recv(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:89
msgid "is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:91
#, no-wrap
msgid "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:97
msgid ""
"All three calls return the length of the message on successful completion.  "
"If a message is too long to fit in the supplied buffer, excess bytes may be "
"discarded depending on the type of socket the message is received from."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:107
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:114
msgid ""
"An application can use B<select>(2), B<poll>(2), or B<epoll>(7)  to "
"determine when more data arrives on a socket."
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:114
#, no-wrap
msgid "The flags argument"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:118
msgid ""
"The I<flags> argument is formed by ORing one or more of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:118
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:129
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:129
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:148
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK>.  This provides similar behavior "
"to setting the B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> "
"operation), but differs in that B<MSG_DONTWAIT> is a per-call option, "
"whereas B<O_NONBLOCK> is a setting on the open file description (see "
"B<open>(2)), which will affect all threads in the calling process and as "
"well as other processes that hold file descriptors referring to the same "
"open file description."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:148
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:167
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of"
" the datagram that caused the error is supplied via I<msg_name>."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:171
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:178
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:190
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* Error number */\n"
"    uint8_t  ee_origin;  /* Where the error originated */\n"
"    uint8_t  ee_type;    /* Type */\n"
"    uint8_t  ee_code;    /* Code */\n"
"    uint8_t  ee_pad;     /* Padding */\n"
"    uint32_t ee_info;    /* Additional information */\n"
"    uint32_t ee_data;    /* Other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:192
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:216
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:230
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> flag is set in the I<msghdr>.  After an error has been "
"passed, the pending socket error is regenerated based on the next queued "
"error and will be passed on the next socket operation."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:230 man-pages/man2/recv.2:423
#, no-wrap
msgid "B<MSG_OOB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:237
msgid ""
"This flag requests receipt of out-of-band data that would not be received in"
" the normal data stream.  Some protocols place expedited data at the head of"
" the normal data queue, and thus this flag cannot be used with such "
"protocols."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:237
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:244
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:244
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr ""

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: man-pages/man2/recv.2:254
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22), and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:257
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:257
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:266
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a"
" signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned.  This flag has no effect"
" for datagram sockets."
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:266
#, no-wrap
msgid "recvfrom()"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:272
msgid ""
"B<recvfrom>()  places the received message into the buffer I<buf>.  The "
"caller must specify the size of the buffer in I<len>."
msgstr ""

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: man-pages/man2/recv.2:300
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address of the message, that source address is placed in the buffer pointed "
"to by I<src_addr>.  In this case, I<addrlen> is a value-result argument.  "
"Before the call, it should be initialized to the size of the buffer "
"associated with I<src_addr>.  Upon return, I<addrlen> is updated to contain "
"the actual size of the source address.  The returned address is truncated if"
" the buffer provided is too small; in this case, I<addrlen> will return a "
"value greater than was supplied to the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:307
msgid ""
"If the caller is not interested in the source address, I<src_addr> and "
"I<addrlen> should be specified as NULL."
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:307
#, no-wrap
msgid "recv()"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:315
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2)).  It is equivalent to the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:318
#, no-wrap
msgid "    recvfrom(fd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:318
#, no-wrap
msgid "recvmsg()"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:326
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:333
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:343
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags on received message */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:359
msgid ""
"The I<msg_name> field points to a caller-allocated buffer that is used to "
"return the source address if the socket is unconnected.  The caller should "
"set I<msg_namelen> to the size of this buffer before this call; upon return "
"from a successful call, I<msg_namelen> will contain the length of the "
"returned address.  If the application does not need to know the source "
"address, I<msg_name> can be specified as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:366
msgid ""
"The fields I<msg_iov> and I<msg_iovlen> describe scatter-gather locations, "
"as discussed in B<readv>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:381
msgid ""
"The field I<msg_control>, which has length I<msg_controllen>, points to a "
"buffer for other protocol control-related messages or miscellaneous "
"ancillary data.  When B<recvmsg>()  is called, I<msg_controllen> should "
"contain the length of the available buffer in I<msg_control>; upon return "
"from a successful call it will contain the length of the control message "
"sequence."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:383
msgid "The messages are of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:394
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:399
msgid ""
"Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:402
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:410
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:410
#, no-wrap
msgid "B<MSG_EOR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:415
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:415
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:419
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:419
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:423
msgid ""
"indicates that some control data was discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:426
msgid ""
"is returned to indicate that expedited or out-of-band data was received."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:426
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:430
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:436
msgid ""
"These calls return the number of bytes received, or -1 if an error occurred."
"  In the event of an error, I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:439
msgid ""
"When a stream socket peer has performed an orderly shutdown, the return "
"value will be 0 (the traditional \"end-of-file\" return)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:443
msgid ""
"Datagram sockets in various domains (e.g., the UNIX and Internet domains)  "
"permit zero-length datagrams.  When such a datagram is received, the return "
"value is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:446
msgid ""
"The value 0 may also be returned if the requested number of bytes to receive"
" from a stream socket was 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:451
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/recv.2:460
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a"
" receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1 allows either error to be returned for this case, and "
"does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:465
msgid "The argument I<sockfd> is an invalid file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:465
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:469
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:473
msgid ""
"The receive buffer pointer(s) point outside the process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:478
msgid ""
"The receive was interrupted by delivery of a signal before any data was "
"available; see B<signal>(7)."
msgstr ""

#.  e.g., msg_namelen < 0 for recvmsg() or addrlen < 0 for recvfrom()
#. type: Plain text
#: man-pages/man2/recv.2:482
msgid "Invalid argument passed."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:486
msgid "Could not allocate memory for B<recvmsg>()."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:486
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:493
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:493
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:498
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:501
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:508
msgid ""
"POSIX.1 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:521
msgid ""
"If a zero-length datagram is pending, B<read>(2)  and B<recv>()  with a "
"I<flags> argument of zero provide different behavior.  In this circumstance,"
" B<read>(2)  has no effect (the datagram remains pending), while B<recv>()  "
"consumes the pending datagram."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:527
msgid "The I<socklen_t> type was invented by POSIX.  See also B<accept>(2)."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/recv.2:543
msgid ""
"According to POSIX.1, the I<msg_controllen> field of the I<msghdr> structure"
" should be typed as I<socklen_t>, but glibc currently types it as I<size_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:548
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:553
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:568
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), "
"B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:49
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a"
" symbolic link, where the extended attribute is removed from the link "
"itself, not the file that it refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by"
" B<open>(2))  in place of I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:78
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:83
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/removexattr.2:84
#, no-wrap
msgid "B<ENODATA>"
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/removexattr.2:92
msgid "The named attribute does not exist."
msgstr ""

#. type: TP
#: man-pages/man2/removexattr.2:92
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:95
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:99
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:102
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:119
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2),"
" B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/readdir.2:30
#, no-wrap
msgid "READDIR"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:33
msgid "readdir - read directory entry"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:38
#, no-wrap
msgid ""
"B<int readdir(unsigned int >I<fd>B<, struct old_linux_dirent *>I<dirp>B<,>\n"
"B<            unsigned int >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:50
msgid ""
"This is not the function you are interested in.  Look at B<readdir>(3)  for "
"the POSIX conforming C library interface.  This page documents the bare "
"kernel system call interface, which is superseded by B<getdents>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:64
msgid ""
"B<readdir>()  reads one I<old_linux_dirent> structure from the directory "
"referred to by the file descriptor I<fd> into the buffer pointed to by "
"I<dirp>.  The argument I<count> is ignored; at most one I<old_linux_dirent> "
"structure is read."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:70
msgid ""
"The I<old_linux_dirent> structure is declared (privately in Linux kernel "
"file B<fs/readdir.c>)  as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:79
#, no-wrap
msgid ""
"struct old_linux_dirent {\n"
"    unsigned long d_ino;     /* inode number */\n"
"    unsigned long d_offset;  /* offset to this I<old_linux_dirent> */\n"
"    unsigned short d_namlen; /* length of this I<d_name> */\n"
"    char  d_name[1];         /* filename (null-terminated) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:93
msgid ""
"I<d_ino> is an inode number.  I<d_offset> is the distance from the start of "
"the directory to this I<old_linux_dirent>.  I<d_reclen> is the size of "
"I<d_name>, not counting the terminating null byte (\\(aq\\e0\\(aq).  "
"I<d_name> is a null-terminated filename."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:99
msgid ""
"On success, 1 is returned.  On end of directory, 0 is returned.  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:104
msgid "Invalid file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:107
msgid "Argument points outside the calling process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:110
msgid "Result buffer is too small."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:113
msgid "No such directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:116
msgid "File descriptor does not refer to a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:127
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  You will need to define the I<old_linux_dirent> structure "
"yourself.  However, probably you should use B<readdir>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:129
msgid "This system call does not exist on x86-64."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:131
msgid "B<getdents>(2), B<readdir>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/reboot.2:28
#, no-wrap
msgid "REBOOT"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:31
msgid "reboot - reboot or enable/disable Ctrl-Alt-Del"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:34
#, no-wrap
msgid ""
"/* Since kernel version 2.1.30 there are symbolic names LINUX_REBOOT_*\n"
"   for the constants and a fourth argument to the call: */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:38
msgid "B<#include E<lt>linux/reboot.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:40
msgid ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:45
#, no-wrap
msgid ""
"/* Under glibc and most alternative libc's (including uclibc, dietlibc,\n"
"   musl and a few others), some of the constants involved have gotten\n"
"   symbolic names RB_*, and the library call is a 1-argument\n"
"   wrapper around the system call: */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:49
msgid "B<#include E<lt>sys/reboot.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:51
msgid "B<int reboot(int >I<cmd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:58
msgid ""
"The B<reboot>()  call reboots the system, or enables/disables the reboot "
"keystroke (abbreviated CAD, since the default is Ctrl-Alt-Delete; it can be "
"changed using B<loadkeys>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:82
msgid ""
"This system call fails (with the error B<EINVAL>)  unless I<magic> equals "
"B<LINUX_REBOOT_MAGIC1> (that is, 0xfee1dead) and I<magic2> equals "
"B<LINUX_REBOOT_MAGIC2> (that is, 672274793).  However, since 2.1.17 also "
"B<LINUX_REBOOT_MAGIC2A> (that is, 85072278)  and since 2.1.97 also "
"B<LINUX_REBOOT_MAGIC2B> (that is, 369367448)  and since 2.5.71 also "
"B<LINUX_REBOOT_MAGIC2C> (that is, 537993216)  are permitted as values for "
"I<magic2>.  (The hexadecimal values of these constants are meaningful.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:86
msgid "The I<cmd> argument can have the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:86
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:96
msgid ""
"(B<RB_DISABLE_CAD>, 0).  CAD is disabled.  This means that the CAD keystroke"
" will cause a B<SIGINT> signal to be sent to init (process 1), whereupon "
"this process may decide upon a proper action (maybe: kill all processes, "
"sync, reboot)."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:96
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_ON>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:104
msgid ""
"(B<RB_ENABLE_CAD>, 0x89abcdef).  CAD is enabled.  This means that the CAD "
"keystroke will immediately cause the action associated with "
"B<LINUX_REBOOT_CMD_RESTART>."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:104
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_HALT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:113
msgid ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; since Linux 1.1.76).  The message \"System "
"halted.\" is printed, and the system is halted.  Control is given to the ROM"
" monitor, if there is one.  If not preceded by a B<sync>(2), data will be "
"lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:113
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_KEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:121
msgid ""
"(B<RB_KEXEC>, 0x45584543, since Linux 2.6.13).  Execute a kernel that has "
"been loaded earlier with B<kexec_load>(2).  This option is available only if"
" the kernel was configured with B<CONFIG_KEXEC>."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:121
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:130
msgid ""
"(B<RB_POWER_OFF>, 0x4321fedc; since Linux 2.1.30).  The message \"Power "
"down.\" is printed, the system is stopped, and all power is removed from the"
" system, if possible.  If not preceded by a B<sync>(2), data will be lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:130
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:139
msgid ""
"(B<RB_AUTOBOOT>, 0x1234567).  The message \"Restarting system.\" is printed,"
" and a default restart is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:139
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:149
msgid ""
"(0xa1b2c3d4; since Linux 2.1.30).  The message \"Restarting system with "
"command \\(aq%s\\(aq\" is printed, and a restart (using the command string "
"given in I<arg>)  is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:149
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_SW_SUSPEND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:156
msgid ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; since Linux 2.5.18).  The system is suspended"
" (hibernated) to disk.  This option is available only if the kernel was "
"configured with B<CONFIG_HIBERNATION>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:159
msgid "Only the superuser may call B<reboot>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:166
msgid ""
"The precise effect of the above actions depends on the architecture.  For "
"the i386 architecture, the additional argument does not do anything at "
"present (2.1.122), but the type of reboot can be determined by kernel "
"command-line arguments (\"reboot=...\") to be either warm or cold, and "
"either hard or through the BIOS."
msgstr ""

#. type: SS
#: man-pages/man2/reboot.2:166
#, no-wrap
msgid "Behavior inside PID namespaces"
msgstr ""

#.  commit cf3f89214ef6a33fad60856bc5ffd7bb2fc4709b
#.  see also commit 923c7538236564c46ee80c253a416705321f13e3
#. type: Plain text
#: man-pages/man2/reboot.2:181
msgid ""
"Since Linux 3.4, if B<reboot>()  is called from a PID namespace other than "
"the initial PID namespace with one of the I<cmd> values listed below, it "
"performs a \"reboot\" of that namespace: the \"init\" process of the PID "
"namespace is immediately terminated, with the effects described in "
"B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:187
msgid ""
"The values that can be supplied in I<cmd> when calling B<reboot>()  in this "
"case are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:187
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>, B<LINUX_REBOOT_CMD_RESTART2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:195
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGHUP> signal."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:195
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>, B<LINUX_REBOOT_CMD_HALT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:203
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGINT> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:212
msgid ""
"For the other I<cmd> values, B<reboot>()  returns -1 and I<errno> is set to "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:225
msgid ""
"For the values of I<cmd> that stop or restart the system, a successful call "
"to B<reboot>()  does not return.  For the other I<cmd> values, zero is "
"returned on success.  In all cases, -1 is returned on failure, and I<errno> "
"is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:230
msgid ""
"Problem with getting user-space data under B<LINUX_REBOOT_CMD_RESTART2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:233
msgid "Bad magic numbers or I<cmd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:240
msgid ""
"The calling process has insufficient privilege to call B<reboot>(); the "
"caller must have the B<CAP_SYS_BOOT> inside its user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:244
msgid ""
"B<reboot>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:253
msgid ""
"B<systemctl>(1), B<systemd>(1), B<kexec_load>(2), B<sync>(2), "
"B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>(8), "
"B<shutdown>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "READV"
msgstr ""

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:35
msgid ""
"readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into "
"multiple buffers"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:38
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:40
#, no-wrap
msgid ""
"B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:42
#, no-wrap
msgid ""
"B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:45
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:48
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:51
#, no-wrap
msgid ""
"B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:54
#, no-wrap
msgid ""
"B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:67
#, no-wrap
msgid ""
"B<preadv>(),\n"
"B<pwritev>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:77
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated"
" with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:87
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather "
"output\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:96
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:103
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:111
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple"
" buffers are filled."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:117
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:136
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov>[0] before proceeding to I<iov>[1], and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be"
" filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov>[0] before proceeding to I<iov>[1], and so on."
msgstr ""

#.  Regarding atomicity, see https://bugzilla.kernel.org/show_bug.cgi?id=10596
#. type: Plain text
#: man-pages/man2/readv.2:155
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the"
" data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)"
"  for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring"
" to the same open file description (see B<open>(2))."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:155
#, no-wrap
msgid "preadv() and pwritev()"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:168
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:181
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and"
" B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:186
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:186
#, no-wrap
msgid "preadv2() and pwritev2()"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:195
msgid ""
"These system calls are similar to B<preadv>()  and B<pwritev>()  calls, but "
"add a fifth argument, I<flags>, which modifies the behavior on a per-call "
"basis."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:203
msgid ""
"Unlike B<preadv>()  and B<pwritev>(), if the I<offset> argument is -1, then "
"the current file offset is used and updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:207
msgid ""
"The I<flags> argument contains a bitwise OR of zero or more of the following"
" flags:"
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:207
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.7)"
msgstr ""

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: man-pages/man2/readv.2:217
msgid ""
"Provide a per-write equivalent of the B<O_DSYNC> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call."
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:217
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:225
msgid ""
"High priority read/write.  Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources."
"  (Currently, this feature is usable only on a file descriptor opened using "
"the B<O_DIRECT> flag.)"
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:225
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.7)"
msgstr ""

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: man-pages/man2/readv.2:235
msgid ""
"Provide a per-write equivalent of the B<O_SYNC> B<open>(2)  flag.  This flag"
" is meaningful only for B<pwritev2>(), and its effect applies only to the "
"data range written by the system call."
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:235
#, no-wrap
msgid "B<RWF_NOWAIT> (since Linux 4.14)"
msgstr ""

#.  commit 3239d834847627b6634a4139cf1dc58f6f137a46
#.  commit 91f9943e1c7b6638f27312d03fe71fcc67b23571
#. type: Plain text
#: man-pages/man2/readv.2:251
msgid ""
"Do not wait for data which is not immediately available.  If this flag is "
"specified, the B<preadv2>()  system call will return instantly if it would "
"have to read data from the backing storage or wait for a lock.  If some data"
" was successfully read, it will return the number of bytes read.  If no "
"bytes were read, it will return -1 and set I<errno> to B<EAGAIN>.  "
"Currently, this flag is meaningful only for B<preadv2>()."
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:251
#, no-wrap
msgid "B<RWF_APPEND> (since Linux 4.16)"
msgstr ""

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: man-pages/man2/readv.2:268
msgid ""
"Provide a per-write equivalent of the B<O_APPEND> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call.  The I<offset> argument does not "
"affect the write operation; the data is always appended to the end of the "
"file.  However, if the I<offset> argument is -1, the current file offset is "
"updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:280
msgid ""
"On success, B<readv>(), B<preadv>()  and B<preadv2>()  return the number of "
"bytes read; B<writev>(), B<pwritev>()  and B<pwritev2>()  return the number "
"of bytes written."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:286
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:288
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:302
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>(), B<preadv2>(), B<pwritev>(), and B<pwritev2>()  can also fail "
"for the same reasons as B<lseek>(2).  Additionally, the following errors are"
" defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:309
msgid "The sum of the I<iov_len> values overflows an I<ssize_t> value."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:314
msgid ""
"The vector count, I<iovcnt>, is less than zero or greater than the permitted"
" maximum."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:317
msgid "An unknown flag is specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:322
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:328
msgid ""
"B<preadv2>()  and B<pwritev2>()  first appeared in Linux 4.6.  Library "
"support was added in glibc 2.26."
msgstr ""

#.  Linux libc5 used \fIsize_t\fP as the type of the \fIiovcnt\fP argument,
#.  and \fIint\fP as the return type.
#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: man-pages/man2/readv.2:337
msgid ""
"B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system "
"calls first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:341
msgid ""
"B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:345
msgid "B<preadv2>(), B<pwritev2>(): nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:359
msgid ""
"POSIX.1 allows an implementation to place a limit on the number of items "
"that can be passed in I<iov>.  An implementation can advertise its limit by "
"defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the return "
"value from I<sysconf(_SC_IOV_MAX)>.  On modern Linux systems, the limit is "
"1024.  Back in Linux 2.0 days, this limit was 16."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:359
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:369
msgid ""
"The raw B<preadv>()  and B<pwritev>()  system calls have call signatures "
"that differ slightly from that of the corresponding GNU C library wrapper "
"functions shown in the SYNOPSIS.  The final argument, I<offset>, is unpacked"
" by the wrapper functions into two arguments in the system calls:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:371
msgid "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:374
msgid ""
"These arguments contain, respectively, the low order and high order 32 bits "
"of I<offset>."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:374
#, no-wrap
msgid "Historical C library/kernel differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:400
msgid ""
"To deal with the fact that B<IOV_MAX> was so low on early versions of Linux,"
" the glibc wrapper functions for B<readv>()  and B<writev>()  did some extra"
" work if they detected that the underlying kernel system call failed because"
" this limit was exceeded.  In the case of B<readv>(), the wrapper function "
"allocated a temporary buffer large enough for all of the items specified by "
"I<iov>, passed that buffer in a call to B<read>(2), copied data from the "
"buffer to the locations specified by the I<iov_base> fields of the elements "
"of I<iov>, and then freed the buffer.  The wrapper function for B<writev>()"
"  performed the analogous task using a temporary buffer and a call to "
"B<write>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:411
msgid ""
"The need for this extra effort in the glibc wrapper functions went away with"
" Linux 2.2 and later.  However, glibc continued to provide this behavior "
"until version 2.10.  Starting with glibc version 2.9, the wrapper functions "
"provide this behavior only if the library detects that the system is running"
" a Linux kernel older than version 2.6.18 (an arbitrarily selected kernel "
"version).  And since glibc 2.20 (which requires a minimum Linux kernel "
"version of 2.6.32), the glibc wrapper functions always just directly invoke "
"the system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:414
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:421
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:426
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:428
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:433
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr ""

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "REPERTOIREMAP"
msgstr ""

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "Linux User Manual"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:26
msgid "repertoiremap - map symbolic character names to Unicode code points"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:32
msgid ""
"A repertoire map defines mappings between symbolic character names "
"(mnemonics) and Unicode code points when compiling a locale with "
"B<localedef>(1).  Using a repertoire map is optional, it is needed only when"
" symbolic names are used instead of now preferred Unicode code points."
msgstr ""

#. type: SS
#: man-pages/man5/repertoiremap.5:32
#, no-wrap
msgid "Syntax"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:35
msgid ""
"The repertoiremap file starts with a header that may consist of the "
"following keywords:"
msgstr ""

#. type: TP
#: man-pages/man5/repertoiremap.5:35
#, no-wrap
msgid "I<comment_char>"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:40
msgid ""
"is followed by a character that will be used as the comment character for "
"the rest of the file.  It defaults to the number sign (#)."
msgstr ""

#. type: TP
#: man-pages/man5/repertoiremap.5:40
#, no-wrap
msgid "I<escape_char>"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:46
msgid ""
"is followed by a character that should be used as the escape character for "
"the rest of the file to mark characters that should be interpreted in a "
"special way.  It defaults to the backslash (\\e)."
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:50
msgid ""
"The mapping section starts with the keyword I<CHARIDS> in the first column."
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:52
msgid "The mapping lines have the following form:"
msgstr ""

#. type: TP
#: man-pages/man5/repertoiremap.5:52
#, no-wrap
msgid "I<E<lt>symbolic-nameE<gt> E<lt>code-pointE<gt> comment>"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:57
msgid "This defines exactly one mapping, I<comment> being optional."
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:60
msgid "The mapping section ends with the string I<END CHARIDS>."
msgstr ""

#. type: TP
#: man-pages/man5/repertoiremap.5:61
#, no-wrap
msgid "I</usr/share/i18n/repertoiremaps>"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:64
msgid "Usual default repertoire map path."
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:66
msgid "POSIX.2."
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:68
msgid "Repertoire maps are deprecated in favor of Unicode code points."
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:70
msgid "A mnemonic for the Euro sign can be defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:73
#, no-wrap
msgid "E<lt>EuE<gt> E<lt>U20ACE<gt> EURO SIGN\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/repertoiremap.5:78
msgid "B<locale>(1), B<localedef>(1), B<charmap>(5), B<locale>(5)"
msgstr ""

#. type: TH
#: man-pages/man5/rpc.5:8
#, no-wrap
msgid "RPC"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:11
msgid "rpc - RPC program number data base"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:13
msgid "B</etc/rpc>"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:19
msgid ""
"The I<rpc> file contains user readable names that can be used in place of "
"RPC program numbers.  Each line has the following information:"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:23
msgid "name of server for the RPC program"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:25
msgid "RPC program number"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:27
msgid "aliases"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:34
msgid ""
"Items are separated by any number of blanks and/or tab characters.  A "
"\\(aq#\\(aq indicates the beginning of a comment; characters from the "
"\\(aq#\\(aq to the end of the line are not interpreted by routines which "
"search the file."
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:38
msgid ""
"Here is an example of the I</etc/rpc> file from the Sun RPC Source "
"distribution."
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:74
#, no-wrap
msgid ""
"#\n"
"# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n"
"#\n"
"portmapper      100000  portmap sunrpc\n"
"rstatd          100001  rstat rstat_svc rup perfmeter\n"
"rusersd         100002  rusers\n"
"nfs             100003  nfsprog\n"
"ypserv          100004  ypprog\n"
"mountd          100005  mount showmount\n"
"ypbind          100007\n"
"walld           100008  rwall shutdown\n"
"yppasswdd       100009  yppasswd\n"
"etherstatd      100010  etherstat\n"
"rquotad         100011  rquotaprog quota rquota\n"
"sprayd          100012  spray\n"
"3270_mapper     100013\n"
"rje_mapper      100014\n"
"selection_svc   100015  selnsvc\n"
"database_svc    100016\n"
"rexd            100017  rex\n"
"alis            100018\n"
"sched           100019\n"
"llockmgr        100020\n"
"nlockmgr        100021\n"
"x25.inr         100022\n"
"statmon         100023\n"
"status          100024\n"
"bootparam       100026\n"
"ypupdated       100028  ypupdate\n"
"keyserv         100029  keyserver\n"
"tfsd            100037\n"
"nsed            100038\n"
"nsemntd         100039\n"
msgstr ""

#. type: TP
#: man-pages/man5/rpc.5:77
#, no-wrap
msgid "I</etc/rpc>"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:80
msgid "RPC program number data base"
msgstr ""

#. type: Plain text
#: man-pages/man5/rpc.5:81
msgid "B<getrpcent>(3)"
msgstr ""

#. type: TH
#: man-pages/man5/resolv.conf.5:23
#, no-wrap
msgid "RESOLV.CONF"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:27
msgid "resolv.conf - resolver configuration file"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:29
msgid "B</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:41
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to"
" the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information.  The configuration file is considered a trusted source"
" of DNS information (e.g., DNSSEC AD-bit information will be returned "
"unmodified from this source)."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:46
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried; the domain name is determined from the hostname and the domain "
"search path is constructed from the domain name."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:48
msgid "The different configuration options are:"
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:48
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:65
msgid ""
"Internet address of a name server that the resolver should query, either an "
"IPv4 address (in dot notation), or an IPv6 address in colon (and possibly "
"dot) notation as per RFC 2373.  Up to B<MAXNS> (currently 3, see "
"I<E<lt>resolv.hE<gt>>) name servers may be listed, one per keyword.  If "
"there are multiple servers, the resolver library queries them in the order "
"listed.  If no B<nameserver> entries are present, the default is to use the "
"name server on the local machine.  (The algorithm used is to try a name "
"server, and if the query times out, try the next, until out of name servers,"
" then repeat trying all the name servers until a maximum number of retries "
"are made.)"
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:65
#, no-wrap
msgid "B<domain> Local domain name."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:76
msgid ""
"Most queries for names within this domain can use short names relative to "
"the local domain.  If set to \\(aq.\\(aq, the root domain is considered.  If"
" no B<domain> entry is present, the domain is determined from the local "
"hostname returned by B<gethostname>(2); the domain part is taken to be "
"everything after the first \\(aq.\\(aq.  Finally, if the hostname does not "
"contain a domain part, the root domain is assumed."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:76
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr ""

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: man-pages/man5/resolv.conf.5:106
msgid ""
"The search list is normally determined from the local domain name; by "
"default, it contains only the local domain name.  This may be changed by "
"listing the desired domain search path following the I<search> keyword with "
"spaces or tabs separating the names.  Resolver queries having fewer than "
"I<ndots> dots (default is 1) in them will be attempted using each component "
"of the search path in turn until a match is found.  For environments with "
"multiple subdomains please read B<options ndots:>I<n> below to avoid man-in-"
"the-middle attacks and unnecessary traffic for the root-dns-servers.  Note "
"that this process may be slow and will generate a lot of network traffic if "
"the servers for the listed domains are not local, and that queries will time"
" out if no server is available for one of the domains."
msgstr ""

#.  glibc commit 3f853f22c87f0b671c0366eb290919719fa56c0e
#. type: Plain text
#: man-pages/man5/resolv.conf.5:112
msgid ""
"In glibc 2.25 and earlier, the search list is limited to six domains with a "
"total of 256 characters.  Since glibc 2.26, the search list is unlimited."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:112
#, no-wrap
msgid "B<sortlist>"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:125
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted."
"  A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and"
" optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:128
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:129
#, no-wrap
msgid "B<options>"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:133
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:136
msgid "B<options> I<option> I<...>"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:138
msgid "where I<option> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:138
#, no-wrap
msgid "B<debug>"
msgstr ""

#.  Since glibc 2.2?
#. type: Plain text
#: man-pages/man5/resolv.conf.5:147
msgid ""
"Sets B<RES_DEBUG> in I<_res.options> (effective only if glibc was built with"
" debug support; see B<resolver>(3))."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:147
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:161
msgid ""
"Sets a threshold for the number of dots which must appear in a name given to"
" B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots"
" in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:161
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:175
msgid ""
"Sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server. This may "
"B<not> be the total time taken by any resolver API call and there is no "
"guarantee that a single resolver API call maps to a single timeout.  "
"Measured in seconds, the default is B<RES_TIMEOUT> (currently 5, see "
"I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:175
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:184
msgid ""
"Sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:184
#, no-wrap
msgid "B<rotate>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:194
msgid ""
"Sets B<RES_ROTATE> in I<_res.options>, which causes round-robin selection of"
" name servers from among those listed.  This has the effect of spreading the"
" query load among all listed servers, rather than having all clients try the"
" first listed server first every time."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:194
#, no-wrap
msgid "B<no-check-names>"
msgstr ""

#.  since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:204
msgid ""
"Sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as"
" underscore (_), non-ASCII, or control characters."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:204
#, no-wrap
msgid "B<inet6>"
msgstr ""

#.  Since glibc 2.2
#.  b76e065991ec01299225d9da90a627ebe6c1ac97
#. type: Plain text
#: man-pages/man5/resolv.conf.5:221
msgid ""
"Sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying an "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists.  Since glibc 2.25, this option is "
"deprecated; applications should use B<getaddrinfo>(3), rather than "
"B<gethostbyname>(3)."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:221
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:233
msgid ""
"Sets B<RES_USEBSTRING> in I<_res.options>.  This causes reverse IPv6 lookups"
" to be made using the bit-label format described in RFC\\ 2673; if this "
"option is not set (which is the default), then nibble format is used.  This "
"option was removed in glibc 2.25, since it relied on a backward-incompatible"
" DNS extension that was never deployed on the Internet."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:233
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 to 2.24)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:256
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  "
"I<ip6.int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 "
"lookups are made in the I<ip6.arpa> zone by default.  These options are "
"available in glibc versions up to 2.24, where B<no-ip6-dotint> is the "
"default.  Since B<ip6-dotint> support long ago ceased to be available on the"
" Internet, these options were removed in glibc 2.25."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:256
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:263
msgid ""
"Sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:263
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:276
msgid ""
"Sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and"
" IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:276
#, no-wrap
msgid "B<single-request-reopen> (since glibc 2.9)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:288
msgid ""
"Sets B<RES_SNGLKUPREOP> in I<_res.options>.  The resolver uses the same "
"socket for the A and AAAA requests.  Some hardware mistakenly sends back "
"only one reply.  When that happens the client system will sit and wait for "
"the second reply.  Turning this option on changes this behavior so that if "
"two requests from the same port are not handled correctly it will close the "
"socket and open a new one before sending the second request."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:288
#, no-wrap
msgid "B<no-tld-query> (since glibc 2.14)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:301
msgid ""
"Sets B<RES_NOTLDQUERY> in I<_res.options>.  This option causes "
"B<res_nsearch>()  to not attempt to resolve an unqualified name as if it "
"were a top level domain (TLD).  This option can cause problems if the site "
"has ``localhost'' as a TLD rather than having localhost on one or more "
"elements of the search list.  This option has no effect if neither "
"RES_DEFNAMES or RES_DNSRCH is set."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:301
#, no-wrap
msgid "B<use-vc> (since glibc 2.14)"
msgstr ""

#.  aef16cc8a4c670036d45590877d411a97f01e0cd
#. type: Plain text
#: man-pages/man5/resolv.conf.5:309
msgid ""
"Sets B<RES_USEVC> in I<_res.options>.  This option forces the use of TCP for"
" DNS resolutions."
msgstr ""

#. type: TP
#: man-pages/man5/resolv.conf.5:309
#, no-wrap
msgid "B<no-reload> (since glibc 2.26)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:316
msgid ""
"Sets B<RES_NORELOAD> in I<_res.options>.  This option disables automatic "
"reloading of a changed configuration file."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:321
msgid ""
"The I<domain> and I<search> keywords are mutually exclusive.  If more than "
"one instance of these keywords is present, the last instance wins."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:326
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on"
" a per-process basis by setting the environment variable B<LOCALDOMAIN> to a"
" space-separated list of search domains."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:332
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a"
" per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under "
"B<options>."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:336
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:339
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:342
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:350
msgid ""
"B<gethostbyname>(3), B<resolver>(3), B<host.conf>(5), B<hosts>(5), "
"B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man5/resolv.conf.5:351
msgid "Name Server Operations Guide for BIND"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:36
msgid "random, srandom, initstate, setstate - random number generator"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:39
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:41
#, no-wrap
msgid "B<long int random(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:43
#, no-wrap
msgid "B<void srandom(unsigned int >I<seed>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:45
#, no-wrap
msgid ""
"B<char *initstate(unsigned int >I<seed>B<, char *>I<state>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:47
#, no-wrap
msgid "B<char *setstate(char *>I<state>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:59
msgid "B<random>(), B<srandom>(), B<initstate>(), B<setstate>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/random.3:64
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:75
msgid ""
"The B<random>()  function uses a nonlinear additive feedback random number "
"generator employing a default table of size 31 long integers to return "
"successive pseudo-random numbers in the range from 0 to B<RAND_MAX>.  The "
"period of this random number generator is very large, approximately I<16\\ "
"*\\ ((2^31)\\ -\\ 1)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:89
msgid ""
"The B<srandom>()  function sets its argument as the seed for a new sequence "
"of pseudo-random integers to be returned by B<random>().  These sequences "
"are repeatable by calling B<srandom>()  with the same seed value.  If no "
"seed value is provided, the B<random>()  function is automatically seeded "
"with a value of 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:108
msgid ""
"The B<initstate>()  function allows a state array I<state> to be initialized"
" for use by B<random>().  The size of the state array I<n> is used by "
"B<initstate>()  to decide how sophisticated a random number generator it "
"should use\\(emthe larger the state array, the better the random numbers "
"will be.  Current \"optimal\" values for the size of the state array I<n> "
"are 8, 32, 64, 128, and 256 bytes; other amounts will be rounded down to the"
" nearest known amount.  Using less than 8 bytes results in an error.  "
"I<seed> is the seed for the initialization, which specifies a starting point"
" for the random number sequence, and provides for restarting at the same "
"point."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:124
msgid ""
"The B<setstate>()  function changes the state array used by the B<random>()"
"  function.  The state array I<state> is used for random number generation "
"until the next call to B<initstate>()  or B<setstate>().  I<state> must "
"first have been initialized using B<initstate>()  or be the result of a "
"previous call of B<setstate>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:132
msgid ""
"The B<random>()  function returns a value between 0 and B<RAND_MAX>.  The "
"B<srandom>()  function returns no value."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:139
msgid ""
"The B<initstate>()  function returns a pointer to the previous state array."
"  On error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:146
msgid ""
"On success, B<setstate>()  returns a pointer to the previous state array.  "
"On error, it returns NULL, with I<errno> set to indicate the cause of the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:154
msgid "The I<state> argument given to B<setstate>()  was NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:158
msgid "A state array of less than 8 bytes was specified to B<initstate>()."
msgstr ""

#. type: SH
#: man-pages/man3/random.3:158
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:161
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:165
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:165
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:169
#, no-wrap
msgid ""
"B<random>(),\n"
"B<srandom>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:169
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:172
#, no-wrap
msgid ""
"B<initstate>(),\n"
"B<setstate>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:172
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man3/random.3:172
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:176
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:184
msgid ""
"The B<random>()  function should not be used in multithreaded programs where"
" reproducible behavior is required.  Use B<random_r>(3)  for that purpose."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:191
msgid ""
"Random-number generation is a complex topic.  I<Numerical Recipes in C: The "
"Art of Scientific Computing> (William H.\\& Press, Brian P.\\& Flannery, "
"Saul A.\\& Teukolsky, William T.\\& Vetterling; New York: Cambridge "
"University Press, 2007, 3rd ed.)  provides an excellent discussion of "
"practical random-number generation issues in Chapter 7 (Random Numbers)."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:197
msgid ""
"For a more theoretical discussion which also covers many practical issues in"
" depth, see Chapter 3 (Random Numbers) in Donald E.\\& Knuth's I<The Art of "
"Computer Programming>, volume 2 (Seminumerical Algorithms), 2nd ed.; "
"Reading, Massachusetts: Addison-Wesley Publishing Company, 1981."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=15380
#. type: Plain text
#: man-pages/man3/random.3:205
msgid ""
"According to POSIX, B<initstate>()  should return NULL on error.  In the "
"glibc implementation, I<errno> is (as specified) set on error, but the "
"function does not return NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/random.3:210
msgid ""
"B<getrandom>(2), B<drand48>(3), B<rand>(3), B<random_r>(3), B<srand>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/rcmd.3:43
#, no-wrap
msgid "RCMD"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:48
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:51
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems"
" */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:54
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:56
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:59
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:62
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:66
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:68
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:72
#, no-wrap
msgid ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:76
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:95
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>(),\n"
"B<rresvport>(),\n"
"B<rresvport_af>(),\n"
"B<iruserok>(),\n"
"B<iruserok_af>(),\n"
"B<ruserok>(),\n"
"B<ruserok_af>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:116
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a file descriptor to a socket"
" with an address in the privileged port space.  The B<iruserok>()  and "
"B<ruserok>()  functions are used by servers to authenticate clients "
"requesting service with B<rcmd>().  All four functions are used by the "
"B<rshd>(8)  server (among others)."
msgstr ""

#. type: SS
#: man-pages/man3/rcmd.3:116
#, no-wrap
msgid "rcmd()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:132
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host and a connection is "
"established to a server residing at the well-known Internet port I<inport>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:161
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as"
" I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel "
"to a control process will be set up, and a file descriptor for it will be "
"placed in I<*fd2p>.  The control process will return diagnostic output from "
"the command (unit 2) on this channel, and will also accept bytes on this "
"channel as being UNIX signal numbers, to be forwarded to the process group "
"of the command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote "
"command) will be made the same as the I<stdout> and no provision is made for"
" sending arbitrary signals to the remote process, although you may be able "
"to get its attention by using out-of-band data."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:164
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr ""

#. type: SS
#: man-pages/man3/rcmd.3:164
#, no-wrap
msgid "rresvport()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:188
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several"
" other functions.  Privileged ports are those in the range 0 to 1023.  Only "
"a privileged process (on Linux: a process that has the "
"B<CAP_NET_BIND_SERVICE> capability in the user namespace governing its "
"network namespace).  is allowed to bind to a privileged port.  In the glibc "
"implementation, this function restricts its search to the ports from 512 to "
"1023.  The I<port> argument is value-result: the value it supplies to the "
"call is used as the starting point for a circular search of the port range; "
"on (successful) return, it contains the port number that was bound to."
msgstr ""

#. type: SS
#: man-pages/man3/rcmd.3:188
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:206
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not>"
" the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:222
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other"
" than the user or the superuser, is writable by anyone other than the owner,"
" or is hardlinked anywhere, the check automatically fails.  Zero is returned"
" if the machine name is listed in the I<hosts.equiv> file, or the host and "
"remote username are found in the I<.rhosts> file; otherwise B<iruserok>()  "
"and B<ruserok>()  return -1.  If the local domain (as obtained from "
"B<gethostname>(2))  is the same as the remote domain, only the machine name "
"need be specified."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:228
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used"
" in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""

#. type: SS
#: man-pages/man3/rcmd.3:228
#, no-wrap
msgid "*_af() variants"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:244
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports"
" the use of B<AF_UNSPEC>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:250
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:261
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded"
" to mean \"All network ports in use.\""
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:267
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:275
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""

#. type: tbl table
#: man-pages/man3/rcmd.3:286
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/rcmd.3:286
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: tbl table
#: man-pages/man3/rcmd.3:290
#, no-wrap
msgid ""
"B<rresvport>(),\n"
"B<rresvport_af>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/rcmd.3:294
#, no-wrap
msgid ""
"B<iruserok>(),\n"
"B<ruserok>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rcmd.3:297
#, no-wrap
msgid ""
"B<iruserok_af>(),\n"
"B<ruserok_af>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/rcmd.3:297
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:308
msgid ""
"Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems.  "
"These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: man-pages/man3/rcmd.3:315
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""

#. type: Plain text
#: man-pages/man3/rcmd.3:322
msgid ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), "
"B<rlogind>(8), B<rshd>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/round.3:27
#, no-wrap
msgid "ROUND"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:30
msgid "round, roundf, roundl - round to nearest integer, away from zero"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:33
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:37
#, no-wrap
msgid ""
"B<double round(double >I<x>B<);>\n"
"B<float roundf(float >I<x>B<);>\n"
"B<long double roundl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:40
msgid "Link with I<-lm>."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:50
msgid "B<round>(), B<roundf>(), B<roundl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:52
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:63
msgid ""
"These functions round I<x> to the nearest integer, but round halfway cases "
"away from zero (regardless of the current rounding direction, see "
"B<fenv>(3)), instead of to the nearest even integer like B<rint>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:69
msgid "For example, I<round(0.5)> is 1.0, and I<round(-0.5)> is -1.0."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:71
msgid "These functions return the rounded integer value."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:77
msgid ""
"If I<x> is integral, +0, -0, NaN, or infinite, I<x> itself is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:80
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:82
msgid "These functions first appeared in glibc in version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/round.3:94
#, no-wrap
msgid ""
"B<round>(),\n"
"B<roundf>(),\n"
"B<roundl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:98
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: man-pages/man3/round.3:114
msgid ""
"POSIX.1-2001 contains text about overflow (which might set I<errno> to "
"B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the result "
"cannot overflow on any current machine, so this error-handling stuff is just"
" nonsense.  (More precisely, overflow can happen only when the maximum value"
" of the exponent is smaller than the number of mantissa bits.  For the "
"IEEE-754 standard 32-bit and 64-bit floating-point numbers the maximum value"
" of the exponent is 128 (respectively, 1024), and the number of mantissa "
"bits is 24 (respectively, 53).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:119
msgid ""
"If you want to store the rounded value in an integer type, you probably want"
" to use one of the functions described in B<lround>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/round.3:125
msgid ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), "
"B<trunc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/rand.3:41
#, no-wrap
msgid "RAND"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:44
msgid "rand, rand_r, srand - pseudo-random number generator"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:49
#, no-wrap
msgid "B<int rand(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:51
#, no-wrap
msgid "B<int rand_r(unsigned int *>I<seedp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:53
#, no-wrap
msgid "B<void srand(unsigned int >I<seed>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:61
msgid "B<rand_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:64
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:67
#, no-wrap
msgid ""
"Glibc 2.23 and earlier\n"
"    _POSIX_C_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:74
msgid ""
"The B<rand>()  function returns a pseudo-random integer in the range 0 to "
"B<RAND_MAX> inclusive (i.e., the mathematical range [0,\\ B<RAND_MAX>])."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:83
msgid ""
"The B<srand>()  function sets its argument as the seed for a new sequence of"
" pseudo-random integers to be returned by B<rand>().  These sequences are "
"repeatable by calling B<srand>()  with the same seed value."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:87
msgid ""
"If no seed value is provided, the B<rand>()  function is automatically "
"seeded with a value of 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:98
msgid ""
"The function B<rand>()  is not reentrant, since it uses hidden state that is"
" modified on each call.  This might just be the seed value to be used by the"
" next call, or it might be something more elaborate.  In order to get "
"reproducible behavior in a threaded application, this state must be made "
"explicit; this can be done using the reentrant function B<rand_r>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:114
msgid ""
"Like B<rand>(), B<rand_r>()  returns a pseudo-random integer in the range "
"[0,\\ B<RAND_MAX>].  The I<seedp> argument is a pointer to an I<unsigned "
"int> that is used to store state between calls.  If B<rand_r>()  is called "
"with the same initial value for the integer pointed to by I<seedp>, and that"
" value is not modified between calls, then the same pseudo-random sequence "
"will result."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:124
msgid ""
"The value pointed to by the I<seedp> argument of B<rand_r>()  provides only "
"a very small amount of state, so this function will be a weak pseudo-random "
"generator.  Try B<drand48_r>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:135
msgid ""
"The B<rand>()  and B<rand_r>()  functions return a value between 0 and "
"B<RAND_MAX> (inclusive).  The B<srand>()  function returns no value."
msgstr ""

#. type: tbl table
#: man-pages/man3/rand.3:147
#, no-wrap
msgid ""
"B<rand>(),\n"
"B<rand_r>(),\n"
"B<srand>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:161
msgid ""
"The functions B<rand>()  and B<srand>()  conform to SVr4, 4.3BSD, C89, C99, "
"POSIX.1-2001.  The function B<rand_r>()  is from POSIX.1-2001.  POSIX.1-2008"
" marks B<rand_r>()  as obsolete."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:180
msgid ""
"The versions of B<rand>()  and B<srand>()  in the Linux C Library use the "
"same random number generator as B<random>(3)  and B<srandom>(3), so the "
"lower-order bits should be as random as the higher-order bits.  However, on "
"older B<rand>()  implementations, and on current implementations on "
"different systems, the lower-order bits are much less random than the "
"higher-order bits.  Do not use this function in applications intended to be "
"portable when good randomness is needed.  (Use B<random>(3)  instead.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:186
msgid ""
"POSIX.1-2001 gives the following example of an implementation of B<rand>()  "
"and B<srand>(), possibly useful when one needs the same sequence on two "
"different machines."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:190
#, no-wrap
msgid "static unsigned long next = 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:196
#, no-wrap
msgid ""
"/* RAND_MAX assumed to be 32767 */\n"
"int myrand(void) {\n"
"    next = next * 1103515245 + 12345;\n"
"    return((unsigned)(next/65536) % 32768);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:200
#, no-wrap
msgid ""
"void mysrand(unsigned int seed) {\n"
"    next = seed;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:207
msgid ""
"The following program can be used to display the pseudo-random sequence "
"produced by B<rand>()  when given a particular seed."
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:212
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:218
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, r, nloops;\n"
"    unsigned int seed;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:223
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>seedE<gt> E<lt>nloopsE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:226
#, no-wrap
msgid ""
"    seed = atoi(argv[1]);\n"
"    nloops = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:232
#, no-wrap
msgid ""
"    srand(seed);\n"
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        r =  rand();\n"
"        printf(\"%d\\en\", r);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rand.3:239
msgid "B<drand48>(3), B<random>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/rewinddir.3:31
#, no-wrap
msgid "REWINDDIR"
msgstr ""

#. type: Plain text
#: man-pages/man3/rewinddir.3:34
msgid "rewinddir - reset directory stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/rewinddir.3:39
#, no-wrap
msgid "B<#include E<lt>dirent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rewinddir.3:41
#, no-wrap
msgid "B<void rewinddir(DIR *>I<dirp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rewinddir.3:49
msgid ""
"The B<rewinddir>()  function resets the position of the directory stream "
"I<dirp> to the beginning of the directory."
msgstr ""

#. type: Plain text
#: man-pages/man3/rewinddir.3:53
msgid "The B<rewinddir>()  function returns no value."
msgstr ""

#. type: tbl table
#: man-pages/man3/rewinddir.3:63
#, no-wrap
msgid "B<rewinddir>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rewinddir.3:73
msgid ""
"B<closedir>(3), B<opendir>(3), B<readdir>(3), B<scandir>(3), B<seekdir>(3), "
"B<telldir>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/rtnetlink.3:12
#, no-wrap
msgid "2014-09-06"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:15
msgid "rtnetlink - macros to manipulate rtnetlink messages"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:28
msgid "B<int RTA_OK(struct rtattr *>I<rta>B<, int >I<rtabuflen>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:30
msgid "B<void *RTA_DATA(struct rtattr *>I<rta>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:32
msgid "B<unsigned int RTA_PAYLOAD(struct rtattr *>I<rta>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:35
msgid ""
"B<struct rtattr *RTA_NEXT(struct rtattr *>I<rta>B<, unsigned int "
">I<rtabuflen>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:37
msgid "B<unsigned int RTA_LENGTH(unsigned int >I<length>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:39
msgid "B<unsigned int RTA_SPACE(unsigned int >I<length>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:46
msgid ""
"All B<rtnetlink>(7)  messages consist of a B<netlink>(7)  message header and"
" appended attributes.  The attributes should be manipulated only using the "
"macros provided here."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:57
msgid ""
"B<RTA_OK(>I<rta>B<, >I<attrlen>B<)> returns true if I<rta> points to a valid"
" routing attribute; I<attrlen> is the running length of the attribute "
"buffer.  When not true then you must assume there are no more attributes in "
"the message, even if I<attrlen> is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:60
msgid ""
"B<RTA_DATA(>I<rta>B<)> returns a pointer to the start of this attribute's "
"data."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:63
msgid "B<RTA_PAYLOAD(>I<rta>B<)> returns the length of this attribute's data."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:72
msgid ""
"B<RTA_NEXT(>I<rta>B<, >I<attrlen>B<)> gets the next attribute after I<rta>."
"  Calling this macro will update I<attrlen>.  You should use B<RTA_OK> to "
"check the validity of the returned pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:77
msgid ""
"B<RTA_LENGTH(>I<len>B<)> returns the length which is required for I<len> "
"bytes of data plus the header."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:82
msgid ""
"B<RTA_SPACE(>I<len>B<)> returns the amount of space which will be needed in "
"a message with I<len> bytes of data."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:84
msgid "These macros are nonstandard Linux extensions."
msgstr ""

#.  FIXME . ? would be better to use libnetlink in the EXAMPLE code here
#. type: Plain text
#: man-pages/man3/rtnetlink.3:89
msgid "Creating a rtnetlink message to set the MTU of a device:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:93
#, no-wrap
msgid "#include E<lt>linux/rtnetlink.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:95
#, no-wrap
msgid "\\&...\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:101
#, no-wrap
msgid ""
"struct {\n"
"    struct nlmsghdr  nh;\n"
"    struct ifinfomsg if;\n"
"    char             attrbuf[512];\n"
"} req;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:104
#, no-wrap
msgid ""
"struct rtattr *rta;\n"
"unsigned int mtu = 1000;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:106
#, no-wrap
msgid "int rtnetlink_sk = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:122
#, no-wrap
msgid ""
"memset(&req, 0, sizeof(req));\n"
"req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n"
"req.nh.nlmsg_flags = NLM_F_REQUEST;\n"
"req.nh.nlmsg_type = RTM_NEWLINK;\n"
"req.if.ifi_family = AF_UNSPEC;\n"
"req.if.ifi_index = INTERFACE_INDEX;\n"
"req.if.ifi_change = 0xffffffff; /* ??? */\n"
"rta = (struct rtattr *)(((char *) &req) +\n"
"                         NLMSG_ALIGN(req.nh.nlmsg_len));\n"
"rta-E<gt>rta_type = IFLA_MTU;\n"
"rta-E<gt>rta_len = RTA_LENGTH(sizeof(unsigned int));\n"
"req.nh.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) +\n"
"                              RTA_LENGTH(sizeof(mtu));\n"
"memcpy(RTA_DATA(rta), &mtu, sizeof(mtu));\n"
"send(rtnetlink_sk, &req, req.nh.nlmsg_len, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtnetlink.3:127
msgid "B<netlink>(3), B<netlink>(7), B<rtnetlink>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:33
msgid "regcomp, regexec, regerror, regfree - POSIX regex functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>regex.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:39
#, no-wrap
msgid ""
"B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int "
">I<cflags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:43
#, no-wrap
msgid ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:46
#, no-wrap
msgid ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:48
#, no-wrap
msgid "B<void regfree(regex_t *>I<preg>B<);>\n"
msgstr ""

#. type: SS
#: man-pages/man3/regex.3:50
#, no-wrap
msgid "POSIX regex compiling"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:56
msgid ""
"B<regcomp>()  is used to compile a regular expression into a form that is "
"suitable for subsequent B<regexec>()  searches."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:65
msgid ""
"B<regcomp>()  is supplied with I<preg>, a pointer to a pattern buffer "
"storage area; I<regex>, a pointer to the null-terminated string and "
"I<cflags>, flags used to determine the type of compilation."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:72
msgid ""
"All regular expression searching must be done via a compiled pattern buffer,"
" thus B<regexec>()  must always be supplied with the address of a "
"B<regcomp>()  initialized pattern buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:77
msgid "I<cflags> may be the bitwise-B<or> of zero or more of the following:"
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:77
#, no-wrap
msgid "B<REG_EXTENDED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:86
msgid ""
"Use B<POSIX> Extended Regular Expression syntax when interpreting I<regex>."
"  If not set, B<POSIX> Basic Regular Expression syntax is used."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:86
#, no-wrap
msgid "B<REG_ICASE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:92
msgid ""
"Do not differentiate case.  Subsequent B<regexec>()  searches using this "
"pattern buffer will be case insensitive."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:92
#, no-wrap
msgid "B<REG_NOSUB>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:102
msgid ""
"Do not report position of matches.  The I<nmatch> and I<pmatch> arguments to"
" B<regexec>()  are ignored if the pattern buffer supplied was compiled with "
"this flag set."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:102
#, no-wrap
msgid "B<REG_NEWLINE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:105
msgid "Match-any-character operators don't match a newline."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:109
msgid ""
"A nonmatching list (B<[^...]>)  not containing a newline does not match a "
"newline."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:119
msgid ""
"Match-beginning-of-line operator (B<^>)  matches the empty string "
"immediately after a newline, regardless of whether I<eflags>, the execution "
"flags of B<regexec>(), contains B<REG_NOTBOL>."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:127
msgid ""
"Match-end-of-line operator (B<$>)  matches the empty string immediately "
"before a newline, regardless of whether I<eflags> contains B<REG_NOTEOL>."
msgstr ""

#. type: SS
#: man-pages/man3/regex.3:127
#, no-wrap
msgid "POSIX regex matching"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:144
msgid ""
"B<regexec>()  is used to match a null-terminated string against the "
"precompiled pattern buffer, I<preg>.  I<nmatch> and I<pmatch> are used to "
"provide information regarding the location of any matches.  I<eflags> may be"
" the bitwise-B<or> of one or both of B<REG_NOTBOL> and B<REG_NOTEOL> which "
"cause changes in matching behavior described below."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:144
#, no-wrap
msgid "B<REG_NOTBOL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:154
msgid ""
"The match-beginning-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above).  This flag may be used when "
"different portions of a string are passed to B<regexec>()  and the beginning"
" of the string should not be interpreted as the beginning of the line."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:154
#, no-wrap
msgid "B<REG_NOTEOL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:160
msgid ""
"The match-end-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:160
#, no-wrap
msgid "B<REG_STARTEND>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:180
msgid ""
"Use I<pmatch[0]> on the input string, starting at byte I<pmatch[0].rm_so> "
"and ending before byte I<pmatch[0].rm_eo>.  This allows matching embedded "
"NUL bytes and avoids a B<strlen>(3)  on large strings.  It does not use "
"I<nmatch> on input, and does not change B<REG_NOTBOL> or B<REG_NEWLINE> "
"processing.  This flag is a BSD extension, not present in POSIX."
msgstr ""

#. type: SS
#: man-pages/man3/regex.3:180
#, no-wrap
msgid "Byte offsets"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:205
msgid ""
"Unless B<REG_NOSUB> was set for the compilation of the pattern buffer, it is"
" possible to obtain match addressing information.  I<pmatch> must be "
"dimensioned to have at least I<nmatch> elements.  These are filled in by "
"B<regexec>()  with substring match addresses.  The offsets of the "
"subexpression starting at the I<i>th open parenthesis are stored in "
"I<pmatch[i]>.  The entire regular expression's match addresses are stored in"
" I<pmatch[0]>.  (Note that to return the offsets of I<N> subexpression "
"matches, I<nmatch> must be at least I<N+1>.)  Any unused structure elements "
"will contain the value -1."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:212
msgid ""
"The I<regmatch_t> structure which is the type of I<pmatch> is defined in "
"I<E<lt>regex.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:219
#, no-wrap
msgid ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:230
msgid ""
"Each I<rm_so> element that is not -1 indicates the start offset of the next "
"largest substring match within the string.  The relative I<rm_eo> element "
"indicates the end offset of the match, which is the offset of the first "
"character after the matching text."
msgstr ""

#. type: SS
#: man-pages/man3/regex.3:230
#, no-wrap
msgid "POSIX error reporting"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:237
msgid ""
"B<regerror>()  is used to turn the error codes that can be returned by both "
"B<regcomp>()  and B<regexec>()  into error message strings."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:259
msgid ""
"B<regerror>()  is passed the error code, I<errcode>, the pattern buffer, "
"I<preg>, a pointer to a character string buffer, I<errbuf>, and the size of "
"the string buffer, I<errbuf_size>.  It returns the size of the I<errbuf> "
"required to contain the null-terminated error message string.  If both "
"I<errbuf> and I<errbuf_size> are nonzero, I<errbuf> is filled in with the "
"first I<errbuf_size - 1> characters of the error message and a terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: SS
#: man-pages/man3/regex.3:259
#, no-wrap
msgid "POSIX pattern buffer freeing"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:267
msgid ""
"Supplying B<regfree>()  with a precompiled pattern buffer, I<preg> will free"
" the memory allocated to the pattern buffer by the compiling process, "
"B<regcomp>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:270
msgid ""
"B<regcomp>()  returns zero for a successful compilation or an error code for"
" failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:275
msgid ""
"B<regexec>()  returns zero for a successful match or B<REG_NOMATCH> for "
"failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:278
msgid "The following errors can be returned by B<regcomp>():"
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:278
#, no-wrap
msgid "B<REG_BADBR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:281
msgid "Invalid use of back reference operator."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:281
#, no-wrap
msgid "B<REG_BADPAT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:284
msgid "Invalid use of pattern operators such as group or list."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:284
#, no-wrap
msgid "B<REG_BADRPT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:288
msgid ""
"Invalid use of repetition operators such as using \\(aq*\\(aq as the first "
"character."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:288
#, no-wrap
msgid "B<REG_EBRACE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:291
msgid "Un-matched brace interval operators."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:291
#, no-wrap
msgid "B<REG_EBRACK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:294
msgid "Un-matched bracket list operators."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:294
#, no-wrap
msgid "B<REG_ECOLLATE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:297
msgid "Invalid collating element."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:297
#, no-wrap
msgid "B<REG_ECTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:300
msgid "Unknown character class name."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:300
#, no-wrap
msgid "B<REG_EEND>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:304
msgid "Nonspecific error.  This is not defined by POSIX.2."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:304
#, no-wrap
msgid "B<REG_EESCAPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:307
msgid "Trailing backslash."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:307
#, no-wrap
msgid "B<REG_EPAREN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:310
msgid "Un-matched parenthesis group operators."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:310
#, no-wrap
msgid "B<REG_ERANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:314
msgid ""
"Invalid use of the range operator; for example, the ending point of the "
"range occurs prior to the starting point."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:314
#, no-wrap
msgid "B<REG_ESIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:318
msgid ""
"Compiled regular expression requires a pattern buffer larger than 64\\ kB.  "
"This is not defined by POSIX.2."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:318
#, no-wrap
msgid "B<REG_ESPACE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:321
msgid "The regex routines ran out of memory."
msgstr ""

#. type: TP
#: man-pages/man3/regex.3:321
#, no-wrap
msgid "B<REG_ESUBREG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:324
msgid "Invalid back reference to a subexpression."
msgstr ""

#. type: tbl table
#: man-pages/man3/regex.3:335
#, no-wrap
msgid ""
"B<regcomp>(),\n"
"B<regexec>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/regex.3:338
#, no-wrap
msgid "B<regerror>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/regex.3:338
#, no-wrap
msgid "MT-Safe env"
msgstr ""

#. type: tbl table
#: man-pages/man3/regex.3:341
#, no-wrap
msgid "B<regfree>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:345
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:348
msgid "B<grep>(1), B<regex>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man3/regex.3:350
msgid "The glibc manual section, I<Regular Expressions>"
msgstr ""

#. type: TH
#: man-pages/man3/resolver.3:33
#, no-wrap
msgid "RESOLVER"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:38
msgid ""
"res_ninit, res_nclose, res_nquery, res_nsearch, res_nquerydomain, "
"res_nmkquery, res_nsend, res_init, res_query, res_search, res_querydomain, "
"res_mkquery, res_send, dn_comp, dn_expand - resolver routines"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:43
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:46
#, no-wrap
msgid ""
"B<struct __res_state;>\n"
"B<typedef struct __res_state *res_state;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:48
#, no-wrap
msgid "B<int res_ninit(res_state >I<statep>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:50
#, no-wrap
msgid "B<void res_nclose(res_state >I<statep>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:54
#, no-wrap
msgid ""
"B<int res_nquery(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:58
#, no-wrap
msgid ""
"B<int res_nsearch(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:63
#, no-wrap
msgid ""
"B<int res_nquerydomain(res_state >I<statep>B<,>\n"
"B<           const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:69
#, no-wrap
msgid ""
"B<int res_nmkquery(res_state >I<statep>B<,>\n"
"B<           int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:73
#, no-wrap
msgid ""
"B<int res_nsend(res_state >I<statep>B<,>\n"
"B<           const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:77
#, no-wrap
msgid ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
"B<           int >I<length>B<, unsigned char **>I<dnptrs>B<,>\n"
"B<           unsigned char **>I<lastdnptr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:82
#, no-wrap
msgid ""
"B<int dn_expand(const unsigned char *>I<msg>B<,>\n"
"B<           const unsigned char *>I<eomorig>B<,>\n"
"B<           const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<           int >I<length>B<);>\n"
msgstr ""

#. type: SS
#: man-pages/man3/resolver.3:84
#, no-wrap
msgid "Deprecated"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:87
#, no-wrap
msgid "B<extern struct __res_state _res;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:89
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:92
#, no-wrap
msgid ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:95
#, no-wrap
msgid ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:99
#, no-wrap
msgid ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:104
#, no-wrap
msgid ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:107
#, no-wrap
msgid ""
"B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:110
msgid "Link with I<-lresolv>."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:114
msgid ""
"B<Note:> This page is incomplete (various resolver functions provided by "
"glibc are not described) and likely out of date."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:117
msgid ""
"The functions described below make queries to and interpret the responses "
"from Internet domain name servers."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:133
msgid ""
"The API consists of a set of more modern, reentrant functions and an older "
"set of nonreentrant functions that have been superseded.  The traditional "
"resolver interfaces such as B<res_init>()  and B<res_query>()  use some "
"static (global) state stored in the I<_res> structure, rendering these "
"functions non-thread-safe.  BIND 8.2 introduced a set of new interfaces "
"B<res_ninit>(), B<res_nquery>(), and so on, which take a I<res_state> as "
"their first argument, so you can use a per-thread resolver state."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:159
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions read the configuration "
"files (see B<resolv.conf>(5))  to get the default domain name and name "
"server address(es).  If no server is given, the local host is tried.  If no "
"domain is given, that associated with the local host is used.  It can be "
"overridden with the environment variable B<LOCALDOMAIN>.  B<res_ninit>()  or"
" B<res_init>()  is normally executed by the first call to one of the other "
"functions.  Every call to B<res_ninit>()  requires a corresponding call to "
"B<res_nclose>()  to free memory allocated by B<res_ninit>()  and subsequent "
"calls to B<res_nquery>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:169
msgid ""
"The B<res_nquery>()  and B<res_query>()  functions query the name server for"
" the fully qualified domain name I<name> of specified I<type> and I<class>."
"  The reply is left in the buffer I<answer> of length I<anslen> supplied by "
"the caller."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:185
msgid ""
"The B<res_nsearch>()  and B<res_search>()  functions make a query and waits "
"for the response like B<res_nquery>()  and B<res_query>(), but in addition "
"they implement the default and search rules controlled by B<RES_DEFNAMES> "
"and B<RES_DNSRCH> (see description of I<_res> options below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:193
msgid ""
"The B<res_nquerydomain>()  and B<res_querydomain>()  functions make a query "
"using B<res_nquery>()/B<res_query>()  on the concatenation of I<name> and "
"I<domain>."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:196
msgid ""
"The following functions are lower-level routines used by "
"B<res_query>()/B<res_query>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:206
msgid ""
"The B<res_nmkquery>()  and B<res_mkquery>()  functions construct a query "
"message in I<buf> of length I<buflen> for the domain name I<dname>.  The "
"query type I<op> is one of the following (typically B<QUERY>):"
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:206
#, no-wrap
msgid "B<QUERY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:209
msgid "Standard query."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:209
#, no-wrap
msgid "B<IQUERY>"
msgstr ""

#.  commit e4e794841e3140875f2aa86b90e2ada3d61e1244
#. type: Plain text
#: man-pages/man3/resolver.3:215
msgid ""
"Inverse query.  This option was removed in glibc 2.26, since it has not been"
" supported by DNS servers for a very long time."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:215
#, no-wrap
msgid "B<NS_NOTIFY_OP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:218
msgid "Notify secondary of SOA (Start of Authority) change."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:220
msgid "I<newrr> is currently unused."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:231
msgid ""
"The B<res_nsend>()  and B<res_send>()  function send a preformatted query "
"given in I<msg> of length I<msglen> and returns the answer in I<answer> "
"which is of length I<anslen>.  They will call B<res_ninit>()/B<res_init>()  "
"if it has not already been called."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:244
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:253
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:268
msgid ""
"The resolver routines use configuration and state information contained in a"
" I<__res_state> structure (either passed as the I<statep> argument, or in "
"the global variable I<_res>, in the case of the older nonreentrant "
"functions).  The only field of this structure that is normally manipulated "
"by the user is the I<options> field.  This field can contain the bitwise "
"\"OR\" of the following options:"
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:268
#, no-wrap
msgid "B<RES_INIT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:275
msgid "True if B<res_ninit>()  or B<res_init>()  has been called."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:275
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr ""

#.  See resolv/README.
#.  Support for RES_DEBUG was made conditional in glibc 2.2.
#. type: Plain text
#: man-pages/man3/resolver.3:282
msgid ""
"Print debugging messages.  This option is available only if glibc was built "
"with debugging enabled, which is not the default."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:282
#, no-wrap
msgid "B<RES_AAONLY> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:290
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:290
#, no-wrap
msgid "B<RES_USEVC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:293
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:293
#, no-wrap
msgid "B<RES_PRIMARY> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:298
msgid ""
"Query primary domain name server only.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:298
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:302
msgid "Ignore truncation errors.  Don't retry with TCP."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:302
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:309
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:309
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:316
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names\\(emthat is, those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:316
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:321
msgid ""
"Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:321
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:330
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and"
" in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled "
"by default]."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:330
#, no-wrap
msgid "B<RES_INSECURE1>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:337
msgid ""
"Accept a response from a wrong server.  This can be used to detect potential"
" security hazards, but you need to compile glibc with debugging enabled and "
"use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:337
#, no-wrap
msgid "B<RES_INSECURE2>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:344
msgid ""
"Accept a response which contains a wrong query.  This can be used to detect "
"potential security hazards, but you need to compile glibc with debugging "
"enabled and use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:344
#, no-wrap
msgid "B<RES_NOALIASES>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:349
msgid "Disable usage of B<HOSTALIASES> environment variable."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:349
#, no-wrap
msgid "B<RES_USE_INET6>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:361
msgid ""
"Try an AAAA query before an A query inside the B<gethostbyname>(3)  "
"function, and map IPv4 responses in IPv6 \"tunneled form\" if no AAAA "
"records are found but an A record set exists.  Since glibc 2.25, this option"
" is deprecated, and its usage produces a warning; applications should use "
"B<getaddrinfo>(3), rather than B<gethostbyname>(3)."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:361
#, no-wrap
msgid "B<RES_ROTATE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:367
msgid ""
"Causes round-robin selection of name servers from among those listed.  This "
"has the effect of spreading the query load among all listed servers, rather "
"than having all clients try the first listed server first every time."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:367
#, no-wrap
msgid "B<RES_NOCHECKNAME> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:374
msgid ""
"Disable the modern BIND checking of incoming hostnames and mail names for "
"invalid characters such as underscore (_), non-ASCII, or control characters."
"  This option was present in glibc until version 2.24; since glibc 2.25, it "
"is deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:374
#, no-wrap
msgid "B<RES_KEEPTSIG> (unimplemented; deprecated in glibc 2.25)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:379
msgid ""
"Do not strip TSIG records.  This option was present but unimplemented in "
"glibc until version 2.24; since glibc 2.25, it is deprecated, and its usage "
"produces a warning."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:379
#, no-wrap
msgid "B<RES_BLAST  (unimplemented; deprecated in glibc 2.25)>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:384
msgid ""
"Send each query simultaneously and recursively to all servers.  This option "
"was present but unimplemented in glibc until version 2.24; since glibc 2.25,"
" it is deprecated, and its usage produces a warning."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:384
#, no-wrap
msgid "B<RES_USEBSTRING> (glibc 2.3.4 to 2.24)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:391
msgid ""
"Make reverse IPv6 lookups using the bit-label format described in RFC 2673; "
"if this option is not set (which is the default), then nibble format is "
"used.  This option was removed in glibc 2.25, since it relied on a backward-"
"incompatible DNS extension that was never deployed on the Internet."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:391
#, no-wrap
msgid "B<RES_NOIP6DOTINT> (glibc 2.24 and earlier)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:401
msgid ""
"Use I<ip6.arpa> zone in IPv6 reverse lookup instead of I<ip6.int>, which is "
"deprecated since glibc 2.3.4.  This option is present in glibc up to and "
"including version 2.24, where it is enabled by default.  In glibc 2.25, this"
" option was removed."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:401
#, no-wrap
msgid "B<RES_USE_EDNS0> (since glibc 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:404
msgid "Enables support for the DNS extensions (EDNS0) described in RFC 2671."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:404
#, no-wrap
msgid "B<RES_SNGLKUP> (since glibc 2.10)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:413
msgid ""
"By default, glibc performs IPv4 and IPv6 lookups in parallel since version "
"2.9.  Some appliance DNS servers cannot handle these queries properly and "
"make the requests time out.  This option disables the behavior and makes "
"glibc perform the IPv6 and IPv4 requests sequentially (at the cost of some "
"slowdown of the resolving process)."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:413
#, no-wrap
msgid "B<RES_SNGLKUPREOP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:418
msgid ""
"When B<RES_SNGLKUP> option is enabled, opens a new socket for the each "
"request."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:418
#, no-wrap
msgid "B<RES_USE_DNSSEC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:423
msgid ""
"Use DNSSEC with OK bit in OPT record.  This option implies B<RES_USE_EDNS0>."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:423
#, no-wrap
msgid "B<RES_NOTLDQUERY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:426
msgid "Do not look up unqualified name as a top-level domain (TLD)."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:426
#, no-wrap
msgid "B<RES_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:435
msgid ""
"Default option which implies: B<RES_RECURSE>, B<RES_DEFNAMES>, B<RES_DNSRCH>"
" and B<RES_NOIP6DOTINT>."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:442
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions return 0 on success, or -1 "
"if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:457
msgid ""
"The B<res_nquery>(), B<res_query>(), B<res_nsearch>(), B<res_search>(), "
"B<res_nquerydomain>(), B<res_querydomain>(), B<res_nmkquery>(), "
"B<res_mkquery>(), B<res_nsend>(), and B<res_send>()  functions return the "
"length of the response, or -1 if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:464
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:478
msgid ""
"In the case of an error return from B<res_nquery>(), B<res_query>(), "
"B<res_nsearch>(), B<res_search>(), B<res_nquerydomain>(), or "
"B<res_querydomain>(), the global variable I<h_errno> (see "
"B<gethostbyname>(3))  can be consulted to determine the cause of the error."
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:479
#, no-wrap
msgid "I</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:482 man-pages/man3/resolver.3:485
msgid "resolver configuration file"
msgstr ""

#. type: TP
#: man-pages/man3/resolver.3:482
#, no-wrap
msgid "I</etc/host.conf>"
msgstr ""

#. type: tbl table
#: man-pages/man3/resolver.3:497
#, no-wrap
msgid ""
"B<res_ninit>(),\n"
"B<res_nclose>(),\n"
"B<res_nquery>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/resolver.3:501
#, no-wrap
msgid ""
"B<res_nsearch>(),\n"
"B<res_nquerydomain>(),\n"
"B<res_nsend>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/resolver.3:505
#, no-wrap
msgid ""
"B<res_nmkquery>(),\n"
"B<dn_comp>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/resolver.3:507
#, no-wrap
msgid "B<dn_expand>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:512
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:518
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man3/resolver.3:520
msgid "The GNU C library source file I<resolv/README>."
msgstr ""

#. type: TH
#: man-pages/man3/rpmatch.3:29
#, no-wrap
msgid "RPMATCH"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:32
msgid ""
"rpmatch - determine if the answer to a question is affirmative or negative"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:37
#, no-wrap
msgid "B<int rpmatch(const char *>I<response>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:49
#, no-wrap
msgid ""
"B<rpmatch>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:53
msgid ""
"B<rpmatch>()  handles a user response to yes or no questions, with support "
"for internationalization."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:60
msgid ""
"I<response> should be a null-terminated string containing a user-supplied "
"response, perhaps obtained with B<fgets>(3)  or B<getline>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:70
msgid ""
"The user's language preference is taken into account per the environment "
"variables B<LANG>, B<LC_MESSAGES>, and B<LC_ALL>, if the program has called "
"B<setlocale>(3)  to effect their changes."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:76
msgid ""
"Regardless of the locale, responses matching B<^[Yy]> are always accepted as"
" affirmative, and those matching B<^[Nn]> are always accepted as negative."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:85
msgid ""
"After examining I<response>, B<rpmatch>()  returns 0 for a recognized "
"negative response (\"no\"), 1 for a recognized positive response (\"yes\"), "
"and -1 when the value of I<response> is unrecognized."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:89
msgid ""
"A return value of -1 may indicate either an invalid input, or some other "
"error.  It is incorrect to only test if the return value is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:102
msgid ""
"B<rpmatch>()  can fail for any of the reasons that B<regcomp>(3)  or "
"B<regexec>(3)  can fail; the cause of the error is not available from "
"I<errno> or anywhere else, but indicates a failure of the regex engine (but "
"this case is indistinguishable from that of an unrecognized value of "
"I<response>)."
msgstr ""

#. type: tbl table
#: man-pages/man3/rpmatch.3:112
#, no-wrap
msgid "B<rpmatch>()"
msgstr ""

#.  It is available on at least AIX 5.1 and FreeBSD 6.0.
#. type: Plain text
#: man-pages/man3/rpmatch.3:120
msgid ""
"B<rpmatch>()  is not required by any standard, but is available on a few "
"other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:135
msgid ""
"The B<rpmatch>()  implementation looks at only the first character of "
"I<response>.  As a consequence, \"nyes\" returns 0, and \"ynever; not in a "
"million years\" returns 1.  It would be preferable to accept input strings "
"much more strictly, for example (using the extended regular expression "
"notation described in B<regex>(7)): B<^([yY]|yes|YES)$> and "
"B<^([nN]|no|NO)$>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:139
msgid ""
"The following program displays the results when B<rpmatch>()  is applied to "
"the string given in the program's command-line argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:146
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"#include E<lt>locale.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:154
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s response\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:159
#, no-wrap
msgid ""
"    setlocale(LC_ALL, \"\");\n"
"    printf(\"rpmatch() returns: %d\\en\", rpmatch(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpmatch.3:165
msgid ""
"B<fgets>(3), B<getline>(3), B<nl_langinfo>(3), B<regcomp>(3), "
"B<setlocale>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/remquo.3:12
#, no-wrap
msgid "REMQUO"
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:15
msgid "remquo, remquof, remquol - remainder and part of quotient"
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:22
#, no-wrap
msgid ""
"B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"
"B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"
"B<long double remquol(long double >I<x>B<, long double >I<y>B<, int *>I<quo>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:35
msgid "B<remquo>(), B<remquof>(), B<remquol>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:49
msgid ""
"These functions compute the remainder and part of the quotient upon division"
" of I<x> by I<y>.  A few bits of the quotient are stored via the I<quo> "
"pointer.  The remainder is returned as the function result."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:53
msgid ""
"The value of the remainder is the same as that computed by the "
"B<remainder>(3)  function."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:59
msgid ""
"The value stored via the I<quo> pointer has the sign of I<x\\ /\\ y> and "
"agrees with the quotient in at least the low order 3 bits."
msgstr ""

#.  A possible application of this function might be the computation
#.  of sin(x). Compute remquo(x, pi/2, &quo) or so.
#.  glibc, UnixWare: return 3 bits
#.  MacOS 10: return 7 bits
#. type: Plain text
#: man-pages/man3/remquo.3:67
msgid ""
"For example, I<remquo(29.0,\\ 3.0)> returns -1.0 and might store 2.  Note "
"that the actual quotient might not fit in an integer."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:71
msgid ""
"On success, these functions return the same value as the analogous functions"
" described in B<remainder>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:77
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:86
msgid ""
"If I<x> is an infinity, and I<y> is not a NaN, a domain error occurs, and a "
"NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:95
msgid ""
"If I<y> is zero, and I<x> is not a NaN, a domain error occurs, and a NaN is "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:100
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:102
msgid "The following errors can occur:"
msgstr ""

#. type: TP
#: man-pages/man3/remquo.3:102
#, no-wrap
msgid ""
"Domain error: I<x> is an infinity or I<y> is 0, and the other argument is "
"not a NaN"
msgstr ""

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/remquo.3:111
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr ""

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6802
#. type: Plain text
#: man-pages/man3/remquo.3:116
msgid "These functions do not set I<errno>."
msgstr ""

#. type: tbl table
#: man-pages/man3/remquo.3:130
#, no-wrap
msgid ""
"B<remquo>(),\n"
"B<remquof>(),\n"
"B<remquol>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/remquo.3:137
msgid "B<fmod>(3), B<logb>(3), B<remainder>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/remainder.3:37
#, no-wrap
msgid "REMAINDER"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:41
msgid ""
"drem, dremf, dreml, remainder, remainderf, remainderl - floating-point "
"remainder function"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:49
#, no-wrap
msgid ""
"/* The C99 versions */\n"
"B<double remainder(double >I<x>B<, double >I<y>B<);>\n"
"B<float remainderf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double remainderl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:54
#, no-wrap
msgid ""
"/* Obsolete synonyms */\n"
"B<double drem(double >I<x>B<, double >I<y>B<);>\n"
"B<float dremf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double dreml(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:65
msgid "B<remainder>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/remainder.3:71
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:75
msgid "B<remainderf>(), B<remainderl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:79
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:84
msgid "B<drem>(), B<dremf>(), B<dreml>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:87
#, no-wrap
msgid ""
"/* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:107
msgid ""
"These functions compute the remainder of dividing I<x> by I<y>.  The return "
"value is I<x>-I<n>*I<y>, where I<n> is the value I<x\\ /\\ y>, rounded to "
"the nearest integer.  If the absolute value of I<x>-I<n>*I<y> is 0.5, I<n> "
"is chosen to be even."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:110
msgid ""
"These functions are unaffected by the current rounding mode (see "
"B<fenv>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:114
msgid "The B<drem>()  function does precisely the same thing."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:120
msgid ""
"On success, these functions return the floating-point remainder, "
"I<x>-I<n>*I<y>.  If the return value is 0, it has the sign of I<x>."
msgstr ""

#. type: TP
#: man-pages/man3/remainder.3:153
#, no-wrap
msgid "Domain error: I<x> is an infinity and I<y> is not a NaN"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:162
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:166
msgid "These functions do not set I<errno> for this case."
msgstr ""

#.  [XXX see bug above] and \fIx\fP is not a NaN
#. type: TP
#: man-pages/man3/remainder.3:166
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:174
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""

#. type: tbl table
#: man-pages/man3/remainder.3:186
#, no-wrap
msgid ""
"B<drem>(),\n"
"B<dremf>(),\n"
"B<dreml>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/remainder.3:189
#, no-wrap
msgid ""
"B<remainder>(),\n"
"B<remainderf>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/remainder.3:191
#, no-wrap
msgid "B<remainderl>()"
msgstr ""

#.  IEC 60559.
#. type: Plain text
#: man-pages/man3/remainder.3:201
msgid ""
"The functions B<remainder>(), B<remainderf>(), and B<remainderl>()  are "
"specified in C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:217
msgid ""
"The function B<drem>()  is from 4.3BSD.  The I<float> and I<long double> "
"variants B<dremf>()  and B<dreml>()  exist on some systems, such as Tru64 "
"and glibc2.  Avoid the use of these functions in favor of B<remainder>()  "
"etc."
msgstr ""

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6779
#. type: Plain text
#: man-pages/man3/remainder.3:221
msgid "Before glibc 2.15, the call"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:223
#, no-wrap
msgid "    remainder(nan(\"\"), 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:226
msgid ""
"returned a NaN, as expected, but wrongly caused a domain error.  Since glibc"
" 2.15, a silent NaN (i.e., no domain error) is returned."
msgstr ""

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6783
#. type: Plain text
#: man-pages/man3/remainder.3:237
msgid ""
"Before glibc 2.15, I<errno> was not set to B<EDOM> for the domain error that"
" occurs when I<x> is an infinity and I<y> is not a NaN."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:239
msgid "The call \"remainder(29.0, 3.0)\" returns -1."
msgstr ""

#. type: Plain text
#: man-pages/man3/remainder.3:242
msgid "B<div>(3), B<fmod>(3), B<remquo>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/random_r.3:26
#, no-wrap
msgid "RANDOM_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:30
msgid ""
"random_r, srandom_r, initstate_r, setstate_r - reentrant random number "
"generator"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:35
#, no-wrap
msgid "B<int random_r(struct random_data *>I<buf>B<, int32_t *>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:37
#, no-wrap
msgid ""
"B<int srandom_r(unsigned int >I<seed>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:40
#, no-wrap
msgid ""
"B<int initstate_r(unsigned int >I<seed>B<, char *>I<statebuf>B<,>\n"
"B<                size_t >I<statelen>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:42
#, no-wrap
msgid ""
"B<int setstate_r(char *>I<statebuf>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:54
msgid "B<random_r>(), B<srandom_r>(), B<initstate_r>(), B<setstate_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:57
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:65
msgid ""
"These functions are the reentrant equivalents of the functions described in "
"B<random>(3).  They are suitable for use in multithreaded programs where "
"each thread needs to obtain an independent, reproducible sequence of random "
"numbers."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:78
msgid ""
"The B<random_r>()  function is like B<random>(3), except that instead of "
"using state information maintained in a global variable, it uses the state "
"information in the argument pointed to by I<buf>, which must have been "
"previously initialized by B<initstate_r>().  The generated random number is "
"returned in the argument I<result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:89
msgid ""
"The B<srandom_r>()  function is like B<srandom>(3), except that it "
"initializes the seed for the random number generator whose state is "
"maintained in the object pointed to by I<buf>, which must have been "
"previously initialized by B<initstate_r>(), instead of the seed associated "
"with the global state variable."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:117
msgid ""
"The B<initstate_r>()  function is like B<initstate>(3)  except that it "
"initializes the state in the object pointed to by I<buf>, rather than "
"initializing the global state variable.  Before calling this function, the "
"I<buf.state> field must be initialized to NULL.  The B<initstate_r>()  "
"function records a pointer to the I<statebuf> argument inside the structure "
"pointed to by I<buf>.  Thus, I<statebuf> should not be deallocated so long "
"as I<buf> is still in use.  (So, I<statebuf> should typically be allocated "
"as a static variable, or allocated on the heap using B<malloc>(3)  or "
"similar.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:130
msgid ""
"The B<setstate_r>()  function is like B<setstate>(3)  except that it "
"modifies the state in the object pointed to by I<buf>, rather than modifying"
" the global state variable.  I<state> must first have been initialized using"
" B<initstate_r>()  or be the result of a previous call of B<setstate_r>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:135
msgid ""
"All of these functions return 0 on success.  On error, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:140
msgid "A state array of less than 8 bytes was specified to B<initstate_r>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:149
msgid "The I<statebuf> or I<buf> argument to B<setstate_r>()  was NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:158
msgid "The I<buf> or I<result> argument to B<random_r>()  was NULL."
msgstr ""

#. type: tbl table
#: man-pages/man3/random_r.3:169
#, no-wrap
msgid ""
"B<random_r>(),\n"
"B<srandom_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/random_r.3:172
#, no-wrap
msgid ""
"B<initstate_r>(),\n"
"B<setstate_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/random_r.3:172
#, no-wrap
msgid "MT-Safe race:buf"
msgstr ""

#.  These functions appear to be on Tru64, but don't seem to be on
#.  Solaris, HP-UX, or FreeBSD.
#. type: Plain text
#: man-pages/man3/random_r.3:178
msgid "These functions are nonstandard glibc extensions."
msgstr ""

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=3662
#. type: Plain text
#: man-pages/man3/random_r.3:189
msgid ""
"The B<initstate_r>()  interface is confusing.  It appears that the "
"I<random_data> type is intended to be opaque, but the implementation "
"requires the user to either initialize the I<buf.state> field to NULL or "
"zero out the entire structure before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/random_r.3:192
msgid "B<drand48>(3), B<rand>(3), B<random>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/readdir_r.3:26
#, no-wrap
msgid "READDIR_R"
msgstr ""

#. type: TH
#: man-pages/man3/readdir_r.3:26
#, no-wrap
msgid "2016-03-01"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:29
msgid "readdir_r - read a directory"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:35
#, no-wrap
msgid ""
"B<int readdir_r(DIR *>I<dirp>B<, struct dirent *>I<entry>B<, struct dirent "
"**>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:44
msgid "B<readdir_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:47
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:53
msgid "This function is deprecated; use B<readdir>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:66
msgid ""
"The B<readdir_r>()  function was invented as a reentrant version of "
"B<readdir>(3).  It reads the next directory entry from the directory stream "
"I<dirp>, and returns it in the caller-allocated buffer pointed to by "
"I<entry>.  For details of the I<dirent> structure, see B<readdir>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:72
msgid ""
"A pointer to the returned buffer is placed in I<*result>; if the end of the "
"directory stream was encountered, then NULL is instead returned in "
"I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:80
msgid ""
"It is recommended that applications use B<readdir>(3)  instead of "
"B<readdir_r>().  Furthermore, since version 2.24, glibc deprecates "
"B<readdir_r>().  The reasons are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:87
msgid ""
"On systems where B<NAME_MAX> is undefined, calling B<readdir_r>()  may be "
"unsafe because the interface does not allow the caller to specify the length"
" of the buffer used for the returned directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:101
msgid ""
"On some systems, B<readdir_r>()  can't read directory entries with very long"
" names.  When the glibc implementation encounters such a name, "
"B<readdir_r>()  fails with the error B<ENAMETOOLONG> I<after the final "
"directory entry has been read>.  On some other systems, B<readdir_r>()  may "
"return a success status, but the returned I<d_name> field may not be null "
"terminated or may be truncated."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:118
msgid ""
"In the current POSIX.1 specification (POSIX.1-2008), B<readdir>(3)  is not "
"required to be thread-safe.  However, in modern implementations (including "
"the glibc implementation), concurrent calls to B<readdir>(3)  that specify "
"different directory streams are thread-safe.  Therefore, the use of "
"B<readdir_r>()  is generally unnecessary in multithreaded programs.  In "
"cases where multiple threads must read from the same directory stream, using"
" B<readdir>(3)  with external synchronization is still preferable to the use"
" of B<readdir_r>(), for the reasons given in the points above."
msgstr ""

#.  FIXME .
#.  http://www.austingroupbugs.net/view.php?id=696
#. type: Plain text
#: man-pages/man3/readdir_r.3:127
msgid ""
"It is expected that a future version of POSIX.1 will make B<readdir_r>()  "
"obsolete, and require that B<readdir>(3)  be thread-safe when concurrently "
"employed on different directory streams."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:136
msgid ""
"The B<readdir_r>()  function returns 0 on success.  On error, it returns a "
"positive error number (listed under ERRORS).  If the end of the directory "
"stream is reached, B<readdir_r>()  returns 0, and returns NULL in "
"I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:140
msgid "Invalid directory stream descriptor I<dirp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:143
msgid "A directory entry whose name was too long to be read was encountered."
msgstr ""

#. type: tbl table
#: man-pages/man3/readdir_r.3:153
#, no-wrap
msgid "B<readdir_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir_r.3:158
msgid "B<readdir>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:14
msgid "rpc - library routines for remote procedure calls"
msgstr ""

#. type: SH
#: man-pages/man3/rpc.3:14
#, no-wrap
msgid "SYNOPSIS AND DESCRIPTION"
msgstr ""

#.  .LP
#.  We don't have an rpc_secure.3 page at the moment -- MTK, 19 Sep 05
#.  Routines that are used for Secure RPC (DES authentication) are described
#. in
#.  .BR rpc_secure (3).
#.  Secure RPC can be used only if DES encryption is available.
#. type: Plain text
#: man-pages/man3/rpc.3:26
msgid ""
"These routines allow C programs to make procedure calls on other machines "
"across the network.  First, the client calls a procedure to send a data "
"packet to the server.  Upon receipt of the packet, the server calls a "
"dispatch routine to perform the requested service, and then sends back a "
"reply.  Finally, the procedure call returns to the client."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:29
msgid ""
"To take use of these routines, include the header file "
"I<E<lt>rpc/rpc.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:31
msgid "The prototypes below make use of the following types:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:35
#, no-wrap
msgid "B<typedef int >I<bool_t>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:37
#, no-wrap
msgid "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:40
#, no-wrap
msgid ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\n"
"B<                                struct sockaddr_in *>I<raddr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:50
msgid ""
"See the header files for the declarations of the I<AUTH>, I<CLIENT>, "
"I<SVCXPRT>, and I<XDR> types."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:53
#, no-wrap
msgid "B<void auth_destroy(AUTH *>I<auth>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:62
msgid ""
"A macro that destroys the authentication information associated with "
"I<auth>.  Destruction usually involves deallocation of private data "
"structures.  The use of I<auth> is undefined after calling "
"B<auth_destroy>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:65
#, no-wrap
msgid "B<AUTH *authnone_create(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:71
msgid ""
"Create and return an RPC authentication handle that passes nonusable "
"authentication information with each remote procedure call.  This is the "
"default authentication used by RPC."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:75
#, no-wrap
msgid ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\n"
"B<                      int >I<len>B<, int *>I<aup_gids>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:91
msgid ""
"Create and return an RPC authentication handle that contains authentication "
"information.  The parameter I<host> is the name of the machine on which the "
"information was created; I<uid> is the user's user ID; I<gid> is the user's "
"current group ID; I<len> and I<aup_gids> refer to a counted array of groups "
"to which the user belongs.  It is easy to impersonate a user."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:94
#, no-wrap
msgid "B<AUTH *authunix_create_default(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:99
msgid "Calls B<authunix_create>()  with the appropriate parameters."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:105
#, no-wrap
msgid ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<            unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<            xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<            xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:129
msgid ""
"Call the remote procedure associated with I<prognum>, I<versnum>, and "
"I<procnum> on the machine, I<host>.  The parameter I<in> is the address of "
"the procedure's argument(s), and I<out> is the address of where to place the"
" result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results.  This routine returns "
"zero if it succeeds, or the value of B<enum clnt_stat> cast to an integer if"
" it fails.  The routine B<clnt_perrno>()  is handy for translating failure "
"statuses into messages."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:135
msgid ""
"Warning: calling remote procedures with this routine uses UDP/IP as a "
"transport; see B<clntudp_create>()  for restrictions.  You do not have "
"control of timeouts or authentication using this routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:142
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\n"
"B<                     unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<                     xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                     xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                     resultproc_t >I<eachresult>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:151
msgid ""
"Like B<callrpc>(), except the call message is broadcast to all locally "
"connected broadcast nets.  Each time it receives a response, this routine "
"calls B<eachresult>(), whose form is:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:155
#, no-wrap
msgid "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:172
msgid ""
"where I<out> is the same as I<out> passed to B<clnt_broadcast>(), except "
"that the remote procedure's output is decoded there; I<addr> points to the "
"address of the machine that sent the results.  If B<eachresult>()  returns "
"zero, B<clnt_broadcast>()  waits for more replies; otherwise it returns with"
" appropriate status."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:176
msgid ""
"Warning: broadcast sockets are limited in size to the maximum transfer unit "
"of the data link.  For ethernet, this value is 1500 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:182
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:201
msgid ""
"A macro that calls the remote procedure I<procnum> associated with the "
"client handle, I<clnt>, which is obtained with an RPC client creation "
"routine such as B<clnt_create>().  The parameter I<in> is the address of the"
" procedure's argument(s), and I<out> is the address of where to place the "
"result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results; I<tout> is the time "
"allowed for results to come back."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:204
#, no-wrap
msgid "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:217
msgid ""
"A macro that destroys the client's RPC handle.  Destruction usually involves"
" deallocation of private data structures, including I<clnt> itself.  Use of "
"I<clnt> is undefined after calling B<clnt_destroy>().  If the RPC library "
"opened the associated socket, it will close it also.  Otherwise, the socket "
"remains open."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:221
#, no-wrap
msgid ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\n"
"B<                    unsigned long >I<vers>B<, char *>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:232
msgid ""
"Generic client creation routine.  I<host> identifies the name of the remote "
"host where the server is located.  I<proto> indicates which kind of "
"transport protocol to use.  The currently supported values for this field "
"are \\(lqudp\\(rq and \\(lqtcp\\(rq.  Default timeouts are set, but can be "
"modified using B<clnt_control>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:237
msgid ""
"Warning: using UDP has its shortcomings.  Since UDP-based RPC messages can "
"hold only up to 8 Kbytes of encoded data, this transport cannot be used for "
"procedures that take large arguments or return huge results."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:240
#, no-wrap
msgid ""
"B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:251
msgid ""
"A macro used to change or retrieve various information about a client "
"object.  I<req> indicates the type of operation, and I<info> is a pointer to"
" the information.  For both UDP and TCP, the supported values of I<req> and "
"their argument types and what they do are:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:256
#, no-wrap
msgid ""
"B<CLSET_TIMEOUT>  I<struct timeval> // set total timeout\n"
"B<CLGET_TIMEOUT>  I<struct timeval> // get total timeout\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:264
msgid ""
"Note: if you set the timeout using B<clnt_control>(), the timeout parameter "
"passed to B<clnt_call>()  will be ignored in all future calls."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:268
#, no-wrap
msgid "B<CLGET_SERVER_ADDR>  I<struct sockaddr_in > // get server's address\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:272
msgid "The following operations are valid for UDP only:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:277
#, no-wrap
msgid ""
"B<CLSET_RETRY_TIMEOUT>  I<struct timeval> // set the retry timeout\n"
"B<CLGET_RETRY_TIMEOUT>  I<struct timeval> // get the retry timeout\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:283
msgid ""
"The retry timeout is the time that \"UDP RPC\" waits for the server to reply"
" before retransmitting the request."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:286
#, no-wrap
msgid ""
"B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char "
"*>I<out>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:297
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the results of an RPC call.  The parameter I<out> is the address of the "
"results, and I<outproc> is the XDR routine describing the results.  This "
"routine returns one if the results were successfully freed, and zero "
"otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:300
#, no-wrap
msgid "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:305
msgid ""
"A macro that copies the error structure out of the client handle to the "
"structure at address I<errp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:308
#, no-wrap
msgid "B<void clnt_pcreateerror(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:322
msgid ""
"Print a message to standard error indicating why a client RPC handle could "
"not be created.  The message is prepended with string I<s> and a colon.  "
"Used when a B<clnt_create>(), B<clntraw_create>(), B<clnttcp_create>(), or "
"B<clntudp_create>()  call fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:325
#, no-wrap
msgid "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:332
msgid ""
"Print a message to standard error corresponding to the condition indicated "
"by I<stat>.  Used after B<callrpc>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:335
#, no-wrap
msgid "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:345
msgid ""
"Print a message to standard error indicating why an RPC call failed; I<clnt>"
" is the handle used to do the call.  The message is prepended with string "
"I<s> and a colon.  Used after B<clnt_call>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:348
#, no-wrap
msgid "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:353
msgid ""
"Like B<clnt_pcreateerror>(), except that it returns a string instead of "
"printing to the standard error."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:355 man-pages/man3/rpc.3:395
msgid "Bugs: returns pointer to static data that is overwritten on each call."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:358
#, no-wrap
msgid "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:365
msgid ""
"Take the same arguments as B<clnt_perrno>(), but instead of sending a "
"message to the standard error indicating why an RPC call failed, return a "
"pointer to a string which contains the message.  The string ends with a "
"NEWLINE."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:383
msgid ""
"B<clnt_sperrno>()  is used instead of B<clnt_perrno>()  if the program does "
"not have a standard error (as a program running as a server quite likely "
"does not), or if the programmer does not want the message to be output with "
"B<printf>(3), or if a message format different than that supported by "
"B<clnt_perrno>()  is to be used.  Note: unlike B<clnt_sperror>()  and "
"B<clnt_spcreateerror>(), B<clnt_sperrno>()  returns pointer to static data, "
"but the result will not get overwritten on each call."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:386
#, no-wrap
msgid "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:393
msgid ""
"Like B<clnt_perror>(), except that (like B<clnt_sperrno>())  it returns a "
"string instead of printing to standard error."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:399
#, no-wrap
msgid ""
"B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long "
">I<versnum>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:412
msgid ""
"This routine creates a toy RPC client for the remote program I<prognum>, "
"version I<versnum>.  The transport used to pass messages to the service is "
"actually a buffer within the process's address space, so the corresponding "
"RPC server should live in the same address space; see B<svcraw_create>().  "
"This allows simulation of RPC and acquisition of RPC overheads, such as "
"round trip times, without any kernel interference.  This routine returns "
"NULL if it fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:418
#, no-wrap
msgid ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >I<recvsz>B<);>\n"
msgstr ""

#. The following inline font conversion is necessary for the hyphen indicator
#. type: Plain text
#: man-pages/man3/rpc.3:448
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses TCP/IP as a transport.  The remote "
"program is located at Internet address I<*addr>.  If I<addr-E<gt>sin_port> "
"is zero, then it is set to the actual port that the remote program is "
"listening on (the remote B<portmap> service is consulted for this "
"information).  The parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, "
"then this routine opens a new one and sets I<sockp>.  Since TCP-based RPC "
"uses buffered I/O, the user may specify the size of the send and receive "
"buffers with the parameters I<sendsz> and I<recvsz>; values of zero choose "
"suitable defaults.  This routine returns NULL if it fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:453
#, no-wrap
msgid ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:479
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses use UDP/IP as a transport.  The remote "
"program is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is"
" zero, then it is set to actual port that the remote program is listening on"
" (the remote B<portmap> service is consulted for this information).  The "
"parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine "
"opens a new one and sets I<sockp>.  The UDP transport resends the call "
"message in intervals of I<wait> time until a response is received or until "
"the call times out.  The total time for the call to time out is specified by"
" B<clnt_call>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:483
msgid ""
"Warning: since UDP-based RPC messages can hold only up to 8 Kbytes of "
"encoded data, this transport cannot be used for procedures that take large "
"arguments or return huge results."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:489
#, no-wrap
msgid ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\n"
"B<            unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<            struct timeval >I<wait>B<, int *>I<sockp>B<,>\n"
"B<            unsigned int >I<sendsize>B<, unsigned int >I<recosize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:515
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, on "
"I<versnum>; the client uses use UDP/IP as a transport.  The remote program "
"is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is zero, "
"then it is set to actual port that the remote program is listening on (the "
"remote B<portmap> service is consulted for this information).  The parameter"
" I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine opens a "
"new one and sets I<sockp>.  The UDP transport resends the call message in "
"intervals of I<wait> time until a response is received or until the call "
"times out.  The total time for the call to time out is specified by "
"B<clnt_call>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:518 man-pages/man3/rpc.3:995
msgid ""
"This allows the user to specify the maximum packet size for sending and "
"receiving UDP-based RPC messages."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:521
#, no-wrap
msgid "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:529
msgid ""
"Stuff the machine's IP address into I<*addr>, without consulting the library"
" routines that deal with I</etc/hosts>.  The port number is always set to "
"B<htons(PMAPPORT)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:532
#, no-wrap
msgid "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:543
msgid ""
"A user interface to the B<portmap> service, which returns a list of the "
"current RPC program-to-port mappings on the host located at IP address "
"I<*addr>.  This routine can return NULL.  The command I<rpcinfo\\ -p> uses "
"this routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:548
#, no-wrap
msgid ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned int >I<protocol>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:572
msgid ""
"A user interface to the B<portmap> service, which returns the port number on"
" which waits a service that supports program number I<prognum>, version "
"I<versnum>, and speaks the transport protocol associated with I<protocol>.  "
"The value of I<protocol> is most likely B<IPPROTO_UDP> or B<IPPROTO_TCP>.  A"
" return value of zero means that the mapping does not exist or that the RPC "
"system failed to contact the remote B<portmap> service.  In the latter case,"
" the global variable I<rpc_createerr> contains the RPC status."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:580
#, no-wrap
msgid ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<, unsigned long *>I<portp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:600
msgid ""
"A user interface to the B<portmap> service, which instructs B<portmap> on "
"the host at IP address I<*addr> to make an RPC call on your behalf to a "
"procedure on that host.  The parameter I<*portp> will be modified to the "
"program's port number if the procedure succeeds.  The definitions of other "
"parameters are discussed in B<callrpc>()  and B<clnt_call>().  This "
"procedure should be used for a \\(lqping\\(rq and nothing else.  See also "
"B<clnt_broadcast>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:604
#, no-wrap
msgid ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:624
msgid ""
"A user interface to the B<portmap> service, which establishes a mapping "
"between the triple [I<prognum>,I<versnum>,I<protocol>] and I<port> on the "
"machine's B<portmap> service.  The value of I<protocol> is most likely "
"B<IPPROTO_UDP> or B<IPPROTO_TCP>.  This routine returns one if it succeeds, "
"zero otherwise.  Automatically done by B<svc_register>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:627
#, no-wrap
msgid ""
"B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long "
">I<versnum>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:639
msgid ""
"A user interface to the B<portmap> service, which destroys all mapping "
"between the triple [I<prognum>,I<versnum>,I<*>] and B<ports> on the "
"machine's B<portmap> service.  This routine returns one if it succeeds, zero"
" otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:644
#, no-wrap
msgid ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char *),>\n"
"B<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:664
msgid ""
"Register procedure I<procname> with the RPC service package.  If a request "
"arrives for program I<prognum>, version I<versnum>, and procedure "
"I<procnum>, I<procname> is called with a pointer to its parameter(s); "
"I<procname> should return a pointer to its static result(s); I<inproc> is "
"used to decode the parameters while I<outproc> is used to encode the "
"results.  This routine returns zero if the registration succeeded, -1 "
"otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:669
msgid ""
"Warning: remote procedures registered in this form are accessed using the "
"UDP/IP transport; see B<svcudp_create>()  for restrictions."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:672
#, no-wrap
msgid "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:679
msgid ""
"A global variable whose value is set by any RPC client creation routine that"
" does not succeed.  Use the routine B<clnt_pcreateerror>()  to print the "
"reason why."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:682
#, no-wrap
msgid "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:693
msgid ""
"A macro that destroys the RPC service transport handle, I<xprt>.  "
"Destruction usually involves deallocation of private data structures, "
"including I<xprt> itself.  Use of I<xprt> is undefined after calling this "
"routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:696
#, no-wrap
msgid "B<fd_set >I<svc_fdset>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:710
msgid ""
"A global variable reflecting the RPC service side's read file descriptor bit"
" mask; it is suitable as a parameter to the B<select>(2)  system call.  This"
" is of interest only if a service implementor does their own asynchronous "
"event processing, instead of calling B<svc_run>().  This variable is read-"
"only (do not pass its address to B<select>(2)!), yet it may change after "
"calls to B<svc_getreqset>()  or any creation routines."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:713
#, no-wrap
msgid "B<int >I<svc_fds>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:720
msgid ""
"Similar to B<svc_fdset>, but limited to 32 file descriptors.  This interface"
" is obsoleted by B<svc_fdset>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:723
#, no-wrap
msgid ""
"B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char "
"*>I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:730
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the arguments to a service procedure using B<svc_getargs>().  This routine "
"returns 1 if the results were successfully freed, and zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:733
#, no-wrap
msgid ""
"B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char "
"*>I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:744
msgid ""
"A macro that decodes the arguments of an RPC request associated with the RPC"
" service transport handle, I<xprt>.  The parameter I<in> is the address "
"where the arguments will be placed; I<inproc> is the XDR routine used to "
"decode the arguments.  This routine returns one if decoding succeeds, and "
"zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:747
#, no-wrap
msgid "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:752
msgid ""
"The approved way of getting the network address of the caller of a procedure"
" associated with the RPC service transport handle, I<xprt>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:755
#, no-wrap
msgid "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:769
msgid ""
"This routine is of interest only if a service implementor does not call "
"B<svc_run>(), but instead implements custom asynchronous event processing.  "
"It is called when the B<select>(2)  system call has determined that an RPC "
"request has arrived on some RPC socket(s); I<rdfds> is the resultant read "
"file descriptor bit mask.  The routine returns when all sockets associated "
"with the value of I<rdfds> have been serviced."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:772
#, no-wrap
msgid "B<void svc_getreq(int >I<rdfds>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:779
msgid ""
"Similar to B<svc_getreqset>(), but limited to 32 file descriptors.  This "
"interface is obsoleted by B<svc_getreqset>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:785
#, no-wrap
msgid ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\n"
"B<                    unsigned long >I<versnum>B<,>\n"
"B<                    void (*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\n"
"B<                    unsigned long >I<protocol>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:815
msgid ""
"Associates I<prognum> and I<versnum> with the service dispatch procedure, "
"I<dispatch>.  If I<protocol> is zero, the service is not registered with the"
" B<portmap> service.  If I<protocol> is nonzero, then a mapping of the "
"triple [I<prognum>,I<versnum>,I<protocol>] to I<xprt-E<gt>xp_port> is "
"established with the local B<portmap> service (generally I<protocol> is "
"zero, B<IPPROTO_UDP> or B<IPPROTO_TCP>).  The procedure I<dispatch> has the "
"following form:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:819
#, no-wrap
msgid "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:825
msgid ""
"The B<svc_register>()  routine returns one if it succeeds, and zero "
"otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:828
#, no-wrap
msgid "B<void svc_run(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:838
msgid ""
"This routine never returns.  It waits for RPC requests to arrive, and calls "
"the appropriate service procedure using B<svc_getreq>()  when one arrives.  "
"This procedure is usually waiting for a B<select>(2)  system call to return."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:842
#, no-wrap
msgid ""
"B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char "
"*>I<out>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:854
msgid ""
"Called by an RPC service's dispatch routine to send the results of a remote "
"procedure call.  The parameter I<xprt> is the request's associated transport"
" handle; I<outproc> is the XDR routine which is used to encode the results; "
"and I<out> is the address of the results.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:857
#, no-wrap
msgid ""
"B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long "
">I<versnum>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:864
msgid ""
"Remove all mapping of the double [I<prognum>,I<versnum>] to dispatch "
"routines, and of the triple [I<prognum>,I<versnum>,I<*>] to port number."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:867
#, no-wrap
msgid "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:871
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to an authentication error."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:874
#, no-wrap
msgid "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:880
msgid ""
"Called by a service dispatch routine that cannot successfully decode its "
"parameters.  See also B<svc_getargs>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:883
#, no-wrap
msgid "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:887
msgid ""
"Called by a service dispatch routine that does not implement the procedure "
"number that the caller requests."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:890
#, no-wrap
msgid "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:894
msgid ""
"Called when the desired program is not registered with the RPC package.  "
"Service implementors usually do not need this routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:897
#, no-wrap
msgid "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:902
msgid ""
"Called when the desired version of a program is not registered with the RPC "
"package.  Service implementors usually do not need this routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:905
#, no-wrap
msgid "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:911
msgid ""
"Called by a service dispatch routine when it detects a system error not "
"covered by any particular protocol.  For example, if a service can no longer"
" allocate storage, it may call this routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:914
#, no-wrap
msgid "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:920
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to insufficient authentication parameters.  The routine "
"calls B<svcerr_auth(xprt, AUTH_TOOWEAK)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:924
#, no-wrap
msgid ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\n"
"B<                      unsigned int >I<recvsize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:934
msgid ""
"Create a service on top of any open file descriptor.  Typically, this file "
"descriptor is a connected socket for a stream protocol such as TCP.  "
"I<sendsize> and I<recvsize> indicate sizes for the send and receive buffers."
"  If they are zero, a reasonable default is chosen."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:937
#, no-wrap
msgid "B<SVCXPRT *svcraw_create(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:947
msgid ""
"This routine creates a toy RPC service transport, to which it returns a "
"pointer.  The transport is really a buffer within the process's address "
"space, so the corresponding RPC client should live in the same address "
"space; see B<clntraw_create>().  This routine allows simulation of RPC and "
"acquisition of RPC overheads (such as round trip times), without any kernel "
"interference.  This routine returns NULL if it fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:951
#, no-wrap
msgid ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>\n"
"B<                       unsigned int >I<recv_buf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:971
msgid ""
"This routine creates a TCP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local TCP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number."
"  This routine returns NULL if it fails.  Since TCP-based RPC uses buffered "
"I/O, users may specify the size of buffers; values of zero choose suitable "
"defaults."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:975
#, no-wrap
msgid ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\n"
"B<                          unsigned int >I<recosize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:992
msgid ""
"This routine creates a UDP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local UDP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number."
"  This routine returns NULL if it fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:998
#, no-wrap
msgid "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1004
msgid ""
"This call is equivalent to I<svcudp_bufcreate(sock,SZ,SZ)> for some default "
"size I<SZ>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1007
#, no-wrap
msgid ""
"B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply "
"*>I<ar>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1012
msgid ""
"Used for encoding RPC reply messages.  This routine is useful for users who "
"wish to generate RPC-style messages without using the RPC package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1015
#, no-wrap
msgid ""
"B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms "
"*>I<aupp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1021
msgid ""
"Used for describing UNIX credentials.  This routine is useful for users who "
"wish to generate these credentials without using the RPC authentication "
"package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1024
#, no-wrap
msgid "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1029
msgid ""
"Used for describing RPC call header messages.  This routine is useful for "
"users who wish to generate RPC-style messages without using the RPC package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1032
#, no-wrap
msgid "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1037
msgid ""
"Used for describing RPC call messages.  This routine is useful for users who"
" wish to generate RPC-style messages without using the RPC package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1040
#, no-wrap
msgid ""
"B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1045
msgid ""
"Used for describing RPC authentication information messages.  This routine "
"is useful for users who wish to generate RPC-style messages without using "
"the RPC package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1048
#, no-wrap
msgid "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1057
msgid ""
"Used for describing parameters to various B<portmap> procedures, externally."
"  This routine is useful for users who wish to generate these parameters "
"without using the B<pmap> interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1060
#, no-wrap
msgid "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1067
msgid ""
"Used for describing a list of port mappings, externally.  This routine is "
"useful for users who wish to generate these parameters without using the "
"B<pmap> interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1070
#, no-wrap
msgid ""
"B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply "
"*>I<rr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1075
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC-style messages without using the RPC package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1078
#, no-wrap
msgid "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1083
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC style messages without using the RPC package."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1086
#, no-wrap
msgid "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1093
msgid ""
"After RPC service transport handles are created, they should register "
"themselves with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1096
#, no-wrap
msgid "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1103
msgid ""
"Before an RPC service transport handle is destroyed, it should unregister "
"itself with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1115
#, no-wrap
msgid ""
"B<auth_destroy>(),\n"
"B<authnone_create>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1117
#, no-wrap
msgid "B<authunix_create>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1119
#, no-wrap
msgid "B<authunix_create_default>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1122
#, no-wrap
msgid ""
"B<callrpc>(),\n"
"B<clnt_broadcast>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1125
#, no-wrap
msgid ""
"B<clnt_call>(),\n"
"B<clnt_destroy>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1128
#, no-wrap
msgid ""
"B<clnt_create>(),\n"
"B<clnt_control>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1131
#, no-wrap
msgid ""
"B<clnt_freeres>(),\n"
"B<clnt_geterr>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1134
#, no-wrap
msgid ""
"B<clnt_pcreateerror>(),\n"
"B<clnt_perrno>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1136
#, no-wrap
msgid "B<clnt_perror>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1138
#, no-wrap
msgid "B<clnt_spcreateerror>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1141
#, no-wrap
msgid ""
"B<clnt_sperrno>(),\n"
"B<clnt_sperror>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1144
#, no-wrap
msgid ""
"B<clntraw_create>(),\n"
"B<clnttcp_create>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1146
#, no-wrap
msgid "B<clntudp_create>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1148
#, no-wrap
msgid "B<clntudp_bufcreate>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1151
#, no-wrap
msgid ""
"B<get_myaddress>(),\n"
"B<pmap_getmaps>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1154
#, no-wrap
msgid ""
"B<pmap_getport>(),\n"
"B<pmap_rmtcall>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1157
#, no-wrap
msgid ""
"B<pmap_set>(),\n"
"B<pmap_unset>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1160
#, no-wrap
msgid ""
"B<registerrpc>(),\n"
"B<svc_destroy>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1163
#, no-wrap
msgid ""
"B<svc_freeargs>(),\n"
"B<svc_getargs>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1166
#, no-wrap
msgid ""
"B<svc_getcaller>(),\n"
"B<svc_getreqset>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1169
#, no-wrap
msgid ""
"B<svc_getreq>(),\n"
"B<svc_register>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1172
#, no-wrap
msgid ""
"B<svc_run>(),\n"
"B<svc_sendreply>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1175
#, no-wrap
msgid ""
"B<svc_unregister>(),\n"
"B<svcerr_auth>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1178
#, no-wrap
msgid ""
"B<svcerr_decode>(),\n"
"B<svcerr_noproc>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1181
#, no-wrap
msgid ""
"B<svcerr_noprog>(),\n"
"B<svcerr_progvers>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1184
#, no-wrap
msgid ""
"B<svcerr_systemerr>(),\n"
"B<svcerr_weakauth>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1187
#, no-wrap
msgid ""
"B<svcfd_create>(),\n"
"B<svcraw_create>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1189
#, no-wrap
msgid "B<svctcp_create>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1191
#, no-wrap
msgid "B<svcudp_bufcreate>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1194
#, no-wrap
msgid ""
"B<svcudp_create>(),\n"
"B<xdr_accepted_reply>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1196
#, no-wrap
msgid "B<xdr_authunix_parms>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1198
#, no-wrap
msgid "B<xdr_callhdr>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1201
#, no-wrap
msgid ""
"B<xdr_callmsg>(),\n"
"B<xdr_opaque_auth>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1204
#, no-wrap
msgid ""
"B<xdr_pmap>(),\n"
"B<xdr_pmaplist>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1206
#, no-wrap
msgid "B<xdr_rejected_reply>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1208
#, no-wrap
msgid "B<xdr_replymsg>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rpc.3:1211
#, no-wrap
msgid ""
"B<xprt_register>(),\n"
"B<xprt_unregister>()"
msgstr ""

#.  We don't have an rpc_secure.3 page in the set at the moment -- MTK, 19 Sep
#. 05
#.  .BR rpc_secure (3),
#. type: Plain text
#: man-pages/man3/rpc.3:1218
msgid "B<xdr>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1220
msgid "The following manuals:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1222
msgid "Remote Procedure Calls: Protocol Specification"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1224
msgid "Remote Procedure Call Programming Guide"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1226
msgid "rpcgen Programming Guide"
msgstr ""

#. type: Plain text
#: man-pages/man3/rpc.3:1231
msgid ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."
msgstr ""

#. type: TH
#: man-pages/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:36
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the filesystem.  It calls B<unlink>(2)  for"
" files, and B<rmdir>(2)  for directories."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:57
msgid "If the name referred to a symbolic link, the link is removed."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr ""

#. type: tbl table
#: man-pages/man3/remove.3:80
#, no-wrap
msgid "B<remove>()"
msgstr ""

#.  .SH NOTES
#.  Under libc4 and libc5,
#.  .BR remove ()
#.  was an alias for
#.  .BR unlink (2)
#.  (and hence would not remove directories).
#. type: Plain text
#: man-pages/man3/remove.3:90
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:93
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""

#. type: Plain text
#: man-pages/man3/remove.3:103
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:39
msgid "readdir - read a directory"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:44
#, no-wrap
msgid "B<struct dirent *readdir(DIR *>I<dirp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:53
msgid ""
"The B<readdir>()  function returns a pointer to a I<dirent> structure "
"representing the next directory entry in the directory stream pointed to by "
"I<dirp>.  It returns NULL on reaching the end of the directory stream or if "
"an error occurred."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:57
msgid ""
"In the glibc implementation, the I<dirent> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:68
#, no-wrap
msgid ""
"struct dirent {\n"
"    ino_t          d_ino;       /* Inode number */\n"
"    off_t          d_off;       /* Not an offset; see below */\n"
"    unsigned short d_reclen;    /* Length of this record */\n"
"    unsigned char  d_type;      /* Type of file; not supported\n"
"                                   by all filesystem types */\n"
"    char           d_name[256]; /* Null-terminated filename */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:79
msgid ""
"The only fields in the I<dirent> structure that are mandated by POSIX.1 are "
"I<d_name> and I<d_ino>.  The other fields are unstandardized, and not "
"present on all systems; see NOTES below for some further details."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:83
msgid "The fields of the I<dirent> structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:83
#, no-wrap
msgid "I<d_ino>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:86
msgid "This is the inode number of the file."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:86
#, no-wrap
msgid "I<d_off>"
msgstr ""

#.  https://lwn.net/Articles/544298/
#. type: Plain text
#: man-pages/man3/readdir.3:100
msgid ""
"The value returned in I<d_off> is the same as would be returned by calling "
"B<telldir>(3)  at the current position in the directory stream.  Be aware "
"that despite its type and name, the I<d_off> field is seldom any kind of "
"directory offset on modern filesystems.  Applications should treat this "
"field as an opaque value, making no assumptions about its contents; see also"
" B<telldir>(3)."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:100
#, no-wrap
msgid "I<d_reclen>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:105
msgid ""
"This is the size (in bytes) of the returned record.  This may not match the "
"size of the structure definition shown above; see NOTES."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:105
#, no-wrap
msgid "I<d_type>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:111
msgid ""
"This field contains a value indicating the file type, making it possible to "
"avoid the expense of calling B<lstat>(2)  if further actions depend on the "
"type of the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:119
msgid ""
"When a suitable feature test macro is defined (B<_DEFAULT_SOURCE> on glibc "
"versions since 2.19, or B<_BSD_SOURCE> on glibc versions 2.19 and earlier), "
"glibc defines the following macro constants for the value returned in "
"I<d_type>:"
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:120
#, no-wrap
msgid "B<DT_BLK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:123
msgid "This is a block device."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:123
#, no-wrap
msgid "B<DT_CHR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:126
msgid "This is a character device."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:126
#, no-wrap
msgid "B<DT_DIR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:129
msgid "This is a directory."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:129
#, no-wrap
msgid "B<DT_FIFO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:132
msgid "This is a named pipe (FIFO)."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:132
#, no-wrap
msgid "B<DT_LNK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:135
msgid "This is a symbolic link."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:135
#, no-wrap
msgid "B<DT_REG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:138
msgid "This is a regular file."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:138
#, no-wrap
msgid "B<DT_SOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:141
msgid "This is a UNIX domain socket."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:141
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:144
msgid "The file type could not be determined."
msgstr ""

#.  kernel 2.6.27
#.  The same sentence is in getdents.2
#. type: Plain text
#: man-pages/man3/readdir.3:154
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr ""

#. type: TP
#: man-pages/man3/readdir.3:154
#, no-wrap
msgid "I<d_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:158
msgid "This field contains the null terminated filename.  I<See NOTES>."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:164
msgid ""
"The data returned by B<readdir>()  may be overwritten by subsequent calls to"
" B<readdir>()  for the same directory stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:173
msgid ""
"On success, B<readdir>()  returns a pointer to a I<dirent> structure.  (This"
" structure may be statically allocated; do not attempt to B<free>(3)  it.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:187
msgid ""
"If the end of the directory stream is reached, NULL is returned and I<errno>"
" is not changed.  If an error occurs, NULL is returned and I<errno> is set "
"appropriately.  To distinguish end of stream and from an error, set I<errno>"
" to zero before calling B<readdir>()  and then check the value of I<errno> "
"if NULL is returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/readdir.3:201
#, no-wrap
msgid "B<readdir>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/readdir.3:201
#, no-wrap
msgid "MT-Unsafe race:dirstream"
msgstr ""

#.  FIXME .
#.  http://www.austingroupbugs.net/view.php?id=696
#. type: Plain text
#: man-pages/man3/readdir.3:224
msgid ""
"In the current POSIX.1 specification (POSIX.1-2008), B<readdir>()  is not "
"required to be thread-safe.  However, in modern implementations (including "
"the glibc implementation), concurrent calls to B<readdir>()  that specify "
"different directory streams are thread-safe.  In cases where multiple "
"threads must read from the same directory stream, using B<readdir>()  with "
"external synchronization is still preferable to the use of the deprecated "
"B<readdir_r>(3)  function.  It is expected that a future version of POSIX.1 "
"will require that B<readdir>()  be thread-safe when concurrently employed on"
" different directory streams."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:229
msgid "A directory stream is opened using B<opendir>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:234
msgid ""
"The order in which filenames are read by successive calls to B<readdir>()  "
"depends on the filesystem implementation; it is unlikely that the names will"
" be sorted in any fashion."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man3/readdir.3:255
msgid ""
"Only the fields I<d_name> and (as an XSI extension)  I<d_ino> are specified "
"in POSIX.1.  Other than Linux, the I<d_type> field is available mainly only "
"on BSD systems.  The remaining fields are available on many, but not all "
"systems.  Under glibc, programs can check for the availability of the fields"
" not defined in POSIX.1 by testing whether the macros "
"B<_DIRENT_HAVE_D_NAMLEN>, B<_DIRENT_HAVE_D_RECLEN>, B<_DIRENT_HAVE_D_OFF>, "
"or B<_DIRENT_HAVE_D_TYPE> are defined."
msgstr ""

#. type: SS
#: man-pages/man3/readdir.3:255
#, no-wrap
msgid "The d_name field"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:262
msgid ""
"The I<dirent> structure definition shown above is taken from the glibc "
"headers, and shows the I<d_name> field with a fixed size."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:272
msgid ""
"I<Warning>: applications should avoid any dependence on the size of the "
"I<d_name> field.  POSIX defines it as I<char\\ d_name[]>, a character array "
"of unspecified size, with at most B<NAME_MAX> characters preceding the "
"terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:286
msgid ""
"POSIX.1 explicitly notes that this field should not be used as an lvalue.  "
"The standard also notes that the use of I<sizeof(d_name)> is incorrect; use "
"I<strlen(d_name)> instead.  (On some systems, this field is defined as "
"I<char\\ d_name[1]>!)  By implication, the use I<sizeof(struct dirent)> to "
"capture the size of the record including the size of I<d_name> is also "
"incorrect."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:288
msgid "Note that while the call"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:290
#, no-wrap
msgid "    fpathconf(fd, _PC_NAME_MAX)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:301
msgid ""
"returns the value 255 for most filesystems, on some filesystems (e.g., CIFS,"
" Windows SMB servers), the null-terminated filename that is (correctly) "
"returned in I<d_name> can actually exceed this size.  In such cases, the "
"I<d_reclen> field will contain a value that exceeds the size of the glibc "
"I<dirent> structure shown above."
msgstr ""

#. type: Plain text
#: man-pages/man3/readdir.3:313
msgid ""
"B<getdents>(2), B<read>(2), B<closedir>(3), B<dirfd>(3), B<ftw>(3), "
"B<offsetof>(3), B<opendir>(3), B<readdir_r>(3), B<rewinddir>(3), "
"B<scandir>(3), B<seekdir>(3), B<telldir>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/rint.3:27
#, no-wrap
msgid "RINT"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:31
msgid ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - round to nearest "
"integer"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:38
#, no-wrap
msgid ""
"B<double nearbyint(double >I<x>B<);>\n"
"B<float nearbyintf(float >I<x>B<);>\n"
"B<long double nearbyintl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:42
#, no-wrap
msgid ""
"B<double rint(double >I<x>B<);>\n"
"B<float rintf(float >I<x>B<);>\n"
"B<long double rintl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:55
msgid "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:57
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _ISOC99_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:60
msgid "B<rint>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:70
msgid "B<rintf>(), B<rintl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:91
msgid ""
"The B<nearbyint>(), B<nearbyintf>(), and B<nearbyintl>()  functions round "
"their argument to an integer value in floating-point format, using the "
"current rounding direction (see B<fesetround>(3))  and without raising the "
"I<inexact> exception.  When the current rounding direction is to nearest, "
"these functions round halfway cases to the even integer in accordance with "
"IEEE-754."
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:104
msgid ""
"The B<rint>(), B<rintf>(), and B<rintl>()  functions do the same, but will "
"raise the I<inexact> exception (B<FE_INEXACT>, checkable via "
"B<fetestexcept>(3))  when the result differs in value from the argument."
msgstr ""

#. type: tbl table
#: man-pages/man3/rint.3:126
#, no-wrap
msgid ""
"B<nearbyint>(),\n"
"B<nearbyintf>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rint.3:129
#, no-wrap
msgid ""
"B<nearbyintl>(),\n"
"B<rint>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/rint.3:132
#, no-wrap
msgid ""
"B<rintf>(),\n"
"B<rintl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:151
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno>"
" to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of"
" mantissa bits is 24 (respectively, 53).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:156
msgid ""
"If you want to store the rounded value in an integer type, you probably want"
" to use one of the functions described in B<lrint>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/rint.3:161
msgid "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/recno.3:36
#, no-wrap
msgid "RECNO"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:40
msgid "recno - record number database access method"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:54
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces."
"  Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is record number files.  The general "
"description of the database access methods is in B<dbopen>(3), this manual "
"page describes only the recno-specific information."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:71
msgid ""
"The record number data structure is either variable or fixed-length records "
"stored in a flat-file format, accessed by the logical record number.  The "
"existence of record number five implies the existence of records one through"
" four, and the deletion of record number one causes record number five to be"
" renumbered to record number four, as well as the cursor, if positioned "
"after record number one, to shift down one record."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:77
msgid ""
"The recno access-method-specific data structure provided to B<dbopen>(3)  is"
" defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:89
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    unsigned int  psize;\n"
"    int           lorder;\n"
"    size_t        reclen;\n"
"    unsigned char bval;\n"
"    char         *bfname;\n"
"} RECNOINFO;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:93
msgid "The elements of this structure are defined as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:93
#, no-wrap
msgid "I<flags>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:97
msgid "The flag value is specified by ORing any of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:98
#, no-wrap
msgid "B<R_FIXEDLEN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:109
msgid ""
"The records are fixed-length, not byte delimited.  The structure element "
"I<reclen> specifies the length of the record, and the structure element "
"I<bval> is used as the pad character.  Any records, inserted into the "
"database, that are less than I<reclen> bytes long are automatically padded."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:109
#, no-wrap
msgid "B<R_NOKEY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:122
msgid ""
"In the interface specified by B<dbopen>(3), the sequential record retrieval "
"fills in both the caller's key and data structures.  If the B<R_NOKEY> flag "
"is specified, the I<cursor> routines are not required to fill in the key "
"structure.  This permits applications to retrieve records at the end of "
"files without reading all of the intervening records."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:122
#, no-wrap
msgid "B<R_SNAPSHOT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:128
msgid ""
"This flag requires that a snapshot of the file be taken when B<dbopen>(3)  "
"is called, instead of permitting any unmodified records to be read from the "
"original file."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:129
#, no-wrap
msgid "I<cachesize>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:138
msgid ""
"A suggested maximum size, in bytes, of the memory cache.  This value is "
"B<only> advisory, and the access method will allocate more memory rather "
"than fail.  If I<cachesize> is 0 (no size is specified), a default cache is "
"used."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:138
#, no-wrap
msgid "I<psize>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:150
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  This value is the size (in bytes) of the pages used for nodes in "
"that tree.  If I<psize> is 0 (no page size is specified), a page size is "
"chosen based on the underlying filesystem I/O block size.  See B<btree>(3)  "
"for more information."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:150
#, no-wrap
msgid "I<lorder>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:158
msgid ""
"The byte order for integers in the stored database metadata.  The number "
"should represent the order as an integer; for example, big endian order "
"would be the number 4,321.  If I<lorder> is 0 (no order is specified), the "
"current host order is used."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:158
#, no-wrap
msgid "I<reclen>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:161
msgid "The length of a fixed-length record."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:161
#, no-wrap
msgid "I<bval>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:169
msgid ""
"The delimiting byte to be used to mark the end of a record for variable-"
"length records, and the pad character for fixed-length records.  If no value"
" is specified, newlines (\"\\en\") are used to mark the end of variable-"
"length records and fixed-length records are padded with spaces."
msgstr ""

#. type: TP
#: man-pages/man3/recno.3:169
#, no-wrap
msgid "I<bfname>"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:179
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  If I<bfname> is non-NULL, it specifies the name of the btree file, "
"as if specified as the filename for a B<dbopen>(3)  of a btree file."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:197
msgid ""
"The data part of the key/data pair used by the I<recno> access method is the"
" same as other access methods.  The key is different.  The I<data> field of "
"the key should be a pointer to a memory location of type I<recno_t>, as "
"defined in the I<E<lt>db.hE<gt>> include file.  This type is normally the "
"largest unsigned integral type available to the implementation.  The I<size>"
" field of the key should be the size of that type."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:202
msgid ""
"Because there can be no metadata associated with the underlying recno access"
" method files, any changes made to the default values (e.g., fixed record "
"length or byte separator value) must be explicitly specified each time the "
"file is opened."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:210
msgid ""
"In the interface specified by B<dbopen>(3), using the I<put> interface to "
"create a new record will cause the creation of multiple, empty records if "
"the record number is more than one greater than the largest record currently"
" in the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:218
msgid ""
"The I<recno> access method routines may fail and set I<errno> for any of the"
" errors specified for the library routine B<dbopen>(3)  or the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:222
msgid ""
"An attempt was made to add a record to a fixed-length database that was too "
"large to fit."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:224
msgid "Only big and little endian byte order is supported."
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:229
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/recno.3:232
msgid ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker,"
" Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No."
" UCB/ERL M82/32, May 1982."
msgstr ""

#. type: TH
#: man-pages/man3/re_comp.3:27
#, no-wrap
msgid "RE_COMP"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:30
msgid "re_comp, re_exec - BSD regex functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:32
msgid "B<#define _REGEX_RE_COMP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:36
msgid "B<#include E<lt>regex.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:38
msgid "B<char *re_comp(const char *>I<regex>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:40
msgid "B<int re_exec(const char *>I<string>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:52
msgid ""
"B<re_comp>()  is used to compile the null-terminated regular expression "
"pointed to by I<regex>.  The compiled pattern occupies a static area, the "
"pattern buffer, which is overwritten by subsequent use of B<re_comp>().  If "
"I<regex> is NULL, no operation is performed and the pattern buffer's "
"contents are not altered."
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:58
msgid ""
"B<re_exec>()  is used to assess whether the null-terminated string pointed "
"to by I<string> matches the previously compiled I<regex>."
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:63
msgid ""
"B<re_comp>()  returns NULL on successful compilation of I<regex> otherwise "
"it returns a pointer to an appropriate error message."
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:66
msgid "B<re_exec>()  returns 1 for a successful match, zero for failure."
msgstr ""

#. type: tbl table
#: man-pages/man3/re_comp.3:77
#, no-wrap
msgid ""
"B<re_comp>(),\n"
"B<re_exec>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:85
msgid ""
"These functions are obsolete; the functions documented in B<regcomp>(3)  "
"should be used instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/re_comp.3:88
msgid "B<regcomp>(3), B<regex>(7), GNU regex manual"
msgstr ""

#. type: TH
#: man-pages/man3/rexec.3:41
#, no-wrap
msgid "REXEC"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:44
msgid "rexec, rexec_af - return stream to a remote command"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:47
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:50
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:54
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:58
msgid "B<rexec>(), B<rexec_af>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:63
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:67
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:86
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host.  If a username and "
"password are both specified, then these are used to authenticate to the "
"foreign host; otherwise the environment and then the I<.netrc> file in "
"user's home directory are searched for appropriate information.  If all this"
" fails, the user is prompted for the information."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:97
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for"
" the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:130
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as"
" I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel "
"to a control process will be setup, and a file descriptor for it will be "
"placed in I<*fd2p>.  The control process will return diagnostic output from "
"the command (unit 2) on this channel, and will also accept bytes on this "
"channel as being UNIX signal numbers, to be forwarded to the process group "
"of the command.  The diagnostic information returned does not include remote"
" authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr ""

#. type: SS
#: man-pages/man3/rexec.3:130
#, no-wrap
msgid "rexec_af()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:146
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:150
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr ""

#. type: tbl table
#: man-pages/man3/rexec.3:161
#, no-wrap
msgid ""
"B<rexec>(),\n"
"B<rexec_af>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:172
msgid ""
"These functions are not in POSIX.1.  The B<rexec>()  function first appeared"
" in 4.2BSD, and is present on the BSDs, Solaris, and many other systems.  "
"The B<rexec_af>()  function is more recent, and less widespread."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:176
msgid ""
"The B<rexec>()  function sends the unencrypted password across the network."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:181
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""

#. type: Plain text
#: man-pages/man3/rexec.3:183
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/rtime.3:12
#, no-wrap
msgid "RTIME"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:15
msgid "rtime - get time from a remote machine"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:18
#, no-wrap
msgid "B<#include E<lt>rpc/auth_des.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:21
#, no-wrap
msgid ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>\n"
"B<          struct rpc_timeval *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:25
msgid ""
"This function uses the Time Server Protocol as described in RFC\\ 868 to "
"obtain the time from a remote machine."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:31
msgid ""
"The Time Server Protocol gives the time in seconds since 00:00:00 UTC, 1 Jan"
" 1900, and this function subtracts the appropriate constant in order to "
"convert the result to seconds since the Epoch, 1970-01-01 00:00:00 +0000 "
"(UTC)."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:36
msgid ""
"When I<timeout> is non-NULL, the udp/time socket (port 37) is used.  "
"Otherwise, the tcp/time socket (port 37) is used."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:42
msgid ""
"On success, 0 is returned, and the obtained 32-bit time value is stored in "
"I<timep-E<gt>tv_sec>.  In case of error -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:51
msgid ""
"All errors for underlying functions (B<sendto>(2), B<poll>(2), "
"B<recvfrom>(2), B<connect>(2), B<read>(2))  can occur.  Moreover:"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:54
msgid "The number of returned bytes is not 4."
msgstr ""

#. type: TP
#: man-pages/man3/rtime.3:54
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:57
msgid "The waiting time as defined in timeout has expired."
msgstr ""

#. type: tbl table
#: man-pages/man3/rtime.3:67
#, no-wrap
msgid "B<rtime>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:71
msgid "Only IPv4 is supported."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:78
msgid ""
"Some I<in.timed> versions support only TCP.  Try the example program with "
"I<use_tcp> set to 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:80
msgid "Libc5 uses the prototype"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:83
#, no-wrap
msgid ""
"    int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:89
msgid ""
"and requires I<E<lt>sys/time.hE<gt>> instead of I<E<lt>rpc/auth_des.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:92
msgid ""
"B<rtime>()  in glibc 2.2.5 and earlier does not work properly on 64-bit "
"machines."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:98
msgid ""
"This example requires that port 37 is up and open.  You may check that the "
"time entry within I</etc/inetd.conf> is not commented out."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:102
msgid ""
"The program connects to a computer called \"linux\".  Using \"localhost\" "
"does not work.  The result is the localtime of the computer \"linux\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:111
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>rpc/auth_des.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:114
#, no-wrap
msgid ""
"static int use_tcp = 0;\n"
"static char *servername = \"linux\";\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:123
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sockaddr_in name;\n"
"    struct rpc_timeval time1 = {0,0};\n"
"    struct rpc_timeval timeout = {1,0};\n"
"    struct hostent *hent;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:128
#, no-wrap
msgid ""
"    memset(&name, 0, sizeof(name));\n"
"    sethostent(1);\n"
"    hent = gethostbyname(servername);\n"
"    memcpy(&name.sin_addr, hent-E<gt>h_addr, hent-E<gt>h_length);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/rtime.3:136
#, no-wrap
msgid ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n"
"    if (ret E<lt> 0)\n"
"        perror(\"rtime error\");\n"
"    else {\n"
"        time_t t = time1.tv_sec;\n"
"        printf(\"%s\\en\", ctime(&t));\n"
"    }\n"
msgstr ""

#.  .BR netdate (1),
#.  .BR rdate (1),
#. type: Plain text
#: man-pages/man3/rtime.3:144
msgid "B<ntpdate>(1), B<inetd>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/raise.3:29
#, no-wrap
msgid "RAISE"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:32
msgid "raise - send a signal to the caller"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:35
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:37
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:43
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:47
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:51
msgid "In a multithreaded program it is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:55
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:61
msgid ""
"If the signal causes a handler to be called, B<raise>()  will return only "
"after the signal handler has returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:64
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr ""

#. type: tbl table
#: man-pages/man3/raise.3:74
#, no-wrap
msgid "B<raise>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:78
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#.  2.3.2 used the obsolete tkill(), if available.
#. type: Plain text
#: man-pages/man3/raise.3:89
msgid ""
"Since version 2.3.3, glibc implements B<raise>()  by calling B<tgkill>(2), "
"if the kernel supports that system call.  Older glibc versions implemented "
"B<raise>()  using B<kill>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/raise.3:95
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3),"
" B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/realpath.3:28
#, no-wrap
msgid "REALPATH"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:31
msgid "realpath - return the canonicalized absolute pathname"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:35
#, no-wrap
msgid ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:37
#, no-wrap
msgid "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:45
msgid "B<realpath>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/realpath.3:51
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:73
msgid ""
"B<realpath>()  expands all symbolic links and resolves references to I</./>,"
" I</../> and extra \\(aq/\\(aq characters in the null-terminated string "
"named by I<path> to produce a canonicalized absolute pathname.  The "
"resulting pathname is stored as a null-terminated string, up to a maximum of"
" B<PATH_MAX> bytes, in the buffer pointed to by I<resolved_path>.  The "
"resulting path will have no symbolic link, I</./> or I</../> components."
msgstr ""

#.  Even if we use resolved_path == NULL, then realpath() will still
#.  return ENAMETOOLONG if the resolved pathname would exceed PATH_MAX
#.  bytes -- MTK, Dec 04
#.  .SH HISTORY
#.  The
#.  .BR realpath ()
#.  function first appeared in 4.4BSD, contributed by Jan-Simon Pendry.
#. type: Plain text
#: man-pages/man3/realpath.3:93
msgid ""
"If I<resolved_path> is specified as NULL, then B<realpath>()  uses "
"B<malloc>(3)  to allocate a buffer of up to B<PATH_MAX> bytes to hold the "
"resolved pathname, and returns a pointer to this buffer.  The caller should "
"deallocate this buffer using B<free>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:98
msgid ""
"If there is no error, B<realpath>()  returns a pointer to the "
"I<resolved_path>."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:105
msgid ""
"Otherwise, it returns NULL, the contents of the array I<resolved_path> are "
"undefined, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:109
msgid ""
"Read or search permission was denied for a component of the path prefix."
msgstr ""

#.  (In libc5 this would just cause a segfault.)
#. type: Plain text
#: man-pages/man3/realpath.3:118
msgid ""
"I<path> is NULL.  (In glibc versions before 2.3, this error is also returned"
" if I<resolved_path> is NULL.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:131
msgid ""
"A component of a pathname exceeded B<NAME_MAX> characters, or an entire "
"pathname exceeded B<PATH_MAX> characters."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:137
msgid "Out of memory."
msgstr ""

#. type: tbl table
#: man-pages/man3/realpath.3:150
#, no-wrap
msgid "B<realpath>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:154
msgid "4.4BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:159
msgid ""
"POSIX.1-2001 says that the behavior if I<resolved_path> is NULL is "
"implementation-defined.  POSIX.1-2008 specifies the behavior described in "
"this page."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:171
msgid ""
"In 4.4BSD and Solaris, the limit on the pathname length is B<MAXPATHLEN> "
"(found in I<E<lt>sys/param.hE<gt>>).  SUSv2 prescribes B<PATH_MAX> and "
"B<NAME_MAX>, as found in I<E<lt>limits.hE<gt>> or provided by the "
"B<pathconf>(3)  function.  A typical source fragment would be"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:181
#, no-wrap
msgid ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:185
msgid "(But see the BUGS section.)"
msgstr ""

#.      2012-05-05, According to Casper Dik, the statement about
#.      Solaris was not true at least as far back as 1997, and
#.      may never have been true.
#.  The 4.4BSD, Linux and SUSv2 versions always return an absolute
#.  pathname.
#.  Solaris may return a relative pathname when the
#.  .I path
#.  argument is relative.
#.  The prototype of
#.  .BR realpath ()
#.  is given in \fI<unistd.h>\fP in libc4 and libc5,
#.  but in \fI<stdlib.h>\fP everywhere else.
#. type: SS
#: man-pages/man3/realpath.3:199
#, no-wrap
msgid "GNU extensions"
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:210
msgid ""
"If the call fails with either B<EACCES> or B<ENOENT> and I<resolved_path> is"
" not NULL, then the prefix of I<path> that is not readable or does not exist"
" is returned in I<resolved_path>."
msgstr ""

#.  .LP
#.  The libc4 and libc5 implementation contained a buffer overflow
#.  (fixed in libc-5.4.13).
#.  Thus, set-user-ID programs like
#.  .BR mount (8)
#.  needed a private version.
#. type: Plain text
#: man-pages/man3/realpath.3:241
msgid ""
"The POSIX.1-2001 standard version of this function is broken by design, "
"since it is impossible to determine a suitable size for the output buffer, "
"I<resolved_path>.  According to POSIX.1-2001 a buffer of size B<PATH_MAX> "
"suffices, but B<PATH_MAX> need not be a defined constant, and may have to be"
" obtained using B<pathconf>(3).  And asking B<pathconf>(3)  does not really "
"help, since, on the one hand POSIX warns that the result of B<pathconf>(3)  "
"may be huge and unsuitable for mallocing memory, and on the other hand "
"B<pathconf>(3)  may return -1 to signify that B<PATH_MAX> is not bounded.  "
"The I<resolved_path\\ ==\\ NULL> feature, not standardized in POSIX.1-2001, "
"but standardized in POSIX.1-2008, allows this design problem to be avoided."
msgstr ""

#. type: Plain text
#: man-pages/man3/realpath.3:247
msgid ""
"B<realpath>(1), B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), "
"B<pathconf>(3), B<sysconf>(3)"
msgstr ""
