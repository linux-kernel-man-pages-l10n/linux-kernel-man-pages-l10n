# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# aereiae <aereiae@gmail.com>, 2014.
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2013-2014,2016.
# Dmitriy S. Seregin <dseregin@59.ru>, 2013.
# Katrin Kutepova <blackkatelv@gmail.com>, 2018.
# Lockal <lockalsash@gmail.com>, 2013.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
# Баринов Владимир, 2016.
# Иван Павлов <pavia00@gmail.com>, 2017,2019.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:26+0300\n"
"PO-Revision-Date: 2019-09-18 18:42+0300\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "RANDOM"
msgstr "RANDOM"

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/random.4:17
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/random.4:18
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/random.4:20
msgid "random, urandom - kernel random number source devices"
msgstr "random, urandom - ядерные устройства-источники случайных чисел"

#. type: SH
#: man-pages/man4/random.4:20
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man4/random.4:22
msgid "#include E<lt>linux/random.hE<gt>"
msgstr "#include E<lt>linux/random.hE<gt>"

#. type: Plain text
#: man-pages/man4/random.4:24
msgid "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"
msgstr "B<int ioctl(>I<fd>B<, RND>I<request>B<, >I<param>B<);>"

#. type: SH
#: man-pages/man4/random.4:24
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/random.4:34
msgid ""
"The character special files I</dev/random> and I</dev/urandom> (present "
"since Linux 1.3.30)  provide an interface to the kernel's random number "
"generator.  The file I</dev/random> has major device number 1 and minor "
"device number 8.  The file I</dev/urandom> has major device number 1 and "
"minor device number 9."
msgstr ""
"Специальные символьные файлы I</dev/random> и I</dev/urandom> (появились в "
"Linux 1.3.30) предоставляют интерфейс к генератору случайных чисел, "
"встроенному в ядро. Файл I</dev/random> имеет старший номер устройства 1 и "
"младший номер устройства 8. Файл I</dev/urandom> имеет старший номер "
"устройства 1 и младший номер устройства 9."

#. type: Plain text
#: man-pages/man4/random.4:40
msgid ""
"The random number generator gathers environmental noise from device drivers "
"and other sources into an entropy pool.  The generator also keeps an "
"estimate of the number of bits of noise in the entropy pool.  From this "
"entropy pool, random numbers are created."
msgstr ""
"Генератор случайных чисел собирает окружающий шум от работы драйверов "
"устройств и из других источников в пул энтропии. Генератор также постоянно "
"оценивает количество битов шума в пуле энтропии. Именно с помощью этого пула "
"создаются случайные числа."

#. type: Plain text
#: man-pages/man4/random.4:47
msgid ""
"Linux 3.17 and later provides the simpler and safer B<getrandom>(2)  "
"interface which requires no special files; see the B<getrandom>(2)  manual "
"page for details."
msgstr ""
"В Linux 3.17 и новее предоставляется более простой и безопасный интерфейс "
"B<getrandom>(2), который не требует специальных файлов; смотрите справочную "
"страницу B<getrandom>(2)."

#. type: Plain text
#: man-pages/man4/random.4:54
msgid ""
"When read, the I</dev/urandom> device returns random bytes using a "
"pseudorandom number generator seeded from the entropy pool.  Reads from this "
"device do not block (i.e., the CPU is not yielded), but can incur an "
"appreciable delay when requesting large amounts of data."
msgstr ""
"При чтении из устройства I</dev/urandom> возвращаются произвольные байты, "
"полученные из генератора псевдослучайных чисел, инициализированного из пула "
"энтропии. Чтение из этого устройства не приводит к блокировке (то есть, ЦП "
"не отдаёт управление), но может вызвать заметную задержку при запросе "
"большого количества данных."

#.  This is a real problem; see
#.  commit 9b4d008787f864f17d008c9c15bbe8a0f7e2fc24
#. type: Plain text
#: man-pages/man4/random.4:63
msgid ""
"When read during early boot time, I</dev/urandom> may return data prior to "
"the entropy pool being initialized.  If this is of concern in your "
"application, use B<getrandom>(2)  or I</dev/random> instead."
msgstr ""
"При чтении во время начальной загрузки ОС I</dev/urandom> может возвращать "
"данные до инициализации пула энтропии. Если это неприемлемо для приложения, "
"используйте B<getrandom>(2) или I</dev/random>."

#. type: Plain text
#: man-pages/man4/random.4:71
msgid ""
"The I</dev/random> device is a legacy interface which dates back to a time "
"where the cryptographic primitives used in the implementation of I</dev/"
"urandom> were not widely trusted.  It will return random bytes only within "
"the estimated number of bits of fresh noise in the entropy pool, blocking if "
"necessary.  I</dev/random> is suitable for applications that need high "
"quality randomness, and can afford indeterminate delays."
msgstr ""
"Устройство I</dev/random> является устаревшим интерфейсом, который относится "
"ко времени времени, когда криптографическим примитивам, используемым в "
"реализации I</dev/urandom>, не очень не доверяли. Интерфейс возвращает "
"произвольные байты только с подсчитанным количеством бит свежего шума в пуле "
"энтропии, блокируя работу при необходимости. Устройство I</dev/random> "
"подходит для приложений, которым нужна произвольность высокого качества и "
"без проблем относятся к задержкам на неопределённое время."

#. type: Plain text
#: man-pages/man4/random.4:90
msgid ""
"When the entropy pool is empty, reads from I</dev/random> will block until "
"additional environmental noise is gathered.  If B<open>(2)  is called for I</"
"dev/random> with the B<O_NONBLOCK> flag, a subsequent B<read>(2)  will not "
"block if the requested number of bytes is not available.  Instead, the "
"available bytes are returned.  If no byte is available, B<read>(2)  will "
"return -1 and I<errno> will be set to B<EAGAIN>."
msgstr ""
"Если пул энтропии пуст, попытка чтения I</dev/random> приведёт к блокировке, "
"пока не будет собран дополнительный окружающий шум. Если вызов B<open>(2) "
"для I</dev/random> запускается с флагом B<O_NONBLOCK>, то последующий "
"B<read>(2) не будет заблокируется, если количество запрашиваемых байт "
"недостаточно. Вместо этого будут возвращены имеющиеся байты. Если ни одного "
"байта нет, то B<read>(2) вернёт -1 и значение I<errno> станет равно "
"B<EAGAIN>."

#. type: Plain text
#: man-pages/man4/random.4:105
msgid ""
"The B<O_NONBLOCK> flag has no effect when opening I</dev/urandom>.  When "
"calling B<read>(2)  for the device I</dev/urandom>, reads of up to 256 bytes "
"will return as many bytes as are requested and will not be interrupted by a "
"signal handler.  Reads with a buffer over this limit may return less than "
"the requested number of bytes or fail with the error B<EINTR>, if "
"interrupted by a signal handler."
msgstr ""
"При открытии I</dev/urandom> флаг B<O_NONBLOCK> не учитывается. При вызове "
"B<read>(2) для устройства I</dev/urandom> чтение до 256 байт вернёт "
"запрошенное количество байт и не будет прервано обработчиком сигнала. Чтение "
"с буфером больше ограничения может вернуть количество байт меньше "
"запрошенного или завершиться ошибкой B<EINTR> при прерывании обработчиком "
"сигнала."

#.  commit 79a8468747c5f95ed3d5ce8376a3e82e0c5857fc
#.  SEC_XFER_SIZE in drivers/char/random.c
#. type: Plain text
#: man-pages/man4/random.4:120
msgid ""
"Since Linux 3.16, a B<read>(2)  from I</dev/urandom> will return at most "
"32\\ MB.  A B<read>(2)  from I</dev/random> will return at most 512 bytes "
"(340 bytes on Linux kernels before version 2.6.12)."
msgstr ""
"Начиная с Linux 3.16, вызов B<read>(2) может прочитать из I</dev/urandom> "
"почти 32\\ МБ. Из I</dev/random> будет прочитано не более 512 байт (340 байт "
"для ядер Linux до версии 2.6.12)."

#. type: Plain text
#: man-pages/man4/random.4:127
msgid ""
"Writing to I</dev/random> or I</dev/urandom> will update the entropy pool "
"with the data written, but this will not result in a higher entropy count.  "
"This means that it will impact the contents read from both files, but it "
"will not make reads from I</dev/random> faster."
msgstr ""
"При записи в I</dev/random> или I</dev/urandom> выполняется обновление пула "
"энтропии записываемыми данными, но при этом не увеличивается счётчик "
"энтропии. Это означает, что изменения отразятся в обоих файлах, но это не "
"ускорит процесс чтения из I</dev/random>."

#. type: SS
#: man-pages/man4/random.4:127
#, no-wrap
msgid "Usage"
msgstr "Использование"

#. type: Plain text
#: man-pages/man4/random.4:138
msgid ""
"The I</dev/random> interface is considered a legacy interface, and I</dev/"
"urandom> is preferred and sufficient in all use cases, with the exception of "
"applications which require randomness during early boot time; for these "
"applications, B<getrandom>(2)  must be used instead, because it will block "
"until the entropy pool is initialized."
msgstr ""
"Интерфейс I</dev/random> считается устаревшим, во всех случаях "
"предпочтительно использовать I</dev/urandom>; исключением являются "
"приложения, которым нужны произвольные байты во время загрузки системы; в "
"таких приложениях нужно использовать B<getrandom>(2), так как этот вызов "
"выполняет блокировку для ожидания наполнения пула энтропии."

#. type: Plain text
#: man-pages/man4/random.4:151
msgid ""
"If a seed file is saved across reboots as recommended below (all major Linux "
"distributions have done this since 2000 at least), the output is "
"cryptographically secure against attackers without local root access as soon "
"as it is reloaded in the boot sequence, and perfectly adequate for network "
"encryption session keys.  Since reads from I</dev/random> may block, users "
"will usually want to open it in nonblocking mode (or perform a read with "
"timeout), and provide some sort of user notification if the desired entropy "
"is not immediately available."
msgstr ""
"Если файл начальных чисел (seed file) сохраняется между перезагрузками как "
"рекомендуется далее (во всех основных дистрибутивах Linux это делается "
"начиная с 2000 года), то результат шифрования стоек от атакующего, не "
"имеющего локально привилегированного доступа, до перезагрузки машины, и "
"вполне подходит для ключей шифрования сетевых сеансов. Так как чтение из I</"
"dev/random> может привести к блокировке, пользователи хотели бы открывать "
"его в неблокирующем режиме (или выполнять чтение с задержкой), и иметь "
"механизм оповещения, если желаемый уровень энтропии в данный момент "
"недоступен."

#. type: SS
#: man-pages/man4/random.4:151
#, no-wrap
msgid "Configuration"
msgstr "Настройка"

#. type: Plain text
#: man-pages/man4/random.4:155
msgid ""
"If your system does not have I</dev/random> and I</dev/urandom> created "
"already, they can be created with the following commands:"
msgstr ""
"Если в системе нет I</dev/random> и I</dev/urandom>, то их можно создать "
"следующими командами:"

#. type: Plain text
#: man-pages/man4/random.4:161
#, no-wrap
msgid ""
"mknod -m 666 /dev/random c 1 8\n"
"mknod -m 666 /dev/urandom c 1 9\n"
"chown root:root /dev/random /dev/urandom\n"
msgstr ""
"mknod -m 666 /dev/random c 1 8\n"
"mknod -m 666 /dev/urandom c 1 9\n"
"chown root:root /dev/random /dev/urandom\n"

#. type: Plain text
#: man-pages/man4/random.4:172
msgid ""
"When a Linux system starts up without much operator interaction, the entropy "
"pool may be in a fairly predictable state.  This reduces the actual amount "
"of noise in the entropy pool below the estimate.  In order to counteract "
"this effect, it helps to carry entropy pool information across shut-downs "
"and start-ups.  To do this, add the lines to an appropriate script which is "
"run during the Linux system start-up sequence:"
msgstr ""
"Когда Linux-система запускается без участия человека, пул энтропии может "
"оказаться в довольно предсказуемом состоянии. Это снижает значимый объём "
"шума в пуле энтропии ниже оцениваемого. Для преодоления этого эффекта можно "
"сохранять информацию пула энтропии во время выключения и восстанавливать во "
"время запуска системы. Для этого добавьте строки в сценарий, который "
"выполняется при запуске Linux-системы:"

#. type: Plain text
#: man-pages/man4/random.4:189
#, no-wrap
msgid ""
"echo \"Initializing random number generator...\"\n"
"random_seed=/var/run/random-seed\n"
"# Carry a random seed from start-up to start-up\n"
"# Load and then save the whole entropy pool\n"
"if [ -f $random_seed ]; then\n"
"    cat $random_seed E<gt>/dev/urandom\n"
"else\n"
"    touch $random_seed\n"
"fi\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""
"echo \"Инициализация генератора случайных чисел…\"\n"
"random_seed=/var/run/random-seed\n"
"#  перенос случайного начального числа от запуска к запуску\n"
"# загрузка и сохранение всего пула энтропии\n"
"if [ -f $random_seed ]; then\n"
"    cat $random_seed E<gt>/dev/urandom\n"
"else\n"
"    touch $random_seed\n"
"fi\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"

#. type: Plain text
#: man-pages/man4/random.4:194
msgid ""
"Also, add the following lines in an appropriate script which is run during "
"the Linux system shutdown:"
msgstr ""
"Также добавьте следующие строки в сценарий, который выполняется при "
"завершении работы Linux-системы:"

#. type: Plain text
#: man-pages/man4/random.4:207
#, no-wrap
msgid ""
"# Carry a random seed from shut-down to start-up\n"
"# Save the whole entropy pool\n"
"echo \"Saving random seed...\"\n"
"random_seed=/var/run/random-seed\n"
"touch $random_seed\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"
msgstr ""
"# перенос случайного начального числа от выключения до запуска\n"
"# сохранение всего пула энтропии\n"
"echo \"Сохранение случайного начального числа…\"\n"
"random_seed=/var/run/random-seed\n"
"touch $random_seed\n"
"chmod 600 $random_seed\n"
"poolfile=/proc/sys/kernel/random/poolsize\n"
"[ -r $poolfile ] && bits=$(cat $poolfile) || bits=4096\n"
"bytes=$(expr $bits / 8)\n"
"dd if=/dev/urandom of=$random_seed count=1 bs=$bytes\n"

#. type: Plain text
#: man-pages/man4/random.4:214
msgid ""
"In the above examples, we assume Linux 2.6.0 or later, where I</proc/sys/"
"kernel/random/poolsize> returns the size of the entropy pool in bits (see "
"below)."
msgstr ""
"В примерах выше мы предполагаем, что используется ядро Linux 2.6.0 или "
"новее, в котором I</proc/sys/kernel/random/poolsize> содержит размер пула "
"энтропии в битах (смотрите ниже)."

#. type: SS
#: man-pages/man4/random.4:214
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#. type: Plain text
#: man-pages/man4/random.4:220
msgid ""
"The files in the directory I</proc/sys/kernel/random> (present since 2.3.16) "
"provide additional information about the I</dev/random> device:"
msgstr ""
"Файлы в каталоге I</proc/sys/kernel/random> (начиная с 2.3.16) предоставляют "
"дополнительную информацию об устройстве I</dev/random>:"

#. type: TP
#: man-pages/man4/random.4:220
#, no-wrap
msgid "I<entropy_avail>"
msgstr "I<entropy_avail>"

#. type: Plain text
#: man-pages/man4/random.4:224
msgid ""
"This read-only file gives the available entropy, in bits.  This will be a "
"number in the range 0 to 4096."
msgstr ""
"Файл доступен только для чтения и показывает количество бит доступной "
"энтропии. Данное число находится в диапазоне от 0 до 4096."

#. type: TP
#: man-pages/man4/random.4:224
#, no-wrap
msgid "I<poolsize>"
msgstr "I<poolsize>"

#. type: Plain text
#: man-pages/man4/random.4:229
msgid ""
"This file gives the size of the entropy pool.  The semantics of this file "
"vary across kernel versions:"
msgstr ""
"Файл содержит размер пула энтропии. Формат файла зависит от версии ядра:"

#. type: TP
#: man-pages/man4/random.4:230
#, no-wrap
msgid "Linux 2.4:"
msgstr "Linux 2.4:"

#. type: Plain text
#: man-pages/man4/random.4:237
msgid ""
"This file gives the size of the entropy pool in I<bytes>.  Normally, this "
"file will have the value 512, but it is writable, and can be changed to any "
"value for which an algorithm is available.  The choices are 32, 64, 128, "
"256, 512, 1024, or 2048."
msgstr ""
"В файле содержится размер пула энтропии в I<байтах>. Обычно это число 512, "
"но так как файл доступен на запись, значение можно изменить, подстроив его "
"под доступный алгоритм. Возможные значения \\(em 32, 64, 128, 256, 512, 1024 "
"или 2048."

#. type: TP
#: man-pages/man4/random.4:237
#, no-wrap
msgid "Linux 2.6 and later:"
msgstr "Linux 2.6 и новее:"

#. type: Plain text
#: man-pages/man4/random.4:242
msgid ""
"This file is read-only, and gives the size of the entropy pool in I<bits>.  "
"It contains the value 4096."
msgstr ""
"Файл доступен только на чтение и содержит размер пула энтропии в I<битах>. "
"Значение равно 4096."

#. type: TP
#: man-pages/man4/random.4:243
#, no-wrap
msgid "I<read_wakeup_threshold>"
msgstr "I<read_wakeup_threshold>"

#. type: Plain text
#: man-pages/man4/random.4:250
msgid ""
"This file contains the number of bits of entropy required for waking up "
"processes that sleep waiting for entropy from I</dev/random>.  The default "
"is 64."
msgstr ""
"В файле содержится количество бит энтропии, требуемое для пробуждения "
"процессов, которые спят в ожидании энтропии из I</dev/random>. Значение по "
"умолчанию равно 64."

#. type: TP
#: man-pages/man4/random.4:250
#, no-wrap
msgid "I<write_wakeup_threshold>"
msgstr "I<write_wakeup_threshold>"

#. type: Plain text
#: man-pages/man4/random.4:261
msgid ""
"This file contains the number of bits of entropy below which we wake up "
"processes that do a B<select>(2)  or B<poll>(2)  for write access to I</dev/"
"random>.  These values can be changed by writing to the files."
msgstr ""
"В файле содержится количество бит энтропии, менее которого мы пробуждаем "
"процессы, которые выполнили вызовы B<select>(2) или B<poll>(2) для ожидания "
"записи в I</dev/random>. Эти значения можно изменить, записав новые числа в "
"эти файлы."

#. type: TP
#: man-pages/man4/random.4:261
#, no-wrap
msgid "I<uuid> and I<boot_id>"
msgstr "I<uuid> и I<boot_id>"

#. type: Plain text
#: man-pages/man4/random.4:268
msgid ""
"These read-only files contain random strings like 6fd5a44b-35f4-4ad4-"
"a9b9-6b9be13e1fe9.  The former is generated afresh for each read, the latter "
"was generated once."
msgstr ""
"Эти файлы, доступные только для чтения, содержат произвольные строки вида "
"6fd5a44b-35f4-4ad4-a9b9-6b9be13e1fe9. Значение первого генерируется заново "
"при каждом чтении, а значение второго генерируется только один раз."

#. type: SS
#: man-pages/man4/random.4:268
#, no-wrap
msgid "ioctl(2) interface"
msgstr "Интерфейс ioctl(2)"

#. type: Plain text
#: man-pages/man4/random.4:279
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to either I</dev/random> or I</dev/urandom>.  All requests "
"performed will interact with the input entropy pool impacting both I</dev/"
"random> and I</dev/urandom>.  The B<CAP_SYS_ADMIN> capability is required "
"for all requests except B<RNDGETENTCNT>."
msgstr ""
"Для файловых дескрипторов, соединённых с файлами I</dev/random> и I</dev/"
"urandom>, определены запросы B<ioctl>(2), перечисленные ниже. Все "
"выполняемые запросы обращаются к входному пулу энтропии, который относится к "
"и к I</dev/random>, и к I</dev/urandom>. Для выполнения всех запросов (кроме "
"B<RNDGETENTCNT>) требуется мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man4/random.4:279
#, no-wrap
msgid "B<RNDGETENTCNT>"
msgstr "B<RNDGETENTCNT>"

#. type: Plain text
#: man-pages/man4/random.4:286
msgid ""
"Retrieve the entropy count of the input pool, the contents will be the same "
"as the I<entropy_avail> file under proc.  The result will be stored in the "
"int pointed to by the argument."
msgstr ""
"Возвращает счётчик энтропии входного пула, возвращается содержимое из файла "
"I<entropy_avail> в proc. Результат сохраняется в int, указанный в параметре."

#. type: TP
#: man-pages/man4/random.4:286
#, no-wrap
msgid "B<RNDADDTOENTCNT>"
msgstr "B<RNDADDTOENTCNT>"

#. type: Plain text
#: man-pages/man4/random.4:290
msgid ""
"Increment or decrement the entropy count of the input pool by the value "
"pointed to by the argument."
msgstr ""
"Увеличивает или уменьшает счётчик энтропии входного пула на значение "
"аргумента."

#. type: TP
#: man-pages/man4/random.4:290
#, no-wrap
msgid "B<RNDGETPOOL>"
msgstr "B<RNDGETPOOL>"

#. type: Plain text
#: man-pages/man4/random.4:293
msgid "Removed in Linux 2.6.9."
msgstr "Удалён из Linux 2.6.9."

#. type: TP
#: man-pages/man4/random.4:293
#, no-wrap
msgid "B<RNDADDENTROPY>"
msgstr "B<RNDADDENTROPY>"

#. type: Plain text
#: man-pages/man4/random.4:301
msgid ""
"Add some additional entropy to the input pool, incrementing the entropy "
"count.  This differs from writing to I</dev/random> or I</dev/urandom>, "
"which only adds some data but does not increment the entropy count.  The "
"following structure is used:"
msgstr ""
"Вносит дополнительную энтропию во входной пул, увеличивая счётчик энтропии. "
"Запись в I</dev/random> или I</dev/urandom> добавляет только данные, но не "
"увеличивает счётчик энтропии (в этом отличие). Используется следующая "
"структура:"

#. type: Plain text
#: man-pages/man4/random.4:309
#, no-wrap
msgid ""
"struct rand_pool_info {\n"
"    int    entropy_count;\n"
"    int    buf_size;\n"
"    __u32  buf[0];\n"
"};\n"
msgstr ""
"struct rand_pool_info {\n"
"    int    entropy_count;\n"
"    int    buf_size;\n"
"    __u32  buf[0];\n"
"};\n"

#. type: Plain text
#: man-pages/man4/random.4:319
msgid ""
"Here I<entropy_count> is the value added to (or subtracted from) the entropy "
"count, and I<buf> is the buffer of size I<buf_size> which gets added to the "
"entropy pool."
msgstr ""
"Здесь I<entropy_count> — добавляемое (или вычитаемое) значение к счётчику "
"энтропии, а I<buf> — буфер с размером I<buf_size>, из которого в пул "
"энтропии добавляются данные."

#. type: TP
#: man-pages/man4/random.4:319
#, no-wrap
msgid "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"
msgstr "B<RNDZAPENTCNT>, B<RNDCLEARPOOL>"

#. type: Plain text
#: man-pages/man4/random.4:323
msgid ""
"Zero the entropy count of all pools and add some system data (such as wall "
"clock) to the pools."
msgstr ""
"Обнуляет счётчики всех пулов и добавляет в них некоторые системные данные "
"(такие как время)."

#. type: SH
#: man-pages/man4/random.4:323
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/random.4:325
msgid "I</dev/random>"
msgstr "I</dev/random>"

#. type: Plain text
#: man-pages/man4/random.4:327
msgid "I</dev/urandom>"
msgstr "I</dev/urandom>"

#. type: SH
#: man-pages/man4/random.4:327
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/random.4:331
msgid ""
"For an overview and comparison of the various interfaces that can be used to "
"obtain randomness, see B<random>(7)."
msgstr ""
"Обзор и сравнение возможных интерфейсов, через которые можно получать "
"случайные данные, смотрите в B<random>(7)."

#. type: SH
#: man-pages/man4/random.4:331
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  .SH AUTHOR
#.  The kernel's random number generator was written by
#.  Theodore Ts'o (tytso@athena.mit.edu).
#. type: Plain text
#: man-pages/man4/random.4:338
msgid ""
"During early boot time, reads from I</dev/urandom> may return data prior to "
"the entropy pool being initialized."
msgstr ""
"Во время начальной загрузки ОС чтение из I</dev/urandom> может возвращать "
"данные до инициализации пула энтропии."

#. type: SH
#: man-pages/man4/random.4:338
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/random.4:342
msgid "B<mknod>(1), B<getrandom>(2), B<random>(7)"
msgstr "B<mknod>(1), B<getrandom>(2), B<random>(7)"

#. type: Plain text
#: man-pages/man4/random.4:343
msgid "RFC\\ 1750, \"Randomness Recommendations for Security\""
msgstr "RFC\\ 1750, \"Randomness Recommendations for Security\""

#. type: TH
#: man-pages/man4/rtc.4:30
#, no-wrap
msgid "RTC"
msgstr "RTC"

#. type: Plain text
#: man-pages/man4/rtc.4:33
msgid "rtc - real-time clock"
msgstr "rtc - часы реального времени"

#. type: Plain text
#: man-pages/man4/rtc.4:35
msgid "#include E<lt>linux/rtc.hE<gt>"
msgstr "#include E<lt>linux/rtc.hE<gt>"

#. type: Plain text
#: man-pages/man4/rtc.4:37
msgid "B<int ioctl(>I<fd>B<, RTC_>I<request>B<, >I<param>B<);>"
msgstr "B<int ioctl(>I<fd>B<, RTC_>I<request>B<, >I<param>B<);>"

#. type: Plain text
#: man-pages/man4/rtc.4:39
msgid "This is the interface to drivers for real-time clocks (RTCs)."
msgstr ""
"Данное устройство представляет собой интерфейс к драйверам часов реального "
"времени (RTC)."

#. type: Plain text
#: man-pages/man4/rtc.4:46
msgid ""
"Most computers have one or more hardware clocks which record the current "
"\"wall clock\" time.  These are called \"Real Time Clocks\" (RTCs).  One of "
"these usually has battery backup power so that it tracks the time even while "
"the computer is turned off.  RTCs often provide alarms and other interrupts."
msgstr ""
"В большинстве компьютеров есть одни и более аппаратных часов,  ведущих отчёт "
"\"обычного\" времени. Они называются \"часами реального времени\" (Real Time "
"Clock, RTC). Некоторые из них имеют батарею резервного питания для "
"продолжения работы в периоды, когда компьютер выключен. В RTC часто встроены "
"будильники и другие прерывания."

#. type: Plain text
#: man-pages/man4/rtc.4:51
msgid ""
"All i386 PCs, and ACPI-based systems, have an RTC that is compatible with "
"the Motorola MC146818 chip on the original PC/AT.  Today such an RTC is "
"usually integrated into the mainboard's chipset (south bridge), and uses a "
"replaceable coin-sized backup battery."
msgstr ""
"Все ПК i386 и системы с ACPI содержат RTC, которые совместимы с микросхемой "
"Motorola MC146818 из первоначальной модели PC/AT. Сегодня такие RTC обычно "
"встраивают в чипсет материнской платы (в южный мост), и они используют "
"заменяемую резервную батарею (типа «таблетки»)."

#. type: Plain text
#: man-pages/man4/rtc.4:55
msgid ""
"Non-PC systems, such as embedded systems built around system-on-chip "
"processors, use other implementations.  They usually won't offer the same "
"functionality as the RTC from a PC/AT."
msgstr ""
"В системах, несовместимых с PC (например, встраиваемые системы, собираемые "
"на процессоре \"всё в одном\"), используются другие варианты. Обычно, они не "
"предоставляют таких возможностей, как RTC в PC/AT."

#. type: SS
#: man-pages/man4/rtc.4:55
#, no-wrap
msgid "RTC vs system clock"
msgstr "RTC и системные часы"

#. type: Plain text
#: man-pages/man4/rtc.4:67
msgid ""
"RTCs should not be confused with the system clock, which is a software clock "
"maintained by the kernel and used to implement B<gettimeofday>(2)  and "
"B<time>(2), as well as setting timestamps on files, and so on.  The system "
"clock reports seconds and microseconds since a start point, defined to be "
"the POSIX Epoch: 1970-01-01 00:00:00 +0000 (UTC).  (One common "
"implementation counts timer interrupts, once per \"jiffy\", at a frequency "
"of 100, 250, or 1000 Hz.)  That is, it is supposed to report wall clock "
"time, which RTCs also do."
msgstr ""
"Не нужно путать RTC с системными часами, которые представляют собой часы, "
"реализованные в ядре программно и используемые для работы B<gettimeofday>(2) "
"и B<time>(2), а также при указании временных меток файлов и т. п. Системные "
"часы выдают секунды и микросекунды, начиная отсчёт от эпохи POSIX: "
"1970-01-01 00:00:00 +0000 (UTC) (в основном, реализуется на основе таймера "
"прерываний ведя подсчёт «мигов» (jiffy) c частотой 100, 250 или 1000 Гц). То "
"есть, предполагается, что они показывают обычное время как и RTC."

#. type: Plain text
#: man-pages/man4/rtc.4:77
msgid ""
"A key difference between an RTC and the system clock is that RTCs run even "
"when the system is in a low power state (including \"off\"), and the system "
"clock can't.  Until it is initialized, the system clock can only report time "
"since system boot ... not since the POSIX Epoch.  So at boot time, and after "
"resuming from a system low power state, the system clock will often be set "
"to the current wall clock time using an RTC.  Systems without an RTC need to "
"set the system clock using another clock, maybe across the network or by "
"entering that data manually."
msgstr ""
"Ключевым отличием RTC от системных часов, является то, что RTC работают даже "
"когда система находится в состоянии пониженного энергопотребления (даже в "
"выключенном), а для системных часов такое недоступно. До своей инициализации "
"системные часы показывают время, прошедшее с момента запуска системы, а не с "
"начала эпохи POSIX. Поэтому при загрузке и после восстановления из состояния "
"пониженного энергопотребления в системных часах часто подстраивают текущее "
"время с помощью RTC. Системам без RTC требуется установить свои системные "
"часы с помощью других часов, возможно через сеть или ручного ввода данных."

#. type: SS
#: man-pages/man4/rtc.4:77
#, no-wrap
msgid "RTC functionality"
msgstr "Назначение RTC"

#. type: Plain text
#: man-pages/man4/rtc.4:81
msgid ""
"RTCs can be read and written with B<hwclock>(8), or directly with the ioctl "
"requests listed below."
msgstr ""
"Из RTC можно читать или писать с помощью B<hwclock>(8) или через вызовы "
"ioctl, перечисленные ниже."

#. type: Plain text
#: man-pages/man4/rtc.4:84
msgid ""
"Besides tracking the date and time, many RTCs can also generate interrupts"
msgstr ""
"Помимо контроля даты и времени многие RTC также позволяют генерировать "
"прерывания"

#. type: IP
#: man-pages/man4/rtc.4:84 man-pages/man4/rtc.4:86 man-pages/man4/rtc.4:89
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man4/rtc.4:86
msgid "on every clock update (i.e., once per second);"
msgstr "при каждом обновлении часов (т.е. раз в секунду);"

#. type: Plain text
#: man-pages/man4/rtc.4:89
msgid ""
"at periodic intervals with a frequency that can be set to any power-of-2 "
"multiple in the range 2 Hz to 8192 Hz;"
msgstr ""
"через периодические интервалы с частотой, значение которой может быть любой "
"степенью 2 в диапазоне от 2 Гц до 8192 Гц;"

#. type: Plain text
#: man-pages/man4/rtc.4:91
msgid "on reaching a previously specified alarm time."
msgstr "по достижению указанного времени будильника."

#. type: Plain text
#: man-pages/man4/rtc.4:100
msgid ""
"Each of those interrupt sources can be enabled or disabled separately.  On "
"many systems, the alarm interrupt can be configured as a system wakeup "
"event, which can resume the system from a low power state such as Suspend-to-"
"RAM (STR, called S3 in ACPI systems), Hibernation (called S4 in ACPI "
"systems), or even \"off\" (called S5 in ACPI systems).  On some systems, the "
"battery backed RTC can't issue interrupts, but another one can."
msgstr ""
"Каждый из этих источников прерываний можно включать или выключать независимо "
"друг от друга. Во многих системах прерывание будильника можно настроить как "
"событие пробуждения системы, для вывода системы из состояний пониженного "
"энергопотребления таких как: ждущего режима (Suspend-to-RAM (STR), S3 в "
"терминологии ACPI), спящего режима (hibernation, S4 в терминологии ACPI) или "
"даже из \"выключенного\" состояния (S5 в терминологии ACPI). Но в некоторых "
"системах RTC с резервной батареей не могут генерировать прерывания."

#. type: Plain text
#: man-pages/man4/rtc.4:120
msgid ""
"The I</dev/rtc> (or I</dev/rtc0>, I</dev/rtc1>, etc.)  device can be opened "
"only once (until it is closed) and it is read-only.  On B<read>(2)  and "
"B<select>(2)  the calling process is blocked until the next interrupt from "
"that RTC is received.  Following the interrupt, the process can read a long "
"integer, of which the least significant byte contains a bit mask encoding "
"the types of interrupt that occurred, while the remaining 3 bytes contain "
"the number of interrupts since the last B<read>(2)."
msgstr ""
"Устройство I</dev/rtc> (или I</dev/rtc0>, I</dev/rtc1> и т.д.) можно открыть "
"только один раз (до тех пор, пока не будет закрыто) и только для чтения. При "
"вызове B<read>(2) и B<select>(2) вызывающий процесс блокируется до "
"следующего приёма прерывания от RTC. После прерывания процесс может "
"прочитать длинное целое, в котором наименее значимый байт содержит битовую "
"маску типа произошедшего прерывания, а остальные 3 байта содержат количество "
"прерываний, произошедших с последнего вызова B<read>(2)."

#. type: Plain text
#: man-pages/man4/rtc.4:124
msgid ""
"The following B<ioctl>(2)  requests are defined on file descriptors "
"connected to RTC devices:"
msgstr ""
"Для файловых дескрипторов, указывающих на открытые устройства RTC, доступны "
"следующие запросы B<ioctl>(2):"

#. type: TP
#: man-pages/man4/rtc.4:124
#, no-wrap
msgid "B<RTC_RD_TIME>"
msgstr "B<RTC_RD_TIME>"

#. type: Plain text
#: man-pages/man4/rtc.4:127
msgid "Returns this RTC's time in the following structure:"
msgstr "Получить время RTC в виде следующей структуры:"

#. type: Plain text
#: man-pages/man4/rtc.4:141
#, no-wrap
msgid ""
"struct rtc_time {\n"
"    int tm_sec;\n"
"    int tm_min;\n"
"    int tm_hour;\n"
"    int tm_mday;\n"
"    int tm_mon;\n"
"    int tm_year;\n"
"    int tm_wday;     /* unused */\n"
"    int tm_yday;     /* unused */\n"
"    int tm_isdst;    /* unused */\n"
"};\n"
msgstr ""
"struct rtc_time {\n"
"    int tm_sec;\n"
"    int tm_min;\n"
"    int tm_hour;\n"
"    int tm_mday;\n"
"    int tm_mon;\n"
"    int tm_year;\n"
"    int tm_wday;     /* не используется */\n"
"    int tm_yday;     /* не используется */\n"
"    int tm_isdst;    /* не используется */\n"
"};\n"

#. type: Plain text
#: man-pages/man4/rtc.4:151
msgid ""
"The fields in this structure have the same meaning and ranges as for the "
"I<tm> structure described in B<gmtime>(3).  A pointer to this structure "
"should be passed as the third B<ioctl>(2)  argument."
msgstr ""
"Поля структуры имеют те же значения и диапазоны что и у структуры I<tm>, "
"описанной в B<gmtime>(3). Указатель на эту структуру должен передаваться в "
"третьем аргументе B<ioctl>(2)."

#. type: TP
#: man-pages/man4/rtc.4:151
#, no-wrap
msgid "B<RTC_SET_TIME>"
msgstr "B<RTC_SET_TIME>"

#. type: Plain text
#: man-pages/man4/rtc.4:162
msgid ""
"Sets this RTC's time to the time specified by the I<rtc_time> structure "
"pointed to by the third B<ioctl>(2)  argument.  To set the RTC's time the "
"process must be privileged (i.e., have the B<CAP_SYS_TIME> capability)."
msgstr ""
"Установить время RTC в значение, заданное в структуре I<rtc_time>, на "
"которую указывает третий аргумент B<ioctl>(2). Для установки времени RTC "
"процесс должен иметь права (т.е., мандат B<CAP_SYS_TIME>)."

#. type: TP
#: man-pages/man4/rtc.4:162
#, no-wrap
msgid "B<RTC_ALM_READ>, B<RTC_ALM_SET>"
msgstr "B<RTC_ALM_READ>, B<RTC_ALM_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:179
msgid ""
"Read and set the alarm time, for RTCs that support alarms.  The alarm "
"interrupt must be separately enabled or disabled using the B<RTC_AIE_ON>, "
"B<RTC_AIE_OFF> requests.  The third B<ioctl>(2)  argument is a pointer to an "
"I<rtc_time> structure.  Only the I<tm_sec>, I<tm_min>, and I<tm_hour> fields "
"of this structure are used."
msgstr ""
"Получить и установить время будильника, если он поддерживается RTC. "
"Прерывание будильника должно быть включено или выключено отдельно с помощью "
"запросов B<RTC_AIE_ON>, B<RTC_AIE_OFF>. Третий аргумент B<ioctl>(2) является "
"указателем на структуру I<rtc_time>. В структуре используются только поля "
"I<tm_sec>, I<tm_min> и I<tm_hour>."

#. type: TP
#: man-pages/man4/rtc.4:179
#, no-wrap
msgid "B<RTC_IRQP_READ>, B<RTC_IRQP_SET>"
msgstr "B<RTC_IRQP_READ>, B<RTC_IRQP_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:201
msgid ""
"Read and set the frequency for periodic interrupts, for RTCs that support "
"periodic interrupts.  The periodic interrupt must be separately enabled or "
"disabled using the B<RTC_PIE_ON>, B<RTC_PIE_OFF> requests.  The third "
"B<ioctl>(2)  argument is an I<unsigned long\\ *> or an I<unsigned long>, "
"respectively.  The value is the frequency in interrupts per second.  The set "
"of allowable frequencies is the multiples of two in the range 2 to 8192.  "
"Only a privileged process (i.e., one having the B<CAP_SYS_RESOURCE> "
"capability) can set frequencies above the value specified in I</proc/sys/dev/"
"rtc/max-user-freq>.  (This file contains the value 64 by default.)"
msgstr ""
"Получить и установить частоту периодических прерываний, если они "
"поддерживаются RTC. Периодическое прерывание должно быть включено или "
"выключено отдельно с помощью запросов B<RTC_PIE_ON>, B<RTC_PIE_OFF>. Третий "
"аргумент B<ioctl>(2) имеет тип I<unsigned long\\ *> или I<unsigned long>, "
"соответственно. Значение задаёт частоту прерываний в секунду. Можно "
"указывать частоты кратны степени 2 в диапазоне от 2 до 8192. Только "
"привилегированный процесс (т.е., имеющий мандат B<CAP_SYS_RESOURCE>) может "
"устанавливать частоты выше значения, указанного в I</proc/sys/dev/rtc/max-"
"user-freq>. (По умолчанию в этом файле содержится значение 64.)"

#. type: TP
#: man-pages/man4/rtc.4:201
#, no-wrap
msgid "B<RTC_AIE_ON>, B<RTC_AIE_OFF>"
msgstr "B<RTC_AIE_ON>, B<RTC_AIE_OFF>"

#. type: Plain text
#: man-pages/man4/rtc.4:207
msgid ""
"Enable or disable the alarm interrupt, for RTCs that support alarms.  The "
"third B<ioctl>(2)  argument is ignored."
msgstr ""
"Включить или выключить прерывание от будильника, если RTC поддерживает "
"будильники. Третий аргумент B<ioctl>(2) игнорируется."

#. type: TP
#: man-pages/man4/rtc.4:207
#, no-wrap
msgid "B<RTC_UIE_ON>, B<RTC_UIE_OFF>"
msgstr "B<RTC_UIE_ON>, B<RTC_UIE_OFF>"

#. type: Plain text
#: man-pages/man4/rtc.4:214
msgid ""
"Enable or disable the interrupt on every clock update, for RTCs that support "
"this once-per-second interrupt.  The third B<ioctl>(2)  argument is ignored."
msgstr ""
"Включить или выключить прерывание при каждом обновлении часов, если RTC "
"поддерживает создание прерываний один раз в секунду. Третий аргумент "
"B<ioctl>(2) игнорируется."

#. type: TP
#: man-pages/man4/rtc.4:214
#, no-wrap
msgid "B<RTC_PIE_ON>, B<RTC_PIE_OFF>"
msgstr "B<RTC_PIE_ON>, B<RTC_PIE_OFF>"

#. type: Plain text
#: man-pages/man4/rtc.4:226
msgid ""
"Enable or disable the periodic interrupt, for RTCs that support these "
"periodic interrupts.  The third B<ioctl>(2)  argument is ignored.  Only a "
"privileged process (i.e., one having the B<CAP_SYS_RESOURCE> capability) can "
"enable the periodic interrupt if the frequency is currently set above the "
"value specified in I</proc/sys/dev/rtc/max-user-freq>."
msgstr ""
"Включить или выключить периодическое прерывание, если RTC поддерживает "
"периодические прерывания. Третий аргумент B<ioctl>(2) игнорируется. Только "
"привилегированный процесс (т.е., имеющий мандат B<CAP_SYS_RESOURCE>) может "
"устанавливать частоты выше значения, указанного в I</proc/sys/dev/rtc/max-"
"user-freq>."

#. type: TP
#: man-pages/man4/rtc.4:226
#, no-wrap
msgid "B<RTC_EPOCH_READ>, B<RTC_EPOCH_SET>"
msgstr "B<RTC_EPOCH_READ>, B<RTC_EPOCH_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:249
msgid ""
"Many RTCs encode the year in an 8-bit register which is either interpreted "
"as an 8-bit binary number or as a BCD number.  In both cases, the number is "
"interpreted relative to this RTC's Epoch.  The RTC's Epoch is initialized to "
"1900 on most systems but on Alpha and MIPS it might also be initialized to "
"1952, 1980, or 2000, depending on the value of an RTC register for the "
"year.  With some RTCs, these operations can be used to read or to set the "
"RTC's Epoch, respectively.  The third B<ioctl>(2)  argument is an I<unsigned "
"long\\ *> or an I<unsigned long>, respectively, and the value returned (or "
"assigned) is the Epoch.  To set the RTC's Epoch the process must be "
"privileged (i.e., have the B<CAP_SYS_TIME> capability)."
msgstr ""
"В многих RTC год кодируется в 8-битном регистре, значение которого может "
"учитываться как 8-битное двоичное число или как число в двоично-десятичном "
"коде (BCD). В обоих случаях, число учитывается относительно начала эпохи "
"RTC. Эпоха RTC на большинстве систем начинается с 1900 года, но на Alpha и "
"MIPS также она может начинаться с 1952, 1980 или 2000 года, в зависимости от "
"значения годового регистра RTC. С некоторыми RTC эти операции можно "
"использовать для чтения или установки эпохи RTC, соответственно. Третий "
"аргумент B<ioctl>(2) имеет тип I<unsigned long\\ *> или I<unsigned long>, "
"соответственно, а возвращаемое значение (или назначаемое) является эпохой. "
"Чтобы установить эпоху RTC процесс должен быть привилегированным (т.е., "
"иметь мандат B<CAP_SYS_TIME>)."

#. type: TP
#: man-pages/man4/rtc.4:249
#, no-wrap
msgid "B<RTC_WKALM_RD>, B<RTC_WKALM_SET>"
msgstr "B<RTC_WKALM_RD>, B<RTC_WKALM_SET>"

#. type: Plain text
#: man-pages/man4/rtc.4:253
msgid ""
"Some RTCs support a more powerful alarm interface, using these ioctls to "
"read or write the RTC's alarm time (respectively) with this structure:"
msgstr ""
"Некоторые RTC поддерживают более универсальный интерфейс будильника, в "
"котором эти ioctl используются для чтения и записи времени будильника RTC "
"(соответственно) с помощью структуры:"

#. type: Plain text
#: man-pages/man4/rtc.4:262
#, no-wrap
msgid ""
"struct rtc_wkalrm {\n"
"    unsigned char enabled;\n"
"    unsigned char pending;\n"
"    struct rtc_time time;\n"
"};\n"
msgstr ""
"struct rtc_wkalrm {\n"
"    unsigned char enabled;\n"
"    unsigned char pending;\n"
"    struct rtc_time time;\n"
"};\n"

#. type: Plain text
#: man-pages/man4/rtc.4:294
msgid ""
"The I<enabled> flag is used to enable or disable the alarm interrupt, or to "
"read its current status; when using these calls, B<RTC_AIE_ON> and "
"B<RTC_AIE_OFF> are not used.  The I<pending> flag is used by B<RTC_WKALM_RD> "
"to report a pending interrupt (so it's mostly useless on Linux, except when "
"talking to the RTC managed by EFI firmware).  The I<time> field is as used "
"with B<RTC_ALM_READ> and B<RTC_ALM_SET> except that the I<tm_mday>, "
"I<tm_mon>, and I<tm_year> fields are also valid.  A pointer to this "
"structure should be passed as the third B<ioctl>(2)  argument."
msgstr ""
"Флаг I<enabled> используется для включения или отключения прерывания "
"будильника, или для чтения его текущего состояния; когда совершаются данные "
"вызовы B<RTC_AIE_ON> и B<RTC_AIE_OFF> не используются. Флаг I<pending> "
"используется B<RTC_WKALM_RD> для сообщения об ожидающем прерывании (хотя это "
"практически бесполезно в Linux, за исключением RTC, управляемого "
"микропрограммой EFI). Поле I<time> используется B<RTC_ALM_READ> и "
"B<RTC_ALM_SET>, но поля I<tm_mday>, I<tm_mon> и I<tm_year> также "
"учитываются. Указатель на эту структуру должен передаваться в третьем "
"аргументе B<ioctl>(2)."

#. type: TP
#: man-pages/man4/rtc.4:295
#, no-wrap
msgid "I</dev/rtc>, I</dev/rtc0>, I</dev/rtc1>, etc."
msgstr "I</dev/rtc>, I</dev/rtc0>, I</dev/rtc1>, и тд."

#. type: Plain text
#: man-pages/man4/rtc.4:298
msgid "RTC special character device files."
msgstr "Файлы специального символьного устройства RTC."

#. type: TP
#: man-pages/man4/rtc.4:298
#, no-wrap
msgid "I</proc/driver/rtc>"
msgstr "I</proc/driver/rtc>"

#. type: Plain text
#: man-pages/man4/rtc.4:301
msgid "status of the (first) RTC."
msgstr "состояние (первого) RTC."

#. type: Plain text
#: man-pages/man4/rtc.4:308
msgid ""
"When the kernel's system time is synchronized with an external reference "
"using B<adjtimex>(2)  it will update a designated RTC periodically every 11 "
"minutes.  To do so, the kernel has to briefly turn off periodic interrupts; "
"this might affect programs using that RTC."
msgstr ""
"Когда системное время ядра синхронизируется с внешним источником с помощью "
"B<adjtimex>(2), оно будет обновляться назначенным RTC с периодичностью "
"каждые 11 минут. Для этого ядро на время отключает периодические прерывания; "
"это может повлиять на программы, использующие RTC."

#. type: Plain text
#: man-pages/man4/rtc.4:311
msgid ""
"An RTC's Epoch has nothing to do with the POSIX Epoch which is used only for "
"the system clock."
msgstr ""
"Эпоха RTC не имеет ничего общего с эпохой POSIX, которая используется только "
"в системных часах."

#. type: Plain text
#: man-pages/man4/rtc.4:315
msgid ""
"If the year according to the RTC's Epoch and the year register is less than "
"1970 it is assumed to be 100 years later, that is, between 2000 and 2069."
msgstr ""
"Если год, согласно эпохи RTC и регистр года меньше чем 1970, то "
"предполагается, что время на 100 лет позже, то есть, между 2000 и 2069 "
"годами."

#. type: Plain text
#: man-pages/man4/rtc.4:322
msgid ""
"Some RTCs support \"wildcard\" values in alarm fields, to support scenarios "
"like periodic alarms at fifteen minutes after every hour, or on the first "
"day of each month.  Such usage is nonportable; portable user-space code "
"expects only a single alarm interrupt, and will either disable or "
"reinitialize the alarm after receiving it."
msgstr ""
"Некоторые RTC поддерживают значения «шаблона» в полях будильника, чтобы "
"обеспечить поддержку сценариев, например периодические будильники, через "
"первые 15 минут в начале каждого часа, или первый день каждого месяца. Но "
"это непереносимо; переносимый код пользовательского пространства только "
"ожидает единичное прерывание от будильника, и будет или отключать, или "
"реинициализировать будильник после приёма."

#. type: Plain text
#: man-pages/man4/rtc.4:330
msgid ""
"Some RTCs support periodic interrupts with periods that are multiples of a "
"second rather than fractions of a second; multiple alarms; programmable "
"output clock signals; nonvolatile memory; and other hardware capabilities "
"that are not currently exposed by this API."
msgstr ""
"Некоторые RTC поддерживают периодические прерывания с периодами кратными "
"степени 2, а не дробной секунде; несколько будильников; программируемые "
"выходные сигналы часов; энергонезависимую память; другие аппаратные "
"свойства, для которых пока ещё не предусмотрено программного интерфейса."

#. type: Plain text
#: man-pages/man4/rtc.4:340
msgid ""
"B<date>(1), B<adjtimex>(2), B<gettimeofday>(2), B<settimeofday>(2), "
"B<stime>(2), B<time>(2), B<gmtime>(3), B<time>(7), B<hwclock>(8)"
msgstr ""
"B<date>(1), B<adjtimex>(2), B<gettimeofday>(2), B<settimeofday>(2), "
"B<stime>(2), B<time>(2), B<gmtime>(3), B<time>(7), B<hwclock>(8)"

#. type: Plain text
#: man-pages/man4/rtc.4:342
msgid "I<Documentation/rtc.txt> in the Linux kernel source tree"
msgstr "Файл I<Documentation/rtc.txt> в дереве исходного кода ядра Linux"

#. type: TH
#: man-pages/man4/ram.4:26
#, no-wrap
msgid "RAM"
msgstr "RAM"

#. type: TH
#: man-pages/man4/ram.4:26
#, no-wrap
msgid "1992-11-21"
msgstr "1992-11-21"

#. type: Plain text
#: man-pages/man4/ram.4:29
msgid "ram - ram disk device"
msgstr "ram - устройство для диска в памяти"

#. type: Plain text
#: man-pages/man4/ram.4:33
msgid "The I<ram> device is a block device to access the ram disk in raw mode."
msgstr ""
"Устройство I<ram> представляет собой блочное устройство, предоставляющее "
"прямой доступ к диску в памяти (ram disk)."

#. type: Plain text
#: man-pages/man4/ram.4:35
msgid "It is typically created by:"
msgstr "Обычно, этот файл создается так:"

#. type: Plain text
#: man-pages/man4/ram.4:40
#, no-wrap
msgid ""
"mknod -m 660 /dev/ram b 1 1\n"
"chown root:disk /dev/ram\n"
msgstr ""
"mknod -m 660 /dev/ram b 1 1\n"
"chown root:disk /dev/ram\n"

#. type: Plain text
#: man-pages/man4/ram.4:44
msgid "I</dev/ram>"
msgstr "I</dev/ram>"

#. type: Plain text
#: man-pages/man4/ram.4:47
msgid "B<chown>(1), B<mknod>(1), B<mount>(8)"
msgstr "B<chown>(1), B<mknod>(1), B<mount>(8)"

#. type: TH
#: man-pages/man7/rtnetlink.7:15
#, no-wrap
msgid "RTNETLINK"
msgstr "RTNETLINK"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:18
msgid "rtnetlink - Linux IPv4 routing socket"
msgstr "rtnetlink - сокет маршрутизации IPv4 в Linux"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:20
msgid "B<#include E<lt>asm/types.hE<gt>>"
msgstr "B<#include E<lt>asm/types.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:22
msgid "B<#include E<lt>linux/netlink.hE<gt>>"
msgstr "B<#include E<lt>linux/netlink.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:24
msgid "B<#include E<lt>linux/rtnetlink.hE<gt>>"
msgstr "B<#include E<lt>linux/rtnetlink.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:26
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:28
msgid ""
"B<rtnetlink_socket = socket(AF_NETLINK, int >I<socket_type>B<, "
"NETLINK_ROUTE);>"
msgstr ""
"B<rtnetlink_socket = socket(AF_NETLINK, int >I<socket_type>B<, "
"NETLINK_ROUTE);>"

#.  FIXME . ? all these macros could be moved to rtnetlink(3)
#. type: Plain text
#: man-pages/man7/rtnetlink.7:42
msgid ""
"Rtnetlink allows the kernel's routing tables to be read and altered.  It is "
"used within the kernel to communicate between various subsystems, though "
"this usage is not documented here, and for communication with user-space "
"programs.  Network routes, IP addresses, link parameters, neighbor setups, "
"queueing disciplines, traffic classes and packet classifiers may all be "
"controlled through B<NETLINK_ROUTE> sockets.  It is based on netlink "
"messages; see B<netlink>(7)  for more information."
msgstr ""
"Rtnetlink позволяет читать и изменять таблицы маршрутизации ядра. Он "
"используется для взаимодействия различных подсистем внутри ядра (это здесь "
"не описано), а также для взаимодействия пользовательских программ. Сетевыми "
"маршрутами, IP-адресами, параметрами связи (link parameters), настройками "
"соседства (neighbor setups), алгоритмами планирования очереди (queueing "
"disciplines), классификацией трафика и  и пакетными классификаторами можно "
"управлять через сокеты B<NETLINK_ROUTE>. Они основываются на сообщениях "
"netlink; подробности смотрите в B<netlink>(7)."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:42 man-pages/man7/rtnetlink.7:96
#, no-wrap
msgid "Routing attributes"
msgstr "Атрибуты маршрутизации"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:44
msgid ""
"Some rtnetlink messages have optional attributes after the initial header:"
msgstr ""
"Некоторые сообщения rtnetlink содержат необязательные атрибуты после "
"начального заголовка:"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:52
#, no-wrap
msgid ""
"struct rtattr {\n"
"    unsigned short rta_len;    /* Length of option */\n"
"    unsigned short rta_type;   /* Type of option */\n"
"    /* Data follows */\n"
"};\n"
msgstr ""
"struct rtattr {\n"
"    unsigned short rta_len;    /* длина параметра */\n"
"    unsigned short rta_type;   /* тип параметра */\n"
"    /* данные … */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:58
msgid ""
"These attributes should be manipulated using only the RTA_* macros or "
"libnetlink, see B<rtnetlink>(3)."
msgstr ""
"Этими атрибутами нужно управлять только с помощью макросов RTA_* или "
"libnetlink, смотрите B<rtnetlink>(3)."

#. type: SS
#: man-pages/man7/rtnetlink.7:58
#, no-wrap
msgid "Messages"
msgstr "Сообщения"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:61
msgid ""
"Rtnetlink consists of these message types (in addition to standard netlink "
"messages):"
msgstr ""
"Rtnetlink поддерживает следующие типы сообщений (в дополнении к стандартным "
"сообщениям netlink):"

#. type: TP
#: man-pages/man7/rtnetlink.7:61
#, no-wrap
msgid "B<RTM_NEWLINK>, B<RTM_DELLINK>, B<RTM_GETLINK>"
msgstr "B<RTM_NEWLINK>, B<RTM_DELLINK>, B<RTM_GETLINK>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:69
msgid ""
"Create, remove or get information about a specific network interface.  These "
"messages contain an I<ifinfomsg> structure followed by a series of I<rtattr> "
"structures."
msgstr ""
"Создание, удаление и получение информации об определённом сетевом "
"интерфейсе. Эти сообщения содержат структуру I<ifinfomsg>, за которой "
"следует ряд структур I<rtattr>."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:78
#, no-wrap
msgid ""
"struct ifinfomsg {\n"
"    unsigned char  ifi_family; /* AF_UNSPEC */\n"
"    unsigned short ifi_type;   /* Device type */\n"
"    int            ifi_index;  /* Interface index */\n"
"    unsigned int   ifi_flags;  /* Device flags  */\n"
"    unsigned int   ifi_change; /* change mask */\n"
"};\n"
msgstr ""
"struct ifinfomsg {\n"
"    unsigned char  ifi_family; /* AF_UNSPEC */\n"
"    unsigned short ifi_type;   /* тип устройства */\n"
"    int            ifi_index;  /* индекс интерфейса */\n"
"    unsigned int   ifi_flags;  /* флаги устройства */\n"
"    unsigned int   ifi_change; /* маска изменения */\n"
"};\n"

#.  FIXME Document ifinfomsg.ifi_type
#. type: Plain text
#: man-pages/man7/rtnetlink.7:92
msgid ""
"I<ifi_flags> contains the device flags, see B<netdevice>(7); I<ifi_index> is "
"the unique interface index (since Linux 3.7, it is possible to feed a "
"nonzero value with the B<RTM_NEWLINK> message, thus creating a link with the "
"given I<ifindex>); I<ifi_change> is reserved for future use and should be "
"always set to 0xFFFFFFFF."
msgstr ""
"В I<ifi_flags> содержатся флаги устройства, смотрите B<netdevice>(7); в "
"I<ifi_index> — уникальный индекс интерфейса (начиная с Linux 3.7 возможно "
"передать ненулевое значение в сообщении B<RTM_NEWLINK>; в этом случае "
"создаётся связь (link) с заданным I<ifindex>); элемент I<ifi_change> "
"зарезервирован на будущее и его значение всегда должно быть равно 0xFFFFFFFF."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313 man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "rta_type"
msgstr "rta_type"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313 man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "value type"
msgstr "тип значения"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:97 man-pages/man7/rtnetlink.7:164
#: man-pages/man7/rtnetlink.7:313
#, no-wrap
msgid "description"
msgstr "описание"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:98 man-pages/man7/rtnetlink.7:165
#: man-pages/man7/rtnetlink.7:215 man-pages/man7/rtnetlink.7:239
#: man-pages/man7/rtnetlink.7:314 man-pages/man7/rtnetlink.7:432
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99
#, no-wrap
msgid "IFLA_UNSPEC"
msgstr "IFLA_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99 man-pages/man7/rtnetlink.7:166
#: man-pages/man7/rtnetlink.7:315 man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "-"
msgstr "-"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:99 man-pages/man7/rtnetlink.7:166
#, no-wrap
msgid "unspecified."
msgstr "не определено"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100
#, no-wrap
msgid "IFLA_ADDRESS"
msgstr "IFLA_ADDRESS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100 man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "hardware address"
msgstr "аппаратный адрес"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:100
#, no-wrap
msgid "interface L2 address"
msgstr "адрес интерфейса L2"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "IFLA_BROADCAST"
msgstr "IFLA_BROADCAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:101
#, no-wrap
msgid "L2 broadcast address."
msgstr "широковещательный адрес L2"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102
#, no-wrap
msgid "IFLA_IFNAME"
msgstr "IFLA_IFNAME"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102 man-pages/man7/rtnetlink.7:105
#: man-pages/man7/rtnetlink.7:169 man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "asciiz string"
msgstr "строка asciiz"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:102
#, no-wrap
msgid "Device name."
msgstr "имя устройства"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "IFLA_MTU"
msgstr "IFLA_MTU"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "unsigned int"
msgstr "unsigned int"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:103
#, no-wrap
msgid "MTU of the device."
msgstr "MTU устройства"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104
#, no-wrap
msgid "IFLA_LINK"
msgstr "IFLA_LINK"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104 man-pages/man7/rtnetlink.7:318
#: man-pages/man7/rtnetlink.7:319 man-pages/man7/rtnetlink.7:321
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "int"
msgstr "int"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:104
#, no-wrap
msgid "Link type."
msgstr "тип связи"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:105
#, no-wrap
msgid "IFLA_QDISC"
msgstr "IFLA_QDISC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:105
#, no-wrap
msgid "Queueing discipline."
msgstr "алгоритм очереди"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:106
#, no-wrap
msgid "IFLA_STATS"
msgstr "IFLA_STATS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:108
#, no-wrap
msgid "see below"
msgstr "смотрите ниже"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:108
#, no-wrap
msgid "Interface Statistics."
msgstr "статистика интерфейса"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:117
msgid ""
"The value type for B<IFLA_STATS> is I<struct rtnl_link_stats> (I<struct "
"net_device_stats> in Linux 2.4 and earlier)."
msgstr ""
"Тип значения для B<IFLA_STATS> — I<struct rtnl_link_stats> (в Linux 2.4 и "
"старее — I<struct net_device_stats>)."

#. type: TP
#: man-pages/man7/rtnetlink.7:117
#, no-wrap
msgid "B<RTM_NEWADDR>, B<RTM_DELADDR>, B<RTM_GETADDR>"
msgstr "B<RTM_NEWADDR>, B<RTM_DELADDR>, B<RTM_GETADDR>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:130
msgid ""
"Add, remove or receive information about an IP address associated with an "
"interface.  In Linux 2.2, an interface can carry multiple IP addresses, this "
"replaces the alias device concept in 2.0.  In Linux 2.2, these messages "
"support IPv4 and IPv6 addresses.  They contain an I<ifaddrmsg> structure, "
"optionally followed by I<rtattr> routing attributes."
msgstr ""
"Добавление, удаление или получение информации об IP-адресе, назначенном "
"интерфейсу. В Linux 2.2 интерфейс может иметь несколько IP-адресов; эта "
"концепция пришла на смену псевдонимам устройства, использовавшимся в версии "
"2.0. В Linux 2.2 эти сообщения поддерживают адреса IPv4 и IPv6. В них "
"содержится структура I<ifaddrmsg>, которая может быть указана после "
"атрибутов маршрутизации I<rtattr>."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:139
#, no-wrap
msgid ""
"struct ifaddrmsg {\n"
"    unsigned char ifa_family;    /* Address type */\n"
"    unsigned char ifa_prefixlen; /* Prefixlength of address */\n"
"    unsigned char ifa_flags;     /* Address flags */\n"
"    unsigned char ifa_scope;     /* Address scope */\n"
"    int           ifa_index;     /* Interface index */\n"
"};\n"
msgstr ""
"struct ifaddrmsg {\n"
"    unsigned char ifa_family;    /* тип адреса */\n"
"    unsigned char ifa_prefixlen; /* длина префикса адреса */\n"
"    unsigned char ifa_flags;     /* флаги адреса */\n"
"    unsigned char ifa_scope;     /* область адреса */\n"
"    int           ifa_index;     /* индекс интерфейса */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:159
msgid ""
"I<ifa_family> is the address family type (currently B<AF_INET> or "
"B<AF_INET6>), I<ifa_prefixlen> is the length of the address mask of the "
"address if defined for the family (like for IPv4), I<ifa_scope> is the "
"address scope, I<ifa_index> is the interface index of the interface the "
"address is associated with.  I<ifa_flags> is a flag word of "
"B<IFA_F_SECONDARY> for secondary address (old alias interface), "
"B<IFA_F_PERMANENT> for a permanent address set by the user and other "
"undocumented flags."
msgstr ""
"Поле I<ifa_family> представляет тип адресного семейства (B<AF_INET> или "
"B<AF_INET6>), I<ifa_prefixlen> — длину адресной маски адреса, если это "
"применимо для семейства (в IPv4), I<ifa_scope> — область адреса, "
"I<ifa_index> — индекс интерфейса, которому назначен адрес. Поле I<ifa_flags> "
"— слово флагов: B<IFA_F_SECONDARY> — вторичный адрес (старый псевдоним "
"интерфейса), B<IFA_F_PERMANENT> — постоянный адрес, назначенный "
"пользователем и другие недокументированные флаги."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:163 man-pages/man7/rtnetlink.7:312
#: man-pages/man7/rtnetlink.7:430
#, no-wrap
msgid "Attributes"
msgstr "Атрибуты"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:166
#, no-wrap
msgid "IFA_UNSPEC"
msgstr "IFA_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167
#, no-wrap
msgid "IFA_ADDRESS"
msgstr "IFA_ADDRESS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167 man-pages/man7/rtnetlink.7:168
#: man-pages/man7/rtnetlink.7:170 man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "raw protocol address"
msgstr "адрес неструктурированного протокола"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:167
#, no-wrap
msgid "interface address"
msgstr "адрес интерфейса"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:168
#, no-wrap
msgid "IFA_LOCAL"
msgstr "IFA_LOCAL"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:168
#, no-wrap
msgid "local address"
msgstr "локальный адрес"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:169
#, no-wrap
msgid "IFA_LABEL"
msgstr "IFA_LABEL"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:169
#, no-wrap
msgid "name of the interface"
msgstr "название интерфейса"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:170
#, no-wrap
msgid "IFA_BROADCAST"
msgstr "IFA_BROADCAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:170
#, no-wrap
msgid "broadcast address."
msgstr "широковещательный адрес"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "IFA_ANYCAST"
msgstr "IFA_ANYCAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:171
#, no-wrap
msgid "anycast address"
msgstr "адрес anycast"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "IFA_CACHEINFO"
msgstr "IFA_CACHEINFO"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "struct ifa_cacheinfo"
msgstr "struct ifa_cacheinfo"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:172
#, no-wrap
msgid "Address information."
msgstr "информация об адресе"

#. type: TP
#: man-pages/man7/rtnetlink.7:175
#, no-wrap
msgid "B<RTM_NEWROUTE>, B<RTM_DELROUTE>, B<RTM_GETROUTE>"
msgstr "B<RTM_NEWROUTE>, B<RTM_DELROUTE>, B<RTM_GETROUTE>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:195
msgid ""
"Create, remove or receive information about a network route.  These messages "
"contain an I<rtmsg> structure with an optional sequence of I<rtattr> "
"structures following.  For B<RTM_GETROUTE>, setting I<rtm_dst_len> and "
"I<rtm_src_len> to 0 means you get all entries for the specified routing "
"table.  For the other fields, except I<rtm_table> and I<rtm_protocol>, 0 is "
"the wildcard."
msgstr ""
"Создание, удаление или получение информации о сетевом маршруте. Эти "
"сообщения содержат структуру I<rtmsg> с необязательными дополнительными "
"структурами I<rtattr>. Для B<RTM_GETROUTE>, если I<rtm_dst_len> и "
"I<rtm_src_len> задать значение 0, то вы получите все записи определённой "
"таблицы маршрутизации. В других полях, кроме I<rtm_table> и I<rtm_protocol>, "
"0 считается шаблоном (wildcard)."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:202
#, no-wrap
msgid ""
"struct rtmsg {\n"
"    unsigned char rtm_family;   /* Address family of route */\n"
"    unsigned char rtm_dst_len;  /* Length of destination */\n"
"    unsigned char rtm_src_len;  /* Length of source */\n"
"    unsigned char rtm_tos;      /* TOS filter */\n"
msgstr ""
"struct rtmsg {\n"
"    unsigned char rtm_family;   /* адресное семейство маршрута */\n"
"    unsigned char rtm_dst_len;  /* длина назначения */\n"
"    unsigned char rtm_src_len;  /* длина источника */\n"
"    unsigned char rtm_tos;      /* фильтр TOS */\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:207
#, no-wrap
msgid ""
"    unsigned char rtm_table;    /* Routing table ID */\n"
"    unsigned char rtm_protocol; /* Routing protocol; see below */\n"
"    unsigned char rtm_scope;    /* See below */\n"
"    unsigned char rtm_type;     /* See below */\n"
msgstr ""
"    unsigned char rtm_table;    /* ID таблицы маршрутизации */\n"
"    unsigned char rtm_protocol; /* протокол марш-ции; см. ниже */\n"
"    unsigned char rtm_scope;    /* см. ниже */\n"
"    unsigned char rtm_type;     /* см. ниже */\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:210
#, no-wrap
msgid ""
"    unsigned int  rtm_flags;\n"
"};\n"
msgstr ""
"    unsigned int  rtm_flags;\n"
"};\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:214
#, no-wrap
msgid "rtm_type"
msgstr "rtm_type"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:214
#, no-wrap
msgid "Route type"
msgstr "Тип маршрута"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:216
#, no-wrap
msgid "RTN_UNSPEC"
msgstr "RTN_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:216
#, no-wrap
msgid "unknown route"
msgstr "неизвестный маршрут"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:217
#, no-wrap
msgid "RTN_UNICAST"
msgstr "RTN_UNICAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:217
#, no-wrap
msgid "a gateway or direct route"
msgstr "шлюз или прямой маршрут"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:218
#, no-wrap
msgid "RTN_LOCAL"
msgstr "RTN_LOCAL"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:218
#, no-wrap
msgid "a local interface route"
msgstr "маршрут локального интерфейса"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:219
#, no-wrap
msgid "RTN_BROADCAST"
msgstr "RTN_BROADCAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:221
#, no-wrap
msgid "a local broadcast route (sent as a broadcast)"
msgstr "локальный широковещательный маршрут (широковещательная отправка)"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:222
#, no-wrap
msgid "RTN_ANYCAST"
msgstr "RTN_ANYCAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:224
#, no-wrap
msgid "a local broadcast route (sent as a unicast)"
msgstr "локальный широковещательный маршрут (однонаправленная отправка)"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:225
#, no-wrap
msgid "RTN_MULTICAST"
msgstr "RTN_MULTICAST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:225
#, no-wrap
msgid "a multicast route"
msgstr "многоадресный маршрут"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:226
#, no-wrap
msgid "RTN_BLACKHOLE"
msgstr "RTN_BLACKHOLE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:226
#, no-wrap
msgid "a packet dropping route"
msgstr "маршрут для отброса пакетов"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:227
#, no-wrap
msgid "RTN_UNREACHABLE"
msgstr "RTN_UNREACHABLE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:227
#, no-wrap
msgid "an unreachable destination"
msgstr "недостижимый пункт назначения"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:228
#, no-wrap
msgid "RTN_PROHIBIT"
msgstr "RTN_PROHIBIT"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:228
#, no-wrap
msgid "a packet rejection route"
msgstr "маршрут для отклонения пакетов"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:229
#, no-wrap
msgid "RTN_THROW"
msgstr "RTN_THROW"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:229
#, no-wrap
msgid "continue routing lookup in another table"
msgstr "продолжение поиска маршрута в другой таблице"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:230
#, no-wrap
msgid "RTN_NAT"
msgstr "RTN_NAT"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:230
#, no-wrap
msgid "a network address translation rule"
msgstr "правило трансляции сетевого адреса"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:231
#, no-wrap
msgid "RTN_XRESOLVE"
msgstr "RTN_XRESOLVE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:233
#, no-wrap
msgid "refer to an external resolver (not implemented)"
msgstr "ссылка на внешний определитель (не реализовано)"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:238
#, no-wrap
msgid "rtm_protocol"
msgstr " "

#. type: tbl table
#: man-pages/man7/rtnetlink.7:238
#, no-wrap
msgid "Route origin."
msgstr "Происхождение маршрута"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:240
#, no-wrap
msgid "RTPROT_UNSPEC"
msgstr "RTPROT_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:240
#, no-wrap
msgid "unknown"
msgstr "неизвестно"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:241
#, no-wrap
msgid "RTPROT_REDIRECT"
msgstr "RTPROT_REDIRECT"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:243
#, no-wrap
msgid "by an ICMP redirect (currently unused)"
msgstr "из-за перенаправления полученном по ICMP (не используется)"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:244
#, no-wrap
msgid "RTPROT_KERNEL"
msgstr "RTPROT_KERNEL"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:244
#, no-wrap
msgid "by the kernel"
msgstr "посылается ядром"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:245
#, no-wrap
msgid "RTPROT_BOOT"
msgstr "RTPROT_BOOT"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:245
#, no-wrap
msgid "during boot"
msgstr "при загрузке машины"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:246
#, no-wrap
msgid "RTPROT_STATIC"
msgstr "RTPROT_STATIC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:246
#, no-wrap
msgid "by the administrator"
msgstr "указан администратором"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:257
msgid ""
"Values larger than B<RTPROT_STATIC> are not interpreted by the kernel, they "
"are just for user information.  They may be used to tag the source of a "
"routing information or to distinguish between multiple routing daemons.  See "
"I<E<lt>linux/rtnetlink.hE<gt>> for the routing daemon identifiers which are "
"already assigned."
msgstr ""
"Значения больше B<RTPROT_STATIC> не учитываются ядром, они предназначены "
"только для пользовательской информации. Они могут использоваться для пометки "
"источника информации о маршрутизации или для отличения различных служб "
"маршрутизации друг от друга. Уже назначенные идентификаторы для служб "
"маршрутизации можно найти в I<E<lt>linux/rtnetlink.hE<gt>>."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:260
msgid "I<rtm_scope> is the distance to the destination:"
msgstr "I<rtm_scope> — расстояние до назначения:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:263
#, no-wrap
msgid "RT_SCOPE_UNIVERSE"
msgstr "RT_SCOPE_UNIVERSE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:263
#, no-wrap
msgid "global route"
msgstr "глобальный маршрут"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:264
#, no-wrap
msgid "RT_SCOPE_SITE"
msgstr "RT_SCOPE_SITE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:266
#, no-wrap
msgid "interior route in the local autonomous system"
msgstr "внутренний маршрут в локальной автономной системе"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:267
#, no-wrap
msgid "RT_SCOPE_LINK"
msgstr "RT_SCOPE_LINK"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:267
#, no-wrap
msgid "route on this link"
msgstr "маршрут на эту связь"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:268
#, no-wrap
msgid "RT_SCOPE_HOST"
msgstr "RT_SCOPE_HOST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:268
#, no-wrap
msgid "route on the local host"
msgstr "маршрут на локальный узел"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:269
#, no-wrap
msgid "RT_SCOPE_NOWHERE"
msgstr "RT_SCOPE_NOWHERE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:269
#, no-wrap
msgid "destination doesn't exist"
msgstr "назначение не существует"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:277
msgid ""
"The values between B<RT_SCOPE_UNIVERSE> and B<RT_SCOPE_SITE> are available "
"to the user."
msgstr ""
"Значения от B<RT_SCOPE_UNIVERSE> и до B<RT_SCOPE_SITE> доступны пользователю."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:281
msgid "The I<rtm_flags> have the following meanings:"
msgstr "Поле I<rtm_flags> может иметь следующие значения:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:284
#, no-wrap
msgid "RTM_F_NOTIFY"
msgstr "RTM_F_NOTIFY"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:286
#, no-wrap
msgid "if the route changes, notify the user via rtnetlink"
msgstr "если маршрут изменился — уведомить пользователя через rtnetlink"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:287
#, no-wrap
msgid "RTM_F_CLONED"
msgstr "RTM_F_CLONED"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:287
#, no-wrap
msgid "route is cloned from another route"
msgstr "маршрут склонирован из другого маршрута"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:288
#, no-wrap
msgid "RTM_F_EQUALIZE"
msgstr "RTM_F_EQUALIZE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:288
#, no-wrap
msgid "a multipath equalizer (not yet implemented)"
msgstr "многопутевой уравниватель (не реализовано)"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:293
msgid "I<rtm_table> specifies the routing table"
msgstr "В I<rtm_table> задаётся таблица маршрутизации:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:296
#, no-wrap
msgid "RT_TABLE_UNSPEC"
msgstr "RT_TABLE_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:296
#, no-wrap
msgid "an unspecified routing table"
msgstr "таблица маршрутизации не задана"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:297
#, no-wrap
msgid "RT_TABLE_DEFAULT"
msgstr "RT_TABLE_DEFAULT"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:297
#, no-wrap
msgid "the default table"
msgstr "таблица по умолчанию"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:298
#, no-wrap
msgid "RT_TABLE_MAIN"
msgstr "RT_TABLE_MAIN"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:298
#, no-wrap
msgid "the main table"
msgstr "главная таблица"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:299
#, no-wrap
msgid "RT_TABLE_LOCAL"
msgstr "RT_TABLE_LOCAL"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:299
#, no-wrap
msgid "the local table"
msgstr "локальная таблица"

#.  Keep table on same page
#. type: Plain text
#: man-pages/man7/rtnetlink.7:307
msgid ""
"The user may assign arbitrary values between B<RT_TABLE_UNSPEC> and "
"B<RT_TABLE_DEFAULT>."
msgstr ""
"Пользователь может назначать произвольные значения от B<RT_TABLE_UNSPEC> и "
"до B<RT_TABLE_DEFAULT>."

#. type: tbl table
#: man-pages/man7/rtnetlink.7:315
#, no-wrap
msgid "RTA_UNSPEC"
msgstr "RTA_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:315
#, no-wrap
msgid "ignored."
msgstr "игнорируется"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316
#, no-wrap
msgid "RTA_DST"
msgstr "RTA_DST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316 man-pages/man7/rtnetlink.7:317
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "protocol address"
msgstr "адрес протокола"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:316
#, no-wrap
msgid "Route destination address."
msgstr "адрес маршрута назначения"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:317
#, no-wrap
msgid "RTA_SRC"
msgstr "RTA_SRC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:317
#, no-wrap
msgid "Route source address."
msgstr "адрес маршрута источника"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:318
#, no-wrap
msgid "RTA_IIF"
msgstr "RTA_IIF"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:318
#, no-wrap
msgid "Input interface index."
msgstr "индекс входного интерфейса"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:319
#, no-wrap
msgid "RTA_OIF"
msgstr "RTA_OIF"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:319
#, no-wrap
msgid "Output interface index."
msgstr "индекс выходного интерфейса"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "RTA_GATEWAY"
msgstr "RTA_GATEWAY"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:320
#, no-wrap
msgid "The gateway of the route"
msgstr "шлюз маршрута"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:321
#, no-wrap
msgid "RTA_PRIORITY"
msgstr "RTA_PRIORITY"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:321
#, no-wrap
msgid "Priority of route."
msgstr "приоритет маршрута"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:322
#, no-wrap
msgid "RTA_PREFSRC"
msgstr "RTA_PREFSRC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "RTA_METRICS"
msgstr "RTA_METRICS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:323
#, no-wrap
msgid "Route metric"
msgstr "метрика маршрута"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:324
#, no-wrap
msgid "RTA_MULTIPATH"
msgstr "RTA_MULTIPATH"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:325
#, no-wrap
msgid "RTA_PROTOINFO"
msgstr "RTA_PROTOINFO"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:326
#, no-wrap
msgid "RTA_FLOW"
msgstr "RTA_FLOW"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:327
#, no-wrap
msgid "RTA_CACHEINFO"
msgstr "RTA_CACHEINFO"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:331
msgid "B<Fill these values in!>"
msgstr "B<Заполнить эти значения!>"

#. type: TP
#: man-pages/man7/rtnetlink.7:331
#, no-wrap
msgid "B<RTM_NEWNEIGH>, B<RTM_DELNEIGH>, B<RTM_GETNEIGH>"
msgstr "B<RTM_NEWNEIGH>, B<RTM_DELNEIGH>, B<RTM_GETNEIGH>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:338
msgid ""
"Add, remove or receive information about a neighbor table entry (e.g., an "
"ARP entry).  The message contains an I<ndmsg> structure."
msgstr ""
"Добавление, удаление или получение информации о записи соседей по таблице "
"(например, запись ARP). В сообщении содержится структура I<ndmsg>:"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:347
#, no-wrap
msgid ""
"struct ndmsg {\n"
"    unsigned char ndm_family;\n"
"    int           ndm_ifindex;  /* Interface index */\n"
"    __u16         ndm_state;    /* State */\n"
"    __u8          ndm_flags;    /* Flags */\n"
"    __u8          ndm_type;\n"
"};\n"
msgstr ""
"struct ndmsg {\n"
"    unsigned char ndm_family;\n"
"    int           ndm_ifindex;  /* индекс интерфейса */\n"
"    __u16         ndm_state;    /* состояние */\n"
"    __u8          ndm_flags;    /* флаги */\n"
"    __u8          ndm_type;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:354
#, no-wrap
msgid ""
"struct nda_cacheinfo {\n"
"    __u32         ndm_confirmed;\n"
"    __u32         ndm_used;\n"
"    __u32         ndm_updated;\n"
"    __u32         ndm_refcnt;\n"
"};\n"
msgstr ""
"struct nda_cacheinfo {\n"
"    __u32         ndm_confirmed;\n"
"    __u32         ndm_used;\n"
"    __u32         ndm_updated;\n"
"    __u32         ndm_refcnt;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:358
msgid "I<ndm_state> is a bit mask of the following states:"
msgstr "В I<ndm_state> содержится битовая маска следующих состояний:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:361
#, no-wrap
msgid "NUD_INCOMPLETE"
msgstr "NUD_INCOMPLETE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:361
#, no-wrap
msgid "a currently resolving cache entry"
msgstr "запись кэша в данный момент определяется"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:362
#, no-wrap
msgid "NUD_REACHABLE"
msgstr "NUD_REACHABLE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:362
#, no-wrap
msgid "a confirmed working cache entry"
msgstr "подтверждённая рабочая запись кэша"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:363
#, no-wrap
msgid "NUD_STALE"
msgstr "NUD_STALE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:363
#, no-wrap
msgid "an expired cache entry"
msgstr "устаревшая запись кэша"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:364
#, no-wrap
msgid "NUD_DELAY"
msgstr "NUD_DELAY"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:364
#, no-wrap
msgid "an entry waiting for a timer"
msgstr "запись ожидает срабатывания таймера"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:365
#, no-wrap
msgid "NUD_PROBE"
msgstr "NUD_PROBE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:365
#, no-wrap
msgid "a cache entry that is currently reprobed"
msgstr "запись кэша в данный момент проверяется повторно"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:366
#, no-wrap
msgid "NUD_FAILED"
msgstr "NUD_FAILED"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:366
#, no-wrap
msgid "an invalid cache entry"
msgstr "некорректная запись кэша"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:367
#, no-wrap
msgid "NUD_NOARP"
msgstr "NUD_NOARP"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:367
#, no-wrap
msgid "a device with no destination cache"
msgstr "устройство без кэша назначений"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:368
#, no-wrap
msgid "NUD_PERMANENT"
msgstr "NUD_PERMANENT"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:368
#, no-wrap
msgid "a static entry"
msgstr "статическая запись"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:374
msgid "Valid I<ndm_flags> are:"
msgstr "Допустимые значения I<ndm_flags>:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:377
#, no-wrap
msgid "NTF_PROXY"
msgstr "NTF_PROXY"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:377
#, no-wrap
msgid "a proxy arp entry"
msgstr "запись прокси arp"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:378
#, no-wrap
msgid "NTF_ROUTER"
msgstr "NTF_ROUTER"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:378
#, no-wrap
msgid "an IPv6 router"
msgstr "маршрутизатор IPv6"

#.  FIXME .
#.  document the members of the struct better
#. type: Plain text
#: man-pages/man7/rtnetlink.7:388
msgid ""
"The I<rtattr> struct has the following meanings for the I<rta_type> field:"
msgstr "Структура I<rtattr> имеет следующие значения для поля I<rta_type>:"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:391
#, no-wrap
msgid "NDA_UNSPEC"
msgstr "NDA_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:391
#, no-wrap
msgid "unknown type"
msgstr "неизвестный тип"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:392
#, no-wrap
msgid "NDA_DST"
msgstr "NDA_DST"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:392
#, no-wrap
msgid "a neighbor cache n/w layer destination address"
msgstr "кэш адресов назначения соседей на сетевом уровне"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:393
#, no-wrap
msgid "NDA_LLADDR"
msgstr "NDA_LLADDR"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:393
#, no-wrap
msgid "a neighbor cache link layer address"
msgstr "кэш адресов соседей на уровне связей"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:394
#, no-wrap
msgid "NDA_CACHEINFO"
msgstr "NDA_CACHEINFO"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:394
#, no-wrap
msgid "cache statistics."
msgstr "статистика кэша"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:404
msgid ""
"If the I<rta_type> field is B<NDA_CACHEINFO>, then a I<struct nda_cacheinfo> "
"header follows"
msgstr ""
"Если значение поля I<rta_type> равно B<NDA_CACHEINFO>, то присутствует "
"заголовок I<struct nda_cacheinfo>."

#. type: TP
#: man-pages/man7/rtnetlink.7:404
#, no-wrap
msgid "B<RTM_NEWRULE>, B<RTM_DELRULE>, B<RTM_GETRULE>"
msgstr "B<RTM_NEWRULE>, B<RTM_DELRULE>, B<RTM_GETRULE>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:409
msgid "Add, delete or retrieve a routing rule.  Carries a I<struct rtmsg>"
msgstr ""
"Добавление, удаление или получение правила маршрутизации. Содержит I<struct "
"rtmsg>."

#. type: TP
#: man-pages/man7/rtnetlink.7:409
#, no-wrap
msgid "B<RTM_NEWQDISC>, B<RTM_DELQDISC>, B<RTM_GETQDISC>"
msgstr "B<RTM_NEWQDISC>, B<RTM_DELQDISC>, B<RTM_GETQDISC>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:416
msgid ""
"Add, remove or get a queueing discipline.  The message contains a I<struct "
"tcmsg> and may be followed by a series of attributes."
msgstr ""
"Добавление, удаление или получение планирования очереди. В сообщении "
"содержится I<struct tcmsg>, а также может быть серия атрибутов."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:425
#, no-wrap
msgid ""
"struct tcmsg {\n"
"    unsigned char    tcm_family;\n"
"    int              tcm_ifindex;   /* interface index */\n"
"    __u32            tcm_handle;    /* Qdisc handle */\n"
"    __u32            tcm_parent;    /* Parent qdisc */\n"
"    __u32            tcm_info;\n"
"};\n"
msgstr ""
"struct tcmsg {\n"
"    unsigned char    tcm_family;\n"
"    int              tcm_ifindex;   /* индекс интерфейса */\n"
"    __u32            tcm_handle;    /* описатель qdisc */\n"
"    __u32            tcm_parent;    /* предок qdisc */\n"
"    __u32            tcm_info;\n"
"};\n"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:431
#, no-wrap
msgid "Description"
msgstr "Описание"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "TCA_UNSPEC"
msgstr "TCA_UNSPEC"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:433
#, no-wrap
msgid "unspecified"
msgstr "не определено"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "TCA_KIND"
msgstr "TCA_KIND"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:434
#, no-wrap
msgid "Name of queueing discipline"
msgstr "имя план-ания очереди"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "TCA_OPTIONS"
msgstr "TCA_OPTIONS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "byte sequence"
msgstr "байтовая последовательность"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:435
#, no-wrap
msgid "Qdisc-specific options follow"
msgstr "есть параметры qdisc"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "TCA_STATS"
msgstr "TCA_STATS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "struct tc_stats"
msgstr "struct tc_stats"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:436
#, no-wrap
msgid "Qdisc statistics."
msgstr "статистика qdisc"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "TCA_XSTATS"
msgstr "TCA_XSTATS"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "qdisc-specific"
msgstr "относится к qdisc"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:437
#, no-wrap
msgid "Module-specific statistics."
msgstr "стат-ка по опр. модулю"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "TCA_RATE"
msgstr "TCA_RATE"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "struct tc_estimator"
msgstr "struct tc_estimator"

#. type: tbl table
#: man-pages/man7/rtnetlink.7:438
#, no-wrap
msgid "Rate limit."
msgstr "ограничение по скорости"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:443
msgid ""
"In addition, various other qdisc-module-specific attributes are allowed.  "
"For more information see the appropriate include files."
msgstr ""
"Также, разрешены дополнительные атрибуты модуля qdisc. Дополнительную "
"информацию можно получить из соответствующих заголовочных файлов."

#. type: TP
#: man-pages/man7/rtnetlink.7:443
#, no-wrap
msgid "B<RTM_NEWTCLASS>, B<RTM_DELTCLASS>, B<RTM_GETTCLASS>"
msgstr "B<RTM_NEWTCLASS>, B<RTM_DELTCLASS>, B<RTM_GETTCLASS>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:449
msgid ""
"Add, remove or get a traffic class.  These messages contain a I<struct "
"tcmsg> as described above."
msgstr ""
"Добавление, удаление или получение класса трафика. В этих сообщениях "
"содержится структура I<struct tcmsg>, описанная ранее."

#. type: TP
#: man-pages/man7/rtnetlink.7:449
#, no-wrap
msgid "B<RTM_NEWTFILTER>, B<RTM_DELTFILTER>, B<RTM_GETTFILTER>"
msgstr "B<RTM_NEWTFILTER>, B<RTM_DELTFILTER>, B<RTM_GETTFILTER>"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:455
msgid ""
"Add, remove or receive information about a traffic filter.  These messages "
"contain a I<struct tcmsg> as described above."
msgstr ""
"Добавление, удаление или получение информации о фильтре трафика. В этих "
"сообщениях содержится структура I<struct tcmsg>, описанная ранее."

#. type: SH
#: man-pages/man7/rtnetlink.7:455
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/rtnetlink.7:458
msgid "B<rtnetlink> is a new feature of Linux 2.2."
msgstr "Свойство B<rtnetlink> появилось в Linux 2.2."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:460
msgid "This manual page is incomplete."
msgstr "Данная справочная страница не полна."

#. type: Plain text
#: man-pages/man7/rtnetlink.7:464
msgid "B<cmsg>(3), B<rtnetlink>(3), B<ip>(7), B<netlink>(7)"
msgstr "B<cmsg>(3), B<rtnetlink>(3), B<ip>(7), B<netlink>(7)"

#. type: TH
#: man-pages/man7/regex.7:37
#, no-wrap
msgid "REGEX"
msgstr "REGEX"

#. type: TH
#: man-pages/man7/regex.7:37
#, no-wrap
msgid "2009-01-12"
msgstr "2009-01-12"

#. type: Plain text
#: man-pages/man7/regex.7:40
msgid "regex - POSIX.2 regular expressions"
msgstr "regex - регулярные выражения POSIX.2"

#. type: Plain text
#: man-pages/man7/regex.7:54
msgid ""
"Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forms: "
"modern REs (roughly those of I<egrep>; POSIX.2 calls these \"extended\" "
"REs)  and obsolete REs (roughly those of B<ed>(1); POSIX.2 \"basic\" REs).  "
"Obsolete REs mostly exist for backward compatibility in some old programs; "
"they will be discussed at the end.  POSIX.2 leaves some aspects of RE syntax "
"and semantics open; \"\\*(dg\" marks decisions on these aspects that may not "
"be fully portable to other POSIX.2 implementations."
msgstr ""
"Регулярные выражения (РВ) стандарта POSIX.2 могут быть двух видов: новые РВ "
"(по сути, использующиеся в I<egrep>; в POSIX.2 их называют ещё "
"«расширенными» РВ) и устаревшие РВ (по сути, использующиеся в B<ed>(1); в "
"POSIX.2 их называют ещё «основными» РВ). Устаревшие РВ существуют, в "
"основном, для совместимости с некоторыми старыми программами (они будут "
"подробнее рассмотрены в конце этого документа). В POSIX.2 не разъяснены "
"некоторые вопросы синтаксиса РВ; знаком \\*(dg отмечаются описания, которые "
"могут быть не полностью совместимы с другими реализациями POSIX.2."

#. type: Plain text
#: man-pages/man7/regex.7:58
msgid ""
"A (modern) RE is one\\*(dg or more nonempty\\*(dg I<branches>, separated by "
"\\(aq|\\(aq.  It matches anything that matches one of the branches."
msgstr ""
"Новое РВ — одна\\*(dg или более непустых\\*(dg I<ветвей>, разделённых \\(aq|"
"\\(aq. Соответствием считается, если есть совпадение для любой из её ветвей."

#. type: Plain text
#: man-pages/man7/regex.7:62
msgid ""
"A branch is one\\*(dg or more I<pieces>, concatenated.  It matches a match "
"for the first, followed by a match for the second, and so on."
msgstr ""
"Ветвь состоит из одной\\*(dg или более I<частей>. Ветвь сначала ведёт поиск "
"соответствий с первой, затем с второй (и т. п.) её частями."

#. type: Plain text
#: man-pages/man7/regex.7:71
msgid ""
"A piece is an I<atom> possibly followed by a single\\*(dg \\(aq*\\(aq, \\(aq+"
"\\(aq, \\(aq?\\(aq, or I<bound>.  An atom followed by \\(aq*\\(aq matches a "
"sequence of 0 or more matches of the atom.  An atom followed by \\(aq+\\(aq "
"matches a sequence of 1 or more matches of the atom.  An atom followed by "
"\\(aq?\\(aq matches a sequence of 0 or 1 matches of the atom."
msgstr ""
"Часть — это I<атом>, за которым может следовать одиночный\\*(dg символ \\(aq*"
"\\(aq, \\(aq+\\(aq, \\(aq?\\(aq или I<интервал>. Если за атомом следует "
"символ \\(aq*\\(aq, это означает, что совпадающая с атомом "
"последовательность может встречаться 0 или более раз. Если за атомом следует "
"символ \\(aq+\\(aq, это означает, что совпадающая с атомом "
"последовательность может встречаться 1 или более раз. Если за атомом следует "
"символ \\(aq?\\(aq, это означает, что совпадающая с атомом "
"последовательность может встречаться 0 или 1 раз."

#. type: Plain text
#: man-pages/man7/regex.7:89
msgid ""
"A I<bound> is \\(aq{\\(aq followed by an unsigned decimal integer, possibly "
"followed by \\(aq,\\(aq possibly followed by another unsigned decimal "
"integer, always followed by \\(aq}\\(aq.  The integers must lie between 0 "
"and B<RE_DUP_MAX> (255\\*(dg) inclusive, and if there are two of them, the "
"first may not exceed the second.  An atom followed by a bound containing one "
"integer I<i> and no comma matches a sequence of exactly I<i> matches of the "
"atom.  An atom followed by a bound containing one integer I<i> and a comma "
"matches a sequence of I<i> or more matches of the atom.  An atom followed by "
"a bound containing two integers I<i> and I<j> matches a sequence of I<i> "
"through I<j> (inclusive) matches of the atom."
msgstr ""
"I<Интервал> — это символ \\(aq{\\(aq, после которого стоит беззнаковое целое "
"десятичное число, за которым может следовать символ \\(aq,\\(aq, далее, "
"возможно, находится ещё одно беззнаковое целое десятичное число, и в конце "
"интервала обязательно стоит символ \\(aq}\\(aq. Числа должны находиться в "
"промежутке от 0 до B<RE_DUP_MAX> (255\\*(dg) включительно, а если указано "
"два числа, то первое не должно превышать второе. Атом с интервалом, в "
"котором есть одно число I<i> и нет запятой, соответствует "
"последовательности, повторяющейся точно I<i> раз. Атом с интервалом, "
"содержащим число I<i> и запятую, соответствует последовательности, "
"повторяющейся I<i> и более раз. Атом с интервалом, содержащим два числа I<i> "
"и I<j>, соответствует последовательности, повторяющейся от I<i> до I<j> раз "
"включительно."

#. type: Plain text
#: man-pages/man7/regex.7:106
msgid ""
"An atom is a regular expression enclosed in \"I<()>\" (matching a match for "
"the regular expression), an empty set of \"I<()>\" (matching the null "
"string)\\*(dg, a I<bracket expression> (see below), \\(aq.\\(aq (matching "
"any single character), \\(aq^\\(aq (matching the null string at the "
"beginning of a line), \\(aq$\\(aq (matching the null string at the end of a "
"line), a \\(aq\\e\\(aq followed by one of the characters \"I<^.[$()|*+?{\\e>"
"\" (matching that character taken as an ordinary character), a \\(aq\\e\\(aq "
"followed by any other character\\*(dg (matching that character taken as an "
"ordinary character, as if the \\(aq\\e\\(aq had not been present\\*(dg), or "
"a single character with no other significance (matching that character).  A "
"\\(aq{\\(aq followed by a character other than a digit is an ordinary "
"character, not the beginning of a bound\\*(dg.  It is illegal to end an RE "
"with \\(aq\\e\\(aq."
msgstr ""
"Атом — это регулярное выражение, заключённое в «I<()>» (соответствующее "
"регулярному выражению), пустые скобки «I<()>» (соответствуют строке "
"null)\\*(dg, I<выражение в квадратных скобках> (см. ниже), \\(aq.\\(aq "
"(соответствует любому одному символу), \\(aq^\\(aq (соответствует строке "
"null в начале строки), \\(aq$\\(aq (соответствует строке null в конце "
"строки), \\(aq\\e\\(aq со следующим после него одним из символов «I<^.[$()|*"
"+?{\\e>» (соответствует этому символу, как он есть), символ \\(aq\\e\\(aq с "
"последующим символом, отличным от предыдущего\\*(dg (соответствует этому "
"символу, как он есть, как если бы \\(aq\\e\\(aq отсутствовал\\*(dg), или "
"одиночный символ без специального назначения (соответствует этому символу). "
"Символ \\(aq{\\(aq с последующим символом, не являющимся цифрой, "
"соответствует символу, а не началу интервала\\*(dg. Нельзя заканчивать РВ "
"символом \\(aq\\e\\(aq."

#. type: Plain text
#: man-pages/man7/regex.7:120
msgid ""
"A I<bracket expression> is a list of characters enclosed in \"I<[]>\".  It "
"normally matches any single character from the list (but see below).  If the "
"list begins with \\(aq^\\(aq, it matches any single character (but see "
"below) I<not> from the rest of the list.  If two characters in the list are "
"separated by \\(aq-\\(aq, this is shorthand for the full I<range> of "
"characters between those two (inclusive) in the collating sequence, for "
"example, \"I<[0-9]>\" in ASCII matches any decimal digit.  It is illegal"
"\\*(dg for two ranges to share an endpoint, for example, \"I<a-c-e>\".  "
"Ranges are very collating-sequence-dependent, and portable programs should "
"avoid relying on them."
msgstr ""
"I<Выражение в квадратных скобках> — список символов, заключенный в «I<[]>». "
"Обычно, оно соответствует любому отдельному символу из списка (но см. ниже). "
"Если список начинается с \\(aq^\\(aq, то он соответствует любому отдельному "
"символу (но см. ниже) I<не> из приведённого списка. Если два символа в "
"списке разделены \\(aq-\\(aq, то это считается сокращением полного "
"I<диапазона> символов, заключённого между этими двумя символами (включая и "
"их) объединяющей последовательности, например, «I<[0-9]>» в кодах ASCII "
"соответствует любой десятичной цифре. Нельзя\\*(dg в двух диапазонах "
"указывать один и тот же символ, например, «a-c-e». Диапазоны сильно зависят "
"от объединяющей последовательности, и в переносимых программах их лучше не "
"использовать."

#. type: Plain text
#: man-pages/man7/regex.7:131
msgid ""
"To include a literal \\(aq]\\(aq in the list, make it the first character "
"(following a possible \\(aq^\\(aq).  To include a literal \\(aq-\\(aq, make "
"it the first or last character, or the second endpoint of a range.  To use a "
"literal \\(aq-\\(aq as the first endpoint of a range, enclose it in \"I<[.>"
"\" and \"I<.]>\" to make it a collating element (see below).  With the "
"exception of these and some combinations using \\(aq[\\(aq (see next "
"paragraphs), all other special characters, including \\(aq\\e\\(aq, lose "
"their special significance within a bracket expression."
msgstr ""
"Для того, чтобы включить в список символ \\(aq]\\(aq, вам следует поставить "
"его в начало списка (после символа \\(aq^\\(aq, если он присутствует). Для "
"того, чтобы включить в список символ \\(aq-\\(aq, поставьте его первым или "
"последним символом или вторым символом конца диапазона. Для того, чтобы "
"обозначить символом \\(aq-\\(aq начало диапазона, заключите его в «I<[.>» и "
"«I<.]>», сделав его объединяющим элементом (смотрите далее). За исключением "
"этих и некоторых других комбинаций, использующих \\(aq[\\(aq  (см. следующие "
"параграфы), все остальные специальные символы, включая \\(aq\\e\\(aq, теряют "
"своё особое назначение в квадратных скобках."

#. type: Plain text
#: man-pages/man7/regex.7:143
msgid ""
"Within a bracket expression, a collating element (a character, a "
"multicharacter sequence that collates as if it were a single character, or a "
"collating-sequence name for either)  enclosed in \"I<[.>\" and \"I<.]>\" "
"stands for the sequence of characters of that collating element.  The "
"sequence is a single element of the bracket expression's list.  A bracket "
"expression containing a multicharacter collating element can thus match more "
"than one character, for example, if the collating sequence includes a \"ch\" "
"collating element, then the RE \"I<[[.ch.]]*c>\" matches the first five "
"characters of \"chchcc\"."
msgstr ""
"Если внутри квадратных скобок объединяющий элемент (одиночный символ, "
"многосимвольная последовательность, которая действует как одиночный символ "
"или имя объединяющей последовательности) заключен в «I<[.>» и «I<.]>», то он "
"обозначает последовательность символов как один объединяющий элемент. "
"Последовательность выражается одиночным элементом списка внутри квадратных "
"скобок. Таким образом, выражение в скобках, содержащее многосимвольный "
"объединяющий элемент, может соответствовать более чем одному символу; "
"например, если последовательность содержит объединяющий элемент «ch», то РВ "
"«I<[[.ch.]]*c>» соответствует первым пяти символам «chchcc»."

#. type: Plain text
#: man-pages/man7/regex.7:155
msgid ""
"Within a bracket expression, a collating element enclosed in \"I<[=>\" and "
"\"I<=]>\" is an equivalence class, standing for the sequences of characters "
"of all collating elements equivalent to that one, including itself.  (If "
"there are no other equivalent collating elements, the treatment is as if the "
"enclosing delimiters were \"I<[.>\" and \"I<.]>\".)  For example, if o and "
"\\o'o^' are the members of an equivalence class, then \"I<[[=o=]]>\", \"I<[[="
"\\o'o^'=]]>\", and \"I<[o\\o'o^']>\" are all synonymous.  An equivalence "
"class may not\\*(dg be an endpoint of a range."
msgstr ""
"Объединяющий элемент в квадратных скобках, заключенный в «I<[=>» и «I<=]>» — "
"это класс-эквивалент, делающий последовательности символов всех объединяющих "
"элементов эквивалентными одной, включая её саму (если нет больше "
"эквивалентных объединяющих элементов, то это аналогично выражению, "
"заключенному в «I<[.>» и «I<.]>»). Например, если o и \\o'o^' являются "
"членами класса-эквивалента, то «I<[[=o=]]>», «I<[[=\\o'o^'=]]>» и «I<[o"
"\\o'o^']>» являются синонимами. Класс-эквивалент не\\*(dg может служить "
"границей диапазона."

#. type: Plain text
#: man-pages/man7/regex.7:161
msgid ""
"Within a bracket expression, the name of a I<character class> enclosed in "
"\"I<[:>\" and \"I<:]>\" stands for the list of all characters belonging to "
"that class.  Standard character class names are:"
msgstr ""
"В выражении в квадратных скобках, имя I<символьного класса>, заключенное в "
"«I<[:>» и «I<:]>», соответствует списку всех символов, принадлежащих этому "
"классу. Существуют стандартные символьные классы:"

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "alnum"
msgstr "alnum"

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "digit"
msgstr "digit"

#. type: tbl table
#: man-pages/man7/regex.7:165
#, no-wrap
msgid "punct"
msgstr "punct"

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "alpha"
msgstr "alpha"

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "graph"
msgstr "graph"

#. type: tbl table
#: man-pages/man7/regex.7:166
#, no-wrap
msgid "space"
msgstr "space"

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "blank"
msgstr "blank"

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "lower"
msgstr "lower"

#. type: tbl table
#: man-pages/man7/regex.7:167
#, no-wrap
msgid "upper"
msgstr "upper"

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "cntrl"
msgstr "cntrl"

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "print"
msgstr "print"

#. type: tbl table
#: man-pages/man7/regex.7:168
#, no-wrap
msgid "xdigit"
msgstr "xdigit"

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  There are two special cases\*(dg of bracket expressions:
#.  the bracket expressions "\fI[[:<:]]\fP" and "\fI[[:>:]]\fP" match
#.  the null string at the beginning and end of a word respectively.
#.  A word is defined as a sequence of
#.  word characters
#.  which is neither preceded nor followed by
#.  word characters.
#.  A word character is an
#.  .I alnum
#.  character (as defined by
#.  .BR wctype (3))
#.  or an underscore.
#.  This is an extension,
#.  compatible with but not specified by POSIX.2,
#.  and should be used with
#.  caution in software intended to be portable to other systems.
#. type: Plain text
#: man-pages/man7/regex.7:195
msgid ""
"These stand for the character classes defined in B<wctype>(3).  A locale may "
"provide others.  A character class may not be used as an endpoint of a range."
msgstr ""
"Эти символьные классы определены в B<wctype>(3). В локали могут быть "
"определены свои классы. Символьный класс не может использоваться в качестве "
"границы диапазона."

#. type: Plain text
#: man-pages/man7/regex.7:207
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string.  If the RE "
"could match more than one substring starting at that point, it matches the "
"longest.  Subexpressions also match the longest possible substrings, subject "
"to the constraint that the whole match be as long as possible, with "
"subexpressions starting earlier in the RE taking priority over ones starting "
"later.  Note that higher-level subexpressions thus take priority over their "
"lower-level component subexpressions."
msgstr ""
"В случае, если РВ совпадает более чем с одной подстрокой заданной строки, то "
"оно считается совпадающим с первой подстрокой строки. Если РВ совпадает "
"более чем с одной подстрокой начинающейся в этой точке, то оно совпадет с "
"самой длинной подстрокой. Подвыражения также соответствуют самой длинной "
"совпадающей подстроке, полное соответствие должно быть наиболее длинным, и "
"подвыражения, стоящие в РВ первыми, имеют приоритет над остальными, "
"находящимися далее. Заметим, что высокоуровневые подвыражения имеют "
"приоритет над низкоуровневыми компонентами подвыражений."

#. type: Plain text
#: man-pages/man7/regex.7:219
msgid ""
"Match lengths are measured in characters, not collating elements.  A null "
"string is considered longer than no match at all.  For example, \"I<bb*>\" "
"matches the three middle characters of \"abbbc\", \"I<(wee|week)(knights|"
"nights)>\" matches all ten characters of \"weeknights\", when \"I<(.*).*>\" "
"is matched against \"abc\" the parenthesized subexpression matches all three "
"characters, and when \"I<(a*)*>\" is matched against \"bc\" both the whole "
"RE and the parenthesized subexpression match the null string."
msgstr ""
"Длина совпадений измеряется в символах, а не в объединяющих элементах. "
"Строка null считается длиннее чем не имеющая совпадений. Например, «I<bb*>» "
"совпадает с тремя средними символами «abbbc», «I<(wee|week)(knights|"
"nights)>» совпадает со всеми десятью символами «weeknights», а когда «I<(.*)."
"*>» сравнивается с «abc», подвыражение в скобках совпадает со всеми тремя "
"символами; при сравнении «I<(a*)*>» с «bc» получается, что РВ и подвыражение "
"в скобках соответствуют строке null."

#. type: Plain text
#: man-pages/man7/regex.7:230
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet.  When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, for example, \\(aqx\\(aq becomes \"I<[xX]>\".  When "
"it appears inside a bracket expression, all case counterparts of it are "
"added to the bracket expression, so that, for example, \"I<[x]>\" becomes "
"\"I<[xX]>\" and \"I<[^x]>\" becomes \"I<[^xX]>\"."
msgstr ""
"Если указано учитывать совпадение независимо от регистра, то все различия по "
"регистру удаляются из алфавита. Когда буква присутствует в различных "
"регистрах вне квадратных скобок, то она трансформируется в выражение в "
"квадратных скобках, содержащее оба регистра, например, \\(aqx\\(aq "
"становится «I<[xX]>». Если буква уже заключена в скобки, то к ней "
"добавляется и другой регистр, например, «I<[x]>» становится «I<[xX]>» , а "
"«I<[^x]>» превращается в «I<[^xX]>»."

#. type: Plain text
#: man-pages/man7/regex.7:236
msgid ""
"No particular limit is imposed on the length of REs\\*(dg.  Programs "
"intended to be portable should not employ REs longer than 256 bytes, as an "
"implementation can refuse to accept such REs and remain POSIX-compliant."
msgstr ""
"Конкретного ограничения длины РВ\\*(dg не существует. Однако, в переносимых "
"программах не следует использовать РВ более 256 байтов, так как реализация "
"может не принимать таких РВ, но оставаться соответствующей POSIX."

#. type: Plain text
#: man-pages/man7/regex.7:252
msgid ""
"Obsolete (\"basic\") regular expressions differ in several respects.  \\(aq|"
"\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq are ordinary characters and there is no "
"equivalent for their functionality.  The delimiters for bounds are \"I<\\e{>"
"\" and \"I<\\e}>\", with \\(aq{\\(aq and \\(aq}\\(aq by themselves ordinary "
"characters.  The parentheses for nested subexpressions are \"I<\\e(>\" and "
"\"I<\\e)>\", with \\(aq(\\(aq and \\(aq)\\(aq by themselves ordinary "
"characters.  \\(aq^\\(aq is an ordinary character except at the beginning of "
"the RE or\\*(dg the beginning of a parenthesized subexpression, \\(aq$\\(aq "
"is an ordinary character except at the end of the RE or\\*(dg the end of a "
"parenthesized subexpression, and \\(aq*\\(aq is an ordinary character if it "
"appears at the beginning of the RE or the beginning of a parenthesized "
"subexpression (after a possible leading \\(aq^\\(aq)."
msgstr ""
"Устаревшие («основные») РВ отличаются по нескольким аспектам. Символы \\(aq|"
"\\(aq, \\(aq+\\(aq и \\(aq?\\(aq считаются обычными символами. Для "
"обозначения границ интервалов используются «I<\\e{>» и «I<\\e}>», а "
"\\(aq{\\(aq и \\(aq}\\(aq сами по себе являются обычными символами. Для "
"обособления подвыражений используются «I<\\e(>» и «I<\\e)>», а \\(aq(\\(aq и "
"\\(aq)\\(aq сами по себе являются обычными символами. Символ \\(aq^\\(aq "
"является обычным символом за исключением того случая, когда он стоит в "
"начале РВ или\\*(dg в начале подвыражения в круглых скобках; символ \\(aq$"
"\\(aq является обычным символом, кроме того случая, когда он стоит в конце "
"РВ или\\*(dg в конце подвыражения в круглых скобках; символ \\(aq*\\(aq "
"является обычным, если он стоит в начале РВ или в начале подвыражения в "
"круглых скобках (возможно, после символа \\(aq^\\(aq в самом начале)."

#. type: Plain text
#: man-pages/man7/regex.7:260
msgid ""
"Finally, there is one new type of atom, a I<back reference>: \\(aq\\e\\(aq "
"followed by a nonzero decimal digit I<d> matches the same sequence of "
"characters matched by the I<d>th parenthesized subexpression (numbering "
"subexpressions by the positions of their opening parentheses, left to "
"right), so that, for example, \"I<\\e([bc]\\e)\\e1>\" matches \"bb\" or \"cc"
"\" but not \"bc\"."
msgstr ""
"Кроме этого, существует ещё один тип атома — I<обратная ссылка>: \\(aq\\e"
"\\(aq с последующей за ней ненулевой десятичной цифрой I<d> соответствует "
"той самой последовательности, что и I<d>-е подвыражение в скобках (нумерация "
"подвыражений считается по их открывающим круглым скобкам, слева направо). "
"Пример: «I<\\e([bc]\\e)\\e1>» соответствует «bb» или «cc», но не «bc»."

#. type: Plain text
#: man-pages/man7/regex.7:262
msgid "Having two kinds of REs is a botch."
msgstr "Наличие двух видов РВ — вынужденная мера."

#. type: Plain text
#: man-pages/man7/regex.7:268
msgid ""
"The current POSIX.2 spec says that \\(aq)\\(aq is an ordinary character in "
"the absence of an unmatched \\(aq(\\(aq; this was an unintentional result of "
"a wording error, and change is likely.  Avoid relying on it."
msgstr ""
"В имеющейся на данный момент документации POSIX.2 указано, что символ "
"\\(aq)\\(aq при отсутствии \\(aq(\\(aq; считается обычным; это "
"непреднамеренная опечатка, которая будет исправлена. Не полагайтесь на это."

#. type: Plain text
#: man-pages/man7/regex.7:275
msgid ""
"Back references are a dreadful botch, posing major problems for efficient "
"implementations.  They are also somewhat vaguely defined (does \"I<a\\e(\\e(b"
"\\e)*\\e2\\e)*d>\" match \"abbbd\"?).  Avoid using them."
msgstr ""
"Обратные ссылки — также вынужденная мера, вызывают серьёзные проблемы "
"эффективности в реализациях. Также они не имеют подробного определения "
"(например, «I<a\\e(\\e(b\\e)*\\e2\\e)*d>» соответствует «abbbd»?)."

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  The syntax for word boundaries is incredibly ugly.
#. type: Plain text
#: man-pages/man7/regex.7:283
msgid ""
"POSIX.2's specification of case-independent matching is vague.  The \"one "
"case implies all cases\" definition given above is current consensus among "
"implementors as to the right interpretation."
msgstr ""
"Определение в POSIX.2 совпадения при отключении учёта регистра тоже очень "
"туманное. Определение типа «один регистр замещает все остальные», по мнению "
"некоторых специалистов, не является правильным."

#. type: SH
#: man-pages/man7/regex.7:283
#, no-wrap
msgid "AUTHOR"
msgstr "АВТОР"

#.  Sigh... The page license means we must have the author's name
#.  in the formatted output.
#. type: Plain text
#: man-pages/man7/regex.7:287
msgid "This page was taken from Henry Spencer's regex package."
msgstr ""
"Эта страница взята из пакета regex, написанного Генри Спенсером (Henry "
"Spencer)."

#. type: Plain text
#: man-pages/man7/regex.7:290
msgid "B<grep>(1), B<regex>(3)"
msgstr "B<grep>(1), B<regex>(3)"

#. type: Plain text
#: man-pages/man7/regex.7:291
msgid "POSIX.2, section 2.8 (Regular Expression Notation)."
msgstr "POSIX.2, раздел 2.8 (запись регулярных выражений)."

#. type: TH
#: man-pages/man7/rtld-audit.7:28
#, no-wrap
msgid "RTLD-AUDIT"
msgstr "RTLD-AUDIT"

#. type: TH
#: man-pages/man7/rtld-audit.7:28
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:31
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""
"rtld-audit - программный интерфейс слежения за динамическим компоновщиком"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:44
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined "
"by including I<E<lt>link.hE<gt>>."
msgstr ""
"Динамический компоновщик GNU (компоновщик времени выполнения) предоставляет "
"API слежения, который позволяет приложению получать уведомления о различных "
"событиях динамической компоновки. Данный API очень похож на интерфейс "
"слежения, предоставляемый компоновщиком времени выполнения из Solaris. "
"Необходимые константы и прототипы определены в I<E<lt>link.hE<gt>>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:51
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""
"Чтобы использовать этот интерфейс, программист создаёт общую библиотеку "
"функций со стандартизованными именами. Не все функции нужно реализовывать: в "
"большинстве случаев, если программист не заинтересован в конкретном классе "
"отслеживаемых событий, то нет нужды в создании соответствующей отслеживающей "
"функции."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:59
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""
"Для применения интерфейса слежения переменная окружения B<LD_AUDIT> должна "
"содержать разделённый двоеточиями список общих библиотек, каждая из которых "
"может реализовывать (частично) API слежения. Когда возникает отслеживаемое "
"событие, из каждой библиотеки вызывается соответствующая функция в том "
"порядке, в котором эти библиотеки были перечислены."

#. type: SS
#: man-pages/man7/rtld-audit.7:59
#, no-wrap
msgid "la_version()"
msgstr "la_version()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:63
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr "B<unsigned int la_version(unsigned int >I<version>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:75
msgid ""
"This is the only function that I<must> be defined by an auditing library: it "
"performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports.  If necessary, the auditing library can check that this version is "
"sufficient for its requirements."
msgstr ""
"Это единственная функция, которая I<должна> быть определена в отслеживающей "
"библиотеке: она осуществляет первичную связь между динамическим "
"компоновщиком и отслеживающей библиотекой. При вызове этой функции "
"динамический компоновщик передаёт в I<version> максимальную версию "
"интерфейса слежения, которую поддерживает сам компоновщик. При "
"необходимости, отслеживающая библиотека может проверить, что эта версия "
"удовлетворяет её требованиям."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:84
msgid ""
"As its function result, this function should return the version of the "
"auditing interface that this auditing library expects to use (returning "
"I<version> is acceptable).  If the returned value is 0, or a version that is "
"greater than that supported by the dynamic linker, then the audit library is "
"ignored."
msgstr ""
"Данная функция должна возвращать версию интерфейса слежения, которую "
"отслеживающая библиотека собирается использовать (возврат I<version> "
"приемлем). Если возвращаемое значение равно 0 или больше чем максимальная "
"версия, поддерживаемая динамическим компоновщиком, то отслеживающая "
"библиотека игнорируется."

#. type: SS
#: man-pages/man7/rtld-audit.7:84
#, no-wrap
msgid "la_objsearch()"
msgstr "la_objsearch()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:89
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:100
msgid ""
"The dynamic linker invokes this function to inform the auditing library that "
"it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""
"Динамический компоновщик вызывает эту функцию для информирования "
"отслеживающей библиотеки при поиске общего объекта. Аргумент I<name> "
"содержит имя файла или путь, который будет разыскиваться. В I<cookie> "
"указывается общий объект, который начал поиск. Аргумент I<flag> "
"устанавливается в одно из следующих значений:"

#. type: TP
#: man-pages/man7/rtld-audit.7:100
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr "B<LA_SER_ORIG>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:109
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""
"Это оригинальное имя, которое будет разыскиваться. Как правило, это имя "
"хранится в записи ELF B<DT_NEEDED> или был передан в аргументе I<filename> "
"при вызове B<dlopen>(3)."

#. type: TP
#: man-pages/man7/rtld-audit.7:109
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr "B<LA_SER_LIBPATH>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:114
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""
"Значение I<name> было создано с использованием каталога из "
"B<LD_LIBRARY_PATH>."

#. type: TP
#: man-pages/man7/rtld-audit.7:114
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr "B<LA_SER_RUNPATH>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:122
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""
"Значение I<name> было создано с использованием каталога из списка ELF "
"B<DT_RPATH> или B<DT_RUNPATH>."

#. type: TP
#: man-pages/man7/rtld-audit.7:122
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr "B<LA_SER_CONFIG>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:129
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""
"Значение I<name> было найдено в кэше B<ldconfig>(8) (I</etc/ld.so.cache>)."

#. type: TP
#: man-pages/man7/rtld-audit.7:129
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr "B<LA_SER_DEFAULT>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:133
msgid "I<name> was found via a search of one of the default directories."
msgstr ""
"Значение I<name> было найдено при поиске в одном из каталогов по умолчанию."

#. type: TP
#: man-pages/man7/rtld-audit.7:133
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr "B<LA_SER_SECURE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:137
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""
"Значение I<name> относится к объекту безопасности (не используется в Linux)."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:146
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then "
"this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""
"Функция B<la_objsearch>() возвращает путь, который динамический компоновщик "
"должен использовать в дальнейшей работе. Если возвращается NULL, то путь "
"игнорируется в дальнейшей работе. Если данная отслеживающая библиотека "
"создана для простого слежения за путями поиска, то должно возвращаться "
"I<name>."

#. type: SS
#: man-pages/man7/rtld-audit.7:146
#, no-wrap
msgid "la_activity()"
msgstr "la_activity()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:150
#, no-wrap
msgid "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:159
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head "
"of the link map.  When the dynamic linker invokes this function, I<flag> is "
"set to one of the following values:"
msgstr ""
"Динамический компоновщик вызывает эту функцию для информирования библиотеки "
"слежения о выполнении действия с картой ссылок (link-map). В I<cookie> "
"задаётся объект, находящийся в начале карты ссылок. Когда динамический "
"компоновщик вызывает эту функцию, аргумент I<flag> устанавливается в одно из "
"следующих значений:"

#. type: TP
#: man-pages/man7/rtld-audit.7:159
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr "B<LA_ACT_ADD>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:162
msgid "New objects are being added to the link map."
msgstr "В карту ссылок добавляется новый объект."

#. type: TP
#: man-pages/man7/rtld-audit.7:162
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr "B<LA_ACT_DELETE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:165
msgid "Objects are being removed from the link map."
msgstr "Из карты ссылок удаляется объект."

#. type: TP
#: man-pages/man7/rtld-audit.7:165
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr "B<LA_ACT_CONSISTENT>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:168
msgid "Link-map activity has been completed: the map is once again consistent."
msgstr ""
"Действие с картой ссылок завершено: карта снова корректна (consistent)."

#. type: SS
#: man-pages/man7/rtld-audit.7:168
#, no-wrap
msgid "la_objopen()"
msgstr "la_objopen()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:173
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:182
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""
"Динамический компоновщик вызывает эту функцию при загрузке нового общего "
"объекта. Аргумент I<map> является указателем на структуру карты ссылок (link-"
"map), которая описывает объект. Поле I<lmid> устанавливается в одно из "
"следующих значений:"

#. type: TP
#: man-pages/man7/rtld-audit.7:182
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr "B<LM_ID_BASE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:185
msgid "Link map is part of the initial namespace."
msgstr "Карта ссылок является частью начального пространства имён (namespace)."

#. type: TP
#: man-pages/man7/rtld-audit.7:185
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr "B<LM_ID_NEWLM>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:189
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""
"Карта ссылок является частью нового пространства имён, запрошенного через "
"B<dlmopen>(3)."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:197
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""
"Аргумент I<cookie> — указатель на идентификатор этого объекта. Идентификатор "
"используется при последующих вызовах функций отслеживающей библиотеки для "
"идентификации этого объекта. Данный идентификатор инициализируется "
"указателем на карту ссылок объекта, но отслеживающая библиотека может "
"изменить идентификатор на другое значение, которое ей удобней использовать "
"для обращения к объекту."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:204
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to "
"select the objects to be monitored by B<la_symbind*>():"
msgstr ""
"Функция B<la_objopen>() возвращает битовую маску, созданное с помощью "
"сложения (OR) нуля или более следующих констант, которые позволяют "
"отслеживающей библиотеке выбирать наблюдаемые объекты через B<la_symbind*>():"

#. type: TP
#: man-pages/man7/rtld-audit.7:204
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr "B<LA_FLG_BINDTO>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:207
msgid "Audit symbol bindings to this object."
msgstr "Следить за символьными привязками этого объекта."

#. type: TP
#: man-pages/man7/rtld-audit.7:207
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr "B<LA_FLG_BINDFROM>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:210
msgid "Audit symbol bindings from this object."
msgstr "Следить за символьными привязками из этого объекта."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:214
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""
"Возвращаемое значение 0 из B<la_objopen>() указывает на то, что не нужно "
"отслеживать символьные привязки этого объекта."

#. type: SS
#: man-pages/man7/rtld-audit.7:214
#, no-wrap
msgid "la_objclose()"
msgstr "la_objclose()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:218
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"
msgstr "B<unsigned int la_objclose(uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:227
msgid ""
"The dynamic linker invokes this function after any finalization code for the "
"object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""
"Динамический компоновщик вызывает эту функцию после выполнения конечного "
"кода (finalization code), но до выгрузки объекта. В I<cookie> задаётся "
"идентификатор, полученный ранее из вызова B<la_objopen>()."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:231
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""
"В текущей реализации значение, возвращаемое B<la_objclose>(), игнорируется."

#. type: SS
#: man-pages/man7/rtld-audit.7:231
#, no-wrap
msgid "la_preinit()"
msgstr "la_preinit()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:235
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:245
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""
"Динамический компоновщик вызывает эту функцию после загрузки всех общих "
"объектов, но до передачи управления приложению (то есть, до вызова "
"I<main>()). Заметим, что I<main>() позднее всё ещё может динамически "
"загрузить объекты с помощью B<dlopen>(3)."

#. type: SS
#: man-pages/man7/rtld-audit.7:245
#, no-wrap
msgid "la_symbind*()"
msgstr "la_symbind*()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:254
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
msgstr ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:266
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on "
"64-bit platforms."
msgstr ""
"Динамический компоновщик вызывает одну из этих функций при выполнении "
"символьной привязки между двумя общими объектами, которые были помечены для "
"уведомления функцией B<la_objopen>(). Функция B<la_symbind32>() применяется "
"на 32-битных платформах; B<la_symbind64>() применяется на 64-битных "
"платформах."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:276
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""
"Аргумент I<sym> является указателем на структуру, которая содержит "
"информацию о привязываемом символе. Определение структуры находится в "
"I<E<lt>elf.hE<gt>>. Среди полей структуры есть поле I<st_value>, которое "
"содержит адрес привязываемого символа."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:281
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the "
"bound shared object."
msgstr ""
"В аргументе I<ndx> указывается индекс символа в таблице символов "
"привязываемого общего объекта."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:296
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""
"В аргументе I<refcook> указывается общий объект, который ссылается на "
"символ; это тот же идентификатор, который указывается в функции "
"B<la_objopen>(), возвращающей B<LA_FLG_BINDFROM>. В аргументе I<defcook> "
"указывается общий объект, который определяет символ, на который производится "
"ссылка; это тот же идентификатор, который указывается в функции "
"B<la_objopen>(), возвращающей  B<LA_FLG_BINDTO>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:300
msgid ""
"The I<symname> argument points a string containing the name of the symbol."
msgstr "В аргументе I<symname> задаётся строка, содержащая имя символа."

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: man-pages/man7/rtld-audit.7:308
msgid ""
"The I<flags> argument is a bit mask that both provides information about the "
"symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""
"Аргумент I<flags> представляет собой битовую маску, которая содержит "
"информацию о символе и может использоваться для изменения дальнейшего "
"отслеживания этой записи PLT (Procedure Linkage Table). Динамический "
"компоновщик может передавать следующие битовые значения в этом аргументе:"

#. type: TP
#: man-pages/man7/rtld-audit.7:308
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr "B<LA_SYMB_DLSYM>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:312
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr "Привязка возникла из-за вызова B<dlsym>(3)."

#. type: TP
#: man-pages/man7/rtld-audit.7:312
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr "B<LA_SYMB_ALTVALUE>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:317
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""
"Предыдущий вызов B<la_symbind*>() вернул альтернативное значение для этого "
"символа."

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: man-pages/man7/rtld-audit.7:331
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced.  "
"The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""
"По умолчанию, если в отслеживающей библиотеке реализованы функции "
"B<la_pltenter>() и B<la_pltexit>() (смотрите ниже), то эти функции "
"вызываются после B<la_symbind>() для записей PLT каждый раз при ссылке на "
"символ. Следующие флаги могут объединяться с помощью OR в I<*flags> для "
"изменения данного поведения по умолчанию:"

#. type: TP
#: man-pages/man7/rtld-audit.7:331
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr "B<LA_SYMB_NOPLTENTER>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:336
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr "Не вызывать B<la_pltenter>() для этого символа."

#. type: TP
#: man-pages/man7/rtld-audit.7:336
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr "B<LA_SYMB_NOPLTEXIT>"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:341
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr "Не вызывать B<la_pltexit>() для этого символа."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:352
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address "
"to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return "
"I<sym-E<gt>st_value>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""
"Возвращаемое значение B<la_symbind32>() и B<la_symbind64>() представляет "
"собой адрес, по которому нужно передать управление после возврата функций. "
"Если отслеживающая библиотека просто наблюдает за привязкой символов, то "
"должно возвращаться I<sym-E<gt>st_value>. Может возвращаться другое "
"значение, если библиотека хочет передать управление в другое место."

#. type: SS
#: man-pages/man7/rtld-audit.7:352
#, no-wrap
msgid "la_pltenter()"
msgstr "la_pltenter()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:358 man-pages/man7/rtld-audit.7:418
msgid ""
"The precise name and argument types for this function depend on the hardware "
"platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)  "
"Here is the definition for x86-32:"
msgstr ""
"Точное имя и типы аргументов данной функции зависят от аппаратной платформы "
"(подходящее определение приведено в I<E<lt>link.hE<gt>>). Ниже показано "
"определение для x86-32:"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:364
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long int *>I<framesizep>B<);>\n"
msgstr ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long int *>I<framesizep>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:368
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""
"Эта функция вызывается до вызова записи PLT между двумя общими объектами, "
"которые помечены для уведомления о привязке."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:378 man-pages/man7/rtld-audit.7:441
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""
"Значение аргументов I<sym>, I<ndx>, I<refcook>, I<defcook> и I<symname> "
"такое же как у B<la_symbind*>()."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:385
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)  "
"containing the values of registers to be used for the call to this PLT entry."
msgstr ""
"Аргумент I<regs> указывает на структуру (определена в I<E<lt>link.hE<gt>>), "
"содержащую значения регистров, которые будут использованы для вызова этой "
"записи PLT."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:391
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""
"Аргумент I<flags> указывает на битовую маску, которая сообщает информацию и "
"может использоваться для изменения последующего слежения за этой записью "
"PLT; значения как у B<la_symbind*>()."

#.  FIXME . Is the following correct?
#. type: Plain text
#: man-pages/man7/rtld-audit.7:407
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used "
"to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltexit>()  "
"function is called only if this buffer is explicitly set to a suitable value."
msgstr ""
"Аргумент I<framesizep> указывает на буфер I<long\\ int>, который можно "
"использовать для явного определения размера фрейма, используемого для вызова "
"этой записи PLT. Если другие вызовы B<la_pltenter>() для этого символа "
"возвращают другие значения, то используется максимальное полученное "
"значение. Функция B<la_pltexit>() вызывается только, если этот буфер явно "
"устанавливает подходящее значение."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:412
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr "Возвращаемое B<la_pltenter>() значение подобно B<la_symbind*>()."

#. type: SS
#: man-pages/man7/rtld-audit.7:412
#, no-wrap
msgid "la_pltexit()"
msgstr "la_pltexit()"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:424
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:431
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""
"Эта функция вызывается после завершения вызова записи PLT, выполняемой между "
"двумя общими объектами, которые были помечены для уведомления при привязке. "
"Функция вызывается перед передачей управления из записи PLT вызывающему."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:454
msgid ""
"The I<inregs> argument points to a structure (defined in I<E<lt>link."
"hE<gt>>)  containing the values of registers used for the call to this PLT "
"entry.  The I<outregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""
"Аргумент I<inregs> указывает на структуру (определена в I<E<lt>link."
"hE<gt>>), содержащую значения регистров, используемых для вызова этой записи "
"PLT. Аргумент I<outregs> указывает на структуру (определена в I<E<lt>link."
"hE<gt>>), содержащую значения для вызова в эту запись PLT. Эти значения "
"могут изменяться вызывающим и изменения будут видимы вызывающему запись PLT."

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: man-pages/man7/rtld-audit.7:462
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""
"В текущей реализации GNU возвращаемое значение B<la_pltexit>() игнорируется."

#. type: SH
#: man-pages/man7/rtld-audit.7:462
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:468
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""
"Данный API не стандартен, но очень похож на Solaris API, описанный в Solaris "
"I<Linker and Libraries Guide> в главе I<Runtime Linker Auditing Interface>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:471
msgid ""
"Note the following differences from the Solaris dynamic linker auditing API:"
msgstr "Отметим следующие отличия API динамического компоновщика в Solaris:"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:475
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""
"Интерфейс Solaris B<la_objfilter>() не поддерживается в реализации GNU."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:483
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide "
"a I<symname> argument."
msgstr ""
"В функциях Solaris B<la_symbind32>() и B<la_pltexit>() нет аргумента "
"I<symname>."

#. type: Plain text
#: man-pages/man7/rtld-audit.7:493
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""
"В функции Solaris B<la_pltexit>() нет аргументов I<inregs> и I<outregs> (но "
"есть аргумент I<retval> со значением, возвращаемым функцией)."

#.  FIXME . Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: man-pages/man7/rtld-audit.7:503
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""
"В glibc до версии 2.9 включительно, указание более одной отслеживающей "
"библиотеки в B<LD_AUDIT> приводит к падению во время выполнения. Это "
"исправлено в glibc 2.10."

#. type: SH
#: man-pages/man7/rtld-audit.7:503
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:507
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:512
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): %d\\en\", version);\n"
msgstr ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): %d\\en\", version);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:515
#, no-wrap
msgid ""
"    return version;\n"
"}\n"
msgstr ""
"    return version;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:528
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %p\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %p\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:531
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr ""
"    return name;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:541
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %p; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %p; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:551
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%p\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%p\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:554
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:559
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %p\\en\", cookie);\n"
msgstr ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %p\\en\", cookie);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:562
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:568
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %p\\en\", cookie);\n"
"}\n"
msgstr ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %p\\en\", cookie);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:577
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:580 man-pages/man7/rtld-audit.7:592
#: man-pages/man7/rtld-audit.7:602
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr ""
"    return sym-E<gt>st_value;\n"
"}\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:589
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"
msgstr ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %p; defcook = %p\\en\", refcook, defcook);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:599
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long int *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"
msgstr ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long int *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"

#. type: Plain text
#: man-pages/man7/rtld-audit.7:607
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: man-pages/man7/raw.7:13
#, no-wrap
msgid "RAW"
msgstr "RAW"

#. type: Plain text
#: man-pages/man7/raw.7:16
msgid "raw - Linux IPv4 raw sockets"
msgstr "raw - неструктурированные сокеты IPv4 в Linux"

#. type: Plain text
#: man-pages/man7/raw.7:20
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr "B<#include E<lt>netinet/in.hE<gt>>"

#. type: Plain text
#: man-pages/man7/raw.7:22
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"

#. type: Plain text
#: man-pages/man7/raw.7:26
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw "
"socket receives or sends the raw datagram not including link level headers."
msgstr ""
"Неструктурированные (raw) сокеты позволяют реализовать новые протоколы IPv4 "
"в пространстве пользователя. Через неструктурированный сокет получают или "
"посылают необработанные датаграммы, не включающие в себя заголовки уровня "
"соединения (link level)."

#. type: Plain text
#: man-pages/man7/raw.7:32
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving, the IP header is "
"always included in the packet."
msgstr ""
"Уровень IPv4 генерирует заголовок IP при посылке пакета, если только для "
"сокета не включён параметр B<IP_HDRINCL>. Если он включён, то пакет должен "
"содержать заголовок IP. Принимаемые пакеты всегда содержат заголовок IP."

#. type: Plain text
#: man-pages/man7/raw.7:36
msgid ""
"In order to create a raw socket, a process must have the B<CAP_NET_RAW> "
"capability in the user namespace that governs its network namespace."
msgstr ""
"Для создания неструктурированного сокета процесс должен иметь мандат "
"B<CAP_NET_RAW> в пользовательском пространстве имён, определяемом по его "
"сетевому пространству имён."

#. type: Plain text
#: man-pages/man7/raw.7:47
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols, see "
"the IANA list of assigned protocol numbers at E<.UR http://www.iana.org/"
"assignments/protocol-numbers/> E<.UE> and B<getprotobyname>(3)."
msgstr ""
"Все пакеты или ошибки, совпадающие с номером протокола I<protocol>, "
"указанным неструктурированному сокету, передаются этому сокету. Список "
"допустимых протоколов назначается списком IANA E<.UR http://www.iana.org/"
"assignments/protocol-numbers/> E<.UE>и содержится в B<getprotobyname>(3)."

#. type: Plain text
#: man-pages/man7/raw.7:57
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""
"Протокол B<IPPROTO_RAW> подразумевает включённый параметр B<IP_HDRINCL> и "
"позволяет отправлять любой протокол IP, который указан в передаваемом "
"заголовке. Приём любых протоколов IP посредством B<IPPROTO_RAW> через "
"неструктурированные сокеты невозможен."

#. type: tbl table
#: man-pages/man7/raw.7:62
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>"
msgstr "Поля заголовка IP, изменяемые B<IP_HDRINCL> при передаче"

#. type: tbl table
#: man-pages/man7/raw.7:63
#, no-wrap
msgid "IP Checksum"
msgstr "контрольная сумма IP"

#. type: tbl table
#: man-pages/man7/raw.7:63 man-pages/man7/raw.7:66
#, no-wrap
msgid "Always filled in"
msgstr "всегда заполняется"

#. type: tbl table
#: man-pages/man7/raw.7:64
#, no-wrap
msgid "Source Address"
msgstr "адрес источника"

#. type: tbl table
#: man-pages/man7/raw.7:64 man-pages/man7/raw.7:65
#, no-wrap
msgid "Filled in when zero"
msgstr "заполняется, если значение равно нулю"

#. type: tbl table
#: man-pages/man7/raw.7:65
#, no-wrap
msgid "Packet ID"
msgstr "ID пакета"

#. type: tbl table
#: man-pages/man7/raw.7:66
#, no-wrap
msgid "Total Length"
msgstr "общая длина"

#. type: Plain text
#: man-pages/man7/raw.7:80
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address, then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""
"Если указан B<IP_HDRINCL> и заголовок IP имеет ненулевой адрес назначения, "
"то для маршрутизации пакета используется адрес назначения сокета. Если "
"указан B<MSG_DONTROUTE>, то адрес назначения должен ссылаться на локальный "
"интерфейс, иначе в любом случае будет производиться поиск в таблице "
"маршрутизации, но маршруты со шлюзами будут игнорироваться."

#. type: Plain text
#: man-pages/man7/raw.7:88
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets "
"with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""
"Если B<IP_HDRINCL> не указан, то параметры заголовка IP в "
"неструктурированных сокетах могут быть установлены с помощью "
"B<setsockopt>(2); более подробная информация приведена в B<ip>(7)."

#. type: Plain text
#: man-pages/man7/raw.7:93
msgid ""
"Starting with Linux 2.2, all IP header fields and options can be set using "
"IP socket options.  This means raw sockets are usually needed only for new "
"protocols or protocols with no user interface (like ICMP)."
msgstr ""
"Начиная с Linux 2.2 все поля заголовка IP и параметры могут быть заданы с "
"помощью параметров сокета IP. Это означает, что неструктурированные сокеты, "
"как правило, необходимы лишь для новых протоколов или протоколов без "
"интерфейса пользователя (например, ICMP)."

#. type: Plain text
#: man-pages/man7/raw.7:97
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""
"Принятый пакет передаётся всем подключенным (bound) к этому протоколу "
"неструктурированным сокетам до того, как он будет передан другим "
"обработчикам протоколов (например, протокольным модулям ядра)."

#. type: SS
#: man-pages/man7/raw.7:97
#, no-wrap
msgid "Address format"
msgstr "Формат адреса"

#.  commit f59fc7f30b710d45aadf715460b3e60dbe9d3418
#. type: Plain text
#: man-pages/man7/raw.7:115
msgid ""
"For sending and receiving datagrams (B<sendto>(2), B<recvfrom>(2), and "
"similar), raw sockets use the standard I<sockaddr_in> address structure "
"defined in B<ip>(7).  The I<sin_port> field could be used to specify the IP "
"protocol number, but it is ignored for sending in Linux 2.2 and later, and "
"should be always set to 0 (see BUGS).  For incoming packets, I<sin_port> is "
"set to zero."
msgstr ""
"При отправке и приёме дейтаграмм (B<sendto>(2), B<recvfrom>(2) и similar) "
"через неструктурированные сокеты используется стандартная адресная структура "
"I<sockaddr_in>, определённая в B<ip>(7). Поле I<sin_port> можно использовать "
"для указания номера протокола IP, но в Linux 2.2 и новее оно игнорируется "
"при отправке, и должно всегда равняться 0 (смотрите ДЕФЕКТЫ). У входящих "
"пакетов I<sin_port> равен нулю."

#. type: SS
#: man-pages/man7/raw.7:115
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокета"

#.  Or SOL_RAW on Linux
#. type: Plain text
#: man-pages/man7/raw.7:124
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""
"Параметры неструктурированных сокетов могут быть установлены с помощью "
"B<setsockopt>(2) и прочитаны с помощью B<getsockopt>(2) с указанием флага "
"семейства B<IPPROTO_RAW>."

#. type: TP
#: man-pages/man7/raw.7:124
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr "B<ICMP_FILTER>"

#. type: Plain text
#: man-pages/man7/raw.7:132
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""
"Запускает специальный фильтр для неструктурированных сокетов, подключенных к "
"протоколу B<IPPROTO_ICMP>. Значение представляет собой набор бит — по "
"установленному биту для каждого типа сообщений ICMP, который должен быть "
"отфильтрован. По умолчанию сообщения ICMP не фильтруются."

#. type: Plain text
#: man-pages/man7/raw.7:137
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""
"Кроме этого, поддерживаются все датаграммные параметры сокетов B<ip>(7) для "
"B<IPPROTO_IP>."

#. type: SS
#: man-pages/man7/raw.7:137
#, no-wrap
msgid "Error handling"
msgstr "Обработка ошибок"

#. type: Plain text
#: man-pages/man7/raw.7:150
msgid ""
"Errors originating from the network are passed to the user only when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""
"Ошибки, возникающие в сети, передаются пользователю только, если сокет "
"подключён или установлен флаг B<IP_RECVERR>. В целях совместимости в "
"подключенные сокеты передаются только B<EMSGSIZE> и B<EPROTO>. При указании "
"B<IP_RECVERR> в очереди ошибок сохраняются все сетевые ошибки."

#. type: SH
#: man-pages/man7/raw.7:150
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/raw.7:151
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man7/raw.7:155
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""
"Пользователь попытался передать пакет по широковещательному адресу без "
"указания на сокете флага широковещательной передачи."

#. type: TP
#: man-pages/man7/raw.7:155
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man7/raw.7:158
msgid "An invalid memory address was supplied."
msgstr "Указан неправильный адрес памяти."

#. type: TP
#: man-pages/man7/raw.7:158
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/raw.7:161
msgid "Invalid argument."
msgstr "Неверный аргумент."

#. type: TP
#: man-pages/man7/raw.7:161
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man7/raw.7:168
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64\\ kB."
msgstr ""
"Размер пакета слишком велик, либо включён Path MTU Discovery (флаг сокета "
"B<IP_PMTU_DISCOVER>), либо размер пакета превышает максимально разрешенный "
"для IPv4 размер, равный 64\\ КБ."

#. type: TP
#: man-pages/man7/raw.7:168
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man7/raw.7:172
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr "Сокетному вызову был передан неверный флаг (например, B<MSG_OOB>)."

#. type: TP
#: man-pages/man7/raw.7:172
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man7/raw.7:178
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""
"Пользователь не имеет прав на открытие неструктурированных сокетов. Это "
"могут делать только процессы с идентификатором эффективного пользователя "
"равным 0, или имеющие мандат B<CAP_NET_RAW>."

#. type: TP
#: man-pages/man7/raw.7:178
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: man-pages/man7/raw.7:181
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr "Получена ошибка ICMP, сообщающая о проблеме с параметром."

#. type: Plain text
#: man-pages/man7/raw.7:187
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""
"Значения B<IP_RECVERR> и B<ICMP_FILTER> появились в Linux 2.2. Они являются "
"расширениями Linux и не должны использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man7/raw.7:193
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set; since Linux 2.2, this "
"option no longer has that effect."
msgstr ""
"Код неструктурированных сокетов в версии Linux 2.0 при установленном "
"параметре B<SO_BSDCOMPAT> был специально сделан совместимым с BSD «вплоть до "
"ошибок». Из Linux 2.2 это было удалено."

#. type: Plain text
#: man-pages/man7/raw.7:211
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"По умолчанию, для неструктурированных сокетов выполняется обнаружение MTU "
"(Maximum Transmission Unit) пути. Это означает, что ядро будет следить за "
"MTU до IP-адреса назначения и возвращать B<EMSGSIZE>, если запись "
"неструктурированного пакета превысит это значение. Когда это происходит, "
"приложение должно уменьшить размер пакета. Также обнаружение MTU пути можно "
"выключить с помощью параметра сокета B<IP_MTU_DISCOVER> или в файле I</proc/"
"sys/net/ipv4/ip_no_pmtu_disc>; подробней смотрите в B<ip>(7). При отключении "
"обнаружения неструктурированные сокеты фрагментируют исходящие пакеты, "
"размер которых превышает MTU интерфейса. Однако по соображениям "
"производительности и надёжности отключение не рекомендуется."

#. type: Plain text
#: man-pages/man7/raw.7:220
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a raw socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""
"Неструктурированный сокет может быть подключён к определённому локальному "
"адресу с помощью вызова B<bind>(2). Если он не подключён, то принимаются все "
"пакеты указанного протокола IP. Кроме того, неструктурированный сокет может "
"быть подключён к определённому сетевому устройству с помощью "
"B<SO_BINDTODEVICE>; смотрите B<socket>(7)."

#. type: Plain text
#: man-pages/man7/raw.7:231
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP "
"packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""
"Сокет B<IPPROTO_RAW> предназначен только для отправки. Если вы хотите "
"получать все пакеты IP, используйте сокет B<packet>(7) с протоколом "
"B<ETH_P_IP>. Заметим, что пакетные сокеты, в отличие от неструктурированных "
"сокетов, не собирают пакеты из фрагментов IP."

#. type: Plain text
#: man-pages/man7/raw.7:237
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""
"Если вы хотите получать все пакеты ICMP для датаграммного сокета, то лучше "
"использовать B<IP_RECVERR> на определённом сокете; смотрите B<ip>(7)."

#. type: Plain text
#: man-pages/man7/raw.7:244
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not "
"be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""
"Неструктурированные сокеты могут перехватывать в Linux все протоколы IP, "
"даже имеющие протокольный модуль в ядре (такие, как ICMP или TCP). В этом "
"случае пакеты передаются как модулю ядра, так и неструктурированным сокетам. "
"На это нельзя закладываться в переносимых программах, так как многие другие "
"реализации сокетов BSD так не делают."

#. type: Plain text
#: man-pages/man7/raw.7:249
msgid ""
"Linux never changes headers passed from the user (except for filling in some "
"zeroed fields as described for B<IP_HDRINCL>).  This differs from many other "
"implementations of raw sockets."
msgstr ""
"Linux никогда не изменяет заголовки, полученные от пользователя (за "
"исключением обнуления некоторых полей, как описано в случае с "
"B<IP_HDRINCL>). Такое поведение отличается от поведения многих других "
"реализаций неструктурированных сокетов."

#. type: Plain text
#: man-pages/man7/raw.7:252
msgid ""
"Raw sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""
"Неструктурированные сокеты, в общем случае, не являются переносимыми, "
"поэтому следует избегать их использования в переносимых программах."

#. type: Plain text
#: man-pages/man7/raw.7:258
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""
"Передача через неструктурированный сокет должна осуществляться с помощью "
"протокола IP из I<sin_port>; эта возможность исчезла в Linux 2.2. Метод "
"обхода — использовать B<IP_HDRINCL>."

#. type: Plain text
#: man-pages/man7/raw.7:260
msgid "Transparent proxy extensions are not described."
msgstr "Не описаны расширения прозрачного прокси."

#. type: Plain text
#: man-pages/man7/raw.7:265
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""
"Если установлен параметр B<IP_HDRINCL>, датаграммы не будут фрагментированы "
"и их размер будет ограничен MTU интерфейса."

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/raw.7:275
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""
"В Linux 2.2 отсутствует настройка протокола IP для отправки  I<sin_port> — "
"всегда используется тот протокол, к которому был подключён сокет или который "
"был указан при первом вызове B<socket>(2)."

#. type: Plain text
#: man-pages/man7/raw.7:281
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"

#. type: Plain text
#: man-pages/man7/raw.7:287
msgid ""
"B<RFC\\ 1191> for path MTU discovery.  B<RFC\\ 791> and the I<E<lt>linux/ip."
"hE<gt>> header file for the IP protocol."
msgstr ""
"В B<RFC\\ 1191> описан процесс обнаружения маршрута MTU. В B<RFC\\ 791> и "
"заголовочном файле I<E<lt>linux/ip.hE<gt>> описан протокол IP."

#. type: TH
#: man-pages/man7/random.7:31
#, no-wrap
msgid "2017-03-13"
msgstr "2017-03-13"

#. type: Plain text
#: man-pages/man7/random.7:34
msgid "random - overview of interfaces for obtaining randomness"
msgstr "random - обзор интерфейсов получения случайных чисел"

#. type: Plain text
#: man-pages/man7/random.7:39
msgid ""
"The kernel random-number generator relies on entropy gathered from device "
"drivers and other sources of environmental noise to seed a cryptographically "
"secure pseudorandom number generator (CSPRNG).  It is designed for security, "
"rather than speed."
msgstr ""
"Генератор случайных чисел ядра полагается на энтропию, собранную с драйверов "
"устройств и других источников окружающего шума, чтобы задать начальное "
"значение криптографически безопасный генератор псевдослучайных чисел "
"(CSPRNG). При разработке главным параметром была безопасность, а не скорость."

#. type: Plain text
#: man-pages/man7/random.7:41
msgid ""
"The following interfaces provide access to output from the kernel CSPRNG:"
msgstr "Следующие интерфейсы предоставляют доступ к данным ядерного CSPRNG:"

#. type: Plain text
#: man-pages/man7/random.7:50
msgid ""
"The I</dev/urandom> and I</dev/random> devices, both described in "
"B<random>(4).  These devices have been present on Linux since early times, "
"and are also available on many other systems."
msgstr ""
"Устройства I</dev/urandom> и I</dev/random>, описаны в B<random>(4). Данные "
"устройства доступны с первых версий Linux, а также они есть и во многих "
"других системах."

#. type: Plain text
#: man-pages/man7/random.7:76
msgid ""
"The Linux-specific B<getrandom>(2)  system call, available since Linux "
"3.17.  This system call provides access either to the same source as I</dev/"
"urandom> (called the I<urandom> source in this page)  or to the same source "
"as I</dev/random> (called the I<random> source in this page).  The default "
"is the I<urandom> source; the I<random> source is selected by specifying the "
"B<GRND_RANDOM> flag to the system call.  (The B<getentropy>(3)  function "
"provides a slightly more portable interface on top of B<getrandom>(2).)"
msgstr ""
"Системный вызов, который есть только в Linux — B<getrandom>(2), доступен "
"начиная с Linux 3.17. Данный вызов предоставляет доступ к источнику как у I</"
"dev/urandom> (в этой странице упоминается как источник I<urandom>) так и к "
"источнику как у I</dev/random> (в этой странице упоминается как I<random>). "
"По умолчанию используется источник I<urandom>; источник I<random> выбирается "
"при указании системному вызову флага B<GRND_RANDOM> (функция "
"B<getentropy>(3) предоставляет схожий, более переносимый интерфейс, "
"основанный на B<getrandom>(2))."

#. type: SS
#: man-pages/man7/random.7:76
#, no-wrap
msgid "Initialization of the entropy pool"
msgstr "Инициализация пула энтропии"

#. type: Plain text
#: man-pages/man7/random.7:80
msgid ""
"The kernel collects bits of entropy from the environment.  When a sufficient "
"number of random bits has been collected, the entropy pool is considered to "
"be initialized."
msgstr ""
"Ядро собирает биты энтропии из окружения. Когда собрано достаточное "
"количество произвольных бит, пул энтропии считается инициализированным."

#. type: SS
#: man-pages/man7/random.7:80
#, no-wrap
msgid "Choice of random source"
msgstr "Выбор источника случайных чисел"

#. type: Plain text
#: man-pages/man7/random.7:99
msgid ""
"Unless you are doing long-term key generation (and most likely not even "
"then), you probably shouldn't be reading from the I</dev/random> device or "
"employing B<getrandom>(2)  with the B<GRND_RANDOM> flag.  Instead, either "
"read from the I</dev/urandom> device or employ B<getrandom>(2)  without the "
"B<GRND_RANDOM> flag.  The cryptographic algorithms used for the I<urandom> "
"source are quite conservative, and so should be sufficient for all purposes."
msgstr ""
"Если вы не генерируете долгосрочные ключи (и, скорее всего, и в этом "
"случае), то, вероятно, не должны читать из устройства I</dev/random> или "
"запускать B<getrandom>(2) с флагом B<GRND_RANDOM>. Вместо этого читайте "
"устройство I</dev/urandom> и запускайте B<getrandom>(2) без флага "
"B<GRND_RANDOM>. Алгоритмы шифрования, используемые для источника I<urandom>, "
"довольно консервативны, и поэтому их должно быть достаточно для любых нужд."

#. type: Plain text
#: man-pages/man7/random.7:112
msgid ""
"The disadvantage of B<GRND_RANDOM> and reads from I</dev/random> is that the "
"operation can block for an indefinite period of time.  Furthermore, dealing "
"with the partially fulfilled requests that can occur when using "
"B<GRND_RANDOM> or when reading from I</dev/random> increases code complexity."
msgstr ""
"Недостаток B<GRND_RANDOM> и чтения из I</dev/random> в том, что эта операция "
"может заблокировать выполнение на неопределённый период времени. Более того, "
"работа с частично выполненными запросами, которые могут вернуться при "
"использовании B<GRND_RANDOM> или чтении I</dev/random>, увеличивает "
"сложность кода."

#. type: SS
#: man-pages/man7/random.7:112
#, no-wrap
msgid "Monte Carlo and other probabilistic sampling applications"
msgstr "Монте-Карло и другие вероятностные приложения выборки"

#. type: Plain text
#: man-pages/man7/random.7:122
msgid ""
"Using these interfaces to provide large quantities of data for Monte Carlo "
"simulations or other programs/algorithms which are doing probabilistic "
"sampling will be slow.  Furthermore, it is unnecessary, because such "
"applications do not need cryptographically secure random numbers.  Instead, "
"use the interfaces described in this page to obtain a small amount of data "
"to seed a user-space pseudorandom number generator for use by such "
"applications."
msgstr ""
"Использование этих интерфейсов для предоставления большого количества данных "
"при моделировании Монте-Карло или другим программам/алгоритмам, выполняющим "
"вероятностную выборку, будет медленным. Кроме того, это излишне, так как "
"таким приложениям не нужны криптографически безопасные случайные числа. "
"Вместо этого используйте интерфейсы, описанные на этой странице, чтобы "
"получить небольшое количество данных для запуска генератора псевдослучайных "
"чисел в пространстве пользователя, который будет задействован для таких "
"приложений."

#. type: SS
#: man-pages/man7/random.7:122
#, no-wrap
msgid "Comparison between getrandom, /dev/urandom, and /dev/random"
msgstr "Сравнение getrandom, /dev/urandom и /dev/random"

#. type: Plain text
#: man-pages/man7/random.7:130
msgid ""
"The following table summarizes the behavior of the various interfaces that "
"can be used to obtain randomness.  B<GRND_NONBLOCK> is a flag that can be "
"used to control the blocking behavior of B<getrandom>(2).  The final column "
"of the table considers the case that can occur in early boot time when the "
"entropy pool is not yet initialized."
msgstr ""
"В следующую таблицу сведено поведение различных интерфейсов получения "
"случайных чисел. Флаг B<GRND_NONBLOCK> можно использовать для управления "
"поведением блокирования B<getrandom>(2). В последней колонке таблицы "
"показано, что может произойти на ранней стадии загрузки ОС, когда пул "
"энтропии ещё не инициализирован."

#. type: tbl table
#: man-pages/man7/random.7:135
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man7/random.7:135
#, no-wrap
msgid "Pool"
msgstr "Пул"

#. type: tbl table
#: man-pages/man7/random.7:138
#, no-wrap
msgid ""
"Blocking\n"
"\\%behavior"
msgstr ""
"Возникновение\n"
"\\%блокировки"

#. type: tbl table
#: man-pages/man7/random.7:140
#, no-wrap
msgid "Behavior when pool is not yet ready"
msgstr "Поведение, когда пул ещё не готов"

#. type: tbl table
#: man-pages/man7/random.7:145
#, no-wrap
msgid "Blocking pool"
msgstr "Блокирующий пул"

#. type: tbl table
#: man-pages/man7/random.7:147 man-pages/man7/random.7:177
#, no-wrap
msgid "If entropy too low, blocks until there is enough entropy again"
msgstr "Если энтропии недостаточно, то блокирует до тех пор, пока не наберётся нужно количество энтропии"

#. type: tbl table
#: man-pages/man7/random.7:149
#, no-wrap
msgid "Blocks until enough entropy gathered"
msgstr "Блокирует, пока не наберётся нужно количество энтропии"

#. type: tbl table
#: man-pages/man7/random.7:154
#, no-wrap
msgid "CSPRNG output"
msgstr "Данные CSPRNG"

#. type: tbl table
#: man-pages/man7/random.7:156
#, no-wrap
msgid "Never blocks"
msgstr "Никогда не блокируется"

#. type: tbl table
#: man-pages/man7/random.7:158
#, no-wrap
msgid "Returns output from uninitialized CSPRNG (may be low entropy and unsuitable for cryptography)"
msgstr "Возвращает данные из неинициализированного CSPRNG (может быть низкая энтропия и не подходить для шифрования)"

#. type: tbl table
#: man-pages/man7/random.7:161
#, no-wrap
msgid "B<getrandom>()"
msgstr "B<getrandom>()"

#. type: tbl table
#: man-pages/man7/random.7:164 man-pages/man7/random.7:186
#, no-wrap
msgid ""
"Same as\n"
"I</dev/urandom>"
msgstr ""
"Тоже, что и\n"
"I</dev/urandom>"

#. type: tbl table
#: man-pages/man7/random.7:166 man-pages/man7/random.7:188
#, no-wrap
msgid "Does not block once is pool ready"
msgstr "Не блокирует в ожидании пула"

#. type: tbl table
#: man-pages/man7/random.7:168 man-pages/man7/random.7:179
#, no-wrap
msgid "Blocks until pool ready"
msgstr "Блокирует до готовности пула"

#. type: tbl table
#: man-pages/man7/random.7:172
#, no-wrap
msgid ""
"B<getrandom>()\n"
"B<GRND_RANDOM>"
msgstr ""
"B<getrandom>()\n"
"B<GRND_RANDOM>"

#. type: tbl table
#: man-pages/man7/random.7:175 man-pages/man7/random.7:199
#, no-wrap
msgid ""
"Same as\n"
"I</dev/random>"
msgstr ""
"Тоже, что и\n"
"I</dev/random>"

#. type: tbl table
#: man-pages/man7/random.7:183
#, no-wrap
msgid ""
"B<getrandom>()\n"
"B<GRND_NONBLOCK>"
msgstr ""
"B<getrandom>()\n"
"B<GRND_NONBLOCK>"

#. type: tbl table
#: man-pages/man7/random.7:190 man-pages/man7/random.7:204
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: tbl table
#: man-pages/man7/random.7:196
#, no-wrap
msgid ""
"B<getrandom>()\n"
"B<GRND_RANDOM>\n"
"+\n"
"B<GRND_NONBLOCK>"
msgstr ""
"B<getrandom>()\n"
"B<GRND_RANDOM>\n"
"+\n"
"B<GRND_NONBLOCK>"

#. type: tbl table
#: man-pages/man7/random.7:202
#, no-wrap
msgid ""
"B<EAGAIN>\n"
"if not enough entropy available"
msgstr ""
"B<EAGAIN>,\n"
"если недостаточно энтропии"

#. type: SS
#: man-pages/man7/random.7:208
#, no-wrap
msgid "Generating cryptographic keys"
msgstr "Генерация ключей шифрования"

#. type: Plain text
#: man-pages/man7/random.7:216
msgid ""
"The amount of seed material required to generate a cryptographic key equals "
"the effective key size of the key.  For example, a 3072-bit RSA or Diffie-"
"Hellman private key has an effective key size of 128 bits (it requires about "
"2^128 operations to break) so a key generator needs only 128 bits (16 bytes) "
"of seed material from I</dev/random>."
msgstr ""
"Количество начального материала, требуемое для генерации ключей шифрования, "
"равно эффективному размеру ключа. Например, 307 2-битный закрытый ключ RSA "
"или Diffie-Hellman имеет эффективный размер ключа  бит (для его подбора "
"требуется просмотреть 2^128 значений), поэтому генератору ключа нужно только "
"128 бит (16 байт) начального материала из I</dev/random>."

#. type: Plain text
#: man-pages/man7/random.7:226
msgid ""
"While some safety margin above that minimum is reasonable, as a guard "
"against flaws in the CSPRNG algorithm, no cryptographic primitive available "
"today can hope to promise more than 256 bits of security, so if any program "
"reads more than 256 bits (32 bytes) from the kernel random pool per "
"invocation, or per reasonable reseed interval (not less than one minute), "
"that should be taken as a sign that its cryptography is I<not> skillfully "
"implemented."
msgstr ""
"Так как разумно добавить некоторый запас прочности к выше указанному "
"минимуму как защиту против недостатков в алгоритме CSPRNG, никакой доступный "
"криптографический примитив сегодня не может обещать больше чем 256 бит "
"безопасности, поэтому если какая-то программа читает больше чем 256 бит (32 "
"байта) из пула случайных чисел ядра за вызов, или за разумный интервал "
"повторного посева (не менее одной минуты), то это нужно считать признаком "
"того, что шифрование в ней реализовано I<НЕДОСТАТОЧНО> продуманно."

#. type: Plain text
#: man-pages/man7/random.7:232
msgid ""
"B<getrandom>(2), B<getauxval>(3), B<getentropy>(3), B<random>(4), "
"B<urandom>(4), B<signal>(7)"
msgstr ""
"B<getrandom>(2), B<getauxval>(3), B<getentropy>(3), B<random>(4), "
"B<urandom>(4), B<signal>(7)"

#. type: TH
#: man-pages/man2/request_key.2:12
#, no-wrap
msgid "REQUEST_KEY"
msgstr "REQUEST_KEY"

#. type: TH
#: man-pages/man2/request_key.2:12
#, no-wrap
msgid "Linux Key Management Calls"
msgstr "Вызовы системы управления ключами Linux"

#. type: Plain text
#: man-pages/man2/request_key.2:15
msgid "request_key - request a key from the kernel's key management facility"
msgstr "request_key - запрашивает ключ из системы управления ключами ядра"

#. type: Plain text
#: man-pages/man2/request_key.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>keyutils.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>keyutils.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/request_key.2:23
#, no-wrap
msgid ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<dest_keyring>B<);>\n"
msgstr ""
"B<key_serial_t request_key(const char *>I<type>B<, const char *>I<description>B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<dest_keyring>B<);>\n"

#. type: Plain text
#: man-pages/man2/request_key.2:26
msgid "No glibc wrapper is provided for this system call; see NOTES."
msgstr ""
"В glibc нет обёрточной функции для данного системного вызова; смотрите "
"ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/request_key.2:38
msgid ""
"B<request_key>()  attempts to find a key of the given I<type> with a "
"description (name) that matches the specified I<description>.  If such a key "
"could not be found, then the key is optionally created.  If the key is found "
"or created, B<request_key>()  attaches it to the keyring whose ID is "
"specified in I<dest_keyring> and returns the key's serial number."
msgstr ""
"Системный вызов B<request_key>() пытается найти ключ заданного I<type> с "
"описанием (именем), совпадающим с I<description>. Если ключ найти "
"невозможно, то ключ может быть создан. Если ключ найден или создан, то "
"B<request_key>() присоединяет его к связке ключей, чей идентификатор указан "
"I<keyring>, и возвращает серийный номер ключа."

#. type: Plain text
#: man-pages/man2/request_key.2:44
msgid ""
"B<request_key>()  first recursively searches for a matching key in all of "
"the keyrings attached to the calling process.  The keyrings are searched in "
"the order: thread-specific keyring, process-specific keyring, and then "
"session keyring."
msgstr ""
"Сначала B<request_key>() выполняет рекурсивный поиск совпадающего ключа во "
"всех связках ключей, присоединённых к вызвавшему процессу. Связки ключей "
"просматриваются в следующем порядке: связки каждой нити, связки вызвавшего "
"процесса и связки ключей сеанса."

#.  David Howells: we can then have an arbitrarily long sequence
#.  of "recursive" request-key upcalls. There is no limit, other
#.  than number of PIDs, etc.
#. type: Plain text
#: man-pages/man2/request_key.2:56
msgid ""
"If B<request_key>()  is called from a program invoked by B<request_key>()  "
"on behalf of some other process to generate a key, then the keyrings of that "
"other process will be searched next, using that other process's user ID, "
"group ID, supplementary group IDs, and security context to determine access."
msgstr ""
"Если B<request_key>() вызван из программы, вызванной B<request_key>() от "
"имени какого-то другого процесс для генерации ключа, то в дальнейшем будет "
"осуществлён поиск по связкам ключей этого другого процесса, используя для "
"определения доступа его идентификатор пользователя, группы и дополнительных "
"групп и контекста безопасности."

#. type: Plain text
#: man-pages/man2/request_key.2:65
msgid ""
"The search of the keyring tree is breadth-first: the keys in each keyring "
"searched are checked for a match before any child keyrings are recursed "
"into.  Only keys for which the caller has I<search> permission be found, and "
"only keyrings for which the caller has I<search> permission may be searched."
msgstr ""
"Поиск в дереве связок ключей выполняется сначала в ширину: искомые ключи в "
"каждой связке проверяются на совпадение до рекурсивного перехода в дочерние "
"связки ключей. Найдены могут быть только те ключи, которые разрешены "
"вызывающему для B<поиска>, и поиск может осуществляться только в разрешённых "
"для B<поиска> связках ключей."

#. type: Plain text
#: man-pages/man2/request_key.2:70
msgid ""
"If the key is not found and I<callout> is NULL, then the call fails with the "
"error B<ENOKEY>."
msgstr ""
"Если ключ не найден и I<callout> равно NULL, то вызов завершается ошибкой "
"B<ENOKEY>."

#. type: Plain text
#: man-pages/man2/request_key.2:76
msgid ""
"If the key is not found and I<callout> is not NULL, then the kernel attempts "
"to invoke a user-space program to instantiate the key.  The details are "
"given below."
msgstr ""
"Если ключ не найден и I<callout> не равно NULL, то ядро пытается вызвать "
"пользовательскую программу для создания ключа. Подробности приведены ниже."

#. type: Plain text
#: man-pages/man2/request_key.2:82
msgid ""
"The I<dest_keyring> serial number may be that of a valid keyring for which "
"the caller has I<write> permission, or it may be one of the following "
"special keyring IDs:"
msgstr ""
"Серийный номер I<dest_keyring> может задаваться серийным номером допустимой "
"связки ключей, на которую у вызывающего есть права на I<запись>, или же это "
"может быть один из следующих специальных идентификаторов связок ключей:"

#. type: TP
#: man-pages/man2/request_key.2:82
#, no-wrap
msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgstr "B<KEY_SPEC_THREAD_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:86
msgid ""
"This specifies the caller's thread-specific keyring (see B<thread-"
"keyring>(7))."
msgstr "Связка ключей вызывающей нити (смотрите B<thread-keyring>(7))."

#. type: TP
#: man-pages/man2/request_key.2:86
#, no-wrap
msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgstr "B<KEY_SPEC_PROCESS_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:90
msgid ""
"This specifies the caller's process-specific keyring (see B<process-"
"keyring>(7))."
msgstr "Связка ключей вызывающего процесса (смотрите B<process-keyring>(7))."

#. type: TP
#: man-pages/man2/request_key.2:90
#, no-wrap
msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_SESSION_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:94
msgid ""
"This specifies the caller's session-specific keyring (see B<session-"
"keyring>(7))."
msgstr "Связка ключей сеанса вызывающего (смотрите B<session-keyring>(7))."

#. type: TP
#: man-pages/man2/request_key.2:94
#, no-wrap
msgid "B<KEY_SPEC_USER_KEYRING>"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:98
msgid ""
"This specifies the caller's UID-specific keyring (see B<user-keyring>(7))."
msgstr "Связка ключей по UID вызывающего (смотрите B<user-keyring>(7))."

#. type: TP
#: man-pages/man2/request_key.2:98
#, no-wrap
msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: man-pages/man2/request_key.2:102
msgid ""
"This specifies the caller's UID-session keyring (see B<user-session-"
"keyring>(7))."
msgstr ""
"Связка ключей по UID сеанса вызывающего (смотрите B<user-session-"
"keyring>(7))."

#. type: Plain text
#: man-pages/man2/request_key.2:108
msgid ""
"When the I<dest_keyring> is specified as 0 and no key construction has been "
"performed, then no additional linking is done."
msgstr ""
"Если I<dest_keyring> равно 0 и создание ключа не выполнено, то "
"дополнительных связей не появляется."

#. type: Plain text
#: man-pages/man2/request_key.2:121
msgid ""
"Otherwise, if I<dest_keyring> is 0 and a new key is constructed, the new key "
"will be linked to the \"default\" keyring.  More precisely, when the kernel "
"tries to determine to which keyring the newly constructed key should be "
"linked, it tries the following keyrings, beginning with the keyring set via "
"the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation and continuing in "
"the order shown below until it finds the first keyring that exists:"
msgstr ""
"В противном случае, если I<dest_keyring> равно 0 и создан новый ключ, то "
"новый ключ будет прицеплен в связку ключей «по умолчанию». Более точно, "
"когда ядро пытается определить в какую связку ключей должен быть прицеплен "
"то только что созданный ключ, оно перебирает связки ключей начиная с со "
"связки, установленной через B<keyctl>(2) с операцией "
"B<KEYCTL_SET_REQKEY_KEYRING> и продолжает в порядке, показанном далее, пока "
"не найдёт существующую связку ключей:"

#. type: IP
#: man-pages/man2/request_key.2:121 man-pages/man2/request_key.2:131
#: man-pages/man2/request_key.2:136 man-pages/man2/request_key.2:141
#: man-pages/man2/request_key.2:146 man-pages/man2/request_key.2:152
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#.  8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#.  FIXME
#.  Actually, is the preceding point correct?
#.  If I understand correctly, we'll only get here if
#.  'dest_keyring' is zero, in which case KEY_REQKEY_DEFL_REQUESTOR_KEYRING
#.  won't refer to a keyring. Have I misunderstood?
#. type: Plain text
#: man-pages/man2/request_key.2:131
msgid ""
"The requestor keyring (B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING>, since Linux "
"2.6.29)."
msgstr ""
"Связка ключей запрашивающего (B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING>, начиная "
"с Linux 2.6.29)."

#. type: Plain text
#: man-pages/man2/request_key.2:136
msgid ""
"The thread-specific keyring (B<KEY_REQKEY_DEFL_THREAD_KEYRING>; see B<thread-"
"keyring>(7))."
msgstr ""
"Связка ключей нити (B<KEY_REQKEY_DEFL_THREAD_KEYRING>; смотрите B<thread-"
"keyring>(7))."

#. type: Plain text
#: man-pages/man2/request_key.2:141
msgid ""
"The process-specific keyring (B<KEY_REQKEY_DEFL_PROCESS_KEYRING>; see "
"B<process-keyring>(7))."
msgstr ""
"Связка ключей процесса (B<KEY_REQKEY_DEFL_PROCESS_KEYRING>; смотрите "
"B<process-keyring>(7))."

#. type: Plain text
#: man-pages/man2/request_key.2:146
msgid ""
"The session-specific keyring (B<KEY_REQKEY_DEFL_SESSION_KEYRING>; see "
"B<session-keyring>(7))."
msgstr ""
"Связка ключей сеанса (B<KEY_REQKEY_DEFL_SESSION_KEYRING>; смотрите B<session-"
"keyring>(7))."

#. type: Plain text
#: man-pages/man2/request_key.2:152
msgid ""
"The session keyring for the process's user ID "
"(B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>; see B<user-session-keyring>(7)).  "
"This keyring is expected to always exist."
msgstr ""
"Связка ключей сеанса для идентификатора пользователя процесса "
"(B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>; смотрите B<user-session-"
"keyring>(7)). Ожидается, что эта связка ключей всегда существует."

#.  mtk: Are there circumstances where the user sessions and UID-specific
#.  keyrings do not exist?
#.  David Howells:
#.      The uid keyrings don't exist until someone tries to access them -
#.      at which point they're both created.  When you log in, pam_keyinit
#.      creates a link to your user keyring in the session keyring it just
#.      created, thereby creating the user and user-session keyrings.
#.  and David elaborated that "access" means:
#.      It means lookup_user_key() was passed KEY_LOOKUP_CREATE.  So:
#.          add_key() - destination keyring
#.          request_key() - destination keyring
#.          KEYCTL_GET_KEYRING_ID - if create arg is true
#.          KEYCTL_CLEAR
#.          KEYCTL_LINK - both args
#.          KEYCTL_SEARCH - destination keyring
#.          KEYCTL_CHOWN
#.          KEYCTL_SETPERM
#.          KEYCTL_SET_TIMEOUT
#.          KEYCTL_INSTANTIATE - destination keyring
#.          KEYCTL_INSTANTIATE_IOV - destination keyring
#.          KEYCTL_NEGATE - destination keyring
#.          KEYCTL_REJECT - destination keyring
#.          KEYCTL_GET_PERSISTENT - destination keyring
#.      will all create a keyring under some circumstances.  Whereas the rest,
#.      such as KEYCTL_GET_SECURITY, KEYCTL_READ and KEYCTL_REVOKE, won't.
#. type: Plain text
#: man-pages/man2/request_key.2:188
msgid ""
"The UID-specific keyring (B<KEY_REQKEY_DEFL_USER_KEYRING>; see B<user-"
"keyring>(7)).  This keyring is also expected to always exist."
msgstr ""
"Связка ключей для идентификатора пользователя процесса "
"(B<KEY_REQKEY_DEFL_USER_KEYRING>; смотрите B<user-keyring>(7)). Ожидается, "
"что эта связка ключей также всегда существует."

#. type: Plain text
#: man-pages/man2/request_key.2:200
msgid ""
"If the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation specifies "
"B<KEY_REQKEY_DEFL_DEFAULT> (or no B<KEYCTL_SET_REQKEY_KEYRING> operation is "
"performed), then the kernel looks for a keyring starting from the beginning "
"of the list."
msgstr ""
"Если вызов B<keyctl>(2) с операцией B<KEYCTL_SET_REQKEY_KEYRING> установил "
"B<KEY_REQKEY_DEFL_DEFAULT> (или операция B<KEYCTL_SET_REQKEY_KEYRING> не "
"выполнялась), то ядро ищет связку ключей начиная с начала списка."

#. type: SS
#: man-pages/man2/request_key.2:200
#, no-wrap
msgid "Requesting user-space instantiation of a key"
msgstr "Запрос на создание ключа из пользовательского пространства"

#. type: Plain text
#: man-pages/man2/request_key.2:213
msgid ""
"If the kernel cannot find a key matching I<type> and I<description>, and "
"I<callout> is not NULL, then the kernel attempts to invoke a user-space "
"program to instantiate a key with the given I<type> and I<description>.  In "
"this case, the following steps are performed:"
msgstr ""
"Если ядро не может найти ключ с соответствующим I<type> и I<description>, и "
"I<callout> не равно NULL, то ядро пытается вызвать программу из "
"пользовательского пространства для создания ключа с заданными I<type> и "
"I<description>. В этом случае выполняются следующие шаги:"

#. type: IP
#: man-pages/man2/request_key.2:213
#, no-wrap
msgid "a)"
msgstr "а)"

#. type: Plain text
#: man-pages/man2/request_key.2:218
msgid ""
"The kernel creates an uninstantiated key, U, with the requested I<type> and "
"I<description>."
msgstr ""
"Ядро создаёт неинициализированный ключ U с запрошенными I<type> и "
"I<description>."

#. type: IP
#: man-pages/man2/request_key.2:218
#, no-wrap
msgid "b)"
msgstr "б)"

#.  struct request_key_auth, defined in security/keys/internal.h
#. type: Plain text
#: man-pages/man2/request_key.2:224
msgid ""
"The kernel creates an authorization key, V, that refers to the key U and "
"records the facts that the caller of B<request_key>()  is:"
msgstr ""
"Ядро создаёт ключ авторизации V, который ссылается на ключ U и сохраняются "
"данные вызывающего B<request_key>():"

#. type: IP
#: man-pages/man2/request_key.2:225
#, no-wrap
msgid "(1)"
msgstr "(1)"

#. type: Plain text
#: man-pages/man2/request_key.2:227
msgid "the context in which the key U should be instantiated and secured, and"
msgstr "контекст, в котором ключ U должен быть создан и защищён и"

#. type: IP
#: man-pages/man2/request_key.2:227
#, no-wrap
msgid "(2)"
msgstr "(2)"

#. type: Plain text
#: man-pages/man2/request_key.2:229
msgid "the context from which associated key requests may be satisfied."
msgstr "контекст, из которого запросы связанного ключа могут быть проведены."

#. type: Plain text
#: man-pages/man2/request_key.2:232
msgid "The authorization key is constructed as follows:"
msgstr "Ключ авторизации создаётся со следующими свойствами:"

#. type: Plain text
#: man-pages/man2/request_key.2:236
msgid "The key type is I<\".request_key_auth\">."
msgstr "Тип ключа — I<\".request_key_auth\">."

#. type: Plain text
#: man-pages/man2/request_key.2:239
msgid ""
"The key's UID and GID are the same as the corresponding filesystem IDs of "
"the requesting process."
msgstr ""
"UID и GID ключа совпадают с ID в файловой системе для запрашивающего "
"процесса."

#. type: Plain text
#: man-pages/man2/request_key.2:248
msgid ""
"The key grants I<view>, I<read>, and I<search> permissions to the key "
"possessor as well as I<view> permission for the key user."
msgstr ""
"Ключ даёт права на I<просмотр>, I<чтение> и I<поиск> на ключ-владелец, а "
"также право I<просмотра> для ключа пользователя."

#. type: Plain text
#: man-pages/man2/request_key.2:252
msgid ""
"The description (name) of the key is the hexadecimal string representing the "
"ID of the key that is to be instantiated in the requesting program."
msgstr ""
"Описание (имя) ключа представляет собой Шестнадцатеричную строку "
"идентификатора ключа, который будет создан в запрашивающей программе."

#. type: Plain text
#: man-pages/man2/request_key.2:255
msgid ""
"The payload of the key is taken from the data specified in I<callout_info>."
msgstr "Полезные данные ключа берутся из данных I<callout_info>."

#. type: Plain text
#: man-pages/man2/request_key.2:258
msgid ""
"Internally, the kernel also records the PID of the process that called "
"B<request_key>()."
msgstr ""
"Внутри ядра также сохраняется PID процесса, который был вызван "
"B<request_key>()."

#. type: IP
#: man-pages/man2/request_key.2:259
#, no-wrap
msgid "c)"
msgstr "в)"

#.  The request-key(8) program can be invoked in circumstances *other* than
#.  when triggered by request_key(2). For example, upcalls from places such
#.  as the DNS resolver.
#. type: Plain text
#: man-pages/man2/request_key.2:266
msgid ""
"The kernel creates a process that executes a user-space service such as "
"B<request-key>(8)  with a new session keyring that contains a link to the "
"authorization key, V."
msgstr ""
"Ядро создаёт процесс, который запускает службу пользовательского "
"пространства, такую как B<request-key>(8), с новой связкой ключей сеанса с "
"прицепленным ключом авторизации V."

#. type: Plain text
#: man-pages/man2/request_key.2:268
msgid "This program is supplied with the following command-line arguments:"
msgstr "Данной программе передаются следующие аргументы командной строки:"

#. type: IP
#: man-pages/man2/request_key.2:269
#, no-wrap
msgid "[0]"
msgstr "[0]"

#. type: Plain text
#: man-pages/man2/request_key.2:272
msgid "The string I<\"/sbin/request-key\">."
msgstr "Строка I<\"/sbin/request-key\">."

#. type: IP
#: man-pages/man2/request_key.2:272
#, no-wrap
msgid "[1]"
msgstr "[1]"

#. type: Plain text
#: man-pages/man2/request_key.2:276
msgid "The string I<\"create\"> (indicating that a key is to be created)."
msgstr "Строка I<\"create\"> (показывающая, что ключ будет создан)."

#. type: IP
#: man-pages/man2/request_key.2:276
#, no-wrap
msgid "[2]"
msgstr "[2]"

#. type: Plain text
#: man-pages/man2/request_key.2:278
msgid "The ID of the key that is to be instantiated."
msgstr "Идентификатор ключа, который будет создан."

#. type: IP
#: man-pages/man2/request_key.2:278
#, no-wrap
msgid "[3]"
msgstr "[3]"

#. type: Plain text
#: man-pages/man2/request_key.2:281
msgid "The filesystem UID of the caller of B<request_key>()."
msgstr "UID (в файловой системе) вызывающего B<request_key>()."

#. type: IP
#: man-pages/man2/request_key.2:281
#, no-wrap
msgid "[4]"
msgstr "[4]"

#. type: Plain text
#: man-pages/man2/request_key.2:284
msgid "The filesystem GID of the caller of B<request_key>()."
msgstr "GID (в файловой системе) вызывающего B<request_key>()."

#. type: IP
#: man-pages/man2/request_key.2:284
#, no-wrap
msgid "[5]"
msgstr "[5]"

#. type: Plain text
#: man-pages/man2/request_key.2:288
msgid ""
"The ID of the thread keyring of the caller of B<request_key>().  This may be "
"zero if that keyring hasn't been created."
msgstr ""
"Идентификатор связки ключей нити вызывающего B<request_key>(). Может быть "
"ноль, если связка ключей не создана."

#. type: IP
#: man-pages/man2/request_key.2:288
#, no-wrap
msgid "[6]"
msgstr "[6]"

#. type: Plain text
#: man-pages/man2/request_key.2:292
msgid ""
"The ID of the process keyring of the caller of B<request_key>().  This may "
"be zero if that keyring hasn't been created."
msgstr ""
"Идентификатор связки ключей процесса вызывающего B<request_key>(). Может "
"быть ноль, если связка ключей не создана."

#. type: IP
#: man-pages/man2/request_key.2:292
#, no-wrap
msgid "[7]"
msgstr "[7]"

#. type: Plain text
#: man-pages/man2/request_key.2:295
msgid "The ID of the session keyring of the caller of B<request_key>()."
msgstr "Идентификатор связки ключей сеанса вызывающего B<request_key>()."

#. type: Plain text
#: man-pages/man2/request_key.2:303
msgid ""
"I<Note>: each of the command-line arguments that is a key ID is encoded in "
"I<decimal> (unlike the key IDs shown in I</proc/keys>, which are shown as "
"hexadecimal values)."
msgstr ""
"I<Замечание>: каждый аргумент командной строки, обозначающий идентификатор "
"ключа, кодируется I<десятичным> числом (в отличие от идентификаторов ключе, "
"показанных в I</proc/keys>, которые выдаются в виде шестнадцатеричных "
"значений)."

#. type: IP
#: man-pages/man2/request_key.2:303
#, no-wrap
msgid "d)"
msgstr "г)"

#. type: Plain text
#: man-pages/man2/request_key.2:305
msgid "The program spawned in the previous step:"
msgstr "Программа, порождённая на предыдущем шаге:"

#. type: Plain text
#: man-pages/man2/request_key.2:313
msgid ""
"Assumes the authority to instantiate the key U using the B<keyctl>(2)  "
"B<KEYCTL_ASSUME_AUTHORITY> operation (typically via the "
"B<keyctl_assume_authority>(3)  function)."
msgstr ""
"Принимает полномочия на создание ключа U с помощью B<keyctl>(2) с операцией "
"B<KEYCTL_ASSUME_AUTHORITY> (обычно, с помощью функции "
"B<keyctl_assume_authority>(3))."

#. type: Plain text
#: man-pages/man2/request_key.2:322
msgid ""
"Obtains the callout data from the payload of the authorization key V (using "
"the B<keyctl>(2)  B<KEYCTL_READ> operation (or, more commonly, the "
"B<keyctl_read>(3)  function) with a key ID value of "
"B<KEY_SPEC_REQKEY_AUTH_KEY>)."
msgstr ""
"Получает исходящие данные (callout data) из полезной нагрузки ключа "
"авторизации V (с помощью B<keyctl>(2) с операцией B<KEYCTL_READ> (или, чаще "
"всего, с помощью функции B<keyctl_read>(3)) с значением идентификатора ключа "
"B<KEY_SPEC_REQKEY_AUTH_KEY>."

#.  Should an instantiating program be using KEY_SPEC_REQUESTOR_KEYRING?
#.  I couldn't find a use in the keyutils git repo.
#.  According to David Howells:
#.  * This feature is provided, but not used at the moment.
#.  * A key added to that ring is then owned by the requester
#. type: Plain text
#: man-pages/man2/request_key.2:344
msgid ""
"Instantiates the key (or execs another program that performs that task), "
"specifying the payload and destination keyring.  (The destination keyring "
"that the requestor specified when calling B<request_key>()  can be accessed "
"using the special key ID B<KEY_SPEC_REQUESTOR_KEYRING>.)  Instantiation is "
"performed using the B<keyctl>(2)  B<KEYCTL_INSTANTIATE> operation (or, more "
"commonly, the B<keyctl_instantiate>(3)  function).  At this point, the "
"B<request_key>()  call completes, and the requesting program can continue "
"execution."
msgstr ""
"Создаёт ключ (или выполняет другую программу, которая делает эту работу), с "
"заданной полезной нагрузкой и связкой ключей назначения (связка ключей "
"назначения та, которую запрашивающий указал при вызове B<request_key>(), и "
"которая быть доступна через специальный идентификатор ключа "
"B<KEY_SPEC_REQUESTOR_KEYRING>). Создание выполняется с помощью B<keyctl>() с "
"операцией B<KEYCTL_INSTANTIATE> (или, чаще всего, с помощью функции "
"B<keyctl_instantiate>(3)). На этот момент вызов B<request_key>() завершается "
"и запрашивающая программа может продолжать выполнение."

#. type: Plain text
#: man-pages/man2/request_key.2:361
msgid ""
"If these steps are unsuccessful, then an B<ENOKEY> error will be returned to "
"the caller of B<request_key>()  and a temporary, negatively instantiated key "
"will be installed in the keyring specified by I<dest_keyring>.  This will "
"expire after a few seconds, but will cause subsequent calls to "
"B<request_key>()  to fail until it does.  The purpose of this negatively "
"instantiated key is to prevent (possibly different) processes making "
"repeated requests (that require expensive B<request-key>(8)  upcalls) for a "
"key that can't (at the moment) be positively instantiated."
msgstr ""
"Если какой-то из этих шагов завершается ошибкой, то вызвавшему "
"B<request_key>() возвращается B<ENOKEY> и временно в связку ключей "
"I<dest_keyring> будет установлен отрицательно инициализированный ключ. Он "
"устареет через несколько секунд, но пока этого не произойдёт все последующие "
"вызовы B<request_key>() будут завершаться ошибкой. Целью данного "
"отрицательно инициализированного ключа является предотвращение повторяющихся "
"запросов (возможно разными) процессами (они требуют затратных восходящих "
"вызовов B<request-key>(8)) для ключа, который невозможно (в данный момент) "
"положительно инициализировать."

#. type: Plain text
#: man-pages/man2/request_key.2:369
msgid ""
"Once the key has been instantiated, the authorization key "
"(B<KEY_SPEC_REQKEY_AUTH_KEY>)  is revoked, and the destination keyring "
"(B<KEY_SPEC_REQUESTOR_KEYRING>)  is no longer accessible from the B<request-"
"key>(8)  program."
msgstr ""
"После инициализации ключа, ключ авторизации (B<KEY_SPEC_REQKEY_AUTH_KEY>) "
"отзывается и связка ключей назначения (B<KEY_SPEC_REQUESTOR_KEYRING>) "
"становится недоступной программе B<request-key>(8)."

#. type: Plain text
#: man-pages/man2/request_key.2:374
msgid ""
"If a key is created, then\\(emregardless of whether it is a valid key or a "
"negatively instantiated key\\(emit will displace any other key with the same "
"type and description from the keyring specified in I<dest_keyring>."
msgstr ""
"Если ключ создан, то независимо от какой он — корректный или отрицательно "
"инициализированный — вытеснит любой другой ключ с тем же типом и описанием "
"из связки ключей I<dest_keyring>."

#. type: SH
#: man-pages/man2/request_key.2:374
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/request_key.2:381
msgid ""
"On success, B<request_key>()  returns the serial number of the key it found "
"or caused to be created.  On error, -1 is returned and I<errno> is set to "
"indicate the cause of the error."
msgstr ""
"При успешном выполнении B<request_key>() возвращается серийный номер "
"найденного или созданного ключа. При ошибке возвращается -1, а в I<errno> "
"содержится код ошибки."

#. type: Plain text
#: man-pages/man2/request_key.2:385
msgid "The keyring wasn't available for modification by the user."
msgstr "Изменение связки ключей пользователю недоступно."

#. type: TP
#: man-pages/man2/request_key.2:385
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/request_key.2:389
msgid ""
"The key quota for this user would be exceeded by creating this key or "
"linking it to the keyring."
msgstr ""
"Квота на ключи для данного пользователя была бы превышена, если бы этот ключ "
"создался или был бы прицеплен в связку ключей."

#. type: Plain text
#: man-pages/man2/request_key.2:397
msgid ""
"One of I<type>, I<description>, or I<callout_info> points outside the "
"process's accessible address space."
msgstr ""
"Значение I<type>, I<description> или I<callout_info> указывают вне "
"доступного адресного пространства процесса."

#. type: TP
#: man-pages/man2/request_key.2:397
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/request_key.2:401
msgid "The request was interrupted by a signal; see B<signal>(7)."
msgstr "Запрос был прерван сигналом; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/request_key.2:408
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<type> or I<description> exceeded the limit (32 bytes and 4096 bytes "
"respectively)."
msgstr ""
"Размер строки (включая конечный байт null), заданной в I<type> или "
"I<description>, превышает ограничение (32 байта и 4096 байт, соответственно)."

#. type: Plain text
#: man-pages/man2/request_key.2:413
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<callout_info> exceeded the system page size."
msgstr ""
"Размер строки (включая конечный байт null), заданной в I<callout_info>, "
"превышает размер системной страницы."

#. type: TP
#: man-pages/man2/request_key.2:413
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr "B<EKEYEXPIRED>"

#. type: Plain text
#: man-pages/man2/request_key.2:416
msgid "An expired key was found, but no replacement could be obtained."
msgstr "Найден просроченный ключ, и замена не может быть получена."

#. type: TP
#: man-pages/man2/request_key.2:416
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr "B<EKEYREJECTED>"

#. type: Plain text
#: man-pages/man2/request_key.2:419
msgid "The attempt to generate a new key was rejected."
msgstr "Попытка генерации нового ключа была отвергнута."

#. type: TP
#: man-pages/man2/request_key.2:419
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr "B<EKEYREVOKED>"

#. type: Plain text
#: man-pages/man2/request_key.2:422
msgid "A revoked key was found, but no replacement could be obtained."
msgstr "Найден отозванный ключ, и замена не может быть получена."

#. type: TP
#: man-pages/man2/request_key.2:422
#, no-wrap
msgid "B<ENOKEY>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: man-pages/man2/request_key.2:425
msgid "No matching key was found."
msgstr "Искомый ключ не найден."

#. type: TP
#: man-pages/man2/request_key.2:425
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/request_key.2:428
msgid "Insufficient memory to create a key."
msgstr "Недостаточно памяти для создания ключа."

#. type: Plain text
#: man-pages/man2/request_key.2:433
msgid "The I<type> argument started with a period (\\(aq.\\(aq)."
msgstr "Аргумент I<type> начинается с точки (\\(aq.\\(aq)."

#.  commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
#. type: Plain text
#: man-pages/man2/request_key.2:438
msgid ""
"This system call first appeared in Linux 2.6.10.  The ability to instantiate "
"keys upon request was added in Linux 2.6.13."
msgstr ""
"Данный системный вызов впервые появился в Linux 2.6.10. Возможность "
"инициализации ключей по запросу была добавлена в Linux 2.6.13."

#. type: Plain text
#: man-pages/man2/request_key.2:440
msgid "This system call is a nonstandard Linux extension."
msgstr "Этот системный вызов является нестандартным расширением Linux."

#. type: Plain text
#: man-pages/man2/request_key.2:447
msgid ""
"No wrapper for this system call is provided in glibc.  A wrapper is provided "
"in the I<libkeyutils> package.  When employing the wrapper in that library, "
"link with I<-lkeyutils>."
msgstr ""
"В glibc нет обёрточной функции для этого системного вызова. Такая функция "
"предоставляется пакетом I<libkeyutils>. Для работы с функцией подключите "
"библиотеку с помощью I<-lkeyutils>."

#. type: Plain text
#: man-pages/man2/request_key.2:458
msgid ""
"The program below demonstrates the use of B<request_key>().  The I<type>, "
"I<description>, and I<callout_info> arguments for the system call are taken "
"from the values supplied in the command-line arguments.  The call specifies "
"the session keyring as the target keyring."
msgstr ""
"В программе, представленной ниже, показано использование B<request_key>(). "
"Аргументы I<type>, I<description> и I<callout_info> для системного вызова "
"берутся из значений, переданных в аргументах командной строки. В качестве "
"связки ключей назначения вызов использует связку ключей сеанса."

#. type: Plain text
#: man-pages/man2/request_key.2:462
msgid ""
"In order to demonstrate this program, we first create a suitable entry in "
"the file I</etc/request-key.conf>."
msgstr ""
"Чтобы показать работу программы сначала нужно создать подходящую запись в "
"файле I</etc/request-key.conf>."

#. type: Plain text
#: man-pages/man2/request_key.2:469
#, no-wrap
msgid ""
"$ sudo sh\n"
"# B<echo 'create user mtk:* *   /bin/keyctl instantiate %k %c %S' \\e>\n"
"          B<E<gt> /etc/request-key.conf>\n"
"# B<exit>\n"
msgstr ""
"$ sudo sh\n"
"# B<echo 'create user mtk:* *   /bin/keyctl instantiate %k %c %S' \\e>\n"
"          B<E<gt> /etc/request-key.conf>\n"
"# B<exit>\n"

#. type: Plain text
#: man-pages/man2/request_key.2:496
msgid ""
"This entry specifies that when a new \"user\" key with the prefix \"mtk:\" "
"must be instantiated, that task should be performed via the B<keyctl>(1)  "
"command's B<instantiate> operation.  The arguments supplied to the "
"B<instantiate> operation are: the ID of the uninstantiated key (I<%k>); the "
"callout data supplied to the B<request_key>()  call (I<%c>); and the session "
"keyring (I<%S>)  of the requestor (i.e., the caller of B<request_key>()).  "
"See B<request-key.conf>(5)  for details of these I<%> specifiers."
msgstr ""
"Эта запись говорит о том, что когда должен быть создан новый ключ «user» с "
"префиксом «mtk:», задача должна выполняться посредством команды B<keyctl>(1) "
"с операцией B<instantiate>. Аргументы, передаваемые операции B<instantiate>: "
"идентификатор неинициализированного ключа (I<%k>); исходящие данные, "
"переданные в вызов B<request_key>() (I<%c>); связка ключей сеанса (I<%S>) "
"запрашивающего (т. е., вызывающий B<request_key>()). Описание значений I<%> "
"смотрите в B<request-key.conf>(5)."

#. type: Plain text
#: man-pages/man2/request_key.2:500
msgid ""
"Then we run the program and check the contents of I</proc/keys> to verify "
"that the requested key has been instantiated:"
msgstr ""
"Теперь запускаем программу и проверяем содержимое I</proc/keys>, чтобы "
"удостовериться, что запрашиваемый ключ создан:"

#. type: Plain text
#: man-pages/man2/request_key.2:506
#, no-wrap
msgid ""
"$ B<./t_request_key user mtk:key1 \"Payload data\">\n"
"$ B<grep \\(aq2dddaf50\\(aq /proc/keys>\n"
"2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12\n"
msgstr ""
"$ B<./t_request_key user mtk:key1 \"Payload data\">\n"
"$ B<grep \\(aq2dddaf50\\(aq /proc/keys>\n"
"2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12\n"

#. type: Plain text
#: man-pages/man2/request_key.2:511
msgid "For another example of the use of this program, see B<keyctl>(2)."
msgstr ""
"Другой пример смотрите использования этой программы смотрите в B<keyctl>(2)."

#. type: SS
#: man-pages/man2/request_key.2:511
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/request_key.2:515
#, no-wrap
msgid "/* t_request_key.c */\n"
msgstr "/* t_request_key.c */\n"

#. type: Plain text
#: man-pages/man2/request_key.2:521
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/request_key.2:526
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    key_serial_t key;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    key_serial_t key;\n"

#. type: Plain text
#: man-pages/man2/request_key.2:532
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s type description callout-data\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Использование: %s тип описание callout-data\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/request_key.2:539
#, no-wrap
msgid ""
"    key = request_key(argv[1], argv[2], argv[3],\n"
"                      KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"request_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    key = request_key(argv[1], argv[2], argv[3],\n"
"                      KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"request_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/request_key.2:541
#, no-wrap
msgid "    printf(\"Key ID is %lx\\en\", (long) key);\n"
msgstr "    printf(\"ID ключа = %lx\\en\", (long) key);\n"

#. type: Plain text
#: man-pages/man2/request_key.2:544
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/request_key.2:562
msgid ""
"B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<keyctl>(3), B<capabilities>(7), "
"B<keyrings>(7), B<keyutils>(7), B<persistent-keyring>(7), B<process-"
"keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7), B<request-key>(8)"
msgstr ""
"B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<keyctl>(3), B<capabilities>(7), "
"B<keyrings>(7), B<keyutils>(7), B<persistent-keyring>(7), B<process-"
"keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7), B<user-session-keyring>(7), B<request-key>(8)"

#.  commit b68101a1e8f0263dbc7b8375d2a7c57c6216fb76
#.  commit 3db38ed76890565772fcca3279cc8d454ea6176b
#. type: Plain text
#: man-pages/man2/request_key.2:572
msgid ""
"The kernel source files I<Documentation/security/keys/core.rst> and "
"I<Documentation/keys/request-key.rst> (or, before Linux 4.13, in the files "
"I<Documentation/security/keys.txt> and I<Documentation/security/keys-request-"
"key.txt>)."
msgstr ""
"Файлы исходного кода ядра I<Documentation/security/keys/core.rst> и "
"I<Documentation/keys/request-key.rst> (или, до Linux 4.13, файлы "
"I<Documentation/security/keys.txt> и I<Documentation/security/keys-request-"
"key.txt>)."

#. type: TH
#: man-pages/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr "RECVMMSG"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr "recvmmsg - получает несколько сообщений из сокета"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:42
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:54
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""
"Системный вызов B<recvmmsg>() является расширенной версией B<recvmsg>(2), "
"позволяя вызывающему получать несколько сообщений из сокета, используя "
"только один системный вызов (в некоторых приложениях это позволяет получить "
"выигрыш в производительности). Ещё одно улучшение B<recvmsg>(2) — настройка "
"времени ожидания для операции получения."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:58
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""
"Аргумент I<sockfd> представляет собой файловый дескриптор сокета приёма "
"данных."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:66
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""
"Аргумент I<msgvec> является указателем на массив структур I<mmsghdr>. Размер "
"этого массива указывается в I<vlen>."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:72
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""
"Структура I<mmsghdr> определена в I<E<lt>sys/socket.hE<gt>> следующим "
"образом:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:79
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Заголовок сообщения */\n"
"    unsigned int  msg_len;  /* Количество полученных байт\n"
"                               для заголовка */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:94
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the "
"message in the entry.  This field has the same value as the return value of "
"a single B<recvmsg>(2)  on the header."
msgstr ""
"Поле I<msg_hdr> представляет собой структуру I<msghdr>, которая описана в "
"B<recvmsg>(2). В поле I<msg_len> содержится количество байт возвращаемого "
"сообщения в записи. Это поле имеет такое же значение, что и возвращаемое "
"значение одиночного вызова B<recvmsg>(2) в заголовке."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:101
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""
"Аргумент I<flags> содержит объединённые с помощью OR флаги. Флаги те же, что "
"и у B<recvmsg>(2), но со следующим дополнением:"

#. type: TP
#: man-pages/man2/recvmmsg.2:101
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr "B<MSG_WAITFORONE> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:106
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr "Включить B<MSG_DONTWAIT> после получения первого сообщения."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:121
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation (I<but see BUGS!>).  (This interval will be rounded up to "
"the system clock granularity, and kernel scheduling delays mean that the "
"blocking interval may overrun by a small amount.)  If I<timeout> is NULL, "
"then the operation blocks indefinitely."
msgstr ""
"Аргумент I<timeout> указывает на I<struct timespec> (смотрите "
"B<clock_gettime>(2)), задающую время ожидания (в секундах и наносекундах) "
"операции приёма (I<но смотрите ДЕФЕКТЫ!>; (этот интервал будет округлён до "
"точности системных часов, и из-за задержек планировщика ядра интервал "
"блокировки может быть немного больше). Если I<timeout> равно NULL, то "
"операция блокируется на неопределённое время."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:132
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""
"Блокирование вызова B<recvmmsg>() происходит до тех пор, пока не будет "
"получено I<vlen> сообщений или не истечёт интервал блокировки. Неблокирующий "
"вызов читает все доступные сообщения (максимальное количество указано в "
"I<vlen>) и сразу завершает работу."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:147
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""
"При выходе из B<recvmmsg>() последующие элементы I<msgvec> обновляются "
"информацией о каждом полученном сообщении: в I<msg_len> содержится размер "
"принятого сообщения; подполя I<msg_hdr> обновляются согласно описанию в "
"B<recvmsg>(2). Возвращаемое значение вызова означает количество обновлённых "
"элементов I<msgvec>."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:155
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""
"При успешном выполнении B<recvmmsg>() возвращает количество принятых в "
"I<msgvec> сообщений; при ошибке возвращается -1 и в I<errno> устанавливается "
"код ошибки."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:159
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can occur:"
msgstr ""
"Возникают те же ошибки что и для B<recvmsg>(2). Кроме этого, случается "
"следующая ошибка:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:163
msgid "I<timeout> is invalid."
msgstr "Значение I<timeout> неверно."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:165
msgid "See also BUGS."
msgstr "Также смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:170
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""
"Системный вызов B<recvmmsg>() был добавлен в Linux 2.6.33. Поддержка в glibc "
"появилась в версии 2.12."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:173
msgid "B<recvmmsg>()  is Linux-specific."
msgstr "Вызов B<recvmmsg>() есть только в Linux."

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=75371
#.  http://thread.gmane.org/gmane.linux.man/5677
#. type: Plain text
#: man-pages/man2/recvmmsg.2:184
msgid ""
"The I<timeout> argument does not work as intended.  The timeout is checked "
"only after the receipt of each datagram, so that if up to I<vlen-1> "
"datagrams are received before the timeout expires, but then no further "
"datagrams are received, the call will block forever."
msgstr ""
"Аргумент I<timeout> работает не так, как планировалось. Время ожидания "
"проверяется только после приёма каждой дейтаграммы, поэтому, если до "
"истечения срока будет получено до I<vlen-1> дейтаграмм, но затем дейтаграммы "
"не поступят, то вызов заблокируется навсегда."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:192
msgid ""
"If an error occurs after at least one message has been received, the call "
"succeeds, and returns the number of messages received.  The error code is "
"expected to be returned on a subsequent call to B<recvmmsg>().  In the "
"current implementation, however, the error code can be overwritten in the "
"meantime by an unrelated network event on a socket, for example an incoming "
"ICMP packet."
msgstr ""
"Если ошибка возникает после получения хотя бы одного сообщения, то вызов "
"выполняется успешно и возвращается количество полученных сообщений. Код "
"ошибки будет возвращён следующим вызовом B<recvmmsg>(). Однако в текущей "
"реализации код ошибки может перезаписаться при возникновении в тоже время "
"события, не связанного с сетью, например, из-за поступившего пакета ICMP."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:200
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers "
"are filled or if the timeout specified has expired."
msgstr ""
"Следующая программа использует B<recvmmsg>() для получения нескольких "
"сообщений через сокет и сохранения их в несколько буферов. Вызов завершается "
"при заполнении всех буферов, либо по окончании заданного временного "
"интервала."

#. type: Plain text
#: man-pages/man2/recvmmsg.2:203
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""
"Следующий отрывок периодически генерирует датаграммы UDP с произвольным "
"номером внутри:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:208
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\n"
"B<sleep 0.25; done>\n"
msgstr ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\n"
"B<sleep 0.25; done>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:213
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr "Эти датаграммы читаются примером приложения, который выдаёт:"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:223
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""
"$B< ./a.out>\n"
"5 сообщений получено\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:234
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:247
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval, i;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval, i;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:253
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:261
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:269
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:272
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:278
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:286
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%d сообщений получено\\en\", retval);\n"
"    for (i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/recvmmsg.2:293
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"

#. type: TH
#: man-pages/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr "RT_SIGQUEUEINFO"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:28
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr "rt_sigqueueinfo, rt_tgsigqueueinfo - ставит сигнал и данные в очередь"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:31
#, no-wrap
msgid "B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<uinfo>B<);>\n"
msgstr "B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<uinfo>B<);>\n"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:34
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"
msgstr ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:38
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточных функций для этих системных вызовов; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:50
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or "
"thread.  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""
"Системные вызовы B<rt_sigqueueinfo>() и B<rt_tgsigqueueinfo>() предоставляют "
"низкоуровневый интерфейс для отправки сигнала с данными процессу или нити. "
"Приёмник сигнала может получить сопутствующие данные, установив обработчик "
"сигнала с помощью B<sigaction>(2) с флагом B<SA_SIGINFO>."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:56
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""
"Данные системные вызовы не предназначены для использования непосредственно "
"из приложения; они нужны для реализации библиотечных функций B<sigqueue>(3) "
"и B<pthread_sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:68
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group (i."
"e., one of the threads that is not currently blocking the signal)."
msgstr ""
"Системный вызов B<rt_sigqueueinfo>() отправляет сигнал I<sig> группе нитей с "
"идентификатором I<tgid> (термин «группа нитей» является синонимом «процесс», "
"а I<tid> соответствует обычному идентификатору процесса UNIX). Сигнал будет "
"доставлен произвольному члену группы нитей (т. е., одной из нитей, которая в "
"этот момент не блокирует сигнал)."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:79
msgid ""
"The I<uinfo> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""
"В аргументе I<uinfo> задаются сопутствующие сигналу данные. Этот аргумент "
"является указателем на структуру типа I<siginfo_t>, описанную в "
"B<sigaction>(2) (и определённую в I<E<lt>sigaction.hE<gt>>). Вызывающий "
"должен заполнить следующие поля структуры:"

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:79
#, no-wrap
msgid "I<si_code>"
msgstr "I<si_code>"

#.  tkill(2) or
#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:95
msgid ""
"This must be one of the B<SI_*> codes in the Linux kernel source file "
"I<include/asm-generic/siginfo.h>, with the restriction that the code must be "
"negative (i.e., cannot be B<SI_USER>, which is used by the kernel to "
"indicate a signal sent by B<kill>(2))  and cannot (since Linux 2.6.39) be "
"B<SI_TKILL> (which is used by the kernel to indicate a signal sent using "
"B<tgkill>(2))."
msgstr ""
"Значением должен быть один из кодов B<SI_*>, перечисленных в файле исходного "
"кода ядра Linux I<include/asm-generic/siginfo.h>, имеющих отрицательное "
"значение (т. е., нельзя указать B<SI_USER>, используемый ядром для "
"обозначения того, что сигнал послан B<kill>(2)) и нельзя указать (начиная с "
"Linux 2.6.39) B<SI_TKILL> (используется ядром для обозначения того, что "
"сигнал послан B<tgkill>(2))."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:95
#, no-wrap
msgid "I<si_pid>"
msgstr "I<si_pid>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:99
msgid ""
"This should be set to a process ID, typically the process ID of the sender."
msgstr "Должно хранить идентификатор процесса, обычно PID отправителя."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:99
#, no-wrap
msgid "I<si_uid>"
msgstr "I<si_uid>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:103
msgid ""
"This should be set to a user ID, typically the real user ID of the sender."
msgstr ""
"Должно хранить идентификатор пользователя, обычно UID реального пользователя "
"отправителя."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:103
#, no-wrap
msgid "I<si_value>"
msgstr "I<si_value>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:110
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""
"Это поле хранит пользовательские данные, сопровождающие сигнал. Подробности "
"смотрите в описании последнего аргумента (I<union sigval>) функции "
"B<sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:117
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number "
"via that field."
msgstr ""
"Внутри ядра полю I<si_signo> устанавливается значение, переданное в I<sig>, "
"так что получатель сигнала может также получить его номер через это поле."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:129
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""
"Системный вызов B<rt_tgsigqueueinfo>() похож на B<rt_sigqueueinfo>(), но "
"посылает сигнал и данные одной нити, указываемой комбинацией I<tgid> — "
"идентификатором группы нитей — и I<tid> — нити из этой группы."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:134
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении эти системные вызовы возвращают 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение "
"ошибки."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:141
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""
"Достигнуто ограничение на количество сигналов в очереди (подробней об этом "
"смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:148
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr "Некорректное значение I<sig>, I<tgid> или I<tid>."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:156
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2).  Or: I<uinfo-E<gt>si_code> is "
"invalid."
msgstr ""
"Вызывающий не имеет прав для отправки сигнала по назначению. Требуемые права "
"смотрите в B<kill>(2). Или некорректное значение I<uinfo-E<gt>si_code>."

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:156
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:162
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr "B<rt_sigqueueinfo>(): Группа нитей I<tgid> не найдена."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:169
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr "B<rt_tgsigqueinfo>(): Нить I<tid> из I<tgid> не найдена."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:176
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version 2.6.31."
msgstr ""
"Системный вызов B<rt_sigqueueinfo>() был добавлен в Linux версии 2.2. "
"Системный вызов B<rt_tgsigqueueinfo>() был добавлен в Linux версии 2.6.31."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:178
msgid "These system calls are Linux-specific."
msgstr "Данные системные вызовы есть только в Linux."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:183
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""
"Поскольку системные вызовы не предназначены для приложений, в glibc для них "
"нет обёрточных функций. Используйте B<syscall>(2) в том маловероятном "
"случае, если вы хотите вызывать их напрямую."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:188
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""
"Как и в случае с B<kill>(2), может быть использован сигнал null (0), чтобы "
"проверить, существует ли указанный процесс или нить."

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:195
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/restart_syscall.2:33
#, no-wrap
msgid "RESTART_SYSCALL"
msgstr "RESTART_SYSCALL"

#. type: Plain text
#: man-pages/man2/restart_syscall.2:36
msgid ""
"restart_syscall - restart a system call after interruption by a stop signal"
msgstr ""
"restart_syscall - перезапускает системный вызов после прерывания сигналом "
"останова"

#. type: Plain text
#: man-pages/man2/restart_syscall.2:38
msgid "B<int restart_syscall(void);>"
msgstr "B<int restart_syscall(void);>"

#. type: Plain text
#: man-pages/man2/restart_syscall.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:53
msgid ""
"The B<restart_syscall>()  system call is used to restart certain system "
"calls after a process that was stopped by a signal (e.g., B<SIGSTOP> or "
"B<SIGTSTP>)  is later resumed after receiving a B<SIGCONT> signal.  This "
"system call is designed only for internal use by the kernel."
msgstr ""
"Системный вызов B<restart_syscall>() предназначен для перезапуска некоторых "
"системных вызовов после того, как процесс, остановленный сигналом (например, "
"B<SIGSTOP> или B<SIGTSTP>), продолжил выполнение после получения сигнала "
"B<SIGCONT>. Этот системный вызов создан только для внутреннего использования "
"ядром."

#.  These system calls correspond to the special internal errno value
#.  ERESTART_RESTARTBLOCK. Each of the system calls has a "restart"
#.  helper function that is invoked by restart_syscall().
#.  Notable (as at Linux 3.17) is that poll() has such a "restart"
#.  function, but ppoll(), select(), and pselect() do not.
#.  This means that the latter system calls do not take account of the
#.  time spent in the stopped state when restarting.
#. type: Plain text
#: man-pages/man2/restart_syscall.2:88
msgid ""
"B<restart_syscall>()  is used for restarting only those system calls that, "
"when restarted, should adjust their time-related parameters\\(emnamely "
"B<poll>(2)  (since Linux 2.6.24), B<nanosleep>(2)  (since Linux 2.6), "
"B<clock_nanosleep>(2)  (since Linux 2.6), and B<futex>(2), when employed "
"with the B<FUTEX_WAIT> (since Linux 2.6.22)  and B<FUTEX_WAIT_BITSET> (since "
"Linux 2.6.31)  operations.  B<restart_syscall>()  restarts the interrupted "
"system call with a time argument that is suitably adjusted to account for "
"the time that has already elapsed (including the time where the process was "
"stopped by a signal).  Without the B<restart_syscall>()  mechanism, "
"restarting these system calls would not correctly deduct the already elapsed "
"time when the process continued execution."
msgstr ""
"Вызов B<restart_syscall>() используется только для тех системных вызовов, "
"которые при перезапуске должны обновить свои параметры, относящиеся к "
"времени, а именно — B<poll>(2) (начиная с Linux 2.6.24), B<nanosleep>(2) "
"(начиная с Linux 2.6), B<clock_nanosleep>(2) (начиная с Linux 2.6), "
"B<futex>(2) при использовании с B<FUTEX_WAIT> (начиная с Linux 2.6.22) и "
"B<FUTEX_WAIT_BITSET> (начиная с Linux 2.6.31). Вызов B<restart_syscall>() "
"перезапускает прерванный системный вызов с аргументом времени, который "
"позволят рассчитать прошедшее время (включая время, когда процесс был "
"остановлен сигналом). Без механизма B<restart_syscall>() при перезапуске "
"этих системных вызовов было бы невозможно вычесть правильное время, "
"прошедшее на момент продолжения выполнение процесса."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:92
msgid ""
"The return value of B<restart_syscall>()  is the return value of whatever "
"system call is being restarted."
msgstr ""
"Возвращаемым значением B<restart_syscall>() является возвращаемое значение "
"перезапущенного системного вызова."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:96
msgid ""
"I<errno> is set as per the errors for whatever system call is being "
"restarted by B<restart_syscall>()."
msgstr ""
"Значение I<errno> устанавливается в соответствии с ошибками системного "
"вызова, перезапущенного B<restart_systemcall>()."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:100
msgid "The B<restart_syscall>()  system call is present since Linux 2.6."
msgstr "Системный вызов B<restart_systemcall>() появился в Linux 2.6."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:102
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:106
msgid ""
"There is no glibc wrapper for this system call, because it is intended for "
"use only by the kernel and should never be called by applications."
msgstr ""
"Для этого системного вызова в glibc нет обёрточной функции, потому что он "
"используется только ядром и не должен вызываться приложениями."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:128
msgid ""
"The kernel uses B<restart_syscall>()  to ensure that when a system call is "
"restarted after a process has been stopped by a signal and then resumed by "
"B<SIGCONT>, then the time that the process spent in the stopped state is "
"counted against the timeout interval specified in the original system call.  "
"In the case of system calls that take a timeout argument and automatically "
"restart after a stop signal plus B<SIGCONT>, but which do not have the "
"B<restart_syscall>()  mechanism built in, then, after the process resumes "
"execution, the time that the process spent in the stop state is I<not> "
"counted against the timeout value.  Notable examples of system calls that "
"suffer this problem are B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"Ядро использует B<restart_syscall>() для гарантии того, что когда системный "
"вызов перезапускается после остановки процесса по сигналу и затем "
"возобновляется по B<SIGCONT>, время, которое процесс пробыл в остановленном "
"состоянии будет учтено в интервале ожидания, заданного в первоначальном "
"системном вызове. У системных вызовов, у которых есть аргумент интервала "
"ожидания и которые автоматически перезапускаются после сигнала останова плюс "
"B<SIGCONT>, но которые не имеют встроенного механизма B<restart_syscall>(2), "
"после возобновления работы процесса время, которое процесс пробыл в "
"остановленном состоянии, I<не> учитывается в значении интервала ожидания. "
"Весомыми примерам системных вызовов, которые подвержены этой проблеме, "
"являются B<ppoll>(2), B<select>(2) и B<pselect>(2)."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:135
msgid ""
"From user space, the operation of B<restart_syscall>()  is largely "
"invisible: to the process that made the system call that is restarted, it "
"appears as though that system call executed and returned in the usual "
"fashion."
msgstr ""
"Из пользовательского пространства работа B<restart_syscall>(), в большинстве "
"случаев, невидима: процессу, выполняющему системный вызов, который "
"перезапускался, кажется, что системный вызов выполнился как обычно."

#. type: Plain text
#: man-pages/man2/restart_syscall.2:138
msgid "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"
msgstr "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "READ"
msgstr "READ"

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "2018-02-02"
msgstr "2018-02-02"

#. type: Plain text
#: man-pages/man2/read.2:38
msgid "read - read from a file descriptor"
msgstr "read - читает из файлового дескриптора"

#. type: Plain text
#: man-pages/man2/read.2:41
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/read.2:43
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/read.2:52
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""
"Вызов B<read>() пытается прочитать I<count> байт из файлового дескриптора "
"I<fd> в буфер, начинающийся по адресу I<buf>."

#. type: Plain text
#: man-pages/man2/read.2:60
msgid ""
"On files that support seeking, the read operation commences at the file "
"offset, and the file offset is incremented by the number of bytes read.  If "
"the file offset is at or past the end of file, no bytes are read, and "
"B<read>()  returns zero."
msgstr ""
"Для файлов, поддерживающих смещения, операция чтения начинается с файлового "
"смещения, и файловое смещение увеличивается на количество прочитанных байт. "
"Если файловое смещение находится за концом файла, то ничего не читается и "
"B<read>() возвращает ноль."

#. type: Plain text
#: man-pages/man2/read.2:75
msgid ""
"If I<count> is zero, B<read>()  I<may> detect the errors described below.  "
"In the absence of any errors, or if B<read>()  does not check for errors, a "
"B<read>()  with a I<count> of 0 returns zero and has no other effects."
msgstr ""
"Если значение I<count> равно 0, то B<read>() I<может> обнаружить ошибки, "
"описанные далее. При отсутствии ошибок, или если B<read>() не выполняет "
"проверки, то B<read>() с I<count> равным 0 возвращает 0 и ничего не меняет."

#. type: Plain text
#: man-pages/man2/read.2:82
msgid ""
"According to POSIX.1, if I<count> is greater than B<SSIZE_MAX>, the result "
"is implementation-defined; see NOTES for the upper limit on Linux."
msgstr ""
"В соответствие с POSIX.1, если I<count> больше B<SSIZE_MAX>, то результат "
"зависит от реализации; смотрите ЗАМЕЧАНИЯ по верхнему пределу в Linux."

#. type: Plain text
#: man-pages/man2/read.2:92
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error "
"if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  See also NOTES."
msgstr ""
"При успешном выполнении возвращается количество прочитанных байт (ноль "
"означает конец файла), а позиция в файле увеличивается на это значение. Если "
"количество прочитанных байт меньше, чем количество запрошенных, то это не "
"считается ошибкой: например, это могло произойти из-за того, что прямо "
"сейчас доступно меньшее количество байт (может быть из-за того, что позиция "
"ближе к концу файла, или потому что выполняется чтение из канала или "
"терминала), или потому что работа B<read>() была прервана сигналом. См. "
"также ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/read.2:98
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately.  In this case, "
"it is left unspecified whether the file position (if any) changes."
msgstr ""
"В случае ошибки возвращается -1, а I<errno> устанавливается в "
"соответствующее значение. В этом случае изменение позиции файла остаётся "
"неопределённым (если это вообще происходило)."

#. type: Plain text
#: man-pages/man2/read.2:111
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr ""
"Файловый дескриптор I<fd> указывает на файл, не являющийся сокетом и "
"помеченный как неблокирующий ввод/вывод (B<O_NONBLOCK>), а чтение вызовет "
"блокировку. См. B<open>(2) для дальнейшей информации по флагу B<O_NONBLOCK>."

#. type: TP
#: man-pages/man2/read.2:111
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> или B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/read.2:122
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either error "
"to be returned for this case, and does not require these constants to have "
"the same value, so a portable application should check for both "
"possibilities."
msgstr ""
"Файловый дескриптор I<fd> указывает на сокет и он помечен как неблокирующий "
"(B<O_NONBLOCK>), а чтение вызвало бы блокировку. POSIX.1-2001 позволяет "
"вернуть любую ошибку в этом случае и не требует, чтобы эти константы имели "
"одинаковое значение, поэтому переносимое приложение должно проверять обе эти "
"возможности."

#. type: TP
#: man-pages/man2/read.2:122
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/read.2:126
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""
"I<fd> не является допустимым файловым дескриптором или не открыт на чтение."

#. type: Plain text
#: man-pages/man2/read.2:130
msgid "I<buf> is outside your accessible address space."
msgstr "I<buf> находится за пределами доступного вам адресного пространства."

#. type: Plain text
#: man-pages/man2/read.2:134
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""
"Вызов был прерван сигналом до того как были прочитаны данные; см. "
"B<signal>(7)."

#. type: Plain text
#: man-pages/man2/read.2:145
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr ""
"I<fd> присоединён к объекту, который не подходит для чтения; или файл был "
"открыт с указанием флага B<O_DIRECT>, или неправильно выравнены адрес в "
"I<buf>, значение I<count> или файловое смещение."

#. type: Plain text
#: man-pages/man2/read.2:155
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""
"I<fd> был создан вызовом B<timerfd_create>(2), а в B<read>() был передан "
"неверный размер буфера; подробней см. в B<timerfd_create>(2)."

#. type: TP
#: man-pages/man2/read.2:155
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/read.2:175
msgid ""
"I/O error.  This will happen for example when the process is in a background "
"process group, tries to read from its controlling terminal, and either it is "
"ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may "
"also occur when there is a low-level I/O error while reading from a disk or "
"tape.  A further possible cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""
"Ошибка ввода/вывода. Например, это происходит когда процесс, находящийся в "
"фоновой группе процессов, пытается выполнить чтение из своего управляющего "
"терминала, и игнорирует или блокирует сигнал B<SIGTTIN>, или же его группа "
"процессов осталась без родителя. Это также может случиться, если произошла "
"низкоуровневая ошибка ввода-вывода при чтении с диска или ленты. Также "
"B<EIO> может возникать у сетевых файловых систем, когда консультативная "
"блокировка была убрана у дескриптора файла и потеряна. Подробности смотрите "
"в абзаце I<Потерянные блокировки> в B<fcntl>(2)."

#. type: TP
#: man-pages/man2/read.2:175
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: man-pages/man2/read.2:179
msgid "I<fd> refers to a directory."
msgstr "I<fd> указывает на каталог."

#. type: Plain text
#: man-pages/man2/read.2:182
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""
"В зависимости от объекта, на который указывает I<fd>, могут происходить и "
"другие ошибки."

#. type: Plain text
#: man-pages/man2/read.2:184
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/read.2:191
msgid ""
"The types I<size_t> and I<ssize_t> are, respectively, unsigned and signed "
"integer data types specified by POSIX.1."
msgstr ""
"Типы данных I<size_t> и I<ssize_t> представляющие собой, соответственно, "
"беззнаковый и знаковый целочисленные типы, определены в POSIX.1."

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: man-pages/man2/read.2:199
msgid ""
"On Linux, B<read>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""
"В Linux B<read>() (и похожие системные вызовы) передаст не больше 0x7ffff000 "
"(2 147 479 552) байт, возвращая число байт, переданных на самом деле (это "
"утверждение справедливо как к 32-битным, так и к 64-битным системам)."

#. type: Plain text
#: man-pages/man2/read.2:215
msgid ""
"On NFS filesystems, reading small amounts of data will update the timestamp "
"only the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"I<st_atime> (last file access time)  updates to the server, and client side "
"reads satisfied from the client's cache will not cause I<st_atime> updates "
"on the server as there are no server-side reads.  UNIX semantics can be "
"obtained by disabling client-side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""
"На файловых системах NFS чтение небольших порций данных обновляет отметки "
"времени только в первый раз, последующие вызовы не делают этого. Это вызвано "
"кэшированием атрибутов с клиентской стороны, потому что большинство (если не "
"все) клиентов NFS предоставляют серверу обновлять I<st_atime> (время "
"последнего доступа), а запросы на чтение, которые удовлетворяются из "
"клиентского кэша, не вызывают обновления I<st_atime>, потому что данные не "
"читаются с сервера. Семантика UNIX может быть достигнута запретом "
"кэширования атрибутов на стороне клиента, но в большинстве случаев это "
"увеличит нагрузку на сервер и снизит производительность."

#. type: Plain text
#: man-pages/man2/read.2:218
msgid ""
"According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions "
"with Regular File Operations\"):"
msgstr ""
"Согласно POSIX.1-2008/SUSv4 раздел XSI 2.9.7 («Thread Interactions with "
"Regular File Operations»):"

#. type: Plain text
#: man-pages/man2/read.2:223
msgid ""
"All of the following functions shall be atomic with respect to each other in "
"the effects specified in POSIX.1-2008 when they operate on regular files or "
"symbolic links: ..."
msgstr ""
"Следующие функции должны выполняться атомарно по отношению друг к другу, "
"чтобы работать с обычными файлами или символическими ссылками так, как "
"указано в POSIX.1-2008: …"

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: man-pages/man2/read.2:254
msgid ""
"Among the APIs subsequently listed are B<read>()  and B<readv>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<read>()  (or B<readv>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the reads in the two processes might (incorrectly) "
"overlap in the blocks of data that they obtained.  This problem was fixed in "
"Linux 3.14."
msgstr ""
"Среди перечисленных в программном интерфейсе есть B<read>() и B<readv>(2). И "
"среди действий, которые должны выполняться атомарно между нитями (и "
"процессами), если обновление файлового смещения. Однако в Linux до версии "
"3.14 это было не так: если два процесса с общим открытым файловым описанием "
"(смотрите B<open>(2)) выполняют B<read>() (или B<readv>(2)) одновременно, то "
"операции ввода-вывода не атомарны при обновлении файлового смещения; в "
"результате прочитанные двумя процессами блоки данных могут (некорректно) "
"перекрываться. Эта ошибка исправлена в Linux 3.14."

#. type: Plain text
#: man-pages/man2/read.2:266
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"

#. type: TH
#: man-pages/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr "READAHEAD"

#. type: Plain text
#: man-pages/man2/readahead.2:31
msgid "readahead - initiate file readahead into page cache"
msgstr "readahead - включает упреждающее чтение файла в кэш страниц"

#. type: Plain text
#: man-pages/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/readahead.2:37
#, no-wrap
msgid "B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/readahead.2:44
msgid ""
"B<readahead>()  initiates readahead on a file so that subsequent reads from "
"that file will be satisfied from the cache, and not block on disk I/O "
"(assuming the readahead was initiated early enough and that other activity "
"on the system did not in the meantime flush pages from the cache)."
msgstr ""
"Вызов B<readahead>() включает упреждающее чтение (initiates readahead) из "
"файла таким образом, что последующие операции чтения этого файла будут брать "
"данные их кэша и не блокировать дисковый ввод-вывод (предполагается, что "
"упреждающее чтение началось раньше и что другие действия в системе не "
"выбросили страницы из кэша)."

#. type: Plain text
#: man-pages/man2/readahead.2:66
msgid ""
"The I<fd> argument is a file descriptor identifying the file which is to be "
"read.  The I<offset> argument specifies the starting point from which data "
"is to be read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  The file offset of the open file description referred to by "
"the file descriptor I<fd> is left unchanged."
msgstr ""
"Аргумент I<fd> — это файловый дескриптор файла для чтения. В аргументе "
"I<offset> указывает начальная точка, от которой нужно читать данные и в "
"I<count> задаётся количество читаемых байт. Ввод-вывод выполняется во все "
"страницы, так что I<offset> эффективно округляется в меньшую сторону к "
"границе страницы и байты читаются до границы следующей страницы, большей или "
"равной I<(offset+count)>. Вызов B<readahead>() не выполняет чтения за концом "
"файла. Файловое смещение открытого файлового описания, на который указывает "
"файловый дескриптор I<fd>, остаётся неизменным."

#. type: Plain text
#: man-pages/man2/readahead.2:72
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<readahead>() возвращает 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/readahead.2:83
msgid ""
"I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""
"I<fd> указывает на файл с типом, который нельзя использовать в "
"B<readahead>()."

#. type: Plain text
#: man-pages/man2/readahead.2:88
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""
"Системный вызов B<readahead>() появился в Linux 2.4.13; поддержка в glibc "
"началась с версии 2.3."

#. type: Plain text
#: man-pages/man2/readahead.2:93
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""
"Системный вызов B<readahead>() есть только в Linux, и не должен "
"использоваться в переносимых приложениях."

#. type: Plain text
#: man-pages/man2/readahead.2:98
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""
"На некоторых 32-битных архитектурах интерфейс системного вызова отличается "
"от описанного выше, по причинам указанным в B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/readahead.2:107
msgid ""
"B<readahead>()  attempts to schedule the reads in the background and return "
"immediately.  However, it may block while it reads the filesystem metadata "
"needed to locate the requested blocks.  This occurs frequently with ext[234] "
"on large files using indirect blocks instead of extents, giving the "
"appearance that the call blocks until the requested data has been read."
msgstr ""
"Вызов B<readahead>() пытается запланировать чтение в фоновом режиме и сразу "
"завершается. Однако, он может заблокироваться на время чтения метаданных "
"файловой системы, необходимых для обнаружения запрашиваемых блоков. Это "
"часто происходит  ext[234] для больших файлов, у которых используются "
"косвенные (indirect) блоки вместо непрерывных (extents), что приводит к "
"блокировке вызова на время прочтения нужных данных."

#. type: Plain text
#: man-pages/man2/readahead.2:112
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""
"B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"

#. type: TH
#: man-pages/man2/readlink.2:44
#, no-wrap
msgid "READLINK"
msgstr "READLINK"

#. type: Plain text
#: man-pages/man2/readlink.2:47
msgid "readlink, readlinkat - read value of a symbolic link"
msgstr "readlink, readlinkat - считывает значение символьной ссылки"

#. type: Plain text
#: man-pages/man2/readlink.2:53
#, no-wrap
msgid "B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr "B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:56
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант of AT_* */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:59
#, no-wrap
msgid ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:64
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/readlink.2:68
msgid "B<readlink>():"
msgstr "B<readlink>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/readlink.2:72
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* в версиях glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/readlink.2:75
msgid "B<readlinkat>():"
msgstr "B<readlinkat>():"

#. type: TP
#: man-pages/man2/readlink.2:78
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/readlink.2:81
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/readlink.2:81
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/readlink.2:84
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/readlink.2:101
msgid ""
"B<readlink>()  places the contents of the symbolic link I<pathname> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will (silently) truncate the contents (to a length "
"of I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr ""
"Вызов B<readlink>() помещает содержимое символьной ссылки I<pathname> в "
"буфер I<buf> размером I<bufsiz>. B<readlink>() не добавляет в I<buf> байт "
"null. Если буфер слишком мал для хранения всего содержимого, то содержимое "
"будет урезано (без выдачи ошибки, до длины в I<bufsiz> символов)."

#. type: SS
#: man-pages/man2/readlink.2:101
#, no-wrap
msgid "readlinkat()"
msgstr "readlinkat()"

#. type: Plain text
#: man-pages/man2/readlink.2:107
msgid ""
"The B<readlinkat>()  system call operates in exactly the same way as "
"B<readlink>(), except for the differences described here."
msgstr ""
"Системный вызов B<readlinkat>() работает также как системный вызов "
"B<readlink>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/readlink.2:117
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<readlink>()  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<readlink>())."

#. type: Plain text
#: man-pages/man2/readlink.2:129
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<readlink>())."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<readlink>())."

#. type: Plain text
#: man-pages/man2/readlink.2:135
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: man-pages/man2/readlink.2:149
msgid ""
"Since Linux 2.6.39, I<pathname> can be an empty string, in which case the "
"call operates on the symbolic link referred to by I<dirfd> (which should "
"have been obtained using B<open>(2)  with the B<O_PATH> and B<O_NOFOLLOW> "
"flags)."
msgstr ""
"Начиная с Linux .6.39, I<pathname> может быть пустой строкой; при этом вызов "
"выполняет действие с символьной ссылкой, на которую ссылается I<dirfd> "
"(должна получаться с помощью вызова B<open>(2) с флагами B<O_PATH> и "
"B<O_NOFOLLOW>)."

#. type: Plain text
#: man-pages/man2/readlink.2:154
msgid "See B<openat>(2)  for an explanation of the need for B<readlinkat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<readlinkat>()."

#. type: Plain text
#: man-pages/man2/readlink.2:163
msgid ""
"On success, these calls return the number of bytes placed in I<buf>.  (If "
"the returned value equals I<bufsiz>, then truncation may have occurred.)  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении эти вызовы возвращают количество байт, помещённых в "
"I<buf> (если возвращаемое значение равно I<bufsiz>, то возможно произошло "
"обрезание). В случае ошибки возвращается -1, а I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/readlink.2:169
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"В одном из каталогов префикса пути не разрешён поиск (см. также "
"B<path_resolution>(7)."

#. type: Plain text
#: man-pages/man2/readlink.2:173
msgid "I<buf> extends outside the process's allocated address space."
msgstr ""
"I<buf> выходит за пределы адресного пространства, выделенного процессу."

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: man-pages/man2/readlink.2:182
msgid "I<bufsiz> is not positive."
msgstr "Аргумент I<bufsiz> содержит отрицательное значение."

#. type: Plain text
#: man-pages/man2/readlink.2:187
msgid ""
"The named file (i.e., the final filename component of I<pathname>)  is not a "
"symbolic link."
msgstr ""
"Указанный файл (т. е., последний компонент имени файла I<pathname>) не "
"является символьной ссылкой."

#. type: Plain text
#: man-pages/man2/readlink.2:190
msgid "An I/O error occurred while reading from the filesystem."
msgstr "При чтении файловой системы произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/readlink.2:190
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/readlink.2:193
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""
"Во время определения pathname встретилось слишком много символьных ссылок."

#. type: TP
#: man-pages/man2/readlink.2:193
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/readlink.2:196
msgid "A pathname, or a component of a pathname, was too long."
msgstr "Слишком длинное значение аргумента pathname или его части."

#. type: TP
#: man-pages/man2/readlink.2:196
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/readlink.2:199
msgid "The named file does not exist."
msgstr "Указанный файл не существует."

#. type: Plain text
#: man-pages/man2/readlink.2:202
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: TP
#: man-pages/man2/readlink.2:202 man-pages/man2/readlink.2:212
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/readlink.2:205
msgid "A component of the path prefix is not a directory."
msgstr "Компонент в префиксе пути не является каталогом."

#. type: Plain text
#: man-pages/man2/readlink.2:208
msgid "The following additional errors can occur for B<readlinkat>():"
msgstr "В B<readlinkat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/readlink.2:212
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/readlink.2:218
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/readlink.2:222
msgid ""
"B<readlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Системный вызов B<readlinkat>() был добавлен в ядро Linux версии 2.6.16; "
"поддержка в glibc доступна с версии 2.4."

#. type: Plain text
#: man-pages/man2/readlink.2:228
msgid ""
"B<readlink>(): 4.4BSD (B<readlink>()  first appeared in 4.2BSD), "
"POSIX.1-2001, POSIX.1-2008."
msgstr ""
"B<readlink>(): 4.4BSD (B<readlink>() появился в 4.2BSD), POSIX.1-2001, "
"POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/readlink.2:231
msgid "B<readlinkat>(): POSIX.1-2008."
msgstr "B<readlinkat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/readlink.2:239
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""
"В версиях glibc до glibc 2.4 включительно, тип результата B<readlink>() был "
"объявлен как I<int>. В настоящее время типом возвращаемого результата "
"является I<ssize_t>, как (теперь) это требуется по POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/readlink.2:262
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  and "
"B<readlinkat>()  should be checked to make sure that the size of the "
"symbolic link did not increase between the calls.  Dynamically allocating "
"the buffer for B<readlink>()  and B<readlinkat>()  also addresses a common "
"portability problem when using I<PATH_MAX> for the buffer size, as this "
"constant is not guaranteed to be defined per POSIX if the system does not "
"have such limit."
msgstr ""
"Буфера с фиксированным размером может не хватить для хранения содержимого "
"символьной ссылки. Требуемый размер буфера можно получить как значение "
"I<stat.st_size>, возвращаемое на ссылку вызовом B<lstat>(2). Однако, "
"количество байт, записанное B<readlink>() и B<readlinkat>(), должно быть "
"проверено, так как требуется убедиться, что размер символьной ссылки не "
"увеличился между вызовами. Динамическое выделение буфера для B<readlink>() и "
"B<readlinkat>() также поможет решить проблему с переносимостью, которая "
"возникает, когда для размера буфера используется I<PATH_MAX>, но согласно "
"POSIX для этой константы не гарантируется, что она определена , если система "
"не имеет такого ограничения."

#. type: SS
#: man-pages/man2/readlink.2:262
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#. type: Plain text
#: man-pages/man2/readlink.2:275
msgid ""
"On older kernels where B<readlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<readlink>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"В старых ядрах, где B<readlinkat>() отсутствует, обёрточная функция glibc "
"использует B<readlink>(). Если I<pathname> является относительным путём, то "
"glibc собирает путь относительно символической ссылки в I</proc/self/fd>, "
"которая соответствует аргументу I<dirfd>."

#. type: Plain text
#: man-pages/man2/readlink.2:285
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(2), falling back to a "
"buffer of size B<PATH_MAX> in cases where B<lstat>(2)  reports a size of "
"zero."
msgstr ""
"Следующая программа динамически выделяет буфер, необходимый B<readlink>(), "
"из информации, предоставленной B<lstat>(2), или использует буфер размером "
"B<PATH_MAX>, если B<lstat>(2) вернул нулевой размер."

#. type: Plain text
#: man-pages/man2/readlink.2:293
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/readlink.2:300
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"

#. type: Plain text
#: man-pages/man2/readlink.2:305
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>путьE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:310
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:313
#, no-wrap
msgid ""
"    /* Add one to the link size, so that we can determine whether\n"
"       the buffer returned by readlink() was truncated. */\n"
msgstr ""
"    /* Добавляем единицу к размеру ссылки, так чтобы можно было определить\n"
"       обрезанность буфера, возвращаемого readlink(). */\n"

#. type: Plain text
#: man-pages/man2/readlink.2:315
#, no-wrap
msgid "    bufsiz = sb.st_size + 1;\n"
msgstr "    bufsiz = sb.st_size + 1;\n"

#. type: Plain text
#: man-pages/man2/readlink.2:319
#, no-wrap
msgid ""
"    /* Some magic symlinks under (for example) /proc and /sys\n"
"       report \\(aqst_size\\(aq as zero. In that case, take PATH_MAX as\n"
"       a \"good enough\" estimate. */\n"
msgstr ""
"    /* У некоторых символьных ссылок в (например) /proc и /sys\n"
"       значение \\(aqst_size\\(aq равно нулю. В этом случае используется\n"
"       PATH_MAX как «достаточный» размер. */\n"

#. type: Plain text
#: man-pages/man2/readlink.2:322
#, no-wrap
msgid ""
"    if (sb.st_size == 0)\n"
"        bufsiz = PATH_MAX;\n"
msgstr ""
"    if (sb.st_size == 0)\n"
"        bufsiz = PATH_MAX;\n"

#. type: Plain text
#: man-pages/man2/readlink.2:328
#, no-wrap
msgid ""
"    buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:334
#, no-wrap
msgid ""
"    nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/readlink.2:336
#, no-wrap
msgid "    printf(\"\\(aq%s\\(aq points to \\(aq%.*s\\(aq\\en\", argv[1], (int) nbytes, buf);\n"
msgstr "    printf(\"\\(aq%s\\(aq указывает на \\(aq%.*s\\(aq\\en\", argv[1], (int) nbytes, buf);\n"

#. type: Plain text
#: man-pages/man2/readlink.2:342
#, no-wrap
msgid ""
"    /* If the return value was equal to the buffer size, then the\n"
"       the link target was larger than expected (perhaps because the\n"
"       target was changed between the call to lstat() and the call to\n"
"       readlink()). Warn the user that the returned target may have\n"
"       been truncated. */\n"
msgstr ""
"    /* Если возвращаемое значение равно размеру буфера, то\n"
"       ссылка назначения больше чем ожидалось (возможно, из-за того,\n"
"       что цель изменилась между вызовом lstat() и readlink()).\n"
"       Предупреждаем пользователя о том, что цель может быть\n"
"       обрезана. */\n"

#. type: Plain text
#: man-pages/man2/readlink.2:345
#, no-wrap
msgid ""
"    if (nbytes == bufsiz)\n"
"        printf(\"(Returned buffer may have been truncated)\\en\");\n"
msgstr ""
"    if (nbytes == bufsiz)\n"
"        printf(\"(Возвращённый буфер мог быть обрезан)\\en\");\n"

#. type: Plain text
#: man-pages/man2/readlink.2:349
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/readlink.2:357
msgid ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr "REMAP_FILE_PAGES"

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr "remap_file_pages - создаёт нелинейное файловое отображение"

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"

#.  commit 33041a0d76d3c3e0aff28ac95a2ffdedf1282dbc
#.  http://lwn.net/Articles/597632/
#.  commit c8d78c1823f46519473949d33f0d1d33fe21ea16
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:53
msgid ""
"B<Note>: this system call was marked as deprecated starting with Linux "
"3.16.  In Linux 4.0, the implementation was replaced by a slower in-kernel "
"emulation.  Those few applications that use this system call should consider "
"migrating to alternatives.  This change was made because the kernel code for "
"this system call was complex, and it is believed to be little used or "
"perhaps even completely unused.  While it had some use cases in database "
"applications on 32-bit systems, those use cases don't exist on 64-bit "
"systems."
msgstr ""
"B<Замечание>: данный системный вызов, начиная с Linux 3.16, устарел. В Linux "
"4.0 реализация была заменена на более медленную эмуляцию ядром. В "
"приложениях, где он используется, нужно применять альтернативные вызовы. "
"Данное изменение было сделано из-за сложности кода ядра этого системного "
"вызова, и считается, что им почти никто или вообще никто не пользуется. "
"Какое-то время он использовался в приложениях баз данных на 32-разрядных "
"системах, но этих вариантов использования на 64-разрядных системах замечено "
"не было."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:65
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using "
"B<remap_file_pages>()  over using repeated calls to B<mmap>(2)  is that the "
"former approach does not require the kernel to create additional VMA "
"(Virtual Memory Area) data structures."
msgstr ""
"Системный вызов B<remap_file_pages>() используется для создания нелинейного "
"отображения, то есть отображения, в котором страницы файла отображаются в "
"память непоследовательно. Преимущество использования B<remap_file_pages>() "
"по сравнению с повторением вызовов B<mmap>(2) в том, что первый не требует "
"от ядра создания дополнительных структур данных VMA (областей виртуальной "
"памяти)."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:67
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr "Для создания нелинейного отображения выполните следующее:"

#. type: TP
#: man-pages/man2/remap_file_pages.2:67
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:75
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""
"Создайте отображение (пока линейное) с помощью B<mmap>(2). Данное "
"отображение должно создаваться с флагом B<MAP_SHARED>."

#. type: TP
#: man-pages/man2/remap_file_pages.2:75
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:83
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""
"Выполните переупорядочивание соответствия между страницами отображения и "
"страницами файла с помощью одного или нескольких вызовов "
"B<remap_file_pages>(). Возможно отображать одну страницу файла в несколько "
"мест отображаемой области."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:94
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""
"В аргументах I<pgoff> и I<size> указывается область файла, которая будет "
"перенесёна  в отображение: в I<pgoff> задаётся смещение в файле, измеряемое "
"в размерах системных страниц; в I<size> задаётся длина области в байтах."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:112
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""
"Аргумент I<addr> предназначен для двух целей. Во-первых, им определяется "
"отображение, чьи страницы мы хотим перенести. То есть в I<addr> должен быть "
"указан адрес в области, которая была ранее отображена с помощью вызова "
"B<mmap>(2). Во-вторых, в I<addr> указывается адрес, по которому должны быть "
"помещены файловые страницы, заданные I<pgoff> и I<size>."

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:126
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""
"Значения, указанные в I<addr> и I<size>, должны быть кратны размеру "
"системной страницы. Если это не так, то ядро округляет I<оба> значения I<в "
"меньшую сторону> до ближайшего числа, кратного размеру страницы."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:130
msgid "The I<prot> argument must be specified as 0."
msgstr "Значение аргумента I<prot> должно быть 0."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:138
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""
"Аргумент I<flags> предназначен для того же, что и в B<mmap>(2), но все "
"флаги, кроме B<MAP_NONBLOCK>, игнорируются."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:145
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При удачном выполнении B<remap_file_pages>() возвращается 0. При ошибке "
"возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:153
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""
"Значение I<addr> не ссылается на допустимое отображение, созданное с флагом "
"B<MAP_SHARED>."

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:162
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr "Некорректное значение в I<addr>, I<size>, I<prot> или I<pgoff>."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:167
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""
"Системный вызов B<remap_file_pages>() появился в Linux 2.5.46; поддержка в "
"glibc началась с версии 2.3.3."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:171
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr "Системный вызов B<remap_file_pages>() есть только в Linux."

#.  commit 3ee6dafc677a68e461a7ddafc94a580ebab80735
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:184
msgid ""
"Since Linux 2.6.23, B<remap_file_pages>()  creates non-linear mappings only "
"on in-memory filesystems such as B<tmpfs>(5), hugetlbfs or ramfs.  On "
"filesystems with a backing store, B<remap_file_pages>()  is not much more "
"efficient than using B<mmap>(2)  to adjust which parts of the file are "
"mapped to which addresses."
msgstr ""
"Начиная с Linux 2.6.23, B<remap_file_pages>() создаёт нелинейные отображения "
"только для файловых систем в оперативной памяти, таких как B<tmpfs>(5), "
"hugetlbfs или ramfs. Для файловых систем с хранилищем B<remap_file_pages>() "
"не намного эффективнее чем B<mmap>(2), так как рассчитывает адреса для "
"частей файла."

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:190
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"

#. type: TH
#: man-pages/man2/rename.2:33
#, no-wrap
msgid "RENAME"
msgstr "RENAME"

#. type: Plain text
#: man-pages/man2/rename.2:36
msgid "rename, renameat, renameat2 - change the name or location of a file"
msgstr "rename, renameat, renameat2 - изменяет имя или расположение файла"

#. type: Plain text
#: man-pages/man2/rename.2:39
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/rename.2:41
#, no-wrap
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/rename.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант AT_* */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/rename.2:47
#, no-wrap
msgid ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"
msgstr ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/rename.2:51
#, no-wrap
msgid ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/rename.2:59
msgid "B<renameat>():"
msgstr "B<renameat>():"

#. type: Plain text
#: man-pages/man2/rename.2:71
msgid "B<renameat2>():"
msgstr "B<renameat2>():"

#. type: TP
#: man-pages/man2/rename.2:72
#, no-wrap
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/rename.2:86
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any "
"other hard links to the file (as created using B<link>(2))  are unaffected.  "
"Open file descriptors for I<oldpath> are also unaffected."
msgstr ""
"Вызов B<rename>() переименовывает файл и, если требуется, перемещает его из "
"одного каталога в другой. Все прочие жёсткие ссылки на файл (созданные с "
"помощью B<link>(2)), не изменяются. Открытые файловые дескрипторы на "
"I<oldpath> также не изменяются."

#. type: Plain text
#: man-pages/man2/rename.2:89
msgid ""
"Various restrictions determine whether or not the rename operation succeeds: "
"see ERRORS below."
msgstr ""
"На успешность выполнения операции переименования влияют различные "
"ограничения: смотрите ОШИБКИ далее."

#. type: Plain text
#: man-pages/man2/rename.2:101
msgid ""
"If I<newpath> already exists, it will be atomically replaced, so that there "
"is no point at which another process attempting to access I<newpath> will "
"find it missing.  However, there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""
"Если I<newpath> уже существует, то он будет атомарно перезаписан так, что "
"другой процесс, пытающийся в этот момент обратиться к I<newpath>, не сможет "
"определить его временное отсутствие. Однако будет промежуток времени, когда "
"I<oldpath> и I<newpath> указывают на один файл."

#. type: Plain text
#: man-pages/man2/rename.2:109
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""
"Если I<oldpath> и I<newpath> являются жёсткими ссылками на один и тот же "
"файл, то B<rename>() ничего не делает и возвращает код успешного выполнения."

#. type: Plain text
#: man-pages/man2/rename.2:117
msgid ""
"If I<newpath> exists but the operation fails for some reason, B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""
"Если I<newpath> существует, но операция завершается ошибкой, то B<rename>() "
"гарантирует, что I<newpath> останется нетронутым."

#. type: Plain text
#: man-pages/man2/rename.2:123
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""
"В I<oldpath> может быть указан каталог. В этом случае каталог в I<newpath> "
"должен или не существовать, или должен быть пуст."

#. type: Plain text
#: man-pages/man2/rename.2:129
msgid ""
"If I<oldpath> refers to a symbolic link, the link is renamed; if I<newpath> "
"refers to a symbolic link, the link will be overwritten."
msgstr ""
"Если I<oldpath> является символьной ссылкой, то она переименовывается; если "
"I<newpath> является символьной ссылкой, то будет вновь записан файл, на "
"который она указывает."

#. type: SS
#: man-pages/man2/rename.2:129
#, no-wrap
msgid "renameat()"
msgstr "renameat()"

#. type: Plain text
#: man-pages/man2/rename.2:135
msgid ""
"The B<renameat>()  system call operates in exactly the same way as "
"B<rename>(), except for the differences described here."
msgstr ""
"Системный вызов B<renameat>() работает также как системный вызов "
"B<rename>(), за исключением случаев, описанных далее."

#. type: Plain text
#: man-pages/man2/rename.2:145
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<rename>()  for a relative pathname)."
msgstr ""
"Если в I<oldpath> указан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<olddirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<rename>())."

#. type: Plain text
#: man-pages/man2/rename.2:157
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<rename>())."
msgstr ""
"Если в I<oldpath> указан относительный путь и I<olddirfd> равно специальному "
"значению B<AT_FDCWD>, то I<oldpath> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<rename>())."

#. type: Plain text
#: man-pages/man2/rename.2:163
msgid "If I<oldpath> is absolute, then I<olddirfd> is ignored."
msgstr "Если в I<oldpath> указан абсолютный путь, то I<olddirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/rename.2:171
msgid ""
"The interpretation of I<newpath> is as for I<oldpath>, except that a "
"relative pathname is interpreted relative to the directory referred to by "
"the file descriptor I<newdirfd>."
msgstr ""
"Значение I<newpath> интерпретируется как I<oldpath>, за исключением того, "
"что относительный путь интерпретируется относительно каталога, на который "
"ссылается файловый дескриптор I<newdirfd>."

#. type: Plain text
#: man-pages/man2/rename.2:176
msgid "See B<openat>(2)  for an explanation of the need for B<renameat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<renameat>()."

#. type: SS
#: man-pages/man2/rename.2:176
#, no-wrap
msgid "renameat2()"
msgstr "renameat2()"

#. type: Plain text
#: man-pages/man2/rename.2:187
msgid ""
"B<renameat2>()  has an additional I<flags> argument.  A B<renameat2>()  call "
"with a zero I<flags> argument is equivalent to B<renameat>()."
msgstr ""
"Вызов B<renameat2>() имеет дополнительный аргумент I<flags>. Если значение "
"I<flags> равно нулю, то B<renameat2>() эквивалентен B<renameat>()."

#. type: Plain text
#: man-pages/man2/rename.2:191
msgid ""
"The I<flags> argument is a bit mask consisting of zero or more of the "
"following flags:"
msgstr ""
"Аргумент I<flags> является битовой маской, состоящей из нуля или более "
"следующих флагов:"

#. type: TP
#: man-pages/man2/rename.2:191
#, no-wrap
msgid "B<RENAME_EXCHANGE>"
msgstr "B<RENAME_EXCHANGE>"

#. type: Plain text
#: man-pages/man2/rename.2:200
msgid ""
"Atomically exchange I<oldpath> and I<newpath>.  Both pathnames must exist "
"but may be of different types (e.g., one could be a non-empty directory and "
"the other a symbolic link)."
msgstr ""
"Атомарно обменять I<oldpath> и I<newpath>. Оба пути должны существовать, но "
"могут быть различных типов (например, один может быть непустым каталогом, а "
"другой символической ссылкой)."

#. type: TP
#: man-pages/man2/rename.2:200
#, no-wrap
msgid "B<RENAME_NOREPLACE>"
msgstr "B<RENAME_NOREPLACE>"

#. type: Plain text
#: man-pages/man2/rename.2:208
msgid ""
"Don't overwrite I<newpath> of the rename.  Return an error if I<newpath> "
"already exists."
msgstr ""
"Не перезаписывать I<newpath>. Возвращать ошибку, если I<newpath> уже "
"существует."

#. type: Plain text
#: man-pages/man2/rename.2:212
msgid "B<RENAME_NOREPLACE> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""
"B<RENAME_NOREPLACE> не может быть применен вместе с B<RENAME_EXCHANGE>."

#. type: Plain text
#: man-pages/man2/rename.2:216
msgid ""
"B<RENAME_NOREPLACE> requires support from the underlying filesystem.  "
"Support for various filesystems was added as follows:"
msgstr ""
"Для B<RENAME_NOREPLACE> требуется поддержка в файловой системе; она есть "
"только у нескольких файловых систем:"

#.  ext4: commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c
#. type: Plain text
#: man-pages/man2/rename.2:220
msgid "ext4 (Linux 3.15);"
msgstr "ext4 (начиная с Linux 3.15);"

#. type: Plain text
#: man-pages/man2/rename.2:222
msgid "btrfs, shmem, and cifs (Linux 3.17);"
msgstr "btrfs, shmem, и cifs (начиная с Linux 3.17);"

#.  btrfs: commit 80ace85c915d0f41016f82917218997b72431258
#.  shmem: commit 3b69ff51d087d265aa4af3a532fc4f20bf33e718
#.  cifs: commit 7c33d5972ce382bcc506d16235f1e9b7d22cbef8
#.  gfs2 in 4.2?
#. type: Plain text
#: man-pages/man2/rename.2:229
msgid "xfs (Linux 4.0);"
msgstr "xfs (начиная с Linux 4.0);"

#.  Also affs, bfs, exofs, hfs, hfsplus, jffs2, logfs, msdos,
#.  nilfs2, omfs, sysvfs, ubifs, udf, ufs
#.  hugetlbfs, ramfs
#.  local filesystems: commit f03b8ad8d38634d13e802165cc15917481b47835
#.  libfs: commit e0e0be8a835520e2f7c89f214dfda570922a1b90
#. type: Plain text
#: man-pages/man2/rename.2:237
msgid ""
"Support for many other filesystems was added in Linux 4.9, including etx2, "
"minix, reiserfs, jfs, vfat, and bpf."
msgstr ""
"Поддержка для других файловых систем была добавлена в Linux 4.9: etx2, "
"minix, reiserfs, jfs, vfat и bpf."

#. type: TP
#: man-pages/man2/rename.2:238
#, no-wrap
msgid "B<RENAME_WHITEOUT> (since Linux 3.18)"
msgstr "B<RENAME_WHITEOUT> (начиная с Linux 3.18)"

#.  commit 0d7a855526dd672e114aff2ac22b60fc6f155b08
#.  commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
#. type: Plain text
#: man-pages/man2/rename.2:244
msgid ""
"This operation makes sense only for overlay/union filesystem implementations."
msgstr ""
"Эта операция применима только для реализаций оверлейных/объединённых "
"файловых систем."

#. type: Plain text
#: man-pages/man2/rename.2:251
msgid ""
"Specifying B<RENAME_WHITEOUT> creates a \"whiteout\" object at the source of "
"the rename at the same time as performing the rename.  The whole operation "
"is atomic, so that if the rename succeeds then the whiteout will also have "
"been created."
msgstr ""
"При указании B<RENAME_WHITEOUT> для источника переименования одновременно с "
"выполнением переименования создаётся «замазанный» объект (whiteout object). "
"Вся операция атомарна, и при успешном выполнении переименования создаётся и "
"замазка."

#. type: Plain text
#: man-pages/man2/rename.2:259
msgid ""
"A \"whiteout\" is an object that has special meaning in union/overlay "
"filesystem constructs.  In these constructs, multiple layers exist and only "
"the top one is ever modified.  A whiteout on an upper layer will effectively "
"hide a matching file in the lower layer, making it appear as if the file "
"didn't exist."
msgstr ""
"«Замазка» — это объект, имеющий специальное предназначение в оверлейных/"
"объединённых файловых системах. В них существует несколько слоёв, и для "
"изменения доступен только верхний. Замазка на верхнем слое эффективно "
"скрывает файл из нижнего слоя, и кажется, что файл не существует."

#. type: Plain text
#: man-pages/man2/rename.2:267
msgid ""
"When a file that exists on the lower layer is renamed, the file is first "
"copied up (if not already on the upper layer)  and then renamed on the "
"upper, read-write layer.  At the same time, the source file needs to be "
"\"whiteouted\" (so that the version of the source file in the lower layer is "
"rendered invisible).  The whole operation needs to be done atomically."
msgstr ""
"Когда переименовывается файл, существующий в нижнем слое, то первым "
"действием он переписывается (если его уже нет в верхнем слое) и "
"переименовывается в верхнем, доступном на чтение-запись слое. Одновременно с "
"этим, исходный файл требуется «замазать» (что исходный файл в нижнем слое "
"отражался невидимым). Вся операция должна выполняться атомарно."

#.  https://www.freebsd.org/cgi/man.cgi?query=mount_unionfs&manpath=FreeBSD+11.0-RELEASE
#. type: Plain text
#: man-pages/man2/rename.2:278
msgid ""
"When not part of a union/overlay, the whiteout appears as a character device "
"with a {0,0} device number.  (Note that other union/overlay implementations "
"may employ different methods for storing whiteout entries; specifically, BSD "
"union mount employs a separate inode type, B<DT_WHT>, which, while supported "
"by some filesystems available in Linux, such as CODA and XFS, is ignored by "
"the kernel's whiteout support code, as of Linux 4.19, at least.)"
msgstr ""
"При отсутствии объединения/оверлея замазка появляется в виде символьного "
"устройства с номером устройства {0,0} (заметим, что в других реализациях "
"объединения/оверлея могут использоваться другие методы хранения элементов "
"замазки; в частности, в BSD для объединения монтирования используется "
"специальный тип иноды, B<DT_WHT>, который, хотя и поддерживается некоторыми "
"файловыми системами, доступными в Linux, например CODA и XFS, но "
"игнорируется кодом поддержки замазки в ядре, по крайней мере, в Linux 4.19)."

#. type: Plain text
#: man-pages/man2/rename.2:283
msgid ""
"B<RENAME_WHITEOUT> requires the same privileges as creating a device node (i."
"e., the B<CAP_MKNOD> capability)."
msgstr ""
"Для B<RENAME_WHITEOUT> требуются те же права, что и для создания узла "
"устройства (т. е., мандата B<CAP_MKNOD>)."

#. type: Plain text
#: man-pages/man2/rename.2:287
msgid "B<RENAME_WHITEOUT> can't be employed together with B<RENAME_EXCHANGE>."
msgstr "B<RENAME_WHITEOUT> не может быть применён вместе с B<RENAME_EXCHANGE>."

#.  tmpfs: commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df
#.  ext4: commit cd808deced431b66b5fa4e5c193cb7ec0059eaff
#.  XFS: commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00
#.  f2fs: commit 7e01e7ad746bc8198a8b46163ddc73a1c7d22339
#.  btrfs: commit cdd1fedf8261cd7a73c0596298902ff4f0f04492
#.  ubifs: commit 9e0a1fff8db56eaaebb74b4a3ef65f86811c4798
#. type: Plain text
#: man-pages/man2/rename.2:303
msgid ""
"B<RENAME_WHITEOUT> requires support from the underlying filesystem.  Among "
"the filesystems that provide that support are tmpfs (since Linux 3.18), ext4 "
"(since Linux 3.18), XFS (since Linux 4.1), f2fs (since Linux 4.2).  btrfs "
"(since Linux 4.7), and ubifs (since Linux 4.9)."
msgstr ""
"Для B<RENAME_WHITEOUT> требуется поддержка в файловой системе. Такая "
"поддержка имеется в tmpfs (начиная с Linux 3.18), ext4 (начиная с Linux "
"3.18), XFS (начиная с Linux 4.1), f2fs (начиная с Linux 4.2), btrfs (начиная "
"с Linux 4.7) и ubifs (начиная с Linux 4.9)."

#. type: Plain text
#: man-pages/man2/rename.2:308
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/rename.2:328
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""
"Запись в каталог, содержащий I<oldpath> или I<newpath>, запрещена, или в "
"одном из каталогов пути I<oldpath> или I<newpath> нельзя производить поиск, "
"или I<oldpath> является каталогом, в который запрещена запись (требует "
"обновления элемента I<..>); смотрите также B<path_resolution>(7))."

#. type: TP
#: man-pages/man2/rename.2:328
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/rename.2:345
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such cases"
"\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""
"Переименование завершилось неудачно, так как I<oldpath> или I<newpath> "
"является каталогом, который используется другим процессом (возможно в "
"качестве текущего рабочего каталога или в качестве корневого каталога, или "
"он открыт на чтение), или используется системой (например, в качестве точки "
"монтирования), и система считает это ошибкой (заметим, что нет требования "
"возвращать B<EBUSY> в таких случаях — нет ничего неправильного в таком "
"переименовании — но разрешается возвращать B<EBUSY>, если система не может "
"иначе обработать такие ситуации)."

#. type: Plain text
#: man-pages/man2/rename.2:348
msgid "The user's quota of disk blocks on the filesystem has been exhausted."
msgstr "Исчерпана пользовательская квота на дисковые блоки файловой системы."

#. type: Plain text
#: man-pages/man2/rename.2:351
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""
"Значения I<oldpath> и I<newpath> указывают за пределы доступного адресного "
"пространства."

#. type: Plain text
#: man-pages/man2/rename.2:355
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""
"Новый путь содержит префикс старого пути или, в более общем смысле, "
"выполняется попытка сделать каталог подкаталогом самого себя."

#. type: Plain text
#: man-pages/man2/rename.2:361
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""
"Каталог I<newpath> уже существует, но I<oldpath> не является каталогом."

#. type: Plain text
#: man-pages/man2/rename.2:365
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""
"Во время определения I<oldpath> или I<newpath> встретилось слишком много "
"символьных ссылок."

#. type: TP
#: man-pages/man2/rename.2:365
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: man-pages/man2/rename.2:372
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""
"В I<oldpath> уже имеется максимальное количество ссылок, или каталог, "
"содержащий I<newpath>, уже имеет максимальное количество ссылок."

#. type: Plain text
#: man-pages/man2/rename.2:375
msgid "I<oldpath> or I<newpath> was too long."
msgstr "Слишком длинное значение аргумента I<oldpath> или I<newpath>."

#. type: Plain text
#: man-pages/man2/rename.2:388
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""
"Ссылка, на которую ссылается I<oldpath>, не существует; компонент каталога в "
"I<newpath> не существует; в I<oldpath> или I<newpath> указана пустая строка."

#. type: TP
#: man-pages/man2/rename.2:391
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/rename.2:395
msgid "The device containing the file has no room for the new directory entry."
msgstr ""
"На устройстве, содержащем файл, нет места для создания нового элемента "
"каталога."

#. type: Plain text
#: man-pages/man2/rename.2:405
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""
"Компонент, используемый как каталог в I<oldpath> или I<newpath>, в "
"действительности не является каталогом. Или I<oldpath> является каталогом и "
"существует I<newpath>, который не является каталогом."

#. type: TP
#: man-pages/man2/rename.2:405
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr "B<ENOTEMPTY> или B<EEXIST>"

#. type: Plain text
#: man-pages/man2/rename.2:409
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than \"."
"\" and \"..\"."
msgstr ""
"Значение I<newpath> является непустым каталогом, то есть содержит элементы, "
"отличные от «.» и «..»."

#. type: TP
#: man-pages/man2/rename.2:409
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr "B<EPERM> или B<EACCES>"

#. type: Plain text
#: man-pages/man2/rename.2:433
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and "
"the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of "
"the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the filesystem containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""
"Каталог, содержащийся в I<oldpath>, имеет закрепляющий бит (B<S_ISVTX>) и "
"эффективный идентификатор процесса не совпадает с идентификатором "
"пользователя удаляемого файла или каталога, его содержащего, и процесс не "
"имеет прав (Linux: нет мандата B<CAP_FOWNER>); или I<newpath> является "
"существующим файлом и каталог, содержащий его, имеет закрепляющий бит и "
"эффективный идентификатор процесса не совпадает с идентификатором "
"пользователя замещаемого файла или каталога, его содержащего, и процесс не "
"имеет прав (Linux: нет мандата B<CAP_FOWNER>); или файловая система, "
"содержащая I<pathname>, не поддерживает переименования запрашиваемого типа."

#. type: TP
#: man-pages/man2/rename.2:433
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man2/rename.2:436
msgid "The file is on a read-only filesystem."
msgstr "Файл расположен в файловой системе, доступной только для чтения."

#. type: TP
#: man-pages/man2/rename.2:436
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: man-pages/man2/rename.2:444
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<rename>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""
"Элементы I<oldpath> и I<newpath> находятся не в одной смонтированной "
"файловой системе (Linux позволяет монтировать файловую систему в несколько "
"точек, но B<rename>() не работает с различающимися точками монтирования, "
"даже если в них смонтирована идентичная файловая система)."

#. type: Plain text
#: man-pages/man2/rename.2:449
msgid ""
"The following additional errors can occur for B<renameat>()  and "
"B<renameat2>():"
msgstr ""
"В B<renameat>() и B<renameat2>() дополнительно могут возникнуть следующие "
"ошибки:"

#. type: Plain text
#: man-pages/man2/rename.2:455
msgid "I<olddirfd> or I<newdirfd> is not a valid file descriptor."
msgstr ""
"Значение I<olddirfd> или I<newdirfd> не является правильным файловым "
"дескриптором."

#. type: Plain text
#: man-pages/man2/rename.2:465
msgid ""
"I<oldpath> is relative and I<olddirfd> is a file descriptor referring to a "
"file other than a directory; or similar for I<newpath> and I<newdirfd>"
msgstr ""
"Значение I<oldpath> содержит относительный путь и I<olddirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог; или произошло "
"тоже самое с I<newpath> и I<newdirfd>."

#. type: Plain text
#: man-pages/man2/rename.2:468
msgid "The following additional errors can occur for B<renameat2>():"
msgstr "В B<renameat2>() дополнительно могут возникнуть следующие ошибки:"

#. type: TP
#: man-pages/man2/rename.2:468
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: man-pages/man2/rename.2:476
msgid "I<flags> contains B<RENAME_NOREPLACE> and I<newpath> already exists."
msgstr ""
"Значение I<flags> содержит B<RENAME_NOREPLACE>, а I<newpath> уже существует."

#. type: Plain text
#: man-pages/man2/rename.2:480
msgid "An invalid flag was specified in I<flags>."
msgstr "В I<flags> указан неверный флаг."

#. type: Plain text
#: man-pages/man2/rename.2:488
msgid ""
"Both B<RENAME_NOREPLACE> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""
"В I<flags> указаны оба флага, B<RENAME_NOREPLACE> и B<RENAME_EXCHANGE>."

#. type: Plain text
#: man-pages/man2/rename.2:496
msgid ""
"Both B<RENAME_WHITEOUT> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr "В I<flags> указаны оба флага, B<RENAME_WHITEOUT> и B<RENAME_EXCHANGE>."

#. type: Plain text
#: man-pages/man2/rename.2:500
msgid "The filesystem does not support one of the flags in I<flags>."
msgstr "Файловая система не поддерживает один из флагов в I<flags>."

#. type: Plain text
#: man-pages/man2/rename.2:508
msgid "I<flags> contains B<RENAME_EXCHANGE> and I<newpath> does not exist."
msgstr "В I<flags> содержится B<RENAME_EXCHANGE>, но I<newpath> не существует."

#. type: Plain text
#: man-pages/man2/rename.2:516
msgid ""
"B<RENAME_WHITEOUT> was specified in I<flags>, but the caller does not have "
"the B<CAP_MKNOD> capability."
msgstr ""
"В I<flags> указан флаг B<RENAME_WHITEOUT> , но вызывающий не имеет мандата "
"B<CAP_MKNOD>."

#. type: Plain text
#: man-pages/man2/rename.2:520
msgid ""
"B<renameat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Системный вызов B<renameat>() был добавлен в ядро Linux версии 2.6.16; "
"поддержка в glibc доступна с версии 2.4."

#. type: Plain text
#: man-pages/man2/rename.2:523
msgid ""
"B<renameat2>()  was added to Linux in kernel 3.15; library support was added "
"in glibc 2.28."
msgstr ""
"Вызов B<renameat2>() был добавлен в Linux 3.15; поддержка в glibc доступна с "
"версии 2.28."

#. type: Plain text
#: man-pages/man2/rename.2:526
msgid "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/rename.2:529
msgid "B<renameat>(): POSIX.1-2008."
msgstr "B<renameat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/rename.2:532
msgid "B<renameat2>()  is Linux-specific."
msgstr "Вызов B<renameat2>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/rename.2:551
msgid ""
"On older kernels where B<renameat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<rename>().  When I<oldpath> and "
"I<newpath> are relative pathnames, glibc constructs pathnames based on the "
"symbolic links in I</proc/self/fd> that correspond to the I<olddirfd> and "
"I<newdirfd> arguments."
msgstr ""
"В старых ядрах, где B<renameat>() отсутствует, обёрточная функция glibc "
"использует B<rename>(). Если I<oldpath> и I<newpath> являются относительными "
"путями, то glibc собирает пути относительно символической ссылки в I</proc/"
"self/fd>, которая соответствует аргументам I<olddirfd> и I<newdirfd>."

#. type: Plain text
#: man-pages/man2/rename.2:562
msgid ""
"On NFS filesystems, you can not assume that if the operation failed, the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up "
"again causes a failure.  The application is expected to deal with this.  See "
"B<link>(2)  for a similar problem."
msgstr ""
"При работе с файловыми системами NFS нельзя считать, что если операция "
"завершилась неудачно, то имя файла не изменилось. Если сервер производит "
"операцию переименования, а затем аварийно останавливает свою работу, то "
"перепосланный пакет RPC будет вновь обработан при восстановлении работы "
"сервера, что вызовет сообщение об ошибке. Приложение в этой ситуации должно "
"работать корректно. Смотрите B<link>(2), где описывается подобная проблема."

#. type: Plain text
#: man-pages/man2/rename.2:569
msgid ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr "RMDIR"

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr "rmdir - удалить каталог"

#. type: Plain text
#: man-pages/man2/rmdir.2:35
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr "B<int rmdir(const char *>I<pathname>B<);>"

#. type: Plain text
#: man-pages/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr "B<rmdir>() удаляет каталог, который должен быть пуст."

#. type: Plain text
#: man-pages/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""
"Нет прав на запись в каталог, содержащийся в I<pathname>, или в одном из "
"каталогов в I<pathname> не разрешён поиск (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux, this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""
"В данный момент I<pathname> используется системой или одним из процессов, "
"что предотвращает удаление. В Linux это означает, что I<pathname> "
"используется в качестве точки монтирования или является корневым каталогом "
"вызвавшего процесса."

#. type: Plain text
#: man-pages/man2/rmdir.2:67
msgid "I<pathname> points outside your accessible address space."
msgstr ""
"Аргумент I<pathname> указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr "I<pathname> содержит I<.> в качестве последнего компонента."

#. type: Plain text
#: man-pages/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""
"Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/rmdir.2:80
msgid "I<pathname> was too long."
msgstr "I<pathname> слишком длинен."

#. type: Plain text
#: man-pages/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"Один из каталогов в I<pathname> не существует или является повисшей "
"символьной ссылкой."

#. type: Plain text
#: man-pages/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""
"I<pathname>, или его компонент, используемый в качестве каталога в "
"I<pathname>, фактически, не является каталогом."

#. type: TP
#: man-pages/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr "B<ENOTEMPTY>"

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/rmdir.2:108
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has "
"I<..> as its final component.  POSIX.1 also allows B<EEXIST> for this "
"condition."
msgstr ""
"I<pathname> содержит элементы, отличные от I<.> и I<..> ; или последним "
"компонентом I<pathname> является I<..>. POSIX.1 также позволяет возвращать "
"B<EEXIST> в такой ситуации."

#. type: Plain text
#: man-pages/man2/rmdir.2:119
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"На каталоге, содержащемся в I<pathname>, установлен закрепляющий (sticky) "
"бит (B<S_ISVTX>) и эффективный идентификатор пользователя не совпадает с "
"пользовательским ID файла или каталога, его содержащего, что требуется для "
"удаления, и процесс не имеет прав (Linux: не имеет мандата B<CAP_FOWNER>)."

#. type: Plain text
#: man-pages/man2/rmdir.2:124
msgid ""
"The filesystem containing I<pathname> does not support the removal of "
"directories."
msgstr ""
"Файловая система, содержащая I<pathname>, не поддерживает удаление каталогов."

#. type: Plain text
#: man-pages/man2/rmdir.2:128
msgid "I<pathname> refers to a directory on a read-only filesystem."
msgstr ""
"I<pathname> указывает на файл в файловой системе, доступной только для "
"чтения."

#. type: Plain text
#: man-pages/man2/rmdir.2:130
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/rmdir.2:133
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""
"Неточности в протоколе NFS могут приводить к неожиданному исчезновению "
"каталогов, которые всё ещё используются."

#. type: Plain text
#: man-pages/man2/rmdir.2:141
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"

#. type: TH
#: man-pages/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr "RECV"

#. type: Plain text
#: man-pages/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr "recv, recvfrom, recvmsg - принимает сообщение из сокета"

#. type: Plain text
#: man-pages/man2/recv.2:49
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/recv.2:51
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/recv.2:53
#, no-wrap
msgid "B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/recv.2:56
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/recv.2:58
#, no-wrap
msgid "B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/recv.2:70
msgid ""
"The B<recv>(), B<recvfrom>(), and B<recvmsg>()  calls are used to receive "
"messages from a socket.  They may be used to receive data on both "
"connectionless and connection-oriented sockets.  This page first describes "
"common features of all three system calls, and then describes the "
"differences between the calls."
msgstr ""
"Системные вызовы B<recv>(), B<recvfrom>() и B<recvmsg>() используются для "
"получения сообщений из сокета. Они могут использоваться для получения "
"данных, независимо от того, является ли сокет ориентированным на соединения "
"или нет. В этой странице сперва описаны общие свойства всех трёх системных "
"вызовов, а затем описываются различия между ними."

#. type: Plain text
#: man-pages/man2/recv.2:85
msgid ""
"The only difference between B<recv>()  and B<read>(2)  is the presence of "
"I<flags>.  With a zero I<flags> argument, B<recv>()  is generally equivalent "
"to B<read>(2)  (but see NOTES).  Also, the following call"
msgstr ""
"Вызов B<recv>() отличается от B<read>(2) только наличием аргумента I<flags>. "
"Если значение I<flags> равно нулю, то вызов B<recv>() эквивалентен "
"B<read>(2) (но смотрите ЗАМЕЧАНИЯ). Также, вызов"

#. type: Plain text
#: man-pages/man2/recv.2:87
#, no-wrap
msgid "    recv(sockfd, buf, len, flags);\n"
msgstr "    recv(sockfd, buf, len, flags);\n"

#. type: Plain text
#: man-pages/man2/recv.2:89
msgid "is equivalent to"
msgstr "эквивалентен"

#. type: Plain text
#: man-pages/man2/recv.2:91
#, no-wrap
msgid "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"
msgstr "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"

#. type: Plain text
#: man-pages/man2/recv.2:97
msgid ""
"All three calls return the length of the message on successful completion.  "
"If a message is too long to fit in the supplied buffer, excess bytes may be "
"discarded depending on the type of socket the message is received from."
msgstr ""
"При успешном выполнении все три вызова возвращают длину сообщения. Если "
"сообщение слишком длинное и не поместилось в предоставленный буфер, лишние "
"байты могут быть отброшены, в зависимости от типа сокета, на котором "
"принимаются сообщения."

#. type: Plain text
#: man-pages/man2/recv.2:107
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""
"Если на сокете не доступно ни одного сообщения, то обсуждаемые вызовы "
"ожидают их прибытия, если сокет не помечен как неблокирующий (см. "
"B<fcntl>(2)), в противном случае возвращается значение -1, а внешняя "
"переменная I<errno> устанавливается в значение B<EAGAIN> или B<EWOULDBLOCK>. "
"Все эти вызовы обычно сразу возвращают все доступные данные вплоть до "
"запрошенного объема, а не ждут, пока появятся данные полной запрошенной "
"длины."

#. type: Plain text
#: man-pages/man2/recv.2:114
msgid ""
"An application can use B<select>(2), B<poll>(2), or B<epoll>(7)  to "
"determine when more data arrives on a socket."
msgstr ""
"Для определения появления новых данных в сокете приложение может "
"использовать B<select>(2), B<poll>(2) или B<epoll>(7)."

#. type: SS
#: man-pages/man2/recv.2:114
#, no-wrap
msgid "The flags argument"
msgstr "Аргумент флагов"

#. type: Plain text
#: man-pages/man2/recv.2:118
msgid ""
"The I<flags> argument is formed by ORing one or more of the following values:"
msgstr ""
"Аргумент I<flags> формируется с помощью объединения логической операцией ИЛИ "
"одного или более следующих значений:"

#. type: TP
#: man-pages/man2/recv.2:118
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr "B<MSG_CMSG_CLOEXEC> (только для B<recvmsg>(); начиная с Linux 2.6.23)"

#. type: Plain text
#: man-pages/man2/recv.2:129
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""
"Установить флаг close-on-exec для файлового дескриптора, полученного через "
"доменный файловый дескриптор UNIX, с помощью операции B<SCM_RIGHTS> (описана "
"в B<unix>(7)). Этот флаг полезен по тем же причинам что и флаг B<O_CLOEXEC> "
"у B<open>(2)."

#. type: TP
#: man-pages/man2/recv.2:129
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr "B<MSG_DONTWAIT> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:148
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK>.  This provides similar behavior "
"to setting the B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> "
"operation), but differs in that B<MSG_DONTWAIT> is a per-call option, "
"whereas B<O_NONBLOCK> is a setting on the open file description (see "
"B<open>(2)), which will affect all threads in the calling process and as "
"well as other processes that hold file descriptors referring to the same "
"open file description."
msgstr ""
"Включить неблокирующий режим. Если операция могла бы привести к блокировке, "
"возвращается B<EAGAIN> или B<EWOULDBLOCK>. Такое поведение подобно заданию "
"флага B<O_NONBLOCK> (в B<fcntl>(2) операцией B<F_SETFL>), но отличие в том, "
"что B<MSG_DONTWAIT> указывается в вызове, а B<O_NONBLOCK> задаётся в "
"описании открытого файла (смотрите B<open>(2)), что влияет на все нити "
"вызывающего процесса, а также на другие процессы, у которых есть файловые "
"дескрипторы, ссылающиеся на это описание открытого файла."

#. type: TP
#: man-pages/man2/recv.2:148
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr "B<MSG_ERRQUEUE> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:167
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""
"Указание этого флага позволяет получить из очереди ошибок сокета "
"накопившиеся ошибки. Ошибка передаётся в вспомогательном сообщении тип "
"которого зависит от протокола (для IPv4 это B<IP_RECVERR>). Вызывающий "
"должен предоставить буфер достаточного размера. Дополнительная информация "
"приведена в B<cmsg>(3) и B<ip>(7). Содержимое исходного пакета, который "
"привёл к ошибке, передаётся в виде обычных данных через I<msg_iovec>. "
"Исходный адрес назначения датаграммы, которая привела к ошибке, передаётся "
"через I<msg_name>."

#. type: Plain text
#: man-pages/man2/recv.2:171
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr "Ошибка передаётся в виде структуры I<sock_extended_err>:"

#. type: Plain text
#: man-pages/man2/recv.2:178
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"

#. type: Plain text
#: man-pages/man2/recv.2:190
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* Error number */\n"
"    uint8_t  ee_origin;  /* Where the error originated */\n"
"    uint8_t  ee_type;    /* Type */\n"
"    uint8_t  ee_code;    /* Code */\n"
"    uint8_t  ee_pad;     /* Padding */\n"
"    uint32_t ee_info;    /* Additional information */\n"
"    uint32_t ee_data;    /* Other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* номер ошибки */\n"
"    uint8_t  ee_origin;  /* источник её происхождения */\n"
"    uint8_t  ee_type;    /* тип */\n"
"    uint8_t  ee_code;    /* код */\n"
"    uint8_t  ee_pad;     /* заполнение для выравнивания */\n"
"    uint32_t ee_info;    /* дополнительная информация */\n"
"    uint32_t ee_data;    /* прочие данные */\n"
"    /* далее могут содержаться ещё данные */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/recv.2:192
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"

#. type: Plain text
#: man-pages/man2/recv.2:216
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""
"В I<ee_errno> содержится значение I<errno> для ожидающей ошибки. В "
"I<ee_origin> содержится источник происхождения ошибки. Смысл остальных полей "
"зависит от протокола. Макрос B<SOCK_EE_OFFENDER> возвращает указатель на "
"адрес сетевого объекта, породившего ошибку. Если этот адрес неизвестен, то "
"поле I<sa_family> структуры I<sockaddr> содержит значение B<AF_UNSPEC>, а "
"прочие поля структуры I<sockaddr> не определены. Содержимое пакета, "
"вызвавшего ошибку, передаётся в виде обычных данных."

#. type: Plain text
#: man-pages/man2/recv.2:230
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> flag is set in the I<msghdr>.  After an error has been "
"passed, the pending socket error is regenerated based on the next queued "
"error and will be passed on the next socket operation."
msgstr ""
"Для локальных ошибок адрес не передаётся (это можно выяснить, проверив поле "
"I<cmsg_len> структуры I<cmsghdr>). Для ошибок при приёме устанавливается "
"флаг B<MSG_ERRQUEUE> в I<msghdr>. После того, как ошибка передана программе, "
"следующая ошибка в очереди ошибок становится ожидающей ошибкой и передается "
"программе при следующей операции на сокете."

#. type: TP
#: man-pages/man2/recv.2:230 man-pages/man2/recv.2:423
#, no-wrap
msgid "B<MSG_OOB>"
msgstr "B<MSG_OOB>"

#. type: Plain text
#: man-pages/man2/recv.2:237
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such protocols."
msgstr ""
"Этот флаг запрашивает приём внеполосных данных, которые в противном случае "
"не были бы получены в обычном потоке данных. Некоторые протоколы помещают "
"данные повышенной срочности в начало очереди с обычными данными, и поэтому "
"этот флаг не может использоваться с такими протоколами."

#. type: TP
#: man-pages/man2/recv.2:237
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr "B<MSG_PEEK>"

#. type: Plain text
#: man-pages/man2/recv.2:244
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""
"Этот флаг заставляет выбрать данные из начала очереди приёма, но не удалять "
"их оттуда. Таким образом, последующий вызов вернёт те же самые данные."

#. type: TP
#: man-pages/man2/recv.2:244
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr "B<MSG_TRUNC> (начиная с Linux 2.2)"

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: man-pages/man2/recv.2:254
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22), and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer."
msgstr ""
"Для «сырых» данных (B<AF_PACKET>), дейтаграмм Интернета (начиная с Linux "
"2.4.27/2.6.8), netlink (начиная с Linux 2.6.22) и дейтаграмм UNIX (начиная с "
"Linux 3.4) возвращает реальную длину пакета или дейтаграммы, даже если она "
"была больше, чем предоставленный буфер."

#. type: Plain text
#: man-pages/man2/recv.2:257
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""
"Описание использования с потоковым сокетами Интернета смотрите в B<tcp>(7)."

#. type: TP
#: man-pages/man2/recv.2:257
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr "B<MSG_WAITALL> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/recv.2:266
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned.  This flag has no effect "
"for datagram sockets."
msgstr ""
"Этим флагом включается блокирование операции до полной обработки запроса. "
"Однако, этот вызов всё равно может вернуть меньше данных, чем было "
"запрошено, если был пойман сигнал, произошла ошибка или разрыв соединения, "
"или если начали поступать данные другого типа, не того, который был сначала. "
"Этот флаг не влияет на датаграммные сокеты."

#. type: SS
#: man-pages/man2/recv.2:266
#, no-wrap
msgid "recvfrom()"
msgstr "recvfrom()"

#. type: Plain text
#: man-pages/man2/recv.2:272
msgid ""
"B<recvfrom>()  places the received message into the buffer I<buf>.  The "
"caller must specify the size of the buffer in I<len>."
msgstr ""
"Вызов B<recvfrom>() помещает принятое сообщение в буфер I<buf>. Вызывающий "
"должен указать размер буфера в I<len>."

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: man-pages/man2/recv.2:300
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address of the message, that source address is placed in the buffer pointed "
"to by I<src_addr>.  In this case, I<addrlen> is a value-result argument.  "
"Before the call, it should be initialized to the size of the buffer "
"associated with I<src_addr>.  Upon return, I<addrlen> is updated to contain "
"the actual size of the source address.  The returned address is truncated if "
"the buffer provided is too small; in this case, I<addrlen> will return a "
"value greater than was supplied to the call."
msgstr ""
"Если значение I<src_addr> не равно NULL, и в нижележащем протоколе "
"используется адрес источника сообщения, то адрес источника помещается в "
"буфер, указанный в I<src_addr>. В этом случае I<addrlen> является аргументом-"
"результатом. Перед вызовом ему должно быть присвоено значение длины буфера, "
"связанного с I<src_addr>. При возврате I<addrlen> обновляется и содержит "
"действительный размер адреса источника. Возвращаемый адрес обрезается, если "
"предоставленный буфер слишком мал; в этом случае I<addrlen> будет содержать "
"значение большее, чем указывалось в вызове."

#. type: Plain text
#: man-pages/man2/recv.2:307
msgid ""
"If the caller is not interested in the source address, I<src_addr> and "
"I<addrlen> should be specified as NULL."
msgstr ""
"Если вызывающему адрес источника не нужен, то значение I<src_addr> и "
"I<addrlen> должно быть равно NULL."

#. type: SS
#: man-pages/man2/recv.2:307
#, no-wrap
msgid "recv()"
msgstr "recv()"

#. type: Plain text
#: man-pages/man2/recv.2:315
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2)).  It is equivalent to the call:"
msgstr ""
"Вызов B<recv>(), обычно, используется только на I<соединённом> сокете "
"(смотрите B<connect>(2)). Он идентичен вызову:"

#. type: Plain text
#: man-pages/man2/recv.2:318
#, no-wrap
msgid "    recvfrom(fd, buf, len, flags, NULL, 0);\n"
msgstr "    recvfrom(fd, buf, len, flags, NULL, 0);\n"

#. type: SS
#: man-pages/man2/recv.2:318
#, no-wrap
msgid "recvmsg()"
msgstr "recvmsg()"

#. type: Plain text
#: man-pages/man2/recv.2:326
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""
"Для минимизации количества передаваемых аргументов в вызов B<recvmsg>() "
"используется структура I<msghdr>. Она определена в I<E<lt>sys/socket.hE<gt>> "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/recv.2:333
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {                    /* массив элементов приёма/передачи */\n"
"    void  *iov_base;              /* начальный адрес */\n"
"    size_t iov_len;               /* количество передаваемых байт */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/recv.2:343
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags on received message */\n"
"};\n"
msgstr ""
"struct msghdr {\n"
"    void         *msg_name;       /* необязательный адрес */\n"
"    socklen_t     msg_namelen;    /* размер адреса */\n"
"    struct iovec *msg_iov;        /* массив приёма/передачи */\n"
"    size_t        msg_iovlen;     /* количество элементов в msg_iov */\n"
"    void         *msg_control;    /* вспомогательные данные,\n"
"                                     см. ниже */\n"
"    size_t        msg_controllen; /* размер буфера вспомогательных\n"
"                                     данных */\n"
"    int           msg_flags;      /* флаги принятого сообщения */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/recv.2:359
msgid ""
"The I<msg_name> field points to a caller-allocated buffer that is used to "
"return the source address if the socket is unconnected.  The caller should "
"set I<msg_namelen> to the size of this buffer before this call; upon return "
"from a successful call, I<msg_namelen> will contain the length of the "
"returned address.  If the application does not need to know the source "
"address, I<msg_name> can be specified as NULL."
msgstr ""
"Поле I<msg_name> указывает на выделенный вызывающим буфер, который "
"используется для возврата адреса источника, если сокет не соединён. "
"Вызывающий должен указать в I<msg_namelen> размер этого буфера перед "
"вызовом; при успешном выполнении вызова в I<msg_namelen> будет содержаться "
"длина возвращаемого адреса. Если приложению не нужно знать адрес источника, "
"то в I<msg_name> можно указать NULL."

#. type: Plain text
#: man-pages/man2/recv.2:366
msgid ""
"The fields I<msg_iov> and I<msg_iovlen> describe scatter-gather locations, "
"as discussed in B<readv>(2)."
msgstr ""
"В полях I<msg_iov> и I<msg_iovlen> описываются место приёма/передачи, "
"обсуждаемые в B<readv>(2)."

#. type: Plain text
#: man-pages/man2/recv.2:381
msgid ""
"The field I<msg_control>, which has length I<msg_controllen>, points to a "
"buffer for other protocol control-related messages or miscellaneous "
"ancillary data.  When B<recvmsg>()  is called, I<msg_controllen> should "
"contain the length of the available buffer in I<msg_control>; upon return "
"from a successful call it will contain the length of the control message "
"sequence."
msgstr ""
"Поле I<msg_control> длиной I<msg_controllen> указывает на буфер для других "
"сообщений, связанных с управлением протоколом или на буфер для разнообразных "
"вспомогательных данных. При вызове B<recvmsg>() в поле I<msg_controllen> "
"должен указываться размер доступного буфера, чей адрес передан в "
"I<msg_control>; при успешном выполнении вызова в этом параметре будет "
"находиться длина последовательности контрольных сообщений."

#. type: Plain text
#: man-pages/man2/recv.2:383
msgid "The messages are of the form:"
msgstr "Сообщения имеют следующий вид:"

#. type: Plain text
#: man-pages/man2/recv.2:394
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* счетчик байтов данных с заголовком\n"
"                           (тип — socklen_t в POSIX) */\n"
"    int    cmsg_level;  /* начальный протокол */\n"
"    int    cmsg_type;   /* тип, зависящий от протокола */\n"
"/* после\n"
"   unsigned char cmsg_data[]; */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/recv.2:399
msgid ""
"Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""
"К вспомогательным данным нужно обращаться только с помощью макросов, "
"определённых в B<cmsg>(3)."

#. type: Plain text
#: man-pages/man2/recv.2:402
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""
"Например, этот механизм вспомогательных данных используется в Linux для "
"передачи расширенных ошибок, флагов IP и файловых дескрипторов через "
"доменные сокеты Unix."

#. type: Plain text
#: man-pages/man2/recv.2:410
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""
"При возврате из B<recvmsg>() устанавливается значение поля I<msg_flags> в "
"I<msghdr>. Оно может содержать несколько флагов:"

#. type: TP
#: man-pages/man2/recv.2:410
#, no-wrap
msgid "B<MSG_EOR>"
msgstr "B<MSG_EOR>"

#. type: Plain text
#: man-pages/man2/recv.2:415
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""
"означает конец записи: возвращённые данные заканчивают запись (обычно "
"используется вместе с сокетами типа B<SOCK_SEQPACKET>)."

#. type: TP
#: man-pages/man2/recv.2:415
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr "B<MSG_TRUNC>"

#. type: Plain text
#: man-pages/man2/recv.2:419
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""
"означает, что хвостовая часть датаграммы была отброшена, потому что "
"датаграмма была больше, чем предоставленный буфер."

#. type: TP
#: man-pages/man2/recv.2:419
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr "B<MSG_CTRUNC>"

#. type: Plain text
#: man-pages/man2/recv.2:423
msgid ""
"indicates that some control data was discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""
"означает, что часть управляющих данных была отброшена из-за недостатка места "
"в буфере вспомогательных данных."

#. type: Plain text
#: man-pages/man2/recv.2:426
msgid ""
"is returned to indicate that expedited or out-of-band data was received."
msgstr ""
"возвращается для индикации, что получены курируемые или внеполосные данные."

#. type: TP
#: man-pages/man2/recv.2:426
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr "B<MSG_ERRQUEUE>"

#. type: Plain text
#: man-pages/man2/recv.2:430
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""
"означает, что были получены не данные, а расширенное сообщение об ошибке из "
"очереди ошибок сокета."

#. type: Plain text
#: man-pages/man2/recv.2:436
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  In the event of an error, I<errno> is set to indicate the error."
msgstr ""
"Эти вызовы возвращают количество принятых байт или -1, если произошла "
"ошибка. В случае ошибки в I<errno> записывается код ошибки."

#. type: Plain text
#: man-pages/man2/recv.2:439
msgid ""
"When a stream socket peer has performed an orderly shutdown, the return "
"value will be 0 (the traditional \"end-of-file\" return)."
msgstr ""
"Когда ответная сторона потока выполняет корректное отключение (shutdown), то "
"возвращается 0 (обычный возврат «конец файла»)."

#. type: Plain text
#: man-pages/man2/recv.2:443
msgid ""
"Datagram sockets in various domains (e.g., the UNIX and Internet domains)  "
"permit zero-length datagrams.  When such a datagram is received, the return "
"value is 0."
msgstr ""
"В датаграмных сокетах некоторых доменов (например, доменах UNIX и Internet) "
"разрешены датаграммы нулевой длины. При получении такой датаграммы "
"возвращается значение 0."

#. type: Plain text
#: man-pages/man2/recv.2:446
msgid ""
"The value 0 may also be returned if the requested number of bytes to receive "
"from a stream socket was 0."
msgstr ""
"Также значение 0 может возвращаться, если запрошенное количество принимаемых "
"байт из потокового сокета равно 0."

#. type: Plain text
#: man-pages/man2/recv.2:451
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""
"Здесь представлено несколько стандартных ошибок, возвращаемых с уровня "
"сокетов. Могут также появиться другие ошибки, возвращаемые из "
"соответствующих протокольных модулей; их описание находится в "
"соответствующих справочных страницах."

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/recv.2:460
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1 allows either error to be returned for this case, and "
"does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""
"Сокет помечен как неблокируемый, а операция приёма привела бы к блокировке, "
"или установлено время ожидания данных и это время истекло до получения "
"данных. Согласно POSIX.1 в этом случае может возвращаться любая ошибка и не "
"требуется, чтобы эти константы имели одинаковое значение, поэтому "
"переносимое приложение должно проверить оба случая."

#. type: Plain text
#: man-pages/man2/recv.2:465
msgid "The argument I<sockfd> is an invalid file descriptor."
msgstr "Аргумент I<sockfd> содержит неверный файловый дескриптор."

#. type: TP
#: man-pages/man2/recv.2:465
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: man-pages/man2/recv.2:469
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""
"Удалённый узел отказался устанавливать сетевое соединение (обычно потому, "
"что там не работает запрошенная служба)."

#. type: Plain text
#: man-pages/man2/recv.2:473
msgid ""
"The receive buffer pointer(s) point outside the process's address space."
msgstr ""
"Указатель на приёмный буфер указывает вне адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/recv.2:478
msgid ""
"The receive was interrupted by delivery of a signal before any data was "
"available; see B<signal>(7)."
msgstr ""
"Приём данных был прерван сигналом, а данные ещё не были доступны; смотрите "
"B<signal>(7)."

#.  e.g., msg_namelen < 0 for recvmsg() or addrlen < 0 for recvfrom()
#. type: Plain text
#: man-pages/man2/recv.2:482
msgid "Invalid argument passed."
msgstr "Передан неверный аргумент."

#. type: Plain text
#: man-pages/man2/recv.2:486
msgid "Could not allocate memory for B<recvmsg>()."
msgstr "Не удалось выделить память для B<recvmsg>()."

#. type: TP
#: man-pages/man2/recv.2:486
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man2/recv.2:493
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""
"Сокет, связанный с протоколом, ориентированным на соединение, не был "
"соединён (см. B<connect>(2) и B<accept>(2))."

#. type: TP
#: man-pages/man2/recv.2:493
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/recv.2:498
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr "Файловый дескриптор I<sockfd> указывает не на каталог."

#. type: Plain text
#: man-pages/man2/recv.2:501
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (эти интерфейсы впервые появились в "
"4.2BSD)."

#. type: Plain text
#: man-pages/man2/recv.2:508
msgid ""
"POSIX.1 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> flags."
msgstr ""
"В POSIX.1 описаны только флаги B<MSG_OOB>, B<MSG_PEEK> и B<MSG_WAITALL>."

#. type: Plain text
#: man-pages/man2/recv.2:521
msgid ""
"If a zero-length datagram is pending, B<read>(2)  and B<recv>()  with a "
"I<flags> argument of zero provide different behavior.  In this circumstance, "
"B<read>(2)  has no effect (the datagram remains pending), while B<recv>()  "
"consumes the pending datagram."
msgstr ""
"Если ожидает дейтаграмма нулевой длины, то B<read>(2) и B<recv>() с нулевым "
"аргументом I<flags> работают по-разному. В этом случае B<read>(2) ничего не "
"делает (дейтаграмма продолжает ждать), а B<recv>() обрабатывает ожидающую "
"дейтаграмму."

#. type: Plain text
#: man-pages/man2/recv.2:527
msgid "The I<socklen_t> type was invented by POSIX.  See also B<accept>(2)."
msgstr "Тип I<socklen_t> появился из POSIX. Также смотрите B<accept>(2)."

#.  POSIX.1-2001, POSIX.1-2008
#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/recv.2:543
msgid ""
"According to POSIX.1, the I<msg_controllen> field of the I<msghdr> structure "
"should be typed as I<socklen_t>, but glibc currently types it as I<size_t>."
msgstr ""
"В соответствие с POSIX.1 поле I<msg_controllen> структуры I<msghdr> должно "
"иметь тип I<socklen_t>, но в настоящее время в glibc оно имеет тип I<size_t>."

#. type: Plain text
#: man-pages/man2/recv.2:548
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""
"В B<recvmmsg>(2) можно найти информацию о специальном системном вызове "
"Linux, который можно использовать для приёма нескольких датаграмм за один "
"вызов."

#. type: Plain text
#: man-pages/man2/recv.2:553
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr "Пример использования B<recvfrom>() показан в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man2/recv.2:568
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), "
"B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), "
"B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr "REMOVEXATTR"

#. type: Plain text
#: man-pages/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr ""
"removexattr, lremovexattr, fremovexattr - удаление расширенных атрибутов"

#. type: Plain text
#: man-pages/man2/removexattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man2/removexattr.2:49
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""
"Расширенные атрибуты представляют собой пару I<имя>:I<значение> и "
"связываются с записями inode (файлы, каталоги, символьные ссылки и т.п.). "
"Они являются расширениями к обычным атрибутам, связанным со всеми записями "
"inode в системе (например, данные B<stat>(2)). Полное описание модели "
"расширенных атрибутов можно найти в B<xattr>(7)."

#. type: Plain text
#: man-pages/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""
"Вызов B<removexattr>() удаляет расширенный атрибут с именем, заданным в "
"I<name> и связанный с заданным I<path> в файловой системе."

#. type: Plain text
#: man-pages/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a "
"symbolic link, where the extended attribute is removed from the link itself, "
"not the file that it refers to."
msgstr ""
"Вызов B<lremovexattr>() идентичен B<removexattr>(), за исключением случая "
"работы с символьными ссылками; он удаляет расширенный атрибут на ссылке, а "
"не на файле, на который она указывает."

#. type: Plain text
#: man-pages/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by "
"B<open>(2))  in place of I<path>."
msgstr ""
"Вызов B<fremovexattr>() идентичен B<removexattr>(), отличием является то, "
"что расширенный атрибут удаляется у открытого файла, на который указывает "
"I<fd> (возвращаемый B<open>(2)), а не на указанном в I<path>."

#. type: Plain text
#: man-pages/man2/removexattr.2:78
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""
"Имя расширенного атрибута представляет собой строку, заканчивающуюся NULL. "
"Имя I<name> включает префикс пространства имён; их может быть несколько, "
"разрозненные пространства ассоциируются с разными inode."

#. type: Plain text
#: man-pages/man2/removexattr.2:83
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, "
"а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/removexattr.2:84
#, no-wrap
msgid "B<ENODATA>"
msgstr "B<ENODATA>"

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/removexattr.2:92
msgid "The named attribute does not exist."
msgstr "Указанный атрибут не существует."

#. type: TP
#: man-pages/man2/removexattr.2:92
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man2/removexattr.2:95
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""
"Расширенные атрибуты не поддерживаются файловой системой или отключены."

#. type: Plain text
#: man-pages/man2/removexattr.2:99
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "Также могут возникать ошибки, описанные в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/removexattr.2:102
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""
"Данные системные вызовы доступны в Linux начиная с ядра версии 2.4; "
"поддержка в glibc появилась в версии 2.3."

#. type: Plain text
#: man-pages/man2/removexattr.2:119
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: man-pages/man2/readdir.2:30
#, no-wrap
msgid "READDIR"
msgstr "READDIR"

#. type: Plain text
#: man-pages/man2/readdir.2:33
msgid "readdir - read directory entry"
msgstr "readdir - читает элемент каталога"

#. type: Plain text
#: man-pages/man2/readdir.2:38
#, no-wrap
msgid ""
"B<int readdir(unsigned int >I<fd>B<, struct old_linux_dirent *>I<dirp>B<,>\n"
"B<            unsigned int >I<count>B<);>\n"
msgstr ""
"B<int readdir(unsigned int >I<fd>B<, struct old_linux_dirent *>I<dirp>B<,>\n"
"B<            unsigned int >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/readdir.2:50
msgid ""
"This is not the function you are interested in.  Look at B<readdir>(3)  for "
"the POSIX conforming C library interface.  This page documents the bare "
"kernel system call interface, which is superseded by B<getdents>(2)."
msgstr ""
"Эта не та функция, которая должна представлять для вас интерес. Смотрите "
"описание функции B<readdir>(3), которая является интерфейсом библиотеки "
"языка C, соответствующим стандарту POSIX. В этой странице описан минимальный "
"интерфейс системного вызова ядра, который заменён на B<getdents>(2)."

#. type: Plain text
#: man-pages/man2/readdir.2:64
msgid ""
"B<readdir>()  reads one I<old_linux_dirent> structure from the directory "
"referred to by the file descriptor I<fd> into the buffer pointed to by "
"I<dirp>.  The argument I<count> is ignored; at most one I<old_linux_dirent> "
"structure is read."
msgstr ""
"Вызов B<readdir>() читает структуру I<old_linux_dirent> из каталога, "
"заданного файловым дескриптором I<fd>, в буфер, указываемый в I<dirp>. "
"Аргумент I<count> игнорируется; всегда считывается только одна структура "
"I<old_linux_dirent>."

#. type: Plain text
#: man-pages/man2/readdir.2:70
msgid ""
"The I<old_linux_dirent> structure is declared (privately in Linux kernel "
"file B<fs/readdir.c>)  as follows:"
msgstr ""
"Структура I<old_linux_dirent> определена (в файле ядра Linux B<fs/readdir."
"c>, недоступна извне) следующим образом:"

#. type: Plain text
#: man-pages/man2/readdir.2:79
#, no-wrap
msgid ""
"struct old_linux_dirent {\n"
"    unsigned long d_ino;     /* inode number */\n"
"    unsigned long d_offset;  /* offset to this I<old_linux_dirent> */\n"
"    unsigned short d_namlen; /* length of this I<d_name> */\n"
"    char  d_name[1];         /* filename (null-terminated) */\n"
"}\n"
msgstr ""
"struct old_linux_dirent {\n"
"    unsigned long d_ino;     /* номер иноды */\n"
"    unsigned long d_offset;  /* смещение на данную I<old_linux_dirent> */\n"
"    unsigned short d_namlen; /* длина данной I<d_name> */\n"
"    char  d_name[1];         /* имя файла (с null в конце) */\n"
"}\n"

#. type: Plain text
#: man-pages/man2/readdir.2:93
msgid ""
"I<d_ino> is an inode number.  I<d_offset> is the distance from the start of "
"the directory to this I<old_linux_dirent>.  I<d_reclen> is the size of "
"I<d_name>, not counting the terminating null byte (\\(aq\\e0\\(aq).  "
"I<d_name> is a null-terminated filename."
msgstr ""
"Значением I<d_ino> является номер иноды. В I<d_offset> задаётся смещение "
"данной I<old_linux_dirent> от начала каталога. В I<d_reclen> задаётся размер "
"I<d_name> без учета завершающего байта null (\\(aq\\e0\\(aq). В I<d_name> "
"указывается имя файла, завершающееся null."

#. type: Plain text
#: man-pages/man2/readdir.2:99
msgid ""
"On success, 1 is returned.  On end of directory, 0 is returned.  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении возвращается 1. Если каталог закончился возвращается "
"0. При ошибке возвращается -1, а переменной I<errno> присваивается номер "
"ошибки."

#. type: Plain text
#: man-pages/man2/readdir.2:104
msgid "Invalid file descriptor I<fd>."
msgstr "Неверный файловый дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/readdir.2:107
msgid "Argument points outside the calling process's address space."
msgstr ""
"Аргумент указывает за пределы адресного пространства вызывающего процесса."

#. type: Plain text
#: man-pages/man2/readdir.2:110
msgid "Result buffer is too small."
msgstr "Буфер результата слишком мал."

#. type: Plain text
#: man-pages/man2/readdir.2:113
msgid "No such directory."
msgstr "Заданный каталог не существует."

#. type: Plain text
#: man-pages/man2/readdir.2:116
msgid "File descriptor does not refer to a directory."
msgstr "Файловый дескриптор указывает не на каталог."

#. type: Plain text
#: man-pages/man2/readdir.2:127
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  You will need to define the I<old_linux_dirent> structure "
"yourself.  However, probably you should use B<readdir>(3)  instead."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2). Структуру I<old_linux_dirent> нужно определить "
"самостоятельно. Однако лучше использовать B<readdir>(3)."

#. type: Plain text
#: man-pages/man2/readdir.2:129
msgid "This system call does not exist on x86-64."
msgstr "Этот системный вызов отсутствует на x86-64."

#. type: Plain text
#: man-pages/man2/readdir.2:131
msgid "B<getdents>(2), B<readdir>(3)"
msgstr "B<getdents>(2), B<readdir>(3)"

#. type: TH
#: man-pages/man2/reboot.2:28
#, no-wrap
msgid "REBOOT"
msgstr "REBOOT"

#. type: Plain text
#: man-pages/man2/reboot.2:31
msgid "reboot - reboot or enable/disable Ctrl-Alt-Del"
msgstr ""
"reboot - перезагружает систему и разрешает/запрещает использование "
"комбинации Ctrl-Alt-Del"

#. type: Plain text
#: man-pages/man2/reboot.2:34
#, no-wrap
msgid ""
"/* Since kernel version 2.1.30 there are symbolic names LINUX_REBOOT_*\n"
"   for the constants and a fourth argument to the call: */\n"
msgstr ""
"/* Начиная с версии ядра 2.1.30 появились символьные имена LINUX_REBOOT_*\n"
"   для констант и четвёртый аргумент вызова: */\n"

#. type: Plain text
#: man-pages/man2/reboot.2:38
msgid "B<#include E<lt>linux/reboot.hE<gt>>"
msgstr "B<#include E<lt>linux/reboot.hE<gt>>"

#. type: Plain text
#: man-pages/man2/reboot.2:40
msgid ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"
msgstr ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"

#. type: Plain text
#: man-pages/man2/reboot.2:45
#, no-wrap
msgid ""
"/* Under glibc and most alternative libc's (including uclibc, dietlibc,\n"
"   musl and a few others), some of the constants involved have gotten\n"
"   symbolic names RB_*, and the library call is a 1-argument\n"
"   wrapper around the system call: */\n"
msgstr ""
"/* В glibc и в большинстве альтернативных libc (включая uclibc,\n"
"   deitlibc, musl и других) некоторым константам присвоены\n"
"   символьные имена RB_*, а библиотечная функция является\n"
"   обёрткой с одним аргументом вокруг системного вызова: */\n"

#. type: Plain text
#: man-pages/man2/reboot.2:49
msgid "B<#include E<lt>sys/reboot.hE<gt>>"
msgstr "B<#include E<lt>sys/reboot.hE<gt>>"

#. type: Plain text
#: man-pages/man2/reboot.2:51
msgid "B<int reboot(int >I<cmd>B<);>"
msgstr "B<int reboot(int >I<cmd>B<);>"

#. type: Plain text
#: man-pages/man2/reboot.2:58
msgid ""
"The B<reboot>()  call reboots the system, or enables/disables the reboot "
"keystroke (abbreviated CAD, since the default is Ctrl-Alt-Delete; it can be "
"changed using B<loadkeys>(1))."
msgstr ""
"Вызов B<reboot>() перезагружает систему или разрешает/запрещает "
"использование для перезагрузки специального сочетания клавиш (сокращённо "
"CAD, от комбинации по умолчанию \\(em Ctrl-Alt-Delete; может быть изменена с "
"помощью B<loadkeys>(1))."

#. type: Plain text
#: man-pages/man2/reboot.2:82
msgid ""
"This system call fails (with the error B<EINVAL>)  unless I<magic> equals "
"B<LINUX_REBOOT_MAGIC1> (that is, 0xfee1dead) and I<magic2> equals "
"B<LINUX_REBOOT_MAGIC2> (that is, 672274793).  However, since 2.1.17 also "
"B<LINUX_REBOOT_MAGIC2A> (that is, 85072278)  and since 2.1.97 also "
"B<LINUX_REBOOT_MAGIC2B> (that is, 369367448)  and since 2.5.71 also "
"B<LINUX_REBOOT_MAGIC2C> (that is, 537993216)  are permitted as values for "
"I<magic2>.  (The hexadecimal values of these constants are meaningful.)"
msgstr ""
"Данный системный вызов завершается ошибкой (B<EINVAL>), если I<magic> не "
"равен B<LINUX_REBOOT_MAGIC1> (0xfee1dead) и I<magic2> не равен "
"B<LINUX_REBOOT_MAGIC2> (672274793). Однако, начиная с 2.1.17 в I<magic2> "
"также можно использовать B<LINUX_REBOOT_MAGIC2A> (85072278)  и начиная с "
"2.1.97 — B<LINUX_REBOOT_MAGIC2B> (369367448) и начиная с 2.5.71 — "
"B<LINUX_REBOOT_MAGIC2C> (537993216) (шестнадцатеричные значения этих "
"констант говорят сами за себя)."

#. type: Plain text
#: man-pages/man2/reboot.2:86
msgid "The I<cmd> argument can have the following values:"
msgstr "Аргумент I<cmd> может принимать следующие значения:"

#. type: TP
#: man-pages/man2/reboot.2:86
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_OFF>"
msgstr "B<LINUX_REBOOT_CMD_CAD_OFF>"

#. type: Plain text
#: man-pages/man2/reboot.2:96
msgid ""
"(B<RB_DISABLE_CAD>, 0).  CAD is disabled.  This means that the CAD keystroke "
"will cause a B<SIGINT> signal to be sent to init (process 1), whereupon this "
"process may decide upon a proper action (maybe: kill all processes, sync, "
"reboot)."
msgstr ""
"(B<RB_DISABLE_CAD>, 0). Запретить использование сочетания клавиш для "
"перезагрузки системы (CAD). Это означает, что нажатие комбинации клавиш CAD "
"приведёт к тому, что процессу init (с идентификатором 1) будет послан сигнал "
"B<SIGINT>, после чего этот процесс может сам решить какие действия выполнять "
"(возможно, послать сигналы процессам, выполнить команду sync, reboot)."

#. type: TP
#: man-pages/man2/reboot.2:96
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_ON>"
msgstr "B<LINUX_REBOOT_CMD_CAD_ON>"

#. type: Plain text
#: man-pages/man2/reboot.2:104
msgid ""
"(B<RB_ENABLE_CAD>, 0x89abcdef).  CAD is enabled.  This means that the CAD "
"keystroke will immediately cause the action associated with "
"B<LINUX_REBOOT_CMD_RESTART>."
msgstr ""
"(B<RB_ENABLE_CAD>, 0x89abcdef). Разрешить использование сочетания клавиш для "
"перезагрузки (CAD). Это означает, что нажатие комбинации клавиш CAD приведёт "
"к немедленному выполнению действия, связанного с B<LINUX_REBOOT_CMD_RESTART>."

#. type: TP
#: man-pages/man2/reboot.2:104
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_HALT>"
msgstr "B<LINUX_REBOOT_CMD_HALT>"

#. type: Plain text
#: man-pages/man2/reboot.2:113
msgid ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; since Linux 1.1.76).  The message \"System "
"halted.\" is printed, and the system is halted.  Control is given to the ROM "
"monitor, if there is one.  If not preceded by a B<sync>(2), data will be "
"lost."
msgstr ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; начиная с Linux 1.1.76) Выводится сообщение "
"«System halted.» и система останавливается. Управление передается монитору в "
"ПЗУ, если таковой имеется. Если вызову этой функции не предшествует "
"B<sync>(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:113
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_KEXEC>"
msgstr "B<LINUX_REBOOT_CMD_KEXEC>"

#. type: Plain text
#: man-pages/man2/reboot.2:121
msgid ""
"(B<RB_KEXEC>, 0x45584543, since Linux 2.6.13).  Execute a kernel that has "
"been loaded earlier with B<kexec_load>(2).  This option is available only if "
"the kernel was configured with B<CONFIG_KEXEC>."
msgstr ""
"(B<RB_KEXEC>, 0x45584543, начиная с Linux 2.6.13) Выполняет ядро, которое "
"было загружено ранее с помощью B<kexec_load>(2). Этот параметр доступен "
"только, если ядро собрано с параметром B<CONFIG_KEXEC>."

#. type: TP
#: man-pages/man2/reboot.2:121
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>"
msgstr "B<LINUX_REBOOT_CMD_POWER_OFF>"

#. type: Plain text
#: man-pages/man2/reboot.2:130
msgid ""
"(B<RB_POWER_OFF>, 0x4321fedc; since Linux 2.1.30).  The message \"Power down."
"\" is printed, the system is stopped, and all power is removed from the "
"system, if possible.  If not preceded by a B<sync>(2), data will be lost."
msgstr ""
"(B<RB_POWER_OFF>, 0x4321fedc; начиная с Linux 2.1.30) Выводится сообщение "
"«Power down.», система останавливается, и у системы отключаются все "
"источники питания, если это возможно. Если вызову этой функции не "
"предшествует B<sync>(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:130
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>"
msgstr "B<LINUX_REBOOT_CMD_RESTART>"

#. type: Plain text
#: man-pages/man2/reboot.2:139
msgid ""
"(B<RB_AUTOBOOT>, 0x1234567).  The message \"Restarting system.\" is printed, "
"and a default restart is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""
"(B<RB_AUTOBOOT>, 0x1234567) Выводится сообщение «Restarting system.», и по "
"умолчанию сразу выполняется перезагрузка системы. Если вызову этой функции "
"не предшествует команда B<sync>(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:139
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART2>"
msgstr "B<LINUX_REBOOT_CMD_RESTART2>"

#. type: Plain text
#: man-pages/man2/reboot.2:149
msgid ""
"(0xa1b2c3d4; since Linux 2.1.30).  The message \"Restarting system with "
"command \\(aq%s\\(aq\" is printed, and a restart (using the command string "
"given in I<arg>)  is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""
"(0xa1b2c3d4; начиная с Linux 2.1.30) Выводится сообщение «Restarting system "
"with command \\(aq%s\\(aq» и немедленно выполняется перезагрузка системы (с "
"использованием командной строки, заданной в I<arg>). Если вызову этой "
"функции не предшествует B<sync>(2), то данные будут потеряны."

#. type: TP
#: man-pages/man2/reboot.2:149
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_SW_SUSPEND>"
msgstr "B<LINUX_REBOOT_CMD_SW_SUSPEND>"

#. type: Plain text
#: man-pages/man2/reboot.2:156
msgid ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; since Linux 2.5.18).  The system is suspended "
"(hibernated) to disk.  This option is available only if the kernel was "
"configured with B<CONFIG_HIBERNATION>."
msgstr ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; начиная с Linux 2.5.18) Система переводится в "
"режим ожидания (suspended, hibernated) на диск. Этот параметр доступен "
"только, если ядро собрано с параметром B<CONFIG_HIBERNATION>."

#. type: Plain text
#: man-pages/man2/reboot.2:159
msgid "Only the superuser may call B<reboot>()."
msgstr "Только суперпользователь может вызывать B<reboot>()."

#. type: Plain text
#: man-pages/man2/reboot.2:166
msgid ""
"The precise effect of the above actions depends on the architecture.  For "
"the i386 architecture, the additional argument does not do anything at "
"present (2.1.122), but the type of reboot can be determined by kernel "
"command-line arguments (\"reboot=...\") to be either warm or cold, and "
"either hard or through the BIOS."
msgstr ""
"Конкретное действие описанных выше команд зависит от архитектуры системы. "
"Что касается i386, то дополнительный аргумент в данное время ничего не даёт "
"(2.1.122), а тип перезагрузки можно задать в командной строке ядра "
"(\"reboot=...\"), определив, будет ли перезагрузка \"тёплой\" или \"холодной"
"\", а также аппаратной или посредством BIOS."

#. type: SS
#: man-pages/man2/reboot.2:166
#, no-wrap
msgid "Behavior inside PID namespaces"
msgstr "Поведение внутри пространств имён PID"

#.  commit cf3f89214ef6a33fad60856bc5ffd7bb2fc4709b
#.  see also commit 923c7538236564c46ee80c253a416705321f13e3
#. type: Plain text
#: man-pages/man2/reboot.2:181
msgid ""
"Since Linux 3.4, if B<reboot>()  is called from a PID namespace other than "
"the initial PID namespace with one of the I<cmd> values listed below, it "
"performs a \"reboot\" of that namespace: the \"init\" process of the PID "
"namespace is immediately terminated, with the effects described in "
"B<pid_namespaces>(7)."
msgstr ""
"Начиная с Linux 3.4, если B<reboot>() вызывается из пространства имён PID, "
"отличающегося от начального пространства имён PID, и и значение I<cmd> равно "
"одному из перечисленных ниже, то выполняется «перезагрузка» в этом "
"пространстве имён: процесс «init» пространства имён PID завершается "
"немедленно, что приводит к результатам, описанным в B<pid_namespaces>(7)."

#. type: Plain text
#: man-pages/man2/reboot.2:187
msgid ""
"The values that can be supplied in I<cmd> when calling B<reboot>()  in this "
"case are as follows:"
msgstr ""
"Возможные значения в этом случае, передаваемые в I<cmd> при вызове "
"B<reboot>(), следующие:"

#. type: TP
#: man-pages/man2/reboot.2:187
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>, B<LINUX_REBOOT_CMD_RESTART2>"
msgstr "B<LINUX_REBOOT_CMD_RESTART>, B<LINUX_REBOOT_CMD_RESTART2>"

#. type: Plain text
#: man-pages/man2/reboot.2:195
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGHUP> signal."
msgstr ""
"Процесс «init» завершается и B<wait>(2) в родительском процессе возвращает, "
"что поток завершился по сигналу B<SIGHUP>."

#. type: TP
#: man-pages/man2/reboot.2:195
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>, B<LINUX_REBOOT_CMD_HALT>"
msgstr "B<LINUX_REBOOT_CMD_POWER_OFF>, B<LINUX_REBOOT_CMD_HALT>"

#. type: Plain text
#: man-pages/man2/reboot.2:203
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGINT> signal."
msgstr ""
"Процесс «init» завершается и B<wait>(2) в родительском процессе возвращает, "
"что поток завершился по сигналу B<SIGINT>."

#. type: Plain text
#: man-pages/man2/reboot.2:212
msgid ""
"For the other I<cmd> values, B<reboot>()  returns -1 and I<errno> is set to "
"B<EINVAL>."
msgstr ""
"При других значениях I<cmd> вызов B<reboot>() возвращает -1 и I<errno> "
"присваивается значение B<EINVAL>."

#. type: Plain text
#: man-pages/man2/reboot.2:225
msgid ""
"For the values of I<cmd> that stop or restart the system, a successful call "
"to B<reboot>()  does not return.  For the other I<cmd> values, zero is "
"returned on success.  In all cases, -1 is returned on failure, and I<errno> "
"is set appropriately."
msgstr ""
"При значениях I<cmd>, по которым система останавливается или "
"перезагружается, в случае успешной работы B<reboot>() ничего не "
"возвращается. При других значений I<cmd> в случае успешной работы "
"возвращается ноль. При ошибке всегда возвращается -1, а I<errno> "
"устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/reboot.2:230
msgid ""
"Problem with getting user-space data under B<LINUX_REBOOT_CMD_RESTART2>."
msgstr ""
"Проблема получения данных пользовательского пространства при "
"B<LINUX_REBOOT_CMD_RESTART2>."

#. type: Plain text
#: man-pages/man2/reboot.2:233
msgid "Bad magic numbers or I<cmd>."
msgstr "Неправильные идентификационные числа или I<cmd>."

#. type: Plain text
#: man-pages/man2/reboot.2:240
msgid ""
"The calling process has insufficient privilege to call B<reboot>(); the "
"caller must have the B<CAP_SYS_BOOT> inside its user namespace."
msgstr ""
"Вызывающий процесс не имеет достаточно прав для вызова B<reboot>(); "
"вызывающий должен иметь мандат B<CAP_SETGID> в своём пользовательском "
"пространстве имён."

#. type: Plain text
#: man-pages/man2/reboot.2:244
msgid ""
"B<reboot>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"Вызов B<reboot>() есть только в Linux, и он не должен использоваться в "
"переносимых программах."

#. type: Plain text
#: man-pages/man2/reboot.2:253
msgid ""
"B<systemctl>(1), B<systemd>(1), B<kexec_load>(2), B<sync>(2), "
"B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>(8), "
"B<shutdown>(8)"
msgstr ""
"B<systemctl>(1), B<systemd>(1), B<kexec_load>(2), B<sync>(2), "
"B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>(8), "
"B<shutdown>(8)"

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "READV"
msgstr "READV"

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man2/readv.2:35
msgid ""
"readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into "
"multiple buffers"
msgstr ""
"readv, writev, preadv, pwritev, preadv2, pwritev2 - читает или пишет данные "
"в несколько буферов"

#. type: Plain text
#: man-pages/man2/readv.2:38
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/readv.2:40
#, no-wrap
msgid "B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"
msgstr "B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:42
#, no-wrap
msgid "B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"
msgstr "B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:45
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:48
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:51
#, no-wrap
msgid ""
"B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:54
#, no-wrap
msgid ""
"B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/readv.2:67
#, no-wrap
msgid ""
"B<preadv>(),\n"
"B<pwritev>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<preadv>(),\n"
"B<pwritev>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/readv.2:77
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated "
"with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""
"Системный вызов B<readv>() считывает I<iovcnt> буферов из файла, связанного "
"с файловым дескриптором I<fd>, в буферы, описываемые I<iov> («разнесённый "
"ввод»)."

#. type: Plain text
#: man-pages/man2/readv.2:87
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather output"
"\")."
msgstr ""
"Системный вызов B<writev>() записывает I<iovcnt> буферов, описанных I<iov>, "
"в файл, связанный с файловым дескриптором I<fd> («сборный вывод»)."

#. type: Plain text
#: man-pages/man2/readv.2:96
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""
"Указатель I<iov> указывает на массив структур I<iovec> (определён в "
"I<E<lt>sys/uio.hE<gt>>:"

#. type: Plain text
#: man-pages/man2/readv.2:103
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;    /* начальный адрес */\n"
"    size_t iov_len;     /* количество передаваемых байт */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/readv.2:111
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple "
"buffers are filled."
msgstr ""
"Системный вызов B<readv>() работает также как B<read>(2), но считывает "
"несколько буферов."

#. type: Plain text
#: man-pages/man2/readv.2:117
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""
"Системный вызов B<writev>() работает также как B<write>(2), но записывает "
"несколько буферов."

#. type: Plain text
#: man-pages/man2/readv.2:136
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov>[0] before proceeding to I<iov>[1], and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be "
"filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov>[0] before proceeding to I<iov>[1], and so on."
msgstr ""
"Буферы выбираются в порядке, в каком они указаны в массиве. Это означает, "
"что B<readv>() сначала полностью заполнит I<iov>[0], и только потом перейдёт "
"к I<iov>[1], и так далее. (Если данных недостаточно, то могут быть заполнены "
"не все буферы, на которые указывает I<iov>.) Подобным образом B<writev>() "
"запишет сначала всё содержимое I<iov>[0], затем I<iov>[1], и так далее."

#.  Regarding atomicity, see https://bugzilla.kernel.org/show_bug.cgi?id=10596
#. type: Plain text
#: man-pages/man2/readv.2:155
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the "
"data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)  "
"for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring "
"to the same open file description (see B<open>(2))."
msgstr ""
"Выполняемые вызовами B<readv>() и B<writev>() пересылки данных атомарны: "
"данные записываются B<writev>() единичным блоком, который не перемешивается "
"с выводом других процессов (см. исключения в B<pipe>(7)); аналогично, "
"B<readv>() гарантированно считывает непрерывный блок данных из файла, "
"независимо от операций чтения из других нитей или процессов, которые имеют "
"файловые дескрипторы, ссылающиеся на это же открытое файловое описание (см. "
"B<open>(2))."

#. type: SS
#: man-pages/man2/readv.2:155
#, no-wrap
msgid "preadv() and pwritev()"
msgstr "preadv() и pwritev()"

#. type: Plain text
#: man-pages/man2/readv.2:168
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""
"В системном вызове B<preadv>() объединены возможности B<readv>() и "
"B<pread>(2). Он выполняет ту же задачу что и B<readv>(), но имеет четвёртый "
"аргумент I<offset>, задающий файловое смещение, по которому нужно выполнить "
"операцию чтения."

#. type: Plain text
#: man-pages/man2/readv.2:181
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and "
"B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""
"В системном вызове B<pwritev>() объединены возможности B<readv>() и "
"B<pwrite>(2). Он выполняет ту же задачу что и B<writev>(), но имеет "
"четвёртый аргумент I<offset>, задающий файловое смещение, по которому нужно "
"выполнить операцию записи."

#. type: Plain text
#: man-pages/man2/readv.2:186
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""
"Файловое смещение не изменяется данными вызовами. Файл, заданный в I<fd>, "
"должен позволять изменение смещения."

#. type: SS
#: man-pages/man2/readv.2:186
#, no-wrap
msgid "preadv2() and pwritev2()"
msgstr "preadv2() и pwritev2()"

#. type: Plain text
#: man-pages/man2/readv.2:195
msgid ""
"These system calls are similar to B<preadv>()  and B<pwritev>()  calls, but "
"add a fifth argument, I<flags>, which modifies the behavior on a per-call "
"basis."
msgstr ""
"Данные системные вызовы подобны B<preadv>() и B<pwritev>(), но имеют "
"дополнительный пятый аргумент I<flags>, который изменяет поведение в "
"зависимости от вызова."

#. type: Plain text
#: man-pages/man2/readv.2:203
msgid ""
"Unlike B<preadv>()  and B<pwritev>(), if the I<offset> argument is -1, then "
"the current file offset is used and updated."
msgstr ""
"В отличие от B<preadv>() и B<pwritev>(), если аргумент I<offset> равен -1, "
"то текущее файловое смещение используется и обновляется."

#. type: Plain text
#: man-pages/man2/readv.2:207
msgid ""
"The I<flags> argument contains a bitwise OR of zero or more of the following "
"flags:"
msgstr ""
"Аргумент I<flags> содержит побитовое ИЛИ нуля и более следующих флагов:"

#. type: TP
#: man-pages/man2/readv.2:207
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.7)"
msgstr "B<RWF_DSYNC> (начиная с Linux 4.7)"

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: man-pages/man2/readv.2:217
msgid ""
"Provide a per-write equivalent of the B<O_DSYNC> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call."
msgstr ""
"Эквивалентен флагу B<O_DSYNC> для B<open>(2), но действующий в конкретной "
"операции записи. Этот флаг имеет смысл только для B<pwritev2>(), и его "
"действие распространяется только на диапазон данных, записываемым системным "
"вызовом."

#. type: TP
#: man-pages/man2/readv.2:217
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.6)"
msgstr "B<RWF_HIPRI> (начиная с Linux 4.6)"

#. type: Plain text
#: man-pages/man2/readv.2:225
msgid ""
"High priority read/write.  Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources.  "
"(Currently, this feature is usable only on a file descriptor opened using "
"the B<O_DIRECT> flag.)"
msgstr ""
"Высокоприоритетное чтение/запись. Позволяет в файловых системах на основе "
"блоков использовать опрос устройства с низкой задержкой, но с возможностью "
"использовать дополнительные ресурсы (в настоящий момент это свойство "
"работает только для файлового дескриптора, открытого с флагом B<O_DIRECT>)."

#. type: TP
#: man-pages/man2/readv.2:225
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.7)"
msgstr "B<RWF_SYNC> (начиная с Linux 4.7)"

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: man-pages/man2/readv.2:235
msgid ""
"Provide a per-write equivalent of the B<O_SYNC> B<open>(2)  flag.  This flag "
"is meaningful only for B<pwritev2>(), and its effect applies only to the "
"data range written by the system call."
msgstr ""
"Эквивалентен флагу B<O_SYNC> для B<open>(2), но действующий в конкретной "
"операции записи. Этот флаг имеет смысл только для B<pwritev2>(), и его "
"действие распространяется только на диапазон данных, записываемым системным "
"вызовом."

#. type: TP
#: man-pages/man2/readv.2:235
#, no-wrap
msgid "B<RWF_NOWAIT> (since Linux 4.14)"
msgstr "B<RWF_NOWAIT> (начиная с Linux 4.14)"

#.  commit 3239d834847627b6634a4139cf1dc58f6f137a46
#.  commit 91f9943e1c7b6638f27312d03fe71fcc67b23571
#. type: Plain text
#: man-pages/man2/readv.2:251
msgid ""
"Do not wait for data which is not immediately available.  If this flag is "
"specified, the B<preadv2>()  system call will return instantly if it would "
"have to read data from the backing storage or wait for a lock.  If some data "
"was successfully read, it will return the number of bytes read.  If no bytes "
"were read, it will return -1 and set I<errno> to B<EAGAIN>.  Currently, this "
"flag is meaningful only for B<preadv2>()."
msgstr ""
"Не ждать данные, если пока нет. Если указан этот флаг, то системный вызов "
"B<preadv2>() сразу завершает работу, если бы ему пришлось читать данные из "
"хранилища (backing storage) или ждать блокировку. Если данные прочитаны, то "
"возвращается количество прочитанных байт. Если байты не прочитаны, то "
"возвращается -1 и I<errno> присваивается B<EAGAIN>. В настоящее время, этот "
"флаг учитывается только в B<preadv2>()."

#. type: TP
#: man-pages/man2/readv.2:251
#, no-wrap
msgid "B<RWF_APPEND> (since Linux 4.16)"
msgstr "B<RWF_APPEND> (начиная с Linux 4.16)"

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: man-pages/man2/readv.2:268
msgid ""
"Provide a per-write equivalent of the B<O_APPEND> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call.  The I<offset> argument does not "
"affect the write operation; the data is always appended to the end of the "
"file.  However, if the I<offset> argument is -1, the current file offset is "
"updated."
msgstr ""
"Предоставляет эквивалент флага B<O_APPEND> для B<open>(2) для каждой записи. "
"Данный флаг значим только для B<pwritev2>(), и его действие проявляется "
"только для диапазона данных, записанных системным вызовом. Аргумент "
"I<offset> не учитывается при операции записи; данные всегда добавляются в "
"конец файла. Однако, если аргумент I<offset> равен -1, то обновляется "
"текущее смещение файла."

#. type: Plain text
#: man-pages/man2/readv.2:280
msgid ""
"On success, B<readv>(), B<preadv>()  and B<preadv2>()  return the number of "
"bytes read; B<writev>(), B<pwritev>()  and B<pwritev2>()  return the number "
"of bytes written."
msgstr ""
"При успешном выполнении B<readv>(), B<preadv>() и B<preadv2>() возвращается "
"количество считанных байт; вызовы B<writev>(), B<pwritev>()  and "
"B<pwritev2>() возвращают количество записанных байт."

#. type: Plain text
#: man-pages/man2/readv.2:286
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""
"Заметим, что для успешного выполнения не считается ошибкой передача меньшего "
"количества байт чем запрошено (смотрите B<read>(2) и B<write>(2))."

#. type: Plain text
#: man-pages/man2/readv.2:288
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"В случае ошибки возвращается -1 и значение I<errno> устанавливается "
"соответствующим образом."

#. type: Plain text
#: man-pages/man2/readv.2:302
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>(), B<preadv2>(), B<pwritev>(), and B<pwritev2>()  can also fail "
"for the same reasons as B<lseek>(2).  Additionally, the following errors are "
"defined:"
msgstr ""
"Вызовы могут возвращать те же ошибки что и B<read>(2) и B<write>(2). Кроме "
"этого, B<preadv>(), B<preadv2>(), B<pwritev>() и B<pwritev2>() также могут "
"завершаться с ошибками как у B<lseek>(2). Дополнительно определены следующие "
"ошибки:"

#. type: Plain text
#: man-pages/man2/readv.2:309
msgid "The sum of the I<iov_len> values overflows an I<ssize_t> value."
msgstr "Сумма значений I<iov_len> превышает значение I<ssize_t>."

#. type: Plain text
#: man-pages/man2/readv.2:314
msgid ""
"The vector count, I<iovcnt>, is less than zero or greater than the permitted "
"maximum."
msgstr ""
"Количество векторов I<iovcnt> меньше нуля или больше разрешённого максимума."

#. type: Plain text
#: man-pages/man2/readv.2:317
msgid "An unknown flag is specified in I<flags>."
msgstr "В I<flags> указан неизвестный флаг."

#. type: Plain text
#: man-pages/man2/readv.2:322
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""
"Вызовы B<preadv>() и B<pwritev>() впервые появились в Linux 2.6.30; "
"поддержка в библиотеке добавлена в glibc 2.10."

#. type: Plain text
#: man-pages/man2/readv.2:328
msgid ""
"B<preadv2>()  and B<pwritev2>()  first appeared in Linux 4.6.  Library "
"support was added in glibc 2.26."
msgstr ""
"Вызовы B<preadv2>() и B<pwritev2>() впервые появились в Linux 4.6. Поддержка "
"в библиотеке glibc добавлена в версии 2.26."

#.  Linux libc5 used \fIsize_t\fP as the type of the \fIiovcnt\fP argument,
#.  and \fIint\fP as the return type.
#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: man-pages/man2/readv.2:337
msgid ""
"B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system "
"calls first appeared in 4.2BSD)."
msgstr ""
"B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (данные "
"системные вызовы впервые появились в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/readv.2:341
msgid ""
"B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr "B<preadv>(), B<pwritev>(): нет в стандарте, но есть в современных BSD."

#. type: Plain text
#: man-pages/man2/readv.2:345
msgid "B<preadv2>(), B<pwritev2>(): nonstandard Linux extension."
msgstr "B<preadv2>(), B<pwritev2>(): нестандартные расширения Linux."

#. type: Plain text
#: man-pages/man2/readv.2:359
msgid ""
"POSIX.1 allows an implementation to place a limit on the number of items "
"that can be passed in I<iov>.  An implementation can advertise its limit by "
"defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the return "
"value from I<sysconf(_SC_IOV_MAX)>.  On modern Linux systems, the limit is "
"1024.  Back in Linux 2.0 days, this limit was 16."
msgstr ""
"Согласно POSIX1, в реализации можно устанавливать ограничение на количество "
"элементов, которые можно передать в I<iov>. Реализация может объявить это "
"ограничение в B<IOV_MAX> (в файле I<E<lt>limits.hE<gt>>) или во время "
"выполнения в виде возвращаемого значения I<sysconf(_SC_IOV_MAX)>. В "
"современных Linux данное ограничение равно 1024. В времена Linux 2.0 оно "
"было равно 16."

#. type: SS
#: man-pages/man2/readv.2:359
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#. type: Plain text
#: man-pages/man2/readv.2:369
msgid ""
"The raw B<preadv>()  and B<pwritev>()  system calls have call signatures "
"that differ slightly from that of the corresponding GNU C library wrapper "
"functions shown in the SYNOPSIS.  The final argument, I<offset>, is unpacked "
"by the wrapper functions into two arguments in the system calls:"
msgstr ""
"Объявления системных вызовов B<preadv>() и B<pwritev>() немного отличаются "
"от им соответствующих обёрточных функций библиотеки GNU C; они показаны в "
"ОБЗОРЕ. Последний аргумент, I<offset>, раскладывается обёрточными функциями "
"на два для системных вызовов:"

#. type: Plain text
#: man-pages/man2/readv.2:371
msgid "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"
msgstr "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"

#. type: Plain text
#: man-pages/man2/readv.2:374
msgid ""
"These arguments contain, respectively, the low order and high order 32 bits "
"of I<offset>."
msgstr ""
"В этих аргументах содержатся старшая и младшая 32-битная часть I<offset>, "
"соответственно."

#. type: SS
#: man-pages/man2/readv.2:374
#, no-wrap
msgid "Historical C library/kernel differences"
msgstr "Исторические отличия между библиотекой C и ядром"

#. type: Plain text
#: man-pages/man2/readv.2:400
msgid ""
"To deal with the fact that B<IOV_MAX> was so low on early versions of Linux, "
"the glibc wrapper functions for B<readv>()  and B<writev>()  did some extra "
"work if they detected that the underlying kernel system call failed because "
"this limit was exceeded.  In the case of B<readv>(), the wrapper function "
"allocated a temporary buffer large enough for all of the items specified by "
"I<iov>, passed that buffer in a call to B<read>(2), copied data from the "
"buffer to the locations specified by the I<iov_base> fields of the elements "
"of I<iov>, and then freed the buffer.  The wrapper function for B<writev>()  "
"performed the analogous task using a temporary buffer and a call to "
"B<write>(2)."
msgstr ""
"Для учёта того, что значение B<IOV_MAX> было мало в старых версиях Linux, "
"обёрточные функции glibc B<readv>() и B<writev>() выполняют дополнительные "
"действия, если обнаруживается, что используемый системный вызов ядра "
"завершился неудачно из-за превышения этого ограничения. В случае B<readv>(), "
"обёрточная функция выделяет временный буфер, достаточный для всех элементов, "
"указанных в I<iov>, передаёт этот буфер в вызов B<read>(2), копирует данные "
"из буфера в места, указанные в полях I<iov_base> элемента I<iov>, а затем "
"освобождает буфер. Обёрточная функция B<writev>() выполняет аналогичную "
"задачу с помощью временного буфера и вызова B<write>(2)."

#. type: Plain text
#: man-pages/man2/readv.2:411
msgid ""
"The need for this extra effort in the glibc wrapper functions went away with "
"Linux 2.2 and later.  However, glibc continued to provide this behavior "
"until version 2.10.  Starting with glibc version 2.9, the wrapper functions "
"provide this behavior only if the library detects that the system is running "
"a Linux kernel older than version 2.6.18 (an arbitrarily selected kernel "
"version).  And since glibc 2.20 (which requires a minimum Linux kernel "
"version of 2.6.32), the glibc wrapper functions always just directly invoke "
"the system calls."
msgstr ""
"Потребность в дополнительных действиях в обёрточных функциях glibc пропала в "
"Linux 2.2 и новее. Однако glibc продолжала так работать до версии 2.10. "
"начиная с glibc 2.9, обёрточные функции так работают только, если библиотека "
"обнаруживает, что система работает с ядром Linux меньше 2.6.18 (произвольно "
"выбранная версия ядра). И начиная с glibc 2.20 (для которой требуется "
"минимальная версия ядра Linux 2.6.32) обёрточные функции glibc всегда просто "
"вызывают системные вызовы."

#. type: Plain text
#: man-pages/man2/readv.2:414
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr "Следующий пример кода демонстрирует использование B<writev>():"

#. type: Plain text
#: man-pages/man2/readv.2:421
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"

#. type: Plain text
#: man-pages/man2/readv.2:426
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"

#. type: Plain text
#: man-pages/man2/readv.2:428
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr "nwritten = writev(STDOUT_FILENO, iov, 2);\n"

#. type: Plain text
#: man-pages/man2/readv.2:433
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr "B<pread>(2), B<read>(2), B<write>(2)"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "REPERTOIREMAP"
msgstr "REPERTOIREMAP"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: man-pages/man5/repertoiremap.5:23
#, no-wrap
msgid "Linux User Manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:26
msgid "repertoiremap - map symbolic character names to Unicode code points"
msgstr ""
"repertoiremap - отображает символические имена символов в кодовые точки "
"Юникода"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:32
msgid ""
"A repertoire map defines mappings between symbolic character names "
"(mnemonics) and Unicode code points when compiling a locale with "
"B<localedef>(1).  Using a repertoire map is optional, it is needed only when "
"symbolic names are used instead of now preferred Unicode code points."
msgstr ""
"Карта набора (repertoire map) определяет отображение между символическими "
"именами (мнемониками) символов и кодовыми точками Юникода (Unicode code "
"points) при компиляции локали с помощью B<localedef>(1). Использование карты "
"набора необязательно, она требуется только при использовании символических "
"имён вместо предпочтительных теперь кодовых точек Юникода."

#. type: SS
#: man-pages/man5/repertoiremap.5:32
#, no-wrap
msgid "Syntax"
msgstr "Синтаксис"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:35
msgid ""
"The repertoiremap file starts with a header that may consist of the "
"following keywords:"
msgstr ""
"Файл repertoiremap начинается с заголовка, который может содержать следующие "
"ключевые слова:"

#. type: TP
#: man-pages/man5/repertoiremap.5:35
#, no-wrap
msgid "I<comment_char>"
msgstr "I<comment_char>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:40
msgid ""
"is followed by a character that will be used as the comment character for "
"the rest of the file.  It defaults to the number sign (#)."
msgstr ""
"за которым указывается символ, использующийся в оставшихся строках файла как "
"символ комментария. По умолчанию это символ решётки (#)."

#. type: TP
#: man-pages/man5/repertoiremap.5:40
#, no-wrap
msgid "I<escape_char>"
msgstr "I<escape_char>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:46
msgid ""
"is followed by a character that should be used as the escape character for "
"the rest of the file to mark characters that should be interpreted in a "
"special way.  It defaults to the backslash (\\e)."
msgstr ""
"за которым указывается символ, использующийся в оставшихся строках файла как "
"символ экранирования для пометки символов, которые должны обрабатываться "
"особым образом. По умолчанию это символ обратной косой черты (\\e)."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:50
msgid ""
"The mapping section starts with the keyword I<CHARIDS> in the first column."
msgstr ""
"Раздел отображения начинается с ключевого слова I<CHARIDS> в первом столбце."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:52
msgid "The mapping lines have the following form:"
msgstr "Строки отображения имеют следующий вид:"

#. type: TP
#: man-pages/man5/repertoiremap.5:52
#, no-wrap
msgid "I<E<lt>symbolic-nameE<gt> E<lt>code-pointE<gt> comment>"
msgstr "I<E<lt>символическое-имяE<gt> E<lt>кодовая-точкаE<gt> комментарий>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:57
msgid "This defines exactly one mapping, I<comment> being optional."
msgstr ""
"Одной строкой определяется одно отображение, I<комментарий> не обязателен."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:60
msgid "The mapping section ends with the string I<END CHARIDS>."
msgstr "Раздел отображения заканчивается строкой I<END CHARIDS>."

#. type: TP
#: man-pages/man5/repertoiremap.5:61
#, no-wrap
msgid "I</usr/share/i18n/repertoiremaps>"
msgstr "I</usr/share/i18n/repertoiremaps>"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:64
msgid "Usual default repertoire map path."
msgstr "Обычный путь по умолчанию для файла карты набора."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:66
msgid "POSIX.2."
msgstr "POSIX.2."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:68
msgid "Repertoire maps are deprecated in favor of Unicode code points."
msgstr "Вместо карт набора следует использовать кодовые точки Юникода."

#. type: Plain text
#: man-pages/man5/repertoiremap.5:70
msgid "A mnemonic for the Euro sign can be defined as follows:"
msgstr "Знак евро можно определить следующим образом:"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:73
#, no-wrap
msgid "E<lt>EuE<gt> E<lt>U20ACE<gt> EURO SIGN\n"
msgstr "E<lt>EuE<gt> E<lt>U20ACE<gt> EURO SIGN\n"

#. type: Plain text
#: man-pages/man5/repertoiremap.5:78
msgid "B<locale>(1), B<localedef>(1), B<charmap>(5), B<locale>(5)"
msgstr "B<locale>(1), B<localedef>(1), B<charmap>(5), B<locale>(5)"

#. type: TH
#: man-pages/man5/rpc.5:8
#, no-wrap
msgid "RPC"
msgstr "RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:11
msgid "rpc - RPC program number data base"
msgstr "rpc - база данных программных номеров RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:13
msgid "B</etc/rpc>"
msgstr "B</etc/rpc>"

#. type: Plain text
#: man-pages/man5/rpc.5:19
msgid ""
"The I<rpc> file contains user readable names that can be used in place of "
"RPC program numbers.  Each line has the following information:"
msgstr ""
"В файле I<rpc> содержатся в понятном для человека виде имена, которые можно "
"использовать вместо программных номеров RPC. Каждая строка содержит "
"следующую информацию:"

#. type: Plain text
#: man-pages/man5/rpc.5:23
msgid "name of server for the RPC program"
msgstr "имя сервера RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:25
msgid "RPC program number"
msgstr "программный номер RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:27
msgid "aliases"
msgstr "псевдонимы"

#. type: Plain text
#: man-pages/man5/rpc.5:34
msgid ""
"Items are separated by any number of blanks and/or tab characters.  A \\(aq#"
"\\(aq indicates the beginning of a comment; characters from the \\(aq#\\(aq "
"to the end of the line are not interpreted by routines which search the file."
msgstr ""
"Поля в файле отделяются друг от друга пробелами и/или символами табуляции. "
"Символом \\(aq#\\(aq отмечается начало комментария; символы начиная с \\(aq#"
"\\(aq до конца строки не интерпретируются процедурами, которые производят "
"поиск в данном файле."

#. type: Plain text
#: man-pages/man5/rpc.5:38
msgid ""
"Here is an example of the I</etc/rpc> file from the Sun RPC Source "
"distribution."
msgstr "Вот пример файла I</etc/rpc>, взятый из дистрибутива Sun RPC Source."

#. type: Plain text
#: man-pages/man5/rpc.5:74
#, no-wrap
msgid ""
"#\n"
"# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n"
"#\n"
"portmapper      100000  portmap sunrpc\n"
"rstatd          100001  rstat rstat_svc rup perfmeter\n"
"rusersd         100002  rusers\n"
"nfs             100003  nfsprog\n"
"ypserv          100004  ypprog\n"
"mountd          100005  mount showmount\n"
"ypbind          100007\n"
"walld           100008  rwall shutdown\n"
"yppasswdd       100009  yppasswd\n"
"etherstatd      100010  etherstat\n"
"rquotad         100011  rquotaprog quota rquota\n"
"sprayd          100012  spray\n"
"3270_mapper     100013\n"
"rje_mapper      100014\n"
"selection_svc   100015  selnsvc\n"
"database_svc    100016\n"
"rexd            100017  rex\n"
"alis            100018\n"
"sched           100019\n"
"llockmgr        100020\n"
"nlockmgr        100021\n"
"x25.inr         100022\n"
"statmon         100023\n"
"status          100024\n"
"bootparam       100026\n"
"ypupdated       100028  ypupdate\n"
"keyserv         100029  keyserver\n"
"tfsd            100037\n"
"nsed            100038\n"
"nsemntd         100039\n"
msgstr ""
"#\n"
"# rpc 88/08/01 4.0 RPCSRC; from 1.12   88/02/07 SMI\n"
"#\n"
"portmapper      100000  portmap sunrpc\n"
"rstatd          100001  rstat rstat_svc rup perfmeter\n"
"rusersd         100002  rusers\n"
"nfs             100003  nfsprog\n"
"ypserv          100004  ypprog\n"
"mountd          100005  mount showmount\n"
"ypbind          100007\n"
"walld           100008  rwall shutdown\n"
"yppasswdd       100009  yppasswd\n"
"etherstatd      100010  etherstat\n"
"rquotad         100011  rquotaprog quota rquota\n"
"sprayd          100012  spray\n"
"3270_mapper     100013\n"
"rje_mapper      100014\n"
"selection_svc   100015  selnsvc\n"
"database_svc    100016\n"
"rexd            100017  rex\n"
"alis            100018\n"
"sched           100019\n"
"llockmgr        100020\n"
"nlockmgr        100021\n"
"x25.inr         100022\n"
"statmon         100023\n"
"status          100024\n"
"bootparam       100026\n"
"ypupdated       100028  ypupdate\n"
"keyserv         100029  keyserver\n"
"tfsd            100037\n"
"nsed            100038\n"
"nsemntd         100039\n"

#. type: TP
#: man-pages/man5/rpc.5:77
#, no-wrap
msgid "I</etc/rpc>"
msgstr "I</etc/rpc>"

#. type: Plain text
#: man-pages/man5/rpc.5:80
msgid "RPC program number data base"
msgstr "база данных программных номеров RPC"

#. type: Plain text
#: man-pages/man5/rpc.5:81
msgid "B<getrpcent>(3)"
msgstr "B<getrpcent>(3)"

#. type: TH
#: man-pages/man5/resolv.conf.5:23
#, no-wrap
msgid "RESOLV.CONF"
msgstr "RESOLV.CONF"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:27
msgid "resolv.conf - resolver configuration file"
msgstr "resolv.conf - файл настройки для процедур определения имён (resolver)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:29
msgid "B</etc/resolv.conf>"
msgstr "B</etc/resolv.conf>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:41
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to "
"the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information.  The configuration file is considered a trusted source "
"of DNS information (e.g., DNSSEC AD-bit information will be returned "
"unmodified from this source)."
msgstr ""
"I<resolver> — это набор функций из библиотеки Си, который предоставляет "
"доступ к системе доменных имён интернет (DNS). Файл настройки определителя "
"(resolver) содержит информацию, которая читается функциями разрешения имён "
"при первом их вызове процессом. Файл разрабатывался в понятном человеку "
"формате, и содержит список ключевых слов со значениями, которые "
"предоставляют различного рода информацию для функций разрешения имён. Файл "
"настройки считается надёжным источником информации DNS (например, информация "
"об AD-бите DNSSEC будет возвращаться в неизменном виде из этого источника)."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:46
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried; the domain name is determined from the hostname and the domain "
"search path is constructed from the domain name."
msgstr ""
"Если этот файл не существует, то будет опрашиваться только служба имён на "
"локальной машине; доменное имя определяется из имени узла, а домен поиска "
"создаётся из имени домена."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:48
msgid "The different configuration options are:"
msgstr "Поддерживаются следующие параметры настройки:"

#. type: TP
#: man-pages/man5/resolv.conf.5:48
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr "B<nameserver> IP-адрес сервера имён"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:65
msgid ""
"Internet address of a name server that the resolver should query, either an "
"IPv4 address (in dot notation), or an IPv6 address in colon (and possibly "
"dot) notation as per RFC 2373.  Up to B<MAXNS> (currently 3, see "
"I<E<lt>resolv.hE<gt>>) name servers may be listed, one per keyword.  If "
"there are multiple servers, the resolver library queries them in the order "
"listed.  If no B<nameserver> entries are present, the default is to use the "
"name server on the local machine.  (The algorithm used is to try a name "
"server, and if the query times out, try the next, until out of name servers, "
"then repeat trying all the name servers until a maximum number of retries "
"are made.)"
msgstr ""
"Задает интернет-адрес сервера имён, на который надо переправлять все "
"запросы, или в виде адреса IPv4 (в точечном формате), или в виде адреса IPv6 "
"в формате с двоеточиями (и, возможно, точками), определённом в RFC 2373. "
"Может быть указано до B<MAXNS> (в настоящее время 3, см. I<E<lt>resolv."
"hE<gt>>) серверов имён, повторяя каждый раз ключевое слово. Если указано "
"несколько серверов, функции разрешения имён будут обращаться к серверам имен "
"в порядке перечисления. Если в файле нет строк B<nameserver>, то функции "
"разрешения имён используют сервер имён на локальной машине. (Функции "
"разрешения имён работают по следующему алгоритму: попробовать обратиться к "
"первому указанному серверу имён. Если нет ответа в отведённое время, "
"попробовать обратиться к следующему серверу, и т.д. пока не будет исчерпан "
"список серверов.)"

#. type: TP
#: man-pages/man5/resolv.conf.5:65
#, no-wrap
msgid "B<domain> Local domain name."
msgstr "B<domain> локальное доменное имя"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:76
msgid ""
"Most queries for names within this domain can use short names relative to "
"the local domain.  If set to \\(aq.\\(aq, the root domain is considered.  If "
"no B<domain> entry is present, the domain is determined from the local "
"hostname returned by B<gethostname>(2); the domain part is taken to be "
"everything after the first \\(aq.\\(aq.  Finally, if the hostname does not "
"contain a domain part, the root domain is assumed."
msgstr ""
"Для большинства запросов имён с доменом можно использовать короткие имена "
"относительно локального домена. Если значение равно \\(aq.\\(aq, то это "
"считается корневым доменом. Если строки B<domain> в файле настройки нет, "
"домен определяется из локального имени узла, возвращаемого "
"B<gethostname>(2); доменной частью считается всё после первой точки \\(aq."
"\\(aq. Наконец, если имя узла не содержит доменной части, то предполагается "
"корневой домен."

#. type: TP
#: man-pages/man5/resolv.conf.5:76
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr "B<search> список поиска"

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: man-pages/man5/resolv.conf.5:106
msgid ""
"The search list is normally determined from the local domain name; by "
"default, it contains only the local domain name.  This may be changed by "
"listing the desired domain search path following the I<search> keyword with "
"spaces or tabs separating the names.  Resolver queries having fewer than "
"I<ndots> dots (default is 1) in them will be attempted using each component "
"of the search path in turn until a match is found.  For environments with "
"multiple subdomains please read B<options ndots:>I<n> below to avoid man-in-"
"the-middle attacks and unnecessary traffic for the root-dns-servers.  Note "
"that this process may be slow and will generate a lot of network traffic if "
"the servers for the listed domains are not local, and that queries will time "
"out if no server is available for one of the domains."
msgstr ""
"Список поиска обычно определяется по имени локального домена; по умолчанию "
"он содержит только имя локального домена. Это можно изменить, перечислив "
"имена доменов, в которых нужно вести поиск, с ключевым полем I<search> через "
"пробел или символ табуляции. При разрешении запросов имён, в которых меньше "
"точек чем указано в I<ndots> (по умолчанию 1), будет использован каждый "
"компонент пути поиска пока не будет найдено соответствующее имя."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:109
msgid ""
"The search list is currently limited to six domains with a total of 256 "
"characters."
msgstr ""
"Список поиска сейчас может содержать не более шести доменов и не может быть "
"длиннее 256 символов."

#. type: TP
#: man-pages/man5/resolv.conf.5:109
#, no-wrap
msgid "B<sortlist>"
msgstr "B<sortlist>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:122
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted.  "
"A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and "
"optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""
"Вызывает сортировку адресов, возвращаемых функцией B<gethostbyname>(3). "
"Список сортировки задается в виде пар IP-адрес/маска сети. Маску сети "
"указывать не обязательно \\(em по умолчанию используется естественная маска "
"сети. IP-адрес и необязательная маска сети разделяются косой чертой. В "
"списке можно указывать до 10 пар. Пример:"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:125
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"

#. type: TP
#: man-pages/man5/resolv.conf.5:126
#, no-wrap
msgid "B<options>"
msgstr "B<options>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:130
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""
"С помощью параметров изменяются некоторые внутренние переменные функций "
"определения имён. Синтаксис"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:133
msgid "B<options> I<option> I<...>"
msgstr "B<options> I<параметр> I<...>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:135
msgid "where I<option> is one of the following:"
msgstr "где I<параметр> может иметь следующие значения:"

#. type: TP
#: man-pages/man5/resolv.conf.5:135
#, no-wrap
msgid "B<debug>"
msgstr "B<debug>"

#.  Since glibc 2.2?
#. type: Plain text
#: man-pages/man5/resolv.conf.5:144
msgid ""
"Sets B<RES_DEBUG> in I<_res.options> (effective only if glibc was built with "
"debug support; see B<resolver>(3))."
msgstr ""
"Задаёт B<RES_DEBUG> в I<_res.options> (только, если glibc собрана с "
"поддержкой отладки; смотрите B<resolver>(3))."

#. type: TP
#: man-pages/man5/resolv.conf.5:144
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr "B<ndots:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:158
msgid ""
"Sets a threshold for the number of dots which must appear in a name given to "
"B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots "
"in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""
"Задаёт минимальное количество точек, которые должны обязательно "
"присутствовать в имени, переданном функции B<res_query>(3) (см. "
"B<resolver>(3)) прежде чем будет выполнен I<начальный абсолютный запрос>. По "
"умолчанию I<n> равно 1, поэтому если в имени есть точки, сначала имя "
"пытаются разрешить как абсолютное, прежде чем добавлять к нему элементы из "
"I<списка поиска>. Значение этого параметра внутренне доходит до 15."

#. type: TP
#: man-pages/man5/resolv.conf.5:158
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr "B<timeout:>I<n>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:172
msgid ""
"Sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server. This may "
"B<not> be the total time taken by any resolver API call and there is no "
"guarantee that a single resolver API call maps to a single timeout.  "
"Measured in seconds, the default is B<RES_TIMEOUT> (currently 5, see "
"I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""
"Задаёт промежуток времени, который функции определения имён будут ждать "
"ответа от удалённого сервера имён перед тем как повторить запрос другому "
"серверу имён. Он I<не> может быть равным общему времени, затрачиваемым "
"вызовом программного интерфейса определителя, и не гарантируется, что один "
"вызов программного интерфейса определителя соответствует одному промежутку. "
"Измеряется в секундах, по умолчанию B<RES_TIMEOUT> (в настоящее время равно "
"5, смотрите I<E<lt>resolv.hE<gt>>). Значение этого параметра внутренне "
"доходит до 30."

#. type: TP
#: man-pages/man5/resolv.conf.5:172
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr "B<attempts:>I<n>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:181
msgid ""
"Sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""
"Задаёт количество раз, которое функции определения имён будут посылать "
"запрос серверам имён перед тем как закончить работу и вернуть ошибку "
"вызывавшему их приложению. По умолчанию равно B<RES_DFLRETRY> (в настоящее "
"время 2, см. I<E<lt>resolv.hE<gt>>). Значение этого параметра внутренне "
"доходит до 5."

#. type: TP
#: man-pages/man5/resolv.conf.5:181
#, no-wrap
msgid "B<rotate>"
msgstr "B<rotate>"

#.  Since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:191
msgid ""
"Sets B<RES_ROTATE> in I<_res.options>, which causes round-robin selection of "
"name servers from among those listed.  This has the effect of spreading the "
"query load among all listed servers, rather than having all clients try the "
"first listed server first every time."
msgstr ""
"Задаёт значение B<RES_ROTATE> в I<_res.options>, что приводит к циклическому "
"выбору указанных серверов имён. Это приводит к распределению нагрузки среди "
"серверов, чтобы исключить использование каждый раз только первого сервера "
"всеми клиентами."

#. type: TP
#: man-pages/man5/resolv.conf.5:191
#, no-wrap
msgid "B<no-check-names>"
msgstr "B<no-check-names>"

#.  since glibc 2.2
#. type: Plain text
#: man-pages/man5/resolv.conf.5:201
msgid ""
"Sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as "
"underscore (_), non-ASCII, or control characters."
msgstr ""
"Задаёт значение B<RES_NOCHECKNAME> в I<_res.options>, что приводит к "
"выключению в современном BIND проверки в поступающих именах узлов и почтовых "
"именах недопустимых символов, таких как символы подчёркивания (_), не-ASCII "
"или управляющие символы."

#. type: TP
#: man-pages/man5/resolv.conf.5:201
#, no-wrap
msgid "B<inet6>"
msgstr "B<inet6>"

#.  Since glibc 2.2
#.  b76e065991ec01299225d9da90a627ebe6c1ac97
#. type: Plain text
#: man-pages/man5/resolv.conf.5:218
msgid ""
"Sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying an "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists.  Since glibc 2.25, this option is "
"deprecated; applications should use B<getaddrinfo>(3), rather than "
"B<gethostbyname>(3)."
msgstr ""
"Задаёт значение B<RES_USE_INET6> в I<_res.options>. Это приводит к "
"выполнению запроса AAAA раньше запроса A внутри функции B<gethostbyname>(3), "
"и отображению ответов IPv4 в «туннелированную форму» IPv6, если записи AAAA "
"не были обнаружены, но есть запись типа A. Начиная с glibc 2.25 этот "
"параметр считается устаревшим; приложения должны использовать "
"B<getaddrinfo>(3), а не B<gethostbyname>(3)."

#. type: TP
#: man-pages/man5/resolv.conf.5:218
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4)"
msgstr "B<ip6-bytestring> (начиная с glibc 2.3.4)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:230
msgid ""
"Sets B<RES_USEBSTRING> in I<_res.options>.  This causes reverse IPv6 lookups "
"to be made using the bit-label format described in RFC\\ 2673; if this "
"option is not set (which is the default), then nibble format is used.  This "
"option was removed in glibc 2.25, since it relied on a backward-incompatible "
"DNS extension that was never deployed on the Internet."
msgstr ""
"Задаёт значение B<RES_USE_BSTRING> в I<_res.options>. Это приводит к поиску "
"обратной записи IPv6 с помощью формата значимых битов, описанного в RFC\\ "
"2673; если этот параметр не задан (по умолчанию), то используется "
"полубайтовый формат. Данный параметр был удалён в glibc 2.25, так как он "
"полагается на обратно несовместимое расширение DNS, которое никогда не "
"разворачивалось в Интернете."

#. type: TP
#: man-pages/man5/resolv.conf.5:230
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 to 2.24)"
msgstr "B<ip6-dotint>/B<no-ip6-dotint> (glibc 2.3.4 по 2.24)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:253
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  I<ip6."
"int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 lookups "
"are made in the I<ip6.arpa> zone by default.  These options are available in "
"glibc versions up to 2.24, where B<no-ip6-dotint> is the default.  Since "
"B<ip6-dotint> support long ago ceased to be available on the Internet, these "
"options were removed in glibc 2.25."
msgstr ""
"Устанавливает/сбрасывает значение B<RES_NOIP6DOTINT> в I<_res.options>. Если "
"указан сброс (B<ip6-dotint>), то выполняется поиск обратной записи IPv6 "
"(устарел) в зоне I<ip6.int>; если задана установка (B<no-ip6-dotint>), то по "
"умолчанию выполняется поиск обратной записи IPv6 в зоне I<ip6.arpa>. Данные "
"параметры доступны в glibc до версии 2.24, где B<no-ip6-dotint> используется "
"по умолчанию. Так как поддержка B<ip6-dotint> давно приостановлена в "
"Интернете, то эти параметры удалены в glibc 2.25."

#. type: TP
#: man-pages/man5/resolv.conf.5:253
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr "B<edns0> (начиная с glibc 2.6)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:260
msgid ""
"Sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""
"Задаёт значение B<RES_USE_EDNSO> в I<_res.options>. Включает поддержку "
"расширений DNS, описанных в RFC\\ 2671."

#. type: TP
#: man-pages/man5/resolv.conf.5:260
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr "B<single-request> (начиная с glibc 2.10)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:273
msgid ""
"Sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and "
"IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""
"Задаёт значение B<RES_SNGLKUP> в I<_res.options>. По умолчанию, glibc "
"начиная с версии 2.9 выполняет поиск по IPv4 и IPv6 параллельно. Некоторые "
"приложения DNS-серверов не могут обработать такие запросы должным образом и "
"делают паузу между ответами на запрос. Этот параметр отключает данное "
"поведение, что заставляет glibc делать запросы IPv6 и IPv4 последовательно "
"(что замедляет процесс определения имени)."

#. type: TP
#: man-pages/man5/resolv.conf.5:273
#, no-wrap
msgid "B<single-request-reopen> (since glibc 2.9)"
msgstr "B<single-request-reopen> (начиная с glibc 2.9)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:285
msgid ""
"Sets B<RES_SNGLKUPREOP> in I<_res.options>.  The resolver uses the same "
"socket for the A and AAAA requests.  Some hardware mistakenly sends back "
"only one reply.  When that happens the client system will sit and wait for "
"the second reply.  Turning this option on changes this behavior so that if "
"two requests from the same port are not handled correctly it will close the "
"socket and open a new one before sending the second request."
msgstr ""
"Задаёт B<RES_SNGLKUPREOP> в I<_res.options>. Для разрешения имён "
"используется единый сокет для запросов A а AAAA. Некоторая аппаратура "
"ошибочно посылает обратно только один ответ. Когда это происходит, клиент "
"остаётся ждать второго ответа. Указание этого параметра изменяет такое "
"поведение так, что если два запроса с одного порта не обрабатываются "
"правильно, то сокет будет закрыт и открыт новый перед посылкой второго "
"запроса."

#. type: TP
#: man-pages/man5/resolv.conf.5:285
#, no-wrap
msgid "B<no-tld-query> (since glibc 2.14)"
msgstr "B<no-tld-query> (начиная с glibc 2.14)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:298
msgid ""
"Sets B<RES_NOTLDQUERY> in I<_res.options>.  This option causes "
"B<res_nsearch>()  to not attempt to resolve an unqualified name as if it "
"were a top level domain (TLD).  This option can cause problems if the site "
"has ``localhost'' as a TLD rather than having localhost on one or more "
"elements of the search list.  This option has no effect if neither "
"RES_DEFNAMES or RES_DNSRCH is set."
msgstr ""
"Задаёт значение RES_NOTLDQUERY в I<_res.options>. Этот параметр указывает "
"B<res_nsearch>() не пытаться определить неполное имя как если бы это домен "
"верхнего уровня. Данный параметр может привести к проблемам, если сайт "
"указал «localhost» как TLD, но содержит localhost в одном или более "
"элементах списка поиска. Данный параметр не действует, если не установлен "
"RES_DEFNAMES или RES_DNSRCH."

#. type: TP
#: man-pages/man5/resolv.conf.5:298
#, no-wrap
msgid "B<use-vc> (since glibc 2.14)"
msgstr "B<use-vc> (начиная с glibc 2.14)"

#.  aef16cc8a4c670036d45590877d411a97f01e0cd
#. type: Plain text
#: man-pages/man5/resolv.conf.5:306
msgid ""
"Sets B<RES_USEVC> in I<_res.options>.  This option forces the use of TCP for "
"DNS resolutions."
msgstr ""
"Задаёт B<RES_USEVC> в I<_res.options>. Данный параметр включает "
"принудительное использование TCP для запросов DNS."

#. type: TP
#: man-pages/man5/resolv.conf.5:306
#, no-wrap
msgid "B<no-reload> (since glibc 2.26)"
msgstr "B<no-reload> (начиная с glibc 2.26)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:313
msgid ""
"Sets B<RES_NORELOAD> in I<_res.options>.  This option disables automatic "
"reloading of a changed configuration file."
msgstr ""
"Устанавливает B<RES_NORELOAD> в I<_res.options>.  Этот параметр выключает "
"автоматическую перезагрузку изменённого файла настройки."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:318
msgid ""
"The I<domain> and I<search> keywords are mutually exclusive.  If more than "
"one instance of these keywords is present, the last instance wins."
msgstr ""
"Ключевые слова I<domain> и I<search> являются взаимоисключающими. Если они "
"указаны более одного раза, то используется значение последнего."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:323
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on "
"a per-process basis by setting the environment variable B<LOCALDOMAIN> to a "
"space-separated list of search domains."
msgstr ""
"Значение ключевого слова I<search> в системном файле I<resolv.conf> может "
"быть изменено назначением переменной окружения для определённого процесса "
"B<LOCALDOMAIN> списка доменов, разделённых пробелами."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:329
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a "
"per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under B<options>."
msgstr ""
"Значение ключевого слова I<options> в системном файле I<resolv.conf> может "
"быть дополнено назначением переменной окружения для определённого процесса "
"B<RES_OPTIONS> списка вышеописанных в B<options> параметров настройки "
"функций определения имён."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:333
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""
"Ключевое слово и значение должны быть в одной строке, и кроме того, ключевое "
"слово(например, B<nameserver>), должно быть в начале строки. Значение должно "
"отделяться от ключевого слова пробельным символом."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:336
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr ""
"Строки, в которых в первой колонке содержится точка с запятой (;) или символ "
"решётки (#), считаются комментариями."

#. type: Plain text
#: man-pages/man5/resolv.conf.5:339
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:347
msgid ""
"B<gethostbyname>(3), B<resolver>(3), B<host.conf>(5), B<hosts>(5), "
"B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"
msgstr ""
"B<gethostbyname>(3), B<resolver>(3), B<host.conf>(5), B<hosts>(5), "
"B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"

#. type: Plain text
#: man-pages/man5/resolv.conf.5:348
msgid "Name Server Operations Guide for BIND"
msgstr "Руководство по работе с сервером имён BIND"

#. type: Plain text
#: man-pages/man3/random.3:36
msgid "random, srandom, initstate, setstate - random number generator"
msgstr "random, srandom, initstate, setstate - генератор случайных чисел"

#. type: Plain text
#: man-pages/man3/random.3:39
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/random.3:41
#, no-wrap
msgid "B<long int random(void);>\n"
msgstr "B<long int random(void);>\n"

#. type: Plain text
#: man-pages/man3/random.3:43
#, no-wrap
msgid "B<void srandom(unsigned int >I<seed>B<);>\n"
msgstr "B<void srandom(unsigned int >I<seed>B<);>\n"

#. type: Plain text
#: man-pages/man3/random.3:45
#, no-wrap
msgid "B<char *initstate(unsigned int >I<seed>B<, char *>I<state>B<, size_t >I<n>B<);>\n"
msgstr "B<char *initstate(unsigned int >I<seed>B<, char *>I<state>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/random.3:47
#, no-wrap
msgid "B<char *setstate(char *>I<state>B<);>\n"
msgstr "B<char *setstate(char *>I<state>B<);>\n"

#. type: Plain text
#: man-pages/man3/random.3:59
msgid "B<random>(), B<srandom>(), B<initstate>(), B<setstate>():"
msgstr "B<random>(), B<srandom>(), B<initstate>(), B<setstate>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/random.3:64
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версиях glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/random.3:75
msgid ""
"The B<random>()  function uses a nonlinear additive feedback random number "
"generator employing a default table of size 31 long integers to return "
"successive pseudo-random numbers in the range from 0 to B<RAND_MAX>.  The "
"period of this random number generator is very large, approximately I<16\\ *"
"\\ ((2^31)\\ -\\ 1)>."
msgstr ""
"Функция B<random>() использует нелинейный возвратно-аддитивный генератор "
"случайных чисел, используя по умолчанию таблицу из 31-ого длинного целого "
"числа и возвращает очередное псевдослучайное число в промежутке от 0 до "
"B<RAND_MAX>. Период этого генератора очень велик, приблизительно I<16\\ *\\ "
"((2^31)\\ -\\ 1)>."

#. type: Plain text
#: man-pages/man3/random.3:89
msgid ""
"The B<srandom>()  function sets its argument as the seed for a new sequence "
"of pseudo-random integers to be returned by B<random>().  These sequences "
"are repeatable by calling B<srandom>()  with the same seed value.  If no "
"seed value is provided, the B<random>()  function is automatically seeded "
"with a value of 1."
msgstr ""
"Функция B<srandom>() устанавливает свой аргумент в качестве семени для новой "
"последовательности псевдослучайных чисел, которые будут возвращаться "
"функцией B<random>(). Эти последовательности повторяются, если вызывать "
"B<srandom>() с тем же значением семени. Если значение семени не указано, то "
"функция B<random>() автоматически устанавливает его равным 1."

#. type: Plain text
#: man-pages/man3/random.3:108
msgid ""
"The B<initstate>()  function allows a state array I<state> to be initialized "
"for use by B<random>().  The size of the state array I<n> is used by "
"B<initstate>()  to decide how sophisticated a random number generator it "
"should use\\(emthe larger the state array, the better the random numbers "
"will be.  Current \"optimal\" values for the size of the state array I<n> "
"are 8, 32, 64, 128, and 256 bytes; other amounts will be rounded down to the "
"nearest known amount.  Using less than 8 bytes results in an error.  I<seed> "
"is the seed for the initialization, which specifies a starting point for the "
"random number sequence, and provides for restarting at the same point."
msgstr ""
"Функция B<initstate>() позволяет инициализировать массив состояния I<state> "
"для использования в функции B<random>(). Размер массива состояния I<n> "
"используется B<initstate>() для определения, какой сложности генератор "
"случайных чисел необходимо использовать — чем больше массив, тем полученные "
"числа будут более случайными. Текущие «оптимальные» значения размера массива "
"состояния I<n>: 8, 32, 64, 128 и 256 байт; другие значения будут округлены "
"до ближайшей нижней границы. Если значения меньше 8 байт, то возвращается "
"ошибка. Значение I<seed> — это семя последовательности для инициализации, "
"которое определяет стартовую точку последовательности псевдослучайных чисел "
"и позволяет перезапустить последовательность с той же точки."

#. type: Plain text
#: man-pages/man3/random.3:124
msgid ""
"The B<setstate>()  function changes the state array used by the B<random>()  "
"function.  The state array I<state> is used for random number generation "
"until the next call to B<initstate>()  or B<setstate>().  I<state> must "
"first have been initialized using B<initstate>()  or be the result of a "
"previous call of B<setstate>()."
msgstr ""
"Функция B<setstate>() изменяет состояние массива состояния, используемого в "
"B<random>(). Массив состояния I<state> используется для генерации случайных "
"чисел до следующего вызова B<initstate>() или B<setstate>(). Значение "
"I<state> должно быть инициализировано с помощью функции B<initstate>() или "
"результатом предыдущего вызова B<setstate>()."

#. type: Plain text
#: man-pages/man3/random.3:132
msgid ""
"The B<random>()  function returns a value between 0 and B<RAND_MAX>.  The "
"B<srandom>()  function returns no value."
msgstr ""
"Функция B<random>() возвращает значение в промежутке от 0 до B<RAND_MAX>. "
"Функция B<srandom>() не возвращает значение."

#. type: Plain text
#: man-pages/man3/random.3:139
msgid ""
"The B<initstate>()  function returns a pointer to the previous state array.  "
"On error, I<errno> is set to indicate the cause."
msgstr ""
"Функция B<initstate>() возвращает указатель на предыдущий массив состояния. "
"При ошибке в I<errno> записывается соответствующий код."

#. type: Plain text
#: man-pages/man3/random.3:146
msgid ""
"On success, B<setstate>()  returns a pointer to the previous state array.  "
"On error, it returns NULL, with I<errno> set to indicate the cause of the "
"error."
msgstr ""
"При успешном выполнении функция B<setstate>() возвращает указатель на "
"предыдущий массив состояния. При ошибке она возвращает NULL и в I<errno> "
"записывает соответствующий код."

#. type: Plain text
#: man-pages/man3/random.3:154
msgid "The I<state> argument given to B<setstate>()  was NULL."
msgstr "Аргумент I<state>, указанный B<setstate>(), равен NULL."

#. type: Plain text
#: man-pages/man3/random.3:158
msgid "A state array of less than 8 bytes was specified to B<initstate>()."
msgstr "Функции B<initstate>() передан массив состояния меньше 8 байт."

#. type: SH
#: man-pages/man3/random.3:158
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man3/random.3:161
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man3/random.3:165
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man3/random.3:165
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man3/random.3:169
#, no-wrap
msgid ""
"B<random>(),\n"
"B<srandom>(),\n"
msgstr ""
"B<random>(),\n"
"B<srandom>(),\n"

#. type: tbl table
#: man-pages/man3/random.3:169
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/random.3:172
#, no-wrap
msgid ""
"B<initstate>(),\n"
"B<setstate>()"
msgstr ""
"B<initstate>(),\n"
"B<setstate>()"

#. type: tbl table
#: man-pages/man3/random.3:172
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man3/random.3:172
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man3/random.3:176
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: man-pages/man3/random.3:184
msgid ""
"The B<random>()  function should not be used in multithreaded programs where "
"reproducible behavior is required.  Use B<random_r>(3)  for that purpose."
msgstr ""
"Функция B<random>() не должна использоваться в многонитевых программах, где "
"требуется повторение поведения. Для этих целей используйте B<random_r>(3)."

#. type: Plain text
#: man-pages/man3/random.3:191
msgid ""
"Random-number generation is a complex topic.  I<Numerical Recipes in C: The "
"Art of Scientific Computing> (William H.\\& Press, Brian P.\\& Flannery, "
"Saul A.\\& Teukolsky, William T.\\& Vetterling; New York: Cambridge "
"University Press, 2007, 3rd ed.)  provides an excellent discussion of "
"practical random-number generation issues in Chapter 7 (Random Numbers)."
msgstr ""
"Генерация случайных чисел является сложной проблемой. В главе 7 (Random "
"Numbers) I<Numerical Recipes in C: The Art of Scientific Computing> (William "
"H.\\& Press, Brian P.\\& Flannery, Saul A.\\& Teukolsky, William T.\\& "
"Vetterling; New York: Cambridge University Press, 2007, 3rd ed.) приведено "
"великолепное обсуждение проблем практического применения генерации случайных "
"чисел."

#. type: Plain text
#: man-pages/man3/random.3:197
msgid ""
"For a more theoretical discussion which also covers many practical issues in "
"depth, see Chapter 3 (Random Numbers) in Donald E.\\& Knuth's I<The Art of "
"Computer Programming>, volume 2 (Seminumerical Algorithms), 2nd ed.; "
"Reading, Massachusetts: Addison-Wesley Publishing Company, 1981."
msgstr ""
"Также вы можете обратиться к теоретическому обсуждению, которое также "
"объясняет многие практические проблемы, приведенному в главе 3 (Random "
"Numbers) второго тома I<Искусства программирования> Дональда Кнута (The Art "
"of Computer Programming, volume 2 (Seminumerical Algorithms), 2nd ed.; "
"Reading, Massachusetts: Addison-Wesley Publishing Company, 1981)."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=15380
#. type: Plain text
#: man-pages/man3/random.3:205
msgid ""
"According to POSIX, B<initstate>()  should return NULL on error.  In the "
"glibc implementation, I<errno> is (as specified) set on error, but the "
"function does not return NULL."
msgstr ""
"Согласно POSIX, B<initstate>() должна возвращать NULL при ошибке. Реализация "
"glibc в I<errno> записывает код ошибки (как по стандарту), но не возвращает "
"NULL."

#. type: Plain text
#: man-pages/man3/random.3:210
msgid "B<getrandom>(2), B<drand48>(3), B<rand>(3), B<random_r>(3), B<srand>(3)"
msgstr ""
"B<getrandom>(2), B<drand48>(3), B<rand>(3), B<random_r>(3), B<srand>(3)"

#. type: TH
#: man-pages/man3/rcmd.3:43
#, no-wrap
msgid "RCMD"
msgstr "RCMD"

#. type: Plain text
#: man-pages/man3/rcmd.3:48
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - процедуры возврата потока в удалённую команду"

#. type: Plain text
#: man-pages/man3/rcmd.3:51
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems */\n"
msgstr "B<#include E<lt>netdb.hE<gt> \\ \\ >/* или E<lt>unistd.hE<gt> в некоторых системах */\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:54
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""
"B<int rcmd(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:56
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr "B<int rresvport(int *>I<port>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:59
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:62
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:66
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rcmd_af(char **>I<ahost>B<, unsigned short >I<inport>B<, const char *>I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:68
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:72
#, no-wrap
msgid ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int iruserok_af(const void *>I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:76
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:95
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>(),\n"
"B<rresvport>(),\n"
"B<rresvport_af>(),\n"
"B<iruserok>(),\n"
"B<iruserok_af>(),\n"
"B<ruserok>(),\n"
"B<ruserok_af>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""
"B<rcmd>(),\n"
"B<rcmd_af>(),\n"
"B<rresvport>(),\n"
"B<rresvport_af>(),\n"
"B<iruserok>(),\n"
"B<iruserok_af>(),\n"
"B<ruserok>(),\n"
"B<ruserok_af>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/rcmd.3:116
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a file descriptor to a socket "
"with an address in the privileged port space.  The B<iruserok>()  and "
"B<ruserok>()  functions are used by servers to authenticate clients "
"requesting service with B<rcmd>().  All four functions are used by the "
"B<rshd>(8)  server (among others)."
msgstr ""
"Функция B<rcmd>() применяется суперпользователем для исполнения команды на "
"удалённой машине при помощи схемы аутентификации, основанной на "
"зарезервированных номерах портов. Функция B<rresvport>() возвращает файловый "
"дескриптор сокета с адресом в привилегированном пространстве портов. Функции "
"B<iruserok>() и B<ruserok>() используются серверами для аутентификации "
"клиентов, запрашивающих сервис B<rcmd>(). Все четыре функции используются "
"сервером B<rshd>(8) (среди прочих)."

#. type: SS
#: man-pages/man3/rcmd.3:116
#, no-wrap
msgid "rcmd()"
msgstr "rcmd()"

#. type: Plain text
#: man-pages/man3/rcmd.3:132
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host and a connection is "
"established to a server residing at the well-known Internet port I<inport>."
msgstr ""
"Функция B<rcmd>() ищет узел I<*ahost>, используя B<gethostbyname>(3) и "
"возвращает -1, если узел не существует. Иначе I<*ahost> устанавливается "
"равным стандартному имени узла, при этом создаётся соединение с сервером на "
"хорошо известном порту Интернет I<inport>."

#. type: Plain text
#: man-pages/man3/rcmd.3:161
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be set up, and a file descriptor for it will be "
"placed in I<*fd2p>.  The control process will return diagnostic output from "
"the command (unit 2) on this channel, and will also accept bytes on this "
"channel as being UNIX signal numbers, to be forwarded to the process group "
"of the command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote "
"command) will be made the same as the I<stdout> and no provision is made for "
"sending arbitrary signals to the remote process, although you may be able to "
"get its attention by using out-of-band data."
msgstr ""
"Если соединение успешно установлено, то вызывающему возвращается сокет в "
"домене Интернет типа B<SOCK_STREAM>, который для удалённой команды считается "
"I<stdin> и I<stdout>. Если I<fd2p> не равно нулю, то устанавливается "
"вспомогательный канал до управляющего процесса, а его файловый дескриптор "
"будет помещён в I<*fd2p>. Управляющий процесс возвращает диагностический "
"вывод из команды (устройства 2) в этот канал, а также принимает байты из "
"этого канала, считая их номерами сигналов UNIX, для их пересылки группе "
"процессов команды. Если I<fd2p> равно 0, то I<stderr> (устройство 2 "
"удалённой команды) будет работать аналогично I<stdout> и для отправки "
"произвольных сигналов в удалённый процесс не будет создано никаких ходов, "
"хотя вы сможете привлечь к себе внимание, используя внеполосную передачу "
"данных."

#. type: Plain text
#: man-pages/man3/rcmd.3:164
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr "Протокол подробно описан в B<rshd>(8)."

#. type: SS
#: man-pages/man3/rcmd.3:164
#, no-wrap
msgid "rresvport()"
msgstr "rresvport()"

#. type: Plain text
#: man-pages/man3/rcmd.3:188
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several "
"other functions.  Privileged ports are those in the range 0 to 1023.  Only a "
"privileged process (on Linux: a process that has the B<CAP_NET_BIND_SERVICE> "
"capability in the user namespace governing its network namespace).  is "
"allowed to bind to a privileged port.  In the glibc implementation, this "
"function restricts its search to the ports from 512 to 1023.  The I<port> "
"argument is value-result: the value it supplies to the call is used as the "
"starting point for a circular search of the port range; on (successful) "
"return, it contains the port number that was bound to."
msgstr ""
"Функция B<rresvport>() используется для получения сокета с привязанным "
"привилегированным портом. Этот сокет подходит для использования функцией "
"B<rcmd>() и некоторыми другими. Привилегированные порты Интернет — это порты "
"с номерами от 0 до 1023. Только привилегированный процесс (в Linux это "
"процесс с мандатом B<CAP_NET_BIND_SERVICE> в пользовательском пространстве "
"имён, управляющим своим сетевым пространством имён) может привязаться к "
"привилегированному порту. В реализации glibc эта функция ограничена в "
"использовании портов номерами с 512 по 1023. Аргумент I<port> является "
"значением-результатом: передаваемое в вызов значение используется в качестве "
"начальной точки кругового поиска в диапазоне портов; при (успешном) "
"возврате, он содержит номер порта, к которому была осуществлена привязка."

#. type: SS
#: man-pages/man3/rcmd.3:188
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr "iruserok() и ruserok()"

#. type: Plain text
#: man-pages/man3/rcmd.3:206
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not> "
"the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""
"Параметрами функций B<iruserok>() и B<ruserok>() являются, соответственно, "
"IP-адрес или имя удалённого узла, два имени пользователя и флаг, "
"указывающий, является ли имя локального пользователя именем "
"суперпользователя. Далее, если пользователь I<не> является "
"суперпользователем, они проверяют файл I</etc/hosts.equiv>. Если ничего не "
"находится или завершается с ошибкой, то проверяется I<.rhosts> в домашнем "
"каталоге пользователя (для получения информации о том, разрешены ли запросы "
"к службе)."

#. type: Plain text
#: man-pages/man3/rcmd.3:222
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other "
"than the user or the superuser, is writable by anyone other than the owner, "
"or is hardlinked anywhere, the check automatically fails.  Zero is returned "
"if the machine name is listed in the I<hosts.equiv> file, or the host and "
"remote username are found in the I<.rhosts> file; otherwise B<iruserok>()  "
"and B<ruserok>()  return -1.  If the local domain (as obtained from "
"B<gethostname>(2))  is the same as the remote domain, only the machine name "
"need be specified."
msgstr ""
"Если этот файл не существует, не является обычным файлом, если его "
"владельцем является не текущий пользователь или не суперпользователь, если "
"он доступен для записи кому-то помимо владельца или на него есть жёсткая "
"ссылка, то проверка завершается с ошибкой. Если имя машины указано в файле "
"I<hosts.equiv>, или если узел и имя пользователя для удалённого доступа "
"найдены в файле I<.rhosts>, то возвращается 0; иначе B<iruserok>() и "
"B<ruserok>() возвращают -1. Если имя локального домена (полученное вызовом "
"B<gethostname>(2)) совпадает с именем удалённого домена, то может "
"указываться только имя машины."

#. type: Plain text
#: man-pages/man3/rcmd.3:228
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used "
"in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""
"Если IP-адрес удалённого узла известен, то должна использоваться "
"B<iruserok>() вместо B<ruserok>(), так как при этом не требуется доверия к "
"DNS-серверу для домена удалённого узла."

#. type: SS
#: man-pages/man3/rcmd.3:228
#, no-wrap
msgid "*_af() variants"
msgstr "Варианты *_af()"

#. type: Plain text
#: man-pages/man3/rcmd.3:244
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports "
"the use of B<AF_UNSPEC>."
msgstr ""
"Все описанные ранее функции работают с сокетами IPv4 (B<AF_INET>). Варианты "
"«_af»  имеют дополнительный аргумент, который позволяет указать адресное "
"семейство сокета. Для этих функций значением аргумента I<af> может быть "
"B<AF_INET> или B<AF_INET6>. Также B<rcmd_af>() поддерживает использование "
"B<AF_UNSPEC>."

#. type: Plain text
#: man-pages/man3/rcmd.3:250
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""
"Функция B<rcmd>() при успешном выполнении возвращает корректный номер "
"дескриптора сокета. При ошибках возвращается -1 и в стандартный поток ошибок "
"выводится диагностическое сообщение."

#. type: Plain text
#: man-pages/man3/rcmd.3:261
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded "
"to mean \"All network ports in use.\""
msgstr ""
"Функция B<rresvport>() при успешном выполнении возвращает корректный "
"привязанный дескриптор сокета. При ошибках возвращается -1 и в глобальную "
"переменную I<errno> записывается код ошибки. Код ошибки B<EAGAIN> означает "
"«Все сетевые порты заняты»."

#. type: Plain text
#: man-pages/man3/rcmd.3:267
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr "Информацию о результатах B<ruserok>() и B<iruserok>() смотрите выше."

#. type: Plain text
#: man-pages/man3/rcmd.3:275
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""
"Функции B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>() и B<ruserok_af>() "
"появились в glibc начиная с версии 2.2."

#. type: tbl table
#: man-pages/man3/rcmd.3:286
#, no-wrap
msgid ""
"B<rcmd>(),\n"
"B<rcmd_af>()"
msgstr ""
"B<rcmd>(),\n"
"B<rcmd_af>()"

#. type: tbl table
#: man-pages/man3/rcmd.3:286
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: tbl table
#: man-pages/man3/rcmd.3:290
#, no-wrap
msgid ""
"B<rresvport>(),\n"
"B<rresvport_af>()"
msgstr ""
"B<rresvport>(),\n"
"B<rresvport_af>()"

#. type: tbl table
#: man-pages/man3/rcmd.3:294
#, no-wrap
msgid ""
"B<iruserok>(),\n"
"B<ruserok>(),\n"
msgstr ""
"B<iruserok>(),\n"
"B<ruserok>(),\n"

#. type: tbl table
#: man-pages/man3/rcmd.3:297
#, no-wrap
msgid ""
"B<iruserok_af>(),\n"
"B<ruserok_af>()"
msgstr ""
"B<iruserok_af>(),\n"
"B<ruserok_af>()"

#. type: tbl table
#: man-pages/man3/rcmd.3:297
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: man-pages/man3/rcmd.3:308
msgid ""
"Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems.  "
"These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""
"Отсутствуют в POSIX.1. Есть в BSD, Solaris и многих других системах. Данные "
"функции впервые появились в 4.2BSD. Варианты «_af» были добавлены позднее и "
"распространены не так широко."

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: man-pages/man3/rcmd.3:315
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""
"Функции B<iruserok>() и B<iruserok_af>() объявляются в заголовках glibc "
"только начиная с версии 2.12."

#. type: Plain text
#: man-pages/man3/rcmd.3:322
msgid ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), "
"B<rlogind>(8), B<rshd>(8)"
msgstr ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), "
"B<rlogind>(8), B<rshd>(8)"

#. type: TH
#: man-pages/man3/round.3:27
#, no-wrap
msgid "ROUND"
msgstr "ROUND"

#. type: Plain text
#: man-pages/man3/round.3:30
msgid "round, roundf, roundl - round to nearest integer, away from zero"
msgstr ""
"round, roundf, roundl - округление до ближайшего целого в направлении от нуля"

#. type: Plain text
#: man-pages/man3/round.3:33
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/round.3:37
#, no-wrap
msgid ""
"B<double round(double >I<x>B<);>\n"
"B<float roundf(float >I<x>B<);>\n"
"B<long double roundl(long double >I<x>B<);>\n"
msgstr ""
"B<double round(double >I<x>B<);>\n"
"B<float roundf(float >I<x>B<);>\n"
"B<long double roundl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/round.3:40
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/round.3:50
msgid "B<round>(), B<roundf>(), B<roundl>():"
msgstr "B<round>(), B<roundf>(), B<roundl>():"

#. type: Plain text
#: man-pages/man3/round.3:52
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/round.3:63
msgid ""
"These functions round I<x> to the nearest integer, but round halfway cases "
"away from zero (regardless of the current rounding direction, see "
"B<fenv>(3)), instead of to the nearest even integer like B<rint>(3)."
msgstr ""
"Эти функции округляют аргумент I<x> до ближайшего целого значения, но при "
"округлении в половине случаев используют направление округления от нуля "
"(независимо от текущего направления округления, смотрите B<fenv>(3)), вместо "
"округления до ближайшего чётного целого, как это делает функция B<rint>(3)."

#. type: Plain text
#: man-pages/man3/round.3:69
msgid "For example, I<round(0.5)> is 1.0, and I<round(-0.5)> is -1.0."
msgstr ""
"Например, результат I<round(0.5)> будет равен 1.0, а I<round(-0.5)> будет "
"равен -1.0."

#. type: Plain text
#: man-pages/man3/round.3:71
msgid "These functions return the rounded integer value."
msgstr "Данные функции возвращают округлённое целое число."

#. type: Plain text
#: man-pages/man3/round.3:77
msgid "If I<x> is integral, +0, -0, NaN, or infinite, I<x> itself is returned."
msgstr ""
"Если I<x> целое, +0, -0, NaN или стремится к бесконечности, то будет "
"возвращено значение I<x>."

#. type: Plain text
#: man-pages/man3/round.3:80
msgid ""
"No errors occur.  POSIX.1-2001 documents a range error for overflows, but "
"see NOTES."
msgstr ""
"Ошибки не возникают. В документах POSIX.1-2001 описывается ошибка диапазона "
"при переполнениях, однако смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man3/round.3:82
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: tbl table
#: man-pages/man3/round.3:94
#, no-wrap
msgid ""
"B<round>(),\n"
"B<roundf>(),\n"
"B<roundl>()"
msgstr ""
"B<round>(),\n"
"B<roundf>(),\n"
"B<roundl>()"

#. type: Plain text
#: man-pages/man3/round.3:98
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C99, POSIX.1-2001, POSIX.1-2008."

#.  The POSIX.1-2001 APPLICATION USAGE SECTION discusses this point.
#. type: Plain text
#: man-pages/man3/round.3:114
msgid ""
"POSIX.1-2001 contains text about overflow (which might set I<errno> to "
"B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the result "
"cannot overflow on any current machine, so this error-handling stuff is just "
"nonsense.  (More precisely, overflow can happen only when the maximum value "
"of the exponent is smaller than the number of mantissa bits.  For the "
"IEEE-754 standard 32-bit and 64-bit floating-point numbers the maximum value "
"of the exponent is 128 (respectively, 1024), and the number of mantissa bits "
"is 24 (respectively, 53).)"
msgstr ""
"В POSIX.1-2001 есть текст о переполнении (которое может установить I<errno> "
"в B<ERANGE> или вызвать исключение B<FE_OVERFLOW>). На практике, результат "
"не может выйти за диапазон ни на каком компьютере, поэтому обработка этой "
"ошибки не имеет смысла (точнее говоря, переполнение возможно только в том "
"случае, когда максимальное значение экспоненты меньше числа бит мантиссы. В "
"стандарте IEEE-754 для 32- и 64-битных чисел с плавающей точкой максимальное "
"значение экспоненты равно 128 и 1024 соответственно, а число бит мантиссы — "
"24 и 53 соответственно)."

#. type: Plain text
#: man-pages/man3/round.3:119
msgid ""
"If you want to store the rounded value in an integer type, you probably want "
"to use one of the functions described in B<lround>(3)  instead."
msgstr ""
"Если вы хотите сохранить округлённое значение в целочисленном типе, то лучше "
"использовать одну из функций, описанных в B<lround>(3)."

#. type: Plain text
#: man-pages/man3/round.3:125
msgid ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), "
"B<trunc>(3)"
msgstr ""
"B<ceil>(3), B<floor>(3), B<lround>(3), B<nearbyint>(3), B<rint>(3), "
"B<trunc>(3)"

#. type: TH
#: man-pages/man3/rand.3:41
#, no-wrap
msgid "RAND"
msgstr "RAND"

#. type: Plain text
#: man-pages/man3/rand.3:44
msgid "rand, rand_r, srand - pseudo-random number generator"
msgstr "rand, rand_r, srand - генератор псевдослучайных чисел"

#. type: Plain text
#: man-pages/man3/rand.3:49
#, no-wrap
msgid "B<int rand(void);>\n"
msgstr "B<int rand(void);>\n"

#. type: Plain text
#: man-pages/man3/rand.3:51
#, no-wrap
msgid "B<int rand_r(unsigned int *>I<seedp>B<);>\n"
msgstr "B<int rand_r(unsigned int *>I<seedp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rand.3:53
#, no-wrap
msgid "B<void srand(unsigned int >I<seed>B<);>\n"
msgstr "B<void srand(unsigned int >I<seed>B<);>\n"

#. type: Plain text
#: man-pages/man3/rand.3:61
msgid "B<rand_r>():"
msgstr "B<rand_r>():"

#. type: Plain text
#: man-pages/man3/rand.3:64
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"
msgstr ""
"начиная с glibc 2.24:\n"
"    _POSIX_C_SOURCE E<gt>= 199506L\n"

#. type: Plain text
#: man-pages/man3/rand.3:67
#, no-wrap
msgid ""
"Glibc 2.23 and earlier\n"
"    _POSIX_C_SOURCE\n"
msgstr ""
"в glibc 2.23 и старее\n"
"    _POSIX_C_SOURCE\n"

#. type: Plain text
#: man-pages/man3/rand.3:74
msgid ""
"The B<rand>()  function returns a pseudo-random integer in the range 0 to "
"B<RAND_MAX> inclusive (i.e., the mathematical range [0,\\ B<RAND_MAX>])."
msgstr ""
"Функция B<rand>() возвращает псевдослучайное целое число в диапазоне от нуля "
"до B<RAND_MAX> включительно (т. е., из математического диапазона [0,\\ "
"B<RAND_MAX>])."

#. type: Plain text
#: man-pages/man3/rand.3:83
msgid ""
"The B<srand>()  function sets its argument as the seed for a new sequence of "
"pseudo-random integers to be returned by B<rand>().  These sequences are "
"repeatable by calling B<srand>()  with the same seed value."
msgstr ""
"Функция B<srand>() устанавливает свой аргумент как основу (seed) для новой "
"последовательности псевдослучайных целых чисел, возвращаемых функцией "
"B<rand>(). Эту последовательность можно воспроизвести. Для этого необходимо "
"вызвать B<srand>() с той же величиной основы."

#. type: Plain text
#: man-pages/man3/rand.3:87
msgid ""
"If no seed value is provided, the B<rand>()  function is automatically "
"seeded with a value of 1."
msgstr ""
"Если основа не задана, то функция B<rand>() автоматически устанавливает её "
"равной 1."

#. type: Plain text
#: man-pages/man3/rand.3:98
msgid ""
"The function B<rand>()  is not reentrant, since it uses hidden state that is "
"modified on each call.  This might just be the seed value to be used by the "
"next call, or it might be something more elaborate.  In order to get "
"reproducible behavior in a threaded application, this state must be made "
"explicit; this can be done using the reentrant function B<rand_r>()."
msgstr ""
"Функция B<rand>() не реентерабельная, так как она использует скрытое "
"состояние, которое изменяется с каждым вызовом. Это может быть как просто "
"значение основы, так и что-то более сложное. Чтобы получить воспроизводимое "
"поведение в многонитевом приложении такое состояние нужно создать явным "
"образом; это можно сделать с помощью реентерабельной функции B<rand_r>()."

#. type: Plain text
#: man-pages/man3/rand.3:114
msgid ""
"Like B<rand>(), B<rand_r>()  returns a pseudo-random integer in the range [0,"
"\\ B<RAND_MAX>].  The I<seedp> argument is a pointer to an I<unsigned int> "
"that is used to store state between calls.  If B<rand_r>()  is called with "
"the same initial value for the integer pointed to by I<seedp>, and that "
"value is not modified between calls, then the same pseudo-random sequence "
"will result."
msgstr ""
"Как и B<rand>(), B<rand_r>() возвращает псевдослучайное целое число из "
"диапазона [0,\\ B<RAND_MAX>]. Аргумент I<seedp> является указателем на число "
"I<unsigned int>, которое используется для хранения состояния между вызовами. "
"Если B<rand_r>() вызывается с одинаковым начальным значением целого, на "
"которое указывает I<seedp>, и это значение не изменяется между вызовами, то "
"результатом будет одинаковая псевдослучайная последовательность."

#. type: Plain text
#: man-pages/man3/rand.3:124
msgid ""
"The value pointed to by the I<seedp> argument of B<rand_r>()  provides only "
"a very small amount of state, so this function will be a weak pseudo-random "
"generator.  Try B<drand48_r>(3)  instead."
msgstr ""
"Значение, на которое указывает аргумент I<seedp> для B<rand_r>(), "
"предоставляет только очень малую часть состояния, поэтому данная функция "
"будет очень не случайным псевдослучайным генератором. Используйте вместо неё "
"B<drand48_r>(3)."

#. type: Plain text
#: man-pages/man3/rand.3:135
msgid ""
"The B<rand>()  and B<rand_r>()  functions return a value between 0 and "
"B<RAND_MAX> (inclusive).  The B<srand>()  function returns no value."
msgstr ""
"Функции B<rand>() и B<rand_r>() возвращают значение в промежутке от 0 до "
"B<RAND_MAX> (включительно). Функция B<srand>() не возвращает результат."

#. type: tbl table
#: man-pages/man3/rand.3:147
#, no-wrap
msgid ""
"B<rand>(),\n"
"B<rand_r>(),\n"
"B<srand>()"
msgstr ""
"B<rand>(),\n"
"B<rand_r>(),\n"
"B<srand>()"

#. type: Plain text
#: man-pages/man3/rand.3:161
msgid ""
"The functions B<rand>()  and B<srand>()  conform to SVr4, 4.3BSD, C89, C99, "
"POSIX.1-2001.  The function B<rand_r>()  is from POSIX.1-2001.  POSIX.1-2008 "
"marks B<rand_r>()  as obsolete."
msgstr ""
"Функции B<rand>() и B<srand>() описаны в SVr4, 4.3BSD, C89, C99, "
"POSIX.1-2001. Функция B<rand_r>() описана в POSIX.1-2001. В POSIX.1-2008 "
"функция B<rand_r>() помечена как устаревшая."

#. type: Plain text
#: man-pages/man3/rand.3:180
msgid ""
"The versions of B<rand>()  and B<srand>()  in the Linux C Library use the "
"same random number generator as B<random>(3)  and B<srandom>(3), so the "
"lower-order bits should be as random as the higher-order bits.  However, on "
"older B<rand>()  implementations, and on current implementations on "
"different systems, the lower-order bits are much less random than the higher-"
"order bits.  Do not use this function in applications intended to be "
"portable when good randomness is needed.  (Use B<random>(3)  instead.)"
msgstr ""
"Версия функций B<rand>() и B<srand>() в библиотеке Си для Linux использует "
"тот же генератор чисел, что и в функциях B<random>(3) и B<srandom>(3), так "
"что младшие биты в числе случайны настолько, насколько и старшие. В то же "
"время, в старых реализациях B<rand>() и в текущих реализациях на других "
"системах младшие биты являются гораздо менее случайными, чем старшие. Не "
"используйте эту функцию в переносимых приложениях, для которых требуется "
"большая случайность (вместо неё используйте B<random>(3))."

#. type: Plain text
#: man-pages/man3/rand.3:186
msgid ""
"POSIX.1-2001 gives the following example of an implementation of B<rand>()  "
"and B<srand>(), possibly useful when one needs the same sequence on two "
"different machines."
msgstr ""
"В POSIX.1-2001 приведён следующий пример реализации B<rand>() и B<srand>(), "
"возможно полезный, если требуется одинаковая последовательность на двух "
"разных машинах."

#. type: Plain text
#: man-pages/man3/rand.3:190
#, no-wrap
msgid "static unsigned long next = 1;\n"
msgstr "static unsigned long next = 1;\n"

#. type: Plain text
#: man-pages/man3/rand.3:196
#, no-wrap
msgid ""
"/* RAND_MAX assumed to be 32767 */\n"
"int myrand(void) {\n"
"    next = next * 1103515245 + 12345;\n"
"    return((unsigned)(next/65536) % 32768);\n"
"}\n"
msgstr ""
"/* предполагается, что RAND_MAX равно 32767 */\n"
"int myrand(void) {\n"
"    next = next * 1103515245 + 12345;\n"
"    return((unsigned)(next/65536) % 32768);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/rand.3:200
#, no-wrap
msgid ""
"void mysrand(unsigned int seed) {\n"
"    next = seed;\n"
"}\n"
msgstr ""
"void mysrand(unsigned int seed) {\n"
"    next = seed;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/rand.3:207
msgid ""
"The following program can be used to display the pseudo-random sequence "
"produced by B<rand>()  when given a particular seed."
msgstr ""
"Следующая программа может использоваться для отображения псевдослучайной "
"последовательности, созданной B<rand>() при указании определённой основы."

#. type: Plain text
#: man-pages/man3/rand.3:212
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rand.3:218
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, r, nloops;\n"
"    unsigned int seed;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, r, nloops;\n"
"    unsigned int seed;\n"

#. type: Plain text
#: man-pages/man3/rand.3:223
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>seedE<gt> E<lt>nloopsE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>seedE<gt> E<lt>nloopsE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/rand.3:226
#, no-wrap
msgid ""
"    seed = atoi(argv[1]);\n"
"    nloops = atoi(argv[2]);\n"
msgstr ""
"    seed = atoi(argv[1]);\n"
"    nloops = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/rand.3:232
#, no-wrap
msgid ""
"    srand(seed);\n"
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        r =  rand();\n"
"        printf(\"%d\\en\", r);\n"
"    }\n"
msgstr ""
"    srand(seed);\n"
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        r =  rand();\n"
"        printf(\"%d\\en\", r);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/rand.3:239
msgid "B<drand48>(3), B<random>(3)"
msgstr "B<drand48>(3), B<random>(3)"

#. type: TH
#: man-pages/man3/rewinddir.3:31
#, no-wrap
msgid "REWINDDIR"
msgstr "REWINDDIR"

#. type: Plain text
#: man-pages/man3/rewinddir.3:34
msgid "rewinddir - reset directory stream"
msgstr "rewinddir - сброс потока каталога"

#. type: Plain text
#: man-pages/man3/rewinddir.3:39
#, no-wrap
msgid "B<#include E<lt>dirent.hE<gt>>\n"
msgstr "B<#include E<lt>dirent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/rewinddir.3:41
#, no-wrap
msgid "B<void rewinddir(DIR *>I<dirp>B<);>\n"
msgstr "B<void rewinddir(DIR *>I<dirp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rewinddir.3:49
msgid ""
"The B<rewinddir>()  function resets the position of the directory stream "
"I<dirp> to the beginning of the directory."
msgstr ""
"Функция B<rewinddir>() сбрасывает текущее положение потока каталога I<dirp> "
"в начало каталога."

#. type: Plain text
#: man-pages/man3/rewinddir.3:53
msgid "The B<rewinddir>()  function returns no value."
msgstr "Функция B<rewinddir>() ничего не возвращает."

#. type: tbl table
#: man-pages/man3/rewinddir.3:63
#, no-wrap
msgid "B<rewinddir>()"
msgstr "B<rewinddir>()"

#. type: Plain text
#: man-pages/man3/rewinddir.3:73
msgid ""
"B<closedir>(3), B<opendir>(3), B<readdir>(3), B<scandir>(3), B<seekdir>(3), "
"B<telldir>(3)"
msgstr ""
"B<closedir>(3), B<opendir>(3), B<readdir>(3), B<scandir>(3), B<seekdir>(3), "
"B<telldir>(3)"

#. type: TH
#: man-pages/man3/rtnetlink.3:12
#, no-wrap
msgid "2014-09-06"
msgstr "2014-09-06"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:15
msgid "rtnetlink - macros to manipulate rtnetlink messages"
msgstr "rtnetlink - макросы для обработки сообщений rtnetlink"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:28
msgid "B<int RTA_OK(struct rtattr *>I<rta>B<, int >I<rtabuflen>B<);>"
msgstr "B<int RTA_OK(struct rtattr *>I<rta>B<, int >I<rtabuflen>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:30
msgid "B<void *RTA_DATA(struct rtattr *>I<rta>B<);>"
msgstr "B<void *RTA_DATA(struct rtattr *>I<rta>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:32
msgid "B<unsigned int RTA_PAYLOAD(struct rtattr *>I<rta>B<);>"
msgstr "B<unsigned int RTA_PAYLOAD(struct rtattr *>I<rta>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:35
msgid ""
"B<struct rtattr *RTA_NEXT(struct rtattr *>I<rta>B<, unsigned int "
">I<rtabuflen>B<);>"
msgstr ""
"B<struct rtattr *RTA_NEXT(struct rtattr *>I<rta>B<, unsigned int "
">I<rtabuflen>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:37
msgid "B<unsigned int RTA_LENGTH(unsigned int >I<length>B<);>"
msgstr "B<unsigned int RTA_LENGTH(unsigned int >I<length>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:39
msgid "B<unsigned int RTA_SPACE(unsigned int >I<length>B<);>"
msgstr "B<unsigned int RTA_SPACE(unsigned int >I<length>B<);>"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:46
msgid ""
"All B<rtnetlink>(7)  messages consist of a B<netlink>(7)  message header and "
"appended attributes.  The attributes should be manipulated only using the "
"macros provided here."
msgstr ""
"Все сообщения B<rtnetlink>(7) состоят из заголовка сообщений B<netlink>(7) и "
"дополнительных атрибутов. Атрибуты могут быть обработаны только описанными "
"здесь макросами."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:57
msgid ""
"B<RTA_OK(>I<rta>B<, >I<attrlen>B<)> returns true if I<rta> points to a valid "
"routing attribute; I<attrlen> is the running length of the attribute "
"buffer.  When not true then you must assume there are no more attributes in "
"the message, even if I<attrlen> is nonzero."
msgstr ""
"B<RTA_OK(>I<rta>B<, >I<attrlen>B<)> возвращает истинное значение в случае, "
"если I<rta> указывает на правильный атрибут маршрутизации; I<attrlen> — "
"рабочая длина буфера атрибутов. Если возвращаемое значение ложно, то в "
"сообщении больше нет атрибутов, даже если I<attrlen> не равно нулю."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:60
msgid ""
"B<RTA_DATA(>I<rta>B<)> returns a pointer to the start of this attribute's "
"data."
msgstr "B<RTA_DATA(>I<rta>B<)> возвращает указатель на начало данных атрибута."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:63
msgid "B<RTA_PAYLOAD(>I<rta>B<)> returns the length of this attribute's data."
msgstr "B<RTA_PAYLOAD(>I<rta>B<)> возвращает длину данных атрибута."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:72
msgid ""
"B<RTA_NEXT(>I<rta>B<, >I<attrlen>B<)> gets the next attribute after I<rta>.  "
"Calling this macro will update I<attrlen>.  You should use B<RTA_OK> to "
"check the validity of the returned pointer."
msgstr ""
"B<RTA_NEXT(>I<rta>B<, >I<attrlen>B<)> считывает следующий за I<rta> атрибут. "
"Вызов этого макроса обновит I<attrlen>. Для проверки правильности "
"полученного указателя используйте B<RTA_OK>."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:77
msgid ""
"B<RTA_LENGTH(>I<len>B<)> returns the length which is required for I<len> "
"bytes of data plus the header."
msgstr ""
"B<RTA_LENGTH(>I<len>B<)> возвращает длину, которая требуется для I<len> "
"байтов данных плюс заголовок."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:82
msgid ""
"B<RTA_SPACE(>I<len>B<)> returns the amount of space which will be needed in "
"a message with I<len> bytes of data."
msgstr ""
"B<RTA_SPACE(>I<len>B<)> возвращает количество места, которое требуется для "
"сообщения с данными длиной I<len> байт."

#. type: Plain text
#: man-pages/man3/rtnetlink.3:84
msgid "These macros are nonstandard Linux extensions."
msgstr "Данные макросы являются нестандартными расширениями Linux."

#.  FIXME . ? would be better to use libnetlink in the EXAMPLE code here
#. type: Plain text
#: man-pages/man3/rtnetlink.3:89
msgid "Creating a rtnetlink message to set the MTU of a device:"
msgstr "Создание сообщения rtnetlink для установки MTU устройства:"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:93
#, no-wrap
msgid "#include E<lt>linux/rtnetlink.hE<gt>\n"
msgstr "#include E<lt>linux/rtnetlink.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:95
#, no-wrap
msgid "\\&...\n"
msgstr "\\&...\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:101
#, no-wrap
msgid ""
"struct {\n"
"    struct nlmsghdr  nh;\n"
"    struct ifinfomsg if;\n"
"    char             attrbuf[512];\n"
"} req;\n"
msgstr ""
"struct {\n"
"    struct nlmsghdr  nh;\n"
"    struct ifinfomsg if;\n"
"    char             attrbuf[512];\n"
"} req;\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:104
#, no-wrap
msgid ""
"struct rtattr *rta;\n"
"unsigned int mtu = 1000;\n"
msgstr ""
"struct rtattr *rta;\n"
"unsigned int mtu = 1000;\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:106
#, no-wrap
msgid "int rtnetlink_sk = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n"
msgstr "int rtnetlink_sk = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE);\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:122
#, no-wrap
msgid ""
"memset(&req, 0, sizeof(req));\n"
"req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n"
"req.nh.nlmsg_flags = NLM_F_REQUEST;\n"
"req.nh.nlmsg_type = RTM_NEWLINK;\n"
"req.if.ifi_family = AF_UNSPEC;\n"
"req.if.ifi_index = INTERFACE_INDEX;\n"
"req.if.ifi_change = 0xffffffff; /* ??? */\n"
"rta = (struct rtattr *)(((char *) &req) +\n"
"                         NLMSG_ALIGN(req.nh.nlmsg_len));\n"
"rta-E<gt>rta_type = IFLA_MTU;\n"
"rta-E<gt>rta_len = RTA_LENGTH(sizeof(unsigned int));\n"
"req.nh.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) +\n"
"                              RTA_LENGTH(sizeof(mtu));\n"
"memcpy(RTA_DATA(rta), &mtu, sizeof(mtu));\n"
"send(rtnetlink_sk, &req, req.nh.nlmsg_len, 0);\n"
msgstr ""
"memset(&req, 0, sizeof(req));\n"
"req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));\n"
"req.nh.nlmsg_flags = NLM_F_REQUEST;\n"
"req.nh.nlmsg_type = RTM_NEWLINK;\n"
"req.if.ifi_family = AF_UNSPEC;\n"
"req.if.ifi_index = INTERFACE_INDEX;\n"
"req.if.ifi_change = 0xffffffff; /* ??? */\n"
"rta = (struct rtattr *)(((char *) &req) +\n"
"                         NLMSG_ALIGN(req.nh.nlmsg_len));\n"
"rta-E<gt>rta_type = IFLA_MTU;\n"
"rta-E<gt>rta_len = RTA_LENGTH(sizeof(unsigned int));\n"
"req.nh.nlmsg_len = NLMSG_ALIGN(req.nh.nlmsg_len) +\n"
"                              RTA_LENGTH(sizeof(mtu));\n"
"memcpy(RTA_DATA(rta), &mtu, sizeof(mtu));\n"
"send(rtnetlink_sk, &req, req.nh.nlmsg_len, 0);\n"

#. type: Plain text
#: man-pages/man3/rtnetlink.3:127
msgid "B<netlink>(3), B<netlink>(7), B<rtnetlink>(7)"
msgstr "B<netlink>(3), B<netlink>(7), B<rtnetlink>(7)"

#. type: Plain text
#: man-pages/man3/regex.3:33
msgid "regcomp, regexec, regerror, regfree - POSIX regex functions"
msgstr ""
"regcomp, regexec, regerror, regfree - функции регулярных выражений POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>regex.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>regex.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/regex.3:39
#, no-wrap
msgid "B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int >I<cflags>B<);>\n"
msgstr "B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int >I<cflags>B<);>\n"

#. type: Plain text
#: man-pages/man3/regex.3:43
#, no-wrap
msgid ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"
msgstr ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t >I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"

#. type: Plain text
#: man-pages/man3/regex.3:46
#, no-wrap
msgid ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"
msgstr ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char *>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"

#. type: Plain text
#: man-pages/man3/regex.3:48
#, no-wrap
msgid "B<void regfree(regex_t *>I<preg>B<);>\n"
msgstr "B<void regfree(regex_t *>I<preg>B<);>\n"

#. type: SS
#: man-pages/man3/regex.3:50
#, no-wrap
msgid "POSIX regex compiling"
msgstr "Компилирование регулярных выражений POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:56
msgid ""
"B<regcomp>()  is used to compile a regular expression into a form that is "
"suitable for subsequent B<regexec>()  searches."
msgstr ""
"Функция B<regcomp>() используется для компиляции регулярного выражения в "
"формат, который подходит для последующих поисков с помощью B<regexec>()."

#. type: Plain text
#: man-pages/man3/regex.3:65
msgid ""
"B<regcomp>()  is supplied with I<preg>, a pointer to a pattern buffer "
"storage area; I<regex>, a pointer to the null-terminated string and "
"I<cflags>, flags used to determine the type of compilation."
msgstr ""
"B<regcomp>() передаётся указатель на область хранения буферного шаблона "
"I<preg>, указатель на заканчивающуюся null строку I<regex> и флаги "
"I<cflags>, используемые для определения типа компиляции."

#. type: Plain text
#: man-pages/man3/regex.3:72
msgid ""
"All regular expression searching must be done via a compiled pattern buffer, "
"thus B<regexec>()  must always be supplied with the address of a "
"B<regcomp>()  initialized pattern buffer."
msgstr ""
"Все поиски регулярных выражений должны выполняться с помощью "
"скомпилированного буферного шаблона, поэтому B<regexec>() должна всегда "
"вызываться с адресом буферного шаблона, инициализированного функцией "
"B<regcomp>()."

#. type: Plain text
#: man-pages/man3/regex.3:77
msgid "I<cflags> may be the bitwise-B<or> of zero or more of the following:"
msgstr ""
"Значение I<cflags> может состоять из поразрядного B<or> нуля или нескольких "
"следующих значений:"

#. type: TP
#: man-pages/man3/regex.3:77
#, no-wrap
msgid "B<REG_EXTENDED>"
msgstr "B<REG_EXTENDED>"

#. type: Plain text
#: man-pages/man3/regex.3:86
msgid ""
"Use B<POSIX> Extended Regular Expression syntax when interpreting I<regex>.  "
"If not set, B<POSIX> Basic Regular Expression syntax is used."
msgstr ""
"Использовать синтаксис расширенных регулярных выражений POSIX во время "
"интерпретации I<regex>. Если не включён этот флаг, то используется синтаксис "
"простых регулярных выражений POSIX."

#. type: TP
#: man-pages/man3/regex.3:86
#, no-wrap
msgid "B<REG_ICASE>"
msgstr "B<REG_ICASE>"

#. type: Plain text
#: man-pages/man3/regex.3:92
msgid ""
"Do not differentiate case.  Subsequent B<regexec>()  searches using this "
"pattern buffer will be case insensitive."
msgstr ""
"Не учитывать регистр. Последующие поиски B<regexec>() с использованием "
"данного буферного шаблона не будут зависеть от регистра."

#. type: TP
#: man-pages/man3/regex.3:92
#, no-wrap
msgid "B<REG_NOSUB>"
msgstr "B<REG_NOSUB>"

#. type: Plain text
#: man-pages/man3/regex.3:102
msgid ""
"Do not report position of matches.  The I<nmatch> and I<pmatch> arguments to "
"B<regexec>()  are ignored if the pattern buffer supplied was compiled with "
"this flag set."
msgstr ""
"Не сообщать положение совпадений. Параметры I<nmatch> и I<pmatch> для "
"B<regexec>() игнорируются, если данный буферный шаблон был скомпилирован с "
"этим включённым флагом."

#. type: TP
#: man-pages/man3/regex.3:102
#, no-wrap
msgid "B<REG_NEWLINE>"
msgstr "B<REG_NEWLINE>"

#. type: Plain text
#: man-pages/man3/regex.3:105
msgid "Match-any-character operators don't match a newline."
msgstr ""
"Операторы совпадения с любым символом не совпадают с символом новой строки."

#. type: Plain text
#: man-pages/man3/regex.3:109
msgid ""
"A nonmatching list (B<[^...]>)  not containing a newline does not match a "
"newline."
msgstr ""
"Список несовпадающих символов (B<[^...]>) без символа новой строки не "
"совпадает с новой строкой."

#. type: Plain text
#: man-pages/man3/regex.3:119
msgid ""
"Match-beginning-of-line operator (B<^>)  matches the empty string "
"immediately after a newline, regardless of whether I<eflags>, the execution "
"flags of B<regexec>(), contains B<REG_NOTBOL>."
msgstr ""
"Оператор сравнения по началу строки (B<^>) совпадает с пустой строкой сразу "
"после новой строки независимо от того, что I<eflags>, флаги выполнения "
"B<regexec>(), содержат B<REG_NOTBOL>."

#. type: Plain text
#: man-pages/man3/regex.3:127
msgid ""
"Match-end-of-line operator (B<$>)  matches the empty string immediately "
"before a newline, regardless of whether I<eflags> contains B<REG_NOTEOL>."
msgstr ""
"Оператор сравнения по концу строки ($) совпадает с пустой строкой до символа "
"начала строки независимо от того, что I<eflags> содержит B<REG_NOTEOL>."

#. type: SS
#: man-pages/man3/regex.3:127
#, no-wrap
msgid "POSIX regex matching"
msgstr "Сравнение с регулярным выражением POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:144
msgid ""
"B<regexec>()  is used to match a null-terminated string against the "
"precompiled pattern buffer, I<preg>.  I<nmatch> and I<pmatch> are used to "
"provide information regarding the location of any matches.  I<eflags> may be "
"the bitwise-B<or> of one or both of B<REG_NOTBOL> and B<REG_NOTEOL> which "
"cause changes in matching behavior described below."
msgstr ""
"Функция B<regexec>() используется для сравнения строки, завершающейся null, "
"с предварительно обработанным буферным шаблоном I<preg>. Аргументы I<nmatch> "
"и I<pmatch> используются для предоставления информации о местонахождении "
"любых совпадений. Значение I<eflags> может быть поразрядным B<ИЛИ> одного "
"или обоих значений B<REG_NOTBOL> и B<REG_NOTEOL>. Данные значения определяют "
"поведение процесса сравнения так, как описано ниже."

#. type: TP
#: man-pages/man3/regex.3:144
#, no-wrap
msgid "B<REG_NOTBOL>"
msgstr "B<REG_NOTBOL>"

#. type: Plain text
#: man-pages/man3/regex.3:154
msgid ""
"The match-beginning-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above).  This flag may be used when "
"different portions of a string are passed to B<regexec>()  and the beginning "
"of the string should not be interpreted as the beginning of the line."
msgstr ""
"Оператор сравнения по началу строки всегда завершается с ошибкой (но "
"смотрите описанный выше флаг компиляции B<REG_NEWLINE>). Этот флаг может "
"использоваться, когда в B<regexec>() передаются отдельные части строки, и "
"начало такой строки в данном случае не должно интерпретироваться как начало "
"новой строки."

#. type: TP
#: man-pages/man3/regex.3:154
#, no-wrap
msgid "B<REG_NOTEOL>"
msgstr "B<REG_NOTEOL>"

#. type: Plain text
#: man-pages/man3/regex.3:160
msgid ""
"The match-end-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)."
msgstr ""
"Оператор сравнения по концу строки всегда завершается с ошибкой (но смотрите "
"описанный выше флаг компиляции B<REG_NEWLINE>)."

#. type: SS
#: man-pages/man3/regex.3:160
#, no-wrap
msgid "Byte offsets"
msgstr "Байтовые смещения"

#. type: Plain text
#: man-pages/man3/regex.3:185
msgid ""
"Unless B<REG_NOSUB> was set for the compilation of the pattern buffer, it is "
"possible to obtain match addressing information.  I<pmatch> must be "
"dimensioned to have at least I<nmatch> elements.  These are filled in by "
"B<regexec>()  with substring match addresses.  The offsets of the "
"subexpression starting at the I<i>th open parenthesis are stored in "
"I<pmatch[i]>.  The entire regular expression's match addresses are stored in "
"I<pmatch[0]>.  (Note that to return the offsets of I<N> subexpression "
"matches, I<nmatch> must be at least I<N+1>.)  Any unused structure elements "
"will contain the value -1."
msgstr ""
"Если B<REG_NOSUB> не установлен при компиляции буферного шаблона, то "
"возможно получать информацию о положении совпадений. Значение I<pmatch> "
"должно быть определено так, чтобы иметь, по крайней мере, I<nmatch> "
"элементов. Они заполняются B<regexec>() адресами внутристрочных совпадений. "
"Смещения подвыражения, начинающегося с I<i>-й открытой скобки, сохраняется в "
"I<pmatch[i]>. Адрес совпадения всего регулярного выражения сохраняется в "
"I<pmatch[0]> (заметим, что чтобы вернуть смещения совпадений I<N> "
"подвыражений, значение I<nmatch> должно быть не менее I<N+1>). Любые "
"неиспользованные элементы структуры будут содержать значение -1."

#. type: Plain text
#: man-pages/man3/regex.3:192
msgid ""
"The I<regmatch_t> structure which is the type of I<pmatch> is defined in "
"I<E<lt>regex.hE<gt>>."
msgstr ""
"Структура I<regmatch_t>, являющаяся типом I<pmatch>, определена в "
"I<E<lt>regex.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/regex.3:199
#, no-wrap
msgid ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"
msgstr ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"

#. type: Plain text
#: man-pages/man3/regex.3:210
msgid ""
"Each I<rm_so> element that is not -1 indicates the start offset of the next "
"largest substring match within the string.  The relative I<rm_eo> element "
"indicates the end offset of the match, which is the offset of the first "
"character after the matching text."
msgstr ""
"Каждый элемент I<rm_so>, не равный -1, показывает начальное смещение "
"следующего совпадения наибольшей подстроки внутри заданной строки. "
"Относительный элемент I<rm_eo> указывает на смещение конца совпадения, "
"которое является первым символом после совпавшего текста."

#. type: SS
#: man-pages/man3/regex.3:210
#, no-wrap
msgid "POSIX error reporting"
msgstr "Сообщение об ошибках POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:217
msgid ""
"B<regerror>()  is used to turn the error codes that can be returned by both "
"B<regcomp>()  and B<regexec>()  into error message strings."
msgstr ""
"Функция B<regerror> используется для преобразования кодов ошибок, которые "
"могут быть получены от B<regcomp>() и B<regexec>(), в строки сообщений об "
"ошибках."

#. type: Plain text
#: man-pages/man3/regex.3:239
msgid ""
"B<regerror>()  is passed the error code, I<errcode>, the pattern buffer, "
"I<preg>, a pointer to a character string buffer, I<errbuf>, and the size of "
"the string buffer, I<errbuf_size>.  It returns the size of the I<errbuf> "
"required to contain the null-terminated error message string.  If both "
"I<errbuf> and I<errbuf_size> are nonzero, I<errbuf> is filled in with the "
"first I<errbuf_size - 1> characters of the error message and a terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""
"В B<regerror> передаются: код ошибки I<errcode>, буферный шаблон I<preg>, "
"указатель на символьный буфер строки I<errbuf> и размер буфера строки "
"I<errbuf_size>. Функция возвращает размер I<errbuf>, который требуется для "
"сохранения сообщения об ошибке в виде строки, оканчивающейся null. Если и "
"I<errbuf>, и I<errbuf_size> не равны нулю, то I<errbuf> заполняется первыми "
"I<errbuf_size - 1> символами сообщения об ошибке и завершается байтом null "
"(\\(aq\\e0\\(aq)."

#. type: SS
#: man-pages/man3/regex.3:239
#, no-wrap
msgid "POSIX pattern buffer freeing"
msgstr "Освобождение буфера шаблона POSIX"

#. type: Plain text
#: man-pages/man3/regex.3:247
msgid ""
"Supplying B<regfree>()  with a precompiled pattern buffer, I<preg> will free "
"the memory allocated to the pattern buffer by the compiling process, "
"B<regcomp>()."
msgstr ""
"Функция B<regfree>() освобождает память, отведённую буферному шаблону "
"I<preg> во время процесса компиляции с помощью B<regcomp>()."

#. type: Plain text
#: man-pages/man3/regex.3:250
msgid ""
"B<regcomp>()  returns zero for a successful compilation or an error code for "
"failure."
msgstr ""
"Функция B<regcomp>() возвращает ноль при успешной компиляции или в противном "
"случае код ошибки."

#. type: Plain text
#: man-pages/man3/regex.3:255
msgid ""
"B<regexec>()  returns zero for a successful match or B<REG_NOMATCH> for "
"failure."
msgstr ""
"Функция B<regexec>() возвращает ноль при совпадении или B<REG_NOMATCH>, если "
"совпадений не было."

#. type: Plain text
#: man-pages/man3/regex.3:258
msgid "The following errors can be returned by B<regcomp>():"
msgstr "Функция B<regcomp>() может возвращать следующие ошибки:"

#. type: TP
#: man-pages/man3/regex.3:258
#, no-wrap
msgid "B<REG_BADBR>"
msgstr "B<REG_BADBR>"

#. type: Plain text
#: man-pages/man3/regex.3:261
msgid "Invalid use of back reference operator."
msgstr "Неправильное использование оператора обратных ссылок."

#. type: TP
#: man-pages/man3/regex.3:261
#, no-wrap
msgid "B<REG_BADPAT>"
msgstr "B<REG_BADPAT>"

#. type: Plain text
#: man-pages/man3/regex.3:264
msgid "Invalid use of pattern operators such as group or list."
msgstr ""
"Неправильное использование операторов шаблона, таких, как операторы группы "
"или списка."

#. type: TP
#: man-pages/man3/regex.3:264
#, no-wrap
msgid "B<REG_BADRPT>"
msgstr "B<REG_BADRPT>"

#. type: Plain text
#: man-pages/man3/regex.3:268
msgid ""
"Invalid use of repetition operators such as using \\(aq*\\(aq as the first "
"character."
msgstr ""
"Неправильное использование операторов повторения, например, использование "
"«*» в качестве первого символа."

#. type: TP
#: man-pages/man3/regex.3:268
#, no-wrap
msgid "B<REG_EBRACE>"
msgstr "B<REG_EBRACE>"

#. type: Plain text
#: man-pages/man3/regex.3:271
msgid "Un-matched brace interval operators."
msgstr "Непарные скобки в операторах интервала."

#. type: TP
#: man-pages/man3/regex.3:271
#, no-wrap
msgid "B<REG_EBRACK>"
msgstr "B<REG_EBRACK>"

#. type: Plain text
#: man-pages/man3/regex.3:274
msgid "Un-matched bracket list operators."
msgstr "Непарные квадратные скобки в операторах списка."

#. type: TP
#: man-pages/man3/regex.3:274
#, no-wrap
msgid "B<REG_ECOLLATE>"
msgstr "B<REG_ECOLLATE>"

#. type: Plain text
#: man-pages/man3/regex.3:277
msgid "Invalid collating element."
msgstr "Неправильный элемент сортировки."

#. type: TP
#: man-pages/man3/regex.3:277
#, no-wrap
msgid "B<REG_ECTYPE>"
msgstr "B<REG_ECTYPE>"

#. type: Plain text
#: man-pages/man3/regex.3:280
msgid "Unknown character class name."
msgstr "Неизвестное имя класса символов."

#. type: TP
#: man-pages/man3/regex.3:280
#, no-wrap
msgid "B<REG_EEND>"
msgstr "B<REG_EEND>"

#. type: Plain text
#: man-pages/man3/regex.3:284
msgid "Nonspecific error.  This is not defined by POSIX.2."
msgstr "Потенциальная ошибка. Не определена в POSIX.2."

#. type: TP
#: man-pages/man3/regex.3:284
#, no-wrap
msgid "B<REG_EESCAPE>"
msgstr "B<REG_EESCAPE>"

#. type: Plain text
#: man-pages/man3/regex.3:287
msgid "Trailing backslash."
msgstr "Конечная обратная косая черта."

#. type: TP
#: man-pages/man3/regex.3:287
#, no-wrap
msgid "B<REG_EPAREN>"
msgstr "B<REG_EPAREN>"

#. type: Plain text
#: man-pages/man3/regex.3:290
msgid "Un-matched parenthesis group operators."
msgstr "Непарные круглые скобки в операторах группировки."

#. type: TP
#: man-pages/man3/regex.3:290
#, no-wrap
msgid "B<REG_ERANGE>"
msgstr "B<REG_ERANGE>"

#. type: Plain text
#: man-pages/man3/regex.3:294
msgid ""
"Invalid use of the range operator; for example, the ending point of the "
"range occurs prior to the starting point."
msgstr ""
"Неправильное использование оператора области: например, конец области "
"появляется прежде её начала."

#. type: TP
#: man-pages/man3/regex.3:294
#, no-wrap
msgid "B<REG_ESIZE>"
msgstr "B<REG_ESIZE>"

#. type: Plain text
#: man-pages/man3/regex.3:298
msgid ""
"Compiled regular expression requires a pattern buffer larger than 64\\ kB.  "
"This is not defined by POSIX.2."
msgstr ""
"Скомпилированное регулярное выражение требует буферный шаблон размером, "
"большим 64\\ Кб. Это не определено в POSIX.2."

#. type: TP
#: man-pages/man3/regex.3:298
#, no-wrap
msgid "B<REG_ESPACE>"
msgstr "B<REG_ESPACE>"

#. type: Plain text
#: man-pages/man3/regex.3:301
msgid "The regex routines ran out of memory."
msgstr "Для процедур регулярных выражений закончилась память."

#. type: TP
#: man-pages/man3/regex.3:301
#, no-wrap
msgid "B<REG_ESUBREG>"
msgstr "B<REG_ESUBREG>"

#. type: Plain text
#: man-pages/man3/regex.3:304
msgid "Invalid back reference to a subexpression."
msgstr "Неправильная обратная ссылка на подвыражение."

#. type: tbl table
#: man-pages/man3/regex.3:315
#, no-wrap
msgid ""
"B<regcomp>(),\n"
"B<regexec>()"
msgstr ""
"B<regcomp>(),\n"
"B<regexec>()"

#. type: tbl table
#: man-pages/man3/regex.3:318
#, no-wrap
msgid "B<regerror>()"
msgstr "B<regerror>()"

#. type: tbl table
#: man-pages/man3/regex.3:318
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: tbl table
#: man-pages/man3/regex.3:321
#, no-wrap
msgid "B<regfree>()"
msgstr "B<regfree>()"

#. type: Plain text
#: man-pages/man3/regex.3:325
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/regex.3:328
msgid "B<grep>(1), B<regex>(7)"
msgstr "B<grep>(1), B<regex>(7)"

#. type: Plain text
#: man-pages/man3/regex.3:330
msgid "The glibc manual section, I<Regular Expressions>"
msgstr "Раздел руководства glibc I<Regular Expressions>"

#. type: TH
#: man-pages/man3/resolver.3:33
#, no-wrap
msgid "RESOLVER"
msgstr "RESOLVER"

#. type: Plain text
#: man-pages/man3/resolver.3:38
msgid ""
"res_ninit, res_nclose, res_nquery, res_nsearch, res_nquerydomain, "
"res_nmkquery, res_nsend, res_init, res_query, res_search, res_querydomain, "
"res_mkquery, res_send, dn_comp, dn_expand - resolver routines"
msgstr ""
"res_ninit, res_nclose, res_nquery, res_nsearch, res_nquerydomain, "
"res_nmkquery, res_nsend, res_init, res_query, res_search, res_querydomain, "
"res_mkquery, res_send, dn_comp, dn_expand - процедуры определителя имён"

#. type: Plain text
#: man-pages/man3/resolver.3:43
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
msgstr ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:46
#, no-wrap
msgid ""
"B<struct __res_state;>\n"
"B<typedef struct __res_state *res_state;>\n"
msgstr ""
"B<struct __res_state;>\n"
"B<typedef struct __res_state *res_state;>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:48
#, no-wrap
msgid "B<int res_ninit(res_state >I<statep>B<);>\n"
msgstr "B<int res_ninit(res_state >I<statep>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:50
#, no-wrap
msgid "B<void res_nclose(res_state >I<statep>B<);>\n"
msgstr "B<void res_nclose(res_state >I<statep>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:54
#, no-wrap
msgid ""
"B<int res_nquery(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nquery(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:58
#, no-wrap
msgid ""
"B<int res_nsearch(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nsearch(res_state >I<statep>B<,>\n"
"B<           const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:63
#, no-wrap
msgid ""
"B<int res_nquerydomain(res_state >I<statep>B<,>\n"
"B<           const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nquerydomain(res_state >I<statep>B<,>\n"
"B<           const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:69
#, no-wrap
msgid ""
"B<int res_nmkquery(res_state >I<statep>B<,>\n"
"B<           int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<int res_nmkquery(res_state >I<statep>B<,>\n"
"B<           int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:73
#, no-wrap
msgid ""
"B<int res_nsend(res_state >I<statep>B<,>\n"
"B<           const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_nsend(res_state >I<statep>B<,>\n"
"B<           const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:77
#, no-wrap
msgid ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
"B<           int >I<length>B<, unsigned char **>I<dnptrs>B<,>\n"
"B<           unsigned char **>I<lastdnptr>B<);>\n"
msgstr ""
"B<int dn_comp(const char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
"B<           int >I<length>B<, unsigned char **>I<dnptrs>B<,>\n"
"B<           unsigned char **>I<lastdnptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:82
#, no-wrap
msgid ""
"B<int dn_expand(const unsigned char *>I<msg>B<,>\n"
"B<           const unsigned char *>I<eomorig>B<,>\n"
"B<           const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<           int >I<length>B<);>\n"
msgstr ""
"B<int dn_expand(const unsigned char *>I<msg>B<,>\n"
"B<           const unsigned char *>I<eomorig>B<,>\n"
"B<           const unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<           int >I<length>B<);>\n"

#. type: SS
#: man-pages/man3/resolver.3:84
#, no-wrap
msgid "Deprecated"
msgstr "Устаревшие"

#. type: Plain text
#: man-pages/man3/resolver.3:87
#, no-wrap
msgid "B<extern struct __res_state _res;>\n"
msgstr "B<extern struct __res_state _res;>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:89
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr "B<int res_init(void);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:92
#, no-wrap
msgid ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:95
#, no-wrap
msgid ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:99
#, no-wrap
msgid ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"
msgstr ""
"B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
"B<           int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<           int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:104
#, no-wrap
msgid ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
"B<           int >I<type>B<, const unsigned char *>I<data>B<, int >I<datalen>B<,>\n"
"B<           const unsigned char *>I<newrr>B<,>\n"
"B<           unsigned char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:107
#, no-wrap
msgid ""
"B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""
"B<int res_send(const unsigned char *>I<msg>B<, int >I<msglen>B<,>\n"
"B<           unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"

#. type: Plain text
#: man-pages/man3/resolver.3:110
msgid "Link with I<-lresolv>."
msgstr "Компонуется при указании параметра I<-lresolv>."

#. type: Plain text
#: man-pages/man3/resolver.3:114
msgid ""
"B<Note:> This page is incomplete (various resolver functions provided by "
"glibc are not described) and likely out of date."
msgstr ""
"B<Замечание:> Данная страница не полна (не описаны различные функции "
"определителя, предоставляемые glibc) и, вероятно, содержит устаревшую "
"информацию."

#. type: Plain text
#: man-pages/man3/resolver.3:117
msgid ""
"The functions described below make queries to and interpret the responses "
"from Internet domain name servers."
msgstr ""
"Описываемые далее функции выполняют запросы и обрабатывают ответы, "
"полученные от серверов доменных имён Интернет."

#. type: Plain text
#: man-pages/man3/resolver.3:133
msgid ""
"The API consists of a set of more modern, reentrant functions and an older "
"set of nonreentrant functions that have been superseded.  The traditional "
"resolver interfaces such as B<res_init>()  and B<res_query>()  use some "
"static (global) state stored in the I<_res> structure, rendering these "
"functions non-thread-safe.  BIND 8.2 introduced a set of new interfaces "
"B<res_ninit>(), B<res_nquery>(), and so on, which take a I<res_state> as "
"their first argument, so you can use a per-thread resolver state."
msgstr ""
"В программный интерфейс входят как современные, реентерабельные функции, так "
"и устаревшие не реентерабельные. Функции B<res_init>()  и B<res_query>() из "
"обычного интерфейса определителя использует статическое (глобальное) "
"состояние, хранимое в структуре I<_res>, что делает эти функции небезопасным "
"при использовании в нитях. В BIND 8.2 появился набор новых интерфейсов "
"B<res_ninit>(), B<res_nquery>() и т. п., в котором I<res_state> указывается "
"в третьем аргументе, что позволяет использовать отдельное состояние "
"определителя в каждой нити."

#. type: Plain text
#: man-pages/man3/resolver.3:159
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions read the configuration "
"files (see B<resolv.conf>(5))  to get the default domain name and name "
"server address(es).  If no server is given, the local host is tried.  If no "
"domain is given, that associated with the local host is used.  It can be "
"overridden with the environment variable B<LOCALDOMAIN>.  B<res_ninit>()  or "
"B<res_init>()  is normally executed by the first call to one of the other "
"functions.  Every call to B<res_ninit>()  requires a corresponding call to "
"B<res_nclose>()  to free memory allocated by B<res_ninit>()  and subsequent "
"calls to B<res_nquery>()."
msgstr ""
"Функции B<res_ninit>() и B<res_init>() читают файлы настройки (смотрите "
"B<resolv.conf>(5)) для получения имени домена по умолчанию и адреса(-ов) "
"сервера имён. Если серверы не заданы, то используется локальный узел. Если "
"не задан домен, то используется домен локального узла. Это может быть "
"изменено через переменную окружения B<LOCALDOMAIN>. Обычно, функция "
"B<res_ninit>() или B<res_init>() выполняется первой из других функций. "
"Каждый вызов B<res_nquery>() требует соответствующего вызова B<res_nclose>() "
"для освобождения памяти, выделенной B<res_ninit>() и последующими вызовами "
"B<res_nquery>()."

#. type: Plain text
#: man-pages/man3/resolver.3:169
msgid ""
"The B<res_nquery>()  and B<res_query>()  functions query the name server for "
"the fully qualified domain name I<name> of specified I<type> and I<class>.  "
"The reply is left in the buffer I<answer> of length I<anslen> supplied by "
"the caller."
msgstr ""
"Функции B<res_nquery>() и B<res_query>() запрашивают у сервера имён полное "
"доменное имя I<name> заданного типа I<type> и класса I<class>. Ответ "
"помещается в буфер I<answer> длиной I<anslen>, указанный вызывающим."

#. type: Plain text
#: man-pages/man3/resolver.3:185
msgid ""
"The B<res_nsearch>()  and B<res_search>()  functions make a query and waits "
"for the response like B<res_nquery>()  and B<res_query>(), but in addition "
"they implement the default and search rules controlled by B<RES_DEFNAMES> "
"and B<RES_DNSRCH> (see description of I<_res> options below)."
msgstr ""
"Функции B<res_nsearch>() и B<res_search>() отправляют запрос и ждут ответа, "
"подобно B<res_nquery>() и B<res_query>(), но при этом ещё учитывают правила "
"работы и поиска по умолчанию, настраиваемые через B<RES_DEFNAMES> и "
"B<RES_DNSRCH> (смотрите ниже описание параметров I<_res>)."

#. type: Plain text
#: man-pages/man3/resolver.3:193
msgid ""
"The B<res_nquerydomain>()  and B<res_querydomain>()  functions make a query "
"using B<res_nquery>()/B<res_query>()  on the concatenation of I<name> and "
"I<domain>."
msgstr ""
"Функции B<res_nquerydomain>() и B<res_querydomain>() отправляют запрос с "
"помощью B<res_nquery>()/B<res_query>() с объединённым I<name> и I<domain>."

#. type: Plain text
#: man-pages/man3/resolver.3:196
msgid ""
"The following functions are lower-level routines used by B<res_query>()/"
"B<res_query>()."
msgstr ""
"Следующие функции являются процедурами низкого уровня, которые используются "
"B<res_nquery>()/B<res_query>()."

#. type: Plain text
#: man-pages/man3/resolver.3:206
msgid ""
"The B<res_nmkquery>()  and B<res_mkquery>()  functions construct a query "
"message in I<buf> of length I<buflen> for the domain name I<dname>.  The "
"query type I<op> is one of the following (typically B<QUERY>):"
msgstr ""
"Функции B<res_nmkquery>() и B<res_mkquery>() создают сообщение-запрос в "
"I<buf> длиной I<buflen> для имени домена I<dname>. Типом запроса I<op> может "
"быть:"

#. type: TP
#: man-pages/man3/resolver.3:206
#, no-wrap
msgid "B<QUERY>"
msgstr "B<QUERY>"

#. type: Plain text
#: man-pages/man3/resolver.3:209
msgid "Standard query."
msgstr "Стандартный запрос."

#. type: TP
#: man-pages/man3/resolver.3:209
#, no-wrap
msgid "B<IQUERY>"
msgstr "B<IQUERY>"

#.  commit e4e794841e3140875f2aa86b90e2ada3d61e1244
#. type: Plain text
#: man-pages/man3/resolver.3:215
msgid ""
"Inverse query.  This option was removed in glibc 2.26, since it has not been "
"supported by DNS servers for a very long time."
msgstr ""
"Обратный запрос. Это значение было удалено в glibc 2.26, так как давно не "
"поддерживалось серверами DNS."

#. type: TP
#: man-pages/man3/resolver.3:215
#, no-wrap
msgid "B<NS_NOTIFY_OP>"
msgstr "B<NS_NOTIFY_OP>"

#. type: Plain text
#: man-pages/man3/resolver.3:218
msgid "Notify secondary of SOA (Start of Authority) change."
msgstr "Уведомить об изменении SOA (Start of Authority) вторичный сервер."

#. type: Plain text
#: man-pages/man3/resolver.3:220
msgid "I<newrr> is currently unused."
msgstr "Параметр I<newrr> в настоящее время не используется."

#. type: Plain text
#: man-pages/man3/resolver.3:231
msgid ""
"The B<res_nsend>()  and B<res_send>()  function send a preformatted query "
"given in I<msg> of length I<msglen> and returns the answer in I<answer> "
"which is of length I<anslen>.  They will call B<res_ninit>()/B<res_init>()  "
"if it has not already been called."
msgstr ""
"Функции B<res_nsend>() и B<res_send>() посылают заранее созданный запрос, "
"указанный в I<msg> длиной I<msglen>, и возвращают ответ в I<answer> длиной "
"I<anslen>. Вызывают функцию B<res_ninit>()/B<res_init>(), если этого ещё не "
"было."

#. type: Plain text
#: man-pages/man3/resolver.3:244
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""
"Функция B<dn_comp>() сжимает имя домена I<exp_dn> и сохраняет его в буфере "
"I<comp_dn> длиной I<length>. Сжатие использует массив указателей I<dnptrs> "
"на предварительно сжатые имена в текущем сообщении. Первый указатель "
"обозначает начало сообщения, а весь список оканчивается NULL. Предел массива "
"определяется в I<lastdnptr>. Если I<dnptr> равно NULL, то имя домена не "
"является сжатым. Если I<lastdnptr> равно NULL, то список меток не "
"обновляется."

#. type: Plain text
#: man-pages/man3/resolver.3:253
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""
"Функция B<dn_expand>() раскрывает сжатое имя домена I<comp_dn> до полного "
"доменного имени, которое затем сохраняется в буфере I<exp_dn> длиной "
"I<length>. Сжатое имя содержится в запросе или ответном сообщении, а I<msg> "
"указывает на начало сообщения."

#. type: Plain text
#: man-pages/man3/resolver.3:268
msgid ""
"The resolver routines use configuration and state information contained in a "
"I<__res_state> structure (either passed as the I<statep> argument, or in the "
"global variable I<_res>, in the case of the older nonreentrant functions).  "
"The only field of this structure that is normally manipulated by the user is "
"the I<options> field.  This field can contain the bitwise \"OR\" of the "
"following options:"
msgstr ""
"Процедуры определителя используют настройки и информацию о состоянии из "
"структуры I<__res_state> (переданной в аргументе I<statep> или в глобальной "
"переменной I<_res>, если используются старые не реентерабельные функции). "
"Обычно, пользователь изменяет в этой структуре только поле I<options>. "
"Данное поле может содержать следующие значения, объединённые с помощью «OR»:"

#. type: TP
#: man-pages/man3/resolver.3:268
#, no-wrap
msgid "B<RES_INIT>"
msgstr "B<RES_INIT>"

#. type: Plain text
#: man-pages/man3/resolver.3:275
msgid "True if B<res_ninit>()  or B<res_init>()  has been called."
msgstr "Истинно, если уже вызывалась функция B<res_ninit>() или B<res_init>()."

#. type: TP
#: man-pages/man3/resolver.3:275
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr "B<RES_DEBUG>"

#.  See resolv/README.
#.  Support for RES_DEBUG was made conditional in glibc 2.2.
#. type: Plain text
#: man-pages/man3/resolver.3:282
msgid ""
"Print debugging messages.  This option is available only if glibc was built "
"with debugging enabled, which is not the default."
msgstr ""
"Печатать отладочные сообщения. Этот параметр доступен только, если glibc "
"собрана с включённой отладкой, которая по умолчанию выключена."

#. type: TP
#: man-pages/man3/resolver.3:282
#, no-wrap
msgid "B<RES_AAONLY> (unimplemented; deprecated in glibc 2.25)"
msgstr "B<RES_AAONLY> (не реализован; устарел в glibc 2.25)"

#. type: Plain text
#: man-pages/man3/resolver.3:290
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""
"Принимать только достоверные ответы. Функция B<res_send>() продолжает "
"работать, пока не найдёт достоверный ответ или возвращает ошибку. Данный "
"параметр имелся, но не был реализован в glibc до версии 2.24; начиная с "
"glibc 2.25 он устарел и его при его использовании выдаётся предупреждение."

#. type: TP
#: man-pages/man3/resolver.3:290
#, no-wrap
msgid "B<RES_USEVC>"
msgstr "B<RES_USEVC>"

#. type: Plain text
#: man-pages/man3/resolver.3:293
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr "использовать TCP-соединение для запросов вместо датаграмм UDP."

#. type: TP
#: man-pages/man3/resolver.3:293
#, no-wrap
msgid "B<RES_PRIMARY> (unimplemented; deprecated in glibc 2.25)"
msgstr "B<RES_PRIMARY> (не реализован; устарел в glibc 2.25)"

#. type: Plain text
#: man-pages/man3/resolver.3:298
msgid ""
"Query primary domain name server only.  This option was present but "
"unimplemented in glibc until version 2.24; since glibc 2.25, it is "
"deprecated, and its usage produces a warning."
msgstr ""
"Запрашивать только первичный сервер имён. Данный параметр имелся, но не был "
"реализован в glibc до версии 2.24; начиная с glibc 2.25 он устарел и его при "
"его использовании выдаётся предупреждение."

#. type: TP
#: man-pages/man3/resolver.3:298
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr "B<RES_IGNTC>"

#. type: Plain text
#: man-pages/man3/resolver.3:302
msgid "Ignore truncation errors.  Don't retry with TCP."
msgstr ""
"Игнорировать ошибки обрезания. Не пытаться повторить запрос с помощью TCP."

#. type: TP
#: man-pages/man3/resolver.3:302
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr "B<RES_RECURSE>"

#. type: Plain text
#: man-pages/man3/resolver.3:309
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""
"Установить в запросах бит рекурсии. Рекурсия выполняется сервером доменных "
"имён, а не функцией B<res_send>() (включено по умолчанию)."

#. type: TP
#: man-pages/man3/resolver.3:309
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr "B<RES_DEFNAMES>"

#. type: Plain text
#: man-pages/man3/resolver.3:316
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names\\(emthat is, those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""
"Если указан, то B<res_search>() будет добавлять имя домена по умолчанию к "
"именам с одним компонентом в имени (не содержащим точек) (включено по "
"умолчанию)."

#. type: TP
#: man-pages/man3/resolver.3:316
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr "B<RES_STAYOPEN>"

#. type: Plain text
#: man-pages/man3/resolver.3:321
msgid "Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr ""
"Используется вместе с B<RES_USEVC> для поддержания TCP-соединения запросов "
"между ответами."

#. type: TP
#: man-pages/man3/resolver.3:321
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr "B<RES_DNSRCH>"

#. type: Plain text
#: man-pages/man3/resolver.3:330
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and "
"in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled by "
"default]."
msgstr ""
"Если указан, то B<res_search>() будет искать имена узлов в текущем и "
"родительском домене. Этот параметр используется B<gethostbyname>(3) "
"(включено по умолчанию)."

#. type: TP
#: man-pages/man3/resolver.3:330
#, no-wrap
msgid "B<RES_INSECURE1>"
msgstr "B<RES_INSECURE1>"

#. type: Plain text
#: man-pages/man3/resolver.3:337
msgid ""
"Accept a response from a wrong server.  This can be used to detect potential "
"security hazards, but you need to compile glibc with debugging enabled and "
"use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""
"Принимать ответ от ошибочного сервера. Может использоваться для обнаружения "
"потенциальных угроза безопасности, но требует перекомпиляции glibc с "
"включённой отладкой и параметром B<RES_DEBUG> (только для отладки)."

#. type: TP
#: man-pages/man3/resolver.3:337
#, no-wrap
msgid "B<RES_INSECURE2>"
msgstr "B<RES_INSECURE2>"

#. type: Plain text
#: man-pages/man3/resolver.3:344
msgid ""
"Accept a response which contains a wrong query.  This can be used to detect "
"potential security hazards, but you need to compile glibc with debugging "
"enabled and use B<RES_DEBUG> option (for debug purpose only)."
msgstr ""
"Принимать ответ, который содержит некорректный запрос. Может использоваться "
"для обнаружения потенциальных угроза безопасности, но требует перекомпиляции "
"glibc с включённой отладкой и параметром B<RES_DEBUG> (только для отладки)."

#. type: TP
#: man-pages/man3/resolver.3:344
#, no-wrap
msgid "B<RES_NOALIASES>"
msgstr "B<RES_NOALIASES>"

#. type: Plain text
#: man-pages/man3/resolver.3:349
msgid "Disable usage of B<HOSTALIASES> environment variable."
msgstr "Отключить использование переменной окружения B<HOSTALIASES>."

#. type: TP
#: man-pages/man3/resolver.3:349
#, no-wrap
msgid "B<RES_USE_INET6>"
msgstr "B<RES_USE_INET6>"

#. type: Plain text
#: man-pages/man3/resolver.3:361
msgid ""
"Try an AAAA query before an A query inside the B<gethostbyname>(3)  "
"function, and map IPv4 responses in IPv6 \"tunneled form\" if no AAAA "
"records are found but an A record set exists.  Since glibc 2.25, this option "
"is deprecated, and its usage produces a warning; applications should use "
"B<getaddrinfo>(3), rather than B<gethostbyname>(3)."
msgstr ""
"Пытаться выполнить запрос AAAA раньше запроса A внутри функции "
"B<gethostbyname>(3), и отображать ответы IPv4 в «туннелированной форме» "
"IPv6, если записи AAAA не были обнаружены, но есть запись типа A. Начиная с "
"glibc 2.25 этот параметр считается устаревшим и при его использовании "
"выдаётся предупреждение; приложения должны использовать B<getaddrinfo>(3), а "
"не B<gethostbyname>(3)."

#. type: TP
#: man-pages/man3/resolver.3:361
#, no-wrap
msgid "B<RES_ROTATE>"
msgstr "B<RES_ROTATE>"

#. type: Plain text
#: man-pages/man3/resolver.3:367
msgid ""
"Causes round-robin selection of name servers from among those listed.  This "
"has the effect of spreading the query load among all listed servers, rather "
"than having all clients try the first listed server first every time."
msgstr ""
"Включить циклический выбор среди имеющихся серверов имён. Это приводит к "
"распределению нагрузки среди серверов и использование каждый раз только "
"первого сервера всеми клиентами не происходит."

#. type: TP
#: man-pages/man3/resolver.3:367
#, no-wrap
msgid "B<RES_NOCHECKNAME> (unimplemented; deprecated in glibc 2.25)"
msgstr "B<RES_NOCHECKNAME> (не реализован; устарел в glibc 2.25)"

#. type: Plain text
#: man-pages/man3/resolver.3:374
msgid ""
"Disable the modern BIND checking of incoming hostnames and mail names for "
"invalid characters such as underscore (_), non-ASCII, or control "
"characters.  This option was present in glibc until version 2.24; since "
"glibc 2.25, it is deprecated, and its usage produces a warning."
msgstr ""
"Выключить в современном BIND проверку недопустимых символов в поступающих "
"именах узлов и почтовых именах, таких как символы подчёркивания (_), не-"
"ASCII или управляющие символы. Данный параметр имелся в glibc до версии "
"2.24; начиная с glibc 2.25 он устарел и его при его использовании выдаётся "
"предупреждение."

#. type: TP
#: man-pages/man3/resolver.3:374
#, no-wrap
msgid "B<RES_KEEPTSIG> (unimplemented; deprecated in glibc 2.25)"
msgstr "B<RES_KEEPTSIG> (не реализован; устарел в glibc 2.25)"

#. type: Plain text
#: man-pages/man3/resolver.3:379
msgid ""
"Do not strip TSIG records.  This option was present but unimplemented in "
"glibc until version 2.24; since glibc 2.25, it is deprecated, and its usage "
"produces a warning."
msgstr ""
"Не обрезать записи TSIG. Данный параметр имелся, но не был реализован в "
"glibc до версии 2.24; начиная с glibc 2.25 он устарел и его при его "
"использовании выдаётся предупреждение."

#. type: TP
#: man-pages/man3/resolver.3:379
#, no-wrap
msgid "B<RES_BLAST  (unimplemented; deprecated in glibc 2.25)>"
msgstr "B<RES_BLAST>  (не реализован; устарел в glibc 2.25)"

#. type: Plain text
#: man-pages/man3/resolver.3:384
msgid ""
"Send each query simultaneously and recursively to all servers.  This option "
"was present but unimplemented in glibc until version 2.24; since glibc 2.25, "
"it is deprecated, and its usage produces a warning."
msgstr ""
"Посылать каждый запрос одновременно и рекурсивно всем серверам. Данный "
"параметр имелся, но не был реализован в glibc до версии 2.24; начиная с "
"glibc 2.25 он устарел и его при его использовании выдаётся предупреждение."

#. type: TP
#: man-pages/man3/resolver.3:384
#, no-wrap
msgid "B<RES_USEBSTRING> (glibc 2.3.4 to 2.24)"
msgstr "B<RES_USEBSTRING> (glibc 2.3.4 по 2.24)"

#. type: Plain text
#: man-pages/man3/resolver.3:391
msgid ""
"Make reverse IPv6 lookups using the bit-label format described in RFC 2673; "
"if this option is not set (which is the default), then nibble format is "
"used.  This option was removed in glibc 2.25, since it relied on a backward-"
"incompatible DNS extension that was never deployed on the Internet."
msgstr ""
"Выполнить поиск обратной записи IPv6 с помощью формата значимых битов, "
"описанного в RFC\\ 2673; если этот параметр не задан (по умолчанию), то "
"используется полубайтовый формат. Данный параметр был удалён в glibc 2.25, "
"так как он полагается на обратно несовместимое расширение DNS, которое "
"никогда не разворачивалось в Интернете."

#. type: TP
#: man-pages/man3/resolver.3:391
#, no-wrap
msgid "B<RES_NOIP6DOTINT> (glibc 2.24 and earlier)"
msgstr "B<RES_NOIP6DOTINT> (glibc 2.24 и старее)"

#. type: Plain text
#: man-pages/man3/resolver.3:401
msgid ""
"Use I<ip6.arpa> zone in IPv6 reverse lookup instead of I<ip6.int>, which is "
"deprecated since glibc 2.3.4.  This option is present in glibc up to and "
"including version 2.24, where it is enabled by default.  In glibc 2.25, this "
"option was removed."
msgstr ""
"Использовать зону I<ip6.arpa> при поиске обратной записи IPv6 вместо I<ip6."
"int>, которая устарела начиная с glibc 2.3.4. Данный параметр существует в "
"glibc по версию  2.24 включительно (и включён по умолчанию). Из glibc 2.25 "
"этот параметр был удалён."

#. type: TP
#: man-pages/man3/resolver.3:401
#, no-wrap
msgid "B<RES_USE_EDNS0> (since glibc 2.6)"
msgstr "B<RES_USE_EDNS0> (начиная с glibc 2.6)"

#. type: Plain text
#: man-pages/man3/resolver.3:404
msgid "Enables support for the DNS extensions (EDNS0) described in RFC 2671."
msgstr "Включить поддержку расширений DNS (EDNS0), описанных в RFC\\ 2671."

#. type: TP
#: man-pages/man3/resolver.3:404
#, no-wrap
msgid "B<RES_SNGLKUP> (since glibc 2.10)"
msgstr "B<RES_SNGLKUP> (начиная с glibc 2.10)"

#. type: Plain text
#: man-pages/man3/resolver.3:413
msgid ""
"By default, glibc performs IPv4 and IPv6 lookups in parallel since version "
"2.9.  Some appliance DNS servers cannot handle these queries properly and "
"make the requests time out.  This option disables the behavior and makes "
"glibc perform the IPv6 and IPv4 requests sequentially (at the cost of some "
"slowdown of the resolving process)."
msgstr ""
"По умолчанию, glibc начиная с версии 2.9 выполняет поиск по IPv4 и IPv6 "
"параллельно. Некоторые приложения DNS-серверов не могут обработать такие "
"запросы должным образом и делают паузу между ответами на запрос. Этот "
"параметр отключает данное поведение, что заставляет glibc делать запросы "
"IPv6 и IPv4 последовательно (что замедляет процесс определения имени)."

#. type: TP
#: man-pages/man3/resolver.3:413
#, no-wrap
msgid "B<RES_SNGLKUPREOP>"
msgstr "B<RES_SNGLKUPREOP>"

#. type: Plain text
#: man-pages/man3/resolver.3:418
msgid ""
"When B<RES_SNGLKUP> option is enabled, opens a new socket for the each "
"request."
msgstr ""
"Открывать для каждого запроса новый сокет, если указано значение "
"B<RES_SNGLKUP>."

#. type: TP
#: man-pages/man3/resolver.3:418
#, no-wrap
msgid "B<RES_USE_DNSSEC>"
msgstr "B<RES_USE_DNSSEC>"

#. type: Plain text
#: man-pages/man3/resolver.3:423
msgid ""
"Use DNSSEC with OK bit in OPT record.  This option implies B<RES_USE_EDNS0>."
msgstr ""
"Использовать DNSSEC с битом OK в записи OPT. Это значение подразумевает "
"B<RES_USE_EDNS0>."

#. type: TP
#: man-pages/man3/resolver.3:423
#, no-wrap
msgid "B<RES_NOTLDQUERY>"
msgstr "B<RES_NOTLDQUERY>"

#. type: Plain text
#: man-pages/man3/resolver.3:426
msgid "Do not look up unqualified name as a top-level domain (TLD)."
msgstr "Не искать неполное имя как домен верхнего уровня (TLD)."

#. type: TP
#: man-pages/man3/resolver.3:426
#, no-wrap
msgid "B<RES_DEFAULT>"
msgstr "B<RES_DEFAULT>"

#. type: Plain text
#: man-pages/man3/resolver.3:435
msgid ""
"Default option which implies: B<RES_RECURSE>, B<RES_DEFNAMES>, B<RES_DNSRCH> "
"and B<RES_NOIP6DOTINT>."
msgstr ""
"Значение по умолчанию подразумевает: B<RES_RECURSE>, B<RES_DEFNAMES>, "
"B<RES_DNSRCH> and B<RES_NOIP6DOTINT>."

#. type: Plain text
#: man-pages/man3/resolver.3:442
msgid ""
"The B<res_ninit>()  and B<res_init>()  functions return 0 on success, or -1 "
"if an error occurs."
msgstr ""
"При успешном выполнении функции B<res_ninit>() и B<res_init>() возвращают 0, "
"и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/resolver.3:457
msgid ""
"The B<res_nquery>(), B<res_query>(), B<res_nsearch>(), B<res_search>(), "
"B<res_nquerydomain>(), B<res_querydomain>(), B<res_nmkquery>(), "
"B<res_mkquery>(), B<res_nsend>(), and B<res_send>()  functions return the "
"length of the response, or -1 if an error occurs."
msgstr ""
"Функции B<res_nquery>(), B<res_query>(), B<res_nsearch>(), B<res_search>(), "
"B<res_nquerydomain>(), B<res_querydomain>(), B<res_nmkquery>(), "
"B<res_mkquery>(), B<res_nsend>() и B<res_send>()  возвращают длину ответа "
"или -1 при ошибке."

#. type: Plain text
#: man-pages/man3/resolver.3:464
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""
"Функции B<dn_comp>() и B<dn_expand>() возвращают длину сжатого имени, или -1 "
"при ошибках."

#. type: Plain text
#: man-pages/man3/resolver.3:478
msgid ""
"In the case of an error return from B<res_nquery>(), B<res_query>(), "
"B<res_nsearch>(), B<res_search>(), B<res_nquerydomain>(), or "
"B<res_querydomain>(), the global variable I<h_errno> (see "
"B<gethostbyname>(3))  can be consulted to determine the cause of the error."
msgstr ""
"В случае завершения B<res_nquery>(), B<res_query>(), B<res_nsearch>(), "
"B<res_search>(), B<res_nquerydomain>() или B<res_querydomain>() с ошибкой, "
"по глобальной переменной I<h_errno> (смотрите B<gethostbyname>(3)) можно "
"определить причину."

#. type: TP
#: man-pages/man3/resolver.3:479
#, no-wrap
msgid "I</etc/resolv.conf>"
msgstr "I</etc/resolv.conf>"

#. type: Plain text
#: man-pages/man3/resolver.3:482 man-pages/man3/resolver.3:485
msgid "resolver configuration file"
msgstr "файл с настройками резолвера"

#. type: TP
#: man-pages/man3/resolver.3:482
#, no-wrap
msgid "I</etc/host.conf>"
msgstr "I</etc/host.conf>"

#. type: tbl table
#: man-pages/man3/resolver.3:497
#, no-wrap
msgid ""
"B<res_ninit>(),\n"
"B<res_nclose>(),\n"
"B<res_nquery>(),\n"
msgstr ""
"B<res_ninit>(),\n"
"B<res_nclose>(),\n"
"B<res_nquery>(),\n"

#. type: tbl table
#: man-pages/man3/resolver.3:501
#, no-wrap
msgid ""
"B<res_nsearch>(),\n"
"B<res_nquerydomain>(),\n"
"B<res_nsend>()"
msgstr ""
"B<res_nsearch>(),\n"
"B<res_nquerydomain>(),\n"
"B<res_nsend>()"

#. type: tbl table
#: man-pages/man3/resolver.3:505
#, no-wrap
msgid ""
"B<res_nmkquery>(),\n"
"B<dn_comp>(),\n"
msgstr ""
"B<res_nmkquery>(),\n"
"B<dn_comp>(),\n"

#. type: tbl table
#: man-pages/man3/resolver.3:507
#, no-wrap
msgid "B<dn_expand>()"
msgstr "B<dn_expand>()"

#. type: Plain text
#: man-pages/man3/resolver.3:512
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: man-pages/man3/resolver.3:518
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"

#. type: Plain text
#: man-pages/man3/resolver.3:520
msgid "The GNU C library source file I<resolv/README>."
msgstr "Файл I<resolv/README> из библиотеки GNU C."

#. type: TH
#: man-pages/man3/rpmatch.3:29
#, no-wrap
msgid "RPMATCH"
msgstr "RPMATCH"

#. type: Plain text
#: man-pages/man3/rpmatch.3:32
msgid ""
"rpmatch - determine if the answer to a question is affirmative or negative"
msgstr ""
"rpmatch - определяет, является ли ответ на вопрос утвердительным или "
"отрицательным"

#. type: Plain text
#: man-pages/man3/rpmatch.3:37
#, no-wrap
msgid "B<int rpmatch(const char *>I<response>B<);>\n"
msgstr "B<int rpmatch(const char *>I<response>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:49
#, no-wrap
msgid ""
"B<rpmatch>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""
"B<rpmatch>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:53
msgid ""
"B<rpmatch>()  handles a user response to yes or no questions, with support "
"for internationalization."
msgstr ""
"Функция B<rpmatch>() обрабатывает ответ пользователя «да» или «нет» на "
"вопросы, учитывая интернационализацию."

#. type: Plain text
#: man-pages/man3/rpmatch.3:60
msgid ""
"I<response> should be a null-terminated string containing a user-supplied "
"response, perhaps obtained with B<fgets>(3)  or B<getline>(3)."
msgstr ""
"В аргументе I<response> должен указываться ответ пользователя в виде строки, "
"заканчивающейся null, полученной, например, с помощью B<fgets>(3) или "
"B<getline>(3)."

#. type: Plain text
#: man-pages/man3/rpmatch.3:70
msgid ""
"The user's language preference is taken into account per the environment "
"variables B<LANG>, B<LC_MESSAGES>, and B<LC_ALL>, if the program has called "
"B<setlocale>(3)  to effect their changes."
msgstr ""
"Пользовательские языковые настройки определяются с помощью переменных "
"окружения B<LANG>, B<LC_MESSAGES> и B<LC_ALL>, если для их учёта программа "
"вызывала B<setlocale>(3)."

#. type: Plain text
#: man-pages/man3/rpmatch.3:76
msgid ""
"Regardless of the locale, responses matching B<^[Yy]> are always accepted as "
"affirmative, and those matching B<^[Nn]> are always accepted as negative."
msgstr ""
"Вне зависимости от локали, ответы, соответствующие B<^[Yy]>, всегда "
"считаются утвердительными, а соответствующие B<^[Nn]>, всегда принимаются за "
"отрицательные."

#. type: Plain text
#: man-pages/man3/rpmatch.3:85
msgid ""
"After examining I<response>, B<rpmatch>()  returns 0 for a recognized "
"negative response (\"no\"), 1 for a recognized positive response (\"yes\"), "
"and -1 when the value of I<response> is unrecognized."
msgstr ""
"После проверки I<response>, функция B<rpmatch>() возвращает 0 при найденном "
"отрицательном ответе («нет»), 1 при положительном ответе («да») и -1, когда "
"значение I<response> не распознано."

#. type: Plain text
#: man-pages/man3/rpmatch.3:89
msgid ""
"A return value of -1 may indicate either an invalid input, or some other "
"error.  It is incorrect to only test if the return value is nonzero."
msgstr ""
"Возвращаемое значение -1 может указывать на неправильные входные данные, "
"либо какую-то другую ошибку. Не стоит проверять является ли возвращаемое "
"значение лишь отличным от нуля."

#. type: Plain text
#: man-pages/man3/rpmatch.3:102
msgid ""
"B<rpmatch>()  can fail for any of the reasons that B<regcomp>(3)  or "
"B<regexec>(3)  can fail; the cause of the error is not available from "
"I<errno> or anywhere else, but indicates a failure of the regex engine (but "
"this case is indistinguishable from that of an unrecognized value of "
"I<response>)."
msgstr ""
"Функция B<rpmatch>() может завершиться с ошибкой по любой из причин, по "
"которым могут не выполниться B<regcomp>(3) или B<regexec>(3); причина ошибки "
"не указывается в I<errno> или где-то ещё — это указывает на ошибку в самом "
"механизме regex (но этот случай не отличается от нераспознанных значений "
"I<response>)."

#. type: tbl table
#: man-pages/man3/rpmatch.3:112
#, no-wrap
msgid "B<rpmatch>()"
msgstr "B<rpmatch>()"

#.  It is available on at least AIX 5.1 and FreeBSD 6.0.
#. type: Plain text
#: man-pages/man3/rpmatch.3:120
msgid ""
"B<rpmatch>()  is not required by any standard, but is available on a few "
"other systems."
msgstr ""
"Функция B<rpmatch>() не является стандартной, но доступна в некоторых других "
"системах."

#. type: Plain text
#: man-pages/man3/rpmatch.3:135
msgid ""
"The B<rpmatch>()  implementation looks at only the first character of "
"I<response>.  As a consequence, \"nyes\" returns 0, and \"ynever; not in a "
"million years\" returns 1.  It would be preferable to accept input strings "
"much more strictly, for example (using the extended regular expression "
"notation described in B<regex>(7)): B<^([yY]|yes|YES)$> and B<^([nN]|no|"
"NO)$>."
msgstr ""
"Реализация B<rpmatch>() учитывает лишь первый символ I<response>. Так что, "
"«ну, да.» вернёт 0, а «да нет же, ни за что!» вернёт 1. Правильнее было бы "
"использовать расширенные правила для обработки входных строк (использования "
"дополненных регулярных выражений описано в B<regex>(7)): B<^([yY]|yes|YES)$> "
"и B<^([nN]|no|NO)$>."

#. type: Plain text
#: man-pages/man3/rpmatch.3:139
msgid ""
"The following program displays the results when B<rpmatch>()  is applied to "
"the string given in the program's command-line argument."
msgstr ""
"Следующая программа показывает результаты, когда в B<rpmatch>() передана "
"строка, полученная программой из командной строки."

#. type: Plain text
#: man-pages/man3/rpmatch.3:146
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"#include E<lt>locale.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _SVID_SOURCE\n"
"#include E<lt>locale.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:154
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s response\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s response\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:159
#, no-wrap
msgid ""
"    setlocale(LC_ALL, \"\");\n"
"    printf(\"rpmatch() returns: %d\\en\", rpmatch(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    setlocale(LC_ALL, \"\");\n"
"    printf(\"rpmatch() returns: %d\\en\", rpmatch(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/rpmatch.3:165
msgid ""
"B<fgets>(3), B<getline>(3), B<nl_langinfo>(3), B<regcomp>(3), B<setlocale>(3)"
msgstr ""
"B<fgets>(3), B<getline>(3), B<nl_langinfo>(3), B<regcomp>(3), B<setlocale>(3)"

#. type: TH
#: man-pages/man3/remquo.3:12
#, no-wrap
msgid "REMQUO"
msgstr "REMQUO"

#. type: Plain text
#: man-pages/man3/remquo.3:15
msgid "remquo, remquof, remquol - remainder and part of quotient"
msgstr "remquo, remquof, remquol - остаток и неполное частное"

#. type: Plain text
#: man-pages/man3/remquo.3:22
#, no-wrap
msgid ""
"B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"
"B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"
"B<long double remquol(long double >I<x>B<, long double >I<y>B<, int *>I<quo>B<);>\n"
msgstr ""
"B<double remquo(double >I<x>B<, double >I<y>B<, int *>I<quo>B<);>\n"
"B<float remquof(float >I<x>B<, float >I<y>B<, int *>I<quo>B<);>\n"
"B<long double remquol(long double >I<x>B<, long double >I<y>B<, int *>I<quo>B<);>\n"

#. type: Plain text
#: man-pages/man3/remquo.3:35
msgid "B<remquo>(), B<remquof>(), B<remquol>():"
msgstr "B<remquo>(), B<remquof>(), B<remquol>():"

#. type: Plain text
#: man-pages/man3/remquo.3:49
msgid ""
"These functions compute the remainder and part of the quotient upon division "
"of I<x> by I<y>.  A few bits of the quotient are stored via the I<quo> "
"pointer.  The remainder is returned as the function result."
msgstr ""
"Эти функции вычисляют остаток и неполное частное при делении I<x> на I<y>. "
"Неполное частное сохраняется через указатель I<quo>. Остаток возвращается "
"как результат функции."

#. type: Plain text
#: man-pages/man3/remquo.3:53
msgid ""
"The value of the remainder is the same as that computed by the "
"B<remainder>(3)  function."
msgstr "Значение остатка тоже, что и при вычислении функцией B<remainder>(3)."

#. type: Plain text
#: man-pages/man3/remquo.3:59
msgid ""
"The value stored via the I<quo> pointer has the sign of I<x\\ /\\ y> and "
"agrees with the quotient in at least the low order 3 bits."
msgstr ""
"Значение, сохраняемое по указателю I<quo>, имеет знак I<x\\ /\\ y> и "
"сохраняет от частного не менее 3 младших бит."

#.  A possible application of this function might be the computation
#.  of sin(x). Compute remquo(x, pi/2, &quo) or so.
#.  glibc, UnixWare: return 3 bits
#.  MacOS 10: return 7 bits
#. type: Plain text
#: man-pages/man3/remquo.3:67
msgid ""
"For example, I<remquo(29.0,\\ 3.0)> returns -1.0 and might store 2.  Note "
"that the actual quotient might not fit in an integer."
msgstr ""
"Например, I<remquo(29.0,\\ 3.0)> возвращает -1.0 и может сохранить 2. "
"Заметим, что реальный остаток может не поместиться в integer."

#. type: Plain text
#: man-pages/man3/remquo.3:71
msgid ""
"On success, these functions return the same value as the analogous functions "
"described in B<remainder>(3)."
msgstr ""
"При успешном выполнении данные функции возвращают тоже значение, что и "
"аналогичные функции, описанные в B<remainder>(3)."

#. type: Plain text
#: man-pages/man3/remquo.3:77
msgid "If I<x> or I<y> is a NaN, a NaN is returned."
msgstr "Если значение I<x> или I<y> равно NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/remquo.3:86
msgid ""
"If I<x> is an infinity, and I<y> is not a NaN, a domain error occurs, and a "
"NaN is returned."
msgstr ""
"Если I<x> стремится к бесконечности и I<y> не равно NaN, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата "
"будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/remquo.3:95
msgid ""
"If I<y> is zero, and I<x> is not a NaN, a domain error occurs, and a NaN is "
"returned."
msgstr ""
"Если I<y> равно 0 и I<x> не равно NaN, то будет сгенерирована ошибка выхода "
"за пределы области, а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/remquo.3:100
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить возникшую ошибку при вызове этих "
"функций."

#. type: Plain text
#: man-pages/man3/remquo.3:102
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/remquo.3:102
#, no-wrap
msgid "Domain error: I<x> is an infinity or I<y> is 0, and the other argument is not a NaN"
msgstr "Ошибка области: I<x> стремится к бесконечности или I<y> равно 0, и другой аргумент не равен NaN."

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/remquo.3:111
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "Возникает исключение неправильной плавающей запятой (B<FE_INVALID>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6802
#. type: Plain text
#: man-pages/man3/remquo.3:116
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: tbl table
#: man-pages/man3/remquo.3:130
#, no-wrap
msgid ""
"B<remquo>(),\n"
"B<remquof>(),\n"
"B<remquol>()"
msgstr ""
"B<remquo>(),\n"
"B<remquof>(),\n"
"B<remquol>()"

#. type: Plain text
#: man-pages/man3/remquo.3:137
msgid "B<fmod>(3), B<logb>(3), B<remainder>(3)"
msgstr "B<fmod>(3), B<logb>(3), B<remainder>(3)"

#. type: TH
#: man-pages/man3/remainder.3:37
#, no-wrap
msgid "REMAINDER"
msgstr "REMAINDER"

#. type: Plain text
#: man-pages/man3/remainder.3:41
msgid ""
"drem, dremf, dreml, remainder, remainderf, remainderl - floating-point "
"remainder function"
msgstr ""
"drem, dremf, dreml, remainder, remainderf, remainderl - функция получения "
"остатка от деления числа с плавающей запятой"

#. type: Plain text
#: man-pages/man3/remainder.3:49
#, no-wrap
msgid ""
"/* The C99 versions */\n"
"B<double remainder(double >I<x>B<, double >I<y>B<);>\n"
"B<float remainderf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double remainderl(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"/* Версии C99 */\n"
"B<double remainder(double >I<x>B<, double >I<y>B<);>\n"
"B<float remainderf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double remainderl(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/remainder.3:54
#, no-wrap
msgid ""
"/* Obsolete synonyms */\n"
"B<double drem(double >I<x>B<, double >I<y>B<);>\n"
"B<float dremf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double dreml(long double >I<x>B<, long double >I<y>B<);>\n"
msgstr ""
"/* Устаревшие синонимы */\n"
"B<double drem(double >I<x>B<, double >I<y>B<);>\n"
"B<float dremf(float >I<x>B<, float >I<y>B<);>\n"
"B<long double dreml(long double >I<x>B<, long double >I<y>B<);>\n"

#. type: Plain text
#: man-pages/man3/remainder.3:65
msgid "B<remainder>():"
msgstr "B<remainder>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/remainder.3:71
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/remainder.3:75
msgid "B<remainderf>(), B<remainderl>():"
msgstr "B<remainderf>(), B<remainderl>():"

#. type: Plain text
#: man-pages/man3/remainder.3:79
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/remainder.3:84
msgid "B<drem>(), B<dremf>(), B<dreml>():"
msgstr "B<drem>(), B<dremf>(), B<dreml>():"

#. type: Plain text
#: man-pages/man3/remainder.3:87
#, no-wrap
msgid ""
"/* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/remainder.3:107
msgid ""
"These functions compute the remainder of dividing I<x> by I<y>.  The return "
"value is I<x>-I<n>*I<y>, where I<n> is the value I<x\\ /\\ y>, rounded to "
"the nearest integer.  If the absolute value of I<x>-I<n>*I<y> is 0.5, I<n> "
"is chosen to be even."
msgstr ""
"Данные функции вычисляют остаток от деления I<x> на I<y>. Возвращаемое "
"значение равно I<x>-I<n>*I<y>, где I<n> равно значению I<x\\ /\\ y>, "
"округлённому до ближайшего целого. Если абсолютное значение I<x>-I<n>*I<y> "
"равно 0.5, то I<n> выбирается целым."

#. type: Plain text
#: man-pages/man3/remainder.3:110
msgid ""
"These functions are unaffected by the current rounding mode (see B<fenv>(3))."
msgstr ""
"Эти функции не подвержены действующему режиму округления (смотрите "
"B<fenv>(3))."

#. type: Plain text
#: man-pages/man3/remainder.3:114
msgid "The B<drem>()  function does precisely the same thing."
msgstr "Функция B<drem>() выполняет тоже самое."

#. type: Plain text
#: man-pages/man3/remainder.3:120
msgid ""
"On success, these functions return the floating-point remainder, I<x>-"
"I<n>*I<y>.  If the return value is 0, it has the sign of I<x>."
msgstr ""
"При успешном выполнении данные функции возвращают остаток I<x>-I<n>*I<y> в "
"виде значения с плавающей запятой. Если возвращаемое значение равно 0, то "
"оно имеет знак I<x>."

#. type: TP
#: man-pages/man3/remainder.3:153
#, no-wrap
msgid "Domain error: I<x> is an infinity and I<y> is not a NaN"
msgstr "Ошибка области: I<x> стремится к бесконечности, а I<y> не равно NaN"

#. type: Plain text
#: man-pages/man3/remainder.3:162
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr ""
"I<errno> устанавливается в B<EDOM> (но см. ДЕФЕКТЫ). Возникает исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#. type: Plain text
#: man-pages/man3/remainder.3:166
msgid "These functions do not set I<errno> for this case."
msgstr "В этом случае функции не изменяют I<errno>."

#.  [XXX see bug above] and \fIx\fP is not a NaN
#. type: TP
#: man-pages/man3/remainder.3:166
#, no-wrap
msgid "Domain error: I<y> is zero"
msgstr "Ошибка области: I<y> равно 0"

#. type: Plain text
#: man-pages/man3/remainder.3:174
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<EDOM>. Возникает исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#. type: tbl table
#: man-pages/man3/remainder.3:186
#, no-wrap
msgid ""
"B<drem>(),\n"
"B<dremf>(),\n"
"B<dreml>(),\n"
msgstr ""
"B<drem>(),\n"
"B<dremf>(),\n"
"B<dreml>(),\n"

#. type: tbl table
#: man-pages/man3/remainder.3:189
#, no-wrap
msgid ""
"B<remainder>(),\n"
"B<remainderf>(),\n"
msgstr ""
"B<remainder>(),\n"
"B<remainderf>(),\n"

#. type: tbl table
#: man-pages/man3/remainder.3:191
#, no-wrap
msgid "B<remainderl>()"
msgstr "B<remainderl>()"

#.  IEC 60559.
#. type: Plain text
#: man-pages/man3/remainder.3:201
msgid ""
"The functions B<remainder>(), B<remainderf>(), and B<remainderl>()  are "
"specified in C99, POSIX.1-2001, and POSIX.1-2008."
msgstr ""
"Функции B<remainder>(), B<remainderf>() и B<remainderl>() определены в C99 и "
"POSIX.1-2001 и POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/remainder.3:217
msgid ""
"The function B<drem>()  is from 4.3BSD.  The I<float> and I<long double> "
"variants B<dremf>()  and B<dreml>()  exist on some systems, such as Tru64 "
"and glibc2.  Avoid the use of these functions in favor of B<remainder>()  "
"etc."
msgstr ""
"Функция B<drem>() появилась из 4.3BSD. Варианты функций B<dremf>() и "
"B<dreml>() с типами I<float> и I<long double> есть в некоторых системах, "
"таких как Tru64 и glibc2. Не используйте эти функции вместо B<remainder>() и "
"ей подобным."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6779
#. type: Plain text
#: man-pages/man3/remainder.3:221
msgid "Before glibc 2.15, the call"
msgstr "До glibc 2.15 вызов"

#. type: Plain text
#: man-pages/man3/remainder.3:223
#, no-wrap
msgid "    remainder(nan(\"\"), 0);\n"
msgstr "    remainder(nan(\"\"), 0);\n"

#. type: Plain text
#: man-pages/man3/remainder.3:226
msgid ""
"returned a NaN, as expected, but wrongly caused a domain error.  Since glibc "
"2.15, a silent NaN (i.e., no domain error) is returned."
msgstr ""
"возвращал NaN, как и ожидается, но некорректно приводит к ошибке области; "
"Начиная с glibc 2.15, просто возвращается NaN (т. е., без ошибки области)."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6783
#. type: Plain text
#: man-pages/man3/remainder.3:237
msgid ""
"Before glibc 2.15, I<errno> was not set to B<EDOM> for the domain error that "
"occurs when I<x> is an infinity and I<y> is not a NaN."
msgstr ""
"До glibc 2.15, I<errno> не присваивалось B<EDOM> пр ошибке области, "
"возникающей когда I<x> — бесконечность, а I<y> не равно NaN."

#. type: Plain text
#: man-pages/man3/remainder.3:239
msgid "The call \"remainder(29.0, 3.0)\" returns -1."
msgstr "Вызов «remainder(29.0, 3.0)» возвращает -1."

#. type: Plain text
#: man-pages/man3/remainder.3:242
msgid "B<div>(3), B<fmod>(3), B<remquo>(3)"
msgstr "B<div>(3), B<fmod>(3), B<remquo>(3)"

#. type: TH
#: man-pages/man3/random_r.3:26
#, no-wrap
msgid "RANDOM_R"
msgstr "RANDOM_R"

#. type: Plain text
#: man-pages/man3/random_r.3:30
msgid ""
"random_r, srandom_r, initstate_r, setstate_r - reentrant random number "
"generator"
msgstr ""
"random_r, srandom_r, initstate_r, setstate_r - реентерабельный генератор "
"случайных чисел"

#. type: Plain text
#: man-pages/man3/random_r.3:35
#, no-wrap
msgid "B<int random_r(struct random_data *>I<buf>B<, int32_t *>I<result>B<);>\n"
msgstr "B<int random_r(struct random_data *>I<buf>B<, int32_t *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:37
#, no-wrap
msgid "B<int srandom_r(unsigned int >I<seed>B<, struct random_data *>I<buf>B<);>\n"
msgstr "B<int srandom_r(unsigned int >I<seed>B<, struct random_data *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:40
#, no-wrap
msgid ""
"B<int initstate_r(unsigned int >I<seed>B<, char *>I<statebuf>B<,>\n"
"B<                size_t >I<statelen>B<, struct random_data *>I<buf>B<);>\n"
msgstr ""
"B<int initstate_r(unsigned int >I<seed>B<, char *>I<statebuf>B<,>\n"
"B<                size_t >I<statelen>B<, struct random_data *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:42
#, no-wrap
msgid "B<int setstate_r(char *>I<statebuf>B<, struct random_data *>I<buf>B<);>\n"
msgstr "B<int setstate_r(char *>I<statebuf>B<, struct random_data *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/random_r.3:54
msgid "B<random_r>(), B<srandom_r>(), B<initstate_r>(), B<setstate_r>():"
msgstr "B<random_r>(), B<srandom_r>(), B<initstate_r>(), B<setstate_r>():"

#. type: Plain text
#: man-pages/man3/random_r.3:57
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"/* в glibc начиная с 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/random_r.3:65
msgid ""
"These functions are the reentrant equivalents of the functions described in "
"B<random>(3).  They are suitable for use in multithreaded programs where "
"each thread needs to obtain an independent, reproducible sequence of random "
"numbers."
msgstr ""
"Эти функции являются реентерабельными эквивалентами функций, которые описаны "
"в B<random>(3). Они подходят для использования в многонитевых программах, "
"где каждой нити необходимо получить независимую, воспроизводимую "
"последовательность случайных чисел."

#. type: Plain text
#: man-pages/man3/random_r.3:78
msgid ""
"The B<random_r>()  function is like B<random>(3), except that instead of "
"using state information maintained in a global variable, it uses the state "
"information in the argument pointed to by I<buf>, which must have been "
"previously initialized by B<initstate_r>().  The generated random number is "
"returned in the argument I<result>."
msgstr ""
"Функция B<random_r>() подобна B<random>(3), но вместо использования "
"информации о состоянии, хранящейся в глобальный переменной, в ней "
"используется информация о состоянии в аргументе, указанном в I<buf>, который "
"должен быть проинициализирован ранее с помощью B<initstate_r>(). "
"Сгенерированное случайное число возвращается в аргументе I<result>."

#. type: Plain text
#: man-pages/man3/random_r.3:89
msgid ""
"The B<srandom_r>()  function is like B<srandom>(3), except that it "
"initializes the seed for the random number generator whose state is "
"maintained in the object pointed to by I<buf>, which must have been "
"previously initialized by B<initstate_r>(), instead of the seed associated "
"with the global state variable."
msgstr ""
"Функция B<srandom_r>() подобна B<srandom>(3), но инициализирует семя для "
"генератора случайных чисел, чьё состояние хранится в объекте, на который "
"указывает I<buf> который должен быть проинициализирован ранее с помощью "
"B<initstate_r>(), а не связывает семя с глобальной переменной состояния."

#. type: Plain text
#: man-pages/man3/random_r.3:117
msgid ""
"The B<initstate_r>()  function is like B<initstate>(3)  except that it "
"initializes the state in the object pointed to by I<buf>, rather than "
"initializing the global state variable.  Before calling this function, the "
"I<buf.state> field must be initialized to NULL.  The B<initstate_r>()  "
"function records a pointer to the I<statebuf> argument inside the structure "
"pointed to by I<buf>.  Thus, I<statebuf> should not be deallocated so long "
"as I<buf> is still in use.  (So, I<statebuf> should typically be allocated "
"as a static variable, or allocated on the heap using B<malloc>(3)  or "
"similar.)"
msgstr ""
"Функция B<initstate_r>() подобна B<initstate>(3), но инициализирует "
"состояние в объекте, на который указывает I<buf>, а не в глобальной "
"переменной состояния. Перед вызовом этой функции в поле I<buf.state> нужно "
"записать NULL. Функция B<initstate_r>() сохраняет указатель на аргумент "
"I<statebuf> внутри структуры, указанной в I<buf>. Таким образом, I<statebuf> "
"не должна освобождаться пока используется I<buf> (и I<statebuf> обычно "
"должна быть статической переменной или выделяться из кучи с помощью "
"B<malloc>(3) и подобных ей)."

#. type: Plain text
#: man-pages/man3/random_r.3:130
msgid ""
"The B<setstate_r>()  function is like B<setstate>(3)  except that it "
"modifies the state in the object pointed to by I<buf>, rather than modifying "
"the global state variable.  I<state> must first have been initialized using "
"B<initstate_r>()  or be the result of a previous call of B<setstate_r>()."
msgstr ""
"Функция B<setstate_r>() подобна B<setstate>(3), но изменяет состояние в "
"объекте, на который указывает I<buf>, а не в глобальной переменной "
"состояния. Переменная I<state> сначала должна инициализироваться с помощью  "
"B<initstate_r>() или быть результатом предшествующего вызова B<setstate_r>()."

#. type: Plain text
#: man-pages/man3/random_r.3:135
msgid ""
"All of these functions return 0 on success.  On error, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении все функции возвращают 0. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/random_r.3:140
msgid "A state array of less than 8 bytes was specified to B<initstate_r>()."
msgstr "Функции B<initstate_r>() передан массив состояния меньше 8 байт."

#. type: Plain text
#: man-pages/man3/random_r.3:149
msgid "The I<statebuf> or I<buf> argument to B<setstate_r>()  was NULL."
msgstr "Аргумент I<statebuf> или I<buf> функции B<setstate_r>() равнялся NULL."

#. type: Plain text
#: man-pages/man3/random_r.3:158
msgid "The I<buf> or I<result> argument to B<random_r>()  was NULL."
msgstr "Аргумент I<buf> или I<result> функции B<random_r>() равнялся NULL."

#. type: tbl table
#: man-pages/man3/random_r.3:169
#, no-wrap
msgid ""
"B<random_r>(),\n"
"B<srandom_r>(),\n"
msgstr ""
"B<random_r>(),\n"
"B<srandom_r>(),\n"

#. type: tbl table
#: man-pages/man3/random_r.3:172
#, no-wrap
msgid ""
"B<initstate_r>(),\n"
"B<setstate_r>()"
msgstr ""
"B<initstate_r>(),\n"
"B<setstate_r>()"

#. type: tbl table
#: man-pages/man3/random_r.3:172
#, no-wrap
msgid "MT-Safe race:buf"
msgstr "MT-Safe race:buf"

#.  These functions appear to be on Tru64, but don't seem to be on
#.  Solaris, HP-UX, or FreeBSD.
#. type: Plain text
#: man-pages/man3/random_r.3:178
msgid "These functions are nonstandard glibc extensions."
msgstr "Это функции являются расширениями glibc."

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=3662
#. type: Plain text
#: man-pages/man3/random_r.3:189
msgid ""
"The B<initstate_r>()  interface is confusing.  It appears that the "
"I<random_data> type is intended to be opaque, but the implementation "
"requires the user to either initialize the I<buf.state> field to NULL or "
"zero out the entire structure before the call."
msgstr ""
"Интерфейс B<initstate_r>() запутывает. Он появился для того, чтобы сделать "
"тип I<random_data> скрытым, но реализация требует от пользователя перед "
"вызовом, или инициализировать поле I<buf.state> значением NULL, или обнулить "
"всю структуру."

#. type: Plain text
#: man-pages/man3/random_r.3:192
msgid "B<drand48>(3), B<rand>(3), B<random>(3)"
msgstr "B<drand48>(3), B<rand>(3), B<random>(3)"

#. type: TH
#: man-pages/man3/readdir_r.3:26
#, no-wrap
msgid "READDIR_R"
msgstr "READDIR_R"

#. type: TH
#: man-pages/man3/readdir_r.3:26
#, no-wrap
msgid "2016-03-01"
msgstr "2016-03-01"

#. type: Plain text
#: man-pages/man3/readdir_r.3:29
msgid "readdir_r - read a directory"
msgstr "readdir_r - чтение содержимого каталога"

#. type: Plain text
#: man-pages/man3/readdir_r.3:35
#, no-wrap
msgid "B<int readdir_r(DIR *>I<dirp>B<, struct dirent *>I<entry>B<, struct dirent **>I<result>B<);>\n"
msgstr "B<int readdir_r(DIR *>I<dirp>B<, struct dirent *>I<entry>B<, struct dirent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/readdir_r.3:44
msgid "B<readdir_r>():"
msgstr "B<readdir_r>():"

#. type: Plain text
#: man-pages/man3/readdir_r.3:47
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_POSIX_C_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/readdir_r.3:53
msgid "This function is deprecated; use B<readdir>(3)  instead."
msgstr "Эта функция устарела; вместо неё используйте B<readdir>(3)."

#. type: Plain text
#: man-pages/man3/readdir_r.3:66
msgid ""
"The B<readdir_r>()  function was invented as a reentrant version of "
"B<readdir>(3).  It reads the next directory entry from the directory stream "
"I<dirp>, and returns it in the caller-allocated buffer pointed to by "
"I<entry>.  For details of the I<dirent> structure, see B<readdir>(3)."
msgstr ""
"Функция B<readdir_r>() является реентерабельной версией B<readdir>(3). Она "
"читает следующий элемент каталога из потока каталога I<dirp> и возвращает "
"его в выделенный вызывающим буфер, на который указывает I<entry>. Описание "
"структуры I<dirent> смотрите в B<readdir>(3)."

#. type: Plain text
#: man-pages/man3/readdir_r.3:72
msgid ""
"A pointer to the returned buffer is placed in I<*result>; if the end of the "
"directory stream was encountered, then NULL is instead returned in "
"I<*result>."
msgstr ""
"Указатель на возвращаемый буфер помещается в I<*result>; если достигнут "
"конец потока каталога, то в I<*result> возвращается NULL.."

#. type: Plain text
#: man-pages/man3/readdir_r.3:80
msgid ""
"It is recommended that applications use B<readdir>(3)  instead of "
"B<readdir_r>().  Furthermore, since version 2.24, glibc deprecates "
"B<readdir_r>().  The reasons are as follows:"
msgstr ""
"В приложениях рекомендуется использовать B<readdir>(3) вместо "
"B<readdir_r>(). Также, начиная с версии 2.24, в glibc B<readdir_r>() "
"считается устаревшей. Причины:"

#. type: Plain text
#: man-pages/man3/readdir_r.3:87
msgid ""
"On systems where B<NAME_MAX> is undefined, calling B<readdir_r>()  may be "
"unsafe because the interface does not allow the caller to specify the length "
"of the buffer used for the returned directory entry."
msgstr ""
"В системах, у которых значение B<NAME_MAX> не определено, вызов "
"B<readdir_r>() может быть небезопасным, так как интерфейс не позволяет "
"вызывающему задать длину буфера, который используется для возврата элемента "
"каталога."

#. type: Plain text
#: man-pages/man3/readdir_r.3:101
msgid ""
"On some systems, B<readdir_r>()  can't read directory entries with very long "
"names.  When the glibc implementation encounters such a name, "
"B<readdir_r>()  fails with the error B<ENAMETOOLONG> I<after the final "
"directory entry has been read>.  On some other systems, B<readdir_r>()  may "
"return a success status, but the returned I<d_name> field may not be null "
"terminated or may be truncated."
msgstr ""
"В некоторых системах B<readdir_r>() не может прочитать элементы каталога с "
"очень длинными именами. Когда реализации glibc встречается такое имя, вызов "
"B<readdir_r>() завершается с ошибкой B<ENAMETOOLONG> I<только после чтения "
"последнего элемента каталога>. В других системах B<readdir_r>() может "
"выполняться без ошибок, но возвращаемое поле I<d_name> может не завершаться "
"null или может быть обрезанным."

#. type: Plain text
#: man-pages/man3/readdir_r.3:118
msgid ""
"In the current POSIX.1 specification (POSIX.1-2008), B<readdir>(3)  is not "
"required to be thread-safe.  However, in modern implementations (including "
"the glibc implementation), concurrent calls to B<readdir>(3)  that specify "
"different directory streams are thread-safe.  Therefore, the use of "
"B<readdir_r>()  is generally unnecessary in multithreaded programs.  In "
"cases where multiple threads must read from the same directory stream, using "
"B<readdir>(3)  with external synchronization is still preferable to the use "
"of B<readdir_r>(), for the reasons given in the points above."
msgstr ""
"В текущей спецификации POSIX.1 (POSIX.1-2008), от B<readdir>(3) не требуется "
"быть нитебезопасной. Однако в современных реализациях (включая glibc) "
"параллельные вызовы B<readdir>(3) для различных потоков каталога являются "
"нитебезопасными. Поэтому использовать B<readdir_r>() в многонитевых "
"программах, обычно, не требуется. В случаях, когда несколько нитей должны "
"читать один поток каталога, всё равно предпочтительней использовать "
"B<readdir>(3) с внешней синхронизацией, а не B<readdir_r>(), по причинам, "
"описанным выше."

#.  FIXME .
#.  http://www.austingroupbugs.net/view.php?id=696
#. type: Plain text
#: man-pages/man3/readdir_r.3:127
msgid ""
"It is expected that a future version of POSIX.1 will make B<readdir_r>()  "
"obsolete, and require that B<readdir>(3)  be thread-safe when concurrently "
"employed on different directory streams."
msgstr ""
"Ожидается, что в будущей версии POSIX.1 функция B<readdir_r>() будет "
"помечена как устаревшая, а для B<readdir>(3) будет требоваться "
"нитебезопасность при одновременной работе с разными потоками каталога."

#. type: Plain text
#: man-pages/man3/readdir_r.3:136
msgid ""
"The B<readdir_r>()  function returns 0 on success.  On error, it returns a "
"positive error number (listed under ERRORS).  If the end of the directory "
"stream is reached, B<readdir_r>()  returns 0, and returns NULL in I<*result>."
msgstr ""
"При успешном выполнении функция B<readdir_r>() возвращает 0. При ошибке она "
"возвращает положительный номер ошибки (перечислены в ОШИБКАХ). Если "
"достигнут конец потока каталога, то B<readdir_r>() возвращает 0 и NULL в "
"I<*result>."

#. type: Plain text
#: man-pages/man3/readdir_r.3:140
msgid "Invalid directory stream descriptor I<dirp>."
msgstr "Неверный дескриптор потока каталога I<dirp>."

#. type: Plain text
#: man-pages/man3/readdir_r.3:143
msgid "A directory entry whose name was too long to be read was encountered."
msgstr "Обнаружено слишком длинное имя элемента каталога для чтения."

#. type: tbl table
#: man-pages/man3/readdir_r.3:153
#, no-wrap
msgid "B<readdir_r>()"
msgstr "B<readdir_r>()"

#. type: Plain text
#: man-pages/man3/readdir_r.3:158
msgid "B<readdir>(3)"
msgstr "B<readdir>(3)"

#. type: Plain text
#: man-pages/man3/rpc.3:14
msgid "rpc - library routines for remote procedure calls"
msgstr "rpc - библиотечные функции для вызова удалённых процедур"

#. type: SH
#: man-pages/man3/rpc.3:14
#, no-wrap
msgid "SYNOPSIS AND DESCRIPTION"
msgstr "СИНТАКСИС И ОПИСАНИЕ"

#.  .LP
#.  We don't have an rpc_secure.3 page at the moment -- MTK, 19 Sep 05
#.  Routines that are used for Secure RPC (DES authentication) are described in
#.  .BR rpc_secure (3).
#.  Secure RPC can be used only if DES encryption is available.
#. type: Plain text
#: man-pages/man3/rpc.3:26
msgid ""
"These routines allow C programs to make procedure calls on other machines "
"across the network.  First, the client calls a procedure to send a data "
"packet to the server.  Upon receipt of the packet, the server calls a "
"dispatch routine to perform the requested service, and then sends back a "
"reply.  Finally, the procedure call returns to the client."
msgstr ""
"Эти функции позволяют программам, созданным на Си, вызывать удалённые "
"процедуры на других машинах в сети. Сначала, клиент вызывает процедуру путём "
"отправки пакета с данными на сервер. После принятия пакета сервер вызывает "
"функцию распределения (dispatch) для выполнения запрошенной службы и "
"отсылает ответ обратно. Последним действием результат выполнения процедуры "
"возвращается клиенту."

#. type: Plain text
#: man-pages/man3/rpc.3:29
msgid ""
"To take use of these routines, include the header file I<E<lt>rpc/rpc."
"hE<gt>>."
msgstr ""
"Чтобы использовать эти функции, включите заголовочный файл I<E<lt>rpc/rpc."
"hE<gt>>."

#. type: Plain text
#: man-pages/man3/rpc.3:31
msgid "The prototypes below make use of the following types:"
msgstr "Представленные ниже прототипы позволяют использовать следующие типы:"

#. type: Plain text
#: man-pages/man3/rpc.3:35
#, no-wrap
msgid "B<typedef int >I<bool_t>B<;>\n"
msgstr "B<typedef int >I<bool_t>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:37
#, no-wrap
msgid "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"
msgstr "B<typedef bool_t (*>I<xdrproc_t>B<) (XDR *, void *, ...);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:40
#, no-wrap
msgid ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\n"
"B<                                struct sockaddr_in *>I<raddr>B<);>\n"
msgstr ""
"B<typedef bool_t (*>I<resultproc_t>B<) (caddr_t >I<resp>B<,>\n"
"B<                                struct sockaddr_in *>I<raddr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:50
msgid ""
"See the header files for the declarations of the I<AUTH>, I<CLIENT>, "
"I<SVCXPRT>, and I<XDR> types."
msgstr ""
"Объявления типов I<AUTH>, I<CLIENT>, I<SVCXPRT> и I<XDR> смотрите в "
"заголовочных файлах."

#. type: Plain text
#: man-pages/man3/rpc.3:53
#, no-wrap
msgid "B<void auth_destroy(AUTH *>I<auth>B<);>\n"
msgstr "B<void auth_destroy(AUTH *>I<auth>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:62
msgid ""
"A macro that destroys the authentication information associated with "
"I<auth>.  Destruction usually involves deallocation of private data "
"structures.  The use of I<auth> is undefined after calling B<auth_destroy>()."
msgstr ""
"Макрос, который уничтожает аутентификационную информацию, связанную с "
"I<auth>. Уничтожение, обычно, вызывает высвобождение скрытых структур "
"данных. Работа с I<auth> после вызова B<auth_destroy>() не описана."

#. type: Plain text
#: man-pages/man3/rpc.3:65
#, no-wrap
msgid "B<AUTH *authnone_create(void);>\n"
msgstr "B<AUTH *authnone_create(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:71
msgid ""
"Create and return an RPC authentication handle that passes nonusable "
"authentication information with each remote procedure call.  This is the "
"default authentication used by RPC."
msgstr ""
"Создаёт и возвращает аутентификационный описатель RPC, который передаёт "
"непригодную аутентификационную информацию с каждым вызовом удалённой "
"процедуры. Данная аутентификация используется в RPC по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:75
#, no-wrap
msgid ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\n"
"B<                      int >I<len>B<, int *>I<aup_gids>B<);>\n"
msgstr ""
"B<AUTH *authunix_create(char *>I<host>B<, int >I<uid>B<, int >I<gid>B<,>\n"
"B<                      int >I<len>B<, int *>I<aup_gids>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:91
msgid ""
"Create and return an RPC authentication handle that contains authentication "
"information.  The parameter I<host> is the name of the machine on which the "
"information was created; I<uid> is the user's user ID; I<gid> is the user's "
"current group ID; I<len> and I<aup_gids> refer to a counted array of groups "
"to which the user belongs.  It is easy to impersonate a user."
msgstr ""
"Создаёт и возвращает аутентификационный описатель RPC, который содержит "
"аутентификационную информацию. В параметре I<host> содержится имя машины, на "
"которой была создана информация; в I<uid> содержится пользовательский "
"идентификатор; в I<gid> содержится идентификатор текущей группы "
"пользователя; значения I<len> и I<aup_gids> описывают обновляемый (counted) "
"массив групп, к которым принадлежит пользователь. Это упрощает "
"персонализацию пользователя."

#. type: Plain text
#: man-pages/man3/rpc.3:94
#, no-wrap
msgid "B<AUTH *authunix_create_default(void);>\n"
msgstr "B<AUTH *authunix_create_default(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:99
msgid "Calls B<authunix_create>()  with the appropriate parameters."
msgstr "Вызывает B<authunix_create>() с соответствующими параметрами."

#. type: Plain text
#: man-pages/man3/rpc.3:105
#, no-wrap
msgid ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<            unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<            xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<            xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr ""
"B<int callrpc(char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<            unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<            xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<            xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:129
msgid ""
"Call the remote procedure associated with I<prognum>, I<versnum>, and "
"I<procnum> on the machine, I<host>.  The parameter I<in> is the address of "
"the procedure's argument(s), and I<out> is the address of where to place the "
"result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results.  This routine returns "
"zero if it succeeds, or the value of B<enum clnt_stat> cast to an integer if "
"it fails.  The routine B<clnt_perrno>()  is handy for translating failure "
"statuses into messages."
msgstr ""
"Вызывает удалённую процедуру, связанную с I<prognum>, I<versnum> и "
"I<procnum> на машине I<host>. В параметре I<in> передаётся адрес параметров "
"процедуры, в I<out> — адрес, по которому должен помещаться результат; "
"I<inproc> используется для кодирования параметров процедуры, а I<outproc> — "
"для декодирования результатов. При успешном выполнении эта функция "
"возвращает 0 или целое значение в B<enum clnt_stat> при ошибке. Для перевода "
"номера ошибки в сообщение об ошибке можно использовать функцию "
"B<clnt_perrno>()."

#. type: Plain text
#: man-pages/man3/rpc.3:135
msgid ""
"Warning: calling remote procedures with this routine uses UDP/IP as a "
"transport; see B<clntudp_create>()  for restrictions.  You do not have "
"control of timeouts or authentication using this routine."
msgstr ""
"Предупреждение: при вызове удалённой процедуры с помощью данной функции для "
"передачи используется протокол UDP/IP; ограничения смотрите в описании "
"B<clntudp_create>(). При использовании данной функции вы не можете управлять "
"задержкой или аутентификацией."

#. type: Plain text
#: man-pages/man3/rpc.3:142
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\n"
"B<                     unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<                     xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                     xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                     resultproc_t >I<eachresult>B<);>\n"
msgstr ""
"B<enum clnt_stat clnt_broadcast(unsigned long >I<prognum>B<,>\n"
"B<                     unsigned long >I<versnum>B<, unsigned long >I<procnum>B<,>\n"
"B<                     xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                     xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                     resultproc_t >I<eachresult>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:151
msgid ""
"Like B<callrpc>(), except the call message is broadcast to all locally "
"connected broadcast nets.  Each time it receives a response, this routine "
"calls B<eachresult>(), whose form is:"
msgstr ""
"Подобна B<callrpc>(), только сообщение посылается как широковещательное во "
"все локально подключённые сети. Каждый раз при получении ответа эта функция "
"вызывает B<eachresult>() следующего вида:"

#. type: Plain text
#: man-pages/man3/rpc.3:155
#, no-wrap
msgid "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<eachresult(char *>I<out>B<, struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:172
msgid ""
"where I<out> is the same as I<out> passed to B<clnt_broadcast>(), except "
"that the remote procedure's output is decoded there; I<addr> points to the "
"address of the machine that sent the results.  If B<eachresult>()  returns "
"zero, B<clnt_broadcast>()  waits for more replies; otherwise it returns with "
"appropriate status."
msgstr ""
"где I<out> — тот же самый параметр I<out>, переданный в B<clnt_broadcast>(), "
"за исключением того, что результат удалённой процедуры сразу же "
"декодируется; I<addr> указывает на адрес машины, которая послала результат. "
"Если B<eachresult>() возвращает 0, то B<clnt_broadcast>() продолжит ждать "
"ответы; в противном случае она возвращает соответствующий статус."

#. type: Plain text
#: man-pages/man3/rpc.3:176
msgid ""
"Warning: broadcast sockets are limited in size to the maximum transfer unit "
"of the data link.  For ethernet, this value is 1500 bytes."
msgstr ""
"Предупреждение: размер широковещательных сокетов ограничен максимальной "
"единицей передачи данных подключения. Для ethernet это значение равно 1500 "
"байтам."

#. type: Plain text
#: man-pages/man3/rpc.3:182
#, no-wrap
msgid ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<);>\n"
msgstr ""
"B<enum clnt_stat clnt_call(CLIENT *>I<clnt>B<, unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:201
msgid ""
"A macro that calls the remote procedure I<procnum> associated with the "
"client handle, I<clnt>, which is obtained with an RPC client creation "
"routine such as B<clnt_create>().  The parameter I<in> is the address of the "
"procedure's argument(s), and I<out> is the address of where to place the "
"result(s); I<inproc> is used to encode the procedure's parameters, and "
"I<outproc> is used to decode the procedure's results; I<tout> is the time "
"allowed for results to come back."
msgstr ""
"Макрос, который вызывает удалённую процедуру I<procnum>, связанную с "
"клиентским описателем I<clnt>, полученным от функции создания клиента RPC, "
"такой как B<clnt_create>(). Параметр I<in> — адрес аргументов процедуры, а "
"I<out> —  адрес, по которому размещается результат; I<inproc> используется "
"для кодирования параметров процедуры, а I<outproc> используется для "
"декодирования её результатов; I<tout> — допустимое время ожидания "
"результатов."

#. type: Plain text
#: man-pages/man3/rpc.3:204
#, no-wrap
msgid "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"
msgstr "B<clnt_destroy(CLIENT *>I<clnt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:217
msgid ""
"A macro that destroys the client's RPC handle.  Destruction usually involves "
"deallocation of private data structures, including I<clnt> itself.  Use of "
"I<clnt> is undefined after calling B<clnt_destroy>().  If the RPC library "
"opened the associated socket, it will close it also.  Otherwise, the socket "
"remains open."
msgstr ""
"Макрос, который уничтожает клиентский описатель RPC. Уничтожение, обычно, "
"затрагивает скрытые структуры данных, включая сам I<clnt>. Работа с I<clnt> "
"после вызова B<clnt_destroy>() не описана. Если библиотека RPC открывала "
"связанный сокет, он также будет закрыт. В противном случае сокет останется "
"открытым."

#. type: Plain text
#: man-pages/man3/rpc.3:221
#, no-wrap
msgid ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\n"
"B<                    unsigned long >I<vers>B<, char *>I<proto>B<);>\n"
msgstr ""
"B<CLIENT *clnt_create(char *>I<host>B<, unsigned long >I<prog>B<,>\n"
"B<                    unsigned long >I<vers>B<, char *>I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:232
msgid ""
"Generic client creation routine.  I<host> identifies the name of the remote "
"host where the server is located.  I<proto> indicates which kind of "
"transport protocol to use.  The currently supported values for this field "
"are \\(lqudp\\(rq and \\(lqtcp\\(rq.  Default timeouts are set, but can be "
"modified using B<clnt_control>()."
msgstr ""
"Основная функция для создания клиента. В I<host> указывается имя удалённой "
"машины, где где расположен сервер. В I<proto> указывается тип протокола "
"передачи, который будет использован. Поддерживаемые значения этого поля: "
"«udp» и «tcp». Время задержки задаётся значением по умолчанию, но может быть "
"изменено с помощью B<clnt_control>()."

#. type: Plain text
#: man-pages/man3/rpc.3:237
msgid ""
"Warning: using UDP has its shortcomings.  Since UDP-based RPC messages can "
"hold only up to 8 Kbytes of encoded data, this transport cannot be used for "
"procedures that take large arguments or return huge results."
msgstr ""
"Предупреждение: использование UDP имеет недостатки. Так как в сообщениях RPC "
"на основе UDP может быть только 8 КБ закодированных данных, этот протокол не "
"может быть использован для процедур с большим количеством параметров или "
"которые возвращают результат большого размера."

#. type: Plain text
#: man-pages/man3/rpc.3:240
#, no-wrap
msgid "B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"
msgstr "B<bool_t clnt_control(CLIENT *>I<cl>B<, int >I<req>B<, char *>I<info>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:251
msgid ""
"A macro used to change or retrieve various information about a client "
"object.  I<req> indicates the type of operation, and I<info> is a pointer to "
"the information.  For both UDP and TCP, the supported values of I<req> and "
"their argument types and what they do are:"
msgstr ""
"Макрос, используемый для изменения или получения различной информации о "
"клиентском объекте. В I<req> указывается тип операции, а в I<info> — "
"указатель на информацию. Для UDP и TCP поддерживаются следующие значения "
"I<req> и их типы параметров:"

#. type: Plain text
#: man-pages/man3/rpc.3:256
#, no-wrap
msgid ""
"B<CLSET_TIMEOUT>  I<struct timeval> // set total timeout\n"
"B<CLGET_TIMEOUT>  I<struct timeval> // get total timeout\n"
msgstr ""
"// назначить общее время ожидания\n"
"B<CLSET_TIMEOUT>  I<struct timeval>\n"
"// получить общее время ожидания\n"
"B<CLGET_TIMEOUT>  I<struct timeval>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:264
msgid ""
"Note: if you set the timeout using B<clnt_control>(), the timeout parameter "
"passed to B<clnt_call>()  will be ignored in all future calls."
msgstr ""
"Замечание: если вы установили время ожидания с помощью B<clnt_control>(), то "
"параметр времени ожидания, передаваемый B<clnt_call>(), будет игнорироваться "
"во всех будущих вызовах."

#. type: Plain text
#: man-pages/man3/rpc.3:268
#, no-wrap
msgid "B<CLGET_SERVER_ADDR>  I<struct sockaddr_in > // get server's address\n"
msgstr ""
"// получить адрес сервера\n"
"B<CLGET_SERVER_ADDR>  I<struct sockaddr_in >\n"

#. type: Plain text
#: man-pages/man3/rpc.3:272
msgid "The following operations are valid for UDP only:"
msgstr "Следующие операции действительны только для UDP:"

#. type: Plain text
#: man-pages/man3/rpc.3:277
#, no-wrap
msgid ""
"B<CLSET_RETRY_TIMEOUT>  I<struct timeval> // set the retry timeout\n"
"B<CLGET_RETRY_TIMEOUT>  I<struct timeval> // get the retry timeout\n"
msgstr ""
"// назначить повторное время ожидания\n"
"B<CLSET_RETRY_TIMEOUT>  I<struct timeval>\n"
"// получить повторное время ожидания\n"
"B<CLGET_RETRY_TIMEOUT>  I<struct timeval>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:283
msgid ""
"The retry timeout is the time that \"UDP RPC\" waits for the server to reply "
"before retransmitting the request."
msgstr ""
"Повторное время — это время, в течение которого «UDP RPC» ждёт ответа от "
"сервера перед повторной отправкой запроса."

#. type: Plain text
#: man-pages/man3/rpc.3:286
#, no-wrap
msgid "B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr "B<clnt_freeres(CLIENT * >I<clnt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:297
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the results of an RPC call.  The parameter I<out> is the address of the "
"results, and I<outproc> is the XDR routine describing the results.  This "
"routine returns one if the results were successfully freed, and zero "
"otherwise."
msgstr ""
"Макрос, который освобождает любые данные, размещаемые системой RPC/XDR, "
"когда она декодирует результаты вызова RPC. Параметр I<out> — адрес "
"результатов, а I<outproc> — функция XDR, описывающая результаты. Эта функция "
"возвращает 1, если результаты были успешно освобождены и 0 в противном "
"случае."

#. type: Plain text
#: man-pages/man3/rpc.3:300
#, no-wrap
msgid "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"
msgstr "B<void clnt_geterr(CLIENT *>I<clnt>B<, struct rpc_err *>I<errp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:305
msgid ""
"A macro that copies the error structure out of the client handle to the "
"structure at address I<errp>."
msgstr ""
"Макрос, который копирует структуру ошибки клиентского описателя в структуру "
"по адресу I<errp>."

#. type: Plain text
#: man-pages/man3/rpc.3:308
#, no-wrap
msgid "B<void clnt_pcreateerror(char *>I<s>B<);>\n"
msgstr "B<void clnt_pcreateerror(char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:322
msgid ""
"Print a message to standard error indicating why a client RPC handle could "
"not be created.  The message is prepended with string I<s> and a colon.  "
"Used when a B<clnt_create>(), B<clntraw_create>(), B<clnttcp_create>(), or "
"B<clntudp_create>()  call fails."
msgstr ""
"Выводит в стандартный поток ошибок сообщение, описывающее почему клиентский "
"описатель RPC не удалось создать. В начало сообщения добавляется строка I<s> "
"и знак двоеточия. Используется при ошибках в функциях B<clnt_create>(), "
"B<clntraw_create>(), B<clnttcp_create>() или B<clntudp_create>()."

#. type: Plain text
#: man-pages/man3/rpc.3:325
#, no-wrap
msgid "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"
msgstr "B<void clnt_perrno(enum clnt_stat >I<stat>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:332
msgid ""
"Print a message to standard error corresponding to the condition indicated "
"by I<stat>.  Used after B<callrpc>()."
msgstr ""
"Выводит в стандартный поток ошибок сообщение согласно условию, указанному в "
"I<stat>. Используется после B<callrpc>()."

#. type: Plain text
#: man-pages/man3/rpc.3:335
#, no-wrap
msgid "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"
msgstr "B<clnt_perror(CLIENT *>I<clnt>B<, char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:345
msgid ""
"Print a message to standard error indicating why an RPC call failed; I<clnt> "
"is the handle used to do the call.  The message is prepended with string "
"I<s> and a colon.  Used after B<clnt_call>()."
msgstr ""
"Выводит в стандартный поток ошибок сообщение, описывающее почему вызов RPC "
"завершился с ошибкой. Значение I<clnt> — описатель, использовавшийся при "
"вызове. В начало сообщения добавляется строка I<s> и знак двоеточия. "
"Используется после B<clnt_call>()."

#. type: Plain text
#: man-pages/man3/rpc.3:348
#, no-wrap
msgid "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"
msgstr "B<char *clnt_spcreateerror(char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:353
msgid ""
"Like B<clnt_pcreateerror>(), except that it returns a string instead of "
"printing to the standard error."
msgstr ""
"Похожа на B<clnt_pcreateerror>(), но возвращает строку вместо вывода в "
"стандартный поток ошибок."

#. type: Plain text
#: man-pages/man3/rpc.3:355 man-pages/man3/rpc.3:395
msgid "Bugs: returns pointer to static data that is overwritten on each call."
msgstr ""
"Дефекты: возвращается указатель на статические данные, которые "
"переписываются при каждом вызове."

#. type: Plain text
#: man-pages/man3/rpc.3:358
#, no-wrap
msgid "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"
msgstr "B<char *clnt_sperrno(enum clnt_stat >I<stat>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:365
msgid ""
"Take the same arguments as B<clnt_perrno>(), but instead of sending a "
"message to the standard error indicating why an RPC call failed, return a "
"pointer to a string which contains the message.  The string ends with a "
"NEWLINE."
msgstr ""
"Получает те же аргументы, что и B<clnt_perrno>(), но вместо отправки в "
"стандартный поток ошибок сообщения, которое показывает почему вызов RPC "
"завершился с ошибкой, возвращает указатель на строку с сообщением. Строка "
"заканчивается символом NEWLINE."

#. type: Plain text
#: man-pages/man3/rpc.3:383
msgid ""
"B<clnt_sperrno>()  is used instead of B<clnt_perrno>()  if the program does "
"not have a standard error (as a program running as a server quite likely "
"does not), or if the programmer does not want the message to be output with "
"B<printf>(3), or if a message format different than that supported by "
"B<clnt_perrno>()  is to be used.  Note: unlike B<clnt_sperror>()  and "
"B<clnt_spcreateerror>(), B<clnt_sperrno>()  returns pointer to static data, "
"but the result will not get overwritten on each call."
msgstr ""
"Функция B<clnt_sperrno>() используется вместо B<clnt_perrno>(), если "
"программа не имеет стандартного потока ошибок (для программ, запущенных как "
"сервер), или если программист не хочет выводить сообщения с помощью "
"B<printf>(3), или если формат сообщения отличается от формата, "
"поддерживаемого B<clnt_perrno>(). Замечание: в отличие от B<clnt_sperror>() "
"и B<clnt_spcreateerror>(), B<clnt_sperrno>() возвращает указатель на "
"статические данные, но результат не будет переписан при каждом вызове."

#. type: Plain text
#: man-pages/man3/rpc.3:386
#, no-wrap
msgid "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"
msgstr "B<char *clnt_sperror(CLIENT *>I<rpch>B<, char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:393
msgid ""
"Like B<clnt_perror>(), except that (like B<clnt_sperrno>())  it returns a "
"string instead of printing to standard error."
msgstr ""
"Похожа на B<clnt_perror>(), но (подобно B<clnt_sperrno>()) возвращает строку "
"вместо вывода сообщения в стандартный поток ошибок."

#. type: Plain text
#: man-pages/man3/rpc.3:399
#, no-wrap
msgid "B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"
msgstr "B<CLIENT *clntraw_create(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:412
msgid ""
"This routine creates a toy RPC client for the remote program I<prognum>, "
"version I<versnum>.  The transport used to pass messages to the service is "
"actually a buffer within the process's address space, so the corresponding "
"RPC server should live in the same address space; see B<svcraw_create>().  "
"This allows simulation of RPC and acquisition of RPC overheads, such as "
"round trip times, without any kernel interference.  This routine returns "
"NULL if it fails."
msgstr ""
"Эта функция создаёт игрушечного клиента RPC для удалённой программы "
"I<prognum> версии I<versnum>. Протокол, используемый для пересылки сообщения "
"службе, на самом деле является буфером внутри адресного пространства "
"процесса, поэтому соответствующий сервер RPC должен находиться в том же "
"адресном пространстве; смотрите B<svcraw_create>(). Он позволяет имитировать "
"RPC и временные задержки без какого-либо участия ядра. При ошибке эта "
"функция возвращает NULL.."

#. type: Plain text
#: man-pages/man3/rpc.3:418
#, no-wrap
msgid ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >I<recvsz>B<);>\n"
msgstr ""
"B<CLIENT *clnttcp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                int *>I<sockp>B<, unsigned int >I<sendsz>B<, unsigned int >I<recvsz>B<);>\n"

#. The following inline font conversion is necessary for the hyphen indicator
#. type: Plain text
#: man-pages/man3/rpc.3:448
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses TCP/IP as a transport.  The remote "
"program is located at Internet address I<*addr>.  If I<addr-E<gt>sin_port> "
"is zero, then it is set to the actual port that the remote program is "
"listening on (the remote B<portmap> service is consulted for this "
"information).  The parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, "
"then this routine opens a new one and sets I<sockp>.  Since TCP-based RPC "
"uses buffered I/O, the user may specify the size of the send and receive "
"buffers with the parameters I<sendsz> and I<recvsz>; values of zero choose "
"suitable defaults.  This routine returns NULL if it fails."
msgstr ""
"Эта функция создаёт клиента RPC для удалённой программы I<prognum>, версии "
"I<versnum>; для передачи клиент использует протокол TCP/IP. Удалённая "
"программа расположена по интернет-адресу I<*addr>. Если значение I<addr-"
"E<gt>sin_port> равно 0, тогда ему назначается реальный порт, который "
"прослушивается удалённой программой (эта информация запрашивается у "
"удалённой службы I<portmap>). Параметр I<sockp> — сокет; если его значение "
"равно B<RPC_ANYSOCK>, тогда эта функция открывает новый сокет и изменяет "
"I<sockp>. Так как в RPC на основе TCP используется буферизация ввода-вывода, "
"пользователь может задать размер посылаемых и получаемых буферов с помощью "
"параметров I<sendsz> и I<recvsz>; при значении 0 выбираются подходящие "
"величины по умолчанию. При ошибке эта функция возвращает NULL."

#. type: Plain text
#: man-pages/man3/rpc.3:453
#, no-wrap
msgid ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"
msgstr ""
"B<CLIENT *clntudp_create(struct sockaddr_in *>I<addr>B<,>\n"
"B<                unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                struct timeval >I<wait>B<, int *>I<sockp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:479
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, "
"version I<versnum>; the client uses use UDP/IP as a transport.  The remote "
"program is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is "
"zero, then it is set to actual port that the remote program is listening on "
"(the remote B<portmap> service is consulted for this information).  The "
"parameter I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine "
"opens a new one and sets I<sockp>.  The UDP transport resends the call "
"message in intervals of I<wait> time until a response is received or until "
"the call times out.  The total time for the call to time out is specified by "
"B<clnt_call>()."
msgstr ""
"Эта функция создаёт клиента RPC для удалённой программы I<prognum> версии "
"I<versnum>; для передачи клиент использует протокол UDP/IP. Удалённая "
"программа расположена по интернет-адресу I<*addr>. Если I<addr-"
"E<gt>sin_port> равно 0, тогда ему назначается реальный порт, который "
"прослушивается удалённой программой (эта информация запрашивается у "
"удалённой службы I<portmap>). Параметр I<sockp> — сокет; если его значение "
"равно B<RPC_ANYSOCK>, тогда эта функция открывает новый сокет и изменяет "
"I<sockp>. Протокол UDP повторяет отправку сообщения через интервал, "
"указанный в параметре I<wait>, пока не будет получен ответ или не истечёт "
"время ожидания. Полное время ожидания вызова определяется B<clnt_call>()."

#. type: Plain text
#: man-pages/man3/rpc.3:483
msgid ""
"Warning: since UDP-based RPC messages can hold only up to 8 Kbytes of "
"encoded data, this transport cannot be used for procedures that take large "
"arguments or return huge results."
msgstr ""
"Предупреждение: так как в сообщениях RPC на основе UDP может быть только 8 "
"КБ закодированных данных, этот протокол не может быть использован для "
"процедур с большим количеством параметров или которые возвращают результат "
"большого размера."

#. type: Plain text
#: man-pages/man3/rpc.3:489
#, no-wrap
msgid ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\n"
"B<            unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<            struct timeval >I<wait>B<, int *>I<sockp>B<,>\n"
"B<            unsigned int >I<sendsize>B<, unsigned int >I<recosize>B<);>\n"
msgstr ""
"B<CLIENT *clntudp_bufcreate(struct sockaddr_in *>I<addr>B<,>\n"
"B<            unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<            struct timeval >I<wait>B<, int *>I<sockp>B<,>\n"
"B<            unsigned int >I<sendsize>B<, unsigned int >I<recosize>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:515
msgid ""
"This routine creates an RPC client for the remote program I<prognum>, on "
"I<versnum>; the client uses use UDP/IP as a transport.  The remote program "
"is located at Internet address I<addr>.  If I<addr-E<gt>sin_port> is zero, "
"then it is set to actual port that the remote program is listening on (the "
"remote B<portmap> service is consulted for this information).  The parameter "
"I<sockp> is a socket; if it is B<RPC_ANYSOCK>, then this routine opens a new "
"one and sets I<sockp>.  The UDP transport resends the call message in "
"intervals of I<wait> time until a response is received or until the call "
"times out.  The total time for the call to time out is specified by "
"B<clnt_call>()."
msgstr ""
"Эта функция создаёт клиента RPC для удалённой программы I<prognum> версии "
"I<versnum>; для передачи клиент использует протокол UDP/IP. Удалённая "
"программа расположена по интернет-адресу  I<*addr>. Если I<addr-"
"E<gt>sin_port> равно 0, тогда ему назначается реальный порт, который "
"прослушивается удалённой программой (эта информация запрашивается у "
"удалённой службы I<portmap>). Параметр I<sockp> — сокет; если его значение "
"равно B<RPC_ANYSOCK>, тогда эта функция открывает новый сокет и изменяет "
"I<sockp>. Протокол UDP повторяет отправку через интервал, указанный в "
"параметре I<wait>, пока не будет получен ответ или не истечёт время "
"ожидания. Полное время ожидания вызова определяется B<clnt_call>()."

#. type: Plain text
#: man-pages/man3/rpc.3:518 man-pages/man3/rpc.3:995
msgid ""
"This allows the user to specify the maximum packet size for sending and "
"receiving UDP-based RPC messages."
msgstr ""
"Эта функция позволяет пользователям задать максимальный размер пакета для "
"отправки и принятия сообщений RPC через UDP."

#. type: Plain text
#: man-pages/man3/rpc.3:521
#, no-wrap
msgid "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<void get_myaddress(struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:529
msgid ""
"Stuff the machine's IP address into I<*addr>, without consulting the library "
"routines that deal with I</etc/hosts>.  The port number is always set to "
"B<htons(PMAPPORT)>."
msgstr ""
"Заполнить IP-адрес машины в I<*addr>, не используя библиотечные функции, "
"которые работают с I</etc/hosts>. Номер порта всегда устанавливается равным "
"B<htons(PMAPPORT)>."

#. type: Plain text
#: man-pages/man3/rpc.3:532
#, no-wrap
msgid "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"
msgstr "B<struct pmaplist *pmap_getmaps(struct sockaddr_in *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:543
msgid ""
"A user interface to the B<portmap> service, which returns a list of the "
"current RPC program-to-port mappings on the host located at IP address "
"I<*addr>.  This routine can return NULL.  The command I<rpcinfo\\ -p> uses "
"this routine."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который возвращает текущий "
"список соответствий RPC-программа — порт, находящихся на машине с "
"определённым IP-адресом I<*addr>. Эта функция может возвратить NULL. Эту "
"функцию использует команда I<rpcinfo\\ -p>."

#. type: Plain text
#: man-pages/man3/rpc.3:548
#, no-wrap
msgid ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned int >I<protocol>B<);>\n"
msgstr ""
"B<unsigned short pmap_getport(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned int >I<protocol>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:572
msgid ""
"A user interface to the B<portmap> service, which returns the port number on "
"which waits a service that supports program number I<prognum>, version "
"I<versnum>, and speaks the transport protocol associated with I<protocol>.  "
"The value of I<protocol> is most likely B<IPPROTO_UDP> or B<IPPROTO_TCP>.  A "
"return value of zero means that the mapping does not exist or that the RPC "
"system failed to contact the remote B<portmap> service.  In the latter case, "
"the global variable I<rpc_createerr> contains the RPC status."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который возвращает номер "
"порта, на котором ожидает подключения служба, поддерживающая программный "
"номер I<prognum> версии I<versnum>, и отвечает по протоколу передачи, "
"связанному с I<protocol>. Обычно, значение I<protocol> равно B<IPPROTO_UDP> "
"или B<IPPROTO_TCP>. Возвращаемое значение 0 означает, что соответствия не "
"существует или что RPC системы не может соединиться с удалённой службой "
"I<portmap>. В последнем случае глобальная переменная I<rpc_createerr> "
"содержит состояние RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:580
#, no-wrap
msgid ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<, unsigned long *>I<portp>B<);>\n"
msgstr ""
"B<enum clnt_stat pmap_rmtcall(struct sockaddr_in *>I<addr>B<,>\n"
"B<                    unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                    unsigned long >I<procnum>B<,>\n"
"B<                    xdrproc_t >I<inproc>B<, char *>I<in>B<,>\n"
"B<                    xdrproc_t >I<outproc>B<, char *>I<out>B<,>\n"
"B<                    struct timeval >I<tout>B<, unsigned long *>I<portp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:600
msgid ""
"A user interface to the B<portmap> service, which instructs B<portmap> on "
"the host at IP address I<*addr> to make an RPC call on your behalf to a "
"procedure on that host.  The parameter I<*portp> will be modified to the "
"program's port number if the procedure succeeds.  The definitions of other "
"parameters are discussed in B<callrpc>()  and B<clnt_call>().  This "
"procedure should be used for a \\(lqping\\(rq and nothing else.  See also "
"B<clnt_broadcast>()."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который указывает B<portmap> "
"на машине с IP-адресом I<*addr> выполнить вызов RPC от вашего имени к "
"процедуре на этой машине. При успешном выполнении процедуры параметр "
"I<*portp> заменяется на номер программного порта. Предназначение других "
"параметров описано в B<callrpc>() и B<clnt_call>(). Эта функция может быть "
"использована только для «ping». Смотрите также B<clnt_broadcast>()."

#. type: Plain text
#: man-pages/man3/rpc.3:604
#, no-wrap
msgid ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>\n"
msgstr ""
"B<bool_t pmap_set(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned int >I<protocol>B<, unsigned short >I<port>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:624
msgid ""
"A user interface to the B<portmap> service, which establishes a mapping "
"between the triple [I<prognum>,I<versnum>,I<protocol>] and I<port> on the "
"machine's B<portmap> service.  The value of I<protocol> is most likely "
"B<IPPROTO_UDP> or B<IPPROTO_TCP>.  This routine returns one if it succeeds, "
"zero otherwise.  Automatically done by B<svc_register>()."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который устанавливает "
"соответствие между [I<prognum>,I<versnum>,I<protocol>] и I<port> на машине с "
"службой B<portmap>. Обычно, значение I<protocol> равно B<IPPROTO_UDP> или "
"B<IPPROTO_TCP>. При успешном выполнении эта функция возвращает 1 и 0 в "
"противном случае. Автоматически выполняется из B<svc_register>()."

#. type: Plain text
#: man-pages/man3/rpc.3:627
#, no-wrap
msgid "B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"
msgstr "B<bool_t pmap_unset(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:639
msgid ""
"A user interface to the B<portmap> service, which destroys all mapping "
"between the triple [I<prognum>,I<versnum>,I<*>] and B<ports> on the "
"machine's B<portmap> service.  This routine returns one if it succeeds, zero "
"otherwise."
msgstr ""
"Пользовательский интерфейс службы B<portmap>, который уничтожает все "
"соответствия между [I<prognum>,I<versnum>,I<*>] и B<ports> на машине с "
"службой B<portmap>. При успешном выполнении эта функция возвращает 1 и 0 в "
"противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:644
#, no-wrap
msgid ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char *),>\n"
"B<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"
msgstr ""
"B<int registerrpc(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<,>\n"
"B<                unsigned long >I<procnum>B<, char *(*>I<procname>B<)(char *),>\n"
"B<                xdrproc_t >I<inproc>B<, xdrproc_t >I<outproc>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:664
msgid ""
"Register procedure I<procname> with the RPC service package.  If a request "
"arrives for program I<prognum>, version I<versnum>, and procedure "
"I<procnum>, I<procname> is called with a pointer to its parameter(s); "
"I<procname> should return a pointer to its static result(s); I<inproc> is "
"used to decode the parameters while I<outproc> is used to encode the "
"results.  This routine returns zero if the registration succeeded, -1 "
"otherwise."
msgstr ""
"Регистрирует процедуру I<procname> в пакете служб RPC. Если запрос приходит "
"программе I<prognum> версии I<versnum> и процедуре I<procnum>, то "
"I<procname> вызывается с указателем на эти параметры; I<procname> должна "
"возвращать указатель на эти статические результаты; I<inproc> используется "
"для декодирования параметров, а I<outproc> — для кодирования результатов. "
"При успешной регистрации эта функция возвращает 0 и -1 в противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:669
msgid ""
"Warning: remote procedures registered in this form are accessed using the "
"UDP/IP transport; see B<svcudp_create>()  for restrictions."
msgstr ""
"Предупреждение: удалённые процедуры, зарегистрированные таким способом, "
"доступны по протоколу UDP/IP; информацию об ограничениях смотрите в "
"B<svcudp_create>()."

#. type: Plain text
#: man-pages/man3/rpc.3:672
#, no-wrap
msgid "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"
msgstr "B<struct rpc_createerr >I<rpc_createerr>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:679
msgid ""
"A global variable whose value is set by any RPC client creation routine that "
"does not succeed.  Use the routine B<clnt_pcreateerror>()  to print the "
"reason why."
msgstr ""
"Глобальная переменная, значение которой устанавливается любой функцией "
"создания клиента RPC при ошибке. Используйте функцию B<clnt_pcreateerror>() "
"для вывода сообщения о причине ошибки."

#. type: Plain text
#: man-pages/man3/rpc.3:682
#, no-wrap
msgid "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svc_destroy(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:693
msgid ""
"A macro that destroys the RPC service transport handle, I<xprt>.  "
"Destruction usually involves deallocation of private data structures, "
"including I<xprt> itself.  Use of I<xprt> is undefined after calling this "
"routine."
msgstr ""
"Макрос, который уничтожает описатель протокола службы RPC I<xprt>. "
"Уничтожение, обычно, освобождает скрытые структуры данных, включая сам "
"I<xprt>. Работа с I<xprt> после вызова этой функции не описана."

#. type: Plain text
#: man-pages/man3/rpc.3:696
#, no-wrap
msgid "B<fd_set >I<svc_fdset>B<;>\n"
msgstr "B<fd_set >I<svc_fdset>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:710
msgid ""
"A global variable reflecting the RPC service side's read file descriptor bit "
"mask; it is suitable as a parameter to the B<select>(2)  system call.  This "
"is of interest only if a service implementor does their own asynchronous "
"event processing, instead of calling B<svc_run>().  This variable is read-"
"only (do not pass its address to B<select>(2)!), yet it may change after "
"calls to B<svc_getreqset>()  or any creation routines."
msgstr ""
"Глобальная переменная, отражающая битовую маску читаемого файлового "
"дескриптора службы RPC; она подходит в качестве параметра для системного "
"вызова B<select>(2). Полезна только, если реализация службы использует "
"собственный обработчик асинхронных событий, а не вызова B<svc_run>(). Эта "
"переменная доступна только для чтения (не передавайте её адрес в "
"B<select>(2)!), также она может измениться после вызова B<svc_getreqset>() "
"или функций создания."

#. type: Plain text
#: man-pages/man3/rpc.3:713
#, no-wrap
msgid "B<int >I<svc_fds>B<;>\n"
msgstr "B<int >I<svc_fds>B<;>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:720
msgid ""
"Similar to B<svc_fdset>, but limited to 32 file descriptors.  This interface "
"is obsoleted by B<svc_fdset>."
msgstr ""
"Подобна B<svc_fdset>, но ограничена 32 файловыми дескрипторами. Устарела, "
"используйте B<svc_fdset>."

#. type: Plain text
#: man-pages/man3/rpc.3:723
#, no-wrap
msgid "B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"
msgstr "B<svc_freeargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:730
msgid ""
"A macro that frees any data allocated by the RPC/XDR system when it decoded "
"the arguments to a service procedure using B<svc_getargs>().  This routine "
"returns 1 if the results were successfully freed, and zero otherwise."
msgstr ""
"Макрос, который освобождает любые данные, выделенные системой RPC/XDR при "
"декодировании аргументов процедуры службы с помощью B<svc_getargs>(). Эта "
"функция возвращает 1, если результаты были успешно освобождены, и 0 в "
"противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:733
#, no-wrap
msgid "B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"
msgstr "B<svc_getargs(SVCXPRT *>I<xprt>B<, xdrproc_t >I<inproc>B<, char *>I<in>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:744
msgid ""
"A macro that decodes the arguments of an RPC request associated with the RPC "
"service transport handle, I<xprt>.  The parameter I<in> is the address where "
"the arguments will be placed; I<inproc> is the XDR routine used to decode "
"the arguments.  This routine returns one if decoding succeeds, and zero "
"otherwise."
msgstr ""
"Макрос, декодирующий параметры запроса RPC, связанного с описателем "
"протокола службы RPC I<xprt>. Параметр I<in> — адрес, по которому будут "
"размещены аргументы; I<inproc> — функция XDR, использующаяся для "
"декодирования аргументов. При успешном декодировании функция возвращает 1 и "
"0 в противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:747
#, no-wrap
msgid "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<struct sockaddr_in *svc_getcaller(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:752
msgid ""
"The approved way of getting the network address of the caller of a procedure "
"associated with the RPC service transport handle, I<xprt>."
msgstr ""
"Правильный способ получения сетевого адреса вызвавшего процедуру, связанную "
"с описателем протокола службы RPC I<xprt>."

#. type: Plain text
#: man-pages/man3/rpc.3:755
#, no-wrap
msgid "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"
msgstr "B<void svc_getreqset(fd_set *>I<rdfds>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:769
msgid ""
"This routine is of interest only if a service implementor does not call "
"B<svc_run>(), but instead implements custom asynchronous event processing.  "
"It is called when the B<select>(2)  system call has determined that an RPC "
"request has arrived on some RPC socket(s); I<rdfds> is the resultant read "
"file descriptor bit mask.  The routine returns when all sockets associated "
"with the value of I<rdfds> have been serviced."
msgstr ""
"Функция представляет интерес, только если реализация службы не вызывает "
"функцию B<svc_run>(), а реализует собственную асинхронную обработку событий. "
"Вызывается, когда системный вызов B<select>(2) определил, что поступил "
"запрос RPC в какой-либо сокет RPC; I<rdfds> — битовая маска читаемого "
"файлового дескриптора. Функция завершается после обработки всех сокетов, "
"связанных со значением I<rdfds>."

#. type: Plain text
#: man-pages/man3/rpc.3:772
#, no-wrap
msgid "B<void svc_getreq(int >I<rdfds>B<);>\n"
msgstr "B<void svc_getreq(int >I<rdfds>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:779
msgid ""
"Similar to B<svc_getreqset>(), but limited to 32 file descriptors.  This "
"interface is obsoleted by B<svc_getreqset>()."
msgstr ""
"Подобна B<svc_getreqset>(), но ограничена 32 файловыми дескрипторами. "
"Устарела, используйте B<svc_getreqset>()."

#. type: Plain text
#: man-pages/man3/rpc.3:785
#, no-wrap
msgid ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\n"
"B<                    unsigned long >I<versnum>B<,>\n"
"B<                    void (*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\n"
"B<                    unsigned long >I<protocol>B<);>\n"
msgstr ""
"B<bool_t svc_register(SVCXPRT *>I<xprt>B<, unsigned long >I<prognum>B<,>\n"
"B<                    unsigned long >I<versnum>B<,>\n"
"B<                    void (*>I<dispatch>B<)(svc_req *, SVCXPRT *),>\n"
"B<                    unsigned long >I<protocol>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:815
msgid ""
"Associates I<prognum> and I<versnum> with the service dispatch procedure, "
"I<dispatch>.  If I<protocol> is zero, the service is not registered with the "
"B<portmap> service.  If I<protocol> is nonzero, then a mapping of the triple "
"[I<prognum>,I<versnum>,I<protocol>] to I<xprt-E<gt>xp_port> is established "
"with the local B<portmap> service (generally I<protocol> is zero, "
"B<IPPROTO_UDP> or B<IPPROTO_TCP>).  The procedure I<dispatch> has the "
"following form:"
msgstr ""
"Связывает I<prognum> и I<versnum> с функцией распределения служб "
"I<dispatch>. Если значение I<protocol> равно 0, то служба не регистрируется "
"службой I<portmap>. Если значение I<protocol> не равно 0, тогда соответствие "
"[I<prognum>,I<versnum>,I<protocol>] и I<xprt-E<gt>xp_port> устанавливается "
"локальной службой I<portmap> (обычно, значение I<protocol> равно 0, "
"B<IPPROTO_UDP> или B<IPPROTO_TCP>). Функция I<dispatch> имеет следующий вид:"

#. type: Plain text
#: man-pages/man3/rpc.3:819
#, no-wrap
msgid "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"
msgstr "dispatch(struct svc_req *request, SVCXPRT *xprt);\n"

#. type: Plain text
#: man-pages/man3/rpc.3:825
msgid ""
"The B<svc_register>()  routine returns one if it succeeds, and zero "
"otherwise."
msgstr ""
"При успешном выполнении функция B<svc_register>() возвращает 1 и 0 в "
"противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:828
#, no-wrap
msgid "B<void svc_run(void);>\n"
msgstr "B<void svc_run(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:838
msgid ""
"This routine never returns.  It waits for RPC requests to arrive, and calls "
"the appropriate service procedure using B<svc_getreq>()  when one arrives.  "
"This procedure is usually waiting for a B<select>(2)  system call to return."
msgstr ""
"Эта функция не возвращает управление. Она ждёт поступления запросов RPC и "
"при их появлении вызывает соответствующую процедуру службы с помощью "
"B<svc_getreq>(). Обычно, эта функция ждёт возврата из системного вызова  "
"B<select>(2)."

#. type: Plain text
#: man-pages/man3/rpc.3:842
#, no-wrap
msgid "B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"
msgstr "B<bool_t svc_sendreply(SVCXPRT *>I<xprt>B<, xdrproc_t >I<outproc>B<, char *>I<out>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:854
msgid ""
"Called by an RPC service's dispatch routine to send the results of a remote "
"procedure call.  The parameter I<xprt> is the request's associated transport "
"handle; I<outproc> is the XDR routine which is used to encode the results; "
"and I<out> is the address of the results.  This routine returns one if it "
"succeeds, zero otherwise."
msgstr ""
"Вызывается функцией распределения служб RPC для отправки результатов вызову "
"удалённой процедуры. Параметр I<xprt> — описатель протокола связанного "
"запроса; I<outproc> — функция XDR, которая используется для кодирования "
"результатов; I<out> — адрес, по которому находятся результаты. При успешном "
"выполнении эта функция возвращает 1 и 0 в противном случае."

#. type: Plain text
#: man-pages/man3/rpc.3:857
#, no-wrap
msgid "B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"
msgstr "B<void svc_unregister(unsigned long >I<prognum>B<, unsigned long >I<versnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:864
msgid ""
"Remove all mapping of the double [I<prognum>,I<versnum>] to dispatch "
"routines, and of the triple [I<prognum>,I<versnum>,I<*>] to port number."
msgstr ""
"Удаляет все сопоставления [I<prognum>,I<versnum>] функциям распределения и "
"[I<prognum>,I<versnum>,I<*>] номеру порта."

#. type: Plain text
#: man-pages/man3/rpc.3:867
#, no-wrap
msgid "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"
msgstr "B<void svcerr_auth(SVCXPRT *>I<xprt>B<, enum auth_stat >I<why>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:871
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to an authentication error."
msgstr ""
"Вызывается функцией распределения служб, которая отклоняет выполнение вызова "
"удалённой процедуры из ошибки аутентификации."

#. type: Plain text
#: man-pages/man3/rpc.3:874
#, no-wrap
msgid "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_decode(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:880
msgid ""
"Called by a service dispatch routine that cannot successfully decode its "
"parameters.  See also B<svc_getargs>()."
msgstr ""
"Вызывается функцией распределения служб, если невозможно декодировать её "
"параметры. Смотрите также B<svc_getargs>()."

#. type: Plain text
#: man-pages/man3/rpc.3:883
#, no-wrap
msgid "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_noproc(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:887
msgid ""
"Called by a service dispatch routine that does not implement the procedure "
"number that the caller requests."
msgstr ""
"Вызывается функцией распределения служб, если не реализован номер процедуры, "
"указанный в полученном запросе."

#. type: Plain text
#: man-pages/man3/rpc.3:890
#, no-wrap
msgid "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_noprog(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:894
msgid ""
"Called when the desired program is not registered with the RPC package.  "
"Service implementors usually do not need this routine."
msgstr ""
"Вызывается, когда желаемая программа не зарегистрирована в пакете RPC. "
"Обычно, для реализации службы эта функция не требуется."

#. type: Plain text
#: man-pages/man3/rpc.3:897
#, no-wrap
msgid "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_progvers(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:902
msgid ""
"Called when the desired version of a program is not registered with the RPC "
"package.  Service implementors usually do not need this routine."
msgstr ""
"Вызывается, когда желаемая версия программы не зарегистрирована в пакете "
"RPC. Обычно, для реализации службы эта функция не требуется."

#. type: Plain text
#: man-pages/man3/rpc.3:905
#, no-wrap
msgid "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_systemerr(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:911
msgid ""
"Called by a service dispatch routine when it detects a system error not "
"covered by any particular protocol.  For example, if a service can no longer "
"allocate storage, it may call this routine."
msgstr ""
"Вызывается функцией распределения служб при обнаружении системной ошибки, не "
"относящейся к какому-то конкретному протоколу. Например, служба может "
"вызвать эту функцию, если не удалось выделить память."

#. type: Plain text
#: man-pages/man3/rpc.3:914
#, no-wrap
msgid "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void svcerr_weakauth(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:920
msgid ""
"Called by a service dispatch routine that refuses to perform a remote "
"procedure call due to insufficient authentication parameters.  The routine "
"calls B<svcerr_auth(xprt, AUTH_TOOWEAK)>."
msgstr ""
"Вызывается функцией распределения служб для отклонения вызова удалённой "
"процедуры из недостатка параметров аутентификации. Функция вызывает "
"B<svcerr_auth(xprt, AUTH_TOOWEAK)>."

#. type: Plain text
#: man-pages/man3/rpc.3:924
#, no-wrap
msgid ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\n"
"B<                      unsigned int >I<recvsize>B<);>\n"
msgstr ""
"B<SVCXPRT *svcfd_create(int >I<fd>B<, unsigned int >I<sendsize>B<,>\n"
"B<                      unsigned int >I<recvsize>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:934
msgid ""
"Create a service on top of any open file descriptor.  Typically, this file "
"descriptor is a connected socket for a stream protocol such as TCP.  "
"I<sendsize> and I<recvsize> indicate sizes for the send and receive "
"buffers.  If they are zero, a reasonable default is chosen."
msgstr ""
"Создаёт службу поверх любого открытого файлового дескриптора. Обычно, этот "
"файловый дескриптор является подключённым сокетом для поточного протокола, "
"например TCP. В I<sendsize> и I<recvsize> указываются размеры буферов "
"отправки и приёма. Если эти значения равны нулю, то выбирается приемлемое "
"значение по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:937
#, no-wrap
msgid "B<SVCXPRT *svcraw_create(void);>\n"
msgstr "B<SVCXPRT *svcraw_create(void);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:947
msgid ""
"This routine creates a toy RPC service transport, to which it returns a "
"pointer.  The transport is really a buffer within the process's address "
"space, so the corresponding RPC client should live in the same address "
"space; see B<clntraw_create>().  This routine allows simulation of RPC and "
"acquisition of RPC overheads (such as round trip times), without any kernel "
"interference.  This routine returns NULL if it fails."
msgstr ""
"Эта функция создаёт игрушечный протокол службы RPC и возвращает указатель на "
"него. В действительности протокол представляет собой буфер внутри адресного "
"пространства процесса, поэтому соответствующие клиенты RPC должны находиться "
"в том же адресном пространстве; смотрите B<clntraw_create>(). Эта функция "
"позволяет имитировать RPC и создавать дополнительные нагрузки на RPC (как, "
"например, время пересылки туда и обратно) без какого-либо вмешательства "
"ядра. При ошибке функция возвращает NULL."

#. type: Plain text
#: man-pages/man3/rpc.3:951
#, no-wrap
msgid ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>\n"
"B<                       unsigned int >I<recv_buf_size>B<);>\n"
msgstr ""
"B<SVCXPRT *svctcp_create(int >I<sock>B<, unsigned int >I<send_buf_size>B<,>\n"
"B<                       unsigned int >I<recv_buf_size>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:971
msgid ""
"This routine creates a TCP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local TCP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number.  "
"This routine returns NULL if it fails.  Since TCP-based RPC uses buffered I/"
"O, users may specify the size of buffers; values of zero choose suitable "
"defaults."
msgstr ""
"Эта функция создаёт протокол службы RPC на основе TCP/IP и возвращает "
"указатель на него. Протокол связывается с сокетом I<sock>, значение которого "
"может быть равно B<RPC_ANYSOCK>; в этом случае создаётся новый сокет. Если "
"сокет не привязан к локальному порту TCP, то эта функция привязывает его к "
"произвольному порту. При завершении I<xprt-E<gt>xp_sock> содержит дескриптор "
"сокета протокола, а I<xprt-E<gt>xp_port> — номер порта протокола. При ошибке "
"эта функция возвращает NULL. Так как в RPC на основе TCP используется "
"буферизация ввода-вывода, пользователи могут задавать размер буферов; при "
"нулевом значении выбирается подходящий размер по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:975
#, no-wrap
msgid ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\n"
"B<                          unsigned int >I<recosize>B<);>\n"
msgstr ""
"B<SVCXPRT *svcudp_bufcreate(int >I<sock>B<, unsigned int >I<sendsize>B<,>\n"
"B<                          unsigned int >I<recosize>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:992
msgid ""
"This routine creates a UDP/IP-based RPC service transport, to which it "
"returns a pointer.  The transport is associated with the socket I<sock>, "
"which may be B<RPC_ANYSOCK>, in which case a new socket is created.  If the "
"socket is not bound to a local UDP port, then this routine binds it to an "
"arbitrary port.  Upon completion, I<xprt-E<gt>xp_sock> is the transport's "
"socket descriptor, and I<xprt-E<gt>xp_port> is the transport's port number.  "
"This routine returns NULL if it fails."
msgstr ""
"Эта функция создаёт протокол службы RPC на основе UDP/IP и возвращает "
"указатель на него. Протокол связывается с сокетом I<sock>, значение которого "
"может быть равно B<RPC_ANYSOCK>; в этом случае создаётся новый сокет. Если "
"сокет не привязан к локальному порту UDP, то эта функция привязывает его к "
"произвольному порту. При завершении I<xprt-E<gt>xp_sock> содержит дескриптор "
"сокета протокола, а I<xprt-E<gt>xp_port> — номер порта протокола. При ошибке "
"эта функция возвращает NULL."

#. type: Plain text
#: man-pages/man3/rpc.3:998
#, no-wrap
msgid "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"
msgstr "B<SVCXPRT *svcudp_create(int >I<sock>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1004
msgid ""
"This call is equivalent to I<svcudp_bufcreate(sock,SZ,SZ)> for some default "
"size I<SZ>."
msgstr ""
"Этот вызов аналогичен I<svcudp_bufcreate(sock,SZ,SZ)> для некоторого размера "
"B<SZ> по умолчанию."

#. type: Plain text
#: man-pages/man3/rpc.3:1007
#, no-wrap
msgid "B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply *>I<ar>B<);>\n"
msgstr "B<bool_t xdr_accepted_reply(XDR *>I<xdrs>B<, struct accepted_reply *>I<ar>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1012
msgid ""
"Used for encoding RPC reply messages.  This routine is useful for users who "
"wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для кодирования ответных сообщений RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1015
#, no-wrap
msgid "B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms *>I<aupp>B<);>\n"
msgstr "B<bool_t xdr_authunix_parms(XDR *>I<xdrs>B<, struct authunix_parms *>I<aupp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1021
msgid ""
"Used for describing UNIX credentials.  This routine is useful for users who "
"wish to generate these credentials without using the RPC authentication "
"package."
msgstr ""
"Используется для описания информации (credentials) UNIX. Эта функция полезна "
"для пользователей, которые хотят генерировать такую информацию без "
"использования пакета аутентификации RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1024
#, no-wrap
msgid "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"
msgstr "B<void xdr_callhdr(XDR *>I<xdrs>B<, struct rpc_msg *>I<chdr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1029
msgid ""
"Used for describing RPC call header messages.  This routine is useful for "
"users who wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для описания заголовка сообщений вызовов RPC. Эта функция "
"полезна для пользователей, которые хотят генерировать RPC-подобные сообщения "
"без использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1032
#, no-wrap
msgid "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"
msgstr "B<bool_t xdr_callmsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<cmsg>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1037
msgid ""
"Used for describing RPC call messages.  This routine is useful for users who "
"wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для описания сообщений вызовов RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1040
#, no-wrap
msgid "B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"
msgstr "B<bool_t xdr_opaque_auth(XDR *>I<xdrs>B<, struct opaque_auth *>I<ap>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1045
msgid ""
"Used for describing RPC authentication information messages.  This routine "
"is useful for users who wish to generate RPC-style messages without using "
"the RPC package."
msgstr ""
"Используется для описания информационных сообщений аутентификации RPC. Эта "
"функция полезна для пользователей, которые хотят генерировать RPC-подобные "
"сообщения без использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1048
#, no-wrap
msgid "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"
msgstr "B<bool_t xdr_pmap(XDR *>I<xdrs>B<, struct pmap *>I<regs>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1057
msgid ""
"Used for describing parameters to various B<portmap> procedures, "
"externally.  This routine is useful for users who wish to generate these "
"parameters without using the B<pmap> interface."
msgstr ""
"Используется для описания параметров различных функций B<portmap> извне. Эта "
"функция полезна для пользователей, которые хотят генерировать такие "
"параметры без использования интерфейса B<pmap>."

#. type: Plain text
#: man-pages/man3/rpc.3:1060
#, no-wrap
msgid "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"
msgstr "B<bool_t xdr_pmaplist(XDR *>I<xdrs>B<, struct pmaplist **>I<rp>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1067
msgid ""
"Used for describing a list of port mappings, externally.  This routine is "
"useful for users who wish to generate these parameters without using the "
"B<pmap> interface."
msgstr ""
"Используется для описания списка соответствия портов извне. Эта функция "
"полезна для пользователей, которые хотят генерировать такие параметры без "
"использования интерфейса B<pmap>."

#. type: Plain text
#: man-pages/man3/rpc.3:1070
#, no-wrap
msgid "B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply *>I<rr>B<);>\n"
msgstr "B<bool_t xdr_rejected_reply(XDR *>I<xdrs>B<, struct rejected_reply *>I<rr>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1075
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC-style messages without using the RPC package."
msgstr ""
"Используется для описания ответных сообщений RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1078
#, no-wrap
msgid "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"
msgstr "B<bool_t xdr_replymsg(XDR *>I<xdrs>B<, struct rpc_msg *>I<rmsg>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1083
msgid ""
"Used for describing RPC reply messages.  This routine is useful for users "
"who wish to generate RPC style messages without using the RPC package."
msgstr ""
"Используется для описания ответных сообщений RPC. Эта функция полезна для "
"пользователей, которые хотят генерировать RPC-подобные сообщения без "
"использования пакета RPC."

#. type: Plain text
#: man-pages/man3/rpc.3:1086
#, no-wrap
msgid "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void xprt_register(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1093
msgid ""
"After RPC service transport handles are created, they should register "
"themselves with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""
"После создания описателей протокола службы RPC они должны самостоятельно "
"зарегистрироваться в пакетом служб RPC. Эта функция изменяет глобальную "
"переменную I<svc_fds>. Обычно, для реализации служб эта функция не требуется."

#. type: Plain text
#: man-pages/man3/rpc.3:1096
#, no-wrap
msgid "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"
msgstr "B<void xprt_unregister(SVCXPRT *>I<xprt>B<);>\n"

#. type: Plain text
#: man-pages/man3/rpc.3:1103
msgid ""
"Before an RPC service transport handle is destroyed, it should unregister "
"itself with the RPC service package.  This routine modifies the global "
"variable I<svc_fds>.  Service implementors usually do not need this routine."
msgstr ""
"Перед уничтожением описателя протокола службы RPC он должен самостоятельно "
"отменить регистрацию в пакете службы RPC. Эта функция изменяет глобальную "
"переменную I<svc_fds>. Обычно, для реализации служб эта функция не требуется."

#. type: tbl table
#: man-pages/man3/rpc.3:1115
#, no-wrap
msgid ""
"B<auth_destroy>(),\n"
"B<authnone_create>(),\n"
msgstr ""
"B<auth_destroy>(),\n"
"B<authnone_create>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1117
#, no-wrap
msgid "B<authunix_create>(),\n"
msgstr "B<authunix_create>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1119
#, no-wrap
msgid "B<authunix_create_default>(),\n"
msgstr "B<authunix_create_default>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1122
#, no-wrap
msgid ""
"B<callrpc>(),\n"
"B<clnt_broadcast>(),\n"
msgstr ""
"B<callrpc>(),\n"
"B<clnt_broadcast>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1125
#, no-wrap
msgid ""
"B<clnt_call>(),\n"
"B<clnt_destroy>(),\n"
msgstr ""
"B<clnt_call>(),\n"
"B<clnt_destroy>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1128
#, no-wrap
msgid ""
"B<clnt_create>(),\n"
"B<clnt_control>(),\n"
msgstr ""
"B<clnt_create>(),\n"
"B<clnt_control>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1131
#, no-wrap
msgid ""
"B<clnt_freeres>(),\n"
"B<clnt_geterr>(),\n"
msgstr ""
"B<clnt_freeres>(),\n"
"B<clnt_geterr>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1134
#, no-wrap
msgid ""
"B<clnt_pcreateerror>(),\n"
"B<clnt_perrno>(),\n"
msgstr ""
"B<clnt_pcreateerror>(),\n"
"B<clnt_perrno>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1136
#, no-wrap
msgid "B<clnt_perror>(),\n"
msgstr "B<clnt_perror>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1138
#, no-wrap
msgid "B<clnt_spcreateerror>(),\n"
msgstr "B<clnt_spcreateerror>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1141
#, no-wrap
msgid ""
"B<clnt_sperrno>(),\n"
"B<clnt_sperror>(),\n"
msgstr ""
"B<clnt_sperrno>(),\n"
"B<clnt_sperror>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1144
#, no-wrap
msgid ""
"B<clntraw_create>(),\n"
"B<clnttcp_create>(),\n"
msgstr ""
"B<clntraw_create>(),\n"
"B<clnttcp_create>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1146
#, no-wrap
msgid "B<clntudp_create>(),\n"
msgstr "B<clntudp_create>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1148
#, no-wrap
msgid "B<clntudp_bufcreate>(),\n"
msgstr "B<clntudp_bufcreate>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1151
#, no-wrap
msgid ""
"B<get_myaddress>(),\n"
"B<pmap_getmaps>(),\n"
msgstr ""
"B<get_myaddress>(),\n"
"B<pmap_getmaps>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1154
#, no-wrap
msgid ""
"B<pmap_getport>(),\n"
"B<pmap_rmtcall>(),\n"
msgstr ""
"B<pmap_getport>(),\n"
"B<pmap_rmtcall>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1157
#, no-wrap
msgid ""
"B<pmap_set>(),\n"
"B<pmap_unset>(),\n"
msgstr ""
"B<pmap_set>(),\n"
"B<pmap_unset>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1160
#, no-wrap
msgid ""
"B<registerrpc>(),\n"
"B<svc_destroy>(),\n"
msgstr ""
"B<registerrpc>(),\n"
"B<svc_destroy>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1163
#, no-wrap
msgid ""
"B<svc_freeargs>(),\n"
"B<svc_getargs>(),\n"
msgstr ""
"B<svc_freeargs>(),\n"
"B<svc_getargs>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1166
#, no-wrap
msgid ""
"B<svc_getcaller>(),\n"
"B<svc_getreqset>(),\n"
msgstr ""
"B<svc_getcaller>(),\n"
"B<svc_getreqset>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1169
#, no-wrap
msgid ""
"B<svc_getreq>(),\n"
"B<svc_register>(),\n"
msgstr ""
"B<svc_getreq>(),\n"
"B<svc_register>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1172
#, no-wrap
msgid ""
"B<svc_run>(),\n"
"B<svc_sendreply>(),\n"
msgstr ""
"B<svc_run>(),\n"
"B<svc_sendreply>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1175
#, no-wrap
msgid ""
"B<svc_unregister>(),\n"
"B<svcerr_auth>(),\n"
msgstr ""
"B<svc_unregister>(),\n"
"B<svcerr_auth>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1178
#, no-wrap
msgid ""
"B<svcerr_decode>(),\n"
"B<svcerr_noproc>(),\n"
msgstr ""
"B<svcerr_decode>(),\n"
"B<svcerr_noproc>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1181
#, no-wrap
msgid ""
"B<svcerr_noprog>(),\n"
"B<svcerr_progvers>(),\n"
msgstr ""
"B<svcerr_noprog>(),\n"
"B<svcerr_progvers>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1184
#, no-wrap
msgid ""
"B<svcerr_systemerr>(),\n"
"B<svcerr_weakauth>(),\n"
msgstr ""
"B<svcerr_systemerr>(),\n"
"B<svcerr_weakauth>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1187
#, no-wrap
msgid ""
"B<svcfd_create>(),\n"
"B<svcraw_create>(),\n"
msgstr ""
"B<svcfd_create>(),\n"
"B<svcraw_create>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1189
#, no-wrap
msgid "B<svctcp_create>(),\n"
msgstr "B<svctcp_create>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1191
#, no-wrap
msgid "B<svcudp_bufcreate>(),\n"
msgstr "B<svcudp_bufcreate>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1194
#, no-wrap
msgid ""
"B<svcudp_create>(),\n"
"B<xdr_accepted_reply>(),\n"
msgstr ""
"B<svcudp_create>(),\n"
"B<xdr_accepted_reply>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1196
#, no-wrap
msgid "B<xdr_authunix_parms>(),\n"
msgstr "B<xdr_authunix_parms>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1198
#, no-wrap
msgid "B<xdr_callhdr>(),\n"
msgstr "B<xdr_callhdr>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1201
#, no-wrap
msgid ""
"B<xdr_callmsg>(),\n"
"B<xdr_opaque_auth>(),\n"
msgstr ""
"B<xdr_callmsg>(),\n"
"B<xdr_opaque_auth>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1204
#, no-wrap
msgid ""
"B<xdr_pmap>(),\n"
"B<xdr_pmaplist>(),\n"
msgstr ""
"B<xdr_pmap>(),\n"
"B<xdr_pmaplist>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1206
#, no-wrap
msgid "B<xdr_rejected_reply>(),\n"
msgstr "B<xdr_rejected_reply>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1208
#, no-wrap
msgid "B<xdr_replymsg>(),\n"
msgstr "B<xdr_replymsg>(),\n"

#. type: tbl table
#: man-pages/man3/rpc.3:1211
#, no-wrap
msgid ""
"B<xprt_register>(),\n"
"B<xprt_unregister>()"
msgstr ""
"B<xprt_register>(),\n"
"B<xprt_unregister>()"

#.  We don't have an rpc_secure.3 page in the set at the moment -- MTK, 19 Sep 05
#.  .BR rpc_secure (3),
#. type: Plain text
#: man-pages/man3/rpc.3:1218
msgid "B<xdr>(3)"
msgstr "B<xdr>(3)"

#. type: Plain text
#: man-pages/man3/rpc.3:1220
msgid "The following manuals:"
msgstr "Руководства:"

#. type: Plain text
#: man-pages/man3/rpc.3:1222
msgid "Remote Procedure Calls: Protocol Specification"
msgstr "Remote Procedure Calls: Protocol Specification"

#. type: Plain text
#: man-pages/man3/rpc.3:1224
msgid "Remote Procedure Call Programming Guide"
msgstr "Remote Procedure Call Programming Guide"

#. type: Plain text
#: man-pages/man3/rpc.3:1226
msgid "rpcgen Programming Guide"
msgstr "rpcgen Programming Guide"

#. type: Plain text
#: man-pages/man3/rpc.3:1231
msgid ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."
msgstr ""
"I<RPC: Remote Procedure Call Protocol Specification>, RFC\\ 1050, Sun "
"Microsystems, Inc., USC-ISI."

#. type: TH
#: man-pages/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr "REMOVE"

#. type: Plain text
#: man-pages/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr "remove - удаляет файл или каталог"

#. type: Plain text
#: man-pages/man3/remove.3:36
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr "B<int remove(const char *>I<pathname>B<);>"

#. type: Plain text
#: man-pages/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the filesystem.  It calls B<unlink>(2)  for "
"files, and B<rmdir>(2)  for directories."
msgstr ""
"Функция B<remove>() удаляет имя из файловой системы. Она вызывает "
"B<unlink>(2) для файлов и B<rmdir>(2) для каталогов."

#. type: Plain text
#: man-pages/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""
"Если удалённое имя было последней ссылкой на файл и больше нет процессов, "
"которые держат этот файл открытым, то данный файл удаляется и место, которое "
"он занимает, освобождается для дальнейшего использования."

#. type: Plain text
#: man-pages/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"Если имя было последней ссылкой на файл, но какие-либо процессы всё ещё "
"держат этот файл открытым, файл будет существовать, пока последний файловый "
"дескриптор, указывающий на него, не будет закрыт."

#. type: Plain text
#: man-pages/man3/remove.3:57
msgid "If the name referred to a symbolic link, the link is removed."
msgstr "Если имя указывает на символьную ссылку, то будет удалена ссылка."

#. type: Plain text
#: man-pages/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""
"Если имя указывает на сокет, FIFO или устройство, то имя будет удалено, но "
"процессы, которые открыли объект, могут продолжать его использовать."

#. type: Plain text
#: man-pages/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr "Ошибки, которые возникают у B<unlink>(2) и B<rmdir>(2)."

#. type: tbl table
#: man-pages/man3/remove.3:80
#, no-wrap
msgid "B<remove>()"
msgstr "B<remove>()"

#.  .SH NOTES
#.  Under libc4 and libc5,
#.  .BR remove ()
#.  was an alias for
#.  .BR unlink (2)
#.  (and hence would not remove directories).
#. type: Plain text
#: man-pages/man3/remove.3:90
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, 4.3BSD."

#. type: Plain text
#: man-pages/man3/remove.3:93
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""
"Неточности в протоколе NFS могут приводить к неожиданному исчезновению "
"файлов, которые всё ещё используются."

#. type: Plain text
#: man-pages/man3/remove.3:103
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"

#. type: Plain text
#: man-pages/man3/readdir.3:39
msgid "readdir - read a directory"
msgstr "readdir - чтение содержимого каталога"

#. type: Plain text
#: man-pages/man3/readdir.3:44
#, no-wrap
msgid "B<struct dirent *readdir(DIR *>I<dirp>B<);>\n"
msgstr "B<struct dirent *readdir(DIR *>I<dirp>B<);>\n"

#. type: Plain text
#: man-pages/man3/readdir.3:53
msgid ""
"The B<readdir>()  function returns a pointer to a I<dirent> structure "
"representing the next directory entry in the directory stream pointed to by "
"I<dirp>.  It returns NULL on reaching the end of the directory stream or if "
"an error occurred."
msgstr ""
"Функция B<readdir>() возвращает указатель на структуру I<dirent>, "
"представляющую следующую запись каталога в потоке каталога, указанного в "
"I<dirp>. Функция возвращает NULL по достижении последней записи в потоке "
"каталога или если произошла ошибка."

#. type: Plain text
#: man-pages/man3/readdir.3:57
msgid ""
"In the glibc implementation, the I<dirent> structure is defined as follows:"
msgstr "В реализации glibc структура I<dirent> определена следующим образом:"

#. type: Plain text
#: man-pages/man3/readdir.3:68
#, no-wrap
msgid ""
"struct dirent {\n"
"    ino_t          d_ino;       /* Inode number */\n"
"    off_t          d_off;       /* Not an offset; see below */\n"
"    unsigned short d_reclen;    /* Length of this record */\n"
"    unsigned char  d_type;      /* Type of file; not supported\n"
"                                   by all filesystem types */\n"
"    char           d_name[256]; /* Null-terminated filename */\n"
"};\n"
msgstr ""
"struct dirent {\n"
"    ino_t          d_ino;       /* номер иноды */\n"
"    off_t          d_off;       /* не смещение, смотрите ниже */\n"
"    unsigned short d_reclen;    /* длина этой записи */\n"
"    unsigned char  d_type;      /* тип файла; поддерживается\n"
"                                   не во всех файловых системах */\n"
"    char           d_name[256]; /* имя файла с null в конце */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/readdir.3:79
msgid ""
"The only fields in the I<dirent> structure that are mandated by POSIX.1 are "
"I<d_name> and I<d_ino>.  The other fields are unstandardized, and not "
"present on all systems; see NOTES below for some further details."
msgstr ""
"В соответствие с POSIX.1, структура I<dirent> обязательно должна содержать "
"поле I<d_name>[] и I<d_ino>. Другие поля не стандартизованы и имеются не во "
"всех системах; подробней смотрите ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man3/readdir.3:83
msgid "The fields of the I<dirent> structure are as follows:"
msgstr "Поля структуры I<dirent>:"

#. type: TP
#: man-pages/man3/readdir.3:83
#, no-wrap
msgid "I<d_ino>"
msgstr "I<d_ino>"

#. type: Plain text
#: man-pages/man3/readdir.3:86
msgid "This is the inode number of the file."
msgstr "Номер иноды файла."

#. type: TP
#: man-pages/man3/readdir.3:86
#, no-wrap
msgid "I<d_off>"
msgstr "I<d_off>"

#.  https://lwn.net/Articles/544298/
#. type: Plain text
#: man-pages/man3/readdir.3:100
msgid ""
"The value returned in I<d_off> is the same as would be returned by calling "
"B<telldir>(3)  at the current position in the directory stream.  Be aware "
"that despite its type and name, the I<d_off> field is seldom any kind of "
"directory offset on modern filesystems.  Applications should treat this "
"field as an opaque value, making no assumptions about its contents; see also "
"B<telldir>(3)."
msgstr ""
"Значение, возвращаемое в I<d_off>, тоже самое что и после вызова "
"B<telldir>(3) в текущем положении курсора в потоке каталога. Учтите, что не "
"смотря на тип и имя, в современных файловых системах поле I<d_off> мало "
"похоже на смещение в каталоге. Приложения должны считать, что это поле "
"неизвестного типа(чёрным ящиком) и не делать предположений о его содержимом; "
"смотрите также B<telldir>(3)."

#. type: TP
#: man-pages/man3/readdir.3:100
#, no-wrap
msgid "I<d_reclen>"
msgstr "I<d_reclen>"

#. type: Plain text
#: man-pages/man3/readdir.3:105
msgid ""
"This is the size (in bytes) of the returned record.  This may not match the "
"size of the structure definition shown above; see NOTES."
msgstr ""
"Размер (в байтах) возвращаемой записи. Может не совпадать с размером "
"структуры, показанной выше; смотрите ЗАМЕЧАНИЯ."

#. type: TP
#: man-pages/man3/readdir.3:105
#, no-wrap
msgid "I<d_type>"
msgstr "I<d_type>"

#. type: Plain text
#: man-pages/man3/readdir.3:111
msgid ""
"This field contains a value indicating the file type, making it possible to "
"avoid the expense of calling B<lstat>(2)  if further actions depend on the "
"type of the file."
msgstr ""
"Это поле содержит значение типа файла, что позволяет не делать "
"дополнительный вызов B<lstat>(2), если дальнейшие действия зависят от типа "
"файла."

#. type: Plain text
#: man-pages/man3/readdir.3:119
msgid ""
"When a suitable feature test macro is defined (B<_DEFAULT_SOURCE> on glibc "
"versions since 2.19, or B<_BSD_SOURCE> on glibc versions 2.19 and earlier), "
"glibc defines the following macro constants for the value returned in "
"I<d_type>:"
msgstr ""
"Если определён подходящий макрос тестирования свойств (B<_DEFAULT_SOURCE> в "
"версиях glibc начиная с 2.19 или B<_BSD_SOURCE> в версиях glibc 2.19 и "
"старее), то для значения, возвращаемого в I<d_type>, glibc определяет "
"следующие макросы-константы:"

#. type: TP
#: man-pages/man3/readdir.3:120
#, no-wrap
msgid "B<DT_BLK>"
msgstr "B<DT_BLK>"

#. type: Plain text
#: man-pages/man3/readdir.3:123
msgid "This is a block device."
msgstr "блочное устройство"

#. type: TP
#: man-pages/man3/readdir.3:123
#, no-wrap
msgid "B<DT_CHR>"
msgstr "B<DT_CHR>"

#. type: Plain text
#: man-pages/man3/readdir.3:126
msgid "This is a character device."
msgstr "символьное устройство"

#. type: TP
#: man-pages/man3/readdir.3:126
#, no-wrap
msgid "B<DT_DIR>"
msgstr "B<DT_DIR>"

#. type: Plain text
#: man-pages/man3/readdir.3:129
msgid "This is a directory."
msgstr "каталог"

#. type: TP
#: man-pages/man3/readdir.3:129
#, no-wrap
msgid "B<DT_FIFO>"
msgstr "B<DT_FIFO>"

#. type: Plain text
#: man-pages/man3/readdir.3:132
msgid "This is a named pipe (FIFO)."
msgstr "именованный канал (FIFO)"

#. type: TP
#: man-pages/man3/readdir.3:132
#, no-wrap
msgid "B<DT_LNK>"
msgstr "B<DT_LNK>"

#. type: Plain text
#: man-pages/man3/readdir.3:135
msgid "This is a symbolic link."
msgstr "символическая ссылка"

#. type: TP
#: man-pages/man3/readdir.3:135
#, no-wrap
msgid "B<DT_REG>"
msgstr "B<DT_REG>"

#. type: Plain text
#: man-pages/man3/readdir.3:138
msgid "This is a regular file."
msgstr "обычный файл"

#. type: TP
#: man-pages/man3/readdir.3:138
#, no-wrap
msgid "B<DT_SOCK>"
msgstr "B<DT_SOCK>"

#. type: Plain text
#: man-pages/man3/readdir.3:141
msgid "This is a UNIX domain socket."
msgstr "доменный сокет UNIX"

#. type: TP
#: man-pages/man3/readdir.3:141
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr "B<DT_UNKNOWN>"

#. type: Plain text
#: man-pages/man3/readdir.3:144
msgid "The file type could not be determined."
msgstr "Тип файла невозможно определить."

#.  kernel 2.6.27
#.  The same sentence is in getdents.2
#. type: Plain text
#: man-pages/man3/readdir.3:154
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr ""
"В настоящее время, только файловые системы (среди которых: Btrfs, ext2, ext3 "
"и ext4) поддерживают возврат типа файла в I<d_type>. Все приложения должны "
"правильно обрабатывать возвращаемое значение B<DT_UNKNOWN>."

#. type: TP
#: man-pages/man3/readdir.3:154
#, no-wrap
msgid "I<d_name>"
msgstr "I<d_name>"

#. type: Plain text
#: man-pages/man3/readdir.3:158
msgid "This field contains the null terminated filename.  I<See NOTES>."
msgstr "Это поле содержит имя файла с завершающим null. I<Смотрите ЗАМЕЧАНИЯ>."

#. type: Plain text
#: man-pages/man3/readdir.3:164
msgid ""
"The data returned by B<readdir>()  may be overwritten by subsequent calls to "
"B<readdir>()  for the same directory stream."
msgstr ""
"Данные, возвращаемые B<readdir>(), могут быть переписаны последующими "
"вызовами B<readdir>() для того же потока каталога."

#. type: Plain text
#: man-pages/man3/readdir.3:173
msgid ""
"On success, B<readdir>()  returns a pointer to a I<dirent> structure.  (This "
"structure may be statically allocated; do not attempt to B<free>(3)  it.)"
msgstr ""
"При успешном выполнении B<readdir>() возвращает указатель на структуру "
"I<dirent> (эта структура может выделяться статически; не пытайтесь "
"освободить её с помощью B<free>(3))."

#. type: Plain text
#: man-pages/man3/readdir.3:187
msgid ""
"If the end of the directory stream is reached, NULL is returned and I<errno> "
"is not changed.  If an error occurs, NULL is returned and I<errno> is set "
"appropriately.  To distinguish end of stream and from an error, set I<errno> "
"to zero before calling B<readdir>()  and then check the value of I<errno> if "
"NULL is returned."
msgstr ""
"При достижении конца потока каталога возвращается NULL и I<errno> не "
"изменяется. При возникновении ошибки возвращается NULL, а I<errno> "
"изменяется соответствующим образом. Чтобы отличить конец потока от ошибки "
"присваивайте I<errno> значение нуля перед вызовом B<readdir>(), а после "
"проверяйте значение I<errno>, если возвращается NULL."

#. type: tbl table
#: man-pages/man3/readdir.3:201
#, no-wrap
msgid "B<readdir>()"
msgstr "B<readdir>()"

#. type: tbl table
#: man-pages/man3/readdir.3:201
#, no-wrap
msgid "MT-Unsafe race:dirstream"
msgstr "MT-Unsafe race:dirstream"

#.  FIXME .
#.  http://www.austingroupbugs.net/view.php?id=696
#. type: Plain text
#: man-pages/man3/readdir.3:224
msgid ""
"In the current POSIX.1 specification (POSIX.1-2008), B<readdir>()  is not "
"required to be thread-safe.  However, in modern implementations (including "
"the glibc implementation), concurrent calls to B<readdir>()  that specify "
"different directory streams are thread-safe.  In cases where multiple "
"threads must read from the same directory stream, using B<readdir>()  with "
"external synchronization is still preferable to the use of the deprecated "
"B<readdir_r>(3)  function.  It is expected that a future version of POSIX.1 "
"will require that B<readdir>()  be thread-safe when concurrently employed on "
"different directory streams."
msgstr ""
"В текущей спецификации POSIX.1 (POSIX.1-2008), от B<readdir>() не требуется "
"быть нитебезопасной. Однако в современных реализациях (включая glibc) "
"параллельные вызовы B<readdir>() для различных потоков каталога являются "
"нитебезопасными. В случаях, когда несколько нитей должны читать один поток "
"каталога, всё равно предпочтительней использовать B<readdir>() с внешней "
"синхронизацией, а не устаревшей B<readdir_r>(3). Ожидается, что в будущей "
"версии POSIX.1 для B<readdir>() будет требоваться нитебезопасность при "
"одновременной работе с разными потоками каталога."

#. type: Plain text
#: man-pages/man3/readdir.3:229
msgid "A directory stream is opened using B<opendir>(3)."
msgstr "Поток каталога открывается с помощью B<opendir>(3)."

#. type: Plain text
#: man-pages/man3/readdir.3:234
msgid ""
"The order in which filenames are read by successive calls to B<readdir>()  "
"depends on the filesystem implementation; it is unlikely that the names will "
"be sorted in any fashion."
msgstr ""
"Порядок последовательно читаемых имён файлов вызовом B<readdir>() зависит от "
"реализации файловой системы; не очень здорово, что имена будут отсортированы "
"в непредсказуемом порядке."

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man3/readdir.3:255
msgid ""
"Only the fields I<d_name> and (as an XSI extension)  I<d_ino> are specified "
"in POSIX.1.  Other than Linux, the I<d_type> field is available mainly only "
"on BSD systems.  The remaining fields are available on many, but not all "
"systems.  Under glibc, programs can check for the availability of the fields "
"not defined in POSIX.1 by testing whether the macros "
"B<_DIRENT_HAVE_D_NAMLEN>, B<_DIRENT_HAVE_D_RECLEN>, B<_DIRENT_HAVE_D_OFF>, "
"or B<_DIRENT_HAVE_D_TYPE> are defined."
msgstr ""
"В POSIX.1 определены только поля I<d_name> и I<d_ino> (расширение XSI). "
"Кроме Linux, поле I<d_type> доступно, преимущественно только в системах BSD. "
"Остальные поля доступны во многих, но не во всех системах. В glibc программы "
"могут определить доступность полей, не определённых в POSIX.1, по наличию "
"макросов B<_DIRENT_HAVE_D_NAMLEN>, B<_DIRENT_HAVE_D_RECLEN>, "
"B<_DIRENT_HAVE_D_OFF> или B<_DIRENT_HAVE_D_TYPE>."

#. type: SS
#: man-pages/man3/readdir.3:255
#, no-wrap
msgid "The d_name field"
msgstr "Поле d_name"

#. type: Plain text
#: man-pages/man3/readdir.3:262
msgid ""
"The I<dirent> structure definition shown above is taken from the glibc "
"headers, and shows the I<d_name> field with a fixed size."
msgstr ""
"Определение структуры I<dirent>, показанное выше, взято из заголовочных "
"файлов glibc и отражает поле I<d_name> с постоянным размером."

#. type: Plain text
#: man-pages/man3/readdir.3:272
msgid ""
"I<Warning>: applications should avoid any dependence on the size of the "
"I<d_name> field.  POSIX defines it as I<char\\ d_name[]>, a character array "
"of unspecified size, with at most B<NAME_MAX> characters preceding the "
"terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""
"I<Предупреждение>: приложения не должны зависеть от размера поля I<d_name>. "
"В POSIX оно определено как I<char\\ d_name[]>, массив символов "
"неопределённого размера, не более B<NAME_MAX> символов с конечным байтом "
"null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/readdir.3:286
msgid ""
"POSIX.1 explicitly notes that this field should not be used as an lvalue.  "
"The standard also notes that the use of I<sizeof(d_name)> is incorrect; use "
"I<strlen(d_name)> instead.  (On some systems, this field is defined as I<char"
"\\ d_name[1]>!)  By implication, the use I<sizeof(struct dirent)> to capture "
"the size of the record including the size of I<d_name> is also incorrect."
msgstr ""
"В POSIX.1 явно сказано, что это поле не должно использоваться как lvalue. В "
"стандарте также отмечено, что использование I<sizeof(d_name)> некорректно; "
"вместо него используйте I<strlen(d_name)> (в некоторых системах это поле "
"определено как I<char\\ d_name[1]>!). Как следствие, использовать "
"I<sizeof(struct dirent)> для получения размера записи, включающей размер "
"I<d_name> также неправильно."

#. type: Plain text
#: man-pages/man3/readdir.3:288
msgid "Note that while the call"
msgstr "Заметим, что хотя вызов"

#. type: Plain text
#: man-pages/man3/readdir.3:290
#, no-wrap
msgid "    fpathconf(fd, _PC_NAME_MAX)\n"
msgstr "    fpathconf(fd, _PC_NAME_MAX)\n"

#. type: Plain text
#: man-pages/man3/readdir.3:301
msgid ""
"returns the value 255 for most filesystems, on some filesystems (e.g., CIFS, "
"Windows SMB servers), the null-terminated filename that is (correctly) "
"returned in I<d_name> can actually exceed this size.  In such cases, the "
"I<d_reclen> field will contain a value that exceeds the size of the glibc "
"I<dirent> structure shown above."
msgstr ""
"и возвращает значение 255 в большинстве файловых систем, но в некоторых "
"файловых системах (например, CIFS, серверы Windows SMB) имя файла с null "
"конце, возвращаемое (правильно) в I<d_name>, может превышать этот размер. В "
"таких случаях поле I<d_reclen> будет содержать значение, превышающее размер "
"структуры glibc I<dirent>, показанной выше."

#. type: Plain text
#: man-pages/man3/readdir.3:313
msgid ""
"B<getdents>(2), B<read>(2), B<closedir>(3), B<dirfd>(3), B<ftw>(3), "
"B<offsetof>(3), B<opendir>(3), B<readdir_r>(3), B<rewinddir>(3), "
"B<scandir>(3), B<seekdir>(3), B<telldir>(3)"
msgstr ""
"B<getdents>(2), B<read>(2), B<closedir>(3), B<dirfd>(3), B<ftw>(3), "
"B<offsetof>(3), B<opendir>(3), B<readdir_r>(3), B<rewinddir>(3), "
"B<scandir>(3), B<seekdir>(3), B<telldir>(3)"

#. type: TH
#: man-pages/man3/rint.3:27
#, no-wrap
msgid "RINT"
msgstr "RINT"

#. type: Plain text
#: man-pages/man3/rint.3:31
msgid ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - round to nearest "
"integer"
msgstr ""
"nearbyint, nearbyintf, nearbyintl, rint, rintf, rintl - округление до "
"ближайшего целого"

#. type: Plain text
#: man-pages/man3/rint.3:38
#, no-wrap
msgid ""
"B<double nearbyint(double >I<x>B<);>\n"
"B<float nearbyintf(float >I<x>B<);>\n"
"B<long double nearbyintl(long double >I<x>B<);>\n"
msgstr ""
"B<double nearbyint(double >I<x>B<);>\n"
"B<float nearbyintf(float >I<x>B<);>\n"
"B<long double nearbyintl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:42
#, no-wrap
msgid ""
"B<double rint(double >I<x>B<);>\n"
"B<float rintf(float >I<x>B<);>\n"
"B<long double rintl(long double >I<x>B<);>\n"
msgstr ""
"B<double rint(double >I<x>B<);>\n"
"B<float rintf(float >I<x>B<);>\n"
"B<long double rintl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/rint.3:55
msgid "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"
msgstr "B<nearbyint>(), B<nearbyintf>(), B<nearbyintl>():"

#. type: Plain text
#: man-pages/man3/rint.3:57
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _ISOC99_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _ISOC99_SOURCE"

#. type: Plain text
#: man-pages/man3/rint.3:60
msgid "B<rint>():"
msgstr "B<rint>():"

#. type: Plain text
#: man-pages/man3/rint.3:70
msgid "B<rintf>(), B<rintl>():"
msgstr "B<rintf>(), B<rintl>():"

#. type: Plain text
#: man-pages/man3/rint.3:91
msgid ""
"The B<nearbyint>(), B<nearbyintf>(), and B<nearbyintl>()  functions round "
"their argument to an integer value in floating-point format, using the "
"current rounding direction (see B<fesetround>(3))  and without raising the "
"I<inexact> exception.  When the current rounding direction is to nearest, "
"these functions round halfway cases to the even integer in accordance with "
"IEEE-754."
msgstr ""
"Функции B<nearbyint>(), B<nearbyintf>() и B<nearbyintl>() округляют "
"переданный аргумент до целого значения в формате с плавающей запятой в "
"соответствии с текущим направлением округления (смотрите B<fesetround>(3)) и "
"не генерируют исключение о I<неточности>. Когда текущее округление "
"направлено к ближайшему целому, то в случае нахождения посереди между "
"значениями эти функции округляют до чётного целого, в соответствии с "
"IEEE-754."

#. type: Plain text
#: man-pages/man3/rint.3:104
msgid ""
"The B<rint>(), B<rintf>(), and B<rintl>()  functions do the same, but will "
"raise the I<inexact> exception (B<FE_INEXACT>, checkable via "
"B<fetestexcept>(3))  when the result differs in value from the argument."
msgstr ""
"Функции B<rint>(), B<rintf>() и B<rintl>() делают то же самое, но генерируют "
"исключение о I<неточности> (B<FE_INEXACT>, проверяется с помощью "
"B<fetestexcept>(3)), если результат отличается в значении от аргумента."

#. type: tbl table
#: man-pages/man3/rint.3:126
#, no-wrap
msgid ""
"B<nearbyint>(),\n"
"B<nearbyintf>(),\n"
msgstr ""
"B<nearbyint>(),\n"
"B<nearbyintf>(),\n"

#. type: tbl table
#: man-pages/man3/rint.3:129
#, no-wrap
msgid ""
"B<nearbyintl>(),\n"
"B<rint>(),\n"
msgstr ""
"B<nearbyintl>(),\n"
"B<rint>(),\n"

#. type: tbl table
#: man-pages/man3/rint.3:132
#, no-wrap
msgid ""
"B<rintf>(),\n"
"B<rintl>()"
msgstr ""
"B<rintf>(),\n"
"B<rintl>()"

#. type: Plain text
#: man-pages/man3/rint.3:151
msgid ""
"SUSv2 and POSIX.1-2001 contain text about overflow (which might set I<errno> "
"to B<ERANGE>, or raise an B<FE_OVERFLOW> exception).  In practice, the "
"result cannot overflow on any current machine, so this error-handling stuff "
"is just nonsense.  (More precisely, overflow can happen only when the "
"maximum value of the exponent is smaller than the number of mantissa bits.  "
"For the IEEE-754 standard 32-bit and 64-bit floating-point numbers the "
"maximum value of the exponent is 128 (respectively, 1024), and the number of "
"mantissa bits is 24 (respectively, 53).)"
msgstr ""
"В SUSv2 и POSIX.1-2001 есть текст о переполнении (которое может установить "
"I<errno> в B<ERANGE> или вызвать исключение B<FE_OVERFLOW>). На практике,  "
"результат не может выйти за диапазон ни на каком компьютере, поэтому "
"обработка этой ошибки не имеет смысла (точнее говоря, переполнение возможно "
"только в том случае, когда максимальное значение экспоненты меньше числа бит "
"мантиссы. В стандарте IEEE-754 для 32- и 64-битных чисел с плавающей точкой "
"максимальное значение экспоненты равно 128 и 1024 соответственно, а число "
"бит мантиссы \\(em 24 и 53 соответственно)."

#. type: Plain text
#: man-pages/man3/rint.3:156
msgid ""
"If you want to store the rounded value in an integer type, you probably want "
"to use one of the functions described in B<lrint>(3)  instead."
msgstr ""
"Если вы хотите сохранить округлённое значение в целочисленном типе, то лучше "
"использовать одну из функций, описанных в B<lrint>(3)."

#. type: Plain text
#: man-pages/man3/rint.3:161
msgid "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"
msgstr "B<ceil>(3), B<floor>(3), B<lrint>(3), B<round>(3), B<trunc>(3)"

#. type: TH
#: man-pages/man3/recno.3:36
#, no-wrap
msgid "RECNO"
msgstr "RECNO"

#. type: Plain text
#: man-pages/man3/recno.3:40
msgid "recno - record number database access method"
msgstr "recno - метод доступа к базам нумерованных данных"

#. type: Plain text
#: man-pages/man3/recno.3:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/recno.3:54
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces.  "
"Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""
"I<Примечание>: В этой странице описаны интерфейсы, предоставляемые glibc до "
"версии 2.1. Начиная с версии 2.2, glibc больше не поддерживает эти "
"интерфейсы. Вероятно, вы ищите API, предоставляемое библиотекой I<libdb>."

#. type: Plain text
#: man-pages/man3/recno.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is record number files.  The general "
"description of the database access methods is in B<dbopen>(3), this manual "
"page describes only the recno-specific information."
msgstr ""
"Функция B<dbopen>(3) — это библиотечный интерфейс к файлам баз данных. Один "
"из поддерживаемых форматов файлов — нумерованные данные. Общее описание "
"методов доступа к базам данных находится в B<dbopen>(3). Эта справочная "
"страница содержит только информацию, относящуюся к нумерованным данным."

#. type: Plain text
#: man-pages/man3/recno.3:71
msgid ""
"The record number data structure is either variable or fixed-length records "
"stored in a flat-file format, accessed by the logical record number.  The "
"existence of record number five implies the existence of records one through "
"four, and the deletion of record number one causes record number five to be "
"renumbered to record number four, as well as the cursor, if positioned after "
"record number one, to shift down one record."
msgstr ""
"Структура нумерованных данных может описывать записи переменной или "
"фиксированной длины, хранящиеся в файле в «плоском» формате, и доступные по "
"логическому номеру записи. Существование записи с номером пять подразумевает "
"существование записей от одного до четырёх и удаление записи с номером один "
"вызывает перенумеровывание записи с номером пять в запись с номером четыре, "
"а также сдвиг курсора вниз на одну запись, если он указывает на запись после "
"номера один."

#. type: Plain text
#: man-pages/man3/recno.3:77
msgid ""
"The recno access-method-specific data structure provided to B<dbopen>(3)  is "
"defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""
"Специальная структура метода доступа к данным recno, предоставляемая "
"B<dbopen>(3), определена в I<E<lt>db.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/recno.3:89
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    unsigned int  psize;\n"
"    int           lorder;\n"
"    size_t        reclen;\n"
"    unsigned char bval;\n"
"    char         *bfname;\n"
"} RECNOINFO;\n"
msgstr ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    unsigned int  psize;\n"
"    int           lorder;\n"
"    size_t        reclen;\n"
"    unsigned char bval;\n"
"    char         *bfname;\n"
"} RECNOINFO;\n"

#. type: Plain text
#: man-pages/man3/recno.3:93
msgid "The elements of this structure are defined as follows:"
msgstr "Элементы этой структуры определены так:"

#. type: TP
#: man-pages/man3/recno.3:93
#, no-wrap
msgid "I<flags>"
msgstr "I<flags>"

#. type: Plain text
#: man-pages/man3/recno.3:97
msgid "The flag value is specified by ORing any of the following values:"
msgstr "Значение флага определяется логическим ИЛИ следующих значений:"

#. type: TP
#: man-pages/man3/recno.3:98
#, no-wrap
msgid "B<R_FIXEDLEN>"
msgstr "B<R_FIXEDLEN>"

#. type: Plain text
#: man-pages/man3/recno.3:109
msgid ""
"The records are fixed-length, not byte delimited.  The structure element "
"I<reclen> specifies the length of the record, and the structure element "
"I<bval> is used as the pad character.  Any records, inserted into the "
"database, that are less than I<reclen> bytes long are automatically padded."
msgstr ""
"Записи фиксированной длины без разделительного байта. Полем I<reclen> "
"определяется длина записи, а поле I<bval> используется как дополняющий "
"символ. Все вставляемые в базу данных записи, размер которых меньше "
"I<reclen> байт, автоматически дополняются."

#. type: TP
#: man-pages/man3/recno.3:109
#, no-wrap
msgid "B<R_NOKEY>"
msgstr "B<R_NOKEY>"

#. type: Plain text
#: man-pages/man3/recno.3:122
msgid ""
"In the interface specified by B<dbopen>(3), the sequential record retrieval "
"fills in both the caller's key and data structures.  If the B<R_NOKEY> flag "
"is specified, the I<cursor> routines are not required to fill in the key "
"structure.  This permits applications to retrieve records at the end of "
"files without reading all of the intervening records."
msgstr ""
"В интерфейсе, определённом B<dbopen>(3), последовательная выборка записей "
"заполняет структуры данных и ключа вызывающего. Если указан флаг B<R_NOKEY>, "
"то процедурам I<cursor> не обязательно заполнять структуру ключа. Это "
"позволяет приложениям извлекать записи из конца файлов без чтения всех "
"промежуточных записей."

#. type: TP
#: man-pages/man3/recno.3:122
#, no-wrap
msgid "B<R_SNAPSHOT>"
msgstr "B<R_SNAPSHOT>"

#. type: Plain text
#: man-pages/man3/recno.3:128
msgid ""
"This flag requires that a snapshot of the file be taken when B<dbopen>(3)  "
"is called, instead of permitting any unmodified records to be read from the "
"original file."
msgstr ""
"Этим флагом указывается, чтобы в момент вызова B<dbopen>(3) был сделан "
"снимок (snapshot) файла, а не выполнялось чтение каких-либо не изменённых "
"записей из оригинального файла."

#. type: TP
#: man-pages/man3/recno.3:129
#, no-wrap
msgid "I<cachesize>"
msgstr "I<cachesize>"

#. type: Plain text
#: man-pages/man3/recno.3:138
msgid ""
"A suggested maximum size, in bytes, of the memory cache.  This value is "
"B<only> advisory, and the access method will allocate more memory rather "
"than fail.  If I<cachesize> is 0 (no size is specified), a default cache is "
"used."
msgstr ""
"Предполагаемый максимальный размер кэша памяти в байтах. Эта величина "
"I<только рекомендация>, метод доступа скорее выделит больше памяти, чем "
"завершится с ошибкой. Если значение I<cachesize> равно 0 (размер не указан), "
"то используется кэш по умолчанию."

#. type: TP
#: man-pages/man3/recno.3:138
#, no-wrap
msgid "I<psize>"
msgstr "I<psize>"

#. type: Plain text
#: man-pages/man3/recno.3:150
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  This value is the size (in bytes) of the pages used for nodes in "
"that tree.  If I<psize> is 0 (no page size is specified), a page size is "
"chosen based on the underlying filesystem I/O block size.  See B<btree>(3)  "
"for more information."
msgstr ""
"Метод доступа recno хранит копии своих записей в памяти в виде дерева btree. "
"Это значение задаёт размер страниц (в байтах), используемых для узлов в этом "
"дереве. Если значение I<psize> равно 0 (размер страницы не указан), то "
"размер выбирается на основе размера блока ввода-вывода нижележащей файловой "
"системы. Подробней смотрите B<btree>(3)."

#. type: TP
#: man-pages/man3/recno.3:150
#, no-wrap
msgid "I<lorder>"
msgstr "I<lorder>"

#. type: Plain text
#: man-pages/man3/recno.3:158
msgid ""
"The byte order for integers in the stored database metadata.  The number "
"should represent the order as an integer; for example, big endian order "
"would be the number 4,321.  If I<lorder> is 0 (no order is specified), the "
"current host order is used."
msgstr ""
"Порядок расположения байтов, используемый при хранении целых чисел в "
"метаданных базы данных. Число должно отражать порядок размещения в виде "
"целого значения; например, порядок «big  endian» должен обозначаться числом "
"4321. Если I<lorder> равно 0 (порядок не определён), то используется "
"значение по умолчанию, принятое на машине."

#. type: TP
#: man-pages/man3/recno.3:158
#, no-wrap
msgid "I<reclen>"
msgstr "I<reclen>"

#. type: Plain text
#: man-pages/man3/recno.3:161
msgid "The length of a fixed-length record."
msgstr "Длина записи фиксированной длины."

#. type: TP
#: man-pages/man3/recno.3:161
#, no-wrap
msgid "I<bval>"
msgstr "I<bval>"

#. type: Plain text
#: man-pages/man3/recno.3:169
msgid ""
"The delimiting byte to be used to mark the end of a record for variable-"
"length records, and the pad character for fixed-length records.  If no value "
"is specified, newlines (\"\\en\") are used to mark the end of variable-"
"length records and fixed-length records are padded with spaces."
msgstr ""
"Разделительный байт, для использования в качестве отметки конца записи с "
"переменной длиной и как заполняющий символ для записи с фиксированной "
"длиной. Если значение не указано, то для отметки конца записи с переменной "
"длиной используется символ новой строки («\\en»), а записи с фиксированной "
"длиной дополняются пробелом."

#. type: TP
#: man-pages/man3/recno.3:169
#, no-wrap
msgid "I<bfname>"
msgstr "I<bfname>"

#. type: Plain text
#: man-pages/man3/recno.3:179
msgid ""
"The recno access method stores the in-memory copies of its records in a "
"btree.  If I<bfname> is non-NULL, it specifies the name of the btree file, "
"as if specified as the filename for a B<dbopen>(3)  of a btree file."
msgstr ""
"Метод доступа recno хранит в памяти копии своих записей в дереве btree. Если "
"значение I<bfname> не равно NULL, то им задаётся имя btree-файла в том же "
"виде, что и при доступе B<dbopen>(3) для доступа к btree-файлу."

#. type: Plain text
#: man-pages/man3/recno.3:197
msgid ""
"The data part of the key/data pair used by the I<recno> access method is the "
"same as other access methods.  The key is different.  The I<data> field of "
"the key should be a pointer to a memory location of type I<recno_t>, as "
"defined in the I<E<lt>db.hE<gt>> include file.  This type is normally the "
"largest unsigned integral type available to the implementation.  The I<size> "
"field of the key should be the size of that type."
msgstr ""
"Часть «данные» из пары ключ/данные, используемая методом доступа I<recno>, "
"является такой же, как в других методах доступа. Ключ используется иначе. "
"Как следует из определения заголовочного файла I<E<lt>db.hE<gt>>, поле ключа "
"I<data> должно быть указателем на расположение памяти типа I<recno_t>. Этот "
"тип, обычно, является наибольшим беззнаковым целочисленным типом данных, "
"применяемым в реализации. Значение поля ключа I<size> должен задавать размер "
"этого типа."

#. type: Plain text
#: man-pages/man3/recno.3:202
msgid ""
"Because there can be no metadata associated with the underlying recno access "
"method files, any changes made to the default values (e.g., fixed record "
"length or byte separator value) must be explicitly specified each time the "
"file is opened."
msgstr ""
"Так как в файлах с данными в формате recno могут отсутствовать метаданные, "
"то любые изменения значений по умолчанию (например, длина фиксированной "
"записи или разделяющий байт) должны явно указываться каждый раз при открытии "
"файла."

#. type: Plain text
#: man-pages/man3/recno.3:210
msgid ""
"In the interface specified by B<dbopen>(3), using the I<put> interface to "
"create a new record will cause the creation of multiple, empty records if "
"the record number is more than one greater than the largest record currently "
"in the database."
msgstr ""
"В интерфейсе, определённым B<dbopen>(3), использование интерфейса I<put> для "
"создания новой записи повлечёт за собой создание множества пустых записей, "
"если номер записи больше, чем номер наибольшей записи, имеющейся в базе "
"данных."

#. type: Plain text
#: man-pages/man3/recno.3:218
msgid ""
"The I<recno> access method routines may fail and set I<errno> for any of the "
"errors specified for the library routine B<dbopen>(3)  or the following:"
msgstr ""
"Функции метода доступа I<recno> могут завершиться с ошибкой и присвоить "
"I<errno> любое значение из определённых для библиотеки функций B<dbopen>(3), "
"а также:"

#. type: Plain text
#: man-pages/man3/recno.3:222
msgid ""
"An attempt was made to add a record to a fixed-length database that was too "
"large to fit."
msgstr ""
"Попытка добавить слишком большую запись в базу данных фиксированной длины."

#. type: Plain text
#: man-pages/man3/recno.3:224
msgid "Only big and little endian byte order is supported."
msgstr "Поддерживаются значения только с прямым и обратным порядком байт."

#. type: Plain text
#: man-pages/man3/recno.3:229
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"
msgstr "B<btree>(3), B<dbopen>(3), B<hash>(3), B<mpool>(3)"

#. type: Plain text
#: man-pages/man3/recno.3:232
msgid ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker, "
"Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No. "
"UCB/ERL M82/32, May 1982."
msgstr ""
"I<Document Processing in a Relational Database System>, Michael Stonebraker, "
"Heidi Stettner, Joseph Kalash, Antonin Guttman, Nadene Lynn, Memorandum No. "
"UCB/ERL M82/32, May 1982."

#. type: TH
#: man-pages/man3/re_comp.3:27
#, no-wrap
msgid "RE_COMP"
msgstr "RE_COMP"

#. type: Plain text
#: man-pages/man3/re_comp.3:30
msgid "re_comp, re_exec - BSD regex functions"
msgstr "re_comp, re_exec - функции BSD для регулярных выражений"

#. type: Plain text
#: man-pages/man3/re_comp.3:32
msgid "B<#define _REGEX_RE_COMP>"
msgstr "B<#define _REGEX_RE_COMP>"

#. type: Plain text
#: man-pages/man3/re_comp.3:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man3/re_comp.3:36
msgid "B<#include E<lt>regex.hE<gt>>"
msgstr "B<#include E<lt>regex.hE<gt>>"

#. type: Plain text
#: man-pages/man3/re_comp.3:38
msgid "B<char *re_comp(const char *>I<regex>B<);>"
msgstr "B<char *re_comp(const char *>I<regex>B<);>"

#. type: Plain text
#: man-pages/man3/re_comp.3:40
msgid "B<int re_exec(const char *>I<string>B<);>"
msgstr "B<int re_exec(const char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/re_comp.3:52
msgid ""
"B<re_comp>()  is used to compile the null-terminated regular expression "
"pointed to by I<regex>.  The compiled pattern occupies a static area, the "
"pattern buffer, which is overwritten by subsequent use of B<re_comp>().  If "
"I<regex> is NULL, no operation is performed and the pattern buffer's "
"contents are not altered."
msgstr ""
"Функция B<re_comp>() используется для компиляции регулярного выражения "
"(завершающегося null), указанного I<regex>. Скомпилированный шаблон "
"располагается в статической области (буфере шаблонов), которая "
"перезаписывается заново каждый раз при вызове B<re_comp>(). Если значение "
"I<regex> равно NULL, то действие не выполняется и содержимое буфера шаблонов "
"остаётся неизменным."

#. type: Plain text
#: man-pages/man3/re_comp.3:58
msgid ""
"B<re_exec>()  is used to assess whether the null-terminated string pointed "
"to by I<string> matches the previously compiled I<regex>."
msgstr ""
"Функция B<re_exec>() используется для проверки совпадения строки "
"(завершается null), на которую указывает I<string>, с предварительно "
"скомпилированным I<regex>."

#. type: Plain text
#: man-pages/man3/re_comp.3:63
msgid ""
"B<re_comp>()  returns NULL on successful compilation of I<regex> otherwise "
"it returns a pointer to an appropriate error message."
msgstr ""
"Функция B<re_comp>() возвращает NULL при успешной компиляции I<regex> или "
"указатель на соответствующее сообщение об ошибке."

#. type: Plain text
#: man-pages/man3/re_comp.3:66
msgid "B<re_exec>()  returns 1 for a successful match, zero for failure."
msgstr ""
"Функция B<re_exec>() возвращает 1 при совпадении или 0, если совпадения не "
"было."

#. type: tbl table
#: man-pages/man3/re_comp.3:77
#, no-wrap
msgid ""
"B<re_comp>(),\n"
"B<re_exec>()"
msgstr ""
"B<re_comp>(),\n"
"B<re_exec>()"

#. type: Plain text
#: man-pages/man3/re_comp.3:85
msgid ""
"These functions are obsolete; the functions documented in B<regcomp>(3)  "
"should be used instead."
msgstr ""
"Эти функции устарели; вместо них следует использовать функции, описанные в "
"B<regcomp>(3)."

#. type: Plain text
#: man-pages/man3/re_comp.3:88
msgid "B<regcomp>(3), B<regex>(7), GNU regex manual"
msgstr "B<regcomp>(3), B<regex>(7), руководство по регулярным выражениям GNU"

#. type: TH
#: man-pages/man3/rexec.3:41
#, no-wrap
msgid "REXEC"
msgstr "REXEC"

#. type: Plain text
#: man-pages/man3/rexec.3:44
msgid "rexec, rexec_af - return stream to a remote command"
msgstr "rexec, rexec_af - возвращает поток удалённой команде"

#. type: Plain text
#: man-pages/man3/rexec.3:47
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/rexec.3:50
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<          const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<);>\n"

#. type: Plain text
#: man-pages/man3/rexec.3:54
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, const char *>I<user>B<, >\n"
"B<             const char *>I<passwd>B<, const char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/rexec.3:58
msgid "B<rexec>(), B<rexec_af>():"
msgstr "B<rexec>(), B<rexec_af>():"

#. type: Plain text
#: man-pages/man3/rexec.3:63
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc до версии 2.19 включительно:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/rexec.3:67
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr "Этот интерфейс устарел, используйте B<rcmd>(3)."

#. type: Plain text
#: man-pages/man3/rexec.3:86
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise, "
"I<*ahost> is set to the standard name of the host.  If a username and "
"password are both specified, then these are used to authenticate to the "
"foreign host; otherwise the environment and then the I<.netrc> file in "
"user's home directory are searched for appropriate information.  If all this "
"fails, the user is prompted for the information."
msgstr ""
"Функция B<rexec>() ищет узел I<*ahost>, используя B<gethostbyname>(3), и "
"возвращает -1, если узел не существует. В противном случае, I<*ahost> "
"присваивается стандартное имя узла. Если указаны имя пользователя и пароль, "
"то они используются для аутентификации на другом узле; иначе происходит "
"поиск соответствующей информации в окружении и затем в файле I<.netrc>, "
"находящемся в домашнем каталоге пользователя. Если всё это заканчивается с "
"ошибкой, пользователь извещается об этом."

#. type: Plain text
#: man-pages/man3/rexec.3:97
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for "
"the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""
"В I<inport> указывается, какой хорошо известный (well-known) порт DARPA "
"Internet нужно использовать для подключения; вызов I<getservbyname(\"exec\", "
"\"tcp\")> (смотрите B<getservent>(3)) вернёт указатель на структуру, которая "
"содержит необходимый порт. Протокол подключения подробно описан в "
"B<rexecd>(8)."

#. type: Plain text
#: man-pages/man3/rexec.3:130
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be setup, and a file descriptor for it will be placed "
"in I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  The diagnostic information returned does not include remote "
"authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr ""
"Если соединение успешно установлено, то вызывающему возвращается сокет в "
"Интернет-домене типа B<SOCK_STREAM>, который для удалённой команды считается "
"I<stdin> и I<stdout>. Если I<fd2p> не равно нулю, то устанавливается "
"вспомогательный канал до управляющего процесса, а его файловый дескриптор "
"будет помещён в I<*fd2p>. Управляющий процесс возвращает диагностический "
"вывод из команды (устройства 2) в этот канал, а также принимает байты из "
"этого канала, считая их номерами сигналов UNIX, для их пересылки группе "
"процессов команды. Возвращаемая диагностическая информация не содержит "
"ошибки удалённой авторизации, так как второе подключение устанавливается "
"после прохождения авторизации. Если I<fd2p> равно 0, то I<stderr> "
"(устройство 2 удалённой команды) будет работать аналогично I<stdout> и для "
"отправки произвольных сигналов в удалённый процесс ничего не будет сделано, "
"хотя вы сможете привлечь к себе внимание, используя внеполосную передачу "
"данных."

#. type: SS
#: man-pages/man3/rexec.3:130
#, no-wrap
msgid "rexec_af()"
msgstr "rexec_af()"

#. type: Plain text
#: man-pages/man3/rexec.3:146
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""
"Функция B<rexec>() работает по протоколу IPv4 (B<AF_INET>). В отличие от "
"неё, B<rexec_af>() предоставляет ещё один аргумент, I<af>, который позволяет "
"вызывающему выбрать протокол. В этом аргументе можно указать значения "
"B<AF_INET>, B<AF_INET6> или B<AF_UNSPEC> (чтобы позволить реализации "
"выбирать протокол)."

#. type: Plain text
#: man-pages/man3/rexec.3:150
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr "Функция B<rexec_af>() впервые появилась в glibc 2.2."

#. type: tbl table
#: man-pages/man3/rexec.3:161
#, no-wrap
msgid ""
"B<rexec>(),\n"
"B<rexec_af>()"
msgstr ""
"B<rexec>(),\n"
"B<rexec_af>()"

#. type: Plain text
#: man-pages/man3/rexec.3:172
msgid ""
"These functions are not in POSIX.1.  The B<rexec>()  function first appeared "
"in 4.2BSD, and is present on the BSDs, Solaris, and many other systems.  The "
"B<rexec_af>()  function is more recent, and less widespread."
msgstr ""
"Данные функции отсутствуют в POSIX.1. Функция B<rexec>() впервые появилась в "
"4.2BSD, и есть в разных BSD, Solaris и других системах. Функция "
"B<rexec_af>() более новая и распространена гораздо меньше."

#. type: Plain text
#: man-pages/man3/rexec.3:176
msgid ""
"The B<rexec>()  function sends the unencrypted password across the network."
msgstr "Функция B<rexec>() посылает пароль через сеть в нешифрованном виде."

#. type: Plain text
#: man-pages/man3/rexec.3:181
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""
"Считается, что лежащая в основе служба является большой дырой в "
"безопасности, и поэтому не включена на большинстве сайтов; смотрите "
"объяснение в B<rexecd>(8)."

#. type: Plain text
#: man-pages/man3/rexec.3:183
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr "B<rcmd>(3), B<rexecd>(8)"

#. type: TH
#: man-pages/man3/rtime.3:12
#, no-wrap
msgid "RTIME"
msgstr "RTIME"

#. type: Plain text
#: man-pages/man3/rtime.3:15
msgid "rtime - get time from a remote machine"
msgstr "rtime - получение времени с удалённого узла"

#. type: Plain text
#: man-pages/man3/rtime.3:18
#, no-wrap
msgid "B<#include E<lt>rpc/auth_des.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/auth_des.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/rtime.3:21
#, no-wrap
msgid ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>\n"
"B<          struct rpc_timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int rtime(struct sockaddr_in *>I<addrp>B<, struct rpc_timeval *>I<timep>B<,>\n"
"B<          struct rpc_timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/rtime.3:25
msgid ""
"This function uses the Time Server Protocol as described in RFC\\ 868 to "
"obtain the time from a remote machine."
msgstr ""
"Для получения времени с удалённого компьютера функция использует протокол "
"Time Server Protocol, описанный в RFC\\ 868."

#. type: Plain text
#: man-pages/man3/rtime.3:31
msgid ""
"The Time Server Protocol gives the time in seconds since 00:00:00 UTC, 1 Jan "
"1900, and this function subtracts the appropriate constant in order to "
"convert the result to seconds since the Epoch, 1970-01-01 00:00:00 +0000 "
"(UTC)."
msgstr ""
"Time Server Protocol возвращает время в секундах начиная с 1 января 1900 "
"года 00:00:00 UTC. Данная функция самостоятельно вычитает подходящую "
"константу для того, чтобы преобразовать результат в секундах от начала Эпохи "
"\\(em 1970-01-01 00:00:00 +0000 (UTC)."

#. type: Plain text
#: man-pages/man3/rtime.3:36
msgid ""
"When I<timeout> is non-NULL, the udp/time socket (port 37) is used.  "
"Otherwise, the tcp/time socket (port 37) is used."
msgstr ""
"Если I<timeout> не равно NULL, то будет использоваться сокет udp/time (порт "
"37), иначе \\(em сокет tcp/time (порт 37)."

#. type: Plain text
#: man-pages/man3/rtime.3:42
msgid ""
"On success, 0 is returned, and the obtained 32-bit time value is stored in "
"I<timep-E<gt>tv_sec>.  In case of error -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0, а полученное 32-битное значение "
"времени сохраняется в I<timep-E<gt>tv_sec>. В случае ошибки возвращается -1, "
"а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/rtime.3:51
msgid ""
"All errors for underlying functions (B<sendto>(2), B<poll>(2), "
"B<recvfrom>(2), B<connect>(2), B<read>(2))  can occur.  Moreover:"
msgstr ""
"Могут возникнуть все ошибки задействованных в работе функций (B<sendto>(2), "
"B<poll>(2), B<recvfrom>(2), B<connect>(2), B<read>(2)), а также:"

#. type: Plain text
#: man-pages/man3/rtime.3:54
msgid "The number of returned bytes is not 4."
msgstr "Количество возвращённых байт не равно 4."

#. type: TP
#: man-pages/man3/rtime.3:54
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man3/rtime.3:57
msgid "The waiting time as defined in timeout has expired."
msgstr "Время ожидания, указанное в таймауте, превышено."

#. type: tbl table
#: man-pages/man3/rtime.3:67
#, no-wrap
msgid "B<rtime>()"
msgstr "B<rtime>()"

#. type: Plain text
#: man-pages/man3/rtime.3:71
msgid "Only IPv4 is supported."
msgstr "Поддерживается только IPv4."

#. type: Plain text
#: man-pages/man3/rtime.3:78
msgid ""
"Some I<in.timed> versions support only TCP.  Try the example program with "
"I<use_tcp> set to 1."
msgstr ""
"Некоторые версии I<in.timed> поддерживают только TCP. Попробуйте пример "
"программы с установленной в 1 значением I<use_tcp>."

#. type: Plain text
#: man-pages/man3/rtime.3:80
msgid "Libc5 uses the prototype"
msgstr "В libc5 используется прототип"

#. type: Plain text
#: man-pages/man3/rtime.3:83
#, no-wrap
msgid "    int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);\n"
msgstr "    int rtime(struct sockaddr_in *, struct timeval *, struct timeval *);\n"

#. type: Plain text
#: man-pages/man3/rtime.3:89
msgid ""
"and requires I<E<lt>sys/time.hE<gt>> instead of I<E<lt>rpc/auth_des.hE<gt>>."
msgstr ""
"для которого требуется I<E<lt>sys/time.hE<gt>> вместо I<E<lt>rpc/auth_des."
"hE<gt>>."

#. type: Plain text
#: man-pages/man3/rtime.3:92
msgid ""
"B<rtime>()  in glibc 2.2.5 and earlier does not work properly on 64-bit "
"machines."
msgstr ""
"B<rtime>() в glibc 2.2.5 и ниже на 64-битных компьютерах работает "
"некорректно."

#. type: Plain text
#: man-pages/man3/rtime.3:98
msgid ""
"This example requires that port 37 is up and open.  You may check that the "
"time entry within I</etc/inetd.conf> is not commented out."
msgstr ""
"Для этого примера требуется поднятие и открытие порта 37. Вы можете "
"проверить это, убедившись в том, что в файле I</etc/inetd.conf> запись time "
"раскомментирована."

#. type: Plain text
#: man-pages/man3/rtime.3:102
msgid ""
"The program connects to a computer called \"linux\".  Using \"localhost\" "
"does not work.  The result is the localtime of the computer \"linux\"."
msgstr ""
"Программа подключается к компьютеру с именем «linux». Использование "
"«localhost» не сработает. В качестве результата будет возвращено локальное "
"время компьютера «linux»."

#. type: Plain text
#: man-pages/man3/rtime.3:111
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>rpc/auth_des.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>rpc/auth_des.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/rtime.3:114
#, no-wrap
msgid ""
"static int use_tcp = 0;\n"
"static char *servername = \"linux\";\n"
msgstr ""
"static int use_tcp = 0;\n"
"static char *servername = \"linux\";\n"

#. type: Plain text
#: man-pages/man3/rtime.3:123
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sockaddr_in name;\n"
"    struct rpc_timeval time1 = {0,0};\n"
"    struct rpc_timeval timeout = {1,0};\n"
"    struct hostent *hent;\n"
"    int ret;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct sockaddr_in name;\n"
"    struct rpc_timeval time1 = {0,0};\n"
"    struct rpc_timeval timeout = {1,0};\n"
"    struct hostent *hent;\n"
"    int ret;\n"

#. type: Plain text
#: man-pages/man3/rtime.3:128
#, no-wrap
msgid ""
"    memset(&name, 0, sizeof(name));\n"
"    sethostent(1);\n"
"    hent = gethostbyname(servername);\n"
"    memcpy(&name.sin_addr, hent-E<gt>h_addr, hent-E<gt>h_length);\n"
msgstr ""
"    memset(&name, 0, sizeof(name));\n"
"    sethostent(1);\n"
"    hent = gethostbyname(servername);\n"
"    memcpy(&name.sin_addr, hent-E<gt>h_addr, hent-E<gt>h_length);\n"

#. type: Plain text
#: man-pages/man3/rtime.3:136
#, no-wrap
msgid ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n"
"    if (ret E<lt> 0)\n"
"        perror(\"rtime error\");\n"
"    else {\n"
"        time_t t = time1.tv_sec;\n"
"        printf(\"%s\\en\", ctime(&t));\n"
"    }\n"
msgstr ""
"    ret = rtime(&name, &time1, use_tcp ? NULL : &timeout);\n"
"    if (ret E<lt> 0)\n"
"        perror(\"ошибка rtime\");\n"
"    else {\n"
"        time_t t = time1.tv_sec;\n"
"        printf(\"%s\\en\", ctime(&t));\n"
"    }\n"

#.  .BR netdate (1),
#.  .BR rdate (1),
#. type: Plain text
#: man-pages/man3/rtime.3:144
msgid "B<ntpdate>(1), B<inetd>(8)"
msgstr "B<ntpdate>(1), B<inetd>(8)"

#. type: TH
#: man-pages/man3/raise.3:29
#, no-wrap
msgid "RAISE"
msgstr "RAISE"

#. type: Plain text
#: man-pages/man3/raise.3:32
msgid "raise - send a signal to the caller"
msgstr "raise - посылает сигнал вызывающему"

#. type: Plain text
#: man-pages/man3/raise.3:35
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/raise.3:37
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr "B<int raise(int >I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/raise.3:43
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""
"Функция B<raise>() посылает сигнал вызвавшему процессу или нити. В "
"однонитевых программах это эквивалентно"

#. type: Plain text
#: man-pages/man3/raise.3:47
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr "kill(getpid(), sig);\n"

#. type: Plain text
#: man-pages/man3/raise.3:51
msgid "In a multithreaded program it is equivalent to"
msgstr "В многонитевых программах это эквивалентно"

#. type: Plain text
#: man-pages/man3/raise.3:55
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr "pthread_kill(pthread_self(), sig);\n"

#. type: Plain text
#: man-pages/man3/raise.3:61
msgid ""
"If the signal causes a handler to be called, B<raise>()  will return only "
"after the signal handler has returned."
msgstr ""
"Если из-за сигнала вызвался обработчик, то B<raise>() вернёт управление "
"только после завершения обработчика сигнала."

#. type: Plain text
#: man-pages/man3/raise.3:64
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr ""
"При успешном выполнении функция B<raise>() возвращает 0 или иное значение "
"при ошибке."

#. type: tbl table
#: man-pages/man3/raise.3:74
#, no-wrap
msgid "B<raise>()"
msgstr "B<raise>()"

#. type: Plain text
#: man-pages/man3/raise.3:78
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99."

#.  2.3.2 used the obsolete tkill(), if available.
#. type: Plain text
#: man-pages/man3/raise.3:89
msgid ""
"Since version 2.3.3, glibc implements B<raise>()  by calling B<tgkill>(2), "
"if the kernel supports that system call.  Older glibc versions implemented "
"B<raise>()  using B<kill>(2)."
msgstr ""
"Начиная с версии 2.3.3 glibc реализует B<raise>() с помощью B<tgkill>(2), "
"если ядро поддерживает этот системный вызов. Предыдущие версии glibc "
"реализовали B<raise>() с помощью B<kill>(2)."

#. type: Plain text
#: man-pages/man3/raise.3:95
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"
msgstr ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"

#. type: TH
#: man-pages/man3/realpath.3:28
#, no-wrap
msgid "REALPATH"
msgstr "REALPATH"

#. type: Plain text
#: man-pages/man3/realpath.3:31
msgid "realpath - return the canonicalized absolute pathname"
msgstr "realpath - возвращает канонизированный абсолютный путь"

#. type: Plain text
#: man-pages/man3/realpath.3:35
#, no-wrap
msgid ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/realpath.3:37
#, no-wrap
msgid "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"
msgstr "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"

#. type: Plain text
#: man-pages/man3/realpath.3:45
msgid "B<realpath>():"
msgstr "B<realpath>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/realpath.3:51
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* в glibc начиная с 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/realpath.3:73
msgid ""
"B<realpath>()  expands all symbolic links and resolves references to I</./>, "
"I</../> and extra \\(aq/\\(aq characters in the null-terminated string named "
"by I<path> to produce a canonicalized absolute pathname.  The resulting "
"pathname is stored as a null-terminated string, up to a maximum of "
"B<PATH_MAX> bytes, in the buffer pointed to by I<resolved_path>.  The "
"resulting path will have no symbolic link, I</./> or I</../> components."
msgstr ""
"Функция B<realpath>() раскрывает все символьные ссылки, конструкции I</./>, "
"I</../> и дополнительные символы «/» в строке I<path> (завершается null) для "
"создания канонического абсолютного пути. Получившееся имя сохраняется в виде "
"строки (с null на конце) не длиннее чем B<PATH_MAX> байт в буфере, указанном "
"в I<resolved_path>. Конечный путь не содержит символьных ссылок и "
"компонентов I</./> или I</../>."

#.  Even if we use resolved_path == NULL, then realpath() will still
#.  return ENAMETOOLONG if the resolved pathname would exceed PATH_MAX
#.  bytes -- MTK, Dec 04
#.  .SH HISTORY
#.  The
#.  .BR realpath ()
#.  function first appeared in 4.4BSD, contributed by Jan-Simon Pendry.
#. type: Plain text
#: man-pages/man3/realpath.3:93
msgid ""
"If I<resolved_path> is specified as NULL, then B<realpath>()  uses "
"B<malloc>(3)  to allocate a buffer of up to B<PATH_MAX> bytes to hold the "
"resolved pathname, and returns a pointer to this buffer.  The caller should "
"deallocate this buffer using B<free>(3)."
msgstr ""
"Если значение I<resolved_path> равно NULL, то B<realpath>() выделяет буфер "
"размером B<PATH_MAX> байт с помощью B<malloc>(3) для хранения полного пути и "
"возвращает указатель на этот буфер. Вызывающий должен освободить буфер с "
"помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/realpath.3:98
msgid ""
"If there is no error, B<realpath>()  returns a pointer to the "
"I<resolved_path>."
msgstr ""
"При успешном выполнении B<realpath>() возвращает указатель на "
"I<resolved_path>."

#. type: Plain text
#: man-pages/man3/realpath.3:105
msgid ""
"Otherwise, it returns NULL, the contents of the array I<resolved_path> are "
"undefined, and I<errno> is set to indicate the error."
msgstr ""
"При ошибках возвращается NULL, содержимое массива I<resolved_path> не "
"определено и в I<errno> указывается код ошибки."

#. type: Plain text
#: man-pages/man3/realpath.3:109
msgid ""
"Read or search permission was denied for a component of the path prefix."
msgstr "Запрещено чтение или поиск для компонента, содержащегося в пути."

#.  (In libc5 this would just cause a segfault.)
#. type: Plain text
#: man-pages/man3/realpath.3:118
msgid ""
"I<path> is NULL.  (In glibc versions before 2.3, this error is also returned "
"if I<resolved_path> is NULL.)"
msgstr ""
"Значение I<path> равно NULL (в glibc до версии 2.3 эта ошибка также "
"возвращалась и при I<resolved_path> равном NULL)."

#. type: Plain text
#: man-pages/man3/realpath.3:131
msgid ""
"A component of a pathname exceeded B<NAME_MAX> characters, or an entire "
"pathname exceeded B<PATH_MAX> characters."
msgstr ""
"Компонент имени пути более B<NAME_MAX> символов, или весь путь более "
"B<PATH_MAX> символов."

#. type: Plain text
#: man-pages/man3/realpath.3:137
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: tbl table
#: man-pages/man3/realpath.3:150
#, no-wrap
msgid "B<realpath>()"
msgstr "B<realpath>()"

#. type: Plain text
#: man-pages/man3/realpath.3:154
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/realpath.3:159
msgid ""
"POSIX.1-2001 says that the behavior if I<resolved_path> is NULL is "
"implementation-defined.  POSIX.1-2008 specifies the behavior described in "
"this page."
msgstr ""
"В POSIX.1-2001 сказано, что поведение при значении I<resolved_path> равном "
"NULL, зависит от реализации. В POSIX.1-2008 определено поведение, "
"аналогичное описанию на этой странице."

#. type: Plain text
#: man-pages/man3/realpath.3:171
msgid ""
"In 4.4BSD and Solaris, the limit on the pathname length is B<MAXPATHLEN> "
"(found in I<E<lt>sys/param.hE<gt>>).  SUSv2 prescribes B<PATH_MAX> and "
"B<NAME_MAX>, as found in I<E<lt>limits.hE<gt>> or provided by the "
"B<pathconf>(3)  function.  A typical source fragment would be"
msgstr ""
"В 4.4BSD и Solaris максимальная длина пути равна B<MAXPATHLEN> (находится в "
"I<E<lt>sys/param.hE<gt>>). В SUSv2 величины B<PATH_MAX> и B<NAME_MAX> "
"представлены в I<E<lt>limits.hE<gt>> или предоставляются функцией "
"B<pathconf>(3). Вот типичный фрагмент кода:"

#. type: Plain text
#: man-pages/man3/realpath.3:181
#, no-wrap
msgid ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"
msgstr ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"

#. type: Plain text
#: man-pages/man3/realpath.3:185
msgid "(But see the BUGS section.)"
msgstr "(Но смотрите раздел ДЕФЕКТЫ)"

#.      2012-05-05, According to Casper Dik, the statement about
#.      Solaris was not true at least as far back as 1997, and
#.      may never have been true.
#.  The 4.4BSD, Linux and SUSv2 versions always return an absolute
#.  pathname.
#.  Solaris may return a relative pathname when the
#.  .I path
#.  argument is relative.
#.  The prototype of
#.  .BR realpath ()
#.  is given in \fI<unistd.h>\fP in libc4 and libc5,
#.  but in \fI<stdlib.h>\fP everywhere else.
#. type: SS
#: man-pages/man3/realpath.3:199
#, no-wrap
msgid "GNU extensions"
msgstr "Расширения GNU"

#. type: Plain text
#: man-pages/man3/realpath.3:210
msgid ""
"If the call fails with either B<EACCES> or B<ENOENT> and I<resolved_path> is "
"not NULL, then the prefix of I<path> that is not readable or does not exist "
"is returned in I<resolved_path>."
msgstr ""
"Если вызов завершается с ошибкой B<EACCES> или B<ENOENT> и значение "
"I<resolved_path> не равно NULL, то в I<resolved_path> возвращается начало не "
"читаемой или не существующей части I<path>."

#.  .LP
#.  The libc4 and libc5 implementation contained a buffer overflow
#.  (fixed in libc-5.4.13).
#.  Thus, set-user-ID programs like
#.  .BR mount (8)
#.  needed a private version.
#. type: Plain text
#: man-pages/man3/realpath.3:241
msgid ""
"The POSIX.1-2001 standard version of this function is broken by design, "
"since it is impossible to determine a suitable size for the output buffer, "
"I<resolved_path>.  According to POSIX.1-2001 a buffer of size B<PATH_MAX> "
"suffices, but B<PATH_MAX> need not be a defined constant, and may have to be "
"obtained using B<pathconf>(3).  And asking B<pathconf>(3)  does not really "
"help, since, on the one hand POSIX warns that the result of B<pathconf>(3)  "
"may be huge and unsuitable for mallocing memory, and on the other hand "
"B<pathconf>(3)  may return -1 to signify that B<PATH_MAX> is not bounded.  "
"The I<resolved_path\\ ==\\ NULL> feature, not standardized in POSIX.1-2001, "
"but standardized in POSIX.1-2008, allows this design problem to be avoided."
msgstr ""
"Стандартная версия этой функции POSIX.1-2001 некорректна изначально, так как "
"невозможно определить подходящий размер для буфера результата. В "
"соответствии с POSIX.1-2001 буфера размером B<PATH_MAX> должно хватить, но "
"B<PATH_MAX> может не задаваться константой, а получаться через функцию "
"B<pathconf>(3). И запрос B<pathconf>(3) особо не поможет, так как с одной "
"стороны POSIX предупреждает, что результат B<pathconf>(3) может быть слишком "
"велик и не пригоден для выделения памяти. С другой стороны, B<pathconf>(3) "
"может возвратить -1 для обозначения того, что B<PATH_MAX> неограничен. "
"Свойство I<resolved_path\\ ==\\ NULL>, не стандартизованное в POSIX.1-2001, "
"но стандартизованное в POSIX.1-2008, позволяет избежать этой проблемы "
"проектирования."

#. type: Plain text
#: man-pages/man3/realpath.3:247
msgid ""
"B<realpath>(1), B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), "
"B<pathconf>(3), B<sysconf>(3)"
msgstr ""
"B<realpath>(1), B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), "
"B<pathconf>(3), B<sysconf>(3)"
